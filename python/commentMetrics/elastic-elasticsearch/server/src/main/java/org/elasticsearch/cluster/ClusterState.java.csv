commented;modifiers;parameterAmount;loc;comment;code
true;default;0;3;/**  * An optional feature that is required for the client to have.  *  * @return an empty optional if no feature is required otherwise a string representing the required feature  */ ;/**  * An optional feature that is required for the client to have.  *  * @return an empty optional if no feature is required otherwise a string representing the required feature  */ default Optional<String> getRequiredFeature() {     return Optional.empty(). }
true;static;2;11;/**  * Tests whether or not the custom should be serialized. The criteria are:  * <ul>  * <li>the output stream must be at least the minimum supported version of the custom</li>  * <li>the output stream must have the feature required by the custom (if any) or not be a transport client</li>  * </ul>  * <p>  * That is, we only serialize customs to clients than can understand the custom based on the version of the client and the features  * that the client has. For transport clients we can be lenient in requiring a feature in which case we do not send the custom but  * for connected nodes we always require that the node has the required feature.  *  * @param out    the output stream  * @param custom the custom to serialize  * @param <T>    the type of the custom  * @return true if the custom should be serialized and false otherwise  */ ;/**  * Tests whether or not the custom should be serialized. The criteria are:  * <ul>  * <li>the output stream must be at least the minimum supported version of the custom</li>  * <li>the output stream must have the feature required by the custom (if any) or not be a transport client</li>  * </ul>  * <p>  * That is, we only serialize customs to clients than can understand the custom based on the version of the client and the features  * that the client has. For transport clients we can be lenient in requiring a feature in which case we do not send the custom but  * for connected nodes we always require that the node has the required feature.  *  * @param out    the output stream  * @param custom the custom to serialize  * @param <T>    the type of the custom  * @return true if the custom should be serialized and false otherwise  */ static <T extends VersionedNamedWriteable & FeatureAware> boolean shouldSerialize(final StreamOutput out, final T custom) {     if (out.getVersion().before(custom.getMinimalSupportedVersion())) {         return false.     }     if (custom.getRequiredFeature().isPresent()) {         final String requiredFeature = custom.getRequiredFeature().get().         // if it is a transport client we are lenient yet for a connected node it must have the required feature         return out.hasFeature(requiredFeature) || out.hasFeature(TransportClient.TRANSPORT_CLIENT_FEATURE) == false.     }     return true. }
true;default;0;3;/**  * Returns <code>true</code> iff this {@link Custom} is private to the cluster and should never be send to a client.  * The default is <code>false</code>.  */ ;/**  * Returns <code>true</code> iff this {@link Custom} is private to the cluster and should never be send to a client.  * The default is <code>false</code>.  */ default boolean isPrivate() {     return false. }
false;public;0;3;;public long term() {     return coordinationMetaData().term(). }
false;public;0;3;;public long version() {     return this.version. }
false;public;0;3;;public long getVersion() {     return version(). }
false;public;0;5;;public long getVersionOrMetaDataVersion() {     // metadata version to determine the freshest node. However when following a Zen2 master the cluster state version should be used.     return term() == ZEN1_BWC_TERM ? metaData().version() : version(). }
true;public;0;3;/**  * This stateUUID is automatically generated for for each version of cluster state. It is used to make sure that  * we are applying diffs to the right previous state.  */ ;/**  * This stateUUID is automatically generated for for each version of cluster state. It is used to make sure that  * we are applying diffs to the right previous state.  */ public String stateUUID() {     return this.stateUUID. }
false;public;0;3;;public DiscoveryNodes nodes() {     return this.nodes. }
false;public;0;3;;public DiscoveryNodes getNodes() {     return nodes(). }
false;public;0;3;;public MetaData metaData() {     return this.metaData. }
false;public;0;3;;public MetaData getMetaData() {     return metaData(). }
false;public;0;3;;public CoordinationMetaData coordinationMetaData() {     return metaData.coordinationMetaData(). }
false;public;0;3;;public RoutingTable routingTable() {     return routingTable. }
false;public;0;3;;public RoutingTable getRoutingTable() {     return routingTable(). }
false;public;0;3;;public ClusterBlocks blocks() {     return this.blocks. }
false;public;0;3;;public ClusterBlocks getBlocks() {     return blocks. }
false;public;0;3;;public ImmutableOpenMap<String, Custom> customs() {     return this.customs. }
false;public;0;3;;public ImmutableOpenMap<String, Custom> getCustoms() {     return this.customs. }
false;public;1;3;;public <T extends Custom> T custom(String type) {     return (T) customs.get(type). }
false;public;0;3;;public ClusterName getClusterName() {     return this.clusterName. }
false;public;0;3;;public VotingConfiguration getLastAcceptedConfiguration() {     return coordinationMetaData().getLastAcceptedConfiguration(). }
false;public;0;3;;public VotingConfiguration getLastCommittedConfiguration() {     return coordinationMetaData().getLastCommittedConfiguration(). }
false;public;0;3;;public Set<VotingConfigExclusion> getVotingConfigExclusions() {     return coordinationMetaData().getVotingConfigExclusions(). }
true;public;0;3;/**  * The node-level `discovery.zen.minimum_master_nodes` setting on the master node that published this cluster state, for use in rolling  * upgrades from 6.x to 7.x. Once all the 6.x master-eligible nodes have left the cluster, the 7.x nodes use this value to determine how  * many master-eligible nodes must be discovered before the cluster can be bootstrapped. Note that this method returns the node-level  * value of this setting, and ignores any cluster-level override that was set via the API. Callers are expected to combine this value  * with any value set in the cluster-level settings. This should be removed once we no longer need support for {@link Version#V_6_7_0}.  */ ;/**  * The node-level `discovery.zen.minimum_master_nodes` setting on the master node that published this cluster state, for use in rolling  * upgrades from 6.x to 7.x. Once all the 6.x master-eligible nodes have left the cluster, the 7.x nodes use this value to determine how  * many master-eligible nodes must be discovered before the cluster can be bootstrapped. Note that this method returns the node-level  * value of this setting, and ignores any cluster-level override that was set via the API. Callers are expected to combine this value  * with any value set in the cluster-level settings. This should be removed once we no longer need support for {@link Version#V_6_7_0}.  */ public int getMinimumMasterNodesOnPublishingMaster() {     return minimumMasterNodesOnPublishingMaster. }
true;public;0;3;// Used for testing and logging to determine how this cluster state was send over the wire ;// Used for testing and logging to determine how this cluster state was send over the wire public boolean wasReadFromDiff() {     return wasReadFromDiff. }
true;public;0;7;/**  * Returns a built (on demand) routing nodes view of the routing table.  */ ;/**  * Returns a built (on demand) routing nodes view of the routing table.  */ public RoutingNodes getRoutingNodes() {     if (routingNodes != null) {         return routingNodes.     }     routingNodes = new RoutingNodes(this).     return routingNodes. }
false;public;0;52;;@Override public String toString() {     StringBuilder sb = new StringBuilder().     final String TAB = "   ".     sb.append("cluster uuid: ").append(metaData.clusterUUID()).append("\n").     sb.append("version: ").append(version).append("\n").     sb.append("state uuid: ").append(stateUUID).append("\n").     sb.append("from_diff: ").append(wasReadFromDiff).append("\n").     sb.append("meta data version: ").append(metaData.version()).append("\n").     sb.append(TAB).append("coordination_metadata:\n").     sb.append(TAB).append(TAB).append("term: ").append(coordinationMetaData().term()).append("\n").     sb.append(TAB).append(TAB).append("last_committed_config: ").append(coordinationMetaData().getLastCommittedConfiguration()).append("\n").     sb.append(TAB).append(TAB).append("last_accepted_config: ").append(coordinationMetaData().getLastAcceptedConfiguration()).append("\n").     sb.append(TAB).append(TAB).append("voting tombstones: ").append(coordinationMetaData().getVotingConfigExclusions()).append("\n").     for (IndexMetaData indexMetaData : metaData) {         sb.append(TAB).append(indexMetaData.getIndex()).         sb.append(": v[").append(indexMetaData.getVersion()).append("], mv[").append(indexMetaData.getMappingVersion()).append("], sv[").append(indexMetaData.getSettingsVersion()).append("]\n").         for (int shard = 0. shard < indexMetaData.getNumberOfShards(). shard++) {             sb.append(TAB).append(TAB).append(shard).append(": ").             sb.append("p_term [").append(indexMetaData.primaryTerm(shard)).append("], ").             sb.append("isa_ids ").append(indexMetaData.inSyncAllocationIds(shard)).append("\n").         }     }     if (metaData.customs().isEmpty() == false) {         sb.append("metadata customs:\n").         for (final ObjectObjectCursor<String, MetaData.Custom> cursor : metaData.customs()) {             final String type = cursor.key.             final MetaData.Custom custom = cursor.value.             sb.append(TAB).append(type).append(": ").append(custom).         }         sb.append("\n").     }     sb.append(blocks()).     sb.append(nodes()).     sb.append(routingTable()).     sb.append(getRoutingNodes()).     if (customs.isEmpty() == false) {         sb.append("customs:\n").         for (ObjectObjectCursor<String, Custom> cursor : customs) {             final String type = cursor.key.             final Custom custom = cursor.value.             sb.append(TAB).append(type).append(": ").append(custom).         }     }     return sb.toString(). }
true;public;1;5;/**  * a cluster state supersedes another state if they are from the same master and the version of this state is higher than that of the  * other state.  * <p>  * In essence that means that all the changes from the other cluster state are also reflected by the current one  */ ;/**  * a cluster state supersedes another state if they are from the same master and the version of this state is higher than that of the  * other state.  * <p>  * In essence that means that all the changes from the other cluster state are also reflected by the current one  */ public boolean supersedes(ClusterState other) {     return this.nodes().getMasterNodeId() != null && this.nodes().getMasterNodeId().equals(other.nodes().getMasterNodeId()) && this.version() > other.version(). }
false;public,static;2;19;;public static EnumSet<Metric> parseString(String param, boolean ignoreUnknown) {     String[] metrics = Strings.splitStringByCommaToArray(param).     EnumSet<Metric> result = EnumSet.noneOf(Metric.class).     for (String metric : metrics) {         if ("_all".equals(metric)) {             result = EnumSet.allOf(Metric.class).             break.         }         Metric m = valueToEnum.get(metric).         if (m == null) {             if (!ignoreUnknown) {                 throw new IllegalArgumentException("Unknown metric [" + metric + "]").             }         } else {             result.add(m).         }     }     return result. }
false;public;0;4;;@Override public String toString() {     return value. }
false;public;2;202;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     EnumSet<Metric> metrics = Metric.parseString(params.param("metric", "_all"), true).     // always provide the cluster_uuid as part of the top-level response (also part of the metadata response)     builder.field("cluster_uuid", metaData().clusterUUID()).     if (metrics.contains(Metric.VERSION)) {         builder.field("version", version).         builder.field("state_uuid", stateUUID).     }     if (metrics.contains(Metric.MASTER_NODE)) {         builder.field("master_node", nodes().getMasterNodeId()).     }     if (metrics.contains(Metric.BLOCKS)) {         builder.startObject("blocks").         if (!blocks().global().isEmpty()) {             builder.startObject("global").             for (ClusterBlock block : blocks().global()) {                 block.toXContent(builder, params).             }             builder.endObject().         }         if (!blocks().indices().isEmpty()) {             builder.startObject("indices").             for (ObjectObjectCursor<String, Set<ClusterBlock>> entry : blocks().indices()) {                 builder.startObject(entry.key).                 for (ClusterBlock block : entry.value) {                     block.toXContent(builder, params).                 }                 builder.endObject().             }             builder.endObject().         }         builder.endObject().     }     // nodes     if (metrics.contains(Metric.NODES)) {         builder.startObject("nodes").         for (DiscoveryNode node : nodes) {             node.toXContent(builder, params).         }         builder.endObject().     }     // meta data     if (metrics.contains(Metric.METADATA)) {         builder.startObject("metadata").         builder.field("cluster_uuid", metaData().clusterUUID()).         builder.startObject("cluster_coordination").         coordinationMetaData().toXContent(builder, params).         builder.endObject().         builder.startObject("templates").         for (ObjectCursor<IndexTemplateMetaData> cursor : metaData().templates().values()) {             IndexTemplateMetaData templateMetaData = cursor.value.             builder.startObject(templateMetaData.name()).             builder.field("index_patterns", templateMetaData.patterns()).             builder.field("order", templateMetaData.order()).             builder.startObject("settings").             Settings settings = templateMetaData.settings().             settings.toXContent(builder, params).             builder.endObject().             builder.startObject("mappings").             for (ObjectObjectCursor<String, CompressedXContent> cursor1 : templateMetaData.mappings()) {                 Map<String, Object> mapping = XContentHelper.convertToMap(new BytesArray(cursor1.value.uncompressed()), false).v2().                 if (mapping.size() == 1 && mapping.containsKey(cursor1.key)) {                     // the type name is the root value, reduce it                     mapping = (Map<String, Object>) mapping.get(cursor1.key).                 }                 builder.field(cursor1.key).                 builder.map(mapping).             }             builder.endObject().             builder.endObject().         }         builder.endObject().         builder.startObject("indices").         for (IndexMetaData indexMetaData : metaData()) {             builder.startObject(indexMetaData.getIndex().getName()).             builder.field("state", indexMetaData.getState().toString().toLowerCase(Locale.ENGLISH)).             builder.startObject("settings").             Settings settings = indexMetaData.getSettings().             settings.toXContent(builder, params).             builder.endObject().             builder.startObject("mappings").             for (ObjectObjectCursor<String, MappingMetaData> cursor : indexMetaData.getMappings()) {                 Map<String, Object> mapping = XContentHelper.convertToMap(new BytesArray(cursor.value.source().uncompressed()), false).v2().                 if (mapping.size() == 1 && mapping.containsKey(cursor.key)) {                     // the type name is the root value, reduce it                     mapping = (Map<String, Object>) mapping.get(cursor.key).                 }                 builder.field(cursor.key).                 builder.map(mapping).             }             builder.endObject().             builder.startArray("aliases").             for (ObjectCursor<String> cursor : indexMetaData.getAliases().keys()) {                 builder.value(cursor.value).             }             builder.endArray().             builder.startObject(IndexMetaData.KEY_PRIMARY_TERMS).             for (int shard = 0. shard < indexMetaData.getNumberOfShards(). shard++) {                 builder.field(Integer.toString(shard), indexMetaData.primaryTerm(shard)).             }             builder.endObject().             builder.startObject(IndexMetaData.KEY_IN_SYNC_ALLOCATIONS).             for (IntObjectCursor<Set<String>> cursor : indexMetaData.getInSyncAllocationIds()) {                 builder.startArray(String.valueOf(cursor.key)).                 for (String allocationId : cursor.value) {                     builder.value(allocationId).                 }                 builder.endArray().             }             builder.endObject().             // index metadata             builder.endObject().         }         builder.endObject().         for (ObjectObjectCursor<String, MetaData.Custom> cursor : metaData.customs()) {             builder.startObject(cursor.key).             cursor.value.toXContent(builder, params).             builder.endObject().         }         builder.endObject().     }     // routing table     if (metrics.contains(Metric.ROUTING_TABLE)) {         builder.startObject("routing_table").         builder.startObject("indices").         for (IndexRoutingTable indexRoutingTable : routingTable()) {             builder.startObject(indexRoutingTable.getIndex().getName()).             builder.startObject("shards").             for (IndexShardRoutingTable indexShardRoutingTable : indexRoutingTable) {                 builder.startArray(Integer.toString(indexShardRoutingTable.shardId().id())).                 for (ShardRouting shardRouting : indexShardRoutingTable) {                     shardRouting.toXContent(builder, params).                 }                 builder.endArray().             }             builder.endObject().             builder.endObject().         }         builder.endObject().         builder.endObject().     }     // routing nodes     if (metrics.contains(Metric.ROUTING_NODES)) {         builder.startObject("routing_nodes").         builder.startArray("unassigned").         for (ShardRouting shardRouting : getRoutingNodes().unassigned()) {             shardRouting.toXContent(builder, params).         }         builder.endArray().         builder.startObject("nodes").         for (RoutingNode routingNode : getRoutingNodes()) {             builder.startArray(routingNode.nodeId() == null ? "null" : routingNode.nodeId()).             for (ShardRouting shardRouting : routingNode) {                 shardRouting.toXContent(builder, params).             }             builder.endArray().         }         builder.endObject().         builder.endObject().     }     if (metrics.contains(Metric.CUSTOMS)) {         for (ObjectObjectCursor<String, Custom> cursor : customs) {             builder.startObject(cursor.key).             cursor.value.toXContent(builder, params).             builder.endObject().         }     }     return builder. }
false;public,static;1;3;;public static Builder builder(ClusterName clusterName) {     return new Builder(clusterName). }
false;public,static;1;3;;public static Builder builder(ClusterState state) {     return new Builder(state). }
false;public;1;3;;public Builder nodes(DiscoveryNodes.Builder nodesBuilder) {     return nodes(nodesBuilder.build()). }
false;public;1;4;;public Builder nodes(DiscoveryNodes nodes) {     this.nodes = nodes.     return this. }
false;public;0;3;;public DiscoveryNodes nodes() {     return nodes. }
false;public;1;4;;public Builder routingTable(RoutingTable routingTable) {     this.routingTable = routingTable.     return this. }
false;public;1;3;;public Builder metaData(MetaData.Builder metaDataBuilder) {     return metaData(metaDataBuilder.build()). }
false;public;1;4;;public Builder metaData(MetaData metaData) {     this.metaData = metaData.     return this. }
false;public;1;3;;public Builder blocks(ClusterBlocks.Builder blocksBuilder) {     return blocks(blocksBuilder.build()). }
false;public;1;4;;public Builder blocks(ClusterBlocks blocks) {     this.blocks = blocks.     return this. }
false;public;1;4;;public Builder version(long version) {     this.version = version.     return this. }
false;public;0;5;;public Builder incrementVersion() {     this.version = version + 1.     this.uuid = UNKNOWN_UUID.     return this. }
false;public;1;4;;public Builder stateUUID(String uuid) {     this.uuid = uuid.     return this. }
false;public;1;4;;public Builder minimumMasterNodesOnPublishingMaster(int minimumMasterNodesOnPublishingMaster) {     this.minimumMasterNodesOnPublishingMaster = minimumMasterNodesOnPublishingMaster.     return this. }
false;public;2;4;;public Builder putCustom(String type, Custom custom) {     customs.put(type, custom).     return this. }
false;public;1;4;;public Builder removeCustom(String type) {     customs.remove(type).     return this. }
false;public;1;4;;public Builder customs(ImmutableOpenMap<String, Custom> customs) {     this.customs.putAll(customs).     return this. }
false;public;1;4;;public Builder fromDiff(boolean fromDiff) {     this.fromDiff = fromDiff.     return this. }
false;public;0;7;;public ClusterState build() {     if (UNKNOWN_UUID.equals(uuid)) {         uuid = UUIDs.randomBase64UUID().     }     return new ClusterState(clusterName, version, uuid, metaData, routingTable, nodes, blocks, customs.build(), minimumMasterNodesOnPublishingMaster, fromDiff). }
false;public,static;1;5;;public static byte[] toBytes(ClusterState state) throws IOException {     BytesStreamOutput os = new BytesStreamOutput().     state.writeTo(os).     return BytesReference.toBytes(os.bytes()). }
true;public,static;3;5;/**  * @param data      input bytes  * @param localNode used to set the local node in the cluster state.  */ ;/**  * @param data      input bytes  * @param localNode used to set the local node in the cluster state.  */ public static ClusterState fromBytes(byte[] data, DiscoveryNode localNode, NamedWriteableRegistry registry) throws IOException {     StreamInput in = new NamedWriteableAwareStreamInput(StreamInput.wrap(data), registry).     return readFrom(in, localNode). }
false;public;1;4;;@Override public Diff<ClusterState> diff(ClusterState previousState) {     return new ClusterStateDiff(previousState, this). }
false;public,static;2;3;;public static Diff<ClusterState> readDiffFrom(StreamInput in, DiscoveryNode localNode) throws IOException {     return new ClusterStateDiff(in, localNode). }
false;public,static;2;17;;public static ClusterState readFrom(StreamInput in, DiscoveryNode localNode) throws IOException {     ClusterName clusterName = new ClusterName(in).     Builder builder = new Builder(clusterName).     builder.version = in.readLong().     builder.uuid = in.readString().     builder.metaData = MetaData.readFrom(in).     builder.routingTable = RoutingTable.readFrom(in).     builder.nodes = DiscoveryNodes.readFrom(in, localNode).     builder.blocks = new ClusterBlocks(in).     int customSize = in.readVInt().     for (int i = 0. i < customSize. i++) {         Custom customIndexMetaData = in.readNamedWriteable(Custom.class).         builder.putCustom(customIndexMetaData.getWriteableName(), customIndexMetaData).     }     builder.minimumMasterNodesOnPublishingMaster = in.getVersion().onOrAfter(Version.V_6_7_0) ? in.readVInt() : -1.     return builder.build(). }
false;public;1;26;;@Override public void writeTo(StreamOutput out) throws IOException {     clusterName.writeTo(out).     out.writeLong(version).     out.writeString(stateUUID).     metaData.writeTo(out).     routingTable.writeTo(out).     nodes.writeTo(out).     blocks.writeTo(out).     // filter out custom states not supported by the other node     int numberOfCustoms = 0.     for (final ObjectCursor<Custom> cursor : customs.values()) {         if (FeatureAware.shouldSerialize(out, cursor.value)) {             numberOfCustoms++.         }     }     out.writeVInt(numberOfCustoms).     for (final ObjectCursor<Custom> cursor : customs.values()) {         if (FeatureAware.shouldSerialize(out, cursor.value)) {             out.writeNamedWriteable(cursor.value).         }     }     if (out.getVersion().onOrAfter(Version.V_6_7_0)) {         out.writeVInt(minimumMasterNodesOnPublishingMaster).     } }
false;public;1;15;;@Override public void writeTo(StreamOutput out) throws IOException {     clusterName.writeTo(out).     out.writeString(fromUuid).     out.writeString(toUuid).     out.writeLong(toVersion).     routingTable.writeTo(out).     nodes.writeTo(out).     metaData.writeTo(out).     blocks.writeTo(out).     customs.writeTo(out).     if (out.getVersion().onOrAfter(Version.V_6_7_0)) {         out.writeVInt(minimumMasterNodesOnPublishingMaster).     } }
false;public;1;21;;@Override public ClusterState apply(ClusterState state) {     Builder builder = new Builder(clusterName).     if (toUuid.equals(state.stateUUID)) {         // no need to read the rest - cluster state didn't change         return state.     }     if (fromUuid.equals(state.stateUUID) == false) {         throw new IncompatibleClusterStateVersionException(state.version, state.stateUUID, toVersion, fromUuid).     }     builder.stateUUID(toUuid).     builder.version(toVersion).     builder.routingTable(routingTable.apply(state.routingTable)).     builder.nodes(nodes.apply(state.nodes)).     builder.metaData(metaData.apply(state.metaData)).     builder.blocks(blocks.apply(state.blocks)).     builder.customs(customs.apply(state.customs)).     builder.minimumMasterNodesOnPublishingMaster(minimumMasterNodesOnPublishingMaster).     builder.fromDiff(true).     return builder.build(). }
