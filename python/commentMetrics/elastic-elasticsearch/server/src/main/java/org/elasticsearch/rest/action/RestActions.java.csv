commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;10;;public static long parseVersion(RestRequest request) {     if (request.hasParam("version")) {         return request.paramAsLong("version", Versions.MATCH_ANY).     }     String ifMatch = request.header("If-Match").     if (ifMatch != null) {         return Long.parseLong(ifMatch).     }     return Versions.MATCH_ANY. }
false;public,static;2;4;;public static long parseVersion(RestRequest request, long defaultVersion) {     long version = parseVersion(request).     return (version == Versions.MATCH_ANY) ? defaultVersion : version. }
false;public,static;3;5;;public static void buildBroadcastShardsHeader(XContentBuilder builder, Params params, BroadcastResponse response) throws IOException {     buildBroadcastShardsHeader(builder, params, response.getTotalShards(), response.getSuccessfulShards(), -1, response.getFailedShards(), response.getShardFailures()). }
false;public,static;7;21;;public static void buildBroadcastShardsHeader(XContentBuilder builder, Params params, int total, int successful, int skipped, int failed, ShardOperationFailedException[] shardFailures) throws IOException {     builder.startObject(_SHARDS_FIELD.getPreferredName()).     builder.field(TOTAL_FIELD.getPreferredName(), total).     builder.field(SUCCESSFUL_FIELD.getPreferredName(), successful).     if (skipped >= 0) {         builder.field(SKIPPED_FIELD.getPreferredName(), skipped).     }     builder.field(FAILED_FIELD.getPreferredName(), failed).     if (shardFailures != null && shardFailures.length > 0) {         builder.startArray(FAILURES_FIELD.getPreferredName()).         for (ShardOperationFailedException shardFailure : ExceptionsHelper.groupBy(shardFailures)) {             builder.startObject().             shardFailure.toXContent(builder, params).             builder.endObject().         }         builder.endArray().     }     builder.endObject(). }
true;public,static;3;8;/**  * Create the XContent header for any {@link BaseNodesResponse}.  *  * @param builder XContent builder.  * @param params XContent parameters.  * @param response The response containing individual, node-level responses.  * @see #buildNodesHeader(XContentBuilder, Params, int, int, int, List)  */ ;/**  * Create the XContent header for any {@link BaseNodesResponse}.  *  * @param builder XContent builder.  * @param params XContent parameters.  * @param response The response containing individual, node-level responses.  * @see #buildNodesHeader(XContentBuilder, Params, int, int, int, List)  */ public static <NodeResponse extends BaseNodeResponse> void buildNodesHeader(final XContentBuilder builder, final Params params, final BaseNodesResponse<NodeResponse> response) throws IOException {     final int successful = response.getNodes().size().     final int failed = response.failures().size().     buildNodesHeader(builder, params, successful + failed, successful, failed, response.failures()). }
true;public,static;6;20;/**  * Create the XContent header for any {@link BaseNodesResponse}. This looks like:  * <code>  * "_nodes" : {  *   "total" : 3,  *   "successful" : 1,  *   "failed" : 2,  *   "failures" : [ { ... }, { ... } ]  * }  * </code>  * Prefer the overload that properly invokes this method to calling this directly.  *  * @param builder XContent builder.  * @param params XContent parameters.  * @param total The total number of nodes touched.  * @param successful The successful number of responses received.  * @param failed The number of failures (effectively {@code total - successful}).  * @param failures The failure exceptions related to {@code failed}.  * @see #buildNodesHeader(XContentBuilder, Params, BaseNodesResponse)  */ ;/**  * Create the XContent header for any {@link BaseNodesResponse}. This looks like:  * <code>  * "_nodes" : {  *   "total" : 3,  *   "successful" : 1,  *   "failed" : 2,  *   "failures" : [ { ... }, { ... } ]  * }  * </code>  * Prefer the overload that properly invokes this method to calling this directly.  *  * @param builder XContent builder.  * @param params XContent parameters.  * @param total The total number of nodes touched.  * @param successful The successful number of responses received.  * @param failed The number of failures (effectively {@code total - successful}).  * @param failures The failure exceptions related to {@code failed}.  * @see #buildNodesHeader(XContentBuilder, Params, BaseNodesResponse)  */ public static void buildNodesHeader(final XContentBuilder builder, final Params params, final int total, final int successful, final int failed, final List<FailedNodeException> failures) throws IOException {     builder.startObject("_nodes").     builder.field("total", total).     builder.field("successful", successful).     builder.field("failed", failed).     if (failures.isEmpty() == false) {         builder.startArray("failures").         for (FailedNodeException failure : failures) {             builder.startObject().             failure.toXContent(builder, params).             builder.endObject().         }         builder.endArray().     }     builder.endObject(). }
true;public,static;3;12;/**  * Automatically transform the {@link ToXContent}-compatible, nodes-level {@code response} into a a {@link BytesRestResponse}.  * <p>  * This looks like:  * <code>  * {  *   "_nodes" : { ... },  *   "cluster_name" : "...",  *   ...  * }  * </code>  *  * @param builder XContent builder.  * @param params XContent parameters.  * @param response The nodes-level (plural) response.  * @return Never {@code null}.  * @throws IOException if building the response causes an issue  */ ;/**  * Automatically transform the {@link ToXContent}-compatible, nodes-level {@code response} into a a {@link BytesRestResponse}.  * <p>  * This looks like:  * <code>  * {  *   "_nodes" : { ... },  *   "cluster_name" : "...",  *   ...  * }  * </code>  *  * @param builder XContent builder.  * @param params XContent parameters.  * @param response The nodes-level (plural) response.  * @return Never {@code null}.  * @throws IOException if building the response causes an issue  */ public static <NodesResponse extends BaseNodesResponse & ToXContent> BytesRestResponse nodesResponse(final XContentBuilder builder, final Params params, final NodesResponse response) throws IOException {     builder.startObject().     RestActions.buildNodesHeader(builder, params, response).     builder.field("cluster_name", response.getClusterName().value()).     response.toXContent(builder, params).     builder.endObject().     return new BytesRestResponse(RestStatus.OK, builder). }
false;public,static;1;16;;public static QueryBuilder urlParamsToQueryBuilder(RestRequest request) {     String queryString = request.param("q").     if (queryString == null) {         return null.     }     QueryStringQueryBuilder queryBuilder = QueryBuilders.queryStringQuery(queryString).     queryBuilder.defaultField(request.param("df")).     queryBuilder.analyzer(request.param("analyzer")).     queryBuilder.analyzeWildcard(request.paramAsBoolean("analyze_wildcard", false)).     queryBuilder.lenient(request.paramAsBoolean("lenient", null)).     String defaultOperator = request.param("default_operator").     if (defaultOperator != null) {         queryBuilder.defaultOperator(Operator.fromString(defaultOperator)).     }     return queryBuilder. }
false;public,static;1;3;;public static QueryBuilder getQueryContent(XContentParser requestParser) {     return parseTopLevelQueryBuilder(requestParser). }
false;public;2;4;;@Override public RestResponse buildResponse(NodesResponse response, XContentBuilder builder) throws Exception {     return RestActions.nodesResponse(builder, channel.request(), response). }
true;private,static;1;29;/**  * Parses a top level query including the query element that wraps it  */ ;/**  * Parses a top level query including the query element that wraps it  */ private static QueryBuilder parseTopLevelQueryBuilder(XContentParser parser) {     try {         QueryBuilder queryBuilder = null.         XContentParser.Token first = parser.nextToken().         if (first == null) {             return null.         } else if (first != XContentParser.Token.START_OBJECT) {             throw new ParsingException(parser.getTokenLocation(), "Expected [" + XContentParser.Token.START_OBJECT + "] but found [" + first + "]", parser.getTokenLocation()).         }         for (XContentParser.Token token = parser.nextToken(). token != XContentParser.Token.END_OBJECT. token = parser.nextToken()) {             if (token == XContentParser.Token.FIELD_NAME) {                 String fieldName = parser.currentName().                 if ("query".equals(fieldName)) {                     queryBuilder = parseInnerQueryBuilder(parser).                 } else {                     throw new ParsingException(parser.getTokenLocation(), "request does not support [" + parser.currentName() + "]").                 }             }         }         return queryBuilder.     } catch (ParsingException e) {         throw e.     } catch (Exception e) {         throw new ParsingException(parser == null ? null : parser.getTokenLocation(), "Failed to parse", e).     } }
