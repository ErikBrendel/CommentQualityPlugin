commented;modifiers;parameterAmount;loc;comment;code
false;private;0;9;;@Nullable private ShardRouting initializeTargetRelocatingShard() {     if (state == ShardRoutingState.RELOCATING) {         return new ShardRouting(shardId, relocatingNodeId, currentNodeId, primary, ShardRoutingState.INITIALIZING, PeerRecoverySource.INSTANCE, unassignedInfo, AllocationId.newTargetRelocation(allocationId), expectedShardSize).     } else {         return null.     } }
true;public,static;4;5;/**  * Creates a new unassigned shard.  */ ;/**  * Creates a new unassigned shard.  */ public static ShardRouting newUnassigned(ShardId shardId, boolean primary, RecoverySource recoverySource, UnassignedInfo unassignedInfo) {     return new ShardRouting(shardId, null, null, primary, ShardRoutingState.UNASSIGNED, recoverySource, unassignedInfo, null, UNAVAILABLE_EXPECTED_SHARD_SIZE). }
false;public;0;3;;public Index index() {     return shardId.getIndex(). }
true;public;0;3;/**  * The index name.  */ ;/**  * The index name.  */ public String getIndexName() {     return shardId.getIndexName(). }
true;public;0;3;/**  * The shard id.  */ ;/**  * The shard id.  */ public int id() {     return shardId.id(). }
true;public;0;3;/**  * The shard id.  */ ;/**  * The shard id.  */ public int getId() {     return id(). }
true;public;0;3;/**  * The shard is unassigned (not allocated to any node).  */ ;/**  * The shard is unassigned (not allocated to any node).  */ public boolean unassigned() {     return state == ShardRoutingState.UNASSIGNED. }
true;public;0;3;/**  * The shard is initializing (usually recovering either from peer shard  * or from gateway).  */ ;/**  * The shard is initializing (usually recovering either from peer shard  * or from gateway).  */ public boolean initializing() {     return state == ShardRoutingState.INITIALIZING. }
true;public;0;3;/**  * Returns <code>true</code> iff the this shard is currently  * {@link ShardRoutingState#STARTED started} or  * {@link ShardRoutingState#RELOCATING relocating} to another node.  * Otherwise <code>false</code>  */ ;/**  * Returns <code>true</code> iff the this shard is currently  * {@link ShardRoutingState#STARTED started} or  * {@link ShardRoutingState#RELOCATING relocating} to another node.  * Otherwise <code>false</code>  */ public boolean active() {     return started() || relocating(). }
true;public;0;3;/**  * The shard is in started mode.  */ ;/**  * The shard is in started mode.  */ public boolean started() {     return state == ShardRoutingState.STARTED. }
true;public;0;3;/**  * Returns <code>true</code> iff the this shard is currently relocating to  * another node. Otherwise <code>false</code>  *  * @see ShardRoutingState#RELOCATING  */ ;/**  * Returns <code>true</code> iff the this shard is currently relocating to  * another node. Otherwise <code>false</code>  *  * @see ShardRoutingState#RELOCATING  */ public boolean relocating() {     return state == ShardRoutingState.RELOCATING. }
true;public;0;3;/**  * Returns <code>true</code> iff this shard is assigned to a node ie. not  * {@link ShardRoutingState#UNASSIGNED unassigned}. Otherwise <code>false</code>  */ ;/**  * Returns <code>true</code> iff this shard is assigned to a node ie. not  * {@link ShardRoutingState#UNASSIGNED unassigned}. Otherwise <code>false</code>  */ public boolean assignedToNode() {     return currentNodeId != null. }
true;public;0;3;/**  * The current node id the shard is allocated on.  */ ;/**  * The current node id the shard is allocated on.  */ public String currentNodeId() {     return this.currentNodeId. }
true;public;0;3;/**  * The relocating node id the shard is either relocating to or relocating from.  */ ;/**  * The relocating node id the shard is either relocating to or relocating from.  */ public String relocatingNodeId() {     return this.relocatingNodeId. }
true;public;0;4;/**  * Returns a shard routing representing the target shard.  * The target shard routing will be the INITIALIZING state and have relocatingNodeId set to the  * source node.  */ ;/**  * Returns a shard routing representing the target shard.  * The target shard routing will be the INITIALIZING state and have relocatingNodeId set to the  * source node.  */ public ShardRouting getTargetRelocatingShard() {     assert relocating().     return targetRelocatingShard. }
true;public;0;4;/**  * Additional metadata on why the shard is/was unassigned. The metadata is kept around  * until the shard moves to STARTED.  */ ;/**  * Additional metadata on why the shard is/was unassigned. The metadata is kept around  * until the shard moves to STARTED.  */ @Nullable public UnassignedInfo unassignedInfo() {     return unassignedInfo. }
true;public;0;4;/**  * An id that uniquely identifies an allocation.  */ ;/**  * An id that uniquely identifies an allocation.  */ @Nullable public AllocationId allocationId() {     return this.allocationId. }
true;public;0;3;/**  * Returns <code>true</code> iff this shard is a primary.  */ ;/**  * Returns <code>true</code> iff this shard is a primary.  */ public boolean primary() {     return this.primary. }
true;public;0;3;/**  * The shard state.  */ ;/**  * The shard state.  */ public ShardRoutingState state() {     return this.state. }
true;public;0;3;/**  * The shard id.  */ ;/**  * The shard id.  */ public ShardId shardId() {     return shardId. }
true;public;0;3;/**  * A shard iterator with just this shard in it.  */ ;/**  * A shard iterator with just this shard in it.  */ public ShardIterator shardsIt() {     return new PlainShardIterator(shardId, asList). }
true;public;1;14;/**  * Writes shard information to {@link StreamOutput} without writing index name and shard id  *  * @param out {@link StreamOutput} to write shard information to  * @throws IOException if something happens during write  */ ;/**  * Writes shard information to {@link StreamOutput} without writing index name and shard id  *  * @param out {@link StreamOutput} to write shard information to  * @throws IOException if something happens during write  */ public void writeToThin(StreamOutput out) throws IOException {     out.writeOptionalString(currentNodeId).     out.writeOptionalString(relocatingNodeId).     out.writeBoolean(primary).     out.writeByte(state.value()).     if (state == ShardRoutingState.UNASSIGNED || state == ShardRoutingState.INITIALIZING) {         recoverySource.writeTo(out).     }     out.writeOptionalWriteable(unassignedInfo).     out.writeOptionalWriteable(allocationId).     if (state == ShardRoutingState.RELOCATING || state == ShardRoutingState.INITIALIZING) {         out.writeLong(expectedShardSize).     } }
false;public;1;5;;@Override public void writeTo(StreamOutput out) throws IOException {     shardId.writeTo(out).     writeToThin(out). }
false;public;2;6;;public ShardRouting updateUnassigned(UnassignedInfo unassignedInfo, RecoverySource recoverySource) {     assert this.unassignedInfo != null : "can only update unassign info if they are already set".     assert this.unassignedInfo.isDelayed() || (unassignedInfo.isDelayed() == false) : "cannot transition from non-delayed to delayed".     return new ShardRouting(shardId, currentNodeId, relocatingNodeId, primary, state, recoverySource, unassignedInfo, allocationId, expectedShardSize). }
true;public;1;15;/**  * Moves the shard to unassigned state.  */ ;/**  * Moves the shard to unassigned state.  */ public ShardRouting moveToUnassigned(UnassignedInfo unassignedInfo) {     assert state != ShardRoutingState.UNASSIGNED : this.     final RecoverySource recoverySource.     if (active()) {         if (primary()) {             recoverySource = ExistingStoreRecoverySource.INSTANCE.         } else {             recoverySource = PeerRecoverySource.INSTANCE.         }     } else {         recoverySource = recoverySource().     }     return new ShardRouting(shardId, null, null, primary, ShardRoutingState.UNASSIGNED, recoverySource, unassignedInfo, null, UNAVAILABLE_EXPECTED_SHARD_SIZE). }
true;public;3;12;/**  * Initializes an unassigned shard on a node.  *  * @param existingAllocationId allocation id to use. If null, a fresh allocation id is generated.  */ ;/**  * Initializes an unassigned shard on a node.  *  * @param existingAllocationId allocation id to use. If null, a fresh allocation id is generated.  */ public ShardRouting initialize(String nodeId, @Nullable String existingAllocationId, long expectedShardSize) {     assert state == ShardRoutingState.UNASSIGNED : this.     assert relocatingNodeId == null : this.     final AllocationId allocationId.     if (existingAllocationId == null) {         allocationId = AllocationId.newInitializing().     } else {         allocationId = AllocationId.newInitializing(existingAllocationId).     }     return new ShardRouting(shardId, nodeId, null, primary, ShardRoutingState.INITIALIZING, recoverySource, unassignedInfo, allocationId, expectedShardSize). }
true;public;2;5;/**  * Relocate the shard to another node.  *  * @param relocatingNodeId id of the node to relocate the shard  */ ;/**  * Relocate the shard to another node.  *  * @param relocatingNodeId id of the node to relocate the shard  */ public ShardRouting relocate(String relocatingNodeId, long expectedShardSize) {     assert state == ShardRoutingState.STARTED : "current shard has to be started in order to be relocated " + this.     return new ShardRouting(shardId, currentNodeId, relocatingNodeId, primary, ShardRoutingState.RELOCATING, recoverySource, null, AllocationId.newRelocation(allocationId), expectedShardSize). }
true;public;0;7;/**  * Cancel relocation of a shard. The shards state must be set  * to <code>RELOCATING</code>.  */ ;/**  * Cancel relocation of a shard. The shards state must be set  * to <code>RELOCATING</code>.  */ public ShardRouting cancelRelocation() {     assert state == ShardRoutingState.RELOCATING : this.     assert assignedToNode() : this.     assert relocatingNodeId != null : this.     return new ShardRouting(shardId, currentNodeId, null, primary, ShardRoutingState.STARTED, recoverySource, null, AllocationId.cancelRelocation(allocationId), UNAVAILABLE_EXPECTED_SHARD_SIZE). }
true;public;0;8;/**  * Removes relocation source of a non-primary shard. The shard state must be <code>INITIALIZING</code>.  * This allows the non-primary shard to continue recovery from the primary even though its non-primary  * relocation source has failed.  */ ;/**  * Removes relocation source of a non-primary shard. The shard state must be <code>INITIALIZING</code>.  * This allows the non-primary shard to continue recovery from the primary even though its non-primary  * relocation source has failed.  */ public ShardRouting removeRelocationSource() {     assert primary == false : this.     assert state == ShardRoutingState.INITIALIZING : this.     assert assignedToNode() : this.     assert relocatingNodeId != null : this.     return new ShardRouting(shardId, currentNodeId, null, primary, state, recoverySource, unassignedInfo, AllocationId.finishRelocation(allocationId), expectedShardSize). }
true;public;0;7;/**  * Reinitializes a replica shard, giving it a fresh allocation id  */ ;/**  * Reinitializes a replica shard, giving it a fresh allocation id  */ public ShardRouting reinitializeReplicaShard() {     assert state == ShardRoutingState.INITIALIZING : this.     assert primary == false : this.     assert isRelocationTarget() == false : this.     return new ShardRouting(shardId, currentNodeId, null, primary, ShardRoutingState.INITIALIZING, recoverySource, unassignedInfo, AllocationId.newInitializing(), expectedShardSize). }
true;public;0;10;/**  * Set the shards state to <code>STARTED</code>. The shards state must be  * <code>INITIALIZING</code> or <code>RELOCATING</code>. Any relocation will be  * canceled.  */ ;/**  * Set the shards state to <code>STARTED</code>. The shards state must be  * <code>INITIALIZING</code> or <code>RELOCATING</code>. Any relocation will be  * canceled.  */ public ShardRouting moveToStarted() {     assert state == ShardRoutingState.INITIALIZING : "expected an initializing shard " + this.     AllocationId allocationId = this.allocationId.     if (allocationId.getRelocationId() != null) {         // relocation target         allocationId = AllocationId.finishRelocation(allocationId).     }     return new ShardRouting(shardId, currentNodeId, null, primary, ShardRoutingState.STARTED, null, null, allocationId, UNAVAILABLE_EXPECTED_SHARD_SIZE). }
true;public;0;8;/**  * Make the active shard primary unless it's not primary  *  * @throws IllegalShardRoutingStateException if shard is already a primary  */ ;/**  * Make the active shard primary unless it's not primary  *  * @throws IllegalShardRoutingStateException if shard is already a primary  */ public ShardRouting moveActiveReplicaToPrimary() {     assert active() : "expected an active shard " + this.     if (primary) {         throw new IllegalShardRoutingStateException(this, "Already primary, can't move to primary").     }     return new ShardRouting(shardId, currentNodeId, relocatingNodeId, true, state, recoverySource, unassignedInfo, allocationId, expectedShardSize). }
true;public;0;8;/**  * Set the unassigned primary shard to non-primary  *  * @throws IllegalShardRoutingStateException if shard is already a replica  */ ;/**  * Set the unassigned primary shard to non-primary  *  * @throws IllegalShardRoutingStateException if shard is already a replica  */ public ShardRouting moveUnassignedFromPrimary() {     assert state == ShardRoutingState.UNASSIGNED : "expected an unassigned shard " + this.     if (!primary) {         throw new IllegalShardRoutingStateException(this, "Not primary, can't move to replica").     }     return new ShardRouting(shardId, currentNodeId, relocatingNodeId, false, state, PeerRecoverySource.INSTANCE, unassignedInfo, allocationId, expectedShardSize). }
true;public;1;6;/**  * returns true if this routing has the same allocation ID as another.  * <p>  * Note: if both shard routing has a null as their {@link #allocationId()}, this method returns false as the routing describe  * no allocation at all..  */ ;/**  * returns true if this routing has the same allocation ID as another.  * <p>  * Note: if both shard routing has a null as their {@link #allocationId()}, this method returns false as the routing describe  * no allocation at all..  */ public boolean isSameAllocation(ShardRouting other) {     boolean b = this.allocationId != null && other.allocationId != null && this.allocationId.getId().equals(other.allocationId.getId()).     assert b == false || this.currentNodeId.equals(other.currentNodeId) : "ShardRoutings have the same allocation id but not the same node. This [" + this + "], other [" + other + "]".     return b. }
true;public;0;3;/**  * Returns <code>true</code> if this shard is a relocation target for another shard  * (i.e., was created with {@link #initializeTargetRelocatingShard()}  */ ;/**  * Returns <code>true</code> if this shard is a relocation target for another shard  * (i.e., was created with {@link #initializeTargetRelocatingShard()}  */ public boolean isRelocationTarget() {     return state == ShardRoutingState.INITIALIZING && relocatingNodeId != null. }
true;public;1;29;/**  * returns true if the routing is the relocation target of the given routing  */ ;/**  * returns true if the routing is the relocation target of the given routing  */ public boolean isRelocationTargetOf(ShardRouting other) {     boolean b = this.allocationId != null && other.allocationId != null && this.state == ShardRoutingState.INITIALIZING && this.allocationId.getId().equals(other.allocationId.getRelocationId()).     assert b == false || other.state == ShardRoutingState.RELOCATING : "ShardRouting is a relocation target but the source shard state isn't relocating. This [" + this + "], other [" + other + "]".     assert b == false || other.allocationId.getId().equals(this.allocationId.getRelocationId()) : "ShardRouting is a relocation target but the source id isn't equal to source's allocationId.getRelocationId." + " This [" + this + "], other [" + other + "]".     assert b == false || other.currentNodeId().equals(this.relocatingNodeId) : "ShardRouting is a relocation target but source current node id isn't equal to target relocating node." + " This [" + this + "], other [" + other + "]".     assert b == false || this.currentNodeId().equals(other.relocatingNodeId) : "ShardRouting is a relocation target but current node id isn't equal to source relocating node." + " This [" + this + "], other [" + other + "]".     assert b == false || this.shardId.equals(other.shardId) : "ShardRouting is a relocation target but both indexRoutings are not of the same shard id." + " This [" + this + "], other [" + other + "]".     assert b == false || this.primary == other.primary : "ShardRouting is a relocation target but primary flag is different." + " This [" + this + "], target [" + other + "]".     return b. }
true;public;1;29;/**  * returns true if the routing is the relocation source for the given routing  */ ;/**  * returns true if the routing is the relocation source for the given routing  */ public boolean isRelocationSourceOf(ShardRouting other) {     boolean b = this.allocationId != null && other.allocationId != null && other.state == ShardRoutingState.INITIALIZING && other.allocationId.getId().equals(this.allocationId.getRelocationId()).     assert b == false || this.state == ShardRoutingState.RELOCATING : "ShardRouting is a relocation source but shard state isn't relocating. This [" + this + "], other [" + other + "]".     assert b == false || this.allocationId.getId().equals(other.allocationId.getRelocationId()) : "ShardRouting is a relocation source but the allocation id isn't equal to other.allocationId.getRelocationId." + " This [" + this + "], other [" + other + "]".     assert b == false || this.currentNodeId().equals(other.relocatingNodeId) : "ShardRouting is a relocation source but current node isn't equal to other's relocating node." + " This [" + this + "], other [" + other + "]".     assert b == false || other.currentNodeId().equals(this.relocatingNodeId) : "ShardRouting is a relocation source but relocating node isn't equal to other's current node." + " This [" + this + "], other [" + other + "]".     assert b == false || this.shardId.equals(other.shardId) : "ShardRouting is a relocation source but both indexRoutings are not of the same shard." + " This [" + this + "], target [" + other + "]".     assert b == false || this.primary == other.primary : "ShardRouting is a relocation source but primary flag is different. This [" + this + "], target [" + other + "]".     return b. }
true;public;1;24;/**  * returns true if the current routing is identical to the other routing in all but meta fields, i.e., unassigned info  */ ;/**  * returns true if the current routing is identical to the other routing in all but meta fields, i.e., unassigned info  */ public boolean equalsIgnoringMetaData(ShardRouting other) {     if (primary != other.primary) {         return false.     }     if (shardId != null ? !shardId.equals(other.shardId) : other.shardId != null) {         return false.     }     if (currentNodeId != null ? !currentNodeId.equals(other.currentNodeId) : other.currentNodeId != null) {         return false.     }     if (relocatingNodeId != null ? !relocatingNodeId.equals(other.relocatingNodeId) : other.relocatingNodeId != null) {         return false.     }     if (allocationId != null ? !allocationId.equals(other.allocationId) : other.allocationId != null) {         return false.     }     if (state != other.state) {         return false.     }     if (recoverySource != null ? !recoverySource.equals(other.recoverySource) : other.recoverySource != null) {         return false.     }     return true. }
false;public;1;14;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (o == null || !(o instanceof ShardRouting)) {         return false.     }     ShardRouting that = (ShardRouting) o.     if (unassignedInfo != null ? !unassignedInfo.equals(that.unassignedInfo) : that.unassignedInfo != null) {         return false.     }     return equalsIgnoringMetaData(that). }
false;public;0;16;;@Override public int hashCode() {     int h = hashCode.     if (h == 0) {         h = shardId.hashCode().         h = 31 * h + (currentNodeId != null ? currentNodeId.hashCode() : 0).         h = 31 * h + (relocatingNodeId != null ? relocatingNodeId.hashCode() : 0).         h = 31 * h + (primary ? 1 : 0).         h = 31 * h + (state != null ? state.hashCode() : 0).         h = 31 * h + (recoverySource != null ? recoverySource.hashCode() : 0).         h = 31 * h + (allocationId != null ? allocationId.hashCode() : 0).         h = 31 * h + (unassignedInfo != null ? unassignedInfo.hashCode() : 0).         hashCode = h.     }     return h. }
false;public;0;4;;@Override public String toString() {     return shortSummary(). }
true;public;0;27;/**  * A short description of the shard.  */ ;/**  * A short description of the shard.  */ public String shortSummary() {     StringBuilder sb = new StringBuilder().     sb.append('[').append(shardId.getIndexName()).append(']').append('[').append(shardId.getId()).append(']').     sb.append(", node[").append(currentNodeId).append("], ").     if (relocatingNodeId != null) {         sb.append("relocating [").append(relocatingNodeId).append("], ").     }     if (primary) {         sb.append("[P]").     } else {         sb.append("[R]").     }     if (recoverySource != null) {         sb.append(", recovery_source[").append(recoverySource).append("]").     }     sb.append(", s[").append(state).append("]").     if (allocationId != null) {         sb.append(", a").append(allocationId).     }     if (this.unassignedInfo != null) {         sb.append(", ").append(unassignedInfo.toString()).     }     if (expectedShardSize != UNAVAILABLE_EXPECTED_SHARD_SIZE) {         sb.append(", expected_shard_size[").append(expectedShardSize).append("]").     }     return sb.toString(). }
false;public;2;24;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().field("state", state()).field("primary", primary()).field("node", currentNodeId()).field("relocating_node", relocatingNodeId()).field("shard", id()).field("index", getIndexName()).     if (expectedShardSize != UNAVAILABLE_EXPECTED_SHARD_SIZE) {         builder.field("expected_shard_size_in_bytes", expectedShardSize).     }     if (recoverySource != null) {         builder.field("recovery_source", recoverySource).     }     if (allocationId != null) {         builder.field("allocation_id").         allocationId.toXContent(builder, params).     }     if (unassignedInfo != null) {         unassignedInfo.toXContent(builder, params).     }     return builder.endObject(). }
true;public;0;3;/**  * Returns the expected shard size for {@link ShardRoutingState#RELOCATING} and {@link ShardRoutingState#INITIALIZING}  * shards. If it's size is not available {@value #UNAVAILABLE_EXPECTED_SHARD_SIZE} will be returned.  */ ;/**  * Returns the expected shard size for {@link ShardRoutingState#RELOCATING} and {@link ShardRoutingState#INITIALIZING}  * shards. If it's size is not available {@value #UNAVAILABLE_EXPECTED_SHARD_SIZE} will be returned.  */ public long getExpectedShardSize() {     return expectedShardSize. }
true;public;0;4;/**  * Returns recovery source for the given shard. Replica shards always recover from the primary {@link PeerRecoverySource}.  *  * @return recovery source or null if shard is {@link #active()}  */ ;/**  * Returns recovery source for the given shard. Replica shards always recover from the primary {@link PeerRecoverySource}.  *  * @return recovery source or null if shard is {@link #active()}  */ @Nullable public RecoverySource recoverySource() {     return recoverySource. }
