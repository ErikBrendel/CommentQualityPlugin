commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String getWriteableName() {     return CompletionSuggestionBuilder.SUGGESTION_NAME. }
false;public;1;7;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     if (out.getVersion().onOrAfter(Version.V_6_1_0)) {         out.writeBoolean(skipDuplicates).     } }
true;public;0;8;/**  * @return the result options for the suggestion  */ ;/**  * @return the result options for the suggestion  */ public List<Entry.Option> getOptions() {     if (entries.isEmpty() == false) {         assert entries.size() == 1 : "CompletionSuggestion must have only one entry".         return entries.get(0).getOptions().     } else {         return Collections.emptyList().     } }
true;public;0;3;/**  * @return whether there is any hits for the suggestion  */ ;/**  * @return whether there is any hits for the suggestion  */ public boolean hasScoreDocs() {     return getOptions().size() > 0. }
false;public;1;5;;@Override public boolean equals(Object other) {     return super.equals(other) && Objects.equals(skipDuplicates, ((CompletionSuggestion) other).skipDuplicates). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(super.hashCode(), skipDuplicates). }
false;public,static;2;5;;public static CompletionSuggestion fromXContent(XContentParser parser, String name) throws IOException {     CompletionSuggestion suggestion = new CompletionSuggestion(name, -1, false).     parseEntries(parser, suggestion, CompletionSuggestion.Entry::fromXContent).     return suggestion. }
false;protected;2;4;;@Override protected boolean lessThan(ShardOptions a, ShardOptions b) {     return COMPARATOR.compare(a.current, b.current) < 0. }
false;;0;8;;boolean advanceToNextOption() {     if (optionsIterator.hasNext()) {         current = optionsIterator.next().         return true.     } else {         return false.     } }
false;public;1;50;;@Override public CompletionSuggestion reduce(List<Suggest.Suggestion<Entry>> toReduce) {     if (toReduce.isEmpty()) {         return null.     } else {         final CompletionSuggestion leader = (CompletionSuggestion) toReduce.get(0).         final Entry leaderEntry = leader.getEntries().get(0).         final String name = leader.getName().         int size = leader.getSize().         if (toReduce.size() == 1) {             return leader.         } else {             // combine suggestion entries from participating shards on the coordinating node             // the global top <code>size</code> entries are collected from the shard results             // using a priority queue             OptionPriorityQueue pq = new OptionPriorityQueue(toReduce.size()).             for (Suggest.Suggestion<Entry> suggestion : toReduce) {                 assert suggestion.getName().equals(name) : "name should be identical across all suggestions".                 Iterator<Entry.Option> it = ((CompletionSuggestion) suggestion).getOptions().iterator().                 if (it.hasNext()) {                     pq.add(new ShardOptions(it)).                 }             }             // Dedup duplicate suggestions (based on the surface form) if skip duplicates is activated             final CharArraySet seenSurfaceForms = leader.skipDuplicates ? new CharArraySet(leader.getSize(), false) : null.             final Entry entry = new Entry(leaderEntry.getText(), leaderEntry.getOffset(), leaderEntry.getLength()).             final List<Entry.Option> options = entry.getOptions().             while (pq.size() > 0) {                 ShardOptions top = pq.top().                 Entry.Option current = top.current.                 if (top.advanceToNextOption()) {                     pq.updateTop().                 } else {                     // options exhausted for this shard                     pq.pop().                 }                 if (leader.skipDuplicates == false || seenSurfaceForms.add(current.getText().toString())) {                     options.add(current).                     if (options.size() >= size) {                         break.                     }                 }             }             final CompletionSuggestion suggestion = new CompletionSuggestion(leader.getName(), leader.getSize(), leader.skipDuplicates).             suggestion.addTerm(entry).             return suggestion.         }     } }
false;public;1;7;;public void setShardIndex(int shardIndex) {     if (entries.isEmpty() == false) {         for (Entry.Option option : getOptions()) {             option.setShardIndex(shardIndex).         }     } }
false;public;0;4;;@Override public int getWriteableType() {     return TYPE. }
false;protected;1;4;;@Override protected Entry newEntry(StreamInput in) throws IOException {     return new Entry(in). }
false;protected;1;4;;@Override protected Option newOption(StreamInput in) throws IOException {     return new Option(in). }
false;public,static;1;3;;public static Entry fromXContent(XContentParser parser) {     return PARSER.apply(parser, null). }
false;protected;1;6;;@Override protected void mergeInto(Suggest.Suggestion.Entry.Option otherOption) {     // org.elasticsearch.search.suggest.completion.CompletionSuggestion.reduce()     throw new UnsupportedOperationException(). }
false;public;0;3;;public Map<String, Set<String>> getContexts() {     return contexts. }
false;public;0;3;;public ScoreDoc getDoc() {     return doc. }
false;public;0;3;;public SearchHit getHit() {     return hit. }
false;public;1;3;;public void setShardIndex(int shardIndex) {     this.doc.shardIndex = shardIndex. }
false;public;1;3;;public void setHit(SearchHit hit) {     this.hit = hit. }
false;public;2;21;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.field(TEXT.getPreferredName(), getText()).     if (hit != null) {         hit.toInnerXContent(builder, params).     } else {         builder.field(SCORE.getPreferredName(), getScore()).     }     if (contexts.size() > 0) {         builder.startObject(CONTEXTS.getPreferredName()).         for (Map.Entry<String, Set<String>> entry : contexts.entrySet()) {             builder.startArray(entry.getKey()).             for (CharSequence context : entry.getValue()) {                 builder.value(context.toString()).             }             builder.endArray().         }         builder.endObject().     }     return builder. }
false;private,static;1;15;;private static Map<String, Set<String>> parseContexts(XContentParser parser) throws IOException {     Map<String, Set<String>> contexts = new HashMap<>().     while ((parser.nextToken()) != XContentParser.Token.END_OBJECT) {         ensureExpectedToken(XContentParser.Token.FIELD_NAME, parser.currentToken(), parser::getTokenLocation).         String key = parser.currentName().         ensureExpectedToken(XContentParser.Token.START_ARRAY, parser.nextToken(), parser::getTokenLocation).         Set<String> values = new HashSet<>().         while ((parser.nextToken()) != XContentParser.Token.END_ARRAY) {             ensureExpectedToken(XContentParser.Token.VALUE_STRING, parser.currentToken(), parser::getTokenLocation).             values.add(parser.text()).         }         contexts.put(key, values).     }     return contexts. }
false;public,static;1;22;;public static Option fromXContent(XContentParser parser) {     Map<String, Object> values = PARSER.apply(parser, null).     Text text = new Text((String) values.get(Suggestion.Entry.Option.TEXT.getPreferredName())).     Float score = (Float) values.get(Suggestion.Entry.Option.SCORE.getPreferredName()).     @SuppressWarnings("unchecked")     Map<String, Set<String>> contexts = (Map<String, Set<String>>) values.get(CompletionSuggestion.Entry.Option.CONTEXTS.getPreferredName()).     if (contexts == null) {         contexts = Collections.emptyMap().     }     SearchHit hit = null.     // the option either prints SCORE or inlines the search hit     if (score == null) {         hit = SearchHit.createFromMap(values).         score = hit.getScore().     }     CompletionSuggestion.Entry.Option option = new CompletionSuggestion.Entry.Option(-1, text, score, contexts).     option.setHit(hit).     return option. }
false;public;1;19;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     Lucene.writeScoreDoc(out, doc).     if (hit != null) {         out.writeBoolean(true).         hit.writeTo(out).     } else {         out.writeBoolean(false).     }     out.writeInt(contexts.size()).     for (Map.Entry<String, Set<String>> entry : contexts.entrySet()) {         out.writeString(entry.getKey()).         out.writeVInt(entry.getValue().size()).         for (CharSequence ctx : entry.getValue()) {             out.writeString(ctx.toString()).         }     } }
false;public;0;17;;@Override public String toString() {     StringBuilder stringBuilder = new StringBuilder().     stringBuilder.append("text:").     stringBuilder.append(getText()).     stringBuilder.append(" score:").     stringBuilder.append(getScore()).     stringBuilder.append(" context:[").     for (Map.Entry<String, Set<String>> entry : contexts.entrySet()) {         stringBuilder.append(" ").         stringBuilder.append(entry.getKey()).         stringBuilder.append(":").         stringBuilder.append(entry.getValue()).     }     stringBuilder.append("]").     return stringBuilder.toString(). }
