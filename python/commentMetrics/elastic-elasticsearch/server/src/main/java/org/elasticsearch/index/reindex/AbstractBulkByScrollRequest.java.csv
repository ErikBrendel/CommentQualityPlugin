commented;modifiers;parameterAmount;loc;comment;code
true;protected,abstract;0;1;/**  * `this` cast to Self. Used for building fluent methods without cast  * warnings.  */ ;/**  * `this` cast to Self. Used for building fluent methods without cast  * warnings.  */ protected abstract Self self().
false;public;0;23;;@Override public ActionRequestValidationException validate() {     ActionRequestValidationException e = searchRequest.validate().     if (searchRequest.source().from() != -1) {         e = addValidationError("from is not supported in this context", e).     }     if (searchRequest.source().storedFields() != null) {         e = addValidationError("stored_fields is not supported in this context", e).     }     if (maxRetries < 0) {         e = addValidationError("retries cannot be negative", e).     }     if (false == (size == -1 || size > 0)) {         e = addValidationError("size should be greater than 0 if the request is limited to some number of documents or -1 if it isn't but it was [" + size + "]", e).     }     if (searchRequest.source().slice() != null && slices != DEFAULT_SLICES) {         e = addValidationError("can't specify both manual and automatic slicing at the same time", e).     }     return e. }
true;public;0;3;/**  * Maximum number of processed documents. Defaults to -1 meaning process all  * documents.  */ ;/**  * Maximum number of processed documents. Defaults to -1 meaning process all  * documents.  */ public int getSize() {     return size. }
true;public;1;7;/**  * Maximum number of processed documents. Defaults to -1 meaning process all  * documents.  */ ;/**  * Maximum number of processed documents. Defaults to -1 meaning process all  * documents.  */ public Self setSize(int size) {     if (size < 0) {         throw new IllegalArgumentException("[size] parameter cannot be negative, found [" + size + "]").     }     this.size = size.     return self(). }
true;public;0;3;/**  * Whether or not version conflicts cause the action to abort.  */ ;/**  * Whether or not version conflicts cause the action to abort.  */ public boolean isAbortOnVersionConflict() {     return abortOnVersionConflict. }
true;public;1;4;/**  * Set whether or not version conflicts cause the action to abort.  */ ;/**  * Set whether or not version conflicts cause the action to abort.  */ public Self setAbortOnVersionConflict(boolean abortOnVersionConflict) {     this.abortOnVersionConflict = abortOnVersionConflict.     return self(). }
true;public;1;12;/**  * Sets abortOnVersionConflict based on REST-friendly names.  */ ;/**  * Sets abortOnVersionConflict based on REST-friendly names.  */ public void setConflicts(String conflicts) {     switch(conflicts) {         case "proceed":             setAbortOnVersionConflict(false).             return.         case "abort":             setAbortOnVersionConflict(true).             return.         default:             throw new IllegalArgumentException("conflicts may only be \"proceed\" or \"abort\" but was [" + conflicts + "]").     } }
true;public;0;3;/**  * The search request that matches the documents to process.  */ ;/**  * The search request that matches the documents to process.  */ public SearchRequest getSearchRequest() {     return searchRequest. }
true;public;0;3;/**  * Call refresh on the indexes we've written to after the request ends?  */ ;/**  * Call refresh on the indexes we've written to after the request ends?  */ public boolean isRefresh() {     return refresh. }
true;public;1;4;/**  * Call refresh on the indexes we've written to after the request ends?  */ ;/**  * Call refresh on the indexes we've written to after the request ends?  */ public Self setRefresh(boolean refresh) {     this.refresh = refresh.     return self(). }
true;public;0;3;/**  * Timeout to wait for the shards on to be available for each bulk request?  */ ;/**  * Timeout to wait for the shards on to be available for each bulk request?  */ public TimeValue getTimeout() {     return timeout. }
true;public;1;4;/**  * Timeout to wait for the shards on to be available for each bulk request?  */ ;/**  * Timeout to wait for the shards on to be available for each bulk request?  */ public Self setTimeout(TimeValue timeout) {     this.timeout = timeout.     return self(). }
true;public;1;4;/**  * Timeout to wait for the shards on to be available for each bulk request?  */ ;/**  * Timeout to wait for the shards on to be available for each bulk request?  */ public Self setTimeout(String timeout) {     this.timeout = TimeValue.parseTimeValue(timeout, this.timeout, getClass().getSimpleName() + ".timeout").     return self(). }
true;public;0;3;/**  * The number of shard copies that must be active before proceeding with the write.  */ ;/**  * The number of shard copies that must be active before proceeding with the write.  */ public ActiveShardCount getWaitForActiveShards() {     return activeShardCount. }
true;public;1;4;/**  * Sets the number of shard copies that must be active before proceeding with the write.  * See {@link ReplicationRequest#waitForActiveShards(ActiveShardCount)} for details.  */ ;/**  * Sets the number of shard copies that must be active before proceeding with the write.  * See {@link ReplicationRequest#waitForActiveShards(ActiveShardCount)} for details.  */ public Self setWaitForActiveShards(ActiveShardCount activeShardCount) {     this.activeShardCount = activeShardCount.     return self(). }
true;public;1;3;/**  * A shortcut for {@link #setWaitForActiveShards(ActiveShardCount)} where the numerical  * shard count is passed in, instead of having to first call {@link ActiveShardCount#from(int)}  * to get the ActiveShardCount.  */ ;/**  * A shortcut for {@link #setWaitForActiveShards(ActiveShardCount)} where the numerical  * shard count is passed in, instead of having to first call {@link ActiveShardCount#from(int)}  * to get the ActiveShardCount.  */ public Self setWaitForActiveShards(final int waitForActiveShards) {     return setWaitForActiveShards(ActiveShardCount.from(waitForActiveShards)). }
true;public;0;3;/**  * Initial delay after a rejection before retrying request.  */ ;/**  * Initial delay after a rejection before retrying request.  */ public TimeValue getRetryBackoffInitialTime() {     return retryBackoffInitialTime. }
true;public;1;4;/**  * Set the initial delay after a rejection before retrying request.  */ ;/**  * Set the initial delay after a rejection before retrying request.  */ public Self setRetryBackoffInitialTime(TimeValue retryBackoffInitialTime) {     this.retryBackoffInitialTime = retryBackoffInitialTime.     return self(). }
true;public;0;3;/**  * Total number of retries attempted for rejections.  */ ;/**  * Total number of retries attempted for rejections.  */ public int getMaxRetries() {     return maxRetries. }
true;public;1;4;/**  * Set the total number of retries attempted for rejections. There is no way to ask for unlimited retries.  */ ;/**  * Set the total number of retries attempted for rejections. There is no way to ask for unlimited retries.  */ public Self setMaxRetries(int maxRetries) {     this.maxRetries = maxRetries.     return self(). }
true;public;0;3;/**  * The throttle for this request in sub-requests per second. {@link Float#POSITIVE_INFINITY} means set no throttle and that is the  * default. Throttling is done between batches, as we start the next scroll requests. That way we can increase the scroll's timeout to  * make sure that it contains any time that we might wait.  */ ;/**  * The throttle for this request in sub-requests per second. {@link Float#POSITIVE_INFINITY} means set no throttle and that is the  * default. Throttling is done between batches, as we start the next scroll requests. That way we can increase the scroll's timeout to  * make sure that it contains any time that we might wait.  */ public float getRequestsPerSecond() {     return requestsPerSecond. }
true;public;1;8;/**  * Set the throttle for this request in sub-requests per second. {@link Float#POSITIVE_INFINITY} means set no throttle and that is the  * default. Throttling is done between batches, as we start the next scroll requests. That way we can increase the scroll's timeout to  * make sure that it contains any time that we might wait.  */ ;/**  * Set the throttle for this request in sub-requests per second. {@link Float#POSITIVE_INFINITY} means set no throttle and that is the  * default. Throttling is done between batches, as we start the next scroll requests. That way we can increase the scroll's timeout to  * make sure that it contains any time that we might wait.  */ public Self setRequestsPerSecond(float requestsPerSecond) {     if (requestsPerSecond <= 0) {         throw new IllegalArgumentException("[requests_per_second] must be greater than 0. Use Float.POSITIVE_INFINITY to disable throttling.").     }     this.requestsPerSecond = requestsPerSecond.     return self(). }
true;public;1;4;/**  * Should this task store its result after it has finished?  */ ;/**  * Should this task store its result after it has finished?  */ public Self setShouldStoreResult(boolean shouldStoreResult) {     this.shouldStoreResult = shouldStoreResult.     return self(). }
false;public;0;4;;@Override public boolean getShouldStoreResult() {     return shouldStoreResult. }
true;public;1;4;/**  * Set scroll timeout for {@link SearchRequest}  */ ;/**  * Set scroll timeout for {@link SearchRequest}  */ public Self setScroll(TimeValue keepAlive) {     searchRequest.scroll(new Scroll(keepAlive)).     return self(). }
true;public;0;3;/**  * Get scroll timeout  */ ;/**  * Get scroll timeout  */ public TimeValue getScrollTime() {     return searchRequest.scroll().keepAlive(). }
true;public;1;7;/**  * The number of slices this task should be divided into. Defaults to 1 meaning the task isn't sliced into subtasks.  */ ;/**  * The number of slices this task should be divided into. Defaults to 1 meaning the task isn't sliced into subtasks.  */ public Self setSlices(int slices) {     if (slices < 0) {         throw new IllegalArgumentException("[slices] must be at least 0 but was [" + slices + "]").     }     this.slices = slices.     return self(). }
true;public;0;3;/**  * The number of slices this task should be divided into. Defaults to 1 meaning the task isn't sliced into subtasks.  */ ;/**  * The number of slices this task should be divided into. Defaults to 1 meaning the task isn't sliced into subtasks.  */ public int getSlices() {     return slices. }
true;public,abstract;3;1;/**  * Build a new request for a slice of the parent request.  */ ;/**  * Build a new request for a slice of the parent request.  */ public abstract Self forSlice(TaskId slicingTask, SearchRequest slice, int totalSlices).
true;protected;3;23;/**  * Setup a clone of this request with the information needed to process a slice of it.  */ ;/**  * Setup a clone of this request with the information needed to process a slice of it.  */ protected Self doForSlice(Self request, TaskId slicingTask, int totalSlices) {     if (totalSlices < 1) {         throw new IllegalArgumentException("Number of total slices must be at least 1 but was [" + totalSlices + "]").     }     request.setAbortOnVersionConflict(abortOnVersionConflict).setRefresh(refresh).setTimeout(timeout).setWaitForActiveShards(activeShardCount).setRetryBackoffInitialTime(retryBackoffInitialTime).setMaxRetries(maxRetries).setShouldStoreResult(false).setRequestsPerSecond(requestsPerSecond / totalSlices).setSlices(1).     if (size != -1) {         // Size is split between workers. This means the size might round         // down!         request.setSize(size == SIZE_ALL_MATCHES ? SIZE_ALL_MATCHES : size / totalSlices).     }     // Set the parent task so this task is cancelled if we cancel the parent     request.setParentTask(slicingTask).     // TODO It'd be nice not to refresh on every slice. Instead we should refresh after the sub requests finish.     return request. }
false;public;5;4;;@Override public Task createTask(long id, String type, String action, TaskId parentTaskId, Map<String, String> headers) {     return new BulkByScrollTask(id, type, action, getDescription(), parentTaskId, headers). }
false;public;1;14;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     searchRequest = new SearchRequest(in).     abortOnVersionConflict = in.readBoolean().     size = in.readVInt().     refresh = in.readBoolean().     timeout = in.readTimeValue().     activeShardCount = ActiveShardCount.readFrom(in).     retryBackoffInitialTime = in.readTimeValue().     maxRetries = in.readVInt().     requestsPerSecond = in.readFloat().     slices = in.readVInt(). }
false;public;1;19;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     searchRequest.writeTo(out).     out.writeBoolean(abortOnVersionConflict).     out.writeVInt(size).     out.writeBoolean(refresh).     out.writeTimeValue(timeout).     activeShardCount.writeTo(out).     out.writeTimeValue(retryBackoffInitialTime).     out.writeVInt(maxRetries).     out.writeFloat(requestsPerSecond).     if (out.getVersion().before(Version.V_6_1_0) && slices == AUTO_SLICES) {         throw new IllegalArgumentException("Slices set as \"auto\" are not supported before version [" + Version.V_6_1_0 + "]. " + "Found version [" + out.getVersion() + "]").     } else {         out.writeVInt(slices).     } }
true;protected;1;10;/**  * Append a short description of the search request to a StringBuilder. Used  * to make toString.  */ ;/**  * Append a short description of the search request to a StringBuilder. Used  * to make toString.  */ protected void searchToString(StringBuilder b) {     if (searchRequest.indices() != null && searchRequest.indices().length != 0) {         b.append(Arrays.toString(searchRequest.indices())).     } else {         b.append("[all indices]").     }     if (searchRequest.types() != null && searchRequest.types().length != 0) {         b.append(Arrays.toString(searchRequest.types())).     } }
false;public;0;4;;@Override public String getDescription() {     return this.toString(). }
