commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public boolean shouldCancelChildrenOnCancellation() {     return true. }
true;public,final;0;4;// a fake parent node id "cluster" in the cluster state ;// In case of persistent tasks we always need to return: `false` // because in case of persistent task the parent task isn't a task in the task manager, but in cluster state. // This instructs the task manager not to try to kill this persistent task when the task manager cannot find // a fake parent node id "cluster" in the cluster state @Override public final boolean cancelOnParentLeaving() {     return false. }
false;public;0;4;;@Override public Status getStatus() {     return new PersistentTasksNodeService.Status(state.get()). }
true;public;2;4;/**  * Updates the persistent state for the corresponding persistent task.  * <p>  * This doesn't affect the status of this allocated task.  */ ;/**  * Updates the persistent state for the corresponding persistent task.  * <p>  * This doesn't affect the status of this allocated task.  */ public void updatePersistentTaskState(final PersistentTaskState state, final ActionListener<PersistentTasksCustomMetaData.PersistentTask<?>> listener) {     persistentTasksService.sendUpdateStateRequest(persistentTaskId, allocationId, state, listener). }
false;public;0;3;;public String getPersistentTaskId() {     return persistentTaskId. }
false;;5;8;;void init(PersistentTasksService persistentTasksService, TaskManager taskManager, Logger logger, String persistentTaskId, long allocationId) {     this.persistentTasksService = persistentTasksService.     this.logger = logger.     this.taskManager = taskManager.     this.persistentTaskId = persistentTaskId.     this.allocationId = allocationId. }
false;public;0;3;;public Exception getFailure() {     return failure. }
false;public;0;3;;public long getAllocationId() {     return allocationId. }
true;public;3;5;/**  * Waits for a given persistent task to comply with a given predicate, then call back the listener accordingly.  *  * @param predicate the persistent task predicate to evaluate  * @param timeout a timeout for waiting  * @param listener the callback listener  */ ;/**  * Waits for a given persistent task to comply with a given predicate, then call back the listener accordingly.  *  * @param predicate the persistent task predicate to evaluate  * @param timeout a timeout for waiting  * @param listener the callback listener  */ public void waitForPersistentTask(final Predicate<PersistentTasksCustomMetaData.PersistentTask<?>> predicate, @Nullable final TimeValue timeout, final PersistentTasksService.WaitForPersistentTaskListener<?> listener) {     persistentTasksService.waitForPersistentTaskCondition(persistentTaskId, predicate, timeout, listener). }
false;protected,final;0;3;;protected final boolean isCompleted() {     return state.get() == State.COMPLETED. }
false;;0;3;;boolean markAsCancelled() {     return state.compareAndSet(State.STARTED, State.PENDING_CANCEL). }
false;public;0;3;;public void markAsCompleted() {     completeAndNotifyIfNeeded(null). }
false;public;1;7;;public void markAsFailed(Exception e) {     if (CancelTasksRequest.DEFAULT_REASON.equals(getReasonCancelled())) {         completeAndNotifyIfNeeded(null).     } else {         completeAndNotifyIfNeeded(e).     } }
false;public;1;5;;@Override public void onResponse(PersistentTasksCustomMetaData.PersistentTask<?> persistentTask) {     logger.trace("notification for task [{}] with id [{}] was successful", getAction(), getPersistentTaskId()). }
false;public;1;5;;@Override public void onFailure(Exception e) {     logger.warn(() -> new ParameterizedMessage("notification for task [{}] with id [{}] failed", getAction(), getPersistentTaskId()), e). }
false;private;1;32;;private void completeAndNotifyIfNeeded(@Nullable Exception failure) {     final State prevState = state.getAndSet(State.COMPLETED).     if (prevState == State.COMPLETED) {         logger.warn("attempt to complete task [{}] with id [{}] in the [{}] state", getAction(), getPersistentTaskId(), prevState).     } else {         if (failure != null) {             logger.warn(() -> new ParameterizedMessage("task {} failed with an exception", getPersistentTaskId()), failure).         }         try {             this.failure = failure.             if (prevState == State.STARTED) {                 logger.trace("sending notification for completed task [{}] with id [{}]", getAction(), getPersistentTaskId()).                 persistentTasksService.sendCompletionRequest(getPersistentTaskId(), getAllocationId(), failure, new ActionListener<PersistentTasksCustomMetaData.PersistentTask<?>>() {                      @Override                     public void onResponse(PersistentTasksCustomMetaData.PersistentTask<?> persistentTask) {                         logger.trace("notification for task [{}] with id [{}] was successful", getAction(), getPersistentTaskId()).                     }                      @Override                     public void onFailure(Exception e) {                         logger.warn(() -> new ParameterizedMessage("notification for task [{}] with id [{}] failed", getAction(), getPersistentTaskId()), e).                     }                 }).             }         } finally {             taskManager.unregister(this).         }     } }
