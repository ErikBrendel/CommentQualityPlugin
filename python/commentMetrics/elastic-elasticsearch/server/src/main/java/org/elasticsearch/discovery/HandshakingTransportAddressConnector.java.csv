commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;37;;@Override protected void doRun() throws Exception {     // TODO if transportService is already connected to this address then skip the handshaking     final DiscoveryNode targetNode = new DiscoveryNode("", transportAddress.toString(), // generated deterministically for reproducible tests     UUIDs.randomBase64UUID(Randomness.get()), transportAddress.address().getHostString(), transportAddress.getAddress(), transportAddress, emptyMap(), emptySet(), Version.CURRENT.minimumCompatibilityVersion()).     logger.trace("[{}] opening probe connection", this).     final Connection connection = transportService.openConnection(targetNode, ConnectionProfile.buildSingleChannelProfile(Type.REG, probeConnectTimeout, probeHandshakeTimeout, TimeValue.MINUS_ONE, null)).     logger.trace("[{}] opened probe connection", this).     final DiscoveryNode remoteNode.     try {         remoteNode = transportService.handshake(connection, probeHandshakeTimeout.millis()).         // success means (amongst other things) that the cluster names match         logger.trace("[{}] handshake successful: {}", this, remoteNode).     } finally {         IOUtils.closeWhileHandlingException(connection).     }     if (remoteNode.equals(transportService.getLocalNode())) {         // TODO cache this result for some time? forever?         listener.onFailure(new ConnectTransportException(remoteNode, "local node found")).     } else if (remoteNode.isMasterNode() == false) {         // TODO cache this result for some time?         listener.onFailure(new ConnectTransportException(remoteNode, "non-master-eligible node found")).     } else {         transportService.connectToNode(remoteNode).         logger.trace("[{}] full connection successful: {}", this, remoteNode).         listener.onResponse(remoteNode).     } }
false;public;1;4;;@Override public void onFailure(Exception e) {     listener.onFailure(e). }
false;public;0;4;;@Override public String toString() {     return "connectToRemoteMasterNode[" + transportAddress + "]". }
false;public;2;52;;@Override public void connectToRemoteMasterNode(TransportAddress transportAddress, ActionListener<DiscoveryNode> listener) {     transportService.getThreadPool().generic().execute(new AbstractRunnable() {          @Override         protected void doRun() throws Exception {             // TODO if transportService is already connected to this address then skip the handshaking             final DiscoveryNode targetNode = new DiscoveryNode("", transportAddress.toString(), // generated deterministically for reproducible tests             UUIDs.randomBase64UUID(Randomness.get()), transportAddress.address().getHostString(), transportAddress.getAddress(), transportAddress, emptyMap(), emptySet(), Version.CURRENT.minimumCompatibilityVersion()).             logger.trace("[{}] opening probe connection", this).             final Connection connection = transportService.openConnection(targetNode, ConnectionProfile.buildSingleChannelProfile(Type.REG, probeConnectTimeout, probeHandshakeTimeout, TimeValue.MINUS_ONE, null)).             logger.trace("[{}] opened probe connection", this).             final DiscoveryNode remoteNode.             try {                 remoteNode = transportService.handshake(connection, probeHandshakeTimeout.millis()).                 // success means (amongst other things) that the cluster names match                 logger.trace("[{}] handshake successful: {}", this, remoteNode).             } finally {                 IOUtils.closeWhileHandlingException(connection).             }             if (remoteNode.equals(transportService.getLocalNode())) {                 // TODO cache this result for some time? forever?                 listener.onFailure(new ConnectTransportException(remoteNode, "local node found")).             } else if (remoteNode.isMasterNode() == false) {                 // TODO cache this result for some time?                 listener.onFailure(new ConnectTransportException(remoteNode, "non-master-eligible node found")).             } else {                 transportService.connectToNode(remoteNode).                 logger.trace("[{}] full connection successful: {}", this, remoteNode).                 listener.onResponse(remoteNode).             }         }          @Override         public void onFailure(Exception e) {             listener.onFailure(e).         }          @Override         public String toString() {             return "connectToRemoteMasterNode[" + transportAddress + "]".         }     }). }
