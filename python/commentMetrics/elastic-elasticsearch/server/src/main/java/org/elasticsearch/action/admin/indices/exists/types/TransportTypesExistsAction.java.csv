commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;5;;@Override protected String executor() {     // lightweight check     return ThreadPool.Names.SAME. }
false;protected;0;4;;@Override protected TypesExistsResponse newResponse() {     return new TypesExistsResponse(). }
false;protected;2;5;;@Override protected ClusterBlockException checkBlock(TypesExistsRequest request, ClusterState state) {     return state.blocks().indicesBlockedException(ClusterBlockLevel.METADATA_READ, indexNameExpressionResolver.concreteIndexNames(state, request)). }
false;protected;3;31;;@Override protected void masterOperation(final TypesExistsRequest request, final ClusterState state, final ActionListener<TypesExistsResponse> listener) {     String[] concreteIndices = indexNameExpressionResolver.concreteIndexNames(state, request.indicesOptions(), request.indices()).     if (concreteIndices.length == 0) {         listener.onResponse(new TypesExistsResponse(false)).         return.     }     for (String concreteIndex : concreteIndices) {         if (!state.metaData().hasConcreteIndex(concreteIndex)) {             listener.onResponse(new TypesExistsResponse(false)).             return.         }         MappingMetaData mapping = state.metaData().getIndices().get(concreteIndex).mapping().         if (mapping == null) {             listener.onResponse(new TypesExistsResponse(false)).             return.         }         for (String type : request.types()) {             if (mapping.type().equals(type) == false) {                 listener.onResponse(new TypesExistsResponse(false)).                 return.             }         }     }     listener.onResponse(new TypesExistsResponse(true)). }
