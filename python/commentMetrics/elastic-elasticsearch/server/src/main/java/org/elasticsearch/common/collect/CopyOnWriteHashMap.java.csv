commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;10;/**  * Return a copy of the provided map.  */ ;/**  * Return a copy of the provided map.  */ public static <K, V> CopyOnWriteHashMap<K, V> copyOf(Map<? extends K, ? extends V> map) {     if (map instanceof CopyOnWriteHashMap) {         // no need to copy in that case         @SuppressWarnings("unchecked")         final CopyOnWriteHashMap<K, V> cowMap = (CopyOnWriteHashMap<K, V>) map.         return cowMap.     } else {         return new CopyOnWriteHashMap<K, V>().copyAndPutAll(map).     } }
true;abstract;2;1;/**  * Recursively get the key with the given hash.  */ ;/**  * Recursively get the key with the given hash.  */ abstract V get(Object key, int hash).
true;abstract;5;1;/**  * Recursively add a new entry to this node. <code>hashBits</code> is  * the number of bits that are still set in the hash. When this value  * reaches a number that is less than or equal to {@code 0}, a leaf  * node needs to be created since it means that a collision occurred  * on the 32 bits of the hash.  */ ;/**  * Recursively add a new entry to this node. <code>hashBits</code> is  * the number of bits that are still set in the hash. When this value  * reaches a number that is less than or equal to {@code 0}, a leaf  * node needs to be created since it means that a collision occurred  * on the 32 bits of the hash.  */ abstract Node<K, V> put(K key, int hash, int hashBits, V value, MutableValueInt newValue).
true;abstract;2;1;/**  * Recursively remove an entry from this node.  */ ;/**  * Recursively remove an entry from this node.  */ abstract Node<K, V> remove(Object key, int hash).
true;abstract;2;1;/**  * For the current node only, append entries that are stored on this  * node to <code>entries</code> and sub nodes to <code>nodes</code>.  */ ;/**  * For the current node only, append entries that are stored on this  * node to <code>entries</code> and sub nodes to <code>nodes</code>.  */ abstract void visit(Deque<Map.Entry<K, V>> entries, Deque<Node<K, V>> nodes).
true;abstract;0;1;/**  * Whether this node stores nothing under it.  */ ;/**  * Whether this node stores nothing under it.  */ abstract boolean isEmpty().
false;;0;4;;@Override boolean isEmpty() {     return keys.length == 0. }
false;;2;6;;@Override void visit(Deque<Map.Entry<K, V>> entries, Deque<Node<K, V>> nodes) {     for (int i = 0. i < keys.length. ++i) {         entries.add(new AbstractMap.SimpleImmutableEntry<>(keys[i], values[i])).     } }
false;;2;10;;@Override V get(Object key, int hash) {     for (int i = 0. i < keys.length. i++) {         if (key.equals(keys[i])) {             return values[i].         }     }     return null. }
false;private,static;3;5;;private static <T> T[] replace(T[] array, int index, T value) {     final T[] copy = Arrays.copyOf(array, array.length).     copy[index] = value.     return copy. }
false;;5;25;;@Override Leaf<K, V> put(K key, int hash, int hashBits, V value, MutableValueInt newValue) {     assert hashBits <= 0 : hashBits.     int slot = -1.     for (int i = 0. i < keys.length. i++) {         if (key.equals(keys[i])) {             slot = i.             break.         }     }     final K[] keys2.     final V[] values2.     if (slot < 0) {         keys2 = appendElement(keys, key).         values2 = appendElement(values, value).         newValue.value = 1.     } else {         keys2 = replace(keys, slot, key).         values2 = replace(values, slot, value).     }     return new Leaf<>(keys2, values2). }
false;;2;16;;@Override Leaf<K, V> remove(Object key, int hash) {     int slot = -1.     for (int i = 0. i < keys.length. i++) {         if (key.equals(keys[i])) {             slot = i.             break.         }     }     if (slot < 0) {         return this.     }     final K[] keys2 = removeArrayElement(keys, slot).     final V[] values2 = removeArrayElement(values, slot).     return new Leaf<>(keys2, values2). }
false;private,static;2;9;;private static <T> T[] removeArrayElement(T[] array, int index) {     final Object result = Array.newInstance(array.getClass().getComponentType(), array.length - 1).     System.arraycopy(array, 0, result, 0, index).     if (index < array.length - 1) {         System.arraycopy(array, index + 1, result, index, array.length - index - 1).     }     return (T[]) result. }
false;public,static;2;5;;public static <T> T[] appendElement(final T[] array, final T element) {     final T[] newArray = Arrays.copyOf(array, array.length + 1).     newArray[newArray.length - 1] = element.     return newArray. }
false;public,static;3;9;;public static <T> T[] insertElement(final T[] array, final T element, final int index) {     final T[] result = Arrays.copyOf(array, array.length + 1).     System.arraycopy(array, 0, result, 0, index).     result[index] = element.     if (index < array.length) {         System.arraycopy(array, index, result, index + 1, array.length - index).     }     return result. }
true;private;0;12;// only used in assert ;// only used in assert private boolean consistent() {     assert Long.bitCount(mask) == keys.length.     assert Long.bitCount(mask) == subNodes.length.     for (int i = 0. i < keys.length. ++i) {         if (subNodes[i] instanceof Node) {             assert keys[i] == null.         } else {             assert keys[i] != null.         }     }     return true. }
false;;0;4;;@Override boolean isEmpty() {     return mask == 0. }
false;;2;16;;@Override void visit(Deque<Map.Entry<K, V>> entries, Deque<Node<K, V>> nodes) {     for (int i = 0. i < keys.length. ++i) {         final Object sub = subNodes[i].         if (sub instanceof Node) {             @SuppressWarnings("unchecked")             final Node<K, V> subNode = (Node<K, V>) sub.             assert keys[i] == null.             nodes.add(subNode).         } else {             @SuppressWarnings("unchecked")             final V value = (V) sub.             entries.add(new AbstractMap.SimpleImmutableEntry<>(keys[i], value)).         }     } }
true;private;1;3;/**  * For a given hash on 6 bits, its value is set if the bitmap has a one  * at the corresponding index.  */ ;/**  * For a given hash on 6 bits, its value is set if the bitmap has a one  * at the corresponding index.  */ private boolean exists(int hash6) {     return (mask & (1L << hash6)) != 0. }
true;private;1;3;/**  * For a given hash on 6 bits, the slot number is the number of one  * bits on the right of the <code>hash6</code>-th bit.  */ ;/**  * For a given hash on 6 bits, the slot number is the number of one  * bits on the right of the <code>hash6</code>-th bit.  */ private int slot(int hash6) {     return Long.bitCount(mask & ((1L << hash6) - 1)). }
false;;2;25;;@Override V get(Object key, int hash) {     final int hash6 = hash & HASH_MASK.     if (!exists(hash6)) {         return null.     }     final int slot = slot(hash6).     final Object sub = subNodes[slot].     assert sub != null.     if (sub instanceof Node) {         // keys don't make sense on inner nodes         assert keys[slot] == null.         @SuppressWarnings("unchecked")         final Node<K, V> subNode = (Node<K, V>) sub.         return subNode.get(key, hash >>> HASH_BITS).     } else {         if (keys[slot].equals(key)) {             @SuppressWarnings("unchecked")             final V v = (V) sub.             return v.         } else {             // we have an entry for this hash, but the value is different             return null.         }     } }
false;private;1;7;;private Node<K, V> newSubNode(int hashBits) {     if (hashBits <= 0) {         return new Leaf<K, V>().     } else {         return new InnerNode<K, V>().     } }
false;private;6;24;;private InnerNode<K, V> putExisting(K key, int hash, int hashBits, int slot, V value, MutableValueInt newValue) {     final K[] keys2 = Arrays.copyOf(keys, keys.length).     final Object[] subNodes2 = Arrays.copyOf(subNodes, subNodes.length).     final Object previousValue = subNodes2[slot].     if (previousValue instanceof Node) {         // insert recursively         assert keys[slot] == null.         subNodes2[slot] = ((Node<K, V>) previousValue).put(key, hash, hashBits, value, newValue).     } else if (keys[slot].equals(key)) {         // replace the existing entry         subNodes2[slot] = value.     } else {         // hash collision         final K previousKey = keys[slot].         final int previousHash = previousKey.hashCode() >>> (TOTAL_HASH_BITS - hashBits).         Node<K, V> subNode = newSubNode(hashBits).         subNode = subNode.put(previousKey, previousHash, hashBits, (V) previousValue, newValue).         subNode = subNode.put(key, hash, hashBits, value, newValue).         keys2[slot] = null.         subNodes2[slot] = subNode.     }     return new InnerNode<>(mask, keys2, subNodes2). }
false;private;4;6;;private InnerNode<K, V> putNew(K key, int hash6, int slot, V value) {     final long mask2 = mask | (1L << hash6).     final K[] keys2 = insertElement(keys, key, slot).     final Object[] subNodes2 = insertElement(subNodes, value, slot).     return new InnerNode<>(mask2, keys2, subNodes2). }
false;;5;14;;@Override InnerNode<K, V> put(K key, int hash, int hashBits, V value, MutableValueInt newValue) {     final int hash6 = hash & HASH_MASK.     final int slot = slot(hash6).     if (exists(hash6)) {         hash >>>= HASH_BITS.         hashBits -= HASH_BITS.         return putExisting(key, hash, hashBits, slot, value, newValue).     } else {         newValue.value = 1.         return putNew(key, hash6, slot, value).     } }
false;private;2;6;;private InnerNode<K, V> removeSlot(int hash6, int slot) {     final long mask2 = mask & ~(1L << hash6).     final K[] keys2 = removeArrayElement(keys, slot).     final Object[] subNodes2 = removeArrayElement(subNodes, slot).     return new InnerNode<>(mask2, keys2, subNodes2). }
false;;2;31;;@Override InnerNode<K, V> remove(Object key, int hash) {     final int hash6 = hash & HASH_MASK.     if (!exists(hash6)) {         return this.     }     final int slot = slot(hash6).     final Object previousValue = subNodes[slot].     if (previousValue instanceof Node) {         @SuppressWarnings("unchecked")         final Node<K, V> subNode = (Node<K, V>) previousValue.         final Node<K, V> removed = subNode.remove(key, hash >>> HASH_BITS).         if (removed == subNode) {             // not in sub-nodes             return this.         }         if (removed.isEmpty()) {             return removeSlot(hash6, slot).         }         final K[] keys2 = Arrays.copyOf(keys, keys.length).         final Object[] subNodes2 = Arrays.copyOf(subNodes, subNodes.length).         subNodes2[slot] = removed.         return new InnerNode<>(mask, keys2, subNodes2).     } else if (keys[slot].equals(key)) {         // remove entry         return removeSlot(hash6, slot).     } else {         // hash collision, nothing to remove         return this.     } }
false;public;0;4;;@Override public boolean hasNext() {     return !entries.isEmpty() || !nodes.isEmpty(). }
false;public;0;11;;@Override public Map.Entry<K, V> next() {     while (entries.isEmpty()) {         if (nodes.isEmpty()) {             throw new NoSuchElementException().         }         final Node<K, V> nextNode = nodes.pop().         nextNode.visit(entries, nodes).     }     return entries.pop(). }
false;public,final;0;4;;@Override public final void remove() {     throw new UnsupportedOperationException(). }
false;public;1;5;;@Override public boolean containsKey(Object key) {     // works fine since null values are not supported     return get(key) != null. }
false;public;1;8;;@Override public V get(Object key) {     if (key == null) {         throw new IllegalArgumentException("null keys are not supported").     }     final int hash = key.hashCode().     return root.get(key, hash). }
false;public;0;5;;@Override public int size() {     assert size != 0 || root.isEmpty().     return size. }
true;public;2;13;/**  * Associate <code>key</code> with <code>value</code> and return a new copy  * of the hash table. The current hash table is not modified.  */ ;/**  * Associate <code>key</code> with <code>value</code> and return a new copy  * of the hash table. The current hash table is not modified.  */ public CopyOnWriteHashMap<K, V> copyAndPut(K key, V value) {     if (key == null) {         throw new IllegalArgumentException("null keys are not supported").     }     if (value == null) {         throw new IllegalArgumentException("null values are not supported").     }     final int hash = key.hashCode().     final MutableValueInt newValue = new MutableValueInt().     final InnerNode<K, V> newRoot = root.put(key, hash, TOTAL_HASH_BITS, value, newValue).     final int newSize = size + newValue.value.     return new CopyOnWriteHashMap<>(newRoot, newSize). }
true;public;1;3;/**  * Same as {@link #copyAndPut(Object, Object)} but for an arbitrary number of entries.  */ ;/**  * Same as {@link #copyAndPut(Object, Object)} but for an arbitrary number of entries.  */ public CopyOnWriteHashMap<K, V> copyAndPutAll(Map<? extends K, ? extends V> other) {     return copyAndPutAll(other.entrySet()). }
false;public;1;7;;public <K1 extends K, V1 extends V> CopyOnWriteHashMap<K, V> copyAndPutAll(Iterable<Entry<K1, V1>> entries) {     CopyOnWriteHashMap<K, V> result = this.     for (Entry<K1, V1> entry : entries) {         result = result.copyAndPut(entry.getKey(), entry.getValue()).     }     return result. }
false;public;1;3;;public <K1 extends K, V1 extends V> CopyOnWriteHashMap<K, V> copyAndPutAll(Stream<Entry<K1, V1>> entries) {     return copyAndPutAll(entries::iterator). }
true;public;1;12;/**  * Remove the given key from this map. The current hash table is not modified.  */ ;/**  * Remove the given key from this map. The current hash table is not modified.  */ public CopyOnWriteHashMap<K, V> copyAndRemove(Object key) {     if (key == null) {         throw new IllegalArgumentException("null keys are not supported").     }     final int hash = key.hashCode().     final InnerNode<K, V> newRoot = root.remove(key, hash).     if (root == newRoot) {         return this.     } else {         return new CopyOnWriteHashMap<>(newRoot, size - 1).     } }
true;public;1;7;/**  * Same as {@link #copyAndRemove(Object)} but for an arbitrary number of entries.  */ ;/**  * Same as {@link #copyAndRemove(Object)} but for an arbitrary number of entries.  */ public CopyOnWriteHashMap<K, V> copyAndRemoveAll(Collection<?> keys) {     CopyOnWriteHashMap<K, V> result = this.     for (Object key : keys) {         result = result.copyAndRemove(key).     }     return result. }
false;public;0;4;;@Override public Iterator<java.util.Map.Entry<K, V>> iterator() {     return new EntryIterator<>(root). }
false;public;1;8;;@Override public boolean contains(Object o) {     if (o == null || !(o instanceof Map.Entry)) {         return false.     }     Map.Entry<?, ?> entry = (java.util.Map.Entry<?, ?>) o.     return entry.getValue().equals(CopyOnWriteHashMap.this.get(entry.getKey())). }
false;public;0;4;;@Override public int size() {     return CopyOnWriteHashMap.this.size(). }
false;public;0;24;;@Override public Set<Map.Entry<K, V>> entrySet() {     return new AbstractSet<Map.Entry<K, V>>() {          @Override         public Iterator<java.util.Map.Entry<K, V>> iterator() {             return new EntryIterator<>(root).         }          @Override         public boolean contains(Object o) {             if (o == null || !(o instanceof Map.Entry)) {                 return false.             }             Map.Entry<?, ?> entry = (java.util.Map.Entry<?, ?>) o.             return entry.getValue().equals(CopyOnWriteHashMap.this.get(entry.getKey())).         }          @Override         public int size() {             return CopyOnWriteHashMap.this.size().         }     }. }
