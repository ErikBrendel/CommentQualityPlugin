# id;timestamp;commentText;codeText;commentWords;codeWords
RemoteClusterService -> public Transport.Connection getConnection(DiscoveryNode node, String cluster);1524684173;Returns a connection to the given node on the given remote cluster_@throws IllegalArgumentException if the remote cluster is unknown;public Transport.Connection getConnection(DiscoveryNode node, String cluster) {_        RemoteClusterConnection connection = remoteClusters.get(cluster)__        if (connection == null) {_            throw new IllegalArgumentException("no such remote cluster: " + cluster)__        }_        return connection.getConnection(node)__    };returns,a,connection,to,the,given,node,on,the,given,remote,cluster,throws,illegal,argument,exception,if,the,remote,cluster,is,unknown;public,transport,connection,get,connection,discovery,node,node,string,cluster,remote,cluster,connection,connection,remote,clusters,get,cluster,if,connection,null,throw,new,illegal,argument,exception,no,such,remote,cluster,cluster,return,connection,get,connection,node
RemoteClusterService -> public Transport.Connection getConnection(DiscoveryNode node, String cluster);1525076988;Returns a connection to the given node on the given remote cluster_@throws IllegalArgumentException if the remote cluster is unknown;public Transport.Connection getConnection(DiscoveryNode node, String cluster) {_        RemoteClusterConnection connection = remoteClusters.get(cluster)__        if (connection == null) {_            throw new IllegalArgumentException("no such remote cluster: " + cluster)__        }_        return connection.getConnection(node)__    };returns,a,connection,to,the,given,node,on,the,given,remote,cluster,throws,illegal,argument,exception,if,the,remote,cluster,is,unknown;public,transport,connection,get,connection,discovery,node,node,string,cluster,remote,cluster,connection,connection,remote,clusters,get,cluster,if,connection,null,throw,new,illegal,argument,exception,no,such,remote,cluster,cluster,return,connection,get,connection,node
RemoteClusterService -> public Transport.Connection getConnection(DiscoveryNode node, String cluster);1525334055;Returns a connection to the given node on the given remote cluster_@throws IllegalArgumentException if the remote cluster is unknown;public Transport.Connection getConnection(DiscoveryNode node, String cluster) {_        RemoteClusterConnection connection = remoteClusters.get(cluster)__        if (connection == null) {_            throw new IllegalArgumentException("no such remote cluster: " + cluster)__        }_        return connection.getConnection(node)__    };returns,a,connection,to,the,given,node,on,the,given,remote,cluster,throws,illegal,argument,exception,if,the,remote,cluster,is,unknown;public,transport,connection,get,connection,discovery,node,node,string,cluster,remote,cluster,connection,connection,remote,clusters,get,cluster,if,connection,null,throw,new,illegal,argument,exception,no,such,remote,cluster,cluster,return,connection,get,connection,node
RemoteClusterService -> public Transport.Connection getConnection(DiscoveryNode node, String cluster);1527773340;Returns a connection to the given node on the given remote cluster_@throws IllegalArgumentException if the remote cluster is unknown;public Transport.Connection getConnection(DiscoveryNode node, String cluster) {_        RemoteClusterConnection connection = remoteClusters.get(cluster)__        if (connection == null) {_            throw new IllegalArgumentException("no such remote cluster: " + cluster)__        }_        return connection.getConnection(node)__    };returns,a,connection,to,the,given,node,on,the,given,remote,cluster,throws,illegal,argument,exception,if,the,remote,cluster,is,unknown;public,transport,connection,get,connection,discovery,node,node,string,cluster,remote,cluster,connection,connection,remote,clusters,get,cluster,if,connection,null,throw,new,illegal,argument,exception,no,such,remote,cluster,cluster,return,connection,get,connection,node
RemoteClusterService -> public Transport.Connection getConnection(DiscoveryNode node, String cluster);1527840262;Returns a connection to the given node on the given remote cluster_@throws IllegalArgumentException if the remote cluster is unknown;public Transport.Connection getConnection(DiscoveryNode node, String cluster) {_        RemoteClusterConnection connection = remoteClusters.get(cluster)__        if (connection == null) {_            throw new IllegalArgumentException("no such remote cluster: " + cluster)__        }_        return connection.getConnection(node)__    };returns,a,connection,to,the,given,node,on,the,given,remote,cluster,throws,illegal,argument,exception,if,the,remote,cluster,is,unknown;public,transport,connection,get,connection,discovery,node,node,string,cluster,remote,cluster,connection,connection,remote,clusters,get,cluster,if,connection,null,throw,new,illegal,argument,exception,no,such,remote,cluster,cluster,return,connection,get,connection,node
RemoteClusterService -> public Transport.Connection getConnection(DiscoveryNode node, String cluster);1534755962;Returns a connection to the given node on the given remote cluster_@throws IllegalArgumentException if the remote cluster is unknown;public Transport.Connection getConnection(DiscoveryNode node, String cluster) {_        RemoteClusterConnection connection = remoteClusters.get(cluster)__        if (connection == null) {_            throw new IllegalArgumentException("no such remote cluster: " + cluster)__        }_        return connection.getConnection(node)__    };returns,a,connection,to,the,given,node,on,the,given,remote,cluster,throws,illegal,argument,exception,if,the,remote,cluster,is,unknown;public,transport,connection,get,connection,discovery,node,node,string,cluster,remote,cluster,connection,connection,remote,clusters,get,cluster,if,connection,null,throw,new,illegal,argument,exception,no,such,remote,cluster,cluster,return,connection,get,connection,node
RemoteClusterService -> public Transport.Connection getConnection(DiscoveryNode node, String cluster);1535046779;Returns a connection to the given node on the given remote cluster_@throws IllegalArgumentException if the remote cluster is unknown;public Transport.Connection getConnection(DiscoveryNode node, String cluster) {_        RemoteClusterConnection connection = remoteClusters.get(cluster)__        if (connection == null) {_            throw new IllegalArgumentException("no such remote cluster: " + cluster)__        }_        return connection.getConnection(node)__    };returns,a,connection,to,the,given,node,on,the,given,remote,cluster,throws,illegal,argument,exception,if,the,remote,cluster,is,unknown;public,transport,connection,get,connection,discovery,node,node,string,cluster,remote,cluster,connection,connection,remote,clusters,get,cluster,if,connection,null,throw,new,illegal,argument,exception,no,such,remote,cluster,cluster,return,connection,get,connection,node
RemoteClusterService -> public Transport.Connection getConnection(DiscoveryNode node, String cluster);1535383145;Returns a connection to the given node on the given remote cluster_@throws IllegalArgumentException if the remote cluster is unknown;public Transport.Connection getConnection(DiscoveryNode node, String cluster) {_        RemoteClusterConnection connection = remoteClusters.get(cluster)__        if (connection == null) {_            throw new IllegalArgumentException("no such remote cluster: " + cluster)__        }_        return connection.getConnection(node)__    };returns,a,connection,to,the,given,node,on,the,given,remote,cluster,throws,illegal,argument,exception,if,the,remote,cluster,is,unknown;public,transport,connection,get,connection,discovery,node,node,string,cluster,remote,cluster,connection,connection,remote,clusters,get,cluster,if,connection,null,throw,new,illegal,argument,exception,no,such,remote,cluster,cluster,return,connection,get,connection,node
RemoteClusterService -> public Transport.Connection getConnection(DiscoveryNode node, String cluster);1536218260;Returns a connection to the given node on the given remote cluster_@throws IllegalArgumentException if the remote cluster is unknown;public Transport.Connection getConnection(DiscoveryNode node, String cluster) {_        RemoteClusterConnection connection = remoteClusters.get(cluster)__        if (connection == null) {_            throw new IllegalArgumentException("no such remote cluster: " + cluster)__        }_        return connection.getConnection(node)__    };returns,a,connection,to,the,given,node,on,the,given,remote,cluster,throws,illegal,argument,exception,if,the,remote,cluster,is,unknown;public,transport,connection,get,connection,discovery,node,node,string,cluster,remote,cluster,connection,connection,remote,clusters,get,cluster,if,connection,null,throw,new,illegal,argument,exception,no,such,remote,cluster,cluster,return,connection,get,connection,node
RemoteClusterService -> public Transport.Connection getConnection(DiscoveryNode node, String cluster);1536828374;Returns a connection to the given node on the given remote cluster_@throws IllegalArgumentException if the remote cluster is unknown;public Transport.Connection getConnection(DiscoveryNode node, String cluster) {_        RemoteClusterConnection connection = remoteClusters.get(cluster)__        if (connection == null) {_            throw new IllegalArgumentException("no such remote cluster: " + cluster)__        }_        return connection.getConnection(node)__    };returns,a,connection,to,the,given,node,on,the,given,remote,cluster,throws,illegal,argument,exception,if,the,remote,cluster,is,unknown;public,transport,connection,get,connection,discovery,node,node,string,cluster,remote,cluster,connection,connection,remote,clusters,get,cluster,if,connection,null,throw,new,illegal,argument,exception,no,such,remote,cluster,cluster,return,connection,get,connection,node
RemoteClusterService -> public Transport.Connection getConnection(DiscoveryNode node, String cluster);1537806831;Returns a connection to the given node on the given remote cluster_@throws IllegalArgumentException if the remote cluster is unknown;public Transport.Connection getConnection(DiscoveryNode node, String cluster) {_        RemoteClusterConnection connection = remoteClusters.get(cluster)__        if (connection == null) {_            throw new IllegalArgumentException("no such remote cluster: " + cluster)__        }_        return connection.getConnection(node)__    };returns,a,connection,to,the,given,node,on,the,given,remote,cluster,throws,illegal,argument,exception,if,the,remote,cluster,is,unknown;public,transport,connection,get,connection,discovery,node,node,string,cluster,remote,cluster,connection,connection,remote,clusters,get,cluster,if,connection,null,throw,new,illegal,argument,exception,no,such,remote,cluster,cluster,return,connection,get,connection,node
RemoteClusterService -> public Transport.Connection getConnection(DiscoveryNode node, String cluster);1541008027;Returns a connection to the given node on the given remote cluster_@throws IllegalArgumentException if the remote cluster is unknown;public Transport.Connection getConnection(DiscoveryNode node, String cluster) {_        return getRemoteClusterConnection(cluster).getConnection(node)__    };returns,a,connection,to,the,given,node,on,the,given,remote,cluster,throws,illegal,argument,exception,if,the,remote,cluster,is,unknown;public,transport,connection,get,connection,discovery,node,node,string,cluster,return,get,remote,cluster,connection,cluster,get,connection,node
RemoteClusterService -> public Transport.Connection getConnection(DiscoveryNode node, String cluster);1541698679;Returns a connection to the given node on the given remote cluster_@throws IllegalArgumentException if the remote cluster is unknown;public Transport.Connection getConnection(DiscoveryNode node, String cluster) {_        return getRemoteClusterConnection(cluster).getConnection(node)__    };returns,a,connection,to,the,given,node,on,the,given,remote,cluster,throws,illegal,argument,exception,if,the,remote,cluster,is,unknown;public,transport,connection,get,connection,discovery,node,node,string,cluster,return,get,remote,cluster,connection,cluster,get,connection,node
RemoteClusterService -> public Transport.Connection getConnection(DiscoveryNode node, String cluster);1542402632;Returns a connection to the given node on the given remote cluster_@throws IllegalArgumentException if the remote cluster is unknown;public Transport.Connection getConnection(DiscoveryNode node, String cluster) {_        return getRemoteClusterConnection(cluster).getConnection(node)__    };returns,a,connection,to,the,given,node,on,the,given,remote,cluster,throws,illegal,argument,exception,if,the,remote,cluster,is,unknown;public,transport,connection,get,connection,discovery,node,node,string,cluster,return,get,remote,cluster,connection,cluster,get,connection,node
RemoteClusterService -> public Transport.Connection getConnection(DiscoveryNode node, String cluster);1543506953;Returns a connection to the given node on the given remote cluster_@throws IllegalArgumentException if the remote cluster is unknown;public Transport.Connection getConnection(DiscoveryNode node, String cluster) {_        return getRemoteClusterConnection(cluster).getConnection(node)__    };returns,a,connection,to,the,given,node,on,the,given,remote,cluster,throws,illegal,argument,exception,if,the,remote,cluster,is,unknown;public,transport,connection,get,connection,discovery,node,node,string,cluster,return,get,remote,cluster,connection,cluster,get,connection,node
RemoteClusterService -> public Transport.Connection getConnection(DiscoveryNode node, String cluster);1543959410;Returns a connection to the given node on the given remote cluster_@throws IllegalArgumentException if the remote cluster is unknown;public Transport.Connection getConnection(DiscoveryNode node, String cluster) {_        return getRemoteClusterConnection(cluster).getConnection(node)__    };returns,a,connection,to,the,given,node,on,the,given,remote,cluster,throws,illegal,argument,exception,if,the,remote,cluster,is,unknown;public,transport,connection,get,connection,discovery,node,node,string,cluster,return,get,remote,cluster,connection,cluster,get,connection,node
RemoteClusterService -> public Transport.Connection getConnection(DiscoveryNode node, String cluster);1544823664;Returns a connection to the given node on the given remote cluster_@throws IllegalArgumentException if the remote cluster is unknown;public Transport.Connection getConnection(DiscoveryNode node, String cluster) {_        return getRemoteClusterConnection(cluster).getConnection(node)__    };returns,a,connection,to,the,given,node,on,the,given,remote,cluster,throws,illegal,argument,exception,if,the,remote,cluster,is,unknown;public,transport,connection,get,connection,discovery,node,node,string,cluster,return,get,remote,cluster,connection,cluster,get,connection,node
RemoteClusterService -> public Transport.Connection getConnection(DiscoveryNode node, String cluster);1545071071;Returns a connection to the given node on the given remote cluster_@throws IllegalArgumentException if the remote cluster is unknown;public Transport.Connection getConnection(DiscoveryNode node, String cluster) {_        return getRemoteClusterConnection(cluster).getConnection(node)__    };returns,a,connection,to,the,given,node,on,the,given,remote,cluster,throws,illegal,argument,exception,if,the,remote,cluster,is,unknown;public,transport,connection,get,connection,discovery,node,node,string,cluster,return,get,remote,cluster,connection,cluster,get,connection,node
RemoteClusterService -> public Transport.Connection getConnection(DiscoveryNode node, String cluster);1546929322;Returns a connection to the given node on the given remote cluster_@throws IllegalArgumentException if the remote cluster is unknown;public Transport.Connection getConnection(DiscoveryNode node, String cluster) {_        return getRemoteClusterConnection(cluster).getConnection(node)__    };returns,a,connection,to,the,given,node,on,the,given,remote,cluster,throws,illegal,argument,exception,if,the,remote,cluster,is,unknown;public,transport,connection,get,connection,discovery,node,node,string,cluster,return,get,remote,cluster,connection,cluster,get,connection,node
RemoteClusterService -> public Transport.Connection getConnection(DiscoveryNode node, String cluster);1547561945;Returns a connection to the given node on the given remote cluster_@throws IllegalArgumentException if the remote cluster is unknown;public Transport.Connection getConnection(DiscoveryNode node, String cluster) {_        return getRemoteClusterConnection(cluster).getConnection(node)__    };returns,a,connection,to,the,given,node,on,the,given,remote,cluster,throws,illegal,argument,exception,if,the,remote,cluster,is,unknown;public,transport,connection,get,connection,discovery,node,node,string,cluster,return,get,remote,cluster,connection,cluster,get,connection,node
RemoteClusterService -> public Transport.Connection getConnection(DiscoveryNode node, String cluster);1548248017;Returns a connection to the given node on the given remote cluster_@throws IllegalArgumentException if the remote cluster is unknown;public Transport.Connection getConnection(DiscoveryNode node, String cluster) {_        return getRemoteClusterConnection(cluster).getConnection(node)__    };returns,a,connection,to,the,given,node,on,the,given,remote,cluster,throws,illegal,argument,exception,if,the,remote,cluster,is,unknown;public,transport,connection,get,connection,discovery,node,node,string,cluster,return,get,remote,cluster,connection,cluster,get,connection,node
RemoteClusterService -> public Transport.Connection getConnection(DiscoveryNode node, String cluster);1548402798;Returns a connection to the given node on the given remote cluster_@throws IllegalArgumentException if the remote cluster is unknown;public Transport.Connection getConnection(DiscoveryNode node, String cluster) {_        return getRemoteClusterConnection(cluster).getConnection(node)__    };returns,a,connection,to,the,given,node,on,the,given,remote,cluster,throws,illegal,argument,exception,if,the,remote,cluster,is,unknown;public,transport,connection,get,connection,discovery,node,node,string,cluster,return,get,remote,cluster,connection,cluster,get,connection,node
RemoteClusterService -> public Transport.Connection getConnection(DiscoveryNode node, String cluster);1549608646;Returns a connection to the given node on the given remote cluster_@throws IllegalArgumentException if the remote cluster is unknown;public Transport.Connection getConnection(DiscoveryNode node, String cluster) {_        return getRemoteClusterConnection(cluster).getConnection(node)__    };returns,a,connection,to,the,given,node,on,the,given,remote,cluster,throws,illegal,argument,exception,if,the,remote,cluster,is,unknown;public,transport,connection,get,connection,discovery,node,node,string,cluster,return,get,remote,cluster,connection,cluster,get,connection,node
RemoteClusterService -> public Transport.Connection getConnection(DiscoveryNode node, String cluster);1550601141;Returns a connection to the given node on the given remote cluster_@throws IllegalArgumentException if the remote cluster is unknown;public Transport.Connection getConnection(DiscoveryNode node, String cluster) {_        return getRemoteClusterConnection(cluster).getConnection(node)__    };returns,a,connection,to,the,given,node,on,the,given,remote,cluster,throws,illegal,argument,exception,if,the,remote,cluster,is,unknown;public,transport,connection,get,connection,discovery,node,node,string,cluster,return,get,remote,cluster,connection,cluster,get,connection,node
RemoteClusterService -> private synchronized void updateRemoteClusters(Map<String, List<Supplier<DiscoveryNode>>> seeds,         ActionListener<Void> connectionListener);1534755962;This method updates the list of remote clusters. It's intended to be used as an update consumer on the settings infrastructure_@param seeds a cluster alias to discovery node mapping representing the remote clusters seeds nodes_@param connectionListener a listener invoked once every configured cluster has been connected to;private synchronized void updateRemoteClusters(Map<String, List<Supplier<DiscoveryNode>>> seeds,_        ActionListener<Void> connectionListener) {_        if (seeds.containsKey(LOCAL_CLUSTER_GROUP_KEY)) {_            throw new IllegalArgumentException("remote clusters must not have the empty string as its key")__        }_        Map<String, RemoteClusterConnection> remoteClusters = new HashMap<>()__        if (seeds.isEmpty()) {_            connectionListener.onResponse(null)__        } else {_            CountDown countDown = new CountDown(seeds.size())__            remoteClusters.putAll(this.remoteClusters)__            for (Map.Entry<String, List<Supplier<DiscoveryNode>>> entry : seeds.entrySet()) {_                RemoteClusterConnection remote = this.remoteClusters.get(entry.getKey())__                if (entry.getValue().isEmpty()) { _                    try {_                        IOUtils.close(remote)__                    } catch (IOException e) {_                        logger.warn("failed to close remote cluster connections for cluster: " + entry.getKey(), e)__                    }_                    remoteClusters.remove(entry.getKey())__                    continue__                }__                if (remote == null) { _                    remote = new RemoteClusterConnection(settings, entry.getKey(), entry.getValue(), transportService, numRemoteConnections,_                        getNodePredicate(settings))__                    remoteClusters.put(entry.getKey(), remote)__                }__                _                RemoteClusterConnection finalRemote = remote__                remote.updateSeedNodes(entry.getValue(), ActionListener.wrap(_                    response -> {_                        if (countDown.countDown()) {_                            connectionListener.onResponse(response)__                        }_                    },_                    exception -> {_                        if (countDown.fastForward()) {_                            connectionListener.onFailure(exception)__                        }_                        if (finalRemote.isClosed() == false) {_                            logger.warn("failed to update seed list for cluster: " + entry.getKey(), exception)__                        }_                    }))__            }_        }_        this.remoteClusters = Collections.unmodifiableMap(remoteClusters)__    };this,method,updates,the,list,of,remote,clusters,it,s,intended,to,be,used,as,an,update,consumer,on,the,settings,infrastructure,param,seeds,a,cluster,alias,to,discovery,node,mapping,representing,the,remote,clusters,seeds,nodes,param,connection,listener,a,listener,invoked,once,every,configured,cluster,has,been,connected,to;private,synchronized,void,update,remote,clusters,map,string,list,supplier,discovery,node,seeds,action,listener,void,connection,listener,if,seeds,contains,key,throw,new,illegal,argument,exception,remote,clusters,must,not,have,the,empty,string,as,its,key,map,string,remote,cluster,connection,remote,clusters,new,hash,map,if,seeds,is,empty,connection,listener,on,response,null,else,count,down,count,down,new,count,down,seeds,size,remote,clusters,put,all,this,remote,clusters,for,map,entry,string,list,supplier,discovery,node,entry,seeds,entry,set,remote,cluster,connection,remote,this,remote,clusters,get,entry,get,key,if,entry,get,value,is,empty,try,ioutils,close,remote,catch,ioexception,e,logger,warn,failed,to,close,remote,cluster,connections,for,cluster,entry,get,key,e,remote,clusters,remove,entry,get,key,continue,if,remote,null,remote,new,remote,cluster,connection,settings,entry,get,key,entry,get,value,transport,service,num,remote,connections,get,node,predicate,settings,remote,clusters,put,entry,get,key,remote,remote,cluster,connection,final,remote,remote,remote,update,seed,nodes,entry,get,value,action,listener,wrap,response,if,count,down,count,down,connection,listener,on,response,response,exception,if,count,down,fast,forward,connection,listener,on,failure,exception,if,final,remote,is,closed,false,logger,warn,failed,to,update,seed,list,for,cluster,entry,get,key,exception,this,remote,clusters,collections,unmodifiable,map,remote,clusters
RemoteClusterService -> private synchronized void updateRemoteClusters(Map<String, List<Supplier<DiscoveryNode>>> seeds,         ActionListener<Void> connectionListener);1535046779;This method updates the list of remote clusters. It's intended to be used as an update consumer on the settings infrastructure_@param seeds a cluster alias to discovery node mapping representing the remote clusters seeds nodes_@param connectionListener a listener invoked once every configured cluster has been connected to;private synchronized void updateRemoteClusters(Map<String, List<Supplier<DiscoveryNode>>> seeds,_        ActionListener<Void> connectionListener) {_        if (seeds.containsKey(LOCAL_CLUSTER_GROUP_KEY)) {_            throw new IllegalArgumentException("remote clusters must not have the empty string as its key")__        }_        Map<String, RemoteClusterConnection> remoteClusters = new HashMap<>()__        if (seeds.isEmpty()) {_            connectionListener.onResponse(null)__        } else {_            CountDown countDown = new CountDown(seeds.size())__            remoteClusters.putAll(this.remoteClusters)__            for (Map.Entry<String, List<Supplier<DiscoveryNode>>> entry : seeds.entrySet()) {_                RemoteClusterConnection remote = this.remoteClusters.get(entry.getKey())__                if (entry.getValue().isEmpty()) { _                    try {_                        IOUtils.close(remote)__                    } catch (IOException e) {_                        logger.warn("failed to close remote cluster connections for cluster: " + entry.getKey(), e)__                    }_                    remoteClusters.remove(entry.getKey())__                    continue__                }__                if (remote == null) { _                    remote = new RemoteClusterConnection(settings, entry.getKey(), entry.getValue(), transportService,_                        new ConnectionManager(settings, transportService.transport, transportService.threadPool), numRemoteConnections,_                        getNodePredicate(settings))__                    remoteClusters.put(entry.getKey(), remote)__                }__                _                RemoteClusterConnection finalRemote = remote__                remote.updateSeedNodes(entry.getValue(), ActionListener.wrap(_                    response -> {_                        if (countDown.countDown()) {_                            connectionListener.onResponse(response)__                        }_                    },_                    exception -> {_                        if (countDown.fastForward()) {_                            connectionListener.onFailure(exception)__                        }_                        if (finalRemote.isClosed() == false) {_                            logger.warn("failed to update seed list for cluster: " + entry.getKey(), exception)__                        }_                    }))__            }_        }_        this.remoteClusters = Collections.unmodifiableMap(remoteClusters)__    };this,method,updates,the,list,of,remote,clusters,it,s,intended,to,be,used,as,an,update,consumer,on,the,settings,infrastructure,param,seeds,a,cluster,alias,to,discovery,node,mapping,representing,the,remote,clusters,seeds,nodes,param,connection,listener,a,listener,invoked,once,every,configured,cluster,has,been,connected,to;private,synchronized,void,update,remote,clusters,map,string,list,supplier,discovery,node,seeds,action,listener,void,connection,listener,if,seeds,contains,key,throw,new,illegal,argument,exception,remote,clusters,must,not,have,the,empty,string,as,its,key,map,string,remote,cluster,connection,remote,clusters,new,hash,map,if,seeds,is,empty,connection,listener,on,response,null,else,count,down,count,down,new,count,down,seeds,size,remote,clusters,put,all,this,remote,clusters,for,map,entry,string,list,supplier,discovery,node,entry,seeds,entry,set,remote,cluster,connection,remote,this,remote,clusters,get,entry,get,key,if,entry,get,value,is,empty,try,ioutils,close,remote,catch,ioexception,e,logger,warn,failed,to,close,remote,cluster,connections,for,cluster,entry,get,key,e,remote,clusters,remove,entry,get,key,continue,if,remote,null,remote,new,remote,cluster,connection,settings,entry,get,key,entry,get,value,transport,service,new,connection,manager,settings,transport,service,transport,transport,service,thread,pool,num,remote,connections,get,node,predicate,settings,remote,clusters,put,entry,get,key,remote,remote,cluster,connection,final,remote,remote,remote,update,seed,nodes,entry,get,value,action,listener,wrap,response,if,count,down,count,down,connection,listener,on,response,response,exception,if,count,down,fast,forward,connection,listener,on,failure,exception,if,final,remote,is,closed,false,logger,warn,failed,to,update,seed,list,for,cluster,entry,get,key,exception,this,remote,clusters,collections,unmodifiable,map,remote,clusters
RemoteClusterService -> public Set<String> getRegisteredRemoteClusterNames();1547561945;Returns the registered remote cluster names.;public Set<String> getRegisteredRemoteClusterNames() {_        _        return remoteClusters.keySet()__    };returns,the,registered,remote,cluster,names;public,set,string,get,registered,remote,cluster,names,return,remote,clusters,key,set
RemoteClusterService -> public Set<String> getRegisteredRemoteClusterNames();1548248017;Returns the registered remote cluster names.;public Set<String> getRegisteredRemoteClusterNames() {_        _        return remoteClusters.keySet()__    };returns,the,registered,remote,cluster,names;public,set,string,get,registered,remote,cluster,names,return,remote,clusters,key,set
RemoteClusterService -> public Set<String> getRegisteredRemoteClusterNames();1548402798;Returns the registered remote cluster names.;public Set<String> getRegisteredRemoteClusterNames() {_        _        return remoteClusters.keySet()__    };returns,the,registered,remote,cluster,names;public,set,string,get,registered,remote,cluster,names,return,remote,clusters,key,set
RemoteClusterService -> public Set<String> getRegisteredRemoteClusterNames();1549608646;Returns the registered remote cluster names.;public Set<String> getRegisteredRemoteClusterNames() {_        _        return remoteClusters.keySet()__    };returns,the,registered,remote,cluster,names;public,set,string,get,registered,remote,cluster,names,return,remote,clusters,key,set
RemoteClusterService -> public Set<String> getRegisteredRemoteClusterNames();1550601141;Returns the registered remote cluster names.;public Set<String> getRegisteredRemoteClusterNames() {_        _        return remoteClusters.keySet()__    };returns,the,registered,remote,cluster,names;public,set,string,get,registered,remote,cluster,names,return,remote,clusters,key,set
RemoteClusterService -> public void ensureConnected(String clusterAlias, ActionListener<Void> listener);1524684173;Ensures that the given cluster alias is connected. If the cluster is connected this operation_will invoke the listener immediately.;public void ensureConnected(String clusterAlias, ActionListener<Void> listener) {_        RemoteClusterConnection remoteClusterConnection = remoteClusters.get(clusterAlias)__        if (remoteClusterConnection == null) {_            throw new IllegalArgumentException("no such remote cluster: " + clusterAlias)__        }_        remoteClusterConnection.ensureConnected(listener)__    };ensures,that,the,given,cluster,alias,is,connected,if,the,cluster,is,connected,this,operation,will,invoke,the,listener,immediately;public,void,ensure,connected,string,cluster,alias,action,listener,void,listener,remote,cluster,connection,remote,cluster,connection,remote,clusters,get,cluster,alias,if,remote,cluster,connection,null,throw,new,illegal,argument,exception,no,such,remote,cluster,cluster,alias,remote,cluster,connection,ensure,connected,listener
RemoteClusterService -> public void ensureConnected(String clusterAlias, ActionListener<Void> listener);1525076988;Ensures that the given cluster alias is connected. If the cluster is connected this operation_will invoke the listener immediately.;public void ensureConnected(String clusterAlias, ActionListener<Void> listener) {_        RemoteClusterConnection remoteClusterConnection = remoteClusters.get(clusterAlias)__        if (remoteClusterConnection == null) {_            throw new IllegalArgumentException("no such remote cluster: " + clusterAlias)__        }_        remoteClusterConnection.ensureConnected(listener)__    };ensures,that,the,given,cluster,alias,is,connected,if,the,cluster,is,connected,this,operation,will,invoke,the,listener,immediately;public,void,ensure,connected,string,cluster,alias,action,listener,void,listener,remote,cluster,connection,remote,cluster,connection,remote,clusters,get,cluster,alias,if,remote,cluster,connection,null,throw,new,illegal,argument,exception,no,such,remote,cluster,cluster,alias,remote,cluster,connection,ensure,connected,listener
RemoteClusterService -> public void ensureConnected(String clusterAlias, ActionListener<Void> listener);1525334055;Ensures that the given cluster alias is connected. If the cluster is connected this operation_will invoke the listener immediately.;public void ensureConnected(String clusterAlias, ActionListener<Void> listener) {_        RemoteClusterConnection remoteClusterConnection = remoteClusters.get(clusterAlias)__        if (remoteClusterConnection == null) {_            throw new IllegalArgumentException("no such remote cluster: " + clusterAlias)__        }_        remoteClusterConnection.ensureConnected(listener)__    };ensures,that,the,given,cluster,alias,is,connected,if,the,cluster,is,connected,this,operation,will,invoke,the,listener,immediately;public,void,ensure,connected,string,cluster,alias,action,listener,void,listener,remote,cluster,connection,remote,cluster,connection,remote,clusters,get,cluster,alias,if,remote,cluster,connection,null,throw,new,illegal,argument,exception,no,such,remote,cluster,cluster,alias,remote,cluster,connection,ensure,connected,listener
RemoteClusterService -> public void ensureConnected(String clusterAlias, ActionListener<Void> listener);1527773340;Ensures that the given cluster alias is connected. If the cluster is connected this operation_will invoke the listener immediately.;public void ensureConnected(String clusterAlias, ActionListener<Void> listener) {_        RemoteClusterConnection remoteClusterConnection = remoteClusters.get(clusterAlias)__        if (remoteClusterConnection == null) {_            throw new IllegalArgumentException("no such remote cluster: " + clusterAlias)__        }_        remoteClusterConnection.ensureConnected(listener)__    };ensures,that,the,given,cluster,alias,is,connected,if,the,cluster,is,connected,this,operation,will,invoke,the,listener,immediately;public,void,ensure,connected,string,cluster,alias,action,listener,void,listener,remote,cluster,connection,remote,cluster,connection,remote,clusters,get,cluster,alias,if,remote,cluster,connection,null,throw,new,illegal,argument,exception,no,such,remote,cluster,cluster,alias,remote,cluster,connection,ensure,connected,listener
RemoteClusterService -> public void ensureConnected(String clusterAlias, ActionListener<Void> listener);1527840262;Ensures that the given cluster alias is connected. If the cluster is connected this operation_will invoke the listener immediately.;public void ensureConnected(String clusterAlias, ActionListener<Void> listener) {_        RemoteClusterConnection remoteClusterConnection = remoteClusters.get(clusterAlias)__        if (remoteClusterConnection == null) {_            throw new IllegalArgumentException("no such remote cluster: " + clusterAlias)__        }_        remoteClusterConnection.ensureConnected(listener)__    };ensures,that,the,given,cluster,alias,is,connected,if,the,cluster,is,connected,this,operation,will,invoke,the,listener,immediately;public,void,ensure,connected,string,cluster,alias,action,listener,void,listener,remote,cluster,connection,remote,cluster,connection,remote,clusters,get,cluster,alias,if,remote,cluster,connection,null,throw,new,illegal,argument,exception,no,such,remote,cluster,cluster,alias,remote,cluster,connection,ensure,connected,listener
RemoteClusterService -> public void ensureConnected(String clusterAlias, ActionListener<Void> listener);1534755962;Ensures that the given cluster alias is connected. If the cluster is connected this operation_will invoke the listener immediately.;public void ensureConnected(String clusterAlias, ActionListener<Void> listener) {_        RemoteClusterConnection remoteClusterConnection = remoteClusters.get(clusterAlias)__        if (remoteClusterConnection == null) {_            throw new IllegalArgumentException("no such remote cluster: " + clusterAlias)__        }_        remoteClusterConnection.ensureConnected(listener)__    };ensures,that,the,given,cluster,alias,is,connected,if,the,cluster,is,connected,this,operation,will,invoke,the,listener,immediately;public,void,ensure,connected,string,cluster,alias,action,listener,void,listener,remote,cluster,connection,remote,cluster,connection,remote,clusters,get,cluster,alias,if,remote,cluster,connection,null,throw,new,illegal,argument,exception,no,such,remote,cluster,cluster,alias,remote,cluster,connection,ensure,connected,listener
RemoteClusterService -> public void ensureConnected(String clusterAlias, ActionListener<Void> listener);1535046779;Ensures that the given cluster alias is connected. If the cluster is connected this operation_will invoke the listener immediately.;public void ensureConnected(String clusterAlias, ActionListener<Void> listener) {_        RemoteClusterConnection remoteClusterConnection = remoteClusters.get(clusterAlias)__        if (remoteClusterConnection == null) {_            throw new IllegalArgumentException("no such remote cluster: " + clusterAlias)__        }_        remoteClusterConnection.ensureConnected(listener)__    };ensures,that,the,given,cluster,alias,is,connected,if,the,cluster,is,connected,this,operation,will,invoke,the,listener,immediately;public,void,ensure,connected,string,cluster,alias,action,listener,void,listener,remote,cluster,connection,remote,cluster,connection,remote,clusters,get,cluster,alias,if,remote,cluster,connection,null,throw,new,illegal,argument,exception,no,such,remote,cluster,cluster,alias,remote,cluster,connection,ensure,connected,listener
RemoteClusterService -> public void ensureConnected(String clusterAlias, ActionListener<Void> listener);1535383145;Ensures that the given cluster alias is connected. If the cluster is connected this operation_will invoke the listener immediately.;public void ensureConnected(String clusterAlias, ActionListener<Void> listener) {_        RemoteClusterConnection remoteClusterConnection = remoteClusters.get(clusterAlias)__        if (remoteClusterConnection == null) {_            throw new IllegalArgumentException("no such remote cluster: " + clusterAlias)__        }_        remoteClusterConnection.ensureConnected(listener)__    };ensures,that,the,given,cluster,alias,is,connected,if,the,cluster,is,connected,this,operation,will,invoke,the,listener,immediately;public,void,ensure,connected,string,cluster,alias,action,listener,void,listener,remote,cluster,connection,remote,cluster,connection,remote,clusters,get,cluster,alias,if,remote,cluster,connection,null,throw,new,illegal,argument,exception,no,such,remote,cluster,cluster,alias,remote,cluster,connection,ensure,connected,listener
RemoteClusterService -> public void ensureConnected(String clusterAlias, ActionListener<Void> listener);1536218260;Ensures that the given cluster alias is connected. If the cluster is connected this operation_will invoke the listener immediately.;public void ensureConnected(String clusterAlias, ActionListener<Void> listener) {_        RemoteClusterConnection remoteClusterConnection = remoteClusters.get(clusterAlias)__        if (remoteClusterConnection == null) {_            throw new IllegalArgumentException("no such remote cluster: " + clusterAlias)__        }_        remoteClusterConnection.ensureConnected(listener)__    };ensures,that,the,given,cluster,alias,is,connected,if,the,cluster,is,connected,this,operation,will,invoke,the,listener,immediately;public,void,ensure,connected,string,cluster,alias,action,listener,void,listener,remote,cluster,connection,remote,cluster,connection,remote,clusters,get,cluster,alias,if,remote,cluster,connection,null,throw,new,illegal,argument,exception,no,such,remote,cluster,cluster,alias,remote,cluster,connection,ensure,connected,listener
RemoteClusterService -> public void ensureConnected(String clusterAlias, ActionListener<Void> listener);1536828374;Ensures that the given cluster alias is connected. If the cluster is connected this operation_will invoke the listener immediately.;public void ensureConnected(String clusterAlias, ActionListener<Void> listener) {_        RemoteClusterConnection remoteClusterConnection = remoteClusters.get(clusterAlias)__        if (remoteClusterConnection == null) {_            throw new IllegalArgumentException("no such remote cluster: " + clusterAlias)__        }_        remoteClusterConnection.ensureConnected(listener)__    };ensures,that,the,given,cluster,alias,is,connected,if,the,cluster,is,connected,this,operation,will,invoke,the,listener,immediately;public,void,ensure,connected,string,cluster,alias,action,listener,void,listener,remote,cluster,connection,remote,cluster,connection,remote,clusters,get,cluster,alias,if,remote,cluster,connection,null,throw,new,illegal,argument,exception,no,such,remote,cluster,cluster,alias,remote,cluster,connection,ensure,connected,listener
RemoteClusterService -> public void ensureConnected(String clusterAlias, ActionListener<Void> listener);1537806831;Ensures that the given cluster alias is connected. If the cluster is connected this operation_will invoke the listener immediately.;public void ensureConnected(String clusterAlias, ActionListener<Void> listener) {_        RemoteClusterConnection remoteClusterConnection = remoteClusters.get(clusterAlias)__        if (remoteClusterConnection == null) {_            throw new IllegalArgumentException("no such remote cluster: " + clusterAlias)__        }_        remoteClusterConnection.ensureConnected(listener)__    };ensures,that,the,given,cluster,alias,is,connected,if,the,cluster,is,connected,this,operation,will,invoke,the,listener,immediately;public,void,ensure,connected,string,cluster,alias,action,listener,void,listener,remote,cluster,connection,remote,cluster,connection,remote,clusters,get,cluster,alias,if,remote,cluster,connection,null,throw,new,illegal,argument,exception,no,such,remote,cluster,cluster,alias,remote,cluster,connection,ensure,connected,listener
RemoteClusterService -> private synchronized void updateRemoteClusters(Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> seeds,                                                    ActionListener<Void> connectionListener);1535383145;This method updates the list of remote clusters. It's intended to be used as an update consumer on the settings infrastructure_@param seeds a cluster alias to discovery node mapping representing the remote clusters seeds nodes_@param connectionListener a listener invoked once every configured cluster has been connected to;private synchronized void updateRemoteClusters(Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> seeds,_                                                   ActionListener<Void> connectionListener) {_        if (seeds.containsKey(LOCAL_CLUSTER_GROUP_KEY)) {_            throw new IllegalArgumentException("remote clusters must not have the empty string as its key")__        }_        Map<String, RemoteClusterConnection> remoteClusters = new HashMap<>()__        if (seeds.isEmpty()) {_            connectionListener.onResponse(null)__        } else {_            CountDown countDown = new CountDown(seeds.size())__            remoteClusters.putAll(this.remoteClusters)__            for (Map.Entry<String, Tuple<String, List<Supplier<DiscoveryNode>>>> entry : seeds.entrySet()) {_                List<Supplier<DiscoveryNode>> seedList = entry.getValue().v2()__                String proxyAddress = entry.getValue().v1()___                RemoteClusterConnection remote = this.remoteClusters.get(entry.getKey())__                if (seedList.isEmpty()) { _                    try {_                        IOUtils.close(remote)__                    } catch (IOException e) {_                        logger.warn("failed to close remote cluster connections for cluster: " + entry.getKey(), e)__                    }_                    remoteClusters.remove(entry.getKey())__                    continue__                }__                if (remote == null) { _                    remote = new RemoteClusterConnection(settings, entry.getKey(), seedList, transportService,_                        new ConnectionManager(settings, transportService.transport, transportService.threadPool), numRemoteConnections,_                        getNodePredicate(settings), proxyAddress)__                    remoteClusters.put(entry.getKey(), remote)__                }__                _                RemoteClusterConnection finalRemote = remote__                remote.updateSeedNodes(proxyAddress, seedList, ActionListener.wrap(_                    response -> {_                        if (countDown.countDown()) {_                            connectionListener.onResponse(response)__                        }_                    },_                    exception -> {_                        if (countDown.fastForward()) {_                            connectionListener.onFailure(exception)__                        }_                        if (finalRemote.isClosed() == false) {_                            logger.warn("failed to update seed list for cluster: " + entry.getKey(), exception)__                        }_                    }))__            }_        }_        this.remoteClusters = Collections.unmodifiableMap(remoteClusters)__    };this,method,updates,the,list,of,remote,clusters,it,s,intended,to,be,used,as,an,update,consumer,on,the,settings,infrastructure,param,seeds,a,cluster,alias,to,discovery,node,mapping,representing,the,remote,clusters,seeds,nodes,param,connection,listener,a,listener,invoked,once,every,configured,cluster,has,been,connected,to;private,synchronized,void,update,remote,clusters,map,string,tuple,string,list,supplier,discovery,node,seeds,action,listener,void,connection,listener,if,seeds,contains,key,throw,new,illegal,argument,exception,remote,clusters,must,not,have,the,empty,string,as,its,key,map,string,remote,cluster,connection,remote,clusters,new,hash,map,if,seeds,is,empty,connection,listener,on,response,null,else,count,down,count,down,new,count,down,seeds,size,remote,clusters,put,all,this,remote,clusters,for,map,entry,string,tuple,string,list,supplier,discovery,node,entry,seeds,entry,set,list,supplier,discovery,node,seed,list,entry,get,value,v2,string,proxy,address,entry,get,value,v1,remote,cluster,connection,remote,this,remote,clusters,get,entry,get,key,if,seed,list,is,empty,try,ioutils,close,remote,catch,ioexception,e,logger,warn,failed,to,close,remote,cluster,connections,for,cluster,entry,get,key,e,remote,clusters,remove,entry,get,key,continue,if,remote,null,remote,new,remote,cluster,connection,settings,entry,get,key,seed,list,transport,service,new,connection,manager,settings,transport,service,transport,transport,service,thread,pool,num,remote,connections,get,node,predicate,settings,proxy,address,remote,clusters,put,entry,get,key,remote,remote,cluster,connection,final,remote,remote,remote,update,seed,nodes,proxy,address,seed,list,action,listener,wrap,response,if,count,down,count,down,connection,listener,on,response,response,exception,if,count,down,fast,forward,connection,listener,on,failure,exception,if,final,remote,is,closed,false,logger,warn,failed,to,update,seed,list,for,cluster,entry,get,key,exception,this,remote,clusters,collections,unmodifiable,map,remote,clusters
RemoteClusterService -> private synchronized void updateRemoteClusters(Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> seeds,                                                    ActionListener<Void> connectionListener);1536218260;This method updates the list of remote clusters. It's intended to be used as an update consumer on the settings infrastructure_@param seeds a cluster alias to discovery node mapping representing the remote clusters seeds nodes_@param connectionListener a listener invoked once every configured cluster has been connected to;private synchronized void updateRemoteClusters(Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> seeds,_                                                   ActionListener<Void> connectionListener) {_        if (seeds.containsKey(LOCAL_CLUSTER_GROUP_KEY)) {_            throw new IllegalArgumentException("remote clusters must not have the empty string as its key")__        }_        Map<String, RemoteClusterConnection> remoteClusters = new HashMap<>()__        if (seeds.isEmpty()) {_            connectionListener.onResponse(null)__        } else {_            CountDown countDown = new CountDown(seeds.size())__            remoteClusters.putAll(this.remoteClusters)__            for (Map.Entry<String, Tuple<String, List<Supplier<DiscoveryNode>>>> entry : seeds.entrySet()) {_                List<Supplier<DiscoveryNode>> seedList = entry.getValue().v2()__                String proxyAddress = entry.getValue().v1()___                RemoteClusterConnection remote = this.remoteClusters.get(entry.getKey())__                if (seedList.isEmpty()) { _                    try {_                        IOUtils.close(remote)__                    } catch (IOException e) {_                        logger.warn("failed to close remote cluster connections for cluster: " + entry.getKey(), e)__                    }_                    remoteClusters.remove(entry.getKey())__                    continue__                }__                if (remote == null) { _                    remote = new RemoteClusterConnection(settings, entry.getKey(), seedList, transportService,_                            new ConnectionManager(settings, transportService.transport, transportService.threadPool), numRemoteConnections,_                            getNodePredicate(settings), proxyAddress)__                    remoteClusters.put(entry.getKey(), remote)__                }__                _                RemoteClusterConnection finalRemote = remote__                remote.updateSeedNodes(proxyAddress, seedList, ActionListener.wrap(_                        response -> {_                            if (countDown.countDown()) {_                                connectionListener.onResponse(response)__                            }_                        },_                        exception -> {_                            if (countDown.fastForward()) {_                                connectionListener.onFailure(exception)__                            }_                            if (finalRemote.isClosed() == false) {_                                logger.warn("failed to update seed list for cluster: " + entry.getKey(), exception)__                            }_                        }))__            }_        }_        this.remoteClusters = Collections.unmodifiableMap(remoteClusters)__    };this,method,updates,the,list,of,remote,clusters,it,s,intended,to,be,used,as,an,update,consumer,on,the,settings,infrastructure,param,seeds,a,cluster,alias,to,discovery,node,mapping,representing,the,remote,clusters,seeds,nodes,param,connection,listener,a,listener,invoked,once,every,configured,cluster,has,been,connected,to;private,synchronized,void,update,remote,clusters,map,string,tuple,string,list,supplier,discovery,node,seeds,action,listener,void,connection,listener,if,seeds,contains,key,throw,new,illegal,argument,exception,remote,clusters,must,not,have,the,empty,string,as,its,key,map,string,remote,cluster,connection,remote,clusters,new,hash,map,if,seeds,is,empty,connection,listener,on,response,null,else,count,down,count,down,new,count,down,seeds,size,remote,clusters,put,all,this,remote,clusters,for,map,entry,string,tuple,string,list,supplier,discovery,node,entry,seeds,entry,set,list,supplier,discovery,node,seed,list,entry,get,value,v2,string,proxy,address,entry,get,value,v1,remote,cluster,connection,remote,this,remote,clusters,get,entry,get,key,if,seed,list,is,empty,try,ioutils,close,remote,catch,ioexception,e,logger,warn,failed,to,close,remote,cluster,connections,for,cluster,entry,get,key,e,remote,clusters,remove,entry,get,key,continue,if,remote,null,remote,new,remote,cluster,connection,settings,entry,get,key,seed,list,transport,service,new,connection,manager,settings,transport,service,transport,transport,service,thread,pool,num,remote,connections,get,node,predicate,settings,proxy,address,remote,clusters,put,entry,get,key,remote,remote,cluster,connection,final,remote,remote,remote,update,seed,nodes,proxy,address,seed,list,action,listener,wrap,response,if,count,down,count,down,connection,listener,on,response,response,exception,if,count,down,fast,forward,connection,listener,on,failure,exception,if,final,remote,is,closed,false,logger,warn,failed,to,update,seed,list,for,cluster,entry,get,key,exception,this,remote,clusters,collections,unmodifiable,map,remote,clusters
RemoteClusterService -> private synchronized void updateRemoteClusters(Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> seeds,                                                    ActionListener<Void> connectionListener);1536828374;This method updates the list of remote clusters. It's intended to be used as an update consumer on the settings infrastructure_@param seeds a cluster alias to discovery node mapping representing the remote clusters seeds nodes_@param connectionListener a listener invoked once every configured cluster has been connected to;private synchronized void updateRemoteClusters(Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> seeds,_                                                   ActionListener<Void> connectionListener) {_        if (seeds.containsKey(LOCAL_CLUSTER_GROUP_KEY)) {_            throw new IllegalArgumentException("remote clusters must not have the empty string as its key")__        }_        Map<String, RemoteClusterConnection> remoteClusters = new HashMap<>()__        if (seeds.isEmpty()) {_            connectionListener.onResponse(null)__        } else {_            CountDown countDown = new CountDown(seeds.size())__            remoteClusters.putAll(this.remoteClusters)__            for (Map.Entry<String, Tuple<String, List<Supplier<DiscoveryNode>>>> entry : seeds.entrySet()) {_                List<Supplier<DiscoveryNode>> seedList = entry.getValue().v2()__                String proxyAddress = entry.getValue().v1()___                RemoteClusterConnection remote = this.remoteClusters.get(entry.getKey())__                if (seedList.isEmpty()) { _                    try {_                        IOUtils.close(remote)__                    } catch (IOException e) {_                        logger.warn("failed to close remote cluster connections for cluster: " + entry.getKey(), e)__                    }_                    remoteClusters.remove(entry.getKey())__                    continue__                }__                if (remote == null) { _                    remote = new RemoteClusterConnection(settings, entry.getKey(), seedList, transportService,_                            new ConnectionManager(settings, transportService.transport, transportService.threadPool), numRemoteConnections,_                            getNodePredicate(settings), proxyAddress)__                    remoteClusters.put(entry.getKey(), remote)__                }__                _                RemoteClusterConnection finalRemote = remote__                remote.updateSeedNodes(proxyAddress, seedList, ActionListener.wrap(_                        response -> {_                            if (countDown.countDown()) {_                                connectionListener.onResponse(response)__                            }_                        },_                        exception -> {_                            if (countDown.fastForward()) {_                                connectionListener.onFailure(exception)__                            }_                            if (finalRemote.isClosed() == false) {_                                logger.warn("failed to update seed list for cluster: " + entry.getKey(), exception)__                            }_                        }))__            }_        }_        this.remoteClusters = Collections.unmodifiableMap(remoteClusters)__    };this,method,updates,the,list,of,remote,clusters,it,s,intended,to,be,used,as,an,update,consumer,on,the,settings,infrastructure,param,seeds,a,cluster,alias,to,discovery,node,mapping,representing,the,remote,clusters,seeds,nodes,param,connection,listener,a,listener,invoked,once,every,configured,cluster,has,been,connected,to;private,synchronized,void,update,remote,clusters,map,string,tuple,string,list,supplier,discovery,node,seeds,action,listener,void,connection,listener,if,seeds,contains,key,throw,new,illegal,argument,exception,remote,clusters,must,not,have,the,empty,string,as,its,key,map,string,remote,cluster,connection,remote,clusters,new,hash,map,if,seeds,is,empty,connection,listener,on,response,null,else,count,down,count,down,new,count,down,seeds,size,remote,clusters,put,all,this,remote,clusters,for,map,entry,string,tuple,string,list,supplier,discovery,node,entry,seeds,entry,set,list,supplier,discovery,node,seed,list,entry,get,value,v2,string,proxy,address,entry,get,value,v1,remote,cluster,connection,remote,this,remote,clusters,get,entry,get,key,if,seed,list,is,empty,try,ioutils,close,remote,catch,ioexception,e,logger,warn,failed,to,close,remote,cluster,connections,for,cluster,entry,get,key,e,remote,clusters,remove,entry,get,key,continue,if,remote,null,remote,new,remote,cluster,connection,settings,entry,get,key,seed,list,transport,service,new,connection,manager,settings,transport,service,transport,transport,service,thread,pool,num,remote,connections,get,node,predicate,settings,proxy,address,remote,clusters,put,entry,get,key,remote,remote,cluster,connection,final,remote,remote,remote,update,seed,nodes,proxy,address,seed,list,action,listener,wrap,response,if,count,down,count,down,connection,listener,on,response,response,exception,if,count,down,fast,forward,connection,listener,on,failure,exception,if,final,remote,is,closed,false,logger,warn,failed,to,update,seed,list,for,cluster,entry,get,key,exception,this,remote,clusters,collections,unmodifiable,map,remote,clusters
RemoteClusterService -> private synchronized void updateRemoteClusters(Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> seeds,                                                    ActionListener<Void> connectionListener);1537806831;This method updates the list of remote clusters. It's intended to be used as an update consumer on the settings infrastructure_@param seeds a cluster alias to discovery node mapping representing the remote clusters seeds nodes_@param connectionListener a listener invoked once every configured cluster has been connected to;private synchronized void updateRemoteClusters(Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> seeds,_                                                   ActionListener<Void> connectionListener) {_        if (seeds.containsKey(LOCAL_CLUSTER_GROUP_KEY)) {_            throw new IllegalArgumentException("remote clusters must not have the empty string as its key")__        }_        Map<String, RemoteClusterConnection> remoteClusters = new HashMap<>()__        if (seeds.isEmpty()) {_            connectionListener.onResponse(null)__        } else {_            CountDown countDown = new CountDown(seeds.size())__            remoteClusters.putAll(this.remoteClusters)__            for (Map.Entry<String, Tuple<String, List<Supplier<DiscoveryNode>>>> entry : seeds.entrySet()) {_                List<Supplier<DiscoveryNode>> seedList = entry.getValue().v2()__                String proxyAddress = entry.getValue().v1()___                RemoteClusterConnection remote = this.remoteClusters.get(entry.getKey())__                if (seedList.isEmpty()) { _                    try {_                        IOUtils.close(remote)__                    } catch (IOException e) {_                        logger.warn("failed to close remote cluster connections for cluster: " + entry.getKey(), e)__                    }_                    remoteClusters.remove(entry.getKey())__                    continue__                }__                if (remote == null) { _                    remote = new RemoteClusterConnection(settings, entry.getKey(), seedList, transportService,_                            new ConnectionManager(settings, transportService.transport, transportService.threadPool), numRemoteConnections,_                            getNodePredicate(settings), proxyAddress)__                    remoteClusters.put(entry.getKey(), remote)__                }__                _                RemoteClusterConnection finalRemote = remote__                remote.updateSeedNodes(proxyAddress, seedList, ActionListener.wrap(_                        response -> {_                            if (countDown.countDown()) {_                                connectionListener.onResponse(response)__                            }_                        },_                        exception -> {_                            if (countDown.fastForward()) {_                                connectionListener.onFailure(exception)__                            }_                            if (finalRemote.isClosed() == false) {_                                logger.warn("failed to update seed list for cluster: " + entry.getKey(), exception)__                            }_                        }))__            }_        }_        this.remoteClusters = Collections.unmodifiableMap(remoteClusters)__    };this,method,updates,the,list,of,remote,clusters,it,s,intended,to,be,used,as,an,update,consumer,on,the,settings,infrastructure,param,seeds,a,cluster,alias,to,discovery,node,mapping,representing,the,remote,clusters,seeds,nodes,param,connection,listener,a,listener,invoked,once,every,configured,cluster,has,been,connected,to;private,synchronized,void,update,remote,clusters,map,string,tuple,string,list,supplier,discovery,node,seeds,action,listener,void,connection,listener,if,seeds,contains,key,throw,new,illegal,argument,exception,remote,clusters,must,not,have,the,empty,string,as,its,key,map,string,remote,cluster,connection,remote,clusters,new,hash,map,if,seeds,is,empty,connection,listener,on,response,null,else,count,down,count,down,new,count,down,seeds,size,remote,clusters,put,all,this,remote,clusters,for,map,entry,string,tuple,string,list,supplier,discovery,node,entry,seeds,entry,set,list,supplier,discovery,node,seed,list,entry,get,value,v2,string,proxy,address,entry,get,value,v1,remote,cluster,connection,remote,this,remote,clusters,get,entry,get,key,if,seed,list,is,empty,try,ioutils,close,remote,catch,ioexception,e,logger,warn,failed,to,close,remote,cluster,connections,for,cluster,entry,get,key,e,remote,clusters,remove,entry,get,key,continue,if,remote,null,remote,new,remote,cluster,connection,settings,entry,get,key,seed,list,transport,service,new,connection,manager,settings,transport,service,transport,transport,service,thread,pool,num,remote,connections,get,node,predicate,settings,proxy,address,remote,clusters,put,entry,get,key,remote,remote,cluster,connection,final,remote,remote,remote,update,seed,nodes,proxy,address,seed,list,action,listener,wrap,response,if,count,down,count,down,connection,listener,on,response,response,exception,if,count,down,fast,forward,connection,listener,on,failure,exception,if,final,remote,is,closed,false,logger,warn,failed,to,update,seed,list,for,cluster,entry,get,key,exception,this,remote,clusters,collections,unmodifiable,map,remote,clusters
RemoteClusterService -> private synchronized void updateRemoteClusters(Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> seeds,                                                    ActionListener<Void> connectionListener);1541008027;This method updates the list of remote clusters. It's intended to be used as an update consumer on the settings infrastructure_@param seeds a cluster alias to discovery node mapping representing the remote clusters seeds nodes_@param connectionListener a listener invoked once every configured cluster has been connected to;private synchronized void updateRemoteClusters(Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> seeds,_                                                   ActionListener<Void> connectionListener) {_        if (seeds.containsKey(LOCAL_CLUSTER_GROUP_KEY)) {_            throw new IllegalArgumentException("remote clusters must not have the empty string as its key")__        }_        Map<String, RemoteClusterConnection> remoteClusters = new HashMap<>()__        if (seeds.isEmpty()) {_            connectionListener.onResponse(null)__        } else {_            CountDown countDown = new CountDown(seeds.size())__            remoteClusters.putAll(this.remoteClusters)__            for (Map.Entry<String, Tuple<String, List<Supplier<DiscoveryNode>>>> entry : seeds.entrySet()) {_                List<Supplier<DiscoveryNode>> seedList = entry.getValue().v2()__                String proxyAddress = entry.getValue().v1()___                RemoteClusterConnection remote = this.remoteClusters.get(entry.getKey())__                if (seedList.isEmpty()) { _                    try {_                        IOUtils.close(remote)__                    } catch (IOException e) {_                        logger.warn("failed to close remote cluster connections for cluster: " + entry.getKey(), e)__                    }_                    remoteClusters.remove(entry.getKey())__                    continue__                }__                if (remote == null) { _                    String clusterAlias = entry.getKey()__                    TimeValue pingSchedule = REMOTE_CLUSTER_PING_SCHEDULE.getConcreteSettingForNamespace(clusterAlias).get(settings)__                    ConnectionManager connectionManager = new ConnectionManager(settings, transportService.transport,_                        transportService.threadPool, pingSchedule)__                    remote = new RemoteClusterConnection(settings, clusterAlias, seedList, transportService, connectionManager,_                        numRemoteConnections, getNodePredicate(settings), proxyAddress)__                    remoteClusters.put(clusterAlias, remote)__                }__                _                RemoteClusterConnection finalRemote = remote__                remote.updateSeedNodes(proxyAddress, seedList, ActionListener.wrap(_                        response -> {_                            if (countDown.countDown()) {_                                connectionListener.onResponse(response)__                            }_                        },_                        exception -> {_                            if (countDown.fastForward()) {_                                connectionListener.onFailure(exception)__                            }_                            if (finalRemote.isClosed() == false) {_                                logger.warn("failed to update seed list for cluster: " + entry.getKey(), exception)__                            }_                        }))__            }_        }_        this.remoteClusters = Collections.unmodifiableMap(remoteClusters)__    };this,method,updates,the,list,of,remote,clusters,it,s,intended,to,be,used,as,an,update,consumer,on,the,settings,infrastructure,param,seeds,a,cluster,alias,to,discovery,node,mapping,representing,the,remote,clusters,seeds,nodes,param,connection,listener,a,listener,invoked,once,every,configured,cluster,has,been,connected,to;private,synchronized,void,update,remote,clusters,map,string,tuple,string,list,supplier,discovery,node,seeds,action,listener,void,connection,listener,if,seeds,contains,key,throw,new,illegal,argument,exception,remote,clusters,must,not,have,the,empty,string,as,its,key,map,string,remote,cluster,connection,remote,clusters,new,hash,map,if,seeds,is,empty,connection,listener,on,response,null,else,count,down,count,down,new,count,down,seeds,size,remote,clusters,put,all,this,remote,clusters,for,map,entry,string,tuple,string,list,supplier,discovery,node,entry,seeds,entry,set,list,supplier,discovery,node,seed,list,entry,get,value,v2,string,proxy,address,entry,get,value,v1,remote,cluster,connection,remote,this,remote,clusters,get,entry,get,key,if,seed,list,is,empty,try,ioutils,close,remote,catch,ioexception,e,logger,warn,failed,to,close,remote,cluster,connections,for,cluster,entry,get,key,e,remote,clusters,remove,entry,get,key,continue,if,remote,null,string,cluster,alias,entry,get,key,time,value,ping,schedule,get,concrete,setting,for,namespace,cluster,alias,get,settings,connection,manager,connection,manager,new,connection,manager,settings,transport,service,transport,transport,service,thread,pool,ping,schedule,remote,new,remote,cluster,connection,settings,cluster,alias,seed,list,transport,service,connection,manager,num,remote,connections,get,node,predicate,settings,proxy,address,remote,clusters,put,cluster,alias,remote,remote,cluster,connection,final,remote,remote,remote,update,seed,nodes,proxy,address,seed,list,action,listener,wrap,response,if,count,down,count,down,connection,listener,on,response,response,exception,if,count,down,fast,forward,connection,listener,on,failure,exception,if,final,remote,is,closed,false,logger,warn,failed,to,update,seed,list,for,cluster,entry,get,key,exception,this,remote,clusters,collections,unmodifiable,map,remote,clusters
RemoteClusterService -> private synchronized void updateRemoteClusters(Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> seeds,                                                    ActionListener<Void> connectionListener);1541698679;This method updates the list of remote clusters. It's intended to be used as an update consumer on the settings infrastructure_@param seeds a cluster alias to discovery node mapping representing the remote clusters seeds nodes_@param connectionListener a listener invoked once every configured cluster has been connected to;private synchronized void updateRemoteClusters(Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> seeds,_                                                   ActionListener<Void> connectionListener) {_        if (seeds.containsKey(LOCAL_CLUSTER_GROUP_KEY)) {_            throw new IllegalArgumentException("remote clusters must not have the empty string as its key")__        }_        Map<String, RemoteClusterConnection> remoteClusters = new HashMap<>()__        if (seeds.isEmpty()) {_            connectionListener.onResponse(null)__        } else {_            CountDown countDown = new CountDown(seeds.size())__            remoteClusters.putAll(this.remoteClusters)__            for (Map.Entry<String, Tuple<String, List<Supplier<DiscoveryNode>>>> entry : seeds.entrySet()) {_                List<Supplier<DiscoveryNode>> seedList = entry.getValue().v2()__                String proxyAddress = entry.getValue().v1()___                RemoteClusterConnection remote = this.remoteClusters.get(entry.getKey())__                if (seedList.isEmpty()) { _                    try {_                        IOUtils.close(remote)__                    } catch (IOException e) {_                        logger.warn("failed to close remote cluster connections for cluster: " + entry.getKey(), e)__                    }_                    remoteClusters.remove(entry.getKey())__                    continue__                }__                if (remote == null) { _                    String clusterAlias = entry.getKey()__                    TimeValue pingSchedule = REMOTE_CLUSTER_PING_SCHEDULE.getConcreteSettingForNamespace(clusterAlias).get(settings)__                    ConnectionManager connectionManager = new ConnectionManager(settings, transportService.transport,_                        transportService.threadPool, pingSchedule)__                    remote = new RemoteClusterConnection(settings, clusterAlias, seedList, transportService, connectionManager,_                        numRemoteConnections, getNodePredicate(settings), proxyAddress)__                    remoteClusters.put(clusterAlias, remote)__                }__                _                RemoteClusterConnection finalRemote = remote__                remote.updateSeedNodes(proxyAddress, seedList, ActionListener.wrap(_                        response -> {_                            if (countDown.countDown()) {_                                connectionListener.onResponse(response)__                            }_                        },_                        exception -> {_                            if (countDown.fastForward()) {_                                connectionListener.onFailure(exception)__                            }_                            if (finalRemote.isClosed() == false) {_                                logger.warn("failed to update seed list for cluster: " + entry.getKey(), exception)__                            }_                        }))__            }_        }_        this.remoteClusters = Collections.unmodifiableMap(remoteClusters)__    };this,method,updates,the,list,of,remote,clusters,it,s,intended,to,be,used,as,an,update,consumer,on,the,settings,infrastructure,param,seeds,a,cluster,alias,to,discovery,node,mapping,representing,the,remote,clusters,seeds,nodes,param,connection,listener,a,listener,invoked,once,every,configured,cluster,has,been,connected,to;private,synchronized,void,update,remote,clusters,map,string,tuple,string,list,supplier,discovery,node,seeds,action,listener,void,connection,listener,if,seeds,contains,key,throw,new,illegal,argument,exception,remote,clusters,must,not,have,the,empty,string,as,its,key,map,string,remote,cluster,connection,remote,clusters,new,hash,map,if,seeds,is,empty,connection,listener,on,response,null,else,count,down,count,down,new,count,down,seeds,size,remote,clusters,put,all,this,remote,clusters,for,map,entry,string,tuple,string,list,supplier,discovery,node,entry,seeds,entry,set,list,supplier,discovery,node,seed,list,entry,get,value,v2,string,proxy,address,entry,get,value,v1,remote,cluster,connection,remote,this,remote,clusters,get,entry,get,key,if,seed,list,is,empty,try,ioutils,close,remote,catch,ioexception,e,logger,warn,failed,to,close,remote,cluster,connections,for,cluster,entry,get,key,e,remote,clusters,remove,entry,get,key,continue,if,remote,null,string,cluster,alias,entry,get,key,time,value,ping,schedule,get,concrete,setting,for,namespace,cluster,alias,get,settings,connection,manager,connection,manager,new,connection,manager,settings,transport,service,transport,transport,service,thread,pool,ping,schedule,remote,new,remote,cluster,connection,settings,cluster,alias,seed,list,transport,service,connection,manager,num,remote,connections,get,node,predicate,settings,proxy,address,remote,clusters,put,cluster,alias,remote,remote,cluster,connection,final,remote,remote,remote,update,seed,nodes,proxy,address,seed,list,action,listener,wrap,response,if,count,down,count,down,connection,listener,on,response,response,exception,if,count,down,fast,forward,connection,listener,on,failure,exception,if,final,remote,is,closed,false,logger,warn,failed,to,update,seed,list,for,cluster,entry,get,key,exception,this,remote,clusters,collections,unmodifiable,map,remote,clusters
RemoteClusterService -> private synchronized void updateRemoteClusters(Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> seeds,                                                    ActionListener<Void> connectionListener);1542402632;This method updates the list of remote clusters. It's intended to be used as an update consumer on the settings infrastructure_@param seeds a cluster alias to discovery node mapping representing the remote clusters seeds nodes_@param connectionListener a listener invoked once every configured cluster has been connected to;private synchronized void updateRemoteClusters(Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> seeds,_                                                   ActionListener<Void> connectionListener) {_        if (seeds.containsKey(LOCAL_CLUSTER_GROUP_KEY)) {_            throw new IllegalArgumentException("remote clusters must not have the empty string as its key")__        }_        Map<String, RemoteClusterConnection> remoteClusters = new HashMap<>()__        if (seeds.isEmpty()) {_            connectionListener.onResponse(null)__        } else {_            CountDown countDown = new CountDown(seeds.size())__            remoteClusters.putAll(this.remoteClusters)__            for (Map.Entry<String, Tuple<String, List<Supplier<DiscoveryNode>>>> entry : seeds.entrySet()) {_                List<Supplier<DiscoveryNode>> seedList = entry.getValue().v2()__                String proxyAddress = entry.getValue().v1()___                RemoteClusterConnection remote = this.remoteClusters.get(entry.getKey())__                if (seedList.isEmpty()) { _                    try {_                        IOUtils.close(remote)__                    } catch (IOException e) {_                        logger.warn("failed to close remote cluster connections for cluster: " + entry.getKey(), e)__                    }_                    remoteClusters.remove(entry.getKey())__                    continue__                }__                if (remote == null) { _                    String clusterAlias = entry.getKey()__                    TimeValue pingSchedule = REMOTE_CLUSTER_PING_SCHEDULE.getConcreteSettingForNamespace(clusterAlias).get(settings)__                    ConnectionManager connectionManager = new ConnectionManager(settings, transportService.transport,_                        transportService.threadPool, pingSchedule)__                    remote = new RemoteClusterConnection(settings, clusterAlias, seedList, transportService, connectionManager,_                        numRemoteConnections, getNodePredicate(settings), proxyAddress)__                    remoteClusters.put(clusterAlias, remote)__                }__                _                RemoteClusterConnection finalRemote = remote__                remote.updateSeedNodes(proxyAddress, seedList, ActionListener.wrap(_                        response -> {_                            if (countDown.countDown()) {_                                connectionListener.onResponse(response)__                            }_                        },_                        exception -> {_                            if (countDown.fastForward()) {_                                connectionListener.onFailure(exception)__                            }_                            if (finalRemote.isClosed() == false) {_                                logger.warn("failed to update seed list for cluster: " + entry.getKey(), exception)__                            }_                        }))__            }_        }_        this.remoteClusters = Collections.unmodifiableMap(remoteClusters)__    };this,method,updates,the,list,of,remote,clusters,it,s,intended,to,be,used,as,an,update,consumer,on,the,settings,infrastructure,param,seeds,a,cluster,alias,to,discovery,node,mapping,representing,the,remote,clusters,seeds,nodes,param,connection,listener,a,listener,invoked,once,every,configured,cluster,has,been,connected,to;private,synchronized,void,update,remote,clusters,map,string,tuple,string,list,supplier,discovery,node,seeds,action,listener,void,connection,listener,if,seeds,contains,key,throw,new,illegal,argument,exception,remote,clusters,must,not,have,the,empty,string,as,its,key,map,string,remote,cluster,connection,remote,clusters,new,hash,map,if,seeds,is,empty,connection,listener,on,response,null,else,count,down,count,down,new,count,down,seeds,size,remote,clusters,put,all,this,remote,clusters,for,map,entry,string,tuple,string,list,supplier,discovery,node,entry,seeds,entry,set,list,supplier,discovery,node,seed,list,entry,get,value,v2,string,proxy,address,entry,get,value,v1,remote,cluster,connection,remote,this,remote,clusters,get,entry,get,key,if,seed,list,is,empty,try,ioutils,close,remote,catch,ioexception,e,logger,warn,failed,to,close,remote,cluster,connections,for,cluster,entry,get,key,e,remote,clusters,remove,entry,get,key,continue,if,remote,null,string,cluster,alias,entry,get,key,time,value,ping,schedule,get,concrete,setting,for,namespace,cluster,alias,get,settings,connection,manager,connection,manager,new,connection,manager,settings,transport,service,transport,transport,service,thread,pool,ping,schedule,remote,new,remote,cluster,connection,settings,cluster,alias,seed,list,transport,service,connection,manager,num,remote,connections,get,node,predicate,settings,proxy,address,remote,clusters,put,cluster,alias,remote,remote,cluster,connection,final,remote,remote,remote,update,seed,nodes,proxy,address,seed,list,action,listener,wrap,response,if,count,down,count,down,connection,listener,on,response,response,exception,if,count,down,fast,forward,connection,listener,on,failure,exception,if,final,remote,is,closed,false,logger,warn,failed,to,update,seed,list,for,cluster,entry,get,key,exception,this,remote,clusters,collections,unmodifiable,map,remote,clusters
RemoteClusterService -> private synchronized void updateRemoteClusters(Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> seeds,                                                    ActionListener<Void> connectionListener);1543506953;This method updates the list of remote clusters. It's intended to be used as an update consumer on the settings infrastructure_@param seeds a cluster alias to discovery node mapping representing the remote clusters seeds nodes_@param connectionListener a listener invoked once every configured cluster has been connected to;private synchronized void updateRemoteClusters(Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> seeds,_                                                   ActionListener<Void> connectionListener) {_        if (seeds.containsKey(LOCAL_CLUSTER_GROUP_KEY)) {_            throw new IllegalArgumentException("remote clusters must not have the empty string as its key")__        }_        Map<String, RemoteClusterConnection> remoteClusters = new HashMap<>()__        if (seeds.isEmpty()) {_            connectionListener.onResponse(null)__        } else {_            CountDown countDown = new CountDown(seeds.size())__            remoteClusters.putAll(this.remoteClusters)__            for (Map.Entry<String, Tuple<String, List<Supplier<DiscoveryNode>>>> entry : seeds.entrySet()) {_                List<Supplier<DiscoveryNode>> seedList = entry.getValue().v2()__                String proxyAddress = entry.getValue().v1()___                RemoteClusterConnection remote = this.remoteClusters.get(entry.getKey())__                if (seedList.isEmpty()) { _                    try {_                        IOUtils.close(remote)__                    } catch (IOException e) {_                        logger.warn("failed to close remote cluster connections for cluster: " + entry.getKey(), e)__                    }_                    remoteClusters.remove(entry.getKey())__                    continue__                }__                if (remote == null) { _                    String clusterAlias = entry.getKey()__                    remote = new RemoteClusterConnection(settings, clusterAlias, seedList, transportService, numRemoteConnections,_                        getNodePredicate(settings), proxyAddress)__                    remoteClusters.put(clusterAlias, remote)__                }__                _                RemoteClusterConnection finalRemote = remote__                remote.updateSeedNodes(proxyAddress, seedList, ActionListener.wrap(_                        response -> {_                            if (countDown.countDown()) {_                                connectionListener.onResponse(response)__                            }_                        },_                        exception -> {_                            if (countDown.fastForward()) {_                                connectionListener.onFailure(exception)__                            }_                            if (finalRemote.isClosed() == false) {_                                logger.warn("failed to update seed list for cluster: " + entry.getKey(), exception)__                            }_                        }))__            }_        }_        this.remoteClusters = Collections.unmodifiableMap(remoteClusters)__    };this,method,updates,the,list,of,remote,clusters,it,s,intended,to,be,used,as,an,update,consumer,on,the,settings,infrastructure,param,seeds,a,cluster,alias,to,discovery,node,mapping,representing,the,remote,clusters,seeds,nodes,param,connection,listener,a,listener,invoked,once,every,configured,cluster,has,been,connected,to;private,synchronized,void,update,remote,clusters,map,string,tuple,string,list,supplier,discovery,node,seeds,action,listener,void,connection,listener,if,seeds,contains,key,throw,new,illegal,argument,exception,remote,clusters,must,not,have,the,empty,string,as,its,key,map,string,remote,cluster,connection,remote,clusters,new,hash,map,if,seeds,is,empty,connection,listener,on,response,null,else,count,down,count,down,new,count,down,seeds,size,remote,clusters,put,all,this,remote,clusters,for,map,entry,string,tuple,string,list,supplier,discovery,node,entry,seeds,entry,set,list,supplier,discovery,node,seed,list,entry,get,value,v2,string,proxy,address,entry,get,value,v1,remote,cluster,connection,remote,this,remote,clusters,get,entry,get,key,if,seed,list,is,empty,try,ioutils,close,remote,catch,ioexception,e,logger,warn,failed,to,close,remote,cluster,connections,for,cluster,entry,get,key,e,remote,clusters,remove,entry,get,key,continue,if,remote,null,string,cluster,alias,entry,get,key,remote,new,remote,cluster,connection,settings,cluster,alias,seed,list,transport,service,num,remote,connections,get,node,predicate,settings,proxy,address,remote,clusters,put,cluster,alias,remote,remote,cluster,connection,final,remote,remote,remote,update,seed,nodes,proxy,address,seed,list,action,listener,wrap,response,if,count,down,count,down,connection,listener,on,response,response,exception,if,count,down,fast,forward,connection,listener,on,failure,exception,if,final,remote,is,closed,false,logger,warn,failed,to,update,seed,list,for,cluster,entry,get,key,exception,this,remote,clusters,collections,unmodifiable,map,remote,clusters
RemoteClusterService -> private synchronized void updateRemoteClusters(Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> seeds,                                                    ActionListener<Void> connectionListener);1543959410;This method updates the list of remote clusters. It's intended to be used as an update consumer on the settings infrastructure_@param seeds a cluster alias to discovery node mapping representing the remote clusters seeds nodes_@param connectionListener a listener invoked once every configured cluster has been connected to;private synchronized void updateRemoteClusters(Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> seeds,_                                                   ActionListener<Void> connectionListener) {_        if (seeds.containsKey(LOCAL_CLUSTER_GROUP_KEY)) {_            throw new IllegalArgumentException("remote clusters must not have the empty string as its key")__        }_        Map<String, RemoteClusterConnection> remoteClusters = new HashMap<>()__        if (seeds.isEmpty()) {_            connectionListener.onResponse(null)__        } else {_            CountDown countDown = new CountDown(seeds.size())__            remoteClusters.putAll(this.remoteClusters)__            for (Map.Entry<String, Tuple<String, List<Supplier<DiscoveryNode>>>> entry : seeds.entrySet()) {_                List<Supplier<DiscoveryNode>> seedList = entry.getValue().v2()__                String proxyAddress = entry.getValue().v1()___                RemoteClusterConnection remote = this.remoteClusters.get(entry.getKey())__                if (seedList.isEmpty()) { _                    try {_                        IOUtils.close(remote)__                    } catch (IOException e) {_                        logger.warn("failed to close remote cluster connections for cluster: " + entry.getKey(), e)__                    }_                    remoteClusters.remove(entry.getKey())__                    continue__                }__                if (remote == null) { _                    String clusterAlias = entry.getKey()__                    remote = new RemoteClusterConnection(settings, clusterAlias, seedList, transportService, numRemoteConnections,_                        getNodePredicate(settings), proxyAddress)__                    remoteClusters.put(clusterAlias, remote)__                }__                _                RemoteClusterConnection finalRemote = remote__                remote.updateSeedNodes(proxyAddress, seedList, ActionListener.wrap(_                        response -> {_                            if (countDown.countDown()) {_                                connectionListener.onResponse(response)__                            }_                        },_                        exception -> {_                            if (countDown.fastForward()) {_                                connectionListener.onFailure(exception)__                            }_                            if (finalRemote.isClosed() == false) {_                                logger.warn("failed to update seed list for cluster: " + entry.getKey(), exception)__                            }_                        }))__            }_        }_        this.remoteClusters = Collections.unmodifiableMap(remoteClusters)__    };this,method,updates,the,list,of,remote,clusters,it,s,intended,to,be,used,as,an,update,consumer,on,the,settings,infrastructure,param,seeds,a,cluster,alias,to,discovery,node,mapping,representing,the,remote,clusters,seeds,nodes,param,connection,listener,a,listener,invoked,once,every,configured,cluster,has,been,connected,to;private,synchronized,void,update,remote,clusters,map,string,tuple,string,list,supplier,discovery,node,seeds,action,listener,void,connection,listener,if,seeds,contains,key,throw,new,illegal,argument,exception,remote,clusters,must,not,have,the,empty,string,as,its,key,map,string,remote,cluster,connection,remote,clusters,new,hash,map,if,seeds,is,empty,connection,listener,on,response,null,else,count,down,count,down,new,count,down,seeds,size,remote,clusters,put,all,this,remote,clusters,for,map,entry,string,tuple,string,list,supplier,discovery,node,entry,seeds,entry,set,list,supplier,discovery,node,seed,list,entry,get,value,v2,string,proxy,address,entry,get,value,v1,remote,cluster,connection,remote,this,remote,clusters,get,entry,get,key,if,seed,list,is,empty,try,ioutils,close,remote,catch,ioexception,e,logger,warn,failed,to,close,remote,cluster,connections,for,cluster,entry,get,key,e,remote,clusters,remove,entry,get,key,continue,if,remote,null,string,cluster,alias,entry,get,key,remote,new,remote,cluster,connection,settings,cluster,alias,seed,list,transport,service,num,remote,connections,get,node,predicate,settings,proxy,address,remote,clusters,put,cluster,alias,remote,remote,cluster,connection,final,remote,remote,remote,update,seed,nodes,proxy,address,seed,list,action,listener,wrap,response,if,count,down,count,down,connection,listener,on,response,response,exception,if,count,down,fast,forward,connection,listener,on,failure,exception,if,final,remote,is,closed,false,logger,warn,failed,to,update,seed,list,for,cluster,entry,get,key,exception,this,remote,clusters,collections,unmodifiable,map,remote,clusters
RemoteClusterService -> private synchronized void updateRemoteClusters(Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> seeds,                                                    ActionListener<Void> connectionListener);1544823664;This method updates the list of remote clusters. It's intended to be used as an update consumer on the settings infrastructure_@param seeds a cluster alias to discovery node mapping representing the remote clusters seeds nodes_@param connectionListener a listener invoked once every configured cluster has been connected to;private synchronized void updateRemoteClusters(Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> seeds,_                                                   ActionListener<Void> connectionListener) {_        if (seeds.containsKey(LOCAL_CLUSTER_GROUP_KEY)) {_            throw new IllegalArgumentException("remote clusters must not have the empty string as its key")__        }_        Map<String, RemoteClusterConnection> remoteClusters = new HashMap<>()__        if (seeds.isEmpty()) {_            connectionListener.onResponse(null)__        } else {_            CountDown countDown = new CountDown(seeds.size())__            remoteClusters.putAll(this.remoteClusters)__            for (Map.Entry<String, Tuple<String, List<Supplier<DiscoveryNode>>>> entry : seeds.entrySet()) {_                List<Supplier<DiscoveryNode>> seedList = entry.getValue().v2()__                String proxyAddress = entry.getValue().v1()___                RemoteClusterConnection remote = this.remoteClusters.get(entry.getKey())__                if (seedList.isEmpty()) { _                    try {_                        IOUtils.close(remote)__                    } catch (IOException e) {_                        logger.warn("failed to close remote cluster connections for cluster: " + entry.getKey(), e)__                    }_                    remoteClusters.remove(entry.getKey())__                    continue__                }__                if (remote == null) { _                    String clusterAlias = entry.getKey()__                    remote = new RemoteClusterConnection(settings, clusterAlias, seedList, transportService, numRemoteConnections,_                        getNodePredicate(settings), proxyAddress)__                    remoteClusters.put(clusterAlias, remote)__                }__                _                RemoteClusterConnection finalRemote = remote__                remote.updateSeedNodes(proxyAddress, seedList, ActionListener.wrap(_                        response -> {_                            if (countDown.countDown()) {_                                connectionListener.onResponse(response)__                            }_                        },_                        exception -> {_                            if (countDown.fastForward()) {_                                connectionListener.onFailure(exception)__                            }_                            if (finalRemote.isClosed() == false) {_                                logger.warn("failed to update seed list for cluster: " + entry.getKey(), exception)__                            }_                        }))__            }_        }_        this.remoteClusters = Collections.unmodifiableMap(remoteClusters)__    };this,method,updates,the,list,of,remote,clusters,it,s,intended,to,be,used,as,an,update,consumer,on,the,settings,infrastructure,param,seeds,a,cluster,alias,to,discovery,node,mapping,representing,the,remote,clusters,seeds,nodes,param,connection,listener,a,listener,invoked,once,every,configured,cluster,has,been,connected,to;private,synchronized,void,update,remote,clusters,map,string,tuple,string,list,supplier,discovery,node,seeds,action,listener,void,connection,listener,if,seeds,contains,key,throw,new,illegal,argument,exception,remote,clusters,must,not,have,the,empty,string,as,its,key,map,string,remote,cluster,connection,remote,clusters,new,hash,map,if,seeds,is,empty,connection,listener,on,response,null,else,count,down,count,down,new,count,down,seeds,size,remote,clusters,put,all,this,remote,clusters,for,map,entry,string,tuple,string,list,supplier,discovery,node,entry,seeds,entry,set,list,supplier,discovery,node,seed,list,entry,get,value,v2,string,proxy,address,entry,get,value,v1,remote,cluster,connection,remote,this,remote,clusters,get,entry,get,key,if,seed,list,is,empty,try,ioutils,close,remote,catch,ioexception,e,logger,warn,failed,to,close,remote,cluster,connections,for,cluster,entry,get,key,e,remote,clusters,remove,entry,get,key,continue,if,remote,null,string,cluster,alias,entry,get,key,remote,new,remote,cluster,connection,settings,cluster,alias,seed,list,transport,service,num,remote,connections,get,node,predicate,settings,proxy,address,remote,clusters,put,cluster,alias,remote,remote,cluster,connection,final,remote,remote,remote,update,seed,nodes,proxy,address,seed,list,action,listener,wrap,response,if,count,down,count,down,connection,listener,on,response,response,exception,if,count,down,fast,forward,connection,listener,on,failure,exception,if,final,remote,is,closed,false,logger,warn,failed,to,update,seed,list,for,cluster,entry,get,key,exception,this,remote,clusters,collections,unmodifiable,map,remote,clusters
RemoteClusterService -> public void collectNodes(Set<String> clusters, ActionListener<BiFunction<String, String, DiscoveryNode>> listener);1524684173;Collects all nodes of the given clusters and returns / passes a (clusterAlias, nodeId) to {@link DiscoveryNode}_function on success.;public void collectNodes(Set<String> clusters, ActionListener<BiFunction<String, String, DiscoveryNode>> listener) {_        Map<String, RemoteClusterConnection> remoteClusters = this.remoteClusters__        for (String cluster : clusters) {_            if (remoteClusters.containsKey(cluster) == false) {_                listener.onFailure(new IllegalArgumentException("no such remote cluster: [" + cluster + "]"))__                return__            }_        }__        final Map<String, Function<String, DiscoveryNode>> clusterMap = new HashMap<>()__        CountDown countDown = new CountDown(clusters.size())__        Function<String, DiscoveryNode> nullFunction = s -> null__        for (final String cluster : clusters) {_            RemoteClusterConnection connection = remoteClusters.get(cluster)__            connection.collectNodes(new ActionListener<Function<String, DiscoveryNode>>() {_                @Override_                public void onResponse(Function<String, DiscoveryNode> nodeLookup) {_                    synchronized (clusterMap) {_                        clusterMap.put(cluster, nodeLookup)__                    }_                    if (countDown.countDown()) {_                        listener.onResponse((clusterAlias, nodeId)_                            -> clusterMap.getOrDefault(clusterAlias, nullFunction).apply(nodeId))__                    }_                }__                @Override_                public void onFailure(Exception e) {_                    if (countDown.fastForward()) { _                        listener.onFailure(e)__                    }_                }_            })__        }_    };collects,all,nodes,of,the,given,clusters,and,returns,passes,a,cluster,alias,node,id,to,link,discovery,node,function,on,success;public,void,collect,nodes,set,string,clusters,action,listener,bi,function,string,string,discovery,node,listener,map,string,remote,cluster,connection,remote,clusters,this,remote,clusters,for,string,cluster,clusters,if,remote,clusters,contains,key,cluster,false,listener,on,failure,new,illegal,argument,exception,no,such,remote,cluster,cluster,return,final,map,string,function,string,discovery,node,cluster,map,new,hash,map,count,down,count,down,new,count,down,clusters,size,function,string,discovery,node,null,function,s,null,for,final,string,cluster,clusters,remote,cluster,connection,connection,remote,clusters,get,cluster,connection,collect,nodes,new,action,listener,function,string,discovery,node,override,public,void,on,response,function,string,discovery,node,node,lookup,synchronized,cluster,map,cluster,map,put,cluster,node,lookup,if,count,down,count,down,listener,on,response,cluster,alias,node,id,cluster,map,get,or,default,cluster,alias,null,function,apply,node,id,override,public,void,on,failure,exception,e,if,count,down,fast,forward,listener,on,failure,e
RemoteClusterService -> public void collectNodes(Set<String> clusters, ActionListener<BiFunction<String, String, DiscoveryNode>> listener);1525076988;Collects all nodes of the given clusters and returns / passes a (clusterAlias, nodeId) to {@link DiscoveryNode}_function on success.;public void collectNodes(Set<String> clusters, ActionListener<BiFunction<String, String, DiscoveryNode>> listener) {_        Map<String, RemoteClusterConnection> remoteClusters = this.remoteClusters__        for (String cluster : clusters) {_            if (remoteClusters.containsKey(cluster) == false) {_                listener.onFailure(new IllegalArgumentException("no such remote cluster: [" + cluster + "]"))__                return__            }_        }__        final Map<String, Function<String, DiscoveryNode>> clusterMap = new HashMap<>()__        CountDown countDown = new CountDown(clusters.size())__        Function<String, DiscoveryNode> nullFunction = s -> null__        for (final String cluster : clusters) {_            RemoteClusterConnection connection = remoteClusters.get(cluster)__            connection.collectNodes(new ActionListener<Function<String, DiscoveryNode>>() {_                @Override_                public void onResponse(Function<String, DiscoveryNode> nodeLookup) {_                    synchronized (clusterMap) {_                        clusterMap.put(cluster, nodeLookup)__                    }_                    if (countDown.countDown()) {_                        listener.onResponse((clusterAlias, nodeId)_                            -> clusterMap.getOrDefault(clusterAlias, nullFunction).apply(nodeId))__                    }_                }__                @Override_                public void onFailure(Exception e) {_                    if (countDown.fastForward()) { _                        listener.onFailure(e)__                    }_                }_            })__        }_    };collects,all,nodes,of,the,given,clusters,and,returns,passes,a,cluster,alias,node,id,to,link,discovery,node,function,on,success;public,void,collect,nodes,set,string,clusters,action,listener,bi,function,string,string,discovery,node,listener,map,string,remote,cluster,connection,remote,clusters,this,remote,clusters,for,string,cluster,clusters,if,remote,clusters,contains,key,cluster,false,listener,on,failure,new,illegal,argument,exception,no,such,remote,cluster,cluster,return,final,map,string,function,string,discovery,node,cluster,map,new,hash,map,count,down,count,down,new,count,down,clusters,size,function,string,discovery,node,null,function,s,null,for,final,string,cluster,clusters,remote,cluster,connection,connection,remote,clusters,get,cluster,connection,collect,nodes,new,action,listener,function,string,discovery,node,override,public,void,on,response,function,string,discovery,node,node,lookup,synchronized,cluster,map,cluster,map,put,cluster,node,lookup,if,count,down,count,down,listener,on,response,cluster,alias,node,id,cluster,map,get,or,default,cluster,alias,null,function,apply,node,id,override,public,void,on,failure,exception,e,if,count,down,fast,forward,listener,on,failure,e
RemoteClusterService -> public void collectNodes(Set<String> clusters, ActionListener<BiFunction<String, String, DiscoveryNode>> listener);1525334055;Collects all nodes of the given clusters and returns / passes a (clusterAlias, nodeId) to {@link DiscoveryNode}_function on success.;public void collectNodes(Set<String> clusters, ActionListener<BiFunction<String, String, DiscoveryNode>> listener) {_        Map<String, RemoteClusterConnection> remoteClusters = this.remoteClusters__        for (String cluster : clusters) {_            if (remoteClusters.containsKey(cluster) == false) {_                listener.onFailure(new IllegalArgumentException("no such remote cluster: [" + cluster + "]"))__                return__            }_        }__        final Map<String, Function<String, DiscoveryNode>> clusterMap = new HashMap<>()__        CountDown countDown = new CountDown(clusters.size())__        Function<String, DiscoveryNode> nullFunction = s -> null__        for (final String cluster : clusters) {_            RemoteClusterConnection connection = remoteClusters.get(cluster)__            connection.collectNodes(new ActionListener<Function<String, DiscoveryNode>>() {_                @Override_                public void onResponse(Function<String, DiscoveryNode> nodeLookup) {_                    synchronized (clusterMap) {_                        clusterMap.put(cluster, nodeLookup)__                    }_                    if (countDown.countDown()) {_                        listener.onResponse((clusterAlias, nodeId)_                            -> clusterMap.getOrDefault(clusterAlias, nullFunction).apply(nodeId))__                    }_                }__                @Override_                public void onFailure(Exception e) {_                    if (countDown.fastForward()) { _                        listener.onFailure(e)__                    }_                }_            })__        }_    };collects,all,nodes,of,the,given,clusters,and,returns,passes,a,cluster,alias,node,id,to,link,discovery,node,function,on,success;public,void,collect,nodes,set,string,clusters,action,listener,bi,function,string,string,discovery,node,listener,map,string,remote,cluster,connection,remote,clusters,this,remote,clusters,for,string,cluster,clusters,if,remote,clusters,contains,key,cluster,false,listener,on,failure,new,illegal,argument,exception,no,such,remote,cluster,cluster,return,final,map,string,function,string,discovery,node,cluster,map,new,hash,map,count,down,count,down,new,count,down,clusters,size,function,string,discovery,node,null,function,s,null,for,final,string,cluster,clusters,remote,cluster,connection,connection,remote,clusters,get,cluster,connection,collect,nodes,new,action,listener,function,string,discovery,node,override,public,void,on,response,function,string,discovery,node,node,lookup,synchronized,cluster,map,cluster,map,put,cluster,node,lookup,if,count,down,count,down,listener,on,response,cluster,alias,node,id,cluster,map,get,or,default,cluster,alias,null,function,apply,node,id,override,public,void,on,failure,exception,e,if,count,down,fast,forward,listener,on,failure,e
RemoteClusterService -> public void collectNodes(Set<String> clusters, ActionListener<BiFunction<String, String, DiscoveryNode>> listener);1527773340;Collects all nodes of the given clusters and returns / passes a (clusterAlias, nodeId) to {@link DiscoveryNode}_function on success.;public void collectNodes(Set<String> clusters, ActionListener<BiFunction<String, String, DiscoveryNode>> listener) {_        Map<String, RemoteClusterConnection> remoteClusters = this.remoteClusters__        for (String cluster : clusters) {_            if (remoteClusters.containsKey(cluster) == false) {_                listener.onFailure(new IllegalArgumentException("no such remote cluster: [" + cluster + "]"))__                return__            }_        }__        final Map<String, Function<String, DiscoveryNode>> clusterMap = new HashMap<>()__        CountDown countDown = new CountDown(clusters.size())__        Function<String, DiscoveryNode> nullFunction = s -> null__        for (final String cluster : clusters) {_            RemoteClusterConnection connection = remoteClusters.get(cluster)__            connection.collectNodes(new ActionListener<Function<String, DiscoveryNode>>() {_                @Override_                public void onResponse(Function<String, DiscoveryNode> nodeLookup) {_                    synchronized (clusterMap) {_                        clusterMap.put(cluster, nodeLookup)__                    }_                    if (countDown.countDown()) {_                        listener.onResponse((clusterAlias, nodeId)_                            -> clusterMap.getOrDefault(clusterAlias, nullFunction).apply(nodeId))__                    }_                }__                @Override_                public void onFailure(Exception e) {_                    if (countDown.fastForward()) { _                        listener.onFailure(e)__                    }_                }_            })__        }_    };collects,all,nodes,of,the,given,clusters,and,returns,passes,a,cluster,alias,node,id,to,link,discovery,node,function,on,success;public,void,collect,nodes,set,string,clusters,action,listener,bi,function,string,string,discovery,node,listener,map,string,remote,cluster,connection,remote,clusters,this,remote,clusters,for,string,cluster,clusters,if,remote,clusters,contains,key,cluster,false,listener,on,failure,new,illegal,argument,exception,no,such,remote,cluster,cluster,return,final,map,string,function,string,discovery,node,cluster,map,new,hash,map,count,down,count,down,new,count,down,clusters,size,function,string,discovery,node,null,function,s,null,for,final,string,cluster,clusters,remote,cluster,connection,connection,remote,clusters,get,cluster,connection,collect,nodes,new,action,listener,function,string,discovery,node,override,public,void,on,response,function,string,discovery,node,node,lookup,synchronized,cluster,map,cluster,map,put,cluster,node,lookup,if,count,down,count,down,listener,on,response,cluster,alias,node,id,cluster,map,get,or,default,cluster,alias,null,function,apply,node,id,override,public,void,on,failure,exception,e,if,count,down,fast,forward,listener,on,failure,e
RemoteClusterService -> public void collectNodes(Set<String> clusters, ActionListener<BiFunction<String, String, DiscoveryNode>> listener);1527840262;Collects all nodes of the given clusters and returns / passes a (clusterAlias, nodeId) to {@link DiscoveryNode}_function on success.;public void collectNodes(Set<String> clusters, ActionListener<BiFunction<String, String, DiscoveryNode>> listener) {_        Map<String, RemoteClusterConnection> remoteClusters = this.remoteClusters__        for (String cluster : clusters) {_            if (remoteClusters.containsKey(cluster) == false) {_                listener.onFailure(new IllegalArgumentException("no such remote cluster: [" + cluster + "]"))__                return__            }_        }__        final Map<String, Function<String, DiscoveryNode>> clusterMap = new HashMap<>()__        CountDown countDown = new CountDown(clusters.size())__        Function<String, DiscoveryNode> nullFunction = s -> null__        for (final String cluster : clusters) {_            RemoteClusterConnection connection = remoteClusters.get(cluster)__            connection.collectNodes(new ActionListener<Function<String, DiscoveryNode>>() {_                @Override_                public void onResponse(Function<String, DiscoveryNode> nodeLookup) {_                    synchronized (clusterMap) {_                        clusterMap.put(cluster, nodeLookup)__                    }_                    if (countDown.countDown()) {_                        listener.onResponse((clusterAlias, nodeId)_                            -> clusterMap.getOrDefault(clusterAlias, nullFunction).apply(nodeId))__                    }_                }__                @Override_                public void onFailure(Exception e) {_                    if (countDown.fastForward()) { _                        listener.onFailure(e)__                    }_                }_            })__        }_    };collects,all,nodes,of,the,given,clusters,and,returns,passes,a,cluster,alias,node,id,to,link,discovery,node,function,on,success;public,void,collect,nodes,set,string,clusters,action,listener,bi,function,string,string,discovery,node,listener,map,string,remote,cluster,connection,remote,clusters,this,remote,clusters,for,string,cluster,clusters,if,remote,clusters,contains,key,cluster,false,listener,on,failure,new,illegal,argument,exception,no,such,remote,cluster,cluster,return,final,map,string,function,string,discovery,node,cluster,map,new,hash,map,count,down,count,down,new,count,down,clusters,size,function,string,discovery,node,null,function,s,null,for,final,string,cluster,clusters,remote,cluster,connection,connection,remote,clusters,get,cluster,connection,collect,nodes,new,action,listener,function,string,discovery,node,override,public,void,on,response,function,string,discovery,node,node,lookup,synchronized,cluster,map,cluster,map,put,cluster,node,lookup,if,count,down,count,down,listener,on,response,cluster,alias,node,id,cluster,map,get,or,default,cluster,alias,null,function,apply,node,id,override,public,void,on,failure,exception,e,if,count,down,fast,forward,listener,on,failure,e
RemoteClusterService -> public void collectNodes(Set<String> clusters, ActionListener<BiFunction<String, String, DiscoveryNode>> listener);1534755962;Collects all nodes of the given clusters and returns / passes a (clusterAlias, nodeId) to {@link DiscoveryNode}_function on success.;public void collectNodes(Set<String> clusters, ActionListener<BiFunction<String, String, DiscoveryNode>> listener) {_        Map<String, RemoteClusterConnection> remoteClusters = this.remoteClusters__        for (String cluster : clusters) {_            if (remoteClusters.containsKey(cluster) == false) {_                listener.onFailure(new IllegalArgumentException("no such remote cluster: [" + cluster + "]"))__                return__            }_        }__        final Map<String, Function<String, DiscoveryNode>> clusterMap = new HashMap<>()__        CountDown countDown = new CountDown(clusters.size())__        Function<String, DiscoveryNode> nullFunction = s -> null__        for (final String cluster : clusters) {_            RemoteClusterConnection connection = remoteClusters.get(cluster)__            connection.collectNodes(new ActionListener<Function<String, DiscoveryNode>>() {_                @Override_                public void onResponse(Function<String, DiscoveryNode> nodeLookup) {_                    synchronized (clusterMap) {_                        clusterMap.put(cluster, nodeLookup)__                    }_                    if (countDown.countDown()) {_                        listener.onResponse((clusterAlias, nodeId)_                            -> clusterMap.getOrDefault(clusterAlias, nullFunction).apply(nodeId))__                    }_                }__                @Override_                public void onFailure(Exception e) {_                    if (countDown.fastForward()) { _                        listener.onFailure(e)__                    }_                }_            })__        }_    };collects,all,nodes,of,the,given,clusters,and,returns,passes,a,cluster,alias,node,id,to,link,discovery,node,function,on,success;public,void,collect,nodes,set,string,clusters,action,listener,bi,function,string,string,discovery,node,listener,map,string,remote,cluster,connection,remote,clusters,this,remote,clusters,for,string,cluster,clusters,if,remote,clusters,contains,key,cluster,false,listener,on,failure,new,illegal,argument,exception,no,such,remote,cluster,cluster,return,final,map,string,function,string,discovery,node,cluster,map,new,hash,map,count,down,count,down,new,count,down,clusters,size,function,string,discovery,node,null,function,s,null,for,final,string,cluster,clusters,remote,cluster,connection,connection,remote,clusters,get,cluster,connection,collect,nodes,new,action,listener,function,string,discovery,node,override,public,void,on,response,function,string,discovery,node,node,lookup,synchronized,cluster,map,cluster,map,put,cluster,node,lookup,if,count,down,count,down,listener,on,response,cluster,alias,node,id,cluster,map,get,or,default,cluster,alias,null,function,apply,node,id,override,public,void,on,failure,exception,e,if,count,down,fast,forward,listener,on,failure,e
RemoteClusterService -> public void collectNodes(Set<String> clusters, ActionListener<BiFunction<String, String, DiscoveryNode>> listener);1535046779;Collects all nodes of the given clusters and returns / passes a (clusterAlias, nodeId) to {@link DiscoveryNode}_function on success.;public void collectNodes(Set<String> clusters, ActionListener<BiFunction<String, String, DiscoveryNode>> listener) {_        Map<String, RemoteClusterConnection> remoteClusters = this.remoteClusters__        for (String cluster : clusters) {_            if (remoteClusters.containsKey(cluster) == false) {_                listener.onFailure(new IllegalArgumentException("no such remote cluster: [" + cluster + "]"))__                return__            }_        }__        final Map<String, Function<String, DiscoveryNode>> clusterMap = new HashMap<>()__        CountDown countDown = new CountDown(clusters.size())__        Function<String, DiscoveryNode> nullFunction = s -> null__        for (final String cluster : clusters) {_            RemoteClusterConnection connection = remoteClusters.get(cluster)__            connection.collectNodes(new ActionListener<Function<String, DiscoveryNode>>() {_                @Override_                public void onResponse(Function<String, DiscoveryNode> nodeLookup) {_                    synchronized (clusterMap) {_                        clusterMap.put(cluster, nodeLookup)__                    }_                    if (countDown.countDown()) {_                        listener.onResponse((clusterAlias, nodeId)_                            -> clusterMap.getOrDefault(clusterAlias, nullFunction).apply(nodeId))__                    }_                }__                @Override_                public void onFailure(Exception e) {_                    if (countDown.fastForward()) { _                        listener.onFailure(e)__                    }_                }_            })__        }_    };collects,all,nodes,of,the,given,clusters,and,returns,passes,a,cluster,alias,node,id,to,link,discovery,node,function,on,success;public,void,collect,nodes,set,string,clusters,action,listener,bi,function,string,string,discovery,node,listener,map,string,remote,cluster,connection,remote,clusters,this,remote,clusters,for,string,cluster,clusters,if,remote,clusters,contains,key,cluster,false,listener,on,failure,new,illegal,argument,exception,no,such,remote,cluster,cluster,return,final,map,string,function,string,discovery,node,cluster,map,new,hash,map,count,down,count,down,new,count,down,clusters,size,function,string,discovery,node,null,function,s,null,for,final,string,cluster,clusters,remote,cluster,connection,connection,remote,clusters,get,cluster,connection,collect,nodes,new,action,listener,function,string,discovery,node,override,public,void,on,response,function,string,discovery,node,node,lookup,synchronized,cluster,map,cluster,map,put,cluster,node,lookup,if,count,down,count,down,listener,on,response,cluster,alias,node,id,cluster,map,get,or,default,cluster,alias,null,function,apply,node,id,override,public,void,on,failure,exception,e,if,count,down,fast,forward,listener,on,failure,e
RemoteClusterService -> public void collectNodes(Set<String> clusters, ActionListener<BiFunction<String, String, DiscoveryNode>> listener);1535383145;Collects all nodes of the given clusters and returns / passes a (clusterAlias, nodeId) to {@link DiscoveryNode}_function on success.;public void collectNodes(Set<String> clusters, ActionListener<BiFunction<String, String, DiscoveryNode>> listener) {_        Map<String, RemoteClusterConnection> remoteClusters = this.remoteClusters__        for (String cluster : clusters) {_            if (remoteClusters.containsKey(cluster) == false) {_                listener.onFailure(new IllegalArgumentException("no such remote cluster: [" + cluster + "]"))__                return__            }_        }__        final Map<String, Function<String, DiscoveryNode>> clusterMap = new HashMap<>()__        CountDown countDown = new CountDown(clusters.size())__        Function<String, DiscoveryNode> nullFunction = s -> null__        for (final String cluster : clusters) {_            RemoteClusterConnection connection = remoteClusters.get(cluster)__            connection.collectNodes(new ActionListener<Function<String, DiscoveryNode>>() {_                @Override_                public void onResponse(Function<String, DiscoveryNode> nodeLookup) {_                    synchronized (clusterMap) {_                        clusterMap.put(cluster, nodeLookup)__                    }_                    if (countDown.countDown()) {_                        listener.onResponse((clusterAlias, nodeId)_                            -> clusterMap.getOrDefault(clusterAlias, nullFunction).apply(nodeId))__                    }_                }__                @Override_                public void onFailure(Exception e) {_                    if (countDown.fastForward()) { _                        listener.onFailure(e)__                    }_                }_            })__        }_    };collects,all,nodes,of,the,given,clusters,and,returns,passes,a,cluster,alias,node,id,to,link,discovery,node,function,on,success;public,void,collect,nodes,set,string,clusters,action,listener,bi,function,string,string,discovery,node,listener,map,string,remote,cluster,connection,remote,clusters,this,remote,clusters,for,string,cluster,clusters,if,remote,clusters,contains,key,cluster,false,listener,on,failure,new,illegal,argument,exception,no,such,remote,cluster,cluster,return,final,map,string,function,string,discovery,node,cluster,map,new,hash,map,count,down,count,down,new,count,down,clusters,size,function,string,discovery,node,null,function,s,null,for,final,string,cluster,clusters,remote,cluster,connection,connection,remote,clusters,get,cluster,connection,collect,nodes,new,action,listener,function,string,discovery,node,override,public,void,on,response,function,string,discovery,node,node,lookup,synchronized,cluster,map,cluster,map,put,cluster,node,lookup,if,count,down,count,down,listener,on,response,cluster,alias,node,id,cluster,map,get,or,default,cluster,alias,null,function,apply,node,id,override,public,void,on,failure,exception,e,if,count,down,fast,forward,listener,on,failure,e
RemoteClusterService -> public void collectNodes(Set<String> clusters, ActionListener<BiFunction<String, String, DiscoveryNode>> listener);1536218260;Collects all nodes of the given clusters and returns / passes a (clusterAlias, nodeId) to {@link DiscoveryNode}_function on success.;public void collectNodes(Set<String> clusters, ActionListener<BiFunction<String, String, DiscoveryNode>> listener) {_        Map<String, RemoteClusterConnection> remoteClusters = this.remoteClusters__        for (String cluster : clusters) {_            if (remoteClusters.containsKey(cluster) == false) {_                listener.onFailure(new IllegalArgumentException("no such remote cluster: [" + cluster + "]"))__                return__            }_        }__        final Map<String, Function<String, DiscoveryNode>> clusterMap = new HashMap<>()__        CountDown countDown = new CountDown(clusters.size())__        Function<String, DiscoveryNode> nullFunction = s -> null__        for (final String cluster : clusters) {_            RemoteClusterConnection connection = remoteClusters.get(cluster)__            connection.collectNodes(new ActionListener<Function<String, DiscoveryNode>>() {_                @Override_                public void onResponse(Function<String, DiscoveryNode> nodeLookup) {_                    synchronized (clusterMap) {_                        clusterMap.put(cluster, nodeLookup)__                    }_                    if (countDown.countDown()) {_                        listener.onResponse((clusterAlias, nodeId)_                                -> clusterMap.getOrDefault(clusterAlias, nullFunction).apply(nodeId))__                    }_                }__                @Override_                public void onFailure(Exception e) {_                    if (countDown.fastForward()) { _                        listener.onFailure(e)__                    }_                }_            })__        }_    };collects,all,nodes,of,the,given,clusters,and,returns,passes,a,cluster,alias,node,id,to,link,discovery,node,function,on,success;public,void,collect,nodes,set,string,clusters,action,listener,bi,function,string,string,discovery,node,listener,map,string,remote,cluster,connection,remote,clusters,this,remote,clusters,for,string,cluster,clusters,if,remote,clusters,contains,key,cluster,false,listener,on,failure,new,illegal,argument,exception,no,such,remote,cluster,cluster,return,final,map,string,function,string,discovery,node,cluster,map,new,hash,map,count,down,count,down,new,count,down,clusters,size,function,string,discovery,node,null,function,s,null,for,final,string,cluster,clusters,remote,cluster,connection,connection,remote,clusters,get,cluster,connection,collect,nodes,new,action,listener,function,string,discovery,node,override,public,void,on,response,function,string,discovery,node,node,lookup,synchronized,cluster,map,cluster,map,put,cluster,node,lookup,if,count,down,count,down,listener,on,response,cluster,alias,node,id,cluster,map,get,or,default,cluster,alias,null,function,apply,node,id,override,public,void,on,failure,exception,e,if,count,down,fast,forward,listener,on,failure,e
RemoteClusterService -> public void collectNodes(Set<String> clusters, ActionListener<BiFunction<String, String, DiscoveryNode>> listener);1536828374;Collects all nodes of the given clusters and returns / passes a (clusterAlias, nodeId) to {@link DiscoveryNode}_function on success.;public void collectNodes(Set<String> clusters, ActionListener<BiFunction<String, String, DiscoveryNode>> listener) {_        Map<String, RemoteClusterConnection> remoteClusters = this.remoteClusters__        for (String cluster : clusters) {_            if (remoteClusters.containsKey(cluster) == false) {_                listener.onFailure(new IllegalArgumentException("no such remote cluster: [" + cluster + "]"))__                return__            }_        }__        final Map<String, Function<String, DiscoveryNode>> clusterMap = new HashMap<>()__        CountDown countDown = new CountDown(clusters.size())__        Function<String, DiscoveryNode> nullFunction = s -> null__        for (final String cluster : clusters) {_            RemoteClusterConnection connection = remoteClusters.get(cluster)__            connection.collectNodes(new ActionListener<Function<String, DiscoveryNode>>() {_                @Override_                public void onResponse(Function<String, DiscoveryNode> nodeLookup) {_                    synchronized (clusterMap) {_                        clusterMap.put(cluster, nodeLookup)__                    }_                    if (countDown.countDown()) {_                        listener.onResponse((clusterAlias, nodeId)_                                -> clusterMap.getOrDefault(clusterAlias, nullFunction).apply(nodeId))__                    }_                }__                @Override_                public void onFailure(Exception e) {_                    if (countDown.fastForward()) { _                        listener.onFailure(e)__                    }_                }_            })__        }_    };collects,all,nodes,of,the,given,clusters,and,returns,passes,a,cluster,alias,node,id,to,link,discovery,node,function,on,success;public,void,collect,nodes,set,string,clusters,action,listener,bi,function,string,string,discovery,node,listener,map,string,remote,cluster,connection,remote,clusters,this,remote,clusters,for,string,cluster,clusters,if,remote,clusters,contains,key,cluster,false,listener,on,failure,new,illegal,argument,exception,no,such,remote,cluster,cluster,return,final,map,string,function,string,discovery,node,cluster,map,new,hash,map,count,down,count,down,new,count,down,clusters,size,function,string,discovery,node,null,function,s,null,for,final,string,cluster,clusters,remote,cluster,connection,connection,remote,clusters,get,cluster,connection,collect,nodes,new,action,listener,function,string,discovery,node,override,public,void,on,response,function,string,discovery,node,node,lookup,synchronized,cluster,map,cluster,map,put,cluster,node,lookup,if,count,down,count,down,listener,on,response,cluster,alias,node,id,cluster,map,get,or,default,cluster,alias,null,function,apply,node,id,override,public,void,on,failure,exception,e,if,count,down,fast,forward,listener,on,failure,e
RemoteClusterService -> public void collectNodes(Set<String> clusters, ActionListener<BiFunction<String, String, DiscoveryNode>> listener);1537806831;Collects all nodes of the given clusters and returns / passes a (clusterAlias, nodeId) to {@link DiscoveryNode}_function on success.;public void collectNodes(Set<String> clusters, ActionListener<BiFunction<String, String, DiscoveryNode>> listener) {_        Map<String, RemoteClusterConnection> remoteClusters = this.remoteClusters__        for (String cluster : clusters) {_            if (remoteClusters.containsKey(cluster) == false) {_                listener.onFailure(new IllegalArgumentException("no such remote cluster: [" + cluster + "]"))__                return__            }_        }__        final Map<String, Function<String, DiscoveryNode>> clusterMap = new HashMap<>()__        CountDown countDown = new CountDown(clusters.size())__        Function<String, DiscoveryNode> nullFunction = s -> null__        for (final String cluster : clusters) {_            RemoteClusterConnection connection = remoteClusters.get(cluster)__            connection.collectNodes(new ActionListener<Function<String, DiscoveryNode>>() {_                @Override_                public void onResponse(Function<String, DiscoveryNode> nodeLookup) {_                    synchronized (clusterMap) {_                        clusterMap.put(cluster, nodeLookup)__                    }_                    if (countDown.countDown()) {_                        listener.onResponse((clusterAlias, nodeId)_                                -> clusterMap.getOrDefault(clusterAlias, nullFunction).apply(nodeId))__                    }_                }__                @Override_                public void onFailure(Exception e) {_                    if (countDown.fastForward()) { _                        listener.onFailure(e)__                    }_                }_            })__        }_    };collects,all,nodes,of,the,given,clusters,and,returns,passes,a,cluster,alias,node,id,to,link,discovery,node,function,on,success;public,void,collect,nodes,set,string,clusters,action,listener,bi,function,string,string,discovery,node,listener,map,string,remote,cluster,connection,remote,clusters,this,remote,clusters,for,string,cluster,clusters,if,remote,clusters,contains,key,cluster,false,listener,on,failure,new,illegal,argument,exception,no,such,remote,cluster,cluster,return,final,map,string,function,string,discovery,node,cluster,map,new,hash,map,count,down,count,down,new,count,down,clusters,size,function,string,discovery,node,null,function,s,null,for,final,string,cluster,clusters,remote,cluster,connection,connection,remote,clusters,get,cluster,connection,collect,nodes,new,action,listener,function,string,discovery,node,override,public,void,on,response,function,string,discovery,node,node,lookup,synchronized,cluster,map,cluster,map,put,cluster,node,lookup,if,count,down,count,down,listener,on,response,cluster,alias,node,id,cluster,map,get,or,default,cluster,alias,null,function,apply,node,id,override,public,void,on,failure,exception,e,if,count,down,fast,forward,listener,on,failure,e
RemoteClusterService -> public void collectNodes(Set<String> clusters, ActionListener<BiFunction<String, String, DiscoveryNode>> listener);1541008027;Collects all nodes of the given clusters and returns / passes a (clusterAlias, nodeId) to {@link DiscoveryNode}_function on success.;public void collectNodes(Set<String> clusters, ActionListener<BiFunction<String, String, DiscoveryNode>> listener) {_        Map<String, RemoteClusterConnection> remoteClusters = this.remoteClusters__        for (String cluster : clusters) {_            if (remoteClusters.containsKey(cluster) == false) {_                listener.onFailure(new IllegalArgumentException("no such remote cluster: [" + cluster + "]"))__                return__            }_        }__        final Map<String, Function<String, DiscoveryNode>> clusterMap = new HashMap<>()__        CountDown countDown = new CountDown(clusters.size())__        Function<String, DiscoveryNode> nullFunction = s -> null__        for (final String cluster : clusters) {_            RemoteClusterConnection connection = remoteClusters.get(cluster)__            connection.collectNodes(new ActionListener<Function<String, DiscoveryNode>>() {_                @Override_                public void onResponse(Function<String, DiscoveryNode> nodeLookup) {_                    synchronized (clusterMap) {_                        clusterMap.put(cluster, nodeLookup)__                    }_                    if (countDown.countDown()) {_                        listener.onResponse((clusterAlias, nodeId)_                                -> clusterMap.getOrDefault(clusterAlias, nullFunction).apply(nodeId))__                    }_                }__                @Override_                public void onFailure(Exception e) {_                    if (countDown.fastForward()) { _                        listener.onFailure(e)__                    }_                }_            })__        }_    };collects,all,nodes,of,the,given,clusters,and,returns,passes,a,cluster,alias,node,id,to,link,discovery,node,function,on,success;public,void,collect,nodes,set,string,clusters,action,listener,bi,function,string,string,discovery,node,listener,map,string,remote,cluster,connection,remote,clusters,this,remote,clusters,for,string,cluster,clusters,if,remote,clusters,contains,key,cluster,false,listener,on,failure,new,illegal,argument,exception,no,such,remote,cluster,cluster,return,final,map,string,function,string,discovery,node,cluster,map,new,hash,map,count,down,count,down,new,count,down,clusters,size,function,string,discovery,node,null,function,s,null,for,final,string,cluster,clusters,remote,cluster,connection,connection,remote,clusters,get,cluster,connection,collect,nodes,new,action,listener,function,string,discovery,node,override,public,void,on,response,function,string,discovery,node,node,lookup,synchronized,cluster,map,cluster,map,put,cluster,node,lookup,if,count,down,count,down,listener,on,response,cluster,alias,node,id,cluster,map,get,or,default,cluster,alias,null,function,apply,node,id,override,public,void,on,failure,exception,e,if,count,down,fast,forward,listener,on,failure,e
RemoteClusterService -> public void collectNodes(Set<String> clusters, ActionListener<BiFunction<String, String, DiscoveryNode>> listener);1541698679;Collects all nodes of the given clusters and returns / passes a (clusterAlias, nodeId) to {@link DiscoveryNode}_function on success.;public void collectNodes(Set<String> clusters, ActionListener<BiFunction<String, String, DiscoveryNode>> listener) {_        Map<String, RemoteClusterConnection> remoteClusters = this.remoteClusters__        for (String cluster : clusters) {_            if (remoteClusters.containsKey(cluster) == false) {_                listener.onFailure(new IllegalArgumentException("no such remote cluster: [" + cluster + "]"))__                return__            }_        }__        final Map<String, Function<String, DiscoveryNode>> clusterMap = new HashMap<>()__        CountDown countDown = new CountDown(clusters.size())__        Function<String, DiscoveryNode> nullFunction = s -> null__        for (final String cluster : clusters) {_            RemoteClusterConnection connection = remoteClusters.get(cluster)__            connection.collectNodes(new ActionListener<Function<String, DiscoveryNode>>() {_                @Override_                public void onResponse(Function<String, DiscoveryNode> nodeLookup) {_                    synchronized (clusterMap) {_                        clusterMap.put(cluster, nodeLookup)__                    }_                    if (countDown.countDown()) {_                        listener.onResponse((clusterAlias, nodeId)_                                -> clusterMap.getOrDefault(clusterAlias, nullFunction).apply(nodeId))__                    }_                }__                @Override_                public void onFailure(Exception e) {_                    if (countDown.fastForward()) { _                        listener.onFailure(e)__                    }_                }_            })__        }_    };collects,all,nodes,of,the,given,clusters,and,returns,passes,a,cluster,alias,node,id,to,link,discovery,node,function,on,success;public,void,collect,nodes,set,string,clusters,action,listener,bi,function,string,string,discovery,node,listener,map,string,remote,cluster,connection,remote,clusters,this,remote,clusters,for,string,cluster,clusters,if,remote,clusters,contains,key,cluster,false,listener,on,failure,new,illegal,argument,exception,no,such,remote,cluster,cluster,return,final,map,string,function,string,discovery,node,cluster,map,new,hash,map,count,down,count,down,new,count,down,clusters,size,function,string,discovery,node,null,function,s,null,for,final,string,cluster,clusters,remote,cluster,connection,connection,remote,clusters,get,cluster,connection,collect,nodes,new,action,listener,function,string,discovery,node,override,public,void,on,response,function,string,discovery,node,node,lookup,synchronized,cluster,map,cluster,map,put,cluster,node,lookup,if,count,down,count,down,listener,on,response,cluster,alias,node,id,cluster,map,get,or,default,cluster,alias,null,function,apply,node,id,override,public,void,on,failure,exception,e,if,count,down,fast,forward,listener,on,failure,e
RemoteClusterService -> public void collectNodes(Set<String> clusters, ActionListener<BiFunction<String, String, DiscoveryNode>> listener);1542402632;Collects all nodes of the given clusters and returns / passes a (clusterAlias, nodeId) to {@link DiscoveryNode}_function on success.;public void collectNodes(Set<String> clusters, ActionListener<BiFunction<String, String, DiscoveryNode>> listener) {_        Map<String, RemoteClusterConnection> remoteClusters = this.remoteClusters__        for (String cluster : clusters) {_            if (remoteClusters.containsKey(cluster) == false) {_                listener.onFailure(new IllegalArgumentException("no such remote cluster: [" + cluster + "]"))__                return__            }_        }__        final Map<String, Function<String, DiscoveryNode>> clusterMap = new HashMap<>()__        CountDown countDown = new CountDown(clusters.size())__        Function<String, DiscoveryNode> nullFunction = s -> null__        for (final String cluster : clusters) {_            RemoteClusterConnection connection = remoteClusters.get(cluster)__            connection.collectNodes(new ActionListener<Function<String, DiscoveryNode>>() {_                @Override_                public void onResponse(Function<String, DiscoveryNode> nodeLookup) {_                    synchronized (clusterMap) {_                        clusterMap.put(cluster, nodeLookup)__                    }_                    if (countDown.countDown()) {_                        listener.onResponse((clusterAlias, nodeId)_                                -> clusterMap.getOrDefault(clusterAlias, nullFunction).apply(nodeId))__                    }_                }__                @Override_                public void onFailure(Exception e) {_                    if (countDown.fastForward()) { _                        listener.onFailure(e)__                    }_                }_            })__        }_    };collects,all,nodes,of,the,given,clusters,and,returns,passes,a,cluster,alias,node,id,to,link,discovery,node,function,on,success;public,void,collect,nodes,set,string,clusters,action,listener,bi,function,string,string,discovery,node,listener,map,string,remote,cluster,connection,remote,clusters,this,remote,clusters,for,string,cluster,clusters,if,remote,clusters,contains,key,cluster,false,listener,on,failure,new,illegal,argument,exception,no,such,remote,cluster,cluster,return,final,map,string,function,string,discovery,node,cluster,map,new,hash,map,count,down,count,down,new,count,down,clusters,size,function,string,discovery,node,null,function,s,null,for,final,string,cluster,clusters,remote,cluster,connection,connection,remote,clusters,get,cluster,connection,collect,nodes,new,action,listener,function,string,discovery,node,override,public,void,on,response,function,string,discovery,node,node,lookup,synchronized,cluster,map,cluster,map,put,cluster,node,lookup,if,count,down,count,down,listener,on,response,cluster,alias,node,id,cluster,map,get,or,default,cluster,alias,null,function,apply,node,id,override,public,void,on,failure,exception,e,if,count,down,fast,forward,listener,on,failure,e
RemoteClusterService -> public void collectNodes(Set<String> clusters, ActionListener<BiFunction<String, String, DiscoveryNode>> listener);1543506953;Collects all nodes of the given clusters and returns / passes a (clusterAlias, nodeId) to {@link DiscoveryNode}_function on success.;public void collectNodes(Set<String> clusters, ActionListener<BiFunction<String, String, DiscoveryNode>> listener) {_        Map<String, RemoteClusterConnection> remoteClusters = this.remoteClusters__        for (String cluster : clusters) {_            if (remoteClusters.containsKey(cluster) == false) {_                listener.onFailure(new IllegalArgumentException("no such remote cluster: [" + cluster + "]"))__                return__            }_        }__        final Map<String, Function<String, DiscoveryNode>> clusterMap = new HashMap<>()__        CountDown countDown = new CountDown(clusters.size())__        Function<String, DiscoveryNode> nullFunction = s -> null__        for (final String cluster : clusters) {_            RemoteClusterConnection connection = remoteClusters.get(cluster)__            connection.collectNodes(new ActionListener<Function<String, DiscoveryNode>>() {_                @Override_                public void onResponse(Function<String, DiscoveryNode> nodeLookup) {_                    synchronized (clusterMap) {_                        clusterMap.put(cluster, nodeLookup)__                    }_                    if (countDown.countDown()) {_                        listener.onResponse((clusterAlias, nodeId)_                                -> clusterMap.getOrDefault(clusterAlias, nullFunction).apply(nodeId))__                    }_                }__                @Override_                public void onFailure(Exception e) {_                    if (countDown.fastForward()) { _                        listener.onFailure(e)__                    }_                }_            })__        }_    };collects,all,nodes,of,the,given,clusters,and,returns,passes,a,cluster,alias,node,id,to,link,discovery,node,function,on,success;public,void,collect,nodes,set,string,clusters,action,listener,bi,function,string,string,discovery,node,listener,map,string,remote,cluster,connection,remote,clusters,this,remote,clusters,for,string,cluster,clusters,if,remote,clusters,contains,key,cluster,false,listener,on,failure,new,illegal,argument,exception,no,such,remote,cluster,cluster,return,final,map,string,function,string,discovery,node,cluster,map,new,hash,map,count,down,count,down,new,count,down,clusters,size,function,string,discovery,node,null,function,s,null,for,final,string,cluster,clusters,remote,cluster,connection,connection,remote,clusters,get,cluster,connection,collect,nodes,new,action,listener,function,string,discovery,node,override,public,void,on,response,function,string,discovery,node,node,lookup,synchronized,cluster,map,cluster,map,put,cluster,node,lookup,if,count,down,count,down,listener,on,response,cluster,alias,node,id,cluster,map,get,or,default,cluster,alias,null,function,apply,node,id,override,public,void,on,failure,exception,e,if,count,down,fast,forward,listener,on,failure,e
RemoteClusterService -> public void collectNodes(Set<String> clusters, ActionListener<BiFunction<String, String, DiscoveryNode>> listener);1543959410;Collects all nodes of the given clusters and returns / passes a (clusterAlias, nodeId) to {@link DiscoveryNode}_function on success.;public void collectNodes(Set<String> clusters, ActionListener<BiFunction<String, String, DiscoveryNode>> listener) {_        Map<String, RemoteClusterConnection> remoteClusters = this.remoteClusters__        for (String cluster : clusters) {_            if (remoteClusters.containsKey(cluster) == false) {_                listener.onFailure(new IllegalArgumentException("no such remote cluster: [" + cluster + "]"))__                return__            }_        }__        final Map<String, Function<String, DiscoveryNode>> clusterMap = new HashMap<>()__        CountDown countDown = new CountDown(clusters.size())__        Function<String, DiscoveryNode> nullFunction = s -> null__        for (final String cluster : clusters) {_            RemoteClusterConnection connection = remoteClusters.get(cluster)__            connection.collectNodes(new ActionListener<Function<String, DiscoveryNode>>() {_                @Override_                public void onResponse(Function<String, DiscoveryNode> nodeLookup) {_                    synchronized (clusterMap) {_                        clusterMap.put(cluster, nodeLookup)__                    }_                    if (countDown.countDown()) {_                        listener.onResponse((clusterAlias, nodeId)_                                -> clusterMap.getOrDefault(clusterAlias, nullFunction).apply(nodeId))__                    }_                }__                @Override_                public void onFailure(Exception e) {_                    if (countDown.fastForward()) { _                        listener.onFailure(e)__                    }_                }_            })__        }_    };collects,all,nodes,of,the,given,clusters,and,returns,passes,a,cluster,alias,node,id,to,link,discovery,node,function,on,success;public,void,collect,nodes,set,string,clusters,action,listener,bi,function,string,string,discovery,node,listener,map,string,remote,cluster,connection,remote,clusters,this,remote,clusters,for,string,cluster,clusters,if,remote,clusters,contains,key,cluster,false,listener,on,failure,new,illegal,argument,exception,no,such,remote,cluster,cluster,return,final,map,string,function,string,discovery,node,cluster,map,new,hash,map,count,down,count,down,new,count,down,clusters,size,function,string,discovery,node,null,function,s,null,for,final,string,cluster,clusters,remote,cluster,connection,connection,remote,clusters,get,cluster,connection,collect,nodes,new,action,listener,function,string,discovery,node,override,public,void,on,response,function,string,discovery,node,node,lookup,synchronized,cluster,map,cluster,map,put,cluster,node,lookup,if,count,down,count,down,listener,on,response,cluster,alias,node,id,cluster,map,get,or,default,cluster,alias,null,function,apply,node,id,override,public,void,on,failure,exception,e,if,count,down,fast,forward,listener,on,failure,e
RemoteClusterService -> public void collectNodes(Set<String> clusters, ActionListener<BiFunction<String, String, DiscoveryNode>> listener);1544823664;Collects all nodes of the given clusters and returns / passes a (clusterAlias, nodeId) to {@link DiscoveryNode}_function on success.;public void collectNodes(Set<String> clusters, ActionListener<BiFunction<String, String, DiscoveryNode>> listener) {_        Map<String, RemoteClusterConnection> remoteClusters = this.remoteClusters__        for (String cluster : clusters) {_            if (remoteClusters.containsKey(cluster) == false) {_                listener.onFailure(new IllegalArgumentException("no such remote cluster: [" + cluster + "]"))__                return__            }_        }__        final Map<String, Function<String, DiscoveryNode>> clusterMap = new HashMap<>()__        CountDown countDown = new CountDown(clusters.size())__        Function<String, DiscoveryNode> nullFunction = s -> null__        for (final String cluster : clusters) {_            RemoteClusterConnection connection = remoteClusters.get(cluster)__            connection.collectNodes(new ActionListener<Function<String, DiscoveryNode>>() {_                @Override_                public void onResponse(Function<String, DiscoveryNode> nodeLookup) {_                    synchronized (clusterMap) {_                        clusterMap.put(cluster, nodeLookup)__                    }_                    if (countDown.countDown()) {_                        listener.onResponse((clusterAlias, nodeId)_                                -> clusterMap.getOrDefault(clusterAlias, nullFunction).apply(nodeId))__                    }_                }__                @Override_                public void onFailure(Exception e) {_                    if (countDown.fastForward()) { _                        listener.onFailure(e)__                    }_                }_            })__        }_    };collects,all,nodes,of,the,given,clusters,and,returns,passes,a,cluster,alias,node,id,to,link,discovery,node,function,on,success;public,void,collect,nodes,set,string,clusters,action,listener,bi,function,string,string,discovery,node,listener,map,string,remote,cluster,connection,remote,clusters,this,remote,clusters,for,string,cluster,clusters,if,remote,clusters,contains,key,cluster,false,listener,on,failure,new,illegal,argument,exception,no,such,remote,cluster,cluster,return,final,map,string,function,string,discovery,node,cluster,map,new,hash,map,count,down,count,down,new,count,down,clusters,size,function,string,discovery,node,null,function,s,null,for,final,string,cluster,clusters,remote,cluster,connection,connection,remote,clusters,get,cluster,connection,collect,nodes,new,action,listener,function,string,discovery,node,override,public,void,on,response,function,string,discovery,node,node,lookup,synchronized,cluster,map,cluster,map,put,cluster,node,lookup,if,count,down,count,down,listener,on,response,cluster,alias,node,id,cluster,map,get,or,default,cluster,alias,null,function,apply,node,id,override,public,void,on,failure,exception,e,if,count,down,fast,forward,listener,on,failure,e
RemoteClusterService -> public void collectNodes(Set<String> clusters, ActionListener<BiFunction<String, String, DiscoveryNode>> listener);1545071071;Collects all nodes of the given clusters and returns / passes a (clusterAlias, nodeId) to {@link DiscoveryNode}_function on success.;public void collectNodes(Set<String> clusters, ActionListener<BiFunction<String, String, DiscoveryNode>> listener) {_        Map<String, RemoteClusterConnection> remoteClusters = this.remoteClusters__        for (String cluster : clusters) {_            if (remoteClusters.containsKey(cluster) == false) {_                listener.onFailure(new IllegalArgumentException("no such remote cluster: [" + cluster + "]"))__                return__            }_        }__        final Map<String, Function<String, DiscoveryNode>> clusterMap = new HashMap<>()__        CountDown countDown = new CountDown(clusters.size())__        Function<String, DiscoveryNode> nullFunction = s -> null__        for (final String cluster : clusters) {_            RemoteClusterConnection connection = remoteClusters.get(cluster)__            connection.collectNodes(new ActionListener<Function<String, DiscoveryNode>>() {_                @Override_                public void onResponse(Function<String, DiscoveryNode> nodeLookup) {_                    synchronized (clusterMap) {_                        clusterMap.put(cluster, nodeLookup)__                    }_                    if (countDown.countDown()) {_                        listener.onResponse((clusterAlias, nodeId)_                                -> clusterMap.getOrDefault(clusterAlias, nullFunction).apply(nodeId))__                    }_                }__                @Override_                public void onFailure(Exception e) {_                    if (countDown.fastForward()) { _                        listener.onFailure(e)__                    }_                }_            })__        }_    };collects,all,nodes,of,the,given,clusters,and,returns,passes,a,cluster,alias,node,id,to,link,discovery,node,function,on,success;public,void,collect,nodes,set,string,clusters,action,listener,bi,function,string,string,discovery,node,listener,map,string,remote,cluster,connection,remote,clusters,this,remote,clusters,for,string,cluster,clusters,if,remote,clusters,contains,key,cluster,false,listener,on,failure,new,illegal,argument,exception,no,such,remote,cluster,cluster,return,final,map,string,function,string,discovery,node,cluster,map,new,hash,map,count,down,count,down,new,count,down,clusters,size,function,string,discovery,node,null,function,s,null,for,final,string,cluster,clusters,remote,cluster,connection,connection,remote,clusters,get,cluster,connection,collect,nodes,new,action,listener,function,string,discovery,node,override,public,void,on,response,function,string,discovery,node,node,lookup,synchronized,cluster,map,cluster,map,put,cluster,node,lookup,if,count,down,count,down,listener,on,response,cluster,alias,node,id,cluster,map,get,or,default,cluster,alias,null,function,apply,node,id,override,public,void,on,failure,exception,e,if,count,down,fast,forward,listener,on,failure,e
RemoteClusterService -> public void collectNodes(Set<String> clusters, ActionListener<BiFunction<String, String, DiscoveryNode>> listener);1546929322;Collects all nodes of the given clusters and returns / passes a (clusterAlias, nodeId) to {@link DiscoveryNode}_function on success.;public void collectNodes(Set<String> clusters, ActionListener<BiFunction<String, String, DiscoveryNode>> listener) {_        Map<String, RemoteClusterConnection> remoteClusters = this.remoteClusters__        for (String cluster : clusters) {_            if (remoteClusters.containsKey(cluster) == false) {_                listener.onFailure(new IllegalArgumentException("no such remote cluster: [" + cluster + "]"))__                return__            }_        }__        final Map<String, Function<String, DiscoveryNode>> clusterMap = new HashMap<>()__        CountDown countDown = new CountDown(clusters.size())__        Function<String, DiscoveryNode> nullFunction = s -> null__        for (final String cluster : clusters) {_            RemoteClusterConnection connection = remoteClusters.get(cluster)__            connection.collectNodes(new ActionListener<Function<String, DiscoveryNode>>() {_                @Override_                public void onResponse(Function<String, DiscoveryNode> nodeLookup) {_                    synchronized (clusterMap) {_                        clusterMap.put(cluster, nodeLookup)__                    }_                    if (countDown.countDown()) {_                        listener.onResponse((clusterAlias, nodeId)_                                -> clusterMap.getOrDefault(clusterAlias, nullFunction).apply(nodeId))__                    }_                }__                @Override_                public void onFailure(Exception e) {_                    if (countDown.fastForward()) { _                        listener.onFailure(e)__                    }_                }_            })__        }_    };collects,all,nodes,of,the,given,clusters,and,returns,passes,a,cluster,alias,node,id,to,link,discovery,node,function,on,success;public,void,collect,nodes,set,string,clusters,action,listener,bi,function,string,string,discovery,node,listener,map,string,remote,cluster,connection,remote,clusters,this,remote,clusters,for,string,cluster,clusters,if,remote,clusters,contains,key,cluster,false,listener,on,failure,new,illegal,argument,exception,no,such,remote,cluster,cluster,return,final,map,string,function,string,discovery,node,cluster,map,new,hash,map,count,down,count,down,new,count,down,clusters,size,function,string,discovery,node,null,function,s,null,for,final,string,cluster,clusters,remote,cluster,connection,connection,remote,clusters,get,cluster,connection,collect,nodes,new,action,listener,function,string,discovery,node,override,public,void,on,response,function,string,discovery,node,node,lookup,synchronized,cluster,map,cluster,map,put,cluster,node,lookup,if,count,down,count,down,listener,on,response,cluster,alias,node,id,cluster,map,get,or,default,cluster,alias,null,function,apply,node,id,override,public,void,on,failure,exception,e,if,count,down,fast,forward,listener,on,failure,e
RemoteClusterService -> public void collectNodes(Set<String> clusters, ActionListener<BiFunction<String, String, DiscoveryNode>> listener);1547561945;Collects all nodes of the given clusters and returns / passes a (clusterAlias, nodeId) to {@link DiscoveryNode}_function on success.;public void collectNodes(Set<String> clusters, ActionListener<BiFunction<String, String, DiscoveryNode>> listener) {_        Map<String, RemoteClusterConnection> remoteClusters = this.remoteClusters__        for (String cluster : clusters) {_            if (remoteClusters.containsKey(cluster) == false) {_                listener.onFailure(new IllegalArgumentException("no such remote cluster: [" + cluster + "]"))__                return__            }_        }__        final Map<String, Function<String, DiscoveryNode>> clusterMap = new HashMap<>()__        CountDown countDown = new CountDown(clusters.size())__        Function<String, DiscoveryNode> nullFunction = s -> null__        for (final String cluster : clusters) {_            RemoteClusterConnection connection = remoteClusters.get(cluster)__            connection.collectNodes(new ActionListener<Function<String, DiscoveryNode>>() {_                @Override_                public void onResponse(Function<String, DiscoveryNode> nodeLookup) {_                    synchronized (clusterMap) {_                        clusterMap.put(cluster, nodeLookup)__                    }_                    if (countDown.countDown()) {_                        listener.onResponse((clusterAlias, nodeId)_                                -> clusterMap.getOrDefault(clusterAlias, nullFunction).apply(nodeId))__                    }_                }__                @Override_                public void onFailure(Exception e) {_                    if (countDown.fastForward()) { _                        listener.onFailure(e)__                    }_                }_            })__        }_    };collects,all,nodes,of,the,given,clusters,and,returns,passes,a,cluster,alias,node,id,to,link,discovery,node,function,on,success;public,void,collect,nodes,set,string,clusters,action,listener,bi,function,string,string,discovery,node,listener,map,string,remote,cluster,connection,remote,clusters,this,remote,clusters,for,string,cluster,clusters,if,remote,clusters,contains,key,cluster,false,listener,on,failure,new,illegal,argument,exception,no,such,remote,cluster,cluster,return,final,map,string,function,string,discovery,node,cluster,map,new,hash,map,count,down,count,down,new,count,down,clusters,size,function,string,discovery,node,null,function,s,null,for,final,string,cluster,clusters,remote,cluster,connection,connection,remote,clusters,get,cluster,connection,collect,nodes,new,action,listener,function,string,discovery,node,override,public,void,on,response,function,string,discovery,node,node,lookup,synchronized,cluster,map,cluster,map,put,cluster,node,lookup,if,count,down,count,down,listener,on,response,cluster,alias,node,id,cluster,map,get,or,default,cluster,alias,null,function,apply,node,id,override,public,void,on,failure,exception,e,if,count,down,fast,forward,listener,on,failure,e
RemoteClusterService -> public void collectNodes(Set<String> clusters, ActionListener<BiFunction<String, String, DiscoveryNode>> listener);1548248017;Collects all nodes of the given clusters and returns / passes a (clusterAlias, nodeId) to {@link DiscoveryNode}_function on success.;public void collectNodes(Set<String> clusters, ActionListener<BiFunction<String, String, DiscoveryNode>> listener) {_        Map<String, RemoteClusterConnection> remoteClusters = this.remoteClusters__        for (String cluster : clusters) {_            if (remoteClusters.containsKey(cluster) == false) {_                listener.onFailure(new IllegalArgumentException("no such remote cluster: [" + cluster + "]"))__                return__            }_        }__        final Map<String, Function<String, DiscoveryNode>> clusterMap = new HashMap<>()__        CountDown countDown = new CountDown(clusters.size())__        Function<String, DiscoveryNode> nullFunction = s -> null__        for (final String cluster : clusters) {_            RemoteClusterConnection connection = remoteClusters.get(cluster)__            connection.collectNodes(new ActionListener<Function<String, DiscoveryNode>>() {_                @Override_                public void onResponse(Function<String, DiscoveryNode> nodeLookup) {_                    synchronized (clusterMap) {_                        clusterMap.put(cluster, nodeLookup)__                    }_                    if (countDown.countDown()) {_                        listener.onResponse((clusterAlias, nodeId)_                                -> clusterMap.getOrDefault(clusterAlias, nullFunction).apply(nodeId))__                    }_                }__                @Override_                public void onFailure(Exception e) {_                    if (countDown.fastForward()) { _                        listener.onFailure(e)__                    }_                }_            })__        }_    };collects,all,nodes,of,the,given,clusters,and,returns,passes,a,cluster,alias,node,id,to,link,discovery,node,function,on,success;public,void,collect,nodes,set,string,clusters,action,listener,bi,function,string,string,discovery,node,listener,map,string,remote,cluster,connection,remote,clusters,this,remote,clusters,for,string,cluster,clusters,if,remote,clusters,contains,key,cluster,false,listener,on,failure,new,illegal,argument,exception,no,such,remote,cluster,cluster,return,final,map,string,function,string,discovery,node,cluster,map,new,hash,map,count,down,count,down,new,count,down,clusters,size,function,string,discovery,node,null,function,s,null,for,final,string,cluster,clusters,remote,cluster,connection,connection,remote,clusters,get,cluster,connection,collect,nodes,new,action,listener,function,string,discovery,node,override,public,void,on,response,function,string,discovery,node,node,lookup,synchronized,cluster,map,cluster,map,put,cluster,node,lookup,if,count,down,count,down,listener,on,response,cluster,alias,node,id,cluster,map,get,or,default,cluster,alias,null,function,apply,node,id,override,public,void,on,failure,exception,e,if,count,down,fast,forward,listener,on,failure,e
RemoteClusterService -> public void collectNodes(Set<String> clusters, ActionListener<BiFunction<String, String, DiscoveryNode>> listener);1548402798;Collects all nodes of the given clusters and returns / passes a (clusterAlias, nodeId) to {@link DiscoveryNode}_function on success.;public void collectNodes(Set<String> clusters, ActionListener<BiFunction<String, String, DiscoveryNode>> listener) {_        Map<String, RemoteClusterConnection> remoteClusters = this.remoteClusters__        for (String cluster : clusters) {_            if (remoteClusters.containsKey(cluster) == false) {_                listener.onFailure(new NoSuchRemoteClusterException(cluster))__                return__            }_        }__        final Map<String, Function<String, DiscoveryNode>> clusterMap = new HashMap<>()__        CountDown countDown = new CountDown(clusters.size())__        Function<String, DiscoveryNode> nullFunction = s -> null__        for (final String cluster : clusters) {_            RemoteClusterConnection connection = remoteClusters.get(cluster)__            connection.collectNodes(new ActionListener<Function<String, DiscoveryNode>>() {_                @Override_                public void onResponse(Function<String, DiscoveryNode> nodeLookup) {_                    synchronized (clusterMap) {_                        clusterMap.put(cluster, nodeLookup)__                    }_                    if (countDown.countDown()) {_                        listener.onResponse((clusterAlias, nodeId)_                                -> clusterMap.getOrDefault(clusterAlias, nullFunction).apply(nodeId))__                    }_                }__                @Override_                public void onFailure(Exception e) {_                    if (countDown.fastForward()) { _                        listener.onFailure(e)__                    }_                }_            })__        }_    };collects,all,nodes,of,the,given,clusters,and,returns,passes,a,cluster,alias,node,id,to,link,discovery,node,function,on,success;public,void,collect,nodes,set,string,clusters,action,listener,bi,function,string,string,discovery,node,listener,map,string,remote,cluster,connection,remote,clusters,this,remote,clusters,for,string,cluster,clusters,if,remote,clusters,contains,key,cluster,false,listener,on,failure,new,no,such,remote,cluster,exception,cluster,return,final,map,string,function,string,discovery,node,cluster,map,new,hash,map,count,down,count,down,new,count,down,clusters,size,function,string,discovery,node,null,function,s,null,for,final,string,cluster,clusters,remote,cluster,connection,connection,remote,clusters,get,cluster,connection,collect,nodes,new,action,listener,function,string,discovery,node,override,public,void,on,response,function,string,discovery,node,node,lookup,synchronized,cluster,map,cluster,map,put,cluster,node,lookup,if,count,down,count,down,listener,on,response,cluster,alias,node,id,cluster,map,get,or,default,cluster,alias,null,function,apply,node,id,override,public,void,on,failure,exception,e,if,count,down,fast,forward,listener,on,failure,e
RemoteClusterService -> public void collectNodes(Set<String> clusters, ActionListener<BiFunction<String, String, DiscoveryNode>> listener);1549608646;Collects all nodes of the given clusters and returns / passes a (clusterAlias, nodeId) to {@link DiscoveryNode}_function on success.;public void collectNodes(Set<String> clusters, ActionListener<BiFunction<String, String, DiscoveryNode>> listener) {_        Map<String, RemoteClusterConnection> remoteClusters = this.remoteClusters__        for (String cluster : clusters) {_            if (remoteClusters.containsKey(cluster) == false) {_                listener.onFailure(new NoSuchRemoteClusterException(cluster))__                return__            }_        }__        final Map<String, Function<String, DiscoveryNode>> clusterMap = new HashMap<>()__        CountDown countDown = new CountDown(clusters.size())__        Function<String, DiscoveryNode> nullFunction = s -> null__        for (final String cluster : clusters) {_            RemoteClusterConnection connection = remoteClusters.get(cluster)__            connection.collectNodes(new ActionListener<Function<String, DiscoveryNode>>() {_                @Override_                public void onResponse(Function<String, DiscoveryNode> nodeLookup) {_                    synchronized (clusterMap) {_                        clusterMap.put(cluster, nodeLookup)__                    }_                    if (countDown.countDown()) {_                        listener.onResponse((clusterAlias, nodeId)_                                -> clusterMap.getOrDefault(clusterAlias, nullFunction).apply(nodeId))__                    }_                }__                @Override_                public void onFailure(Exception e) {_                    if (countDown.fastForward()) { _                        listener.onFailure(e)__                    }_                }_            })__        }_    };collects,all,nodes,of,the,given,clusters,and,returns,passes,a,cluster,alias,node,id,to,link,discovery,node,function,on,success;public,void,collect,nodes,set,string,clusters,action,listener,bi,function,string,string,discovery,node,listener,map,string,remote,cluster,connection,remote,clusters,this,remote,clusters,for,string,cluster,clusters,if,remote,clusters,contains,key,cluster,false,listener,on,failure,new,no,such,remote,cluster,exception,cluster,return,final,map,string,function,string,discovery,node,cluster,map,new,hash,map,count,down,count,down,new,count,down,clusters,size,function,string,discovery,node,null,function,s,null,for,final,string,cluster,clusters,remote,cluster,connection,connection,remote,clusters,get,cluster,connection,collect,nodes,new,action,listener,function,string,discovery,node,override,public,void,on,response,function,string,discovery,node,node,lookup,synchronized,cluster,map,cluster,map,put,cluster,node,lookup,if,count,down,count,down,listener,on,response,cluster,alias,node,id,cluster,map,get,or,default,cluster,alias,null,function,apply,node,id,override,public,void,on,failure,exception,e,if,count,down,fast,forward,listener,on,failure,e
RemoteClusterService -> public void collectNodes(Set<String> clusters, ActionListener<BiFunction<String, String, DiscoveryNode>> listener);1550601141;Collects all nodes of the given clusters and returns / passes a (clusterAlias, nodeId) to {@link DiscoveryNode}_function on success.;public void collectNodes(Set<String> clusters, ActionListener<BiFunction<String, String, DiscoveryNode>> listener) {_        Map<String, RemoteClusterConnection> remoteClusters = this.remoteClusters__        for (String cluster : clusters) {_            if (remoteClusters.containsKey(cluster) == false) {_                listener.onFailure(new NoSuchRemoteClusterException(cluster))__                return__            }_        }__        final Map<String, Function<String, DiscoveryNode>> clusterMap = new HashMap<>()__        CountDown countDown = new CountDown(clusters.size())__        Function<String, DiscoveryNode> nullFunction = s -> null__        for (final String cluster : clusters) {_            RemoteClusterConnection connection = remoteClusters.get(cluster)__            connection.collectNodes(new ActionListener<Function<String, DiscoveryNode>>() {_                @Override_                public void onResponse(Function<String, DiscoveryNode> nodeLookup) {_                    synchronized (clusterMap) {_                        clusterMap.put(cluster, nodeLookup)__                    }_                    if (countDown.countDown()) {_                        listener.onResponse((clusterAlias, nodeId)_                                -> clusterMap.getOrDefault(clusterAlias, nullFunction).apply(nodeId))__                    }_                }__                @Override_                public void onFailure(Exception e) {_                    if (countDown.fastForward()) { _                        listener.onFailure(e)__                    }_                }_            })__        }_    };collects,all,nodes,of,the,given,clusters,and,returns,passes,a,cluster,alias,node,id,to,link,discovery,node,function,on,success;public,void,collect,nodes,set,string,clusters,action,listener,bi,function,string,string,discovery,node,listener,map,string,remote,cluster,connection,remote,clusters,this,remote,clusters,for,string,cluster,clusters,if,remote,clusters,contains,key,cluster,false,listener,on,failure,new,no,such,remote,cluster,exception,cluster,return,final,map,string,function,string,discovery,node,cluster,map,new,hash,map,count,down,count,down,new,count,down,clusters,size,function,string,discovery,node,null,function,s,null,for,final,string,cluster,clusters,remote,cluster,connection,connection,remote,clusters,get,cluster,connection,collect,nodes,new,action,listener,function,string,discovery,node,override,public,void,on,response,function,string,discovery,node,node,lookup,synchronized,cluster,map,cluster,map,put,cluster,node,lookup,if,count,down,count,down,listener,on,response,cluster,alias,node,id,cluster,map,get,or,default,cluster,alias,null,function,apply,node,id,override,public,void,on,failure,exception,e,if,count,down,fast,forward,listener,on,failure,e
RemoteClusterService -> public boolean isCrossClusterSearchEnabled();1524684173;Returns <code>true</code> if at least one remote cluster is configured;public boolean isCrossClusterSearchEnabled() {_        return remoteClusters.isEmpty() == false__    };returns,code,true,code,if,at,least,one,remote,cluster,is,configured;public,boolean,is,cross,cluster,search,enabled,return,remote,clusters,is,empty,false
RemoteClusterService -> public boolean isCrossClusterSearchEnabled();1525076988;Returns <code>true</code> if at least one remote cluster is configured;public boolean isCrossClusterSearchEnabled() {_        return remoteClusters.isEmpty() == false__    };returns,code,true,code,if,at,least,one,remote,cluster,is,configured;public,boolean,is,cross,cluster,search,enabled,return,remote,clusters,is,empty,false
RemoteClusterService -> public boolean isCrossClusterSearchEnabled();1525334055;Returns <code>true</code> if at least one remote cluster is configured;public boolean isCrossClusterSearchEnabled() {_        return remoteClusters.isEmpty() == false__    };returns,code,true,code,if,at,least,one,remote,cluster,is,configured;public,boolean,is,cross,cluster,search,enabled,return,remote,clusters,is,empty,false
RemoteClusterService -> public boolean isCrossClusterSearchEnabled();1527773340;Returns <code>true</code> if at least one remote cluster is configured;public boolean isCrossClusterSearchEnabled() {_        return remoteClusters.isEmpty() == false__    };returns,code,true,code,if,at,least,one,remote,cluster,is,configured;public,boolean,is,cross,cluster,search,enabled,return,remote,clusters,is,empty,false
RemoteClusterService -> public boolean isCrossClusterSearchEnabled();1527840262;Returns <code>true</code> if at least one remote cluster is configured;public boolean isCrossClusterSearchEnabled() {_        return remoteClusters.isEmpty() == false__    };returns,code,true,code,if,at,least,one,remote,cluster,is,configured;public,boolean,is,cross,cluster,search,enabled,return,remote,clusters,is,empty,false
RemoteClusterService -> public boolean isCrossClusterSearchEnabled();1534755962;Returns <code>true</code> if at least one remote cluster is configured;public boolean isCrossClusterSearchEnabled() {_        return remoteClusters.isEmpty() == false__    };returns,code,true,code,if,at,least,one,remote,cluster,is,configured;public,boolean,is,cross,cluster,search,enabled,return,remote,clusters,is,empty,false
RemoteClusterService -> public boolean isCrossClusterSearchEnabled();1535046779;Returns <code>true</code> if at least one remote cluster is configured;public boolean isCrossClusterSearchEnabled() {_        return remoteClusters.isEmpty() == false__    };returns,code,true,code,if,at,least,one,remote,cluster,is,configured;public,boolean,is,cross,cluster,search,enabled,return,remote,clusters,is,empty,false
RemoteClusterService -> public boolean isCrossClusterSearchEnabled();1535383145;Returns <code>true</code> if at least one remote cluster is configured;public boolean isCrossClusterSearchEnabled() {_        return remoteClusters.isEmpty() == false__    };returns,code,true,code,if,at,least,one,remote,cluster,is,configured;public,boolean,is,cross,cluster,search,enabled,return,remote,clusters,is,empty,false
RemoteClusterService -> public boolean isCrossClusterSearchEnabled();1536218260;Returns <code>true</code> if at least one remote cluster is configured;public boolean isCrossClusterSearchEnabled() {_        return remoteClusters.isEmpty() == false__    };returns,code,true,code,if,at,least,one,remote,cluster,is,configured;public,boolean,is,cross,cluster,search,enabled,return,remote,clusters,is,empty,false
RemoteClusterService -> public boolean isCrossClusterSearchEnabled();1536828374;Returns <code>true</code> if at least one remote cluster is configured;public boolean isCrossClusterSearchEnabled() {_        return remoteClusters.isEmpty() == false__    };returns,code,true,code,if,at,least,one,remote,cluster,is,configured;public,boolean,is,cross,cluster,search,enabled,return,remote,clusters,is,empty,false
RemoteClusterService -> public boolean isCrossClusterSearchEnabled();1537806831;Returns <code>true</code> if at least one remote cluster is configured;public boolean isCrossClusterSearchEnabled() {_        return remoteClusters.isEmpty() == false__    };returns,code,true,code,if,at,least,one,remote,cluster,is,configured;public,boolean,is,cross,cluster,search,enabled,return,remote,clusters,is,empty,false
RemoteClusterService -> public boolean isCrossClusterSearchEnabled();1541008027;Returns <code>true</code> if at least one remote cluster is configured;public boolean isCrossClusterSearchEnabled() {_        return remoteClusters.isEmpty() == false__    };returns,code,true,code,if,at,least,one,remote,cluster,is,configured;public,boolean,is,cross,cluster,search,enabled,return,remote,clusters,is,empty,false
RemoteClusterService -> public boolean isCrossClusterSearchEnabled();1541698679;Returns <code>true</code> if at least one remote cluster is configured;public boolean isCrossClusterSearchEnabled() {_        return remoteClusters.isEmpty() == false__    };returns,code,true,code,if,at,least,one,remote,cluster,is,configured;public,boolean,is,cross,cluster,search,enabled,return,remote,clusters,is,empty,false
RemoteClusterService -> public boolean isCrossClusterSearchEnabled();1542402632;Returns <code>true</code> if at least one remote cluster is configured;public boolean isCrossClusterSearchEnabled() {_        return remoteClusters.isEmpty() == false__    };returns,code,true,code,if,at,least,one,remote,cluster,is,configured;public,boolean,is,cross,cluster,search,enabled,return,remote,clusters,is,empty,false
RemoteClusterService -> public boolean isCrossClusterSearchEnabled();1543506953;Returns <code>true</code> if at least one remote cluster is configured;public boolean isCrossClusterSearchEnabled() {_        return remoteClusters.isEmpty() == false__    };returns,code,true,code,if,at,least,one,remote,cluster,is,configured;public,boolean,is,cross,cluster,search,enabled,return,remote,clusters,is,empty,false
RemoteClusterService -> public boolean isCrossClusterSearchEnabled();1543959410;Returns <code>true</code> if at least one remote cluster is configured;public boolean isCrossClusterSearchEnabled() {_        return remoteClusters.isEmpty() == false__    };returns,code,true,code,if,at,least,one,remote,cluster,is,configured;public,boolean,is,cross,cluster,search,enabled,return,remote,clusters,is,empty,false
RemoteClusterService -> public boolean isCrossClusterSearchEnabled();1544823664;Returns <code>true</code> if at least one remote cluster is configured;public boolean isCrossClusterSearchEnabled() {_        return remoteClusters.isEmpty() == false__    };returns,code,true,code,if,at,least,one,remote,cluster,is,configured;public,boolean,is,cross,cluster,search,enabled,return,remote,clusters,is,empty,false
RemoteClusterService -> public boolean isCrossClusterSearchEnabled();1545071071;Returns <code>true</code> if at least one remote cluster is configured;public boolean isCrossClusterSearchEnabled() {_        return remoteClusters.isEmpty() == false__    };returns,code,true,code,if,at,least,one,remote,cluster,is,configured;public,boolean,is,cross,cluster,search,enabled,return,remote,clusters,is,empty,false
RemoteClusterService -> public boolean isCrossClusterSearchEnabled();1546929322;Returns <code>true</code> if at least one remote cluster is configured;public boolean isCrossClusterSearchEnabled() {_        return remoteClusters.isEmpty() == false__    };returns,code,true,code,if,at,least,one,remote,cluster,is,configured;public,boolean,is,cross,cluster,search,enabled,return,remote,clusters,is,empty,false
RemoteClusterService -> public boolean isCrossClusterSearchEnabled();1547561945;Returns <code>true</code> if at least one remote cluster is configured;public boolean isCrossClusterSearchEnabled() {_        return remoteClusters.isEmpty() == false__    };returns,code,true,code,if,at,least,one,remote,cluster,is,configured;public,boolean,is,cross,cluster,search,enabled,return,remote,clusters,is,empty,false
RemoteClusterService -> public boolean isCrossClusterSearchEnabled();1548248017;Returns <code>true</code> if at least one remote cluster is configured;public boolean isCrossClusterSearchEnabled() {_        return remoteClusters.isEmpty() == false__    };returns,code,true,code,if,at,least,one,remote,cluster,is,configured;public,boolean,is,cross,cluster,search,enabled,return,remote,clusters,is,empty,false
RemoteClusterService -> public boolean isCrossClusterSearchEnabled();1548402798;Returns <code>true</code> if at least one remote cluster is configured;public boolean isCrossClusterSearchEnabled() {_        return remoteClusters.isEmpty() == false__    };returns,code,true,code,if,at,least,one,remote,cluster,is,configured;public,boolean,is,cross,cluster,search,enabled,return,remote,clusters,is,empty,false
RemoteClusterService -> public boolean isCrossClusterSearchEnabled();1549608646;Returns <code>true</code> if at least one remote cluster is configured;public boolean isCrossClusterSearchEnabled() {_        return remoteClusters.isEmpty() == false__    };returns,code,true,code,if,at,least,one,remote,cluster,is,configured;public,boolean,is,cross,cluster,search,enabled,return,remote,clusters,is,empty,false
RemoteClusterService -> public boolean isCrossClusterSearchEnabled();1550601141;Returns <code>true</code> if at least one remote cluster is configured;public boolean isCrossClusterSearchEnabled() {_        return remoteClusters.isEmpty() == false__    };returns,code,true,code,if,at,least,one,remote,cluster,is,configured;public,boolean,is,cross,cluster,search,enabled,return,remote,clusters,is,empty,false
RemoteClusterService -> private synchronized void updateRemoteClusters(Map<String, Tuple<String, List<Tuple<String, Supplier<DiscoveryNode>>>>> seeds,                                                    ActionListener<Void> connectionListener);1545071071;This method updates the list of remote clusters. It's intended to be used as an update consumer on the settings infrastructure_@param seeds a cluster alias to discovery node mapping representing the remote clusters seeds nodes_@param connectionListener a listener invoked once every configured cluster has been connected to;private synchronized void updateRemoteClusters(Map<String, Tuple<String, List<Tuple<String, Supplier<DiscoveryNode>>>>> seeds,_                                                   ActionListener<Void> connectionListener) {_        if (seeds.containsKey(LOCAL_CLUSTER_GROUP_KEY)) {_            throw new IllegalArgumentException("remote clusters must not have the empty string as its key")__        }_        Map<String, RemoteClusterConnection> remoteClusters = new HashMap<>()__        if (seeds.isEmpty()) {_            connectionListener.onResponse(null)__        } else {_            CountDown countDown = new CountDown(seeds.size())__            remoteClusters.putAll(this.remoteClusters)__            for (Map.Entry<String, Tuple<String, List<Tuple<String, Supplier<DiscoveryNode>>>>> entry : seeds.entrySet()) {_                List<Tuple<String, Supplier<DiscoveryNode>>> seedList = entry.getValue().v2()__                String proxyAddress = entry.getValue().v1()___                RemoteClusterConnection remote = this.remoteClusters.get(entry.getKey())__                if (seedList.isEmpty()) { _                    try {_                        IOUtils.close(remote)__                    } catch (IOException e) {_                        logger.warn("failed to close remote cluster connections for cluster: " + entry.getKey(), e)__                    }_                    remoteClusters.remove(entry.getKey())__                    continue__                }__                if (remote == null) { _                    String clusterAlias = entry.getKey()__                    remote = new RemoteClusterConnection(settings, clusterAlias, seedList, transportService, numRemoteConnections,_                        getNodePredicate(settings), proxyAddress)__                    remoteClusters.put(clusterAlias, remote)__                }__                _                RemoteClusterConnection finalRemote = remote__                remote.updateSeedNodes(proxyAddress, seedList, ActionListener.wrap(_                        response -> {_                            if (countDown.countDown()) {_                                connectionListener.onResponse(response)__                            }_                        },_                        exception -> {_                            if (countDown.fastForward()) {_                                connectionListener.onFailure(exception)__                            }_                            if (finalRemote.isClosed() == false) {_                                logger.warn("failed to update seed list for cluster: " + entry.getKey(), exception)__                            }_                        }))__            }_        }_        this.remoteClusters = Collections.unmodifiableMap(remoteClusters)__    };this,method,updates,the,list,of,remote,clusters,it,s,intended,to,be,used,as,an,update,consumer,on,the,settings,infrastructure,param,seeds,a,cluster,alias,to,discovery,node,mapping,representing,the,remote,clusters,seeds,nodes,param,connection,listener,a,listener,invoked,once,every,configured,cluster,has,been,connected,to;private,synchronized,void,update,remote,clusters,map,string,tuple,string,list,tuple,string,supplier,discovery,node,seeds,action,listener,void,connection,listener,if,seeds,contains,key,throw,new,illegal,argument,exception,remote,clusters,must,not,have,the,empty,string,as,its,key,map,string,remote,cluster,connection,remote,clusters,new,hash,map,if,seeds,is,empty,connection,listener,on,response,null,else,count,down,count,down,new,count,down,seeds,size,remote,clusters,put,all,this,remote,clusters,for,map,entry,string,tuple,string,list,tuple,string,supplier,discovery,node,entry,seeds,entry,set,list,tuple,string,supplier,discovery,node,seed,list,entry,get,value,v2,string,proxy,address,entry,get,value,v1,remote,cluster,connection,remote,this,remote,clusters,get,entry,get,key,if,seed,list,is,empty,try,ioutils,close,remote,catch,ioexception,e,logger,warn,failed,to,close,remote,cluster,connections,for,cluster,entry,get,key,e,remote,clusters,remove,entry,get,key,continue,if,remote,null,string,cluster,alias,entry,get,key,remote,new,remote,cluster,connection,settings,cluster,alias,seed,list,transport,service,num,remote,connections,get,node,predicate,settings,proxy,address,remote,clusters,put,cluster,alias,remote,remote,cluster,connection,final,remote,remote,remote,update,seed,nodes,proxy,address,seed,list,action,listener,wrap,response,if,count,down,count,down,connection,listener,on,response,response,exception,if,count,down,fast,forward,connection,listener,on,failure,exception,if,final,remote,is,closed,false,logger,warn,failed,to,update,seed,list,for,cluster,entry,get,key,exception,this,remote,clusters,collections,unmodifiable,map,remote,clusters
RemoteClusterService -> private synchronized void updateRemoteClusters(Map<String, Tuple<String, List<Tuple<String, Supplier<DiscoveryNode>>>>> seeds,                                                    ActionListener<Void> connectionListener);1546929322;This method updates the list of remote clusters. It's intended to be used as an update consumer on the settings infrastructure_@param seeds a cluster alias to discovery node mapping representing the remote clusters seeds nodes_@param connectionListener a listener invoked once every configured cluster has been connected to;private synchronized void updateRemoteClusters(Map<String, Tuple<String, List<Tuple<String, Supplier<DiscoveryNode>>>>> seeds,_                                                   ActionListener<Void> connectionListener) {_        if (seeds.containsKey(LOCAL_CLUSTER_GROUP_KEY)) {_            throw new IllegalArgumentException("remote clusters must not have the empty string as its key")__        }_        Map<String, RemoteClusterConnection> remoteClusters = new HashMap<>()__        if (seeds.isEmpty()) {_            connectionListener.onResponse(null)__        } else {_            CountDown countDown = new CountDown(seeds.size())__            remoteClusters.putAll(this.remoteClusters)__            for (Map.Entry<String, Tuple<String, List<Tuple<String, Supplier<DiscoveryNode>>>>> entry : seeds.entrySet()) {_                List<Tuple<String, Supplier<DiscoveryNode>>> seedList = entry.getValue().v2()__                String proxyAddress = entry.getValue().v1()___                RemoteClusterConnection remote = this.remoteClusters.get(entry.getKey())__                if (seedList.isEmpty()) { _                    try {_                        IOUtils.close(remote)__                    } catch (IOException e) {_                        logger.warn("failed to close remote cluster connections for cluster: " + entry.getKey(), e)__                    }_                    remoteClusters.remove(entry.getKey())__                    continue__                }__                if (remote == null) { _                    String clusterAlias = entry.getKey()__                    remote = new RemoteClusterConnection(settings, clusterAlias, seedList, transportService, numRemoteConnections,_                        getNodePredicate(settings), proxyAddress)__                    remoteClusters.put(clusterAlias, remote)__                }__                _                RemoteClusterConnection finalRemote = remote__                remote.updateSeedNodes(proxyAddress, seedList, ActionListener.wrap(_                        response -> {_                            if (countDown.countDown()) {_                                connectionListener.onResponse(response)__                            }_                        },_                        exception -> {_                            if (countDown.fastForward()) {_                                connectionListener.onFailure(exception)__                            }_                            if (finalRemote.isClosed() == false) {_                                logger.warn("failed to update seed list for cluster: " + entry.getKey(), exception)__                            }_                        }))__            }_        }_        this.remoteClusters = Collections.unmodifiableMap(remoteClusters)__    };this,method,updates,the,list,of,remote,clusters,it,s,intended,to,be,used,as,an,update,consumer,on,the,settings,infrastructure,param,seeds,a,cluster,alias,to,discovery,node,mapping,representing,the,remote,clusters,seeds,nodes,param,connection,listener,a,listener,invoked,once,every,configured,cluster,has,been,connected,to;private,synchronized,void,update,remote,clusters,map,string,tuple,string,list,tuple,string,supplier,discovery,node,seeds,action,listener,void,connection,listener,if,seeds,contains,key,throw,new,illegal,argument,exception,remote,clusters,must,not,have,the,empty,string,as,its,key,map,string,remote,cluster,connection,remote,clusters,new,hash,map,if,seeds,is,empty,connection,listener,on,response,null,else,count,down,count,down,new,count,down,seeds,size,remote,clusters,put,all,this,remote,clusters,for,map,entry,string,tuple,string,list,tuple,string,supplier,discovery,node,entry,seeds,entry,set,list,tuple,string,supplier,discovery,node,seed,list,entry,get,value,v2,string,proxy,address,entry,get,value,v1,remote,cluster,connection,remote,this,remote,clusters,get,entry,get,key,if,seed,list,is,empty,try,ioutils,close,remote,catch,ioexception,e,logger,warn,failed,to,close,remote,cluster,connections,for,cluster,entry,get,key,e,remote,clusters,remove,entry,get,key,continue,if,remote,null,string,cluster,alias,entry,get,key,remote,new,remote,cluster,connection,settings,cluster,alias,seed,list,transport,service,num,remote,connections,get,node,predicate,settings,proxy,address,remote,clusters,put,cluster,alias,remote,remote,cluster,connection,final,remote,remote,remote,update,seed,nodes,proxy,address,seed,list,action,listener,wrap,response,if,count,down,count,down,connection,listener,on,response,response,exception,if,count,down,fast,forward,connection,listener,on,failure,exception,if,final,remote,is,closed,false,logger,warn,failed,to,update,seed,list,for,cluster,entry,get,key,exception,this,remote,clusters,collections,unmodifiable,map,remote,clusters
RemoteClusterService -> private synchronized void updateRemoteClusters(Map<String, Tuple<String, List<Tuple<String, Supplier<DiscoveryNode>>>>> seeds,                                                    ActionListener<Void> connectionListener);1547561945;This method updates the list of remote clusters. It's intended to be used as an update consumer on the settings infrastructure_@param seeds a cluster alias to discovery node mapping representing the remote clusters seeds nodes_@param connectionListener a listener invoked once every configured cluster has been connected to;private synchronized void updateRemoteClusters(Map<String, Tuple<String, List<Tuple<String, Supplier<DiscoveryNode>>>>> seeds,_                                                   ActionListener<Void> connectionListener) {_        if (seeds.containsKey(LOCAL_CLUSTER_GROUP_KEY)) {_            throw new IllegalArgumentException("remote clusters must not have the empty string as its key")__        }_        Map<String, RemoteClusterConnection> remoteClusters = new HashMap<>()__        if (seeds.isEmpty()) {_            connectionListener.onResponse(null)__        } else {_            CountDown countDown = new CountDown(seeds.size())__            remoteClusters.putAll(this.remoteClusters)__            for (Map.Entry<String, Tuple<String, List<Tuple<String, Supplier<DiscoveryNode>>>>> entry : seeds.entrySet()) {_                List<Tuple<String, Supplier<DiscoveryNode>>> seedList = entry.getValue().v2()__                String proxyAddress = entry.getValue().v1()___                RemoteClusterConnection remote = this.remoteClusters.get(entry.getKey())__                if (seedList.isEmpty()) { _                    try {_                        IOUtils.close(remote)__                    } catch (IOException e) {_                        logger.warn("failed to close remote cluster connections for cluster: " + entry.getKey(), e)__                    }_                    remoteClusters.remove(entry.getKey())__                    continue__                }__                if (remote == null) { _                    String clusterAlias = entry.getKey()__                    remote = new RemoteClusterConnection(settings, clusterAlias, seedList, transportService, numRemoteConnections,_                        getNodePredicate(settings), proxyAddress)__                    remoteClusters.put(clusterAlias, remote)__                }__                _                RemoteClusterConnection finalRemote = remote__                remote.updateSeedNodes(proxyAddress, seedList, ActionListener.wrap(_                        response -> {_                            if (countDown.countDown()) {_                                connectionListener.onResponse(response)__                            }_                        },_                        exception -> {_                            if (countDown.fastForward()) {_                                connectionListener.onFailure(exception)__                            }_                            if (finalRemote.isClosed() == false) {_                                logger.warn("failed to update seed list for cluster: " + entry.getKey(), exception)__                            }_                        }))__            }_        }_        this.remoteClusters = Collections.unmodifiableMap(remoteClusters)__    };this,method,updates,the,list,of,remote,clusters,it,s,intended,to,be,used,as,an,update,consumer,on,the,settings,infrastructure,param,seeds,a,cluster,alias,to,discovery,node,mapping,representing,the,remote,clusters,seeds,nodes,param,connection,listener,a,listener,invoked,once,every,configured,cluster,has,been,connected,to;private,synchronized,void,update,remote,clusters,map,string,tuple,string,list,tuple,string,supplier,discovery,node,seeds,action,listener,void,connection,listener,if,seeds,contains,key,throw,new,illegal,argument,exception,remote,clusters,must,not,have,the,empty,string,as,its,key,map,string,remote,cluster,connection,remote,clusters,new,hash,map,if,seeds,is,empty,connection,listener,on,response,null,else,count,down,count,down,new,count,down,seeds,size,remote,clusters,put,all,this,remote,clusters,for,map,entry,string,tuple,string,list,tuple,string,supplier,discovery,node,entry,seeds,entry,set,list,tuple,string,supplier,discovery,node,seed,list,entry,get,value,v2,string,proxy,address,entry,get,value,v1,remote,cluster,connection,remote,this,remote,clusters,get,entry,get,key,if,seed,list,is,empty,try,ioutils,close,remote,catch,ioexception,e,logger,warn,failed,to,close,remote,cluster,connections,for,cluster,entry,get,key,e,remote,clusters,remove,entry,get,key,continue,if,remote,null,string,cluster,alias,entry,get,key,remote,new,remote,cluster,connection,settings,cluster,alias,seed,list,transport,service,num,remote,connections,get,node,predicate,settings,proxy,address,remote,clusters,put,cluster,alias,remote,remote,cluster,connection,final,remote,remote,remote,update,seed,nodes,proxy,address,seed,list,action,listener,wrap,response,if,count,down,count,down,connection,listener,on,response,response,exception,if,count,down,fast,forward,connection,listener,on,failure,exception,if,final,remote,is,closed,false,logger,warn,failed,to,update,seed,list,for,cluster,entry,get,key,exception,this,remote,clusters,collections,unmodifiable,map,remote,clusters
RemoteClusterService -> private synchronized void updateRemoteClusters(Map<String, Tuple<String, List<Tuple<String, Supplier<DiscoveryNode>>>>> seeds,                                                    ActionListener<Void> connectionListener);1548248017;This method updates the list of remote clusters. It's intended to be used as an update consumer on the settings infrastructure_@param seeds a cluster alias to discovery node mapping representing the remote clusters seeds nodes_@param connectionListener a listener invoked once every configured cluster has been connected to;private synchronized void updateRemoteClusters(Map<String, Tuple<String, List<Tuple<String, Supplier<DiscoveryNode>>>>> seeds,_                                                   ActionListener<Void> connectionListener) {_        if (seeds.containsKey(LOCAL_CLUSTER_GROUP_KEY)) {_            throw new IllegalArgumentException("remote clusters must not have the empty string as its key")__        }_        Map<String, RemoteClusterConnection> remoteClusters = new HashMap<>()__        if (seeds.isEmpty()) {_            connectionListener.onResponse(null)__        } else {_            CountDown countDown = new CountDown(seeds.size())__            remoteClusters.putAll(this.remoteClusters)__            for (Map.Entry<String, Tuple<String, List<Tuple<String, Supplier<DiscoveryNode>>>>> entry : seeds.entrySet()) {_                List<Tuple<String, Supplier<DiscoveryNode>>> seedList = entry.getValue().v2()__                String proxyAddress = entry.getValue().v1()___                RemoteClusterConnection remote = this.remoteClusters.get(entry.getKey())__                if (seedList.isEmpty()) { _                    try {_                        IOUtils.close(remote)__                    } catch (IOException e) {_                        logger.warn("failed to close remote cluster connections for cluster: " + entry.getKey(), e)__                    }_                    remoteClusters.remove(entry.getKey())__                    continue__                }__                if (remote == null) { _                    String clusterAlias = entry.getKey()__                    remote = new RemoteClusterConnection(settings, clusterAlias, seedList, transportService, numRemoteConnections,_                        getNodePredicate(settings), proxyAddress)__                    remoteClusters.put(clusterAlias, remote)__                }__                _                RemoteClusterConnection finalRemote = remote__                remote.updateSeedNodes(proxyAddress, seedList, ActionListener.wrap(_                        response -> {_                            if (countDown.countDown()) {_                                connectionListener.onResponse(response)__                            }_                        },_                        exception -> {_                            if (countDown.fastForward()) {_                                connectionListener.onFailure(exception)__                            }_                            if (finalRemote.isClosed() == false) {_                                logger.warn("failed to update seed list for cluster: " + entry.getKey(), exception)__                            }_                        }))__            }_        }_        this.remoteClusters = Collections.unmodifiableMap(remoteClusters)__    };this,method,updates,the,list,of,remote,clusters,it,s,intended,to,be,used,as,an,update,consumer,on,the,settings,infrastructure,param,seeds,a,cluster,alias,to,discovery,node,mapping,representing,the,remote,clusters,seeds,nodes,param,connection,listener,a,listener,invoked,once,every,configured,cluster,has,been,connected,to;private,synchronized,void,update,remote,clusters,map,string,tuple,string,list,tuple,string,supplier,discovery,node,seeds,action,listener,void,connection,listener,if,seeds,contains,key,throw,new,illegal,argument,exception,remote,clusters,must,not,have,the,empty,string,as,its,key,map,string,remote,cluster,connection,remote,clusters,new,hash,map,if,seeds,is,empty,connection,listener,on,response,null,else,count,down,count,down,new,count,down,seeds,size,remote,clusters,put,all,this,remote,clusters,for,map,entry,string,tuple,string,list,tuple,string,supplier,discovery,node,entry,seeds,entry,set,list,tuple,string,supplier,discovery,node,seed,list,entry,get,value,v2,string,proxy,address,entry,get,value,v1,remote,cluster,connection,remote,this,remote,clusters,get,entry,get,key,if,seed,list,is,empty,try,ioutils,close,remote,catch,ioexception,e,logger,warn,failed,to,close,remote,cluster,connections,for,cluster,entry,get,key,e,remote,clusters,remove,entry,get,key,continue,if,remote,null,string,cluster,alias,entry,get,key,remote,new,remote,cluster,connection,settings,cluster,alias,seed,list,transport,service,num,remote,connections,get,node,predicate,settings,proxy,address,remote,clusters,put,cluster,alias,remote,remote,cluster,connection,final,remote,remote,remote,update,seed,nodes,proxy,address,seed,list,action,listener,wrap,response,if,count,down,count,down,connection,listener,on,response,response,exception,if,count,down,fast,forward,connection,listener,on,failure,exception,if,final,remote,is,closed,false,logger,warn,failed,to,update,seed,list,for,cluster,entry,get,key,exception,this,remote,clusters,collections,unmodifiable,map,remote,clusters
RemoteClusterService -> private synchronized void updateRemoteClusters(Map<String, Tuple<String, List<Tuple<String, Supplier<DiscoveryNode>>>>> seeds,                                                    ActionListener<Void> connectionListener);1548402798;This method updates the list of remote clusters. It's intended to be used as an update consumer on the settings infrastructure_@param seeds a cluster alias to discovery node mapping representing the remote clusters seeds nodes_@param connectionListener a listener invoked once every configured cluster has been connected to;private synchronized void updateRemoteClusters(Map<String, Tuple<String, List<Tuple<String, Supplier<DiscoveryNode>>>>> seeds,_                                                   ActionListener<Void> connectionListener) {_        if (seeds.containsKey(LOCAL_CLUSTER_GROUP_KEY)) {_            throw new IllegalArgumentException("remote clusters must not have the empty string as its key")__        }_        Map<String, RemoteClusterConnection> remoteClusters = new HashMap<>()__        if (seeds.isEmpty()) {_            connectionListener.onResponse(null)__        } else {_            CountDown countDown = new CountDown(seeds.size())__            remoteClusters.putAll(this.remoteClusters)__            for (Map.Entry<String, Tuple<String, List<Tuple<String, Supplier<DiscoveryNode>>>>> entry : seeds.entrySet()) {_                List<Tuple<String, Supplier<DiscoveryNode>>> seedList = entry.getValue().v2()__                String proxyAddress = entry.getValue().v1()___                RemoteClusterConnection remote = this.remoteClusters.get(entry.getKey())__                if (seedList.isEmpty()) { _                    try {_                        IOUtils.close(remote)__                    } catch (IOException e) {_                        logger.warn("failed to close remote cluster connections for cluster: " + entry.getKey(), e)__                    }_                    remoteClusters.remove(entry.getKey())__                    continue__                }__                if (remote == null) { _                    String clusterAlias = entry.getKey()__                    remote = new RemoteClusterConnection(settings, clusterAlias, seedList, transportService, numRemoteConnections,_                        getNodePredicate(settings), proxyAddress)__                    remoteClusters.put(clusterAlias, remote)__                }__                _                RemoteClusterConnection finalRemote = remote__                remote.updateSeedNodes(proxyAddress, seedList, ActionListener.wrap(_                        response -> {_                            if (countDown.countDown()) {_                                connectionListener.onResponse(response)__                            }_                        },_                        exception -> {_                            if (countDown.fastForward()) {_                                connectionListener.onFailure(exception)__                            }_                            if (finalRemote.isClosed() == false) {_                                logger.warn("failed to update seed list for cluster: " + entry.getKey(), exception)__                            }_                        }))__            }_        }_        this.remoteClusters = Collections.unmodifiableMap(remoteClusters)__    };this,method,updates,the,list,of,remote,clusters,it,s,intended,to,be,used,as,an,update,consumer,on,the,settings,infrastructure,param,seeds,a,cluster,alias,to,discovery,node,mapping,representing,the,remote,clusters,seeds,nodes,param,connection,listener,a,listener,invoked,once,every,configured,cluster,has,been,connected,to;private,synchronized,void,update,remote,clusters,map,string,tuple,string,list,tuple,string,supplier,discovery,node,seeds,action,listener,void,connection,listener,if,seeds,contains,key,throw,new,illegal,argument,exception,remote,clusters,must,not,have,the,empty,string,as,its,key,map,string,remote,cluster,connection,remote,clusters,new,hash,map,if,seeds,is,empty,connection,listener,on,response,null,else,count,down,count,down,new,count,down,seeds,size,remote,clusters,put,all,this,remote,clusters,for,map,entry,string,tuple,string,list,tuple,string,supplier,discovery,node,entry,seeds,entry,set,list,tuple,string,supplier,discovery,node,seed,list,entry,get,value,v2,string,proxy,address,entry,get,value,v1,remote,cluster,connection,remote,this,remote,clusters,get,entry,get,key,if,seed,list,is,empty,try,ioutils,close,remote,catch,ioexception,e,logger,warn,failed,to,close,remote,cluster,connections,for,cluster,entry,get,key,e,remote,clusters,remove,entry,get,key,continue,if,remote,null,string,cluster,alias,entry,get,key,remote,new,remote,cluster,connection,settings,cluster,alias,seed,list,transport,service,num,remote,connections,get,node,predicate,settings,proxy,address,remote,clusters,put,cluster,alias,remote,remote,cluster,connection,final,remote,remote,remote,update,seed,nodes,proxy,address,seed,list,action,listener,wrap,response,if,count,down,count,down,connection,listener,on,response,response,exception,if,count,down,fast,forward,connection,listener,on,failure,exception,if,final,remote,is,closed,false,logger,warn,failed,to,update,seed,list,for,cluster,entry,get,key,exception,this,remote,clusters,collections,unmodifiable,map,remote,clusters
RemoteClusterService -> private synchronized void updateRemoteClusters(Map<String, Tuple<String, List<Tuple<String, Supplier<DiscoveryNode>>>>> seeds,                                                    ActionListener<Void> connectionListener);1549608646;This method updates the list of remote clusters. It's intended to be used as an update consumer on the settings infrastructure_@param seeds a cluster alias to discovery node mapping representing the remote clusters seeds nodes_@param connectionListener a listener invoked once every configured cluster has been connected to;private synchronized void updateRemoteClusters(Map<String, Tuple<String, List<Tuple<String, Supplier<DiscoveryNode>>>>> seeds,_                                                   ActionListener<Void> connectionListener) {_        if (seeds.containsKey(LOCAL_CLUSTER_GROUP_KEY)) {_            throw new IllegalArgumentException("remote clusters must not have the empty string as its key")__        }_        Map<String, RemoteClusterConnection> remoteClusters = new HashMap<>()__        if (seeds.isEmpty()) {_            connectionListener.onResponse(null)__        } else {_            CountDown countDown = new CountDown(seeds.size())__            remoteClusters.putAll(this.remoteClusters)__            for (Map.Entry<String, Tuple<String, List<Tuple<String, Supplier<DiscoveryNode>>>>> entry : seeds.entrySet()) {_                List<Tuple<String, Supplier<DiscoveryNode>>> seedList = entry.getValue().v2()__                String proxyAddress = entry.getValue().v1()___                RemoteClusterConnection remote = this.remoteClusters.get(entry.getKey())__                if (seedList.isEmpty()) { _                    try {_                        IOUtils.close(remote)__                    } catch (IOException e) {_                        logger.warn("failed to close remote cluster connections for cluster: " + entry.getKey(), e)__                    }_                    remoteClusters.remove(entry.getKey())__                    continue__                }__                if (remote == null) { _                    String clusterAlias = entry.getKey()__                    remote = new RemoteClusterConnection(settings, clusterAlias, seedList, transportService, numRemoteConnections,_                        getNodePredicate(settings), proxyAddress)__                    remoteClusters.put(clusterAlias, remote)__                }__                _                RemoteClusterConnection finalRemote = remote__                remote.updateSeedNodes(proxyAddress, seedList, ActionListener.wrap(_                        response -> {_                            if (countDown.countDown()) {_                                connectionListener.onResponse(response)__                            }_                        },_                        exception -> {_                            if (countDown.fastForward()) {_                                connectionListener.onFailure(exception)__                            }_                            if (finalRemote.isClosed() == false) {_                                logger.warn("failed to update seed list for cluster: " + entry.getKey(), exception)__                            }_                        }))__            }_        }_        this.remoteClusters = Collections.unmodifiableMap(remoteClusters)__    };this,method,updates,the,list,of,remote,clusters,it,s,intended,to,be,used,as,an,update,consumer,on,the,settings,infrastructure,param,seeds,a,cluster,alias,to,discovery,node,mapping,representing,the,remote,clusters,seeds,nodes,param,connection,listener,a,listener,invoked,once,every,configured,cluster,has,been,connected,to;private,synchronized,void,update,remote,clusters,map,string,tuple,string,list,tuple,string,supplier,discovery,node,seeds,action,listener,void,connection,listener,if,seeds,contains,key,throw,new,illegal,argument,exception,remote,clusters,must,not,have,the,empty,string,as,its,key,map,string,remote,cluster,connection,remote,clusters,new,hash,map,if,seeds,is,empty,connection,listener,on,response,null,else,count,down,count,down,new,count,down,seeds,size,remote,clusters,put,all,this,remote,clusters,for,map,entry,string,tuple,string,list,tuple,string,supplier,discovery,node,entry,seeds,entry,set,list,tuple,string,supplier,discovery,node,seed,list,entry,get,value,v2,string,proxy,address,entry,get,value,v1,remote,cluster,connection,remote,this,remote,clusters,get,entry,get,key,if,seed,list,is,empty,try,ioutils,close,remote,catch,ioexception,e,logger,warn,failed,to,close,remote,cluster,connections,for,cluster,entry,get,key,e,remote,clusters,remove,entry,get,key,continue,if,remote,null,string,cluster,alias,entry,get,key,remote,new,remote,cluster,connection,settings,cluster,alias,seed,list,transport,service,num,remote,connections,get,node,predicate,settings,proxy,address,remote,clusters,put,cluster,alias,remote,remote,cluster,connection,final,remote,remote,remote,update,seed,nodes,proxy,address,seed,list,action,listener,wrap,response,if,count,down,count,down,connection,listener,on,response,response,exception,if,count,down,fast,forward,connection,listener,on,failure,exception,if,final,remote,is,closed,false,logger,warn,failed,to,update,seed,list,for,cluster,entry,get,key,exception,this,remote,clusters,collections,unmodifiable,map,remote,clusters
RemoteClusterService -> private synchronized void updateRemoteClusters(Map<String, Tuple<String, List<Tuple<String, Supplier<DiscoveryNode>>>>> seeds,                                                    ActionListener<Void> connectionListener);1550601141;This method updates the list of remote clusters. It's intended to be used as an update consumer on the settings infrastructure_@param seeds a cluster alias to discovery node mapping representing the remote clusters seeds nodes_@param connectionListener a listener invoked once every configured cluster has been connected to;private synchronized void updateRemoteClusters(Map<String, Tuple<String, List<Tuple<String, Supplier<DiscoveryNode>>>>> seeds,_                                                   ActionListener<Void> connectionListener) {_        if (seeds.containsKey(LOCAL_CLUSTER_GROUP_KEY)) {_            throw new IllegalArgumentException("remote clusters must not have the empty string as its key")__        }_        Map<String, RemoteClusterConnection> remoteClusters = new HashMap<>()__        if (seeds.isEmpty()) {_            connectionListener.onResponse(null)__        } else {_            CountDown countDown = new CountDown(seeds.size())__            remoteClusters.putAll(this.remoteClusters)__            for (Map.Entry<String, Tuple<String, List<Tuple<String, Supplier<DiscoveryNode>>>>> entry : seeds.entrySet()) {_                List<Tuple<String, Supplier<DiscoveryNode>>> seedList = entry.getValue().v2()__                String proxyAddress = entry.getValue().v1()___                String clusterAlias = entry.getKey()__                RemoteClusterConnection remote = this.remoteClusters.get(clusterAlias)__                ConnectionProfile connectionProfile = this.remoteClusterConnectionProfiles.get(clusterAlias)__                if (seedList.isEmpty()) { _                    try {_                        IOUtils.close(remote)__                    } catch (IOException e) {_                        logger.warn("failed to close remote cluster connections for cluster: " + clusterAlias, e)__                    }_                    remoteClusters.remove(clusterAlias)__                    continue__                }__                if (remote == null) { _                    remote = new RemoteClusterConnection(settings, clusterAlias, seedList, transportService, numRemoteConnections,_                        getNodePredicate(settings), proxyAddress, connectionProfile)__                    remoteClusters.put(clusterAlias, remote)__                } else if (connectionProfileChanged(remote.getConnectionManager().getConnectionProfile(), connectionProfile)) {_                    _                    try {_                        IOUtils.close(remote)__                    } catch (IOException e) {_                        logger.warn("failed to close remote cluster connections for cluster: " + clusterAlias, e)__                    }_                    remoteClusters.remove(clusterAlias)__                    remote = new RemoteClusterConnection(settings, clusterAlias, seedList, transportService, numRemoteConnections,_                        getNodePredicate(settings), proxyAddress, connectionProfile)__                    remoteClusters.put(clusterAlias, remote)__                }__                _                RemoteClusterConnection finalRemote = remote__                remote.updateSeedNodes(proxyAddress, seedList, ActionListener.wrap(_                        response -> {_                            if (countDown.countDown()) {_                                connectionListener.onResponse(response)__                            }_                        },_                        exception -> {_                            if (countDown.fastForward()) {_                                connectionListener.onFailure(exception)__                            }_                            if (finalRemote.isClosed() == false) {_                                logger.warn("failed to update seed list for cluster: " + clusterAlias, exception)__                            }_                        }))__            }_        }_        this.remoteClusters = Collections.unmodifiableMap(remoteClusters)__    };this,method,updates,the,list,of,remote,clusters,it,s,intended,to,be,used,as,an,update,consumer,on,the,settings,infrastructure,param,seeds,a,cluster,alias,to,discovery,node,mapping,representing,the,remote,clusters,seeds,nodes,param,connection,listener,a,listener,invoked,once,every,configured,cluster,has,been,connected,to;private,synchronized,void,update,remote,clusters,map,string,tuple,string,list,tuple,string,supplier,discovery,node,seeds,action,listener,void,connection,listener,if,seeds,contains,key,throw,new,illegal,argument,exception,remote,clusters,must,not,have,the,empty,string,as,its,key,map,string,remote,cluster,connection,remote,clusters,new,hash,map,if,seeds,is,empty,connection,listener,on,response,null,else,count,down,count,down,new,count,down,seeds,size,remote,clusters,put,all,this,remote,clusters,for,map,entry,string,tuple,string,list,tuple,string,supplier,discovery,node,entry,seeds,entry,set,list,tuple,string,supplier,discovery,node,seed,list,entry,get,value,v2,string,proxy,address,entry,get,value,v1,string,cluster,alias,entry,get,key,remote,cluster,connection,remote,this,remote,clusters,get,cluster,alias,connection,profile,connection,profile,this,remote,cluster,connection,profiles,get,cluster,alias,if,seed,list,is,empty,try,ioutils,close,remote,catch,ioexception,e,logger,warn,failed,to,close,remote,cluster,connections,for,cluster,cluster,alias,e,remote,clusters,remove,cluster,alias,continue,if,remote,null,remote,new,remote,cluster,connection,settings,cluster,alias,seed,list,transport,service,num,remote,connections,get,node,predicate,settings,proxy,address,connection,profile,remote,clusters,put,cluster,alias,remote,else,if,connection,profile,changed,remote,get,connection,manager,get,connection,profile,connection,profile,try,ioutils,close,remote,catch,ioexception,e,logger,warn,failed,to,close,remote,cluster,connections,for,cluster,cluster,alias,e,remote,clusters,remove,cluster,alias,remote,new,remote,cluster,connection,settings,cluster,alias,seed,list,transport,service,num,remote,connections,get,node,predicate,settings,proxy,address,connection,profile,remote,clusters,put,cluster,alias,remote,remote,cluster,connection,final,remote,remote,remote,update,seed,nodes,proxy,address,seed,list,action,listener,wrap,response,if,count,down,count,down,connection,listener,on,response,response,exception,if,count,down,fast,forward,connection,listener,on,failure,exception,if,final,remote,is,closed,false,logger,warn,failed,to,update,seed,list,for,cluster,cluster,alias,exception,this,remote,clusters,collections,unmodifiable,map,remote,clusters
RemoteClusterService -> public boolean isSkipUnavailable(String clusterAlias);1548248017;Returns whether the cluster identified by the provided alias is configured to be skipped when unavailable;public boolean isSkipUnavailable(String clusterAlias) {_        return getRemoteClusterConnection(clusterAlias).isSkipUnavailable()__    };returns,whether,the,cluster,identified,by,the,provided,alias,is,configured,to,be,skipped,when,unavailable;public,boolean,is,skip,unavailable,string,cluster,alias,return,get,remote,cluster,connection,cluster,alias,is,skip,unavailable
RemoteClusterService -> public boolean isSkipUnavailable(String clusterAlias);1548402798;Returns whether the cluster identified by the provided alias is configured to be skipped when unavailable;public boolean isSkipUnavailable(String clusterAlias) {_        return getRemoteClusterConnection(clusterAlias).isSkipUnavailable()__    };returns,whether,the,cluster,identified,by,the,provided,alias,is,configured,to,be,skipped,when,unavailable;public,boolean,is,skip,unavailable,string,cluster,alias,return,get,remote,cluster,connection,cluster,alias,is,skip,unavailable
RemoteClusterService -> public boolean isSkipUnavailable(String clusterAlias);1549608646;Returns whether the cluster identified by the provided alias is configured to be skipped when unavailable;public boolean isSkipUnavailable(String clusterAlias) {_        return getRemoteClusterConnection(clusterAlias).isSkipUnavailable()__    };returns,whether,the,cluster,identified,by,the,provided,alias,is,configured,to,be,skipped,when,unavailable;public,boolean,is,skip,unavailable,string,cluster,alias,return,get,remote,cluster,connection,cluster,alias,is,skip,unavailable
RemoteClusterService -> public boolean isSkipUnavailable(String clusterAlias);1550601141;Returns whether the cluster identified by the provided alias is configured to be skipped when unavailable;public boolean isSkipUnavailable(String clusterAlias) {_        return getRemoteClusterConnection(clusterAlias).isSkipUnavailable()__    };returns,whether,the,cluster,identified,by,the,provided,alias,is,configured,to,be,skipped,when,unavailable;public,boolean,is,skip,unavailable,string,cluster,alias,return,get,remote,cluster,connection,cluster,alias,is,skip,unavailable
RemoteClusterService -> private synchronized void updateRemoteClusters(Map<String, List<DiscoveryNode>> seeds, ActionListener<Void> connectionListener);1524684173;This method updates the list of remote clusters. It's intended to be used as an update consumer on the settings infrastructure_@param seeds a cluster alias to discovery node mapping representing the remote clusters seeds nodes_@param connectionListener a listener invoked once every configured cluster has been connected to;private synchronized void updateRemoteClusters(Map<String, List<DiscoveryNode>> seeds, ActionListener<Void> connectionListener) {_        if (seeds.containsKey(LOCAL_CLUSTER_GROUP_KEY)) {_            throw new IllegalArgumentException("remote clusters must not have the empty string as its key")__        }_        Map<String, RemoteClusterConnection> remoteClusters = new HashMap<>()__        if (seeds.isEmpty()) {_            connectionListener.onResponse(null)__        } else {_            CountDown countDown = new CountDown(seeds.size())__            Predicate<DiscoveryNode> nodePredicate = (node) -> Version.CURRENT.isCompatible(node.getVersion())__            if (REMOTE_NODE_ATTRIBUTE.exists(settings)) {_                _                _                String attribute = REMOTE_NODE_ATTRIBUTE.get(settings)__                nodePredicate = nodePredicate.and((node) -> Booleans.parseBoolean(node.getAttributes().getOrDefault(attribute, "false")))__            }_            remoteClusters.putAll(this.remoteClusters)__            for (Map.Entry<String, List<DiscoveryNode>> entry : seeds.entrySet()) {_                RemoteClusterConnection remote = this.remoteClusters.get(entry.getKey())__                if (entry.getValue().isEmpty()) { _                    try {_                        IOUtils.close(remote)__                    } catch (IOException e) {_                        logger.warn("failed to close remote cluster connections for cluster: " + entry.getKey(), e)__                    }_                    remoteClusters.remove(entry.getKey())__                    continue__                }__                if (remote == null) { _                    remote = new RemoteClusterConnection(settings, entry.getKey(), entry.getValue(), transportService, numRemoteConnections,_                        nodePredicate)__                    remoteClusters.put(entry.getKey(), remote)__                }__                _                RemoteClusterConnection finalRemote = remote__                remote.updateSeedNodes(entry.getValue(), ActionListener.wrap(_                    response -> {_                        if (countDown.countDown()) {_                            connectionListener.onResponse(response)__                        }_                    },_                    exception -> {_                        if (countDown.fastForward()) {_                            connectionListener.onFailure(exception)__                        }_                        if (finalRemote.isClosed() == false) {_                            logger.warn("failed to update seed list for cluster: " + entry.getKey(), exception)__                        }_                    }))__            }_        }_        this.remoteClusters = Collections.unmodifiableMap(remoteClusters)__    };this,method,updates,the,list,of,remote,clusters,it,s,intended,to,be,used,as,an,update,consumer,on,the,settings,infrastructure,param,seeds,a,cluster,alias,to,discovery,node,mapping,representing,the,remote,clusters,seeds,nodes,param,connection,listener,a,listener,invoked,once,every,configured,cluster,has,been,connected,to;private,synchronized,void,update,remote,clusters,map,string,list,discovery,node,seeds,action,listener,void,connection,listener,if,seeds,contains,key,throw,new,illegal,argument,exception,remote,clusters,must,not,have,the,empty,string,as,its,key,map,string,remote,cluster,connection,remote,clusters,new,hash,map,if,seeds,is,empty,connection,listener,on,response,null,else,count,down,count,down,new,count,down,seeds,size,predicate,discovery,node,node,predicate,node,version,current,is,compatible,node,get,version,if,exists,settings,string,attribute,get,settings,node,predicate,node,predicate,and,node,booleans,parse,boolean,node,get,attributes,get,or,default,attribute,false,remote,clusters,put,all,this,remote,clusters,for,map,entry,string,list,discovery,node,entry,seeds,entry,set,remote,cluster,connection,remote,this,remote,clusters,get,entry,get,key,if,entry,get,value,is,empty,try,ioutils,close,remote,catch,ioexception,e,logger,warn,failed,to,close,remote,cluster,connections,for,cluster,entry,get,key,e,remote,clusters,remove,entry,get,key,continue,if,remote,null,remote,new,remote,cluster,connection,settings,entry,get,key,entry,get,value,transport,service,num,remote,connections,node,predicate,remote,clusters,put,entry,get,key,remote,remote,cluster,connection,final,remote,remote,remote,update,seed,nodes,entry,get,value,action,listener,wrap,response,if,count,down,count,down,connection,listener,on,response,response,exception,if,count,down,fast,forward,connection,listener,on,failure,exception,if,final,remote,is,closed,false,logger,warn,failed,to,update,seed,list,for,cluster,entry,get,key,exception,this,remote,clusters,collections,unmodifiable,map,remote,clusters
RemoteClusterService -> private synchronized void updateRemoteClusters(Map<String, List<DiscoveryNode>> seeds, ActionListener<Void> connectionListener);1525076988;This method updates the list of remote clusters. It's intended to be used as an update consumer on the settings infrastructure_@param seeds a cluster alias to discovery node mapping representing the remote clusters seeds nodes_@param connectionListener a listener invoked once every configured cluster has been connected to;private synchronized void updateRemoteClusters(Map<String, List<DiscoveryNode>> seeds, ActionListener<Void> connectionListener) {_        if (seeds.containsKey(LOCAL_CLUSTER_GROUP_KEY)) {_            throw new IllegalArgumentException("remote clusters must not have the empty string as its key")__        }_        Map<String, RemoteClusterConnection> remoteClusters = new HashMap<>()__        if (seeds.isEmpty()) {_            connectionListener.onResponse(null)__        } else {_            CountDown countDown = new CountDown(seeds.size())__            Predicate<DiscoveryNode> nodePredicate = (node) -> Version.CURRENT.isCompatible(node.getVersion())__            if (REMOTE_NODE_ATTRIBUTE.exists(settings)) {_                _                _                String attribute = REMOTE_NODE_ATTRIBUTE.get(settings)__                nodePredicate = nodePredicate.and((node) -> Booleans.parseBoolean(node.getAttributes().getOrDefault(attribute, "false")))__            }_            remoteClusters.putAll(this.remoteClusters)__            for (Map.Entry<String, List<DiscoveryNode>> entry : seeds.entrySet()) {_                RemoteClusterConnection remote = this.remoteClusters.get(entry.getKey())__                if (entry.getValue().isEmpty()) { _                    try {_                        IOUtils.close(remote)__                    } catch (IOException e) {_                        logger.warn("failed to close remote cluster connections for cluster: " + entry.getKey(), e)__                    }_                    remoteClusters.remove(entry.getKey())__                    continue__                }__                if (remote == null) { _                    remote = new RemoteClusterConnection(settings, entry.getKey(), entry.getValue(), transportService, numRemoteConnections,_                        nodePredicate)__                    remoteClusters.put(entry.getKey(), remote)__                }__                _                RemoteClusterConnection finalRemote = remote__                remote.updateSeedNodes(entry.getValue(), ActionListener.wrap(_                    response -> {_                        if (countDown.countDown()) {_                            connectionListener.onResponse(response)__                        }_                    },_                    exception -> {_                        if (countDown.fastForward()) {_                            connectionListener.onFailure(exception)__                        }_                        if (finalRemote.isClosed() == false) {_                            logger.warn("failed to update seed list for cluster: " + entry.getKey(), exception)__                        }_                    }))__            }_        }_        this.remoteClusters = Collections.unmodifiableMap(remoteClusters)__    };this,method,updates,the,list,of,remote,clusters,it,s,intended,to,be,used,as,an,update,consumer,on,the,settings,infrastructure,param,seeds,a,cluster,alias,to,discovery,node,mapping,representing,the,remote,clusters,seeds,nodes,param,connection,listener,a,listener,invoked,once,every,configured,cluster,has,been,connected,to;private,synchronized,void,update,remote,clusters,map,string,list,discovery,node,seeds,action,listener,void,connection,listener,if,seeds,contains,key,throw,new,illegal,argument,exception,remote,clusters,must,not,have,the,empty,string,as,its,key,map,string,remote,cluster,connection,remote,clusters,new,hash,map,if,seeds,is,empty,connection,listener,on,response,null,else,count,down,count,down,new,count,down,seeds,size,predicate,discovery,node,node,predicate,node,version,current,is,compatible,node,get,version,if,exists,settings,string,attribute,get,settings,node,predicate,node,predicate,and,node,booleans,parse,boolean,node,get,attributes,get,or,default,attribute,false,remote,clusters,put,all,this,remote,clusters,for,map,entry,string,list,discovery,node,entry,seeds,entry,set,remote,cluster,connection,remote,this,remote,clusters,get,entry,get,key,if,entry,get,value,is,empty,try,ioutils,close,remote,catch,ioexception,e,logger,warn,failed,to,close,remote,cluster,connections,for,cluster,entry,get,key,e,remote,clusters,remove,entry,get,key,continue,if,remote,null,remote,new,remote,cluster,connection,settings,entry,get,key,entry,get,value,transport,service,num,remote,connections,node,predicate,remote,clusters,put,entry,get,key,remote,remote,cluster,connection,final,remote,remote,remote,update,seed,nodes,entry,get,value,action,listener,wrap,response,if,count,down,count,down,connection,listener,on,response,response,exception,if,count,down,fast,forward,connection,listener,on,failure,exception,if,final,remote,is,closed,false,logger,warn,failed,to,update,seed,list,for,cluster,entry,get,key,exception,this,remote,clusters,collections,unmodifiable,map,remote,clusters
RemoteClusterService -> private synchronized void updateRemoteClusters(Map<String, List<DiscoveryNode>> seeds, ActionListener<Void> connectionListener);1525334055;This method updates the list of remote clusters. It's intended to be used as an update consumer on the settings infrastructure_@param seeds a cluster alias to discovery node mapping representing the remote clusters seeds nodes_@param connectionListener a listener invoked once every configured cluster has been connected to;private synchronized void updateRemoteClusters(Map<String, List<DiscoveryNode>> seeds, ActionListener<Void> connectionListener) {_        if (seeds.containsKey(LOCAL_CLUSTER_GROUP_KEY)) {_            throw new IllegalArgumentException("remote clusters must not have the empty string as its key")__        }_        Map<String, RemoteClusterConnection> remoteClusters = new HashMap<>()__        if (seeds.isEmpty()) {_            connectionListener.onResponse(null)__        } else {_            CountDown countDown = new CountDown(seeds.size())__            Predicate<DiscoveryNode> nodePredicate = (node) -> Version.CURRENT.isCompatible(node.getVersion())__            if (REMOTE_NODE_ATTRIBUTE.exists(settings)) {_                _                _                String attribute = REMOTE_NODE_ATTRIBUTE.get(settings)__                nodePredicate = nodePredicate.and((node) -> Booleans.parseBoolean(node.getAttributes().getOrDefault(attribute, "false")))__            }_            remoteClusters.putAll(this.remoteClusters)__            for (Map.Entry<String, List<DiscoveryNode>> entry : seeds.entrySet()) {_                RemoteClusterConnection remote = this.remoteClusters.get(entry.getKey())__                if (entry.getValue().isEmpty()) { _                    try {_                        IOUtils.close(remote)__                    } catch (IOException e) {_                        logger.warn("failed to close remote cluster connections for cluster: " + entry.getKey(), e)__                    }_                    remoteClusters.remove(entry.getKey())__                    continue__                }__                if (remote == null) { _                    remote = new RemoteClusterConnection(settings, entry.getKey(), entry.getValue(), transportService, numRemoteConnections,_                        nodePredicate)__                    remoteClusters.put(entry.getKey(), remote)__                }__                _                RemoteClusterConnection finalRemote = remote__                remote.updateSeedNodes(entry.getValue(), ActionListener.wrap(_                    response -> {_                        if (countDown.countDown()) {_                            connectionListener.onResponse(response)__                        }_                    },_                    exception -> {_                        if (countDown.fastForward()) {_                            connectionListener.onFailure(exception)__                        }_                        if (finalRemote.isClosed() == false) {_                            logger.warn("failed to update seed list for cluster: " + entry.getKey(), exception)__                        }_                    }))__            }_        }_        this.remoteClusters = Collections.unmodifiableMap(remoteClusters)__    };this,method,updates,the,list,of,remote,clusters,it,s,intended,to,be,used,as,an,update,consumer,on,the,settings,infrastructure,param,seeds,a,cluster,alias,to,discovery,node,mapping,representing,the,remote,clusters,seeds,nodes,param,connection,listener,a,listener,invoked,once,every,configured,cluster,has,been,connected,to;private,synchronized,void,update,remote,clusters,map,string,list,discovery,node,seeds,action,listener,void,connection,listener,if,seeds,contains,key,throw,new,illegal,argument,exception,remote,clusters,must,not,have,the,empty,string,as,its,key,map,string,remote,cluster,connection,remote,clusters,new,hash,map,if,seeds,is,empty,connection,listener,on,response,null,else,count,down,count,down,new,count,down,seeds,size,predicate,discovery,node,node,predicate,node,version,current,is,compatible,node,get,version,if,exists,settings,string,attribute,get,settings,node,predicate,node,predicate,and,node,booleans,parse,boolean,node,get,attributes,get,or,default,attribute,false,remote,clusters,put,all,this,remote,clusters,for,map,entry,string,list,discovery,node,entry,seeds,entry,set,remote,cluster,connection,remote,this,remote,clusters,get,entry,get,key,if,entry,get,value,is,empty,try,ioutils,close,remote,catch,ioexception,e,logger,warn,failed,to,close,remote,cluster,connections,for,cluster,entry,get,key,e,remote,clusters,remove,entry,get,key,continue,if,remote,null,remote,new,remote,cluster,connection,settings,entry,get,key,entry,get,value,transport,service,num,remote,connections,node,predicate,remote,clusters,put,entry,get,key,remote,remote,cluster,connection,final,remote,remote,remote,update,seed,nodes,entry,get,value,action,listener,wrap,response,if,count,down,count,down,connection,listener,on,response,response,exception,if,count,down,fast,forward,connection,listener,on,failure,exception,if,final,remote,is,closed,false,logger,warn,failed,to,update,seed,list,for,cluster,entry,get,key,exception,this,remote,clusters,collections,unmodifiable,map,remote,clusters
RemoteClusterService -> private synchronized void updateRemoteClusters(Map<String, List<DiscoveryNode>> seeds, ActionListener<Void> connectionListener);1527773340;This method updates the list of remote clusters. It's intended to be used as an update consumer on the settings infrastructure_@param seeds a cluster alias to discovery node mapping representing the remote clusters seeds nodes_@param connectionListener a listener invoked once every configured cluster has been connected to;private synchronized void updateRemoteClusters(Map<String, List<DiscoveryNode>> seeds, ActionListener<Void> connectionListener) {_        if (seeds.containsKey(LOCAL_CLUSTER_GROUP_KEY)) {_            throw new IllegalArgumentException("remote clusters must not have the empty string as its key")__        }_        Map<String, RemoteClusterConnection> remoteClusters = new HashMap<>()__        if (seeds.isEmpty()) {_            connectionListener.onResponse(null)__        } else {_            CountDown countDown = new CountDown(seeds.size())__            remoteClusters.putAll(this.remoteClusters)__            for (Map.Entry<String, List<DiscoveryNode>> entry : seeds.entrySet()) {_                RemoteClusterConnection remote = this.remoteClusters.get(entry.getKey())__                if (entry.getValue().isEmpty()) { _                    try {_                        IOUtils.close(remote)__                    } catch (IOException e) {_                        logger.warn("failed to close remote cluster connections for cluster: " + entry.getKey(), e)__                    }_                    remoteClusters.remove(entry.getKey())__                    continue__                }__                if (remote == null) { _                    remote = new RemoteClusterConnection(settings, entry.getKey(), entry.getValue(), transportService, numRemoteConnections,_                        getNodePredicate(settings))__                    remoteClusters.put(entry.getKey(), remote)__                }__                _                RemoteClusterConnection finalRemote = remote__                remote.updateSeedNodes(entry.getValue(), ActionListener.wrap(_                    response -> {_                        if (countDown.countDown()) {_                            connectionListener.onResponse(response)__                        }_                    },_                    exception -> {_                        if (countDown.fastForward()) {_                            connectionListener.onFailure(exception)__                        }_                        if (finalRemote.isClosed() == false) {_                            logger.warn("failed to update seed list for cluster: " + entry.getKey(), exception)__                        }_                    }))__            }_        }_        this.remoteClusters = Collections.unmodifiableMap(remoteClusters)__    };this,method,updates,the,list,of,remote,clusters,it,s,intended,to,be,used,as,an,update,consumer,on,the,settings,infrastructure,param,seeds,a,cluster,alias,to,discovery,node,mapping,representing,the,remote,clusters,seeds,nodes,param,connection,listener,a,listener,invoked,once,every,configured,cluster,has,been,connected,to;private,synchronized,void,update,remote,clusters,map,string,list,discovery,node,seeds,action,listener,void,connection,listener,if,seeds,contains,key,throw,new,illegal,argument,exception,remote,clusters,must,not,have,the,empty,string,as,its,key,map,string,remote,cluster,connection,remote,clusters,new,hash,map,if,seeds,is,empty,connection,listener,on,response,null,else,count,down,count,down,new,count,down,seeds,size,remote,clusters,put,all,this,remote,clusters,for,map,entry,string,list,discovery,node,entry,seeds,entry,set,remote,cluster,connection,remote,this,remote,clusters,get,entry,get,key,if,entry,get,value,is,empty,try,ioutils,close,remote,catch,ioexception,e,logger,warn,failed,to,close,remote,cluster,connections,for,cluster,entry,get,key,e,remote,clusters,remove,entry,get,key,continue,if,remote,null,remote,new,remote,cluster,connection,settings,entry,get,key,entry,get,value,transport,service,num,remote,connections,get,node,predicate,settings,remote,clusters,put,entry,get,key,remote,remote,cluster,connection,final,remote,remote,remote,update,seed,nodes,entry,get,value,action,listener,wrap,response,if,count,down,count,down,connection,listener,on,response,response,exception,if,count,down,fast,forward,connection,listener,on,failure,exception,if,final,remote,is,closed,false,logger,warn,failed,to,update,seed,list,for,cluster,entry,get,key,exception,this,remote,clusters,collections,unmodifiable,map,remote,clusters
RemoteClusterService -> private synchronized void updateRemoteClusters(Map<String, List<DiscoveryNode>> seeds, ActionListener<Void> connectionListener);1527840262;This method updates the list of remote clusters. It's intended to be used as an update consumer on the settings infrastructure_@param seeds a cluster alias to discovery node mapping representing the remote clusters seeds nodes_@param connectionListener a listener invoked once every configured cluster has been connected to;private synchronized void updateRemoteClusters(Map<String, List<DiscoveryNode>> seeds, ActionListener<Void> connectionListener) {_        if (seeds.containsKey(LOCAL_CLUSTER_GROUP_KEY)) {_            throw new IllegalArgumentException("remote clusters must not have the empty string as its key")__        }_        Map<String, RemoteClusterConnection> remoteClusters = new HashMap<>()__        if (seeds.isEmpty()) {_            connectionListener.onResponse(null)__        } else {_            CountDown countDown = new CountDown(seeds.size())__            remoteClusters.putAll(this.remoteClusters)__            for (Map.Entry<String, List<DiscoveryNode>> entry : seeds.entrySet()) {_                RemoteClusterConnection remote = this.remoteClusters.get(entry.getKey())__                if (entry.getValue().isEmpty()) { _                    try {_                        IOUtils.close(remote)__                    } catch (IOException e) {_                        logger.warn("failed to close remote cluster connections for cluster: " + entry.getKey(), e)__                    }_                    remoteClusters.remove(entry.getKey())__                    continue__                }__                if (remote == null) { _                    remote = new RemoteClusterConnection(settings, entry.getKey(), entry.getValue(), transportService, numRemoteConnections,_                        getNodePredicate(settings))__                    remoteClusters.put(entry.getKey(), remote)__                }__                _                RemoteClusterConnection finalRemote = remote__                remote.updateSeedNodes(entry.getValue(), ActionListener.wrap(_                    response -> {_                        if (countDown.countDown()) {_                            connectionListener.onResponse(response)__                        }_                    },_                    exception -> {_                        if (countDown.fastForward()) {_                            connectionListener.onFailure(exception)__                        }_                        if (finalRemote.isClosed() == false) {_                            logger.warn("failed to update seed list for cluster: " + entry.getKey(), exception)__                        }_                    }))__            }_        }_        this.remoteClusters = Collections.unmodifiableMap(remoteClusters)__    };this,method,updates,the,list,of,remote,clusters,it,s,intended,to,be,used,as,an,update,consumer,on,the,settings,infrastructure,param,seeds,a,cluster,alias,to,discovery,node,mapping,representing,the,remote,clusters,seeds,nodes,param,connection,listener,a,listener,invoked,once,every,configured,cluster,has,been,connected,to;private,synchronized,void,update,remote,clusters,map,string,list,discovery,node,seeds,action,listener,void,connection,listener,if,seeds,contains,key,throw,new,illegal,argument,exception,remote,clusters,must,not,have,the,empty,string,as,its,key,map,string,remote,cluster,connection,remote,clusters,new,hash,map,if,seeds,is,empty,connection,listener,on,response,null,else,count,down,count,down,new,count,down,seeds,size,remote,clusters,put,all,this,remote,clusters,for,map,entry,string,list,discovery,node,entry,seeds,entry,set,remote,cluster,connection,remote,this,remote,clusters,get,entry,get,key,if,entry,get,value,is,empty,try,ioutils,close,remote,catch,ioexception,e,logger,warn,failed,to,close,remote,cluster,connections,for,cluster,entry,get,key,e,remote,clusters,remove,entry,get,key,continue,if,remote,null,remote,new,remote,cluster,connection,settings,entry,get,key,entry,get,value,transport,service,num,remote,connections,get,node,predicate,settings,remote,clusters,put,entry,get,key,remote,remote,cluster,connection,final,remote,remote,remote,update,seed,nodes,entry,get,value,action,listener,wrap,response,if,count,down,count,down,connection,listener,on,response,response,exception,if,count,down,fast,forward,connection,listener,on,failure,exception,if,final,remote,is,closed,false,logger,warn,failed,to,update,seed,list,for,cluster,entry,get,key,exception,this,remote,clusters,collections,unmodifiable,map,remote,clusters
RemoteClusterService -> void ensureConnected(String clusterAlias, ActionListener<Void> listener);1541008027;Ensures that the given cluster alias is connected. If the cluster is connected this operation_will invoke the listener immediately.;void ensureConnected(String clusterAlias, ActionListener<Void> listener) {_        getRemoteClusterConnection(clusterAlias).ensureConnected(listener)__    };ensures,that,the,given,cluster,alias,is,connected,if,the,cluster,is,connected,this,operation,will,invoke,the,listener,immediately;void,ensure,connected,string,cluster,alias,action,listener,void,listener,get,remote,cluster,connection,cluster,alias,ensure,connected,listener
RemoteClusterService -> void ensureConnected(String clusterAlias, ActionListener<Void> listener);1541698679;Ensures that the given cluster alias is connected. If the cluster is connected this operation_will invoke the listener immediately.;void ensureConnected(String clusterAlias, ActionListener<Void> listener) {_        getRemoteClusterConnection(clusterAlias).ensureConnected(listener)__    };ensures,that,the,given,cluster,alias,is,connected,if,the,cluster,is,connected,this,operation,will,invoke,the,listener,immediately;void,ensure,connected,string,cluster,alias,action,listener,void,listener,get,remote,cluster,connection,cluster,alias,ensure,connected,listener
RemoteClusterService -> void ensureConnected(String clusterAlias, ActionListener<Void> listener);1542402632;Ensures that the given cluster alias is connected. If the cluster is connected this operation_will invoke the listener immediately.;void ensureConnected(String clusterAlias, ActionListener<Void> listener) {_        getRemoteClusterConnection(clusterAlias).ensureConnected(listener)__    };ensures,that,the,given,cluster,alias,is,connected,if,the,cluster,is,connected,this,operation,will,invoke,the,listener,immediately;void,ensure,connected,string,cluster,alias,action,listener,void,listener,get,remote,cluster,connection,cluster,alias,ensure,connected,listener
RemoteClusterService -> void ensureConnected(String clusterAlias, ActionListener<Void> listener);1543506953;Ensures that the given cluster alias is connected. If the cluster is connected this operation_will invoke the listener immediately.;void ensureConnected(String clusterAlias, ActionListener<Void> listener) {_        getRemoteClusterConnection(clusterAlias).ensureConnected(listener)__    };ensures,that,the,given,cluster,alias,is,connected,if,the,cluster,is,connected,this,operation,will,invoke,the,listener,immediately;void,ensure,connected,string,cluster,alias,action,listener,void,listener,get,remote,cluster,connection,cluster,alias,ensure,connected,listener
RemoteClusterService -> void ensureConnected(String clusterAlias, ActionListener<Void> listener);1543959410;Ensures that the given cluster alias is connected. If the cluster is connected this operation_will invoke the listener immediately.;void ensureConnected(String clusterAlias, ActionListener<Void> listener) {_        getRemoteClusterConnection(clusterAlias).ensureConnected(listener)__    };ensures,that,the,given,cluster,alias,is,connected,if,the,cluster,is,connected,this,operation,will,invoke,the,listener,immediately;void,ensure,connected,string,cluster,alias,action,listener,void,listener,get,remote,cluster,connection,cluster,alias,ensure,connected,listener
RemoteClusterService -> void ensureConnected(String clusterAlias, ActionListener<Void> listener);1544823664;Ensures that the given cluster alias is connected. If the cluster is connected this operation_will invoke the listener immediately.;void ensureConnected(String clusterAlias, ActionListener<Void> listener) {_        getRemoteClusterConnection(clusterAlias).ensureConnected(listener)__    };ensures,that,the,given,cluster,alias,is,connected,if,the,cluster,is,connected,this,operation,will,invoke,the,listener,immediately;void,ensure,connected,string,cluster,alias,action,listener,void,listener,get,remote,cluster,connection,cluster,alias,ensure,connected,listener
RemoteClusterService -> void ensureConnected(String clusterAlias, ActionListener<Void> listener);1545071071;Ensures that the given cluster alias is connected. If the cluster is connected this operation_will invoke the listener immediately.;void ensureConnected(String clusterAlias, ActionListener<Void> listener) {_        getRemoteClusterConnection(clusterAlias).ensureConnected(listener)__    };ensures,that,the,given,cluster,alias,is,connected,if,the,cluster,is,connected,this,operation,will,invoke,the,listener,immediately;void,ensure,connected,string,cluster,alias,action,listener,void,listener,get,remote,cluster,connection,cluster,alias,ensure,connected,listener
RemoteClusterService -> void ensureConnected(String clusterAlias, ActionListener<Void> listener);1546929322;Ensures that the given cluster alias is connected. If the cluster is connected this operation_will invoke the listener immediately.;void ensureConnected(String clusterAlias, ActionListener<Void> listener) {_        getRemoteClusterConnection(clusterAlias).ensureConnected(listener)__    };ensures,that,the,given,cluster,alias,is,connected,if,the,cluster,is,connected,this,operation,will,invoke,the,listener,immediately;void,ensure,connected,string,cluster,alias,action,listener,void,listener,get,remote,cluster,connection,cluster,alias,ensure,connected,listener
RemoteClusterService -> void ensureConnected(String clusterAlias, ActionListener<Void> listener);1547561945;Ensures that the given cluster alias is connected. If the cluster is connected this operation_will invoke the listener immediately.;void ensureConnected(String clusterAlias, ActionListener<Void> listener) {_        getRemoteClusterConnection(clusterAlias).ensureConnected(listener)__    };ensures,that,the,given,cluster,alias,is,connected,if,the,cluster,is,connected,this,operation,will,invoke,the,listener,immediately;void,ensure,connected,string,cluster,alias,action,listener,void,listener,get,remote,cluster,connection,cluster,alias,ensure,connected,listener
RemoteClusterService -> void ensureConnected(String clusterAlias, ActionListener<Void> listener);1548248017;Ensures that the given cluster alias is connected. If the cluster is connected this operation_will invoke the listener immediately.;void ensureConnected(String clusterAlias, ActionListener<Void> listener) {_        getRemoteClusterConnection(clusterAlias).ensureConnected(listener)__    };ensures,that,the,given,cluster,alias,is,connected,if,the,cluster,is,connected,this,operation,will,invoke,the,listener,immediately;void,ensure,connected,string,cluster,alias,action,listener,void,listener,get,remote,cluster,connection,cluster,alias,ensure,connected,listener
RemoteClusterService -> void ensureConnected(String clusterAlias, ActionListener<Void> listener);1548402798;Ensures that the given cluster alias is connected. If the cluster is connected this operation_will invoke the listener immediately.;void ensureConnected(String clusterAlias, ActionListener<Void> listener) {_        getRemoteClusterConnection(clusterAlias).ensureConnected(listener)__    };ensures,that,the,given,cluster,alias,is,connected,if,the,cluster,is,connected,this,operation,will,invoke,the,listener,immediately;void,ensure,connected,string,cluster,alias,action,listener,void,listener,get,remote,cluster,connection,cluster,alias,ensure,connected,listener
RemoteClusterService -> void ensureConnected(String clusterAlias, ActionListener<Void> listener);1549608646;Ensures that the given cluster alias is connected. If the cluster is connected this operation_will invoke the listener immediately.;void ensureConnected(String clusterAlias, ActionListener<Void> listener) {_        getRemoteClusterConnection(clusterAlias).ensureConnected(listener)__    };ensures,that,the,given,cluster,alias,is,connected,if,the,cluster,is,connected,this,operation,will,invoke,the,listener,immediately;void,ensure,connected,string,cluster,alias,action,listener,void,listener,get,remote,cluster,connection,cluster,alias,ensure,connected,listener
RemoteClusterService -> void ensureConnected(String clusterAlias, ActionListener<Void> listener);1550601141;Ensures that the given cluster alias is connected. If the cluster is connected this operation_will invoke the listener immediately.;void ensureConnected(String clusterAlias, ActionListener<Void> listener) {_        getRemoteClusterConnection(clusterAlias).ensureConnected(listener)__    };ensures,that,the,given,cluster,alias,is,connected,if,the,cluster,is,connected,this,operation,will,invoke,the,listener,immediately;void,ensure,connected,string,cluster,alias,action,listener,void,listener,get,remote,cluster,connection,cluster,alias,ensure,connected,listener
RemoteClusterService -> void initializeRemoteClusters();1524684173;Connects to all remote clusters in a blocking fashion. This should be called on node startup to establish an initial connection_to all configured seed nodes.;void initializeRemoteClusters() {_        final TimeValue timeValue = REMOTE_INITIAL_CONNECTION_TIMEOUT_SETTING.get(settings)__        final PlainActionFuture<Void> future = new PlainActionFuture<>()__        Map<String, List<DiscoveryNode>> seeds = RemoteClusterAware.buildRemoteClustersSeeds(settings)__        updateRemoteClusters(seeds, future)__        try {_            future.get(timeValue.millis(), TimeUnit.MILLISECONDS)__        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()__        } catch (TimeoutException ex) {_            logger.warn("failed to connect to remote clusters within {}", timeValue.toString())__        } catch (Exception e) {_            throw new IllegalStateException("failed to connect to remote clusters", e)__        }_    };connects,to,all,remote,clusters,in,a,blocking,fashion,this,should,be,called,on,node,startup,to,establish,an,initial,connection,to,all,configured,seed,nodes;void,initialize,remote,clusters,final,time,value,time,value,get,settings,final,plain,action,future,void,future,new,plain,action,future,map,string,list,discovery,node,seeds,remote,cluster,aware,build,remote,clusters,seeds,settings,update,remote,clusters,seeds,future,try,future,get,time,value,millis,time,unit,milliseconds,catch,interrupted,exception,e,thread,current,thread,interrupt,catch,timeout,exception,ex,logger,warn,failed,to,connect,to,remote,clusters,within,time,value,to,string,catch,exception,e,throw,new,illegal,state,exception,failed,to,connect,to,remote,clusters,e
RemoteClusterService -> void initializeRemoteClusters();1525076988;Connects to all remote clusters in a blocking fashion. This should be called on node startup to establish an initial connection_to all configured seed nodes.;void initializeRemoteClusters() {_        final TimeValue timeValue = REMOTE_INITIAL_CONNECTION_TIMEOUT_SETTING.get(settings)__        final PlainActionFuture<Void> future = new PlainActionFuture<>()__        Map<String, List<DiscoveryNode>> seeds = RemoteClusterAware.buildRemoteClustersSeeds(settings)__        updateRemoteClusters(seeds, future)__        try {_            future.get(timeValue.millis(), TimeUnit.MILLISECONDS)__        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()__        } catch (TimeoutException ex) {_            logger.warn("failed to connect to remote clusters within {}", timeValue.toString())__        } catch (Exception e) {_            throw new IllegalStateException("failed to connect to remote clusters", e)__        }_    };connects,to,all,remote,clusters,in,a,blocking,fashion,this,should,be,called,on,node,startup,to,establish,an,initial,connection,to,all,configured,seed,nodes;void,initialize,remote,clusters,final,time,value,time,value,get,settings,final,plain,action,future,void,future,new,plain,action,future,map,string,list,discovery,node,seeds,remote,cluster,aware,build,remote,clusters,seeds,settings,update,remote,clusters,seeds,future,try,future,get,time,value,millis,time,unit,milliseconds,catch,interrupted,exception,e,thread,current,thread,interrupt,catch,timeout,exception,ex,logger,warn,failed,to,connect,to,remote,clusters,within,time,value,to,string,catch,exception,e,throw,new,illegal,state,exception,failed,to,connect,to,remote,clusters,e
RemoteClusterService -> void initializeRemoteClusters();1525334055;Connects to all remote clusters in a blocking fashion. This should be called on node startup to establish an initial connection_to all configured seed nodes.;void initializeRemoteClusters() {_        final TimeValue timeValue = REMOTE_INITIAL_CONNECTION_TIMEOUT_SETTING.get(settings)__        final PlainActionFuture<Void> future = new PlainActionFuture<>()__        Map<String, List<DiscoveryNode>> seeds = RemoteClusterAware.buildRemoteClustersSeeds(settings)__        updateRemoteClusters(seeds, future)__        try {_            future.get(timeValue.millis(), TimeUnit.MILLISECONDS)__        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()__        } catch (TimeoutException ex) {_            logger.warn("failed to connect to remote clusters within {}", timeValue.toString())__        } catch (Exception e) {_            throw new IllegalStateException("failed to connect to remote clusters", e)__        }_    };connects,to,all,remote,clusters,in,a,blocking,fashion,this,should,be,called,on,node,startup,to,establish,an,initial,connection,to,all,configured,seed,nodes;void,initialize,remote,clusters,final,time,value,time,value,get,settings,final,plain,action,future,void,future,new,plain,action,future,map,string,list,discovery,node,seeds,remote,cluster,aware,build,remote,clusters,seeds,settings,update,remote,clusters,seeds,future,try,future,get,time,value,millis,time,unit,milliseconds,catch,interrupted,exception,e,thread,current,thread,interrupt,catch,timeout,exception,ex,logger,warn,failed,to,connect,to,remote,clusters,within,time,value,to,string,catch,exception,e,throw,new,illegal,state,exception,failed,to,connect,to,remote,clusters,e
RemoteClusterService -> void initializeRemoteClusters();1527773340;Connects to all remote clusters in a blocking fashion. This should be called on node startup to establish an initial connection_to all configured seed nodes.;void initializeRemoteClusters() {_        final TimeValue timeValue = REMOTE_INITIAL_CONNECTION_TIMEOUT_SETTING.get(settings)__        final PlainActionFuture<Void> future = new PlainActionFuture<>()__        Map<String, List<DiscoveryNode>> seeds = RemoteClusterAware.buildRemoteClustersSeeds(settings)__        updateRemoteClusters(seeds, future)__        try {_            future.get(timeValue.millis(), TimeUnit.MILLISECONDS)__        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()__        } catch (TimeoutException ex) {_            logger.warn("failed to connect to remote clusters within {}", timeValue.toString())__        } catch (Exception e) {_            throw new IllegalStateException("failed to connect to remote clusters", e)__        }_    };connects,to,all,remote,clusters,in,a,blocking,fashion,this,should,be,called,on,node,startup,to,establish,an,initial,connection,to,all,configured,seed,nodes;void,initialize,remote,clusters,final,time,value,time,value,get,settings,final,plain,action,future,void,future,new,plain,action,future,map,string,list,discovery,node,seeds,remote,cluster,aware,build,remote,clusters,seeds,settings,update,remote,clusters,seeds,future,try,future,get,time,value,millis,time,unit,milliseconds,catch,interrupted,exception,e,thread,current,thread,interrupt,catch,timeout,exception,ex,logger,warn,failed,to,connect,to,remote,clusters,within,time,value,to,string,catch,exception,e,throw,new,illegal,state,exception,failed,to,connect,to,remote,clusters,e
RemoteClusterService -> void initializeRemoteClusters();1527840262;Connects to all remote clusters in a blocking fashion. This should be called on node startup to establish an initial connection_to all configured seed nodes.;void initializeRemoteClusters() {_        final TimeValue timeValue = REMOTE_INITIAL_CONNECTION_TIMEOUT_SETTING.get(settings)__        final PlainActionFuture<Void> future = new PlainActionFuture<>()__        Map<String, List<DiscoveryNode>> seeds = RemoteClusterAware.buildRemoteClustersSeeds(settings)__        updateRemoteClusters(seeds, future)__        try {_            future.get(timeValue.millis(), TimeUnit.MILLISECONDS)__        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()__        } catch (TimeoutException ex) {_            logger.warn("failed to connect to remote clusters within {}", timeValue.toString())__        } catch (Exception e) {_            throw new IllegalStateException("failed to connect to remote clusters", e)__        }_    };connects,to,all,remote,clusters,in,a,blocking,fashion,this,should,be,called,on,node,startup,to,establish,an,initial,connection,to,all,configured,seed,nodes;void,initialize,remote,clusters,final,time,value,time,value,get,settings,final,plain,action,future,void,future,new,plain,action,future,map,string,list,discovery,node,seeds,remote,cluster,aware,build,remote,clusters,seeds,settings,update,remote,clusters,seeds,future,try,future,get,time,value,millis,time,unit,milliseconds,catch,interrupted,exception,e,thread,current,thread,interrupt,catch,timeout,exception,ex,logger,warn,failed,to,connect,to,remote,clusters,within,time,value,to,string,catch,exception,e,throw,new,illegal,state,exception,failed,to,connect,to,remote,clusters,e
RemoteClusterService -> void initializeRemoteClusters();1534755962;Connects to all remote clusters in a blocking fashion. This should be called on node startup to establish an initial connection_to all configured seed nodes.;void initializeRemoteClusters() {_        final TimeValue timeValue = REMOTE_INITIAL_CONNECTION_TIMEOUT_SETTING.get(settings)__        final PlainActionFuture<Void> future = new PlainActionFuture<>()__        Map<String, List<Supplier<DiscoveryNode>>> seeds = RemoteClusterAware.buildRemoteClustersSeeds(settings)__        updateRemoteClusters(seeds, future)__        try {_            future.get(timeValue.millis(), TimeUnit.MILLISECONDS)__        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()__        } catch (TimeoutException ex) {_            logger.warn("failed to connect to remote clusters within {}", timeValue.toString())__        } catch (Exception e) {_            throw new IllegalStateException("failed to connect to remote clusters", e)__        }_    };connects,to,all,remote,clusters,in,a,blocking,fashion,this,should,be,called,on,node,startup,to,establish,an,initial,connection,to,all,configured,seed,nodes;void,initialize,remote,clusters,final,time,value,time,value,get,settings,final,plain,action,future,void,future,new,plain,action,future,map,string,list,supplier,discovery,node,seeds,remote,cluster,aware,build,remote,clusters,seeds,settings,update,remote,clusters,seeds,future,try,future,get,time,value,millis,time,unit,milliseconds,catch,interrupted,exception,e,thread,current,thread,interrupt,catch,timeout,exception,ex,logger,warn,failed,to,connect,to,remote,clusters,within,time,value,to,string,catch,exception,e,throw,new,illegal,state,exception,failed,to,connect,to,remote,clusters,e
RemoteClusterService -> void initializeRemoteClusters();1535046779;Connects to all remote clusters in a blocking fashion. This should be called on node startup to establish an initial connection_to all configured seed nodes.;void initializeRemoteClusters() {_        final TimeValue timeValue = REMOTE_INITIAL_CONNECTION_TIMEOUT_SETTING.get(settings)__        final PlainActionFuture<Void> future = new PlainActionFuture<>()__        Map<String, List<Supplier<DiscoveryNode>>> seeds = RemoteClusterAware.buildRemoteClustersSeeds(settings)__        updateRemoteClusters(seeds, future)__        try {_            future.get(timeValue.millis(), TimeUnit.MILLISECONDS)__        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()__        } catch (TimeoutException ex) {_            logger.warn("failed to connect to remote clusters within {}", timeValue.toString())__        } catch (Exception e) {_            throw new IllegalStateException("failed to connect to remote clusters", e)__        }_    };connects,to,all,remote,clusters,in,a,blocking,fashion,this,should,be,called,on,node,startup,to,establish,an,initial,connection,to,all,configured,seed,nodes;void,initialize,remote,clusters,final,time,value,time,value,get,settings,final,plain,action,future,void,future,new,plain,action,future,map,string,list,supplier,discovery,node,seeds,remote,cluster,aware,build,remote,clusters,seeds,settings,update,remote,clusters,seeds,future,try,future,get,time,value,millis,time,unit,milliseconds,catch,interrupted,exception,e,thread,current,thread,interrupt,catch,timeout,exception,ex,logger,warn,failed,to,connect,to,remote,clusters,within,time,value,to,string,catch,exception,e,throw,new,illegal,state,exception,failed,to,connect,to,remote,clusters,e
RemoteClusterService -> void initializeRemoteClusters();1535383145;Connects to all remote clusters in a blocking fashion. This should be called on node startup to establish an initial connection_to all configured seed nodes.;void initializeRemoteClusters() {_        final TimeValue timeValue = REMOTE_INITIAL_CONNECTION_TIMEOUT_SETTING.get(settings)__        final PlainActionFuture<Void> future = new PlainActionFuture<>()__        Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> seeds = RemoteClusterAware.buildRemoteClustersDynamicConfig(settings)__        updateRemoteClusters(seeds, future)__        try {_            future.get(timeValue.millis(), TimeUnit.MILLISECONDS)__        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()__        } catch (TimeoutException ex) {_            logger.warn("failed to connect to remote clusters within {}", timeValue.toString())__        } catch (Exception e) {_            throw new IllegalStateException("failed to connect to remote clusters", e)__        }_    };connects,to,all,remote,clusters,in,a,blocking,fashion,this,should,be,called,on,node,startup,to,establish,an,initial,connection,to,all,configured,seed,nodes;void,initialize,remote,clusters,final,time,value,time,value,get,settings,final,plain,action,future,void,future,new,plain,action,future,map,string,tuple,string,list,supplier,discovery,node,seeds,remote,cluster,aware,build,remote,clusters,dynamic,config,settings,update,remote,clusters,seeds,future,try,future,get,time,value,millis,time,unit,milliseconds,catch,interrupted,exception,e,thread,current,thread,interrupt,catch,timeout,exception,ex,logger,warn,failed,to,connect,to,remote,clusters,within,time,value,to,string,catch,exception,e,throw,new,illegal,state,exception,failed,to,connect,to,remote,clusters,e
RemoteClusterService -> void initializeRemoteClusters();1536218260;Connects to all remote clusters in a blocking fashion. This should be called on node startup to establish an initial connection_to all configured seed nodes.;void initializeRemoteClusters() {_        final TimeValue timeValue = REMOTE_INITIAL_CONNECTION_TIMEOUT_SETTING.get(settings)__        final PlainActionFuture<Void> future = new PlainActionFuture<>()__        Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> seeds = RemoteClusterAware.buildRemoteClustersDynamicConfig(settings)__        updateRemoteClusters(seeds, future)__        try {_            future.get(timeValue.millis(), TimeUnit.MILLISECONDS)__        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()__        } catch (TimeoutException ex) {_            logger.warn("failed to connect to remote clusters within {}", timeValue.toString())__        } catch (Exception e) {_            throw new IllegalStateException("failed to connect to remote clusters", e)__        }_    };connects,to,all,remote,clusters,in,a,blocking,fashion,this,should,be,called,on,node,startup,to,establish,an,initial,connection,to,all,configured,seed,nodes;void,initialize,remote,clusters,final,time,value,time,value,get,settings,final,plain,action,future,void,future,new,plain,action,future,map,string,tuple,string,list,supplier,discovery,node,seeds,remote,cluster,aware,build,remote,clusters,dynamic,config,settings,update,remote,clusters,seeds,future,try,future,get,time,value,millis,time,unit,milliseconds,catch,interrupted,exception,e,thread,current,thread,interrupt,catch,timeout,exception,ex,logger,warn,failed,to,connect,to,remote,clusters,within,time,value,to,string,catch,exception,e,throw,new,illegal,state,exception,failed,to,connect,to,remote,clusters,e
RemoteClusterService -> void initializeRemoteClusters();1536828374;Connects to all remote clusters in a blocking fashion. This should be called on node startup to establish an initial connection_to all configured seed nodes.;void initializeRemoteClusters() {_        final TimeValue timeValue = REMOTE_INITIAL_CONNECTION_TIMEOUT_SETTING.get(settings)__        final PlainActionFuture<Void> future = new PlainActionFuture<>()__        Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> seeds = RemoteClusterAware.buildRemoteClustersDynamicConfig(settings)__        updateRemoteClusters(seeds, future)__        try {_            future.get(timeValue.millis(), TimeUnit.MILLISECONDS)__        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()__        } catch (TimeoutException ex) {_            logger.warn("failed to connect to remote clusters within {}", timeValue.toString())__        } catch (Exception e) {_            throw new IllegalStateException("failed to connect to remote clusters", e)__        }_    };connects,to,all,remote,clusters,in,a,blocking,fashion,this,should,be,called,on,node,startup,to,establish,an,initial,connection,to,all,configured,seed,nodes;void,initialize,remote,clusters,final,time,value,time,value,get,settings,final,plain,action,future,void,future,new,plain,action,future,map,string,tuple,string,list,supplier,discovery,node,seeds,remote,cluster,aware,build,remote,clusters,dynamic,config,settings,update,remote,clusters,seeds,future,try,future,get,time,value,millis,time,unit,milliseconds,catch,interrupted,exception,e,thread,current,thread,interrupt,catch,timeout,exception,ex,logger,warn,failed,to,connect,to,remote,clusters,within,time,value,to,string,catch,exception,e,throw,new,illegal,state,exception,failed,to,connect,to,remote,clusters,e
RemoteClusterService -> void initializeRemoteClusters();1537806831;Connects to all remote clusters in a blocking fashion. This should be called on node startup to establish an initial connection_to all configured seed nodes.;void initializeRemoteClusters() {_        final TimeValue timeValue = REMOTE_INITIAL_CONNECTION_TIMEOUT_SETTING.get(settings)__        final PlainActionFuture<Void> future = new PlainActionFuture<>()__        Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> seeds = RemoteClusterAware.buildRemoteClustersDynamicConfig(settings)__        updateRemoteClusters(seeds, future)__        try {_            future.get(timeValue.millis(), TimeUnit.MILLISECONDS)__        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()__        } catch (TimeoutException ex) {_            logger.warn("failed to connect to remote clusters within {}", timeValue.toString())__        } catch (Exception e) {_            throw new IllegalStateException("failed to connect to remote clusters", e)__        }_    };connects,to,all,remote,clusters,in,a,blocking,fashion,this,should,be,called,on,node,startup,to,establish,an,initial,connection,to,all,configured,seed,nodes;void,initialize,remote,clusters,final,time,value,time,value,get,settings,final,plain,action,future,void,future,new,plain,action,future,map,string,tuple,string,list,supplier,discovery,node,seeds,remote,cluster,aware,build,remote,clusters,dynamic,config,settings,update,remote,clusters,seeds,future,try,future,get,time,value,millis,time,unit,milliseconds,catch,interrupted,exception,e,thread,current,thread,interrupt,catch,timeout,exception,ex,logger,warn,failed,to,connect,to,remote,clusters,within,time,value,to,string,catch,exception,e,throw,new,illegal,state,exception,failed,to,connect,to,remote,clusters,e
RemoteClusterService -> void initializeRemoteClusters();1541008027;Connects to all remote clusters in a blocking fashion. This should be called on node startup to establish an initial connection_to all configured seed nodes.;void initializeRemoteClusters() {_        final TimeValue timeValue = REMOTE_INITIAL_CONNECTION_TIMEOUT_SETTING.get(settings)__        final PlainActionFuture<Void> future = new PlainActionFuture<>()__        Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> seeds = RemoteClusterAware.buildRemoteClustersDynamicConfig(settings)__        updateRemoteClusters(seeds, future)__        try {_            future.get(timeValue.millis(), TimeUnit.MILLISECONDS)__        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()__        } catch (TimeoutException ex) {_            logger.warn("failed to connect to remote clusters within {}", timeValue.toString())__        } catch (Exception e) {_            throw new IllegalStateException("failed to connect to remote clusters", e)__        }_    };connects,to,all,remote,clusters,in,a,blocking,fashion,this,should,be,called,on,node,startup,to,establish,an,initial,connection,to,all,configured,seed,nodes;void,initialize,remote,clusters,final,time,value,time,value,get,settings,final,plain,action,future,void,future,new,plain,action,future,map,string,tuple,string,list,supplier,discovery,node,seeds,remote,cluster,aware,build,remote,clusters,dynamic,config,settings,update,remote,clusters,seeds,future,try,future,get,time,value,millis,time,unit,milliseconds,catch,interrupted,exception,e,thread,current,thread,interrupt,catch,timeout,exception,ex,logger,warn,failed,to,connect,to,remote,clusters,within,time,value,to,string,catch,exception,e,throw,new,illegal,state,exception,failed,to,connect,to,remote,clusters,e
RemoteClusterService -> void initializeRemoteClusters();1541698679;Connects to all remote clusters in a blocking fashion. This should be called on node startup to establish an initial connection_to all configured seed nodes.;void initializeRemoteClusters() {_        final TimeValue timeValue = REMOTE_INITIAL_CONNECTION_TIMEOUT_SETTING.get(settings)__        final PlainActionFuture<Void> future = new PlainActionFuture<>()__        Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> seeds = RemoteClusterAware.buildRemoteClustersDynamicConfig(settings)__        updateRemoteClusters(seeds, future)__        try {_            future.get(timeValue.millis(), TimeUnit.MILLISECONDS)__        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()__        } catch (TimeoutException ex) {_            logger.warn("failed to connect to remote clusters within {}", timeValue.toString())__        } catch (Exception e) {_            throw new IllegalStateException("failed to connect to remote clusters", e)__        }_    };connects,to,all,remote,clusters,in,a,blocking,fashion,this,should,be,called,on,node,startup,to,establish,an,initial,connection,to,all,configured,seed,nodes;void,initialize,remote,clusters,final,time,value,time,value,get,settings,final,plain,action,future,void,future,new,plain,action,future,map,string,tuple,string,list,supplier,discovery,node,seeds,remote,cluster,aware,build,remote,clusters,dynamic,config,settings,update,remote,clusters,seeds,future,try,future,get,time,value,millis,time,unit,milliseconds,catch,interrupted,exception,e,thread,current,thread,interrupt,catch,timeout,exception,ex,logger,warn,failed,to,connect,to,remote,clusters,within,time,value,to,string,catch,exception,e,throw,new,illegal,state,exception,failed,to,connect,to,remote,clusters,e
RemoteClusterService -> void initializeRemoteClusters();1542402632;Connects to all remote clusters in a blocking fashion. This should be called on node startup to establish an initial connection_to all configured seed nodes.;void initializeRemoteClusters() {_        final TimeValue timeValue = REMOTE_INITIAL_CONNECTION_TIMEOUT_SETTING.get(settings)__        final PlainActionFuture<Void> future = new PlainActionFuture<>()__        Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> seeds = RemoteClusterAware.buildRemoteClustersDynamicConfig(settings)__        updateRemoteClusters(seeds, future)__        try {_            future.get(timeValue.millis(), TimeUnit.MILLISECONDS)__        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()__        } catch (TimeoutException ex) {_            logger.warn("failed to connect to remote clusters within {}", timeValue.toString())__        } catch (Exception e) {_            throw new IllegalStateException("failed to connect to remote clusters", e)__        }_    };connects,to,all,remote,clusters,in,a,blocking,fashion,this,should,be,called,on,node,startup,to,establish,an,initial,connection,to,all,configured,seed,nodes;void,initialize,remote,clusters,final,time,value,time,value,get,settings,final,plain,action,future,void,future,new,plain,action,future,map,string,tuple,string,list,supplier,discovery,node,seeds,remote,cluster,aware,build,remote,clusters,dynamic,config,settings,update,remote,clusters,seeds,future,try,future,get,time,value,millis,time,unit,milliseconds,catch,interrupted,exception,e,thread,current,thread,interrupt,catch,timeout,exception,ex,logger,warn,failed,to,connect,to,remote,clusters,within,time,value,to,string,catch,exception,e,throw,new,illegal,state,exception,failed,to,connect,to,remote,clusters,e
RemoteClusterService -> void initializeRemoteClusters();1543506953;Connects to all remote clusters in a blocking fashion. This should be called on node startup to establish an initial connection_to all configured seed nodes.;void initializeRemoteClusters() {_        final TimeValue timeValue = REMOTE_INITIAL_CONNECTION_TIMEOUT_SETTING.get(settings)__        final PlainActionFuture<Void> future = new PlainActionFuture<>()__        Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> seeds = RemoteClusterAware.buildRemoteClustersDynamicConfig(settings)__        updateRemoteClusters(seeds, future)__        try {_            future.get(timeValue.millis(), TimeUnit.MILLISECONDS)__        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()__        } catch (TimeoutException ex) {_            logger.warn("failed to connect to remote clusters within {}", timeValue.toString())__        } catch (Exception e) {_            throw new IllegalStateException("failed to connect to remote clusters", e)__        }_    };connects,to,all,remote,clusters,in,a,blocking,fashion,this,should,be,called,on,node,startup,to,establish,an,initial,connection,to,all,configured,seed,nodes;void,initialize,remote,clusters,final,time,value,time,value,get,settings,final,plain,action,future,void,future,new,plain,action,future,map,string,tuple,string,list,supplier,discovery,node,seeds,remote,cluster,aware,build,remote,clusters,dynamic,config,settings,update,remote,clusters,seeds,future,try,future,get,time,value,millis,time,unit,milliseconds,catch,interrupted,exception,e,thread,current,thread,interrupt,catch,timeout,exception,ex,logger,warn,failed,to,connect,to,remote,clusters,within,time,value,to,string,catch,exception,e,throw,new,illegal,state,exception,failed,to,connect,to,remote,clusters,e
RemoteClusterService -> void initializeRemoteClusters();1543959410;Connects to all remote clusters in a blocking fashion. This should be called on node startup to establish an initial connection_to all configured seed nodes.;void initializeRemoteClusters() {_        final TimeValue timeValue = REMOTE_INITIAL_CONNECTION_TIMEOUT_SETTING.get(settings)__        final PlainActionFuture<Void> future = new PlainActionFuture<>()__        Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> seeds = RemoteClusterAware.buildRemoteClustersDynamicConfig(settings)__        updateRemoteClusters(seeds, future)__        try {_            future.get(timeValue.millis(), TimeUnit.MILLISECONDS)__        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()__        } catch (TimeoutException ex) {_            logger.warn("failed to connect to remote clusters within {}", timeValue.toString())__        } catch (Exception e) {_            throw new IllegalStateException("failed to connect to remote clusters", e)__        }_    };connects,to,all,remote,clusters,in,a,blocking,fashion,this,should,be,called,on,node,startup,to,establish,an,initial,connection,to,all,configured,seed,nodes;void,initialize,remote,clusters,final,time,value,time,value,get,settings,final,plain,action,future,void,future,new,plain,action,future,map,string,tuple,string,list,supplier,discovery,node,seeds,remote,cluster,aware,build,remote,clusters,dynamic,config,settings,update,remote,clusters,seeds,future,try,future,get,time,value,millis,time,unit,milliseconds,catch,interrupted,exception,e,thread,current,thread,interrupt,catch,timeout,exception,ex,logger,warn,failed,to,connect,to,remote,clusters,within,time,value,to,string,catch,exception,e,throw,new,illegal,state,exception,failed,to,connect,to,remote,clusters,e
RemoteClusterService -> void initializeRemoteClusters();1544823664;Connects to all remote clusters in a blocking fashion. This should be called on node startup to establish an initial connection_to all configured seed nodes.;void initializeRemoteClusters() {_        final TimeValue timeValue = REMOTE_INITIAL_CONNECTION_TIMEOUT_SETTING.get(settings)__        final PlainActionFuture<Void> future = new PlainActionFuture<>()__        Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> seeds = RemoteClusterAware.buildRemoteClustersDynamicConfig(settings)__        updateRemoteClusters(seeds, future)__        try {_            future.get(timeValue.millis(), TimeUnit.MILLISECONDS)__        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()__        } catch (TimeoutException ex) {_            logger.warn("failed to connect to remote clusters within {}", timeValue.toString())__        } catch (Exception e) {_            throw new IllegalStateException("failed to connect to remote clusters", e)__        }_    };connects,to,all,remote,clusters,in,a,blocking,fashion,this,should,be,called,on,node,startup,to,establish,an,initial,connection,to,all,configured,seed,nodes;void,initialize,remote,clusters,final,time,value,time,value,get,settings,final,plain,action,future,void,future,new,plain,action,future,map,string,tuple,string,list,supplier,discovery,node,seeds,remote,cluster,aware,build,remote,clusters,dynamic,config,settings,update,remote,clusters,seeds,future,try,future,get,time,value,millis,time,unit,milliseconds,catch,interrupted,exception,e,thread,current,thread,interrupt,catch,timeout,exception,ex,logger,warn,failed,to,connect,to,remote,clusters,within,time,value,to,string,catch,exception,e,throw,new,illegal,state,exception,failed,to,connect,to,remote,clusters,e
RemoteClusterService -> void initializeRemoteClusters();1545071071;Connects to all remote clusters in a blocking fashion. This should be called on node startup to establish an initial connection_to all configured seed nodes.;void initializeRemoteClusters() {_        final TimeValue timeValue = REMOTE_INITIAL_CONNECTION_TIMEOUT_SETTING.get(settings)__        final PlainActionFuture<Void> future = new PlainActionFuture<>()__        Map<String, Tuple<String, List<Tuple<String, Supplier<DiscoveryNode>>>>> seeds =_                RemoteClusterAware.buildRemoteClustersDynamicConfig(settings)__        updateRemoteClusters(seeds, future)__        try {_            future.get(timeValue.millis(), TimeUnit.MILLISECONDS)__        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()__        } catch (TimeoutException ex) {_            logger.warn("failed to connect to remote clusters within {}", timeValue.toString())__        } catch (Exception e) {_            throw new IllegalStateException("failed to connect to remote clusters", e)__        }_    };connects,to,all,remote,clusters,in,a,blocking,fashion,this,should,be,called,on,node,startup,to,establish,an,initial,connection,to,all,configured,seed,nodes;void,initialize,remote,clusters,final,time,value,time,value,get,settings,final,plain,action,future,void,future,new,plain,action,future,map,string,tuple,string,list,tuple,string,supplier,discovery,node,seeds,remote,cluster,aware,build,remote,clusters,dynamic,config,settings,update,remote,clusters,seeds,future,try,future,get,time,value,millis,time,unit,milliseconds,catch,interrupted,exception,e,thread,current,thread,interrupt,catch,timeout,exception,ex,logger,warn,failed,to,connect,to,remote,clusters,within,time,value,to,string,catch,exception,e,throw,new,illegal,state,exception,failed,to,connect,to,remote,clusters,e
RemoteClusterService -> void initializeRemoteClusters();1546929322;Connects to all remote clusters in a blocking fashion. This should be called on node startup to establish an initial connection_to all configured seed nodes.;void initializeRemoteClusters() {_        final TimeValue timeValue = REMOTE_INITIAL_CONNECTION_TIMEOUT_SETTING.get(settings)__        final PlainActionFuture<Void> future = new PlainActionFuture<>()__        Map<String, Tuple<String, List<Tuple<String, Supplier<DiscoveryNode>>>>> seeds =_                RemoteClusterAware.buildRemoteClustersDynamicConfig(settings)__        updateRemoteClusters(seeds, future)__        try {_            future.get(timeValue.millis(), TimeUnit.MILLISECONDS)__        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()__        } catch (TimeoutException ex) {_            logger.warn("failed to connect to remote clusters within {}", timeValue.toString())__        } catch (Exception e) {_            throw new IllegalStateException("failed to connect to remote clusters", e)__        }_    };connects,to,all,remote,clusters,in,a,blocking,fashion,this,should,be,called,on,node,startup,to,establish,an,initial,connection,to,all,configured,seed,nodes;void,initialize,remote,clusters,final,time,value,time,value,get,settings,final,plain,action,future,void,future,new,plain,action,future,map,string,tuple,string,list,tuple,string,supplier,discovery,node,seeds,remote,cluster,aware,build,remote,clusters,dynamic,config,settings,update,remote,clusters,seeds,future,try,future,get,time,value,millis,time,unit,milliseconds,catch,interrupted,exception,e,thread,current,thread,interrupt,catch,timeout,exception,ex,logger,warn,failed,to,connect,to,remote,clusters,within,time,value,to,string,catch,exception,e,throw,new,illegal,state,exception,failed,to,connect,to,remote,clusters,e
RemoteClusterService -> void initializeRemoteClusters();1547561945;Connects to all remote clusters in a blocking fashion. This should be called on node startup to establish an initial connection_to all configured seed nodes.;void initializeRemoteClusters() {_        final TimeValue timeValue = REMOTE_INITIAL_CONNECTION_TIMEOUT_SETTING.get(settings)__        final PlainActionFuture<Void> future = new PlainActionFuture<>()__        Map<String, Tuple<String, List<Tuple<String, Supplier<DiscoveryNode>>>>> seeds =_                RemoteClusterAware.buildRemoteClustersDynamicConfig(settings)__        updateRemoteClusters(seeds, future)__        try {_            future.get(timeValue.millis(), TimeUnit.MILLISECONDS)__        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()__        } catch (TimeoutException ex) {_            logger.warn("failed to connect to remote clusters within {}", timeValue.toString())__        } catch (Exception e) {_            throw new IllegalStateException("failed to connect to remote clusters", e)__        }_    };connects,to,all,remote,clusters,in,a,blocking,fashion,this,should,be,called,on,node,startup,to,establish,an,initial,connection,to,all,configured,seed,nodes;void,initialize,remote,clusters,final,time,value,time,value,get,settings,final,plain,action,future,void,future,new,plain,action,future,map,string,tuple,string,list,tuple,string,supplier,discovery,node,seeds,remote,cluster,aware,build,remote,clusters,dynamic,config,settings,update,remote,clusters,seeds,future,try,future,get,time,value,millis,time,unit,milliseconds,catch,interrupted,exception,e,thread,current,thread,interrupt,catch,timeout,exception,ex,logger,warn,failed,to,connect,to,remote,clusters,within,time,value,to,string,catch,exception,e,throw,new,illegal,state,exception,failed,to,connect,to,remote,clusters,e
RemoteClusterService -> void initializeRemoteClusters();1548248017;Connects to all remote clusters in a blocking fashion. This should be called on node startup to establish an initial connection_to all configured seed nodes.;void initializeRemoteClusters() {_        final TimeValue timeValue = REMOTE_INITIAL_CONNECTION_TIMEOUT_SETTING.get(settings)__        final PlainActionFuture<Void> future = new PlainActionFuture<>()__        Map<String, Tuple<String, List<Tuple<String, Supplier<DiscoveryNode>>>>> seeds =_                RemoteClusterAware.buildRemoteClustersDynamicConfig(settings)__        updateRemoteClusters(seeds, future)__        try {_            future.get(timeValue.millis(), TimeUnit.MILLISECONDS)__        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()__        } catch (TimeoutException ex) {_            logger.warn("failed to connect to remote clusters within {}", timeValue.toString())__        } catch (Exception e) {_            throw new IllegalStateException("failed to connect to remote clusters", e)__        }_    };connects,to,all,remote,clusters,in,a,blocking,fashion,this,should,be,called,on,node,startup,to,establish,an,initial,connection,to,all,configured,seed,nodes;void,initialize,remote,clusters,final,time,value,time,value,get,settings,final,plain,action,future,void,future,new,plain,action,future,map,string,tuple,string,list,tuple,string,supplier,discovery,node,seeds,remote,cluster,aware,build,remote,clusters,dynamic,config,settings,update,remote,clusters,seeds,future,try,future,get,time,value,millis,time,unit,milliseconds,catch,interrupted,exception,e,thread,current,thread,interrupt,catch,timeout,exception,ex,logger,warn,failed,to,connect,to,remote,clusters,within,time,value,to,string,catch,exception,e,throw,new,illegal,state,exception,failed,to,connect,to,remote,clusters,e
RemoteClusterService -> void initializeRemoteClusters();1548402798;Connects to all remote clusters in a blocking fashion. This should be called on node startup to establish an initial connection_to all configured seed nodes.;void initializeRemoteClusters() {_        final TimeValue timeValue = REMOTE_INITIAL_CONNECTION_TIMEOUT_SETTING.get(settings)__        final PlainActionFuture<Void> future = new PlainActionFuture<>()__        Map<String, Tuple<String, List<Tuple<String, Supplier<DiscoveryNode>>>>> seeds =_                RemoteClusterAware.buildRemoteClustersDynamicConfig(settings)__        updateRemoteClusters(seeds, future)__        try {_            future.get(timeValue.millis(), TimeUnit.MILLISECONDS)__        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()__        } catch (TimeoutException ex) {_            logger.warn("failed to connect to remote clusters within {}", timeValue.toString())__        } catch (Exception e) {_            throw new IllegalStateException("failed to connect to remote clusters", e)__        }_    };connects,to,all,remote,clusters,in,a,blocking,fashion,this,should,be,called,on,node,startup,to,establish,an,initial,connection,to,all,configured,seed,nodes;void,initialize,remote,clusters,final,time,value,time,value,get,settings,final,plain,action,future,void,future,new,plain,action,future,map,string,tuple,string,list,tuple,string,supplier,discovery,node,seeds,remote,cluster,aware,build,remote,clusters,dynamic,config,settings,update,remote,clusters,seeds,future,try,future,get,time,value,millis,time,unit,milliseconds,catch,interrupted,exception,e,thread,current,thread,interrupt,catch,timeout,exception,ex,logger,warn,failed,to,connect,to,remote,clusters,within,time,value,to,string,catch,exception,e,throw,new,illegal,state,exception,failed,to,connect,to,remote,clusters,e
RemoteClusterService -> void initializeRemoteClusters();1549608646;Connects to all remote clusters in a blocking fashion. This should be called on node startup to establish an initial connection_to all configured seed nodes.;void initializeRemoteClusters() {_        final TimeValue timeValue = REMOTE_INITIAL_CONNECTION_TIMEOUT_SETTING.get(settings)__        final PlainActionFuture<Void> future = new PlainActionFuture<>()__        Map<String, Tuple<String, List<Tuple<String, Supplier<DiscoveryNode>>>>> seeds =_                RemoteClusterAware.buildRemoteClustersDynamicConfig(settings)__        updateRemoteClusters(seeds, future)__        try {_            future.get(timeValue.millis(), TimeUnit.MILLISECONDS)__        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()__        } catch (TimeoutException ex) {_            logger.warn("failed to connect to remote clusters within {}", timeValue.toString())__        } catch (Exception e) {_            throw new IllegalStateException("failed to connect to remote clusters", e)__        }_    };connects,to,all,remote,clusters,in,a,blocking,fashion,this,should,be,called,on,node,startup,to,establish,an,initial,connection,to,all,configured,seed,nodes;void,initialize,remote,clusters,final,time,value,time,value,get,settings,final,plain,action,future,void,future,new,plain,action,future,map,string,tuple,string,list,tuple,string,supplier,discovery,node,seeds,remote,cluster,aware,build,remote,clusters,dynamic,config,settings,update,remote,clusters,seeds,future,try,future,get,time,value,millis,time,unit,milliseconds,catch,interrupted,exception,e,thread,current,thread,interrupt,catch,timeout,exception,ex,logger,warn,failed,to,connect,to,remote,clusters,within,time,value,to,string,catch,exception,e,throw,new,illegal,state,exception,failed,to,connect,to,remote,clusters,e
RemoteClusterService -> void initializeRemoteClusters();1550601141;Connects to all remote clusters in a blocking fashion. This should be called on node startup to establish an initial connection_to all configured seed nodes.;void initializeRemoteClusters() {_        final TimeValue timeValue = REMOTE_INITIAL_CONNECTION_TIMEOUT_SETTING.get(settings)__        final PlainActionFuture<Void> future = new PlainActionFuture<>()__        Map<String, Tuple<String, List<Tuple<String, Supplier<DiscoveryNode>>>>> seeds =_                RemoteClusterAware.buildRemoteClustersDynamicConfig(settings)__        initializeConnectionProfiles(seeds.keySet())__        updateRemoteClusters(seeds, future)__        try {_            future.get(timeValue.millis(), TimeUnit.MILLISECONDS)__        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()__        } catch (TimeoutException ex) {_            logger.warn("failed to connect to remote clusters within {}", timeValue.toString())__        } catch (Exception e) {_            throw new IllegalStateException("failed to connect to remote clusters", e)__        }_    };connects,to,all,remote,clusters,in,a,blocking,fashion,this,should,be,called,on,node,startup,to,establish,an,initial,connection,to,all,configured,seed,nodes;void,initialize,remote,clusters,final,time,value,time,value,get,settings,final,plain,action,future,void,future,new,plain,action,future,map,string,tuple,string,list,tuple,string,supplier,discovery,node,seeds,remote,cluster,aware,build,remote,clusters,dynamic,config,settings,initialize,connection,profiles,seeds,key,set,update,remote,clusters,seeds,future,try,future,get,time,value,millis,time,unit,milliseconds,catch,interrupted,exception,e,thread,current,thread,interrupt,catch,timeout,exception,ex,logger,warn,failed,to,connect,to,remote,clusters,within,time,value,to,string,catch,exception,e,throw,new,illegal,state,exception,failed,to,connect,to,remote,clusters,e
RemoteClusterService -> boolean isRemoteClusterRegistered(String clusterName);1524684173;Returns <code>true</code> iff the given cluster is configured as a remote cluster. Otherwise <code>false</code>;boolean isRemoteClusterRegistered(String clusterName) {_        return remoteClusters.containsKey(clusterName)__    };returns,code,true,code,iff,the,given,cluster,is,configured,as,a,remote,cluster,otherwise,code,false,code;boolean,is,remote,cluster,registered,string,cluster,name,return,remote,clusters,contains,key,cluster,name
RemoteClusterService -> boolean isRemoteClusterRegistered(String clusterName);1525076988;Returns <code>true</code> iff the given cluster is configured as a remote cluster. Otherwise <code>false</code>;boolean isRemoteClusterRegistered(String clusterName) {_        return remoteClusters.containsKey(clusterName)__    };returns,code,true,code,iff,the,given,cluster,is,configured,as,a,remote,cluster,otherwise,code,false,code;boolean,is,remote,cluster,registered,string,cluster,name,return,remote,clusters,contains,key,cluster,name
RemoteClusterService -> boolean isRemoteClusterRegistered(String clusterName);1525334055;Returns <code>true</code> iff the given cluster is configured as a remote cluster. Otherwise <code>false</code>;boolean isRemoteClusterRegistered(String clusterName) {_        return remoteClusters.containsKey(clusterName)__    };returns,code,true,code,iff,the,given,cluster,is,configured,as,a,remote,cluster,otherwise,code,false,code;boolean,is,remote,cluster,registered,string,cluster,name,return,remote,clusters,contains,key,cluster,name
RemoteClusterService -> boolean isRemoteClusterRegistered(String clusterName);1527773340;Returns <code>true</code> iff the given cluster is configured as a remote cluster. Otherwise <code>false</code>;boolean isRemoteClusterRegistered(String clusterName) {_        return remoteClusters.containsKey(clusterName)__    };returns,code,true,code,iff,the,given,cluster,is,configured,as,a,remote,cluster,otherwise,code,false,code;boolean,is,remote,cluster,registered,string,cluster,name,return,remote,clusters,contains,key,cluster,name
RemoteClusterService -> boolean isRemoteClusterRegistered(String clusterName);1527840262;Returns <code>true</code> iff the given cluster is configured as a remote cluster. Otherwise <code>false</code>;boolean isRemoteClusterRegistered(String clusterName) {_        return remoteClusters.containsKey(clusterName)__    };returns,code,true,code,iff,the,given,cluster,is,configured,as,a,remote,cluster,otherwise,code,false,code;boolean,is,remote,cluster,registered,string,cluster,name,return,remote,clusters,contains,key,cluster,name
RemoteClusterService -> boolean isRemoteClusterRegistered(String clusterName);1534755962;Returns <code>true</code> iff the given cluster is configured as a remote cluster. Otherwise <code>false</code>;boolean isRemoteClusterRegistered(String clusterName) {_        return remoteClusters.containsKey(clusterName)__    };returns,code,true,code,iff,the,given,cluster,is,configured,as,a,remote,cluster,otherwise,code,false,code;boolean,is,remote,cluster,registered,string,cluster,name,return,remote,clusters,contains,key,cluster,name
RemoteClusterService -> boolean isRemoteClusterRegistered(String clusterName);1535046779;Returns <code>true</code> iff the given cluster is configured as a remote cluster. Otherwise <code>false</code>;boolean isRemoteClusterRegistered(String clusterName) {_        return remoteClusters.containsKey(clusterName)__    };returns,code,true,code,iff,the,given,cluster,is,configured,as,a,remote,cluster,otherwise,code,false,code;boolean,is,remote,cluster,registered,string,cluster,name,return,remote,clusters,contains,key,cluster,name
RemoteClusterService -> boolean isRemoteClusterRegistered(String clusterName);1535383145;Returns <code>true</code> iff the given cluster is configured as a remote cluster. Otherwise <code>false</code>;boolean isRemoteClusterRegistered(String clusterName) {_        return remoteClusters.containsKey(clusterName)__    };returns,code,true,code,iff,the,given,cluster,is,configured,as,a,remote,cluster,otherwise,code,false,code;boolean,is,remote,cluster,registered,string,cluster,name,return,remote,clusters,contains,key,cluster,name
RemoteClusterService -> boolean isRemoteClusterRegistered(String clusterName);1536218260;Returns <code>true</code> iff the given cluster is configured as a remote cluster. Otherwise <code>false</code>;boolean isRemoteClusterRegistered(String clusterName) {_        return remoteClusters.containsKey(clusterName)__    };returns,code,true,code,iff,the,given,cluster,is,configured,as,a,remote,cluster,otherwise,code,false,code;boolean,is,remote,cluster,registered,string,cluster,name,return,remote,clusters,contains,key,cluster,name
RemoteClusterService -> boolean isRemoteClusterRegistered(String clusterName);1536828374;Returns <code>true</code> iff the given cluster is configured as a remote cluster. Otherwise <code>false</code>;boolean isRemoteClusterRegistered(String clusterName) {_        return remoteClusters.containsKey(clusterName)__    };returns,code,true,code,iff,the,given,cluster,is,configured,as,a,remote,cluster,otherwise,code,false,code;boolean,is,remote,cluster,registered,string,cluster,name,return,remote,clusters,contains,key,cluster,name
RemoteClusterService -> boolean isRemoteClusterRegistered(String clusterName);1537806831;Returns <code>true</code> iff the given cluster is configured as a remote cluster. Otherwise <code>false</code>;boolean isRemoteClusterRegistered(String clusterName) {_        return remoteClusters.containsKey(clusterName)__    };returns,code,true,code,iff,the,given,cluster,is,configured,as,a,remote,cluster,otherwise,code,false,code;boolean,is,remote,cluster,registered,string,cluster,name,return,remote,clusters,contains,key,cluster,name
RemoteClusterService -> boolean isRemoteClusterRegistered(String clusterName);1541008027;Returns <code>true</code> iff the given cluster is configured as a remote cluster. Otherwise <code>false</code>;boolean isRemoteClusterRegistered(String clusterName) {_        return remoteClusters.containsKey(clusterName)__    };returns,code,true,code,iff,the,given,cluster,is,configured,as,a,remote,cluster,otherwise,code,false,code;boolean,is,remote,cluster,registered,string,cluster,name,return,remote,clusters,contains,key,cluster,name
RemoteClusterService -> boolean isRemoteClusterRegistered(String clusterName);1541698679;Returns <code>true</code> iff the given cluster is configured as a remote cluster. Otherwise <code>false</code>;boolean isRemoteClusterRegistered(String clusterName) {_        return remoteClusters.containsKey(clusterName)__    };returns,code,true,code,iff,the,given,cluster,is,configured,as,a,remote,cluster,otherwise,code,false,code;boolean,is,remote,cluster,registered,string,cluster,name,return,remote,clusters,contains,key,cluster,name
RemoteClusterService -> boolean isRemoteClusterRegistered(String clusterName);1542402632;Returns <code>true</code> iff the given cluster is configured as a remote cluster. Otherwise <code>false</code>;boolean isRemoteClusterRegistered(String clusterName) {_        return remoteClusters.containsKey(clusterName)__    };returns,code,true,code,iff,the,given,cluster,is,configured,as,a,remote,cluster,otherwise,code,false,code;boolean,is,remote,cluster,registered,string,cluster,name,return,remote,clusters,contains,key,cluster,name
RemoteClusterService -> boolean isRemoteClusterRegistered(String clusterName);1543506953;Returns <code>true</code> iff the given cluster is configured as a remote cluster. Otherwise <code>false</code>;boolean isRemoteClusterRegistered(String clusterName) {_        return remoteClusters.containsKey(clusterName)__    };returns,code,true,code,iff,the,given,cluster,is,configured,as,a,remote,cluster,otherwise,code,false,code;boolean,is,remote,cluster,registered,string,cluster,name,return,remote,clusters,contains,key,cluster,name
RemoteClusterService -> boolean isRemoteClusterRegistered(String clusterName);1543959410;Returns <code>true</code> iff the given cluster is configured as a remote cluster. Otherwise <code>false</code>;boolean isRemoteClusterRegistered(String clusterName) {_        return remoteClusters.containsKey(clusterName)__    };returns,code,true,code,iff,the,given,cluster,is,configured,as,a,remote,cluster,otherwise,code,false,code;boolean,is,remote,cluster,registered,string,cluster,name,return,remote,clusters,contains,key,cluster,name
RemoteClusterService -> boolean isRemoteClusterRegistered(String clusterName);1544823664;Returns <code>true</code> iff the given cluster is configured as a remote cluster. Otherwise <code>false</code>;boolean isRemoteClusterRegistered(String clusterName) {_        return remoteClusters.containsKey(clusterName)__    };returns,code,true,code,iff,the,given,cluster,is,configured,as,a,remote,cluster,otherwise,code,false,code;boolean,is,remote,cluster,registered,string,cluster,name,return,remote,clusters,contains,key,cluster,name
RemoteClusterService -> boolean isRemoteClusterRegistered(String clusterName);1545071071;Returns <code>true</code> iff the given cluster is configured as a remote cluster. Otherwise <code>false</code>;boolean isRemoteClusterRegistered(String clusterName) {_        return remoteClusters.containsKey(clusterName)__    };returns,code,true,code,iff,the,given,cluster,is,configured,as,a,remote,cluster,otherwise,code,false,code;boolean,is,remote,cluster,registered,string,cluster,name,return,remote,clusters,contains,key,cluster,name
RemoteClusterService -> boolean isRemoteClusterRegistered(String clusterName);1546929322;Returns <code>true</code> iff the given cluster is configured as a remote cluster. Otherwise <code>false</code>;boolean isRemoteClusterRegistered(String clusterName) {_        return remoteClusters.containsKey(clusterName)__    };returns,code,true,code,iff,the,given,cluster,is,configured,as,a,remote,cluster,otherwise,code,false,code;boolean,is,remote,cluster,registered,string,cluster,name,return,remote,clusters,contains,key,cluster,name
RemoteClusterService -> boolean isRemoteClusterRegistered(String clusterName);1547561945;Returns <code>true</code> iff the given cluster is configured as a remote cluster. Otherwise <code>false</code>;boolean isRemoteClusterRegistered(String clusterName) {_        return remoteClusters.containsKey(clusterName)__    };returns,code,true,code,iff,the,given,cluster,is,configured,as,a,remote,cluster,otherwise,code,false,code;boolean,is,remote,cluster,registered,string,cluster,name,return,remote,clusters,contains,key,cluster,name
RemoteClusterService -> boolean isRemoteClusterRegistered(String clusterName);1548248017;Returns <code>true</code> iff the given cluster is configured as a remote cluster. Otherwise <code>false</code>;boolean isRemoteClusterRegistered(String clusterName) {_        return remoteClusters.containsKey(clusterName)__    };returns,code,true,code,iff,the,given,cluster,is,configured,as,a,remote,cluster,otherwise,code,false,code;boolean,is,remote,cluster,registered,string,cluster,name,return,remote,clusters,contains,key,cluster,name
RemoteClusterService -> boolean isRemoteClusterRegistered(String clusterName);1548402798;Returns <code>true</code> iff the given cluster is configured as a remote cluster. Otherwise <code>false</code>;boolean isRemoteClusterRegistered(String clusterName) {_        return remoteClusters.containsKey(clusterName)__    };returns,code,true,code,iff,the,given,cluster,is,configured,as,a,remote,cluster,otherwise,code,false,code;boolean,is,remote,cluster,registered,string,cluster,name,return,remote,clusters,contains,key,cluster,name
RemoteClusterService -> boolean isRemoteClusterRegistered(String clusterName);1549608646;Returns <code>true</code> iff the given cluster is configured as a remote cluster. Otherwise <code>false</code>;boolean isRemoteClusterRegistered(String clusterName) {_        return remoteClusters.containsKey(clusterName)__    };returns,code,true,code,iff,the,given,cluster,is,configured,as,a,remote,cluster,otherwise,code,false,code;boolean,is,remote,cluster,registered,string,cluster,name,return,remote,clusters,contains,key,cluster,name
RemoteClusterService -> boolean isRemoteClusterRegistered(String clusterName);1550601141;Returns <code>true</code> iff the given cluster is configured as a remote cluster. Otherwise <code>false</code>;boolean isRemoteClusterRegistered(String clusterName) {_        return remoteClusters.containsKey(clusterName)__    };returns,code,true,code,iff,the,given,cluster,is,configured,as,a,remote,cluster,otherwise,code,false,code;boolean,is,remote,cluster,registered,string,cluster,name,return,remote,clusters,contains,key,cluster,name
RemoteClusterService -> public Client getRemoteClusterClient(ThreadPool threadPool, String clusterAlias);1524684173;Returns a client to the remote cluster if the given cluster alias exists._@param threadPool the {@link ThreadPool} for the client_@param clusterAlias the cluster alias the remote cluster is registered under__@throws IllegalArgumentException if the given clusterAlias doesn't exist;public Client getRemoteClusterClient(ThreadPool threadPool, String clusterAlias) {_        if (transportService.getRemoteClusterService().getRemoteClusterNames().contains(clusterAlias) == false) {_            throw new IllegalArgumentException("unknown cluster alias [" + clusterAlias + "]")__        }_        return new RemoteClusterAwareClient(settings, threadPool, transportService, clusterAlias)__    };returns,a,client,to,the,remote,cluster,if,the,given,cluster,alias,exists,param,thread,pool,the,link,thread,pool,for,the,client,param,cluster,alias,the,cluster,alias,the,remote,cluster,is,registered,under,throws,illegal,argument,exception,if,the,given,cluster,alias,doesn,t,exist;public,client,get,remote,cluster,client,thread,pool,thread,pool,string,cluster,alias,if,transport,service,get,remote,cluster,service,get,remote,cluster,names,contains,cluster,alias,false,throw,new,illegal,argument,exception,unknown,cluster,alias,cluster,alias,return,new,remote,cluster,aware,client,settings,thread,pool,transport,service,cluster,alias
RemoteClusterService -> public Client getRemoteClusterClient(ThreadPool threadPool, String clusterAlias);1525076988;Returns a client to the remote cluster if the given cluster alias exists._@param threadPool the {@link ThreadPool} for the client_@param clusterAlias the cluster alias the remote cluster is registered under__@throws IllegalArgumentException if the given clusterAlias doesn't exist;public Client getRemoteClusterClient(ThreadPool threadPool, String clusterAlias) {_        if (transportService.getRemoteClusterService().getRemoteClusterNames().contains(clusterAlias) == false) {_            throw new IllegalArgumentException("unknown cluster alias [" + clusterAlias + "]")__        }_        return new RemoteClusterAwareClient(settings, threadPool, transportService, clusterAlias)__    };returns,a,client,to,the,remote,cluster,if,the,given,cluster,alias,exists,param,thread,pool,the,link,thread,pool,for,the,client,param,cluster,alias,the,cluster,alias,the,remote,cluster,is,registered,under,throws,illegal,argument,exception,if,the,given,cluster,alias,doesn,t,exist;public,client,get,remote,cluster,client,thread,pool,thread,pool,string,cluster,alias,if,transport,service,get,remote,cluster,service,get,remote,cluster,names,contains,cluster,alias,false,throw,new,illegal,argument,exception,unknown,cluster,alias,cluster,alias,return,new,remote,cluster,aware,client,settings,thread,pool,transport,service,cluster,alias
RemoteClusterService -> public Client getRemoteClusterClient(ThreadPool threadPool, String clusterAlias);1525334055;Returns a client to the remote cluster if the given cluster alias exists._@param threadPool the {@link ThreadPool} for the client_@param clusterAlias the cluster alias the remote cluster is registered under__@throws IllegalArgumentException if the given clusterAlias doesn't exist;public Client getRemoteClusterClient(ThreadPool threadPool, String clusterAlias) {_        if (transportService.getRemoteClusterService().getRemoteClusterNames().contains(clusterAlias) == false) {_            throw new IllegalArgumentException("unknown cluster alias [" + clusterAlias + "]")__        }_        return new RemoteClusterAwareClient(settings, threadPool, transportService, clusterAlias)__    };returns,a,client,to,the,remote,cluster,if,the,given,cluster,alias,exists,param,thread,pool,the,link,thread,pool,for,the,client,param,cluster,alias,the,cluster,alias,the,remote,cluster,is,registered,under,throws,illegal,argument,exception,if,the,given,cluster,alias,doesn,t,exist;public,client,get,remote,cluster,client,thread,pool,thread,pool,string,cluster,alias,if,transport,service,get,remote,cluster,service,get,remote,cluster,names,contains,cluster,alias,false,throw,new,illegal,argument,exception,unknown,cluster,alias,cluster,alias,return,new,remote,cluster,aware,client,settings,thread,pool,transport,service,cluster,alias
RemoteClusterService -> public Client getRemoteClusterClient(ThreadPool threadPool, String clusterAlias);1527773340;Returns a client to the remote cluster if the given cluster alias exists._@param threadPool the {@link ThreadPool} for the client_@param clusterAlias the cluster alias the remote cluster is registered under__@throws IllegalArgumentException if the given clusterAlias doesn't exist;public Client getRemoteClusterClient(ThreadPool threadPool, String clusterAlias) {_        if (transportService.getRemoteClusterService().getRemoteClusterNames().contains(clusterAlias) == false) {_            throw new IllegalArgumentException("unknown cluster alias [" + clusterAlias + "]")__        }_        return new RemoteClusterAwareClient(settings, threadPool, transportService, clusterAlias)__    };returns,a,client,to,the,remote,cluster,if,the,given,cluster,alias,exists,param,thread,pool,the,link,thread,pool,for,the,client,param,cluster,alias,the,cluster,alias,the,remote,cluster,is,registered,under,throws,illegal,argument,exception,if,the,given,cluster,alias,doesn,t,exist;public,client,get,remote,cluster,client,thread,pool,thread,pool,string,cluster,alias,if,transport,service,get,remote,cluster,service,get,remote,cluster,names,contains,cluster,alias,false,throw,new,illegal,argument,exception,unknown,cluster,alias,cluster,alias,return,new,remote,cluster,aware,client,settings,thread,pool,transport,service,cluster,alias
RemoteClusterService -> public Client getRemoteClusterClient(ThreadPool threadPool, String clusterAlias);1527840262;Returns a client to the remote cluster if the given cluster alias exists._@param threadPool the {@link ThreadPool} for the client_@param clusterAlias the cluster alias the remote cluster is registered under__@throws IllegalArgumentException if the given clusterAlias doesn't exist;public Client getRemoteClusterClient(ThreadPool threadPool, String clusterAlias) {_        if (transportService.getRemoteClusterService().getRemoteClusterNames().contains(clusterAlias) == false) {_            throw new IllegalArgumentException("unknown cluster alias [" + clusterAlias + "]")__        }_        return new RemoteClusterAwareClient(settings, threadPool, transportService, clusterAlias)__    };returns,a,client,to,the,remote,cluster,if,the,given,cluster,alias,exists,param,thread,pool,the,link,thread,pool,for,the,client,param,cluster,alias,the,cluster,alias,the,remote,cluster,is,registered,under,throws,illegal,argument,exception,if,the,given,cluster,alias,doesn,t,exist;public,client,get,remote,cluster,client,thread,pool,thread,pool,string,cluster,alias,if,transport,service,get,remote,cluster,service,get,remote,cluster,names,contains,cluster,alias,false,throw,new,illegal,argument,exception,unknown,cluster,alias,cluster,alias,return,new,remote,cluster,aware,client,settings,thread,pool,transport,service,cluster,alias
RemoteClusterService -> public Client getRemoteClusterClient(ThreadPool threadPool, String clusterAlias);1534755962;Returns a client to the remote cluster if the given cluster alias exists._@param threadPool the {@link ThreadPool} for the client_@param clusterAlias the cluster alias the remote cluster is registered under__@throws IllegalArgumentException if the given clusterAlias doesn't exist;public Client getRemoteClusterClient(ThreadPool threadPool, String clusterAlias) {_        if (transportService.getRemoteClusterService().getRemoteClusterNames().contains(clusterAlias) == false) {_            throw new IllegalArgumentException("unknown cluster alias [" + clusterAlias + "]")__        }_        return new RemoteClusterAwareClient(settings, threadPool, transportService, clusterAlias)__    };returns,a,client,to,the,remote,cluster,if,the,given,cluster,alias,exists,param,thread,pool,the,link,thread,pool,for,the,client,param,cluster,alias,the,cluster,alias,the,remote,cluster,is,registered,under,throws,illegal,argument,exception,if,the,given,cluster,alias,doesn,t,exist;public,client,get,remote,cluster,client,thread,pool,thread,pool,string,cluster,alias,if,transport,service,get,remote,cluster,service,get,remote,cluster,names,contains,cluster,alias,false,throw,new,illegal,argument,exception,unknown,cluster,alias,cluster,alias,return,new,remote,cluster,aware,client,settings,thread,pool,transport,service,cluster,alias
RemoteClusterService -> public Client getRemoteClusterClient(ThreadPool threadPool, String clusterAlias);1535046779;Returns a client to the remote cluster if the given cluster alias exists._@param threadPool the {@link ThreadPool} for the client_@param clusterAlias the cluster alias the remote cluster is registered under__@throws IllegalArgumentException if the given clusterAlias doesn't exist;public Client getRemoteClusterClient(ThreadPool threadPool, String clusterAlias) {_        if (transportService.getRemoteClusterService().getRemoteClusterNames().contains(clusterAlias) == false) {_            throw new IllegalArgumentException("unknown cluster alias [" + clusterAlias + "]")__        }_        return new RemoteClusterAwareClient(settings, threadPool, transportService, clusterAlias)__    };returns,a,client,to,the,remote,cluster,if,the,given,cluster,alias,exists,param,thread,pool,the,link,thread,pool,for,the,client,param,cluster,alias,the,cluster,alias,the,remote,cluster,is,registered,under,throws,illegal,argument,exception,if,the,given,cluster,alias,doesn,t,exist;public,client,get,remote,cluster,client,thread,pool,thread,pool,string,cluster,alias,if,transport,service,get,remote,cluster,service,get,remote,cluster,names,contains,cluster,alias,false,throw,new,illegal,argument,exception,unknown,cluster,alias,cluster,alias,return,new,remote,cluster,aware,client,settings,thread,pool,transport,service,cluster,alias
RemoteClusterService -> public Client getRemoteClusterClient(ThreadPool threadPool, String clusterAlias);1535383145;Returns a client to the remote cluster if the given cluster alias exists._@param threadPool the {@link ThreadPool} for the client_@param clusterAlias the cluster alias the remote cluster is registered under__@throws IllegalArgumentException if the given clusterAlias doesn't exist;public Client getRemoteClusterClient(ThreadPool threadPool, String clusterAlias) {_        if (transportService.getRemoteClusterService().getRemoteClusterNames().contains(clusterAlias) == false) {_            throw new IllegalArgumentException("unknown cluster alias [" + clusterAlias + "]")__        }_        return new RemoteClusterAwareClient(settings, threadPool, transportService, clusterAlias)__    };returns,a,client,to,the,remote,cluster,if,the,given,cluster,alias,exists,param,thread,pool,the,link,thread,pool,for,the,client,param,cluster,alias,the,cluster,alias,the,remote,cluster,is,registered,under,throws,illegal,argument,exception,if,the,given,cluster,alias,doesn,t,exist;public,client,get,remote,cluster,client,thread,pool,thread,pool,string,cluster,alias,if,transport,service,get,remote,cluster,service,get,remote,cluster,names,contains,cluster,alias,false,throw,new,illegal,argument,exception,unknown,cluster,alias,cluster,alias,return,new,remote,cluster,aware,client,settings,thread,pool,transport,service,cluster,alias
RemoteClusterService -> public Client getRemoteClusterClient(ThreadPool threadPool, String clusterAlias);1536218260;Returns a client to the remote cluster if the given cluster alias exists._@param threadPool the {@link ThreadPool} for the client_@param clusterAlias the cluster alias the remote cluster is registered under__@throws IllegalArgumentException if the given clusterAlias doesn't exist;public Client getRemoteClusterClient(ThreadPool threadPool, String clusterAlias) {_        if (transportService.getRemoteClusterService().getRemoteClusterNames().contains(clusterAlias) == false) {_            throw new IllegalArgumentException("unknown cluster alias [" + clusterAlias + "]")__        }_        return new RemoteClusterAwareClient(settings, threadPool, transportService, clusterAlias)__    };returns,a,client,to,the,remote,cluster,if,the,given,cluster,alias,exists,param,thread,pool,the,link,thread,pool,for,the,client,param,cluster,alias,the,cluster,alias,the,remote,cluster,is,registered,under,throws,illegal,argument,exception,if,the,given,cluster,alias,doesn,t,exist;public,client,get,remote,cluster,client,thread,pool,thread,pool,string,cluster,alias,if,transport,service,get,remote,cluster,service,get,remote,cluster,names,contains,cluster,alias,false,throw,new,illegal,argument,exception,unknown,cluster,alias,cluster,alias,return,new,remote,cluster,aware,client,settings,thread,pool,transport,service,cluster,alias
RemoteClusterService -> public Client getRemoteClusterClient(ThreadPool threadPool, String clusterAlias);1536828374;Returns a client to the remote cluster if the given cluster alias exists._@param threadPool the {@link ThreadPool} for the client_@param clusterAlias the cluster alias the remote cluster is registered under__@throws IllegalArgumentException if the given clusterAlias doesn't exist;public Client getRemoteClusterClient(ThreadPool threadPool, String clusterAlias) {_        if (transportService.getRemoteClusterService().getRemoteClusterNames().contains(clusterAlias) == false) {_            throw new IllegalArgumentException("unknown cluster alias [" + clusterAlias + "]")__        }_        return new RemoteClusterAwareClient(settings, threadPool, transportService, clusterAlias)__    };returns,a,client,to,the,remote,cluster,if,the,given,cluster,alias,exists,param,thread,pool,the,link,thread,pool,for,the,client,param,cluster,alias,the,cluster,alias,the,remote,cluster,is,registered,under,throws,illegal,argument,exception,if,the,given,cluster,alias,doesn,t,exist;public,client,get,remote,cluster,client,thread,pool,thread,pool,string,cluster,alias,if,transport,service,get,remote,cluster,service,get,remote,cluster,names,contains,cluster,alias,false,throw,new,illegal,argument,exception,unknown,cluster,alias,cluster,alias,return,new,remote,cluster,aware,client,settings,thread,pool,transport,service,cluster,alias
RemoteClusterService -> public Client getRemoteClusterClient(ThreadPool threadPool, String clusterAlias);1537806831;Returns a client to the remote cluster if the given cluster alias exists._@param threadPool the {@link ThreadPool} for the client_@param clusterAlias the cluster alias the remote cluster is registered under__@throws IllegalArgumentException if the given clusterAlias doesn't exist;public Client getRemoteClusterClient(ThreadPool threadPool, String clusterAlias) {_        if (transportService.getRemoteClusterService().getRemoteClusterNames().contains(clusterAlias) == false) {_            throw new IllegalArgumentException("unknown cluster alias [" + clusterAlias + "]")__        }_        return new RemoteClusterAwareClient(settings, threadPool, transportService, clusterAlias)__    };returns,a,client,to,the,remote,cluster,if,the,given,cluster,alias,exists,param,thread,pool,the,link,thread,pool,for,the,client,param,cluster,alias,the,cluster,alias,the,remote,cluster,is,registered,under,throws,illegal,argument,exception,if,the,given,cluster,alias,doesn,t,exist;public,client,get,remote,cluster,client,thread,pool,thread,pool,string,cluster,alias,if,transport,service,get,remote,cluster,service,get,remote,cluster,names,contains,cluster,alias,false,throw,new,illegal,argument,exception,unknown,cluster,alias,cluster,alias,return,new,remote,cluster,aware,client,settings,thread,pool,transport,service,cluster,alias
RemoteClusterService -> public Client getRemoteClusterClient(ThreadPool threadPool, String clusterAlias);1541008027;Returns a client to the remote cluster if the given cluster alias exists._@param threadPool the {@link ThreadPool} for the client_@param clusterAlias the cluster alias the remote cluster is registered under__@throws IllegalArgumentException if the given clusterAlias doesn't exist;public Client getRemoteClusterClient(ThreadPool threadPool, String clusterAlias) {_        if (transportService.getRemoteClusterService().getRemoteClusterNames().contains(clusterAlias) == false) {_            throw new IllegalArgumentException("unknown cluster alias [" + clusterAlias + "]")__        }_        return new RemoteClusterAwareClient(settings, threadPool, transportService, clusterAlias)__    };returns,a,client,to,the,remote,cluster,if,the,given,cluster,alias,exists,param,thread,pool,the,link,thread,pool,for,the,client,param,cluster,alias,the,cluster,alias,the,remote,cluster,is,registered,under,throws,illegal,argument,exception,if,the,given,cluster,alias,doesn,t,exist;public,client,get,remote,cluster,client,thread,pool,thread,pool,string,cluster,alias,if,transport,service,get,remote,cluster,service,get,remote,cluster,names,contains,cluster,alias,false,throw,new,illegal,argument,exception,unknown,cluster,alias,cluster,alias,return,new,remote,cluster,aware,client,settings,thread,pool,transport,service,cluster,alias
RemoteClusterService -> public Client getRemoteClusterClient(ThreadPool threadPool, String clusterAlias);1541698679;Returns a client to the remote cluster if the given cluster alias exists._@param threadPool the {@link ThreadPool} for the client_@param clusterAlias the cluster alias the remote cluster is registered under__@throws IllegalArgumentException if the given clusterAlias doesn't exist;public Client getRemoteClusterClient(ThreadPool threadPool, String clusterAlias) {_        if (transportService.getRemoteClusterService().getRemoteClusterNames().contains(clusterAlias) == false) {_            throw new IllegalArgumentException("unknown cluster alias [" + clusterAlias + "]")__        }_        return new RemoteClusterAwareClient(settings, threadPool, transportService, clusterAlias)__    };returns,a,client,to,the,remote,cluster,if,the,given,cluster,alias,exists,param,thread,pool,the,link,thread,pool,for,the,client,param,cluster,alias,the,cluster,alias,the,remote,cluster,is,registered,under,throws,illegal,argument,exception,if,the,given,cluster,alias,doesn,t,exist;public,client,get,remote,cluster,client,thread,pool,thread,pool,string,cluster,alias,if,transport,service,get,remote,cluster,service,get,remote,cluster,names,contains,cluster,alias,false,throw,new,illegal,argument,exception,unknown,cluster,alias,cluster,alias,return,new,remote,cluster,aware,client,settings,thread,pool,transport,service,cluster,alias
RemoteClusterService -> public Client getRemoteClusterClient(ThreadPool threadPool, String clusterAlias);1542402632;Returns a client to the remote cluster if the given cluster alias exists._@param threadPool the {@link ThreadPool} for the client_@param clusterAlias the cluster alias the remote cluster is registered under__@throws IllegalArgumentException if the given clusterAlias doesn't exist;public Client getRemoteClusterClient(ThreadPool threadPool, String clusterAlias) {_        if (transportService.getRemoteClusterService().getRemoteClusterNames().contains(clusterAlias) == false) {_            throw new IllegalArgumentException("unknown cluster alias [" + clusterAlias + "]")__        }_        return new RemoteClusterAwareClient(settings, threadPool, transportService, clusterAlias)__    };returns,a,client,to,the,remote,cluster,if,the,given,cluster,alias,exists,param,thread,pool,the,link,thread,pool,for,the,client,param,cluster,alias,the,cluster,alias,the,remote,cluster,is,registered,under,throws,illegal,argument,exception,if,the,given,cluster,alias,doesn,t,exist;public,client,get,remote,cluster,client,thread,pool,thread,pool,string,cluster,alias,if,transport,service,get,remote,cluster,service,get,remote,cluster,names,contains,cluster,alias,false,throw,new,illegal,argument,exception,unknown,cluster,alias,cluster,alias,return,new,remote,cluster,aware,client,settings,thread,pool,transport,service,cluster,alias
RemoteClusterService -> public Client getRemoteClusterClient(ThreadPool threadPool, String clusterAlias);1543506953;Returns a client to the remote cluster if the given cluster alias exists._@param threadPool the {@link ThreadPool} for the client_@param clusterAlias the cluster alias the remote cluster is registered under__@throws IllegalArgumentException if the given clusterAlias doesn't exist;public Client getRemoteClusterClient(ThreadPool threadPool, String clusterAlias) {_        if (transportService.getRemoteClusterService().getRemoteClusterNames().contains(clusterAlias) == false) {_            throw new IllegalArgumentException("unknown cluster alias [" + clusterAlias + "]")__        }_        return new RemoteClusterAwareClient(settings, threadPool, transportService, clusterAlias)__    };returns,a,client,to,the,remote,cluster,if,the,given,cluster,alias,exists,param,thread,pool,the,link,thread,pool,for,the,client,param,cluster,alias,the,cluster,alias,the,remote,cluster,is,registered,under,throws,illegal,argument,exception,if,the,given,cluster,alias,doesn,t,exist;public,client,get,remote,cluster,client,thread,pool,thread,pool,string,cluster,alias,if,transport,service,get,remote,cluster,service,get,remote,cluster,names,contains,cluster,alias,false,throw,new,illegal,argument,exception,unknown,cluster,alias,cluster,alias,return,new,remote,cluster,aware,client,settings,thread,pool,transport,service,cluster,alias
RemoteClusterService -> public Client getRemoteClusterClient(ThreadPool threadPool, String clusterAlias);1543959410;Returns a client to the remote cluster if the given cluster alias exists._@param threadPool the {@link ThreadPool} for the client_@param clusterAlias the cluster alias the remote cluster is registered under__@throws IllegalArgumentException if the given clusterAlias doesn't exist;public Client getRemoteClusterClient(ThreadPool threadPool, String clusterAlias) {_        if (transportService.getRemoteClusterService().getRemoteClusterNames().contains(clusterAlias) == false) {_            throw new IllegalArgumentException("unknown cluster alias [" + clusterAlias + "]")__        }_        return new RemoteClusterAwareClient(settings, threadPool, transportService, clusterAlias)__    };returns,a,client,to,the,remote,cluster,if,the,given,cluster,alias,exists,param,thread,pool,the,link,thread,pool,for,the,client,param,cluster,alias,the,cluster,alias,the,remote,cluster,is,registered,under,throws,illegal,argument,exception,if,the,given,cluster,alias,doesn,t,exist;public,client,get,remote,cluster,client,thread,pool,thread,pool,string,cluster,alias,if,transport,service,get,remote,cluster,service,get,remote,cluster,names,contains,cluster,alias,false,throw,new,illegal,argument,exception,unknown,cluster,alias,cluster,alias,return,new,remote,cluster,aware,client,settings,thread,pool,transport,service,cluster,alias
RemoteClusterService -> public Client getRemoteClusterClient(ThreadPool threadPool, String clusterAlias);1544823664;Returns a client to the remote cluster if the given cluster alias exists._@param threadPool the {@link ThreadPool} for the client_@param clusterAlias the cluster alias the remote cluster is registered under__@throws IllegalArgumentException if the given clusterAlias doesn't exist;public Client getRemoteClusterClient(ThreadPool threadPool, String clusterAlias) {_        if (transportService.getRemoteClusterService().getRemoteClusterNames().contains(clusterAlias) == false) {_            throw new IllegalArgumentException("unknown cluster alias [" + clusterAlias + "]")__        }_        return new RemoteClusterAwareClient(settings, threadPool, transportService, clusterAlias)__    };returns,a,client,to,the,remote,cluster,if,the,given,cluster,alias,exists,param,thread,pool,the,link,thread,pool,for,the,client,param,cluster,alias,the,cluster,alias,the,remote,cluster,is,registered,under,throws,illegal,argument,exception,if,the,given,cluster,alias,doesn,t,exist;public,client,get,remote,cluster,client,thread,pool,thread,pool,string,cluster,alias,if,transport,service,get,remote,cluster,service,get,remote,cluster,names,contains,cluster,alias,false,throw,new,illegal,argument,exception,unknown,cluster,alias,cluster,alias,return,new,remote,cluster,aware,client,settings,thread,pool,transport,service,cluster,alias
RemoteClusterService -> public Client getRemoteClusterClient(ThreadPool threadPool, String clusterAlias);1545071071;Returns a client to the remote cluster if the given cluster alias exists._@param threadPool the {@link ThreadPool} for the client_@param clusterAlias the cluster alias the remote cluster is registered under__@throws IllegalArgumentException if the given clusterAlias doesn't exist;public Client getRemoteClusterClient(ThreadPool threadPool, String clusterAlias) {_        if (transportService.getRemoteClusterService().getRemoteClusterNames().contains(clusterAlias) == false) {_            throw new IllegalArgumentException("unknown cluster alias [" + clusterAlias + "]")__        }_        return new RemoteClusterAwareClient(settings, threadPool, transportService, clusterAlias)__    };returns,a,client,to,the,remote,cluster,if,the,given,cluster,alias,exists,param,thread,pool,the,link,thread,pool,for,the,client,param,cluster,alias,the,cluster,alias,the,remote,cluster,is,registered,under,throws,illegal,argument,exception,if,the,given,cluster,alias,doesn,t,exist;public,client,get,remote,cluster,client,thread,pool,thread,pool,string,cluster,alias,if,transport,service,get,remote,cluster,service,get,remote,cluster,names,contains,cluster,alias,false,throw,new,illegal,argument,exception,unknown,cluster,alias,cluster,alias,return,new,remote,cluster,aware,client,settings,thread,pool,transport,service,cluster,alias
RemoteClusterService -> public Client getRemoteClusterClient(ThreadPool threadPool, String clusterAlias);1546929322;Returns a client to the remote cluster if the given cluster alias exists._@param threadPool the {@link ThreadPool} for the client_@param clusterAlias the cluster alias the remote cluster is registered under__@throws IllegalArgumentException if the given clusterAlias doesn't exist;public Client getRemoteClusterClient(ThreadPool threadPool, String clusterAlias) {_        if (transportService.getRemoteClusterService().getRemoteClusterNames().contains(clusterAlias) == false) {_            throw new IllegalArgumentException("unknown cluster alias [" + clusterAlias + "]")__        }_        return new RemoteClusterAwareClient(settings, threadPool, transportService, clusterAlias)__    };returns,a,client,to,the,remote,cluster,if,the,given,cluster,alias,exists,param,thread,pool,the,link,thread,pool,for,the,client,param,cluster,alias,the,cluster,alias,the,remote,cluster,is,registered,under,throws,illegal,argument,exception,if,the,given,cluster,alias,doesn,t,exist;public,client,get,remote,cluster,client,thread,pool,thread,pool,string,cluster,alias,if,transport,service,get,remote,cluster,service,get,remote,cluster,names,contains,cluster,alias,false,throw,new,illegal,argument,exception,unknown,cluster,alias,cluster,alias,return,new,remote,cluster,aware,client,settings,thread,pool,transport,service,cluster,alias
RemoteClusterService -> public Client getRemoteClusterClient(ThreadPool threadPool, String clusterAlias);1547561945;Returns a client to the remote cluster if the given cluster alias exists._@param threadPool the {@link ThreadPool} for the client_@param clusterAlias the cluster alias the remote cluster is registered under__@throws IllegalArgumentException if the given clusterAlias doesn't exist;public Client getRemoteClusterClient(ThreadPool threadPool, String clusterAlias) {_        if (transportService.getRemoteClusterService().getRemoteClusterNames().contains(clusterAlias) == false) {_            throw new IllegalArgumentException("unknown cluster alias [" + clusterAlias + "]")__        }_        return new RemoteClusterAwareClient(settings, threadPool, transportService, clusterAlias)__    };returns,a,client,to,the,remote,cluster,if,the,given,cluster,alias,exists,param,thread,pool,the,link,thread,pool,for,the,client,param,cluster,alias,the,cluster,alias,the,remote,cluster,is,registered,under,throws,illegal,argument,exception,if,the,given,cluster,alias,doesn,t,exist;public,client,get,remote,cluster,client,thread,pool,thread,pool,string,cluster,alias,if,transport,service,get,remote,cluster,service,get,remote,cluster,names,contains,cluster,alias,false,throw,new,illegal,argument,exception,unknown,cluster,alias,cluster,alias,return,new,remote,cluster,aware,client,settings,thread,pool,transport,service,cluster,alias
RemoteClusterService -> public Client getRemoteClusterClient(ThreadPool threadPool, String clusterAlias);1548248017;Returns a client to the remote cluster if the given cluster alias exists._@param threadPool the {@link ThreadPool} for the client_@param clusterAlias the cluster alias the remote cluster is registered under__@throws IllegalArgumentException if the given clusterAlias doesn't exist;public Client getRemoteClusterClient(ThreadPool threadPool, String clusterAlias) {_        if (transportService.getRemoteClusterService().getRemoteClusterNames().contains(clusterAlias) == false) {_            throw new IllegalArgumentException("unknown cluster alias [" + clusterAlias + "]")__        }_        return new RemoteClusterAwareClient(settings, threadPool, transportService, clusterAlias)__    };returns,a,client,to,the,remote,cluster,if,the,given,cluster,alias,exists,param,thread,pool,the,link,thread,pool,for,the,client,param,cluster,alias,the,cluster,alias,the,remote,cluster,is,registered,under,throws,illegal,argument,exception,if,the,given,cluster,alias,doesn,t,exist;public,client,get,remote,cluster,client,thread,pool,thread,pool,string,cluster,alias,if,transport,service,get,remote,cluster,service,get,remote,cluster,names,contains,cluster,alias,false,throw,new,illegal,argument,exception,unknown,cluster,alias,cluster,alias,return,new,remote,cluster,aware,client,settings,thread,pool,transport,service,cluster,alias
RemoteClusterService -> public Client getRemoteClusterClient(ThreadPool threadPool, String clusterAlias);1548402798;Returns a client to the remote cluster if the given cluster alias exists._@param threadPool the {@link ThreadPool} for the client_@param clusterAlias the cluster alias the remote cluster is registered under__@throws IllegalArgumentException if the given clusterAlias doesn't exist;public Client getRemoteClusterClient(ThreadPool threadPool, String clusterAlias) {_        if (transportService.getRemoteClusterService().getRemoteClusterNames().contains(clusterAlias) == false) {_            throw new NoSuchRemoteClusterException(clusterAlias)__        }_        return new RemoteClusterAwareClient(settings, threadPool, transportService, clusterAlias)__    };returns,a,client,to,the,remote,cluster,if,the,given,cluster,alias,exists,param,thread,pool,the,link,thread,pool,for,the,client,param,cluster,alias,the,cluster,alias,the,remote,cluster,is,registered,under,throws,illegal,argument,exception,if,the,given,cluster,alias,doesn,t,exist;public,client,get,remote,cluster,client,thread,pool,thread,pool,string,cluster,alias,if,transport,service,get,remote,cluster,service,get,remote,cluster,names,contains,cluster,alias,false,throw,new,no,such,remote,cluster,exception,cluster,alias,return,new,remote,cluster,aware,client,settings,thread,pool,transport,service,cluster,alias
RemoteClusterService -> public Client getRemoteClusterClient(ThreadPool threadPool, String clusterAlias);1549608646;Returns a client to the remote cluster if the given cluster alias exists._@param threadPool the {@link ThreadPool} for the client_@param clusterAlias the cluster alias the remote cluster is registered under__@throws IllegalArgumentException if the given clusterAlias doesn't exist;public Client getRemoteClusterClient(ThreadPool threadPool, String clusterAlias) {_        if (transportService.getRemoteClusterService().getRemoteClusterNames().contains(clusterAlias) == false) {_            throw new NoSuchRemoteClusterException(clusterAlias)__        }_        return new RemoteClusterAwareClient(settings, threadPool, transportService, clusterAlias)__    };returns,a,client,to,the,remote,cluster,if,the,given,cluster,alias,exists,param,thread,pool,the,link,thread,pool,for,the,client,param,cluster,alias,the,cluster,alias,the,remote,cluster,is,registered,under,throws,illegal,argument,exception,if,the,given,cluster,alias,doesn,t,exist;public,client,get,remote,cluster,client,thread,pool,thread,pool,string,cluster,alias,if,transport,service,get,remote,cluster,service,get,remote,cluster,names,contains,cluster,alias,false,throw,new,no,such,remote,cluster,exception,cluster,alias,return,new,remote,cluster,aware,client,settings,thread,pool,transport,service,cluster,alias
RemoteClusterService -> public Client getRemoteClusterClient(ThreadPool threadPool, String clusterAlias);1550601141;Returns a client to the remote cluster if the given cluster alias exists._@param threadPool the {@link ThreadPool} for the client_@param clusterAlias the cluster alias the remote cluster is registered under__@throws IllegalArgumentException if the given clusterAlias doesn't exist;public Client getRemoteClusterClient(ThreadPool threadPool, String clusterAlias) {_        if (transportService.getRemoteClusterService().getRemoteClusterNames().contains(clusterAlias) == false) {_            throw new NoSuchRemoteClusterException(clusterAlias)__        }_        return new RemoteClusterAwareClient(settings, threadPool, transportService, clusterAlias)__    };returns,a,client,to,the,remote,cluster,if,the,given,cluster,alias,exists,param,thread,pool,the,link,thread,pool,for,the,client,param,cluster,alias,the,cluster,alias,the,remote,cluster,is,registered,under,throws,illegal,argument,exception,if,the,given,cluster,alias,doesn,t,exist;public,client,get,remote,cluster,client,thread,pool,thread,pool,string,cluster,alias,if,transport,service,get,remote,cluster,service,get,remote,cluster,names,contains,cluster,alias,false,throw,new,no,such,remote,cluster,exception,cluster,alias,return,new,remote,cluster,aware,client,settings,thread,pool,transport,service,cluster,alias
