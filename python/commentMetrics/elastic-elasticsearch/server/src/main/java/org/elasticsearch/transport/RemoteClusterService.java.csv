commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public Setting<Boolean> getSetting() {     return SEARCH_REMOTE_CLUSTER_SKIP_UNAVAILABLE. }
false;public;1;4;;@Override public String getKey(final String key) {     return key.replaceFirst("^search", "cluster"). }
true;private,synchronized;2;65;/**  * This method updates the list of remote clusters. It's intended to be used as an update consumer on the settings infrastructure  * @param seeds a cluster alias to discovery node mapping representing the remote clusters seeds nodes  * @param connectionListener a listener invoked once every configured cluster has been connected to  */ ;/**  * This method updates the list of remote clusters. It's intended to be used as an update consumer on the settings infrastructure  * @param seeds a cluster alias to discovery node mapping representing the remote clusters seeds nodes  * @param connectionListener a listener invoked once every configured cluster has been connected to  */ private synchronized void updateRemoteClusters(Map<String, Tuple<String, List<Tuple<String, Supplier<DiscoveryNode>>>>> seeds, ActionListener<Void> connectionListener) {     if (seeds.containsKey(LOCAL_CLUSTER_GROUP_KEY)) {         throw new IllegalArgumentException("remote clusters must not have the empty string as its key").     }     Map<String, RemoteClusterConnection> remoteClusters = new HashMap<>().     if (seeds.isEmpty()) {         connectionListener.onResponse(null).     } else {         CountDown countDown = new CountDown(seeds.size()).         remoteClusters.putAll(this.remoteClusters).         for (Map.Entry<String, Tuple<String, List<Tuple<String, Supplier<DiscoveryNode>>>>> entry : seeds.entrySet()) {             List<Tuple<String, Supplier<DiscoveryNode>>> seedList = entry.getValue().v2().             String proxyAddress = entry.getValue().v1().             String clusterAlias = entry.getKey().             RemoteClusterConnection remote = this.remoteClusters.get(clusterAlias).             ConnectionProfile connectionProfile = this.remoteClusterConnectionProfiles.get(clusterAlias).             if (seedList.isEmpty()) {                 // with no seed nodes we just remove the connection                 try {                     IOUtils.close(remote).                 } catch (IOException e) {                     logger.warn("failed to close remote cluster connections for cluster: " + clusterAlias, e).                 }                 remoteClusters.remove(clusterAlias).                 continue.             }             if (remote == null) {                 // this is a new cluster we have to add a new representation                 remote = new RemoteClusterConnection(settings, clusterAlias, seedList, transportService, numRemoteConnections, getNodePredicate(settings), proxyAddress, connectionProfile).                 remoteClusters.put(clusterAlias, remote).             } else if (connectionProfileChanged(remote.getConnectionManager().getConnectionProfile(), connectionProfile)) {                 // New ConnectionProfile. Must tear down existing connection                 try {                     IOUtils.close(remote).                 } catch (IOException e) {                     logger.warn("failed to close remote cluster connections for cluster: " + clusterAlias, e).                 }                 remoteClusters.remove(clusterAlias).                 remote = new RemoteClusterConnection(settings, clusterAlias, seedList, transportService, numRemoteConnections, getNodePredicate(settings), proxyAddress, connectionProfile).                 remoteClusters.put(clusterAlias, remote).             }             // now update the seed nodes no matter if it's new or already existing             RemoteClusterConnection finalRemote = remote.             remote.updateSeedNodes(proxyAddress, seedList, ActionListener.wrap(response -> {                 if (countDown.countDown()) {                     connectionListener.onResponse(response).                 }             }, exception -> {                 if (countDown.fastForward()) {                     connectionListener.onFailure(exception).                 }                 if (finalRemote.isClosed() == false) {                     logger.warn("failed to update seed list for cluster: " + clusterAlias, exception).                 }             })).         }     }     this.remoteClusters = Collections.unmodifiableMap(remoteClusters). }
false;static;1;8;;static Predicate<DiscoveryNode> getNodePredicate(Settings settings) {     if (REMOTE_NODE_ATTRIBUTE.exists(settings)) {         // nodes can be tagged with node.attr.remote_gateway: true to allow a node to be a gateway node for cross cluster search         String attribute = REMOTE_NODE_ATTRIBUTE.get(settings).         return DEFAULT_NODE_PREDICATE.and((node) -> Booleans.parseBoolean(node.getAttributes().getOrDefault(attribute, "false"))).     }     return DEFAULT_NODE_PREDICATE. }
true;public;0;3;/**  * Returns <code>true</code> if at least one remote cluster is configured  */ ;/**  * Returns <code>true</code> if at least one remote cluster is configured  */ public boolean isCrossClusterSearchEnabled() {     return remoteClusters.isEmpty() == false. }
false;;2;3;;boolean isRemoteNodeConnected(final String remoteCluster, final DiscoveryNode node) {     return remoteClusters.get(remoteCluster).isNodeConnected(node). }
false;public;3;20;;public Map<String, OriginalIndices> groupIndices(IndicesOptions indicesOptions, String[] indices, Predicate<String> indexExists) {     Map<String, OriginalIndices> originalIndicesMap = new HashMap<>().     if (isCrossClusterSearchEnabled()) {         final Map<String, List<String>> groupedIndices = groupClusterIndices(getRemoteClusterNames(), indices, indexExists).         if (groupedIndices.isEmpty()) {             // search on _all in the local cluster if neither local indices nor remote indices were specified             originalIndicesMap.put(LOCAL_CLUSTER_GROUP_KEY, new OriginalIndices(Strings.EMPTY_ARRAY, indicesOptions)).         } else {             for (Map.Entry<String, List<String>> entry : groupedIndices.entrySet()) {                 String clusterAlias = entry.getKey().                 List<String> originalIndices = entry.getValue().                 originalIndicesMap.put(clusterAlias, new OriginalIndices(originalIndices.toArray(new String[0]), indicesOptions)).             }         }     } else {         originalIndicesMap.put(LOCAL_CLUSTER_GROUP_KEY, new OriginalIndices(indices, indicesOptions)).     }     return originalIndicesMap. }
true;;1;3;/**  * Returns <code>true</code> iff the given cluster is configured as a remote cluster. Otherwise <code>false</code>  */ ;/**  * Returns <code>true</code> iff the given cluster is configured as a remote cluster. Otherwise <code>false</code>  */ boolean isRemoteClusterRegistered(String clusterName) {     return remoteClusters.containsKey(clusterName). }
true;public;0;4;/**  * Returns the registered remote cluster names.  */ ;/**  * Returns the registered remote cluster names.  */ public Set<String> getRegisteredRemoteClusterNames() {     // remoteClusters is unmodifiable so its key set will be unmodifiable too     return remoteClusters.keySet(). }
true;public;2;3;/**  * Returns a connection to the given node on the given remote cluster  * @throws IllegalArgumentException if the remote cluster is unknown  */ ;/**  * Returns a connection to the given node on the given remote cluster  * @throws IllegalArgumentException if the remote cluster is unknown  */ public Transport.Connection getConnection(DiscoveryNode node, String cluster) {     return getRemoteClusterConnection(cluster).getConnection(node). }
true;;2;3;/**  * Ensures that the given cluster alias is connected. If the cluster is connected this operation  * will invoke the listener immediately.  */ ;/**  * Ensures that the given cluster alias is connected. If the cluster is connected this operation  * will invoke the listener immediately.  */ void ensureConnected(String clusterAlias, ActionListener<Void> listener) {     getRemoteClusterConnection(clusterAlias).ensureConnected(listener). }
true;public;1;3;/**  * Returns whether the cluster identified by the provided alias is configured to be skipped when unavailable  */ ;/**  * Returns whether the cluster identified by the provided alias is configured to be skipped when unavailable  */ public boolean isSkipUnavailable(String clusterAlias) {     return getRemoteClusterConnection(clusterAlias).isSkipUnavailable(). }
false;public;1;3;;public Transport.Connection getConnection(String cluster) {     return getRemoteClusterConnection(cluster).getConnection(). }
false;;1;7;;RemoteClusterConnection getRemoteClusterConnection(String cluster) {     RemoteClusterConnection connection = remoteClusters.get(cluster).     if (connection == null) {         throw new NoSuchRemoteClusterException(cluster).     }     return connection. }
false;;0;3;;Set<String> getRemoteClusterNames() {     return this.remoteClusters.keySet(). }
false;public;1;6;;@Override public void listenForUpdates(ClusterSettings clusterSettings) {     super.listenForUpdates(clusterSettings).     clusterSettings.addAffixUpdateConsumer(REMOTE_CLUSTER_SKIP_UNAVAILABLE, this::updateSkipUnavailable, (alias, value) -> {     }).     clusterSettings.addAffixUpdateConsumer(SEARCH_REMOTE_CLUSTER_SKIP_UNAVAILABLE, this::updateSkipUnavailable, (alias, value) -> {     }). }
false;private,synchronized;2;6;;private synchronized void updateSkipUnavailable(String clusterAlias, Boolean skipUnavailable) {     RemoteClusterConnection remote = this.remoteClusters.get(clusterAlias).     if (remote != null) {         remote.updateSkipUnavailable(skipUnavailable).     } }
false;protected;5;21;;@Override protected void updateRemoteCluster(String clusterAlias, List<String> addresses, String proxyAddress, boolean compressionEnabled, TimeValue pingSchedule) {     if (LOCAL_CLUSTER_GROUP_KEY.equals(clusterAlias)) {         throw new IllegalArgumentException("remote clusters must not have the empty string as its key").     }     ConnectionProfile oldProfile = remoteClusterConnectionProfiles.get(clusterAlias).     ConnectionProfile newProfile.     if (oldProfile != null) {         ConnectionProfile.Builder builder = new ConnectionProfile.Builder(oldProfile).         builder.setCompressionEnabled(compressionEnabled).         builder.setPingInterval(pingSchedule).         newProfile = builder.build().     } else {         ConnectionProfile.Builder builder = new ConnectionProfile.Builder(buildConnectionProfileFromSettings(clusterAlias)).         builder.setCompressionEnabled(compressionEnabled).         builder.setPingInterval(pingSchedule).         newProfile = builder.build().     }     updateRemoteCluster(clusterAlias, addresses, proxyAddress, newProfile, noopListener). }
false;;5;11;;void updateRemoteCluster(final String clusterAlias, final List<String> addresses, final String proxyAddress, final ConnectionProfile connectionProfile, final ActionListener<Void> connectionListener) {     HashMap<String, ConnectionProfile> connectionProfiles = new HashMap<>(remoteClusterConnectionProfiles).     connectionProfiles.put(clusterAlias, connectionProfile).     this.remoteClusterConnectionProfiles = Collections.unmodifiableMap(connectionProfiles).     final List<Tuple<String, Supplier<DiscoveryNode>>> nodes = addresses.stream().<Tuple<String, Supplier<DiscoveryNode>>>map(address -> Tuple.tuple(address, () -> buildSeedNode(clusterAlias, address, Strings.hasLength(proxyAddress)))).collect(Collectors.toList()).     updateRemoteClusters(Collections.singletonMap(clusterAlias, new Tuple<>(proxyAddress, nodes)), connectionListener). }
true;;0;17;/**  * Connects to all remote clusters in a blocking fashion. This should be called on node startup to establish an initial connection  * to all configured seed nodes.  */ ;/**  * Connects to all remote clusters in a blocking fashion. This should be called on node startup to establish an initial connection  * to all configured seed nodes.  */ void initializeRemoteClusters() {     final TimeValue timeValue = REMOTE_INITIAL_CONNECTION_TIMEOUT_SETTING.get(settings).     final PlainActionFuture<Void> future = new PlainActionFuture<>().     Map<String, Tuple<String, List<Tuple<String, Supplier<DiscoveryNode>>>>> seeds = RemoteClusterAware.buildRemoteClustersDynamicConfig(settings).     initializeConnectionProfiles(seeds.keySet()).     updateRemoteClusters(seeds, future).     try {         future.get(timeValue.millis(), TimeUnit.MILLISECONDS).     } catch (InterruptedException e) {         Thread.currentThread().interrupt().     } catch (TimeoutException ex) {         logger.warn("failed to connect to remote clusters within {}", timeValue.toString()).     } catch (Exception e) {         throw new IllegalStateException("failed to connect to remote clusters", e).     } }
false;private,synchronized;1;7;;private synchronized void initializeConnectionProfiles(Set<String> remoteClusters) {     Map<String, ConnectionProfile> connectionProfiles = new HashMap<>(remoteClusters.size()).     for (String clusterName : remoteClusters) {         connectionProfiles.put(clusterName, buildConnectionProfileFromSettings(clusterName)).     }     this.remoteClusterConnectionProfiles = Collections.unmodifiableMap(connectionProfiles). }
false;private;1;3;;private ConnectionProfile buildConnectionProfileFromSettings(String clusterName) {     return buildConnectionProfileFromSettings(settings, clusterName). }
false;static;2;13;;static ConnectionProfile buildConnectionProfileFromSettings(Settings settings, String clusterName) {     return new ConnectionProfile.Builder().setConnectTimeout(TransportSettings.CONNECT_TIMEOUT.get(settings)).setHandshakeTimeout(TransportSettings.CONNECT_TIMEOUT.get(settings)).addConnections(6, TransportRequestOptions.Type.REG, // TODO make this configurable?     TransportRequestOptions.Type.PING).addConnections(0, TransportRequestOptions.Type.BULK, TransportRequestOptions.Type.STATE, TransportRequestOptions.Type.RECOVERY).setCompressionEnabled(REMOTE_CLUSTER_COMPRESS.getConcreteSettingForNamespace(clusterName).get(settings)).setPingInterval(REMOTE_CLUSTER_PING_SCHEDULE.getConcreteSettingForNamespace(clusterName).get(settings)).build(). }
false;public;0;4;;@Override public void close() throws IOException {     IOUtils.close(remoteClusters.values()). }
false;public;0;3;;public Stream<RemoteConnectionInfo> getRemoteConnectionInfos() {     return remoteClusters.values().stream().map(RemoteClusterConnection::getConnectionInfo). }
false;private;2;4;;private boolean connectionProfileChanged(ConnectionProfile oldProfile, ConnectionProfile newProfile) {     return Objects.equals(oldProfile.getCompressionEnabled(), newProfile.getCompressionEnabled()) == false || Objects.equals(oldProfile.getPingInterval(), newProfile.getPingInterval()) == false. }
false;public;1;10;;@Override public void onResponse(Function<String, DiscoveryNode> nodeLookup) {     synchronized (clusterMap) {         clusterMap.put(cluster, nodeLookup).     }     if (countDown.countDown()) {         listener.onResponse((clusterAlias, nodeId) -> clusterMap.getOrDefault(clusterAlias, nullFunction).apply(nodeId)).     } }
false;public;1;6;;@Override public void onFailure(Exception e) {     if (countDown.fastForward()) {         // we need to check if it's true since we could have multiple failures         listener.onFailure(e).     } }
true;public;2;35;/**  * Collects all nodes of the given clusters and returns / passes a (clusterAlias, nodeId) to {@link DiscoveryNode}  * function on success.  */ ;/**  * Collects all nodes of the given clusters and returns / passes a (clusterAlias, nodeId) to {@link DiscoveryNode}  * function on success.  */ public void collectNodes(Set<String> clusters, ActionListener<BiFunction<String, String, DiscoveryNode>> listener) {     Map<String, RemoteClusterConnection> remoteClusters = this.remoteClusters.     for (String cluster : clusters) {         if (remoteClusters.containsKey(cluster) == false) {             listener.onFailure(new NoSuchRemoteClusterException(cluster)).             return.         }     }     final Map<String, Function<String, DiscoveryNode>> clusterMap = new HashMap<>().     CountDown countDown = new CountDown(clusters.size()).     Function<String, DiscoveryNode> nullFunction = s -> null.     for (final String cluster : clusters) {         RemoteClusterConnection connection = remoteClusters.get(cluster).         connection.collectNodes(new ActionListener<Function<String, DiscoveryNode>>() {              @Override             public void onResponse(Function<String, DiscoveryNode> nodeLookup) {                 synchronized (clusterMap) {                     clusterMap.put(cluster, nodeLookup).                 }                 if (countDown.countDown()) {                     listener.onResponse((clusterAlias, nodeId) -> clusterMap.getOrDefault(clusterAlias, nullFunction).apply(nodeId)).                 }             }              @Override             public void onFailure(Exception e) {                 if (countDown.fastForward()) {                     // we need to check if it's true since we could have multiple failures                     listener.onFailure(e).                 }             }         }).     } }
true;public;2;6;/**  * Returns a client to the remote cluster if the given cluster alias exists.  * @param threadPool the {@link ThreadPool} for the client  * @param clusterAlias the cluster alias the remote cluster is registered under  *  * @throws IllegalArgumentException if the given clusterAlias doesn't exist  */ ;/**  * Returns a client to the remote cluster if the given cluster alias exists.  * @param threadPool the {@link ThreadPool} for the client  * @param clusterAlias the cluster alias the remote cluster is registered under  *  * @throws IllegalArgumentException if the given clusterAlias doesn't exist  */ public Client getRemoteClusterClient(ThreadPool threadPool, String clusterAlias) {     if (transportService.getRemoteClusterService().getRemoteClusterNames().contains(clusterAlias) == false) {         throw new NoSuchRemoteClusterException(clusterAlias).     }     return new RemoteClusterAwareClient(settings, threadPool, transportService, clusterAlias). }
false;;0;3;;Collection<RemoteClusterConnection> getConnections() {     return remoteClusters.values(). }
