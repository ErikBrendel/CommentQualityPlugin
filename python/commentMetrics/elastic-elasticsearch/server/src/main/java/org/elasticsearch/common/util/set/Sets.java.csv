commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;8;;public static <T> HashSet<T> newHashSet(Iterator<T> iterator) {     Objects.requireNonNull(iterator).     HashSet<T> set = new HashSet<>().     while (iterator.hasNext()) {         set.add(iterator.next()).     }     return set. }
false;public,static;1;4;;public static <T> HashSet<T> newHashSet(Iterable<T> iterable) {     Objects.requireNonNull(iterable).     return iterable instanceof Collection ? new HashSet<>((Collection) iterable) : newHashSet(iterable.iterator()). }
false;public,static;1;6;;public static <T> HashSet<T> newHashSet(T... elements) {     Objects.requireNonNull(elements).     HashSet<T> set = new HashSet<>(elements.length).     Collections.addAll(set, elements).     return set. }
false;public,static;0;3;;public static <T> Set<T> newConcurrentHashSet() {     return Collections.newSetFromMap(new ConcurrentHashMap<>()). }
false;public,static;2;5;;public static <T> boolean haveEmptyIntersection(Set<T> left, Set<T> right) {     Objects.requireNonNull(left).     Objects.requireNonNull(right).     return !left.stream().anyMatch(k -> right.contains(k)). }
true;public,static;2;5;/**  * The relative complement, or difference, of the specified left and right set. Namely, the resulting set contains all the elements that  * are in the left set but not in the right set. Neither input is mutated by this operation, an entirely new set is returned.  *  * @param left  the left set  * @param right the right set  * @param <T>   the type of the elements of the sets  * @return the relative complement of the left set with respect to the right set  */ ;/**  * The relative complement, or difference, of the specified left and right set. Namely, the resulting set contains all the elements that  * are in the left set but not in the right set. Neither input is mutated by this operation, an entirely new set is returned.  *  * @param left  the left set  * @param right the right set  * @param <T>   the type of the elements of the sets  * @return the relative complement of the left set with respect to the right set  */ public static <T> Set<T> difference(Set<T> left, Set<T> right) {     Objects.requireNonNull(left).     Objects.requireNonNull(right).     return left.stream().filter(k -> !right.contains(k)).collect(Collectors.toSet()). }
true;public,static;2;5;/**  * The relative complement, or difference, of the specified left and right set, returned as a sorted set. Namely, the resulting set  * contains all the elements that are in the left set but not in the right set, and the set is sorted using the natural ordering of  * element type. Neither input is mutated by this operation, an entirely new set is returned.  *  * @param left  the left set  * @param right the right set  * @param <T>   the type of the elements of the sets  * @return the sorted relative complement of the left set with respect to the right set  */ ;/**  * The relative complement, or difference, of the specified left and right set, returned as a sorted set. Namely, the resulting set  * contains all the elements that are in the left set but not in the right set, and the set is sorted using the natural ordering of  * element type. Neither input is mutated by this operation, an entirely new set is returned.  *  * @param left  the left set  * @param right the right set  * @param <T>   the type of the elements of the sets  * @return the sorted relative complement of the left set with respect to the right set  */ public static <T> SortedSet<T> sortedDifference(Set<T> left, Set<T> right) {     Objects.requireNonNull(left).     Objects.requireNonNull(right).     return left.stream().filter(k -> !right.contains(k)).collect(new SortedSetCollector<>()). }
false;public;0;4;;@Override public Supplier<SortedSet<T>> supplier() {     return TreeSet::new. }
false;public;0;4;;@Override public BiConsumer<SortedSet<T>, T> accumulator() {     return (s, e) -> s.add(e). }
false;public;0;7;;@Override public BinaryOperator<SortedSet<T>> combiner() {     return (s, t) -> {         s.addAll(t).         return s.     }. }
false;public;0;4;;@Override public Function<SortedSet<T>, SortedSet<T>> finisher() {     return Function.identity(). }
false;public;0;4;;@Override public Set<Characteristics> characteristics() {     return CHARACTERISTICS. }
false;public,static;2;7;;public static <T> Set<T> union(Set<T> left, Set<T> right) {     Objects.requireNonNull(left).     Objects.requireNonNull(right).     Set<T> union = new HashSet<>(left).     union.addAll(right).     return union. }
false;public,static;2;14;;public static <T> Set<T> intersection(Set<T> set1, Set<T> set2) {     Objects.requireNonNull(set1).     Objects.requireNonNull(set2).     final Set<T> left.     final Set<T> right.     if (set1.size() < set2.size()) {         left = set1.         right = set2.     } else {         left = set2.         right = set1.     }     return left.stream().filter(o -> right.contains(o)).collect(Collectors.toSet()). }
