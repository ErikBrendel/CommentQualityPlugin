commented;modifiers;parameterAmount;loc;comment;code
true;public;0;8;/**  * sets the last observed state to the currently applied cluster state and returns it  */ ;/**  * sets the last observed state to the currently applied cluster state and returns it  */ public ClusterState setAndGetObservedState() {     if (observingContext.get() != null) {         throw new ElasticsearchException("cannot set current cluster state while waiting for a cluster state change").     }     ClusterState clusterState = clusterApplierService.state().     lastObservedState.set(new StoredState(clusterState)).     return clusterState. }
true;public;0;3;/**  * indicates whether this observer has timed out  */ ;/**  * indicates whether this observer has timed out  */ public boolean isTimedOut() {     return timedOut. }
false;public;1;3;;public void waitForNextChange(Listener listener) {     waitForNextChange(listener, MATCH_ALL_CHANGES_PREDICATE). }
false;public;2;3;;public void waitForNextChange(Listener listener, @Nullable TimeValue timeOutValue) {     waitForNextChange(listener, MATCH_ALL_CHANGES_PREDICATE, timeOutValue). }
false;public;2;3;;public void waitForNextChange(Listener listener, Predicate<ClusterState> statePredicate) {     waitForNextChange(listener, statePredicate, null). }
true;public;3;50;/**  * Wait for the next cluster state which satisfies statePredicate  *  * @param listener        callback listener  * @param statePredicate predicate to check whether cluster state changes are relevant and the callback should be called  * @param timeOutValue    a timeout for waiting. If null the global observer timeout will be used.  */ ;/**  * Wait for the next cluster state which satisfies statePredicate  *  * @param listener        callback listener  * @param statePredicate predicate to check whether cluster state changes are relevant and the callback should be called  * @param timeOutValue    a timeout for waiting. If null the global observer timeout will be used.  */ public void waitForNextChange(Listener listener, Predicate<ClusterState> statePredicate, @Nullable TimeValue timeOutValue) {     listener = new ContextPreservingListener(listener, contextHolder.newRestorableContext(false)).     if (observingContext.get() != null) {         throw new ElasticsearchException("already waiting for a cluster state change").     }     Long timeoutTimeLeftMS.     if (timeOutValue == null) {         timeOutValue = this.timeOutValue.         if (timeOutValue != null) {             long timeSinceStartMS = TimeValue.nsecToMSec(System.nanoTime() - startTimeNS).             timeoutTimeLeftMS = timeOutValue.millis() - timeSinceStartMS.             if (timeoutTimeLeftMS <= 0L) {                 // things have timeout while we were busy -> notify                 logger.trace("observer timed out. notifying listener. timeout setting [{}], time since start [{}]", timeOutValue, new TimeValue(timeSinceStartMS)).                 // update to latest, in case people want to retry                 timedOut = true.                 lastObservedState.set(new StoredState(clusterApplierService.state())).                 listener.onTimeout(timeOutValue).                 return.             }         } else {             timeoutTimeLeftMS = null.         }     } else {         this.startTimeNS = System.nanoTime().         this.timeOutValue = timeOutValue.         timeoutTimeLeftMS = timeOutValue.millis().         timedOut = false.     }     // sample a new state. This state maybe *older* than the supplied state if we are called from an applier,     // which wants to wait for something else to happen     ClusterState newState = clusterApplierService.state().     if (lastObservedState.get().isOlderOrDifferentMaster(newState) && statePredicate.test(newState)) {         // good enough, let's go.         logger.trace("observer: sampled state accepted by predicate ({})", newState).         lastObservedState.set(new StoredState(newState)).         listener.onNewClusterState(newState).     } else {         logger.trace("observer: sampled state rejected by predicate ({}). adding listener to ClusterService", newState).         final ObservingContext context = new ObservingContext(listener, statePredicate).         if (!observingContext.compareAndSet(null, context)) {             throw new ElasticsearchException("already waiting for a cluster state change").         }         clusterApplierService.addTimeoutListener(timeoutTimeLeftMS == null ? null : new TimeValue(timeoutTimeLeftMS), clusterStateListener).     } }
false;public;1;22;;@Override public void clusterChanged(ClusterChangedEvent event) {     ObservingContext context = observingContext.get().     if (context == null) {         // No need to remove listener as it is the responsibility of the thread that set observingContext to null         return.     }     final ClusterState state = event.state().     if (context.statePredicate.test(state)) {         if (observingContext.compareAndSet(context, null)) {             clusterApplierService.removeTimeoutListener(this).             logger.trace("observer: accepting cluster state change ({})", state).             lastObservedState.set(new StoredState(state)).             context.listener.onNewClusterState(state).         } else {             logger.trace("observer: predicate approved change but observing context has changed " + "- ignoring (new cluster state version [{}])", state.version()).         }     } else {         logger.trace("observer: predicate rejected change (new cluster state version [{}])", state.version()).     } }
false;public;0;23;;@Override public void postAdded() {     ObservingContext context = observingContext.get().     if (context == null) {         // No need to remove listener as it is the responsibility of the thread that set observingContext to null         return.     }     ClusterState newState = clusterApplierService.state().     if (lastObservedState.get().isOlderOrDifferentMaster(newState) && context.statePredicate.test(newState)) {         // double check we're still listening         if (observingContext.compareAndSet(context, null)) {             logger.trace("observer: post adding listener: accepting current cluster state ({})", newState).             clusterApplierService.removeTimeoutListener(this).             lastObservedState.set(new StoredState(newState)).             context.listener.onNewClusterState(newState).         } else {             logger.trace("observer: postAdded - predicate approved state but observing context has changed - ignoring ({})", newState).         }     } else {         logger.trace("observer: postAdded - predicate rejected state ({})", newState).     } }
false;public;0;10;;@Override public void onClose() {     ObservingContext context = observingContext.getAndSet(null).     if (context != null) {         logger.trace("observer: cluster service closed. notifying listener.").         clusterApplierService.removeTimeoutListener(this).         context.listener.onClusterServiceClose().     } }
false;public;1;14;;@Override public void onTimeout(TimeValue timeout) {     ObservingContext context = observingContext.getAndSet(null).     if (context != null) {         clusterApplierService.removeTimeoutListener(this).         long timeSinceStartMS = TimeValue.nsecToMSec(System.nanoTime() - startTimeNS).         logger.trace("observer: timeout notification from cluster service. timeout setting [{}], time since start [{}]", timeOutValue, new TimeValue(timeSinceStartMS)).         // update to latest, in case people want to retry         lastObservedState.set(new StoredState(clusterApplierService.state())).         timedOut = true.         context.listener.onTimeout(timeOutValue).     } }
true;public;1;3;/**  * returns true if stored state is older then given state or they are from a different master, meaning they can't be compared  */ ;/**  * returns true if stored state is older then given state or they are from a different master, meaning they can't be compared  */ public boolean isOlderOrDifferentMaster(ClusterState clusterState) {     return version < clusterState.version() || Objects.equals(masterNodeId, clusterState.nodes().getMasterNodeId()) == false. }
true;;1;1;/**  * called when a new state is observed  */ ;/**  * called when a new state is observed  */ void onNewClusterState(ClusterState state).
true;;0;1;/**  * called when the cluster service is closed  */ ;/**  * called when the cluster service is closed  */ void onClusterServiceClose().
false;;1;1;;void onTimeout(TimeValue timeout).
false;public;1;6;;@Override public void onNewClusterState(ClusterState state) {     try (ThreadContext.StoredContext context = contextSupplier.get()) {         delegate.onNewClusterState(state).     } }
false;public;0;6;;@Override public void onClusterServiceClose() {     try (ThreadContext.StoredContext context = contextSupplier.get()) {         delegate.onClusterServiceClose().     } }
false;public;1;6;;@Override public void onTimeout(TimeValue timeout) {     try (ThreadContext.StoredContext context = contextSupplier.get()) {         delegate.onTimeout(timeout).     } }
