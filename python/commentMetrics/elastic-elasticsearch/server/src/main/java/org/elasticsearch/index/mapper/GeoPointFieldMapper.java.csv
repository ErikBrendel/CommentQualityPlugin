commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;public Builder ignoreMalformed(boolean ignoreMalformed) {     this.ignoreMalformed = ignoreMalformed.     return builder. }
false;protected;1;9;;protected Explicit<Boolean> ignoreMalformed(BuilderContext context) {     if (ignoreMalformed != null) {         return new Explicit<>(ignoreMalformed, true).     }     if (context.indexSettings() != null) {         return new Explicit<>(IGNORE_MALFORMED_SETTING.get(context.indexSettings()), false).     }     return GeoPointFieldMapper.Defaults.IGNORE_MALFORMED. }
false;protected;1;6;;protected Explicit<Boolean> ignoreZValue(BuilderContext context) {     if (ignoreZValue != null) {         return new Explicit<>(ignoreZValue, true).     }     return Defaults.IGNORE_Z_VALUE. }
false;public;1;4;;public Builder ignoreZValue(final boolean ignoreZValue) {     this.ignoreZValue = ignoreZValue.     return this. }
false;public;9;8;;public GeoPointFieldMapper build(BuilderContext context, String simpleName, MappedFieldType fieldType, MappedFieldType defaultFieldType, Settings indexSettings, MultiFields multiFields, Explicit<Boolean> ignoreMalformed, Explicit<Boolean> ignoreZValue, CopyTo copyTo) {     setupFieldType(context).     return new GeoPointFieldMapper(simpleName, fieldType, defaultFieldType, indexSettings, multiFields, ignoreMalformed, ignoreZValue, copyTo). }
false;public;1;6;;@Override public GeoPointFieldMapper build(BuilderContext context) {     return build(context, name, fieldType, defaultFieldType, context.indexSettings(), multiFieldsBuilder.build(this, context), ignoreMalformed(context), ignoreZValue(context), copyTo). }
false;public;3;45;;@Override public Mapper.Builder parse(String name, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {     Builder builder = new GeoPointFieldMapper.Builder(name).     parseField(builder, name, node, parserContext).     Object nullValue = null.     for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(). iterator.hasNext(). ) {         Map.Entry<String, Object> entry = iterator.next().         String propName = entry.getKey().         Object propNode = entry.getValue().         if (propName.equals(Names.IGNORE_MALFORMED)) {             builder.ignoreMalformed(XContentMapValues.nodeBooleanValue(propNode, name + "." + Names.IGNORE_MALFORMED)).             iterator.remove().         } else if (propName.equals(Names.IGNORE_Z_VALUE.getPreferredName())) {             builder.ignoreZValue(XContentMapValues.nodeBooleanValue(propNode, name + "." + Names.IGNORE_Z_VALUE.getPreferredName())).             iterator.remove().         } else if (propName.equals(Names.NULL_VALUE)) {             if (propNode == null) {                 throw new MapperParsingException("Property [null_value] cannot be null.").             }             nullValue = propNode.             iterator.remove().         }     }     if (nullValue != null) {         boolean ignoreZValue = builder.ignoreZValue == null ? Defaults.IGNORE_Z_VALUE.value() : builder.ignoreZValue.         boolean ignoreMalformed = builder.ignoreMalformed == null ? Defaults.IGNORE_MALFORMED.value() : builder.ignoreZValue.         GeoPoint point = GeoUtils.parseGeoPoint(nullValue, ignoreZValue).         if (ignoreMalformed == false) {             if (point.lat() > 90.0 || point.lat() < -90.0) {                 throw new IllegalArgumentException("illegal latitude value [" + point.lat() + "]").             }             if (point.lon() > 180.0 || point.lon() < -180) {                 throw new IllegalArgumentException("illegal longitude value [" + point.lon() + "]").             }         } else {             GeoUtils.normalizePoint(point).         }         builder.nullValue(point).     }     return builder. }
false;protected;1;11;;@Override protected void doMerge(Mapper mergeWith) {     super.doMerge(mergeWith).     GeoPointFieldMapper gpfmMergeWith = (GeoPointFieldMapper) mergeWith.     if (gpfmMergeWith.ignoreMalformed.explicit()) {         this.ignoreMalformed = gpfmMergeWith.ignoreMalformed.     }     if (gpfmMergeWith.ignoreZValue.explicit()) {         this.ignoreZValue = gpfmMergeWith.ignoreZValue.     } }
false;protected;0;4;;@Override protected String contentType() {     return CONTENT_TYPE. }
false;protected;2;4;;@Override protected void parseCreateField(ParseContext context, List<IndexableField> fields) throws IOException {     throw new UnsupportedOperationException("Parsing is implemented in parse(), this method should NEVER be called"). }
false;public;0;4;;@Override public String typeName() {     return CONTENT_TYPE. }
false;public;0;4;;@Override public MappedFieldType clone() {     return new GeoPointFieldType(this). }
false;public;1;5;;@Override public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {     failIfNoDocValues().     return new AbstractLatLonPointDVIndexFieldData.Builder(). }
false;public;1;8;;@Override public Query existsQuery(QueryShardContext context) {     if (hasDocValues()) {         return new DocValuesFieldExistsQuery(name()).     } else {         return new TermQuery(new Term(FieldNamesFieldMapper.NAME, name())).     } }
false;public;2;5;;@Override public Query termQuery(Object value, QueryShardContext context) {     throw new QueryShardException(context, "Geo fields do not support exact searching, use dedicated geo queries instead: [" + name() + "]"). }
false;protected;2;36;;protected void parse(ParseContext context, GeoPoint point) throws IOException {     if (ignoreMalformed.value() == false) {         if (point.lat() > 90.0 || point.lat() < -90.0) {             throw new IllegalArgumentException("illegal latitude value [" + point.lat() + "] for " + name()).         }         if (point.lon() > 180.0 || point.lon() < -180) {             throw new IllegalArgumentException("illegal longitude value [" + point.lon() + "] for " + name()).         }     } else {         if (isNormalizable(point.lat()) && isNormalizable(point.lon())) {             GeoUtils.normalizePoint(point).         } else {             throw new ElasticsearchParseException("cannot normalize the point - not a number").         }     }     if (fieldType().indexOptions() != IndexOptions.NONE) {         context.doc().add(new LatLonPoint(fieldType().name(), point.lat(), point.lon())).     }     if (fieldType().stored()) {         context.doc().add(new StoredField(fieldType().name(), point.toString())).     }     if (fieldType.hasDocValues()) {         context.doc().add(new LatLonDocValuesField(fieldType().name(), point.lat(), point.lon())).     } else if (fieldType().stored() || fieldType().indexOptions() != IndexOptions.NONE) {         List<IndexableField> fields = new ArrayList<>(1).         createFieldNamesField(context, fields).         for (IndexableField field : fields) {             context.doc().add(field).         }     }     // if the mapping contains multifields then use the geohash string     if (multiFields.iterator().hasNext()) {         multiFields.parse(this, context.createExternalValueContext(point.geohash())).     } }
false;public;1;60;;@Override public void parse(ParseContext context) throws IOException {     context.path().add(simpleName()).     try {         GeoPoint sparse = context.parseExternalValue(GeoPoint.class).         if (sparse != null) {             parse(context, sparse).         } else {             sparse = new GeoPoint().             XContentParser.Token token = context.parser().currentToken().             if (token == XContentParser.Token.START_ARRAY) {                 token = context.parser().nextToken().                 if (token == XContentParser.Token.START_ARRAY) {                     // its an array of array of lon/lat [ [1.2, 1.3], [1.4, 1.5] ]                     while (token != XContentParser.Token.END_ARRAY) {                         parseGeoPointIgnoringMalformed(context, sparse).                         token = context.parser().nextToken().                     }                 } else {                     // its an array of other possible values                     if (token == XContentParser.Token.VALUE_NUMBER) {                         double lon = context.parser().doubleValue().                         context.parser().nextToken().                         double lat = context.parser().doubleValue().                         token = context.parser().nextToken().                         if (token == XContentParser.Token.VALUE_NUMBER) {                             GeoPoint.assertZValue(ignoreZValue.value(), context.parser().doubleValue()).                         } else if (token != XContentParser.Token.END_ARRAY) {                             throw new ElasticsearchParseException("[{}] field type does not accept > 3 dimensions", CONTENT_TYPE).                         }                         parse(context, sparse.reset(lat, lon)).                     } else {                         while (token != XContentParser.Token.END_ARRAY) {                             if (token == XContentParser.Token.VALUE_STRING) {                                 parseGeoPointStringIgnoringMalformed(context, sparse).                             } else {                                 parseGeoPointIgnoringMalformed(context, sparse).                             }                             token = context.parser().nextToken().                         }                     }                 }             } else if (token == XContentParser.Token.VALUE_STRING) {                 parseGeoPointStringIgnoringMalformed(context, sparse).             } else if (token == XContentParser.Token.VALUE_NULL) {                 if (fieldType.nullValue() != null) {                     parse(context, (GeoPoint) fieldType.nullValue()).                 }             } else {                 parseGeoPointIgnoringMalformed(context, sparse).             }         }     } catch (Exception ex) {         throw new MapperParsingException("failed to parse field [{}] of type [{}]", ex, fieldType().name(), fieldType().typeName()).     }     context.path().remove(). }
true;private;2;10;/**  * Parses geopoint represented as an object or an array, ignores malformed geopoints if needed  */ ;/**  * Parses geopoint represented as an object or an array, ignores malformed geopoints if needed  */ private void parseGeoPointIgnoringMalformed(ParseContext context, GeoPoint sparse) throws IOException {     try {         parse(context, GeoUtils.parseGeoPoint(context.parser(), sparse)).     } catch (ElasticsearchParseException e) {         if (ignoreMalformed.value() == false) {             throw e.         }         context.addIgnoredField(fieldType.name()).     } }
true;private;2;10;/**  * Parses geopoint represented as a string and ignores malformed geopoints if needed  */ ;/**  * Parses geopoint represented as a string and ignores malformed geopoints if needed  */ private void parseGeoPointStringIgnoringMalformed(ParseContext context, GeoPoint sparse) throws IOException {     try {         parse(context, sparse.resetFromString(context.parser().text(), ignoreZValue.value())).     } catch (ElasticsearchParseException e) {         if (ignoreMalformed.value() == false) {             throw e.         }         context.addIgnoredField(fieldType.name()).     } }
false;protected;3;14;;@Override protected void doXContentBody(XContentBuilder builder, boolean includeDefaults, Params params) throws IOException {     super.doXContentBody(builder, includeDefaults, params).     if (includeDefaults || ignoreMalformed.explicit()) {         builder.field(Names.IGNORE_MALFORMED, ignoreMalformed.value()).     }     if (includeDefaults || ignoreZValue.explicit()) {         builder.field(Names.IGNORE_Z_VALUE.getPreferredName(), ignoreZValue.value()).     }     if (includeDefaults || fieldType().nullValue() != null) {         builder.field(Names.NULL_VALUE, fieldType().nullValue()).     } }
false;public;0;3;;public Explicit<Boolean> ignoreZValue() {     return ignoreZValue. }
false;private;1;3;;private boolean isNormalizable(double coord) {     return Double.isNaN(coord) == false && Double.isInfinite(coord) == false. }
