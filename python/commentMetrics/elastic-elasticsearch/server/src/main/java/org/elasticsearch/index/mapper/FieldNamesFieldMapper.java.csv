commented;modifiers;parameterAmount;loc;comment;code
false;private;1;4;;private Builder enabled(boolean enabled) {     this.enabled = enabled.     return this. }
false;public;1;8;;@Override public FieldNamesFieldMapper build(BuilderContext context) {     setupFieldType(context).     fieldType.setHasDocValues(false).     FieldNamesFieldType fieldNamesFieldType = (FieldNamesFieldType) fieldType.     fieldNamesFieldType.setEnabled(enabled).     return new FieldNamesFieldMapper(fieldType, context.indexSettings()). }
false;public;3;16;;@Override public MetadataFieldMapper.Builder<?, ?> parse(String name, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {     Builder builder = new Builder(parserContext.mapperService().fullName(NAME)).     for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(). iterator.hasNext(). ) {         Map.Entry<String, Object> entry = iterator.next().         String fieldName = entry.getKey().         Object fieldNode = entry.getValue().         if (fieldName.equals("enabled")) {             builder.enabled(XContentMapValues.nodeBooleanValue(fieldNode, name + ".enabled")).             iterator.remove().         }     }     return builder. }
false;public;2;10;;@Override public MetadataFieldMapper getDefault(MappedFieldType fieldType, ParserContext context) {     final Settings indexSettings = context.mapperService().getIndexSettings().getSettings().     if (fieldType != null) {         return new FieldNamesFieldMapper(indexSettings, fieldType).     } else {         return parse(NAME, Collections.emptyMap(), context).build(new BuilderContext(indexSettings, new ContentPath(1))).     } }
false;public;0;4;;@Override public FieldNamesFieldType clone() {     return new FieldNamesFieldType(this). }
false;public;1;6;;@Override public boolean equals(Object o) {     if (!super.equals(o))         return false.     FieldNamesFieldType that = (FieldNamesFieldType) o.     return enabled == that.enabled. }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(super.hashCode(), enabled). }
false;public;0;4;;@Override public String typeName() {     return CONTENT_TYPE. }
false;public;1;4;;public void setEnabled(boolean enabled) {     checkIfFrozen().     this.enabled = enabled. }
false;public;0;3;;public boolean isEnabled() {     return enabled. }
false;public;1;4;;@Override public Query existsQuery(QueryShardContext context) {     throw new UnsupportedOperationException("Cannot run exists query on _field_names"). }
false;public;2;9;;@Override public Query termQuery(Object value, QueryShardContext context) {     if (isEnabled() == false) {         throw new IllegalStateException("Cannot run [exists] queries if the [_field_names] field is disabled").     }     deprecationLogger.deprecated("terms query on the _field_names field is deprecated and will be removed, use exists query instead").     return super.termQuery(value, context). }
false;public;0;4;;@Override public FieldNamesFieldType fieldType() {     return (FieldNamesFieldType) super.fieldType(). }
false;public;1;3;;@Override public void preParse(ParseContext context) { }
false;public;1;6;;@Override public void postParse(ParseContext context) throws IOException {     if (context.indexSettings().getIndexVersionCreated().before(Version.V_6_1_0)) {         super.parse(context).     } }
false;public;1;4;;@Override public void parse(ParseContext context) throws IOException { // Adding values to the _field_names field is handled by the mappers for each field type }
false;private;1;6;;private int nextEndIndex(int index) {     while (index < fullPath.length() && fullPath.charAt(index) != '.') {         index += 1.     }     return index. }
false;public;0;4;;@Override public boolean hasNext() {     return endIndex <= fullPath.length(). }
false;public;0;6;;@Override public String next() {     final String result = fullPath.substring(0, endIndex).     endIndex = nextEndIndex(endIndex + 1).     return result. }
false;public;0;4;;@Override public void remove() {     throw new UnsupportedOperationException(). }
false;public;0;32;;@Override public Iterator<String> iterator() {     return new Iterator<String>() {          int endIndex = nextEndIndex(0).          private int nextEndIndex(int index) {             while (index < fullPath.length() && fullPath.charAt(index) != '.') {                 index += 1.             }             return index.         }          @Override         public boolean hasNext() {             return endIndex <= fullPath.length().         }          @Override         public String next() {             final String result = fullPath.substring(0, endIndex).             endIndex = nextEndIndex(endIndex + 1).             return result.         }          @Override         public void remove() {             throw new UnsupportedOperationException().         }     }. }
false;static;1;36;;static Iterable<String> extractFieldNames(final String fullPath) {     return new Iterable<String>() {          @Override         public Iterator<String> iterator() {             return new Iterator<String>() {                  int endIndex = nextEndIndex(0).                  private int nextEndIndex(int index) {                     while (index < fullPath.length() && fullPath.charAt(index) != '.') {                         index += 1.                     }                     return index.                 }                  @Override                 public boolean hasNext() {                     return endIndex <= fullPath.length().                 }                  @Override                 public String next() {                     final String result = fullPath.substring(0, endIndex).                     endIndex = nextEndIndex(endIndex + 1).                     return result.                 }                  @Override                 public void remove() {                     throw new UnsupportedOperationException().                 }             }.         }     }. }
false;protected;2;29;;@Override protected void parseCreateField(ParseContext context, List<IndexableField> fields) throws IOException {     if (fieldType().isEnabled() == false) {         return.     }     for (ParseContext.Document document : context) {         final List<String> paths = new ArrayList<>(document.getFields().size()).         // used as a sentinel - field names can't be empty         String previousPath = "".         for (IndexableField field : document.getFields()) {             final String path = field.name().             if (path.equals(previousPath)) {                 // gives Lucene fewer values to deal with.                 continue.             }             paths.add(path).             previousPath = path.         }         for (String path : paths) {             for (String fieldName : extractFieldNames(path)) {                 if (fieldType().indexOptions() != IndexOptions.NONE || fieldType().stored()) {                     document.add(new Field(fieldType().name(), fieldName, fieldType())).                 }             }         }     } }
false;protected;0;4;;@Override protected String contentType() {     return CONTENT_TYPE. }
false;public;2;16;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     boolean includeDefaults = params.paramAsBoolean("include_defaults", false).     if (includeDefaults == false && fieldType().isEnabled() == Defaults.ENABLED) {         return builder.     }     builder.startObject(NAME).     if (includeDefaults || fieldType().isEnabled() != Defaults.ENABLED) {         builder.field("enabled", fieldType().isEnabled()).     }     builder.endObject().     return builder. }
