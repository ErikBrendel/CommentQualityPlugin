commented;modifiers;parameterAmount;loc;comment;code
true;public;1;5;/**  * Returns an instance that uses {@code source} as a reference point for newly added errors.  */ ;/**  * Returns an instance that uses {@code source} as a reference point for newly added errors.  */ public Errors withSource(Object source) {     return source == SourceProvider.UNKNOWN_SOURCE ? this : new Errors(this, source). }
true;public;1;3;/**  * We use a fairly generic error message here. The motivation is to share the  * same message for both bind time errors:  * <pre><code>Guice.createInjector(new AbstractModule() {  *   public void configure() {  *     bind(Runnable.class).  *   }  * }</code></pre>  * ...and at provide-time errors:  * <pre><code>Guice.createInjector().getInstance(Runnable.class).</code></pre>  * Otherwise we need to know who's calling when resolving a just-in-time  * binding, which makes things unnecessarily complex.  */ ;/**  * We use a fairly generic error message here. The motivation is to share the  * same message for both bind time errors:  * <pre><code>Guice.createInjector(new AbstractModule() {  *   public void configure() {  *     bind(Runnable.class).  *   }  * }</code></pre>  * ...and at provide-time errors:  * <pre><code>Guice.createInjector().getInstance(Runnable.class).</code></pre>  * Otherwise we need to know who's calling when resolving a just-in-time  * binding, which makes things unnecessarily complex.  */ public Errors missingImplementation(Key key) {     return addMessage("No implementation for %s was bound.", key). }
false;public;4;6;;public Errors converterReturnedNull(String stringValue, Object source, TypeLiteral<?> type, MatcherAndConverter matchingConverter) {     return addMessage("Received null converting '%s' (bound at %s) to %s%n" + " using %s.", stringValue, convert(source), type, matchingConverter). }
false;public;5;7;;public Errors conversionTypeError(String stringValue, Object source, TypeLiteral<?> type, MatcherAndConverter matchingConverter, Object converted) {     return addMessage("Type mismatch converting '%s' (bound at %s) to %s%n" + " using %s.%n" + " Converter returned %s.", stringValue, convert(source), type, matchingConverter, converted). }
false;public;5;7;;public Errors conversionError(String stringValue, Object source, TypeLiteral<?> type, MatcherAndConverter matchingConverter, RuntimeException cause) {     return errorInUserCode(cause, "Error converting '%s' (bound at %s) to %s%n" + " using %s.%n" + " Reason: %s", stringValue, convert(source), type, matchingConverter, cause). }
false;public;5;8;;public Errors ambiguousTypeConversion(String stringValue, Object source, TypeLiteral<?> type, MatcherAndConverter a, MatcherAndConverter b) {     return addMessage("Multiple converters can convert '%s' (bound at %s) to %s:%n" + " %s and%n" + " %s.%n" + " Please adjust your type converter configuration to avoid overlapping matches.", stringValue, convert(source), type, a, b). }
false;public;0;3;;public Errors bindingToProvider() {     return addMessage("Binding to Provider is not allowed."). }
false;public;2;4;;public Errors subtypeNotProvided(Class<? extends Provider<?>> providerType, Class<?> type) {     return addMessage("%s doesn't provide instances of %s.", providerType, type). }
false;public;2;3;;public Errors notASubtype(Class<?> implementationType, Class<?> type) {     return addMessage("%s doesn't extend %s.", implementationType, type). }
false;public;0;3;;public Errors recursiveImplementationType() {     return addMessage("@ImplementedBy points to the same class it annotates."). }
false;public;0;3;;public Errors recursiveProviderType() {     return addMessage("@ProvidedBy points to the same class it annotates."). }
false;public;1;4;;public Errors missingRuntimeRetention(Object source) {     return addMessage("Please annotate with @Retention(RUNTIME).%n" + " Bound at %s.", convert(source)). }
false;public;0;3;;public Errors missingScopeAnnotation() {     return addMessage("Please annotate with @ScopeAnnotation."). }
false;public;1;4;;public Errors optionalConstructor(Constructor constructor) {     return addMessage("%s is annotated @Inject(optional=true), " + "but constructors cannot be optional.", constructor). }
false;public;1;3;;public Errors cannotBindToGuiceType(String simpleName) {     return addMessage("Binding to core guice framework type is not allowed: %s.", simpleName). }
false;public;1;3;;public Errors scopeNotFound(Class<? extends Annotation> scopeAnnotation) {     return addMessage("No scope is bound to %s.", scopeAnnotation). }
false;public;3;5;;public Errors scopeAnnotationOnAbstractType(Class<? extends Annotation> scopeAnnotation, Class<?> type, Object source) {     return addMessage("%s is annotated with %s, but scope annotations are not supported " + "for abstract types.%n Bound at %s.", type, scopeAnnotation, convert(source)). }
false;public;2;4;;public Errors misplacedBindingAnnotation(Member member, Annotation bindingAnnotation) {     return addMessage("%s is annotated with %s, but binding annotations should be applied " + "to its parameters instead.", member, bindingAnnotation). }
false;public;1;4;;public Errors missingConstructor(Class<?> implementation) {     return addMessage("Could not find a suitable constructor in %s. " + CONSTRUCTOR_RULES, implementation). }
false;public;1;4;;public Errors tooManyConstructors(Class<?> implementation) {     return addMessage("%s has more than one constructor annotated with @Inject. " + CONSTRUCTOR_RULES, implementation). }
false;public;3;5;;public Errors duplicateScopes(Scope existing, Class<? extends Annotation> annotationType, Scope scope) {     return addMessage("Scope %s is already bound to %s. Cannot bind %s.", existing, annotationType, scope). }
false;public;0;3;;public Errors voidProviderMethod() {     return addMessage("Provider methods must return a value. Do not return void."). }
false;public;0;3;;public Errors missingConstantValues() {     return addMessage("Missing constant value. Please call to(...)."). }
false;public;1;4;;public Errors cannotInjectInnerClass(Class<?> type) {     return addMessage("Injecting into inner classes is not supported.  " + "Please use a 'static' class (top-level or nested) instead of %s.", type). }
false;public;3;5;;public Errors duplicateBindingAnnotations(Member member, Class<? extends Annotation> a, Class<? extends Annotation> b) {     return addMessage("%s has more than one annotation annotated with @BindingAnnotation: " + "%s and %s", member, a, b). }
false;public;2;4;;public Errors duplicateScopeAnnotations(Class<? extends Annotation> a, Class<? extends Annotation> b) {     return addMessage("More than one scope annotation was found: %s and %s.", a, b). }
false;public;0;3;;public Errors recursiveBinding() {     return addMessage("Binding points to itself."). }
false;public;2;3;;public Errors bindingAlreadySet(Key<?> key, Object source) {     return addMessage("A binding to %s was already configured at %s.", key, convert(source)). }
false;public;1;3;;public Errors childBindingAlreadySet(Key<?> key) {     return addMessage("A binding to %s already exists on a child injector.", key). }
false;public;1;3;;public Errors errorInjectingMethod(Throwable cause) {     return errorInUserCode(cause, "Error injecting method, %s", cause). }
false;public;3;7;;public Errors errorNotifyingTypeListener(TypeListenerBinding listener, TypeLiteral<?> type, Throwable cause) {     return errorInUserCode(cause, "Error notifying TypeListener %s (bound at %s) of %s.%n" + " Reason: %s", listener.getListener(), convert(listener.getSource()), type, cause). }
false;public;1;3;;public Errors errorInjectingConstructor(Throwable cause) {     return errorInUserCode(cause, "Error injecting constructor, %s", cause). }
false;public;1;3;;public Errors errorInProvider(RuntimeException runtimeException) {     return errorInUserCode(runtimeException, "Error in custom provider, %s", runtimeException). }
false;public;3;5;;public Errors errorInUserInjector(MembersInjector<?> listener, TypeLiteral<?> type, RuntimeException cause) {     return errorInUserCode(cause, "Error injecting %s using %s.%n" + " Reason: %s", type, listener, cause). }
false;public;3;5;;public Errors errorNotifyingInjectionListener(InjectionListener<?> listener, TypeLiteral<?> type, RuntimeException cause) {     return errorInUserCode(cause, "Error notifying InjectionListener %s of %s.%n" + " Reason: %s", listener, type, cause). }
false;public;1;3;;public void exposedButNotBound(Key<?> key) {     addMessage("Could not expose() %s, it must be explicitly bound.", key). }
false;public,static;1;11;;public static Collection<Message> getMessagesFromThrowable(Throwable throwable) {     if (throwable instanceof ProvisionException) {         return ((ProvisionException) throwable).getErrorMessages().     } else if (throwable instanceof ConfigurationException) {         return ((ConfigurationException) throwable).getErrorMessages().     } else if (throwable instanceof CreationException) {         return ((CreationException) throwable).getErrorMessages().     } else {         return emptySet().     } }
false;public;3;9;;public Errors errorInUserCode(Throwable cause, String messageFormat, Object... arguments) {     Collection<Message> messages = getMessagesFromThrowable(cause).     if (!messages.isEmpty()) {         return merge(messages).     } else {         return addMessage(cause, messageFormat, arguments).     } }
false;public;0;3;;public Errors cannotInjectRawProvider() {     return addMessage("Cannot inject a Provider that has no type parameter"). }
false;public;0;3;;public Errors cannotInjectRawMembersInjector() {     return addMessage("Cannot inject a MembersInjector that has no type parameter"). }
false;public;1;3;;public Errors cannotInjectTypeLiteralOf(Type unsupportedType) {     return addMessage("Cannot inject a TypeLiteral of %s", unsupportedType). }
false;public;0;3;;public Errors cannotInjectRawTypeLiteral() {     return addMessage("Cannot inject a TypeLiteral that has no type parameter"). }
false;public;1;5;;public Errors cannotSatisfyCircularDependency(Class<?> expectedType) {     return addMessage("Tried proxying %s to support a circular dependency, but it is not an interface.", expectedType). }
false;public;0;7;;public void throwCreationExceptionIfErrorsExist() {     if (!hasErrors()) {         return.     }     throw new CreationException(getMessages()). }
false;public;0;7;;public void throwConfigurationExceptionIfErrorsExist() {     if (!hasErrors()) {         return.     }     throw new ConfigurationException(getMessages()). }
false;public;0;7;;public void throwProvisionExceptionIfErrorsExist() {     if (!hasErrors()) {         return.     }     throw new ProvisionException(getMessages()). }
false;private;1;6;;private Message merge(Message message) {     List<Object> sources = new ArrayList<>().     sources.addAll(getSources()).     sources.addAll(message.getSources()).     return new Message(sources, message.getMessage(), message.getCause()). }
false;public;1;6;;public Errors merge(Collection<Message> messages) {     for (Message message : messages) {         addMessage(merge(message)).     }     return this. }
false;public;1;8;;public Errors merge(Errors moreErrors) {     if (moreErrors.root == root || moreErrors.root.errors == null) {         return this.     }     merge(moreErrors.root.errors).     return this. }
false;public;0;9;;public List<Object> getSources() {     List<Object> sources = new ArrayList<>().     for (Errors e = this. e != null. e = e.parent) {         if (e.source != SourceProvider.UNKNOWN_SOURCE) {             sources.add(0, e.source).         }     }     return sources. }
false;public;1;7;;public void throwIfNewErrors(int expectedSize) throws ErrorsException {     if (size() == expectedSize) {         return.     }     throw toException(). }
false;public;0;3;;public ErrorsException toException() {     return new ErrorsException(this). }
false;public;0;3;;public boolean hasErrors() {     return root.errors != null. }
false;public;2;3;;public Errors addMessage(String messageFormat, Object... arguments) {     return addMessage(null, messageFormat, arguments). }
false;private;3;5;;private Errors addMessage(Throwable cause, String messageFormat, Object... arguments) {     String message = format(messageFormat, arguments).     addMessage(new Message(getSources(), message, cause)).     return this. }
false;public;1;7;;public Errors addMessage(Message message) {     if (root.errors == null) {         root.errors = new ArrayList<>().     }     root.errors.add(message).     return this. }
false;public,static;2;6;;public static String format(String messageFormat, Object... arguments) {     for (int i = 0. i < arguments.length. i++) {         arguments[i] = Errors.convert(arguments[i]).     }     return String.format(Locale.ROOT, messageFormat, arguments). }
false;public;2;4;;@Override public int compare(Message a, Message b) {     return a.getSource().compareTo(b.getSource()). }
false;public;0;15;;public List<Message> getMessages() {     if (root.errors == null) {         return Collections.emptyList().     }     List<Message> result = new ArrayList<>(root.errors).     CollectionUtil.timSort(result, new Comparator<Message>() {          @Override         public int compare(Message a, Message b) {             return a.getSource().compareTo(b.getSource()).         }     }).     return unmodifiableList(result). }
true;public,static;2;34;/**  * Returns the formatted message for an exception with the specified messages.  */ ;/**  * Returns the formatted message for an exception with the specified messages.  */ public static String format(String heading, Collection<Message> errorMessages) {     try (Formatter fmt = new Formatter(Locale.ROOT)) {         fmt.format(heading).format(":%n%n").         int index = 1.         boolean displayCauses = getOnlyCause(errorMessages) == null.         for (Message errorMessage : errorMessages) {             fmt.format("%s) %s%n", index++, errorMessage.getMessage()).             List<Object> dependencies = errorMessage.getSources().             for (int i = dependencies.size() - 1. i >= 0. i--) {                 Object source = dependencies.get(i).                 formatSource(fmt, source).             }             Throwable cause = errorMessage.getCause().             if (displayCauses && cause != null) {                 StringWriter writer = new StringWriter().                 cause.printStackTrace(new PrintWriter(writer)).                 fmt.format("Caused by: %s", writer.getBuffer()).             }             fmt.format("%n").         }         if (errorMessages.size() == 1) {             fmt.format("1 error").         } else {             fmt.format("%s errors", errorMessages.size()).         }         return fmt.toString().     } }
true;public;3;15;/**  * Returns {@code value} if it is non-null allowed to be null. Otherwise a message is added and  * an {@code ErrorsException} is thrown.  */ ;/**  * Returns {@code value} if it is non-null allowed to be null. Otherwise a message is added and  * an {@code ErrorsException} is thrown.  */ public <T> T checkForNull(T value, Object source, Dependency<?> dependency) throws ErrorsException {     if (value != null || dependency.isNullable()) {         return value.     }     int parameterIndex = dependency.getParameterIndex().     String parameterName = (parameterIndex != -1) ? "parameter " + parameterIndex + " of " : "".     addMessage("null returned by binding at %s%n but %s%s is not @Nullable", source, parameterName, dependency.getInjectionPoint().getMember()).     throw toException(). }
true;public,static;1;17;/**  * Returns the cause throwable if there is exactly one cause in {@code messages}. If there are  * zero or multiple messages with causes, null is returned.  */ ;/**  * Returns the cause throwable if there is exactly one cause in {@code messages}. If there are  * zero or multiple messages with causes, null is returned.  */ public static Throwable getOnlyCause(Collection<Message> messages) {     Throwable onlyCause = null.     for (Message message : messages) {         Throwable messageCause = message.getCause().         if (messageCause == null) {             continue.         }         if (onlyCause != null) {             return null.         }         onlyCause = messageCause.     }     return onlyCause. }
false;public;0;3;;public int size() {     return root.errors == null ? 0 : root.errors.size(). }
false;;1;3;;boolean appliesTo(Object o) {     return type.isAssignableFrom(o.getClass()). }
false;;1;3;;String convert(Object o) {     return toString(type.cast(o)). }
false;abstract;1;1;;abstract String toString(T t).
false;public;1;4;;@Override public String toString(Class c) {     return c.getName(). }
false;public;1;4;;@Override public String toString(Member member) {     return MoreTypes.toString(member). }
false;public;1;9;;@Override public String toString(Key key) {     if (key.getAnnotationType() != null) {         return key.getTypeLiteral() + " annotated with " + (key.getAnnotation() != null ? key.getAnnotation() : key.getAnnotationType()).     } else {         return key.getTypeLiteral().toString().     } }
false;public,static;1;8;;public static Object convert(Object o) {     for (Converter<?> converter : converters) {         if (converter.appliesTo(o)) {             return converter.convert(o).         }     }     return o. }
false;public,static;2;30;;public static void formatSource(Formatter formatter, Object source) {     if (source instanceof Dependency) {         Dependency<?> dependency = (Dependency<?>) source.         InjectionPoint injectionPoint = dependency.getInjectionPoint().         if (injectionPoint != null) {             formatInjectionPoint(formatter, dependency, injectionPoint).         } else {             formatSource(formatter, dependency.getKey()).         }     } else if (source instanceof InjectionPoint) {         formatInjectionPoint(formatter, null, (InjectionPoint) source).     } else if (source instanceof Class) {         formatter.format("  at %s%n", StackTraceElements.forType((Class<?>) source)).     } else if (source instanceof Member) {         formatter.format("  at %s%n", StackTraceElements.forMember((Member) source)).     } else if (source instanceof TypeLiteral) {         formatter.format("  while locating %s%n", source).     } else if (source instanceof Key) {         Key<?> key = (Key<?>) source.         formatter.format("  while locating %s%n", convert(key)).     } else {         formatter.format("  at %s%n", source).     } }
false;public,static;3;19;;public static void formatInjectionPoint(Formatter formatter, Dependency<?> dependency, InjectionPoint injectionPoint) {     Member member = injectionPoint.getMember().     Class<? extends Member> memberType = MoreTypes.memberType(member).     if (memberType == Field.class) {         dependency = injectionPoint.getDependencies().get(0).         formatter.format("  while locating %s%n", convert(dependency.getKey())).         formatter.format("    for field at %s%n", StackTraceElements.forMember(member)).     } else if (dependency != null) {         formatter.format("  while locating %s%n", convert(dependency.getKey())).         formatter.format("    for parameter %s at %s%n", dependency.getParameterIndex(), StackTraceElements.forMember(member)).     } else {         formatSource(formatter, injectionPoint.getMember()).     } }
