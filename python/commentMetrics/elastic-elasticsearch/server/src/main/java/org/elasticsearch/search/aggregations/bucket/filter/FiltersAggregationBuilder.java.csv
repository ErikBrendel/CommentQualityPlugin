commented;modifiers;parameterAmount;loc;comment;code
false;protected;2;4;;@Override protected AggregationBuilder shallowCopy(Builder factoriesBuilder, Map<String, Object> metaData) {     return new FiltersAggregationBuilder(this, factoriesBuilder, metaData). }
false;protected;1;16;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     out.writeBoolean(keyed).     out.writeVInt(filters.size()).     if (keyed) {         for (KeyedFilter keyedFilter : filters) {             keyedFilter.writeTo(out).         }     } else {         for (KeyedFilter keyedFilter : filters) {             out.writeNamedWriteable(keyedFilter.filter()).         }     }     out.writeBoolean(otherBucket).     out.writeString(otherBucketKey). }
true;public;1;4;/**  * Set whether to include a bucket for documents not matching any filter  */ ;/**  * Set whether to include a bucket for documents not matching any filter  */ public FiltersAggregationBuilder otherBucket(boolean otherBucket) {     this.otherBucket = otherBucket.     return this. }
true;public;0;3;/**  * Get whether to include a bucket for documents not matching any filter  */ ;/**  * Get whether to include a bucket for documents not matching any filter  */ public boolean otherBucket() {     return otherBucket. }
true;public;0;3;/**  * Get the filters. This will be an unmodifiable list  */ ;/**  * Get the filters. This will be an unmodifiable list  */ public List<KeyedFilter> filters() {     return Collections.unmodifiableList(this.filters). }
true;public;0;3;/**  * @return true if this builders filters have a key  */ ;/**  * @return true if this builders filters have a key  */ public boolean isKeyed() {     return this.keyed. }
true;public;1;7;/**  * Set the key to use for the bucket for documents not matching any  * filter.  */ ;/**  * Set the key to use for the bucket for documents not matching any  * filter.  */ public FiltersAggregationBuilder otherBucketKey(String otherBucketKey) {     if (otherBucketKey == null) {         throw new IllegalArgumentException("[otherBucketKey] must not be null: [" + name + "]").     }     this.otherBucketKey = otherBucketKey.     return this. }
true;public;0;3;/**  * Get the key to use for the bucket for documents not matching any  * filter.  */ ;/**  * Get the key to use for the bucket for documents not matching any  * filter.  */ public String otherBucketKey() {     return otherBucketKey. }
false;protected;1;20;;@Override protected AggregationBuilder doRewrite(QueryRewriteContext queryShardContext) throws IOException {     List<KeyedFilter> rewrittenFilters = new ArrayList<>(filters.size()).     boolean changed = false.     for (KeyedFilter kf : filters) {         QueryBuilder result = Rewriteable.rewrite(kf.filter(), queryShardContext).         rewrittenFilters.add(new KeyedFilter(kf.key(), result)).         if (result != kf.filter()) {             changed = true.         }     }     if (changed) {         FiltersAggregationBuilder rewritten = new FiltersAggregationBuilder(getName(), rewrittenFilters, this.keyed).         rewritten.otherBucket(otherBucket).         rewritten.otherBucketKey(otherBucketKey).         return rewritten.     } else {         return this.     } }
false;protected;3;6;;@Override protected AggregatorFactory<?> doBuild(SearchContext context, AggregatorFactory<?> parent, Builder subFactoriesBuilder) throws IOException {     return new FiltersAggregatorFactory(name, filters, keyed, otherBucket, otherBucketKey, context, parent, subFactoriesBuilder, metaData). }
false;protected;2;21;;@Override protected XContentBuilder internalXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     if (keyed) {         builder.startObject(FiltersAggregator.FILTERS_FIELD.getPreferredName()).         for (KeyedFilter keyedFilter : filters) {             builder.field(keyedFilter.key(), keyedFilter.filter()).         }         builder.endObject().     } else {         builder.startArray(FiltersAggregator.FILTERS_FIELD.getPreferredName()).         for (KeyedFilter keyedFilter : filters) {             builder.value(keyedFilter.filter()).         }         builder.endArray().     }     builder.field(FiltersAggregator.OTHER_BUCKET_FIELD.getPreferredName(), otherBucket).     builder.field(FiltersAggregator.OTHER_BUCKET_KEY_FIELD.getPreferredName(), otherBucketKey).     builder.endObject().     return builder. }
false;public,static;2;81;;public static FiltersAggregationBuilder parse(String aggregationName, XContentParser parser) throws IOException {     List<FiltersAggregator.KeyedFilter> keyedFilters = null.     List<QueryBuilder> nonKeyedFilters = null.     XContentParser.Token token = null.     String currentFieldName = null.     String otherBucketKey = null.     Boolean otherBucket = null.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token == XContentParser.Token.VALUE_BOOLEAN) {             if (OTHER_BUCKET_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 otherBucket = parser.booleanValue().             } else {                 throw new ParsingException(parser.getTokenLocation(), "Unknown key for a " + token + " in [" + aggregationName + "]: [" + currentFieldName + "].").             }         } else if (token == XContentParser.Token.VALUE_STRING) {             if (OTHER_BUCKET_KEY_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 otherBucketKey = parser.text().             } else {                 throw new ParsingException(parser.getTokenLocation(), "Unknown key for a " + token + " in [" + aggregationName + "]: [" + currentFieldName + "].").             }         } else if (token == XContentParser.Token.START_OBJECT) {             if (FILTERS_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 keyedFilters = new ArrayList<>().                 String key = null.                 while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {                     if (token == XContentParser.Token.FIELD_NAME) {                         key = parser.currentName().                     } else {                         QueryBuilder filter = parseInnerQueryBuilder(parser).                         keyedFilters.add(new FiltersAggregator.KeyedFilter(key, filter)).                     }                 }             } else {                 throw new ParsingException(parser.getTokenLocation(), "Unknown key for a " + token + " in [" + aggregationName + "]: [" + currentFieldName + "].").             }         } else if (token == XContentParser.Token.START_ARRAY) {             if (FILTERS_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 nonKeyedFilters = new ArrayList<>().                 while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {                     QueryBuilder filter = parseInnerQueryBuilder(parser).                     nonKeyedFilters.add(filter).                 }             } else {                 throw new ParsingException(parser.getTokenLocation(), "Unknown key for a " + token + " in [" + aggregationName + "]: [" + currentFieldName + "].").             }         } else {             throw new ParsingException(parser.getTokenLocation(), "Unknown key for a " + token + " in [" + aggregationName + "]: [" + currentFieldName + "].").         }     }     if (otherBucket == null && otherBucketKey != null) {         // automatically enable the other bucket if a key is set, as per the doc         otherBucket = true.     }     FiltersAggregationBuilder factory.     if (keyedFilters != null) {         factory = new FiltersAggregationBuilder(aggregationName, keyedFilters.toArray(new FiltersAggregator.KeyedFilter[keyedFilters.size()])).     } else {         factory = new FiltersAggregationBuilder(aggregationName, nonKeyedFilters.toArray(new QueryBuilder[nonKeyedFilters.size()])).     }     if (otherBucket != null) {         factory.otherBucket(otherBucket).     }     if (otherBucketKey != null) {         factory.otherBucketKey(otherBucketKey).     }     return factory. }
false;protected;0;4;;@Override protected int doHashCode() {     return Objects.hash(filters, keyed, otherBucket, otherBucketKey). }
false;protected;1;8;;@Override protected boolean doEquals(Object obj) {     FiltersAggregationBuilder other = (FiltersAggregationBuilder) obj.     return Objects.equals(filters, other.filters) && Objects.equals(keyed, other.keyed) && Objects.equals(otherBucket, other.otherBucket) && Objects.equals(otherBucketKey, other.otherBucketKey). }
false;public;0;4;;@Override public String getType() {     return NAME. }
