commented;modifiers;parameterAmount;loc;comment;code
true;static;1;8;/**  * Create a scheduler that can be used client side. Server side, please use <code>ThreadPool.schedule</code> instead.  *  * Notice that if any scheduled jobs fail with an exception, these will bubble up to the uncaught exception handler where they will  * be logged as a warning. This includes jobs started using execute, submit and schedule.  * @param settings the settings to use  * @return executor  */ ;/**  * Create a scheduler that can be used client side. Server side, please use <code>ThreadPool.schedule</code> instead.  *  * Notice that if any scheduled jobs fail with an exception, these will bubble up to the uncaught exception handler where they will  * be logged as a warning. This includes jobs started using execute, submit and schedule.  * @param settings the settings to use  * @return executor  */ static ScheduledThreadPoolExecutor initScheduler(Settings settings) {     final ScheduledThreadPoolExecutor scheduler = new SafeScheduledThreadPoolExecutor(1, EsExecutors.daemonThreadFactory(settings, "scheduler"), new EsAbortPolicy()).     scheduler.setExecuteExistingDelayedTasksAfterShutdownPolicy(false).     scheduler.setContinueExistingPeriodicTasksAfterShutdownPolicy(false).     scheduler.setRemoveOnCancelPolicy(true).     return scheduler. }
false;static;3;9;;static boolean terminate(ScheduledThreadPoolExecutor scheduledThreadPoolExecutor, long timeout, TimeUnit timeUnit) {     scheduledThreadPoolExecutor.shutdown().     if (awaitTermination(scheduledThreadPoolExecutor, timeout, timeUnit)) {         return true.     }     // last resort     scheduledThreadPoolExecutor.shutdownNow().     return awaitTermination(scheduledThreadPoolExecutor, timeout, timeUnit). }
false;static;3;11;;static boolean awaitTermination(final ScheduledThreadPoolExecutor scheduledThreadPoolExecutor, final long timeout, final TimeUnit timeUnit) {     try {         if (scheduledThreadPoolExecutor.awaitTermination(timeout, timeUnit)) {             return true.         }     } catch (InterruptedException e) {         Thread.currentThread().interrupt().     }     return false. }
true;default;1;3;/**  * Does nothing by default but can be used by subclasses to save the current thread context and wraps the command in a Runnable  * that restores that context before running the command.  */ ;/**  * Does nothing by default but can be used by subclasses to save the current thread context and wraps the command in a Runnable  * that restores that context before running the command.  */ default Runnable preserveContext(Runnable command) {     return command. }
true;;3;1;/**  * Schedules a one-shot command to be run after a given delay. The command is not run in the context of the calling thread.  * To preserve the context of the calling thread you may call {@link #preserveContext(Runnable)} on the runnable before passing  * it to this method.  * The command runs on scheduler thread. Do not run blocking calls on the scheduler thread. Subclasses may allow  * to execute on a different executor, in which case blocking calls are allowed.  *  * @param command the command to run  * @param delay delay before the task executes  * @param executor the name of the executor that has to execute this task. Ignored in the default implementation but can be used  *                 by subclasses that support multiple executors.  * @return a ScheduledFuture who's get will return when the task has been added to its target thread pool and throws an exception if  *         the task is canceled before it was added to its target thread pool. Once the task has been added to its target thread pool  *         the ScheduledFuture cannot interact with it.  * @throws EsRejectedExecutionException if the task cannot be scheduled for execution  */ ;/**  * Schedules a one-shot command to be run after a given delay. The command is not run in the context of the calling thread.  * To preserve the context of the calling thread you may call {@link #preserveContext(Runnable)} on the runnable before passing  * it to this method.  * The command runs on scheduler thread. Do not run blocking calls on the scheduler thread. Subclasses may allow  * to execute on a different executor, in which case blocking calls are allowed.  *  * @param command the command to run  * @param delay delay before the task executes  * @param executor the name of the executor that has to execute this task. Ignored in the default implementation but can be used  *                 by subclasses that support multiple executors.  * @return a ScheduledFuture who's get will return when the task has been added to its target thread pool and throws an exception if  *         the task is canceled before it was added to its target thread pool. Once the task has been added to its target thread pool  *         the ScheduledFuture cannot interact with it.  * @throws EsRejectedExecutionException if the task cannot be scheduled for execution  */ ScheduledCancellable schedule(Runnable command, TimeValue delay, String executor).
true;default;3;3;/**  * Schedules a periodic action that runs on scheduler thread. Do not run blocking calls on the scheduler thread. Subclasses may allow  * to execute on a different executor, in which case blocking calls are allowed.  *  * @param command the action to take  * @param interval the delay interval  * @param executor the name of the executor that has to execute this task. Ignored in the default implementation but can be used  *                 by subclasses that support multiple executors.  * @return a {@link Cancellable} that can be used to cancel the subsequent runs of the command. If the command is running, it will  *         not be interrupted.  */ ;/**  * Schedules a periodic action that runs on scheduler thread. Do not run blocking calls on the scheduler thread. Subclasses may allow  * to execute on a different executor, in which case blocking calls are allowed.  *  * @param command the action to take  * @param interval the delay interval  * @param executor the name of the executor that has to execute this task. Ignored in the default implementation but can be used  *                 by subclasses that support multiple executors.  * @return a {@link Cancellable} that can be used to cancel the subsequent runs of the command. If the command is running, it will  *         not be interrupted.  */ default Cancellable scheduleWithFixedDelay(Runnable command, TimeValue interval, String executor) {     return new ReschedulingRunnable(command, interval, executor, this, (e) -> {     }, (e) -> {     }). }
true;static;1;3;/**  * Utility method to wrap a <code>Future</code> as a <code>Cancellable</code>  * @param future the future to wrap  * @return a cancellable delegating to the future  */ ;/**  * Utility method to wrap a <code>Future</code> as a <code>Cancellable</code>  * @param future the future to wrap  * @return a cancellable delegating to the future  */ static Cancellable wrapAsCancellable(Future<?> future) {     return new CancellableAdapter(future). }
true;static;1;3;/**  * Utility method to wrap a <code>ScheduledFuture</code> as a <code>ScheduledCancellable</code>  * @param scheduledFuture the scheduled future to wrap  * @return a SchedulecCancellable delegating to the scheduledFuture  */ ;/**  * Utility method to wrap a <code>ScheduledFuture</code> as a <code>ScheduledCancellable</code>  * @param scheduledFuture the scheduled future to wrap  * @return a SchedulecCancellable delegating to the scheduledFuture  */ static ScheduledCancellable wrapAsScheduledCancellable(ScheduledFuture<?> scheduledFuture) {     return new ScheduledCancellableAdapter(scheduledFuture). }
true;;0;1;/**  * Cancel the execution of this object. This method is idempotent.  */ ;/**  * Cancel the execution of this object. This method is idempotent.  */ boolean cancel().
true;;0;1;/**  * Check if the execution has been cancelled  * @return true if cancelled  */ ;/**  * Check if the execution has been cancelled  * @return true if cancelled  */ boolean isCancelled().
false;public;0;6;;@Override public boolean cancel() {     final boolean result = run.     run = false.     return result. }
false;public;0;4;;@Override public boolean isCancelled() {     return run == false. }
false;public;0;7;;@Override public void doRun() {     // always check run here since this may have been cancelled since the last execution and we do not want to run     if (run) {         runnable.run().     } }
false;public;1;4;;@Override public void onFailure(Exception e) {     failureConsumer.accept(e). }
false;public;1;5;;@Override public void onRejection(Exception e) {     run = false.     rejectionConsumer.accept(e). }
false;public;0;11;;@Override public void onAfter() {     // if this has not been cancelled reschedule it to run again     if (run) {         try {             scheduler.schedule(this, interval, executor).         } catch (final EsRejectedExecutionException e) {             onRejection(e).         }     } }
false;protected;2;7;;@Override protected void afterExecute(Runnable r, Throwable t) {     if (t != null)         return.     // Scheduler only allows Runnable's so we expect no checked exceptions here. If anyone uses submit directly on `this`, we     // accept the wrapped exception in the output.     ExceptionsHelper.reThrowIfNotNull(EsExecutors.rethrowErrors(r)). }
