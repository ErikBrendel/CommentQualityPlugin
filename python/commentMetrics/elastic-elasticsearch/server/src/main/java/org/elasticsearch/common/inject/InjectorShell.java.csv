commented;modifiers;parameterAmount;loc;comment;code
false;;0;3;;InjectorImpl getInjector() {     return injector. }
false;;0;3;;List<Element> getElements() {     return elements. }
false;;1;5;;Builder parent(InjectorImpl parent) {     this.parent = parent.     this.state = new InheritingState(parent.state).     return this. }
false;;1;4;;Builder stage(Stage stage) {     this.stage = stage.     return this. }
false;;1;5;;Builder privateElements(PrivateElements privateElements) {     this.privateElements = (PrivateElementsImpl) privateElements.     this.elements.addAll(privateElements.getElements()).     return this. }
false;;1;5;;void addModules(Iterable<? extends Module> modules) {     for (Module module : modules) {         this.modules.add(module).     } }
true;;0;3;/**  * Synchronize on this before calling {@link #build}.  */ ;/**  * Synchronize on this before calling {@link #build}.  */ Object lock() {     return getState().lock(). }
true;;4;57;/**  * Creates and returns the injector shells for the current modules. Multiple shells will be  * returned if any modules contain {@link Binder#newPrivateBinder private environments}. The  * primary injector will be first in the returned list.  */ ;/**  * Creates and returns the injector shells for the current modules. Multiple shells will be  * returned if any modules contain {@link Binder#newPrivateBinder private environments}. The  * primary injector will be first in the returned list.  */ List<InjectorShell> build(Initializer initializer, BindingProcessor bindingProcessor, Stopwatch stopwatch, Errors errors) {     if (stage == null) {         throw new IllegalStateException("Stage not initialized").     }     if (privateElements != null && parent == null) {         throw new IllegalStateException("PrivateElements with no parent").     }     if (state == null) {         throw new IllegalStateException("no state. Did you remember to lock() ?").     }     InjectorImpl injector = new InjectorImpl(state, initializer).     if (privateElements != null) {         privateElements.initInjector(injector).     }     // bind Stage and Singleton if this is a top-level injector     if (parent == null) {         modules.add(0, new RootModule(stage)).         new TypeConverterBindingProcessor(errors).prepareBuiltInConverters(injector).     }     elements.addAll(Elements.getElements(stage, modules)).     stopwatch.resetAndLog("Module execution").     new MessageProcessor(errors).process(injector, elements).     new TypeListenerBindingProcessor(errors).process(injector, elements).     List<TypeListenerBinding> listenerBindings = injector.state.getTypeListenerBindings().     injector.membersInjectorStore = new MembersInjectorStore(injector, listenerBindings).     stopwatch.resetAndLog("TypeListeners creation").     new ScopeBindingProcessor(errors).process(injector, elements).     stopwatch.resetAndLog("Scopes creation").     new TypeConverterBindingProcessor(errors).process(injector, elements).     stopwatch.resetAndLog("Converters creation").     bindInjector(injector).     bindLogger(injector).     bindingProcessor.process(injector, elements).     stopwatch.resetAndLog("Binding creation").     List<InjectorShell> injectorShells = new ArrayList<>().     injectorShells.add(new InjectorShell(elements, injector)).     // recursively build child shells     PrivateElementProcessor processor = new PrivateElementProcessor(errors, stage).     processor.process(injector, elements).     for (Builder builder : processor.getInjectorShellBuilders()) {         injectorShells.addAll(builder.build(initializer, bindingProcessor, stopwatch, errors)).     }     stopwatch.resetAndLog("Private environment creation").     return injectorShells. }
false;private;0;6;;private State getState() {     if (state == null) {         state = new InheritingState(State.NONE).     }     return state. }
true;private,static;1;8;/**  * The Injector is a special case because we allow both parent and child injectors to both have  * a binding for that key.  */ ;/**  * The Injector is a special case because we allow both parent and child injectors to both have  * a binding for that key.  */ private static void bindInjector(InjectorImpl injector) {     Key<Injector> key = Key.get(Injector.class).     InjectorFactory injectorFactory = new InjectorFactory(injector).     injector.state.putBinding(key, new ProviderInstanceBindingImpl<>(injector, key, SourceProvider.UNKNOWN_SOURCE, injectorFactory, Scoping.UNSCOPED, injectorFactory, emptySet())). }
false;public;3;5;;@Override public Injector get(Errors errors, InternalContext context, Dependency<?> dependency) throws ErrorsException {     return injector. }
false;public;0;4;;@Override public Injector get() {     return injector. }
false;public;0;4;;@Override public String toString() {     return "Provider<Injector>". }
true;private,static;1;8;/**  * The Logger is a special case because it knows the injection point of the injected member. It's  * the only binding that does this.  */ ;/**  * The Logger is a special case because it knows the injection point of the injected member. It's  * the only binding that does this.  */ private static void bindLogger(InjectorImpl injector) {     Key<Logger> key = Key.get(Logger.class).     LoggerFactory loggerFactory = new LoggerFactory().     injector.state.putBinding(key, new ProviderInstanceBindingImpl<>(injector, key, SourceProvider.UNKNOWN_SOURCE, loggerFactory, Scoping.UNSCOPED, loggerFactory, emptySet())). }
false;public;3;7;;@Override public Logger get(Errors errors, InternalContext context, Dependency<?> dependency) {     InjectionPoint injectionPoint = dependency.getInjectionPoint().     return injectionPoint == null ? Logger.getAnonymousLogger() : Logger.getLogger(injectionPoint.getMember().getDeclaringClass().getName()). }
false;public;0;4;;@Override public Logger get() {     return Logger.getAnonymousLogger(). }
false;public;0;4;;@Override public String toString() {     return "Provider<Logger>". }
false;public;1;6;;@Override public void configure(Binder binder) {     binder = binder.withSource(SourceProvider.UNKNOWN_SOURCE).     binder.bind(Stage.class).toInstance(stage).     binder.bindScope(Singleton.class, SINGLETON). }
