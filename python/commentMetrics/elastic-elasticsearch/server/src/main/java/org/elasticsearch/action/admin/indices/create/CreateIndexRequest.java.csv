commented;modifiers;parameterAmount;loc;comment;code
false;public;0;8;;@Override public ActionRequestValidationException validate() {     ActionRequestValidationException validationException = null.     if (index == null) {         validationException = addValidationError("index is missing", validationException).     }     return validationException. }
false;public;0;4;;@Override public String[] indices() {     return new String[] { index }. }
false;public;0;4;;@Override public IndicesOptions indicesOptions() {     return IndicesOptions.strictSingleIndexNoExpandForbidClosed(). }
true;public;0;3;/**  * The index name to create.  */ ;/**  * The index name to create.  */ public String index() {     return index. }
false;public;1;4;;public CreateIndexRequest index(String index) {     this.index = index.     return this. }
true;public;0;3;/**  * The settings to create the index with.  */ ;/**  * The settings to create the index with.  */ public Settings settings() {     return settings. }
true;public;0;3;/**  * The cause for this index creation.  */ ;/**  * The cause for this index creation.  */ public String cause() {     return cause. }
true;public;1;4;/**  * The settings to create the index with.  */ ;/**  * The settings to create the index with.  */ public CreateIndexRequest settings(Settings.Builder settings) {     this.settings = settings.build().     return this. }
true;public;1;4;/**  * The settings to create the index with.  */ ;/**  * The settings to create the index with.  */ public CreateIndexRequest settings(Settings settings) {     this.settings = settings.     return this. }
true;public;2;4;/**  * The settings to create the index with (either json or yaml format)  */ ;/**  * The settings to create the index with (either json or yaml format)  */ public CreateIndexRequest settings(String source, XContentType xContentType) {     this.settings = Settings.builder().loadFromSource(source, xContentType).build().     return this. }
true;public;1;4;/**  * Allows to set the settings using a json builder.  */ ;/**  * Allows to set the settings using a json builder.  */ public CreateIndexRequest settings(XContentBuilder builder) {     settings(Strings.toString(builder), builder.contentType()).     return this. }
true;public;1;10;/**  * The settings to create the index with (either json/yaml/properties format)  */ ;/**  * The settings to create the index with (either json/yaml/properties format)  */ public CreateIndexRequest settings(Map<String, ?> source) {     try {         XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON).         builder.map(source).         settings(Strings.toString(builder), XContentType.JSON).     } catch (IOException e) {         throw new ElasticsearchGenerationException("Failed to generate [" + source + "]", e).     }     return this. }
true;public;3;3;/**  * Adds mapping that will be added when the index gets created.  *  * @param type   The mapping type  * @param source The mapping source  * @param xContentType The content type of the source  */ ;/**  * Adds mapping that will be added when the index gets created.  *  * @param type   The mapping type  * @param source The mapping source  * @param xContentType The content type of the source  */ public CreateIndexRequest mapping(String type, String source, XContentType xContentType) {     return mapping(type, new BytesArray(source), xContentType). }
true;private;3;12;/**  * Adds mapping that will be added when the index gets created.  *  * @param type   The mapping type  * @param source The mapping source  * @param xContentType the content type of the mapping source  */ ;/**  * Adds mapping that will be added when the index gets created.  *  * @param type   The mapping type  * @param source The mapping source  * @param xContentType the content type of the mapping source  */ private CreateIndexRequest mapping(String type, BytesReference source, XContentType xContentType) {     if (mappings.containsKey(type)) {         throw new IllegalStateException("mappings for type \"" + type + "\" were already defined").     }     Objects.requireNonNull(xContentType).     try {         mappings.put(type, XContentHelper.convertToJson(source, false, false, xContentType)).         return this.     } catch (IOException e) {         throw new UncheckedIOException("failed to convert to json", e).     } }
true;public;1;4;/**  * The cause for this index creation.  */ ;/**  * The cause for this index creation.  */ public CreateIndexRequest cause(String cause) {     this.cause = cause.     return this. }
true;public;2;3;/**  * Adds mapping that will be added when the index gets created.  *  * @param type   The mapping type  * @param source The mapping source  */ ;/**  * Adds mapping that will be added when the index gets created.  *  * @param type   The mapping type  * @param source The mapping source  */ public CreateIndexRequest mapping(String type, XContentBuilder source) {     return mapping(type, BytesReference.bytes(source), source.contentType()). }
true;public;2;16;/**  * Adds mapping that will be added when the index gets created.  *  * @param type   The mapping type  * @param source The mapping source  */ ;/**  * Adds mapping that will be added when the index gets created.  *  * @param type   The mapping type  * @param source The mapping source  */ public CreateIndexRequest mapping(String type, Map<String, ?> source) {     if (mappings.containsKey(type)) {         throw new IllegalStateException("mappings for type \"" + type + "\" were already defined").     }     // wrap it in a type map if its not     if (source.size() != 1 || !source.containsKey(type)) {         source = MapBuilder.<String, Object>newMapBuilder().put(type, source).map().     }     try {         XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON).         builder.map(source).         return mapping(type, builder).     } catch (IOException e) {         throw new ElasticsearchGenerationException("Failed to generate [" + source + "]", e).     } }
true;public;2;4;/**  * A specialized simplified mapping source method, takes the form of simple properties definition:  * ("field1", "type=string,store=true").  */ ;/**  * A specialized simplified mapping source method, takes the form of simple properties definition:  * ("field1", "type=string,store=true").  */ public CreateIndexRequest mapping(String type, Object... source) {     mapping(type, PutMappingRequest.buildFromSimplifiedDef(type, source)).     return this. }
true;public;1;9;/**  * Sets the aliases that will be associated with the index when it gets created  */ ;/**  * Sets the aliases that will be associated with the index when it gets created  */ public CreateIndexRequest aliases(Map<String, ?> source) {     try {         XContentBuilder builder = XContentFactory.jsonBuilder().         builder.map(source).         return aliases(BytesReference.bytes(builder)).     } catch (IOException e) {         throw new ElasticsearchGenerationException("Failed to generate [" + source + "]", e).     } }
true;public;1;3;/**  * Sets the aliases that will be associated with the index when it gets created  */ ;/**  * Sets the aliases that will be associated with the index when it gets created  */ public CreateIndexRequest aliases(XContentBuilder source) {     return aliases(BytesReference.bytes(source)). }
true;public;1;3;/**  * Sets the aliases that will be associated with the index when it gets created  */ ;/**  * Sets the aliases that will be associated with the index when it gets created  */ public CreateIndexRequest aliases(String source) {     return aliases(new BytesArray(source)). }
true;public;1;14;/**  * Sets the aliases that will be associated with the index when it gets created  */ ;/**  * Sets the aliases that will be associated with the index when it gets created  */ public CreateIndexRequest aliases(BytesReference source) {     // EMPTY is safe here because we never call namedObject     try (XContentParser parser = XContentHelper.createParser(NamedXContentRegistry.EMPTY, LoggingDeprecationHandler.INSTANCE, source)) {         // move to the first alias         parser.nextToken().         while ((parser.nextToken()) != XContentParser.Token.END_OBJECT) {             alias(Alias.fromXContent(parser)).         }         return this.     } catch (IOException e) {         throw new ElasticsearchParseException("Failed to parse aliases", e).     } }
true;public;1;4;/**  * Adds an alias that will be associated with the index when it gets created  */ ;/**  * Adds an alias that will be associated with the index when it gets created  */ public CreateIndexRequest alias(Alias alias) {     this.aliases.add(alias).     return this. }
true;public;2;3;/**  * Sets the settings and mappings as a single source.  */ ;/**  * Sets the settings and mappings as a single source.  */ public CreateIndexRequest source(String source, XContentType xContentType) {     return source(new BytesArray(source), xContentType). }
true;public;1;3;/**  * Sets the settings and mappings as a single source.  */ ;/**  * Sets the settings and mappings as a single source.  */ public CreateIndexRequest source(XContentBuilder source) {     return source(BytesReference.bytes(source), source.contentType()). }
true;public;2;3;/**  * Sets the settings and mappings as a single source.  */ ;/**  * Sets the settings and mappings as a single source.  */ public CreateIndexRequest source(byte[] source, XContentType xContentType) {     return source(source, 0, source.length, xContentType). }
true;public;4;3;/**  * Sets the settings and mappings as a single source.  */ ;/**  * Sets the settings and mappings as a single source.  */ public CreateIndexRequest source(byte[] source, int offset, int length, XContentType xContentType) {     return source(new BytesArray(source, offset, length), xContentType). }
true;public;2;5;/**  * Sets the settings and mappings as a single source.  */ ;/**  * Sets the settings and mappings as a single source.  */ public CreateIndexRequest source(BytesReference source, XContentType xContentType) {     Objects.requireNonNull(xContentType).     source(XContentHelper.convertToMap(source, false, xContentType).v2(), LoggingDeprecationHandler.INSTANCE).     return this. }
true;public;2;19;/**  * Sets the settings and mappings as a single source.  */ ;/**  * Sets the settings and mappings as a single source.  */ @SuppressWarnings("unchecked") public CreateIndexRequest source(Map<String, ?> source, DeprecationHandler deprecationHandler) {     for (Map.Entry<String, ?> entry : source.entrySet()) {         String name = entry.getKey().         if (SETTINGS.match(name, deprecationHandler)) {             settings((Map<String, Object>) entry.getValue()).         } else if (MAPPINGS.match(name, deprecationHandler)) {             Map<String, Object> mappings = (Map<String, Object>) entry.getValue().             for (Map.Entry<String, Object> entry1 : mappings.entrySet()) {                 mapping(entry1.getKey(), (Map<String, Object>) entry1.getValue()).             }         } else if (ALIASES.match(name, deprecationHandler)) {             aliases((Map<String, Object>) entry.getValue()).         } else {             throw new ElasticsearchParseException("unknown key [{}] for create index", name).         }     }     return this. }
false;public;0;3;;public Map<String, String> mappings() {     return this.mappings. }
false;public;0;3;;public Set<Alias> aliases() {     return this.aliases. }
false;public;0;3;;public ActiveShardCount waitForActiveShards() {     return waitForActiveShards. }
true;public;1;4;/**  * Sets the number of shard copies that should be active for index creation to return.  * Defaults to {@link ActiveShardCount#DEFAULT}, which will wait for one shard copy  * (the primary) to become active. Set this value to {@link ActiveShardCount#ALL} to  * wait for all shards (primary and all replicas) to be active before returning.  * Otherwise, use {@link ActiveShardCount#from(int)} to set this value to any  * non-negative integer, up to the number of copies per shard (number of replicas + 1),  * to wait for the desired amount of shard copies to become active before returning.  * Index creation will only wait up until the timeout value for the number of shard copies  * to be active before returning.  Check {@link CreateIndexResponse#isShardsAcknowledged()} to  * determine if the requisite shard copies were all started before returning or timing out.  *  * @param waitForActiveShards number of active shard copies to wait on  */ ;/**  * Sets the number of shard copies that should be active for index creation to return.  * Defaults to {@link ActiveShardCount#DEFAULT}, which will wait for one shard copy  * (the primary) to become active. Set this value to {@link ActiveShardCount#ALL} to  * wait for all shards (primary and all replicas) to be active before returning.  * Otherwise, use {@link ActiveShardCount#from(int)} to set this value to any  * non-negative integer, up to the number of copies per shard (number of replicas + 1),  * to wait for the desired amount of shard copies to become active before returning.  * Index creation will only wait up until the timeout value for the number of shard copies  * to be active before returning.  Check {@link CreateIndexResponse#isShardsAcknowledged()} to  * determine if the requisite shard copies were all started before returning or timing out.  *  * @param waitForActiveShards number of active shard copies to wait on  */ public CreateIndexRequest waitForActiveShards(ActiveShardCount waitForActiveShards) {     this.waitForActiveShards = waitForActiveShards.     return this. }
true;public;1;3;/**  * A shortcut for {@link #waitForActiveShards(ActiveShardCount)} where the numerical  * shard count is passed in, instead of having to first call {@link ActiveShardCount#from(int)}  * to get the ActiveShardCount.  */ ;/**  * A shortcut for {@link #waitForActiveShards(ActiveShardCount)} where the numerical  * shard count is passed in, instead of having to first call {@link ActiveShardCount#from(int)}  * to get the ActiveShardCount.  */ public CreateIndexRequest waitForActiveShards(final int waitForActiveShards) {     return waitForActiveShards(ActiveShardCount.from(waitForActiveShards)). }
false;public;1;33;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     cause = in.readString().     index = in.readString().     settings = readSettingsFromStream(in).     int size = in.readVInt().     for (int i = 0. i < size. i++) {         final String type = in.readString().         String source = in.readString().         if (in.getVersion().before(Version.V_6_0_0_alpha1)) {             // TODO change to 5.3.0 after backport             // we do not know the content type that comes from earlier versions so we autodetect and convert             source = XContentHelper.convertToJson(new BytesArray(source), false, false, XContentFactory.xContentType(source)).         }         mappings.put(type, source).     }     if (in.getVersion().before(Version.V_6_5_0)) {         // This used to be the size of custom metadata classes         int customSize = in.readVInt().         assert customSize == 0 : "unexpected custom metadata when none is supported".         if (customSize > 0) {             throw new IllegalStateException("unexpected custom metadata when none is supported").         }     }     int aliasesSize = in.readVInt().     for (int i = 0. i < aliasesSize. i++) {         aliases.add(Alias.read(in)).     }     if (in.getVersion().before(Version.V_7_0_0)) {         // updateAllTypes         in.readBoolean().     }     waitForActiveShards = ActiveShardCount.readFrom(in). }
false;public;1;24;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeString(cause).     out.writeString(index).     writeSettingsToStream(settings, out).     out.writeVInt(mappings.size()).     for (Map.Entry<String, String> entry : mappings.entrySet()) {         out.writeString(entry.getKey()).         out.writeString(entry.getValue()).     }     if (out.getVersion().before(Version.V_6_5_0)) {         // Size of custom index metadata, which is removed         out.writeVInt(0).     }     out.writeVInt(aliases.size()).     for (Alias alias : aliases) {         alias.writeTo(out).     }     if (out.getVersion().before(Version.V_7_0_0)) {         // updateAllTypes         out.writeBoolean(true).     }     waitForActiveShards.writeTo(out). }
false;public;2;7;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     innerToXContent(builder, params).     builder.endObject().     return builder. }
false;public;2;20;;public XContentBuilder innerToXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject(SETTINGS.getPreferredName()).     settings.toXContent(builder, params).     builder.endObject().     builder.startObject(MAPPINGS.getPreferredName()).     for (Map.Entry<String, String> entry : mappings.entrySet()) {         try (InputStream stream = new BytesArray(entry.getValue()).streamInput()) {             builder.rawField(entry.getKey(), stream, XContentType.JSON).         }     }     builder.endObject().     builder.startObject(ALIASES.getPreferredName()).     for (Alias alias : aliases) {         alias.toXContent(builder, params).     }     builder.endObject().     return builder. }
