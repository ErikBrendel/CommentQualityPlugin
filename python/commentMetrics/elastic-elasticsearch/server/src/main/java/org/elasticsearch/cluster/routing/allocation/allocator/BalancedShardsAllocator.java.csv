# id;timestamp;commentText;codeText;commentWords;codeWords
BalancedShardsAllocator -> Balancer -> public float avgShardsPerNode(String index);1524684173;Returns the average of shards per node for the given index;public float avgShardsPerNode(String index) {_            return ((float) metaData.index(index).getTotalNumberOfShards()) / nodes.size()__        };returns,the,average,of,shards,per,node,for,the,given,index;public,float,avg,shards,per,node,string,index,return,float,meta,data,index,index,get,total,number,of,shards,nodes,size
BalancedShardsAllocator -> Balancer -> public float avgShardsPerNode(String index);1525334055;Returns the average of shards per node for the given index;public float avgShardsPerNode(String index) {_            return ((float) metaData.index(index).getTotalNumberOfShards()) / nodes.size()__        };returns,the,average,of,shards,per,node,for,the,given,index;public,float,avg,shards,per,node,string,index,return,float,meta,data,index,index,get,total,number,of,shards,nodes,size
BalancedShardsAllocator -> Balancer -> public float avgShardsPerNode(String index);1531234550;Returns the average of shards per node for the given index;public float avgShardsPerNode(String index) {_            return ((float) metaData.index(index).getTotalNumberOfShards()) / nodes.size()__        };returns,the,average,of,shards,per,node,for,the,given,index;public,float,avg,shards,per,node,string,index,return,float,meta,data,index,index,get,total,number,of,shards,nodes,size
BalancedShardsAllocator -> Balancer -> public float avgShardsPerNode(String index);1540847035;Returns the average of shards per node for the given index;public float avgShardsPerNode(String index) {_            return ((float) metaData.index(index).getTotalNumberOfShards()) / nodes.size()__        };returns,the,average,of,shards,per,node,for,the,given,index;public,float,avg,shards,per,node,string,index,return,float,meta,data,index,index,get,total,number,of,shards,nodes,size
BalancedShardsAllocator -> Balancer -> public float avgShardsPerNode(String index);1541092382;Returns the average of shards per node for the given index;public float avgShardsPerNode(String index) {_            return ((float) metaData.index(index).getTotalNumberOfShards()) / nodes.size()__        };returns,the,average,of,shards,per,node,for,the,given,index;public,float,avg,shards,per,node,string,index,return,float,meta,data,index,index,get,total,number,of,shards,nodes,size
BalancedShardsAllocator -> Balancer -> public float avgShardsPerNode(String index);1541446827;Returns the average of shards per node for the given index;public float avgShardsPerNode(String index) {_            return ((float) metaData.index(index).getTotalNumberOfShards()) / nodes.size()__        };returns,the,average,of,shards,per,node,for,the,given,index;public,float,avg,shards,per,node,string,index,return,float,meta,data,index,index,get,total,number,of,shards,nodes,size
BalancedShardsAllocator -> Balancer -> public float avgShardsPerNode(String index);1542402632;Returns the average of shards per node for the given index;public float avgShardsPerNode(String index) {_            return ((float) metaData.index(index).getTotalNumberOfShards()) / nodes.size()__        };returns,the,average,of,shards,per,node,for,the,given,index;public,float,avg,shards,per,node,string,index,return,float,meta,data,index,index,get,total,number,of,shards,nodes,size
BalancedShardsAllocator -> Balancer -> public float avgShardsPerNode(String index);1549912434;Returns the average of shards per node for the given index;public float avgShardsPerNode(String index) {_            return ((float) metaData.index(index).getTotalNumberOfShards()) / nodes.size()__        };returns,the,average,of,shards,per,node,for,the,given,index;public,float,avg,shards,per,node,string,index,return,float,meta,data,index,index,get,total,number,of,shards,nodes,size
BalancedShardsAllocator -> Balancer -> private Map<String, ModelNode> buildModelFromAssigned();1524684173;Builds the internal model from all shards in the given_{@link Iterable}. All shards in the {@link Iterable} must be assigned_to a node. This method will skip shards in the state_{@link ShardRoutingState#RELOCATING} since each relocating shard has_a shadow shard in the state {@link ShardRoutingState#INITIALIZING}_on the target node which we respect during the allocation / balancing_process. In short, this method recreates the status-quo in the cluster.;private Map<String, ModelNode> buildModelFromAssigned() {_            Map<String, ModelNode> nodes = new HashMap<>()__            for (RoutingNode rn : routingNodes) {_                ModelNode node = new ModelNode(rn)__                nodes.put(rn.nodeId(), node)__                for (ShardRouting shard : rn) {_                    assert rn.nodeId().equals(shard.currentNodeId())__                    _                    if (shard.state() != RELOCATING) {_                        node.addShard(shard)__                        if (logger.isTraceEnabled()) {_                            logger.trace("Assigned shard [{}] to node [{}]", shard, node.getNodeId())__                        }_                    }_                }_            }_            return nodes__        };builds,the,internal,model,from,all,shards,in,the,given,link,iterable,all,shards,in,the,link,iterable,must,be,assigned,to,a,node,this,method,will,skip,shards,in,the,state,link,shard,routing,state,relocating,since,each,relocating,shard,has,a,shadow,shard,in,the,state,link,shard,routing,state,initializing,on,the,target,node,which,we,respect,during,the,allocation,balancing,process,in,short,this,method,recreates,the,status,quo,in,the,cluster;private,map,string,model,node,build,model,from,assigned,map,string,model,node,nodes,new,hash,map,for,routing,node,rn,routing,nodes,model,node,node,new,model,node,rn,nodes,put,rn,node,id,node,for,shard,routing,shard,rn,assert,rn,node,id,equals,shard,current,node,id,if,shard,state,relocating,node,add,shard,shard,if,logger,is,trace,enabled,logger,trace,assigned,shard,to,node,shard,node,get,node,id,return,nodes
BalancedShardsAllocator -> Balancer -> private Map<String, ModelNode> buildModelFromAssigned();1525334055;Builds the internal model from all shards in the given_{@link Iterable}. All shards in the {@link Iterable} must be assigned_to a node. This method will skip shards in the state_{@link ShardRoutingState#RELOCATING} since each relocating shard has_a shadow shard in the state {@link ShardRoutingState#INITIALIZING}_on the target node which we respect during the allocation / balancing_process. In short, this method recreates the status-quo in the cluster.;private Map<String, ModelNode> buildModelFromAssigned() {_            Map<String, ModelNode> nodes = new HashMap<>()__            for (RoutingNode rn : routingNodes) {_                ModelNode node = new ModelNode(rn)__                nodes.put(rn.nodeId(), node)__                for (ShardRouting shard : rn) {_                    assert rn.nodeId().equals(shard.currentNodeId())__                    _                    if (shard.state() != RELOCATING) {_                        node.addShard(shard)__                        if (logger.isTraceEnabled()) {_                            logger.trace("Assigned shard [{}] to node [{}]", shard, node.getNodeId())__                        }_                    }_                }_            }_            return nodes__        };builds,the,internal,model,from,all,shards,in,the,given,link,iterable,all,shards,in,the,link,iterable,must,be,assigned,to,a,node,this,method,will,skip,shards,in,the,state,link,shard,routing,state,relocating,since,each,relocating,shard,has,a,shadow,shard,in,the,state,link,shard,routing,state,initializing,on,the,target,node,which,we,respect,during,the,allocation,balancing,process,in,short,this,method,recreates,the,status,quo,in,the,cluster;private,map,string,model,node,build,model,from,assigned,map,string,model,node,nodes,new,hash,map,for,routing,node,rn,routing,nodes,model,node,node,new,model,node,rn,nodes,put,rn,node,id,node,for,shard,routing,shard,rn,assert,rn,node,id,equals,shard,current,node,id,if,shard,state,relocating,node,add,shard,shard,if,logger,is,trace,enabled,logger,trace,assigned,shard,to,node,shard,node,get,node,id,return,nodes
BalancedShardsAllocator -> Balancer -> private Map<String, ModelNode> buildModelFromAssigned();1531234550;Builds the internal model from all shards in the given_{@link Iterable}. All shards in the {@link Iterable} must be assigned_to a node. This method will skip shards in the state_{@link ShardRoutingState#RELOCATING} since each relocating shard has_a shadow shard in the state {@link ShardRoutingState#INITIALIZING}_on the target node which we respect during the allocation / balancing_process. In short, this method recreates the status-quo in the cluster.;private Map<String, ModelNode> buildModelFromAssigned() {_            Map<String, ModelNode> nodes = new HashMap<>()__            for (RoutingNode rn : routingNodes) {_                ModelNode node = new ModelNode(rn)__                nodes.put(rn.nodeId(), node)__                for (ShardRouting shard : rn) {_                    assert rn.nodeId().equals(shard.currentNodeId())__                    _                    if (shard.state() != RELOCATING) {_                        node.addShard(shard)__                        if (logger.isTraceEnabled()) {_                            logger.trace("Assigned shard [{}] to node [{}]", shard, node.getNodeId())__                        }_                    }_                }_            }_            return nodes__        };builds,the,internal,model,from,all,shards,in,the,given,link,iterable,all,shards,in,the,link,iterable,must,be,assigned,to,a,node,this,method,will,skip,shards,in,the,state,link,shard,routing,state,relocating,since,each,relocating,shard,has,a,shadow,shard,in,the,state,link,shard,routing,state,initializing,on,the,target,node,which,we,respect,during,the,allocation,balancing,process,in,short,this,method,recreates,the,status,quo,in,the,cluster;private,map,string,model,node,build,model,from,assigned,map,string,model,node,nodes,new,hash,map,for,routing,node,rn,routing,nodes,model,node,node,new,model,node,rn,nodes,put,rn,node,id,node,for,shard,routing,shard,rn,assert,rn,node,id,equals,shard,current,node,id,if,shard,state,relocating,node,add,shard,shard,if,logger,is,trace,enabled,logger,trace,assigned,shard,to,node,shard,node,get,node,id,return,nodes
BalancedShardsAllocator -> Balancer -> private Map<String, ModelNode> buildModelFromAssigned();1540847035;Builds the internal model from all shards in the given_{@link Iterable}. All shards in the {@link Iterable} must be assigned_to a node. This method will skip shards in the state_{@link ShardRoutingState#RELOCATING} since each relocating shard has_a shadow shard in the state {@link ShardRoutingState#INITIALIZING}_on the target node which we respect during the allocation / balancing_process. In short, this method recreates the status-quo in the cluster.;private Map<String, ModelNode> buildModelFromAssigned() {_            Map<String, ModelNode> nodes = new HashMap<>()__            for (RoutingNode rn : routingNodes) {_                ModelNode node = new ModelNode(rn)__                nodes.put(rn.nodeId(), node)__                for (ShardRouting shard : rn) {_                    assert rn.nodeId().equals(shard.currentNodeId())__                    _                    if (shard.state() != RELOCATING) {_                        node.addShard(shard)__                        if (logger.isTraceEnabled()) {_                            logger.trace("Assigned shard [{}] to node [{}]", shard, node.getNodeId())__                        }_                    }_                }_            }_            return nodes__        };builds,the,internal,model,from,all,shards,in,the,given,link,iterable,all,shards,in,the,link,iterable,must,be,assigned,to,a,node,this,method,will,skip,shards,in,the,state,link,shard,routing,state,relocating,since,each,relocating,shard,has,a,shadow,shard,in,the,state,link,shard,routing,state,initializing,on,the,target,node,which,we,respect,during,the,allocation,balancing,process,in,short,this,method,recreates,the,status,quo,in,the,cluster;private,map,string,model,node,build,model,from,assigned,map,string,model,node,nodes,new,hash,map,for,routing,node,rn,routing,nodes,model,node,node,new,model,node,rn,nodes,put,rn,node,id,node,for,shard,routing,shard,rn,assert,rn,node,id,equals,shard,current,node,id,if,shard,state,relocating,node,add,shard,shard,if,logger,is,trace,enabled,logger,trace,assigned,shard,to,node,shard,node,get,node,id,return,nodes
BalancedShardsAllocator -> Balancer -> private Map<String, ModelNode> buildModelFromAssigned();1541092382;Builds the internal model from all shards in the given_{@link Iterable}. All shards in the {@link Iterable} must be assigned_to a node. This method will skip shards in the state_{@link ShardRoutingState#RELOCATING} since each relocating shard has_a shadow shard in the state {@link ShardRoutingState#INITIALIZING}_on the target node which we respect during the allocation / balancing_process. In short, this method recreates the status-quo in the cluster.;private Map<String, ModelNode> buildModelFromAssigned() {_            Map<String, ModelNode> nodes = new HashMap<>()__            for (RoutingNode rn : routingNodes) {_                ModelNode node = new ModelNode(rn)__                nodes.put(rn.nodeId(), node)__                for (ShardRouting shard : rn) {_                    assert rn.nodeId().equals(shard.currentNodeId())__                    _                    if (shard.state() != RELOCATING) {_                        node.addShard(shard)__                        if (logger.isTraceEnabled()) {_                            logger.trace("Assigned shard [{}] to node [{}]", shard, node.getNodeId())__                        }_                    }_                }_            }_            return nodes__        };builds,the,internal,model,from,all,shards,in,the,given,link,iterable,all,shards,in,the,link,iterable,must,be,assigned,to,a,node,this,method,will,skip,shards,in,the,state,link,shard,routing,state,relocating,since,each,relocating,shard,has,a,shadow,shard,in,the,state,link,shard,routing,state,initializing,on,the,target,node,which,we,respect,during,the,allocation,balancing,process,in,short,this,method,recreates,the,status,quo,in,the,cluster;private,map,string,model,node,build,model,from,assigned,map,string,model,node,nodes,new,hash,map,for,routing,node,rn,routing,nodes,model,node,node,new,model,node,rn,nodes,put,rn,node,id,node,for,shard,routing,shard,rn,assert,rn,node,id,equals,shard,current,node,id,if,shard,state,relocating,node,add,shard,shard,if,logger,is,trace,enabled,logger,trace,assigned,shard,to,node,shard,node,get,node,id,return,nodes
BalancedShardsAllocator -> Balancer -> private Map<String, ModelNode> buildModelFromAssigned();1541446827;Builds the internal model from all shards in the given_{@link Iterable}. All shards in the {@link Iterable} must be assigned_to a node. This method will skip shards in the state_{@link ShardRoutingState#RELOCATING} since each relocating shard has_a shadow shard in the state {@link ShardRoutingState#INITIALIZING}_on the target node which we respect during the allocation / balancing_process. In short, this method recreates the status-quo in the cluster.;private Map<String, ModelNode> buildModelFromAssigned() {_            Map<String, ModelNode> nodes = new HashMap<>()__            for (RoutingNode rn : routingNodes) {_                ModelNode node = new ModelNode(rn)__                nodes.put(rn.nodeId(), node)__                for (ShardRouting shard : rn) {_                    assert rn.nodeId().equals(shard.currentNodeId())__                    _                    if (shard.state() != RELOCATING) {_                        node.addShard(shard)__                        if (logger.isTraceEnabled()) {_                            logger.trace("Assigned shard [{}] to node [{}]", shard, node.getNodeId())__                        }_                    }_                }_            }_            return nodes__        };builds,the,internal,model,from,all,shards,in,the,given,link,iterable,all,shards,in,the,link,iterable,must,be,assigned,to,a,node,this,method,will,skip,shards,in,the,state,link,shard,routing,state,relocating,since,each,relocating,shard,has,a,shadow,shard,in,the,state,link,shard,routing,state,initializing,on,the,target,node,which,we,respect,during,the,allocation,balancing,process,in,short,this,method,recreates,the,status,quo,in,the,cluster;private,map,string,model,node,build,model,from,assigned,map,string,model,node,nodes,new,hash,map,for,routing,node,rn,routing,nodes,model,node,node,new,model,node,rn,nodes,put,rn,node,id,node,for,shard,routing,shard,rn,assert,rn,node,id,equals,shard,current,node,id,if,shard,state,relocating,node,add,shard,shard,if,logger,is,trace,enabled,logger,trace,assigned,shard,to,node,shard,node,get,node,id,return,nodes
BalancedShardsAllocator -> Balancer -> private Map<String, ModelNode> buildModelFromAssigned();1542402632;Builds the internal model from all shards in the given_{@link Iterable}. All shards in the {@link Iterable} must be assigned_to a node. This method will skip shards in the state_{@link ShardRoutingState#RELOCATING} since each relocating shard has_a shadow shard in the state {@link ShardRoutingState#INITIALIZING}_on the target node which we respect during the allocation / balancing_process. In short, this method recreates the status-quo in the cluster.;private Map<String, ModelNode> buildModelFromAssigned() {_            Map<String, ModelNode> nodes = new HashMap<>()__            for (RoutingNode rn : routingNodes) {_                ModelNode node = new ModelNode(rn)__                nodes.put(rn.nodeId(), node)__                for (ShardRouting shard : rn) {_                    assert rn.nodeId().equals(shard.currentNodeId())__                    _                    if (shard.state() != RELOCATING) {_                        node.addShard(shard)__                        if (logger.isTraceEnabled()) {_                            logger.trace("Assigned shard [{}] to node [{}]", shard, node.getNodeId())__                        }_                    }_                }_            }_            return nodes__        };builds,the,internal,model,from,all,shards,in,the,given,link,iterable,all,shards,in,the,link,iterable,must,be,assigned,to,a,node,this,method,will,skip,shards,in,the,state,link,shard,routing,state,relocating,since,each,relocating,shard,has,a,shadow,shard,in,the,state,link,shard,routing,state,initializing,on,the,target,node,which,we,respect,during,the,allocation,balancing,process,in,short,this,method,recreates,the,status,quo,in,the,cluster;private,map,string,model,node,build,model,from,assigned,map,string,model,node,nodes,new,hash,map,for,routing,node,rn,routing,nodes,model,node,node,new,model,node,rn,nodes,put,rn,node,id,node,for,shard,routing,shard,rn,assert,rn,node,id,equals,shard,current,node,id,if,shard,state,relocating,node,add,shard,shard,if,logger,is,trace,enabled,logger,trace,assigned,shard,to,node,shard,node,get,node,id,return,nodes
BalancedShardsAllocator -> Balancer -> private Map<String, ModelNode> buildModelFromAssigned();1549912434;Builds the internal model from all shards in the given_{@link Iterable}. All shards in the {@link Iterable} must be assigned_to a node. This method will skip shards in the state_{@link ShardRoutingState#RELOCATING} since each relocating shard has_a shadow shard in the state {@link ShardRoutingState#INITIALIZING}_on the target node which we respect during the allocation / balancing_process. In short, this method recreates the status-quo in the cluster.;private Map<String, ModelNode> buildModelFromAssigned() {_            Map<String, ModelNode> nodes = new HashMap<>()__            for (RoutingNode rn : routingNodes) {_                ModelNode node = new ModelNode(rn)__                nodes.put(rn.nodeId(), node)__                for (ShardRouting shard : rn) {_                    assert rn.nodeId().equals(shard.currentNodeId())__                    _                    if (shard.state() != RELOCATING) {_                        node.addShard(shard)__                        if (logger.isTraceEnabled()) {_                            logger.trace("Assigned shard [{}] to node [{}]", shard, node.getNodeId())__                        }_                    }_                }_            }_            return nodes__        };builds,the,internal,model,from,all,shards,in,the,given,link,iterable,all,shards,in,the,link,iterable,must,be,assigned,to,a,node,this,method,will,skip,shards,in,the,state,link,shard,routing,state,relocating,since,each,relocating,shard,has,a,shadow,shard,in,the,state,link,shard,routing,state,initializing,on,the,target,node,which,we,respect,during,the,allocation,balancing,process,in,short,this,method,recreates,the,status,quo,in,the,cluster;private,map,string,model,node,build,model,from,assigned,map,string,model,node,nodes,new,hash,map,for,routing,node,rn,routing,nodes,model,node,node,new,model,node,rn,nodes,put,rn,node,id,node,for,shard,routing,shard,rn,assert,rn,node,id,equals,shard,current,node,id,if,shard,state,relocating,node,add,shard,shard,if,logger,is,trace,enabled,logger,trace,assigned,shard,to,node,shard,node,get,node,id,return,nodes
BalancedShardsAllocator -> public float getThreshold();1524684173;Returns the currently configured delta threshold;public float getThreshold() {_        return threshold__    };returns,the,currently,configured,delta,threshold;public,float,get,threshold,return,threshold
BalancedShardsAllocator -> public float getThreshold();1525334055;Returns the currently configured delta threshold;public float getThreshold() {_        return threshold__    };returns,the,currently,configured,delta,threshold;public,float,get,threshold,return,threshold
BalancedShardsAllocator -> public float getThreshold();1531234550;Returns the currently configured delta threshold;public float getThreshold() {_        return threshold__    };returns,the,currently,configured,delta,threshold;public,float,get,threshold,return,threshold
BalancedShardsAllocator -> public float getThreshold();1540847035;Returns the currently configured delta threshold;public float getThreshold() {_        return threshold__    };returns,the,currently,configured,delta,threshold;public,float,get,threshold,return,threshold
BalancedShardsAllocator -> public float getThreshold();1541092382;Returns the currently configured delta threshold;public float getThreshold() {_        return threshold__    };returns,the,currently,configured,delta,threshold;public,float,get,threshold,return,threshold
BalancedShardsAllocator -> public float getThreshold();1541446827;Returns the currently configured delta threshold;public float getThreshold() {_        return threshold__    };returns,the,currently,configured,delta,threshold;public,float,get,threshold,return,threshold
BalancedShardsAllocator -> public float getThreshold();1542402632;Returns the currently configured delta threshold;public float getThreshold() {_        return threshold__    };returns,the,currently,configured,delta,threshold;public,float,get,threshold,return,threshold
BalancedShardsAllocator -> public float getThreshold();1549912434;Returns the currently configured delta threshold;public float getThreshold() {_        return threshold__    };returns,the,currently,configured,delta,threshold;public,float,get,threshold,return,threshold
BalancedShardsAllocator -> Balancer -> private ModelNode[] nodesArray();1524684173;Returns an array view on the nodes in the balancer. Nodes should not be removed from this list.;private ModelNode[] nodesArray() {_            return nodes.values().toArray(new ModelNode[nodes.size()])__        };returns,an,array,view,on,the,nodes,in,the,balancer,nodes,should,not,be,removed,from,this,list;private,model,node,nodes,array,return,nodes,values,to,array,new,model,node,nodes,size
BalancedShardsAllocator -> Balancer -> private ModelNode[] nodesArray();1525334055;Returns an array view on the nodes in the balancer. Nodes should not be removed from this list.;private ModelNode[] nodesArray() {_            return nodes.values().toArray(new ModelNode[nodes.size()])__        };returns,an,array,view,on,the,nodes,in,the,balancer,nodes,should,not,be,removed,from,this,list;private,model,node,nodes,array,return,nodes,values,to,array,new,model,node,nodes,size
BalancedShardsAllocator -> Balancer -> private ModelNode[] nodesArray();1531234550;Returns an array view on the nodes in the balancer. Nodes should not be removed from this list.;private ModelNode[] nodesArray() {_            return nodes.values().toArray(new ModelNode[nodes.size()])__        };returns,an,array,view,on,the,nodes,in,the,balancer,nodes,should,not,be,removed,from,this,list;private,model,node,nodes,array,return,nodes,values,to,array,new,model,node,nodes,size
BalancedShardsAllocator -> Balancer -> private ModelNode[] nodesArray();1540847035;Returns an array view on the nodes in the balancer. Nodes should not be removed from this list.;private ModelNode[] nodesArray() {_            return nodes.values().toArray(new ModelNode[nodes.size()])__        };returns,an,array,view,on,the,nodes,in,the,balancer,nodes,should,not,be,removed,from,this,list;private,model,node,nodes,array,return,nodes,values,to,array,new,model,node,nodes,size
BalancedShardsAllocator -> Balancer -> private ModelNode[] nodesArray();1541092382;Returns an array view on the nodes in the balancer. Nodes should not be removed from this list.;private ModelNode[] nodesArray() {_            return nodes.values().toArray(new ModelNode[nodes.size()])__        };returns,an,array,view,on,the,nodes,in,the,balancer,nodes,should,not,be,removed,from,this,list;private,model,node,nodes,array,return,nodes,values,to,array,new,model,node,nodes,size
BalancedShardsAllocator -> Balancer -> private ModelNode[] nodesArray();1541446827;Returns an array view on the nodes in the balancer. Nodes should not be removed from this list.;private ModelNode[] nodesArray() {_            return nodes.values().toArray(new ModelNode[nodes.size()])__        };returns,an,array,view,on,the,nodes,in,the,balancer,nodes,should,not,be,removed,from,this,list;private,model,node,nodes,array,return,nodes,values,to,array,new,model,node,nodes,size
BalancedShardsAllocator -> Balancer -> private ModelNode[] nodesArray();1542402632;Returns an array view on the nodes in the balancer. Nodes should not be removed from this list.;private ModelNode[] nodesArray() {_            return nodes.values().toArray(new ModelNode[nodes.size()])__        };returns,an,array,view,on,the,nodes,in,the,balancer,nodes,should,not,be,removed,from,this,list;private,model,node,nodes,array,return,nodes,values,to,array,new,model,node,nodes,size
BalancedShardsAllocator -> Balancer -> private ModelNode[] nodesArray();1549912434;Returns an array view on the nodes in the balancer. Nodes should not be removed from this list.;private ModelNode[] nodesArray() {_            return nodes.values().toArray(new ModelNode[nodes.size()])__        };returns,an,array,view,on,the,nodes,in,the,balancer,nodes,should,not,be,removed,from,this,list;private,model,node,nodes,array,return,nodes,values,to,array,new,model,node,nodes,size
BalancedShardsAllocator -> Balancer -> private void balance();1524684173;Balances the nodes on the cluster model according to the weight function._The actual balancing is delegated to {@link #balanceByWeights()};private void balance() {_            if (logger.isTraceEnabled()) {_                logger.trace("Start balancing cluster")__            }_            if (allocation.hasPendingAsyncFetch()) {_                _                logger.debug("skipping rebalance due to in-flight shard/store fetches")__                return__            }_            if (allocation.deciders().canRebalance(allocation).type() != Type.YES) {_                logger.trace("skipping rebalance as it is disabled")__                return__            }_            if (nodes.size() < 2) { _                logger.trace("skipping rebalance as single node only")__                return__            }_            balanceByWeights()__        };balances,the,nodes,on,the,cluster,model,according,to,the,weight,function,the,actual,balancing,is,delegated,to,link,balance,by,weights;private,void,balance,if,logger,is,trace,enabled,logger,trace,start,balancing,cluster,if,allocation,has,pending,async,fetch,logger,debug,skipping,rebalance,due,to,in,flight,shard,store,fetches,return,if,allocation,deciders,can,rebalance,allocation,type,type,yes,logger,trace,skipping,rebalance,as,it,is,disabled,return,if,nodes,size,2,logger,trace,skipping,rebalance,as,single,node,only,return,balance,by,weights
BalancedShardsAllocator -> Balancer -> private void balance();1525334055;Balances the nodes on the cluster model according to the weight function._The actual balancing is delegated to {@link #balanceByWeights()};private void balance() {_            if (logger.isTraceEnabled()) {_                logger.trace("Start balancing cluster")__            }_            if (allocation.hasPendingAsyncFetch()) {_                _                logger.debug("skipping rebalance due to in-flight shard/store fetches")__                return__            }_            if (allocation.deciders().canRebalance(allocation).type() != Type.YES) {_                logger.trace("skipping rebalance as it is disabled")__                return__            }_            if (nodes.size() < 2) { _                logger.trace("skipping rebalance as single node only")__                return__            }_            balanceByWeights()__        };balances,the,nodes,on,the,cluster,model,according,to,the,weight,function,the,actual,balancing,is,delegated,to,link,balance,by,weights;private,void,balance,if,logger,is,trace,enabled,logger,trace,start,balancing,cluster,if,allocation,has,pending,async,fetch,logger,debug,skipping,rebalance,due,to,in,flight,shard,store,fetches,return,if,allocation,deciders,can,rebalance,allocation,type,type,yes,logger,trace,skipping,rebalance,as,it,is,disabled,return,if,nodes,size,2,logger,trace,skipping,rebalance,as,single,node,only,return,balance,by,weights
BalancedShardsAllocator -> Balancer -> private void balance();1531234550;Balances the nodes on the cluster model according to the weight function._The actual balancing is delegated to {@link #balanceByWeights()};private void balance() {_            if (logger.isTraceEnabled()) {_                logger.trace("Start balancing cluster")__            }_            if (allocation.hasPendingAsyncFetch()) {_                _                logger.debug("skipping rebalance due to in-flight shard/store fetches")__                return__            }_            if (allocation.deciders().canRebalance(allocation).type() != Type.YES) {_                logger.trace("skipping rebalance as it is disabled")__                return__            }_            if (nodes.size() < 2) { _                logger.trace("skipping rebalance as single node only")__                return__            }_            balanceByWeights()__        };balances,the,nodes,on,the,cluster,model,according,to,the,weight,function,the,actual,balancing,is,delegated,to,link,balance,by,weights;private,void,balance,if,logger,is,trace,enabled,logger,trace,start,balancing,cluster,if,allocation,has,pending,async,fetch,logger,debug,skipping,rebalance,due,to,in,flight,shard,store,fetches,return,if,allocation,deciders,can,rebalance,allocation,type,type,yes,logger,trace,skipping,rebalance,as,it,is,disabled,return,if,nodes,size,2,logger,trace,skipping,rebalance,as,single,node,only,return,balance,by,weights
BalancedShardsAllocator -> Balancer -> private void balance();1540847035;Balances the nodes on the cluster model according to the weight function._The actual balancing is delegated to {@link #balanceByWeights()};private void balance() {_            if (logger.isTraceEnabled()) {_                logger.trace("Start balancing cluster")__            }_            if (allocation.hasPendingAsyncFetch()) {_                _                logger.debug("skipping rebalance due to in-flight shard/store fetches")__                return__            }_            if (allocation.deciders().canRebalance(allocation).type() != Type.YES) {_                logger.trace("skipping rebalance as it is disabled")__                return__            }_            if (nodes.size() < 2) { _                logger.trace("skipping rebalance as single node only")__                return__            }_            balanceByWeights()__        };balances,the,nodes,on,the,cluster,model,according,to,the,weight,function,the,actual,balancing,is,delegated,to,link,balance,by,weights;private,void,balance,if,logger,is,trace,enabled,logger,trace,start,balancing,cluster,if,allocation,has,pending,async,fetch,logger,debug,skipping,rebalance,due,to,in,flight,shard,store,fetches,return,if,allocation,deciders,can,rebalance,allocation,type,type,yes,logger,trace,skipping,rebalance,as,it,is,disabled,return,if,nodes,size,2,logger,trace,skipping,rebalance,as,single,node,only,return,balance,by,weights
BalancedShardsAllocator -> Balancer -> private void balance();1541092382;Balances the nodes on the cluster model according to the weight function._The actual balancing is delegated to {@link #balanceByWeights()};private void balance() {_            if (logger.isTraceEnabled()) {_                logger.trace("Start balancing cluster")__            }_            if (allocation.hasPendingAsyncFetch()) {_                _                logger.debug("skipping rebalance due to in-flight shard/store fetches")__                return__            }_            if (allocation.deciders().canRebalance(allocation).type() != Type.YES) {_                logger.trace("skipping rebalance as it is disabled")__                return__            }_            if (nodes.size() < 2) { _                logger.trace("skipping rebalance as single node only")__                return__            }_            balanceByWeights()__        };balances,the,nodes,on,the,cluster,model,according,to,the,weight,function,the,actual,balancing,is,delegated,to,link,balance,by,weights;private,void,balance,if,logger,is,trace,enabled,logger,trace,start,balancing,cluster,if,allocation,has,pending,async,fetch,logger,debug,skipping,rebalance,due,to,in,flight,shard,store,fetches,return,if,allocation,deciders,can,rebalance,allocation,type,type,yes,logger,trace,skipping,rebalance,as,it,is,disabled,return,if,nodes,size,2,logger,trace,skipping,rebalance,as,single,node,only,return,balance,by,weights
BalancedShardsAllocator -> Balancer -> private void balance();1541446827;Balances the nodes on the cluster model according to the weight function._The actual balancing is delegated to {@link #balanceByWeights()};private void balance() {_            if (logger.isTraceEnabled()) {_                logger.trace("Start balancing cluster")__            }_            if (allocation.hasPendingAsyncFetch()) {_                _                logger.debug("skipping rebalance due to in-flight shard/store fetches")__                return__            }_            if (allocation.deciders().canRebalance(allocation).type() != Type.YES) {_                logger.trace("skipping rebalance as it is disabled")__                return__            }_            if (nodes.size() < 2) { _                logger.trace("skipping rebalance as single node only")__                return__            }_            balanceByWeights()__        };balances,the,nodes,on,the,cluster,model,according,to,the,weight,function,the,actual,balancing,is,delegated,to,link,balance,by,weights;private,void,balance,if,logger,is,trace,enabled,logger,trace,start,balancing,cluster,if,allocation,has,pending,async,fetch,logger,debug,skipping,rebalance,due,to,in,flight,shard,store,fetches,return,if,allocation,deciders,can,rebalance,allocation,type,type,yes,logger,trace,skipping,rebalance,as,it,is,disabled,return,if,nodes,size,2,logger,trace,skipping,rebalance,as,single,node,only,return,balance,by,weights
BalancedShardsAllocator -> Balancer -> private void balance();1542402632;Balances the nodes on the cluster model according to the weight function._The actual balancing is delegated to {@link #balanceByWeights()};private void balance() {_            if (logger.isTraceEnabled()) {_                logger.trace("Start balancing cluster")__            }_            if (allocation.hasPendingAsyncFetch()) {_                _                logger.debug("skipping rebalance due to in-flight shard/store fetches")__                return__            }_            if (allocation.deciders().canRebalance(allocation).type() != Type.YES) {_                logger.trace("skipping rebalance as it is disabled")__                return__            }_            if (nodes.size() < 2) { _                logger.trace("skipping rebalance as single node only")__                return__            }_            balanceByWeights()__        };balances,the,nodes,on,the,cluster,model,according,to,the,weight,function,the,actual,balancing,is,delegated,to,link,balance,by,weights;private,void,balance,if,logger,is,trace,enabled,logger,trace,start,balancing,cluster,if,allocation,has,pending,async,fetch,logger,debug,skipping,rebalance,due,to,in,flight,shard,store,fetches,return,if,allocation,deciders,can,rebalance,allocation,type,type,yes,logger,trace,skipping,rebalance,as,it,is,disabled,return,if,nodes,size,2,logger,trace,skipping,rebalance,as,single,node,only,return,balance,by,weights
BalancedShardsAllocator -> Balancer -> private void balance();1549912434;Balances the nodes on the cluster model according to the weight function._The actual balancing is delegated to {@link #balanceByWeights()};private void balance() {_            if (logger.isTraceEnabled()) {_                logger.trace("Start balancing cluster")__            }_            if (allocation.hasPendingAsyncFetch()) {_                _                logger.debug("skipping rebalance due to in-flight shard/store fetches")__                return__            }_            if (allocation.deciders().canRebalance(allocation).type() != Type.YES) {_                logger.trace("skipping rebalance as it is disabled")__                return__            }_            if (nodes.size() < 2) { _                logger.trace("skipping rebalance as single node only")__                return__            }_            balanceByWeights()__        };balances,the,nodes,on,the,cluster,model,according,to,the,weight,function,the,actual,balancing,is,delegated,to,link,balance,by,weights;private,void,balance,if,logger,is,trace,enabled,logger,trace,start,balancing,cluster,if,allocation,has,pending,async,fetch,logger,debug,skipping,rebalance,due,to,in,flight,shard,store,fetches,return,if,allocation,deciders,can,rebalance,allocation,type,type,yes,logger,trace,skipping,rebalance,as,it,is,disabled,return,if,nodes,size,2,logger,trace,skipping,rebalance,as,single,node,only,return,balance,by,weights
BalancedShardsAllocator -> Balancer -> public void moveShards();1524684173;Move started shards that can not be allocated to a node anymore__For each shard to be moved this function executes a move operation_to the minimal eligible node with respect to the_weight function. If a shard is moved the shard will be set to_{@link ShardRoutingState#RELOCATING} and a shadow instance of this_shard is created with an incremented version in the state_{@link ShardRoutingState#INITIALIZING}.;public void moveShards() {_            _            _            _            for (Iterator<ShardRouting> it = allocation.routingNodes().nodeInterleavedShardIterator()_ it.hasNext()_ ) {_                ShardRouting shardRouting = it.next()__                final MoveDecision moveDecision = decideMove(shardRouting)__                if (moveDecision.isDecisionTaken() && moveDecision.forceMove()) {_                    final ModelNode sourceNode = nodes.get(shardRouting.currentNodeId())__                    final ModelNode targetNode = nodes.get(moveDecision.getTargetNode().getId())__                    sourceNode.removeShard(shardRouting)__                    Tuple<ShardRouting, ShardRouting> relocatingShards = routingNodes.relocateShard(shardRouting, targetNode.getNodeId(),_                        allocation.clusterInfo().getShardSize(shardRouting, ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE), allocation.changes())__                    targetNode.addShard(relocatingShards.v2())__                    if (logger.isTraceEnabled()) {_                        logger.trace("Moved shard [{}] to node [{}]", shardRouting, targetNode.getRoutingNode())__                    }_                } else if (moveDecision.isDecisionTaken() && moveDecision.canRemain() == false) {_                    logger.trace("[{}][{}] can't move", shardRouting.index(), shardRouting.id())__                }_            }_        };move,started,shards,that,can,not,be,allocated,to,a,node,anymore,for,each,shard,to,be,moved,this,function,executes,a,move,operation,to,the,minimal,eligible,node,with,respect,to,the,weight,function,if,a,shard,is,moved,the,shard,will,be,set,to,link,shard,routing,state,relocating,and,a,shadow,instance,of,this,shard,is,created,with,an,incremented,version,in,the,state,link,shard,routing,state,initializing;public,void,move,shards,for,iterator,shard,routing,it,allocation,routing,nodes,node,interleaved,shard,iterator,it,has,next,shard,routing,shard,routing,it,next,final,move,decision,move,decision,decide,move,shard,routing,if,move,decision,is,decision,taken,move,decision,force,move,final,model,node,source,node,nodes,get,shard,routing,current,node,id,final,model,node,target,node,nodes,get,move,decision,get,target,node,get,id,source,node,remove,shard,shard,routing,tuple,shard,routing,shard,routing,relocating,shards,routing,nodes,relocate,shard,shard,routing,target,node,get,node,id,allocation,cluster,info,get,shard,size,shard,routing,shard,routing,allocation,changes,target,node,add,shard,relocating,shards,v2,if,logger,is,trace,enabled,logger,trace,moved,shard,to,node,shard,routing,target,node,get,routing,node,else,if,move,decision,is,decision,taken,move,decision,can,remain,false,logger,trace,can,t,move,shard,routing,index,shard,routing,id
BalancedShardsAllocator -> Balancer -> public void moveShards();1525334055;Move started shards that can not be allocated to a node anymore__For each shard to be moved this function executes a move operation_to the minimal eligible node with respect to the_weight function. If a shard is moved the shard will be set to_{@link ShardRoutingState#RELOCATING} and a shadow instance of this_shard is created with an incremented version in the state_{@link ShardRoutingState#INITIALIZING}.;public void moveShards() {_            _            _            _            for (Iterator<ShardRouting> it = allocation.routingNodes().nodeInterleavedShardIterator()_ it.hasNext()_ ) {_                ShardRouting shardRouting = it.next()__                final MoveDecision moveDecision = decideMove(shardRouting)__                if (moveDecision.isDecisionTaken() && moveDecision.forceMove()) {_                    final ModelNode sourceNode = nodes.get(shardRouting.currentNodeId())__                    final ModelNode targetNode = nodes.get(moveDecision.getTargetNode().getId())__                    sourceNode.removeShard(shardRouting)__                    Tuple<ShardRouting, ShardRouting> relocatingShards = routingNodes.relocateShard(shardRouting, targetNode.getNodeId(),_                        allocation.clusterInfo().getShardSize(shardRouting, ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE), allocation.changes())__                    targetNode.addShard(relocatingShards.v2())__                    if (logger.isTraceEnabled()) {_                        logger.trace("Moved shard [{}] to node [{}]", shardRouting, targetNode.getRoutingNode())__                    }_                } else if (moveDecision.isDecisionTaken() && moveDecision.canRemain() == false) {_                    logger.trace("[{}][{}] can't move", shardRouting.index(), shardRouting.id())__                }_            }_        };move,started,shards,that,can,not,be,allocated,to,a,node,anymore,for,each,shard,to,be,moved,this,function,executes,a,move,operation,to,the,minimal,eligible,node,with,respect,to,the,weight,function,if,a,shard,is,moved,the,shard,will,be,set,to,link,shard,routing,state,relocating,and,a,shadow,instance,of,this,shard,is,created,with,an,incremented,version,in,the,state,link,shard,routing,state,initializing;public,void,move,shards,for,iterator,shard,routing,it,allocation,routing,nodes,node,interleaved,shard,iterator,it,has,next,shard,routing,shard,routing,it,next,final,move,decision,move,decision,decide,move,shard,routing,if,move,decision,is,decision,taken,move,decision,force,move,final,model,node,source,node,nodes,get,shard,routing,current,node,id,final,model,node,target,node,nodes,get,move,decision,get,target,node,get,id,source,node,remove,shard,shard,routing,tuple,shard,routing,shard,routing,relocating,shards,routing,nodes,relocate,shard,shard,routing,target,node,get,node,id,allocation,cluster,info,get,shard,size,shard,routing,shard,routing,allocation,changes,target,node,add,shard,relocating,shards,v2,if,logger,is,trace,enabled,logger,trace,moved,shard,to,node,shard,routing,target,node,get,routing,node,else,if,move,decision,is,decision,taken,move,decision,can,remain,false,logger,trace,can,t,move,shard,routing,index,shard,routing,id
BalancedShardsAllocator -> Balancer -> public void moveShards();1531234550;Move started shards that can not be allocated to a node anymore__For each shard to be moved this function executes a move operation_to the minimal eligible node with respect to the_weight function. If a shard is moved the shard will be set to_{@link ShardRoutingState#RELOCATING} and a shadow instance of this_shard is created with an incremented version in the state_{@link ShardRoutingState#INITIALIZING}.;public void moveShards() {_            _            _            _            for (Iterator<ShardRouting> it = allocation.routingNodes().nodeInterleavedShardIterator()_ it.hasNext()_ ) {_                ShardRouting shardRouting = it.next()__                final MoveDecision moveDecision = decideMove(shardRouting)__                if (moveDecision.isDecisionTaken() && moveDecision.forceMove()) {_                    final ModelNode sourceNode = nodes.get(shardRouting.currentNodeId())__                    final ModelNode targetNode = nodes.get(moveDecision.getTargetNode().getId())__                    sourceNode.removeShard(shardRouting)__                    Tuple<ShardRouting, ShardRouting> relocatingShards = routingNodes.relocateShard(shardRouting, targetNode.getNodeId(),_                        allocation.clusterInfo().getShardSize(shardRouting, ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE), allocation.changes())__                    targetNode.addShard(relocatingShards.v2())__                    if (logger.isTraceEnabled()) {_                        logger.trace("Moved shard [{}] to node [{}]", shardRouting, targetNode.getRoutingNode())__                    }_                } else if (moveDecision.isDecisionTaken() && moveDecision.canRemain() == false) {_                    logger.trace("[{}][{}] can't move", shardRouting.index(), shardRouting.id())__                }_            }_        };move,started,shards,that,can,not,be,allocated,to,a,node,anymore,for,each,shard,to,be,moved,this,function,executes,a,move,operation,to,the,minimal,eligible,node,with,respect,to,the,weight,function,if,a,shard,is,moved,the,shard,will,be,set,to,link,shard,routing,state,relocating,and,a,shadow,instance,of,this,shard,is,created,with,an,incremented,version,in,the,state,link,shard,routing,state,initializing;public,void,move,shards,for,iterator,shard,routing,it,allocation,routing,nodes,node,interleaved,shard,iterator,it,has,next,shard,routing,shard,routing,it,next,final,move,decision,move,decision,decide,move,shard,routing,if,move,decision,is,decision,taken,move,decision,force,move,final,model,node,source,node,nodes,get,shard,routing,current,node,id,final,model,node,target,node,nodes,get,move,decision,get,target,node,get,id,source,node,remove,shard,shard,routing,tuple,shard,routing,shard,routing,relocating,shards,routing,nodes,relocate,shard,shard,routing,target,node,get,node,id,allocation,cluster,info,get,shard,size,shard,routing,shard,routing,allocation,changes,target,node,add,shard,relocating,shards,v2,if,logger,is,trace,enabled,logger,trace,moved,shard,to,node,shard,routing,target,node,get,routing,node,else,if,move,decision,is,decision,taken,move,decision,can,remain,false,logger,trace,can,t,move,shard,routing,index,shard,routing,id
BalancedShardsAllocator -> Balancer -> public void moveShards();1540847035;Move started shards that can not be allocated to a node anymore__For each shard to be moved this function executes a move operation_to the minimal eligible node with respect to the_weight function. If a shard is moved the shard will be set to_{@link ShardRoutingState#RELOCATING} and a shadow instance of this_shard is created with an incremented version in the state_{@link ShardRoutingState#INITIALIZING}.;public void moveShards() {_            _            _            _            for (Iterator<ShardRouting> it = allocation.routingNodes().nodeInterleavedShardIterator()_ it.hasNext()_ ) {_                ShardRouting shardRouting = it.next()__                final MoveDecision moveDecision = decideMove(shardRouting)__                if (moveDecision.isDecisionTaken() && moveDecision.forceMove()) {_                    final ModelNode sourceNode = nodes.get(shardRouting.currentNodeId())__                    final ModelNode targetNode = nodes.get(moveDecision.getTargetNode().getId())__                    sourceNode.removeShard(shardRouting)__                    Tuple<ShardRouting, ShardRouting> relocatingShards = routingNodes.relocateShard(shardRouting, targetNode.getNodeId(),_                        allocation.clusterInfo().getShardSize(shardRouting,_                                                              ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE), allocation.changes())__                    targetNode.addShard(relocatingShards.v2())__                    if (logger.isTraceEnabled()) {_                        logger.trace("Moved shard [{}] to node [{}]", shardRouting, targetNode.getRoutingNode())__                    }_                } else if (moveDecision.isDecisionTaken() && moveDecision.canRemain() == false) {_                    logger.trace("[{}][{}] can't move", shardRouting.index(), shardRouting.id())__                }_            }_        };move,started,shards,that,can,not,be,allocated,to,a,node,anymore,for,each,shard,to,be,moved,this,function,executes,a,move,operation,to,the,minimal,eligible,node,with,respect,to,the,weight,function,if,a,shard,is,moved,the,shard,will,be,set,to,link,shard,routing,state,relocating,and,a,shadow,instance,of,this,shard,is,created,with,an,incremented,version,in,the,state,link,shard,routing,state,initializing;public,void,move,shards,for,iterator,shard,routing,it,allocation,routing,nodes,node,interleaved,shard,iterator,it,has,next,shard,routing,shard,routing,it,next,final,move,decision,move,decision,decide,move,shard,routing,if,move,decision,is,decision,taken,move,decision,force,move,final,model,node,source,node,nodes,get,shard,routing,current,node,id,final,model,node,target,node,nodes,get,move,decision,get,target,node,get,id,source,node,remove,shard,shard,routing,tuple,shard,routing,shard,routing,relocating,shards,routing,nodes,relocate,shard,shard,routing,target,node,get,node,id,allocation,cluster,info,get,shard,size,shard,routing,shard,routing,allocation,changes,target,node,add,shard,relocating,shards,v2,if,logger,is,trace,enabled,logger,trace,moved,shard,to,node,shard,routing,target,node,get,routing,node,else,if,move,decision,is,decision,taken,move,decision,can,remain,false,logger,trace,can,t,move,shard,routing,index,shard,routing,id
BalancedShardsAllocator -> Balancer -> public void moveShards();1541092382;Move started shards that can not be allocated to a node anymore__For each shard to be moved this function executes a move operation_to the minimal eligible node with respect to the_weight function. If a shard is moved the shard will be set to_{@link ShardRoutingState#RELOCATING} and a shadow instance of this_shard is created with an incremented version in the state_{@link ShardRoutingState#INITIALIZING}.;public void moveShards() {_            _            _            _            for (Iterator<ShardRouting> it = allocation.routingNodes().nodeInterleavedShardIterator()_ it.hasNext()_ ) {_                ShardRouting shardRouting = it.next()__                final MoveDecision moveDecision = decideMove(shardRouting)__                if (moveDecision.isDecisionTaken() && moveDecision.forceMove()) {_                    final ModelNode sourceNode = nodes.get(shardRouting.currentNodeId())__                    final ModelNode targetNode = nodes.get(moveDecision.getTargetNode().getId())__                    sourceNode.removeShard(shardRouting)__                    Tuple<ShardRouting, ShardRouting> relocatingShards = routingNodes.relocateShard(shardRouting, targetNode.getNodeId(),_                        allocation.clusterInfo().getShardSize(shardRouting,_                                                              ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE), allocation.changes())__                    targetNode.addShard(relocatingShards.v2())__                    if (logger.isTraceEnabled()) {_                        logger.trace("Moved shard [{}] to node [{}]", shardRouting, targetNode.getRoutingNode())__                    }_                } else if (moveDecision.isDecisionTaken() && moveDecision.canRemain() == false) {_                    logger.trace("[{}][{}] can't move", shardRouting.index(), shardRouting.id())__                }_            }_        };move,started,shards,that,can,not,be,allocated,to,a,node,anymore,for,each,shard,to,be,moved,this,function,executes,a,move,operation,to,the,minimal,eligible,node,with,respect,to,the,weight,function,if,a,shard,is,moved,the,shard,will,be,set,to,link,shard,routing,state,relocating,and,a,shadow,instance,of,this,shard,is,created,with,an,incremented,version,in,the,state,link,shard,routing,state,initializing;public,void,move,shards,for,iterator,shard,routing,it,allocation,routing,nodes,node,interleaved,shard,iterator,it,has,next,shard,routing,shard,routing,it,next,final,move,decision,move,decision,decide,move,shard,routing,if,move,decision,is,decision,taken,move,decision,force,move,final,model,node,source,node,nodes,get,shard,routing,current,node,id,final,model,node,target,node,nodes,get,move,decision,get,target,node,get,id,source,node,remove,shard,shard,routing,tuple,shard,routing,shard,routing,relocating,shards,routing,nodes,relocate,shard,shard,routing,target,node,get,node,id,allocation,cluster,info,get,shard,size,shard,routing,shard,routing,allocation,changes,target,node,add,shard,relocating,shards,v2,if,logger,is,trace,enabled,logger,trace,moved,shard,to,node,shard,routing,target,node,get,routing,node,else,if,move,decision,is,decision,taken,move,decision,can,remain,false,logger,trace,can,t,move,shard,routing,index,shard,routing,id
BalancedShardsAllocator -> Balancer -> public void moveShards();1541446827;Move started shards that can not be allocated to a node anymore__For each shard to be moved this function executes a move operation_to the minimal eligible node with respect to the_weight function. If a shard is moved the shard will be set to_{@link ShardRoutingState#RELOCATING} and a shadow instance of this_shard is created with an incremented version in the state_{@link ShardRoutingState#INITIALIZING}.;public void moveShards() {_            _            _            _            for (Iterator<ShardRouting> it = allocation.routingNodes().nodeInterleavedShardIterator()_ it.hasNext()_ ) {_                ShardRouting shardRouting = it.next()__                final MoveDecision moveDecision = decideMove(shardRouting)__                if (moveDecision.isDecisionTaken() && moveDecision.forceMove()) {_                    final ModelNode sourceNode = nodes.get(shardRouting.currentNodeId())__                    final ModelNode targetNode = nodes.get(moveDecision.getTargetNode().getId())__                    sourceNode.removeShard(shardRouting)__                    Tuple<ShardRouting, ShardRouting> relocatingShards = routingNodes.relocateShard(shardRouting, targetNode.getNodeId(),_                        allocation.clusterInfo().getShardSize(shardRouting,_                                                              ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE), allocation.changes())__                    targetNode.addShard(relocatingShards.v2())__                    if (logger.isTraceEnabled()) {_                        logger.trace("Moved shard [{}] to node [{}]", shardRouting, targetNode.getRoutingNode())__                    }_                } else if (moveDecision.isDecisionTaken() && moveDecision.canRemain() == false) {_                    logger.trace("[{}][{}] can't move", shardRouting.index(), shardRouting.id())__                }_            }_        };move,started,shards,that,can,not,be,allocated,to,a,node,anymore,for,each,shard,to,be,moved,this,function,executes,a,move,operation,to,the,minimal,eligible,node,with,respect,to,the,weight,function,if,a,shard,is,moved,the,shard,will,be,set,to,link,shard,routing,state,relocating,and,a,shadow,instance,of,this,shard,is,created,with,an,incremented,version,in,the,state,link,shard,routing,state,initializing;public,void,move,shards,for,iterator,shard,routing,it,allocation,routing,nodes,node,interleaved,shard,iterator,it,has,next,shard,routing,shard,routing,it,next,final,move,decision,move,decision,decide,move,shard,routing,if,move,decision,is,decision,taken,move,decision,force,move,final,model,node,source,node,nodes,get,shard,routing,current,node,id,final,model,node,target,node,nodes,get,move,decision,get,target,node,get,id,source,node,remove,shard,shard,routing,tuple,shard,routing,shard,routing,relocating,shards,routing,nodes,relocate,shard,shard,routing,target,node,get,node,id,allocation,cluster,info,get,shard,size,shard,routing,shard,routing,allocation,changes,target,node,add,shard,relocating,shards,v2,if,logger,is,trace,enabled,logger,trace,moved,shard,to,node,shard,routing,target,node,get,routing,node,else,if,move,decision,is,decision,taken,move,decision,can,remain,false,logger,trace,can,t,move,shard,routing,index,shard,routing,id
BalancedShardsAllocator -> Balancer -> public void moveShards();1542402632;Move started shards that can not be allocated to a node anymore__For each shard to be moved this function executes a move operation_to the minimal eligible node with respect to the_weight function. If a shard is moved the shard will be set to_{@link ShardRoutingState#RELOCATING} and a shadow instance of this_shard is created with an incremented version in the state_{@link ShardRoutingState#INITIALIZING}.;public void moveShards() {_            _            _            _            for (Iterator<ShardRouting> it = allocation.routingNodes().nodeInterleavedShardIterator()_ it.hasNext()_ ) {_                ShardRouting shardRouting = it.next()__                final MoveDecision moveDecision = decideMove(shardRouting)__                if (moveDecision.isDecisionTaken() && moveDecision.forceMove()) {_                    final ModelNode sourceNode = nodes.get(shardRouting.currentNodeId())__                    final ModelNode targetNode = nodes.get(moveDecision.getTargetNode().getId())__                    sourceNode.removeShard(shardRouting)__                    Tuple<ShardRouting, ShardRouting> relocatingShards = routingNodes.relocateShard(shardRouting, targetNode.getNodeId(),_                        allocation.clusterInfo().getShardSize(shardRouting,_                                                              ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE), allocation.changes())__                    targetNode.addShard(relocatingShards.v2())__                    if (logger.isTraceEnabled()) {_                        logger.trace("Moved shard [{}] to node [{}]", shardRouting, targetNode.getRoutingNode())__                    }_                } else if (moveDecision.isDecisionTaken() && moveDecision.canRemain() == false) {_                    logger.trace("[{}][{}] can't move", shardRouting.index(), shardRouting.id())__                }_            }_        };move,started,shards,that,can,not,be,allocated,to,a,node,anymore,for,each,shard,to,be,moved,this,function,executes,a,move,operation,to,the,minimal,eligible,node,with,respect,to,the,weight,function,if,a,shard,is,moved,the,shard,will,be,set,to,link,shard,routing,state,relocating,and,a,shadow,instance,of,this,shard,is,created,with,an,incremented,version,in,the,state,link,shard,routing,state,initializing;public,void,move,shards,for,iterator,shard,routing,it,allocation,routing,nodes,node,interleaved,shard,iterator,it,has,next,shard,routing,shard,routing,it,next,final,move,decision,move,decision,decide,move,shard,routing,if,move,decision,is,decision,taken,move,decision,force,move,final,model,node,source,node,nodes,get,shard,routing,current,node,id,final,model,node,target,node,nodes,get,move,decision,get,target,node,get,id,source,node,remove,shard,shard,routing,tuple,shard,routing,shard,routing,relocating,shards,routing,nodes,relocate,shard,shard,routing,target,node,get,node,id,allocation,cluster,info,get,shard,size,shard,routing,shard,routing,allocation,changes,target,node,add,shard,relocating,shards,v2,if,logger,is,trace,enabled,logger,trace,moved,shard,to,node,shard,routing,target,node,get,routing,node,else,if,move,decision,is,decision,taken,move,decision,can,remain,false,logger,trace,can,t,move,shard,routing,index,shard,routing,id
BalancedShardsAllocator -> Balancer -> public void moveShards();1549912434;Move started shards that can not be allocated to a node anymore__For each shard to be moved this function executes a move operation_to the minimal eligible node with respect to the_weight function. If a shard is moved the shard will be set to_{@link ShardRoutingState#RELOCATING} and a shadow instance of this_shard is created with an incremented version in the state_{@link ShardRoutingState#INITIALIZING}.;public void moveShards() {_            _            _            _            for (Iterator<ShardRouting> it = allocation.routingNodes().nodeInterleavedShardIterator()_ it.hasNext()_ ) {_                ShardRouting shardRouting = it.next()__                final MoveDecision moveDecision = decideMove(shardRouting)__                if (moveDecision.isDecisionTaken() && moveDecision.forceMove()) {_                    final ModelNode sourceNode = nodes.get(shardRouting.currentNodeId())__                    final ModelNode targetNode = nodes.get(moveDecision.getTargetNode().getId())__                    sourceNode.removeShard(shardRouting)__                    Tuple<ShardRouting, ShardRouting> relocatingShards = routingNodes.relocateShard(shardRouting, targetNode.getNodeId(),_                        allocation.clusterInfo().getShardSize(shardRouting,_                                                              ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE), allocation.changes())__                    targetNode.addShard(relocatingShards.v2())__                    if (logger.isTraceEnabled()) {_                        logger.trace("Moved shard [{}] to node [{}]", shardRouting, targetNode.getRoutingNode())__                    }_                } else if (moveDecision.isDecisionTaken() && moveDecision.canRemain() == false) {_                    logger.trace("[{}][{}] can't move", shardRouting.index(), shardRouting.id())__                }_            }_        };move,started,shards,that,can,not,be,allocated,to,a,node,anymore,for,each,shard,to,be,moved,this,function,executes,a,move,operation,to,the,minimal,eligible,node,with,respect,to,the,weight,function,if,a,shard,is,moved,the,shard,will,be,set,to,link,shard,routing,state,relocating,and,a,shadow,instance,of,this,shard,is,created,with,an,incremented,version,in,the,state,link,shard,routing,state,initializing;public,void,move,shards,for,iterator,shard,routing,it,allocation,routing,nodes,node,interleaved,shard,iterator,it,has,next,shard,routing,shard,routing,it,next,final,move,decision,move,decision,decide,move,shard,routing,if,move,decision,is,decision,taken,move,decision,force,move,final,model,node,source,node,nodes,get,shard,routing,current,node,id,final,model,node,target,node,nodes,get,move,decision,get,target,node,get,id,source,node,remove,shard,shard,routing,tuple,shard,routing,shard,routing,relocating,shards,routing,nodes,relocate,shard,shard,routing,target,node,get,node,id,allocation,cluster,info,get,shard,size,shard,routing,shard,routing,allocation,changes,target,node,add,shard,relocating,shards,v2,if,logger,is,trace,enabled,logger,trace,moved,shard,to,node,shard,routing,target,node,get,routing,node,else,if,move,decision,is,decision,taken,move,decision,can,remain,false,logger,trace,can,t,move,shard,routing,index,shard,routing,id
BalancedShardsAllocator -> Balancer -> private static float absDelta(float lower, float higher);1524684173;The absolute value difference between two weights.;private static float absDelta(float lower, float higher) {_            assert higher >= lower : higher + " lt " + lower +" but was expected to be gte"__            return Math.abs(higher - lower)__        };the,absolute,value,difference,between,two,weights;private,static,float,abs,delta,float,lower,float,higher,assert,higher,lower,higher,lt,lower,but,was,expected,to,be,gte,return,math,abs,higher,lower
BalancedShardsAllocator -> Balancer -> private static float absDelta(float lower, float higher);1525334055;The absolute value difference between two weights.;private static float absDelta(float lower, float higher) {_            assert higher >= lower : higher + " lt " + lower +" but was expected to be gte"__            return Math.abs(higher - lower)__        };the,absolute,value,difference,between,two,weights;private,static,float,abs,delta,float,lower,float,higher,assert,higher,lower,higher,lt,lower,but,was,expected,to,be,gte,return,math,abs,higher,lower
BalancedShardsAllocator -> Balancer -> private static float absDelta(float lower, float higher);1531234550;The absolute value difference between two weights.;private static float absDelta(float lower, float higher) {_            assert higher >= lower : higher + " lt " + lower +" but was expected to be gte"__            return Math.abs(higher - lower)__        };the,absolute,value,difference,between,two,weights;private,static,float,abs,delta,float,lower,float,higher,assert,higher,lower,higher,lt,lower,but,was,expected,to,be,gte,return,math,abs,higher,lower
BalancedShardsAllocator -> Balancer -> private static float absDelta(float lower, float higher);1540847035;The absolute value difference between two weights.;private static float absDelta(float lower, float higher) {_            assert higher >= lower : higher + " lt " + lower +" but was expected to be gte"__            return Math.abs(higher - lower)__        };the,absolute,value,difference,between,two,weights;private,static,float,abs,delta,float,lower,float,higher,assert,higher,lower,higher,lt,lower,but,was,expected,to,be,gte,return,math,abs,higher,lower
BalancedShardsAllocator -> Balancer -> private static float absDelta(float lower, float higher);1541092382;The absolute value difference between two weights.;private static float absDelta(float lower, float higher) {_            assert higher >= lower : higher + " lt " + lower +" but was expected to be gte"__            return Math.abs(higher - lower)__        };the,absolute,value,difference,between,two,weights;private,static,float,abs,delta,float,lower,float,higher,assert,higher,lower,higher,lt,lower,but,was,expected,to,be,gte,return,math,abs,higher,lower
BalancedShardsAllocator -> Balancer -> private static float absDelta(float lower, float higher);1541446827;The absolute value difference between two weights.;private static float absDelta(float lower, float higher) {_            assert higher >= lower : higher + " lt " + lower +" but was expected to be gte"__            return Math.abs(higher - lower)__        };the,absolute,value,difference,between,two,weights;private,static,float,abs,delta,float,lower,float,higher,assert,higher,lower,higher,lt,lower,but,was,expected,to,be,gte,return,math,abs,higher,lower
BalancedShardsAllocator -> Balancer -> private static float absDelta(float lower, float higher);1542402632;The absolute value difference between two weights.;private static float absDelta(float lower, float higher) {_            assert higher >= lower : higher + " lt " + lower +" but was expected to be gte"__            return Math.abs(higher - lower)__        };the,absolute,value,difference,between,two,weights;private,static,float,abs,delta,float,lower,float,higher,assert,higher,lower,higher,lt,lower,but,was,expected,to,be,gte,return,math,abs,higher,lower
BalancedShardsAllocator -> Balancer -> private static float absDelta(float lower, float higher);1549912434;The absolute value difference between two weights.;private static float absDelta(float lower, float higher) {_            assert higher >= lower : higher + " lt " + lower +" but was expected to be gte"__            return Math.abs(higher - lower)__        };the,absolute,value,difference,between,two,weights;private,static,float,abs,delta,float,lower,float,higher,assert,higher,lower,higher,lt,lower,but,was,expected,to,be,gte,return,math,abs,higher,lower
BalancedShardsAllocator -> public float getShardBalance();1524684173;Returns the shard related weight factor.;public float getShardBalance() {_        return weightFunction.shardBalance__    };returns,the,shard,related,weight,factor;public,float,get,shard,balance,return,weight,function,shard,balance
BalancedShardsAllocator -> public float getShardBalance();1525334055;Returns the shard related weight factor.;public float getShardBalance() {_        return weightFunction.shardBalance__    };returns,the,shard,related,weight,factor;public,float,get,shard,balance,return,weight,function,shard,balance
BalancedShardsAllocator -> public float getShardBalance();1531234550;Returns the shard related weight factor.;public float getShardBalance() {_        return weightFunction.shardBalance__    };returns,the,shard,related,weight,factor;public,float,get,shard,balance,return,weight,function,shard,balance
BalancedShardsAllocator -> public float getShardBalance();1540847035;Returns the shard related weight factor.;public float getShardBalance() {_        return weightFunction.shardBalance__    };returns,the,shard,related,weight,factor;public,float,get,shard,balance,return,weight,function,shard,balance
BalancedShardsAllocator -> public float getShardBalance();1541092382;Returns the shard related weight factor.;public float getShardBalance() {_        return weightFunction.shardBalance__    };returns,the,shard,related,weight,factor;public,float,get,shard,balance,return,weight,function,shard,balance
BalancedShardsAllocator -> public float getShardBalance();1541446827;Returns the shard related weight factor.;public float getShardBalance() {_        return weightFunction.shardBalance__    };returns,the,shard,related,weight,factor;public,float,get,shard,balance,return,weight,function,shard,balance
BalancedShardsAllocator -> public float getShardBalance();1542402632;Returns the shard related weight factor.;public float getShardBalance() {_        return weightFunction.shardBalance__    };returns,the,shard,related,weight,factor;public,float,get,shard,balance,return,weight,function,shard,balance
BalancedShardsAllocator -> public float getShardBalance();1549912434;Returns the shard related weight factor.;public float getShardBalance() {_        return weightFunction.shardBalance__    };returns,the,shard,related,weight,factor;public,float,get,shard,balance,return,weight,function,shard,balance
BalancedShardsAllocator -> Balancer -> private NodeSorter newNodeSorter();1524684173;Returns a new {@link NodeSorter} that sorts the nodes based on their_current weight with respect to the index passed to the sorter. The_returned sorter is not sorted. Use {@link NodeSorter#reset(String)}_to sort based on an index.;private NodeSorter newNodeSorter() {_            return new NodeSorter(nodesArray(), weight, this)__        };returns,a,new,link,node,sorter,that,sorts,the,nodes,based,on,their,current,weight,with,respect,to,the,index,passed,to,the,sorter,the,returned,sorter,is,not,sorted,use,link,node,sorter,reset,string,to,sort,based,on,an,index;private,node,sorter,new,node,sorter,return,new,node,sorter,nodes,array,weight,this
BalancedShardsAllocator -> Balancer -> private NodeSorter newNodeSorter();1525334055;Returns a new {@link NodeSorter} that sorts the nodes based on their_current weight with respect to the index passed to the sorter. The_returned sorter is not sorted. Use {@link NodeSorter#reset(String)}_to sort based on an index.;private NodeSorter newNodeSorter() {_            return new NodeSorter(nodesArray(), weight, this)__        };returns,a,new,link,node,sorter,that,sorts,the,nodes,based,on,their,current,weight,with,respect,to,the,index,passed,to,the,sorter,the,returned,sorter,is,not,sorted,use,link,node,sorter,reset,string,to,sort,based,on,an,index;private,node,sorter,new,node,sorter,return,new,node,sorter,nodes,array,weight,this
BalancedShardsAllocator -> Balancer -> private NodeSorter newNodeSorter();1531234550;Returns a new {@link NodeSorter} that sorts the nodes based on their_current weight with respect to the index passed to the sorter. The_returned sorter is not sorted. Use {@link NodeSorter#reset(String)}_to sort based on an index.;private NodeSorter newNodeSorter() {_            return new NodeSorter(nodesArray(), weight, this)__        };returns,a,new,link,node,sorter,that,sorts,the,nodes,based,on,their,current,weight,with,respect,to,the,index,passed,to,the,sorter,the,returned,sorter,is,not,sorted,use,link,node,sorter,reset,string,to,sort,based,on,an,index;private,node,sorter,new,node,sorter,return,new,node,sorter,nodes,array,weight,this
BalancedShardsAllocator -> Balancer -> private NodeSorter newNodeSorter();1540847035;Returns a new {@link NodeSorter} that sorts the nodes based on their_current weight with respect to the index passed to the sorter. The_returned sorter is not sorted. Use {@link NodeSorter#reset(String)}_to sort based on an index.;private NodeSorter newNodeSorter() {_            return new NodeSorter(nodesArray(), weight, this)__        };returns,a,new,link,node,sorter,that,sorts,the,nodes,based,on,their,current,weight,with,respect,to,the,index,passed,to,the,sorter,the,returned,sorter,is,not,sorted,use,link,node,sorter,reset,string,to,sort,based,on,an,index;private,node,sorter,new,node,sorter,return,new,node,sorter,nodes,array,weight,this
BalancedShardsAllocator -> Balancer -> private NodeSorter newNodeSorter();1541092382;Returns a new {@link NodeSorter} that sorts the nodes based on their_current weight with respect to the index passed to the sorter. The_returned sorter is not sorted. Use {@link NodeSorter#reset(String)}_to sort based on an index.;private NodeSorter newNodeSorter() {_            return new NodeSorter(nodesArray(), weight, this)__        };returns,a,new,link,node,sorter,that,sorts,the,nodes,based,on,their,current,weight,with,respect,to,the,index,passed,to,the,sorter,the,returned,sorter,is,not,sorted,use,link,node,sorter,reset,string,to,sort,based,on,an,index;private,node,sorter,new,node,sorter,return,new,node,sorter,nodes,array,weight,this
BalancedShardsAllocator -> Balancer -> private NodeSorter newNodeSorter();1541446827;Returns a new {@link NodeSorter} that sorts the nodes based on their_current weight with respect to the index passed to the sorter. The_returned sorter is not sorted. Use {@link NodeSorter#reset(String)}_to sort based on an index.;private NodeSorter newNodeSorter() {_            return new NodeSorter(nodesArray(), weight, this)__        };returns,a,new,link,node,sorter,that,sorts,the,nodes,based,on,their,current,weight,with,respect,to,the,index,passed,to,the,sorter,the,returned,sorter,is,not,sorted,use,link,node,sorter,reset,string,to,sort,based,on,an,index;private,node,sorter,new,node,sorter,return,new,node,sorter,nodes,array,weight,this
BalancedShardsAllocator -> Balancer -> private NodeSorter newNodeSorter();1542402632;Returns a new {@link NodeSorter} that sorts the nodes based on their_current weight with respect to the index passed to the sorter. The_returned sorter is not sorted. Use {@link NodeSorter#reset(String)}_to sort based on an index.;private NodeSorter newNodeSorter() {_            return new NodeSorter(nodesArray(), weight, this)__        };returns,a,new,link,node,sorter,that,sorts,the,nodes,based,on,their,current,weight,with,respect,to,the,index,passed,to,the,sorter,the,returned,sorter,is,not,sorted,use,link,node,sorter,reset,string,to,sort,based,on,an,index;private,node,sorter,new,node,sorter,return,new,node,sorter,nodes,array,weight,this
BalancedShardsAllocator -> Balancer -> private NodeSorter newNodeSorter();1549912434;Returns a new {@link NodeSorter} that sorts the nodes based on their_current weight with respect to the index passed to the sorter. The_returned sorter is not sorted. Use {@link NodeSorter#reset(String)}_to sort based on an index.;private NodeSorter newNodeSorter() {_            return new NodeSorter(nodesArray(), weight, this)__        };returns,a,new,link,node,sorter,that,sorts,the,nodes,based,on,their,current,weight,with,respect,to,the,index,passed,to,the,sorter,the,returned,sorter,is,not,sorted,use,link,node,sorter,reset,string,to,sort,based,on,an,index;private,node,sorter,new,node,sorter,return,new,node,sorter,nodes,array,weight,this
BalancedShardsAllocator -> Balancer -> public float avgShardsPerNode();1524684173;Returns the global average of shards per node;public float avgShardsPerNode() {_            return avgShardsPerNode__        };returns,the,global,average,of,shards,per,node;public,float,avg,shards,per,node,return,avg,shards,per,node
BalancedShardsAllocator -> Balancer -> public float avgShardsPerNode();1525334055;Returns the global average of shards per node;public float avgShardsPerNode() {_            return avgShardsPerNode__        };returns,the,global,average,of,shards,per,node;public,float,avg,shards,per,node,return,avg,shards,per,node
BalancedShardsAllocator -> Balancer -> public float avgShardsPerNode();1531234550;Returns the global average of shards per node;public float avgShardsPerNode() {_            return avgShardsPerNode__        };returns,the,global,average,of,shards,per,node;public,float,avg,shards,per,node,return,avg,shards,per,node
BalancedShardsAllocator -> Balancer -> public float avgShardsPerNode();1540847035;Returns the global average of shards per node;public float avgShardsPerNode() {_            return avgShardsPerNode__        };returns,the,global,average,of,shards,per,node;public,float,avg,shards,per,node,return,avg,shards,per,node
BalancedShardsAllocator -> Balancer -> public float avgShardsPerNode();1541092382;Returns the global average of shards per node;public float avgShardsPerNode() {_            return avgShardsPerNode__        };returns,the,global,average,of,shards,per,node;public,float,avg,shards,per,node,return,avg,shards,per,node
BalancedShardsAllocator -> Balancer -> public float avgShardsPerNode();1541446827;Returns the global average of shards per node;public float avgShardsPerNode() {_            return avgShardsPerNode__        };returns,the,global,average,of,shards,per,node;public,float,avg,shards,per,node,return,avg,shards,per,node
BalancedShardsAllocator -> Balancer -> public float avgShardsPerNode();1542402632;Returns the global average of shards per node;public float avgShardsPerNode() {_            return avgShardsPerNode__        };returns,the,global,average,of,shards,per,node;public,float,avg,shards,per,node,return,avg,shards,per,node
BalancedShardsAllocator -> Balancer -> public float avgShardsPerNode();1549912434;Returns the global average of shards per node;public float avgShardsPerNode() {_            return avgShardsPerNode__        };returns,the,global,average,of,shards,per,node;public,float,avg,shards,per,node,return,avg,shards,per,node
BalancedShardsAllocator -> Balancer -> private AllocateUnassignedDecision decideAllocateUnassigned(final ShardRouting shard, final Set<ModelNode> throttledNodes);1524684173;Make a decision for allocating an unassigned shard.  This method returns a two values in a tuple: the_first value is the {@link Decision} taken to allocate the unassigned shard, the second value is the_{@link ModelNode} representing the node that the shard should be assigned to.  If the decision returned_is of type {@link Type#NO}, then the assigned node will be null.;private AllocateUnassignedDecision decideAllocateUnassigned(final ShardRouting shard, final Set<ModelNode> throttledNodes) {_            if (shard.assignedToNode()) {_                _                return AllocateUnassignedDecision.NOT_TAKEN__            }__            final boolean explain = allocation.debugDecision()__            Decision shardLevelDecision = allocation.deciders().canAllocate(shard, allocation)__            if (shardLevelDecision.type() == Type.NO && explain == false) {_                _                return AllocateUnassignedDecision.no(AllocationStatus.DECIDERS_NO, null)__            }__            _            float minWeight = Float.POSITIVE_INFINITY__            ModelNode minNode = null__            Decision decision = null__            if (throttledNodes.size() >= nodes.size() && explain == false) {_                _                _                return AllocateUnassignedDecision.no(AllocationStatus.DECIDERS_NO, null)__            }_            _            Map<String, NodeAllocationResult> nodeExplanationMap = explain ? new HashMap<>() : null__            List<Tuple<String, Float>> nodeWeights = explain ? new ArrayList<>() : null__            for (ModelNode node : nodes.values()) {_                if ((throttledNodes.contains(node) || node.containsShard(shard)) && explain == false) {_                    _                    continue__                }__                _                float currentWeight = weight.weightShardAdded(this, node, shard.getIndexName())__                _                if (currentWeight > minWeight && explain == false) {_                    continue__                }__                Decision currentDecision = allocation.deciders().canAllocate(shard, node.getRoutingNode(), allocation)__                if (explain) {_                    nodeExplanationMap.put(node.getNodeId(),_                        new NodeAllocationResult(node.getRoutingNode().node(), currentDecision, 0))__                    nodeWeights.add(Tuple.tuple(node.getNodeId(), currentWeight))__                }_                if (currentDecision.type() == Type.YES || currentDecision.type() == Type.THROTTLE) {_                    final boolean updateMinNode__                    if (currentWeight == minWeight) {_                        _                        if (currentDecision.type() == decision.type()) {_                            final int repId = shard.id()__                            final int nodeHigh = node.highestPrimary(shard.index().getName())__                            final int minNodeHigh = minNode.highestPrimary(shard.getIndexName())__                            updateMinNode = ((((nodeHigh > repId && minNodeHigh > repId)_                                                   || (nodeHigh < repId && minNodeHigh < repId))_                                                  && (nodeHigh < minNodeHigh))_                                                 || (nodeHigh > minNodeHigh && nodeHigh > repId && minNodeHigh < repId))__                        } else {_                            updateMinNode = currentDecision.type() == Type.YES__                        }_                    } else {_                        updateMinNode = true__                    }_                    if (updateMinNode) {_                        minNode = node__                        minWeight = currentWeight__                        decision = currentDecision__                    }_                }_            }_            if (decision == null) {_                _                decision = Decision.NO__            }_            List<NodeAllocationResult> nodeDecisions = null__            if (explain) {_                nodeDecisions = new ArrayList<>()__                _                nodeWeights.sort((nodeWeight1, nodeWeight2) -> Float.compare(nodeWeight1.v2(), nodeWeight2.v2()))__                int weightRanking = 0__                for (Tuple<String, Float> nodeWeight : nodeWeights) {_                    NodeAllocationResult current = nodeExplanationMap.get(nodeWeight.v1())__                    nodeDecisions.add(new NodeAllocationResult(current.getNode(), current.getCanAllocateDecision(), ++weightRanking))__                }_            }_            return AllocateUnassignedDecision.fromDecision(_                decision,_                minNode != null ? minNode.routingNode.node() : null,_                nodeDecisions_            )__        };make,a,decision,for,allocating,an,unassigned,shard,this,method,returns,a,two,values,in,a,tuple,the,first,value,is,the,link,decision,taken,to,allocate,the,unassigned,shard,the,second,value,is,the,link,model,node,representing,the,node,that,the,shard,should,be,assigned,to,if,the,decision,returned,is,of,type,link,type,no,then,the,assigned,node,will,be,null;private,allocate,unassigned,decision,decide,allocate,unassigned,final,shard,routing,shard,final,set,model,node,throttled,nodes,if,shard,assigned,to,node,return,allocate,unassigned,decision,final,boolean,explain,allocation,debug,decision,decision,shard,level,decision,allocation,deciders,can,allocate,shard,allocation,if,shard,level,decision,type,type,no,explain,false,return,allocate,unassigned,decision,no,allocation,status,null,float,min,weight,float,model,node,min,node,null,decision,decision,null,if,throttled,nodes,size,nodes,size,explain,false,return,allocate,unassigned,decision,no,allocation,status,null,map,string,node,allocation,result,node,explanation,map,explain,new,hash,map,null,list,tuple,string,float,node,weights,explain,new,array,list,null,for,model,node,node,nodes,values,if,throttled,nodes,contains,node,node,contains,shard,shard,explain,false,continue,float,current,weight,weight,weight,shard,added,this,node,shard,get,index,name,if,current,weight,min,weight,explain,false,continue,decision,current,decision,allocation,deciders,can,allocate,shard,node,get,routing,node,allocation,if,explain,node,explanation,map,put,node,get,node,id,new,node,allocation,result,node,get,routing,node,node,current,decision,0,node,weights,add,tuple,tuple,node,get,node,id,current,weight,if,current,decision,type,type,yes,current,decision,type,type,throttle,final,boolean,update,min,node,if,current,weight,min,weight,if,current,decision,type,decision,type,final,int,rep,id,shard,id,final,int,node,high,node,highest,primary,shard,index,get,name,final,int,min,node,high,min,node,highest,primary,shard,get,index,name,update,min,node,node,high,rep,id,min,node,high,rep,id,node,high,rep,id,min,node,high,rep,id,node,high,min,node,high,node,high,min,node,high,node,high,rep,id,min,node,high,rep,id,else,update,min,node,current,decision,type,type,yes,else,update,min,node,true,if,update,min,node,min,node,node,min,weight,current,weight,decision,current,decision,if,decision,null,decision,decision,no,list,node,allocation,result,node,decisions,null,if,explain,node,decisions,new,array,list,node,weights,sort,node,weight1,node,weight2,float,compare,node,weight1,v2,node,weight2,v2,int,weight,ranking,0,for,tuple,string,float,node,weight,node,weights,node,allocation,result,current,node,explanation,map,get,node,weight,v1,node,decisions,add,new,node,allocation,result,current,get,node,current,get,can,allocate,decision,weight,ranking,return,allocate,unassigned,decision,from,decision,decision,min,node,null,min,node,routing,node,node,null,node,decisions
BalancedShardsAllocator -> Balancer -> private AllocateUnassignedDecision decideAllocateUnassigned(final ShardRouting shard, final Set<ModelNode> throttledNodes);1525334055;Make a decision for allocating an unassigned shard.  This method returns a two values in a tuple: the_first value is the {@link Decision} taken to allocate the unassigned shard, the second value is the_{@link ModelNode} representing the node that the shard should be assigned to.  If the decision returned_is of type {@link Type#NO}, then the assigned node will be null.;private AllocateUnassignedDecision decideAllocateUnassigned(final ShardRouting shard, final Set<ModelNode> throttledNodes) {_            if (shard.assignedToNode()) {_                _                return AllocateUnassignedDecision.NOT_TAKEN__            }__            final boolean explain = allocation.debugDecision()__            Decision shardLevelDecision = allocation.deciders().canAllocate(shard, allocation)__            if (shardLevelDecision.type() == Type.NO && explain == false) {_                _                return AllocateUnassignedDecision.no(AllocationStatus.DECIDERS_NO, null)__            }__            _            float minWeight = Float.POSITIVE_INFINITY__            ModelNode minNode = null__            Decision decision = null__            if (throttledNodes.size() >= nodes.size() && explain == false) {_                _                _                return AllocateUnassignedDecision.no(AllocationStatus.DECIDERS_NO, null)__            }_            _            Map<String, NodeAllocationResult> nodeExplanationMap = explain ? new HashMap<>() : null__            List<Tuple<String, Float>> nodeWeights = explain ? new ArrayList<>() : null__            for (ModelNode node : nodes.values()) {_                if ((throttledNodes.contains(node) || node.containsShard(shard)) && explain == false) {_                    _                    continue__                }__                _                float currentWeight = weight.weightShardAdded(this, node, shard.getIndexName())__                _                if (currentWeight > minWeight && explain == false) {_                    continue__                }__                Decision currentDecision = allocation.deciders().canAllocate(shard, node.getRoutingNode(), allocation)__                if (explain) {_                    nodeExplanationMap.put(node.getNodeId(),_                        new NodeAllocationResult(node.getRoutingNode().node(), currentDecision, 0))__                    nodeWeights.add(Tuple.tuple(node.getNodeId(), currentWeight))__                }_                if (currentDecision.type() == Type.YES || currentDecision.type() == Type.THROTTLE) {_                    final boolean updateMinNode__                    if (currentWeight == minWeight) {_                        _                        if (currentDecision.type() == decision.type()) {_                            final int repId = shard.id()__                            final int nodeHigh = node.highestPrimary(shard.index().getName())__                            final int minNodeHigh = minNode.highestPrimary(shard.getIndexName())__                            updateMinNode = ((((nodeHigh > repId && minNodeHigh > repId)_                                                   || (nodeHigh < repId && minNodeHigh < repId))_                                                  && (nodeHigh < minNodeHigh))_                                                 || (nodeHigh > minNodeHigh && nodeHigh > repId && minNodeHigh < repId))__                        } else {_                            updateMinNode = currentDecision.type() == Type.YES__                        }_                    } else {_                        updateMinNode = true__                    }_                    if (updateMinNode) {_                        minNode = node__                        minWeight = currentWeight__                        decision = currentDecision__                    }_                }_            }_            if (decision == null) {_                _                decision = Decision.NO__            }_            List<NodeAllocationResult> nodeDecisions = null__            if (explain) {_                nodeDecisions = new ArrayList<>()__                _                nodeWeights.sort((nodeWeight1, nodeWeight2) -> Float.compare(nodeWeight1.v2(), nodeWeight2.v2()))__                int weightRanking = 0__                for (Tuple<String, Float> nodeWeight : nodeWeights) {_                    NodeAllocationResult current = nodeExplanationMap.get(nodeWeight.v1())__                    nodeDecisions.add(new NodeAllocationResult(current.getNode(), current.getCanAllocateDecision(), ++weightRanking))__                }_            }_            return AllocateUnassignedDecision.fromDecision(_                decision,_                minNode != null ? minNode.routingNode.node() : null,_                nodeDecisions_            )__        };make,a,decision,for,allocating,an,unassigned,shard,this,method,returns,a,two,values,in,a,tuple,the,first,value,is,the,link,decision,taken,to,allocate,the,unassigned,shard,the,second,value,is,the,link,model,node,representing,the,node,that,the,shard,should,be,assigned,to,if,the,decision,returned,is,of,type,link,type,no,then,the,assigned,node,will,be,null;private,allocate,unassigned,decision,decide,allocate,unassigned,final,shard,routing,shard,final,set,model,node,throttled,nodes,if,shard,assigned,to,node,return,allocate,unassigned,decision,final,boolean,explain,allocation,debug,decision,decision,shard,level,decision,allocation,deciders,can,allocate,shard,allocation,if,shard,level,decision,type,type,no,explain,false,return,allocate,unassigned,decision,no,allocation,status,null,float,min,weight,float,model,node,min,node,null,decision,decision,null,if,throttled,nodes,size,nodes,size,explain,false,return,allocate,unassigned,decision,no,allocation,status,null,map,string,node,allocation,result,node,explanation,map,explain,new,hash,map,null,list,tuple,string,float,node,weights,explain,new,array,list,null,for,model,node,node,nodes,values,if,throttled,nodes,contains,node,node,contains,shard,shard,explain,false,continue,float,current,weight,weight,weight,shard,added,this,node,shard,get,index,name,if,current,weight,min,weight,explain,false,continue,decision,current,decision,allocation,deciders,can,allocate,shard,node,get,routing,node,allocation,if,explain,node,explanation,map,put,node,get,node,id,new,node,allocation,result,node,get,routing,node,node,current,decision,0,node,weights,add,tuple,tuple,node,get,node,id,current,weight,if,current,decision,type,type,yes,current,decision,type,type,throttle,final,boolean,update,min,node,if,current,weight,min,weight,if,current,decision,type,decision,type,final,int,rep,id,shard,id,final,int,node,high,node,highest,primary,shard,index,get,name,final,int,min,node,high,min,node,highest,primary,shard,get,index,name,update,min,node,node,high,rep,id,min,node,high,rep,id,node,high,rep,id,min,node,high,rep,id,node,high,min,node,high,node,high,min,node,high,node,high,rep,id,min,node,high,rep,id,else,update,min,node,current,decision,type,type,yes,else,update,min,node,true,if,update,min,node,min,node,node,min,weight,current,weight,decision,current,decision,if,decision,null,decision,decision,no,list,node,allocation,result,node,decisions,null,if,explain,node,decisions,new,array,list,node,weights,sort,node,weight1,node,weight2,float,compare,node,weight1,v2,node,weight2,v2,int,weight,ranking,0,for,tuple,string,float,node,weight,node,weights,node,allocation,result,current,node,explanation,map,get,node,weight,v1,node,decisions,add,new,node,allocation,result,current,get,node,current,get,can,allocate,decision,weight,ranking,return,allocate,unassigned,decision,from,decision,decision,min,node,null,min,node,routing,node,node,null,node,decisions
BalancedShardsAllocator -> Balancer -> private AllocateUnassignedDecision decideAllocateUnassigned(final ShardRouting shard, final Set<ModelNode> throttledNodes);1531234550;Make a decision for allocating an unassigned shard.  This method returns a two values in a tuple: the_first value is the {@link Decision} taken to allocate the unassigned shard, the second value is the_{@link ModelNode} representing the node that the shard should be assigned to.  If the decision returned_is of type {@link Type#NO}, then the assigned node will be null.;private AllocateUnassignedDecision decideAllocateUnassigned(final ShardRouting shard, final Set<ModelNode> throttledNodes) {_            if (shard.assignedToNode()) {_                _                return AllocateUnassignedDecision.NOT_TAKEN__            }__            final boolean explain = allocation.debugDecision()__            Decision shardLevelDecision = allocation.deciders().canAllocate(shard, allocation)__            if (shardLevelDecision.type() == Type.NO && explain == false) {_                _                return AllocateUnassignedDecision.no(AllocationStatus.DECIDERS_NO, null)__            }__            _            float minWeight = Float.POSITIVE_INFINITY__            ModelNode minNode = null__            Decision decision = null__            if (throttledNodes.size() >= nodes.size() && explain == false) {_                _                _                return AllocateUnassignedDecision.no(AllocationStatus.DECIDERS_NO, null)__            }_            _            Map<String, NodeAllocationResult> nodeExplanationMap = explain ? new HashMap<>() : null__            List<Tuple<String, Float>> nodeWeights = explain ? new ArrayList<>() : null__            for (ModelNode node : nodes.values()) {_                if ((throttledNodes.contains(node) || node.containsShard(shard)) && explain == false) {_                    _                    continue__                }__                _                float currentWeight = weight.weightShardAdded(this, node, shard.getIndexName())__                _                if (currentWeight > minWeight && explain == false) {_                    continue__                }__                Decision currentDecision = allocation.deciders().canAllocate(shard, node.getRoutingNode(), allocation)__                if (explain) {_                    nodeExplanationMap.put(node.getNodeId(),_                        new NodeAllocationResult(node.getRoutingNode().node(), currentDecision, 0))__                    nodeWeights.add(Tuple.tuple(node.getNodeId(), currentWeight))__                }_                if (currentDecision.type() == Type.YES || currentDecision.type() == Type.THROTTLE) {_                    final boolean updateMinNode__                    if (currentWeight == minWeight) {_                        _                        if (currentDecision.type() == decision.type()) {_                            final int repId = shard.id()__                            final int nodeHigh = node.highestPrimary(shard.index().getName())__                            final int minNodeHigh = minNode.highestPrimary(shard.getIndexName())__                            updateMinNode = ((((nodeHigh > repId && minNodeHigh > repId)_                                                   || (nodeHigh < repId && minNodeHigh < repId))_                                                  && (nodeHigh < minNodeHigh))_                                                 || (nodeHigh > minNodeHigh && nodeHigh > repId && minNodeHigh < repId))__                        } else {_                            updateMinNode = currentDecision.type() == Type.YES__                        }_                    } else {_                        updateMinNode = true__                    }_                    if (updateMinNode) {_                        minNode = node__                        minWeight = currentWeight__                        decision = currentDecision__                    }_                }_            }_            if (decision == null) {_                _                decision = Decision.NO__            }_            List<NodeAllocationResult> nodeDecisions = null__            if (explain) {_                nodeDecisions = new ArrayList<>()__                _                nodeWeights.sort((nodeWeight1, nodeWeight2) -> Float.compare(nodeWeight1.v2(), nodeWeight2.v2()))__                int weightRanking = 0__                for (Tuple<String, Float> nodeWeight : nodeWeights) {_                    NodeAllocationResult current = nodeExplanationMap.get(nodeWeight.v1())__                    nodeDecisions.add(new NodeAllocationResult(current.getNode(), current.getCanAllocateDecision(), ++weightRanking))__                }_            }_            return AllocateUnassignedDecision.fromDecision(_                decision,_                minNode != null ? minNode.routingNode.node() : null,_                nodeDecisions_            )__        };make,a,decision,for,allocating,an,unassigned,shard,this,method,returns,a,two,values,in,a,tuple,the,first,value,is,the,link,decision,taken,to,allocate,the,unassigned,shard,the,second,value,is,the,link,model,node,representing,the,node,that,the,shard,should,be,assigned,to,if,the,decision,returned,is,of,type,link,type,no,then,the,assigned,node,will,be,null;private,allocate,unassigned,decision,decide,allocate,unassigned,final,shard,routing,shard,final,set,model,node,throttled,nodes,if,shard,assigned,to,node,return,allocate,unassigned,decision,final,boolean,explain,allocation,debug,decision,decision,shard,level,decision,allocation,deciders,can,allocate,shard,allocation,if,shard,level,decision,type,type,no,explain,false,return,allocate,unassigned,decision,no,allocation,status,null,float,min,weight,float,model,node,min,node,null,decision,decision,null,if,throttled,nodes,size,nodes,size,explain,false,return,allocate,unassigned,decision,no,allocation,status,null,map,string,node,allocation,result,node,explanation,map,explain,new,hash,map,null,list,tuple,string,float,node,weights,explain,new,array,list,null,for,model,node,node,nodes,values,if,throttled,nodes,contains,node,node,contains,shard,shard,explain,false,continue,float,current,weight,weight,weight,shard,added,this,node,shard,get,index,name,if,current,weight,min,weight,explain,false,continue,decision,current,decision,allocation,deciders,can,allocate,shard,node,get,routing,node,allocation,if,explain,node,explanation,map,put,node,get,node,id,new,node,allocation,result,node,get,routing,node,node,current,decision,0,node,weights,add,tuple,tuple,node,get,node,id,current,weight,if,current,decision,type,type,yes,current,decision,type,type,throttle,final,boolean,update,min,node,if,current,weight,min,weight,if,current,decision,type,decision,type,final,int,rep,id,shard,id,final,int,node,high,node,highest,primary,shard,index,get,name,final,int,min,node,high,min,node,highest,primary,shard,get,index,name,update,min,node,node,high,rep,id,min,node,high,rep,id,node,high,rep,id,min,node,high,rep,id,node,high,min,node,high,node,high,min,node,high,node,high,rep,id,min,node,high,rep,id,else,update,min,node,current,decision,type,type,yes,else,update,min,node,true,if,update,min,node,min,node,node,min,weight,current,weight,decision,current,decision,if,decision,null,decision,decision,no,list,node,allocation,result,node,decisions,null,if,explain,node,decisions,new,array,list,node,weights,sort,node,weight1,node,weight2,float,compare,node,weight1,v2,node,weight2,v2,int,weight,ranking,0,for,tuple,string,float,node,weight,node,weights,node,allocation,result,current,node,explanation,map,get,node,weight,v1,node,decisions,add,new,node,allocation,result,current,get,node,current,get,can,allocate,decision,weight,ranking,return,allocate,unassigned,decision,from,decision,decision,min,node,null,min,node,routing,node,node,null,node,decisions
BalancedShardsAllocator -> Balancer -> private AllocateUnassignedDecision decideAllocateUnassigned(final ShardRouting shard, final Set<ModelNode> throttledNodes);1540847035;Make a decision for allocating an unassigned shard.  This method returns a two values in a tuple: the_first value is the {@link Decision} taken to allocate the unassigned shard, the second value is the_{@link ModelNode} representing the node that the shard should be assigned to.  If the decision returned_is of type {@link Type#NO}, then the assigned node will be null.;private AllocateUnassignedDecision decideAllocateUnassigned(final ShardRouting shard, final Set<ModelNode> throttledNodes) {_            if (shard.assignedToNode()) {_                _                return AllocateUnassignedDecision.NOT_TAKEN__            }__            final boolean explain = allocation.debugDecision()__            Decision shardLevelDecision = allocation.deciders().canAllocate(shard, allocation)__            if (shardLevelDecision.type() == Type.NO && explain == false) {_                _                return AllocateUnassignedDecision.no(AllocationStatus.DECIDERS_NO, null)__            }__            _            float minWeight = Float.POSITIVE_INFINITY__            ModelNode minNode = null__            Decision decision = null__            if (throttledNodes.size() >= nodes.size() && explain == false) {_                _                _                return AllocateUnassignedDecision.no(AllocationStatus.DECIDERS_NO, null)__            }_            _            Map<String, NodeAllocationResult> nodeExplanationMap = explain ? new HashMap<>() : null__            List<Tuple<String, Float>> nodeWeights = explain ? new ArrayList<>() : null__            for (ModelNode node : nodes.values()) {_                if ((throttledNodes.contains(node) || node.containsShard(shard)) && explain == false) {_                    _                    continue__                }__                _                float currentWeight = weight.weightShardAdded(this, node, shard.getIndexName())__                _                if (currentWeight > minWeight && explain == false) {_                    continue__                }__                Decision currentDecision = allocation.deciders().canAllocate(shard, node.getRoutingNode(), allocation)__                if (explain) {_                    nodeExplanationMap.put(node.getNodeId(),_                        new NodeAllocationResult(node.getRoutingNode().node(), currentDecision, 0))__                    nodeWeights.add(Tuple.tuple(node.getNodeId(), currentWeight))__                }_                if (currentDecision.type() == Type.YES || currentDecision.type() == Type.THROTTLE) {_                    final boolean updateMinNode__                    if (currentWeight == minWeight) {_                        _                        if (currentDecision.type() == decision.type()) {_                            final int repId = shard.id()__                            final int nodeHigh = node.highestPrimary(shard.index().getName())__                            final int minNodeHigh = minNode.highestPrimary(shard.getIndexName())__                            updateMinNode = ((((nodeHigh > repId && minNodeHigh > repId)_                                                   || (nodeHigh < repId && minNodeHigh < repId))_                                                  && (nodeHigh < minNodeHigh))_                                                 || (nodeHigh > minNodeHigh && nodeHigh > repId && minNodeHigh < repId))__                        } else {_                            updateMinNode = currentDecision.type() == Type.YES__                        }_                    } else {_                        updateMinNode = true__                    }_                    if (updateMinNode) {_                        minNode = node__                        minWeight = currentWeight__                        decision = currentDecision__                    }_                }_            }_            if (decision == null) {_                _                decision = Decision.NO__            }_            List<NodeAllocationResult> nodeDecisions = null__            if (explain) {_                nodeDecisions = new ArrayList<>()__                _                nodeWeights.sort((nodeWeight1, nodeWeight2) -> Float.compare(nodeWeight1.v2(), nodeWeight2.v2()))__                int weightRanking = 0__                for (Tuple<String, Float> nodeWeight : nodeWeights) {_                    NodeAllocationResult current = nodeExplanationMap.get(nodeWeight.v1())__                    nodeDecisions.add(new NodeAllocationResult(current.getNode(), current.getCanAllocateDecision(), ++weightRanking))__                }_            }_            return AllocateUnassignedDecision.fromDecision(_                decision,_                minNode != null ? minNode.routingNode.node() : null,_                nodeDecisions_            )__        };make,a,decision,for,allocating,an,unassigned,shard,this,method,returns,a,two,values,in,a,tuple,the,first,value,is,the,link,decision,taken,to,allocate,the,unassigned,shard,the,second,value,is,the,link,model,node,representing,the,node,that,the,shard,should,be,assigned,to,if,the,decision,returned,is,of,type,link,type,no,then,the,assigned,node,will,be,null;private,allocate,unassigned,decision,decide,allocate,unassigned,final,shard,routing,shard,final,set,model,node,throttled,nodes,if,shard,assigned,to,node,return,allocate,unassigned,decision,final,boolean,explain,allocation,debug,decision,decision,shard,level,decision,allocation,deciders,can,allocate,shard,allocation,if,shard,level,decision,type,type,no,explain,false,return,allocate,unassigned,decision,no,allocation,status,null,float,min,weight,float,model,node,min,node,null,decision,decision,null,if,throttled,nodes,size,nodes,size,explain,false,return,allocate,unassigned,decision,no,allocation,status,null,map,string,node,allocation,result,node,explanation,map,explain,new,hash,map,null,list,tuple,string,float,node,weights,explain,new,array,list,null,for,model,node,node,nodes,values,if,throttled,nodes,contains,node,node,contains,shard,shard,explain,false,continue,float,current,weight,weight,weight,shard,added,this,node,shard,get,index,name,if,current,weight,min,weight,explain,false,continue,decision,current,decision,allocation,deciders,can,allocate,shard,node,get,routing,node,allocation,if,explain,node,explanation,map,put,node,get,node,id,new,node,allocation,result,node,get,routing,node,node,current,decision,0,node,weights,add,tuple,tuple,node,get,node,id,current,weight,if,current,decision,type,type,yes,current,decision,type,type,throttle,final,boolean,update,min,node,if,current,weight,min,weight,if,current,decision,type,decision,type,final,int,rep,id,shard,id,final,int,node,high,node,highest,primary,shard,index,get,name,final,int,min,node,high,min,node,highest,primary,shard,get,index,name,update,min,node,node,high,rep,id,min,node,high,rep,id,node,high,rep,id,min,node,high,rep,id,node,high,min,node,high,node,high,min,node,high,node,high,rep,id,min,node,high,rep,id,else,update,min,node,current,decision,type,type,yes,else,update,min,node,true,if,update,min,node,min,node,node,min,weight,current,weight,decision,current,decision,if,decision,null,decision,decision,no,list,node,allocation,result,node,decisions,null,if,explain,node,decisions,new,array,list,node,weights,sort,node,weight1,node,weight2,float,compare,node,weight1,v2,node,weight2,v2,int,weight,ranking,0,for,tuple,string,float,node,weight,node,weights,node,allocation,result,current,node,explanation,map,get,node,weight,v1,node,decisions,add,new,node,allocation,result,current,get,node,current,get,can,allocate,decision,weight,ranking,return,allocate,unassigned,decision,from,decision,decision,min,node,null,min,node,routing,node,node,null,node,decisions
BalancedShardsAllocator -> Balancer -> private AllocateUnassignedDecision decideAllocateUnassigned(final ShardRouting shard, final Set<ModelNode> throttledNodes);1541092382;Make a decision for allocating an unassigned shard.  This method returns a two values in a tuple: the_first value is the {@link Decision} taken to allocate the unassigned shard, the second value is the_{@link ModelNode} representing the node that the shard should be assigned to.  If the decision returned_is of type {@link Type#NO}, then the assigned node will be null.;private AllocateUnassignedDecision decideAllocateUnassigned(final ShardRouting shard, final Set<ModelNode> throttledNodes) {_            if (shard.assignedToNode()) {_                _                return AllocateUnassignedDecision.NOT_TAKEN__            }__            final boolean explain = allocation.debugDecision()__            Decision shardLevelDecision = allocation.deciders().canAllocate(shard, allocation)__            if (shardLevelDecision.type() == Type.NO && explain == false) {_                _                return AllocateUnassignedDecision.no(AllocationStatus.DECIDERS_NO, null)__            }__            _            float minWeight = Float.POSITIVE_INFINITY__            ModelNode minNode = null__            Decision decision = null__            if (throttledNodes.size() >= nodes.size() && explain == false) {_                _                _                return AllocateUnassignedDecision.no(AllocationStatus.DECIDERS_NO, null)__            }_            _            Map<String, NodeAllocationResult> nodeExplanationMap = explain ? new HashMap<>() : null__            List<Tuple<String, Float>> nodeWeights = explain ? new ArrayList<>() : null__            for (ModelNode node : nodes.values()) {_                if ((throttledNodes.contains(node) || node.containsShard(shard)) && explain == false) {_                    _                    continue__                }__                _                float currentWeight = weight.weightShardAdded(this, node, shard.getIndexName())__                _                if (currentWeight > minWeight && explain == false) {_                    continue__                }__                Decision currentDecision = allocation.deciders().canAllocate(shard, node.getRoutingNode(), allocation)__                if (explain) {_                    nodeExplanationMap.put(node.getNodeId(),_                        new NodeAllocationResult(node.getRoutingNode().node(), currentDecision, 0))__                    nodeWeights.add(Tuple.tuple(node.getNodeId(), currentWeight))__                }_                if (currentDecision.type() == Type.YES || currentDecision.type() == Type.THROTTLE) {_                    final boolean updateMinNode__                    if (currentWeight == minWeight) {_                        _                        if (currentDecision.type() == decision.type()) {_                            final int repId = shard.id()__                            final int nodeHigh = node.highestPrimary(shard.index().getName())__                            final int minNodeHigh = minNode.highestPrimary(shard.getIndexName())__                            updateMinNode = ((((nodeHigh > repId && minNodeHigh > repId)_                                                   || (nodeHigh < repId && minNodeHigh < repId))_                                                  && (nodeHigh < minNodeHigh))_                                                 || (nodeHigh > minNodeHigh && nodeHigh > repId && minNodeHigh < repId))__                        } else {_                            updateMinNode = currentDecision.type() == Type.YES__                        }_                    } else {_                        updateMinNode = true__                    }_                    if (updateMinNode) {_                        minNode = node__                        minWeight = currentWeight__                        decision = currentDecision__                    }_                }_            }_            if (decision == null) {_                _                decision = Decision.NO__            }_            List<NodeAllocationResult> nodeDecisions = null__            if (explain) {_                nodeDecisions = new ArrayList<>()__                _                nodeWeights.sort((nodeWeight1, nodeWeight2) -> Float.compare(nodeWeight1.v2(), nodeWeight2.v2()))__                int weightRanking = 0__                for (Tuple<String, Float> nodeWeight : nodeWeights) {_                    NodeAllocationResult current = nodeExplanationMap.get(nodeWeight.v1())__                    nodeDecisions.add(new NodeAllocationResult(current.getNode(), current.getCanAllocateDecision(), ++weightRanking))__                }_            }_            return AllocateUnassignedDecision.fromDecision(_                decision,_                minNode != null ? minNode.routingNode.node() : null,_                nodeDecisions_            )__        };make,a,decision,for,allocating,an,unassigned,shard,this,method,returns,a,two,values,in,a,tuple,the,first,value,is,the,link,decision,taken,to,allocate,the,unassigned,shard,the,second,value,is,the,link,model,node,representing,the,node,that,the,shard,should,be,assigned,to,if,the,decision,returned,is,of,type,link,type,no,then,the,assigned,node,will,be,null;private,allocate,unassigned,decision,decide,allocate,unassigned,final,shard,routing,shard,final,set,model,node,throttled,nodes,if,shard,assigned,to,node,return,allocate,unassigned,decision,final,boolean,explain,allocation,debug,decision,decision,shard,level,decision,allocation,deciders,can,allocate,shard,allocation,if,shard,level,decision,type,type,no,explain,false,return,allocate,unassigned,decision,no,allocation,status,null,float,min,weight,float,model,node,min,node,null,decision,decision,null,if,throttled,nodes,size,nodes,size,explain,false,return,allocate,unassigned,decision,no,allocation,status,null,map,string,node,allocation,result,node,explanation,map,explain,new,hash,map,null,list,tuple,string,float,node,weights,explain,new,array,list,null,for,model,node,node,nodes,values,if,throttled,nodes,contains,node,node,contains,shard,shard,explain,false,continue,float,current,weight,weight,weight,shard,added,this,node,shard,get,index,name,if,current,weight,min,weight,explain,false,continue,decision,current,decision,allocation,deciders,can,allocate,shard,node,get,routing,node,allocation,if,explain,node,explanation,map,put,node,get,node,id,new,node,allocation,result,node,get,routing,node,node,current,decision,0,node,weights,add,tuple,tuple,node,get,node,id,current,weight,if,current,decision,type,type,yes,current,decision,type,type,throttle,final,boolean,update,min,node,if,current,weight,min,weight,if,current,decision,type,decision,type,final,int,rep,id,shard,id,final,int,node,high,node,highest,primary,shard,index,get,name,final,int,min,node,high,min,node,highest,primary,shard,get,index,name,update,min,node,node,high,rep,id,min,node,high,rep,id,node,high,rep,id,min,node,high,rep,id,node,high,min,node,high,node,high,min,node,high,node,high,rep,id,min,node,high,rep,id,else,update,min,node,current,decision,type,type,yes,else,update,min,node,true,if,update,min,node,min,node,node,min,weight,current,weight,decision,current,decision,if,decision,null,decision,decision,no,list,node,allocation,result,node,decisions,null,if,explain,node,decisions,new,array,list,node,weights,sort,node,weight1,node,weight2,float,compare,node,weight1,v2,node,weight2,v2,int,weight,ranking,0,for,tuple,string,float,node,weight,node,weights,node,allocation,result,current,node,explanation,map,get,node,weight,v1,node,decisions,add,new,node,allocation,result,current,get,node,current,get,can,allocate,decision,weight,ranking,return,allocate,unassigned,decision,from,decision,decision,min,node,null,min,node,routing,node,node,null,node,decisions
BalancedShardsAllocator -> Balancer -> private AllocateUnassignedDecision decideAllocateUnassigned(final ShardRouting shard, final Set<ModelNode> throttledNodes);1541446827;Make a decision for allocating an unassigned shard.  This method returns a two values in a tuple: the_first value is the {@link Decision} taken to allocate the unassigned shard, the second value is the_{@link ModelNode} representing the node that the shard should be assigned to.  If the decision returned_is of type {@link Type#NO}, then the assigned node will be null.;private AllocateUnassignedDecision decideAllocateUnassigned(final ShardRouting shard, final Set<ModelNode> throttledNodes) {_            if (shard.assignedToNode()) {_                _                return AllocateUnassignedDecision.NOT_TAKEN__            }__            final boolean explain = allocation.debugDecision()__            Decision shardLevelDecision = allocation.deciders().canAllocate(shard, allocation)__            if (shardLevelDecision.type() == Type.NO && explain == false) {_                _                return AllocateUnassignedDecision.no(AllocationStatus.DECIDERS_NO, null)__            }__            _            float minWeight = Float.POSITIVE_INFINITY__            ModelNode minNode = null__            Decision decision = null__            if (throttledNodes.size() >= nodes.size() && explain == false) {_                _                _                return AllocateUnassignedDecision.no(AllocationStatus.DECIDERS_NO, null)__            }_            _            Map<String, NodeAllocationResult> nodeExplanationMap = explain ? new HashMap<>() : null__            List<Tuple<String, Float>> nodeWeights = explain ? new ArrayList<>() : null__            for (ModelNode node : nodes.values()) {_                if ((throttledNodes.contains(node) || node.containsShard(shard)) && explain == false) {_                    _                    continue__                }__                _                float currentWeight = weight.weightShardAdded(this, node, shard.getIndexName())__                _                if (currentWeight > minWeight && explain == false) {_                    continue__                }__                Decision currentDecision = allocation.deciders().canAllocate(shard, node.getRoutingNode(), allocation)__                if (explain) {_                    nodeExplanationMap.put(node.getNodeId(),_                        new NodeAllocationResult(node.getRoutingNode().node(), currentDecision, 0))__                    nodeWeights.add(Tuple.tuple(node.getNodeId(), currentWeight))__                }_                if (currentDecision.type() == Type.YES || currentDecision.type() == Type.THROTTLE) {_                    final boolean updateMinNode__                    if (currentWeight == minWeight) {_                        _                        if (currentDecision.type() == decision.type()) {_                            final int repId = shard.id()__                            final int nodeHigh = node.highestPrimary(shard.index().getName())__                            final int minNodeHigh = minNode.highestPrimary(shard.getIndexName())__                            updateMinNode = ((((nodeHigh > repId && minNodeHigh > repId)_                                                   || (nodeHigh < repId && minNodeHigh < repId))_                                                  && (nodeHigh < minNodeHigh))_                                                 || (nodeHigh > minNodeHigh && nodeHigh > repId && minNodeHigh < repId))__                        } else {_                            updateMinNode = currentDecision.type() == Type.YES__                        }_                    } else {_                        updateMinNode = true__                    }_                    if (updateMinNode) {_                        minNode = node__                        minWeight = currentWeight__                        decision = currentDecision__                    }_                }_            }_            if (decision == null) {_                _                decision = Decision.NO__            }_            List<NodeAllocationResult> nodeDecisions = null__            if (explain) {_                nodeDecisions = new ArrayList<>()__                _                nodeWeights.sort((nodeWeight1, nodeWeight2) -> Float.compare(nodeWeight1.v2(), nodeWeight2.v2()))__                int weightRanking = 0__                for (Tuple<String, Float> nodeWeight : nodeWeights) {_                    NodeAllocationResult current = nodeExplanationMap.get(nodeWeight.v1())__                    nodeDecisions.add(new NodeAllocationResult(current.getNode(), current.getCanAllocateDecision(), ++weightRanking))__                }_            }_            return AllocateUnassignedDecision.fromDecision(_                decision,_                minNode != null ? minNode.routingNode.node() : null,_                nodeDecisions_            )__        };make,a,decision,for,allocating,an,unassigned,shard,this,method,returns,a,two,values,in,a,tuple,the,first,value,is,the,link,decision,taken,to,allocate,the,unassigned,shard,the,second,value,is,the,link,model,node,representing,the,node,that,the,shard,should,be,assigned,to,if,the,decision,returned,is,of,type,link,type,no,then,the,assigned,node,will,be,null;private,allocate,unassigned,decision,decide,allocate,unassigned,final,shard,routing,shard,final,set,model,node,throttled,nodes,if,shard,assigned,to,node,return,allocate,unassigned,decision,final,boolean,explain,allocation,debug,decision,decision,shard,level,decision,allocation,deciders,can,allocate,shard,allocation,if,shard,level,decision,type,type,no,explain,false,return,allocate,unassigned,decision,no,allocation,status,null,float,min,weight,float,model,node,min,node,null,decision,decision,null,if,throttled,nodes,size,nodes,size,explain,false,return,allocate,unassigned,decision,no,allocation,status,null,map,string,node,allocation,result,node,explanation,map,explain,new,hash,map,null,list,tuple,string,float,node,weights,explain,new,array,list,null,for,model,node,node,nodes,values,if,throttled,nodes,contains,node,node,contains,shard,shard,explain,false,continue,float,current,weight,weight,weight,shard,added,this,node,shard,get,index,name,if,current,weight,min,weight,explain,false,continue,decision,current,decision,allocation,deciders,can,allocate,shard,node,get,routing,node,allocation,if,explain,node,explanation,map,put,node,get,node,id,new,node,allocation,result,node,get,routing,node,node,current,decision,0,node,weights,add,tuple,tuple,node,get,node,id,current,weight,if,current,decision,type,type,yes,current,decision,type,type,throttle,final,boolean,update,min,node,if,current,weight,min,weight,if,current,decision,type,decision,type,final,int,rep,id,shard,id,final,int,node,high,node,highest,primary,shard,index,get,name,final,int,min,node,high,min,node,highest,primary,shard,get,index,name,update,min,node,node,high,rep,id,min,node,high,rep,id,node,high,rep,id,min,node,high,rep,id,node,high,min,node,high,node,high,min,node,high,node,high,rep,id,min,node,high,rep,id,else,update,min,node,current,decision,type,type,yes,else,update,min,node,true,if,update,min,node,min,node,node,min,weight,current,weight,decision,current,decision,if,decision,null,decision,decision,no,list,node,allocation,result,node,decisions,null,if,explain,node,decisions,new,array,list,node,weights,sort,node,weight1,node,weight2,float,compare,node,weight1,v2,node,weight2,v2,int,weight,ranking,0,for,tuple,string,float,node,weight,node,weights,node,allocation,result,current,node,explanation,map,get,node,weight,v1,node,decisions,add,new,node,allocation,result,current,get,node,current,get,can,allocate,decision,weight,ranking,return,allocate,unassigned,decision,from,decision,decision,min,node,null,min,node,routing,node,node,null,node,decisions
BalancedShardsAllocator -> Balancer -> private AllocateUnassignedDecision decideAllocateUnassigned(final ShardRouting shard, final Set<ModelNode> throttledNodes);1542402632;Make a decision for allocating an unassigned shard.  This method returns a two values in a tuple: the_first value is the {@link Decision} taken to allocate the unassigned shard, the second value is the_{@link ModelNode} representing the node that the shard should be assigned to.  If the decision returned_is of type {@link Type#NO}, then the assigned node will be null.;private AllocateUnassignedDecision decideAllocateUnassigned(final ShardRouting shard, final Set<ModelNode> throttledNodes) {_            if (shard.assignedToNode()) {_                _                return AllocateUnassignedDecision.NOT_TAKEN__            }__            final boolean explain = allocation.debugDecision()__            Decision shardLevelDecision = allocation.deciders().canAllocate(shard, allocation)__            if (shardLevelDecision.type() == Type.NO && explain == false) {_                _                return AllocateUnassignedDecision.no(AllocationStatus.DECIDERS_NO, null)__            }__            _            float minWeight = Float.POSITIVE_INFINITY__            ModelNode minNode = null__            Decision decision = null__            if (throttledNodes.size() >= nodes.size() && explain == false) {_                _                _                return AllocateUnassignedDecision.no(AllocationStatus.DECIDERS_NO, null)__            }_            _            Map<String, NodeAllocationResult> nodeExplanationMap = explain ? new HashMap<>() : null__            List<Tuple<String, Float>> nodeWeights = explain ? new ArrayList<>() : null__            for (ModelNode node : nodes.values()) {_                if ((throttledNodes.contains(node) || node.containsShard(shard)) && explain == false) {_                    _                    continue__                }__                _                float currentWeight = weight.weightShardAdded(this, node, shard.getIndexName())__                _                if (currentWeight > minWeight && explain == false) {_                    continue__                }__                Decision currentDecision = allocation.deciders().canAllocate(shard, node.getRoutingNode(), allocation)__                if (explain) {_                    nodeExplanationMap.put(node.getNodeId(),_                        new NodeAllocationResult(node.getRoutingNode().node(), currentDecision, 0))__                    nodeWeights.add(Tuple.tuple(node.getNodeId(), currentWeight))__                }_                if (currentDecision.type() == Type.YES || currentDecision.type() == Type.THROTTLE) {_                    final boolean updateMinNode__                    if (currentWeight == minWeight) {_                        _                        if (currentDecision.type() == decision.type()) {_                            final int repId = shard.id()__                            final int nodeHigh = node.highestPrimary(shard.index().getName())__                            final int minNodeHigh = minNode.highestPrimary(shard.getIndexName())__                            updateMinNode = ((((nodeHigh > repId && minNodeHigh > repId)_                                                   || (nodeHigh < repId && minNodeHigh < repId))_                                                  && (nodeHigh < minNodeHigh))_                                                 || (nodeHigh > minNodeHigh && nodeHigh > repId && minNodeHigh < repId))__                        } else {_                            updateMinNode = currentDecision.type() == Type.YES__                        }_                    } else {_                        updateMinNode = true__                    }_                    if (updateMinNode) {_                        minNode = node__                        minWeight = currentWeight__                        decision = currentDecision__                    }_                }_            }_            if (decision == null) {_                _                decision = Decision.NO__            }_            List<NodeAllocationResult> nodeDecisions = null__            if (explain) {_                nodeDecisions = new ArrayList<>()__                _                nodeWeights.sort((nodeWeight1, nodeWeight2) -> Float.compare(nodeWeight1.v2(), nodeWeight2.v2()))__                int weightRanking = 0__                for (Tuple<String, Float> nodeWeight : nodeWeights) {_                    NodeAllocationResult current = nodeExplanationMap.get(nodeWeight.v1())__                    nodeDecisions.add(new NodeAllocationResult(current.getNode(), current.getCanAllocateDecision(), ++weightRanking))__                }_            }_            return AllocateUnassignedDecision.fromDecision(_                decision,_                minNode != null ? minNode.routingNode.node() : null,_                nodeDecisions_            )__        };make,a,decision,for,allocating,an,unassigned,shard,this,method,returns,a,two,values,in,a,tuple,the,first,value,is,the,link,decision,taken,to,allocate,the,unassigned,shard,the,second,value,is,the,link,model,node,representing,the,node,that,the,shard,should,be,assigned,to,if,the,decision,returned,is,of,type,link,type,no,then,the,assigned,node,will,be,null;private,allocate,unassigned,decision,decide,allocate,unassigned,final,shard,routing,shard,final,set,model,node,throttled,nodes,if,shard,assigned,to,node,return,allocate,unassigned,decision,final,boolean,explain,allocation,debug,decision,decision,shard,level,decision,allocation,deciders,can,allocate,shard,allocation,if,shard,level,decision,type,type,no,explain,false,return,allocate,unassigned,decision,no,allocation,status,null,float,min,weight,float,model,node,min,node,null,decision,decision,null,if,throttled,nodes,size,nodes,size,explain,false,return,allocate,unassigned,decision,no,allocation,status,null,map,string,node,allocation,result,node,explanation,map,explain,new,hash,map,null,list,tuple,string,float,node,weights,explain,new,array,list,null,for,model,node,node,nodes,values,if,throttled,nodes,contains,node,node,contains,shard,shard,explain,false,continue,float,current,weight,weight,weight,shard,added,this,node,shard,get,index,name,if,current,weight,min,weight,explain,false,continue,decision,current,decision,allocation,deciders,can,allocate,shard,node,get,routing,node,allocation,if,explain,node,explanation,map,put,node,get,node,id,new,node,allocation,result,node,get,routing,node,node,current,decision,0,node,weights,add,tuple,tuple,node,get,node,id,current,weight,if,current,decision,type,type,yes,current,decision,type,type,throttle,final,boolean,update,min,node,if,current,weight,min,weight,if,current,decision,type,decision,type,final,int,rep,id,shard,id,final,int,node,high,node,highest,primary,shard,index,get,name,final,int,min,node,high,min,node,highest,primary,shard,get,index,name,update,min,node,node,high,rep,id,min,node,high,rep,id,node,high,rep,id,min,node,high,rep,id,node,high,min,node,high,node,high,min,node,high,node,high,rep,id,min,node,high,rep,id,else,update,min,node,current,decision,type,type,yes,else,update,min,node,true,if,update,min,node,min,node,node,min,weight,current,weight,decision,current,decision,if,decision,null,decision,decision,no,list,node,allocation,result,node,decisions,null,if,explain,node,decisions,new,array,list,node,weights,sort,node,weight1,node,weight2,float,compare,node,weight1,v2,node,weight2,v2,int,weight,ranking,0,for,tuple,string,float,node,weight,node,weights,node,allocation,result,current,node,explanation,map,get,node,weight,v1,node,decisions,add,new,node,allocation,result,current,get,node,current,get,can,allocate,decision,weight,ranking,return,allocate,unassigned,decision,from,decision,decision,min,node,null,min,node,routing,node,node,null,node,decisions
BalancedShardsAllocator -> Balancer -> private AllocateUnassignedDecision decideAllocateUnassigned(final ShardRouting shard, final Set<ModelNode> throttledNodes);1549912434;Make a decision for allocating an unassigned shard.  This method returns a two values in a tuple: the_first value is the {@link Decision} taken to allocate the unassigned shard, the second value is the_{@link ModelNode} representing the node that the shard should be assigned to.  If the decision returned_is of type {@link Type#NO}, then the assigned node will be null.;private AllocateUnassignedDecision decideAllocateUnassigned(final ShardRouting shard, final Set<ModelNode> throttledNodes) {_            if (shard.assignedToNode()) {_                _                return AllocateUnassignedDecision.NOT_TAKEN__            }__            final boolean explain = allocation.debugDecision()__            Decision shardLevelDecision = allocation.deciders().canAllocate(shard, allocation)__            if (shardLevelDecision.type() == Type.NO && explain == false) {_                _                return AllocateUnassignedDecision.no(AllocationStatus.DECIDERS_NO, null)__            }__            _            float minWeight = Float.POSITIVE_INFINITY__            ModelNode minNode = null__            Decision decision = null__            if (throttledNodes.size() >= nodes.size() && explain == false) {_                _                _                return AllocateUnassignedDecision.no(AllocationStatus.DECIDERS_NO, null)__            }_            _            Map<String, NodeAllocationResult> nodeExplanationMap = explain ? new HashMap<>() : null__            List<Tuple<String, Float>> nodeWeights = explain ? new ArrayList<>() : null__            for (ModelNode node : nodes.values()) {_                if ((throttledNodes.contains(node) || node.containsShard(shard)) && explain == false) {_                    _                    continue__                }__                _                float currentWeight = weight.weightShardAdded(this, node, shard.getIndexName())__                _                if (currentWeight > minWeight && explain == false) {_                    continue__                }__                Decision currentDecision = allocation.deciders().canAllocate(shard, node.getRoutingNode(), allocation)__                if (explain) {_                    nodeExplanationMap.put(node.getNodeId(),_                        new NodeAllocationResult(node.getRoutingNode().node(), currentDecision, 0))__                    nodeWeights.add(Tuple.tuple(node.getNodeId(), currentWeight))__                }_                if (currentDecision.type() == Type.YES || currentDecision.type() == Type.THROTTLE) {_                    final boolean updateMinNode__                    if (currentWeight == minWeight) {_                        _                        if (currentDecision.type() == decision.type()) {_                            final int repId = shard.id()__                            final int nodeHigh = node.highestPrimary(shard.index().getName())__                            final int minNodeHigh = minNode.highestPrimary(shard.getIndexName())__                            updateMinNode = ((((nodeHigh > repId && minNodeHigh > repId)_                                                   || (nodeHigh < repId && minNodeHigh < repId))_                                                  && (nodeHigh < minNodeHigh))_                                                 || (nodeHigh > repId && minNodeHigh < repId))__                        } else {_                            updateMinNode = currentDecision.type() == Type.YES__                        }_                    } else {_                        updateMinNode = true__                    }_                    if (updateMinNode) {_                        minNode = node__                        minWeight = currentWeight__                        decision = currentDecision__                    }_                }_            }_            if (decision == null) {_                _                decision = Decision.NO__            }_            List<NodeAllocationResult> nodeDecisions = null__            if (explain) {_                nodeDecisions = new ArrayList<>()__                _                nodeWeights.sort((nodeWeight1, nodeWeight2) -> Float.compare(nodeWeight1.v2(), nodeWeight2.v2()))__                int weightRanking = 0__                for (Tuple<String, Float> nodeWeight : nodeWeights) {_                    NodeAllocationResult current = nodeExplanationMap.get(nodeWeight.v1())__                    nodeDecisions.add(new NodeAllocationResult(current.getNode(), current.getCanAllocateDecision(), ++weightRanking))__                }_            }_            return AllocateUnassignedDecision.fromDecision(_                decision,_                minNode != null ? minNode.routingNode.node() : null,_                nodeDecisions_            )__        };make,a,decision,for,allocating,an,unassigned,shard,this,method,returns,a,two,values,in,a,tuple,the,first,value,is,the,link,decision,taken,to,allocate,the,unassigned,shard,the,second,value,is,the,link,model,node,representing,the,node,that,the,shard,should,be,assigned,to,if,the,decision,returned,is,of,type,link,type,no,then,the,assigned,node,will,be,null;private,allocate,unassigned,decision,decide,allocate,unassigned,final,shard,routing,shard,final,set,model,node,throttled,nodes,if,shard,assigned,to,node,return,allocate,unassigned,decision,final,boolean,explain,allocation,debug,decision,decision,shard,level,decision,allocation,deciders,can,allocate,shard,allocation,if,shard,level,decision,type,type,no,explain,false,return,allocate,unassigned,decision,no,allocation,status,null,float,min,weight,float,model,node,min,node,null,decision,decision,null,if,throttled,nodes,size,nodes,size,explain,false,return,allocate,unassigned,decision,no,allocation,status,null,map,string,node,allocation,result,node,explanation,map,explain,new,hash,map,null,list,tuple,string,float,node,weights,explain,new,array,list,null,for,model,node,node,nodes,values,if,throttled,nodes,contains,node,node,contains,shard,shard,explain,false,continue,float,current,weight,weight,weight,shard,added,this,node,shard,get,index,name,if,current,weight,min,weight,explain,false,continue,decision,current,decision,allocation,deciders,can,allocate,shard,node,get,routing,node,allocation,if,explain,node,explanation,map,put,node,get,node,id,new,node,allocation,result,node,get,routing,node,node,current,decision,0,node,weights,add,tuple,tuple,node,get,node,id,current,weight,if,current,decision,type,type,yes,current,decision,type,type,throttle,final,boolean,update,min,node,if,current,weight,min,weight,if,current,decision,type,decision,type,final,int,rep,id,shard,id,final,int,node,high,node,highest,primary,shard,index,get,name,final,int,min,node,high,min,node,highest,primary,shard,get,index,name,update,min,node,node,high,rep,id,min,node,high,rep,id,node,high,rep,id,min,node,high,rep,id,node,high,min,node,high,node,high,rep,id,min,node,high,rep,id,else,update,min,node,current,decision,type,type,yes,else,update,min,node,true,if,update,min,node,min,node,node,min,weight,current,weight,decision,current,decision,if,decision,null,decision,decision,no,list,node,allocation,result,node,decisions,null,if,explain,node,decisions,new,array,list,node,weights,sort,node,weight1,node,weight2,float,compare,node,weight1,v2,node,weight2,v2,int,weight,ranking,0,for,tuple,string,float,node,weight,node,weights,node,allocation,result,current,node,explanation,map,get,node,weight,v1,node,decisions,add,new,node,allocation,result,current,get,node,current,get,can,allocate,decision,weight,ranking,return,allocate,unassigned,decision,from,decision,decision,min,node,null,min,node,routing,node,node,null,node,decisions
BalancedShardsAllocator -> public float getIndexBalance();1524684173;Returns the index related weight factor.;public float getIndexBalance() {_        return weightFunction.indexBalance__    };returns,the,index,related,weight,factor;public,float,get,index,balance,return,weight,function,index,balance
BalancedShardsAllocator -> public float getIndexBalance();1525334055;Returns the index related weight factor.;public float getIndexBalance() {_        return weightFunction.indexBalance__    };returns,the,index,related,weight,factor;public,float,get,index,balance,return,weight,function,index,balance
BalancedShardsAllocator -> public float getIndexBalance();1531234550;Returns the index related weight factor.;public float getIndexBalance() {_        return weightFunction.indexBalance__    };returns,the,index,related,weight,factor;public,float,get,index,balance,return,weight,function,index,balance
BalancedShardsAllocator -> public float getIndexBalance();1540847035;Returns the index related weight factor.;public float getIndexBalance() {_        return weightFunction.indexBalance__    };returns,the,index,related,weight,factor;public,float,get,index,balance,return,weight,function,index,balance
BalancedShardsAllocator -> public float getIndexBalance();1541092382;Returns the index related weight factor.;public float getIndexBalance() {_        return weightFunction.indexBalance__    };returns,the,index,related,weight,factor;public,float,get,index,balance,return,weight,function,index,balance
BalancedShardsAllocator -> public float getIndexBalance();1541446827;Returns the index related weight factor.;public float getIndexBalance() {_        return weightFunction.indexBalance__    };returns,the,index,related,weight,factor;public,float,get,index,balance,return,weight,function,index,balance
BalancedShardsAllocator -> public float getIndexBalance();1542402632;Returns the index related weight factor.;public float getIndexBalance() {_        return weightFunction.indexBalance__    };returns,the,index,related,weight,factor;public,float,get,index,balance,return,weight,function,index,balance
BalancedShardsAllocator -> public float getIndexBalance();1549912434;Returns the index related weight factor.;public float getIndexBalance() {_        return weightFunction.indexBalance__    };returns,the,index,related,weight,factor;public,float,get,index,balance,return,weight,function,index,balance
BalancedShardsAllocator -> Balancer -> private MoveDecision decideRebalance(final ShardRouting shard);1524684173;Makes a decision about moving a single shard to a different node to form a more_optimally balanced cluster.  This method is invoked from the cluster allocation_explain API only.;private MoveDecision decideRebalance(final ShardRouting shard) {_            if (shard.started() == false) {_                _                return MoveDecision.NOT_TAKEN__            }__            Decision canRebalance = allocation.deciders().canRebalance(shard, allocation)___            sorter.reset(shard.getIndexName())__            ModelNode[] modelNodes = sorter.modelNodes__            final String currentNodeId = shard.currentNodeId()__            _            ModelNode currentNode = null__            for (ModelNode node : modelNodes) {_                if (node.getNodeId().equals(currentNodeId)) {_                    currentNode = node__                    break__                }_            }_            assert currentNode != null : "currently assigned node could not be found"___            _            final float currentWeight = sorter.weight(currentNode)__            final AllocationDeciders deciders = allocation.deciders()__            final String idxName = shard.getIndexName()__            Type rebalanceDecisionType = Type.NO__            ModelNode assignedNode = null__            List<Tuple<ModelNode, Decision>> betterBalanceNodes = new ArrayList<>()__            List<Tuple<ModelNode, Decision>> sameBalanceNodes = new ArrayList<>()__            List<Tuple<ModelNode, Decision>> worseBalanceNodes = new ArrayList<>()__            for (ModelNode node : modelNodes) {_                if (node == currentNode) {_                    continue_ _                }_                final Decision canAllocate = deciders.canAllocate(shard, node.getRoutingNode(), allocation)__                _                _                _                _                final float nodeWeight = sorter.weight(node)__                _                _                _                final boolean betterWeightThanCurrent = nodeWeight <= currentWeight__                boolean rebalanceConditionsMet = false__                if (betterWeightThanCurrent) {_                    _                    float currentDelta = absDelta(nodeWeight, currentWeight)__                    _                    _                    _                    _                    boolean deltaAboveThreshold = lessThan(currentDelta, threshold) == false__                    _                    float weightWithShardAdded = weight.weightShardAdded(this, node, idxName)__                    _                    _                    float proposedDelta = weightWithShardAdded - weight.weightShardRemoved(this, currentNode, idxName)__                    boolean betterWeightWithShardAdded = proposedDelta < currentDelta__                    rebalanceConditionsMet = deltaAboveThreshold && betterWeightWithShardAdded__                    _                    _                    _                    if (rebalanceConditionsMet && canAllocate.type().higherThan(rebalanceDecisionType)) {_                        _                        _                        rebalanceDecisionType = canAllocate.type()__                        assignedNode = node__                    }_                }_                Tuple<ModelNode, Decision> nodeResult = Tuple.tuple(node, canAllocate)__                if (rebalanceConditionsMet) {_                    betterBalanceNodes.add(nodeResult)__                } else if (betterWeightThanCurrent) {_                    sameBalanceNodes.add(nodeResult)__                } else {_                    worseBalanceNodes.add(nodeResult)__                }_            }__            int weightRanking = 0__            List<NodeAllocationResult> nodeDecisions = new ArrayList<>(modelNodes.length - 1)__            for (Tuple<ModelNode, Decision> result : betterBalanceNodes) {_                nodeDecisions.add(new NodeAllocationResult(_                    result.v1().routingNode.node(), AllocationDecision.fromDecisionType(result.v2().type()), result.v2(), ++weightRanking)_                )__            }_            int currentNodeWeightRanking = ++weightRanking__            for (Tuple<ModelNode, Decision> result : sameBalanceNodes) {_                AllocationDecision nodeDecision = result.v2().type() == Type.NO ? AllocationDecision.NO : AllocationDecision.WORSE_BALANCE__                nodeDecisions.add(new NodeAllocationResult(_                    result.v1().routingNode.node(), nodeDecision, result.v2(), currentNodeWeightRanking)_                )__            }_            for (Tuple<ModelNode, Decision> result : worseBalanceNodes) {_                AllocationDecision nodeDecision = result.v2().type() == Type.NO ? AllocationDecision.NO : AllocationDecision.WORSE_BALANCE__                nodeDecisions.add(new NodeAllocationResult(_                    result.v1().routingNode.node(), nodeDecision, result.v2(), ++weightRanking)_                )__            }__            if (canRebalance.type() != Type.YES || allocation.hasPendingAsyncFetch()) {_                AllocationDecision allocationDecision = allocation.hasPendingAsyncFetch() ? AllocationDecision.AWAITING_INFO :_                                                            AllocationDecision.fromDecisionType(canRebalance.type())__                return MoveDecision.cannotRebalance(canRebalance, allocationDecision, currentNodeWeightRanking, nodeDecisions)__            } else {_                return MoveDecision.rebalance(canRebalance, AllocationDecision.fromDecisionType(rebalanceDecisionType),_                    assignedNode != null ? assignedNode.routingNode.node() : null, currentNodeWeightRanking, nodeDecisions)__            }_        };makes,a,decision,about,moving,a,single,shard,to,a,different,node,to,form,a,more,optimally,balanced,cluster,this,method,is,invoked,from,the,cluster,allocation,explain,api,only;private,move,decision,decide,rebalance,final,shard,routing,shard,if,shard,started,false,return,move,decision,decision,can,rebalance,allocation,deciders,can,rebalance,shard,allocation,sorter,reset,shard,get,index,name,model,node,model,nodes,sorter,model,nodes,final,string,current,node,id,shard,current,node,id,model,node,current,node,null,for,model,node,node,model,nodes,if,node,get,node,id,equals,current,node,id,current,node,node,break,assert,current,node,null,currently,assigned,node,could,not,be,found,final,float,current,weight,sorter,weight,current,node,final,allocation,deciders,deciders,allocation,deciders,final,string,idx,name,shard,get,index,name,type,rebalance,decision,type,type,no,model,node,assigned,node,null,list,tuple,model,node,decision,better,balance,nodes,new,array,list,list,tuple,model,node,decision,same,balance,nodes,new,array,list,list,tuple,model,node,decision,worse,balance,nodes,new,array,list,for,model,node,node,model,nodes,if,node,current,node,continue,final,decision,can,allocate,deciders,can,allocate,shard,node,get,routing,node,allocation,final,float,node,weight,sorter,weight,node,final,boolean,better,weight,than,current,node,weight,current,weight,boolean,rebalance,conditions,met,false,if,better,weight,than,current,float,current,delta,abs,delta,node,weight,current,weight,boolean,delta,above,threshold,less,than,current,delta,threshold,false,float,weight,with,shard,added,weight,weight,shard,added,this,node,idx,name,float,proposed,delta,weight,with,shard,added,weight,weight,shard,removed,this,current,node,idx,name,boolean,better,weight,with,shard,added,proposed,delta,current,delta,rebalance,conditions,met,delta,above,threshold,better,weight,with,shard,added,if,rebalance,conditions,met,can,allocate,type,higher,than,rebalance,decision,type,rebalance,decision,type,can,allocate,type,assigned,node,node,tuple,model,node,decision,node,result,tuple,tuple,node,can,allocate,if,rebalance,conditions,met,better,balance,nodes,add,node,result,else,if,better,weight,than,current,same,balance,nodes,add,node,result,else,worse,balance,nodes,add,node,result,int,weight,ranking,0,list,node,allocation,result,node,decisions,new,array,list,model,nodes,length,1,for,tuple,model,node,decision,result,better,balance,nodes,node,decisions,add,new,node,allocation,result,result,v1,routing,node,node,allocation,decision,from,decision,type,result,v2,type,result,v2,weight,ranking,int,current,node,weight,ranking,weight,ranking,for,tuple,model,node,decision,result,same,balance,nodes,allocation,decision,node,decision,result,v2,type,type,no,allocation,decision,no,allocation,decision,node,decisions,add,new,node,allocation,result,result,v1,routing,node,node,node,decision,result,v2,current,node,weight,ranking,for,tuple,model,node,decision,result,worse,balance,nodes,allocation,decision,node,decision,result,v2,type,type,no,allocation,decision,no,allocation,decision,node,decisions,add,new,node,allocation,result,result,v1,routing,node,node,node,decision,result,v2,weight,ranking,if,can,rebalance,type,type,yes,allocation,has,pending,async,fetch,allocation,decision,allocation,decision,allocation,has,pending,async,fetch,allocation,decision,allocation,decision,from,decision,type,can,rebalance,type,return,move,decision,cannot,rebalance,can,rebalance,allocation,decision,current,node,weight,ranking,node,decisions,else,return,move,decision,rebalance,can,rebalance,allocation,decision,from,decision,type,rebalance,decision,type,assigned,node,null,assigned,node,routing,node,node,null,current,node,weight,ranking,node,decisions
BalancedShardsAllocator -> Balancer -> private MoveDecision decideRebalance(final ShardRouting shard);1525334055;Makes a decision about moving a single shard to a different node to form a more_optimally balanced cluster.  This method is invoked from the cluster allocation_explain API only.;private MoveDecision decideRebalance(final ShardRouting shard) {_            if (shard.started() == false) {_                _                return MoveDecision.NOT_TAKEN__            }__            Decision canRebalance = allocation.deciders().canRebalance(shard, allocation)___            sorter.reset(shard.getIndexName())__            ModelNode[] modelNodes = sorter.modelNodes__            final String currentNodeId = shard.currentNodeId()__            _            ModelNode currentNode = null__            for (ModelNode node : modelNodes) {_                if (node.getNodeId().equals(currentNodeId)) {_                    currentNode = node__                    break__                }_            }_            assert currentNode != null : "currently assigned node could not be found"___            _            final float currentWeight = sorter.weight(currentNode)__            final AllocationDeciders deciders = allocation.deciders()__            final String idxName = shard.getIndexName()__            Type rebalanceDecisionType = Type.NO__            ModelNode assignedNode = null__            List<Tuple<ModelNode, Decision>> betterBalanceNodes = new ArrayList<>()__            List<Tuple<ModelNode, Decision>> sameBalanceNodes = new ArrayList<>()__            List<Tuple<ModelNode, Decision>> worseBalanceNodes = new ArrayList<>()__            for (ModelNode node : modelNodes) {_                if (node == currentNode) {_                    continue_ _                }_                final Decision canAllocate = deciders.canAllocate(shard, node.getRoutingNode(), allocation)__                _                _                _                _                final float nodeWeight = sorter.weight(node)__                _                _                _                final boolean betterWeightThanCurrent = nodeWeight <= currentWeight__                boolean rebalanceConditionsMet = false__                if (betterWeightThanCurrent) {_                    _                    float currentDelta = absDelta(nodeWeight, currentWeight)__                    _                    _                    _                    _                    boolean deltaAboveThreshold = lessThan(currentDelta, threshold) == false__                    _                    float weightWithShardAdded = weight.weightShardAdded(this, node, idxName)__                    _                    _                    float proposedDelta = weightWithShardAdded - weight.weightShardRemoved(this, currentNode, idxName)__                    boolean betterWeightWithShardAdded = proposedDelta < currentDelta__                    rebalanceConditionsMet = deltaAboveThreshold && betterWeightWithShardAdded__                    _                    _                    _                    if (rebalanceConditionsMet && canAllocate.type().higherThan(rebalanceDecisionType)) {_                        _                        _                        rebalanceDecisionType = canAllocate.type()__                        assignedNode = node__                    }_                }_                Tuple<ModelNode, Decision> nodeResult = Tuple.tuple(node, canAllocate)__                if (rebalanceConditionsMet) {_                    betterBalanceNodes.add(nodeResult)__                } else if (betterWeightThanCurrent) {_                    sameBalanceNodes.add(nodeResult)__                } else {_                    worseBalanceNodes.add(nodeResult)__                }_            }__            int weightRanking = 0__            List<NodeAllocationResult> nodeDecisions = new ArrayList<>(modelNodes.length - 1)__            for (Tuple<ModelNode, Decision> result : betterBalanceNodes) {_                nodeDecisions.add(new NodeAllocationResult(_                    result.v1().routingNode.node(), AllocationDecision.fromDecisionType(result.v2().type()), result.v2(), ++weightRanking)_                )__            }_            int currentNodeWeightRanking = ++weightRanking__            for (Tuple<ModelNode, Decision> result : sameBalanceNodes) {_                AllocationDecision nodeDecision = result.v2().type() == Type.NO ? AllocationDecision.NO : AllocationDecision.WORSE_BALANCE__                nodeDecisions.add(new NodeAllocationResult(_                    result.v1().routingNode.node(), nodeDecision, result.v2(), currentNodeWeightRanking)_                )__            }_            for (Tuple<ModelNode, Decision> result : worseBalanceNodes) {_                AllocationDecision nodeDecision = result.v2().type() == Type.NO ? AllocationDecision.NO : AllocationDecision.WORSE_BALANCE__                nodeDecisions.add(new NodeAllocationResult(_                    result.v1().routingNode.node(), nodeDecision, result.v2(), ++weightRanking)_                )__            }__            if (canRebalance.type() != Type.YES || allocation.hasPendingAsyncFetch()) {_                AllocationDecision allocationDecision = allocation.hasPendingAsyncFetch() ? AllocationDecision.AWAITING_INFO :_                                                            AllocationDecision.fromDecisionType(canRebalance.type())__                return MoveDecision.cannotRebalance(canRebalance, allocationDecision, currentNodeWeightRanking, nodeDecisions)__            } else {_                return MoveDecision.rebalance(canRebalance, AllocationDecision.fromDecisionType(rebalanceDecisionType),_                    assignedNode != null ? assignedNode.routingNode.node() : null, currentNodeWeightRanking, nodeDecisions)__            }_        };makes,a,decision,about,moving,a,single,shard,to,a,different,node,to,form,a,more,optimally,balanced,cluster,this,method,is,invoked,from,the,cluster,allocation,explain,api,only;private,move,decision,decide,rebalance,final,shard,routing,shard,if,shard,started,false,return,move,decision,decision,can,rebalance,allocation,deciders,can,rebalance,shard,allocation,sorter,reset,shard,get,index,name,model,node,model,nodes,sorter,model,nodes,final,string,current,node,id,shard,current,node,id,model,node,current,node,null,for,model,node,node,model,nodes,if,node,get,node,id,equals,current,node,id,current,node,node,break,assert,current,node,null,currently,assigned,node,could,not,be,found,final,float,current,weight,sorter,weight,current,node,final,allocation,deciders,deciders,allocation,deciders,final,string,idx,name,shard,get,index,name,type,rebalance,decision,type,type,no,model,node,assigned,node,null,list,tuple,model,node,decision,better,balance,nodes,new,array,list,list,tuple,model,node,decision,same,balance,nodes,new,array,list,list,tuple,model,node,decision,worse,balance,nodes,new,array,list,for,model,node,node,model,nodes,if,node,current,node,continue,final,decision,can,allocate,deciders,can,allocate,shard,node,get,routing,node,allocation,final,float,node,weight,sorter,weight,node,final,boolean,better,weight,than,current,node,weight,current,weight,boolean,rebalance,conditions,met,false,if,better,weight,than,current,float,current,delta,abs,delta,node,weight,current,weight,boolean,delta,above,threshold,less,than,current,delta,threshold,false,float,weight,with,shard,added,weight,weight,shard,added,this,node,idx,name,float,proposed,delta,weight,with,shard,added,weight,weight,shard,removed,this,current,node,idx,name,boolean,better,weight,with,shard,added,proposed,delta,current,delta,rebalance,conditions,met,delta,above,threshold,better,weight,with,shard,added,if,rebalance,conditions,met,can,allocate,type,higher,than,rebalance,decision,type,rebalance,decision,type,can,allocate,type,assigned,node,node,tuple,model,node,decision,node,result,tuple,tuple,node,can,allocate,if,rebalance,conditions,met,better,balance,nodes,add,node,result,else,if,better,weight,than,current,same,balance,nodes,add,node,result,else,worse,balance,nodes,add,node,result,int,weight,ranking,0,list,node,allocation,result,node,decisions,new,array,list,model,nodes,length,1,for,tuple,model,node,decision,result,better,balance,nodes,node,decisions,add,new,node,allocation,result,result,v1,routing,node,node,allocation,decision,from,decision,type,result,v2,type,result,v2,weight,ranking,int,current,node,weight,ranking,weight,ranking,for,tuple,model,node,decision,result,same,balance,nodes,allocation,decision,node,decision,result,v2,type,type,no,allocation,decision,no,allocation,decision,node,decisions,add,new,node,allocation,result,result,v1,routing,node,node,node,decision,result,v2,current,node,weight,ranking,for,tuple,model,node,decision,result,worse,balance,nodes,allocation,decision,node,decision,result,v2,type,type,no,allocation,decision,no,allocation,decision,node,decisions,add,new,node,allocation,result,result,v1,routing,node,node,node,decision,result,v2,weight,ranking,if,can,rebalance,type,type,yes,allocation,has,pending,async,fetch,allocation,decision,allocation,decision,allocation,has,pending,async,fetch,allocation,decision,allocation,decision,from,decision,type,can,rebalance,type,return,move,decision,cannot,rebalance,can,rebalance,allocation,decision,current,node,weight,ranking,node,decisions,else,return,move,decision,rebalance,can,rebalance,allocation,decision,from,decision,type,rebalance,decision,type,assigned,node,null,assigned,node,routing,node,node,null,current,node,weight,ranking,node,decisions
BalancedShardsAllocator -> Balancer -> private MoveDecision decideRebalance(final ShardRouting shard);1531234550;Makes a decision about moving a single shard to a different node to form a more_optimally balanced cluster.  This method is invoked from the cluster allocation_explain API only.;private MoveDecision decideRebalance(final ShardRouting shard) {_            if (shard.started() == false) {_                _                return MoveDecision.NOT_TAKEN__            }__            Decision canRebalance = allocation.deciders().canRebalance(shard, allocation)___            sorter.reset(shard.getIndexName())__            ModelNode[] modelNodes = sorter.modelNodes__            final String currentNodeId = shard.currentNodeId()__            _            ModelNode currentNode = null__            for (ModelNode node : modelNodes) {_                if (node.getNodeId().equals(currentNodeId)) {_                    currentNode = node__                    break__                }_            }_            assert currentNode != null : "currently assigned node could not be found"___            _            final float currentWeight = sorter.weight(currentNode)__            final AllocationDeciders deciders = allocation.deciders()__            final String idxName = shard.getIndexName()__            Type rebalanceDecisionType = Type.NO__            ModelNode assignedNode = null__            List<Tuple<ModelNode, Decision>> betterBalanceNodes = new ArrayList<>()__            List<Tuple<ModelNode, Decision>> sameBalanceNodes = new ArrayList<>()__            List<Tuple<ModelNode, Decision>> worseBalanceNodes = new ArrayList<>()__            for (ModelNode node : modelNodes) {_                if (node == currentNode) {_                    continue_ _                }_                final Decision canAllocate = deciders.canAllocate(shard, node.getRoutingNode(), allocation)__                _                _                _                _                final float nodeWeight = sorter.weight(node)__                _                _                _                final boolean betterWeightThanCurrent = nodeWeight <= currentWeight__                boolean rebalanceConditionsMet = false__                if (betterWeightThanCurrent) {_                    _                    float currentDelta = absDelta(nodeWeight, currentWeight)__                    _                    _                    _                    _                    boolean deltaAboveThreshold = lessThan(currentDelta, threshold) == false__                    _                    float weightWithShardAdded = weight.weightShardAdded(this, node, idxName)__                    _                    _                    float proposedDelta = weightWithShardAdded - weight.weightShardRemoved(this, currentNode, idxName)__                    boolean betterWeightWithShardAdded = proposedDelta < currentDelta__                    rebalanceConditionsMet = deltaAboveThreshold && betterWeightWithShardAdded__                    _                    _                    _                    if (rebalanceConditionsMet && canAllocate.type().higherThan(rebalanceDecisionType)) {_                        _                        _                        rebalanceDecisionType = canAllocate.type()__                        assignedNode = node__                    }_                }_                Tuple<ModelNode, Decision> nodeResult = Tuple.tuple(node, canAllocate)__                if (rebalanceConditionsMet) {_                    betterBalanceNodes.add(nodeResult)__                } else if (betterWeightThanCurrent) {_                    sameBalanceNodes.add(nodeResult)__                } else {_                    worseBalanceNodes.add(nodeResult)__                }_            }__            int weightRanking = 0__            List<NodeAllocationResult> nodeDecisions = new ArrayList<>(modelNodes.length - 1)__            for (Tuple<ModelNode, Decision> result : betterBalanceNodes) {_                nodeDecisions.add(new NodeAllocationResult(_                    result.v1().routingNode.node(), AllocationDecision.fromDecisionType(result.v2().type()), result.v2(), ++weightRanking)_                )__            }_            int currentNodeWeightRanking = ++weightRanking__            for (Tuple<ModelNode, Decision> result : sameBalanceNodes) {_                AllocationDecision nodeDecision = result.v2().type() == Type.NO ? AllocationDecision.NO : AllocationDecision.WORSE_BALANCE__                nodeDecisions.add(new NodeAllocationResult(_                    result.v1().routingNode.node(), nodeDecision, result.v2(), currentNodeWeightRanking)_                )__            }_            for (Tuple<ModelNode, Decision> result : worseBalanceNodes) {_                AllocationDecision nodeDecision = result.v2().type() == Type.NO ? AllocationDecision.NO : AllocationDecision.WORSE_BALANCE__                nodeDecisions.add(new NodeAllocationResult(_                    result.v1().routingNode.node(), nodeDecision, result.v2(), ++weightRanking)_                )__            }__            if (canRebalance.type() != Type.YES || allocation.hasPendingAsyncFetch()) {_                AllocationDecision allocationDecision = allocation.hasPendingAsyncFetch() ? AllocationDecision.AWAITING_INFO :_                                                            AllocationDecision.fromDecisionType(canRebalance.type())__                return MoveDecision.cannotRebalance(canRebalance, allocationDecision, currentNodeWeightRanking, nodeDecisions)__            } else {_                return MoveDecision.rebalance(canRebalance, AllocationDecision.fromDecisionType(rebalanceDecisionType),_                    assignedNode != null ? assignedNode.routingNode.node() : null, currentNodeWeightRanking, nodeDecisions)__            }_        };makes,a,decision,about,moving,a,single,shard,to,a,different,node,to,form,a,more,optimally,balanced,cluster,this,method,is,invoked,from,the,cluster,allocation,explain,api,only;private,move,decision,decide,rebalance,final,shard,routing,shard,if,shard,started,false,return,move,decision,decision,can,rebalance,allocation,deciders,can,rebalance,shard,allocation,sorter,reset,shard,get,index,name,model,node,model,nodes,sorter,model,nodes,final,string,current,node,id,shard,current,node,id,model,node,current,node,null,for,model,node,node,model,nodes,if,node,get,node,id,equals,current,node,id,current,node,node,break,assert,current,node,null,currently,assigned,node,could,not,be,found,final,float,current,weight,sorter,weight,current,node,final,allocation,deciders,deciders,allocation,deciders,final,string,idx,name,shard,get,index,name,type,rebalance,decision,type,type,no,model,node,assigned,node,null,list,tuple,model,node,decision,better,balance,nodes,new,array,list,list,tuple,model,node,decision,same,balance,nodes,new,array,list,list,tuple,model,node,decision,worse,balance,nodes,new,array,list,for,model,node,node,model,nodes,if,node,current,node,continue,final,decision,can,allocate,deciders,can,allocate,shard,node,get,routing,node,allocation,final,float,node,weight,sorter,weight,node,final,boolean,better,weight,than,current,node,weight,current,weight,boolean,rebalance,conditions,met,false,if,better,weight,than,current,float,current,delta,abs,delta,node,weight,current,weight,boolean,delta,above,threshold,less,than,current,delta,threshold,false,float,weight,with,shard,added,weight,weight,shard,added,this,node,idx,name,float,proposed,delta,weight,with,shard,added,weight,weight,shard,removed,this,current,node,idx,name,boolean,better,weight,with,shard,added,proposed,delta,current,delta,rebalance,conditions,met,delta,above,threshold,better,weight,with,shard,added,if,rebalance,conditions,met,can,allocate,type,higher,than,rebalance,decision,type,rebalance,decision,type,can,allocate,type,assigned,node,node,tuple,model,node,decision,node,result,tuple,tuple,node,can,allocate,if,rebalance,conditions,met,better,balance,nodes,add,node,result,else,if,better,weight,than,current,same,balance,nodes,add,node,result,else,worse,balance,nodes,add,node,result,int,weight,ranking,0,list,node,allocation,result,node,decisions,new,array,list,model,nodes,length,1,for,tuple,model,node,decision,result,better,balance,nodes,node,decisions,add,new,node,allocation,result,result,v1,routing,node,node,allocation,decision,from,decision,type,result,v2,type,result,v2,weight,ranking,int,current,node,weight,ranking,weight,ranking,for,tuple,model,node,decision,result,same,balance,nodes,allocation,decision,node,decision,result,v2,type,type,no,allocation,decision,no,allocation,decision,node,decisions,add,new,node,allocation,result,result,v1,routing,node,node,node,decision,result,v2,current,node,weight,ranking,for,tuple,model,node,decision,result,worse,balance,nodes,allocation,decision,node,decision,result,v2,type,type,no,allocation,decision,no,allocation,decision,node,decisions,add,new,node,allocation,result,result,v1,routing,node,node,node,decision,result,v2,weight,ranking,if,can,rebalance,type,type,yes,allocation,has,pending,async,fetch,allocation,decision,allocation,decision,allocation,has,pending,async,fetch,allocation,decision,allocation,decision,from,decision,type,can,rebalance,type,return,move,decision,cannot,rebalance,can,rebalance,allocation,decision,current,node,weight,ranking,node,decisions,else,return,move,decision,rebalance,can,rebalance,allocation,decision,from,decision,type,rebalance,decision,type,assigned,node,null,assigned,node,routing,node,node,null,current,node,weight,ranking,node,decisions
BalancedShardsAllocator -> Balancer -> private MoveDecision decideRebalance(final ShardRouting shard);1540847035;Makes a decision about moving a single shard to a different node to form a more_optimally balanced cluster.  This method is invoked from the cluster allocation_explain API only.;private MoveDecision decideRebalance(final ShardRouting shard) {_            if (shard.started() == false) {_                _                return MoveDecision.NOT_TAKEN__            }__            Decision canRebalance = allocation.deciders().canRebalance(shard, allocation)___            sorter.reset(shard.getIndexName())__            ModelNode[] modelNodes = sorter.modelNodes__            final String currentNodeId = shard.currentNodeId()__            _            ModelNode currentNode = null__            for (ModelNode node : modelNodes) {_                if (node.getNodeId().equals(currentNodeId)) {_                    currentNode = node__                    break__                }_            }_            assert currentNode != null : "currently assigned node could not be found"___            _            final float currentWeight = sorter.weight(currentNode)__            final AllocationDeciders deciders = allocation.deciders()__            final String idxName = shard.getIndexName()__            Type rebalanceDecisionType = Type.NO__            ModelNode assignedNode = null__            List<Tuple<ModelNode, Decision>> betterBalanceNodes = new ArrayList<>()__            List<Tuple<ModelNode, Decision>> sameBalanceNodes = new ArrayList<>()__            List<Tuple<ModelNode, Decision>> worseBalanceNodes = new ArrayList<>()__            for (ModelNode node : modelNodes) {_                if (node == currentNode) {_                    continue_ _                }_                final Decision canAllocate = deciders.canAllocate(shard, node.getRoutingNode(), allocation)__                _                _                _                _                final float nodeWeight = sorter.weight(node)__                _                _                _                final boolean betterWeightThanCurrent = nodeWeight <= currentWeight__                boolean rebalanceConditionsMet = false__                if (betterWeightThanCurrent) {_                    _                    float currentDelta = absDelta(nodeWeight, currentWeight)__                    _                    _                    _                    _                    boolean deltaAboveThreshold = lessThan(currentDelta, threshold) == false__                    _                    float weightWithShardAdded = weight.weightShardAdded(this, node, idxName)__                    _                    _                    float proposedDelta = weightWithShardAdded - weight.weightShardRemoved(this, currentNode, idxName)__                    boolean betterWeightWithShardAdded = proposedDelta < currentDelta__                    rebalanceConditionsMet = deltaAboveThreshold && betterWeightWithShardAdded__                    _                    _                    _                    if (rebalanceConditionsMet && canAllocate.type().higherThan(rebalanceDecisionType)) {_                        _                        _                        rebalanceDecisionType = canAllocate.type()__                        assignedNode = node__                    }_                }_                Tuple<ModelNode, Decision> nodeResult = Tuple.tuple(node, canAllocate)__                if (rebalanceConditionsMet) {_                    betterBalanceNodes.add(nodeResult)__                } else if (betterWeightThanCurrent) {_                    sameBalanceNodes.add(nodeResult)__                } else {_                    worseBalanceNodes.add(nodeResult)__                }_            }__            int weightRanking = 0__            List<NodeAllocationResult> nodeDecisions = new ArrayList<>(modelNodes.length - 1)__            for (Tuple<ModelNode, Decision> result : betterBalanceNodes) {_                nodeDecisions.add(new NodeAllocationResult(_                    result.v1().routingNode.node(), AllocationDecision.fromDecisionType(result.v2().type()), result.v2(), ++weightRanking)_                )__            }_            int currentNodeWeightRanking = ++weightRanking__            for (Tuple<ModelNode, Decision> result : sameBalanceNodes) {_                AllocationDecision nodeDecision = result.v2().type() == Type.NO ? AllocationDecision.NO : AllocationDecision.WORSE_BALANCE__                nodeDecisions.add(new NodeAllocationResult(_                    result.v1().routingNode.node(), nodeDecision, result.v2(), currentNodeWeightRanking)_                )__            }_            for (Tuple<ModelNode, Decision> result : worseBalanceNodes) {_                AllocationDecision nodeDecision = result.v2().type() == Type.NO ? AllocationDecision.NO : AllocationDecision.WORSE_BALANCE__                nodeDecisions.add(new NodeAllocationResult(_                    result.v1().routingNode.node(), nodeDecision, result.v2(), ++weightRanking)_                )__            }__            if (canRebalance.type() != Type.YES || allocation.hasPendingAsyncFetch()) {_                AllocationDecision allocationDecision = allocation.hasPendingAsyncFetch() ? AllocationDecision.AWAITING_INFO :_                                                            AllocationDecision.fromDecisionType(canRebalance.type())__                return MoveDecision.cannotRebalance(canRebalance, allocationDecision, currentNodeWeightRanking, nodeDecisions)__            } else {_                return MoveDecision.rebalance(canRebalance, AllocationDecision.fromDecisionType(rebalanceDecisionType),_                    assignedNode != null ? assignedNode.routingNode.node() : null, currentNodeWeightRanking, nodeDecisions)__            }_        };makes,a,decision,about,moving,a,single,shard,to,a,different,node,to,form,a,more,optimally,balanced,cluster,this,method,is,invoked,from,the,cluster,allocation,explain,api,only;private,move,decision,decide,rebalance,final,shard,routing,shard,if,shard,started,false,return,move,decision,decision,can,rebalance,allocation,deciders,can,rebalance,shard,allocation,sorter,reset,shard,get,index,name,model,node,model,nodes,sorter,model,nodes,final,string,current,node,id,shard,current,node,id,model,node,current,node,null,for,model,node,node,model,nodes,if,node,get,node,id,equals,current,node,id,current,node,node,break,assert,current,node,null,currently,assigned,node,could,not,be,found,final,float,current,weight,sorter,weight,current,node,final,allocation,deciders,deciders,allocation,deciders,final,string,idx,name,shard,get,index,name,type,rebalance,decision,type,type,no,model,node,assigned,node,null,list,tuple,model,node,decision,better,balance,nodes,new,array,list,list,tuple,model,node,decision,same,balance,nodes,new,array,list,list,tuple,model,node,decision,worse,balance,nodes,new,array,list,for,model,node,node,model,nodes,if,node,current,node,continue,final,decision,can,allocate,deciders,can,allocate,shard,node,get,routing,node,allocation,final,float,node,weight,sorter,weight,node,final,boolean,better,weight,than,current,node,weight,current,weight,boolean,rebalance,conditions,met,false,if,better,weight,than,current,float,current,delta,abs,delta,node,weight,current,weight,boolean,delta,above,threshold,less,than,current,delta,threshold,false,float,weight,with,shard,added,weight,weight,shard,added,this,node,idx,name,float,proposed,delta,weight,with,shard,added,weight,weight,shard,removed,this,current,node,idx,name,boolean,better,weight,with,shard,added,proposed,delta,current,delta,rebalance,conditions,met,delta,above,threshold,better,weight,with,shard,added,if,rebalance,conditions,met,can,allocate,type,higher,than,rebalance,decision,type,rebalance,decision,type,can,allocate,type,assigned,node,node,tuple,model,node,decision,node,result,tuple,tuple,node,can,allocate,if,rebalance,conditions,met,better,balance,nodes,add,node,result,else,if,better,weight,than,current,same,balance,nodes,add,node,result,else,worse,balance,nodes,add,node,result,int,weight,ranking,0,list,node,allocation,result,node,decisions,new,array,list,model,nodes,length,1,for,tuple,model,node,decision,result,better,balance,nodes,node,decisions,add,new,node,allocation,result,result,v1,routing,node,node,allocation,decision,from,decision,type,result,v2,type,result,v2,weight,ranking,int,current,node,weight,ranking,weight,ranking,for,tuple,model,node,decision,result,same,balance,nodes,allocation,decision,node,decision,result,v2,type,type,no,allocation,decision,no,allocation,decision,node,decisions,add,new,node,allocation,result,result,v1,routing,node,node,node,decision,result,v2,current,node,weight,ranking,for,tuple,model,node,decision,result,worse,balance,nodes,allocation,decision,node,decision,result,v2,type,type,no,allocation,decision,no,allocation,decision,node,decisions,add,new,node,allocation,result,result,v1,routing,node,node,node,decision,result,v2,weight,ranking,if,can,rebalance,type,type,yes,allocation,has,pending,async,fetch,allocation,decision,allocation,decision,allocation,has,pending,async,fetch,allocation,decision,allocation,decision,from,decision,type,can,rebalance,type,return,move,decision,cannot,rebalance,can,rebalance,allocation,decision,current,node,weight,ranking,node,decisions,else,return,move,decision,rebalance,can,rebalance,allocation,decision,from,decision,type,rebalance,decision,type,assigned,node,null,assigned,node,routing,node,node,null,current,node,weight,ranking,node,decisions
BalancedShardsAllocator -> Balancer -> private MoveDecision decideRebalance(final ShardRouting shard);1541092382;Makes a decision about moving a single shard to a different node to form a more_optimally balanced cluster.  This method is invoked from the cluster allocation_explain API only.;private MoveDecision decideRebalance(final ShardRouting shard) {_            if (shard.started() == false) {_                _                return MoveDecision.NOT_TAKEN__            }__            Decision canRebalance = allocation.deciders().canRebalance(shard, allocation)___            sorter.reset(shard.getIndexName())__            ModelNode[] modelNodes = sorter.modelNodes__            final String currentNodeId = shard.currentNodeId()__            _            ModelNode currentNode = null__            for (ModelNode node : modelNodes) {_                if (node.getNodeId().equals(currentNodeId)) {_                    currentNode = node__                    break__                }_            }_            assert currentNode != null : "currently assigned node could not be found"___            _            final float currentWeight = sorter.weight(currentNode)__            final AllocationDeciders deciders = allocation.deciders()__            final String idxName = shard.getIndexName()__            Type rebalanceDecisionType = Type.NO__            ModelNode assignedNode = null__            List<Tuple<ModelNode, Decision>> betterBalanceNodes = new ArrayList<>()__            List<Tuple<ModelNode, Decision>> sameBalanceNodes = new ArrayList<>()__            List<Tuple<ModelNode, Decision>> worseBalanceNodes = new ArrayList<>()__            for (ModelNode node : modelNodes) {_                if (node == currentNode) {_                    continue_ _                }_                final Decision canAllocate = deciders.canAllocate(shard, node.getRoutingNode(), allocation)__                _                _                _                _                final float nodeWeight = sorter.weight(node)__                _                _                _                final boolean betterWeightThanCurrent = nodeWeight <= currentWeight__                boolean rebalanceConditionsMet = false__                if (betterWeightThanCurrent) {_                    _                    float currentDelta = absDelta(nodeWeight, currentWeight)__                    _                    _                    _                    _                    boolean deltaAboveThreshold = lessThan(currentDelta, threshold) == false__                    _                    float weightWithShardAdded = weight.weightShardAdded(this, node, idxName)__                    _                    _                    float proposedDelta = weightWithShardAdded - weight.weightShardRemoved(this, currentNode, idxName)__                    boolean betterWeightWithShardAdded = proposedDelta < currentDelta__                    rebalanceConditionsMet = deltaAboveThreshold && betterWeightWithShardAdded__                    _                    _                    _                    if (rebalanceConditionsMet && canAllocate.type().higherThan(rebalanceDecisionType)) {_                        _                        _                        rebalanceDecisionType = canAllocate.type()__                        assignedNode = node__                    }_                }_                Tuple<ModelNode, Decision> nodeResult = Tuple.tuple(node, canAllocate)__                if (rebalanceConditionsMet) {_                    betterBalanceNodes.add(nodeResult)__                } else if (betterWeightThanCurrent) {_                    sameBalanceNodes.add(nodeResult)__                } else {_                    worseBalanceNodes.add(nodeResult)__                }_            }__            int weightRanking = 0__            List<NodeAllocationResult> nodeDecisions = new ArrayList<>(modelNodes.length - 1)__            for (Tuple<ModelNode, Decision> result : betterBalanceNodes) {_                nodeDecisions.add(new NodeAllocationResult(_                    result.v1().routingNode.node(), AllocationDecision.fromDecisionType(result.v2().type()), result.v2(), ++weightRanking)_                )__            }_            int currentNodeWeightRanking = ++weightRanking__            for (Tuple<ModelNode, Decision> result : sameBalanceNodes) {_                AllocationDecision nodeDecision = result.v2().type() == Type.NO ? AllocationDecision.NO : AllocationDecision.WORSE_BALANCE__                nodeDecisions.add(new NodeAllocationResult(_                    result.v1().routingNode.node(), nodeDecision, result.v2(), currentNodeWeightRanking)_                )__            }_            for (Tuple<ModelNode, Decision> result : worseBalanceNodes) {_                AllocationDecision nodeDecision = result.v2().type() == Type.NO ? AllocationDecision.NO : AllocationDecision.WORSE_BALANCE__                nodeDecisions.add(new NodeAllocationResult(_                    result.v1().routingNode.node(), nodeDecision, result.v2(), ++weightRanking)_                )__            }__            if (canRebalance.type() != Type.YES || allocation.hasPendingAsyncFetch()) {_                AllocationDecision allocationDecision = allocation.hasPendingAsyncFetch() ? AllocationDecision.AWAITING_INFO :_                                                            AllocationDecision.fromDecisionType(canRebalance.type())__                return MoveDecision.cannotRebalance(canRebalance, allocationDecision, currentNodeWeightRanking, nodeDecisions)__            } else {_                return MoveDecision.rebalance(canRebalance, AllocationDecision.fromDecisionType(rebalanceDecisionType),_                    assignedNode != null ? assignedNode.routingNode.node() : null, currentNodeWeightRanking, nodeDecisions)__            }_        };makes,a,decision,about,moving,a,single,shard,to,a,different,node,to,form,a,more,optimally,balanced,cluster,this,method,is,invoked,from,the,cluster,allocation,explain,api,only;private,move,decision,decide,rebalance,final,shard,routing,shard,if,shard,started,false,return,move,decision,decision,can,rebalance,allocation,deciders,can,rebalance,shard,allocation,sorter,reset,shard,get,index,name,model,node,model,nodes,sorter,model,nodes,final,string,current,node,id,shard,current,node,id,model,node,current,node,null,for,model,node,node,model,nodes,if,node,get,node,id,equals,current,node,id,current,node,node,break,assert,current,node,null,currently,assigned,node,could,not,be,found,final,float,current,weight,sorter,weight,current,node,final,allocation,deciders,deciders,allocation,deciders,final,string,idx,name,shard,get,index,name,type,rebalance,decision,type,type,no,model,node,assigned,node,null,list,tuple,model,node,decision,better,balance,nodes,new,array,list,list,tuple,model,node,decision,same,balance,nodes,new,array,list,list,tuple,model,node,decision,worse,balance,nodes,new,array,list,for,model,node,node,model,nodes,if,node,current,node,continue,final,decision,can,allocate,deciders,can,allocate,shard,node,get,routing,node,allocation,final,float,node,weight,sorter,weight,node,final,boolean,better,weight,than,current,node,weight,current,weight,boolean,rebalance,conditions,met,false,if,better,weight,than,current,float,current,delta,abs,delta,node,weight,current,weight,boolean,delta,above,threshold,less,than,current,delta,threshold,false,float,weight,with,shard,added,weight,weight,shard,added,this,node,idx,name,float,proposed,delta,weight,with,shard,added,weight,weight,shard,removed,this,current,node,idx,name,boolean,better,weight,with,shard,added,proposed,delta,current,delta,rebalance,conditions,met,delta,above,threshold,better,weight,with,shard,added,if,rebalance,conditions,met,can,allocate,type,higher,than,rebalance,decision,type,rebalance,decision,type,can,allocate,type,assigned,node,node,tuple,model,node,decision,node,result,tuple,tuple,node,can,allocate,if,rebalance,conditions,met,better,balance,nodes,add,node,result,else,if,better,weight,than,current,same,balance,nodes,add,node,result,else,worse,balance,nodes,add,node,result,int,weight,ranking,0,list,node,allocation,result,node,decisions,new,array,list,model,nodes,length,1,for,tuple,model,node,decision,result,better,balance,nodes,node,decisions,add,new,node,allocation,result,result,v1,routing,node,node,allocation,decision,from,decision,type,result,v2,type,result,v2,weight,ranking,int,current,node,weight,ranking,weight,ranking,for,tuple,model,node,decision,result,same,balance,nodes,allocation,decision,node,decision,result,v2,type,type,no,allocation,decision,no,allocation,decision,node,decisions,add,new,node,allocation,result,result,v1,routing,node,node,node,decision,result,v2,current,node,weight,ranking,for,tuple,model,node,decision,result,worse,balance,nodes,allocation,decision,node,decision,result,v2,type,type,no,allocation,decision,no,allocation,decision,node,decisions,add,new,node,allocation,result,result,v1,routing,node,node,node,decision,result,v2,weight,ranking,if,can,rebalance,type,type,yes,allocation,has,pending,async,fetch,allocation,decision,allocation,decision,allocation,has,pending,async,fetch,allocation,decision,allocation,decision,from,decision,type,can,rebalance,type,return,move,decision,cannot,rebalance,can,rebalance,allocation,decision,current,node,weight,ranking,node,decisions,else,return,move,decision,rebalance,can,rebalance,allocation,decision,from,decision,type,rebalance,decision,type,assigned,node,null,assigned,node,routing,node,node,null,current,node,weight,ranking,node,decisions
BalancedShardsAllocator -> Balancer -> private MoveDecision decideRebalance(final ShardRouting shard);1541446827;Makes a decision about moving a single shard to a different node to form a more_optimally balanced cluster.  This method is invoked from the cluster allocation_explain API only.;private MoveDecision decideRebalance(final ShardRouting shard) {_            if (shard.started() == false) {_                _                return MoveDecision.NOT_TAKEN__            }__            Decision canRebalance = allocation.deciders().canRebalance(shard, allocation)___            sorter.reset(shard.getIndexName())__            ModelNode[] modelNodes = sorter.modelNodes__            final String currentNodeId = shard.currentNodeId()__            _            ModelNode currentNode = null__            for (ModelNode node : modelNodes) {_                if (node.getNodeId().equals(currentNodeId)) {_                    currentNode = node__                    break__                }_            }_            assert currentNode != null : "currently assigned node could not be found"___            _            final float currentWeight = sorter.weight(currentNode)__            final AllocationDeciders deciders = allocation.deciders()__            final String idxName = shard.getIndexName()__            Type rebalanceDecisionType = Type.NO__            ModelNode assignedNode = null__            List<Tuple<ModelNode, Decision>> betterBalanceNodes = new ArrayList<>()__            List<Tuple<ModelNode, Decision>> sameBalanceNodes = new ArrayList<>()__            List<Tuple<ModelNode, Decision>> worseBalanceNodes = new ArrayList<>()__            for (ModelNode node : modelNodes) {_                if (node == currentNode) {_                    continue_ _                }_                final Decision canAllocate = deciders.canAllocate(shard, node.getRoutingNode(), allocation)__                _                _                _                _                final float nodeWeight = sorter.weight(node)__                _                _                _                final boolean betterWeightThanCurrent = nodeWeight <= currentWeight__                boolean rebalanceConditionsMet = false__                if (betterWeightThanCurrent) {_                    _                    float currentDelta = absDelta(nodeWeight, currentWeight)__                    _                    _                    _                    _                    boolean deltaAboveThreshold = lessThan(currentDelta, threshold) == false__                    _                    float weightWithShardAdded = weight.weightShardAdded(this, node, idxName)__                    _                    _                    float proposedDelta = weightWithShardAdded - weight.weightShardRemoved(this, currentNode, idxName)__                    boolean betterWeightWithShardAdded = proposedDelta < currentDelta__                    rebalanceConditionsMet = deltaAboveThreshold && betterWeightWithShardAdded__                    _                    _                    _                    if (rebalanceConditionsMet && canAllocate.type().higherThan(rebalanceDecisionType)) {_                        _                        _                        rebalanceDecisionType = canAllocate.type()__                        assignedNode = node__                    }_                }_                Tuple<ModelNode, Decision> nodeResult = Tuple.tuple(node, canAllocate)__                if (rebalanceConditionsMet) {_                    betterBalanceNodes.add(nodeResult)__                } else if (betterWeightThanCurrent) {_                    sameBalanceNodes.add(nodeResult)__                } else {_                    worseBalanceNodes.add(nodeResult)__                }_            }__            int weightRanking = 0__            List<NodeAllocationResult> nodeDecisions = new ArrayList<>(modelNodes.length - 1)__            for (Tuple<ModelNode, Decision> result : betterBalanceNodes) {_                nodeDecisions.add(new NodeAllocationResult(_                    result.v1().routingNode.node(), AllocationDecision.fromDecisionType(result.v2().type()), result.v2(), ++weightRanking)_                )__            }_            int currentNodeWeightRanking = ++weightRanking__            for (Tuple<ModelNode, Decision> result : sameBalanceNodes) {_                AllocationDecision nodeDecision = result.v2().type() == Type.NO ? AllocationDecision.NO : AllocationDecision.WORSE_BALANCE__                nodeDecisions.add(new NodeAllocationResult(_                    result.v1().routingNode.node(), nodeDecision, result.v2(), currentNodeWeightRanking)_                )__            }_            for (Tuple<ModelNode, Decision> result : worseBalanceNodes) {_                AllocationDecision nodeDecision = result.v2().type() == Type.NO ? AllocationDecision.NO : AllocationDecision.WORSE_BALANCE__                nodeDecisions.add(new NodeAllocationResult(_                    result.v1().routingNode.node(), nodeDecision, result.v2(), ++weightRanking)_                )__            }__            if (canRebalance.type() != Type.YES || allocation.hasPendingAsyncFetch()) {_                AllocationDecision allocationDecision = allocation.hasPendingAsyncFetch() ? AllocationDecision.AWAITING_INFO :_                                                            AllocationDecision.fromDecisionType(canRebalance.type())__                return MoveDecision.cannotRebalance(canRebalance, allocationDecision, currentNodeWeightRanking, nodeDecisions)__            } else {_                return MoveDecision.rebalance(canRebalance, AllocationDecision.fromDecisionType(rebalanceDecisionType),_                    assignedNode != null ? assignedNode.routingNode.node() : null, currentNodeWeightRanking, nodeDecisions)__            }_        };makes,a,decision,about,moving,a,single,shard,to,a,different,node,to,form,a,more,optimally,balanced,cluster,this,method,is,invoked,from,the,cluster,allocation,explain,api,only;private,move,decision,decide,rebalance,final,shard,routing,shard,if,shard,started,false,return,move,decision,decision,can,rebalance,allocation,deciders,can,rebalance,shard,allocation,sorter,reset,shard,get,index,name,model,node,model,nodes,sorter,model,nodes,final,string,current,node,id,shard,current,node,id,model,node,current,node,null,for,model,node,node,model,nodes,if,node,get,node,id,equals,current,node,id,current,node,node,break,assert,current,node,null,currently,assigned,node,could,not,be,found,final,float,current,weight,sorter,weight,current,node,final,allocation,deciders,deciders,allocation,deciders,final,string,idx,name,shard,get,index,name,type,rebalance,decision,type,type,no,model,node,assigned,node,null,list,tuple,model,node,decision,better,balance,nodes,new,array,list,list,tuple,model,node,decision,same,balance,nodes,new,array,list,list,tuple,model,node,decision,worse,balance,nodes,new,array,list,for,model,node,node,model,nodes,if,node,current,node,continue,final,decision,can,allocate,deciders,can,allocate,shard,node,get,routing,node,allocation,final,float,node,weight,sorter,weight,node,final,boolean,better,weight,than,current,node,weight,current,weight,boolean,rebalance,conditions,met,false,if,better,weight,than,current,float,current,delta,abs,delta,node,weight,current,weight,boolean,delta,above,threshold,less,than,current,delta,threshold,false,float,weight,with,shard,added,weight,weight,shard,added,this,node,idx,name,float,proposed,delta,weight,with,shard,added,weight,weight,shard,removed,this,current,node,idx,name,boolean,better,weight,with,shard,added,proposed,delta,current,delta,rebalance,conditions,met,delta,above,threshold,better,weight,with,shard,added,if,rebalance,conditions,met,can,allocate,type,higher,than,rebalance,decision,type,rebalance,decision,type,can,allocate,type,assigned,node,node,tuple,model,node,decision,node,result,tuple,tuple,node,can,allocate,if,rebalance,conditions,met,better,balance,nodes,add,node,result,else,if,better,weight,than,current,same,balance,nodes,add,node,result,else,worse,balance,nodes,add,node,result,int,weight,ranking,0,list,node,allocation,result,node,decisions,new,array,list,model,nodes,length,1,for,tuple,model,node,decision,result,better,balance,nodes,node,decisions,add,new,node,allocation,result,result,v1,routing,node,node,allocation,decision,from,decision,type,result,v2,type,result,v2,weight,ranking,int,current,node,weight,ranking,weight,ranking,for,tuple,model,node,decision,result,same,balance,nodes,allocation,decision,node,decision,result,v2,type,type,no,allocation,decision,no,allocation,decision,node,decisions,add,new,node,allocation,result,result,v1,routing,node,node,node,decision,result,v2,current,node,weight,ranking,for,tuple,model,node,decision,result,worse,balance,nodes,allocation,decision,node,decision,result,v2,type,type,no,allocation,decision,no,allocation,decision,node,decisions,add,new,node,allocation,result,result,v1,routing,node,node,node,decision,result,v2,weight,ranking,if,can,rebalance,type,type,yes,allocation,has,pending,async,fetch,allocation,decision,allocation,decision,allocation,has,pending,async,fetch,allocation,decision,allocation,decision,from,decision,type,can,rebalance,type,return,move,decision,cannot,rebalance,can,rebalance,allocation,decision,current,node,weight,ranking,node,decisions,else,return,move,decision,rebalance,can,rebalance,allocation,decision,from,decision,type,rebalance,decision,type,assigned,node,null,assigned,node,routing,node,node,null,current,node,weight,ranking,node,decisions
BalancedShardsAllocator -> Balancer -> private MoveDecision decideRebalance(final ShardRouting shard);1542402632;Makes a decision about moving a single shard to a different node to form a more_optimally balanced cluster.  This method is invoked from the cluster allocation_explain API only.;private MoveDecision decideRebalance(final ShardRouting shard) {_            if (shard.started() == false) {_                _                return MoveDecision.NOT_TAKEN__            }__            Decision canRebalance = allocation.deciders().canRebalance(shard, allocation)___            sorter.reset(shard.getIndexName())__            ModelNode[] modelNodes = sorter.modelNodes__            final String currentNodeId = shard.currentNodeId()__            _            ModelNode currentNode = null__            for (ModelNode node : modelNodes) {_                if (node.getNodeId().equals(currentNodeId)) {_                    currentNode = node__                    break__                }_            }_            assert currentNode != null : "currently assigned node could not be found"___            _            final float currentWeight = sorter.weight(currentNode)__            final AllocationDeciders deciders = allocation.deciders()__            final String idxName = shard.getIndexName()__            Type rebalanceDecisionType = Type.NO__            ModelNode assignedNode = null__            List<Tuple<ModelNode, Decision>> betterBalanceNodes = new ArrayList<>()__            List<Tuple<ModelNode, Decision>> sameBalanceNodes = new ArrayList<>()__            List<Tuple<ModelNode, Decision>> worseBalanceNodes = new ArrayList<>()__            for (ModelNode node : modelNodes) {_                if (node == currentNode) {_                    continue_ _                }_                final Decision canAllocate = deciders.canAllocate(shard, node.getRoutingNode(), allocation)__                _                _                _                _                final float nodeWeight = sorter.weight(node)__                _                _                _                final boolean betterWeightThanCurrent = nodeWeight <= currentWeight__                boolean rebalanceConditionsMet = false__                if (betterWeightThanCurrent) {_                    _                    float currentDelta = absDelta(nodeWeight, currentWeight)__                    _                    _                    _                    _                    boolean deltaAboveThreshold = lessThan(currentDelta, threshold) == false__                    _                    float weightWithShardAdded = weight.weightShardAdded(this, node, idxName)__                    _                    _                    float proposedDelta = weightWithShardAdded - weight.weightShardRemoved(this, currentNode, idxName)__                    boolean betterWeightWithShardAdded = proposedDelta < currentDelta__                    rebalanceConditionsMet = deltaAboveThreshold && betterWeightWithShardAdded__                    _                    _                    _                    if (rebalanceConditionsMet && canAllocate.type().higherThan(rebalanceDecisionType)) {_                        _                        _                        rebalanceDecisionType = canAllocate.type()__                        assignedNode = node__                    }_                }_                Tuple<ModelNode, Decision> nodeResult = Tuple.tuple(node, canAllocate)__                if (rebalanceConditionsMet) {_                    betterBalanceNodes.add(nodeResult)__                } else if (betterWeightThanCurrent) {_                    sameBalanceNodes.add(nodeResult)__                } else {_                    worseBalanceNodes.add(nodeResult)__                }_            }__            int weightRanking = 0__            List<NodeAllocationResult> nodeDecisions = new ArrayList<>(modelNodes.length - 1)__            for (Tuple<ModelNode, Decision> result : betterBalanceNodes) {_                nodeDecisions.add(new NodeAllocationResult(_                    result.v1().routingNode.node(), AllocationDecision.fromDecisionType(result.v2().type()), result.v2(), ++weightRanking)_                )__            }_            int currentNodeWeightRanking = ++weightRanking__            for (Tuple<ModelNode, Decision> result : sameBalanceNodes) {_                AllocationDecision nodeDecision = result.v2().type() == Type.NO ? AllocationDecision.NO : AllocationDecision.WORSE_BALANCE__                nodeDecisions.add(new NodeAllocationResult(_                    result.v1().routingNode.node(), nodeDecision, result.v2(), currentNodeWeightRanking)_                )__            }_            for (Tuple<ModelNode, Decision> result : worseBalanceNodes) {_                AllocationDecision nodeDecision = result.v2().type() == Type.NO ? AllocationDecision.NO : AllocationDecision.WORSE_BALANCE__                nodeDecisions.add(new NodeAllocationResult(_                    result.v1().routingNode.node(), nodeDecision, result.v2(), ++weightRanking)_                )__            }__            if (canRebalance.type() != Type.YES || allocation.hasPendingAsyncFetch()) {_                AllocationDecision allocationDecision = allocation.hasPendingAsyncFetch() ? AllocationDecision.AWAITING_INFO :_                                                            AllocationDecision.fromDecisionType(canRebalance.type())__                return MoveDecision.cannotRebalance(canRebalance, allocationDecision, currentNodeWeightRanking, nodeDecisions)__            } else {_                return MoveDecision.rebalance(canRebalance, AllocationDecision.fromDecisionType(rebalanceDecisionType),_                    assignedNode != null ? assignedNode.routingNode.node() : null, currentNodeWeightRanking, nodeDecisions)__            }_        };makes,a,decision,about,moving,a,single,shard,to,a,different,node,to,form,a,more,optimally,balanced,cluster,this,method,is,invoked,from,the,cluster,allocation,explain,api,only;private,move,decision,decide,rebalance,final,shard,routing,shard,if,shard,started,false,return,move,decision,decision,can,rebalance,allocation,deciders,can,rebalance,shard,allocation,sorter,reset,shard,get,index,name,model,node,model,nodes,sorter,model,nodes,final,string,current,node,id,shard,current,node,id,model,node,current,node,null,for,model,node,node,model,nodes,if,node,get,node,id,equals,current,node,id,current,node,node,break,assert,current,node,null,currently,assigned,node,could,not,be,found,final,float,current,weight,sorter,weight,current,node,final,allocation,deciders,deciders,allocation,deciders,final,string,idx,name,shard,get,index,name,type,rebalance,decision,type,type,no,model,node,assigned,node,null,list,tuple,model,node,decision,better,balance,nodes,new,array,list,list,tuple,model,node,decision,same,balance,nodes,new,array,list,list,tuple,model,node,decision,worse,balance,nodes,new,array,list,for,model,node,node,model,nodes,if,node,current,node,continue,final,decision,can,allocate,deciders,can,allocate,shard,node,get,routing,node,allocation,final,float,node,weight,sorter,weight,node,final,boolean,better,weight,than,current,node,weight,current,weight,boolean,rebalance,conditions,met,false,if,better,weight,than,current,float,current,delta,abs,delta,node,weight,current,weight,boolean,delta,above,threshold,less,than,current,delta,threshold,false,float,weight,with,shard,added,weight,weight,shard,added,this,node,idx,name,float,proposed,delta,weight,with,shard,added,weight,weight,shard,removed,this,current,node,idx,name,boolean,better,weight,with,shard,added,proposed,delta,current,delta,rebalance,conditions,met,delta,above,threshold,better,weight,with,shard,added,if,rebalance,conditions,met,can,allocate,type,higher,than,rebalance,decision,type,rebalance,decision,type,can,allocate,type,assigned,node,node,tuple,model,node,decision,node,result,tuple,tuple,node,can,allocate,if,rebalance,conditions,met,better,balance,nodes,add,node,result,else,if,better,weight,than,current,same,balance,nodes,add,node,result,else,worse,balance,nodes,add,node,result,int,weight,ranking,0,list,node,allocation,result,node,decisions,new,array,list,model,nodes,length,1,for,tuple,model,node,decision,result,better,balance,nodes,node,decisions,add,new,node,allocation,result,result,v1,routing,node,node,allocation,decision,from,decision,type,result,v2,type,result,v2,weight,ranking,int,current,node,weight,ranking,weight,ranking,for,tuple,model,node,decision,result,same,balance,nodes,allocation,decision,node,decision,result,v2,type,type,no,allocation,decision,no,allocation,decision,node,decisions,add,new,node,allocation,result,result,v1,routing,node,node,node,decision,result,v2,current,node,weight,ranking,for,tuple,model,node,decision,result,worse,balance,nodes,allocation,decision,node,decision,result,v2,type,type,no,allocation,decision,no,allocation,decision,node,decisions,add,new,node,allocation,result,result,v1,routing,node,node,node,decision,result,v2,weight,ranking,if,can,rebalance,type,type,yes,allocation,has,pending,async,fetch,allocation,decision,allocation,decision,allocation,has,pending,async,fetch,allocation,decision,allocation,decision,from,decision,type,can,rebalance,type,return,move,decision,cannot,rebalance,can,rebalance,allocation,decision,current,node,weight,ranking,node,decisions,else,return,move,decision,rebalance,can,rebalance,allocation,decision,from,decision,type,rebalance,decision,type,assigned,node,null,assigned,node,routing,node,node,null,current,node,weight,ranking,node,decisions
BalancedShardsAllocator -> Balancer -> private MoveDecision decideRebalance(final ShardRouting shard);1549912434;Makes a decision about moving a single shard to a different node to form a more_optimally balanced cluster.  This method is invoked from the cluster allocation_explain API only.;private MoveDecision decideRebalance(final ShardRouting shard) {_            if (shard.started() == false) {_                _                return MoveDecision.NOT_TAKEN__            }__            Decision canRebalance = allocation.deciders().canRebalance(shard, allocation)___            sorter.reset(shard.getIndexName())__            ModelNode[] modelNodes = sorter.modelNodes__            final String currentNodeId = shard.currentNodeId()__            _            ModelNode currentNode = null__            for (ModelNode node : modelNodes) {_                if (node.getNodeId().equals(currentNodeId)) {_                    currentNode = node__                    break__                }_            }_            assert currentNode != null : "currently assigned node could not be found"___            _            final float currentWeight = sorter.weight(currentNode)__            final AllocationDeciders deciders = allocation.deciders()__            final String idxName = shard.getIndexName()__            Type rebalanceDecisionType = Type.NO__            ModelNode assignedNode = null__            List<Tuple<ModelNode, Decision>> betterBalanceNodes = new ArrayList<>()__            List<Tuple<ModelNode, Decision>> sameBalanceNodes = new ArrayList<>()__            List<Tuple<ModelNode, Decision>> worseBalanceNodes = new ArrayList<>()__            for (ModelNode node : modelNodes) {_                if (node == currentNode) {_                    continue_ _                }_                final Decision canAllocate = deciders.canAllocate(shard, node.getRoutingNode(), allocation)__                _                _                _                _                final float nodeWeight = sorter.weight(node)__                _                _                _                final boolean betterWeightThanCurrent = nodeWeight <= currentWeight__                boolean rebalanceConditionsMet = false__                if (betterWeightThanCurrent) {_                    _                    float currentDelta = absDelta(nodeWeight, currentWeight)__                    _                    _                    _                    _                    boolean deltaAboveThreshold = lessThan(currentDelta, threshold) == false__                    _                    float weightWithShardAdded = weight.weightShardAdded(this, node, idxName)__                    _                    _                    float proposedDelta = weightWithShardAdded - weight.weightShardRemoved(this, currentNode, idxName)__                    boolean betterWeightWithShardAdded = proposedDelta < currentDelta__                    rebalanceConditionsMet = deltaAboveThreshold && betterWeightWithShardAdded__                    _                    _                    _                    if (rebalanceConditionsMet && canAllocate.type().higherThan(rebalanceDecisionType)) {_                        _                        _                        rebalanceDecisionType = canAllocate.type()__                        assignedNode = node__                    }_                }_                Tuple<ModelNode, Decision> nodeResult = Tuple.tuple(node, canAllocate)__                if (rebalanceConditionsMet) {_                    betterBalanceNodes.add(nodeResult)__                } else if (betterWeightThanCurrent) {_                    sameBalanceNodes.add(nodeResult)__                } else {_                    worseBalanceNodes.add(nodeResult)__                }_            }__            int weightRanking = 0__            List<NodeAllocationResult> nodeDecisions = new ArrayList<>(modelNodes.length - 1)__            for (Tuple<ModelNode, Decision> result : betterBalanceNodes) {_                nodeDecisions.add(new NodeAllocationResult(_                    result.v1().routingNode.node(), AllocationDecision.fromDecisionType(result.v2().type()), result.v2(), ++weightRanking)_                )__            }_            int currentNodeWeightRanking = ++weightRanking__            for (Tuple<ModelNode, Decision> result : sameBalanceNodes) {_                AllocationDecision nodeDecision = result.v2().type() == Type.NO ? AllocationDecision.NO : AllocationDecision.WORSE_BALANCE__                nodeDecisions.add(new NodeAllocationResult(_                    result.v1().routingNode.node(), nodeDecision, result.v2(), currentNodeWeightRanking)_                )__            }_            for (Tuple<ModelNode, Decision> result : worseBalanceNodes) {_                AllocationDecision nodeDecision = result.v2().type() == Type.NO ? AllocationDecision.NO : AllocationDecision.WORSE_BALANCE__                nodeDecisions.add(new NodeAllocationResult(_                    result.v1().routingNode.node(), nodeDecision, result.v2(), ++weightRanking)_                )__            }__            if (canRebalance.type() != Type.YES || allocation.hasPendingAsyncFetch()) {_                AllocationDecision allocationDecision = allocation.hasPendingAsyncFetch() ? AllocationDecision.AWAITING_INFO :_                                                            AllocationDecision.fromDecisionType(canRebalance.type())__                return MoveDecision.cannotRebalance(canRebalance, allocationDecision, currentNodeWeightRanking, nodeDecisions)__            } else {_                return MoveDecision.rebalance(canRebalance, AllocationDecision.fromDecisionType(rebalanceDecisionType),_                    assignedNode != null ? assignedNode.routingNode.node() : null, currentNodeWeightRanking, nodeDecisions)__            }_        };makes,a,decision,about,moving,a,single,shard,to,a,different,node,to,form,a,more,optimally,balanced,cluster,this,method,is,invoked,from,the,cluster,allocation,explain,api,only;private,move,decision,decide,rebalance,final,shard,routing,shard,if,shard,started,false,return,move,decision,decision,can,rebalance,allocation,deciders,can,rebalance,shard,allocation,sorter,reset,shard,get,index,name,model,node,model,nodes,sorter,model,nodes,final,string,current,node,id,shard,current,node,id,model,node,current,node,null,for,model,node,node,model,nodes,if,node,get,node,id,equals,current,node,id,current,node,node,break,assert,current,node,null,currently,assigned,node,could,not,be,found,final,float,current,weight,sorter,weight,current,node,final,allocation,deciders,deciders,allocation,deciders,final,string,idx,name,shard,get,index,name,type,rebalance,decision,type,type,no,model,node,assigned,node,null,list,tuple,model,node,decision,better,balance,nodes,new,array,list,list,tuple,model,node,decision,same,balance,nodes,new,array,list,list,tuple,model,node,decision,worse,balance,nodes,new,array,list,for,model,node,node,model,nodes,if,node,current,node,continue,final,decision,can,allocate,deciders,can,allocate,shard,node,get,routing,node,allocation,final,float,node,weight,sorter,weight,node,final,boolean,better,weight,than,current,node,weight,current,weight,boolean,rebalance,conditions,met,false,if,better,weight,than,current,float,current,delta,abs,delta,node,weight,current,weight,boolean,delta,above,threshold,less,than,current,delta,threshold,false,float,weight,with,shard,added,weight,weight,shard,added,this,node,idx,name,float,proposed,delta,weight,with,shard,added,weight,weight,shard,removed,this,current,node,idx,name,boolean,better,weight,with,shard,added,proposed,delta,current,delta,rebalance,conditions,met,delta,above,threshold,better,weight,with,shard,added,if,rebalance,conditions,met,can,allocate,type,higher,than,rebalance,decision,type,rebalance,decision,type,can,allocate,type,assigned,node,node,tuple,model,node,decision,node,result,tuple,tuple,node,can,allocate,if,rebalance,conditions,met,better,balance,nodes,add,node,result,else,if,better,weight,than,current,same,balance,nodes,add,node,result,else,worse,balance,nodes,add,node,result,int,weight,ranking,0,list,node,allocation,result,node,decisions,new,array,list,model,nodes,length,1,for,tuple,model,node,decision,result,better,balance,nodes,node,decisions,add,new,node,allocation,result,result,v1,routing,node,node,allocation,decision,from,decision,type,result,v2,type,result,v2,weight,ranking,int,current,node,weight,ranking,weight,ranking,for,tuple,model,node,decision,result,same,balance,nodes,allocation,decision,node,decision,result,v2,type,type,no,allocation,decision,no,allocation,decision,node,decisions,add,new,node,allocation,result,result,v1,routing,node,node,node,decision,result,v2,current,node,weight,ranking,for,tuple,model,node,decision,result,worse,balance,nodes,allocation,decision,node,decision,result,v2,type,type,no,allocation,decision,no,allocation,decision,node,decisions,add,new,node,allocation,result,result,v1,routing,node,node,node,decision,result,v2,weight,ranking,if,can,rebalance,type,type,yes,allocation,has,pending,async,fetch,allocation,decision,allocation,decision,allocation,has,pending,async,fetch,allocation,decision,allocation,decision,from,decision,type,can,rebalance,type,return,move,decision,cannot,rebalance,can,rebalance,allocation,decision,current,node,weight,ranking,node,decisions,else,return,move,decision,rebalance,can,rebalance,allocation,decision,from,decision,type,rebalance,decision,type,assigned,node,null,assigned,node,routing,node,node,null,current,node,weight,ranking,node,decisions
BalancedShardsAllocator -> Balancer -> private String[] buildWeightOrderedIndices();1524684173;This builds a initial index ordering where the indices are returned_in most unbalanced first. We need this in order to prevent over_allocations on added nodes from one index when the weight parameters_for global balance overrule the index balance at an intermediate_state. For example this can happen if we have 3 nodes and 3 indices_with 3 primary and 1 replica shards. At the first stage all three nodes hold_2 shard for each index. Now we add another node and the first index_is balanced moving three shards from two of the nodes over to the new node since it_has no shards yet and global balance for the node is way below_average. To re-balance we need to move shards back eventually likely_to the nodes we relocated them from.;private String[] buildWeightOrderedIndices() {_            final String[] indices = allocation.routingTable().indicesRouting().keys().toArray(String.class)__            final float[] deltas = new float[indices.length]__            for (int i = 0_ i < deltas.length_ i++) {_                sorter.reset(indices[i])__                deltas[i] = sorter.delta()__            }_            new IntroSorter() {__                float pivotWeight___                @Override_                protected void swap(int i, int j) {_                    final String tmpIdx = indices[i]__                    indices[i] = indices[j]__                    indices[j] = tmpIdx__                    final float tmpDelta = deltas[i]__                    deltas[i] = deltas[j]__                    deltas[j] = tmpDelta__                }__                @Override_                protected int compare(int i, int j) {_                    return Float.compare(deltas[j], deltas[i])__                }__                @Override_                protected void setPivot(int i) {_                    pivotWeight = deltas[i]__                }__                @Override_                protected int comparePivot(int j) {_                    return Float.compare(deltas[j], pivotWeight)__                }_            }.sort(0, deltas.length)___            return indices__        };this,builds,a,initial,index,ordering,where,the,indices,are,returned,in,most,unbalanced,first,we,need,this,in,order,to,prevent,over,allocations,on,added,nodes,from,one,index,when,the,weight,parameters,for,global,balance,overrule,the,index,balance,at,an,intermediate,state,for,example,this,can,happen,if,we,have,3,nodes,and,3,indices,with,3,primary,and,1,replica,shards,at,the,first,stage,all,three,nodes,hold,2,shard,for,each,index,now,we,add,another,node,and,the,first,index,is,balanced,moving,three,shards,from,two,of,the,nodes,over,to,the,new,node,since,it,has,no,shards,yet,and,global,balance,for,the,node,is,way,below,average,to,re,balance,we,need,to,move,shards,back,eventually,likely,to,the,nodes,we,relocated,them,from;private,string,build,weight,ordered,indices,final,string,indices,allocation,routing,table,indices,routing,keys,to,array,string,class,final,float,deltas,new,float,indices,length,for,int,i,0,i,deltas,length,i,sorter,reset,indices,i,deltas,i,sorter,delta,new,intro,sorter,float,pivot,weight,override,protected,void,swap,int,i,int,j,final,string,tmp,idx,indices,i,indices,i,indices,j,indices,j,tmp,idx,final,float,tmp,delta,deltas,i,deltas,i,deltas,j,deltas,j,tmp,delta,override,protected,int,compare,int,i,int,j,return,float,compare,deltas,j,deltas,i,override,protected,void,set,pivot,int,i,pivot,weight,deltas,i,override,protected,int,compare,pivot,int,j,return,float,compare,deltas,j,pivot,weight,sort,0,deltas,length,return,indices
BalancedShardsAllocator -> Balancer -> private String[] buildWeightOrderedIndices();1525334055;This builds a initial index ordering where the indices are returned_in most unbalanced first. We need this in order to prevent over_allocations on added nodes from one index when the weight parameters_for global balance overrule the index balance at an intermediate_state. For example this can happen if we have 3 nodes and 3 indices_with 3 primary and 1 replica shards. At the first stage all three nodes hold_2 shard for each index. Now we add another node and the first index_is balanced moving three shards from two of the nodes over to the new node since it_has no shards yet and global balance for the node is way below_average. To re-balance we need to move shards back eventually likely_to the nodes we relocated them from.;private String[] buildWeightOrderedIndices() {_            final String[] indices = allocation.routingTable().indicesRouting().keys().toArray(String.class)__            final float[] deltas = new float[indices.length]__            for (int i = 0_ i < deltas.length_ i++) {_                sorter.reset(indices[i])__                deltas[i] = sorter.delta()__            }_            new IntroSorter() {__                float pivotWeight___                @Override_                protected void swap(int i, int j) {_                    final String tmpIdx = indices[i]__                    indices[i] = indices[j]__                    indices[j] = tmpIdx__                    final float tmpDelta = deltas[i]__                    deltas[i] = deltas[j]__                    deltas[j] = tmpDelta__                }__                @Override_                protected int compare(int i, int j) {_                    return Float.compare(deltas[j], deltas[i])__                }__                @Override_                protected void setPivot(int i) {_                    pivotWeight = deltas[i]__                }__                @Override_                protected int comparePivot(int j) {_                    return Float.compare(deltas[j], pivotWeight)__                }_            }.sort(0, deltas.length)___            return indices__        };this,builds,a,initial,index,ordering,where,the,indices,are,returned,in,most,unbalanced,first,we,need,this,in,order,to,prevent,over,allocations,on,added,nodes,from,one,index,when,the,weight,parameters,for,global,balance,overrule,the,index,balance,at,an,intermediate,state,for,example,this,can,happen,if,we,have,3,nodes,and,3,indices,with,3,primary,and,1,replica,shards,at,the,first,stage,all,three,nodes,hold,2,shard,for,each,index,now,we,add,another,node,and,the,first,index,is,balanced,moving,three,shards,from,two,of,the,nodes,over,to,the,new,node,since,it,has,no,shards,yet,and,global,balance,for,the,node,is,way,below,average,to,re,balance,we,need,to,move,shards,back,eventually,likely,to,the,nodes,we,relocated,them,from;private,string,build,weight,ordered,indices,final,string,indices,allocation,routing,table,indices,routing,keys,to,array,string,class,final,float,deltas,new,float,indices,length,for,int,i,0,i,deltas,length,i,sorter,reset,indices,i,deltas,i,sorter,delta,new,intro,sorter,float,pivot,weight,override,protected,void,swap,int,i,int,j,final,string,tmp,idx,indices,i,indices,i,indices,j,indices,j,tmp,idx,final,float,tmp,delta,deltas,i,deltas,i,deltas,j,deltas,j,tmp,delta,override,protected,int,compare,int,i,int,j,return,float,compare,deltas,j,deltas,i,override,protected,void,set,pivot,int,i,pivot,weight,deltas,i,override,protected,int,compare,pivot,int,j,return,float,compare,deltas,j,pivot,weight,sort,0,deltas,length,return,indices
BalancedShardsAllocator -> Balancer -> private String[] buildWeightOrderedIndices();1531234550;This builds a initial index ordering where the indices are returned_in most unbalanced first. We need this in order to prevent over_allocations on added nodes from one index when the weight parameters_for global balance overrule the index balance at an intermediate_state. For example this can happen if we have 3 nodes and 3 indices_with 3 primary and 1 replica shards. At the first stage all three nodes hold_2 shard for each index. Now we add another node and the first index_is balanced moving three shards from two of the nodes over to the new node since it_has no shards yet and global balance for the node is way below_average. To re-balance we need to move shards back eventually likely_to the nodes we relocated them from.;private String[] buildWeightOrderedIndices() {_            final String[] indices = allocation.routingTable().indicesRouting().keys().toArray(String.class)__            final float[] deltas = new float[indices.length]__            for (int i = 0_ i < deltas.length_ i++) {_                sorter.reset(indices[i])__                deltas[i] = sorter.delta()__            }_            new IntroSorter() {__                float pivotWeight___                @Override_                protected void swap(int i, int j) {_                    final String tmpIdx = indices[i]__                    indices[i] = indices[j]__                    indices[j] = tmpIdx__                    final float tmpDelta = deltas[i]__                    deltas[i] = deltas[j]__                    deltas[j] = tmpDelta__                }__                @Override_                protected int compare(int i, int j) {_                    return Float.compare(deltas[j], deltas[i])__                }__                @Override_                protected void setPivot(int i) {_                    pivotWeight = deltas[i]__                }__                @Override_                protected int comparePivot(int j) {_                    return Float.compare(deltas[j], pivotWeight)__                }_            }.sort(0, deltas.length)___            return indices__        };this,builds,a,initial,index,ordering,where,the,indices,are,returned,in,most,unbalanced,first,we,need,this,in,order,to,prevent,over,allocations,on,added,nodes,from,one,index,when,the,weight,parameters,for,global,balance,overrule,the,index,balance,at,an,intermediate,state,for,example,this,can,happen,if,we,have,3,nodes,and,3,indices,with,3,primary,and,1,replica,shards,at,the,first,stage,all,three,nodes,hold,2,shard,for,each,index,now,we,add,another,node,and,the,first,index,is,balanced,moving,three,shards,from,two,of,the,nodes,over,to,the,new,node,since,it,has,no,shards,yet,and,global,balance,for,the,node,is,way,below,average,to,re,balance,we,need,to,move,shards,back,eventually,likely,to,the,nodes,we,relocated,them,from;private,string,build,weight,ordered,indices,final,string,indices,allocation,routing,table,indices,routing,keys,to,array,string,class,final,float,deltas,new,float,indices,length,for,int,i,0,i,deltas,length,i,sorter,reset,indices,i,deltas,i,sorter,delta,new,intro,sorter,float,pivot,weight,override,protected,void,swap,int,i,int,j,final,string,tmp,idx,indices,i,indices,i,indices,j,indices,j,tmp,idx,final,float,tmp,delta,deltas,i,deltas,i,deltas,j,deltas,j,tmp,delta,override,protected,int,compare,int,i,int,j,return,float,compare,deltas,j,deltas,i,override,protected,void,set,pivot,int,i,pivot,weight,deltas,i,override,protected,int,compare,pivot,int,j,return,float,compare,deltas,j,pivot,weight,sort,0,deltas,length,return,indices
BalancedShardsAllocator -> Balancer -> private String[] buildWeightOrderedIndices();1540847035;This builds a initial index ordering where the indices are returned_in most unbalanced first. We need this in order to prevent over_allocations on added nodes from one index when the weight parameters_for global balance overrule the index balance at an intermediate_state. For example this can happen if we have 3 nodes and 3 indices_with 3 primary and 1 replica shards. At the first stage all three nodes hold_2 shard for each index. Now we add another node and the first index_is balanced moving three shards from two of the nodes over to the new node since it_has no shards yet and global balance for the node is way below_average. To re-balance we need to move shards back eventually likely_to the nodes we relocated them from.;private String[] buildWeightOrderedIndices() {_            final String[] indices = allocation.routingTable().indicesRouting().keys().toArray(String.class)__            final float[] deltas = new float[indices.length]__            for (int i = 0_ i < deltas.length_ i++) {_                sorter.reset(indices[i])__                deltas[i] = sorter.delta()__            }_            new IntroSorter() {__                float pivotWeight___                @Override_                protected void swap(int i, int j) {_                    final String tmpIdx = indices[i]__                    indices[i] = indices[j]__                    indices[j] = tmpIdx__                    final float tmpDelta = deltas[i]__                    deltas[i] = deltas[j]__                    deltas[j] = tmpDelta__                }__                @Override_                protected int compare(int i, int j) {_                    return Float.compare(deltas[j], deltas[i])__                }__                @Override_                protected void setPivot(int i) {_                    pivotWeight = deltas[i]__                }__                @Override_                protected int comparePivot(int j) {_                    return Float.compare(deltas[j], pivotWeight)__                }_            }.sort(0, deltas.length)___            return indices__        };this,builds,a,initial,index,ordering,where,the,indices,are,returned,in,most,unbalanced,first,we,need,this,in,order,to,prevent,over,allocations,on,added,nodes,from,one,index,when,the,weight,parameters,for,global,balance,overrule,the,index,balance,at,an,intermediate,state,for,example,this,can,happen,if,we,have,3,nodes,and,3,indices,with,3,primary,and,1,replica,shards,at,the,first,stage,all,three,nodes,hold,2,shard,for,each,index,now,we,add,another,node,and,the,first,index,is,balanced,moving,three,shards,from,two,of,the,nodes,over,to,the,new,node,since,it,has,no,shards,yet,and,global,balance,for,the,node,is,way,below,average,to,re,balance,we,need,to,move,shards,back,eventually,likely,to,the,nodes,we,relocated,them,from;private,string,build,weight,ordered,indices,final,string,indices,allocation,routing,table,indices,routing,keys,to,array,string,class,final,float,deltas,new,float,indices,length,for,int,i,0,i,deltas,length,i,sorter,reset,indices,i,deltas,i,sorter,delta,new,intro,sorter,float,pivot,weight,override,protected,void,swap,int,i,int,j,final,string,tmp,idx,indices,i,indices,i,indices,j,indices,j,tmp,idx,final,float,tmp,delta,deltas,i,deltas,i,deltas,j,deltas,j,tmp,delta,override,protected,int,compare,int,i,int,j,return,float,compare,deltas,j,deltas,i,override,protected,void,set,pivot,int,i,pivot,weight,deltas,i,override,protected,int,compare,pivot,int,j,return,float,compare,deltas,j,pivot,weight,sort,0,deltas,length,return,indices
BalancedShardsAllocator -> Balancer -> private String[] buildWeightOrderedIndices();1541092382;This builds a initial index ordering where the indices are returned_in most unbalanced first. We need this in order to prevent over_allocations on added nodes from one index when the weight parameters_for global balance overrule the index balance at an intermediate_state. For example this can happen if we have 3 nodes and 3 indices_with 3 primary and 1 replica shards. At the first stage all three nodes hold_2 shard for each index. Now we add another node and the first index_is balanced moving three shards from two of the nodes over to the new node since it_has no shards yet and global balance for the node is way below_average. To re-balance we need to move shards back eventually likely_to the nodes we relocated them from.;private String[] buildWeightOrderedIndices() {_            final String[] indices = allocation.routingTable().indicesRouting().keys().toArray(String.class)__            final float[] deltas = new float[indices.length]__            for (int i = 0_ i < deltas.length_ i++) {_                sorter.reset(indices[i])__                deltas[i] = sorter.delta()__            }_            new IntroSorter() {__                float pivotWeight___                @Override_                protected void swap(int i, int j) {_                    final String tmpIdx = indices[i]__                    indices[i] = indices[j]__                    indices[j] = tmpIdx__                    final float tmpDelta = deltas[i]__                    deltas[i] = deltas[j]__                    deltas[j] = tmpDelta__                }__                @Override_                protected int compare(int i, int j) {_                    return Float.compare(deltas[j], deltas[i])__                }__                @Override_                protected void setPivot(int i) {_                    pivotWeight = deltas[i]__                }__                @Override_                protected int comparePivot(int j) {_                    return Float.compare(deltas[j], pivotWeight)__                }_            }.sort(0, deltas.length)___            return indices__        };this,builds,a,initial,index,ordering,where,the,indices,are,returned,in,most,unbalanced,first,we,need,this,in,order,to,prevent,over,allocations,on,added,nodes,from,one,index,when,the,weight,parameters,for,global,balance,overrule,the,index,balance,at,an,intermediate,state,for,example,this,can,happen,if,we,have,3,nodes,and,3,indices,with,3,primary,and,1,replica,shards,at,the,first,stage,all,three,nodes,hold,2,shard,for,each,index,now,we,add,another,node,and,the,first,index,is,balanced,moving,three,shards,from,two,of,the,nodes,over,to,the,new,node,since,it,has,no,shards,yet,and,global,balance,for,the,node,is,way,below,average,to,re,balance,we,need,to,move,shards,back,eventually,likely,to,the,nodes,we,relocated,them,from;private,string,build,weight,ordered,indices,final,string,indices,allocation,routing,table,indices,routing,keys,to,array,string,class,final,float,deltas,new,float,indices,length,for,int,i,0,i,deltas,length,i,sorter,reset,indices,i,deltas,i,sorter,delta,new,intro,sorter,float,pivot,weight,override,protected,void,swap,int,i,int,j,final,string,tmp,idx,indices,i,indices,i,indices,j,indices,j,tmp,idx,final,float,tmp,delta,deltas,i,deltas,i,deltas,j,deltas,j,tmp,delta,override,protected,int,compare,int,i,int,j,return,float,compare,deltas,j,deltas,i,override,protected,void,set,pivot,int,i,pivot,weight,deltas,i,override,protected,int,compare,pivot,int,j,return,float,compare,deltas,j,pivot,weight,sort,0,deltas,length,return,indices
BalancedShardsAllocator -> Balancer -> private String[] buildWeightOrderedIndices();1541446827;This builds a initial index ordering where the indices are returned_in most unbalanced first. We need this in order to prevent over_allocations on added nodes from one index when the weight parameters_for global balance overrule the index balance at an intermediate_state. For example this can happen if we have 3 nodes and 3 indices_with 3 primary and 1 replica shards. At the first stage all three nodes hold_2 shard for each index. Now we add another node and the first index_is balanced moving three shards from two of the nodes over to the new node since it_has no shards yet and global balance for the node is way below_average. To re-balance we need to move shards back eventually likely_to the nodes we relocated them from.;private String[] buildWeightOrderedIndices() {_            final String[] indices = allocation.routingTable().indicesRouting().keys().toArray(String.class)__            final float[] deltas = new float[indices.length]__            for (int i = 0_ i < deltas.length_ i++) {_                sorter.reset(indices[i])__                deltas[i] = sorter.delta()__            }_            new IntroSorter() {__                float pivotWeight___                @Override_                protected void swap(int i, int j) {_                    final String tmpIdx = indices[i]__                    indices[i] = indices[j]__                    indices[j] = tmpIdx__                    final float tmpDelta = deltas[i]__                    deltas[i] = deltas[j]__                    deltas[j] = tmpDelta__                }__                @Override_                protected int compare(int i, int j) {_                    return Float.compare(deltas[j], deltas[i])__                }__                @Override_                protected void setPivot(int i) {_                    pivotWeight = deltas[i]__                }__                @Override_                protected int comparePivot(int j) {_                    return Float.compare(deltas[j], pivotWeight)__                }_            }.sort(0, deltas.length)___            return indices__        };this,builds,a,initial,index,ordering,where,the,indices,are,returned,in,most,unbalanced,first,we,need,this,in,order,to,prevent,over,allocations,on,added,nodes,from,one,index,when,the,weight,parameters,for,global,balance,overrule,the,index,balance,at,an,intermediate,state,for,example,this,can,happen,if,we,have,3,nodes,and,3,indices,with,3,primary,and,1,replica,shards,at,the,first,stage,all,three,nodes,hold,2,shard,for,each,index,now,we,add,another,node,and,the,first,index,is,balanced,moving,three,shards,from,two,of,the,nodes,over,to,the,new,node,since,it,has,no,shards,yet,and,global,balance,for,the,node,is,way,below,average,to,re,balance,we,need,to,move,shards,back,eventually,likely,to,the,nodes,we,relocated,them,from;private,string,build,weight,ordered,indices,final,string,indices,allocation,routing,table,indices,routing,keys,to,array,string,class,final,float,deltas,new,float,indices,length,for,int,i,0,i,deltas,length,i,sorter,reset,indices,i,deltas,i,sorter,delta,new,intro,sorter,float,pivot,weight,override,protected,void,swap,int,i,int,j,final,string,tmp,idx,indices,i,indices,i,indices,j,indices,j,tmp,idx,final,float,tmp,delta,deltas,i,deltas,i,deltas,j,deltas,j,tmp,delta,override,protected,int,compare,int,i,int,j,return,float,compare,deltas,j,deltas,i,override,protected,void,set,pivot,int,i,pivot,weight,deltas,i,override,protected,int,compare,pivot,int,j,return,float,compare,deltas,j,pivot,weight,sort,0,deltas,length,return,indices
BalancedShardsAllocator -> Balancer -> private String[] buildWeightOrderedIndices();1542402632;This builds a initial index ordering where the indices are returned_in most unbalanced first. We need this in order to prevent over_allocations on added nodes from one index when the weight parameters_for global balance overrule the index balance at an intermediate_state. For example this can happen if we have 3 nodes and 3 indices_with 3 primary and 1 replica shards. At the first stage all three nodes hold_2 shard for each index. Now we add another node and the first index_is balanced moving three shards from two of the nodes over to the new node since it_has no shards yet and global balance for the node is way below_average. To re-balance we need to move shards back eventually likely_to the nodes we relocated them from.;private String[] buildWeightOrderedIndices() {_            final String[] indices = allocation.routingTable().indicesRouting().keys().toArray(String.class)__            final float[] deltas = new float[indices.length]__            for (int i = 0_ i < deltas.length_ i++) {_                sorter.reset(indices[i])__                deltas[i] = sorter.delta()__            }_            new IntroSorter() {__                float pivotWeight___                @Override_                protected void swap(int i, int j) {_                    final String tmpIdx = indices[i]__                    indices[i] = indices[j]__                    indices[j] = tmpIdx__                    final float tmpDelta = deltas[i]__                    deltas[i] = deltas[j]__                    deltas[j] = tmpDelta__                }__                @Override_                protected int compare(int i, int j) {_                    return Float.compare(deltas[j], deltas[i])__                }__                @Override_                protected void setPivot(int i) {_                    pivotWeight = deltas[i]__                }__                @Override_                protected int comparePivot(int j) {_                    return Float.compare(deltas[j], pivotWeight)__                }_            }.sort(0, deltas.length)___            return indices__        };this,builds,a,initial,index,ordering,where,the,indices,are,returned,in,most,unbalanced,first,we,need,this,in,order,to,prevent,over,allocations,on,added,nodes,from,one,index,when,the,weight,parameters,for,global,balance,overrule,the,index,balance,at,an,intermediate,state,for,example,this,can,happen,if,we,have,3,nodes,and,3,indices,with,3,primary,and,1,replica,shards,at,the,first,stage,all,three,nodes,hold,2,shard,for,each,index,now,we,add,another,node,and,the,first,index,is,balanced,moving,three,shards,from,two,of,the,nodes,over,to,the,new,node,since,it,has,no,shards,yet,and,global,balance,for,the,node,is,way,below,average,to,re,balance,we,need,to,move,shards,back,eventually,likely,to,the,nodes,we,relocated,them,from;private,string,build,weight,ordered,indices,final,string,indices,allocation,routing,table,indices,routing,keys,to,array,string,class,final,float,deltas,new,float,indices,length,for,int,i,0,i,deltas,length,i,sorter,reset,indices,i,deltas,i,sorter,delta,new,intro,sorter,float,pivot,weight,override,protected,void,swap,int,i,int,j,final,string,tmp,idx,indices,i,indices,i,indices,j,indices,j,tmp,idx,final,float,tmp,delta,deltas,i,deltas,i,deltas,j,deltas,j,tmp,delta,override,protected,int,compare,int,i,int,j,return,float,compare,deltas,j,deltas,i,override,protected,void,set,pivot,int,i,pivot,weight,deltas,i,override,protected,int,compare,pivot,int,j,return,float,compare,deltas,j,pivot,weight,sort,0,deltas,length,return,indices
BalancedShardsAllocator -> Balancer -> private String[] buildWeightOrderedIndices();1549912434;This builds a initial index ordering where the indices are returned_in most unbalanced first. We need this in order to prevent over_allocations on added nodes from one index when the weight parameters_for global balance overrule the index balance at an intermediate_state. For example this can happen if we have 3 nodes and 3 indices_with 3 primary and 1 replica shards. At the first stage all three nodes hold_2 shard for each index. Now we add another node and the first index_is balanced moving three shards from two of the nodes over to the new node since it_has no shards yet and global balance for the node is way below_average. To re-balance we need to move shards back eventually likely_to the nodes we relocated them from.;private String[] buildWeightOrderedIndices() {_            final String[] indices = allocation.routingTable().indicesRouting().keys().toArray(String.class)__            final float[] deltas = new float[indices.length]__            for (int i = 0_ i < deltas.length_ i++) {_                sorter.reset(indices[i])__                deltas[i] = sorter.delta()__            }_            new IntroSorter() {__                float pivotWeight___                @Override_                protected void swap(int i, int j) {_                    final String tmpIdx = indices[i]__                    indices[i] = indices[j]__                    indices[j] = tmpIdx__                    final float tmpDelta = deltas[i]__                    deltas[i] = deltas[j]__                    deltas[j] = tmpDelta__                }__                @Override_                protected int compare(int i, int j) {_                    return Float.compare(deltas[j], deltas[i])__                }__                @Override_                protected void setPivot(int i) {_                    pivotWeight = deltas[i]__                }__                @Override_                protected int comparePivot(int j) {_                    return Float.compare(deltas[j], pivotWeight)__                }_            }.sort(0, deltas.length)___            return indices__        };this,builds,a,initial,index,ordering,where,the,indices,are,returned,in,most,unbalanced,first,we,need,this,in,order,to,prevent,over,allocations,on,added,nodes,from,one,index,when,the,weight,parameters,for,global,balance,overrule,the,index,balance,at,an,intermediate,state,for,example,this,can,happen,if,we,have,3,nodes,and,3,indices,with,3,primary,and,1,replica,shards,at,the,first,stage,all,three,nodes,hold,2,shard,for,each,index,now,we,add,another,node,and,the,first,index,is,balanced,moving,three,shards,from,two,of,the,nodes,over,to,the,new,node,since,it,has,no,shards,yet,and,global,balance,for,the,node,is,way,below,average,to,re,balance,we,need,to,move,shards,back,eventually,likely,to,the,nodes,we,relocated,them,from;private,string,build,weight,ordered,indices,final,string,indices,allocation,routing,table,indices,routing,keys,to,array,string,class,final,float,deltas,new,float,indices,length,for,int,i,0,i,deltas,length,i,sorter,reset,indices,i,deltas,i,sorter,delta,new,intro,sorter,float,pivot,weight,override,protected,void,swap,int,i,int,j,final,string,tmp,idx,indices,i,indices,i,indices,j,indices,j,tmp,idx,final,float,tmp,delta,deltas,i,deltas,i,deltas,j,deltas,j,tmp,delta,override,protected,int,compare,int,i,int,j,return,float,compare,deltas,j,deltas,i,override,protected,void,set,pivot,int,i,pivot,weight,deltas,i,override,protected,int,compare,pivot,int,j,return,float,compare,deltas,j,pivot,weight,sort,0,deltas,length,return,indices
BalancedShardsAllocator -> Balancer -> public MoveDecision decideMove(final ShardRouting shardRouting);1524684173;Makes a decision on whether to move a started shard to another node.  The following rules apply_to the {@link MoveDecision} return object:_1. If the shard is not started, no decision will be taken and {@link MoveDecision#isDecisionTaken()} will return false._2. If the shard is allowed to remain on its current node, no attempt will be made to move the shard and_{@link MoveDecision#canRemainDecision} will have a decision type of YES.  All other fields in the object will be null._3. If the shard is not allowed to remain on its current node, then {@link MoveDecision#getAllocationDecision()} will be_populated with the decision of moving to another node.  If {@link MoveDecision#forceMove()} ()} returns {@code true}, then_{@link MoveDecision#targetNode} will return a non-null value, otherwise the assignedNodeId will be null._4. If the method is invoked in explain mode (e.g. from the cluster allocation explain APIs), then_{@link MoveDecision#nodeDecisions} will have a non-null value.;public MoveDecision decideMove(final ShardRouting shardRouting) {_            if (shardRouting.started() == false) {_                _                return MoveDecision.NOT_TAKEN__            }__            final boolean explain = allocation.debugDecision()__            final ModelNode sourceNode = nodes.get(shardRouting.currentNodeId())__            assert sourceNode != null && sourceNode.containsShard(shardRouting)__            RoutingNode routingNode = sourceNode.getRoutingNode()__            Decision canRemain = allocation.deciders().canRemain(shardRouting, routingNode, allocation)__            if (canRemain.type() != Decision.Type.NO) {_                return MoveDecision.stay(canRemain)__            }__            sorter.reset(shardRouting.getIndexName())__            _            Type bestDecision = Type.NO__            RoutingNode targetNode = null__            final List<NodeAllocationResult> nodeExplanationMap = explain ? new ArrayList<>() : null__            int weightRanking = 0__            for (ModelNode currentNode : sorter.modelNodes) {_                if (currentNode != sourceNode) {_                    RoutingNode target = currentNode.getRoutingNode()__                    _                    Decision allocationDecision = allocation.deciders().canAllocate(shardRouting, target, allocation)__                    if (explain) {_                        nodeExplanationMap.add(new NodeAllocationResult(_                            currentNode.getRoutingNode().node(), allocationDecision, ++weightRanking))__                    }_                    _                    if (allocationDecision.type().higherThan(bestDecision)) {_                        bestDecision = allocationDecision.type()__                        if (bestDecision == Type.YES) {_                            targetNode = target__                            if (explain == false) {_                                _                                _                                break__                            }_                        }_                    }_                }_            }__            return MoveDecision.cannotRemain(canRemain, AllocationDecision.fromDecisionType(bestDecision),_                targetNode != null ? targetNode.node() : null, nodeExplanationMap)__        };makes,a,decision,on,whether,to,move,a,started,shard,to,another,node,the,following,rules,apply,to,the,link,move,decision,return,object,1,if,the,shard,is,not,started,no,decision,will,be,taken,and,link,move,decision,is,decision,taken,will,return,false,2,if,the,shard,is,allowed,to,remain,on,its,current,node,no,attempt,will,be,made,to,move,the,shard,and,link,move,decision,can,remain,decision,will,have,a,decision,type,of,yes,all,other,fields,in,the,object,will,be,null,3,if,the,shard,is,not,allowed,to,remain,on,its,current,node,then,link,move,decision,get,allocation,decision,will,be,populated,with,the,decision,of,moving,to,another,node,if,link,move,decision,force,move,returns,code,true,then,link,move,decision,target,node,will,return,a,non,null,value,otherwise,the,assigned,node,id,will,be,null,4,if,the,method,is,invoked,in,explain,mode,e,g,from,the,cluster,allocation,explain,apis,then,link,move,decision,node,decisions,will,have,a,non,null,value;public,move,decision,decide,move,final,shard,routing,shard,routing,if,shard,routing,started,false,return,move,decision,final,boolean,explain,allocation,debug,decision,final,model,node,source,node,nodes,get,shard,routing,current,node,id,assert,source,node,null,source,node,contains,shard,shard,routing,routing,node,routing,node,source,node,get,routing,node,decision,can,remain,allocation,deciders,can,remain,shard,routing,routing,node,allocation,if,can,remain,type,decision,type,no,return,move,decision,stay,can,remain,sorter,reset,shard,routing,get,index,name,type,best,decision,type,no,routing,node,target,node,null,final,list,node,allocation,result,node,explanation,map,explain,new,array,list,null,int,weight,ranking,0,for,model,node,current,node,sorter,model,nodes,if,current,node,source,node,routing,node,target,current,node,get,routing,node,decision,allocation,decision,allocation,deciders,can,allocate,shard,routing,target,allocation,if,explain,node,explanation,map,add,new,node,allocation,result,current,node,get,routing,node,node,allocation,decision,weight,ranking,if,allocation,decision,type,higher,than,best,decision,best,decision,allocation,decision,type,if,best,decision,type,yes,target,node,target,if,explain,false,break,return,move,decision,cannot,remain,can,remain,allocation,decision,from,decision,type,best,decision,target,node,null,target,node,node,null,node,explanation,map
BalancedShardsAllocator -> Balancer -> public MoveDecision decideMove(final ShardRouting shardRouting);1525334055;Makes a decision on whether to move a started shard to another node.  The following rules apply_to the {@link MoveDecision} return object:_1. If the shard is not started, no decision will be taken and {@link MoveDecision#isDecisionTaken()} will return false._2. If the shard is allowed to remain on its current node, no attempt will be made to move the shard and_{@link MoveDecision#canRemainDecision} will have a decision type of YES.  All other fields in the object will be null._3. If the shard is not allowed to remain on its current node, then {@link MoveDecision#getAllocationDecision()} will be_populated with the decision of moving to another node.  If {@link MoveDecision#forceMove()} ()} returns {@code true}, then_{@link MoveDecision#targetNode} will return a non-null value, otherwise the assignedNodeId will be null._4. If the method is invoked in explain mode (e.g. from the cluster allocation explain APIs), then_{@link MoveDecision#nodeDecisions} will have a non-null value.;public MoveDecision decideMove(final ShardRouting shardRouting) {_            if (shardRouting.started() == false) {_                _                return MoveDecision.NOT_TAKEN__            }__            final boolean explain = allocation.debugDecision()__            final ModelNode sourceNode = nodes.get(shardRouting.currentNodeId())__            assert sourceNode != null && sourceNode.containsShard(shardRouting)__            RoutingNode routingNode = sourceNode.getRoutingNode()__            Decision canRemain = allocation.deciders().canRemain(shardRouting, routingNode, allocation)__            if (canRemain.type() != Decision.Type.NO) {_                return MoveDecision.stay(canRemain)__            }__            sorter.reset(shardRouting.getIndexName())__            _            Type bestDecision = Type.NO__            RoutingNode targetNode = null__            final List<NodeAllocationResult> nodeExplanationMap = explain ? new ArrayList<>() : null__            int weightRanking = 0__            for (ModelNode currentNode : sorter.modelNodes) {_                if (currentNode != sourceNode) {_                    RoutingNode target = currentNode.getRoutingNode()__                    _                    Decision allocationDecision = allocation.deciders().canAllocate(shardRouting, target, allocation)__                    if (explain) {_                        nodeExplanationMap.add(new NodeAllocationResult(_                            currentNode.getRoutingNode().node(), allocationDecision, ++weightRanking))__                    }_                    _                    if (allocationDecision.type().higherThan(bestDecision)) {_                        bestDecision = allocationDecision.type()__                        if (bestDecision == Type.YES) {_                            targetNode = target__                            if (explain == false) {_                                _                                _                                break__                            }_                        }_                    }_                }_            }__            return MoveDecision.cannotRemain(canRemain, AllocationDecision.fromDecisionType(bestDecision),_                targetNode != null ? targetNode.node() : null, nodeExplanationMap)__        };makes,a,decision,on,whether,to,move,a,started,shard,to,another,node,the,following,rules,apply,to,the,link,move,decision,return,object,1,if,the,shard,is,not,started,no,decision,will,be,taken,and,link,move,decision,is,decision,taken,will,return,false,2,if,the,shard,is,allowed,to,remain,on,its,current,node,no,attempt,will,be,made,to,move,the,shard,and,link,move,decision,can,remain,decision,will,have,a,decision,type,of,yes,all,other,fields,in,the,object,will,be,null,3,if,the,shard,is,not,allowed,to,remain,on,its,current,node,then,link,move,decision,get,allocation,decision,will,be,populated,with,the,decision,of,moving,to,another,node,if,link,move,decision,force,move,returns,code,true,then,link,move,decision,target,node,will,return,a,non,null,value,otherwise,the,assigned,node,id,will,be,null,4,if,the,method,is,invoked,in,explain,mode,e,g,from,the,cluster,allocation,explain,apis,then,link,move,decision,node,decisions,will,have,a,non,null,value;public,move,decision,decide,move,final,shard,routing,shard,routing,if,shard,routing,started,false,return,move,decision,final,boolean,explain,allocation,debug,decision,final,model,node,source,node,nodes,get,shard,routing,current,node,id,assert,source,node,null,source,node,contains,shard,shard,routing,routing,node,routing,node,source,node,get,routing,node,decision,can,remain,allocation,deciders,can,remain,shard,routing,routing,node,allocation,if,can,remain,type,decision,type,no,return,move,decision,stay,can,remain,sorter,reset,shard,routing,get,index,name,type,best,decision,type,no,routing,node,target,node,null,final,list,node,allocation,result,node,explanation,map,explain,new,array,list,null,int,weight,ranking,0,for,model,node,current,node,sorter,model,nodes,if,current,node,source,node,routing,node,target,current,node,get,routing,node,decision,allocation,decision,allocation,deciders,can,allocate,shard,routing,target,allocation,if,explain,node,explanation,map,add,new,node,allocation,result,current,node,get,routing,node,node,allocation,decision,weight,ranking,if,allocation,decision,type,higher,than,best,decision,best,decision,allocation,decision,type,if,best,decision,type,yes,target,node,target,if,explain,false,break,return,move,decision,cannot,remain,can,remain,allocation,decision,from,decision,type,best,decision,target,node,null,target,node,node,null,node,explanation,map
BalancedShardsAllocator -> Balancer -> public MoveDecision decideMove(final ShardRouting shardRouting);1531234550;Makes a decision on whether to move a started shard to another node.  The following rules apply_to the {@link MoveDecision} return object:_1. If the shard is not started, no decision will be taken and {@link MoveDecision#isDecisionTaken()} will return false._2. If the shard is allowed to remain on its current node, no attempt will be made to move the shard and_{@link MoveDecision#canRemainDecision} will have a decision type of YES.  All other fields in the object will be null._3. If the shard is not allowed to remain on its current node, then {@link MoveDecision#getAllocationDecision()} will be_populated with the decision of moving to another node.  If {@link MoveDecision#forceMove()} ()} returns {@code true}, then_{@link MoveDecision#targetNode} will return a non-null value, otherwise the assignedNodeId will be null._4. If the method is invoked in explain mode (e.g. from the cluster allocation explain APIs), then_{@link MoveDecision#nodeDecisions} will have a non-null value.;public MoveDecision decideMove(final ShardRouting shardRouting) {_            if (shardRouting.started() == false) {_                _                return MoveDecision.NOT_TAKEN__            }__            final boolean explain = allocation.debugDecision()__            final ModelNode sourceNode = nodes.get(shardRouting.currentNodeId())__            assert sourceNode != null && sourceNode.containsShard(shardRouting)__            RoutingNode routingNode = sourceNode.getRoutingNode()__            Decision canRemain = allocation.deciders().canRemain(shardRouting, routingNode, allocation)__            if (canRemain.type() != Decision.Type.NO) {_                return MoveDecision.stay(canRemain)__            }__            sorter.reset(shardRouting.getIndexName())__            _            Type bestDecision = Type.NO__            RoutingNode targetNode = null__            final List<NodeAllocationResult> nodeExplanationMap = explain ? new ArrayList<>() : null__            int weightRanking = 0__            for (ModelNode currentNode : sorter.modelNodes) {_                if (currentNode != sourceNode) {_                    RoutingNode target = currentNode.getRoutingNode()__                    _                    Decision allocationDecision = allocation.deciders().canAllocate(shardRouting, target, allocation)__                    if (explain) {_                        nodeExplanationMap.add(new NodeAllocationResult(_                            currentNode.getRoutingNode().node(), allocationDecision, ++weightRanking))__                    }_                    _                    if (allocationDecision.type().higherThan(bestDecision)) {_                        bestDecision = allocationDecision.type()__                        if (bestDecision == Type.YES) {_                            targetNode = target__                            if (explain == false) {_                                _                                _                                break__                            }_                        }_                    }_                }_            }__            return MoveDecision.cannotRemain(canRemain, AllocationDecision.fromDecisionType(bestDecision),_                targetNode != null ? targetNode.node() : null, nodeExplanationMap)__        };makes,a,decision,on,whether,to,move,a,started,shard,to,another,node,the,following,rules,apply,to,the,link,move,decision,return,object,1,if,the,shard,is,not,started,no,decision,will,be,taken,and,link,move,decision,is,decision,taken,will,return,false,2,if,the,shard,is,allowed,to,remain,on,its,current,node,no,attempt,will,be,made,to,move,the,shard,and,link,move,decision,can,remain,decision,will,have,a,decision,type,of,yes,all,other,fields,in,the,object,will,be,null,3,if,the,shard,is,not,allowed,to,remain,on,its,current,node,then,link,move,decision,get,allocation,decision,will,be,populated,with,the,decision,of,moving,to,another,node,if,link,move,decision,force,move,returns,code,true,then,link,move,decision,target,node,will,return,a,non,null,value,otherwise,the,assigned,node,id,will,be,null,4,if,the,method,is,invoked,in,explain,mode,e,g,from,the,cluster,allocation,explain,apis,then,link,move,decision,node,decisions,will,have,a,non,null,value;public,move,decision,decide,move,final,shard,routing,shard,routing,if,shard,routing,started,false,return,move,decision,final,boolean,explain,allocation,debug,decision,final,model,node,source,node,nodes,get,shard,routing,current,node,id,assert,source,node,null,source,node,contains,shard,shard,routing,routing,node,routing,node,source,node,get,routing,node,decision,can,remain,allocation,deciders,can,remain,shard,routing,routing,node,allocation,if,can,remain,type,decision,type,no,return,move,decision,stay,can,remain,sorter,reset,shard,routing,get,index,name,type,best,decision,type,no,routing,node,target,node,null,final,list,node,allocation,result,node,explanation,map,explain,new,array,list,null,int,weight,ranking,0,for,model,node,current,node,sorter,model,nodes,if,current,node,source,node,routing,node,target,current,node,get,routing,node,decision,allocation,decision,allocation,deciders,can,allocate,shard,routing,target,allocation,if,explain,node,explanation,map,add,new,node,allocation,result,current,node,get,routing,node,node,allocation,decision,weight,ranking,if,allocation,decision,type,higher,than,best,decision,best,decision,allocation,decision,type,if,best,decision,type,yes,target,node,target,if,explain,false,break,return,move,decision,cannot,remain,can,remain,allocation,decision,from,decision,type,best,decision,target,node,null,target,node,node,null,node,explanation,map
BalancedShardsAllocator -> Balancer -> public MoveDecision decideMove(final ShardRouting shardRouting);1540847035;Makes a decision on whether to move a started shard to another node.  The following rules apply_to the {@link MoveDecision} return object:_1. If the shard is not started, no decision will be taken and {@link MoveDecision#isDecisionTaken()} will return false._2. If the shard is allowed to remain on its current node, no attempt will be made to move the shard and_{@link MoveDecision#canRemainDecision} will have a decision type of YES.  All other fields in the object will be null._3. If the shard is not allowed to remain on its current node, then {@link MoveDecision#getAllocationDecision()} will be_populated with the decision of moving to another node.  If {@link MoveDecision#forceMove()} ()} returns {@code true}, then_{@link MoveDecision#targetNode} will return a non-null value, otherwise the assignedNodeId will be null._4. If the method is invoked in explain mode (e.g. from the cluster allocation explain APIs), then_{@link MoveDecision#nodeDecisions} will have a non-null value.;public MoveDecision decideMove(final ShardRouting shardRouting) {_            if (shardRouting.started() == false) {_                _                return MoveDecision.NOT_TAKEN__            }__            final boolean explain = allocation.debugDecision()__            final ModelNode sourceNode = nodes.get(shardRouting.currentNodeId())__            assert sourceNode != null && sourceNode.containsShard(shardRouting)__            RoutingNode routingNode = sourceNode.getRoutingNode()__            Decision canRemain = allocation.deciders().canRemain(shardRouting, routingNode, allocation)__            if (canRemain.type() != Decision.Type.NO) {_                return MoveDecision.stay(canRemain)__            }__            sorter.reset(shardRouting.getIndexName())__            _            Type bestDecision = Type.NO__            RoutingNode targetNode = null__            final List<NodeAllocationResult> nodeExplanationMap = explain ? new ArrayList<>() : null__            int weightRanking = 0__            for (ModelNode currentNode : sorter.modelNodes) {_                if (currentNode != sourceNode) {_                    RoutingNode target = currentNode.getRoutingNode()__                    _                    Decision allocationDecision = allocation.deciders().canAllocate(shardRouting, target, allocation)__                    if (explain) {_                        nodeExplanationMap.add(new NodeAllocationResult(_                            currentNode.getRoutingNode().node(), allocationDecision, ++weightRanking))__                    }_                    _                    if (allocationDecision.type().higherThan(bestDecision)) {_                        bestDecision = allocationDecision.type()__                        if (bestDecision == Type.YES) {_                            targetNode = target__                            if (explain == false) {_                                _                                _                                break__                            }_                        }_                    }_                }_            }__            return MoveDecision.cannotRemain(canRemain, AllocationDecision.fromDecisionType(bestDecision),_                targetNode != null ? targetNode.node() : null, nodeExplanationMap)__        };makes,a,decision,on,whether,to,move,a,started,shard,to,another,node,the,following,rules,apply,to,the,link,move,decision,return,object,1,if,the,shard,is,not,started,no,decision,will,be,taken,and,link,move,decision,is,decision,taken,will,return,false,2,if,the,shard,is,allowed,to,remain,on,its,current,node,no,attempt,will,be,made,to,move,the,shard,and,link,move,decision,can,remain,decision,will,have,a,decision,type,of,yes,all,other,fields,in,the,object,will,be,null,3,if,the,shard,is,not,allowed,to,remain,on,its,current,node,then,link,move,decision,get,allocation,decision,will,be,populated,with,the,decision,of,moving,to,another,node,if,link,move,decision,force,move,returns,code,true,then,link,move,decision,target,node,will,return,a,non,null,value,otherwise,the,assigned,node,id,will,be,null,4,if,the,method,is,invoked,in,explain,mode,e,g,from,the,cluster,allocation,explain,apis,then,link,move,decision,node,decisions,will,have,a,non,null,value;public,move,decision,decide,move,final,shard,routing,shard,routing,if,shard,routing,started,false,return,move,decision,final,boolean,explain,allocation,debug,decision,final,model,node,source,node,nodes,get,shard,routing,current,node,id,assert,source,node,null,source,node,contains,shard,shard,routing,routing,node,routing,node,source,node,get,routing,node,decision,can,remain,allocation,deciders,can,remain,shard,routing,routing,node,allocation,if,can,remain,type,decision,type,no,return,move,decision,stay,can,remain,sorter,reset,shard,routing,get,index,name,type,best,decision,type,no,routing,node,target,node,null,final,list,node,allocation,result,node,explanation,map,explain,new,array,list,null,int,weight,ranking,0,for,model,node,current,node,sorter,model,nodes,if,current,node,source,node,routing,node,target,current,node,get,routing,node,decision,allocation,decision,allocation,deciders,can,allocate,shard,routing,target,allocation,if,explain,node,explanation,map,add,new,node,allocation,result,current,node,get,routing,node,node,allocation,decision,weight,ranking,if,allocation,decision,type,higher,than,best,decision,best,decision,allocation,decision,type,if,best,decision,type,yes,target,node,target,if,explain,false,break,return,move,decision,cannot,remain,can,remain,allocation,decision,from,decision,type,best,decision,target,node,null,target,node,node,null,node,explanation,map
BalancedShardsAllocator -> Balancer -> public MoveDecision decideMove(final ShardRouting shardRouting);1541092382;Makes a decision on whether to move a started shard to another node.  The following rules apply_to the {@link MoveDecision} return object:_1. If the shard is not started, no decision will be taken and {@link MoveDecision#isDecisionTaken()} will return false._2. If the shard is allowed to remain on its current node, no attempt will be made to move the shard and_{@link MoveDecision#canRemainDecision} will have a decision type of YES.  All other fields in the object will be null._3. If the shard is not allowed to remain on its current node, then {@link MoveDecision#getAllocationDecision()} will be_populated with the decision of moving to another node.  If {@link MoveDecision#forceMove()} ()} returns {@code true}, then_{@link MoveDecision#targetNode} will return a non-null value, otherwise the assignedNodeId will be null._4. If the method is invoked in explain mode (e.g. from the cluster allocation explain APIs), then_{@link MoveDecision#nodeDecisions} will have a non-null value.;public MoveDecision decideMove(final ShardRouting shardRouting) {_            if (shardRouting.started() == false) {_                _                return MoveDecision.NOT_TAKEN__            }__            final boolean explain = allocation.debugDecision()__            final ModelNode sourceNode = nodes.get(shardRouting.currentNodeId())__            assert sourceNode != null && sourceNode.containsShard(shardRouting)__            RoutingNode routingNode = sourceNode.getRoutingNode()__            Decision canRemain = allocation.deciders().canRemain(shardRouting, routingNode, allocation)__            if (canRemain.type() != Decision.Type.NO) {_                return MoveDecision.stay(canRemain)__            }__            sorter.reset(shardRouting.getIndexName())__            _            Type bestDecision = Type.NO__            RoutingNode targetNode = null__            final List<NodeAllocationResult> nodeExplanationMap = explain ? new ArrayList<>() : null__            int weightRanking = 0__            for (ModelNode currentNode : sorter.modelNodes) {_                if (currentNode != sourceNode) {_                    RoutingNode target = currentNode.getRoutingNode()__                    _                    Decision allocationDecision = allocation.deciders().canAllocate(shardRouting, target, allocation)__                    if (explain) {_                        nodeExplanationMap.add(new NodeAllocationResult(_                            currentNode.getRoutingNode().node(), allocationDecision, ++weightRanking))__                    }_                    _                    if (allocationDecision.type().higherThan(bestDecision)) {_                        bestDecision = allocationDecision.type()__                        if (bestDecision == Type.YES) {_                            targetNode = target__                            if (explain == false) {_                                _                                _                                break__                            }_                        }_                    }_                }_            }__            return MoveDecision.cannotRemain(canRemain, AllocationDecision.fromDecisionType(bestDecision),_                targetNode != null ? targetNode.node() : null, nodeExplanationMap)__        };makes,a,decision,on,whether,to,move,a,started,shard,to,another,node,the,following,rules,apply,to,the,link,move,decision,return,object,1,if,the,shard,is,not,started,no,decision,will,be,taken,and,link,move,decision,is,decision,taken,will,return,false,2,if,the,shard,is,allowed,to,remain,on,its,current,node,no,attempt,will,be,made,to,move,the,shard,and,link,move,decision,can,remain,decision,will,have,a,decision,type,of,yes,all,other,fields,in,the,object,will,be,null,3,if,the,shard,is,not,allowed,to,remain,on,its,current,node,then,link,move,decision,get,allocation,decision,will,be,populated,with,the,decision,of,moving,to,another,node,if,link,move,decision,force,move,returns,code,true,then,link,move,decision,target,node,will,return,a,non,null,value,otherwise,the,assigned,node,id,will,be,null,4,if,the,method,is,invoked,in,explain,mode,e,g,from,the,cluster,allocation,explain,apis,then,link,move,decision,node,decisions,will,have,a,non,null,value;public,move,decision,decide,move,final,shard,routing,shard,routing,if,shard,routing,started,false,return,move,decision,final,boolean,explain,allocation,debug,decision,final,model,node,source,node,nodes,get,shard,routing,current,node,id,assert,source,node,null,source,node,contains,shard,shard,routing,routing,node,routing,node,source,node,get,routing,node,decision,can,remain,allocation,deciders,can,remain,shard,routing,routing,node,allocation,if,can,remain,type,decision,type,no,return,move,decision,stay,can,remain,sorter,reset,shard,routing,get,index,name,type,best,decision,type,no,routing,node,target,node,null,final,list,node,allocation,result,node,explanation,map,explain,new,array,list,null,int,weight,ranking,0,for,model,node,current,node,sorter,model,nodes,if,current,node,source,node,routing,node,target,current,node,get,routing,node,decision,allocation,decision,allocation,deciders,can,allocate,shard,routing,target,allocation,if,explain,node,explanation,map,add,new,node,allocation,result,current,node,get,routing,node,node,allocation,decision,weight,ranking,if,allocation,decision,type,higher,than,best,decision,best,decision,allocation,decision,type,if,best,decision,type,yes,target,node,target,if,explain,false,break,return,move,decision,cannot,remain,can,remain,allocation,decision,from,decision,type,best,decision,target,node,null,target,node,node,null,node,explanation,map
BalancedShardsAllocator -> Balancer -> public MoveDecision decideMove(final ShardRouting shardRouting);1541446827;Makes a decision on whether to move a started shard to another node.  The following rules apply_to the {@link MoveDecision} return object:_1. If the shard is not started, no decision will be taken and {@link MoveDecision#isDecisionTaken()} will return false._2. If the shard is allowed to remain on its current node, no attempt will be made to move the shard and_{@link MoveDecision#canRemainDecision} will have a decision type of YES.  All other fields in the object will be null._3. If the shard is not allowed to remain on its current node, then {@link MoveDecision#getAllocationDecision()} will be_populated with the decision of moving to another node.  If {@link MoveDecision#forceMove()} ()} returns {@code true}, then_{@link MoveDecision#targetNode} will return a non-null value, otherwise the assignedNodeId will be null._4. If the method is invoked in explain mode (e.g. from the cluster allocation explain APIs), then_{@link MoveDecision#nodeDecisions} will have a non-null value.;public MoveDecision decideMove(final ShardRouting shardRouting) {_            if (shardRouting.started() == false) {_                _                return MoveDecision.NOT_TAKEN__            }__            final boolean explain = allocation.debugDecision()__            final ModelNode sourceNode = nodes.get(shardRouting.currentNodeId())__            assert sourceNode != null && sourceNode.containsShard(shardRouting)__            RoutingNode routingNode = sourceNode.getRoutingNode()__            Decision canRemain = allocation.deciders().canRemain(shardRouting, routingNode, allocation)__            if (canRemain.type() != Decision.Type.NO) {_                return MoveDecision.stay(canRemain)__            }__            sorter.reset(shardRouting.getIndexName())__            _            Type bestDecision = Type.NO__            RoutingNode targetNode = null__            final List<NodeAllocationResult> nodeExplanationMap = explain ? new ArrayList<>() : null__            int weightRanking = 0__            for (ModelNode currentNode : sorter.modelNodes) {_                if (currentNode != sourceNode) {_                    RoutingNode target = currentNode.getRoutingNode()__                    _                    Decision allocationDecision = allocation.deciders().canAllocate(shardRouting, target, allocation)__                    if (explain) {_                        nodeExplanationMap.add(new NodeAllocationResult(_                            currentNode.getRoutingNode().node(), allocationDecision, ++weightRanking))__                    }_                    _                    if (allocationDecision.type().higherThan(bestDecision)) {_                        bestDecision = allocationDecision.type()__                        if (bestDecision == Type.YES) {_                            targetNode = target__                            if (explain == false) {_                                _                                _                                break__                            }_                        }_                    }_                }_            }__            return MoveDecision.cannotRemain(canRemain, AllocationDecision.fromDecisionType(bestDecision),_                targetNode != null ? targetNode.node() : null, nodeExplanationMap)__        };makes,a,decision,on,whether,to,move,a,started,shard,to,another,node,the,following,rules,apply,to,the,link,move,decision,return,object,1,if,the,shard,is,not,started,no,decision,will,be,taken,and,link,move,decision,is,decision,taken,will,return,false,2,if,the,shard,is,allowed,to,remain,on,its,current,node,no,attempt,will,be,made,to,move,the,shard,and,link,move,decision,can,remain,decision,will,have,a,decision,type,of,yes,all,other,fields,in,the,object,will,be,null,3,if,the,shard,is,not,allowed,to,remain,on,its,current,node,then,link,move,decision,get,allocation,decision,will,be,populated,with,the,decision,of,moving,to,another,node,if,link,move,decision,force,move,returns,code,true,then,link,move,decision,target,node,will,return,a,non,null,value,otherwise,the,assigned,node,id,will,be,null,4,if,the,method,is,invoked,in,explain,mode,e,g,from,the,cluster,allocation,explain,apis,then,link,move,decision,node,decisions,will,have,a,non,null,value;public,move,decision,decide,move,final,shard,routing,shard,routing,if,shard,routing,started,false,return,move,decision,final,boolean,explain,allocation,debug,decision,final,model,node,source,node,nodes,get,shard,routing,current,node,id,assert,source,node,null,source,node,contains,shard,shard,routing,routing,node,routing,node,source,node,get,routing,node,decision,can,remain,allocation,deciders,can,remain,shard,routing,routing,node,allocation,if,can,remain,type,decision,type,no,return,move,decision,stay,can,remain,sorter,reset,shard,routing,get,index,name,type,best,decision,type,no,routing,node,target,node,null,final,list,node,allocation,result,node,explanation,map,explain,new,array,list,null,int,weight,ranking,0,for,model,node,current,node,sorter,model,nodes,if,current,node,source,node,routing,node,target,current,node,get,routing,node,decision,allocation,decision,allocation,deciders,can,allocate,shard,routing,target,allocation,if,explain,node,explanation,map,add,new,node,allocation,result,current,node,get,routing,node,node,allocation,decision,weight,ranking,if,allocation,decision,type,higher,than,best,decision,best,decision,allocation,decision,type,if,best,decision,type,yes,target,node,target,if,explain,false,break,return,move,decision,cannot,remain,can,remain,allocation,decision,from,decision,type,best,decision,target,node,null,target,node,node,null,node,explanation,map
BalancedShardsAllocator -> Balancer -> public MoveDecision decideMove(final ShardRouting shardRouting);1542402632;Makes a decision on whether to move a started shard to another node.  The following rules apply_to the {@link MoveDecision} return object:_1. If the shard is not started, no decision will be taken and {@link MoveDecision#isDecisionTaken()} will return false._2. If the shard is allowed to remain on its current node, no attempt will be made to move the shard and_{@link MoveDecision#canRemainDecision} will have a decision type of YES.  All other fields in the object will be null._3. If the shard is not allowed to remain on its current node, then {@link MoveDecision#getAllocationDecision()} will be_populated with the decision of moving to another node.  If {@link MoveDecision#forceMove()} ()} returns {@code true}, then_{@link MoveDecision#targetNode} will return a non-null value, otherwise the assignedNodeId will be null._4. If the method is invoked in explain mode (e.g. from the cluster allocation explain APIs), then_{@link MoveDecision#nodeDecisions} will have a non-null value.;public MoveDecision decideMove(final ShardRouting shardRouting) {_            if (shardRouting.started() == false) {_                _                return MoveDecision.NOT_TAKEN__            }__            final boolean explain = allocation.debugDecision()__            final ModelNode sourceNode = nodes.get(shardRouting.currentNodeId())__            assert sourceNode != null && sourceNode.containsShard(shardRouting)__            RoutingNode routingNode = sourceNode.getRoutingNode()__            Decision canRemain = allocation.deciders().canRemain(shardRouting, routingNode, allocation)__            if (canRemain.type() != Decision.Type.NO) {_                return MoveDecision.stay(canRemain)__            }__            sorter.reset(shardRouting.getIndexName())__            _            Type bestDecision = Type.NO__            RoutingNode targetNode = null__            final List<NodeAllocationResult> nodeExplanationMap = explain ? new ArrayList<>() : null__            int weightRanking = 0__            for (ModelNode currentNode : sorter.modelNodes) {_                if (currentNode != sourceNode) {_                    RoutingNode target = currentNode.getRoutingNode()__                    _                    Decision allocationDecision = allocation.deciders().canAllocate(shardRouting, target, allocation)__                    if (explain) {_                        nodeExplanationMap.add(new NodeAllocationResult(_                            currentNode.getRoutingNode().node(), allocationDecision, ++weightRanking))__                    }_                    _                    if (allocationDecision.type().higherThan(bestDecision)) {_                        bestDecision = allocationDecision.type()__                        if (bestDecision == Type.YES) {_                            targetNode = target__                            if (explain == false) {_                                _                                _                                break__                            }_                        }_                    }_                }_            }__            return MoveDecision.cannotRemain(canRemain, AllocationDecision.fromDecisionType(bestDecision),_                targetNode != null ? targetNode.node() : null, nodeExplanationMap)__        };makes,a,decision,on,whether,to,move,a,started,shard,to,another,node,the,following,rules,apply,to,the,link,move,decision,return,object,1,if,the,shard,is,not,started,no,decision,will,be,taken,and,link,move,decision,is,decision,taken,will,return,false,2,if,the,shard,is,allowed,to,remain,on,its,current,node,no,attempt,will,be,made,to,move,the,shard,and,link,move,decision,can,remain,decision,will,have,a,decision,type,of,yes,all,other,fields,in,the,object,will,be,null,3,if,the,shard,is,not,allowed,to,remain,on,its,current,node,then,link,move,decision,get,allocation,decision,will,be,populated,with,the,decision,of,moving,to,another,node,if,link,move,decision,force,move,returns,code,true,then,link,move,decision,target,node,will,return,a,non,null,value,otherwise,the,assigned,node,id,will,be,null,4,if,the,method,is,invoked,in,explain,mode,e,g,from,the,cluster,allocation,explain,apis,then,link,move,decision,node,decisions,will,have,a,non,null,value;public,move,decision,decide,move,final,shard,routing,shard,routing,if,shard,routing,started,false,return,move,decision,final,boolean,explain,allocation,debug,decision,final,model,node,source,node,nodes,get,shard,routing,current,node,id,assert,source,node,null,source,node,contains,shard,shard,routing,routing,node,routing,node,source,node,get,routing,node,decision,can,remain,allocation,deciders,can,remain,shard,routing,routing,node,allocation,if,can,remain,type,decision,type,no,return,move,decision,stay,can,remain,sorter,reset,shard,routing,get,index,name,type,best,decision,type,no,routing,node,target,node,null,final,list,node,allocation,result,node,explanation,map,explain,new,array,list,null,int,weight,ranking,0,for,model,node,current,node,sorter,model,nodes,if,current,node,source,node,routing,node,target,current,node,get,routing,node,decision,allocation,decision,allocation,deciders,can,allocate,shard,routing,target,allocation,if,explain,node,explanation,map,add,new,node,allocation,result,current,node,get,routing,node,node,allocation,decision,weight,ranking,if,allocation,decision,type,higher,than,best,decision,best,decision,allocation,decision,type,if,best,decision,type,yes,target,node,target,if,explain,false,break,return,move,decision,cannot,remain,can,remain,allocation,decision,from,decision,type,best,decision,target,node,null,target,node,node,null,node,explanation,map
BalancedShardsAllocator -> Balancer -> public MoveDecision decideMove(final ShardRouting shardRouting);1549912434;Makes a decision on whether to move a started shard to another node.  The following rules apply_to the {@link MoveDecision} return object:_1. If the shard is not started, no decision will be taken and {@link MoveDecision#isDecisionTaken()} will return false._2. If the shard is allowed to remain on its current node, no attempt will be made to move the shard and_{@link MoveDecision#canRemainDecision} will have a decision type of YES.  All other fields in the object will be null._3. If the shard is not allowed to remain on its current node, then {@link MoveDecision#getAllocationDecision()} will be_populated with the decision of moving to another node.  If {@link MoveDecision#forceMove()} ()} returns {@code true}, then_{@link MoveDecision#targetNode} will return a non-null value, otherwise the assignedNodeId will be null._4. If the method is invoked in explain mode (e.g. from the cluster allocation explain APIs), then_{@link MoveDecision#nodeDecisions} will have a non-null value.;public MoveDecision decideMove(final ShardRouting shardRouting) {_            if (shardRouting.started() == false) {_                _                return MoveDecision.NOT_TAKEN__            }__            final boolean explain = allocation.debugDecision()__            final ModelNode sourceNode = nodes.get(shardRouting.currentNodeId())__            assert sourceNode != null && sourceNode.containsShard(shardRouting)__            RoutingNode routingNode = sourceNode.getRoutingNode()__            Decision canRemain = allocation.deciders().canRemain(shardRouting, routingNode, allocation)__            if (canRemain.type() != Decision.Type.NO) {_                return MoveDecision.stay(canRemain)__            }__            sorter.reset(shardRouting.getIndexName())__            _            Type bestDecision = Type.NO__            RoutingNode targetNode = null__            final List<NodeAllocationResult> nodeExplanationMap = explain ? new ArrayList<>() : null__            int weightRanking = 0__            for (ModelNode currentNode : sorter.modelNodes) {_                if (currentNode != sourceNode) {_                    RoutingNode target = currentNode.getRoutingNode()__                    _                    Decision allocationDecision = allocation.deciders().canAllocate(shardRouting, target, allocation)__                    if (explain) {_                        nodeExplanationMap.add(new NodeAllocationResult(_                            currentNode.getRoutingNode().node(), allocationDecision, ++weightRanking))__                    }_                    _                    if (allocationDecision.type().higherThan(bestDecision)) {_                        bestDecision = allocationDecision.type()__                        if (bestDecision == Type.YES) {_                            targetNode = target__                            if (explain == false) {_                                _                                _                                break__                            }_                        }_                    }_                }_            }__            return MoveDecision.cannotRemain(canRemain, AllocationDecision.fromDecisionType(bestDecision),_                targetNode != null ? targetNode.node() : null, nodeExplanationMap)__        };makes,a,decision,on,whether,to,move,a,started,shard,to,another,node,the,following,rules,apply,to,the,link,move,decision,return,object,1,if,the,shard,is,not,started,no,decision,will,be,taken,and,link,move,decision,is,decision,taken,will,return,false,2,if,the,shard,is,allowed,to,remain,on,its,current,node,no,attempt,will,be,made,to,move,the,shard,and,link,move,decision,can,remain,decision,will,have,a,decision,type,of,yes,all,other,fields,in,the,object,will,be,null,3,if,the,shard,is,not,allowed,to,remain,on,its,current,node,then,link,move,decision,get,allocation,decision,will,be,populated,with,the,decision,of,moving,to,another,node,if,link,move,decision,force,move,returns,code,true,then,link,move,decision,target,node,will,return,a,non,null,value,otherwise,the,assigned,node,id,will,be,null,4,if,the,method,is,invoked,in,explain,mode,e,g,from,the,cluster,allocation,explain,apis,then,link,move,decision,node,decisions,will,have,a,non,null,value;public,move,decision,decide,move,final,shard,routing,shard,routing,if,shard,routing,started,false,return,move,decision,final,boolean,explain,allocation,debug,decision,final,model,node,source,node,nodes,get,shard,routing,current,node,id,assert,source,node,null,source,node,contains,shard,shard,routing,routing,node,routing,node,source,node,get,routing,node,decision,can,remain,allocation,deciders,can,remain,shard,routing,routing,node,allocation,if,can,remain,type,decision,type,no,return,move,decision,stay,can,remain,sorter,reset,shard,routing,get,index,name,type,best,decision,type,no,routing,node,target,node,null,final,list,node,allocation,result,node,explanation,map,explain,new,array,list,null,int,weight,ranking,0,for,model,node,current,node,sorter,model,nodes,if,current,node,source,node,routing,node,target,current,node,get,routing,node,decision,allocation,decision,allocation,deciders,can,allocate,shard,routing,target,allocation,if,explain,node,explanation,map,add,new,node,allocation,result,current,node,get,routing,node,node,allocation,decision,weight,ranking,if,allocation,decision,type,higher,than,best,decision,best,decision,allocation,decision,type,if,best,decision,type,yes,target,node,target,if,explain,false,break,return,move,decision,cannot,remain,can,remain,allocation,decision,from,decision,type,best,decision,target,node,null,target,node,node,null,node,explanation,map
BalancedShardsAllocator -> NodeSorter -> public void reset(String index, int from, int to);1524684173;Resets the sorter, recalculates the weights per node and sorts the_nodes by weight, with minimal weight first.;public void reset(String index, int from, int to) {_            this.index = index__            for (int i = from_ i < to_ i++) {_                weights[i] = weight(modelNodes[i])__            }_            sort(from, to)__        };resets,the,sorter,recalculates,the,weights,per,node,and,sorts,the,nodes,by,weight,with,minimal,weight,first;public,void,reset,string,index,int,from,int,to,this,index,index,for,int,i,from,i,to,i,weights,i,weight,model,nodes,i,sort,from,to
BalancedShardsAllocator -> NodeSorter -> public void reset(String index, int from, int to);1525334055;Resets the sorter, recalculates the weights per node and sorts the_nodes by weight, with minimal weight first.;public void reset(String index, int from, int to) {_            this.index = index__            for (int i = from_ i < to_ i++) {_                weights[i] = weight(modelNodes[i])__            }_            sort(from, to)__        };resets,the,sorter,recalculates,the,weights,per,node,and,sorts,the,nodes,by,weight,with,minimal,weight,first;public,void,reset,string,index,int,from,int,to,this,index,index,for,int,i,from,i,to,i,weights,i,weight,model,nodes,i,sort,from,to
BalancedShardsAllocator -> NodeSorter -> public void reset(String index, int from, int to);1531234550;Resets the sorter, recalculates the weights per node and sorts the_nodes by weight, with minimal weight first.;public void reset(String index, int from, int to) {_            this.index = index__            for (int i = from_ i < to_ i++) {_                weights[i] = weight(modelNodes[i])__            }_            sort(from, to)__        };resets,the,sorter,recalculates,the,weights,per,node,and,sorts,the,nodes,by,weight,with,minimal,weight,first;public,void,reset,string,index,int,from,int,to,this,index,index,for,int,i,from,i,to,i,weights,i,weight,model,nodes,i,sort,from,to
BalancedShardsAllocator -> NodeSorter -> public void reset(String index, int from, int to);1540847035;Resets the sorter, recalculates the weights per node and sorts the_nodes by weight, with minimal weight first.;public void reset(String index, int from, int to) {_            this.index = index__            for (int i = from_ i < to_ i++) {_                weights[i] = weight(modelNodes[i])__            }_            sort(from, to)__        };resets,the,sorter,recalculates,the,weights,per,node,and,sorts,the,nodes,by,weight,with,minimal,weight,first;public,void,reset,string,index,int,from,int,to,this,index,index,for,int,i,from,i,to,i,weights,i,weight,model,nodes,i,sort,from,to
BalancedShardsAllocator -> NodeSorter -> public void reset(String index, int from, int to);1541092382;Resets the sorter, recalculates the weights per node and sorts the_nodes by weight, with minimal weight first.;public void reset(String index, int from, int to) {_            this.index = index__            for (int i = from_ i < to_ i++) {_                weights[i] = weight(modelNodes[i])__            }_            sort(from, to)__        };resets,the,sorter,recalculates,the,weights,per,node,and,sorts,the,nodes,by,weight,with,minimal,weight,first;public,void,reset,string,index,int,from,int,to,this,index,index,for,int,i,from,i,to,i,weights,i,weight,model,nodes,i,sort,from,to
BalancedShardsAllocator -> NodeSorter -> public void reset(String index, int from, int to);1541446827;Resets the sorter, recalculates the weights per node and sorts the_nodes by weight, with minimal weight first.;public void reset(String index, int from, int to) {_            this.index = index__            for (int i = from_ i < to_ i++) {_                weights[i] = weight(modelNodes[i])__            }_            sort(from, to)__        };resets,the,sorter,recalculates,the,weights,per,node,and,sorts,the,nodes,by,weight,with,minimal,weight,first;public,void,reset,string,index,int,from,int,to,this,index,index,for,int,i,from,i,to,i,weights,i,weight,model,nodes,i,sort,from,to
BalancedShardsAllocator -> NodeSorter -> public void reset(String index, int from, int to);1542402632;Resets the sorter, recalculates the weights per node and sorts the_nodes by weight, with minimal weight first.;public void reset(String index, int from, int to) {_            this.index = index__            for (int i = from_ i < to_ i++) {_                weights[i] = weight(modelNodes[i])__            }_            sort(from, to)__        };resets,the,sorter,recalculates,the,weights,per,node,and,sorts,the,nodes,by,weight,with,minimal,weight,first;public,void,reset,string,index,int,from,int,to,this,index,index,for,int,i,from,i,to,i,weights,i,weight,model,nodes,i,sort,from,to
BalancedShardsAllocator -> NodeSorter -> public void reset(String index, int from, int to);1549912434;Resets the sorter, recalculates the weights per node and sorts the_nodes by weight, with minimal weight first.;public void reset(String index, int from, int to) {_            this.index = index__            for (int i = from_ i < to_ i++) {_                weights[i] = weight(modelNodes[i])__            }_            sort(from, to)__        };resets,the,sorter,recalculates,the,weights,per,node,and,sorts,the,nodes,by,weight,with,minimal,weight,first;public,void,reset,string,index,int,from,int,to,this,index,index,for,int,i,from,i,to,i,weights,i,weight,model,nodes,i,sort,from,to
BalancedShardsAllocator -> Balancer -> private static boolean lessThan(float delta, float threshold);1524684173;Returns {@code true} iff the weight delta between two nodes is under a defined threshold._See {@link #THRESHOLD_SETTING} for defining the threshold.;private static boolean lessThan(float delta, float threshold) {_            _            return delta <= (threshold + 0.001f)__        };returns,code,true,iff,the,weight,delta,between,two,nodes,is,under,a,defined,threshold,see,link,for,defining,the,threshold;private,static,boolean,less,than,float,delta,float,threshold,return,delta,threshold,0,001f
BalancedShardsAllocator -> Balancer -> private static boolean lessThan(float delta, float threshold);1525334055;Returns {@code true} iff the weight delta between two nodes is under a defined threshold._See {@link #THRESHOLD_SETTING} for defining the threshold.;private static boolean lessThan(float delta, float threshold) {_            _            return delta <= (threshold + 0.001f)__        };returns,code,true,iff,the,weight,delta,between,two,nodes,is,under,a,defined,threshold,see,link,for,defining,the,threshold;private,static,boolean,less,than,float,delta,float,threshold,return,delta,threshold,0,001f
BalancedShardsAllocator -> Balancer -> private static boolean lessThan(float delta, float threshold);1531234550;Returns {@code true} iff the weight delta between two nodes is under a defined threshold._See {@link #THRESHOLD_SETTING} for defining the threshold.;private static boolean lessThan(float delta, float threshold) {_            _            return delta <= (threshold + 0.001f)__        };returns,code,true,iff,the,weight,delta,between,two,nodes,is,under,a,defined,threshold,see,link,for,defining,the,threshold;private,static,boolean,less,than,float,delta,float,threshold,return,delta,threshold,0,001f
BalancedShardsAllocator -> Balancer -> private static boolean lessThan(float delta, float threshold);1540847035;Returns {@code true} iff the weight delta between two nodes is under a defined threshold._See {@link #THRESHOLD_SETTING} for defining the threshold.;private static boolean lessThan(float delta, float threshold) {_            _            return delta <= (threshold + 0.001f)__        };returns,code,true,iff,the,weight,delta,between,two,nodes,is,under,a,defined,threshold,see,link,for,defining,the,threshold;private,static,boolean,less,than,float,delta,float,threshold,return,delta,threshold,0,001f
BalancedShardsAllocator -> Balancer -> private static boolean lessThan(float delta, float threshold);1541092382;Returns {@code true} iff the weight delta between two nodes is under a defined threshold._See {@link #THRESHOLD_SETTING} for defining the threshold.;private static boolean lessThan(float delta, float threshold) {_            _            return delta <= (threshold + 0.001f)__        };returns,code,true,iff,the,weight,delta,between,two,nodes,is,under,a,defined,threshold,see,link,for,defining,the,threshold;private,static,boolean,less,than,float,delta,float,threshold,return,delta,threshold,0,001f
BalancedShardsAllocator -> Balancer -> private static boolean lessThan(float delta, float threshold);1541446827;Returns {@code true} iff the weight delta between two nodes is under a defined threshold._See {@link #THRESHOLD_SETTING} for defining the threshold.;private static boolean lessThan(float delta, float threshold) {_            _            return delta <= (threshold + 0.001f)__        };returns,code,true,iff,the,weight,delta,between,two,nodes,is,under,a,defined,threshold,see,link,for,defining,the,threshold;private,static,boolean,less,than,float,delta,float,threshold,return,delta,threshold,0,001f
BalancedShardsAllocator -> Balancer -> private static boolean lessThan(float delta, float threshold);1542402632;Returns {@code true} iff the weight delta between two nodes is under a defined threshold._See {@link #THRESHOLD_SETTING} for defining the threshold.;private static boolean lessThan(float delta, float threshold) {_            _            return delta <= (threshold + 0.001f)__        };returns,code,true,iff,the,weight,delta,between,two,nodes,is,under,a,defined,threshold,see,link,for,defining,the,threshold;private,static,boolean,less,than,float,delta,float,threshold,return,delta,threshold,0,001f
BalancedShardsAllocator -> Balancer -> private static boolean lessThan(float delta, float threshold);1549912434;Returns {@code true} iff the weight delta between two nodes is under a defined threshold._See {@link #THRESHOLD_SETTING} for defining the threshold.;private static boolean lessThan(float delta, float threshold) {_            _            return delta <= (threshold + 0.001f)__        };returns,code,true,iff,the,weight,delta,between,two,nodes,is,under,a,defined,threshold,see,link,for,defining,the,threshold;private,static,boolean,less,than,float,delta,float,threshold,return,delta,threshold,0,001f
BalancedShardsAllocator -> Balancer -> private void balanceByWeights();1524684173;Balances the nodes on the cluster model according to the weight_function. The configured threshold is the minimum delta between the_weight of the maximum node and the minimum node according to the_{@link WeightFunction}. This weight is calculated per index to_distribute shards evenly per index. The balancer tries to relocate_shards only if the delta exceeds the threshold. In the default case_the threshold is set to <tt>1.0</tt> to enforce gaining relocation_only, or in other words relocations that move the weight delta closer_to <tt>0.0</tt>;private void balanceByWeights() {_            final AllocationDeciders deciders = allocation.deciders()__            final ModelNode[] modelNodes = sorter.modelNodes__            final float[] weights = sorter.weights__            for (String index : buildWeightOrderedIndices()) {_                IndexMetaData indexMetaData = metaData.index(index)___                _                _                int relevantNodes = 0__                for (int i = 0_ i < modelNodes.length_ i++) {_                    ModelNode modelNode = modelNodes[i]__                    if (modelNode.getIndex(index) != null_                        || deciders.canAllocate(indexMetaData, modelNode.getRoutingNode(), allocation).type() != Type.NO) {_                        _                        modelNodes[i] = modelNodes[relevantNodes]__                        modelNodes[relevantNodes] = modelNode__                        relevantNodes++__                    }_                }__                if (relevantNodes < 2) {_                    continue__                }__                sorter.reset(index, 0, relevantNodes)__                int lowIdx = 0__                int highIdx = relevantNodes - 1__                while (true) {_                    final ModelNode minNode = modelNodes[lowIdx]__                    final ModelNode maxNode = modelNodes[highIdx]__                    advance_range:_                    if (maxNode.numShards(index) > 0) {_                        final float delta = absDelta(weights[lowIdx], weights[highIdx])__                        if (lessThan(delta, threshold)) {_                            if (lowIdx > 0 && highIdx-1 > 0 _                                && (absDelta(weights[0], weights[highIdx-1]) > threshold) _                                ) {_                                _                                break advance_range__                            }_                            if (logger.isTraceEnabled()) {_                                logger.trace("Stop balancing index [{}]  min_node [{}] weight: [{}]  max_node [{}] weight: [{}]  delta: [{}]",_                                        index, maxNode.getNodeId(), weights[highIdx], minNode.getNodeId(), weights[lowIdx], delta)__                            }_                            break__                        }_                        if (logger.isTraceEnabled()) {_                            logger.trace("Balancing from node [{}] weight: [{}] to node [{}] weight: [{}]  delta: [{}]",_                                    maxNode.getNodeId(), weights[highIdx], minNode.getNodeId(), weights[lowIdx], delta)__                        }_                        _                        if (tryRelocateShard(minNode, maxNode, index, delta)) {_                            _                            weights[lowIdx] = sorter.weight(modelNodes[lowIdx])__                            weights[highIdx] = sorter.weight(modelNodes[highIdx])__                            sorter.sort(0, relevantNodes)__                            lowIdx = 0__                            highIdx = relevantNodes - 1__                            continue__                        }_                    }_                    if (lowIdx < highIdx - 1) {_                        _                        lowIdx++__                    } else if (lowIdx > 0) {_                        _                        lowIdx = 0__                        highIdx--__                    } else {_                        _                        break__                    }_                }_            }_        };balances,the,nodes,on,the,cluster,model,according,to,the,weight,function,the,configured,threshold,is,the,minimum,delta,between,the,weight,of,the,maximum,node,and,the,minimum,node,according,to,the,link,weight,function,this,weight,is,calculated,per,index,to,distribute,shards,evenly,per,index,the,balancer,tries,to,relocate,shards,only,if,the,delta,exceeds,the,threshold,in,the,default,case,the,threshold,is,set,to,tt,1,0,tt,to,enforce,gaining,relocation,only,or,in,other,words,relocations,that,move,the,weight,delta,closer,to,tt,0,0,tt;private,void,balance,by,weights,final,allocation,deciders,deciders,allocation,deciders,final,model,node,model,nodes,sorter,model,nodes,final,float,weights,sorter,weights,for,string,index,build,weight,ordered,indices,index,meta,data,index,meta,data,meta,data,index,index,int,relevant,nodes,0,for,int,i,0,i,model,nodes,length,i,model,node,model,node,model,nodes,i,if,model,node,get,index,index,null,deciders,can,allocate,index,meta,data,model,node,get,routing,node,allocation,type,type,no,model,nodes,i,model,nodes,relevant,nodes,model,nodes,relevant,nodes,model,node,relevant,nodes,if,relevant,nodes,2,continue,sorter,reset,index,0,relevant,nodes,int,low,idx,0,int,high,idx,relevant,nodes,1,while,true,final,model,node,min,node,model,nodes,low,idx,final,model,node,max,node,model,nodes,high,idx,if,max,node,num,shards,index,0,final,float,delta,abs,delta,weights,low,idx,weights,high,idx,if,less,than,delta,threshold,if,low,idx,0,high,idx,1,0,abs,delta,weights,0,weights,high,idx,1,threshold,break,if,logger,is,trace,enabled,logger,trace,stop,balancing,index,weight,weight,delta,index,max,node,get,node,id,weights,high,idx,min,node,get,node,id,weights,low,idx,delta,break,if,logger,is,trace,enabled,logger,trace,balancing,from,node,weight,to,node,weight,delta,max,node,get,node,id,weights,high,idx,min,node,get,node,id,weights,low,idx,delta,if,try,relocate,shard,min,node,max,node,index,delta,weights,low,idx,sorter,weight,model,nodes,low,idx,weights,high,idx,sorter,weight,model,nodes,high,idx,sorter,sort,0,relevant,nodes,low,idx,0,high,idx,relevant,nodes,1,continue,if,low,idx,high,idx,1,low,idx,else,if,low,idx,0,low,idx,0,high,idx,else,break
BalancedShardsAllocator -> Balancer -> private void balanceByWeights();1525334055;Balances the nodes on the cluster model according to the weight_function. The configured threshold is the minimum delta between the_weight of the maximum node and the minimum node according to the_{@link WeightFunction}. This weight is calculated per index to_distribute shards evenly per index. The balancer tries to relocate_shards only if the delta exceeds the threshold. In the default case_the threshold is set to {@code 1.0} to enforce gaining relocation_only, or in other words relocations that move the weight delta closer_to {@code 0.0};private void balanceByWeights() {_            final AllocationDeciders deciders = allocation.deciders()__            final ModelNode[] modelNodes = sorter.modelNodes__            final float[] weights = sorter.weights__            for (String index : buildWeightOrderedIndices()) {_                IndexMetaData indexMetaData = metaData.index(index)___                _                _                int relevantNodes = 0__                for (int i = 0_ i < modelNodes.length_ i++) {_                    ModelNode modelNode = modelNodes[i]__                    if (modelNode.getIndex(index) != null_                        || deciders.canAllocate(indexMetaData, modelNode.getRoutingNode(), allocation).type() != Type.NO) {_                        _                        modelNodes[i] = modelNodes[relevantNodes]__                        modelNodes[relevantNodes] = modelNode__                        relevantNodes++__                    }_                }__                if (relevantNodes < 2) {_                    continue__                }__                sorter.reset(index, 0, relevantNodes)__                int lowIdx = 0__                int highIdx = relevantNodes - 1__                while (true) {_                    final ModelNode minNode = modelNodes[lowIdx]__                    final ModelNode maxNode = modelNodes[highIdx]__                    advance_range:_                    if (maxNode.numShards(index) > 0) {_                        final float delta = absDelta(weights[lowIdx], weights[highIdx])__                        if (lessThan(delta, threshold)) {_                            if (lowIdx > 0 && highIdx-1 > 0 _                                && (absDelta(weights[0], weights[highIdx-1]) > threshold) _                                ) {_                                _                                break advance_range__                            }_                            if (logger.isTraceEnabled()) {_                                logger.trace("Stop balancing index [{}]  min_node [{}] weight: [{}]  max_node [{}] weight: [{}]  delta: [{}]",_                                        index, maxNode.getNodeId(), weights[highIdx], minNode.getNodeId(), weights[lowIdx], delta)__                            }_                            break__                        }_                        if (logger.isTraceEnabled()) {_                            logger.trace("Balancing from node [{}] weight: [{}] to node [{}] weight: [{}]  delta: [{}]",_                                    maxNode.getNodeId(), weights[highIdx], minNode.getNodeId(), weights[lowIdx], delta)__                        }_                        _                        if (tryRelocateShard(minNode, maxNode, index, delta)) {_                            _                            weights[lowIdx] = sorter.weight(modelNodes[lowIdx])__                            weights[highIdx] = sorter.weight(modelNodes[highIdx])__                            sorter.sort(0, relevantNodes)__                            lowIdx = 0__                            highIdx = relevantNodes - 1__                            continue__                        }_                    }_                    if (lowIdx < highIdx - 1) {_                        _                        lowIdx++__                    } else if (lowIdx > 0) {_                        _                        lowIdx = 0__                        highIdx--__                    } else {_                        _                        break__                    }_                }_            }_        };balances,the,nodes,on,the,cluster,model,according,to,the,weight,function,the,configured,threshold,is,the,minimum,delta,between,the,weight,of,the,maximum,node,and,the,minimum,node,according,to,the,link,weight,function,this,weight,is,calculated,per,index,to,distribute,shards,evenly,per,index,the,balancer,tries,to,relocate,shards,only,if,the,delta,exceeds,the,threshold,in,the,default,case,the,threshold,is,set,to,code,1,0,to,enforce,gaining,relocation,only,or,in,other,words,relocations,that,move,the,weight,delta,closer,to,code,0,0;private,void,balance,by,weights,final,allocation,deciders,deciders,allocation,deciders,final,model,node,model,nodes,sorter,model,nodes,final,float,weights,sorter,weights,for,string,index,build,weight,ordered,indices,index,meta,data,index,meta,data,meta,data,index,index,int,relevant,nodes,0,for,int,i,0,i,model,nodes,length,i,model,node,model,node,model,nodes,i,if,model,node,get,index,index,null,deciders,can,allocate,index,meta,data,model,node,get,routing,node,allocation,type,type,no,model,nodes,i,model,nodes,relevant,nodes,model,nodes,relevant,nodes,model,node,relevant,nodes,if,relevant,nodes,2,continue,sorter,reset,index,0,relevant,nodes,int,low,idx,0,int,high,idx,relevant,nodes,1,while,true,final,model,node,min,node,model,nodes,low,idx,final,model,node,max,node,model,nodes,high,idx,if,max,node,num,shards,index,0,final,float,delta,abs,delta,weights,low,idx,weights,high,idx,if,less,than,delta,threshold,if,low,idx,0,high,idx,1,0,abs,delta,weights,0,weights,high,idx,1,threshold,break,if,logger,is,trace,enabled,logger,trace,stop,balancing,index,weight,weight,delta,index,max,node,get,node,id,weights,high,idx,min,node,get,node,id,weights,low,idx,delta,break,if,logger,is,trace,enabled,logger,trace,balancing,from,node,weight,to,node,weight,delta,max,node,get,node,id,weights,high,idx,min,node,get,node,id,weights,low,idx,delta,if,try,relocate,shard,min,node,max,node,index,delta,weights,low,idx,sorter,weight,model,nodes,low,idx,weights,high,idx,sorter,weight,model,nodes,high,idx,sorter,sort,0,relevant,nodes,low,idx,0,high,idx,relevant,nodes,1,continue,if,low,idx,high,idx,1,low,idx,else,if,low,idx,0,low,idx,0,high,idx,else,break
BalancedShardsAllocator -> Balancer -> private void balanceByWeights();1531234550;Balances the nodes on the cluster model according to the weight_function. The configured threshold is the minimum delta between the_weight of the maximum node and the minimum node according to the_{@link WeightFunction}. This weight is calculated per index to_distribute shards evenly per index. The balancer tries to relocate_shards only if the delta exceeds the threshold. In the default case_the threshold is set to {@code 1.0} to enforce gaining relocation_only, or in other words relocations that move the weight delta closer_to {@code 0.0};private void balanceByWeights() {_            final AllocationDeciders deciders = allocation.deciders()__            final ModelNode[] modelNodes = sorter.modelNodes__            final float[] weights = sorter.weights__            for (String index : buildWeightOrderedIndices()) {_                IndexMetaData indexMetaData = metaData.index(index)___                _                _                int relevantNodes = 0__                for (int i = 0_ i < modelNodes.length_ i++) {_                    ModelNode modelNode = modelNodes[i]__                    if (modelNode.getIndex(index) != null_                        || deciders.canAllocate(indexMetaData, modelNode.getRoutingNode(), allocation).type() != Type.NO) {_                        _                        modelNodes[i] = modelNodes[relevantNodes]__                        modelNodes[relevantNodes] = modelNode__                        relevantNodes++__                    }_                }__                if (relevantNodes < 2) {_                    continue__                }__                sorter.reset(index, 0, relevantNodes)__                int lowIdx = 0__                int highIdx = relevantNodes - 1__                while (true) {_                    final ModelNode minNode = modelNodes[lowIdx]__                    final ModelNode maxNode = modelNodes[highIdx]__                    advance_range:_                    if (maxNode.numShards(index) > 0) {_                        final float delta = absDelta(weights[lowIdx], weights[highIdx])__                        if (lessThan(delta, threshold)) {_                            if (lowIdx > 0 && highIdx-1 > 0 _                                && (absDelta(weights[0], weights[highIdx-1]) > threshold) _                                ) {_                                _                                break advance_range__                            }_                            if (logger.isTraceEnabled()) {_                                logger.trace("Stop balancing index [{}]  min_node [{}] weight: [{}]  max_node [{}] weight: [{}]  delta: [{}]",_                                        index, maxNode.getNodeId(), weights[highIdx], minNode.getNodeId(), weights[lowIdx], delta)__                            }_                            break__                        }_                        if (logger.isTraceEnabled()) {_                            logger.trace("Balancing from node [{}] weight: [{}] to node [{}] weight: [{}]  delta: [{}]",_                                    maxNode.getNodeId(), weights[highIdx], minNode.getNodeId(), weights[lowIdx], delta)__                        }_                        _                        if (tryRelocateShard(minNode, maxNode, index, delta)) {_                            _                            weights[lowIdx] = sorter.weight(modelNodes[lowIdx])__                            weights[highIdx] = sorter.weight(modelNodes[highIdx])__                            sorter.sort(0, relevantNodes)__                            lowIdx = 0__                            highIdx = relevantNodes - 1__                            continue__                        }_                    }_                    if (lowIdx < highIdx - 1) {_                        _                        lowIdx++__                    } else if (lowIdx > 0) {_                        _                        lowIdx = 0__                        highIdx--__                    } else {_                        _                        break__                    }_                }_            }_        };balances,the,nodes,on,the,cluster,model,according,to,the,weight,function,the,configured,threshold,is,the,minimum,delta,between,the,weight,of,the,maximum,node,and,the,minimum,node,according,to,the,link,weight,function,this,weight,is,calculated,per,index,to,distribute,shards,evenly,per,index,the,balancer,tries,to,relocate,shards,only,if,the,delta,exceeds,the,threshold,in,the,default,case,the,threshold,is,set,to,code,1,0,to,enforce,gaining,relocation,only,or,in,other,words,relocations,that,move,the,weight,delta,closer,to,code,0,0;private,void,balance,by,weights,final,allocation,deciders,deciders,allocation,deciders,final,model,node,model,nodes,sorter,model,nodes,final,float,weights,sorter,weights,for,string,index,build,weight,ordered,indices,index,meta,data,index,meta,data,meta,data,index,index,int,relevant,nodes,0,for,int,i,0,i,model,nodes,length,i,model,node,model,node,model,nodes,i,if,model,node,get,index,index,null,deciders,can,allocate,index,meta,data,model,node,get,routing,node,allocation,type,type,no,model,nodes,i,model,nodes,relevant,nodes,model,nodes,relevant,nodes,model,node,relevant,nodes,if,relevant,nodes,2,continue,sorter,reset,index,0,relevant,nodes,int,low,idx,0,int,high,idx,relevant,nodes,1,while,true,final,model,node,min,node,model,nodes,low,idx,final,model,node,max,node,model,nodes,high,idx,if,max,node,num,shards,index,0,final,float,delta,abs,delta,weights,low,idx,weights,high,idx,if,less,than,delta,threshold,if,low,idx,0,high,idx,1,0,abs,delta,weights,0,weights,high,idx,1,threshold,break,if,logger,is,trace,enabled,logger,trace,stop,balancing,index,weight,weight,delta,index,max,node,get,node,id,weights,high,idx,min,node,get,node,id,weights,low,idx,delta,break,if,logger,is,trace,enabled,logger,trace,balancing,from,node,weight,to,node,weight,delta,max,node,get,node,id,weights,high,idx,min,node,get,node,id,weights,low,idx,delta,if,try,relocate,shard,min,node,max,node,index,delta,weights,low,idx,sorter,weight,model,nodes,low,idx,weights,high,idx,sorter,weight,model,nodes,high,idx,sorter,sort,0,relevant,nodes,low,idx,0,high,idx,relevant,nodes,1,continue,if,low,idx,high,idx,1,low,idx,else,if,low,idx,0,low,idx,0,high,idx,else,break
BalancedShardsAllocator -> Balancer -> private void balanceByWeights();1540847035;Balances the nodes on the cluster model according to the weight_function. The configured threshold is the minimum delta between the_weight of the maximum node and the minimum node according to the_{@link WeightFunction}. This weight is calculated per index to_distribute shards evenly per index. The balancer tries to relocate_shards only if the delta exceeds the threshold. In the default case_the threshold is set to {@code 1.0} to enforce gaining relocation_only, or in other words relocations that move the weight delta closer_to {@code 0.0};private void balanceByWeights() {_            final AllocationDeciders deciders = allocation.deciders()__            final ModelNode[] modelNodes = sorter.modelNodes__            final float[] weights = sorter.weights__            for (String index : buildWeightOrderedIndices()) {_                IndexMetaData indexMetaData = metaData.index(index)___                _                _                int relevantNodes = 0__                for (int i = 0_ i < modelNodes.length_ i++) {_                    ModelNode modelNode = modelNodes[i]__                    if (modelNode.getIndex(index) != null_                        || deciders.canAllocate(indexMetaData, modelNode.getRoutingNode(), allocation).type() != Type.NO) {_                        _                        modelNodes[i] = modelNodes[relevantNodes]__                        modelNodes[relevantNodes] = modelNode__                        relevantNodes++__                    }_                }__                if (relevantNodes < 2) {_                    continue__                }__                sorter.reset(index, 0, relevantNodes)__                int lowIdx = 0__                int highIdx = relevantNodes - 1__                while (true) {_                    final ModelNode minNode = modelNodes[lowIdx]__                    final ModelNode maxNode = modelNodes[highIdx]__                    advance_range:_                    if (maxNode.numShards(index) > 0) {_                        final float delta = absDelta(weights[lowIdx], weights[highIdx])__                        if (lessThan(delta, threshold)) {_                            if (lowIdx > 0 && highIdx-1 > 0 _                                && (absDelta(weights[0], weights[highIdx-1]) > threshold) _                                ) {_                                _                                break advance_range__                            }_                            if (logger.isTraceEnabled()) {_                                logger.trace("Stop balancing index [{}]  min_node [{}] weight: [{}]" +_                                        "  max_node [{}] weight: [{}]  delta: [{}]",_                                        index, maxNode.getNodeId(), weights[highIdx], minNode.getNodeId(), weights[lowIdx], delta)__                            }_                            break__                        }_                        if (logger.isTraceEnabled()) {_                            logger.trace("Balancing from node [{}] weight: [{}] to node [{}] weight: [{}]  delta: [{}]",_                                    maxNode.getNodeId(), weights[highIdx], minNode.getNodeId(), weights[lowIdx], delta)__                        }_                        _                        if (tryRelocateShard(minNode, maxNode, index, delta)) {_                            _                            weights[lowIdx] = sorter.weight(modelNodes[lowIdx])__                            weights[highIdx] = sorter.weight(modelNodes[highIdx])__                            sorter.sort(0, relevantNodes)__                            lowIdx = 0__                            highIdx = relevantNodes - 1__                            continue__                        }_                    }_                    if (lowIdx < highIdx - 1) {_                        _                        lowIdx++__                    } else if (lowIdx > 0) {_                        _                        lowIdx = 0__                        highIdx--__                    } else {_                        _                        break__                    }_                }_            }_        };balances,the,nodes,on,the,cluster,model,according,to,the,weight,function,the,configured,threshold,is,the,minimum,delta,between,the,weight,of,the,maximum,node,and,the,minimum,node,according,to,the,link,weight,function,this,weight,is,calculated,per,index,to,distribute,shards,evenly,per,index,the,balancer,tries,to,relocate,shards,only,if,the,delta,exceeds,the,threshold,in,the,default,case,the,threshold,is,set,to,code,1,0,to,enforce,gaining,relocation,only,or,in,other,words,relocations,that,move,the,weight,delta,closer,to,code,0,0;private,void,balance,by,weights,final,allocation,deciders,deciders,allocation,deciders,final,model,node,model,nodes,sorter,model,nodes,final,float,weights,sorter,weights,for,string,index,build,weight,ordered,indices,index,meta,data,index,meta,data,meta,data,index,index,int,relevant,nodes,0,for,int,i,0,i,model,nodes,length,i,model,node,model,node,model,nodes,i,if,model,node,get,index,index,null,deciders,can,allocate,index,meta,data,model,node,get,routing,node,allocation,type,type,no,model,nodes,i,model,nodes,relevant,nodes,model,nodes,relevant,nodes,model,node,relevant,nodes,if,relevant,nodes,2,continue,sorter,reset,index,0,relevant,nodes,int,low,idx,0,int,high,idx,relevant,nodes,1,while,true,final,model,node,min,node,model,nodes,low,idx,final,model,node,max,node,model,nodes,high,idx,if,max,node,num,shards,index,0,final,float,delta,abs,delta,weights,low,idx,weights,high,idx,if,less,than,delta,threshold,if,low,idx,0,high,idx,1,0,abs,delta,weights,0,weights,high,idx,1,threshold,break,if,logger,is,trace,enabled,logger,trace,stop,balancing,index,weight,weight,delta,index,max,node,get,node,id,weights,high,idx,min,node,get,node,id,weights,low,idx,delta,break,if,logger,is,trace,enabled,logger,trace,balancing,from,node,weight,to,node,weight,delta,max,node,get,node,id,weights,high,idx,min,node,get,node,id,weights,low,idx,delta,if,try,relocate,shard,min,node,max,node,index,delta,weights,low,idx,sorter,weight,model,nodes,low,idx,weights,high,idx,sorter,weight,model,nodes,high,idx,sorter,sort,0,relevant,nodes,low,idx,0,high,idx,relevant,nodes,1,continue,if,low,idx,high,idx,1,low,idx,else,if,low,idx,0,low,idx,0,high,idx,else,break
BalancedShardsAllocator -> Balancer -> private void balanceByWeights();1541092382;Balances the nodes on the cluster model according to the weight_function. The configured threshold is the minimum delta between the_weight of the maximum node and the minimum node according to the_{@link WeightFunction}. This weight is calculated per index to_distribute shards evenly per index. The balancer tries to relocate_shards only if the delta exceeds the threshold. In the default case_the threshold is set to {@code 1.0} to enforce gaining relocation_only, or in other words relocations that move the weight delta closer_to {@code 0.0};private void balanceByWeights() {_            final AllocationDeciders deciders = allocation.deciders()__            final ModelNode[] modelNodes = sorter.modelNodes__            final float[] weights = sorter.weights__            for (String index : buildWeightOrderedIndices()) {_                IndexMetaData indexMetaData = metaData.index(index)___                _                _                int relevantNodes = 0__                for (int i = 0_ i < modelNodes.length_ i++) {_                    ModelNode modelNode = modelNodes[i]__                    if (modelNode.getIndex(index) != null_                        || deciders.canAllocate(indexMetaData, modelNode.getRoutingNode(), allocation).type() != Type.NO) {_                        _                        modelNodes[i] = modelNodes[relevantNodes]__                        modelNodes[relevantNodes] = modelNode__                        relevantNodes++__                    }_                }__                if (relevantNodes < 2) {_                    continue__                }__                sorter.reset(index, 0, relevantNodes)__                int lowIdx = 0__                int highIdx = relevantNodes - 1__                while (true) {_                    final ModelNode minNode = modelNodes[lowIdx]__                    final ModelNode maxNode = modelNodes[highIdx]__                    advance_range:_                    if (maxNode.numShards(index) > 0) {_                        final float delta = absDelta(weights[lowIdx], weights[highIdx])__                        if (lessThan(delta, threshold)) {_                            if (lowIdx > 0 && highIdx-1 > 0 _                                && (absDelta(weights[0], weights[highIdx-1]) > threshold) _                                ) {_                                _                                break advance_range__                            }_                            if (logger.isTraceEnabled()) {_                                logger.trace("Stop balancing index [{}]  min_node [{}] weight: [{}]" +_                                        "  max_node [{}] weight: [{}]  delta: [{}]",_                                        index, maxNode.getNodeId(), weights[highIdx], minNode.getNodeId(), weights[lowIdx], delta)__                            }_                            break__                        }_                        if (logger.isTraceEnabled()) {_                            logger.trace("Balancing from node [{}] weight: [{}] to node [{}] weight: [{}]  delta: [{}]",_                                    maxNode.getNodeId(), weights[highIdx], minNode.getNodeId(), weights[lowIdx], delta)__                        }_                        _                        if (tryRelocateShard(minNode, maxNode, index, delta)) {_                            _                            weights[lowIdx] = sorter.weight(modelNodes[lowIdx])__                            weights[highIdx] = sorter.weight(modelNodes[highIdx])__                            sorter.sort(0, relevantNodes)__                            lowIdx = 0__                            highIdx = relevantNodes - 1__                            continue__                        }_                    }_                    if (lowIdx < highIdx - 1) {_                        _                        lowIdx++__                    } else if (lowIdx > 0) {_                        _                        lowIdx = 0__                        highIdx--__                    } else {_                        _                        break__                    }_                }_            }_        };balances,the,nodes,on,the,cluster,model,according,to,the,weight,function,the,configured,threshold,is,the,minimum,delta,between,the,weight,of,the,maximum,node,and,the,minimum,node,according,to,the,link,weight,function,this,weight,is,calculated,per,index,to,distribute,shards,evenly,per,index,the,balancer,tries,to,relocate,shards,only,if,the,delta,exceeds,the,threshold,in,the,default,case,the,threshold,is,set,to,code,1,0,to,enforce,gaining,relocation,only,or,in,other,words,relocations,that,move,the,weight,delta,closer,to,code,0,0;private,void,balance,by,weights,final,allocation,deciders,deciders,allocation,deciders,final,model,node,model,nodes,sorter,model,nodes,final,float,weights,sorter,weights,for,string,index,build,weight,ordered,indices,index,meta,data,index,meta,data,meta,data,index,index,int,relevant,nodes,0,for,int,i,0,i,model,nodes,length,i,model,node,model,node,model,nodes,i,if,model,node,get,index,index,null,deciders,can,allocate,index,meta,data,model,node,get,routing,node,allocation,type,type,no,model,nodes,i,model,nodes,relevant,nodes,model,nodes,relevant,nodes,model,node,relevant,nodes,if,relevant,nodes,2,continue,sorter,reset,index,0,relevant,nodes,int,low,idx,0,int,high,idx,relevant,nodes,1,while,true,final,model,node,min,node,model,nodes,low,idx,final,model,node,max,node,model,nodes,high,idx,if,max,node,num,shards,index,0,final,float,delta,abs,delta,weights,low,idx,weights,high,idx,if,less,than,delta,threshold,if,low,idx,0,high,idx,1,0,abs,delta,weights,0,weights,high,idx,1,threshold,break,if,logger,is,trace,enabled,logger,trace,stop,balancing,index,weight,weight,delta,index,max,node,get,node,id,weights,high,idx,min,node,get,node,id,weights,low,idx,delta,break,if,logger,is,trace,enabled,logger,trace,balancing,from,node,weight,to,node,weight,delta,max,node,get,node,id,weights,high,idx,min,node,get,node,id,weights,low,idx,delta,if,try,relocate,shard,min,node,max,node,index,delta,weights,low,idx,sorter,weight,model,nodes,low,idx,weights,high,idx,sorter,weight,model,nodes,high,idx,sorter,sort,0,relevant,nodes,low,idx,0,high,idx,relevant,nodes,1,continue,if,low,idx,high,idx,1,low,idx,else,if,low,idx,0,low,idx,0,high,idx,else,break
BalancedShardsAllocator -> Balancer -> private void balanceByWeights();1541446827;Balances the nodes on the cluster model according to the weight_function. The configured threshold is the minimum delta between the_weight of the maximum node and the minimum node according to the_{@link WeightFunction}. This weight is calculated per index to_distribute shards evenly per index. The balancer tries to relocate_shards only if the delta exceeds the threshold. In the default case_the threshold is set to {@code 1.0} to enforce gaining relocation_only, or in other words relocations that move the weight delta closer_to {@code 0.0};private void balanceByWeights() {_            final AllocationDeciders deciders = allocation.deciders()__            final ModelNode[] modelNodes = sorter.modelNodes__            final float[] weights = sorter.weights__            for (String index : buildWeightOrderedIndices()) {_                IndexMetaData indexMetaData = metaData.index(index)___                _                _                int relevantNodes = 0__                for (int i = 0_ i < modelNodes.length_ i++) {_                    ModelNode modelNode = modelNodes[i]__                    if (modelNode.getIndex(index) != null_                        || deciders.canAllocate(indexMetaData, modelNode.getRoutingNode(), allocation).type() != Type.NO) {_                        _                        modelNodes[i] = modelNodes[relevantNodes]__                        modelNodes[relevantNodes] = modelNode__                        relevantNodes++__                    }_                }__                if (relevantNodes < 2) {_                    continue__                }__                sorter.reset(index, 0, relevantNodes)__                int lowIdx = 0__                int highIdx = relevantNodes - 1__                while (true) {_                    final ModelNode minNode = modelNodes[lowIdx]__                    final ModelNode maxNode = modelNodes[highIdx]__                    advance_range:_                    if (maxNode.numShards(index) > 0) {_                        final float delta = absDelta(weights[lowIdx], weights[highIdx])__                        if (lessThan(delta, threshold)) {_                            if (lowIdx > 0 && highIdx-1 > 0 _                                && (absDelta(weights[0], weights[highIdx-1]) > threshold) _                                ) {_                                _                                break advance_range__                            }_                            if (logger.isTraceEnabled()) {_                                logger.trace("Stop balancing index [{}]  min_node [{}] weight: [{}]" +_                                        "  max_node [{}] weight: [{}]  delta: [{}]",_                                        index, maxNode.getNodeId(), weights[highIdx], minNode.getNodeId(), weights[lowIdx], delta)__                            }_                            break__                        }_                        if (logger.isTraceEnabled()) {_                            logger.trace("Balancing from node [{}] weight: [{}] to node [{}] weight: [{}]  delta: [{}]",_                                    maxNode.getNodeId(), weights[highIdx], minNode.getNodeId(), weights[lowIdx], delta)__                        }_                        _                        if (tryRelocateShard(minNode, maxNode, index, delta)) {_                            _                            weights[lowIdx] = sorter.weight(modelNodes[lowIdx])__                            weights[highIdx] = sorter.weight(modelNodes[highIdx])__                            sorter.sort(0, relevantNodes)__                            lowIdx = 0__                            highIdx = relevantNodes - 1__                            continue__                        }_                    }_                    if (lowIdx < highIdx - 1) {_                        _                        lowIdx++__                    } else if (lowIdx > 0) {_                        _                        lowIdx = 0__                        highIdx--__                    } else {_                        _                        break__                    }_                }_            }_        };balances,the,nodes,on,the,cluster,model,according,to,the,weight,function,the,configured,threshold,is,the,minimum,delta,between,the,weight,of,the,maximum,node,and,the,minimum,node,according,to,the,link,weight,function,this,weight,is,calculated,per,index,to,distribute,shards,evenly,per,index,the,balancer,tries,to,relocate,shards,only,if,the,delta,exceeds,the,threshold,in,the,default,case,the,threshold,is,set,to,code,1,0,to,enforce,gaining,relocation,only,or,in,other,words,relocations,that,move,the,weight,delta,closer,to,code,0,0;private,void,balance,by,weights,final,allocation,deciders,deciders,allocation,deciders,final,model,node,model,nodes,sorter,model,nodes,final,float,weights,sorter,weights,for,string,index,build,weight,ordered,indices,index,meta,data,index,meta,data,meta,data,index,index,int,relevant,nodes,0,for,int,i,0,i,model,nodes,length,i,model,node,model,node,model,nodes,i,if,model,node,get,index,index,null,deciders,can,allocate,index,meta,data,model,node,get,routing,node,allocation,type,type,no,model,nodes,i,model,nodes,relevant,nodes,model,nodes,relevant,nodes,model,node,relevant,nodes,if,relevant,nodes,2,continue,sorter,reset,index,0,relevant,nodes,int,low,idx,0,int,high,idx,relevant,nodes,1,while,true,final,model,node,min,node,model,nodes,low,idx,final,model,node,max,node,model,nodes,high,idx,if,max,node,num,shards,index,0,final,float,delta,abs,delta,weights,low,idx,weights,high,idx,if,less,than,delta,threshold,if,low,idx,0,high,idx,1,0,abs,delta,weights,0,weights,high,idx,1,threshold,break,if,logger,is,trace,enabled,logger,trace,stop,balancing,index,weight,weight,delta,index,max,node,get,node,id,weights,high,idx,min,node,get,node,id,weights,low,idx,delta,break,if,logger,is,trace,enabled,logger,trace,balancing,from,node,weight,to,node,weight,delta,max,node,get,node,id,weights,high,idx,min,node,get,node,id,weights,low,idx,delta,if,try,relocate,shard,min,node,max,node,index,delta,weights,low,idx,sorter,weight,model,nodes,low,idx,weights,high,idx,sorter,weight,model,nodes,high,idx,sorter,sort,0,relevant,nodes,low,idx,0,high,idx,relevant,nodes,1,continue,if,low,idx,high,idx,1,low,idx,else,if,low,idx,0,low,idx,0,high,idx,else,break
BalancedShardsAllocator -> Balancer -> private void balanceByWeights();1542402632;Balances the nodes on the cluster model according to the weight_function. The configured threshold is the minimum delta between the_weight of the maximum node and the minimum node according to the_{@link WeightFunction}. This weight is calculated per index to_distribute shards evenly per index. The balancer tries to relocate_shards only if the delta exceeds the threshold. In the default case_the threshold is set to {@code 1.0} to enforce gaining relocation_only, or in other words relocations that move the weight delta closer_to {@code 0.0};private void balanceByWeights() {_            final AllocationDeciders deciders = allocation.deciders()__            final ModelNode[] modelNodes = sorter.modelNodes__            final float[] weights = sorter.weights__            for (String index : buildWeightOrderedIndices()) {_                IndexMetaData indexMetaData = metaData.index(index)___                _                _                int relevantNodes = 0__                for (int i = 0_ i < modelNodes.length_ i++) {_                    ModelNode modelNode = modelNodes[i]__                    if (modelNode.getIndex(index) != null_                        || deciders.canAllocate(indexMetaData, modelNode.getRoutingNode(), allocation).type() != Type.NO) {_                        _                        modelNodes[i] = modelNodes[relevantNodes]__                        modelNodes[relevantNodes] = modelNode__                        relevantNodes++__                    }_                }__                if (relevantNodes < 2) {_                    continue__                }__                sorter.reset(index, 0, relevantNodes)__                int lowIdx = 0__                int highIdx = relevantNodes - 1__                while (true) {_                    final ModelNode minNode = modelNodes[lowIdx]__                    final ModelNode maxNode = modelNodes[highIdx]__                    advance_range:_                    if (maxNode.numShards(index) > 0) {_                        final float delta = absDelta(weights[lowIdx], weights[highIdx])__                        if (lessThan(delta, threshold)) {_                            if (lowIdx > 0 && highIdx-1 > 0 _                                && (absDelta(weights[0], weights[highIdx-1]) > threshold) _                                ) {_                                _                                break advance_range__                            }_                            if (logger.isTraceEnabled()) {_                                logger.trace("Stop balancing index [{}]  min_node [{}] weight: [{}]" +_                                        "  max_node [{}] weight: [{}]  delta: [{}]",_                                        index, maxNode.getNodeId(), weights[highIdx], minNode.getNodeId(), weights[lowIdx], delta)__                            }_                            break__                        }_                        if (logger.isTraceEnabled()) {_                            logger.trace("Balancing from node [{}] weight: [{}] to node [{}] weight: [{}]  delta: [{}]",_                                    maxNode.getNodeId(), weights[highIdx], minNode.getNodeId(), weights[lowIdx], delta)__                        }_                        _                        if (tryRelocateShard(minNode, maxNode, index, delta)) {_                            _                            weights[lowIdx] = sorter.weight(modelNodes[lowIdx])__                            weights[highIdx] = sorter.weight(modelNodes[highIdx])__                            sorter.sort(0, relevantNodes)__                            lowIdx = 0__                            highIdx = relevantNodes - 1__                            continue__                        }_                    }_                    if (lowIdx < highIdx - 1) {_                        _                        lowIdx++__                    } else if (lowIdx > 0) {_                        _                        lowIdx = 0__                        highIdx--__                    } else {_                        _                        break__                    }_                }_            }_        };balances,the,nodes,on,the,cluster,model,according,to,the,weight,function,the,configured,threshold,is,the,minimum,delta,between,the,weight,of,the,maximum,node,and,the,minimum,node,according,to,the,link,weight,function,this,weight,is,calculated,per,index,to,distribute,shards,evenly,per,index,the,balancer,tries,to,relocate,shards,only,if,the,delta,exceeds,the,threshold,in,the,default,case,the,threshold,is,set,to,code,1,0,to,enforce,gaining,relocation,only,or,in,other,words,relocations,that,move,the,weight,delta,closer,to,code,0,0;private,void,balance,by,weights,final,allocation,deciders,deciders,allocation,deciders,final,model,node,model,nodes,sorter,model,nodes,final,float,weights,sorter,weights,for,string,index,build,weight,ordered,indices,index,meta,data,index,meta,data,meta,data,index,index,int,relevant,nodes,0,for,int,i,0,i,model,nodes,length,i,model,node,model,node,model,nodes,i,if,model,node,get,index,index,null,deciders,can,allocate,index,meta,data,model,node,get,routing,node,allocation,type,type,no,model,nodes,i,model,nodes,relevant,nodes,model,nodes,relevant,nodes,model,node,relevant,nodes,if,relevant,nodes,2,continue,sorter,reset,index,0,relevant,nodes,int,low,idx,0,int,high,idx,relevant,nodes,1,while,true,final,model,node,min,node,model,nodes,low,idx,final,model,node,max,node,model,nodes,high,idx,if,max,node,num,shards,index,0,final,float,delta,abs,delta,weights,low,idx,weights,high,idx,if,less,than,delta,threshold,if,low,idx,0,high,idx,1,0,abs,delta,weights,0,weights,high,idx,1,threshold,break,if,logger,is,trace,enabled,logger,trace,stop,balancing,index,weight,weight,delta,index,max,node,get,node,id,weights,high,idx,min,node,get,node,id,weights,low,idx,delta,break,if,logger,is,trace,enabled,logger,trace,balancing,from,node,weight,to,node,weight,delta,max,node,get,node,id,weights,high,idx,min,node,get,node,id,weights,low,idx,delta,if,try,relocate,shard,min,node,max,node,index,delta,weights,low,idx,sorter,weight,model,nodes,low,idx,weights,high,idx,sorter,weight,model,nodes,high,idx,sorter,sort,0,relevant,nodes,low,idx,0,high,idx,relevant,nodes,1,continue,if,low,idx,high,idx,1,low,idx,else,if,low,idx,0,low,idx,0,high,idx,else,break
BalancedShardsAllocator -> Balancer -> private void balanceByWeights();1549912434;Balances the nodes on the cluster model according to the weight_function. The configured threshold is the minimum delta between the_weight of the maximum node and the minimum node according to the_{@link WeightFunction}. This weight is calculated per index to_distribute shards evenly per index. The balancer tries to relocate_shards only if the delta exceeds the threshold. In the default case_the threshold is set to {@code 1.0} to enforce gaining relocation_only, or in other words relocations that move the weight delta closer_to {@code 0.0};private void balanceByWeights() {_            final AllocationDeciders deciders = allocation.deciders()__            final ModelNode[] modelNodes = sorter.modelNodes__            final float[] weights = sorter.weights__            for (String index : buildWeightOrderedIndices()) {_                IndexMetaData indexMetaData = metaData.index(index)___                _                _                int relevantNodes = 0__                for (int i = 0_ i < modelNodes.length_ i++) {_                    ModelNode modelNode = modelNodes[i]__                    if (modelNode.getIndex(index) != null_                        || deciders.canAllocate(indexMetaData, modelNode.getRoutingNode(), allocation).type() != Type.NO) {_                        _                        modelNodes[i] = modelNodes[relevantNodes]__                        modelNodes[relevantNodes] = modelNode__                        relevantNodes++__                    }_                }__                if (relevantNodes < 2) {_                    continue__                }__                sorter.reset(index, 0, relevantNodes)__                int lowIdx = 0__                int highIdx = relevantNodes - 1__                while (true) {_                    final ModelNode minNode = modelNodes[lowIdx]__                    final ModelNode maxNode = modelNodes[highIdx]__                    advance_range:_                    if (maxNode.numShards(index) > 0) {_                        final float delta = absDelta(weights[lowIdx], weights[highIdx])__                        if (lessThan(delta, threshold)) {_                            if (lowIdx > 0 && highIdx-1 > 0 _                                && (absDelta(weights[0], weights[highIdx-1]) > threshold) _                                ) {_                                _                                break advance_range__                            }_                            if (logger.isTraceEnabled()) {_                                logger.trace("Stop balancing index [{}]  min_node [{}] weight: [{}]" +_                                        "  max_node [{}] weight: [{}]  delta: [{}]",_                                        index, maxNode.getNodeId(), weights[highIdx], minNode.getNodeId(), weights[lowIdx], delta)__                            }_                            break__                        }_                        if (logger.isTraceEnabled()) {_                            logger.trace("Balancing from node [{}] weight: [{}] to node [{}] weight: [{}]  delta: [{}]",_                                    maxNode.getNodeId(), weights[highIdx], minNode.getNodeId(), weights[lowIdx], delta)__                        }_                        _                        if (tryRelocateShard(minNode, maxNode, index, delta)) {_                            _                            weights[lowIdx] = sorter.weight(modelNodes[lowIdx])__                            weights[highIdx] = sorter.weight(modelNodes[highIdx])__                            sorter.sort(0, relevantNodes)__                            lowIdx = 0__                            highIdx = relevantNodes - 1__                            continue__                        }_                    }_                    if (lowIdx < highIdx - 1) {_                        _                        lowIdx++__                    } else if (lowIdx > 0) {_                        _                        lowIdx = 0__                        highIdx--__                    } else {_                        _                        break__                    }_                }_            }_        };balances,the,nodes,on,the,cluster,model,according,to,the,weight,function,the,configured,threshold,is,the,minimum,delta,between,the,weight,of,the,maximum,node,and,the,minimum,node,according,to,the,link,weight,function,this,weight,is,calculated,per,index,to,distribute,shards,evenly,per,index,the,balancer,tries,to,relocate,shards,only,if,the,delta,exceeds,the,threshold,in,the,default,case,the,threshold,is,set,to,code,1,0,to,enforce,gaining,relocation,only,or,in,other,words,relocations,that,move,the,weight,delta,closer,to,code,0,0;private,void,balance,by,weights,final,allocation,deciders,deciders,allocation,deciders,final,model,node,model,nodes,sorter,model,nodes,final,float,weights,sorter,weights,for,string,index,build,weight,ordered,indices,index,meta,data,index,meta,data,meta,data,index,index,int,relevant,nodes,0,for,int,i,0,i,model,nodes,length,i,model,node,model,node,model,nodes,i,if,model,node,get,index,index,null,deciders,can,allocate,index,meta,data,model,node,get,routing,node,allocation,type,type,no,model,nodes,i,model,nodes,relevant,nodes,model,nodes,relevant,nodes,model,node,relevant,nodes,if,relevant,nodes,2,continue,sorter,reset,index,0,relevant,nodes,int,low,idx,0,int,high,idx,relevant,nodes,1,while,true,final,model,node,min,node,model,nodes,low,idx,final,model,node,max,node,model,nodes,high,idx,if,max,node,num,shards,index,0,final,float,delta,abs,delta,weights,low,idx,weights,high,idx,if,less,than,delta,threshold,if,low,idx,0,high,idx,1,0,abs,delta,weights,0,weights,high,idx,1,threshold,break,if,logger,is,trace,enabled,logger,trace,stop,balancing,index,weight,weight,delta,index,max,node,get,node,id,weights,high,idx,min,node,get,node,id,weights,low,idx,delta,break,if,logger,is,trace,enabled,logger,trace,balancing,from,node,weight,to,node,weight,delta,max,node,get,node,id,weights,high,idx,min,node,get,node,id,weights,low,idx,delta,if,try,relocate,shard,min,node,max,node,index,delta,weights,low,idx,sorter,weight,model,nodes,low,idx,weights,high,idx,sorter,weight,model,nodes,high,idx,sorter,sort,0,relevant,nodes,low,idx,0,high,idx,relevant,nodes,1,continue,if,low,idx,high,idx,1,low,idx,else,if,low,idx,0,low,idx,0,high,idx,else,break
BalancedShardsAllocator -> Balancer -> private void allocateUnassigned();1524684173;Allocates all given shards on the minimal eligible node for the shards index_with respect to the weight function. All given shards must be unassigned.;private void allocateUnassigned() {_            RoutingNodes.UnassignedShards unassigned = routingNodes.unassigned()__            assert !nodes.isEmpty()__            if (logger.isTraceEnabled()) {_                logger.trace("Start allocating unassigned shards")__            }_            if (unassigned.isEmpty()) {_                return__            }__            _            final AllocationDeciders deciders = allocation.deciders()__            final PriorityComparator secondaryComparator = PriorityComparator.getAllocationComparator(allocation)__            final Comparator<ShardRouting> comparator = (o1, o2) -> {_                if (o1.primary() ^ o2.primary()) {_                    return o1.primary() ? -1 : o2.primary() ? 1 : 0__                }_                final int indexCmp__                if ((indexCmp = o1.getIndexName().compareTo(o2.getIndexName())) == 0) {_                    return o1.getId() - o2.getId()__                }_                _                _                _                _                final int secondary = secondaryComparator.compare(o1, o2)__                return secondary == 0 ? indexCmp : secondary__            }__            _            ShardRouting[] primary = unassigned.drain()__            ShardRouting[] secondary = new ShardRouting[primary.length]__            int secondaryLength = 0__            int primaryLength = primary.length__            ArrayUtil.timSort(primary, comparator)__            final Set<ModelNode> throttledNodes = Collections.newSetFromMap(new IdentityHashMap<>())__            do {_                for (int i = 0_ i < primaryLength_ i++) {_                    ShardRouting shard = primary[i]__                    AllocateUnassignedDecision allocationDecision = decideAllocateUnassigned(shard, throttledNodes)__                    final String assignedNodeId = allocationDecision.getTargetNode() != null ?_                                                      allocationDecision.getTargetNode().getId() : null__                    final ModelNode minNode = assignedNodeId != null ? nodes.get(assignedNodeId) : null___                    if (allocationDecision.getAllocationDecision() == AllocationDecision.YES) {_                        if (logger.isTraceEnabled()) {_                            logger.trace("Assigned shard [{}] to [{}]", shard, minNode.getNodeId())__                        }__                        final long shardSize = DiskThresholdDecider.getExpectedShardSize(shard, allocation,_                            ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE)__                        shard = routingNodes.initializeShard(shard, minNode.getNodeId(), null, shardSize, allocation.changes())__                        minNode.addShard(shard)__                        if (!shard.primary()) {_                            _                            _                            while(i < primaryLength-1 && comparator.compare(primary[i], primary[i+1]) == 0) {_                                secondary[secondaryLength++] = primary[++i]__                            }_                        }_                    } else {_                        _                        if (logger.isTraceEnabled()) {_                            logger.trace("No eligible node found to assign shard [{}] allocation_status [{}]", shard,_                                allocationDecision.getAllocationStatus())__                        }__                        if (minNode != null) {_                            _                            assert allocationDecision.getAllocationStatus() == AllocationStatus.DECIDERS_THROTTLED__                            final long shardSize = DiskThresholdDecider.getExpectedShardSize(shard, allocation,_                                ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE)__                            minNode.addShard(shard.initialize(minNode.getNodeId(), null, shardSize))__                            final RoutingNode node = minNode.getRoutingNode()__                            final Decision.Type nodeLevelDecision = deciders.canAllocate(node, allocation).type()__                            if (nodeLevelDecision != Type.YES) {_                                if (logger.isTraceEnabled()) {_                                    logger.trace("Can not allocate on node [{}] remove from round decision [{}]", node,_                                        allocationDecision.getAllocationStatus())__                                }_                                assert nodeLevelDecision == Type.NO__                                throttledNodes.add(minNode)__                            }_                        } else {_                            if (logger.isTraceEnabled()) {_                                logger.trace("No Node found to assign shard [{}]", shard)__                            }_                        }__                        unassigned.ignoreShard(shard, allocationDecision.getAllocationStatus(), allocation.changes())__                        if (!shard.primary()) { _                            while(i < primaryLength-1 && comparator.compare(primary[i], primary[i+1]) == 0) {_                                unassigned.ignoreShard(primary[++i], allocationDecision.getAllocationStatus(), allocation.changes())__                            }_                        }_                    }_                }_                primaryLength = secondaryLength__                ShardRouting[] tmp = primary__                primary = secondary__                secondary = tmp__                secondaryLength = 0__            } while (primaryLength > 0)__            _        };allocates,all,given,shards,on,the,minimal,eligible,node,for,the,shards,index,with,respect,to,the,weight,function,all,given,shards,must,be,unassigned;private,void,allocate,unassigned,routing,nodes,unassigned,shards,unassigned,routing,nodes,unassigned,assert,nodes,is,empty,if,logger,is,trace,enabled,logger,trace,start,allocating,unassigned,shards,if,unassigned,is,empty,return,final,allocation,deciders,deciders,allocation,deciders,final,priority,comparator,secondary,comparator,priority,comparator,get,allocation,comparator,allocation,final,comparator,shard,routing,comparator,o1,o2,if,o1,primary,o2,primary,return,o1,primary,1,o2,primary,1,0,final,int,index,cmp,if,index,cmp,o1,get,index,name,compare,to,o2,get,index,name,0,return,o1,get,id,o2,get,id,final,int,secondary,secondary,comparator,compare,o1,o2,return,secondary,0,index,cmp,secondary,shard,routing,primary,unassigned,drain,shard,routing,secondary,new,shard,routing,primary,length,int,secondary,length,0,int,primary,length,primary,length,array,util,tim,sort,primary,comparator,final,set,model,node,throttled,nodes,collections,new,set,from,map,new,identity,hash,map,do,for,int,i,0,i,primary,length,i,shard,routing,shard,primary,i,allocate,unassigned,decision,allocation,decision,decide,allocate,unassigned,shard,throttled,nodes,final,string,assigned,node,id,allocation,decision,get,target,node,null,allocation,decision,get,target,node,get,id,null,final,model,node,min,node,assigned,node,id,null,nodes,get,assigned,node,id,null,if,allocation,decision,get,allocation,decision,allocation,decision,yes,if,logger,is,trace,enabled,logger,trace,assigned,shard,to,shard,min,node,get,node,id,final,long,shard,size,disk,threshold,decider,get,expected,shard,size,shard,allocation,shard,routing,shard,routing,nodes,initialize,shard,shard,min,node,get,node,id,null,shard,size,allocation,changes,min,node,add,shard,shard,if,shard,primary,while,i,primary,length,1,comparator,compare,primary,i,primary,i,1,0,secondary,secondary,length,primary,i,else,if,logger,is,trace,enabled,logger,trace,no,eligible,node,found,to,assign,shard,shard,allocation,decision,get,allocation,status,if,min,node,null,assert,allocation,decision,get,allocation,status,allocation,status,final,long,shard,size,disk,threshold,decider,get,expected,shard,size,shard,allocation,shard,routing,min,node,add,shard,shard,initialize,min,node,get,node,id,null,shard,size,final,routing,node,node,min,node,get,routing,node,final,decision,type,node,level,decision,deciders,can,allocate,node,allocation,type,if,node,level,decision,type,yes,if,logger,is,trace,enabled,logger,trace,can,not,allocate,on,node,remove,from,round,decision,node,allocation,decision,get,allocation,status,assert,node,level,decision,type,no,throttled,nodes,add,min,node,else,if,logger,is,trace,enabled,logger,trace,no,node,found,to,assign,shard,shard,unassigned,ignore,shard,shard,allocation,decision,get,allocation,status,allocation,changes,if,shard,primary,while,i,primary,length,1,comparator,compare,primary,i,primary,i,1,0,unassigned,ignore,shard,primary,i,allocation,decision,get,allocation,status,allocation,changes,primary,length,secondary,length,shard,routing,tmp,primary,primary,secondary,secondary,tmp,secondary,length,0,while,primary,length,0
BalancedShardsAllocator -> Balancer -> private void allocateUnassigned();1525334055;Allocates all given shards on the minimal eligible node for the shards index_with respect to the weight function. All given shards must be unassigned.;private void allocateUnassigned() {_            RoutingNodes.UnassignedShards unassigned = routingNodes.unassigned()__            assert !nodes.isEmpty()__            if (logger.isTraceEnabled()) {_                logger.trace("Start allocating unassigned shards")__            }_            if (unassigned.isEmpty()) {_                return__            }__            _            final AllocationDeciders deciders = allocation.deciders()__            final PriorityComparator secondaryComparator = PriorityComparator.getAllocationComparator(allocation)__            final Comparator<ShardRouting> comparator = (o1, o2) -> {_                if (o1.primary() ^ o2.primary()) {_                    return o1.primary() ? -1 : o2.primary() ? 1 : 0__                }_                final int indexCmp__                if ((indexCmp = o1.getIndexName().compareTo(o2.getIndexName())) == 0) {_                    return o1.getId() - o2.getId()__                }_                _                _                _                _                final int secondary = secondaryComparator.compare(o1, o2)__                return secondary == 0 ? indexCmp : secondary__            }__            _            ShardRouting[] primary = unassigned.drain()__            ShardRouting[] secondary = new ShardRouting[primary.length]__            int secondaryLength = 0__            int primaryLength = primary.length__            ArrayUtil.timSort(primary, comparator)__            final Set<ModelNode> throttledNodes = Collections.newSetFromMap(new IdentityHashMap<>())__            do {_                for (int i = 0_ i < primaryLength_ i++) {_                    ShardRouting shard = primary[i]__                    AllocateUnassignedDecision allocationDecision = decideAllocateUnassigned(shard, throttledNodes)__                    final String assignedNodeId = allocationDecision.getTargetNode() != null ?_                                                      allocationDecision.getTargetNode().getId() : null__                    final ModelNode minNode = assignedNodeId != null ? nodes.get(assignedNodeId) : null___                    if (allocationDecision.getAllocationDecision() == AllocationDecision.YES) {_                        if (logger.isTraceEnabled()) {_                            logger.trace("Assigned shard [{}] to [{}]", shard, minNode.getNodeId())__                        }__                        final long shardSize = DiskThresholdDecider.getExpectedShardSize(shard, allocation,_                            ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE)__                        shard = routingNodes.initializeShard(shard, minNode.getNodeId(), null, shardSize, allocation.changes())__                        minNode.addShard(shard)__                        if (!shard.primary()) {_                            _                            _                            while(i < primaryLength-1 && comparator.compare(primary[i], primary[i+1]) == 0) {_                                secondary[secondaryLength++] = primary[++i]__                            }_                        }_                    } else {_                        _                        if (logger.isTraceEnabled()) {_                            logger.trace("No eligible node found to assign shard [{}] allocation_status [{}]", shard,_                                allocationDecision.getAllocationStatus())__                        }__                        if (minNode != null) {_                            _                            assert allocationDecision.getAllocationStatus() == AllocationStatus.DECIDERS_THROTTLED__                            final long shardSize = DiskThresholdDecider.getExpectedShardSize(shard, allocation,_                                ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE)__                            minNode.addShard(shard.initialize(minNode.getNodeId(), null, shardSize))__                            final RoutingNode node = minNode.getRoutingNode()__                            final Decision.Type nodeLevelDecision = deciders.canAllocate(node, allocation).type()__                            if (nodeLevelDecision != Type.YES) {_                                if (logger.isTraceEnabled()) {_                                    logger.trace("Can not allocate on node [{}] remove from round decision [{}]", node,_                                        allocationDecision.getAllocationStatus())__                                }_                                assert nodeLevelDecision == Type.NO__                                throttledNodes.add(minNode)__                            }_                        } else {_                            if (logger.isTraceEnabled()) {_                                logger.trace("No Node found to assign shard [{}]", shard)__                            }_                        }__                        unassigned.ignoreShard(shard, allocationDecision.getAllocationStatus(), allocation.changes())__                        if (!shard.primary()) { _                            while(i < primaryLength-1 && comparator.compare(primary[i], primary[i+1]) == 0) {_                                unassigned.ignoreShard(primary[++i], allocationDecision.getAllocationStatus(), allocation.changes())__                            }_                        }_                    }_                }_                primaryLength = secondaryLength__                ShardRouting[] tmp = primary__                primary = secondary__                secondary = tmp__                secondaryLength = 0__            } while (primaryLength > 0)__            _        };allocates,all,given,shards,on,the,minimal,eligible,node,for,the,shards,index,with,respect,to,the,weight,function,all,given,shards,must,be,unassigned;private,void,allocate,unassigned,routing,nodes,unassigned,shards,unassigned,routing,nodes,unassigned,assert,nodes,is,empty,if,logger,is,trace,enabled,logger,trace,start,allocating,unassigned,shards,if,unassigned,is,empty,return,final,allocation,deciders,deciders,allocation,deciders,final,priority,comparator,secondary,comparator,priority,comparator,get,allocation,comparator,allocation,final,comparator,shard,routing,comparator,o1,o2,if,o1,primary,o2,primary,return,o1,primary,1,o2,primary,1,0,final,int,index,cmp,if,index,cmp,o1,get,index,name,compare,to,o2,get,index,name,0,return,o1,get,id,o2,get,id,final,int,secondary,secondary,comparator,compare,o1,o2,return,secondary,0,index,cmp,secondary,shard,routing,primary,unassigned,drain,shard,routing,secondary,new,shard,routing,primary,length,int,secondary,length,0,int,primary,length,primary,length,array,util,tim,sort,primary,comparator,final,set,model,node,throttled,nodes,collections,new,set,from,map,new,identity,hash,map,do,for,int,i,0,i,primary,length,i,shard,routing,shard,primary,i,allocate,unassigned,decision,allocation,decision,decide,allocate,unassigned,shard,throttled,nodes,final,string,assigned,node,id,allocation,decision,get,target,node,null,allocation,decision,get,target,node,get,id,null,final,model,node,min,node,assigned,node,id,null,nodes,get,assigned,node,id,null,if,allocation,decision,get,allocation,decision,allocation,decision,yes,if,logger,is,trace,enabled,logger,trace,assigned,shard,to,shard,min,node,get,node,id,final,long,shard,size,disk,threshold,decider,get,expected,shard,size,shard,allocation,shard,routing,shard,routing,nodes,initialize,shard,shard,min,node,get,node,id,null,shard,size,allocation,changes,min,node,add,shard,shard,if,shard,primary,while,i,primary,length,1,comparator,compare,primary,i,primary,i,1,0,secondary,secondary,length,primary,i,else,if,logger,is,trace,enabled,logger,trace,no,eligible,node,found,to,assign,shard,shard,allocation,decision,get,allocation,status,if,min,node,null,assert,allocation,decision,get,allocation,status,allocation,status,final,long,shard,size,disk,threshold,decider,get,expected,shard,size,shard,allocation,shard,routing,min,node,add,shard,shard,initialize,min,node,get,node,id,null,shard,size,final,routing,node,node,min,node,get,routing,node,final,decision,type,node,level,decision,deciders,can,allocate,node,allocation,type,if,node,level,decision,type,yes,if,logger,is,trace,enabled,logger,trace,can,not,allocate,on,node,remove,from,round,decision,node,allocation,decision,get,allocation,status,assert,node,level,decision,type,no,throttled,nodes,add,min,node,else,if,logger,is,trace,enabled,logger,trace,no,node,found,to,assign,shard,shard,unassigned,ignore,shard,shard,allocation,decision,get,allocation,status,allocation,changes,if,shard,primary,while,i,primary,length,1,comparator,compare,primary,i,primary,i,1,0,unassigned,ignore,shard,primary,i,allocation,decision,get,allocation,status,allocation,changes,primary,length,secondary,length,shard,routing,tmp,primary,primary,secondary,secondary,tmp,secondary,length,0,while,primary,length,0
BalancedShardsAllocator -> Balancer -> private void allocateUnassigned();1531234550;Allocates all given shards on the minimal eligible node for the shards index_with respect to the weight function. All given shards must be unassigned.;private void allocateUnassigned() {_            RoutingNodes.UnassignedShards unassigned = routingNodes.unassigned()__            assert !nodes.isEmpty()__            if (logger.isTraceEnabled()) {_                logger.trace("Start allocating unassigned shards")__            }_            if (unassigned.isEmpty()) {_                return__            }__            _            final AllocationDeciders deciders = allocation.deciders()__            final PriorityComparator secondaryComparator = PriorityComparator.getAllocationComparator(allocation)__            final Comparator<ShardRouting> comparator = (o1, o2) -> {_                if (o1.primary() ^ o2.primary()) {_                    return o1.primary() ? -1 : o2.primary() ? 1 : 0__                }_                final int indexCmp__                if ((indexCmp = o1.getIndexName().compareTo(o2.getIndexName())) == 0) {_                    return o1.getId() - o2.getId()__                }_                _                _                _                _                final int secondary = secondaryComparator.compare(o1, o2)__                return secondary == 0 ? indexCmp : secondary__            }__            _            ShardRouting[] primary = unassigned.drain()__            ShardRouting[] secondary = new ShardRouting[primary.length]__            int secondaryLength = 0__            int primaryLength = primary.length__            ArrayUtil.timSort(primary, comparator)__            final Set<ModelNode> throttledNodes = Collections.newSetFromMap(new IdentityHashMap<>())__            do {_                for (int i = 0_ i < primaryLength_ i++) {_                    ShardRouting shard = primary[i]__                    AllocateUnassignedDecision allocationDecision = decideAllocateUnassigned(shard, throttledNodes)__                    final String assignedNodeId = allocationDecision.getTargetNode() != null ?_                                                      allocationDecision.getTargetNode().getId() : null__                    final ModelNode minNode = assignedNodeId != null ? nodes.get(assignedNodeId) : null___                    if (allocationDecision.getAllocationDecision() == AllocationDecision.YES) {_                        if (logger.isTraceEnabled()) {_                            logger.trace("Assigned shard [{}] to [{}]", shard, minNode.getNodeId())__                        }__                        final long shardSize = DiskThresholdDecider.getExpectedShardSize(shard, allocation,_                            ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE)__                        shard = routingNodes.initializeShard(shard, minNode.getNodeId(), null, shardSize, allocation.changes())__                        minNode.addShard(shard)__                        if (!shard.primary()) {_                            _                            _                            while(i < primaryLength-1 && comparator.compare(primary[i], primary[i+1]) == 0) {_                                secondary[secondaryLength++] = primary[++i]__                            }_                        }_                    } else {_                        _                        if (logger.isTraceEnabled()) {_                            logger.trace("No eligible node found to assign shard [{}] allocation_status [{}]", shard,_                                allocationDecision.getAllocationStatus())__                        }__                        if (minNode != null) {_                            _                            assert allocationDecision.getAllocationStatus() == AllocationStatus.DECIDERS_THROTTLED__                            final long shardSize = DiskThresholdDecider.getExpectedShardSize(shard, allocation,_                                ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE)__                            minNode.addShard(shard.initialize(minNode.getNodeId(), null, shardSize))__                            final RoutingNode node = minNode.getRoutingNode()__                            final Decision.Type nodeLevelDecision = deciders.canAllocate(node, allocation).type()__                            if (nodeLevelDecision != Type.YES) {_                                if (logger.isTraceEnabled()) {_                                    logger.trace("Can not allocate on node [{}] remove from round decision [{}]", node,_                                        allocationDecision.getAllocationStatus())__                                }_                                assert nodeLevelDecision == Type.NO__                                throttledNodes.add(minNode)__                            }_                        } else {_                            if (logger.isTraceEnabled()) {_                                logger.trace("No Node found to assign shard [{}]", shard)__                            }_                        }__                        unassigned.ignoreShard(shard, allocationDecision.getAllocationStatus(), allocation.changes())__                        if (!shard.primary()) { _                            while(i < primaryLength-1 && comparator.compare(primary[i], primary[i+1]) == 0) {_                                unassigned.ignoreShard(primary[++i], allocationDecision.getAllocationStatus(), allocation.changes())__                            }_                        }_                    }_                }_                primaryLength = secondaryLength__                ShardRouting[] tmp = primary__                primary = secondary__                secondary = tmp__                secondaryLength = 0__            } while (primaryLength > 0)__            _        };allocates,all,given,shards,on,the,minimal,eligible,node,for,the,shards,index,with,respect,to,the,weight,function,all,given,shards,must,be,unassigned;private,void,allocate,unassigned,routing,nodes,unassigned,shards,unassigned,routing,nodes,unassigned,assert,nodes,is,empty,if,logger,is,trace,enabled,logger,trace,start,allocating,unassigned,shards,if,unassigned,is,empty,return,final,allocation,deciders,deciders,allocation,deciders,final,priority,comparator,secondary,comparator,priority,comparator,get,allocation,comparator,allocation,final,comparator,shard,routing,comparator,o1,o2,if,o1,primary,o2,primary,return,o1,primary,1,o2,primary,1,0,final,int,index,cmp,if,index,cmp,o1,get,index,name,compare,to,o2,get,index,name,0,return,o1,get,id,o2,get,id,final,int,secondary,secondary,comparator,compare,o1,o2,return,secondary,0,index,cmp,secondary,shard,routing,primary,unassigned,drain,shard,routing,secondary,new,shard,routing,primary,length,int,secondary,length,0,int,primary,length,primary,length,array,util,tim,sort,primary,comparator,final,set,model,node,throttled,nodes,collections,new,set,from,map,new,identity,hash,map,do,for,int,i,0,i,primary,length,i,shard,routing,shard,primary,i,allocate,unassigned,decision,allocation,decision,decide,allocate,unassigned,shard,throttled,nodes,final,string,assigned,node,id,allocation,decision,get,target,node,null,allocation,decision,get,target,node,get,id,null,final,model,node,min,node,assigned,node,id,null,nodes,get,assigned,node,id,null,if,allocation,decision,get,allocation,decision,allocation,decision,yes,if,logger,is,trace,enabled,logger,trace,assigned,shard,to,shard,min,node,get,node,id,final,long,shard,size,disk,threshold,decider,get,expected,shard,size,shard,allocation,shard,routing,shard,routing,nodes,initialize,shard,shard,min,node,get,node,id,null,shard,size,allocation,changes,min,node,add,shard,shard,if,shard,primary,while,i,primary,length,1,comparator,compare,primary,i,primary,i,1,0,secondary,secondary,length,primary,i,else,if,logger,is,trace,enabled,logger,trace,no,eligible,node,found,to,assign,shard,shard,allocation,decision,get,allocation,status,if,min,node,null,assert,allocation,decision,get,allocation,status,allocation,status,final,long,shard,size,disk,threshold,decider,get,expected,shard,size,shard,allocation,shard,routing,min,node,add,shard,shard,initialize,min,node,get,node,id,null,shard,size,final,routing,node,node,min,node,get,routing,node,final,decision,type,node,level,decision,deciders,can,allocate,node,allocation,type,if,node,level,decision,type,yes,if,logger,is,trace,enabled,logger,trace,can,not,allocate,on,node,remove,from,round,decision,node,allocation,decision,get,allocation,status,assert,node,level,decision,type,no,throttled,nodes,add,min,node,else,if,logger,is,trace,enabled,logger,trace,no,node,found,to,assign,shard,shard,unassigned,ignore,shard,shard,allocation,decision,get,allocation,status,allocation,changes,if,shard,primary,while,i,primary,length,1,comparator,compare,primary,i,primary,i,1,0,unassigned,ignore,shard,primary,i,allocation,decision,get,allocation,status,allocation,changes,primary,length,secondary,length,shard,routing,tmp,primary,primary,secondary,secondary,tmp,secondary,length,0,while,primary,length,0
BalancedShardsAllocator -> Balancer -> private void allocateUnassigned();1540847035;Allocates all given shards on the minimal eligible node for the shards index_with respect to the weight function. All given shards must be unassigned.;private void allocateUnassigned() {_            RoutingNodes.UnassignedShards unassigned = routingNodes.unassigned()__            assert !nodes.isEmpty()__            if (logger.isTraceEnabled()) {_                logger.trace("Start allocating unassigned shards")__            }_            if (unassigned.isEmpty()) {_                return__            }__            _            final AllocationDeciders deciders = allocation.deciders()__            final PriorityComparator secondaryComparator = PriorityComparator.getAllocationComparator(allocation)__            final Comparator<ShardRouting> comparator = (o1, o2) -> {_                if (o1.primary() ^ o2.primary()) {_                    return o1.primary() ? -1 : o2.primary() ? 1 : 0__                }_                final int indexCmp__                if ((indexCmp = o1.getIndexName().compareTo(o2.getIndexName())) == 0) {_                    return o1.getId() - o2.getId()__                }_                _                _                _                _                final int secondary = secondaryComparator.compare(o1, o2)__                return secondary == 0 ? indexCmp : secondary__            }__            _            ShardRouting[] primary = unassigned.drain()__            ShardRouting[] secondary = new ShardRouting[primary.length]__            int secondaryLength = 0__            int primaryLength = primary.length__            ArrayUtil.timSort(primary, comparator)__            final Set<ModelNode> throttledNodes = Collections.newSetFromMap(new IdentityHashMap<>())__            do {_                for (int i = 0_ i < primaryLength_ i++) {_                    ShardRouting shard = primary[i]__                    AllocateUnassignedDecision allocationDecision = decideAllocateUnassigned(shard, throttledNodes)__                    final String assignedNodeId = allocationDecision.getTargetNode() != null ?_                                                      allocationDecision.getTargetNode().getId() : null__                    final ModelNode minNode = assignedNodeId != null ? nodes.get(assignedNodeId) : null___                    if (allocationDecision.getAllocationDecision() == AllocationDecision.YES) {_                        if (logger.isTraceEnabled()) {_                            logger.trace("Assigned shard [{}] to [{}]", shard, minNode.getNodeId())__                        }__                        final long shardSize = DiskThresholdDecider.getExpectedShardSize(shard, allocation,_                            ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE)__                        shard = routingNodes.initializeShard(shard, minNode.getNodeId(), null, shardSize, allocation.changes())__                        minNode.addShard(shard)__                        if (!shard.primary()) {_                            _                            _                            while(i < primaryLength-1 && comparator.compare(primary[i], primary[i+1]) == 0) {_                                secondary[secondaryLength++] = primary[++i]__                            }_                        }_                    } else {_                        _                        if (logger.isTraceEnabled()) {_                            logger.trace("No eligible node found to assign shard [{}] allocation_status [{}]", shard,_                                allocationDecision.getAllocationStatus())__                        }__                        if (minNode != null) {_                            _                            assert allocationDecision.getAllocationStatus() == AllocationStatus.DECIDERS_THROTTLED__                            final long shardSize = DiskThresholdDecider.getExpectedShardSize(shard, allocation,_                                ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE)__                            minNode.addShard(shard.initialize(minNode.getNodeId(), null, shardSize))__                            final RoutingNode node = minNode.getRoutingNode()__                            final Decision.Type nodeLevelDecision = deciders.canAllocate(node, allocation).type()__                            if (nodeLevelDecision != Type.YES) {_                                if (logger.isTraceEnabled()) {_                                    logger.trace("Can not allocate on node [{}] remove from round decision [{}]", node,_                                        allocationDecision.getAllocationStatus())__                                }_                                assert nodeLevelDecision == Type.NO__                                throttledNodes.add(minNode)__                            }_                        } else {_                            if (logger.isTraceEnabled()) {_                                logger.trace("No Node found to assign shard [{}]", shard)__                            }_                        }__                        unassigned.ignoreShard(shard, allocationDecision.getAllocationStatus(), allocation.changes())__                        if (!shard.primary()) { _                            while(i < primaryLength-1 && comparator.compare(primary[i], primary[i+1]) == 0) {_                                unassigned.ignoreShard(primary[++i], allocationDecision.getAllocationStatus(), allocation.changes())__                            }_                        }_                    }_                }_                primaryLength = secondaryLength__                ShardRouting[] tmp = primary__                primary = secondary__                secondary = tmp__                secondaryLength = 0__            } while (primaryLength > 0)__            _        };allocates,all,given,shards,on,the,minimal,eligible,node,for,the,shards,index,with,respect,to,the,weight,function,all,given,shards,must,be,unassigned;private,void,allocate,unassigned,routing,nodes,unassigned,shards,unassigned,routing,nodes,unassigned,assert,nodes,is,empty,if,logger,is,trace,enabled,logger,trace,start,allocating,unassigned,shards,if,unassigned,is,empty,return,final,allocation,deciders,deciders,allocation,deciders,final,priority,comparator,secondary,comparator,priority,comparator,get,allocation,comparator,allocation,final,comparator,shard,routing,comparator,o1,o2,if,o1,primary,o2,primary,return,o1,primary,1,o2,primary,1,0,final,int,index,cmp,if,index,cmp,o1,get,index,name,compare,to,o2,get,index,name,0,return,o1,get,id,o2,get,id,final,int,secondary,secondary,comparator,compare,o1,o2,return,secondary,0,index,cmp,secondary,shard,routing,primary,unassigned,drain,shard,routing,secondary,new,shard,routing,primary,length,int,secondary,length,0,int,primary,length,primary,length,array,util,tim,sort,primary,comparator,final,set,model,node,throttled,nodes,collections,new,set,from,map,new,identity,hash,map,do,for,int,i,0,i,primary,length,i,shard,routing,shard,primary,i,allocate,unassigned,decision,allocation,decision,decide,allocate,unassigned,shard,throttled,nodes,final,string,assigned,node,id,allocation,decision,get,target,node,null,allocation,decision,get,target,node,get,id,null,final,model,node,min,node,assigned,node,id,null,nodes,get,assigned,node,id,null,if,allocation,decision,get,allocation,decision,allocation,decision,yes,if,logger,is,trace,enabled,logger,trace,assigned,shard,to,shard,min,node,get,node,id,final,long,shard,size,disk,threshold,decider,get,expected,shard,size,shard,allocation,shard,routing,shard,routing,nodes,initialize,shard,shard,min,node,get,node,id,null,shard,size,allocation,changes,min,node,add,shard,shard,if,shard,primary,while,i,primary,length,1,comparator,compare,primary,i,primary,i,1,0,secondary,secondary,length,primary,i,else,if,logger,is,trace,enabled,logger,trace,no,eligible,node,found,to,assign,shard,shard,allocation,decision,get,allocation,status,if,min,node,null,assert,allocation,decision,get,allocation,status,allocation,status,final,long,shard,size,disk,threshold,decider,get,expected,shard,size,shard,allocation,shard,routing,min,node,add,shard,shard,initialize,min,node,get,node,id,null,shard,size,final,routing,node,node,min,node,get,routing,node,final,decision,type,node,level,decision,deciders,can,allocate,node,allocation,type,if,node,level,decision,type,yes,if,logger,is,trace,enabled,logger,trace,can,not,allocate,on,node,remove,from,round,decision,node,allocation,decision,get,allocation,status,assert,node,level,decision,type,no,throttled,nodes,add,min,node,else,if,logger,is,trace,enabled,logger,trace,no,node,found,to,assign,shard,shard,unassigned,ignore,shard,shard,allocation,decision,get,allocation,status,allocation,changes,if,shard,primary,while,i,primary,length,1,comparator,compare,primary,i,primary,i,1,0,unassigned,ignore,shard,primary,i,allocation,decision,get,allocation,status,allocation,changes,primary,length,secondary,length,shard,routing,tmp,primary,primary,secondary,secondary,tmp,secondary,length,0,while,primary,length,0
BalancedShardsAllocator -> Balancer -> private void allocateUnassigned();1541092382;Allocates all given shards on the minimal eligible node for the shards index_with respect to the weight function. All given shards must be unassigned.;private void allocateUnassigned() {_            RoutingNodes.UnassignedShards unassigned = routingNodes.unassigned()__            assert !nodes.isEmpty()__            if (logger.isTraceEnabled()) {_                logger.trace("Start allocating unassigned shards")__            }_            if (unassigned.isEmpty()) {_                return__            }__            _            final AllocationDeciders deciders = allocation.deciders()__            final PriorityComparator secondaryComparator = PriorityComparator.getAllocationComparator(allocation)__            final Comparator<ShardRouting> comparator = (o1, o2) -> {_                if (o1.primary() ^ o2.primary()) {_                    return o1.primary() ? -1 : o2.primary() ? 1 : 0__                }_                final int indexCmp__                if ((indexCmp = o1.getIndexName().compareTo(o2.getIndexName())) == 0) {_                    return o1.getId() - o2.getId()__                }_                _                _                _                _                final int secondary = secondaryComparator.compare(o1, o2)__                return secondary == 0 ? indexCmp : secondary__            }__            _            ShardRouting[] primary = unassigned.drain()__            ShardRouting[] secondary = new ShardRouting[primary.length]__            int secondaryLength = 0__            int primaryLength = primary.length__            ArrayUtil.timSort(primary, comparator)__            final Set<ModelNode> throttledNodes = Collections.newSetFromMap(new IdentityHashMap<>())__            do {_                for (int i = 0_ i < primaryLength_ i++) {_                    ShardRouting shard = primary[i]__                    AllocateUnassignedDecision allocationDecision = decideAllocateUnassigned(shard, throttledNodes)__                    final String assignedNodeId = allocationDecision.getTargetNode() != null ?_                                                      allocationDecision.getTargetNode().getId() : null__                    final ModelNode minNode = assignedNodeId != null ? nodes.get(assignedNodeId) : null___                    if (allocationDecision.getAllocationDecision() == AllocationDecision.YES) {_                        if (logger.isTraceEnabled()) {_                            logger.trace("Assigned shard [{}] to [{}]", shard, minNode.getNodeId())__                        }__                        final long shardSize = DiskThresholdDecider.getExpectedShardSize(shard, allocation,_                            ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE)__                        shard = routingNodes.initializeShard(shard, minNode.getNodeId(), null, shardSize, allocation.changes())__                        minNode.addShard(shard)__                        if (!shard.primary()) {_                            _                            _                            while(i < primaryLength-1 && comparator.compare(primary[i], primary[i+1]) == 0) {_                                secondary[secondaryLength++] = primary[++i]__                            }_                        }_                    } else {_                        _                        if (logger.isTraceEnabled()) {_                            logger.trace("No eligible node found to assign shard [{}] allocation_status [{}]", shard,_                                allocationDecision.getAllocationStatus())__                        }__                        if (minNode != null) {_                            _                            assert allocationDecision.getAllocationStatus() == AllocationStatus.DECIDERS_THROTTLED__                            final long shardSize = DiskThresholdDecider.getExpectedShardSize(shard, allocation,_                                ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE)__                            minNode.addShard(shard.initialize(minNode.getNodeId(), null, shardSize))__                            final RoutingNode node = minNode.getRoutingNode()__                            final Decision.Type nodeLevelDecision = deciders.canAllocate(node, allocation).type()__                            if (nodeLevelDecision != Type.YES) {_                                if (logger.isTraceEnabled()) {_                                    logger.trace("Can not allocate on node [{}] remove from round decision [{}]", node,_                                        allocationDecision.getAllocationStatus())__                                }_                                assert nodeLevelDecision == Type.NO__                                throttledNodes.add(minNode)__                            }_                        } else {_                            if (logger.isTraceEnabled()) {_                                logger.trace("No Node found to assign shard [{}]", shard)__                            }_                        }__                        unassigned.ignoreShard(shard, allocationDecision.getAllocationStatus(), allocation.changes())__                        if (!shard.primary()) { _                            while(i < primaryLength-1 && comparator.compare(primary[i], primary[i+1]) == 0) {_                                unassigned.ignoreShard(primary[++i], allocationDecision.getAllocationStatus(), allocation.changes())__                            }_                        }_                    }_                }_                primaryLength = secondaryLength__                ShardRouting[] tmp = primary__                primary = secondary__                secondary = tmp__                secondaryLength = 0__            } while (primaryLength > 0)__            _        };allocates,all,given,shards,on,the,minimal,eligible,node,for,the,shards,index,with,respect,to,the,weight,function,all,given,shards,must,be,unassigned;private,void,allocate,unassigned,routing,nodes,unassigned,shards,unassigned,routing,nodes,unassigned,assert,nodes,is,empty,if,logger,is,trace,enabled,logger,trace,start,allocating,unassigned,shards,if,unassigned,is,empty,return,final,allocation,deciders,deciders,allocation,deciders,final,priority,comparator,secondary,comparator,priority,comparator,get,allocation,comparator,allocation,final,comparator,shard,routing,comparator,o1,o2,if,o1,primary,o2,primary,return,o1,primary,1,o2,primary,1,0,final,int,index,cmp,if,index,cmp,o1,get,index,name,compare,to,o2,get,index,name,0,return,o1,get,id,o2,get,id,final,int,secondary,secondary,comparator,compare,o1,o2,return,secondary,0,index,cmp,secondary,shard,routing,primary,unassigned,drain,shard,routing,secondary,new,shard,routing,primary,length,int,secondary,length,0,int,primary,length,primary,length,array,util,tim,sort,primary,comparator,final,set,model,node,throttled,nodes,collections,new,set,from,map,new,identity,hash,map,do,for,int,i,0,i,primary,length,i,shard,routing,shard,primary,i,allocate,unassigned,decision,allocation,decision,decide,allocate,unassigned,shard,throttled,nodes,final,string,assigned,node,id,allocation,decision,get,target,node,null,allocation,decision,get,target,node,get,id,null,final,model,node,min,node,assigned,node,id,null,nodes,get,assigned,node,id,null,if,allocation,decision,get,allocation,decision,allocation,decision,yes,if,logger,is,trace,enabled,logger,trace,assigned,shard,to,shard,min,node,get,node,id,final,long,shard,size,disk,threshold,decider,get,expected,shard,size,shard,allocation,shard,routing,shard,routing,nodes,initialize,shard,shard,min,node,get,node,id,null,shard,size,allocation,changes,min,node,add,shard,shard,if,shard,primary,while,i,primary,length,1,comparator,compare,primary,i,primary,i,1,0,secondary,secondary,length,primary,i,else,if,logger,is,trace,enabled,logger,trace,no,eligible,node,found,to,assign,shard,shard,allocation,decision,get,allocation,status,if,min,node,null,assert,allocation,decision,get,allocation,status,allocation,status,final,long,shard,size,disk,threshold,decider,get,expected,shard,size,shard,allocation,shard,routing,min,node,add,shard,shard,initialize,min,node,get,node,id,null,shard,size,final,routing,node,node,min,node,get,routing,node,final,decision,type,node,level,decision,deciders,can,allocate,node,allocation,type,if,node,level,decision,type,yes,if,logger,is,trace,enabled,logger,trace,can,not,allocate,on,node,remove,from,round,decision,node,allocation,decision,get,allocation,status,assert,node,level,decision,type,no,throttled,nodes,add,min,node,else,if,logger,is,trace,enabled,logger,trace,no,node,found,to,assign,shard,shard,unassigned,ignore,shard,shard,allocation,decision,get,allocation,status,allocation,changes,if,shard,primary,while,i,primary,length,1,comparator,compare,primary,i,primary,i,1,0,unassigned,ignore,shard,primary,i,allocation,decision,get,allocation,status,allocation,changes,primary,length,secondary,length,shard,routing,tmp,primary,primary,secondary,secondary,tmp,secondary,length,0,while,primary,length,0
BalancedShardsAllocator -> Balancer -> private void allocateUnassigned();1541446827;Allocates all given shards on the minimal eligible node for the shards index_with respect to the weight function. All given shards must be unassigned.;private void allocateUnassigned() {_            RoutingNodes.UnassignedShards unassigned = routingNodes.unassigned()__            assert !nodes.isEmpty()__            if (logger.isTraceEnabled()) {_                logger.trace("Start allocating unassigned shards")__            }_            if (unassigned.isEmpty()) {_                return__            }__            _            final AllocationDeciders deciders = allocation.deciders()__            final PriorityComparator secondaryComparator = PriorityComparator.getAllocationComparator(allocation)__            final Comparator<ShardRouting> comparator = (o1, o2) -> {_                if (o1.primary() ^ o2.primary()) {_                    return o1.primary() ? -1 : o2.primary() ? 1 : 0__                }_                final int indexCmp__                if ((indexCmp = o1.getIndexName().compareTo(o2.getIndexName())) == 0) {_                    return o1.getId() - o2.getId()__                }_                _                _                _                _                final int secondary = secondaryComparator.compare(o1, o2)__                return secondary == 0 ? indexCmp : secondary__            }__            _            ShardRouting[] primary = unassigned.drain()__            ShardRouting[] secondary = new ShardRouting[primary.length]__            int secondaryLength = 0__            int primaryLength = primary.length__            ArrayUtil.timSort(primary, comparator)__            final Set<ModelNode> throttledNodes = Collections.newSetFromMap(new IdentityHashMap<>())__            do {_                for (int i = 0_ i < primaryLength_ i++) {_                    ShardRouting shard = primary[i]__                    AllocateUnassignedDecision allocationDecision = decideAllocateUnassigned(shard, throttledNodes)__                    final String assignedNodeId = allocationDecision.getTargetNode() != null ?_                                                      allocationDecision.getTargetNode().getId() : null__                    final ModelNode minNode = assignedNodeId != null ? nodes.get(assignedNodeId) : null___                    if (allocationDecision.getAllocationDecision() == AllocationDecision.YES) {_                        if (logger.isTraceEnabled()) {_                            logger.trace("Assigned shard [{}] to [{}]", shard, minNode.getNodeId())__                        }__                        final long shardSize = DiskThresholdDecider.getExpectedShardSize(shard, allocation,_                            ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE)__                        shard = routingNodes.initializeShard(shard, minNode.getNodeId(), null, shardSize, allocation.changes())__                        minNode.addShard(shard)__                        if (!shard.primary()) {_                            _                            _                            while(i < primaryLength-1 && comparator.compare(primary[i], primary[i+1]) == 0) {_                                secondary[secondaryLength++] = primary[++i]__                            }_                        }_                    } else {_                        _                        if (logger.isTraceEnabled()) {_                            logger.trace("No eligible node found to assign shard [{}] allocation_status [{}]", shard,_                                allocationDecision.getAllocationStatus())__                        }__                        if (minNode != null) {_                            _                            assert allocationDecision.getAllocationStatus() == AllocationStatus.DECIDERS_THROTTLED__                            final long shardSize = DiskThresholdDecider.getExpectedShardSize(shard, allocation,_                                ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE)__                            minNode.addShard(shard.initialize(minNode.getNodeId(), null, shardSize))__                            final RoutingNode node = minNode.getRoutingNode()__                            final Decision.Type nodeLevelDecision = deciders.canAllocate(node, allocation).type()__                            if (nodeLevelDecision != Type.YES) {_                                if (logger.isTraceEnabled()) {_                                    logger.trace("Can not allocate on node [{}] remove from round decision [{}]", node,_                                        allocationDecision.getAllocationStatus())__                                }_                                assert nodeLevelDecision == Type.NO__                                throttledNodes.add(minNode)__                            }_                        } else {_                            if (logger.isTraceEnabled()) {_                                logger.trace("No Node found to assign shard [{}]", shard)__                            }_                        }__                        unassigned.ignoreShard(shard, allocationDecision.getAllocationStatus(), allocation.changes())__                        if (!shard.primary()) { _                            while(i < primaryLength-1 && comparator.compare(primary[i], primary[i+1]) == 0) {_                                unassigned.ignoreShard(primary[++i], allocationDecision.getAllocationStatus(), allocation.changes())__                            }_                        }_                    }_                }_                primaryLength = secondaryLength__                ShardRouting[] tmp = primary__                primary = secondary__                secondary = tmp__                secondaryLength = 0__            } while (primaryLength > 0)__            _        };allocates,all,given,shards,on,the,minimal,eligible,node,for,the,shards,index,with,respect,to,the,weight,function,all,given,shards,must,be,unassigned;private,void,allocate,unassigned,routing,nodes,unassigned,shards,unassigned,routing,nodes,unassigned,assert,nodes,is,empty,if,logger,is,trace,enabled,logger,trace,start,allocating,unassigned,shards,if,unassigned,is,empty,return,final,allocation,deciders,deciders,allocation,deciders,final,priority,comparator,secondary,comparator,priority,comparator,get,allocation,comparator,allocation,final,comparator,shard,routing,comparator,o1,o2,if,o1,primary,o2,primary,return,o1,primary,1,o2,primary,1,0,final,int,index,cmp,if,index,cmp,o1,get,index,name,compare,to,o2,get,index,name,0,return,o1,get,id,o2,get,id,final,int,secondary,secondary,comparator,compare,o1,o2,return,secondary,0,index,cmp,secondary,shard,routing,primary,unassigned,drain,shard,routing,secondary,new,shard,routing,primary,length,int,secondary,length,0,int,primary,length,primary,length,array,util,tim,sort,primary,comparator,final,set,model,node,throttled,nodes,collections,new,set,from,map,new,identity,hash,map,do,for,int,i,0,i,primary,length,i,shard,routing,shard,primary,i,allocate,unassigned,decision,allocation,decision,decide,allocate,unassigned,shard,throttled,nodes,final,string,assigned,node,id,allocation,decision,get,target,node,null,allocation,decision,get,target,node,get,id,null,final,model,node,min,node,assigned,node,id,null,nodes,get,assigned,node,id,null,if,allocation,decision,get,allocation,decision,allocation,decision,yes,if,logger,is,trace,enabled,logger,trace,assigned,shard,to,shard,min,node,get,node,id,final,long,shard,size,disk,threshold,decider,get,expected,shard,size,shard,allocation,shard,routing,shard,routing,nodes,initialize,shard,shard,min,node,get,node,id,null,shard,size,allocation,changes,min,node,add,shard,shard,if,shard,primary,while,i,primary,length,1,comparator,compare,primary,i,primary,i,1,0,secondary,secondary,length,primary,i,else,if,logger,is,trace,enabled,logger,trace,no,eligible,node,found,to,assign,shard,shard,allocation,decision,get,allocation,status,if,min,node,null,assert,allocation,decision,get,allocation,status,allocation,status,final,long,shard,size,disk,threshold,decider,get,expected,shard,size,shard,allocation,shard,routing,min,node,add,shard,shard,initialize,min,node,get,node,id,null,shard,size,final,routing,node,node,min,node,get,routing,node,final,decision,type,node,level,decision,deciders,can,allocate,node,allocation,type,if,node,level,decision,type,yes,if,logger,is,trace,enabled,logger,trace,can,not,allocate,on,node,remove,from,round,decision,node,allocation,decision,get,allocation,status,assert,node,level,decision,type,no,throttled,nodes,add,min,node,else,if,logger,is,trace,enabled,logger,trace,no,node,found,to,assign,shard,shard,unassigned,ignore,shard,shard,allocation,decision,get,allocation,status,allocation,changes,if,shard,primary,while,i,primary,length,1,comparator,compare,primary,i,primary,i,1,0,unassigned,ignore,shard,primary,i,allocation,decision,get,allocation,status,allocation,changes,primary,length,secondary,length,shard,routing,tmp,primary,primary,secondary,secondary,tmp,secondary,length,0,while,primary,length,0
BalancedShardsAllocator -> Balancer -> private void allocateUnassigned();1542402632;Allocates all given shards on the minimal eligible node for the shards index_with respect to the weight function. All given shards must be unassigned.;private void allocateUnassigned() {_            RoutingNodes.UnassignedShards unassigned = routingNodes.unassigned()__            assert !nodes.isEmpty()__            if (logger.isTraceEnabled()) {_                logger.trace("Start allocating unassigned shards")__            }_            if (unassigned.isEmpty()) {_                return__            }__            _            final AllocationDeciders deciders = allocation.deciders()__            final PriorityComparator secondaryComparator = PriorityComparator.getAllocationComparator(allocation)__            final Comparator<ShardRouting> comparator = (o1, o2) -> {_                if (o1.primary() ^ o2.primary()) {_                    return o1.primary() ? -1 : o2.primary() ? 1 : 0__                }_                final int indexCmp__                if ((indexCmp = o1.getIndexName().compareTo(o2.getIndexName())) == 0) {_                    return o1.getId() - o2.getId()__                }_                _                _                _                _                final int secondary = secondaryComparator.compare(o1, o2)__                return secondary == 0 ? indexCmp : secondary__            }__            _            ShardRouting[] primary = unassigned.drain()__            ShardRouting[] secondary = new ShardRouting[primary.length]__            int secondaryLength = 0__            int primaryLength = primary.length__            ArrayUtil.timSort(primary, comparator)__            final Set<ModelNode> throttledNodes = Collections.newSetFromMap(new IdentityHashMap<>())__            do {_                for (int i = 0_ i < primaryLength_ i++) {_                    ShardRouting shard = primary[i]__                    AllocateUnassignedDecision allocationDecision = decideAllocateUnassigned(shard, throttledNodes)__                    final String assignedNodeId = allocationDecision.getTargetNode() != null ?_                                                      allocationDecision.getTargetNode().getId() : null__                    final ModelNode minNode = assignedNodeId != null ? nodes.get(assignedNodeId) : null___                    if (allocationDecision.getAllocationDecision() == AllocationDecision.YES) {_                        if (logger.isTraceEnabled()) {_                            logger.trace("Assigned shard [{}] to [{}]", shard, minNode.getNodeId())__                        }__                        final long shardSize = DiskThresholdDecider.getExpectedShardSize(shard, allocation,_                            ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE)__                        shard = routingNodes.initializeShard(shard, minNode.getNodeId(), null, shardSize, allocation.changes())__                        minNode.addShard(shard)__                        if (!shard.primary()) {_                            _                            _                            while(i < primaryLength-1 && comparator.compare(primary[i], primary[i+1]) == 0) {_                                secondary[secondaryLength++] = primary[++i]__                            }_                        }_                    } else {_                        _                        if (logger.isTraceEnabled()) {_                            logger.trace("No eligible node found to assign shard [{}] allocation_status [{}]", shard,_                                allocationDecision.getAllocationStatus())__                        }__                        if (minNode != null) {_                            _                            assert allocationDecision.getAllocationStatus() == AllocationStatus.DECIDERS_THROTTLED__                            final long shardSize = DiskThresholdDecider.getExpectedShardSize(shard, allocation,_                                ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE)__                            minNode.addShard(shard.initialize(minNode.getNodeId(), null, shardSize))__                            final RoutingNode node = minNode.getRoutingNode()__                            final Decision.Type nodeLevelDecision = deciders.canAllocate(node, allocation).type()__                            if (nodeLevelDecision != Type.YES) {_                                if (logger.isTraceEnabled()) {_                                    logger.trace("Can not allocate on node [{}] remove from round decision [{}]", node,_                                        allocationDecision.getAllocationStatus())__                                }_                                assert nodeLevelDecision == Type.NO__                                throttledNodes.add(minNode)__                            }_                        } else {_                            if (logger.isTraceEnabled()) {_                                logger.trace("No Node found to assign shard [{}]", shard)__                            }_                        }__                        unassigned.ignoreShard(shard, allocationDecision.getAllocationStatus(), allocation.changes())__                        if (!shard.primary()) { _                            while(i < primaryLength-1 && comparator.compare(primary[i], primary[i+1]) == 0) {_                                unassigned.ignoreShard(primary[++i], allocationDecision.getAllocationStatus(), allocation.changes())__                            }_                        }_                    }_                }_                primaryLength = secondaryLength__                ShardRouting[] tmp = primary__                primary = secondary__                secondary = tmp__                secondaryLength = 0__            } while (primaryLength > 0)__            _        };allocates,all,given,shards,on,the,minimal,eligible,node,for,the,shards,index,with,respect,to,the,weight,function,all,given,shards,must,be,unassigned;private,void,allocate,unassigned,routing,nodes,unassigned,shards,unassigned,routing,nodes,unassigned,assert,nodes,is,empty,if,logger,is,trace,enabled,logger,trace,start,allocating,unassigned,shards,if,unassigned,is,empty,return,final,allocation,deciders,deciders,allocation,deciders,final,priority,comparator,secondary,comparator,priority,comparator,get,allocation,comparator,allocation,final,comparator,shard,routing,comparator,o1,o2,if,o1,primary,o2,primary,return,o1,primary,1,o2,primary,1,0,final,int,index,cmp,if,index,cmp,o1,get,index,name,compare,to,o2,get,index,name,0,return,o1,get,id,o2,get,id,final,int,secondary,secondary,comparator,compare,o1,o2,return,secondary,0,index,cmp,secondary,shard,routing,primary,unassigned,drain,shard,routing,secondary,new,shard,routing,primary,length,int,secondary,length,0,int,primary,length,primary,length,array,util,tim,sort,primary,comparator,final,set,model,node,throttled,nodes,collections,new,set,from,map,new,identity,hash,map,do,for,int,i,0,i,primary,length,i,shard,routing,shard,primary,i,allocate,unassigned,decision,allocation,decision,decide,allocate,unassigned,shard,throttled,nodes,final,string,assigned,node,id,allocation,decision,get,target,node,null,allocation,decision,get,target,node,get,id,null,final,model,node,min,node,assigned,node,id,null,nodes,get,assigned,node,id,null,if,allocation,decision,get,allocation,decision,allocation,decision,yes,if,logger,is,trace,enabled,logger,trace,assigned,shard,to,shard,min,node,get,node,id,final,long,shard,size,disk,threshold,decider,get,expected,shard,size,shard,allocation,shard,routing,shard,routing,nodes,initialize,shard,shard,min,node,get,node,id,null,shard,size,allocation,changes,min,node,add,shard,shard,if,shard,primary,while,i,primary,length,1,comparator,compare,primary,i,primary,i,1,0,secondary,secondary,length,primary,i,else,if,logger,is,trace,enabled,logger,trace,no,eligible,node,found,to,assign,shard,shard,allocation,decision,get,allocation,status,if,min,node,null,assert,allocation,decision,get,allocation,status,allocation,status,final,long,shard,size,disk,threshold,decider,get,expected,shard,size,shard,allocation,shard,routing,min,node,add,shard,shard,initialize,min,node,get,node,id,null,shard,size,final,routing,node,node,min,node,get,routing,node,final,decision,type,node,level,decision,deciders,can,allocate,node,allocation,type,if,node,level,decision,type,yes,if,logger,is,trace,enabled,logger,trace,can,not,allocate,on,node,remove,from,round,decision,node,allocation,decision,get,allocation,status,assert,node,level,decision,type,no,throttled,nodes,add,min,node,else,if,logger,is,trace,enabled,logger,trace,no,node,found,to,assign,shard,shard,unassigned,ignore,shard,shard,allocation,decision,get,allocation,status,allocation,changes,if,shard,primary,while,i,primary,length,1,comparator,compare,primary,i,primary,i,1,0,unassigned,ignore,shard,primary,i,allocation,decision,get,allocation,status,allocation,changes,primary,length,secondary,length,shard,routing,tmp,primary,primary,secondary,secondary,tmp,secondary,length,0,while,primary,length,0
BalancedShardsAllocator -> Balancer -> private void allocateUnassigned();1549912434;Allocates all given shards on the minimal eligible node for the shards index_with respect to the weight function. All given shards must be unassigned.;private void allocateUnassigned() {_            RoutingNodes.UnassignedShards unassigned = routingNodes.unassigned()__            assert !nodes.isEmpty()__            if (logger.isTraceEnabled()) {_                logger.trace("Start allocating unassigned shards")__            }_            if (unassigned.isEmpty()) {_                return__            }__            _            final AllocationDeciders deciders = allocation.deciders()__            final PriorityComparator secondaryComparator = PriorityComparator.getAllocationComparator(allocation)__            final Comparator<ShardRouting> comparator = (o1, o2) -> {_                if (o1.primary() ^ o2.primary()) {_                    return o1.primary() ? -1 : 1__                }_                final int indexCmp__                if ((indexCmp = o1.getIndexName().compareTo(o2.getIndexName())) == 0) {_                    return o1.getId() - o2.getId()__                }_                _                _                _                _                final int secondary = secondaryComparator.compare(o1, o2)__                return secondary == 0 ? indexCmp : secondary__            }__            _            ShardRouting[] primary = unassigned.drain()__            ShardRouting[] secondary = new ShardRouting[primary.length]__            int secondaryLength = 0__            int primaryLength = primary.length__            ArrayUtil.timSort(primary, comparator)__            final Set<ModelNode> throttledNodes = Collections.newSetFromMap(new IdentityHashMap<>())__            do {_                for (int i = 0_ i < primaryLength_ i++) {_                    ShardRouting shard = primary[i]__                    AllocateUnassignedDecision allocationDecision = decideAllocateUnassigned(shard, throttledNodes)__                    final String assignedNodeId = allocationDecision.getTargetNode() != null ?_                                                      allocationDecision.getTargetNode().getId() : null__                    final ModelNode minNode = assignedNodeId != null ? nodes.get(assignedNodeId) : null___                    if (allocationDecision.getAllocationDecision() == AllocationDecision.YES) {_                        if (logger.isTraceEnabled()) {_                            logger.trace("Assigned shard [{}] to [{}]", shard, minNode.getNodeId())__                        }__                        final long shardSize = DiskThresholdDecider.getExpectedShardSize(shard, allocation,_                            ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE)__                        shard = routingNodes.initializeShard(shard, minNode.getNodeId(), null, shardSize, allocation.changes())__                        minNode.addShard(shard)__                        if (!shard.primary()) {_                            _                            _                            while(i < primaryLength-1 && comparator.compare(primary[i], primary[i+1]) == 0) {_                                secondary[secondaryLength++] = primary[++i]__                            }_                        }_                    } else {_                        _                        if (logger.isTraceEnabled()) {_                            logger.trace("No eligible node found to assign shard [{}] allocation_status [{}]", shard,_                                allocationDecision.getAllocationStatus())__                        }__                        if (minNode != null) {_                            _                            assert allocationDecision.getAllocationStatus() == AllocationStatus.DECIDERS_THROTTLED__                            final long shardSize = DiskThresholdDecider.getExpectedShardSize(shard, allocation,_                                ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE)__                            minNode.addShard(shard.initialize(minNode.getNodeId(), null, shardSize))__                            final RoutingNode node = minNode.getRoutingNode()__                            final Decision.Type nodeLevelDecision = deciders.canAllocate(node, allocation).type()__                            if (nodeLevelDecision != Type.YES) {_                                if (logger.isTraceEnabled()) {_                                    logger.trace("Can not allocate on node [{}] remove from round decision [{}]", node,_                                        allocationDecision.getAllocationStatus())__                                }_                                assert nodeLevelDecision == Type.NO__                                throttledNodes.add(minNode)__                            }_                        } else {_                            if (logger.isTraceEnabled()) {_                                logger.trace("No Node found to assign shard [{}]", shard)__                            }_                        }__                        unassigned.ignoreShard(shard, allocationDecision.getAllocationStatus(), allocation.changes())__                        if (!shard.primary()) { _                            while(i < primaryLength-1 && comparator.compare(primary[i], primary[i+1]) == 0) {_                                unassigned.ignoreShard(primary[++i], allocationDecision.getAllocationStatus(), allocation.changes())__                            }_                        }_                    }_                }_                primaryLength = secondaryLength__                ShardRouting[] tmp = primary__                primary = secondary__                secondary = tmp__                secondaryLength = 0__            } while (primaryLength > 0)__            _        };allocates,all,given,shards,on,the,minimal,eligible,node,for,the,shards,index,with,respect,to,the,weight,function,all,given,shards,must,be,unassigned;private,void,allocate,unassigned,routing,nodes,unassigned,shards,unassigned,routing,nodes,unassigned,assert,nodes,is,empty,if,logger,is,trace,enabled,logger,trace,start,allocating,unassigned,shards,if,unassigned,is,empty,return,final,allocation,deciders,deciders,allocation,deciders,final,priority,comparator,secondary,comparator,priority,comparator,get,allocation,comparator,allocation,final,comparator,shard,routing,comparator,o1,o2,if,o1,primary,o2,primary,return,o1,primary,1,1,final,int,index,cmp,if,index,cmp,o1,get,index,name,compare,to,o2,get,index,name,0,return,o1,get,id,o2,get,id,final,int,secondary,secondary,comparator,compare,o1,o2,return,secondary,0,index,cmp,secondary,shard,routing,primary,unassigned,drain,shard,routing,secondary,new,shard,routing,primary,length,int,secondary,length,0,int,primary,length,primary,length,array,util,tim,sort,primary,comparator,final,set,model,node,throttled,nodes,collections,new,set,from,map,new,identity,hash,map,do,for,int,i,0,i,primary,length,i,shard,routing,shard,primary,i,allocate,unassigned,decision,allocation,decision,decide,allocate,unassigned,shard,throttled,nodes,final,string,assigned,node,id,allocation,decision,get,target,node,null,allocation,decision,get,target,node,get,id,null,final,model,node,min,node,assigned,node,id,null,nodes,get,assigned,node,id,null,if,allocation,decision,get,allocation,decision,allocation,decision,yes,if,logger,is,trace,enabled,logger,trace,assigned,shard,to,shard,min,node,get,node,id,final,long,shard,size,disk,threshold,decider,get,expected,shard,size,shard,allocation,shard,routing,shard,routing,nodes,initialize,shard,shard,min,node,get,node,id,null,shard,size,allocation,changes,min,node,add,shard,shard,if,shard,primary,while,i,primary,length,1,comparator,compare,primary,i,primary,i,1,0,secondary,secondary,length,primary,i,else,if,logger,is,trace,enabled,logger,trace,no,eligible,node,found,to,assign,shard,shard,allocation,decision,get,allocation,status,if,min,node,null,assert,allocation,decision,get,allocation,status,allocation,status,final,long,shard,size,disk,threshold,decider,get,expected,shard,size,shard,allocation,shard,routing,min,node,add,shard,shard,initialize,min,node,get,node,id,null,shard,size,final,routing,node,node,min,node,get,routing,node,final,decision,type,node,level,decision,deciders,can,allocate,node,allocation,type,if,node,level,decision,type,yes,if,logger,is,trace,enabled,logger,trace,can,not,allocate,on,node,remove,from,round,decision,node,allocation,decision,get,allocation,status,assert,node,level,decision,type,no,throttled,nodes,add,min,node,else,if,logger,is,trace,enabled,logger,trace,no,node,found,to,assign,shard,shard,unassigned,ignore,shard,shard,allocation,decision,get,allocation,status,allocation,changes,if,shard,primary,while,i,primary,length,1,comparator,compare,primary,i,primary,i,1,0,unassigned,ignore,shard,primary,i,allocation,decision,get,allocation,status,allocation,changes,primary,length,secondary,length,shard,routing,tmp,primary,primary,secondary,secondary,tmp,secondary,length,0,while,primary,length,0
BalancedShardsAllocator -> Balancer -> private boolean tryRelocateShard(ModelNode minNode, ModelNode maxNode, String idx, float minCost);1524684173;Tries to find a relocation from the max node to the minimal node for an arbitrary shard of the given index on the_balance model. Iff this method returns a <code>true</code> the relocation has already been executed on the_simulation model as well as on the cluster.;private boolean tryRelocateShard(ModelNode minNode, ModelNode maxNode, String idx, float minCost) {_            final ModelIndex index = maxNode.getIndex(idx)__            Decision decision = null__            if (index != null) {_                if (logger.isTraceEnabled()) {_                    logger.trace("Try relocating shard for index index [{}] from node [{}] to node [{}]", idx, maxNode.getNodeId(),_                            minNode.getNodeId())__                }_                ShardRouting candidate = null__                final AllocationDeciders deciders = allocation.deciders()__                for (ShardRouting shard : index) {_                    if (shard.started()) {_                        _                        Decision allocationDecision = deciders.canAllocate(shard, minNode.getRoutingNode(), allocation)__                        Decision rebalanceDecision = deciders.canRebalance(shard, allocation)__                        if (((allocationDecision.type() == Type.YES) || (allocationDecision.type() == Type.THROTTLE))_                                && ((rebalanceDecision.type() == Type.YES) || (rebalanceDecision.type() == Type.THROTTLE))) {_                            if (maxNode.containsShard(shard)) {_                                _                                final float delta = weight.weightShardAdded(this, minNode, idx) - weight.weightShardRemoved(this, maxNode, idx)__                                if (delta < minCost ||_                                        (candidate != null && delta == minCost && candidate.id() > shard.id())) {_                                    _                                    minCost = delta__                                    candidate = shard__                                    decision = new Decision.Multi().add(allocationDecision).add(rebalanceDecision)__                                }_                            }_                        }_                    }_                }__                if (candidate != null) {_                    _                    maxNode.removeShard(candidate)__                    long shardSize = allocation.clusterInfo().getShardSize(candidate, ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE)___                    if (decision.type() == Type.YES) { _                        logger.debug("Relocate shard [{}] from node [{}] to node [{}]", candidate, maxNode.getNodeId(),_                                    minNode.getNodeId())__                        _                        minNode.addShard(routingNodes.relocateShard(candidate, minNode.getNodeId(), shardSize, allocation.changes()).v1())__                        return true__                    } else {_                        assert decision.type() == Type.THROTTLE__                        minNode.addShard(candidate.relocate(minNode.getNodeId(), shardSize))__                    }_                }_            }_            if (logger.isTraceEnabled()) {_                logger.trace("Couldn't find shard to relocate from node [{}] to node [{}] allocation decision [{}]", maxNode.getNodeId(),_                        minNode.getNodeId(), decision == null ? "NO" : decision.type().name())__            }_            return false__        };tries,to,find,a,relocation,from,the,max,node,to,the,minimal,node,for,an,arbitrary,shard,of,the,given,index,on,the,balance,model,iff,this,method,returns,a,code,true,code,the,relocation,has,already,been,executed,on,the,simulation,model,as,well,as,on,the,cluster;private,boolean,try,relocate,shard,model,node,min,node,model,node,max,node,string,idx,float,min,cost,final,model,index,index,max,node,get,index,idx,decision,decision,null,if,index,null,if,logger,is,trace,enabled,logger,trace,try,relocating,shard,for,index,index,from,node,to,node,idx,max,node,get,node,id,min,node,get,node,id,shard,routing,candidate,null,final,allocation,deciders,deciders,allocation,deciders,for,shard,routing,shard,index,if,shard,started,decision,allocation,decision,deciders,can,allocate,shard,min,node,get,routing,node,allocation,decision,rebalance,decision,deciders,can,rebalance,shard,allocation,if,allocation,decision,type,type,yes,allocation,decision,type,type,throttle,rebalance,decision,type,type,yes,rebalance,decision,type,type,throttle,if,max,node,contains,shard,shard,final,float,delta,weight,weight,shard,added,this,min,node,idx,weight,weight,shard,removed,this,max,node,idx,if,delta,min,cost,candidate,null,delta,min,cost,candidate,id,shard,id,min,cost,delta,candidate,shard,decision,new,decision,multi,add,allocation,decision,add,rebalance,decision,if,candidate,null,max,node,remove,shard,candidate,long,shard,size,allocation,cluster,info,get,shard,size,candidate,shard,routing,if,decision,type,type,yes,logger,debug,relocate,shard,from,node,to,node,candidate,max,node,get,node,id,min,node,get,node,id,min,node,add,shard,routing,nodes,relocate,shard,candidate,min,node,get,node,id,shard,size,allocation,changes,v1,return,true,else,assert,decision,type,type,throttle,min,node,add,shard,candidate,relocate,min,node,get,node,id,shard,size,if,logger,is,trace,enabled,logger,trace,couldn,t,find,shard,to,relocate,from,node,to,node,allocation,decision,max,node,get,node,id,min,node,get,node,id,decision,null,no,decision,type,name,return,false
BalancedShardsAllocator -> Balancer -> private boolean tryRelocateShard(ModelNode minNode, ModelNode maxNode, String idx, float minCost);1525334055;Tries to find a relocation from the max node to the minimal node for an arbitrary shard of the given index on the_balance model. Iff this method returns a <code>true</code> the relocation has already been executed on the_simulation model as well as on the cluster.;private boolean tryRelocateShard(ModelNode minNode, ModelNode maxNode, String idx, float minCost) {_            final ModelIndex index = maxNode.getIndex(idx)__            Decision decision = null__            if (index != null) {_                if (logger.isTraceEnabled()) {_                    logger.trace("Try relocating shard for index index [{}] from node [{}] to node [{}]", idx, maxNode.getNodeId(),_                            minNode.getNodeId())__                }_                ShardRouting candidate = null__                final AllocationDeciders deciders = allocation.deciders()__                for (ShardRouting shard : index) {_                    if (shard.started()) {_                        _                        Decision allocationDecision = deciders.canAllocate(shard, minNode.getRoutingNode(), allocation)__                        Decision rebalanceDecision = deciders.canRebalance(shard, allocation)__                        if (((allocationDecision.type() == Type.YES) || (allocationDecision.type() == Type.THROTTLE))_                                && ((rebalanceDecision.type() == Type.YES) || (rebalanceDecision.type() == Type.THROTTLE))) {_                            if (maxNode.containsShard(shard)) {_                                _                                final float delta = weight.weightShardAdded(this, minNode, idx) - weight.weightShardRemoved(this, maxNode, idx)__                                if (delta < minCost ||_                                        (candidate != null && delta == minCost && candidate.id() > shard.id())) {_                                    _                                    minCost = delta__                                    candidate = shard__                                    decision = new Decision.Multi().add(allocationDecision).add(rebalanceDecision)__                                }_                            }_                        }_                    }_                }__                if (candidate != null) {_                    _                    maxNode.removeShard(candidate)__                    long shardSize = allocation.clusterInfo().getShardSize(candidate, ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE)___                    if (decision.type() == Type.YES) { _                        logger.debug("Relocate shard [{}] from node [{}] to node [{}]", candidate, maxNode.getNodeId(),_                                    minNode.getNodeId())__                        _                        minNode.addShard(routingNodes.relocateShard(candidate, minNode.getNodeId(), shardSize, allocation.changes()).v1())__                        return true__                    } else {_                        assert decision.type() == Type.THROTTLE__                        minNode.addShard(candidate.relocate(minNode.getNodeId(), shardSize))__                    }_                }_            }_            if (logger.isTraceEnabled()) {_                logger.trace("Couldn't find shard to relocate from node [{}] to node [{}] allocation decision [{}]", maxNode.getNodeId(),_                        minNode.getNodeId(), decision == null ? "NO" : decision.type().name())__            }_            return false__        };tries,to,find,a,relocation,from,the,max,node,to,the,minimal,node,for,an,arbitrary,shard,of,the,given,index,on,the,balance,model,iff,this,method,returns,a,code,true,code,the,relocation,has,already,been,executed,on,the,simulation,model,as,well,as,on,the,cluster;private,boolean,try,relocate,shard,model,node,min,node,model,node,max,node,string,idx,float,min,cost,final,model,index,index,max,node,get,index,idx,decision,decision,null,if,index,null,if,logger,is,trace,enabled,logger,trace,try,relocating,shard,for,index,index,from,node,to,node,idx,max,node,get,node,id,min,node,get,node,id,shard,routing,candidate,null,final,allocation,deciders,deciders,allocation,deciders,for,shard,routing,shard,index,if,shard,started,decision,allocation,decision,deciders,can,allocate,shard,min,node,get,routing,node,allocation,decision,rebalance,decision,deciders,can,rebalance,shard,allocation,if,allocation,decision,type,type,yes,allocation,decision,type,type,throttle,rebalance,decision,type,type,yes,rebalance,decision,type,type,throttle,if,max,node,contains,shard,shard,final,float,delta,weight,weight,shard,added,this,min,node,idx,weight,weight,shard,removed,this,max,node,idx,if,delta,min,cost,candidate,null,delta,min,cost,candidate,id,shard,id,min,cost,delta,candidate,shard,decision,new,decision,multi,add,allocation,decision,add,rebalance,decision,if,candidate,null,max,node,remove,shard,candidate,long,shard,size,allocation,cluster,info,get,shard,size,candidate,shard,routing,if,decision,type,type,yes,logger,debug,relocate,shard,from,node,to,node,candidate,max,node,get,node,id,min,node,get,node,id,min,node,add,shard,routing,nodes,relocate,shard,candidate,min,node,get,node,id,shard,size,allocation,changes,v1,return,true,else,assert,decision,type,type,throttle,min,node,add,shard,candidate,relocate,min,node,get,node,id,shard,size,if,logger,is,trace,enabled,logger,trace,couldn,t,find,shard,to,relocate,from,node,to,node,allocation,decision,max,node,get,node,id,min,node,get,node,id,decision,null,no,decision,type,name,return,false
BalancedShardsAllocator -> Balancer -> private boolean tryRelocateShard(ModelNode minNode, ModelNode maxNode, String idx, float minCost);1531234550;Tries to find a relocation from the max node to the minimal node for an arbitrary shard of the given index on the_balance model. Iff this method returns a <code>true</code> the relocation has already been executed on the_simulation model as well as on the cluster.;private boolean tryRelocateShard(ModelNode minNode, ModelNode maxNode, String idx, float minCost) {_            final ModelIndex index = maxNode.getIndex(idx)__            Decision decision = null__            if (index != null) {_                if (logger.isTraceEnabled()) {_                    logger.trace("Try relocating shard for index index [{}] from node [{}] to node [{}]", idx, maxNode.getNodeId(),_                            minNode.getNodeId())__                }_                ShardRouting candidate = null__                final AllocationDeciders deciders = allocation.deciders()__                for (ShardRouting shard : index) {_                    if (shard.started()) {_                        _                        Decision allocationDecision = deciders.canAllocate(shard, minNode.getRoutingNode(), allocation)__                        Decision rebalanceDecision = deciders.canRebalance(shard, allocation)__                        if (((allocationDecision.type() == Type.YES) || (allocationDecision.type() == Type.THROTTLE))_                                && ((rebalanceDecision.type() == Type.YES) || (rebalanceDecision.type() == Type.THROTTLE))) {_                            if (maxNode.containsShard(shard)) {_                                _                                final float delta = weight.weightShardAdded(this, minNode, idx) - weight.weightShardRemoved(this, maxNode, idx)__                                if (delta < minCost ||_                                        (candidate != null && Float.compare(delta, minCost) == 0 && candidate.id() > shard.id())) {_                                    _                                    minCost = delta__                                    candidate = shard__                                    decision = new Decision.Multi().add(allocationDecision).add(rebalanceDecision)__                                }_                            }_                        }_                    }_                }__                if (candidate != null) {_                    _                    maxNode.removeShard(candidate)__                    long shardSize = allocation.clusterInfo().getShardSize(candidate, ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE)___                    if (decision.type() == Type.YES) { _                        logger.debug("Relocate shard [{}] from node [{}] to node [{}]", candidate, maxNode.getNodeId(),_                                    minNode.getNodeId())__                        _                        minNode.addShard(routingNodes.relocateShard(candidate, minNode.getNodeId(), shardSize, allocation.changes()).v1())__                        return true__                    } else {_                        assert decision.type() == Type.THROTTLE__                        minNode.addShard(candidate.relocate(minNode.getNodeId(), shardSize))__                    }_                }_            }_            if (logger.isTraceEnabled()) {_                logger.trace("Couldn't find shard to relocate from node [{}] to node [{}] allocation decision [{}]", maxNode.getNodeId(),_                        minNode.getNodeId(), decision == null ? "NO" : decision.type().name())__            }_            return false__        };tries,to,find,a,relocation,from,the,max,node,to,the,minimal,node,for,an,arbitrary,shard,of,the,given,index,on,the,balance,model,iff,this,method,returns,a,code,true,code,the,relocation,has,already,been,executed,on,the,simulation,model,as,well,as,on,the,cluster;private,boolean,try,relocate,shard,model,node,min,node,model,node,max,node,string,idx,float,min,cost,final,model,index,index,max,node,get,index,idx,decision,decision,null,if,index,null,if,logger,is,trace,enabled,logger,trace,try,relocating,shard,for,index,index,from,node,to,node,idx,max,node,get,node,id,min,node,get,node,id,shard,routing,candidate,null,final,allocation,deciders,deciders,allocation,deciders,for,shard,routing,shard,index,if,shard,started,decision,allocation,decision,deciders,can,allocate,shard,min,node,get,routing,node,allocation,decision,rebalance,decision,deciders,can,rebalance,shard,allocation,if,allocation,decision,type,type,yes,allocation,decision,type,type,throttle,rebalance,decision,type,type,yes,rebalance,decision,type,type,throttle,if,max,node,contains,shard,shard,final,float,delta,weight,weight,shard,added,this,min,node,idx,weight,weight,shard,removed,this,max,node,idx,if,delta,min,cost,candidate,null,float,compare,delta,min,cost,0,candidate,id,shard,id,min,cost,delta,candidate,shard,decision,new,decision,multi,add,allocation,decision,add,rebalance,decision,if,candidate,null,max,node,remove,shard,candidate,long,shard,size,allocation,cluster,info,get,shard,size,candidate,shard,routing,if,decision,type,type,yes,logger,debug,relocate,shard,from,node,to,node,candidate,max,node,get,node,id,min,node,get,node,id,min,node,add,shard,routing,nodes,relocate,shard,candidate,min,node,get,node,id,shard,size,allocation,changes,v1,return,true,else,assert,decision,type,type,throttle,min,node,add,shard,candidate,relocate,min,node,get,node,id,shard,size,if,logger,is,trace,enabled,logger,trace,couldn,t,find,shard,to,relocate,from,node,to,node,allocation,decision,max,node,get,node,id,min,node,get,node,id,decision,null,no,decision,type,name,return,false
BalancedShardsAllocator -> Balancer -> private boolean tryRelocateShard(ModelNode minNode, ModelNode maxNode, String idx, float minCost);1540847035;Tries to find a relocation from the max node to the minimal node for an arbitrary shard of the given index on the_balance model. Iff this method returns a <code>true</code> the relocation has already been executed on the_simulation model as well as on the cluster.;private boolean tryRelocateShard(ModelNode minNode, ModelNode maxNode, String idx, float minCost) {_            final ModelIndex index = maxNode.getIndex(idx)__            Decision decision = null__            if (index != null) {_                if (logger.isTraceEnabled()) {_                    logger.trace("Try relocating shard for index index [{}] from node [{}] to node [{}]", idx, maxNode.getNodeId(),_                            minNode.getNodeId())__                }_                ShardRouting candidate = null__                final AllocationDeciders deciders = allocation.deciders()__                for (ShardRouting shard : index) {_                    if (shard.started()) {_                        _                        Decision allocationDecision = deciders.canAllocate(shard, minNode.getRoutingNode(), allocation)__                        Decision rebalanceDecision = deciders.canRebalance(shard, allocation)__                        if (((allocationDecision.type() == Type.YES) || (allocationDecision.type() == Type.THROTTLE))_                                && ((rebalanceDecision.type() == Type.YES) || (rebalanceDecision.type() == Type.THROTTLE))) {_                            if (maxNode.containsShard(shard)) {_                                _                                final float delta = weight.weightShardAdded(_                                    this, minNode, idx) - weight.weightShardRemoved(this, maxNode, idx)__                                if (delta < minCost ||_                                        (candidate != null && Float.compare(delta, minCost) == 0 && candidate.id() > shard.id())) {_                                    _                                    minCost = delta__                                    candidate = shard__                                    decision = new Decision.Multi().add(allocationDecision).add(rebalanceDecision)__                                }_                            }_                        }_                    }_                }__                if (candidate != null) {_                    _                    maxNode.removeShard(candidate)__                    long shardSize = allocation.clusterInfo().getShardSize(candidate, ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE)___                    if (decision.type() == Type.YES) { _                        logger.debug("Relocate shard [{}] from node [{}] to node [{}]", candidate, maxNode.getNodeId(),_                                    minNode.getNodeId())__                        _                        minNode.addShard(routingNodes.relocateShard(candidate, minNode.getNodeId(), shardSize, allocation.changes()).v1())__                        return true__                    } else {_                        assert decision.type() == Type.THROTTLE__                        minNode.addShard(candidate.relocate(minNode.getNodeId(), shardSize))__                    }_                }_            }_            if (logger.isTraceEnabled()) {_                logger.trace("Couldn't find shard to relocate from node [{}] to node [{}] allocation decision [{}]",_                    maxNode.getNodeId(), minNode.getNodeId(), decision == null ? "NO" : decision.type().name())__            }_            return false__        };tries,to,find,a,relocation,from,the,max,node,to,the,minimal,node,for,an,arbitrary,shard,of,the,given,index,on,the,balance,model,iff,this,method,returns,a,code,true,code,the,relocation,has,already,been,executed,on,the,simulation,model,as,well,as,on,the,cluster;private,boolean,try,relocate,shard,model,node,min,node,model,node,max,node,string,idx,float,min,cost,final,model,index,index,max,node,get,index,idx,decision,decision,null,if,index,null,if,logger,is,trace,enabled,logger,trace,try,relocating,shard,for,index,index,from,node,to,node,idx,max,node,get,node,id,min,node,get,node,id,shard,routing,candidate,null,final,allocation,deciders,deciders,allocation,deciders,for,shard,routing,shard,index,if,shard,started,decision,allocation,decision,deciders,can,allocate,shard,min,node,get,routing,node,allocation,decision,rebalance,decision,deciders,can,rebalance,shard,allocation,if,allocation,decision,type,type,yes,allocation,decision,type,type,throttle,rebalance,decision,type,type,yes,rebalance,decision,type,type,throttle,if,max,node,contains,shard,shard,final,float,delta,weight,weight,shard,added,this,min,node,idx,weight,weight,shard,removed,this,max,node,idx,if,delta,min,cost,candidate,null,float,compare,delta,min,cost,0,candidate,id,shard,id,min,cost,delta,candidate,shard,decision,new,decision,multi,add,allocation,decision,add,rebalance,decision,if,candidate,null,max,node,remove,shard,candidate,long,shard,size,allocation,cluster,info,get,shard,size,candidate,shard,routing,if,decision,type,type,yes,logger,debug,relocate,shard,from,node,to,node,candidate,max,node,get,node,id,min,node,get,node,id,min,node,add,shard,routing,nodes,relocate,shard,candidate,min,node,get,node,id,shard,size,allocation,changes,v1,return,true,else,assert,decision,type,type,throttle,min,node,add,shard,candidate,relocate,min,node,get,node,id,shard,size,if,logger,is,trace,enabled,logger,trace,couldn,t,find,shard,to,relocate,from,node,to,node,allocation,decision,max,node,get,node,id,min,node,get,node,id,decision,null,no,decision,type,name,return,false
BalancedShardsAllocator -> Balancer -> private boolean tryRelocateShard(ModelNode minNode, ModelNode maxNode, String idx, float minCost);1541092382;Tries to find a relocation from the max node to the minimal node for an arbitrary shard of the given index on the_balance model. Iff this method returns a <code>true</code> the relocation has already been executed on the_simulation model as well as on the cluster.;private boolean tryRelocateShard(ModelNode minNode, ModelNode maxNode, String idx, float minCost) {_            final ModelIndex index = maxNode.getIndex(idx)__            Decision decision = null__            if (index != null) {_                if (logger.isTraceEnabled()) {_                    logger.trace("Try relocating shard for index index [{}] from node [{}] to node [{}]", idx, maxNode.getNodeId(),_                            minNode.getNodeId())__                }_                ShardRouting candidate = null__                final AllocationDeciders deciders = allocation.deciders()__                for (ShardRouting shard : index) {_                    if (shard.started()) {_                        _                        Decision allocationDecision = deciders.canAllocate(shard, minNode.getRoutingNode(), allocation)__                        Decision rebalanceDecision = deciders.canRebalance(shard, allocation)__                        if (((allocationDecision.type() == Type.YES) || (allocationDecision.type() == Type.THROTTLE))_                                && ((rebalanceDecision.type() == Type.YES) || (rebalanceDecision.type() == Type.THROTTLE))) {_                            if (maxNode.containsShard(shard)) {_                                _                                final float delta = weight.weightShardAdded(_                                    this, minNode, idx) - weight.weightShardRemoved(this, maxNode, idx)__                                if (delta < minCost ||_                                        (candidate != null && Float.compare(delta, minCost) == 0 && candidate.id() > shard.id())) {_                                    _                                    minCost = delta__                                    candidate = shard__                                    decision = new Decision.Multi().add(allocationDecision).add(rebalanceDecision)__                                }_                            }_                        }_                    }_                }__                if (candidate != null) {_                    _                    maxNode.removeShard(candidate)__                    long shardSize = allocation.clusterInfo().getShardSize(candidate, ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE)___                    if (decision.type() == Type.YES) { _                        logger.debug("Relocate shard [{}] from node [{}] to node [{}]", candidate, maxNode.getNodeId(),_                                    minNode.getNodeId())__                        _                        minNode.addShard(routingNodes.relocateShard(candidate, minNode.getNodeId(), shardSize, allocation.changes()).v1())__                        return true__                    } else {_                        assert decision.type() == Type.THROTTLE__                        minNode.addShard(candidate.relocate(minNode.getNodeId(), shardSize))__                    }_                }_            }_            if (logger.isTraceEnabled()) {_                logger.trace("Couldn't find shard to relocate from node [{}] to node [{}] allocation decision [{}]",_                    maxNode.getNodeId(), minNode.getNodeId(), decision == null ? "NO" : decision.type().name())__            }_            return false__        };tries,to,find,a,relocation,from,the,max,node,to,the,minimal,node,for,an,arbitrary,shard,of,the,given,index,on,the,balance,model,iff,this,method,returns,a,code,true,code,the,relocation,has,already,been,executed,on,the,simulation,model,as,well,as,on,the,cluster;private,boolean,try,relocate,shard,model,node,min,node,model,node,max,node,string,idx,float,min,cost,final,model,index,index,max,node,get,index,idx,decision,decision,null,if,index,null,if,logger,is,trace,enabled,logger,trace,try,relocating,shard,for,index,index,from,node,to,node,idx,max,node,get,node,id,min,node,get,node,id,shard,routing,candidate,null,final,allocation,deciders,deciders,allocation,deciders,for,shard,routing,shard,index,if,shard,started,decision,allocation,decision,deciders,can,allocate,shard,min,node,get,routing,node,allocation,decision,rebalance,decision,deciders,can,rebalance,shard,allocation,if,allocation,decision,type,type,yes,allocation,decision,type,type,throttle,rebalance,decision,type,type,yes,rebalance,decision,type,type,throttle,if,max,node,contains,shard,shard,final,float,delta,weight,weight,shard,added,this,min,node,idx,weight,weight,shard,removed,this,max,node,idx,if,delta,min,cost,candidate,null,float,compare,delta,min,cost,0,candidate,id,shard,id,min,cost,delta,candidate,shard,decision,new,decision,multi,add,allocation,decision,add,rebalance,decision,if,candidate,null,max,node,remove,shard,candidate,long,shard,size,allocation,cluster,info,get,shard,size,candidate,shard,routing,if,decision,type,type,yes,logger,debug,relocate,shard,from,node,to,node,candidate,max,node,get,node,id,min,node,get,node,id,min,node,add,shard,routing,nodes,relocate,shard,candidate,min,node,get,node,id,shard,size,allocation,changes,v1,return,true,else,assert,decision,type,type,throttle,min,node,add,shard,candidate,relocate,min,node,get,node,id,shard,size,if,logger,is,trace,enabled,logger,trace,couldn,t,find,shard,to,relocate,from,node,to,node,allocation,decision,max,node,get,node,id,min,node,get,node,id,decision,null,no,decision,type,name,return,false
BalancedShardsAllocator -> Balancer -> private boolean tryRelocateShard(ModelNode minNode, ModelNode maxNode, String idx, float minCost);1541446827;Tries to find a relocation from the max node to the minimal node for an arbitrary shard of the given index on the_balance model. Iff this method returns a <code>true</code> the relocation has already been executed on the_simulation model as well as on the cluster.;private boolean tryRelocateShard(ModelNode minNode, ModelNode maxNode, String idx, float minCost) {_            final ModelIndex index = maxNode.getIndex(idx)__            Decision decision = null__            if (index != null) {_                if (logger.isTraceEnabled()) {_                    logger.trace("Try relocating shard for index index [{}] from node [{}] to node [{}]", idx, maxNode.getNodeId(),_                            minNode.getNodeId())__                }_                ShardRouting candidate = null__                final AllocationDeciders deciders = allocation.deciders()__                for (ShardRouting shard : index) {_                    if (shard.started()) {_                        _                        Decision allocationDecision = deciders.canAllocate(shard, minNode.getRoutingNode(), allocation)__                        Decision rebalanceDecision = deciders.canRebalance(shard, allocation)__                        if (((allocationDecision.type() == Type.YES) || (allocationDecision.type() == Type.THROTTLE))_                                && ((rebalanceDecision.type() == Type.YES) || (rebalanceDecision.type() == Type.THROTTLE))) {_                            if (maxNode.containsShard(shard)) {_                                _                                final float delta = weight.weightShardAdded(_                                    this, minNode, idx) - weight.weightShardRemoved(this, maxNode, idx)__                                if (delta < minCost ||_                                        (candidate != null && Float.compare(delta, minCost) == 0 && candidate.id() > shard.id())) {_                                    _                                    minCost = delta__                                    candidate = shard__                                    decision = new Decision.Multi().add(allocationDecision).add(rebalanceDecision)__                                }_                            }_                        }_                    }_                }__                if (candidate != null) {_                    _                    maxNode.removeShard(candidate)__                    long shardSize = allocation.clusterInfo().getShardSize(candidate, ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE)___                    if (decision.type() == Type.YES) { _                        logger.debug("Relocate shard [{}] from node [{}] to node [{}]", candidate, maxNode.getNodeId(),_                                    minNode.getNodeId())__                        _                        minNode.addShard(routingNodes.relocateShard(candidate, minNode.getNodeId(), shardSize, allocation.changes()).v1())__                        return true__                    } else {_                        assert decision.type() == Type.THROTTLE__                        minNode.addShard(candidate.relocate(minNode.getNodeId(), shardSize))__                    }_                }_            }_            if (logger.isTraceEnabled()) {_                logger.trace("Couldn't find shard to relocate from node [{}] to node [{}] allocation decision [{}]",_                    maxNode.getNodeId(), minNode.getNodeId(), decision == null ? "NO" : decision.type().name())__            }_            return false__        };tries,to,find,a,relocation,from,the,max,node,to,the,minimal,node,for,an,arbitrary,shard,of,the,given,index,on,the,balance,model,iff,this,method,returns,a,code,true,code,the,relocation,has,already,been,executed,on,the,simulation,model,as,well,as,on,the,cluster;private,boolean,try,relocate,shard,model,node,min,node,model,node,max,node,string,idx,float,min,cost,final,model,index,index,max,node,get,index,idx,decision,decision,null,if,index,null,if,logger,is,trace,enabled,logger,trace,try,relocating,shard,for,index,index,from,node,to,node,idx,max,node,get,node,id,min,node,get,node,id,shard,routing,candidate,null,final,allocation,deciders,deciders,allocation,deciders,for,shard,routing,shard,index,if,shard,started,decision,allocation,decision,deciders,can,allocate,shard,min,node,get,routing,node,allocation,decision,rebalance,decision,deciders,can,rebalance,shard,allocation,if,allocation,decision,type,type,yes,allocation,decision,type,type,throttle,rebalance,decision,type,type,yes,rebalance,decision,type,type,throttle,if,max,node,contains,shard,shard,final,float,delta,weight,weight,shard,added,this,min,node,idx,weight,weight,shard,removed,this,max,node,idx,if,delta,min,cost,candidate,null,float,compare,delta,min,cost,0,candidate,id,shard,id,min,cost,delta,candidate,shard,decision,new,decision,multi,add,allocation,decision,add,rebalance,decision,if,candidate,null,max,node,remove,shard,candidate,long,shard,size,allocation,cluster,info,get,shard,size,candidate,shard,routing,if,decision,type,type,yes,logger,debug,relocate,shard,from,node,to,node,candidate,max,node,get,node,id,min,node,get,node,id,min,node,add,shard,routing,nodes,relocate,shard,candidate,min,node,get,node,id,shard,size,allocation,changes,v1,return,true,else,assert,decision,type,type,throttle,min,node,add,shard,candidate,relocate,min,node,get,node,id,shard,size,if,logger,is,trace,enabled,logger,trace,couldn,t,find,shard,to,relocate,from,node,to,node,allocation,decision,max,node,get,node,id,min,node,get,node,id,decision,null,no,decision,type,name,return,false
BalancedShardsAllocator -> Balancer -> private boolean tryRelocateShard(ModelNode minNode, ModelNode maxNode, String idx, float minCost);1542402632;Tries to find a relocation from the max node to the minimal node for an arbitrary shard of the given index on the_balance model. Iff this method returns a <code>true</code> the relocation has already been executed on the_simulation model as well as on the cluster.;private boolean tryRelocateShard(ModelNode minNode, ModelNode maxNode, String idx, float minCost) {_            final ModelIndex index = maxNode.getIndex(idx)__            Decision decision = null__            if (index != null) {_                if (logger.isTraceEnabled()) {_                    logger.trace("Try relocating shard for index index [{}] from node [{}] to node [{}]", idx, maxNode.getNodeId(),_                            minNode.getNodeId())__                }_                ShardRouting candidate = null__                final AllocationDeciders deciders = allocation.deciders()__                for (ShardRouting shard : index) {_                    if (shard.started()) {_                        _                        Decision allocationDecision = deciders.canAllocate(shard, minNode.getRoutingNode(), allocation)__                        Decision rebalanceDecision = deciders.canRebalance(shard, allocation)__                        if (((allocationDecision.type() == Type.YES) || (allocationDecision.type() == Type.THROTTLE))_                                && ((rebalanceDecision.type() == Type.YES) || (rebalanceDecision.type() == Type.THROTTLE))) {_                            if (maxNode.containsShard(shard)) {_                                _                                final float delta = weight.weightShardAdded(_                                    this, minNode, idx) - weight.weightShardRemoved(this, maxNode, idx)__                                if (delta < minCost ||_                                        (candidate != null && Float.compare(delta, minCost) == 0 && candidate.id() > shard.id())) {_                                    _                                    minCost = delta__                                    candidate = shard__                                    decision = new Decision.Multi().add(allocationDecision).add(rebalanceDecision)__                                }_                            }_                        }_                    }_                }__                if (candidate != null) {_                    _                    maxNode.removeShard(candidate)__                    long shardSize = allocation.clusterInfo().getShardSize(candidate, ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE)___                    if (decision.type() == Type.YES) { _                        logger.debug("Relocate shard [{}] from node [{}] to node [{}]", candidate, maxNode.getNodeId(),_                                    minNode.getNodeId())__                        _                        minNode.addShard(routingNodes.relocateShard(candidate, minNode.getNodeId(), shardSize, allocation.changes()).v1())__                        return true__                    } else {_                        assert decision.type() == Type.THROTTLE__                        minNode.addShard(candidate.relocate(minNode.getNodeId(), shardSize))__                    }_                }_            }_            if (logger.isTraceEnabled()) {_                logger.trace("Couldn't find shard to relocate from node [{}] to node [{}] allocation decision [{}]",_                    maxNode.getNodeId(), minNode.getNodeId(), decision == null ? "NO" : decision.type().name())__            }_            return false__        };tries,to,find,a,relocation,from,the,max,node,to,the,minimal,node,for,an,arbitrary,shard,of,the,given,index,on,the,balance,model,iff,this,method,returns,a,code,true,code,the,relocation,has,already,been,executed,on,the,simulation,model,as,well,as,on,the,cluster;private,boolean,try,relocate,shard,model,node,min,node,model,node,max,node,string,idx,float,min,cost,final,model,index,index,max,node,get,index,idx,decision,decision,null,if,index,null,if,logger,is,trace,enabled,logger,trace,try,relocating,shard,for,index,index,from,node,to,node,idx,max,node,get,node,id,min,node,get,node,id,shard,routing,candidate,null,final,allocation,deciders,deciders,allocation,deciders,for,shard,routing,shard,index,if,shard,started,decision,allocation,decision,deciders,can,allocate,shard,min,node,get,routing,node,allocation,decision,rebalance,decision,deciders,can,rebalance,shard,allocation,if,allocation,decision,type,type,yes,allocation,decision,type,type,throttle,rebalance,decision,type,type,yes,rebalance,decision,type,type,throttle,if,max,node,contains,shard,shard,final,float,delta,weight,weight,shard,added,this,min,node,idx,weight,weight,shard,removed,this,max,node,idx,if,delta,min,cost,candidate,null,float,compare,delta,min,cost,0,candidate,id,shard,id,min,cost,delta,candidate,shard,decision,new,decision,multi,add,allocation,decision,add,rebalance,decision,if,candidate,null,max,node,remove,shard,candidate,long,shard,size,allocation,cluster,info,get,shard,size,candidate,shard,routing,if,decision,type,type,yes,logger,debug,relocate,shard,from,node,to,node,candidate,max,node,get,node,id,min,node,get,node,id,min,node,add,shard,routing,nodes,relocate,shard,candidate,min,node,get,node,id,shard,size,allocation,changes,v1,return,true,else,assert,decision,type,type,throttle,min,node,add,shard,candidate,relocate,min,node,get,node,id,shard,size,if,logger,is,trace,enabled,logger,trace,couldn,t,find,shard,to,relocate,from,node,to,node,allocation,decision,max,node,get,node,id,min,node,get,node,id,decision,null,no,decision,type,name,return,false
BalancedShardsAllocator -> Balancer -> private boolean tryRelocateShard(ModelNode minNode, ModelNode maxNode, String idx, float minCost);1549912434;Tries to find a relocation from the max node to the minimal node for an arbitrary shard of the given index on the_balance model. Iff this method returns a <code>true</code> the relocation has already been executed on the_simulation model as well as on the cluster.;private boolean tryRelocateShard(ModelNode minNode, ModelNode maxNode, String idx, float minCost) {_            final ModelIndex index = maxNode.getIndex(idx)__            Decision decision = null__            if (index != null) {_                if (logger.isTraceEnabled()) {_                    logger.trace("Try relocating shard for index index [{}] from node [{}] to node [{}]", idx, maxNode.getNodeId(),_                            minNode.getNodeId())__                }_                ShardRouting candidate = null__                final AllocationDeciders deciders = allocation.deciders()__                for (ShardRouting shard : index) {_                    if (shard.started()) {_                        _                        Decision allocationDecision = deciders.canAllocate(shard, minNode.getRoutingNode(), allocation)__                        Decision rebalanceDecision = deciders.canRebalance(shard, allocation)__                        if (((allocationDecision.type() == Type.YES) || (allocationDecision.type() == Type.THROTTLE))_                                && ((rebalanceDecision.type() == Type.YES) || (rebalanceDecision.type() == Type.THROTTLE))) {_                            if (maxNode.containsShard(shard)) {_                                _                                final float delta = weight.weightShardAdded(_                                    this, minNode, idx) - weight.weightShardRemoved(this, maxNode, idx)__                                if (delta < minCost ||_                                        (candidate != null && Float.compare(delta, minCost) == 0 && candidate.id() > shard.id())) {_                                    _                                    minCost = delta__                                    candidate = shard__                                    decision = new Decision.Multi().add(allocationDecision).add(rebalanceDecision)__                                }_                            }_                        }_                    }_                }__                if (candidate != null) {_                    _                    maxNode.removeShard(candidate)__                    long shardSize = allocation.clusterInfo().getShardSize(candidate, ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE)___                    if (decision.type() == Type.YES) { _                        logger.debug("Relocate shard [{}] from node [{}] to node [{}]", candidate, maxNode.getNodeId(),_                                    minNode.getNodeId())__                        _                        minNode.addShard(routingNodes.relocateShard(candidate, minNode.getNodeId(), shardSize, allocation.changes()).v1())__                        return true__                    } else {_                        assert decision.type() == Type.THROTTLE__                        minNode.addShard(candidate.relocate(minNode.getNodeId(), shardSize))__                    }_                }_            }_            if (logger.isTraceEnabled()) {_                logger.trace("Couldn't find shard to relocate from node [{}] to node [{}] allocation decision [{}]",_                    maxNode.getNodeId(), minNode.getNodeId(), decision == null ? "NO" : decision.type().name())__            }_            return false__        };tries,to,find,a,relocation,from,the,max,node,to,the,minimal,node,for,an,arbitrary,shard,of,the,given,index,on,the,balance,model,iff,this,method,returns,a,code,true,code,the,relocation,has,already,been,executed,on,the,simulation,model,as,well,as,on,the,cluster;private,boolean,try,relocate,shard,model,node,min,node,model,node,max,node,string,idx,float,min,cost,final,model,index,index,max,node,get,index,idx,decision,decision,null,if,index,null,if,logger,is,trace,enabled,logger,trace,try,relocating,shard,for,index,index,from,node,to,node,idx,max,node,get,node,id,min,node,get,node,id,shard,routing,candidate,null,final,allocation,deciders,deciders,allocation,deciders,for,shard,routing,shard,index,if,shard,started,decision,allocation,decision,deciders,can,allocate,shard,min,node,get,routing,node,allocation,decision,rebalance,decision,deciders,can,rebalance,shard,allocation,if,allocation,decision,type,type,yes,allocation,decision,type,type,throttle,rebalance,decision,type,type,yes,rebalance,decision,type,type,throttle,if,max,node,contains,shard,shard,final,float,delta,weight,weight,shard,added,this,min,node,idx,weight,weight,shard,removed,this,max,node,idx,if,delta,min,cost,candidate,null,float,compare,delta,min,cost,0,candidate,id,shard,id,min,cost,delta,candidate,shard,decision,new,decision,multi,add,allocation,decision,add,rebalance,decision,if,candidate,null,max,node,remove,shard,candidate,long,shard,size,allocation,cluster,info,get,shard,size,candidate,shard,routing,if,decision,type,type,yes,logger,debug,relocate,shard,from,node,to,node,candidate,max,node,get,node,id,min,node,get,node,id,min,node,add,shard,routing,nodes,relocate,shard,candidate,min,node,get,node,id,shard,size,allocation,changes,v1,return,true,else,assert,decision,type,type,throttle,min,node,add,shard,candidate,relocate,min,node,get,node,id,shard,size,if,logger,is,trace,enabled,logger,trace,couldn,t,find,shard,to,relocate,from,node,to,node,allocation,decision,max,node,get,node,id,min,node,get,node,id,decision,null,no,decision,type,name,return,false
