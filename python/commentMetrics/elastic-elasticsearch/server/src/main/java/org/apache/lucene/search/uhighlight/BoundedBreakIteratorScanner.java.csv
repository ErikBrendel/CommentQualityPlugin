commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public CharacterIterator getText() {     return mainBreak.getText(). }
false;public;1;6;;@Override public void setText(CharacterIterator newText) {     reset().     mainBreak.setText(newText).     innerBreak.setText(newText). }
false;public;1;6;;@Override public void setText(String newText) {     reset().     mainBreak.setText(newText).     innerBreak.setText(newText). }
false;private;0;7;;private void reset() {     lastPrecedingOffset = -1.     windowStart = -1.     windowEnd = -1.     innerStart = -1.     innerEnd = 0. }
true;public;1;39;/**  * Must be called with increasing offset. See {@link FieldHighlighter} for usage.  */ ;/**  * Must be called with increasing offset. See {@link FieldHighlighter} for usage.  */ @Override public int preceding(int offset) {     if (offset < lastPrecedingOffset) {         throw new IllegalArgumentException("offset < lastPrecedingOffset: " + "usage doesn't look like UnifiedHighlighter").     }     if (offset > windowStart && offset < windowEnd) {         innerStart = innerEnd.         innerEnd = windowEnd.     } else {         windowStart = innerStart = mainBreak.preceding(offset).         windowEnd = innerEnd = mainBreak.following(offset - 1).         // expand to next break until we reach maxLen         while (innerEnd - innerStart < maxLen) {             int newEnd = mainBreak.following(innerEnd).             if (newEnd == DONE || (newEnd - innerStart) > maxLen) {                 break.             }             windowEnd = innerEnd = newEnd.         }     }     if (innerEnd - innerStart > maxLen) {         // so starting from the current term we try to find boundaries on the left first         if (offset - maxLen > innerStart) {             innerStart = Math.max(innerStart, innerBreak.preceding(offset - maxLen)).         }         // and then we try to expand the passage to the right with the remaining size         int remaining = Math.max(0, maxLen - (offset - innerStart)).         if (offset + remaining < windowEnd) {             innerEnd = Math.min(windowEnd, innerBreak.following(offset + remaining)).         }     }     lastPrecedingOffset = offset - 1.     return innerStart. }
true;public;1;8;/**  * Can be invoked only after a call to preceding(offset+1).  * See {@link FieldHighlighter} for usage.  */ ;/**  * Can be invoked only after a call to preceding(offset+1).  * See {@link FieldHighlighter} for usage.  */ @Override public int following(int offset) {     if (offset != lastPrecedingOffset || innerEnd == -1) {         throw new IllegalArgumentException("offset != lastPrecedingOffset: " + "usage doesn't look like UnifiedHighlighter").     }     return innerEnd. }
true;public,static;2;5;/**  * Returns a {@link BreakIterator#getSentenceInstance(Locale)} bounded to maxLen.  * Secondary boundaries are found using a {@link BreakIterator#getWordInstance(Locale)}.  */ ;/**  * Returns a {@link BreakIterator#getSentenceInstance(Locale)} bounded to maxLen.  * Secondary boundaries are found using a {@link BreakIterator#getWordInstance(Locale)}.  */ public static BreakIterator getSentence(Locale locale, int maxLen) {     final BreakIterator sBreak = BreakIterator.getSentenceInstance(locale).     final BreakIterator wBreak = BreakIterator.getWordInstance(locale).     return new BoundedBreakIteratorScanner(sBreak, wBreak, maxLen). }
false;public;0;5;;@Override public int current() {     // Returns the last offset of the current split     return this.innerEnd. }
false;public;0;4;;@Override public int first() {     throw new IllegalStateException("first() should not be called in this context"). }
false;public;0;4;;@Override public int next() {     throw new IllegalStateException("next() should not be called in this context"). }
false;public;0;4;;@Override public int last() {     throw new IllegalStateException("last() should not be called in this context"). }
false;public;1;4;;@Override public int next(int n) {     throw new IllegalStateException("next(n) should not be called in this context"). }
false;public;0;4;;@Override public int previous() {     throw new IllegalStateException("previous() should not be called in this context"). }
