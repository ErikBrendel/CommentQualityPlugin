commented;modifiers;parameterAmount;loc;comment;code
true;public,static;7;68;/**  * Resolve a {@link ValuesSourceConfig} given configuration parameters.  */ ;/**  * Resolve a {@link ValuesSourceConfig} given configuration parameters.  */ public static <VS extends ValuesSource> ValuesSourceConfig<VS> resolve(QueryShardContext context, ValueType valueType, String field, Script script, Object missing, ZoneId timeZone, String format) {     if (field == null) {         if (script == null) {             ValuesSourceConfig<VS> config = new ValuesSourceConfig<>(ValuesSourceType.ANY).             config.format(resolveFormat(null, valueType, timeZone)).             return config.         }         ValuesSourceType valuesSourceType = valueType != null ? valueType.getValuesSourceType() : ValuesSourceType.ANY.         if (valuesSourceType == ValuesSourceType.ANY) {             // the specific value source type is undefined, but for scripts,             // we need to have a specific value source             // type to know how to handle the script values, so we fallback             // on Bytes             valuesSourceType = ValuesSourceType.BYTES.         }         ValuesSourceConfig<VS> config = new ValuesSourceConfig<>(valuesSourceType).         config.missing(missing).         config.timezone(timeZone).         config.format(resolveFormat(format, valueType, timeZone)).         config.script(createScript(script, context)).         config.scriptValueType(valueType).         return config.     }     MappedFieldType fieldType = context.fieldMapper(field).     if (fieldType == null) {         ValuesSourceType valuesSourceType = valueType != null ? valueType.getValuesSourceType() : ValuesSourceType.ANY.         ValuesSourceConfig<VS> config = new ValuesSourceConfig<>(valuesSourceType).         config.missing(missing).         config.timezone(timeZone).         config.format(resolveFormat(format, valueType, timeZone)).         config.unmapped(true).         if (valueType != null) {             // todo do we really need this for unmapped?             config.scriptValueType(valueType).         }         return config.     }     IndexFieldData<?> indexFieldData = context.getForField(fieldType).     ValuesSourceConfig<VS> config.     if (valueType == null) {         if (indexFieldData instanceof IndexNumericFieldData) {             config = new ValuesSourceConfig<>(ValuesSourceType.NUMERIC).         } else if (indexFieldData instanceof IndexGeoPointFieldData) {             config = new ValuesSourceConfig<>(ValuesSourceType.GEOPOINT).         } else {             config = new ValuesSourceConfig<>(ValuesSourceType.BYTES).         }     } else {         config = new ValuesSourceConfig<>(valueType.getValuesSourceType()).     }     config.fieldContext(new FieldContext(field, indexFieldData, fieldType)).     config.missing(missing).     config.timezone(timeZone).     config.script(createScript(script, context)).     config.format(fieldType.docValueFormat(format, timeZone)).     return config. }
false;private,static;2;8;;private static AggregationScript.LeafFactory createScript(Script script, QueryShardContext context) {     if (script == null) {         return null.     } else {         AggregationScript.Factory factory = context.getScriptService().compile(script, AggregationScript.CONTEXT).         return factory.newFactory(script.getParams(), context.lookup()).     } }
false;private,static;3;14;;private static DocValueFormat resolveFormat(@Nullable String format, @Nullable ValueType valueType, @Nullable ZoneId tz) {     if (valueType == null) {         // we can't figure it out         return DocValueFormat.RAW.     }     DocValueFormat valueFormat = valueType.defaultFormat.     if (valueFormat instanceof DocValueFormat.Decimal && format != null) {         valueFormat = new DocValueFormat.Decimal(format).     }     if (valueFormat instanceof DocValueFormat.DateTime && format != null) {         valueFormat = new DocValueFormat.DateTime(DateFormatter.forPattern(format), tz != null ? tz : ZoneOffset.UTC, DateFieldMapper.Resolution.MILLISECONDS).     }     return valueFormat. }
false;public;0;3;;public ValuesSourceType valueSourceType() {     return valueSourceType. }
false;public;0;3;;public FieldContext fieldContext() {     return fieldContext. }
false;public;0;3;;public AggregationScript.LeafFactory script() {     return script. }
false;public;0;3;;public boolean unmapped() {     return unmapped. }
false;public;0;3;;public boolean valid() {     return fieldContext != null || script != null || unmapped. }
false;public;1;4;;public ValuesSourceConfig<VS> fieldContext(FieldContext fieldContext) {     this.fieldContext = fieldContext.     return this. }
false;public;1;4;;public ValuesSourceConfig<VS> script(AggregationScript.LeafFactory script) {     this.script = script.     return this. }
false;public;1;4;;public ValuesSourceConfig<VS> scriptValueType(ValueType scriptValueType) {     this.scriptValueType = scriptValueType.     return this. }
false;public;0;3;;public ValueType scriptValueType() {     return this.scriptValueType. }
false;public;1;4;;public ValuesSourceConfig<VS> unmapped(boolean unmapped) {     this.unmapped = unmapped.     return this. }
false;public;1;4;;public ValuesSourceConfig<VS> format(final DocValueFormat format) {     this.format = format.     return this. }
false;public;1;4;;public ValuesSourceConfig<VS> missing(final Object missing) {     this.missing = missing.     return this. }
false;public;0;3;;public Object missing() {     return this.missing. }
false;public;1;4;;public ValuesSourceConfig<VS> timezone(final ZoneId timeZone) {     this.timeZone = timeZone.     return this. }
false;public;0;3;;public ZoneId timezone() {     return this.timeZone. }
false;public;0;3;;public DocValueFormat format() {     return format. }
true;public;1;48;/**  * Get a value source given its configuration. A return value of null indicates that  *  no value source could be built.  */ ;/**  * Get a value source given its configuration. A return value of null indicates that  *  no value source could be built.  */ @Nullable public VS toValuesSource(QueryShardContext context) {     if (!valid()) {         throw new IllegalStateException("value source config is invalid. must have either a field context or a script or marked as unwrapped").     }     final VS vs.     if (unmapped()) {         if (missing() == null) {             // otherwise we will have values because of the missing value             vs = null.         } else if (valueSourceType() == ValuesSourceType.NUMERIC) {             vs = (VS) ValuesSource.Numeric.EMPTY.         } else if (valueSourceType() == ValuesSourceType.GEOPOINT) {             vs = (VS) ValuesSource.GeoPoint.EMPTY.         } else if (valueSourceType() == ValuesSourceType.ANY || valueSourceType() == ValuesSourceType.BYTES) {             vs = (VS) ValuesSource.Bytes.WithOrdinals.EMPTY.         } else {             throw new IllegalArgumentException("Can't deal with unmapped ValuesSource type " + valueSourceType()).         }     } else {         vs = originalValuesSource().     }     if (missing() == null) {         return vs.     }     if (vs instanceof ValuesSource.Bytes) {         final BytesRef missing = format.parseBytesRef(missing().toString()).         if (vs instanceof ValuesSource.Bytes.WithOrdinals) {             return (VS) MissingValues.replaceMissing((ValuesSource.Bytes.WithOrdinals) vs, missing).         } else {             return (VS) MissingValues.replaceMissing((ValuesSource.Bytes) vs, missing).         }     } else if (vs instanceof ValuesSource.Numeric) {         Number missing = format.parseDouble(missing().toString(), false, context::nowInMillis).         return (VS) MissingValues.replaceMissing((ValuesSource.Numeric) vs, missing).     } else if (vs instanceof ValuesSource.GeoPoint) {         // TODO: also support the structured formats of geo points         final GeoPoint missing = new GeoPoint(missing().toString()).         return (VS) MissingValues.replaceMissing((ValuesSource.GeoPoint) vs, missing).     } else {         // Should not happen         throw new IllegalArgumentException("Can't apply missing values on a " + vs.getClass()).     } }
true;private;0;21;/**  * Return the original values source, before we apply `missing`.  */ ;/**  * Return the original values source, before we apply `missing`.  */ private VS originalValuesSource() {     if (fieldContext() == null) {         if (valueSourceType() == ValuesSourceType.NUMERIC) {             return (VS) numericScript().         }         if (valueSourceType() == ValuesSourceType.BYTES) {             return (VS) bytesScript().         }         throw new AggregationExecutionException("value source of type [" + valueSourceType().name() + "] is not supported by scripts").     }     if (valueSourceType() == ValuesSourceType.NUMERIC) {         return (VS) numericField().     }     if (valueSourceType() == ValuesSourceType.GEOPOINT) {         return (VS) geoPointField().     }     // falling back to bytes values     return (VS) bytesField(). }
false;private;0;3;;private ValuesSource.Numeric numericScript() {     return new ValuesSource.Numeric.Script(script(), scriptValueType()). }
false;private;0;13;;private ValuesSource.Numeric numericField() {     if (!(fieldContext().indexFieldData() instanceof IndexNumericFieldData)) {         throw new IllegalArgumentException("Expected numeric type on field [" + fieldContext().field() + "], but got [" + fieldContext().fieldType().typeName() + "]").     }     ValuesSource.Numeric dataSource = new ValuesSource.Numeric.FieldData((IndexNumericFieldData) fieldContext().indexFieldData()).     if (script() != null) {         dataSource = new ValuesSource.Numeric.WithScript(dataSource, script()).     }     return dataSource. }
false;private;0;13;;private ValuesSource bytesField() {     final IndexFieldData<?> indexFieldData = fieldContext().indexFieldData().     ValuesSource dataSource.     if (indexFieldData instanceof IndexOrdinalsFieldData) {         dataSource = new ValuesSource.Bytes.WithOrdinals.FieldData((IndexOrdinalsFieldData) indexFieldData).     } else {         dataSource = new ValuesSource.Bytes.FieldData(indexFieldData).     }     if (script() != null) {         dataSource = new ValuesSource.WithScript(dataSource, script()).     }     return dataSource. }
false;private;0;3;;private ValuesSource.Bytes bytesScript() {     return new ValuesSource.Bytes.Script(script()). }
false;private;0;9;;private ValuesSource.GeoPoint geoPointField() {     if (!(fieldContext().indexFieldData() instanceof IndexGeoPointFieldData)) {         throw new IllegalArgumentException("Expected geo_point type on field [" + fieldContext().field() + "], but got [" + fieldContext().fieldType().typeName() + "]").     }     return new ValuesSource.GeoPoint.Fielddata((IndexGeoPointFieldData) fieldContext().indexFieldData()). }
