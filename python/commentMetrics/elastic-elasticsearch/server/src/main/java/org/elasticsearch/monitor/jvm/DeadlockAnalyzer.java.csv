commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;3;;public static DeadlockAnalyzer deadlockAnalyzer() {     return INSTANCE. }
false;public;0;11;;public Deadlock[] findDeadlocks() {     long[] deadlockedThreads = threadBean.findMonitorDeadlockedThreads().     if (deadlockedThreads == null || deadlockedThreads.length == 0) {         return NULL_RESULT.     }     Map<Long, ThreadInfo> threadInfoMap = createThreadInfoMap(deadlockedThreads).     Set<LinkedHashSet<ThreadInfo>> cycles = calculateCycles(threadInfoMap).     Set<LinkedHashSet<ThreadInfo>> chains = calculateCycleDeadlockChains(threadInfoMap, cycles).     cycles.addAll(chains).     return createDeadlockDescriptions(cycles). }
false;private;1;10;;private Deadlock[] createDeadlockDescriptions(Set<LinkedHashSet<ThreadInfo>> cycles) {     Deadlock[] result = new Deadlock[cycles.size()].     int count = 0.     for (LinkedHashSet<ThreadInfo> cycle : cycles) {         ThreadInfo[] asArray = cycle.toArray(new ThreadInfo[cycle.size()]).         Deadlock d = new Deadlock(asArray).         result[count++] = d.     }     return result. }
false;private;1;14;;private Set<LinkedHashSet<ThreadInfo>> calculateCycles(Map<Long, ThreadInfo> threadInfoMap) {     Set<LinkedHashSet<ThreadInfo>> cycles = new HashSet<>().     for (Map.Entry<Long, ThreadInfo> entry : threadInfoMap.entrySet()) {         LinkedHashSet<ThreadInfo> cycle = new LinkedHashSet<>().         for (ThreadInfo t = entry.getValue(). !cycle.contains(t). t = threadInfoMap.get(Long.valueOf(t.getLockOwnerId()))) {             cycle.add(t).         }         if (!cycles.contains(cycle)) {             cycles.add(cycle).         }     }     return cycles. }
false;private;2;25;;private Set<LinkedHashSet<ThreadInfo>> calculateCycleDeadlockChains(Map<Long, ThreadInfo> threadInfoMap, Set<LinkedHashSet<ThreadInfo>> cycles) {     ThreadInfo[] allThreads = threadBean.getThreadInfo(threadBean.getAllThreadIds()).     Set<LinkedHashSet<ThreadInfo>> deadlockChain = new HashSet<>().     Set<Long> knownDeadlockedThreads = threadInfoMap.keySet().     for (ThreadInfo threadInfo : allThreads) {         Thread.State state = threadInfo.getThreadState().         if (state == Thread.State.BLOCKED && !knownDeadlockedThreads.contains(threadInfo.getThreadId())) {             for (LinkedHashSet<ThreadInfo> cycle : cycles) {                 if (cycle.contains(threadInfoMap.get(Long.valueOf(threadInfo.getLockOwnerId())))) {                     LinkedHashSet<ThreadInfo> chain = new LinkedHashSet<>().                     ThreadInfo node = threadInfo.                     while (!chain.contains(node)) {                         chain.add(node).                         node = threadInfoMap.get(Long.valueOf(node.getLockOwnerId())).                     }                     deadlockChain.add(chain).                 }             }         }     }     return deadlockChain. }
false;private;1;8;;private Map<Long, ThreadInfo> createThreadInfoMap(long[] threadIds) {     ThreadInfo[] threadInfos = threadBean.getThreadInfo(threadIds).     Map<Long, ThreadInfo> threadInfoMap = new HashMap<>().     for (ThreadInfo threadInfo : threadInfos) {         threadInfoMap.put(threadInfo.getThreadId(), threadInfo).     }     return unmodifiableMap(threadInfoMap). }
false;public;0;3;;public ThreadInfo[] members() {     return members. }
false;public;1;11;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     Deadlock deadlock = (Deadlock) o.     if (memberIds != null ? !memberIds.equals(deadlock.memberIds) : deadlock.memberIds != null)         return false.     return true. }
false;public;0;7;;@Override public int hashCode() {     int result = members != null ? Arrays.hashCode(members) : 0.     result = 31 * result + (description != null ? description.hashCode() : 0).     result = 31 * result + (memberIds != null ? memberIds.hashCode() : 0).     return result. }
false;public;0;4;;@Override public String toString() {     return description. }
