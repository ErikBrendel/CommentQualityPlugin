commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * total number shards, including replicas, both assigned and unassigned  */ ;/**  * total number shards, including replicas, both assigned and unassigned  */ public int totalShards() {     return shardCounts.total. }
true;public;0;3;/**  * total number of shards for which the operation failed  */ ;/**  * total number of shards for which the operation failed  */ public int failedShards() {     return shardCounts.failed. }
true;public;0;3;/**  * total number of shards which were successfully sync-flushed  */ ;/**  * total number of shards which were successfully sync-flushed  */ public int successfulShards() {     return shardCounts.successful. }
false;public;0;3;;public RestStatus restStatus() {     return failedShards() == 0 ? RestStatus.OK : RestStatus.CONFLICT. }
false;public;0;3;;public Map<String, List<ShardsSyncedFlushResult>> getShardsResultPerIndex() {     return shardsResultPerIndex. }
false;public;2;35;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject(Fields._SHARDS).     shardCounts.toXContent(builder, params).     builder.endObject().     for (Map.Entry<String, List<ShardsSyncedFlushResult>> indexEntry : shardsResultPerIndex.entrySet()) {         List<ShardsSyncedFlushResult> indexResult = indexEntry.getValue().         builder.startObject(indexEntry.getKey()).         ShardCounts indexShardCounts = calculateShardCounts(indexResult).         indexShardCounts.toXContent(builder, params).         if (indexShardCounts.failed > 0) {             builder.startArray(Fields.FAILURES).             for (ShardsSyncedFlushResult shardResults : indexResult) {                 if (shardResults.failed()) {                     builder.startObject().                     builder.field(Fields.SHARD, shardResults.shardId().id()).                     builder.field(Fields.REASON, shardResults.failureReason()).                     builder.endObject().                     continue.                 }                 Map<ShardRouting, SyncedFlushService.ShardSyncedFlushResponse> failedShards = shardResults.failedShards().                 for (Map.Entry<ShardRouting, SyncedFlushService.ShardSyncedFlushResponse> shardEntry : failedShards.entrySet()) {                     builder.startObject().                     builder.field(Fields.SHARD, shardResults.shardId().id()).                     builder.field(Fields.REASON, shardEntry.getValue().failureReason()).                     builder.field(Fields.ROUTING, shardEntry.getKey()).                     builder.endObject().                 }             }             builder.endArray().         }         builder.endObject().     }     return builder. }
false;static;1;15;;static ShardCounts calculateShardCounts(Iterable<ShardsSyncedFlushResult> results) {     int total = 0, successful = 0, failed = 0.     for (ShardsSyncedFlushResult result : results) {         total += result.totalShards().         successful += result.successfulShards().         if (result.failed()) {             // treat all shard copies as failed             failed += result.totalShards().         } else {             // some shards may have failed during the sync phase             failed += result.failedShards().size().         }     }     return new ShardCounts(total, successful, failed). }
false;public;2;7;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.field(Fields.TOTAL, total).     builder.field(Fields.SUCCESSFUL, successful).     builder.field(Fields.FAILED, failed).     return builder. }
false;public;1;6;;@Override public void readFrom(StreamInput in) throws IOException {     total = in.readInt().     successful = in.readInt().     failed = in.readInt(). }
false;public;1;6;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeInt(total).     out.writeInt(successful).     out.writeInt(failed). }
false;public;1;18;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     shardCounts = new ShardCounts().     shardCounts.readFrom(in).     Map<String, List<ShardsSyncedFlushResult>> tmpShardsResultPerIndex = new HashMap<>().     int numShardsResults = in.readInt().     for (int i = 0. i < numShardsResults. i++) {         String index = in.readString().         List<ShardsSyncedFlushResult> shardsSyncedFlushResults = new ArrayList<>().         int numShards = in.readInt().         for (int j = 0. j < numShards. j++) {             shardsSyncedFlushResults.add(ShardsSyncedFlushResult.readShardsSyncedFlushResult(in)).         }         tmpShardsResultPerIndex.put(index, shardsSyncedFlushResults).     }     shardsResultPerIndex = Collections.unmodifiableMap(tmpShardsResultPerIndex). }
false;public;1;13;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     shardCounts.writeTo(out).     out.writeInt(shardsResultPerIndex.size()).     for (Map.Entry<String, List<ShardsSyncedFlushResult>> entry : shardsResultPerIndex.entrySet()) {         out.writeString(entry.getKey()).         out.writeInt(entry.getValue().size()).         for (ShardsSyncedFlushResult shardsSyncedFlushResult : entry.getValue()) {             shardsSyncedFlushResult.writeTo(out).         }     } }
