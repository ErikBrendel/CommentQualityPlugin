commented;modifiers;parameterAmount;loc;comment;code
false;private;0;5;;private void computeLookup() {     for (int i = 0. i < percents.length. i++) {         percentileLookups.put(percents[i], percentiles[i]).     } }
false;protected;1;10;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     out.writeNamedWriteable(format).     out.writeDoubleArray(percentiles).     out.writeDoubleArray(percents).     if (out.getVersion().onOrAfter(Version.V_7_0_0)) {         out.writeBoolean(keyed).     } }
false;public;0;4;;@Override public String getWriteableName() {     return PercentilesBucketPipelineAggregationBuilder.NAME. }
false;public;1;9;;@Override public double percentile(double percent) throws IllegalArgumentException {     Double percentile = percentileLookups.get(percent).     if (percentile == null) {         throw new IllegalArgumentException("Percent requested [" + String.valueOf(percent) + "] was not" + " one of the computed percentiles.  Available keys are: " + Arrays.toString(percents)).     }     return percentile. }
false;public;1;4;;@Override public String percentileAsString(double percent) {     return format.format(percentile(percent)).toString(). }
false;;0;3;;DocValueFormat formatter() {     return format. }
false;public;0;4;;@Override public Iterator<Percentile> iterator() {     return new Iter(percents, percentiles). }
false;public;1;4;;@Override public double value(String name) {     return percentile(Double.parseDouble(name)). }
false;public;2;4;;@Override public InternalMax doReduce(List<InternalAggregation> aggregations, ReduceContext reduceContext) {     throw new UnsupportedOperationException("Not supported"). }
false;public;2;31;;@Override public XContentBuilder doXContentBody(XContentBuilder builder, Params params) throws IOException {     if (keyed) {         builder.startObject("values").         for (double percent : percents) {             double value = percentile(percent).             boolean hasValue = !(Double.isInfinite(value) || Double.isNaN(value)).             String key = String.valueOf(percent).             builder.field(key, hasValue ? value : null).             if (hasValue && format != DocValueFormat.RAW) {                 builder.field(key + "_as_string", percentileAsString(percent)).             }         }         builder.endObject().     } else {         builder.startArray("values").         for (double percent : percents) {             double value = percentile(percent).             boolean hasValue = !(Double.isInfinite(value) || Double.isNaN(value)).             builder.startObject().             builder.field("key", percent).             builder.field("value", hasValue ? value : null).             if (hasValue && format != DocValueFormat.RAW) {                 builder.field(String.valueOf(percent) + "_as_string", percentileAsString(percent)).             }             builder.endObject().         }         builder.endArray().     }     return builder. }
false;protected;1;5;;@Override protected boolean doEquals(Object obj) {     InternalPercentilesBucket that = (InternalPercentilesBucket) obj.     return Arrays.equals(percents, that.percents) && Arrays.equals(percentiles, that.percentiles). }
false;protected;0;4;;@Override protected int doHashCode() {     return Objects.hash(Arrays.hashCode(percents), Arrays.hashCode(percentiles)). }
false;public;0;4;;@Override public boolean hasNext() {     return i < percents.length. }
false;public;0;6;;@Override public Percentile next() {     final Percentile next = new Percentile(percents[i], percentiles[i]).     ++i.     return next. }
false;public,final;0;4;;@Override public final void remove() {     throw new UnsupportedOperationException(). }
