commented;modifiers;parameterAmount;loc;comment;code
false;public;1;6;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeString(scrollId).     out.writeOptionalWriteable(scroll). }
false;public;0;8;;@Override public ActionRequestValidationException validate() {     ActionRequestValidationException validationException = null.     if (scrollId == null) {         validationException = addValidationError("scrollId is missing", validationException).     }     return validationException. }
true;public;0;3;/**  * The scroll id used to scroll the search.  */ ;/**  * The scroll id used to scroll the search.  */ public String scrollId() {     return scrollId. }
false;public;1;4;;public SearchScrollRequest scrollId(String scrollId) {     this.scrollId = scrollId.     return this. }
true;public;0;3;/**  * If set, will enable scrolling of the search request.  */ ;/**  * If set, will enable scrolling of the search request.  */ public Scroll scroll() {     return scroll. }
true;public;1;4;/**  * If set, will enable scrolling of the search request.  */ ;/**  * If set, will enable scrolling of the search request.  */ public SearchScrollRequest scroll(Scroll scroll) {     this.scroll = scroll.     return this. }
true;public;1;3;/**  * If set, will enable scrolling of the search request for the specified timeout.  */ ;/**  * If set, will enable scrolling of the search request for the specified timeout.  */ public SearchScrollRequest scroll(TimeValue keepAlive) {     return scroll(new Scroll(keepAlive)). }
true;public;1;3;/**  * If set, will enable scrolling of the search request for the specified timeout.  */ ;/**  * If set, will enable scrolling of the search request for the specified timeout.  */ public SearchScrollRequest scroll(String keepAlive) {     return scroll(new Scroll(TimeValue.parseTimeValue(keepAlive, null, getClass().getSimpleName() + ".keepAlive"))). }
false;public;1;4;;@Override public void readFrom(StreamInput in) throws IOException {     throw new UnsupportedOperationException("usage of Streamable is to be replaced by Writeable"). }
false;public;5;4;;@Override public Task createTask(long id, String type, String action, TaskId parentTaskId, Map<String, String> headers) {     return new SearchTask(id, type, action, getDescription(), parentTaskId, headers). }
false;public;1;12;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (o == null || getClass() != o.getClass()) {         return false.     }     SearchScrollRequest that = (SearchScrollRequest) o.     return Objects.equals(scrollId, that.scrollId) && Objects.equals(scroll, that.scroll). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(scrollId, scroll). }
false;public;0;7;;@Override public String toString() {     return "SearchScrollRequest{" + "scrollId='" + scrollId + '\'' + ", scroll=" + scroll + '}'. }
false;public;0;4;;@Override public String getDescription() {     return "scrollId[" + scrollId + "], scroll[" + scroll + "]". }
false;public;2;10;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.field("scroll_id", scrollId).     if (scroll != null) {         builder.field("scroll", scroll.keepAlive().getStringRep()).     }     builder.endObject().     return builder. }
true;public;1;20;/**  * Parse a search scroll request from a request body provided through the REST layer.  * Values that are already be set and are also found while parsing will be overridden.  */ ;/**  * Parse a search scroll request from a request body provided through the REST layer.  * Values that are already be set and are also found while parsing will be overridden.  */ public void fromXContent(XContentParser parser) throws IOException {     if (parser.nextToken() != XContentParser.Token.START_OBJECT) {         throw new IllegalArgumentException("Malformed content, must start with an object").     } else {         XContentParser.Token token.         String currentFieldName = null.         while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {             if (token == XContentParser.Token.FIELD_NAME) {                 currentFieldName = parser.currentName().             } else if ("scroll_id".equals(currentFieldName) && token == XContentParser.Token.VALUE_STRING) {                 scrollId(parser.text()).             } else if ("scroll".equals(currentFieldName) && token == XContentParser.Token.VALUE_STRING) {                 scroll(new Scroll(TimeValue.parseTimeValue(parser.text(), null, "scroll"))).             } else {                 throw new IllegalArgumentException("Unknown parameter [" + currentFieldName + "] in request body or parameter is of the wrong type[" + token + "] ").             }         }     } }
