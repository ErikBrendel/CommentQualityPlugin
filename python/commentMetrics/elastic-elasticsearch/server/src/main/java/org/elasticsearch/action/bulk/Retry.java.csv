commented;modifiers;parameterAmount;loc;comment;code
true;public;3;5;/**  * Invokes #accept(BulkRequest, ActionListener). Backs off on the provided exception and delegates results to the  * provided listener. Retries will be scheduled using the class's thread pool.  * @param consumer The consumer to which apply the request and listener  * @param bulkRequest The bulk request that should be executed.  * @param listener A listener that is invoked when the bulk request finishes or completes with an exception. The listener is not  */ ;/**  * Invokes #accept(BulkRequest, ActionListener). Backs off on the provided exception and delegates results to the  * provided listener. Retries will be scheduled using the class's thread pool.  * @param consumer The consumer to which apply the request and listener  * @param bulkRequest The bulk request that should be executed.  * @param listener A listener that is invoked when the bulk request finishes or completes with an exception. The listener is not  */ public void withBackoff(BiConsumer<BulkRequest, ActionListener<BulkResponse>> consumer, BulkRequest bulkRequest, ActionListener<BulkResponse> listener) {     RetryHandler r = new RetryHandler(backoffPolicy, consumer, listener, scheduler).     r.execute(bulkRequest). }
true;public;2;6;/**  * Invokes #accept(BulkRequest, ActionListener). Backs off on the provided exception. Retries will be scheduled using  * the class's thread pool.  *  * @param consumer The consumer to which apply the request and listener  * @param bulkRequest The bulk request that should be executed.  * @return a future representing the bulk response returned by the client.  */ ;/**  * Invokes #accept(BulkRequest, ActionListener). Backs off on the provided exception. Retries will be scheduled using  * the class's thread pool.  *  * @param consumer The consumer to which apply the request and listener  * @param bulkRequest The bulk request that should be executed.  * @return a future representing the bulk response returned by the client.  */ public PlainActionFuture<BulkResponse> withBackoff(BiConsumer<BulkRequest, ActionListener<BulkResponse>> consumer, BulkRequest bulkRequest) {     PlainActionFuture<BulkResponse> future = PlainActionFuture.newFuture().     withBackoff(consumer, bulkRequest, future).     return future. }
false;public;1;16;;@Override public void onResponse(BulkResponse bulkItemResponses) {     if (!bulkItemResponses.hasFailures()) {         // we're done here, include all responses         addResponses(bulkItemResponses, (r -> true)).         finishHim().     } else {         if (canRetry(bulkItemResponses)) {             addResponses(bulkItemResponses, (r -> !r.isFailed())).             retry(createBulkRequestForRetry(bulkItemResponses)).         } else {             addResponses(bulkItemResponses, (r -> true)).             finishHim().         }     } }
false;public;1;10;;@Override public void onFailure(Exception e) {     try {         listener.onFailure(e).     } finally {         if (retryCancellable != null) {             retryCancellable.cancel().         }     } }
false;private;1;7;;private void retry(BulkRequest bulkRequestForRetry) {     assert backoff.hasNext().     TimeValue next = backoff.next().     logger.trace("Retry of bulk request scheduled in {} ms.", next.millis()).     Runnable command = scheduler.preserveContext(() -> this.execute(bulkRequestForRetry)).     retryCancellable = scheduler.schedule(command, next, ThreadPool.Names.SAME). }
false;private;1;11;;private BulkRequest createBulkRequestForRetry(BulkResponse bulkItemResponses) {     BulkRequest requestToReissue = new BulkRequest().     int index = 0.     for (BulkItemResponse bulkItemResponse : bulkItemResponses.getItems()) {         if (bulkItemResponse.isFailed()) {             requestToReissue.add(currentBulkRequest.requests().get(index)).         }         index++.     }     return requestToReissue. }
false;private;1;14;;private boolean canRetry(BulkResponse bulkItemResponses) {     if (!backoff.hasNext()) {         return false.     }     for (BulkItemResponse bulkItemResponse : bulkItemResponses) {         if (bulkItemResponse.isFailed()) {             final RestStatus status = bulkItemResponse.status().             if (status != RETRY_STATUS) {                 return false.             }         }     }     return true. }
false;private;0;9;;private void finishHim() {     try {         listener.onResponse(getAccumulatedResponse()).     } finally {         if (retryCancellable != null) {             retryCancellable.cancel().         }     } }
false;private;2;12;;private void addResponses(BulkResponse response, Predicate<BulkItemResponse> filter) {     for (BulkItemResponse bulkItemResponse : response) {         if (filter.test(bulkItemResponse)) {             // scheduled on the same thread is fragile.             synchronized (responses) {                 responses.add(bulkItemResponse).             }         }     } }
false;private;0;9;;private BulkResponse getAccumulatedResponse() {     BulkItemResponse[] itemResponses.     synchronized (responses) {         itemResponses = responses.toArray(new BulkItemResponse[1]).     }     long stopTimestamp = System.nanoTime().     long totalLatencyMs = TimeValue.timeValueNanos(stopTimestamp - startTimestampNanos).millis().     return new BulkResponse(itemResponses, totalLatencyMs). }
false;public;1;4;;public void execute(BulkRequest bulkRequest) {     this.currentBulkRequest = bulkRequest.     consumer.accept(bulkRequest, this). }
