commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public void close() {     cache.invalidateAll(). }
false;;1;4;;void clear(CacheEntity entity) {     keysToClean.add(new CleanupKey(entity, null)).     cleanCache(). }
false;public;1;4;;@Override public void onRemoval(RemovalNotification<Key, BytesReference> notification) {     notification.getKey().entity.onRemoval(notification). }
true;;5;27;// removed when this issue is solved ;// NORELEASE The cacheKeyRenderer has been added in order to debug // https://github.com/elastic/elasticsearch/issues/32827, it should be // removed when this issue is solved BytesReference getOrCompute(CacheEntity cacheEntity, Supplier<BytesReference> loader, DirectoryReader reader, BytesReference cacheKey, Supplier<String> cacheKeyRenderer) throws Exception {     assert reader.getReaderCacheHelper() != null.     final Key key = new Key(cacheEntity, reader.getReaderCacheHelper().getKey(), cacheKey).     Loader cacheLoader = new Loader(cacheEntity, loader).     BytesReference value = cache.computeIfAbsent(key, cacheLoader).     if (cacheLoader.isLoaded()) {         key.entity.onMiss().         if (logger.isTraceEnabled()) {             logger.trace("Cache miss for reader version [{}] and request:\n {}", reader.getVersion(), cacheKeyRenderer.get()).         }         // see if its the first time we see this reader, and make sure to register a cleanup key         CleanupKey cleanupKey = new CleanupKey(cacheEntity, reader.getReaderCacheHelper().getKey()).         if (!registeredClosedListeners.containsKey(cleanupKey)) {             Boolean previous = registeredClosedListeners.putIfAbsent(cleanupKey, Boolean.TRUE).             if (previous == null) {                 ElasticsearchDirectoryReader.addReaderCloseListener(reader, cleanupKey).             }         }     } else {         key.entity.onHit().         if (logger.isTraceEnabled()) {             logger.trace("Cache hit for reader version [{}] and request:\n {}", reader.getVersion(), cacheKeyRenderer.get()).         }     }     return value. }
true;;3;4;/**  * Invalidates the given the cache entry for the given key and it's context  * @param cacheEntity the cache entity to invalidate for  * @param reader the reader to invalidate the cache entry for  * @param cacheKey the cache key to invalidate  */ ;/**  * Invalidates the given the cache entry for the given key and it's context  * @param cacheEntity the cache entity to invalidate for  * @param reader the reader to invalidate the cache entry for  * @param cacheKey the cache key to invalidate  */ void invalidate(CacheEntity cacheEntity, DirectoryReader reader, BytesReference cacheKey) {     assert reader.getReaderCacheHelper() != null.     cache.invalidate(new Key(cacheEntity, reader.getReaderCacheHelper().getKey(), cacheKey)). }
false;public;0;3;;public boolean isLoaded() {     return this.loaded. }
false;public;1;7;;@Override public BytesReference load(Key key) throws Exception {     BytesReference value = loader.get().     entity.onCached(key, value).     loaded = true.     return value. }
true;;2;1;/**  * Called after the value was loaded.  */ ;/**  * Called after the value was loaded.  */ void onCached(Key key, BytesReference value).
true;;0;1;/**  * Returns <code>true</code> iff the resource behind this entity is still open ie.  * entities associated with it can remain in the cache. ie. IndexShard is still open.  */ ;/**  * Returns <code>true</code> iff the resource behind this entity is still open ie.  * entities associated with it can remain in the cache. ie. IndexShard is still open.  */ boolean isOpen().
true;;0;1;/**  * Returns the cache identity. this is, similar to {@link #isOpen()} the resource identity behind this cache entity.  * For instance IndexShard is the identity while a CacheEntity is per DirectoryReader. Yet, we group by IndexShard instance.  */ ;/**  * Returns the cache identity. this is, similar to {@link #isOpen()} the resource identity behind this cache entity.  * For instance IndexShard is the identity while a CacheEntity is per DirectoryReader. Yet, we group by IndexShard instance.  */ Object getCacheIdentity().
true;;0;1;/**  * Called each time this entity has a cache hit.  */ ;/**  * Called each time this entity has a cache hit.  */ void onHit().
true;;0;1;/**  * Called each time this entity has a cache miss.  */ ;/**  * Called each time this entity has a cache miss.  */ void onMiss().
true;;1;1;/**  * Called when this entity instance is removed  */ ;/**  * Called when this entity instance is removed  */ void onRemoval(RemovalNotification<Key, BytesReference> notification).
false;public;0;4;;@Override public long ramBytesUsed() {     return BASE_RAM_BYTES_USED + entity.ramBytesUsed() + value.length(). }
false;public;0;5;;@Override public Collection<Accountable> getChildResources() {     // TODO: more detailed ram usage?     return Collections.emptyList(). }
false;public;1;10;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     Key key = (Key) o.     if (Objects.equals(readerCacheKey, key.readerCacheKey) == false)         return false.     if (!entity.getCacheIdentity().equals(key.entity.getCacheIdentity()))         return false.     if (!value.equals(key.value))         return false.     return true. }
false;public;0;7;;@Override public int hashCode() {     int result = entity.getCacheIdentity().hashCode().     result = 31 * result + readerCacheKey.hashCode().     result = 31 * result + value.hashCode().     return result. }
false;public;1;7;;@Override public void onClose(IndexReader.CacheKey cacheKey) {     Boolean remove = registeredClosedListeners.remove(this).     if (remove != null) {         keysToClean.add(this).     } }
false;public;1;11;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass()) {         return false.     }     CleanupKey that = (CleanupKey) o.     if (Objects.equals(readerCacheKey, that.readerCacheKey) == false)         return false.     if (!entity.getCacheIdentity().equals(that.entity.getCacheIdentity()))         return false.     return true. }
false;public;0;6;;@Override public int hashCode() {     int result = entity.getCacheIdentity().hashCode().     result = 31 * result + Objects.hashCode(readerCacheKey).     return result. }
false;synchronized;0;30;;synchronized void cleanCache() {     final ObjectSet<CleanupKey> currentKeysToClean = new ObjectHashSet<>().     final ObjectSet<Object> currentFullClean = new ObjectHashSet<>().     currentKeysToClean.clear().     currentFullClean.clear().     for (Iterator<CleanupKey> iterator = keysToClean.iterator(). iterator.hasNext(). ) {         CleanupKey cleanupKey = iterator.next().         iterator.remove().         if (cleanupKey.readerCacheKey == null || cleanupKey.entity.isOpen() == false) {             // null indicates full cleanup, as does a closed shard             currentFullClean.add(cleanupKey.entity.getCacheIdentity()).         } else {             currentKeysToClean.add(cleanupKey).         }     }     if (!currentKeysToClean.isEmpty() || !currentFullClean.isEmpty()) {         for (Iterator<Key> iterator = cache.keys().iterator(). iterator.hasNext(). ) {             Key key = iterator.next().             if (currentFullClean.contains(key.entity.getCacheIdentity())) {                 iterator.remove().             } else {                 if (currentKeysToClean.contains(new CleanupKey(key.entity, key.readerCacheKey))) {                     iterator.remove().                 }             }         }     }     cache.refresh(). }
true;;0;3;/**  * Returns the current size of the cache  */ ;/**  * Returns the current size of the cache  */ int count() {     return cache.count(). }
false;;0;3;;int numRegisteredCloseListeners() {     // for testing     return registeredClosedListeners.size(). }
