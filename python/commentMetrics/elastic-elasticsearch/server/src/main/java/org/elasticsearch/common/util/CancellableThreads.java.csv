commented;modifiers;parameterAmount;loc;comment;code
false;public,synchronized;0;3;;public synchronized boolean isCancelled() {     return cancelled. }
false;public;0;3;;public void checkForCancel() {     checkForCancel(null). }
false;private;1;19;;private void checkForCancel(Exception beforeCancelException) {     if (isCancelled()) {         final String reason.         final OnCancel onCancel.         synchronized (this) {             reason = this.reason.             onCancel = this.onCancel.get().         }         if (onCancel != null) {             onCancel.onCancel(reason, beforeCancelException).         }         // fallback to the default exception         final RuntimeException cancelExp = new ExecutionCancelledException("operation was cancelled reason [" + reason + "]").         if (beforeCancelException != null) {             cancelExp.addSuppressed(beforeCancelException).         }         throw cancelExp.     } }
false;private,synchronized;0;7;;private synchronized boolean add() {     checkForCancel().     threads.add(Thread.currentThread()).     // our own interrupt. we do so under lock so we know we don't clear our own.     return Thread.interrupted(). }
true;public;1;8;/**  * run the Interruptible, capturing the executing thread. Concurrent calls to {@link #cancel(String)} will interrupt this thread  * causing the call to prematurely return.  *  * @param interruptible code to run  */ ;/**  * run the Interruptible, capturing the executing thread. Concurrent calls to {@link #cancel(String)} will interrupt this thread  * causing the call to prematurely return.  *  * @param interruptible code to run  */ public void execute(Interruptible interruptible) {     try {         executeIO(interruptible).     } catch (IOException e) {         assert false : "the passed interruptible can not result in an IOException".         throw new RuntimeException("unexpected IO exception", e).     } }
true;public;1;45;/**  * run the Interruptible, capturing the executing thread. Concurrent calls to {@link #cancel(String)} will interrupt this thread  * causing the call to prematurely return.  *  * @param interruptible code to run  */ ;/**  * run the Interruptible, capturing the executing thread. Concurrent calls to {@link #cancel(String)} will interrupt this thread  * causing the call to prematurely return.  *  * @param interruptible code to run  */ public void executeIO(IOInterruptible interruptible) throws IOException {     boolean wasInterrupted = add().     boolean cancelledByExternalInterrupt = false.     RuntimeException runtimeException = null.     IOException ioException = null.     try {         interruptible.run().     } catch (InterruptedException | ThreadInterruptedException e) {         // ignore, this interrupt has been triggered by us in #cancel()...         assert cancelled : "Interruption via Thread#interrupt() is unsupported. Use CancellableThreads#cancel() instead".         // we can only reach here if assertions are disabled. If we reach this code and cancelled is false, this means that we've         // been interrupted externally (which we don't support).         cancelledByExternalInterrupt = !cancelled.     } catch (RuntimeException t) {         runtimeException = t.     } catch (IOException e) {         ioException = e.     } finally {         remove().     }     // restore old flag and see if we need to fail     if (wasInterrupted) {         Thread.currentThread().interrupt().     } else {         // clear the flag interrupted flag as we are checking for failure..         Thread.interrupted().     }     checkForCancel(ioException != null ? ioException : runtimeException).     if (ioException != null) {         // if we're not canceling, we throw the original exception         throw ioException.     }     if (runtimeException != null) {         // if we're not canceling, we throw the original exception         throw runtimeException.     }     if (cancelledByExternalInterrupt) {         // restore interrupt flag to at least adhere to expected behavior         Thread.currentThread().interrupt().         throw new RuntimeException("Interruption via Thread#interrupt() is unsupported. Use CancellableThreads#cancel() instead").     } }
false;private,synchronized;0;3;;private synchronized void remove() {     threads.remove(Thread.currentThread()). }
true;public,synchronized;1;14;/**  * cancel all current running operations. Future calls to {@link #checkForCancel()} will be failed with the given reason  */ ;/**  * cancel all current running operations. Future calls to {@link #checkForCancel()} will be failed with the given reason  */ public synchronized void cancel(String reason) {     if (cancelled) {         // Thread.interrupted without handling it         return.     }     cancelled = true.     this.reason = reason.     for (Thread thread : threads) {         thread.interrupt().     }     threads.clear(). }
false;;0;1;;void run() throws InterruptedException.
false;;0;1;;void run() throws IOException, InterruptedException.
true;public,synchronized;1;3;/**  * Registers a callback that will be invoked when some running operations are cancelled or {@link #checkForCancel()} is called.  */ ;/**  * Registers a callback that will be invoked when some running operations are cancelled or {@link #checkForCancel()} is called.  */ public synchronized void setOnCancel(OnCancel onCancel) {     this.onCancel.set(onCancel). }
true;;2;1;/**  * Called when some running operations are cancelled or {@link #checkForCancel()} is explicitly called.  * If this method throws an exception, cancelling tasks will fail with that exception. otherwise they  * will fail with the default exception {@link ExecutionCancelledException}.  *  * @param reason                the reason of the cancellation  * @param beforeCancelException any error that was encountered during the execution before the operations were cancelled.  * @see #checkForCancel()  * @see #setOnCancel(OnCancel)  */ ;/**  * Called when some running operations are cancelled or {@link #checkForCancel()} is explicitly called.  * If this method throws an exception, cancelling tasks will fail with that exception. otherwise they  * will fail with the default exception {@link ExecutionCancelledException}.  *  * @param reason                the reason of the cancellation  * @param beforeCancelException any error that was encountered during the execution before the operations were cancelled.  * @see #checkForCancel()  * @see #setOnCancel(OnCancel)  */ void onCancel(String reason, @Nullable Exception beforeCancelException).
