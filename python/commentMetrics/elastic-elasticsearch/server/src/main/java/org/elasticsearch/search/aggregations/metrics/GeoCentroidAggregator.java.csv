commented;modifiers;parameterAmount;loc;comment;code
false;public;2;31;;@Override public void collect(int doc, long bucket) throws IOException {     centroids = bigArrays.grow(centroids, bucket + 1).     counts = bigArrays.grow(counts, bucket + 1).     if (values.advanceExact(doc)) {         final int valueCount = values.docValueCount().         double[] pt = new double[2].         // get the previously accumulated number of counts         long prevCounts = counts.get(bucket).         // increment by the number of points for this document         counts.increment(bucket, valueCount).         // computed         if (prevCounts > 0) {             final long mortonCode = centroids.get(bucket).             pt[0] = InternalGeoCentroid.decodeLongitude(mortonCode).             pt[1] = InternalGeoCentroid.decodeLatitude(mortonCode).         }         // update the moving average         for (int i = 0. i < valueCount. ++i) {             GeoPoint value = values.nextValue().             pt[0] = pt[0] + (value.getLon() - pt[0]) / ++prevCounts.             pt[1] = pt[1] + (value.getLat() - pt[1]) / prevCounts.         }         // TODO: we do not need to interleave the lat and lon         // bits here         // should we just store them contiguously?         centroids.set(bucket, InternalGeoCentroid.encodeLatLon(pt[1], pt[0])).     } }
false;public;2;41;;@Override public LeafBucketCollector getLeafCollector(LeafReaderContext ctx, LeafBucketCollector sub) throws IOException {     if (valuesSource == null) {         return LeafBucketCollector.NO_OP_COLLECTOR.     }     final BigArrays bigArrays = context.bigArrays().     final MultiGeoPointValues values = valuesSource.geoPointValues(ctx).     return new LeafBucketCollectorBase(sub, values) {          @Override         public void collect(int doc, long bucket) throws IOException {             centroids = bigArrays.grow(centroids, bucket + 1).             counts = bigArrays.grow(counts, bucket + 1).             if (values.advanceExact(doc)) {                 final int valueCount = values.docValueCount().                 double[] pt = new double[2].                 // get the previously accumulated number of counts                 long prevCounts = counts.get(bucket).                 // increment by the number of points for this document                 counts.increment(bucket, valueCount).                 // computed                 if (prevCounts > 0) {                     final long mortonCode = centroids.get(bucket).                     pt[0] = InternalGeoCentroid.decodeLongitude(mortonCode).                     pt[1] = InternalGeoCentroid.decodeLatitude(mortonCode).                 }                 // update the moving average                 for (int i = 0. i < valueCount. ++i) {                     GeoPoint value = values.nextValue().                     pt[0] = pt[0] + (value.getLon() - pt[0]) / ++prevCounts.                     pt[1] = pt[1] + (value.getLat() - pt[1]) / prevCounts.                 }                 // TODO: we do not need to interleave the lat and lon                 // bits here                 // should we just store them contiguously?                 centroids.set(bucket, InternalGeoCentroid.encodeLatLon(pt[1], pt[0])).             }         }     }. }
false;public;1;13;;@Override public InternalAggregation buildAggregation(long bucket) {     if (valuesSource == null || bucket >= centroids.size()) {         return buildEmptyAggregation().     }     final long bucketCount = counts.get(bucket).     final long mortonCode = centroids.get(bucket).     final GeoPoint bucketCentroid = (bucketCount > 0) ? new GeoPoint(InternalGeoCentroid.decodeLatitude(mortonCode), InternalGeoCentroid.decodeLongitude(mortonCode)) : null.     return new InternalGeoCentroid(name, bucketCentroid, bucketCount, pipelineAggregators(), metaData()). }
false;public;0;4;;@Override public InternalAggregation buildEmptyAggregation() {     return new InternalGeoCentroid(name, null, 0L, pipelineAggregators(), metaData()). }
false;public;0;4;;@Override public void doClose() {     Releasables.close(centroids, counts). }
