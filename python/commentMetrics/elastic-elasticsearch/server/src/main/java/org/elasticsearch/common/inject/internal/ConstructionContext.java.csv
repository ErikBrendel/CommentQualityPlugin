commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public T getCurrentReference() {     return currentReference. }
false;public;0;3;;public void removeCurrentReference() {     this.currentReference = null. }
false;public;1;3;;public void setCurrentReference(T currentReference) {     this.currentReference = currentReference. }
false;public;0;3;;public boolean isConstructing() {     return constructing. }
false;public;0;3;;public void startConstruction() {     this.constructing = true. }
false;public;0;4;;public void finishConstruction() {     this.constructing = false.     invocationHandlers = null. }
false;public;2;24;;public Object createProxy(Errors errors, Class<?> expectedType) throws ErrorsException {     if (!expectedType.isInterface()) {         throw errors.cannotSatisfyCircularDependency(expectedType).toException().     }     if (invocationHandlers == null) {         invocationHandlers = new ArrayList<>().     }     DelegatingInvocationHandler<T> invocationHandler = new DelegatingInvocationHandler<>().     invocationHandlers.add(invocationHandler).     // ES: Replace, since we don't use bytecode gen, just get the type class loader, or system if its null     // ClassLoader classLoader = BytecodeGen.getClassLoader(expectedType).     ClassLoader classLoader = expectedType.getClassLoader() == null ? ClassLoader.getSystemClassLoader() : expectedType.getClassLoader().     return expectedType.cast(Proxy.newProxyInstance(classLoader, new Class[] { expectedType }, invocationHandler)). }
false;public;1;7;;public void setProxyDelegates(T delegate) {     if (invocationHandlers != null) {         for (DelegatingInvocationHandler<T> handler : invocationHandlers) {             handler.setDelegate(delegate).         }     } }
false;public;3;21;;@Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {     if (delegate == null) {         throw new IllegalStateException("This is a proxy used to support" + " circular references involving constructors. The object we're" + " proxying is not constructed yet. Please wait until after" + " injection has completed to use this object.").     }     try {         // This appears to be not test-covered         return method.invoke(delegate, args).     } catch (IllegalAccessException e) {         throw new RuntimeException(e).     } catch (IllegalArgumentException e) {         throw new RuntimeException(e).     } catch (InvocationTargetException e) {         throw e.getTargetException().     } }
false;;1;3;;void setDelegate(T delegate) {     this.delegate = delegate. }
