commented;modifiers;parameterAmount;loc;comment;code
false;public;1;7;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeBoolean(completed).     task.writeTo(out).     out.writeOptionalBytesReference(error).     out.writeOptionalBytesReference(response). }
true;public;0;3;/**  * Get the task that this wraps.  */ ;/**  * Get the task that this wraps.  */ public TaskInfo getTask() {     return task. }
true;public;0;3;/**  * Get the error that finished this task. Will return null if the task didn't finish with an error, it hasn't yet finished, or didn't  * store its result.  */ ;/**  * Get the error that finished this task. Will return null if the task didn't finish with an error, it hasn't yet finished, or didn't  * store its result.  */ public BytesReference getError() {     return error. }
true;public;0;6;/**  * Convert {@link #getError()} from XContent to a Map for easy processing. Will return an empty map if the task didn't finish with an  * error, hasn't yet finished, or didn't store its result.  */ ;/**  * Convert {@link #getError()} from XContent to a Map for easy processing. Will return an empty map if the task didn't finish with an  * error, hasn't yet finished, or didn't store its result.  */ public Map<String, Object> getErrorAsMap() {     if (error == null) {         return emptyMap().     }     return convertToMap(error, false).v2(). }
true;public;0;3;/**  * Get the response that this task finished with. Will return null if the task was finished by an error, it hasn't yet finished, or  * didn't store its result.  */ ;/**  * Get the response that this task finished with. Will return null if the task was finished by an error, it hasn't yet finished, or  * didn't store its result.  */ public BytesReference getResponse() {     return response. }
true;public;0;6;/**  * Convert {@link #getResponse()} from XContent to a Map for easy processing. Will return an empty map if the task was finished with an  * error, hasn't yet finished, or didn't store its result.  */ ;/**  * Convert {@link #getResponse()} from XContent to a Map for easy processing. Will return an empty map if the task was finished with an  * error, hasn't yet finished, or didn't store its result.  */ public Map<String, Object> getResponseAsMap() {     if (response == null) {         return emptyMap().     }     return convertToMap(response, false).v2(). }
false;public;0;3;;public boolean isCompleted() {     return completed. }
false;public;2;6;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     innerToXContent(builder, params).     return builder.endObject(). }
false;public;2;13;;public XContentBuilder innerToXContent(XContentBuilder builder, Params params) throws IOException {     builder.field("completed", completed).     builder.startObject("task").     task.toXContent(builder, params).     builder.endObject().     if (error != null) {         XContentHelper.writeRawField("error", error, builder, params).     }     if (response != null) {         XContentHelper.writeRawField("response", response, builder, params).     }     return builder. }
false;public;0;4;;@Override public String toString() {     return Strings.toString(this). }
true;public;1;15;// Implements equals and hashcode for testing ;// Implements equals and hashcode for testing @Override public boolean equals(Object obj) {     if (obj == null || obj.getClass() != TaskResult.class) {         return false.     }     TaskResult other = (TaskResult) obj.     /*          * Equality of error and result is done by converting them to a map first. Not efficient but ignores field order and spacing          * differences so perfect for testing.          */     return Objects.equals(completed, other.completed) && Objects.equals(task, other.task) && Objects.equals(getErrorAsMap(), other.getErrorAsMap()) && Objects.equals(getResponseAsMap(), other.getResponseAsMap()). }
false;public;0;8;;@Override public int hashCode() {     /*          * Hashing of error and result is done by converting them to a map first. Not efficient but ignores field order and spacing          * differences so perfect for testing.          */     return Objects.hash(completed, task, getErrorAsMap(), getResponseAsMap()). }
false;private,static;1;8;;private static BytesReference toXContent(Exception error) throws IOException {     try (XContentBuilder builder = XContentFactory.contentBuilder(Requests.INDEX_CONTENT_TYPE)) {         builder.startObject().         ElasticsearchException.generateThrowableXContent(builder, ToXContent.EMPTY_PARAMS, error).         builder.endObject().         return BytesReference.bytes(builder).     } }
