commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * The registry used to build new {@link XContentParser}s. Contains registered named parsers needed to parse the query.  */ ;/**  * The registry used to build new {@link XContentParser}s. Contains registered named parsers needed to parse the query.  */ public NamedXContentRegistry getXContentRegistry() {     return xContentRegistry. }
true;public;0;3;/**  * Returns the time in milliseconds that is shared across all resources involved. Even across shards and nodes.  */ ;/**  * Returns the time in milliseconds that is shared across all resources involved. Even across shards and nodes.  */ public long nowInMillis() {     return nowInMillis.getAsLong(). }
false;public;0;3;;public NamedWriteableRegistry getWriteableRegistry() {     return writeableRegistry. }
true;public;0;3;/**  * Returns an instance of {@link QueryShardContext} if available of null otherwise  */ ;/**  * Returns an instance of {@link QueryShardContext} if available of null otherwise  */ public QueryShardContext convertToShardContext() {     return null. }
true;public;1;3;/**  * Registers an async action that must be executed before the next rewrite round in order to make progress.  * This should be used if a rewriteabel needs to fetch some external resources in order to be executed ie. a document  * from an index.  */ ;/**  * Registers an async action that must be executed before the next rewrite round in order to make progress.  * This should be used if a rewriteabel needs to fetch some external resources in order to be executed ie. a document  * from an index.  */ public void registerAsyncAction(BiConsumer<Client, ActionListener<?>> asyncAction) {     asyncActions.add(asyncAction). }
true;public;0;3;/**  * Returns <code>true</code> if there are any registered async actions.  */ ;/**  * Returns <code>true</code> if there are any registered async actions.  */ public boolean hasAsyncActions() {     return asyncActions.isEmpty() == false. }
false;public;1;6;;@Override public void onResponse(Object o) {     if (countDown.countDown()) {         listener.onResponse(null).     } }
false;public;1;6;;@Override public void onFailure(Exception e) {     if (countDown.fastForward()) {         listener.onFailure(e).     } }
true;public;1;28;/**  * Executes all registered async actions and notifies the listener once it's done. The value that is passed to the listener is always  * <code>null</code>. The list of registered actions is cleared once this method returns.  */ ;/**  * Executes all registered async actions and notifies the listener once it's done. The value that is passed to the listener is always  * <code>null</code>. The list of registered actions is cleared once this method returns.  */ public void executeAsyncActions(ActionListener listener) {     if (asyncActions.isEmpty()) {         listener.onResponse(null).     } else {         CountDown countDown = new CountDown(asyncActions.size()).         ActionListener<?> internalListener = new ActionListener() {              @Override             public void onResponse(Object o) {                 if (countDown.countDown()) {                     listener.onResponse(null).                 }             }              @Override             public void onFailure(Exception e) {                 if (countDown.fastForward()) {                     listener.onFailure(e).                 }             }         }.         // make a copy to prevent concurrent modification exception         List<BiConsumer<Client, ActionListener<?>>> biConsumers = new ArrayList<>(asyncActions).         asyncActions.clear().         for (BiConsumer<Client, ActionListener<?>> action : biConsumers) {             action.accept(client, internalListener).         }     } }
true;public;0;3;/**  * In pre-processing contexts that happen at index time 'now' date ranges should be replaced by a {@link MatchAllQueryBuilder}.  * Otherwise documents that should match at query time would never match and the document that have fallen outside the  * date range would continue to match.  *  * @return indicates whether range queries with date ranges using 'now' are rewritten to a {@link MatchAllQueryBuilder}.  */ ;/**  * In pre-processing contexts that happen at index time 'now' date ranges should be replaced by a {@link MatchAllQueryBuilder}.  * Otherwise documents that should match at query time would never match and the document that have fallen outside the  * date range would continue to match.  *  * @return indicates whether range queries with date ranges using 'now' are rewritten to a {@link MatchAllQueryBuilder}.  */ public boolean convertNowRangeToMatchAll() {     return false. }
