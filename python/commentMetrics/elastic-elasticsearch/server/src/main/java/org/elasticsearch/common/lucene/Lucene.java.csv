# id;timestamp;commentText;codeText;commentWords;codeWords
Lucene -> public static void scanSeqNosInReader(DirectoryReader directoryReader, long fromSeqNo, long toSeqNo,                                           LongConsumer onNewSeqNo) throws IOException;1540238977;Scans sequence numbers (i.e., {@link SeqNoFieldMapper#NAME}) between {@code fromSeqNo}(inclusive) and {@code toSeqNo}(inclusive)_in the provided directory reader. This method invokes the callback {@code onNewSeqNo} whenever a sequence number value is found.__@param directoryReader the directory reader to scan_@param fromSeqNo       the lower bound of a range of seq_no to scan (inclusive)_@param toSeqNo         the upper bound of a range of seq_no to scan (inclusive)_@param onNewSeqNo      the callback to be called whenever a new valid sequence number is found;public static void scanSeqNosInReader(DirectoryReader directoryReader, long fromSeqNo, long toSeqNo,_                                          LongConsumer onNewSeqNo) throws IOException {_        final DirectoryReader reader = Lucene.wrapAllDocsLive(directoryReader)__        final IndexSearcher searcher = new IndexSearcher(reader)__        searcher.setQueryCache(null)__        final Query query = LongPoint.newRangeQuery(SeqNoFieldMapper.NAME, fromSeqNo, toSeqNo)__        final Weight weight = searcher.createWeight(query, ScoreMode.COMPLETE_NO_SCORES, 1.0f)__        for (LeafReaderContext leaf : reader.leaves()) {_            final Scorer scorer = weight.scorer(leaf)__            if (scorer == null) {_                continue__            }_            final DocIdSetIterator docIdSetIterator = scorer.iterator()__            final NumericDocValues seqNoDocValues = leaf.reader().getNumericDocValues(SeqNoFieldMapper.NAME)__            int docId__            while ((docId = docIdSetIterator.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {_                if (seqNoDocValues == null || seqNoDocValues.advanceExact(docId) == false) {_                    throw new IllegalStateException("seq_no doc_values not found for doc_id=" + docId)__                }_                final long seqNo = seqNoDocValues.longValue()__                assert fromSeqNo <= seqNo && seqNo <= toSeqNo : "from_seq_no=" + fromSeqNo + " seq_no=" + seqNo + " to_seq_no=" + toSeqNo__                onNewSeqNo.accept(seqNo)__            }_        }_    };scans,sequence,numbers,i,e,link,seq,no,field,mapper,name,between,code,from,seq,no,inclusive,and,code,to,seq,no,inclusive,in,the,provided,directory,reader,this,method,invokes,the,callback,code,on,new,seq,no,whenever,a,sequence,number,value,is,found,param,directory,reader,the,directory,reader,to,scan,param,from,seq,no,the,lower,bound,of,a,range,of,to,scan,inclusive,param,to,seq,no,the,upper,bound,of,a,range,of,to,scan,inclusive,param,on,new,seq,no,the,callback,to,be,called,whenever,a,new,valid,sequence,number,is,found;public,static,void,scan,seq,nos,in,reader,directory,reader,directory,reader,long,from,seq,no,long,to,seq,no,long,consumer,on,new,seq,no,throws,ioexception,final,directory,reader,reader,lucene,wrap,all,docs,live,directory,reader,final,index,searcher,searcher,new,index,searcher,reader,searcher,set,query,cache,null,final,query,query,long,point,new,range,query,seq,no,field,mapper,name,from,seq,no,to,seq,no,final,weight,weight,searcher,create,weight,query,score,mode,1,0f,for,leaf,reader,context,leaf,reader,leaves,final,scorer,scorer,weight,scorer,leaf,if,scorer,null,continue,final,doc,id,set,iterator,doc,id,set,iterator,scorer,iterator,final,numeric,doc,values,seq,no,doc,values,leaf,reader,get,numeric,doc,values,seq,no,field,mapper,name,int,doc,id,while,doc,id,doc,id,set,iterator,next,doc,doc,id,set,iterator,if,seq,no,doc,values,null,seq,no,doc,values,advance,exact,doc,id,false,throw,new,illegal,state,exception,not,found,for,doc,id,final,long,seq,no,seq,no,doc,values,long,value,assert,from,seq,no,seq,no,seq,no,to,seq,no,from,seq,no,seq,no,to,seq,no,on,new,seq,no,accept,seq,no
Lucene -> public static void scanSeqNosInReader(DirectoryReader directoryReader, long fromSeqNo, long toSeqNo,                                           LongConsumer onNewSeqNo) throws IOException;1541592065;Scans sequence numbers (i.e., {@link SeqNoFieldMapper#NAME}) between {@code fromSeqNo}(inclusive) and {@code toSeqNo}(inclusive)_in the provided directory reader. This method invokes the callback {@code onNewSeqNo} whenever a sequence number value is found.__@param directoryReader the directory reader to scan_@param fromSeqNo       the lower bound of a range of seq_no to scan (inclusive)_@param toSeqNo         the upper bound of a range of seq_no to scan (inclusive)_@param onNewSeqNo      the callback to be called whenever a new valid sequence number is found;public static void scanSeqNosInReader(DirectoryReader directoryReader, long fromSeqNo, long toSeqNo,_                                          LongConsumer onNewSeqNo) throws IOException {_        final DirectoryReader reader = Lucene.wrapAllDocsLive(directoryReader)__        final IndexSearcher searcher = new IndexSearcher(reader)__        searcher.setQueryCache(null)__        final Query query = LongPoint.newRangeQuery(SeqNoFieldMapper.NAME, fromSeqNo, toSeqNo)__        final Weight weight = searcher.createWeight(query, ScoreMode.COMPLETE_NO_SCORES, 1.0f)__        for (LeafReaderContext leaf : reader.leaves()) {_            final Scorer scorer = weight.scorer(leaf)__            if (scorer == null) {_                continue__            }_            final DocIdSetIterator docIdSetIterator = scorer.iterator()__            final NumericDocValues seqNoDocValues = leaf.reader().getNumericDocValues(SeqNoFieldMapper.NAME)__            int docId__            while ((docId = docIdSetIterator.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {_                if (seqNoDocValues == null || seqNoDocValues.advanceExact(docId) == false) {_                    throw new IllegalStateException("seq_no doc_values not found for doc_id=" + docId)__                }_                final long seqNo = seqNoDocValues.longValue()__                assert fromSeqNo <= seqNo && seqNo <= toSeqNo : "from_seq_no=" + fromSeqNo + " seq_no=" + seqNo + " to_seq_no=" + toSeqNo__                onNewSeqNo.accept(seqNo)__            }_        }_    };scans,sequence,numbers,i,e,link,seq,no,field,mapper,name,between,code,from,seq,no,inclusive,and,code,to,seq,no,inclusive,in,the,provided,directory,reader,this,method,invokes,the,callback,code,on,new,seq,no,whenever,a,sequence,number,value,is,found,param,directory,reader,the,directory,reader,to,scan,param,from,seq,no,the,lower,bound,of,a,range,of,to,scan,inclusive,param,to,seq,no,the,upper,bound,of,a,range,of,to,scan,inclusive,param,on,new,seq,no,the,callback,to,be,called,whenever,a,new,valid,sequence,number,is,found;public,static,void,scan,seq,nos,in,reader,directory,reader,directory,reader,long,from,seq,no,long,to,seq,no,long,consumer,on,new,seq,no,throws,ioexception,final,directory,reader,reader,lucene,wrap,all,docs,live,directory,reader,final,index,searcher,searcher,new,index,searcher,reader,searcher,set,query,cache,null,final,query,query,long,point,new,range,query,seq,no,field,mapper,name,from,seq,no,to,seq,no,final,weight,weight,searcher,create,weight,query,score,mode,1,0f,for,leaf,reader,context,leaf,reader,leaves,final,scorer,scorer,weight,scorer,leaf,if,scorer,null,continue,final,doc,id,set,iterator,doc,id,set,iterator,scorer,iterator,final,numeric,doc,values,seq,no,doc,values,leaf,reader,get,numeric,doc,values,seq,no,field,mapper,name,int,doc,id,while,doc,id,doc,id,set,iterator,next,doc,doc,id,set,iterator,if,seq,no,doc,values,null,seq,no,doc,values,advance,exact,doc,id,false,throw,new,illegal,state,exception,not,found,for,doc,id,final,long,seq,no,seq,no,doc,values,long,value,assert,from,seq,no,seq,no,seq,no,to,seq,no,from,seq,no,seq,no,to,seq,no,on,new,seq,no,accept,seq,no
Lucene -> public static void scanSeqNosInReader(DirectoryReader directoryReader, long fromSeqNo, long toSeqNo,                                           LongConsumer onNewSeqNo) throws IOException;1541618615;Scans sequence numbers (i.e., {@link SeqNoFieldMapper#NAME}) between {@code fromSeqNo}(inclusive) and {@code toSeqNo}(inclusive)_in the provided directory reader. This method invokes the callback {@code onNewSeqNo} whenever a sequence number value is found.__@param directoryReader the directory reader to scan_@param fromSeqNo       the lower bound of a range of seq_no to scan (inclusive)_@param toSeqNo         the upper bound of a range of seq_no to scan (inclusive)_@param onNewSeqNo      the callback to be called whenever a new valid sequence number is found;public static void scanSeqNosInReader(DirectoryReader directoryReader, long fromSeqNo, long toSeqNo,_                                          LongConsumer onNewSeqNo) throws IOException {_        final DirectoryReader reader = Lucene.wrapAllDocsLive(directoryReader)__        final IndexSearcher searcher = new IndexSearcher(reader)__        searcher.setQueryCache(null)__        final Query query = LongPoint.newRangeQuery(SeqNoFieldMapper.NAME, fromSeqNo, toSeqNo)__        final Weight weight = searcher.createWeight(query, ScoreMode.COMPLETE_NO_SCORES, 1.0f)__        for (LeafReaderContext leaf : reader.leaves()) {_            final Scorer scorer = weight.scorer(leaf)__            if (scorer == null) {_                continue__            }_            final DocIdSetIterator docIdSetIterator = scorer.iterator()__            final NumericDocValues seqNoDocValues = leaf.reader().getNumericDocValues(SeqNoFieldMapper.NAME)__            int docId__            while ((docId = docIdSetIterator.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {_                if (seqNoDocValues == null || seqNoDocValues.advanceExact(docId) == false) {_                    throw new IllegalStateException("seq_no doc_values not found for doc_id=" + docId)__                }_                final long seqNo = seqNoDocValues.longValue()__                assert fromSeqNo <= seqNo && seqNo <= toSeqNo : "from_seq_no=" + fromSeqNo + " seq_no=" + seqNo + " to_seq_no=" + toSeqNo__                onNewSeqNo.accept(seqNo)__            }_        }_    };scans,sequence,numbers,i,e,link,seq,no,field,mapper,name,between,code,from,seq,no,inclusive,and,code,to,seq,no,inclusive,in,the,provided,directory,reader,this,method,invokes,the,callback,code,on,new,seq,no,whenever,a,sequence,number,value,is,found,param,directory,reader,the,directory,reader,to,scan,param,from,seq,no,the,lower,bound,of,a,range,of,to,scan,inclusive,param,to,seq,no,the,upper,bound,of,a,range,of,to,scan,inclusive,param,on,new,seq,no,the,callback,to,be,called,whenever,a,new,valid,sequence,number,is,found;public,static,void,scan,seq,nos,in,reader,directory,reader,directory,reader,long,from,seq,no,long,to,seq,no,long,consumer,on,new,seq,no,throws,ioexception,final,directory,reader,reader,lucene,wrap,all,docs,live,directory,reader,final,index,searcher,searcher,new,index,searcher,reader,searcher,set,query,cache,null,final,query,query,long,point,new,range,query,seq,no,field,mapper,name,from,seq,no,to,seq,no,final,weight,weight,searcher,create,weight,query,score,mode,1,0f,for,leaf,reader,context,leaf,reader,leaves,final,scorer,scorer,weight,scorer,leaf,if,scorer,null,continue,final,doc,id,set,iterator,doc,id,set,iterator,scorer,iterator,final,numeric,doc,values,seq,no,doc,values,leaf,reader,get,numeric,doc,values,seq,no,field,mapper,name,int,doc,id,while,doc,id,doc,id,set,iterator,next,doc,doc,id,set,iterator,if,seq,no,doc,values,null,seq,no,doc,values,advance,exact,doc,id,false,throw,new,illegal,state,exception,not,found,for,doc,id,final,long,seq,no,seq,no,doc,values,long,value,assert,from,seq,no,seq,no,seq,no,to,seq,no,from,seq,no,seq,no,to,seq,no,on,new,seq,no,accept,seq,no
Lucene -> public static void scanSeqNosInReader(DirectoryReader directoryReader, long fromSeqNo, long toSeqNo,                                           LongConsumer onNewSeqNo) throws IOException;1544076142;Scans sequence numbers (i.e., {@link SeqNoFieldMapper#NAME}) between {@code fromSeqNo}(inclusive) and {@code toSeqNo}(inclusive)_in the provided directory reader. This method invokes the callback {@code onNewSeqNo} whenever a sequence number value is found.__@param directoryReader the directory reader to scan_@param fromSeqNo       the lower bound of a range of seq_no to scan (inclusive)_@param toSeqNo         the upper bound of a range of seq_no to scan (inclusive)_@param onNewSeqNo      the callback to be called whenever a new valid sequence number is found;public static void scanSeqNosInReader(DirectoryReader directoryReader, long fromSeqNo, long toSeqNo,_                                          LongConsumer onNewSeqNo) throws IOException {_        final DirectoryReader reader = Lucene.wrapAllDocsLive(directoryReader)__        final IndexSearcher searcher = new IndexSearcher(reader)__        searcher.setQueryCache(null)__        final Query query = LongPoint.newRangeQuery(SeqNoFieldMapper.NAME, fromSeqNo, toSeqNo)__        final Weight weight = searcher.createWeight(query, ScoreMode.COMPLETE_NO_SCORES, 1.0f)__        for (LeafReaderContext leaf : reader.leaves()) {_            final Scorer scorer = weight.scorer(leaf)__            if (scorer == null) {_                continue__            }_            final DocIdSetIterator docIdSetIterator = scorer.iterator()__            final NumericDocValues seqNoDocValues = leaf.reader().getNumericDocValues(SeqNoFieldMapper.NAME)__            int docId__            while ((docId = docIdSetIterator.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {_                if (seqNoDocValues == null || seqNoDocValues.advanceExact(docId) == false) {_                    throw new IllegalStateException("seq_no doc_values not found for doc_id=" + docId)__                }_                final long seqNo = seqNoDocValues.longValue()__                assert fromSeqNo <= seqNo && seqNo <= toSeqNo : "from_seq_no=" + fromSeqNo + " seq_no=" + seqNo + " to_seq_no=" + toSeqNo__                onNewSeqNo.accept(seqNo)__            }_        }_    };scans,sequence,numbers,i,e,link,seq,no,field,mapper,name,between,code,from,seq,no,inclusive,and,code,to,seq,no,inclusive,in,the,provided,directory,reader,this,method,invokes,the,callback,code,on,new,seq,no,whenever,a,sequence,number,value,is,found,param,directory,reader,the,directory,reader,to,scan,param,from,seq,no,the,lower,bound,of,a,range,of,to,scan,inclusive,param,to,seq,no,the,upper,bound,of,a,range,of,to,scan,inclusive,param,on,new,seq,no,the,callback,to,be,called,whenever,a,new,valid,sequence,number,is,found;public,static,void,scan,seq,nos,in,reader,directory,reader,directory,reader,long,from,seq,no,long,to,seq,no,long,consumer,on,new,seq,no,throws,ioexception,final,directory,reader,reader,lucene,wrap,all,docs,live,directory,reader,final,index,searcher,searcher,new,index,searcher,reader,searcher,set,query,cache,null,final,query,query,long,point,new,range,query,seq,no,field,mapper,name,from,seq,no,to,seq,no,final,weight,weight,searcher,create,weight,query,score,mode,1,0f,for,leaf,reader,context,leaf,reader,leaves,final,scorer,scorer,weight,scorer,leaf,if,scorer,null,continue,final,doc,id,set,iterator,doc,id,set,iterator,scorer,iterator,final,numeric,doc,values,seq,no,doc,values,leaf,reader,get,numeric,doc,values,seq,no,field,mapper,name,int,doc,id,while,doc,id,doc,id,set,iterator,next,doc,doc,id,set,iterator,if,seq,no,doc,values,null,seq,no,doc,values,advance,exact,doc,id,false,throw,new,illegal,state,exception,not,found,for,doc,id,final,long,seq,no,seq,no,doc,values,long,value,assert,from,seq,no,seq,no,seq,no,to,seq,no,from,seq,no,seq,no,to,seq,no,on,new,seq,no,accept,seq,no
Lucene -> public static void scanSeqNosInReader(DirectoryReader directoryReader, long fromSeqNo, long toSeqNo,                                           LongConsumer onNewSeqNo) throws IOException;1544322276;Scans sequence numbers (i.e., {@link SeqNoFieldMapper#NAME}) between {@code fromSeqNo}(inclusive) and {@code toSeqNo}(inclusive)_in the provided directory reader. This method invokes the callback {@code onNewSeqNo} whenever a sequence number value is found.__@param directoryReader the directory reader to scan_@param fromSeqNo       the lower bound of a range of seq_no to scan (inclusive)_@param toSeqNo         the upper bound of a range of seq_no to scan (inclusive)_@param onNewSeqNo      the callback to be called whenever a new valid sequence number is found;public static void scanSeqNosInReader(DirectoryReader directoryReader, long fromSeqNo, long toSeqNo,_                                          LongConsumer onNewSeqNo) throws IOException {_        final DirectoryReader reader = Lucene.wrapAllDocsLive(directoryReader)__        final IndexSearcher searcher = new IndexSearcher(reader)__        searcher.setQueryCache(null)__        final Query query = LongPoint.newRangeQuery(SeqNoFieldMapper.NAME, fromSeqNo, toSeqNo)__        final Weight weight = searcher.createWeight(query, ScoreMode.COMPLETE_NO_SCORES, 1.0f)__        for (LeafReaderContext leaf : reader.leaves()) {_            final Scorer scorer = weight.scorer(leaf)__            if (scorer == null) {_                continue__            }_            final DocIdSetIterator docIdSetIterator = scorer.iterator()__            final NumericDocValues seqNoDocValues = leaf.reader().getNumericDocValues(SeqNoFieldMapper.NAME)__            int docId__            while ((docId = docIdSetIterator.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {_                if (seqNoDocValues == null || seqNoDocValues.advanceExact(docId) == false) {_                    throw new IllegalStateException("seq_no doc_values not found for doc_id=" + docId)__                }_                final long seqNo = seqNoDocValues.longValue()__                assert fromSeqNo <= seqNo && seqNo <= toSeqNo : "from_seq_no=" + fromSeqNo + " seq_no=" + seqNo + " to_seq_no=" + toSeqNo__                onNewSeqNo.accept(seqNo)__            }_        }_    };scans,sequence,numbers,i,e,link,seq,no,field,mapper,name,between,code,from,seq,no,inclusive,and,code,to,seq,no,inclusive,in,the,provided,directory,reader,this,method,invokes,the,callback,code,on,new,seq,no,whenever,a,sequence,number,value,is,found,param,directory,reader,the,directory,reader,to,scan,param,from,seq,no,the,lower,bound,of,a,range,of,to,scan,inclusive,param,to,seq,no,the,upper,bound,of,a,range,of,to,scan,inclusive,param,on,new,seq,no,the,callback,to,be,called,whenever,a,new,valid,sequence,number,is,found;public,static,void,scan,seq,nos,in,reader,directory,reader,directory,reader,long,from,seq,no,long,to,seq,no,long,consumer,on,new,seq,no,throws,ioexception,final,directory,reader,reader,lucene,wrap,all,docs,live,directory,reader,final,index,searcher,searcher,new,index,searcher,reader,searcher,set,query,cache,null,final,query,query,long,point,new,range,query,seq,no,field,mapper,name,from,seq,no,to,seq,no,final,weight,weight,searcher,create,weight,query,score,mode,1,0f,for,leaf,reader,context,leaf,reader,leaves,final,scorer,scorer,weight,scorer,leaf,if,scorer,null,continue,final,doc,id,set,iterator,doc,id,set,iterator,scorer,iterator,final,numeric,doc,values,seq,no,doc,values,leaf,reader,get,numeric,doc,values,seq,no,field,mapper,name,int,doc,id,while,doc,id,doc,id,set,iterator,next,doc,doc,id,set,iterator,if,seq,no,doc,values,null,seq,no,doc,values,advance,exact,doc,id,false,throw,new,illegal,state,exception,not,found,for,doc,id,final,long,seq,no,seq,no,doc,values,long,value,assert,from,seq,no,seq,no,seq,no,to,seq,no,from,seq,no,seq,no,to,seq,no,on,new,seq,no,accept,seq,no
Lucene -> public static void scanSeqNosInReader(DirectoryReader directoryReader, long fromSeqNo, long toSeqNo,                                           LongConsumer onNewSeqNo) throws IOException;1544786574;Scans sequence numbers (i.e., {@link SeqNoFieldMapper#NAME}) between {@code fromSeqNo}(inclusive) and {@code toSeqNo}(inclusive)_in the provided directory reader. This method invokes the callback {@code onNewSeqNo} whenever a sequence number value is found.__@param directoryReader the directory reader to scan_@param fromSeqNo       the lower bound of a range of seq_no to scan (inclusive)_@param toSeqNo         the upper bound of a range of seq_no to scan (inclusive)_@param onNewSeqNo      the callback to be called whenever a new valid sequence number is found;public static void scanSeqNosInReader(DirectoryReader directoryReader, long fromSeqNo, long toSeqNo,_                                          LongConsumer onNewSeqNo) throws IOException {_        final DirectoryReader reader = Lucene.wrapAllDocsLive(directoryReader)__        final IndexSearcher searcher = new IndexSearcher(reader)__        searcher.setQueryCache(null)__        final Query query = LongPoint.newRangeQuery(SeqNoFieldMapper.NAME, fromSeqNo, toSeqNo)__        final Weight weight = searcher.createWeight(query, ScoreMode.COMPLETE_NO_SCORES, 1.0f)__        for (LeafReaderContext leaf : reader.leaves()) {_            final Scorer scorer = weight.scorer(leaf)__            if (scorer == null) {_                continue__            }_            final DocIdSetIterator docIdSetIterator = scorer.iterator()__            final NumericDocValues seqNoDocValues = leaf.reader().getNumericDocValues(SeqNoFieldMapper.NAME)__            int docId__            while ((docId = docIdSetIterator.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {_                if (seqNoDocValues == null || seqNoDocValues.advanceExact(docId) == false) {_                    throw new IllegalStateException("seq_no doc_values not found for doc_id=" + docId)__                }_                final long seqNo = seqNoDocValues.longValue()__                assert fromSeqNo <= seqNo && seqNo <= toSeqNo : "from_seq_no=" + fromSeqNo + " seq_no=" + seqNo + " to_seq_no=" + toSeqNo__                onNewSeqNo.accept(seqNo)__            }_        }_    };scans,sequence,numbers,i,e,link,seq,no,field,mapper,name,between,code,from,seq,no,inclusive,and,code,to,seq,no,inclusive,in,the,provided,directory,reader,this,method,invokes,the,callback,code,on,new,seq,no,whenever,a,sequence,number,value,is,found,param,directory,reader,the,directory,reader,to,scan,param,from,seq,no,the,lower,bound,of,a,range,of,to,scan,inclusive,param,to,seq,no,the,upper,bound,of,a,range,of,to,scan,inclusive,param,on,new,seq,no,the,callback,to,be,called,whenever,a,new,valid,sequence,number,is,found;public,static,void,scan,seq,nos,in,reader,directory,reader,directory,reader,long,from,seq,no,long,to,seq,no,long,consumer,on,new,seq,no,throws,ioexception,final,directory,reader,reader,lucene,wrap,all,docs,live,directory,reader,final,index,searcher,searcher,new,index,searcher,reader,searcher,set,query,cache,null,final,query,query,long,point,new,range,query,seq,no,field,mapper,name,from,seq,no,to,seq,no,final,weight,weight,searcher,create,weight,query,score,mode,1,0f,for,leaf,reader,context,leaf,reader,leaves,final,scorer,scorer,weight,scorer,leaf,if,scorer,null,continue,final,doc,id,set,iterator,doc,id,set,iterator,scorer,iterator,final,numeric,doc,values,seq,no,doc,values,leaf,reader,get,numeric,doc,values,seq,no,field,mapper,name,int,doc,id,while,doc,id,doc,id,set,iterator,next,doc,doc,id,set,iterator,if,seq,no,doc,values,null,seq,no,doc,values,advance,exact,doc,id,false,throw,new,illegal,state,exception,not,found,for,doc,id,final,long,seq,no,seq,no,doc,values,long,value,assert,from,seq,no,seq,no,seq,no,to,seq,no,from,seq,no,seq,no,to,seq,no,on,new,seq,no,accept,seq,no
Lucene -> public static boolean exists(IndexSearcher searcher, Query query) throws IOException;1524684173;Check whether there is one or more documents matching the provided query.;public static boolean exists(IndexSearcher searcher, Query query) throws IOException {_        final Weight weight = searcher.createNormalizedWeight(query, false)__        _        _        for (LeafReaderContext context : searcher.getIndexReader().leaves()) {_            final Scorer scorer = weight.scorer(context)__            if (scorer == null) {_                continue__            }_            final Bits liveDocs = context.reader().getLiveDocs()__            final DocIdSetIterator iterator = scorer.iterator()__            for (int doc = iterator.nextDoc()_ doc != DocIdSetIterator.NO_MORE_DOCS_ doc = iterator.nextDoc()) {_                if (liveDocs == null || liveDocs.get(doc)) {_                    return true__                }_            }_        }_        return false__    };check,whether,there,is,one,or,more,documents,matching,the,provided,query;public,static,boolean,exists,index,searcher,searcher,query,query,throws,ioexception,final,weight,weight,searcher,create,normalized,weight,query,false,for,leaf,reader,context,context,searcher,get,index,reader,leaves,final,scorer,scorer,weight,scorer,context,if,scorer,null,continue,final,bits,live,docs,context,reader,get,live,docs,final,doc,id,set,iterator,iterator,scorer,iterator,for,int,doc,iterator,next,doc,doc,doc,id,set,iterator,doc,iterator,next,doc,if,live,docs,null,live,docs,get,doc,return,true,return,false
Lucene -> public static boolean exists(IndexSearcher searcher, Query query) throws IOException;1525334055;Check whether there is one or more documents matching the provided query.;public static boolean exists(IndexSearcher searcher, Query query) throws IOException {_        final Weight weight = searcher.createNormalizedWeight(query, false)__        _        _        for (LeafReaderContext context : searcher.getIndexReader().leaves()) {_            final Scorer scorer = weight.scorer(context)__            if (scorer == null) {_                continue__            }_            final Bits liveDocs = context.reader().getLiveDocs()__            final DocIdSetIterator iterator = scorer.iterator()__            for (int doc = iterator.nextDoc()_ doc != DocIdSetIterator.NO_MORE_DOCS_ doc = iterator.nextDoc()) {_                if (liveDocs == null || liveDocs.get(doc)) {_                    return true__                }_            }_        }_        return false__    };check,whether,there,is,one,or,more,documents,matching,the,provided,query;public,static,boolean,exists,index,searcher,searcher,query,query,throws,ioexception,final,weight,weight,searcher,create,normalized,weight,query,false,for,leaf,reader,context,context,searcher,get,index,reader,leaves,final,scorer,scorer,weight,scorer,context,if,scorer,null,continue,final,bits,live,docs,context,reader,get,live,docs,final,doc,id,set,iterator,iterator,scorer,iterator,for,int,doc,iterator,next,doc,doc,doc,id,set,iterator,doc,iterator,next,doc,if,live,docs,null,live,docs,get,doc,return,true,return,false
Lucene -> public static boolean exists(IndexSearcher searcher, Query query) throws IOException;1535046779;Check whether there is one or more documents matching the provided query.;public static boolean exists(IndexSearcher searcher, Query query) throws IOException {_        final Weight weight = searcher.createNormalizedWeight(query, false)__        _        _        for (LeafReaderContext context : searcher.getIndexReader().leaves()) {_            final Scorer scorer = weight.scorer(context)__            if (scorer == null) {_                continue__            }_            final Bits liveDocs = context.reader().getLiveDocs()__            final DocIdSetIterator iterator = scorer.iterator()__            for (int doc = iterator.nextDoc()_ doc != DocIdSetIterator.NO_MORE_DOCS_ doc = iterator.nextDoc()) {_                if (liveDocs == null || liveDocs.get(doc)) {_                    return true__                }_            }_        }_        return false__    };check,whether,there,is,one,or,more,documents,matching,the,provided,query;public,static,boolean,exists,index,searcher,searcher,query,query,throws,ioexception,final,weight,weight,searcher,create,normalized,weight,query,false,for,leaf,reader,context,context,searcher,get,index,reader,leaves,final,scorer,scorer,weight,scorer,context,if,scorer,null,continue,final,bits,live,docs,context,reader,get,live,docs,final,doc,id,set,iterator,iterator,scorer,iterator,for,int,doc,iterator,next,doc,doc,doc,id,set,iterator,doc,iterator,next,doc,if,live,docs,null,live,docs,get,doc,return,true,return,false
Lucene -> public static boolean exists(IndexSearcher searcher, Query query) throws IOException;1535723122;Check whether there is one or more documents matching the provided query.;public static boolean exists(IndexSearcher searcher, Query query) throws IOException {_        final Weight weight = searcher.createNormalizedWeight(query, false)__        _        _        for (LeafReaderContext context : searcher.getIndexReader().leaves()) {_            final Scorer scorer = weight.scorer(context)__            if (scorer == null) {_                continue__            }_            final Bits liveDocs = context.reader().getLiveDocs()__            final DocIdSetIterator iterator = scorer.iterator()__            for (int doc = iterator.nextDoc()_ doc != DocIdSetIterator.NO_MORE_DOCS_ doc = iterator.nextDoc()) {_                if (liveDocs == null || liveDocs.get(doc)) {_                    return true__                }_            }_        }_        return false__    };check,whether,there,is,one,or,more,documents,matching,the,provided,query;public,static,boolean,exists,index,searcher,searcher,query,query,throws,ioexception,final,weight,weight,searcher,create,normalized,weight,query,false,for,leaf,reader,context,context,searcher,get,index,reader,leaves,final,scorer,scorer,weight,scorer,context,if,scorer,null,continue,final,bits,live,docs,context,reader,get,live,docs,final,doc,id,set,iterator,iterator,scorer,iterator,for,int,doc,iterator,next,doc,doc,doc,id,set,iterator,doc,iterator,next,doc,if,live,docs,null,live,docs,get,doc,return,true,return,false
Lucene -> public static boolean exists(IndexSearcher searcher, Query query) throws IOException;1536314350;Check whether there is one or more documents matching the provided query.;public static boolean exists(IndexSearcher searcher, Query query) throws IOException {_        final Weight weight = searcher.createWeight(searcher.rewrite(query), ScoreMode.COMPLETE_NO_SCORES, 1f)__        _        _        for (LeafReaderContext context : searcher.getIndexReader().leaves()) {_            final Scorer scorer = weight.scorer(context)__            if (scorer == null) {_                continue__            }_            final Bits liveDocs = context.reader().getLiveDocs()__            final DocIdSetIterator iterator = scorer.iterator()__            for (int doc = iterator.nextDoc()_ doc != DocIdSetIterator.NO_MORE_DOCS_ doc = iterator.nextDoc()) {_                if (liveDocs == null || liveDocs.get(doc)) {_                    return true__                }_            }_        }_        return false__    };check,whether,there,is,one,or,more,documents,matching,the,provided,query;public,static,boolean,exists,index,searcher,searcher,query,query,throws,ioexception,final,weight,weight,searcher,create,weight,searcher,rewrite,query,score,mode,1f,for,leaf,reader,context,context,searcher,get,index,reader,leaves,final,scorer,scorer,weight,scorer,context,if,scorer,null,continue,final,bits,live,docs,context,reader,get,live,docs,final,doc,id,set,iterator,iterator,scorer,iterator,for,int,doc,iterator,next,doc,doc,doc,id,set,iterator,doc,iterator,next,doc,if,live,docs,null,live,docs,get,doc,return,true,return,false
Lucene -> public static boolean exists(IndexSearcher searcher, Query query) throws IOException;1536611444;Check whether there is one or more documents matching the provided query.;public static boolean exists(IndexSearcher searcher, Query query) throws IOException {_        final Weight weight = searcher.createWeight(searcher.rewrite(query), ScoreMode.COMPLETE_NO_SCORES, 1f)__        _        _        for (LeafReaderContext context : searcher.getIndexReader().leaves()) {_            final Scorer scorer = weight.scorer(context)__            if (scorer == null) {_                continue__            }_            final Bits liveDocs = context.reader().getLiveDocs()__            final DocIdSetIterator iterator = scorer.iterator()__            for (int doc = iterator.nextDoc()_ doc != DocIdSetIterator.NO_MORE_DOCS_ doc = iterator.nextDoc()) {_                if (liveDocs == null || liveDocs.get(doc)) {_                    return true__                }_            }_        }_        return false__    };check,whether,there,is,one,or,more,documents,matching,the,provided,query;public,static,boolean,exists,index,searcher,searcher,query,query,throws,ioexception,final,weight,weight,searcher,create,weight,searcher,rewrite,query,score,mode,1f,for,leaf,reader,context,context,searcher,get,index,reader,leaves,final,scorer,scorer,weight,scorer,context,if,scorer,null,continue,final,bits,live,docs,context,reader,get,live,docs,final,doc,id,set,iterator,iterator,scorer,iterator,for,int,doc,iterator,next,doc,doc,doc,id,set,iterator,doc,iterator,next,doc,if,live,docs,null,live,docs,get,doc,return,true,return,false
Lucene -> public static boolean exists(IndexSearcher searcher, Query query) throws IOException;1537371806;Check whether there is one or more documents matching the provided query.;public static boolean exists(IndexSearcher searcher, Query query) throws IOException {_        final Weight weight = searcher.createWeight(searcher.rewrite(query), ScoreMode.COMPLETE_NO_SCORES, 1f)__        _        _        for (LeafReaderContext context : searcher.getIndexReader().leaves()) {_            final Scorer scorer = weight.scorer(context)__            if (scorer == null) {_                continue__            }_            final Bits liveDocs = context.reader().getLiveDocs()__            final DocIdSetIterator iterator = scorer.iterator()__            for (int doc = iterator.nextDoc()_ doc != DocIdSetIterator.NO_MORE_DOCS_ doc = iterator.nextDoc()) {_                if (liveDocs == null || liveDocs.get(doc)) {_                    return true__                }_            }_        }_        return false__    };check,whether,there,is,one,or,more,documents,matching,the,provided,query;public,static,boolean,exists,index,searcher,searcher,query,query,throws,ioexception,final,weight,weight,searcher,create,weight,searcher,rewrite,query,score,mode,1f,for,leaf,reader,context,context,searcher,get,index,reader,leaves,final,scorer,scorer,weight,scorer,context,if,scorer,null,continue,final,bits,live,docs,context,reader,get,live,docs,final,doc,id,set,iterator,iterator,scorer,iterator,for,int,doc,iterator,next,doc,doc,doc,id,set,iterator,doc,iterator,next,doc,if,live,docs,null,live,docs,get,doc,return,true,return,false
Lucene -> public static boolean exists(IndexSearcher searcher, Query query) throws IOException;1539815831;Check whether there is one or more documents matching the provided query.;public static boolean exists(IndexSearcher searcher, Query query) throws IOException {_        final Weight weight = searcher.createWeight(searcher.rewrite(query), ScoreMode.COMPLETE_NO_SCORES, 1f)__        _        _        for (LeafReaderContext context : searcher.getIndexReader().leaves()) {_            final Scorer scorer = weight.scorer(context)__            if (scorer == null) {_                continue__            }_            final Bits liveDocs = context.reader().getLiveDocs()__            final DocIdSetIterator iterator = scorer.iterator()__            for (int doc = iterator.nextDoc()_ doc != DocIdSetIterator.NO_MORE_DOCS_ doc = iterator.nextDoc()) {_                if (liveDocs == null || liveDocs.get(doc)) {_                    return true__                }_            }_        }_        return false__    };check,whether,there,is,one,or,more,documents,matching,the,provided,query;public,static,boolean,exists,index,searcher,searcher,query,query,throws,ioexception,final,weight,weight,searcher,create,weight,searcher,rewrite,query,score,mode,1f,for,leaf,reader,context,context,searcher,get,index,reader,leaves,final,scorer,scorer,weight,scorer,context,if,scorer,null,continue,final,bits,live,docs,context,reader,get,live,docs,final,doc,id,set,iterator,iterator,scorer,iterator,for,int,doc,iterator,next,doc,doc,doc,id,set,iterator,doc,iterator,next,doc,if,live,docs,null,live,docs,get,doc,return,true,return,false
Lucene -> public static boolean exists(IndexSearcher searcher, Query query) throws IOException;1540238977;Check whether there is one or more documents matching the provided query.;public static boolean exists(IndexSearcher searcher, Query query) throws IOException {_        final Weight weight = searcher.createWeight(searcher.rewrite(query), ScoreMode.COMPLETE_NO_SCORES, 1f)__        _        _        for (LeafReaderContext context : searcher.getIndexReader().leaves()) {_            final Scorer scorer = weight.scorer(context)__            if (scorer == null) {_                continue__            }_            final Bits liveDocs = context.reader().getLiveDocs()__            final DocIdSetIterator iterator = scorer.iterator()__            for (int doc = iterator.nextDoc()_ doc != DocIdSetIterator.NO_MORE_DOCS_ doc = iterator.nextDoc()) {_                if (liveDocs == null || liveDocs.get(doc)) {_                    return true__                }_            }_        }_        return false__    };check,whether,there,is,one,or,more,documents,matching,the,provided,query;public,static,boolean,exists,index,searcher,searcher,query,query,throws,ioexception,final,weight,weight,searcher,create,weight,searcher,rewrite,query,score,mode,1f,for,leaf,reader,context,context,searcher,get,index,reader,leaves,final,scorer,scorer,weight,scorer,context,if,scorer,null,continue,final,bits,live,docs,context,reader,get,live,docs,final,doc,id,set,iterator,iterator,scorer,iterator,for,int,doc,iterator,next,doc,doc,doc,id,set,iterator,doc,iterator,next,doc,if,live,docs,null,live,docs,get,doc,return,true,return,false
Lucene -> public static boolean exists(IndexSearcher searcher, Query query) throws IOException;1541592065;Check whether there is one or more documents matching the provided query.;public static boolean exists(IndexSearcher searcher, Query query) throws IOException {_        final Weight weight = searcher.createWeight(searcher.rewrite(query), ScoreMode.COMPLETE_NO_SCORES, 1f)__        _        _        for (LeafReaderContext context : searcher.getIndexReader().leaves()) {_            final Scorer scorer = weight.scorer(context)__            if (scorer == null) {_                continue__            }_            final Bits liveDocs = context.reader().getLiveDocs()__            final DocIdSetIterator iterator = scorer.iterator()__            for (int doc = iterator.nextDoc()_ doc != DocIdSetIterator.NO_MORE_DOCS_ doc = iterator.nextDoc()) {_                if (liveDocs == null || liveDocs.get(doc)) {_                    return true__                }_            }_        }_        return false__    };check,whether,there,is,one,or,more,documents,matching,the,provided,query;public,static,boolean,exists,index,searcher,searcher,query,query,throws,ioexception,final,weight,weight,searcher,create,weight,searcher,rewrite,query,score,mode,1f,for,leaf,reader,context,context,searcher,get,index,reader,leaves,final,scorer,scorer,weight,scorer,context,if,scorer,null,continue,final,bits,live,docs,context,reader,get,live,docs,final,doc,id,set,iterator,iterator,scorer,iterator,for,int,doc,iterator,next,doc,doc,doc,id,set,iterator,doc,iterator,next,doc,if,live,docs,null,live,docs,get,doc,return,true,return,false
Lucene -> public static boolean exists(IndexSearcher searcher, Query query) throws IOException;1541618615;Check whether there is one or more documents matching the provided query.;public static boolean exists(IndexSearcher searcher, Query query) throws IOException {_        final Weight weight = searcher.createWeight(searcher.rewrite(query), ScoreMode.COMPLETE_NO_SCORES, 1f)__        _        _        for (LeafReaderContext context : searcher.getIndexReader().leaves()) {_            final Scorer scorer = weight.scorer(context)__            if (scorer == null) {_                continue__            }_            final Bits liveDocs = context.reader().getLiveDocs()__            final DocIdSetIterator iterator = scorer.iterator()__            for (int doc = iterator.nextDoc()_ doc != DocIdSetIterator.NO_MORE_DOCS_ doc = iterator.nextDoc()) {_                if (liveDocs == null || liveDocs.get(doc)) {_                    return true__                }_            }_        }_        return false__    };check,whether,there,is,one,or,more,documents,matching,the,provided,query;public,static,boolean,exists,index,searcher,searcher,query,query,throws,ioexception,final,weight,weight,searcher,create,weight,searcher,rewrite,query,score,mode,1f,for,leaf,reader,context,context,searcher,get,index,reader,leaves,final,scorer,scorer,weight,scorer,context,if,scorer,null,continue,final,bits,live,docs,context,reader,get,live,docs,final,doc,id,set,iterator,iterator,scorer,iterator,for,int,doc,iterator,next,doc,doc,doc,id,set,iterator,doc,iterator,next,doc,if,live,docs,null,live,docs,get,doc,return,true,return,false
Lucene -> public static boolean exists(IndexSearcher searcher, Query query) throws IOException;1544076142;Check whether there is one or more documents matching the provided query.;public static boolean exists(IndexSearcher searcher, Query query) throws IOException {_        final Weight weight = searcher.createWeight(searcher.rewrite(query), ScoreMode.COMPLETE_NO_SCORES, 1f)__        _        _        for (LeafReaderContext context : searcher.getIndexReader().leaves()) {_            final Scorer scorer = weight.scorer(context)__            if (scorer == null) {_                continue__            }_            final Bits liveDocs = context.reader().getLiveDocs()__            final DocIdSetIterator iterator = scorer.iterator()__            for (int doc = iterator.nextDoc()_ doc != DocIdSetIterator.NO_MORE_DOCS_ doc = iterator.nextDoc()) {_                if (liveDocs == null || liveDocs.get(doc)) {_                    return true__                }_            }_        }_        return false__    };check,whether,there,is,one,or,more,documents,matching,the,provided,query;public,static,boolean,exists,index,searcher,searcher,query,query,throws,ioexception,final,weight,weight,searcher,create,weight,searcher,rewrite,query,score,mode,1f,for,leaf,reader,context,context,searcher,get,index,reader,leaves,final,scorer,scorer,weight,scorer,context,if,scorer,null,continue,final,bits,live,docs,context,reader,get,live,docs,final,doc,id,set,iterator,iterator,scorer,iterator,for,int,doc,iterator,next,doc,doc,doc,id,set,iterator,doc,iterator,next,doc,if,live,docs,null,live,docs,get,doc,return,true,return,false
Lucene -> public static boolean exists(IndexSearcher searcher, Query query) throws IOException;1544322276;Check whether there is one or more documents matching the provided query.;public static boolean exists(IndexSearcher searcher, Query query) throws IOException {_        final Weight weight = searcher.createWeight(searcher.rewrite(query), ScoreMode.COMPLETE_NO_SCORES, 1f)__        _        _        for (LeafReaderContext context : searcher.getIndexReader().leaves()) {_            final Scorer scorer = weight.scorer(context)__            if (scorer == null) {_                continue__            }_            final Bits liveDocs = context.reader().getLiveDocs()__            final DocIdSetIterator iterator = scorer.iterator()__            for (int doc = iterator.nextDoc()_ doc != DocIdSetIterator.NO_MORE_DOCS_ doc = iterator.nextDoc()) {_                if (liveDocs == null || liveDocs.get(doc)) {_                    return true__                }_            }_        }_        return false__    };check,whether,there,is,one,or,more,documents,matching,the,provided,query;public,static,boolean,exists,index,searcher,searcher,query,query,throws,ioexception,final,weight,weight,searcher,create,weight,searcher,rewrite,query,score,mode,1f,for,leaf,reader,context,context,searcher,get,index,reader,leaves,final,scorer,scorer,weight,scorer,context,if,scorer,null,continue,final,bits,live,docs,context,reader,get,live,docs,final,doc,id,set,iterator,iterator,scorer,iterator,for,int,doc,iterator,next,doc,doc,doc,id,set,iterator,doc,iterator,next,doc,if,live,docs,null,live,docs,get,doc,return,true,return,false
Lucene -> public static boolean exists(IndexSearcher searcher, Query query) throws IOException;1544786574;Check whether there is one or more documents matching the provided query.;public static boolean exists(IndexSearcher searcher, Query query) throws IOException {_        final Weight weight = searcher.createWeight(searcher.rewrite(query), ScoreMode.COMPLETE_NO_SCORES, 1f)__        _        _        for (LeafReaderContext context : searcher.getIndexReader().leaves()) {_            final Scorer scorer = weight.scorer(context)__            if (scorer == null) {_                continue__            }_            final Bits liveDocs = context.reader().getLiveDocs()__            final DocIdSetIterator iterator = scorer.iterator()__            for (int doc = iterator.nextDoc()_ doc != DocIdSetIterator.NO_MORE_DOCS_ doc = iterator.nextDoc()) {_                if (liveDocs == null || liveDocs.get(doc)) {_                    return true__                }_            }_        }_        return false__    };check,whether,there,is,one,or,more,documents,matching,the,provided,query;public,static,boolean,exists,index,searcher,searcher,query,query,throws,ioexception,final,weight,weight,searcher,create,weight,searcher,rewrite,query,score,mode,1f,for,leaf,reader,context,context,searcher,get,index,reader,leaves,final,scorer,scorer,weight,scorer,context,if,scorer,null,continue,final,bits,live,docs,context,reader,get,live,docs,final,doc,id,set,iterator,iterator,scorer,iterator,for,int,doc,iterator,next,doc,doc,doc,id,set,iterator,doc,iterator,next,doc,if,live,docs,null,live,docs,get,doc,return,true,return,false
Lucene -> public static SegmentInfos pruneUnreferencedFiles(String segmentsFileName, Directory directory) throws IOException;1524684173;This method removes all files from the given directory that are not referenced by the given segments file._This method will open an IndexWriter and relies on index file deleter to remove all unreferenced files. Segment files_that are newer than the given segments file are removed forcefully to prevent problems with IndexWriter opening a potentially_broken commit point / leftover._<b>Note:</b> this method will fail if there is another IndexWriter open on the given directory. This method will also acquire_a write lock from the directory while pruning unused files. This method expects an existing index in the given directory that has_the given segments file.;public static SegmentInfos pruneUnreferencedFiles(String segmentsFileName, Directory directory) throws IOException {_        final SegmentInfos si = readSegmentInfos(segmentsFileName, directory)__        try (Lock writeLock = directory.obtainLock(IndexWriter.WRITE_LOCK_NAME)) {_            int foundSegmentFiles = 0__            for (final String file : directory.listAll()) {_                _                if (file.startsWith(IndexFileNames.SEGMENTS) || file.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {_                    foundSegmentFiles++__                    if (file.equals(si.getSegmentsFileName()) == false) {_                        directory.deleteFile(file)_ _                    }_                }_            }_            assert SegmentInfos.getLastCommitSegmentsFileName(directory).equals(segmentsFileName)__            if (foundSegmentFiles == 0) {_                throw new IllegalStateException("no commit found in the directory")__            }_        }_        final CommitPoint cp = new CommitPoint(si, directory)__        try (IndexWriter writer = new IndexWriter(directory, new IndexWriterConfig(Lucene.STANDARD_ANALYZER)_                .setIndexCommit(cp)_                .setCommitOnClose(false)_                .setMergePolicy(NoMergePolicy.INSTANCE)_                .setOpenMode(IndexWriterConfig.OpenMode.APPEND))) {_            _        }_        return si__    };this,method,removes,all,files,from,the,given,directory,that,are,not,referenced,by,the,given,segments,file,this,method,will,open,an,index,writer,and,relies,on,index,file,deleter,to,remove,all,unreferenced,files,segment,files,that,are,newer,than,the,given,segments,file,are,removed,forcefully,to,prevent,problems,with,index,writer,opening,a,potentially,broken,commit,point,leftover,b,note,b,this,method,will,fail,if,there,is,another,index,writer,open,on,the,given,directory,this,method,will,also,acquire,a,write,lock,from,the,directory,while,pruning,unused,files,this,method,expects,an,existing,index,in,the,given,directory,that,has,the,given,segments,file;public,static,segment,infos,prune,unreferenced,files,string,segments,file,name,directory,directory,throws,ioexception,final,segment,infos,si,read,segment,infos,segments,file,name,directory,try,lock,write,lock,directory,obtain,lock,index,writer,int,found,segment,files,0,for,final,string,file,directory,list,all,if,file,starts,with,index,file,names,segments,file,equals,index,file,names,found,segment,files,if,file,equals,si,get,segments,file,name,false,directory,delete,file,file,assert,segment,infos,get,last,commit,segments,file,name,directory,equals,segments,file,name,if,found,segment,files,0,throw,new,illegal,state,exception,no,commit,found,in,the,directory,final,commit,point,cp,new,commit,point,si,directory,try,index,writer,writer,new,index,writer,directory,new,index,writer,config,lucene,set,index,commit,cp,set,commit,on,close,false,set,merge,policy,no,merge,policy,instance,set,open,mode,index,writer,config,open,mode,append,return,si
Lucene -> public static SegmentInfos pruneUnreferencedFiles(String segmentsFileName, Directory directory) throws IOException;1525334055;This method removes all files from the given directory that are not referenced by the given segments file._This method will open an IndexWriter and relies on index file deleter to remove all unreferenced files. Segment files_that are newer than the given segments file are removed forcefully to prevent problems with IndexWriter opening a potentially_broken commit point / leftover._<b>Note:</b> this method will fail if there is another IndexWriter open on the given directory. This method will also acquire_a write lock from the directory while pruning unused files. This method expects an existing index in the given directory that has_the given segments file.;public static SegmentInfos pruneUnreferencedFiles(String segmentsFileName, Directory directory) throws IOException {_        final SegmentInfos si = readSegmentInfos(segmentsFileName, directory)__        try (Lock writeLock = directory.obtainLock(IndexWriter.WRITE_LOCK_NAME)) {_            int foundSegmentFiles = 0__            for (final String file : directory.listAll()) {_                _                if (file.startsWith(IndexFileNames.SEGMENTS) || file.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {_                    foundSegmentFiles++__                    if (file.equals(si.getSegmentsFileName()) == false) {_                        directory.deleteFile(file)_ _                    }_                }_            }_            assert SegmentInfos.getLastCommitSegmentsFileName(directory).equals(segmentsFileName)__            if (foundSegmentFiles == 0) {_                throw new IllegalStateException("no commit found in the directory")__            }_        }_        final CommitPoint cp = new CommitPoint(si, directory)__        try (IndexWriter writer = new IndexWriter(directory, new IndexWriterConfig(Lucene.STANDARD_ANALYZER)_                .setIndexCommit(cp)_                .setCommitOnClose(false)_                .setMergePolicy(NoMergePolicy.INSTANCE)_                .setOpenMode(IndexWriterConfig.OpenMode.APPEND))) {_            _        }_        return si__    };this,method,removes,all,files,from,the,given,directory,that,are,not,referenced,by,the,given,segments,file,this,method,will,open,an,index,writer,and,relies,on,index,file,deleter,to,remove,all,unreferenced,files,segment,files,that,are,newer,than,the,given,segments,file,are,removed,forcefully,to,prevent,problems,with,index,writer,opening,a,potentially,broken,commit,point,leftover,b,note,b,this,method,will,fail,if,there,is,another,index,writer,open,on,the,given,directory,this,method,will,also,acquire,a,write,lock,from,the,directory,while,pruning,unused,files,this,method,expects,an,existing,index,in,the,given,directory,that,has,the,given,segments,file;public,static,segment,infos,prune,unreferenced,files,string,segments,file,name,directory,directory,throws,ioexception,final,segment,infos,si,read,segment,infos,segments,file,name,directory,try,lock,write,lock,directory,obtain,lock,index,writer,int,found,segment,files,0,for,final,string,file,directory,list,all,if,file,starts,with,index,file,names,segments,file,equals,index,file,names,found,segment,files,if,file,equals,si,get,segments,file,name,false,directory,delete,file,file,assert,segment,infos,get,last,commit,segments,file,name,directory,equals,segments,file,name,if,found,segment,files,0,throw,new,illegal,state,exception,no,commit,found,in,the,directory,final,commit,point,cp,new,commit,point,si,directory,try,index,writer,writer,new,index,writer,directory,new,index,writer,config,lucene,set,index,commit,cp,set,commit,on,close,false,set,merge,policy,no,merge,policy,instance,set,open,mode,index,writer,config,open,mode,append,return,si
Lucene -> public static SegmentInfos pruneUnreferencedFiles(String segmentsFileName, Directory directory) throws IOException;1535046779;This method removes all files from the given directory that are not referenced by the given segments file._This method will open an IndexWriter and relies on index file deleter to remove all unreferenced files. Segment files_that are newer than the given segments file are removed forcefully to prevent problems with IndexWriter opening a potentially_broken commit point / leftover._<b>Note:</b> this method will fail if there is another IndexWriter open on the given directory. This method will also acquire_a write lock from the directory while pruning unused files. This method expects an existing index in the given directory that has_the given segments file.;public static SegmentInfos pruneUnreferencedFiles(String segmentsFileName, Directory directory) throws IOException {_        final SegmentInfos si = readSegmentInfos(segmentsFileName, directory)__        try (Lock writeLock = directory.obtainLock(IndexWriter.WRITE_LOCK_NAME)) {_            int foundSegmentFiles = 0__            for (final String file : directory.listAll()) {_                _                if (file.startsWith(IndexFileNames.SEGMENTS) || file.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {_                    foundSegmentFiles++__                    if (file.equals(si.getSegmentsFileName()) == false) {_                        directory.deleteFile(file)_ _                    }_                }_            }_            assert SegmentInfos.getLastCommitSegmentsFileName(directory).equals(segmentsFileName)__            if (foundSegmentFiles == 0) {_                throw new IllegalStateException("no commit found in the directory")__            }_        }_        final CommitPoint cp = new CommitPoint(si, directory)__        try (IndexWriter writer = new IndexWriter(directory, new IndexWriterConfig(Lucene.STANDARD_ANALYZER)_                .setIndexCommit(cp)_                .setCommitOnClose(false)_                .setMergePolicy(NoMergePolicy.INSTANCE)_                .setOpenMode(IndexWriterConfig.OpenMode.APPEND))) {_            _        }_        return si__    };this,method,removes,all,files,from,the,given,directory,that,are,not,referenced,by,the,given,segments,file,this,method,will,open,an,index,writer,and,relies,on,index,file,deleter,to,remove,all,unreferenced,files,segment,files,that,are,newer,than,the,given,segments,file,are,removed,forcefully,to,prevent,problems,with,index,writer,opening,a,potentially,broken,commit,point,leftover,b,note,b,this,method,will,fail,if,there,is,another,index,writer,open,on,the,given,directory,this,method,will,also,acquire,a,write,lock,from,the,directory,while,pruning,unused,files,this,method,expects,an,existing,index,in,the,given,directory,that,has,the,given,segments,file;public,static,segment,infos,prune,unreferenced,files,string,segments,file,name,directory,directory,throws,ioexception,final,segment,infos,si,read,segment,infos,segments,file,name,directory,try,lock,write,lock,directory,obtain,lock,index,writer,int,found,segment,files,0,for,final,string,file,directory,list,all,if,file,starts,with,index,file,names,segments,file,equals,index,file,names,found,segment,files,if,file,equals,si,get,segments,file,name,false,directory,delete,file,file,assert,segment,infos,get,last,commit,segments,file,name,directory,equals,segments,file,name,if,found,segment,files,0,throw,new,illegal,state,exception,no,commit,found,in,the,directory,final,commit,point,cp,new,commit,point,si,directory,try,index,writer,writer,new,index,writer,directory,new,index,writer,config,lucene,set,index,commit,cp,set,commit,on,close,false,set,merge,policy,no,merge,policy,instance,set,open,mode,index,writer,config,open,mode,append,return,si
Lucene -> public static SegmentInfos pruneUnreferencedFiles(String segmentsFileName, Directory directory) throws IOException;1535723122;This method removes all files from the given directory that are not referenced by the given segments file._This method will open an IndexWriter and relies on index file deleter to remove all unreferenced files. Segment files_that are newer than the given segments file are removed forcefully to prevent problems with IndexWriter opening a potentially_broken commit point / leftover._<b>Note:</b> this method will fail if there is another IndexWriter open on the given directory. This method will also acquire_a write lock from the directory while pruning unused files. This method expects an existing index in the given directory that has_the given segments file.;public static SegmentInfos pruneUnreferencedFiles(String segmentsFileName, Directory directory) throws IOException {_        final SegmentInfos si = readSegmentInfos(segmentsFileName, directory)__        try (Lock writeLock = directory.obtainLock(IndexWriter.WRITE_LOCK_NAME)) {_            int foundSegmentFiles = 0__            for (final String file : directory.listAll()) {_                _                if (file.startsWith(IndexFileNames.SEGMENTS) || file.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {_                    foundSegmentFiles++__                    if (file.equals(si.getSegmentsFileName()) == false) {_                        directory.deleteFile(file)_ _                    }_                }_            }_            assert SegmentInfos.getLastCommitSegmentsFileName(directory).equals(segmentsFileName)__            if (foundSegmentFiles == 0) {_                throw new IllegalStateException("no commit found in the directory")__            }_        }_        final CommitPoint cp = new CommitPoint(si, directory)__        try (IndexWriter writer = new IndexWriter(directory, new IndexWriterConfig(Lucene.STANDARD_ANALYZER)_                .setSoftDeletesField(Lucene.SOFT_DELETES_FIELD)_                .setIndexCommit(cp)_                .setCommitOnClose(false)_                .setMergePolicy(NoMergePolicy.INSTANCE)_                .setOpenMode(IndexWriterConfig.OpenMode.APPEND))) {_            _        }_        return si__    };this,method,removes,all,files,from,the,given,directory,that,are,not,referenced,by,the,given,segments,file,this,method,will,open,an,index,writer,and,relies,on,index,file,deleter,to,remove,all,unreferenced,files,segment,files,that,are,newer,than,the,given,segments,file,are,removed,forcefully,to,prevent,problems,with,index,writer,opening,a,potentially,broken,commit,point,leftover,b,note,b,this,method,will,fail,if,there,is,another,index,writer,open,on,the,given,directory,this,method,will,also,acquire,a,write,lock,from,the,directory,while,pruning,unused,files,this,method,expects,an,existing,index,in,the,given,directory,that,has,the,given,segments,file;public,static,segment,infos,prune,unreferenced,files,string,segments,file,name,directory,directory,throws,ioexception,final,segment,infos,si,read,segment,infos,segments,file,name,directory,try,lock,write,lock,directory,obtain,lock,index,writer,int,found,segment,files,0,for,final,string,file,directory,list,all,if,file,starts,with,index,file,names,segments,file,equals,index,file,names,found,segment,files,if,file,equals,si,get,segments,file,name,false,directory,delete,file,file,assert,segment,infos,get,last,commit,segments,file,name,directory,equals,segments,file,name,if,found,segment,files,0,throw,new,illegal,state,exception,no,commit,found,in,the,directory,final,commit,point,cp,new,commit,point,si,directory,try,index,writer,writer,new,index,writer,directory,new,index,writer,config,lucene,set,soft,deletes,field,lucene,set,index,commit,cp,set,commit,on,close,false,set,merge,policy,no,merge,policy,instance,set,open,mode,index,writer,config,open,mode,append,return,si
Lucene -> public static SegmentInfos pruneUnreferencedFiles(String segmentsFileName, Directory directory) throws IOException;1536314350;This method removes all files from the given directory that are not referenced by the given segments file._This method will open an IndexWriter and relies on index file deleter to remove all unreferenced files. Segment files_that are newer than the given segments file are removed forcefully to prevent problems with IndexWriter opening a potentially_broken commit point / leftover._<b>Note:</b> this method will fail if there is another IndexWriter open on the given directory. This method will also acquire_a write lock from the directory while pruning unused files. This method expects an existing index in the given directory that has_the given segments file.;public static SegmentInfos pruneUnreferencedFiles(String segmentsFileName, Directory directory) throws IOException {_        final SegmentInfos si = readSegmentInfos(segmentsFileName, directory)__        try (Lock writeLock = directory.obtainLock(IndexWriter.WRITE_LOCK_NAME)) {_            int foundSegmentFiles = 0__            for (final String file : directory.listAll()) {_                _                if (file.startsWith(IndexFileNames.SEGMENTS) || file.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {_                    foundSegmentFiles++__                    if (file.equals(si.getSegmentsFileName()) == false) {_                        directory.deleteFile(file)_ _                    }_                }_            }_            assert SegmentInfos.getLastCommitSegmentsFileName(directory).equals(segmentsFileName)__            if (foundSegmentFiles == 0) {_                throw new IllegalStateException("no commit found in the directory")__            }_        }_        final CommitPoint cp = new CommitPoint(si, directory)__        try (IndexWriter writer = new IndexWriter(directory, new IndexWriterConfig(Lucene.STANDARD_ANALYZER)_                .setSoftDeletesField(Lucene.SOFT_DELETES_FIELD)_                .setIndexCommit(cp)_                .setCommitOnClose(false)_                .setMergePolicy(NoMergePolicy.INSTANCE)_                .setOpenMode(IndexWriterConfig.OpenMode.APPEND))) {_            _        }_        return si__    };this,method,removes,all,files,from,the,given,directory,that,are,not,referenced,by,the,given,segments,file,this,method,will,open,an,index,writer,and,relies,on,index,file,deleter,to,remove,all,unreferenced,files,segment,files,that,are,newer,than,the,given,segments,file,are,removed,forcefully,to,prevent,problems,with,index,writer,opening,a,potentially,broken,commit,point,leftover,b,note,b,this,method,will,fail,if,there,is,another,index,writer,open,on,the,given,directory,this,method,will,also,acquire,a,write,lock,from,the,directory,while,pruning,unused,files,this,method,expects,an,existing,index,in,the,given,directory,that,has,the,given,segments,file;public,static,segment,infos,prune,unreferenced,files,string,segments,file,name,directory,directory,throws,ioexception,final,segment,infos,si,read,segment,infos,segments,file,name,directory,try,lock,write,lock,directory,obtain,lock,index,writer,int,found,segment,files,0,for,final,string,file,directory,list,all,if,file,starts,with,index,file,names,segments,file,equals,index,file,names,found,segment,files,if,file,equals,si,get,segments,file,name,false,directory,delete,file,file,assert,segment,infos,get,last,commit,segments,file,name,directory,equals,segments,file,name,if,found,segment,files,0,throw,new,illegal,state,exception,no,commit,found,in,the,directory,final,commit,point,cp,new,commit,point,si,directory,try,index,writer,writer,new,index,writer,directory,new,index,writer,config,lucene,set,soft,deletes,field,lucene,set,index,commit,cp,set,commit,on,close,false,set,merge,policy,no,merge,policy,instance,set,open,mode,index,writer,config,open,mode,append,return,si
Lucene -> public static SegmentInfos pruneUnreferencedFiles(String segmentsFileName, Directory directory) throws IOException;1536611444;This method removes all files from the given directory that are not referenced by the given segments file._This method will open an IndexWriter and relies on index file deleter to remove all unreferenced files. Segment files_that are newer than the given segments file are removed forcefully to prevent problems with IndexWriter opening a potentially_broken commit point / leftover._<b>Note:</b> this method will fail if there is another IndexWriter open on the given directory. This method will also acquire_a write lock from the directory while pruning unused files. This method expects an existing index in the given directory that has_the given segments file.;public static SegmentInfos pruneUnreferencedFiles(String segmentsFileName, Directory directory) throws IOException {_        final SegmentInfos si = readSegmentInfos(segmentsFileName, directory)__        try (Lock writeLock = directory.obtainLock(IndexWriter.WRITE_LOCK_NAME)) {_            int foundSegmentFiles = 0__            for (final String file : directory.listAll()) {_                _                if (file.startsWith(IndexFileNames.SEGMENTS) || file.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {_                    foundSegmentFiles++__                    if (file.equals(si.getSegmentsFileName()) == false) {_                        directory.deleteFile(file)_ _                    }_                }_            }_            assert SegmentInfos.getLastCommitSegmentsFileName(directory).equals(segmentsFileName)__            if (foundSegmentFiles == 0) {_                throw new IllegalStateException("no commit found in the directory")__            }_        }_        final CommitPoint cp = new CommitPoint(si, directory)__        try (IndexWriter writer = new IndexWriter(directory, new IndexWriterConfig(Lucene.STANDARD_ANALYZER)_                .setSoftDeletesField(Lucene.SOFT_DELETES_FIELD)_                .setIndexCommit(cp)_                .setCommitOnClose(false)_                .setMergePolicy(NoMergePolicy.INSTANCE)_                .setOpenMode(IndexWriterConfig.OpenMode.APPEND))) {_            _        }_        return si__    };this,method,removes,all,files,from,the,given,directory,that,are,not,referenced,by,the,given,segments,file,this,method,will,open,an,index,writer,and,relies,on,index,file,deleter,to,remove,all,unreferenced,files,segment,files,that,are,newer,than,the,given,segments,file,are,removed,forcefully,to,prevent,problems,with,index,writer,opening,a,potentially,broken,commit,point,leftover,b,note,b,this,method,will,fail,if,there,is,another,index,writer,open,on,the,given,directory,this,method,will,also,acquire,a,write,lock,from,the,directory,while,pruning,unused,files,this,method,expects,an,existing,index,in,the,given,directory,that,has,the,given,segments,file;public,static,segment,infos,prune,unreferenced,files,string,segments,file,name,directory,directory,throws,ioexception,final,segment,infos,si,read,segment,infos,segments,file,name,directory,try,lock,write,lock,directory,obtain,lock,index,writer,int,found,segment,files,0,for,final,string,file,directory,list,all,if,file,starts,with,index,file,names,segments,file,equals,index,file,names,found,segment,files,if,file,equals,si,get,segments,file,name,false,directory,delete,file,file,assert,segment,infos,get,last,commit,segments,file,name,directory,equals,segments,file,name,if,found,segment,files,0,throw,new,illegal,state,exception,no,commit,found,in,the,directory,final,commit,point,cp,new,commit,point,si,directory,try,index,writer,writer,new,index,writer,directory,new,index,writer,config,lucene,set,soft,deletes,field,lucene,set,index,commit,cp,set,commit,on,close,false,set,merge,policy,no,merge,policy,instance,set,open,mode,index,writer,config,open,mode,append,return,si
Lucene -> public static SegmentInfos pruneUnreferencedFiles(String segmentsFileName, Directory directory) throws IOException;1537371806;This method removes all files from the given directory that are not referenced by the given segments file._This method will open an IndexWriter and relies on index file deleter to remove all unreferenced files. Segment files_that are newer than the given segments file are removed forcefully to prevent problems with IndexWriter opening a potentially_broken commit point / leftover._<b>Note:</b> this method will fail if there is another IndexWriter open on the given directory. This method will also acquire_a write lock from the directory while pruning unused files. This method expects an existing index in the given directory that has_the given segments file.;public static SegmentInfos pruneUnreferencedFiles(String segmentsFileName, Directory directory) throws IOException {_        final SegmentInfos si = readSegmentInfos(segmentsFileName, directory)__        try (Lock writeLock = directory.obtainLock(IndexWriter.WRITE_LOCK_NAME)) {_            int foundSegmentFiles = 0__            for (final String file : directory.listAll()) {_                _                if (file.startsWith(IndexFileNames.SEGMENTS) || file.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {_                    foundSegmentFiles++__                    if (file.equals(si.getSegmentsFileName()) == false) {_                        directory.deleteFile(file)_ _                    }_                }_            }_            assert SegmentInfos.getLastCommitSegmentsFileName(directory).equals(segmentsFileName)__            if (foundSegmentFiles == 0) {_                throw new IllegalStateException("no commit found in the directory")__            }_        }_        final CommitPoint cp = new CommitPoint(si, directory)__        try (IndexWriter writer = new IndexWriter(directory, new IndexWriterConfig(Lucene.STANDARD_ANALYZER)_                .setSoftDeletesField(Lucene.SOFT_DELETES_FIELD)_                .setIndexCommit(cp)_                .setCommitOnClose(false)_                .setMergePolicy(NoMergePolicy.INSTANCE)_                .setOpenMode(IndexWriterConfig.OpenMode.APPEND))) {_            _        }_        return si__    };this,method,removes,all,files,from,the,given,directory,that,are,not,referenced,by,the,given,segments,file,this,method,will,open,an,index,writer,and,relies,on,index,file,deleter,to,remove,all,unreferenced,files,segment,files,that,are,newer,than,the,given,segments,file,are,removed,forcefully,to,prevent,problems,with,index,writer,opening,a,potentially,broken,commit,point,leftover,b,note,b,this,method,will,fail,if,there,is,another,index,writer,open,on,the,given,directory,this,method,will,also,acquire,a,write,lock,from,the,directory,while,pruning,unused,files,this,method,expects,an,existing,index,in,the,given,directory,that,has,the,given,segments,file;public,static,segment,infos,prune,unreferenced,files,string,segments,file,name,directory,directory,throws,ioexception,final,segment,infos,si,read,segment,infos,segments,file,name,directory,try,lock,write,lock,directory,obtain,lock,index,writer,int,found,segment,files,0,for,final,string,file,directory,list,all,if,file,starts,with,index,file,names,segments,file,equals,index,file,names,found,segment,files,if,file,equals,si,get,segments,file,name,false,directory,delete,file,file,assert,segment,infos,get,last,commit,segments,file,name,directory,equals,segments,file,name,if,found,segment,files,0,throw,new,illegal,state,exception,no,commit,found,in,the,directory,final,commit,point,cp,new,commit,point,si,directory,try,index,writer,writer,new,index,writer,directory,new,index,writer,config,lucene,set,soft,deletes,field,lucene,set,index,commit,cp,set,commit,on,close,false,set,merge,policy,no,merge,policy,instance,set,open,mode,index,writer,config,open,mode,append,return,si
Lucene -> public static SegmentInfos pruneUnreferencedFiles(String segmentsFileName, Directory directory) throws IOException;1539815831;This method removes all files from the given directory that are not referenced by the given segments file._This method will open an IndexWriter and relies on index file deleter to remove all unreferenced files. Segment files_that are newer than the given segments file are removed forcefully to prevent problems with IndexWriter opening a potentially_broken commit point / leftover._<b>Note:</b> this method will fail if there is another IndexWriter open on the given directory. This method will also acquire_a write lock from the directory while pruning unused files. This method expects an existing index in the given directory that has_the given segments file.;public static SegmentInfos pruneUnreferencedFiles(String segmentsFileName, Directory directory) throws IOException {_        final SegmentInfos si = readSegmentInfos(segmentsFileName, directory)__        try (Lock writeLock = directory.obtainLock(IndexWriter.WRITE_LOCK_NAME)) {_            int foundSegmentFiles = 0__            for (final String file : directory.listAll()) {_                _                if (file.startsWith(IndexFileNames.SEGMENTS) || file.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {_                    foundSegmentFiles++__                    if (file.equals(si.getSegmentsFileName()) == false) {_                        directory.deleteFile(file)_ _                    }_                }_            }_            assert SegmentInfos.getLastCommitSegmentsFileName(directory).equals(segmentsFileName)__            if (foundSegmentFiles == 0) {_                throw new IllegalStateException("no commit found in the directory")__            }_        }_        final CommitPoint cp = new CommitPoint(si, directory)__        try (IndexWriter writer = new IndexWriter(directory, new IndexWriterConfig(Lucene.STANDARD_ANALYZER)_                .setSoftDeletesField(Lucene.SOFT_DELETES_FIELD)_                .setIndexCommit(cp)_                .setCommitOnClose(false)_                .setMergePolicy(NoMergePolicy.INSTANCE)_                .setOpenMode(IndexWriterConfig.OpenMode.APPEND))) {_            _        }_        return si__    };this,method,removes,all,files,from,the,given,directory,that,are,not,referenced,by,the,given,segments,file,this,method,will,open,an,index,writer,and,relies,on,index,file,deleter,to,remove,all,unreferenced,files,segment,files,that,are,newer,than,the,given,segments,file,are,removed,forcefully,to,prevent,problems,with,index,writer,opening,a,potentially,broken,commit,point,leftover,b,note,b,this,method,will,fail,if,there,is,another,index,writer,open,on,the,given,directory,this,method,will,also,acquire,a,write,lock,from,the,directory,while,pruning,unused,files,this,method,expects,an,existing,index,in,the,given,directory,that,has,the,given,segments,file;public,static,segment,infos,prune,unreferenced,files,string,segments,file,name,directory,directory,throws,ioexception,final,segment,infos,si,read,segment,infos,segments,file,name,directory,try,lock,write,lock,directory,obtain,lock,index,writer,int,found,segment,files,0,for,final,string,file,directory,list,all,if,file,starts,with,index,file,names,segments,file,equals,index,file,names,found,segment,files,if,file,equals,si,get,segments,file,name,false,directory,delete,file,file,assert,segment,infos,get,last,commit,segments,file,name,directory,equals,segments,file,name,if,found,segment,files,0,throw,new,illegal,state,exception,no,commit,found,in,the,directory,final,commit,point,cp,new,commit,point,si,directory,try,index,writer,writer,new,index,writer,directory,new,index,writer,config,lucene,set,soft,deletes,field,lucene,set,index,commit,cp,set,commit,on,close,false,set,merge,policy,no,merge,policy,instance,set,open,mode,index,writer,config,open,mode,append,return,si
Lucene -> public static SegmentInfos pruneUnreferencedFiles(String segmentsFileName, Directory directory) throws IOException;1540238977;This method removes all files from the given directory that are not referenced by the given segments file._This method will open an IndexWriter and relies on index file deleter to remove all unreferenced files. Segment files_that are newer than the given segments file are removed forcefully to prevent problems with IndexWriter opening a potentially_broken commit point / leftover._<b>Note:</b> this method will fail if there is another IndexWriter open on the given directory. This method will also acquire_a write lock from the directory while pruning unused files. This method expects an existing index in the given directory that has_the given segments file.;public static SegmentInfos pruneUnreferencedFiles(String segmentsFileName, Directory directory) throws IOException {_        final SegmentInfos si = readSegmentInfos(segmentsFileName, directory)__        try (Lock writeLock = directory.obtainLock(IndexWriter.WRITE_LOCK_NAME)) {_            int foundSegmentFiles = 0__            for (final String file : directory.listAll()) {_                _                if (file.startsWith(IndexFileNames.SEGMENTS) || file.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {_                    foundSegmentFiles++__                    if (file.equals(si.getSegmentsFileName()) == false) {_                        directory.deleteFile(file)_ _                    }_                }_            }_            assert SegmentInfos.getLastCommitSegmentsFileName(directory).equals(segmentsFileName)__            if (foundSegmentFiles == 0) {_                throw new IllegalStateException("no commit found in the directory")__            }_        }_        final CommitPoint cp = new CommitPoint(si, directory)__        try (IndexWriter writer = new IndexWriter(directory, new IndexWriterConfig(Lucene.STANDARD_ANALYZER)_                .setSoftDeletesField(Lucene.SOFT_DELETES_FIELD)_                .setIndexCommit(cp)_                .setCommitOnClose(false)_                .setMergePolicy(NoMergePolicy.INSTANCE)_                .setOpenMode(IndexWriterConfig.OpenMode.APPEND))) {_            _        }_        return si__    };this,method,removes,all,files,from,the,given,directory,that,are,not,referenced,by,the,given,segments,file,this,method,will,open,an,index,writer,and,relies,on,index,file,deleter,to,remove,all,unreferenced,files,segment,files,that,are,newer,than,the,given,segments,file,are,removed,forcefully,to,prevent,problems,with,index,writer,opening,a,potentially,broken,commit,point,leftover,b,note,b,this,method,will,fail,if,there,is,another,index,writer,open,on,the,given,directory,this,method,will,also,acquire,a,write,lock,from,the,directory,while,pruning,unused,files,this,method,expects,an,existing,index,in,the,given,directory,that,has,the,given,segments,file;public,static,segment,infos,prune,unreferenced,files,string,segments,file,name,directory,directory,throws,ioexception,final,segment,infos,si,read,segment,infos,segments,file,name,directory,try,lock,write,lock,directory,obtain,lock,index,writer,int,found,segment,files,0,for,final,string,file,directory,list,all,if,file,starts,with,index,file,names,segments,file,equals,index,file,names,found,segment,files,if,file,equals,si,get,segments,file,name,false,directory,delete,file,file,assert,segment,infos,get,last,commit,segments,file,name,directory,equals,segments,file,name,if,found,segment,files,0,throw,new,illegal,state,exception,no,commit,found,in,the,directory,final,commit,point,cp,new,commit,point,si,directory,try,index,writer,writer,new,index,writer,directory,new,index,writer,config,lucene,set,soft,deletes,field,lucene,set,index,commit,cp,set,commit,on,close,false,set,merge,policy,no,merge,policy,instance,set,open,mode,index,writer,config,open,mode,append,return,si
Lucene -> public static SegmentInfos pruneUnreferencedFiles(String segmentsFileName, Directory directory) throws IOException;1541592065;This method removes all files from the given directory that are not referenced by the given segments file._This method will open an IndexWriter and relies on index file deleter to remove all unreferenced files. Segment files_that are newer than the given segments file are removed forcefully to prevent problems with IndexWriter opening a potentially_broken commit point / leftover._<b>Note:</b> this method will fail if there is another IndexWriter open on the given directory. This method will also acquire_a write lock from the directory while pruning unused files. This method expects an existing index in the given directory that has_the given segments file.;public static SegmentInfos pruneUnreferencedFiles(String segmentsFileName, Directory directory) throws IOException {_        final SegmentInfos si = readSegmentInfos(segmentsFileName, directory)__        try (Lock writeLock = directory.obtainLock(IndexWriter.WRITE_LOCK_NAME)) {_            int foundSegmentFiles = 0__            for (final String file : directory.listAll()) {_                _                if (file.startsWith(IndexFileNames.SEGMENTS) || file.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {_                    foundSegmentFiles++__                    if (file.equals(si.getSegmentsFileName()) == false) {_                        directory.deleteFile(file)_ _                    }_                }_            }_            assert SegmentInfos.getLastCommitSegmentsFileName(directory).equals(segmentsFileName)__            if (foundSegmentFiles == 0) {_                throw new IllegalStateException("no commit found in the directory")__            }_        }_        final CommitPoint cp = new CommitPoint(si, directory)__        try (IndexWriter writer = new IndexWriter(directory, new IndexWriterConfig(Lucene.STANDARD_ANALYZER)_                .setSoftDeletesField(Lucene.SOFT_DELETES_FIELD)_                .setIndexCommit(cp)_                .setCommitOnClose(false)_                .setMergePolicy(NoMergePolicy.INSTANCE)_                .setOpenMode(IndexWriterConfig.OpenMode.APPEND))) {_            _        }_        return si__    };this,method,removes,all,files,from,the,given,directory,that,are,not,referenced,by,the,given,segments,file,this,method,will,open,an,index,writer,and,relies,on,index,file,deleter,to,remove,all,unreferenced,files,segment,files,that,are,newer,than,the,given,segments,file,are,removed,forcefully,to,prevent,problems,with,index,writer,opening,a,potentially,broken,commit,point,leftover,b,note,b,this,method,will,fail,if,there,is,another,index,writer,open,on,the,given,directory,this,method,will,also,acquire,a,write,lock,from,the,directory,while,pruning,unused,files,this,method,expects,an,existing,index,in,the,given,directory,that,has,the,given,segments,file;public,static,segment,infos,prune,unreferenced,files,string,segments,file,name,directory,directory,throws,ioexception,final,segment,infos,si,read,segment,infos,segments,file,name,directory,try,lock,write,lock,directory,obtain,lock,index,writer,int,found,segment,files,0,for,final,string,file,directory,list,all,if,file,starts,with,index,file,names,segments,file,equals,index,file,names,found,segment,files,if,file,equals,si,get,segments,file,name,false,directory,delete,file,file,assert,segment,infos,get,last,commit,segments,file,name,directory,equals,segments,file,name,if,found,segment,files,0,throw,new,illegal,state,exception,no,commit,found,in,the,directory,final,commit,point,cp,new,commit,point,si,directory,try,index,writer,writer,new,index,writer,directory,new,index,writer,config,lucene,set,soft,deletes,field,lucene,set,index,commit,cp,set,commit,on,close,false,set,merge,policy,no,merge,policy,instance,set,open,mode,index,writer,config,open,mode,append,return,si
Lucene -> public static SegmentInfos pruneUnreferencedFiles(String segmentsFileName, Directory directory) throws IOException;1541618615;This method removes all files from the given directory that are not referenced by the given segments file._This method will open an IndexWriter and relies on index file deleter to remove all unreferenced files. Segment files_that are newer than the given segments file are removed forcefully to prevent problems with IndexWriter opening a potentially_broken commit point / leftover._<b>Note:</b> this method will fail if there is another IndexWriter open on the given directory. This method will also acquire_a write lock from the directory while pruning unused files. This method expects an existing index in the given directory that has_the given segments file.;public static SegmentInfos pruneUnreferencedFiles(String segmentsFileName, Directory directory) throws IOException {_        final SegmentInfos si = readSegmentInfos(segmentsFileName, directory)__        try (Lock writeLock = directory.obtainLock(IndexWriter.WRITE_LOCK_NAME)) {_            int foundSegmentFiles = 0__            for (final String file : directory.listAll()) {_                _                if (file.startsWith(IndexFileNames.SEGMENTS) || file.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {_                    foundSegmentFiles++__                    if (file.equals(si.getSegmentsFileName()) == false) {_                        directory.deleteFile(file)_ _                    }_                }_            }_            assert SegmentInfos.getLastCommitSegmentsFileName(directory).equals(segmentsFileName)__            if (foundSegmentFiles == 0) {_                throw new IllegalStateException("no commit found in the directory")__            }_        }_        final IndexCommit cp = getIndexCommit(si, directory)__        try (IndexWriter writer = new IndexWriter(directory, new IndexWriterConfig(Lucene.STANDARD_ANALYZER)_                .setSoftDeletesField(Lucene.SOFT_DELETES_FIELD)_                .setIndexCommit(cp)_                .setCommitOnClose(false)_                .setMergePolicy(NoMergePolicy.INSTANCE)_                .setOpenMode(IndexWriterConfig.OpenMode.APPEND))) {_            _        }_        return si__    };this,method,removes,all,files,from,the,given,directory,that,are,not,referenced,by,the,given,segments,file,this,method,will,open,an,index,writer,and,relies,on,index,file,deleter,to,remove,all,unreferenced,files,segment,files,that,are,newer,than,the,given,segments,file,are,removed,forcefully,to,prevent,problems,with,index,writer,opening,a,potentially,broken,commit,point,leftover,b,note,b,this,method,will,fail,if,there,is,another,index,writer,open,on,the,given,directory,this,method,will,also,acquire,a,write,lock,from,the,directory,while,pruning,unused,files,this,method,expects,an,existing,index,in,the,given,directory,that,has,the,given,segments,file;public,static,segment,infos,prune,unreferenced,files,string,segments,file,name,directory,directory,throws,ioexception,final,segment,infos,si,read,segment,infos,segments,file,name,directory,try,lock,write,lock,directory,obtain,lock,index,writer,int,found,segment,files,0,for,final,string,file,directory,list,all,if,file,starts,with,index,file,names,segments,file,equals,index,file,names,found,segment,files,if,file,equals,si,get,segments,file,name,false,directory,delete,file,file,assert,segment,infos,get,last,commit,segments,file,name,directory,equals,segments,file,name,if,found,segment,files,0,throw,new,illegal,state,exception,no,commit,found,in,the,directory,final,index,commit,cp,get,index,commit,si,directory,try,index,writer,writer,new,index,writer,directory,new,index,writer,config,lucene,set,soft,deletes,field,lucene,set,index,commit,cp,set,commit,on,close,false,set,merge,policy,no,merge,policy,instance,set,open,mode,index,writer,config,open,mode,append,return,si
Lucene -> public static SegmentInfos pruneUnreferencedFiles(String segmentsFileName, Directory directory) throws IOException;1544076142;This method removes all files from the given directory that are not referenced by the given segments file._This method will open an IndexWriter and relies on index file deleter to remove all unreferenced files. Segment files_that are newer than the given segments file are removed forcefully to prevent problems with IndexWriter opening a potentially_broken commit point / leftover._<b>Note:</b> this method will fail if there is another IndexWriter open on the given directory. This method will also acquire_a write lock from the directory while pruning unused files. This method expects an existing index in the given directory that has_the given segments file.;public static SegmentInfos pruneUnreferencedFiles(String segmentsFileName, Directory directory) throws IOException {_        final SegmentInfos si = readSegmentInfos(segmentsFileName, directory)__        try (Lock writeLock = directory.obtainLock(IndexWriter.WRITE_LOCK_NAME)) {_            int foundSegmentFiles = 0__            for (final String file : directory.listAll()) {_                _                if (file.startsWith(IndexFileNames.SEGMENTS) || file.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {_                    foundSegmentFiles++__                    if (file.equals(si.getSegmentsFileName()) == false) {_                        directory.deleteFile(file)_ _                    }_                }_            }_            assert SegmentInfos.getLastCommitSegmentsFileName(directory).equals(segmentsFileName)__            if (foundSegmentFiles == 0) {_                throw new IllegalStateException("no commit found in the directory")__            }_        }_        final IndexCommit cp = getIndexCommit(si, directory)__        try (IndexWriter writer = new IndexWriter(directory, new IndexWriterConfig(Lucene.STANDARD_ANALYZER)_                .setSoftDeletesField(Lucene.SOFT_DELETES_FIELD)_                .setIndexCommit(cp)_                .setCommitOnClose(false)_                .setMergePolicy(NoMergePolicy.INSTANCE)_                .setOpenMode(IndexWriterConfig.OpenMode.APPEND))) {_            _        }_        return si__    };this,method,removes,all,files,from,the,given,directory,that,are,not,referenced,by,the,given,segments,file,this,method,will,open,an,index,writer,and,relies,on,index,file,deleter,to,remove,all,unreferenced,files,segment,files,that,are,newer,than,the,given,segments,file,are,removed,forcefully,to,prevent,problems,with,index,writer,opening,a,potentially,broken,commit,point,leftover,b,note,b,this,method,will,fail,if,there,is,another,index,writer,open,on,the,given,directory,this,method,will,also,acquire,a,write,lock,from,the,directory,while,pruning,unused,files,this,method,expects,an,existing,index,in,the,given,directory,that,has,the,given,segments,file;public,static,segment,infos,prune,unreferenced,files,string,segments,file,name,directory,directory,throws,ioexception,final,segment,infos,si,read,segment,infos,segments,file,name,directory,try,lock,write,lock,directory,obtain,lock,index,writer,int,found,segment,files,0,for,final,string,file,directory,list,all,if,file,starts,with,index,file,names,segments,file,equals,index,file,names,found,segment,files,if,file,equals,si,get,segments,file,name,false,directory,delete,file,file,assert,segment,infos,get,last,commit,segments,file,name,directory,equals,segments,file,name,if,found,segment,files,0,throw,new,illegal,state,exception,no,commit,found,in,the,directory,final,index,commit,cp,get,index,commit,si,directory,try,index,writer,writer,new,index,writer,directory,new,index,writer,config,lucene,set,soft,deletes,field,lucene,set,index,commit,cp,set,commit,on,close,false,set,merge,policy,no,merge,policy,instance,set,open,mode,index,writer,config,open,mode,append,return,si
Lucene -> public static SegmentInfos pruneUnreferencedFiles(String segmentsFileName, Directory directory) throws IOException;1544322276;This method removes all files from the given directory that are not referenced by the given segments file._This method will open an IndexWriter and relies on index file deleter to remove all unreferenced files. Segment files_that are newer than the given segments file are removed forcefully to prevent problems with IndexWriter opening a potentially_broken commit point / leftover._<b>Note:</b> this method will fail if there is another IndexWriter open on the given directory. This method will also acquire_a write lock from the directory while pruning unused files. This method expects an existing index in the given directory that has_the given segments file.;public static SegmentInfos pruneUnreferencedFiles(String segmentsFileName, Directory directory) throws IOException {_        final SegmentInfos si = readSegmentInfos(segmentsFileName, directory)__        try (Lock writeLock = directory.obtainLock(IndexWriter.WRITE_LOCK_NAME)) {_            int foundSegmentFiles = 0__            for (final String file : directory.listAll()) {_                _                if (file.startsWith(IndexFileNames.SEGMENTS) || file.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {_                    foundSegmentFiles++__                    if (file.equals(si.getSegmentsFileName()) == false) {_                        directory.deleteFile(file)_ _                    }_                }_            }_            assert SegmentInfos.getLastCommitSegmentsFileName(directory).equals(segmentsFileName)__            if (foundSegmentFiles == 0) {_                throw new IllegalStateException("no commit found in the directory")__            }_        }_        final IndexCommit cp = getIndexCommit(si, directory)__        try (IndexWriter writer = new IndexWriter(directory, new IndexWriterConfig(Lucene.STANDARD_ANALYZER)_                .setSoftDeletesField(Lucene.SOFT_DELETES_FIELD)_                .setIndexCommit(cp)_                .setCommitOnClose(false)_                .setMergePolicy(NoMergePolicy.INSTANCE)_                .setOpenMode(IndexWriterConfig.OpenMode.APPEND))) {_            _        }_        return si__    };this,method,removes,all,files,from,the,given,directory,that,are,not,referenced,by,the,given,segments,file,this,method,will,open,an,index,writer,and,relies,on,index,file,deleter,to,remove,all,unreferenced,files,segment,files,that,are,newer,than,the,given,segments,file,are,removed,forcefully,to,prevent,problems,with,index,writer,opening,a,potentially,broken,commit,point,leftover,b,note,b,this,method,will,fail,if,there,is,another,index,writer,open,on,the,given,directory,this,method,will,also,acquire,a,write,lock,from,the,directory,while,pruning,unused,files,this,method,expects,an,existing,index,in,the,given,directory,that,has,the,given,segments,file;public,static,segment,infos,prune,unreferenced,files,string,segments,file,name,directory,directory,throws,ioexception,final,segment,infos,si,read,segment,infos,segments,file,name,directory,try,lock,write,lock,directory,obtain,lock,index,writer,int,found,segment,files,0,for,final,string,file,directory,list,all,if,file,starts,with,index,file,names,segments,file,equals,index,file,names,found,segment,files,if,file,equals,si,get,segments,file,name,false,directory,delete,file,file,assert,segment,infos,get,last,commit,segments,file,name,directory,equals,segments,file,name,if,found,segment,files,0,throw,new,illegal,state,exception,no,commit,found,in,the,directory,final,index,commit,cp,get,index,commit,si,directory,try,index,writer,writer,new,index,writer,directory,new,index,writer,config,lucene,set,soft,deletes,field,lucene,set,index,commit,cp,set,commit,on,close,false,set,merge,policy,no,merge,policy,instance,set,open,mode,index,writer,config,open,mode,append,return,si
Lucene -> public static SegmentInfos pruneUnreferencedFiles(String segmentsFileName, Directory directory) throws IOException;1544786574;This method removes all files from the given directory that are not referenced by the given segments file._This method will open an IndexWriter and relies on index file deleter to remove all unreferenced files. Segment files_that are newer than the given segments file are removed forcefully to prevent problems with IndexWriter opening a potentially_broken commit point / leftover._<b>Note:</b> this method will fail if there is another IndexWriter open on the given directory. This method will also acquire_a write lock from the directory while pruning unused files. This method expects an existing index in the given directory that has_the given segments file.;public static SegmentInfos pruneUnreferencedFiles(String segmentsFileName, Directory directory) throws IOException {_        final SegmentInfos si = readSegmentInfos(segmentsFileName, directory)__        try (Lock writeLock = directory.obtainLock(IndexWriter.WRITE_LOCK_NAME)) {_            int foundSegmentFiles = 0__            for (final String file : directory.listAll()) {_                _                if (file.startsWith(IndexFileNames.SEGMENTS) || file.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {_                    foundSegmentFiles++__                    if (file.equals(si.getSegmentsFileName()) == false) {_                        directory.deleteFile(file)_ _                    }_                }_            }_            assert SegmentInfos.getLastCommitSegmentsFileName(directory).equals(segmentsFileName)__            if (foundSegmentFiles == 0) {_                throw new IllegalStateException("no commit found in the directory")__            }_        }_        final IndexCommit cp = getIndexCommit(si, directory)__        try (IndexWriter writer = new IndexWriter(directory, new IndexWriterConfig(Lucene.STANDARD_ANALYZER)_                .setSoftDeletesField(Lucene.SOFT_DELETES_FIELD)_                .setIndexCommit(cp)_                .setCommitOnClose(false)_                .setMergePolicy(NoMergePolicy.INSTANCE)_                .setOpenMode(IndexWriterConfig.OpenMode.APPEND))) {_            _        }_        return si__    };this,method,removes,all,files,from,the,given,directory,that,are,not,referenced,by,the,given,segments,file,this,method,will,open,an,index,writer,and,relies,on,index,file,deleter,to,remove,all,unreferenced,files,segment,files,that,are,newer,than,the,given,segments,file,are,removed,forcefully,to,prevent,problems,with,index,writer,opening,a,potentially,broken,commit,point,leftover,b,note,b,this,method,will,fail,if,there,is,another,index,writer,open,on,the,given,directory,this,method,will,also,acquire,a,write,lock,from,the,directory,while,pruning,unused,files,this,method,expects,an,existing,index,in,the,given,directory,that,has,the,given,segments,file;public,static,segment,infos,prune,unreferenced,files,string,segments,file,name,directory,directory,throws,ioexception,final,segment,infos,si,read,segment,infos,segments,file,name,directory,try,lock,write,lock,directory,obtain,lock,index,writer,int,found,segment,files,0,for,final,string,file,directory,list,all,if,file,starts,with,index,file,names,segments,file,equals,index,file,names,found,segment,files,if,file,equals,si,get,segments,file,name,false,directory,delete,file,file,assert,segment,infos,get,last,commit,segments,file,name,directory,equals,segments,file,name,if,found,segment,files,0,throw,new,illegal,state,exception,no,commit,found,in,the,directory,final,index,commit,cp,get,index,commit,si,directory,try,index,writer,writer,new,index,writer,directory,new,index,writer,config,lucene,set,soft,deletes,field,lucene,set,index,commit,cp,set,commit,on,close,false,set,merge,policy,no,merge,policy,instance,set,open,mode,index,writer,config,open,mode,append,return,si
Lucene -> public static SegmentInfos readSegmentInfos(Directory directory) throws IOException;1524684173;Reads the segments infos, failing if it fails to load;public static SegmentInfos readSegmentInfos(Directory directory) throws IOException {_        return SegmentInfos.readLatestCommit(directory)__    };reads,the,segments,infos,failing,if,it,fails,to,load;public,static,segment,infos,read,segment,infos,directory,directory,throws,ioexception,return,segment,infos,read,latest,commit,directory
Lucene -> public static SegmentInfos readSegmentInfos(Directory directory) throws IOException;1525334055;Reads the segments infos, failing if it fails to load;public static SegmentInfos readSegmentInfos(Directory directory) throws IOException {_        return SegmentInfos.readLatestCommit(directory)__    };reads,the,segments,infos,failing,if,it,fails,to,load;public,static,segment,infos,read,segment,infos,directory,directory,throws,ioexception,return,segment,infos,read,latest,commit,directory
Lucene -> public static SegmentInfos readSegmentInfos(Directory directory) throws IOException;1535046779;Reads the segments infos, failing if it fails to load;public static SegmentInfos readSegmentInfos(Directory directory) throws IOException {_        return SegmentInfos.readLatestCommit(directory)__    };reads,the,segments,infos,failing,if,it,fails,to,load;public,static,segment,infos,read,segment,infos,directory,directory,throws,ioexception,return,segment,infos,read,latest,commit,directory
Lucene -> public static SegmentInfos readSegmentInfos(Directory directory) throws IOException;1535723122;Reads the segments infos, failing if it fails to load;public static SegmentInfos readSegmentInfos(Directory directory) throws IOException {_        return SegmentInfos.readLatestCommit(directory)__    };reads,the,segments,infos,failing,if,it,fails,to,load;public,static,segment,infos,read,segment,infos,directory,directory,throws,ioexception,return,segment,infos,read,latest,commit,directory
Lucene -> public static SegmentInfos readSegmentInfos(Directory directory) throws IOException;1536314350;Reads the segments infos, failing if it fails to load;public static SegmentInfos readSegmentInfos(Directory directory) throws IOException {_        return SegmentInfos.readLatestCommit(directory)__    };reads,the,segments,infos,failing,if,it,fails,to,load;public,static,segment,infos,read,segment,infos,directory,directory,throws,ioexception,return,segment,infos,read,latest,commit,directory
Lucene -> public static SegmentInfos readSegmentInfos(Directory directory) throws IOException;1536611444;Reads the segments infos, failing if it fails to load;public static SegmentInfos readSegmentInfos(Directory directory) throws IOException {_        return SegmentInfos.readLatestCommit(directory)__    };reads,the,segments,infos,failing,if,it,fails,to,load;public,static,segment,infos,read,segment,infos,directory,directory,throws,ioexception,return,segment,infos,read,latest,commit,directory
Lucene -> public static SegmentInfos readSegmentInfos(Directory directory) throws IOException;1537371806;Reads the segments infos, failing if it fails to load;public static SegmentInfos readSegmentInfos(Directory directory) throws IOException {_        return SegmentInfos.readLatestCommit(directory)__    };reads,the,segments,infos,failing,if,it,fails,to,load;public,static,segment,infos,read,segment,infos,directory,directory,throws,ioexception,return,segment,infos,read,latest,commit,directory
Lucene -> public static SegmentInfos readSegmentInfos(Directory directory) throws IOException;1539815831;Reads the segments infos, failing if it fails to load;public static SegmentInfos readSegmentInfos(Directory directory) throws IOException {_        return SegmentInfos.readLatestCommit(directory)__    };reads,the,segments,infos,failing,if,it,fails,to,load;public,static,segment,infos,read,segment,infos,directory,directory,throws,ioexception,return,segment,infos,read,latest,commit,directory
Lucene -> public static SegmentInfos readSegmentInfos(Directory directory) throws IOException;1540238977;Reads the segments infos, failing if it fails to load;public static SegmentInfos readSegmentInfos(Directory directory) throws IOException {_        return SegmentInfos.readLatestCommit(directory)__    };reads,the,segments,infos,failing,if,it,fails,to,load;public,static,segment,infos,read,segment,infos,directory,directory,throws,ioexception,return,segment,infos,read,latest,commit,directory
Lucene -> public static SegmentInfos readSegmentInfos(Directory directory) throws IOException;1541592065;Reads the segments infos, failing if it fails to load;public static SegmentInfos readSegmentInfos(Directory directory) throws IOException {_        return SegmentInfos.readLatestCommit(directory)__    };reads,the,segments,infos,failing,if,it,fails,to,load;public,static,segment,infos,read,segment,infos,directory,directory,throws,ioexception,return,segment,infos,read,latest,commit,directory
Lucene -> public static SegmentInfos readSegmentInfos(Directory directory) throws IOException;1541618615;Reads the segments infos, failing if it fails to load;public static SegmentInfos readSegmentInfos(Directory directory) throws IOException {_        return SegmentInfos.readLatestCommit(directory)__    };reads,the,segments,infos,failing,if,it,fails,to,load;public,static,segment,infos,read,segment,infos,directory,directory,throws,ioexception,return,segment,infos,read,latest,commit,directory
Lucene -> public static SegmentInfos readSegmentInfos(Directory directory) throws IOException;1544076142;Reads the segments infos, failing if it fails to load;public static SegmentInfos readSegmentInfos(Directory directory) throws IOException {_        return SegmentInfos.readLatestCommit(directory)__    };reads,the,segments,infos,failing,if,it,fails,to,load;public,static,segment,infos,read,segment,infos,directory,directory,throws,ioexception,return,segment,infos,read,latest,commit,directory
Lucene -> public static SegmentInfos readSegmentInfos(Directory directory) throws IOException;1544322276;Reads the segments infos, failing if it fails to load;public static SegmentInfos readSegmentInfos(Directory directory) throws IOException {_        return SegmentInfos.readLatestCommit(directory)__    };reads,the,segments,infos,failing,if,it,fails,to,load;public,static,segment,infos,read,segment,infos,directory,directory,throws,ioexception,return,segment,infos,read,latest,commit,directory
Lucene -> public static SegmentInfos readSegmentInfos(Directory directory) throws IOException;1544786574;Reads the segments infos, failing if it fails to load;public static SegmentInfos readSegmentInfos(Directory directory) throws IOException {_        return SegmentInfos.readLatestCommit(directory)__    };reads,the,segments,infos,failing,if,it,fails,to,load;public,static,segment,infos,read,segment,infos,directory,directory,throws,ioexception,return,segment,infos,read,latest,commit,directory
Lucene -> public static LeafReader emptyReader(final int maxDoc);1541618615;Returns an empty leaf reader with the given max docs. The reader will be fully deleted.;public static LeafReader emptyReader(final int maxDoc) {_        return new LeafReader() {_            final Bits liveDocs = new Bits.MatchNoBits(maxDoc)___            public Terms terms(String field) {_                return null__            }__            public NumericDocValues getNumericDocValues(String field) {_                return null__            }__            public BinaryDocValues getBinaryDocValues(String field) {_                return null__            }__            public SortedDocValues getSortedDocValues(String field) {_                return null__            }__            public SortedNumericDocValues getSortedNumericDocValues(String field) {_                return null__            }__            public SortedSetDocValues getSortedSetDocValues(String field) {_                return null__            }__            public NumericDocValues getNormValues(String field) {_                return null__            }__            public FieldInfos getFieldInfos() {_                return new FieldInfos(new FieldInfo[0])__            }__            public Bits getLiveDocs() {_                return this.liveDocs__            }__            public PointValues getPointValues(String fieldName) {_                return null__            }__            public void checkIntegrity() {_            }__            public Fields getTermVectors(int docID) {_                return null__            }__            public int numDocs() {_                return 0__            }__            public int maxDoc() {_                return maxDoc__            }__            public void document(int docID, StoredFieldVisitor visitor) {_            }__            protected void doClose() {_            }__            public LeafMetaData getMetaData() {_                return new LeafMetaData(Version.LATEST.major, Version.LATEST, (Sort)null)__            }__            public CacheHelper getCoreCacheHelper() {_                return null__            }__            public CacheHelper getReaderCacheHelper() {_                return null__            }_        }__    };returns,an,empty,leaf,reader,with,the,given,max,docs,the,reader,will,be,fully,deleted;public,static,leaf,reader,empty,reader,final,int,max,doc,return,new,leaf,reader,final,bits,live,docs,new,bits,match,no,bits,max,doc,public,terms,terms,string,field,return,null,public,numeric,doc,values,get,numeric,doc,values,string,field,return,null,public,binary,doc,values,get,binary,doc,values,string,field,return,null,public,sorted,doc,values,get,sorted,doc,values,string,field,return,null,public,sorted,numeric,doc,values,get,sorted,numeric,doc,values,string,field,return,null,public,sorted,set,doc,values,get,sorted,set,doc,values,string,field,return,null,public,numeric,doc,values,get,norm,values,string,field,return,null,public,field,infos,get,field,infos,return,new,field,infos,new,field,info,0,public,bits,get,live,docs,return,this,live,docs,public,point,values,get,point,values,string,field,name,return,null,public,void,check,integrity,public,fields,get,term,vectors,int,doc,id,return,null,public,int,num,docs,return,0,public,int,max,doc,return,max,doc,public,void,document,int,doc,id,stored,field,visitor,visitor,protected,void,do,close,public,leaf,meta,data,get,meta,data,return,new,leaf,meta,data,version,latest,major,version,latest,sort,null,public,cache,helper,get,core,cache,helper,return,null,public,cache,helper,get,reader,cache,helper,return,null
Lucene -> public static LeafReader emptyReader(final int maxDoc);1544076142;Returns an empty leaf reader with the given max docs. The reader will be fully deleted.;public static LeafReader emptyReader(final int maxDoc) {_        return new LeafReader() {_            final Bits liveDocs = new Bits.MatchNoBits(maxDoc)___            public Terms terms(String field) {_                return null__            }__            public NumericDocValues getNumericDocValues(String field) {_                return null__            }__            public BinaryDocValues getBinaryDocValues(String field) {_                return null__            }__            public SortedDocValues getSortedDocValues(String field) {_                return null__            }__            public SortedNumericDocValues getSortedNumericDocValues(String field) {_                return null__            }__            public SortedSetDocValues getSortedSetDocValues(String field) {_                return null__            }__            public NumericDocValues getNormValues(String field) {_                return null__            }__            public FieldInfos getFieldInfos() {_                return new FieldInfos(new FieldInfo[0])__            }__            public Bits getLiveDocs() {_                return this.liveDocs__            }__            public PointValues getPointValues(String fieldName) {_                return null__            }__            public void checkIntegrity() {_            }__            public Fields getTermVectors(int docID) {_                return null__            }__            public int numDocs() {_                return 0__            }__            public int maxDoc() {_                return maxDoc__            }__            public void document(int docID, StoredFieldVisitor visitor) {_            }__            protected void doClose() {_            }__            public LeafMetaData getMetaData() {_                return new LeafMetaData(Version.LATEST.major, Version.LATEST, (Sort)null)__            }__            public CacheHelper getCoreCacheHelper() {_                return null__            }__            public CacheHelper getReaderCacheHelper() {_                return null__            }_        }__    };returns,an,empty,leaf,reader,with,the,given,max,docs,the,reader,will,be,fully,deleted;public,static,leaf,reader,empty,reader,final,int,max,doc,return,new,leaf,reader,final,bits,live,docs,new,bits,match,no,bits,max,doc,public,terms,terms,string,field,return,null,public,numeric,doc,values,get,numeric,doc,values,string,field,return,null,public,binary,doc,values,get,binary,doc,values,string,field,return,null,public,sorted,doc,values,get,sorted,doc,values,string,field,return,null,public,sorted,numeric,doc,values,get,sorted,numeric,doc,values,string,field,return,null,public,sorted,set,doc,values,get,sorted,set,doc,values,string,field,return,null,public,numeric,doc,values,get,norm,values,string,field,return,null,public,field,infos,get,field,infos,return,new,field,infos,new,field,info,0,public,bits,get,live,docs,return,this,live,docs,public,point,values,get,point,values,string,field,name,return,null,public,void,check,integrity,public,fields,get,term,vectors,int,doc,id,return,null,public,int,num,docs,return,0,public,int,max,doc,return,max,doc,public,void,document,int,doc,id,stored,field,visitor,visitor,protected,void,do,close,public,leaf,meta,data,get,meta,data,return,new,leaf,meta,data,version,latest,major,version,latest,sort,null,public,cache,helper,get,core,cache,helper,return,null,public,cache,helper,get,reader,cache,helper,return,null
Lucene -> public static LeafReader emptyReader(final int maxDoc);1544322276;Returns an empty leaf reader with the given max docs. The reader will be fully deleted.;public static LeafReader emptyReader(final int maxDoc) {_        return new LeafReader() {_            final Bits liveDocs = new Bits.MatchNoBits(maxDoc)___            public Terms terms(String field) {_                return null__            }__            public NumericDocValues getNumericDocValues(String field) {_                return null__            }__            public BinaryDocValues getBinaryDocValues(String field) {_                return null__            }__            public SortedDocValues getSortedDocValues(String field) {_                return null__            }__            public SortedNumericDocValues getSortedNumericDocValues(String field) {_                return null__            }__            public SortedSetDocValues getSortedSetDocValues(String field) {_                return null__            }__            public NumericDocValues getNormValues(String field) {_                return null__            }__            public FieldInfos getFieldInfos() {_                return new FieldInfos(new FieldInfo[0])__            }__            public Bits getLiveDocs() {_                return this.liveDocs__            }__            public PointValues getPointValues(String fieldName) {_                return null__            }__            public void checkIntegrity() {_            }__            public Fields getTermVectors(int docID) {_                return null__            }__            public int numDocs() {_                return 0__            }__            public int maxDoc() {_                return maxDoc__            }__            public void document(int docID, StoredFieldVisitor visitor) {_            }__            protected void doClose() {_            }__            public LeafMetaData getMetaData() {_                return new LeafMetaData(Version.LATEST.major, Version.LATEST, (Sort)null)__            }__            public CacheHelper getCoreCacheHelper() {_                return null__            }__            public CacheHelper getReaderCacheHelper() {_                return null__            }_        }__    };returns,an,empty,leaf,reader,with,the,given,max,docs,the,reader,will,be,fully,deleted;public,static,leaf,reader,empty,reader,final,int,max,doc,return,new,leaf,reader,final,bits,live,docs,new,bits,match,no,bits,max,doc,public,terms,terms,string,field,return,null,public,numeric,doc,values,get,numeric,doc,values,string,field,return,null,public,binary,doc,values,get,binary,doc,values,string,field,return,null,public,sorted,doc,values,get,sorted,doc,values,string,field,return,null,public,sorted,numeric,doc,values,get,sorted,numeric,doc,values,string,field,return,null,public,sorted,set,doc,values,get,sorted,set,doc,values,string,field,return,null,public,numeric,doc,values,get,norm,values,string,field,return,null,public,field,infos,get,field,infos,return,new,field,infos,new,field,info,0,public,bits,get,live,docs,return,this,live,docs,public,point,values,get,point,values,string,field,name,return,null,public,void,check,integrity,public,fields,get,term,vectors,int,doc,id,return,null,public,int,num,docs,return,0,public,int,max,doc,return,max,doc,public,void,document,int,doc,id,stored,field,visitor,visitor,protected,void,do,close,public,leaf,meta,data,get,meta,data,return,new,leaf,meta,data,version,latest,major,version,latest,sort,null,public,cache,helper,get,core,cache,helper,return,null,public,cache,helper,get,reader,cache,helper,return,null
Lucene -> public static LeafReader emptyReader(final int maxDoc);1544786574;Returns an empty leaf reader with the given max docs. The reader will be fully deleted.;public static LeafReader emptyReader(final int maxDoc) {_        return new LeafReader() {_            final Bits liveDocs = new Bits.MatchNoBits(maxDoc)___            public Terms terms(String field) {_                return null__            }__            public NumericDocValues getNumericDocValues(String field) {_                return null__            }__            public BinaryDocValues getBinaryDocValues(String field) {_                return null__            }__            public SortedDocValues getSortedDocValues(String field) {_                return null__            }__            public SortedNumericDocValues getSortedNumericDocValues(String field) {_                return null__            }__            public SortedSetDocValues getSortedSetDocValues(String field) {_                return null__            }__            public NumericDocValues getNormValues(String field) {_                return null__            }__            public FieldInfos getFieldInfos() {_                return new FieldInfos(new FieldInfo[0])__            }__            public Bits getLiveDocs() {_                return this.liveDocs__            }__            public PointValues getPointValues(String fieldName) {_                return null__            }__            public void checkIntegrity() {_            }__            public Fields getTermVectors(int docID) {_                return null__            }__            public int numDocs() {_                return 0__            }__            public int maxDoc() {_                return maxDoc__            }__            public void document(int docID, StoredFieldVisitor visitor) {_            }__            protected void doClose() {_            }__            public LeafMetaData getMetaData() {_                return new LeafMetaData(Version.LATEST.major, Version.LATEST, null)__            }__            public CacheHelper getCoreCacheHelper() {_                return null__            }__            public CacheHelper getReaderCacheHelper() {_                return null__            }_        }__    };returns,an,empty,leaf,reader,with,the,given,max,docs,the,reader,will,be,fully,deleted;public,static,leaf,reader,empty,reader,final,int,max,doc,return,new,leaf,reader,final,bits,live,docs,new,bits,match,no,bits,max,doc,public,terms,terms,string,field,return,null,public,numeric,doc,values,get,numeric,doc,values,string,field,return,null,public,binary,doc,values,get,binary,doc,values,string,field,return,null,public,sorted,doc,values,get,sorted,doc,values,string,field,return,null,public,sorted,numeric,doc,values,get,sorted,numeric,doc,values,string,field,return,null,public,sorted,set,doc,values,get,sorted,set,doc,values,string,field,return,null,public,numeric,doc,values,get,norm,values,string,field,return,null,public,field,infos,get,field,infos,return,new,field,infos,new,field,info,0,public,bits,get,live,docs,return,this,live,docs,public,point,values,get,point,values,string,field,name,return,null,public,void,check,integrity,public,fields,get,term,vectors,int,doc,id,return,null,public,int,num,docs,return,0,public,int,max,doc,return,max,doc,public,void,document,int,doc,id,stored,field,visitor,visitor,protected,void,do,close,public,leaf,meta,data,get,meta,data,return,new,leaf,meta,data,version,latest,major,version,latest,null,public,cache,helper,get,core,cache,helper,return,null,public,cache,helper,get,reader,cache,helper,return,null
Lucene -> public static Scorer illegalScorer(final String message);1524684173;Return a Scorer that throws an ElasticsearchIllegalStateException_on all operations with the given message.;public static Scorer illegalScorer(final String message) {_        return new Scorer(null) {_            @Override_            public float score() throws IOException {_                throw new IllegalStateException(message)__            }_            @Override_            public int docID() {_                throw new IllegalStateException(message)__            }_            @Override_            public DocIdSetIterator iterator() {_                throw new IllegalStateException(message)__            }_        }__    };return,a,scorer,that,throws,an,elasticsearch,illegal,state,exception,on,all,operations,with,the,given,message;public,static,scorer,illegal,scorer,final,string,message,return,new,scorer,null,override,public,float,score,throws,ioexception,throw,new,illegal,state,exception,message,override,public,int,doc,id,throw,new,illegal,state,exception,message,override,public,doc,id,set,iterator,iterator,throw,new,illegal,state,exception,message
Lucene -> public static Scorer illegalScorer(final String message);1525334055;Return a Scorer that throws an ElasticsearchIllegalStateException_on all operations with the given message.;public static Scorer illegalScorer(final String message) {_        return new Scorer(null) {_            @Override_            public float score() throws IOException {_                throw new IllegalStateException(message)__            }_            @Override_            public int docID() {_                throw new IllegalStateException(message)__            }_            @Override_            public DocIdSetIterator iterator() {_                throw new IllegalStateException(message)__            }_        }__    };return,a,scorer,that,throws,an,elasticsearch,illegal,state,exception,on,all,operations,with,the,given,message;public,static,scorer,illegal,scorer,final,string,message,return,new,scorer,null,override,public,float,score,throws,ioexception,throw,new,illegal,state,exception,message,override,public,int,doc,id,throw,new,illegal,state,exception,message,override,public,doc,id,set,iterator,iterator,throw,new,illegal,state,exception,message
Lucene -> public static Scorer illegalScorer(final String message);1535046779;Return a Scorer that throws an ElasticsearchIllegalStateException_on all operations with the given message.;public static Scorer illegalScorer(final String message) {_        return new Scorer(null) {_            @Override_            public float score() throws IOException {_                throw new IllegalStateException(message)__            }_            @Override_            public int docID() {_                throw new IllegalStateException(message)__            }_            @Override_            public DocIdSetIterator iterator() {_                throw new IllegalStateException(message)__            }_        }__    };return,a,scorer,that,throws,an,elasticsearch,illegal,state,exception,on,all,operations,with,the,given,message;public,static,scorer,illegal,scorer,final,string,message,return,new,scorer,null,override,public,float,score,throws,ioexception,throw,new,illegal,state,exception,message,override,public,int,doc,id,throw,new,illegal,state,exception,message,override,public,doc,id,set,iterator,iterator,throw,new,illegal,state,exception,message
Lucene -> public static Scorer illegalScorer(final String message);1535723122;Return a Scorer that throws an ElasticsearchIllegalStateException_on all operations with the given message.;public static Scorer illegalScorer(final String message) {_        return new Scorer(null) {_            @Override_            public float score() throws IOException {_                throw new IllegalStateException(message)__            }_            @Override_            public int docID() {_                throw new IllegalStateException(message)__            }_            @Override_            public DocIdSetIterator iterator() {_                throw new IllegalStateException(message)__            }_        }__    };return,a,scorer,that,throws,an,elasticsearch,illegal,state,exception,on,all,operations,with,the,given,message;public,static,scorer,illegal,scorer,final,string,message,return,new,scorer,null,override,public,float,score,throws,ioexception,throw,new,illegal,state,exception,message,override,public,int,doc,id,throw,new,illegal,state,exception,message,override,public,doc,id,set,iterator,iterator,throw,new,illegal,state,exception,message
Lucene -> public static Scorer illegalScorer(final String message);1536314350;Return a Scorer that throws an ElasticsearchIllegalStateException_on all operations with the given message.;public static Scorer illegalScorer(final String message) {_        return new Scorer(null) {_            @Override_            public float score() throws IOException {_                throw new IllegalStateException(message)__            }_            @Override_            public int docID() {_                throw new IllegalStateException(message)__            }_            @Override_            public DocIdSetIterator iterator() {_                throw new IllegalStateException(message)__            }_            @Override_            public float getMaxScore(int upTo) throws IOException {_                throw new IllegalStateException(message)__            }_        }__    };return,a,scorer,that,throws,an,elasticsearch,illegal,state,exception,on,all,operations,with,the,given,message;public,static,scorer,illegal,scorer,final,string,message,return,new,scorer,null,override,public,float,score,throws,ioexception,throw,new,illegal,state,exception,message,override,public,int,doc,id,throw,new,illegal,state,exception,message,override,public,doc,id,set,iterator,iterator,throw,new,illegal,state,exception,message,override,public,float,get,max,score,int,up,to,throws,ioexception,throw,new,illegal,state,exception,message
Lucene -> public static NumericDocValuesField newSoftDeletesField();1535723122;Returns a numeric docvalues which can be used to soft-delete documents.;public static NumericDocValuesField newSoftDeletesField() {_        return new NumericDocValuesField(SOFT_DELETES_FIELD, 1)__    };returns,a,numeric,docvalues,which,can,be,used,to,soft,delete,documents;public,static,numeric,doc,values,field,new,soft,deletes,field,return,new,numeric,doc,values,field,1
Lucene -> public static NumericDocValuesField newSoftDeletesField();1536314350;Returns a numeric docvalues which can be used to soft-delete documents.;public static NumericDocValuesField newSoftDeletesField() {_        return new NumericDocValuesField(SOFT_DELETES_FIELD, 1)__    };returns,a,numeric,docvalues,which,can,be,used,to,soft,delete,documents;public,static,numeric,doc,values,field,new,soft,deletes,field,return,new,numeric,doc,values,field,1
Lucene -> public static NumericDocValuesField newSoftDeletesField();1536611444;Returns a numeric docvalues which can be used to soft-delete documents.;public static NumericDocValuesField newSoftDeletesField() {_        return new NumericDocValuesField(SOFT_DELETES_FIELD, 1)__    };returns,a,numeric,docvalues,which,can,be,used,to,soft,delete,documents;public,static,numeric,doc,values,field,new,soft,deletes,field,return,new,numeric,doc,values,field,1
Lucene -> public static NumericDocValuesField newSoftDeletesField();1537371806;Returns a numeric docvalues which can be used to soft-delete documents.;public static NumericDocValuesField newSoftDeletesField() {_        return new NumericDocValuesField(SOFT_DELETES_FIELD, 1)__    };returns,a,numeric,docvalues,which,can,be,used,to,soft,delete,documents;public,static,numeric,doc,values,field,new,soft,deletes,field,return,new,numeric,doc,values,field,1
Lucene -> public static NumericDocValuesField newSoftDeletesField();1539815831;Returns a numeric docvalues which can be used to soft-delete documents.;public static NumericDocValuesField newSoftDeletesField() {_        return new NumericDocValuesField(SOFT_DELETES_FIELD, 1)__    };returns,a,numeric,docvalues,which,can,be,used,to,soft,delete,documents;public,static,numeric,doc,values,field,new,soft,deletes,field,return,new,numeric,doc,values,field,1
Lucene -> public static NumericDocValuesField newSoftDeletesField();1540238977;Returns a numeric docvalues which can be used to soft-delete documents.;public static NumericDocValuesField newSoftDeletesField() {_        return new NumericDocValuesField(SOFT_DELETES_FIELD, 1)__    };returns,a,numeric,docvalues,which,can,be,used,to,soft,delete,documents;public,static,numeric,doc,values,field,new,soft,deletes,field,return,new,numeric,doc,values,field,1
Lucene -> public static NumericDocValuesField newSoftDeletesField();1541592065;Returns a numeric docvalues which can be used to soft-delete documents.;public static NumericDocValuesField newSoftDeletesField() {_        return new NumericDocValuesField(SOFT_DELETES_FIELD, 1)__    };returns,a,numeric,docvalues,which,can,be,used,to,soft,delete,documents;public,static,numeric,doc,values,field,new,soft,deletes,field,return,new,numeric,doc,values,field,1
Lucene -> public static NumericDocValuesField newSoftDeletesField();1541618615;Returns a numeric docvalues which can be used to soft-delete documents.;public static NumericDocValuesField newSoftDeletesField() {_        return new NumericDocValuesField(SOFT_DELETES_FIELD, 1)__    };returns,a,numeric,docvalues,which,can,be,used,to,soft,delete,documents;public,static,numeric,doc,values,field,new,soft,deletes,field,return,new,numeric,doc,values,field,1
Lucene -> public static NumericDocValuesField newSoftDeletesField();1544076142;Returns a numeric docvalues which can be used to soft-delete documents.;public static NumericDocValuesField newSoftDeletesField() {_        return new NumericDocValuesField(SOFT_DELETES_FIELD, 1)__    };returns,a,numeric,docvalues,which,can,be,used,to,soft,delete,documents;public,static,numeric,doc,values,field,new,soft,deletes,field,return,new,numeric,doc,values,field,1
Lucene -> public static NumericDocValuesField newSoftDeletesField();1544322276;Returns a numeric docvalues which can be used to soft-delete documents.;public static NumericDocValuesField newSoftDeletesField() {_        return new NumericDocValuesField(SOFT_DELETES_FIELD, 1)__    };returns,a,numeric,docvalues,which,can,be,used,to,soft,delete,documents;public,static,numeric,doc,values,field,new,soft,deletes,field,return,new,numeric,doc,values,field,1
Lucene -> public static NumericDocValuesField newSoftDeletesField();1544786574;Returns a numeric docvalues which can be used to soft-delete documents.;public static NumericDocValuesField newSoftDeletesField() {_        return new NumericDocValuesField(SOFT_DELETES_FIELD, 1)__    };returns,a,numeric,docvalues,which,can,be,used,to,soft,delete,documents;public,static,numeric,doc,values,field,new,soft,deletes,field,return,new,numeric,doc,values,field,1
Lucene -> public static boolean isCorruptionException(Throwable t);1524684173;Returns <tt>true</tt> iff the given exception or_one of it's causes is an instance of {@link CorruptIndexException},_{@link IndexFormatTooOldException}, or {@link IndexFormatTooNewException} otherwise <tt>false</tt>.;public static boolean isCorruptionException(Throwable t) {_        return ExceptionsHelper.unwrapCorruption(t) != null__    };returns,tt,true,tt,iff,the,given,exception,or,one,of,it,s,causes,is,an,instance,of,link,corrupt,index,exception,link,index,format,too,old,exception,or,link,index,format,too,new,exception,otherwise,tt,false,tt;public,static,boolean,is,corruption,exception,throwable,t,return,exceptions,helper,unwrap,corruption,t,null
Lucene -> public static boolean isCorruptionException(Throwable t);1525334055;Returns {@code true} iff the given exception or_one of it's causes is an instance of {@link CorruptIndexException},_{@link IndexFormatTooOldException}, or {@link IndexFormatTooNewException} otherwise {@code false}.;public static boolean isCorruptionException(Throwable t) {_        return ExceptionsHelper.unwrapCorruption(t) != null__    };returns,code,true,iff,the,given,exception,or,one,of,it,s,causes,is,an,instance,of,link,corrupt,index,exception,link,index,format,too,old,exception,or,link,index,format,too,new,exception,otherwise,code,false;public,static,boolean,is,corruption,exception,throwable,t,return,exceptions,helper,unwrap,corruption,t,null
Lucene -> public static boolean isCorruptionException(Throwable t);1535046779;Returns {@code true} iff the given exception or_one of it's causes is an instance of {@link CorruptIndexException},_{@link IndexFormatTooOldException}, or {@link IndexFormatTooNewException} otherwise {@code false}.;public static boolean isCorruptionException(Throwable t) {_        return ExceptionsHelper.unwrapCorruption(t) != null__    };returns,code,true,iff,the,given,exception,or,one,of,it,s,causes,is,an,instance,of,link,corrupt,index,exception,link,index,format,too,old,exception,or,link,index,format,too,new,exception,otherwise,code,false;public,static,boolean,is,corruption,exception,throwable,t,return,exceptions,helper,unwrap,corruption,t,null
Lucene -> public static boolean isCorruptionException(Throwable t);1535723122;Returns {@code true} iff the given exception or_one of it's causes is an instance of {@link CorruptIndexException},_{@link IndexFormatTooOldException}, or {@link IndexFormatTooNewException} otherwise {@code false}.;public static boolean isCorruptionException(Throwable t) {_        return ExceptionsHelper.unwrapCorruption(t) != null__    };returns,code,true,iff,the,given,exception,or,one,of,it,s,causes,is,an,instance,of,link,corrupt,index,exception,link,index,format,too,old,exception,or,link,index,format,too,new,exception,otherwise,code,false;public,static,boolean,is,corruption,exception,throwable,t,return,exceptions,helper,unwrap,corruption,t,null
Lucene -> public static boolean isCorruptionException(Throwable t);1536314350;Returns {@code true} iff the given exception or_one of it's causes is an instance of {@link CorruptIndexException},_{@link IndexFormatTooOldException}, or {@link IndexFormatTooNewException} otherwise {@code false}.;public static boolean isCorruptionException(Throwable t) {_        return ExceptionsHelper.unwrapCorruption(t) != null__    };returns,code,true,iff,the,given,exception,or,one,of,it,s,causes,is,an,instance,of,link,corrupt,index,exception,link,index,format,too,old,exception,or,link,index,format,too,new,exception,otherwise,code,false;public,static,boolean,is,corruption,exception,throwable,t,return,exceptions,helper,unwrap,corruption,t,null
Lucene -> public static boolean isCorruptionException(Throwable t);1536611444;Returns {@code true} iff the given exception or_one of it's causes is an instance of {@link CorruptIndexException},_{@link IndexFormatTooOldException}, or {@link IndexFormatTooNewException} otherwise {@code false}.;public static boolean isCorruptionException(Throwable t) {_        return ExceptionsHelper.unwrapCorruption(t) != null__    };returns,code,true,iff,the,given,exception,or,one,of,it,s,causes,is,an,instance,of,link,corrupt,index,exception,link,index,format,too,old,exception,or,link,index,format,too,new,exception,otherwise,code,false;public,static,boolean,is,corruption,exception,throwable,t,return,exceptions,helper,unwrap,corruption,t,null
Lucene -> public static boolean isCorruptionException(Throwable t);1537371806;Returns {@code true} iff the given exception or_one of it's causes is an instance of {@link CorruptIndexException},_{@link IndexFormatTooOldException}, or {@link IndexFormatTooNewException} otherwise {@code false}.;public static boolean isCorruptionException(Throwable t) {_        return ExceptionsHelper.unwrapCorruption(t) != null__    };returns,code,true,iff,the,given,exception,or,one,of,it,s,causes,is,an,instance,of,link,corrupt,index,exception,link,index,format,too,old,exception,or,link,index,format,too,new,exception,otherwise,code,false;public,static,boolean,is,corruption,exception,throwable,t,return,exceptions,helper,unwrap,corruption,t,null
Lucene -> public static boolean isCorruptionException(Throwable t);1539815831;Returns {@code true} iff the given exception or_one of it's causes is an instance of {@link CorruptIndexException},_{@link IndexFormatTooOldException}, or {@link IndexFormatTooNewException} otherwise {@code false}.;public static boolean isCorruptionException(Throwable t) {_        return ExceptionsHelper.unwrapCorruption(t) != null__    };returns,code,true,iff,the,given,exception,or,one,of,it,s,causes,is,an,instance,of,link,corrupt,index,exception,link,index,format,too,old,exception,or,link,index,format,too,new,exception,otherwise,code,false;public,static,boolean,is,corruption,exception,throwable,t,return,exceptions,helper,unwrap,corruption,t,null
Lucene -> public static boolean isCorruptionException(Throwable t);1540238977;Returns {@code true} iff the given exception or_one of it's causes is an instance of {@link CorruptIndexException},_{@link IndexFormatTooOldException}, or {@link IndexFormatTooNewException} otherwise {@code false}.;public static boolean isCorruptionException(Throwable t) {_        return ExceptionsHelper.unwrapCorruption(t) != null__    };returns,code,true,iff,the,given,exception,or,one,of,it,s,causes,is,an,instance,of,link,corrupt,index,exception,link,index,format,too,old,exception,or,link,index,format,too,new,exception,otherwise,code,false;public,static,boolean,is,corruption,exception,throwable,t,return,exceptions,helper,unwrap,corruption,t,null
Lucene -> public static boolean isCorruptionException(Throwable t);1541592065;Returns {@code true} iff the given exception or_one of it's causes is an instance of {@link CorruptIndexException},_{@link IndexFormatTooOldException}, or {@link IndexFormatTooNewException} otherwise {@code false}.;public static boolean isCorruptionException(Throwable t) {_        return ExceptionsHelper.unwrapCorruption(t) != null__    };returns,code,true,iff,the,given,exception,or,one,of,it,s,causes,is,an,instance,of,link,corrupt,index,exception,link,index,format,too,old,exception,or,link,index,format,too,new,exception,otherwise,code,false;public,static,boolean,is,corruption,exception,throwable,t,return,exceptions,helper,unwrap,corruption,t,null
Lucene -> public static boolean isCorruptionException(Throwable t);1541618615;Returns {@code true} iff the given exception or_one of it's causes is an instance of {@link CorruptIndexException},_{@link IndexFormatTooOldException}, or {@link IndexFormatTooNewException} otherwise {@code false}.;public static boolean isCorruptionException(Throwable t) {_        return ExceptionsHelper.unwrapCorruption(t) != null__    };returns,code,true,iff,the,given,exception,or,one,of,it,s,causes,is,an,instance,of,link,corrupt,index,exception,link,index,format,too,old,exception,or,link,index,format,too,new,exception,otherwise,code,false;public,static,boolean,is,corruption,exception,throwable,t,return,exceptions,helper,unwrap,corruption,t,null
Lucene -> public static boolean isCorruptionException(Throwable t);1544076142;Returns {@code true} iff the given exception or_one of it's causes is an instance of {@link CorruptIndexException},_{@link IndexFormatTooOldException}, or {@link IndexFormatTooNewException} otherwise {@code false}.;public static boolean isCorruptionException(Throwable t) {_        return ExceptionsHelper.unwrapCorruption(t) != null__    };returns,code,true,iff,the,given,exception,or,one,of,it,s,causes,is,an,instance,of,link,corrupt,index,exception,link,index,format,too,old,exception,or,link,index,format,too,new,exception,otherwise,code,false;public,static,boolean,is,corruption,exception,throwable,t,return,exceptions,helper,unwrap,corruption,t,null
Lucene -> public static boolean isCorruptionException(Throwable t);1544322276;Returns {@code true} iff the given exception or_one of it's causes is an instance of {@link CorruptIndexException},_{@link IndexFormatTooOldException}, or {@link IndexFormatTooNewException} otherwise {@code false}.;public static boolean isCorruptionException(Throwable t) {_        return ExceptionsHelper.unwrapCorruption(t) != null__    };returns,code,true,iff,the,given,exception,or,one,of,it,s,causes,is,an,instance,of,link,corrupt,index,exception,link,index,format,too,old,exception,or,link,index,format,too,new,exception,otherwise,code,false;public,static,boolean,is,corruption,exception,throwable,t,return,exceptions,helper,unwrap,corruption,t,null
Lucene -> public static boolean isCorruptionException(Throwable t);1544786574;Returns {@code true} iff the given exception or_one of it's causes is an instance of {@link CorruptIndexException},_{@link IndexFormatTooOldException}, or {@link IndexFormatTooNewException} otherwise {@code false}.;public static boolean isCorruptionException(Throwable t) {_        return ExceptionsHelper.unwrapCorruption(t) != null__    };returns,code,true,iff,the,given,exception,or,one,of,it,s,causes,is,an,instance,of,link,corrupt,index,exception,link,index,format,too,old,exception,or,link,index,format,too,new,exception,otherwise,code,false;public,static,boolean,is,corruption,exception,throwable,t,return,exceptions,helper,unwrap,corruption,t,null
Lucene -> public static Bits asSequentialAccessBits(final int maxDoc, @Nullable ScorerSupplier scorerSupplier) throws IOException;1524684173;Given a {@link ScorerSupplier}, return a {@link Bits} instance that will match_all documents contained in the set. Note that the returned {@link Bits}_instance MUST be consumed in order.;public static Bits asSequentialAccessBits(final int maxDoc, @Nullable ScorerSupplier scorerSupplier) throws IOException {_        if (scorerSupplier == null) {_            return new Bits.MatchNoBits(maxDoc)__        }_        _        final Scorer scorer = scorerSupplier.get(Long.MAX_VALUE)_ _        final TwoPhaseIterator twoPhase = scorer.twoPhaseIterator()__        final DocIdSetIterator iterator__        if (twoPhase == null) {_            iterator = scorer.iterator()__        } else {_            iterator = twoPhase.approximation()__        }__        return new Bits() {__            int previous = -1__            boolean previousMatched = false___            @Override_            public boolean get(int index) {_                if (index < 0 || index >= maxDoc) {_                    throw new IndexOutOfBoundsException(index + " is out of bounds: [" + 0 + "-" + maxDoc + "[")__                }_                if (index < previous) {_                    throw new IllegalArgumentException("This Bits instance can only be consumed in order. "_                            + "Got called on [" + index + "] while previously called on [" + previous + "]")__                }_                if (index == previous) {_                    _                    _                    return previousMatched__                }_                previous = index___                int doc = iterator.docID()__                if (doc < index) {_                    try {_                        doc = iterator.advance(index)__                    } catch (IOException e) {_                        throw new IllegalStateException("Cannot advance iterator", e)__                    }_                }_                if (index == doc) {_                    try {_                        return previousMatched = twoPhase == null || twoPhase.matches()__                    } catch (IOException e) {_                        throw new IllegalStateException("Cannot validate match", e)__                    }_                }_                return previousMatched = false__            }__            @Override_            public int length() {_                return maxDoc__            }_        }__    };given,a,link,scorer,supplier,return,a,link,bits,instance,that,will,match,all,documents,contained,in,the,set,note,that,the,returned,link,bits,instance,must,be,consumed,in,order;public,static,bits,as,sequential,access,bits,final,int,max,doc,nullable,scorer,supplier,scorer,supplier,throws,ioexception,if,scorer,supplier,null,return,new,bits,match,no,bits,max,doc,final,scorer,scorer,scorer,supplier,get,long,final,two,phase,iterator,two,phase,scorer,two,phase,iterator,final,doc,id,set,iterator,iterator,if,two,phase,null,iterator,scorer,iterator,else,iterator,two,phase,approximation,return,new,bits,int,previous,1,boolean,previous,matched,false,override,public,boolean,get,int,index,if,index,0,index,max,doc,throw,new,index,out,of,bounds,exception,index,is,out,of,bounds,0,max,doc,if,index,previous,throw,new,illegal,argument,exception,this,bits,instance,can,only,be,consumed,in,order,got,called,on,index,while,previously,called,on,previous,if,index,previous,return,previous,matched,previous,index,int,doc,iterator,doc,id,if,doc,index,try,doc,iterator,advance,index,catch,ioexception,e,throw,new,illegal,state,exception,cannot,advance,iterator,e,if,index,doc,try,return,previous,matched,two,phase,null,two,phase,matches,catch,ioexception,e,throw,new,illegal,state,exception,cannot,validate,match,e,return,previous,matched,false,override,public,int,length,return,max,doc
Lucene -> public static Bits asSequentialAccessBits(final int maxDoc, @Nullable ScorerSupplier scorerSupplier) throws IOException;1525334055;Given a {@link ScorerSupplier}, return a {@link Bits} instance that will match_all documents contained in the set. Note that the returned {@link Bits}_instance MUST be consumed in order.;public static Bits asSequentialAccessBits(final int maxDoc, @Nullable ScorerSupplier scorerSupplier) throws IOException {_        if (scorerSupplier == null) {_            return new Bits.MatchNoBits(maxDoc)__        }_        _        final Scorer scorer = scorerSupplier.get(Long.MAX_VALUE)_ _        final TwoPhaseIterator twoPhase = scorer.twoPhaseIterator()__        final DocIdSetIterator iterator__        if (twoPhase == null) {_            iterator = scorer.iterator()__        } else {_            iterator = twoPhase.approximation()__        }__        return new Bits() {__            int previous = -1__            boolean previousMatched = false___            @Override_            public boolean get(int index) {_                if (index < 0 || index >= maxDoc) {_                    throw new IndexOutOfBoundsException(index + " is out of bounds: [" + 0 + "-" + maxDoc + "[")__                }_                if (index < previous) {_                    throw new IllegalArgumentException("This Bits instance can only be consumed in order. "_                            + "Got called on [" + index + "] while previously called on [" + previous + "]")__                }_                if (index == previous) {_                    _                    _                    return previousMatched__                }_                previous = index___                int doc = iterator.docID()__                if (doc < index) {_                    try {_                        doc = iterator.advance(index)__                    } catch (IOException e) {_                        throw new IllegalStateException("Cannot advance iterator", e)__                    }_                }_                if (index == doc) {_                    try {_                        return previousMatched = twoPhase == null || twoPhase.matches()__                    } catch (IOException e) {_                        throw new IllegalStateException("Cannot validate match", e)__                    }_                }_                return previousMatched = false__            }__            @Override_            public int length() {_                return maxDoc__            }_        }__    };given,a,link,scorer,supplier,return,a,link,bits,instance,that,will,match,all,documents,contained,in,the,set,note,that,the,returned,link,bits,instance,must,be,consumed,in,order;public,static,bits,as,sequential,access,bits,final,int,max,doc,nullable,scorer,supplier,scorer,supplier,throws,ioexception,if,scorer,supplier,null,return,new,bits,match,no,bits,max,doc,final,scorer,scorer,scorer,supplier,get,long,final,two,phase,iterator,two,phase,scorer,two,phase,iterator,final,doc,id,set,iterator,iterator,if,two,phase,null,iterator,scorer,iterator,else,iterator,two,phase,approximation,return,new,bits,int,previous,1,boolean,previous,matched,false,override,public,boolean,get,int,index,if,index,0,index,max,doc,throw,new,index,out,of,bounds,exception,index,is,out,of,bounds,0,max,doc,if,index,previous,throw,new,illegal,argument,exception,this,bits,instance,can,only,be,consumed,in,order,got,called,on,index,while,previously,called,on,previous,if,index,previous,return,previous,matched,previous,index,int,doc,iterator,doc,id,if,doc,index,try,doc,iterator,advance,index,catch,ioexception,e,throw,new,illegal,state,exception,cannot,advance,iterator,e,if,index,doc,try,return,previous,matched,two,phase,null,two,phase,matches,catch,ioexception,e,throw,new,illegal,state,exception,cannot,validate,match,e,return,previous,matched,false,override,public,int,length,return,max,doc
Lucene -> public static Bits asSequentialAccessBits(final int maxDoc, @Nullable ScorerSupplier scorerSupplier) throws IOException;1535046779;Given a {@link ScorerSupplier}, return a {@link Bits} instance that will match_all documents contained in the set. Note that the returned {@link Bits}_instance MUST be consumed in order.;public static Bits asSequentialAccessBits(final int maxDoc, @Nullable ScorerSupplier scorerSupplier) throws IOException {_        if (scorerSupplier == null) {_            return new Bits.MatchNoBits(maxDoc)__        }_        _        final Scorer scorer = scorerSupplier.get(Long.MAX_VALUE)_ _        final TwoPhaseIterator twoPhase = scorer.twoPhaseIterator()__        final DocIdSetIterator iterator__        if (twoPhase == null) {_            iterator = scorer.iterator()__        } else {_            iterator = twoPhase.approximation()__        }__        return new Bits() {__            int previous = -1__            boolean previousMatched = false___            @Override_            public boolean get(int index) {_                if (index < 0 || index >= maxDoc) {_                    throw new IndexOutOfBoundsException(index + " is out of bounds: [" + 0 + "-" + maxDoc + "[")__                }_                if (index < previous) {_                    throw new IllegalArgumentException("This Bits instance can only be consumed in order. "_                            + "Got called on [" + index + "] while previously called on [" + previous + "]")__                }_                if (index == previous) {_                    _                    _                    return previousMatched__                }_                previous = index___                int doc = iterator.docID()__                if (doc < index) {_                    try {_                        doc = iterator.advance(index)__                    } catch (IOException e) {_                        throw new IllegalStateException("Cannot advance iterator", e)__                    }_                }_                if (index == doc) {_                    try {_                        return previousMatched = twoPhase == null || twoPhase.matches()__                    } catch (IOException e) {_                        throw new IllegalStateException("Cannot validate match", e)__                    }_                }_                return previousMatched = false__            }__            @Override_            public int length() {_                return maxDoc__            }_        }__    };given,a,link,scorer,supplier,return,a,link,bits,instance,that,will,match,all,documents,contained,in,the,set,note,that,the,returned,link,bits,instance,must,be,consumed,in,order;public,static,bits,as,sequential,access,bits,final,int,max,doc,nullable,scorer,supplier,scorer,supplier,throws,ioexception,if,scorer,supplier,null,return,new,bits,match,no,bits,max,doc,final,scorer,scorer,scorer,supplier,get,long,final,two,phase,iterator,two,phase,scorer,two,phase,iterator,final,doc,id,set,iterator,iterator,if,two,phase,null,iterator,scorer,iterator,else,iterator,two,phase,approximation,return,new,bits,int,previous,1,boolean,previous,matched,false,override,public,boolean,get,int,index,if,index,0,index,max,doc,throw,new,index,out,of,bounds,exception,index,is,out,of,bounds,0,max,doc,if,index,previous,throw,new,illegal,argument,exception,this,bits,instance,can,only,be,consumed,in,order,got,called,on,index,while,previously,called,on,previous,if,index,previous,return,previous,matched,previous,index,int,doc,iterator,doc,id,if,doc,index,try,doc,iterator,advance,index,catch,ioexception,e,throw,new,illegal,state,exception,cannot,advance,iterator,e,if,index,doc,try,return,previous,matched,two,phase,null,two,phase,matches,catch,ioexception,e,throw,new,illegal,state,exception,cannot,validate,match,e,return,previous,matched,false,override,public,int,length,return,max,doc
Lucene -> public static Bits asSequentialAccessBits(final int maxDoc, @Nullable ScorerSupplier scorerSupplier) throws IOException;1535723122;Given a {@link ScorerSupplier}, return a {@link Bits} instance that will match_all documents contained in the set. Note that the returned {@link Bits}_instance MUST be consumed in order.;public static Bits asSequentialAccessBits(final int maxDoc, @Nullable ScorerSupplier scorerSupplier) throws IOException {_        if (scorerSupplier == null) {_            return new Bits.MatchNoBits(maxDoc)__        }_        _        final Scorer scorer = scorerSupplier.get(Long.MAX_VALUE)_ _        final TwoPhaseIterator twoPhase = scorer.twoPhaseIterator()__        final DocIdSetIterator iterator__        if (twoPhase == null) {_            iterator = scorer.iterator()__        } else {_            iterator = twoPhase.approximation()__        }__        return new Bits() {__            int previous = -1__            boolean previousMatched = false___            @Override_            public boolean get(int index) {_                if (index < 0 || index >= maxDoc) {_                    throw new IndexOutOfBoundsException(index + " is out of bounds: [" + 0 + "-" + maxDoc + "[")__                }_                if (index < previous) {_                    throw new IllegalArgumentException("This Bits instance can only be consumed in order. "_                            + "Got called on [" + index + "] while previously called on [" + previous + "]")__                }_                if (index == previous) {_                    _                    _                    return previousMatched__                }_                previous = index___                int doc = iterator.docID()__                if (doc < index) {_                    try {_                        doc = iterator.advance(index)__                    } catch (IOException e) {_                        throw new IllegalStateException("Cannot advance iterator", e)__                    }_                }_                if (index == doc) {_                    try {_                        return previousMatched = twoPhase == null || twoPhase.matches()__                    } catch (IOException e) {_                        throw new IllegalStateException("Cannot validate match", e)__                    }_                }_                return previousMatched = false__            }__            @Override_            public int length() {_                return maxDoc__            }_        }__    };given,a,link,scorer,supplier,return,a,link,bits,instance,that,will,match,all,documents,contained,in,the,set,note,that,the,returned,link,bits,instance,must,be,consumed,in,order;public,static,bits,as,sequential,access,bits,final,int,max,doc,nullable,scorer,supplier,scorer,supplier,throws,ioexception,if,scorer,supplier,null,return,new,bits,match,no,bits,max,doc,final,scorer,scorer,scorer,supplier,get,long,final,two,phase,iterator,two,phase,scorer,two,phase,iterator,final,doc,id,set,iterator,iterator,if,two,phase,null,iterator,scorer,iterator,else,iterator,two,phase,approximation,return,new,bits,int,previous,1,boolean,previous,matched,false,override,public,boolean,get,int,index,if,index,0,index,max,doc,throw,new,index,out,of,bounds,exception,index,is,out,of,bounds,0,max,doc,if,index,previous,throw,new,illegal,argument,exception,this,bits,instance,can,only,be,consumed,in,order,got,called,on,index,while,previously,called,on,previous,if,index,previous,return,previous,matched,previous,index,int,doc,iterator,doc,id,if,doc,index,try,doc,iterator,advance,index,catch,ioexception,e,throw,new,illegal,state,exception,cannot,advance,iterator,e,if,index,doc,try,return,previous,matched,two,phase,null,two,phase,matches,catch,ioexception,e,throw,new,illegal,state,exception,cannot,validate,match,e,return,previous,matched,false,override,public,int,length,return,max,doc
Lucene -> public static Bits asSequentialAccessBits(final int maxDoc, @Nullable ScorerSupplier scorerSupplier) throws IOException;1536314350;Given a {@link ScorerSupplier}, return a {@link Bits} instance that will match_all documents contained in the set. Note that the returned {@link Bits}_instance MUST be consumed in order.;public static Bits asSequentialAccessBits(final int maxDoc, @Nullable ScorerSupplier scorerSupplier) throws IOException {_        if (scorerSupplier == null) {_            return new Bits.MatchNoBits(maxDoc)__        }_        _        final Scorer scorer = scorerSupplier.get(Long.MAX_VALUE)_ _        final TwoPhaseIterator twoPhase = scorer.twoPhaseIterator()__        final DocIdSetIterator iterator__        if (twoPhase == null) {_            iterator = scorer.iterator()__        } else {_            iterator = twoPhase.approximation()__        }__        return new Bits() {__            int previous = -1__            boolean previousMatched = false___            @Override_            public boolean get(int index) {_                if (index < 0 || index >= maxDoc) {_                    throw new IndexOutOfBoundsException(index + " is out of bounds: [" + 0 + "-" + maxDoc + "[")__                }_                if (index < previous) {_                    throw new IllegalArgumentException("This Bits instance can only be consumed in order. "_                            + "Got called on [" + index + "] while previously called on [" + previous + "]")__                }_                if (index == previous) {_                    _                    _                    return previousMatched__                }_                previous = index___                int doc = iterator.docID()__                if (doc < index) {_                    try {_                        doc = iterator.advance(index)__                    } catch (IOException e) {_                        throw new IllegalStateException("Cannot advance iterator", e)__                    }_                }_                if (index == doc) {_                    try {_                        return previousMatched = twoPhase == null || twoPhase.matches()__                    } catch (IOException e) {_                        throw new IllegalStateException("Cannot validate match", e)__                    }_                }_                return previousMatched = false__            }__            @Override_            public int length() {_                return maxDoc__            }_        }__    };given,a,link,scorer,supplier,return,a,link,bits,instance,that,will,match,all,documents,contained,in,the,set,note,that,the,returned,link,bits,instance,must,be,consumed,in,order;public,static,bits,as,sequential,access,bits,final,int,max,doc,nullable,scorer,supplier,scorer,supplier,throws,ioexception,if,scorer,supplier,null,return,new,bits,match,no,bits,max,doc,final,scorer,scorer,scorer,supplier,get,long,final,two,phase,iterator,two,phase,scorer,two,phase,iterator,final,doc,id,set,iterator,iterator,if,two,phase,null,iterator,scorer,iterator,else,iterator,two,phase,approximation,return,new,bits,int,previous,1,boolean,previous,matched,false,override,public,boolean,get,int,index,if,index,0,index,max,doc,throw,new,index,out,of,bounds,exception,index,is,out,of,bounds,0,max,doc,if,index,previous,throw,new,illegal,argument,exception,this,bits,instance,can,only,be,consumed,in,order,got,called,on,index,while,previously,called,on,previous,if,index,previous,return,previous,matched,previous,index,int,doc,iterator,doc,id,if,doc,index,try,doc,iterator,advance,index,catch,ioexception,e,throw,new,illegal,state,exception,cannot,advance,iterator,e,if,index,doc,try,return,previous,matched,two,phase,null,two,phase,matches,catch,ioexception,e,throw,new,illegal,state,exception,cannot,validate,match,e,return,previous,matched,false,override,public,int,length,return,max,doc
Lucene -> public static Bits asSequentialAccessBits(final int maxDoc, @Nullable ScorerSupplier scorerSupplier) throws IOException;1536611444;Given a {@link ScorerSupplier}, return a {@link Bits} instance that will match_all documents contained in the set. Note that the returned {@link Bits}_instance MUST be consumed in order.;public static Bits asSequentialAccessBits(final int maxDoc, @Nullable ScorerSupplier scorerSupplier) throws IOException {_        if (scorerSupplier == null) {_            return new Bits.MatchNoBits(maxDoc)__        }_        _        final Scorer scorer = scorerSupplier.get(Long.MAX_VALUE)_ _        final TwoPhaseIterator twoPhase = scorer.twoPhaseIterator()__        final DocIdSetIterator iterator__        if (twoPhase == null) {_            iterator = scorer.iterator()__        } else {_            iterator = twoPhase.approximation()__        }__        return new Bits() {__            int previous = -1__            boolean previousMatched = false___            @Override_            public boolean get(int index) {_                if (index < 0 || index >= maxDoc) {_                    throw new IndexOutOfBoundsException(index + " is out of bounds: [" + 0 + "-" + maxDoc + "[")__                }_                if (index < previous) {_                    throw new IllegalArgumentException("This Bits instance can only be consumed in order. "_                            + "Got called on [" + index + "] while previously called on [" + previous + "]")__                }_                if (index == previous) {_                    _                    _                    return previousMatched__                }_                previous = index___                int doc = iterator.docID()__                if (doc < index) {_                    try {_                        doc = iterator.advance(index)__                    } catch (IOException e) {_                        throw new IllegalStateException("Cannot advance iterator", e)__                    }_                }_                if (index == doc) {_                    try {_                        return previousMatched = twoPhase == null || twoPhase.matches()__                    } catch (IOException e) {_                        throw new IllegalStateException("Cannot validate match", e)__                    }_                }_                return previousMatched = false__            }__            @Override_            public int length() {_                return maxDoc__            }_        }__    };given,a,link,scorer,supplier,return,a,link,bits,instance,that,will,match,all,documents,contained,in,the,set,note,that,the,returned,link,bits,instance,must,be,consumed,in,order;public,static,bits,as,sequential,access,bits,final,int,max,doc,nullable,scorer,supplier,scorer,supplier,throws,ioexception,if,scorer,supplier,null,return,new,bits,match,no,bits,max,doc,final,scorer,scorer,scorer,supplier,get,long,final,two,phase,iterator,two,phase,scorer,two,phase,iterator,final,doc,id,set,iterator,iterator,if,two,phase,null,iterator,scorer,iterator,else,iterator,two,phase,approximation,return,new,bits,int,previous,1,boolean,previous,matched,false,override,public,boolean,get,int,index,if,index,0,index,max,doc,throw,new,index,out,of,bounds,exception,index,is,out,of,bounds,0,max,doc,if,index,previous,throw,new,illegal,argument,exception,this,bits,instance,can,only,be,consumed,in,order,got,called,on,index,while,previously,called,on,previous,if,index,previous,return,previous,matched,previous,index,int,doc,iterator,doc,id,if,doc,index,try,doc,iterator,advance,index,catch,ioexception,e,throw,new,illegal,state,exception,cannot,advance,iterator,e,if,index,doc,try,return,previous,matched,two,phase,null,two,phase,matches,catch,ioexception,e,throw,new,illegal,state,exception,cannot,validate,match,e,return,previous,matched,false,override,public,int,length,return,max,doc
Lucene -> public static Bits asSequentialAccessBits(final int maxDoc, @Nullable ScorerSupplier scorerSupplier) throws IOException;1537371806;Given a {@link ScorerSupplier}, return a {@link Bits} instance that will match_all documents contained in the set. Note that the returned {@link Bits}_instance MUST be consumed in order.;public static Bits asSequentialAccessBits(final int maxDoc, @Nullable ScorerSupplier scorerSupplier) throws IOException {_        if (scorerSupplier == null) {_            return new Bits.MatchNoBits(maxDoc)__        }_        _        final Scorer scorer = scorerSupplier.get(Long.MAX_VALUE)_ _        final TwoPhaseIterator twoPhase = scorer.twoPhaseIterator()__        final DocIdSetIterator iterator__        if (twoPhase == null) {_            iterator = scorer.iterator()__        } else {_            iterator = twoPhase.approximation()__        }__        return new Bits() {__            int previous = -1__            boolean previousMatched = false___            @Override_            public boolean get(int index) {_                if (index < 0 || index >= maxDoc) {_                    throw new IndexOutOfBoundsException(index + " is out of bounds: [" + 0 + "-" + maxDoc + "[")__                }_                if (index < previous) {_                    throw new IllegalArgumentException("This Bits instance can only be consumed in order. "_                            + "Got called on [" + index + "] while previously called on [" + previous + "]")__                }_                if (index == previous) {_                    _                    _                    return previousMatched__                }_                previous = index___                int doc = iterator.docID()__                if (doc < index) {_                    try {_                        doc = iterator.advance(index)__                    } catch (IOException e) {_                        throw new IllegalStateException("Cannot advance iterator", e)__                    }_                }_                if (index == doc) {_                    try {_                        return previousMatched = twoPhase == null || twoPhase.matches()__                    } catch (IOException e) {_                        throw new IllegalStateException("Cannot validate match", e)__                    }_                }_                return previousMatched = false__            }__            @Override_            public int length() {_                return maxDoc__            }_        }__    };given,a,link,scorer,supplier,return,a,link,bits,instance,that,will,match,all,documents,contained,in,the,set,note,that,the,returned,link,bits,instance,must,be,consumed,in,order;public,static,bits,as,sequential,access,bits,final,int,max,doc,nullable,scorer,supplier,scorer,supplier,throws,ioexception,if,scorer,supplier,null,return,new,bits,match,no,bits,max,doc,final,scorer,scorer,scorer,supplier,get,long,final,two,phase,iterator,two,phase,scorer,two,phase,iterator,final,doc,id,set,iterator,iterator,if,two,phase,null,iterator,scorer,iterator,else,iterator,two,phase,approximation,return,new,bits,int,previous,1,boolean,previous,matched,false,override,public,boolean,get,int,index,if,index,0,index,max,doc,throw,new,index,out,of,bounds,exception,index,is,out,of,bounds,0,max,doc,if,index,previous,throw,new,illegal,argument,exception,this,bits,instance,can,only,be,consumed,in,order,got,called,on,index,while,previously,called,on,previous,if,index,previous,return,previous,matched,previous,index,int,doc,iterator,doc,id,if,doc,index,try,doc,iterator,advance,index,catch,ioexception,e,throw,new,illegal,state,exception,cannot,advance,iterator,e,if,index,doc,try,return,previous,matched,two,phase,null,two,phase,matches,catch,ioexception,e,throw,new,illegal,state,exception,cannot,validate,match,e,return,previous,matched,false,override,public,int,length,return,max,doc
Lucene -> public static Bits asSequentialAccessBits(final int maxDoc, @Nullable ScorerSupplier scorerSupplier) throws IOException;1539815831;Given a {@link ScorerSupplier}, return a {@link Bits} instance that will match_all documents contained in the set. Note that the returned {@link Bits}_instance MUST be consumed in order.;public static Bits asSequentialAccessBits(final int maxDoc, @Nullable ScorerSupplier scorerSupplier) throws IOException {_        if (scorerSupplier == null) {_            return new Bits.MatchNoBits(maxDoc)__        }_        _        final Scorer scorer = scorerSupplier.get(Long.MAX_VALUE)_ _        final TwoPhaseIterator twoPhase = scorer.twoPhaseIterator()__        final DocIdSetIterator iterator__        if (twoPhase == null) {_            iterator = scorer.iterator()__        } else {_            iterator = twoPhase.approximation()__        }__        return new Bits() {__            int previous = -1__            boolean previousMatched = false___            @Override_            public boolean get(int index) {_                if (index < 0 || index >= maxDoc) {_                    throw new IndexOutOfBoundsException(index + " is out of bounds: [" + 0 + "-" + maxDoc + "[")__                }_                if (index < previous) {_                    throw new IllegalArgumentException("This Bits instance can only be consumed in order. "_                            + "Got called on [" + index + "] while previously called on [" + previous + "]")__                }_                if (index == previous) {_                    _                    _                    return previousMatched__                }_                previous = index___                int doc = iterator.docID()__                if (doc < index) {_                    try {_                        doc = iterator.advance(index)__                    } catch (IOException e) {_                        throw new IllegalStateException("Cannot advance iterator", e)__                    }_                }_                if (index == doc) {_                    try {_                        return previousMatched = twoPhase == null || twoPhase.matches()__                    } catch (IOException e) {_                        throw new IllegalStateException("Cannot validate match", e)__                    }_                }_                return previousMatched = false__            }__            @Override_            public int length() {_                return maxDoc__            }_        }__    };given,a,link,scorer,supplier,return,a,link,bits,instance,that,will,match,all,documents,contained,in,the,set,note,that,the,returned,link,bits,instance,must,be,consumed,in,order;public,static,bits,as,sequential,access,bits,final,int,max,doc,nullable,scorer,supplier,scorer,supplier,throws,ioexception,if,scorer,supplier,null,return,new,bits,match,no,bits,max,doc,final,scorer,scorer,scorer,supplier,get,long,final,two,phase,iterator,two,phase,scorer,two,phase,iterator,final,doc,id,set,iterator,iterator,if,two,phase,null,iterator,scorer,iterator,else,iterator,two,phase,approximation,return,new,bits,int,previous,1,boolean,previous,matched,false,override,public,boolean,get,int,index,if,index,0,index,max,doc,throw,new,index,out,of,bounds,exception,index,is,out,of,bounds,0,max,doc,if,index,previous,throw,new,illegal,argument,exception,this,bits,instance,can,only,be,consumed,in,order,got,called,on,index,while,previously,called,on,previous,if,index,previous,return,previous,matched,previous,index,int,doc,iterator,doc,id,if,doc,index,try,doc,iterator,advance,index,catch,ioexception,e,throw,new,illegal,state,exception,cannot,advance,iterator,e,if,index,doc,try,return,previous,matched,two,phase,null,two,phase,matches,catch,ioexception,e,throw,new,illegal,state,exception,cannot,validate,match,e,return,previous,matched,false,override,public,int,length,return,max,doc
Lucene -> public static Bits asSequentialAccessBits(final int maxDoc, @Nullable ScorerSupplier scorerSupplier) throws IOException;1540238977;Given a {@link ScorerSupplier}, return a {@link Bits} instance that will match_all documents contained in the set. Note that the returned {@link Bits}_instance MUST be consumed in order.;public static Bits asSequentialAccessBits(final int maxDoc, @Nullable ScorerSupplier scorerSupplier) throws IOException {_        if (scorerSupplier == null) {_            return new Bits.MatchNoBits(maxDoc)__        }_        _        final Scorer scorer = scorerSupplier.get(Long.MAX_VALUE)_ _        final TwoPhaseIterator twoPhase = scorer.twoPhaseIterator()__        final DocIdSetIterator iterator__        if (twoPhase == null) {_            iterator = scorer.iterator()__        } else {_            iterator = twoPhase.approximation()__        }__        return new Bits() {__            int previous = -1__            boolean previousMatched = false___            @Override_            public boolean get(int index) {_                if (index < 0 || index >= maxDoc) {_                    throw new IndexOutOfBoundsException(index + " is out of bounds: [" + 0 + "-" + maxDoc + "[")__                }_                if (index < previous) {_                    throw new IllegalArgumentException("This Bits instance can only be consumed in order. "_                            + "Got called on [" + index + "] while previously called on [" + previous + "]")__                }_                if (index == previous) {_                    _                    _                    return previousMatched__                }_                previous = index___                int doc = iterator.docID()__                if (doc < index) {_                    try {_                        doc = iterator.advance(index)__                    } catch (IOException e) {_                        throw new IllegalStateException("Cannot advance iterator", e)__                    }_                }_                if (index == doc) {_                    try {_                        return previousMatched = twoPhase == null || twoPhase.matches()__                    } catch (IOException e) {_                        throw new IllegalStateException("Cannot validate match", e)__                    }_                }_                return previousMatched = false__            }__            @Override_            public int length() {_                return maxDoc__            }_        }__    };given,a,link,scorer,supplier,return,a,link,bits,instance,that,will,match,all,documents,contained,in,the,set,note,that,the,returned,link,bits,instance,must,be,consumed,in,order;public,static,bits,as,sequential,access,bits,final,int,max,doc,nullable,scorer,supplier,scorer,supplier,throws,ioexception,if,scorer,supplier,null,return,new,bits,match,no,bits,max,doc,final,scorer,scorer,scorer,supplier,get,long,final,two,phase,iterator,two,phase,scorer,two,phase,iterator,final,doc,id,set,iterator,iterator,if,two,phase,null,iterator,scorer,iterator,else,iterator,two,phase,approximation,return,new,bits,int,previous,1,boolean,previous,matched,false,override,public,boolean,get,int,index,if,index,0,index,max,doc,throw,new,index,out,of,bounds,exception,index,is,out,of,bounds,0,max,doc,if,index,previous,throw,new,illegal,argument,exception,this,bits,instance,can,only,be,consumed,in,order,got,called,on,index,while,previously,called,on,previous,if,index,previous,return,previous,matched,previous,index,int,doc,iterator,doc,id,if,doc,index,try,doc,iterator,advance,index,catch,ioexception,e,throw,new,illegal,state,exception,cannot,advance,iterator,e,if,index,doc,try,return,previous,matched,two,phase,null,two,phase,matches,catch,ioexception,e,throw,new,illegal,state,exception,cannot,validate,match,e,return,previous,matched,false,override,public,int,length,return,max,doc
Lucene -> public static Bits asSequentialAccessBits(final int maxDoc, @Nullable ScorerSupplier scorerSupplier) throws IOException;1541592065;Given a {@link ScorerSupplier}, return a {@link Bits} instance that will match_all documents contained in the set. Note that the returned {@link Bits}_instance MUST be consumed in order.;public static Bits asSequentialAccessBits(final int maxDoc, @Nullable ScorerSupplier scorerSupplier) throws IOException {_        if (scorerSupplier == null) {_            return new Bits.MatchNoBits(maxDoc)__        }_        _        final Scorer scorer = scorerSupplier.get(Long.MAX_VALUE)_ _        final TwoPhaseIterator twoPhase = scorer.twoPhaseIterator()__        final DocIdSetIterator iterator__        if (twoPhase == null) {_            iterator = scorer.iterator()__        } else {_            iterator = twoPhase.approximation()__        }__        return new Bits() {__            int previous = -1__            boolean previousMatched = false___            @Override_            public boolean get(int index) {_                if (index < 0 || index >= maxDoc) {_                    throw new IndexOutOfBoundsException(index + " is out of bounds: [" + 0 + "-" + maxDoc + "[")__                }_                if (index < previous) {_                    throw new IllegalArgumentException("This Bits instance can only be consumed in order. "_                            + "Got called on [" + index + "] while previously called on [" + previous + "]")__                }_                if (index == previous) {_                    _                    _                    return previousMatched__                }_                previous = index___                int doc = iterator.docID()__                if (doc < index) {_                    try {_                        doc = iterator.advance(index)__                    } catch (IOException e) {_                        throw new IllegalStateException("Cannot advance iterator", e)__                    }_                }_                if (index == doc) {_                    try {_                        return previousMatched = twoPhase == null || twoPhase.matches()__                    } catch (IOException e) {_                        throw new IllegalStateException("Cannot validate match", e)__                    }_                }_                return previousMatched = false__            }__            @Override_            public int length() {_                return maxDoc__            }_        }__    };given,a,link,scorer,supplier,return,a,link,bits,instance,that,will,match,all,documents,contained,in,the,set,note,that,the,returned,link,bits,instance,must,be,consumed,in,order;public,static,bits,as,sequential,access,bits,final,int,max,doc,nullable,scorer,supplier,scorer,supplier,throws,ioexception,if,scorer,supplier,null,return,new,bits,match,no,bits,max,doc,final,scorer,scorer,scorer,supplier,get,long,final,two,phase,iterator,two,phase,scorer,two,phase,iterator,final,doc,id,set,iterator,iterator,if,two,phase,null,iterator,scorer,iterator,else,iterator,two,phase,approximation,return,new,bits,int,previous,1,boolean,previous,matched,false,override,public,boolean,get,int,index,if,index,0,index,max,doc,throw,new,index,out,of,bounds,exception,index,is,out,of,bounds,0,max,doc,if,index,previous,throw,new,illegal,argument,exception,this,bits,instance,can,only,be,consumed,in,order,got,called,on,index,while,previously,called,on,previous,if,index,previous,return,previous,matched,previous,index,int,doc,iterator,doc,id,if,doc,index,try,doc,iterator,advance,index,catch,ioexception,e,throw,new,illegal,state,exception,cannot,advance,iterator,e,if,index,doc,try,return,previous,matched,two,phase,null,two,phase,matches,catch,ioexception,e,throw,new,illegal,state,exception,cannot,validate,match,e,return,previous,matched,false,override,public,int,length,return,max,doc
Lucene -> public static Bits asSequentialAccessBits(final int maxDoc, @Nullable ScorerSupplier scorerSupplier) throws IOException;1541618615;Given a {@link ScorerSupplier}, return a {@link Bits} instance that will match_all documents contained in the set. Note that the returned {@link Bits}_instance MUST be consumed in order.;public static Bits asSequentialAccessBits(final int maxDoc, @Nullable ScorerSupplier scorerSupplier) throws IOException {_        if (scorerSupplier == null) {_            return new Bits.MatchNoBits(maxDoc)__        }_        _        final Scorer scorer = scorerSupplier.get(Long.MAX_VALUE)_ _        final TwoPhaseIterator twoPhase = scorer.twoPhaseIterator()__        final DocIdSetIterator iterator__        if (twoPhase == null) {_            iterator = scorer.iterator()__        } else {_            iterator = twoPhase.approximation()__        }__        return new Bits() {__            int previous = -1__            boolean previousMatched = false___            @Override_            public boolean get(int index) {_                if (index < 0 || index >= maxDoc) {_                    throw new IndexOutOfBoundsException(index + " is out of bounds: [" + 0 + "-" + maxDoc + "[")__                }_                if (index < previous) {_                    throw new IllegalArgumentException("This Bits instance can only be consumed in order. "_                            + "Got called on [" + index + "] while previously called on [" + previous + "]")__                }_                if (index == previous) {_                    _                    _                    return previousMatched__                }_                previous = index___                int doc = iterator.docID()__                if (doc < index) {_                    try {_                        doc = iterator.advance(index)__                    } catch (IOException e) {_                        throw new IllegalStateException("Cannot advance iterator", e)__                    }_                }_                if (index == doc) {_                    try {_                        return previousMatched = twoPhase == null || twoPhase.matches()__                    } catch (IOException e) {_                        throw new IllegalStateException("Cannot validate match", e)__                    }_                }_                return previousMatched = false__            }__            @Override_            public int length() {_                return maxDoc__            }_        }__    };given,a,link,scorer,supplier,return,a,link,bits,instance,that,will,match,all,documents,contained,in,the,set,note,that,the,returned,link,bits,instance,must,be,consumed,in,order;public,static,bits,as,sequential,access,bits,final,int,max,doc,nullable,scorer,supplier,scorer,supplier,throws,ioexception,if,scorer,supplier,null,return,new,bits,match,no,bits,max,doc,final,scorer,scorer,scorer,supplier,get,long,final,two,phase,iterator,two,phase,scorer,two,phase,iterator,final,doc,id,set,iterator,iterator,if,two,phase,null,iterator,scorer,iterator,else,iterator,two,phase,approximation,return,new,bits,int,previous,1,boolean,previous,matched,false,override,public,boolean,get,int,index,if,index,0,index,max,doc,throw,new,index,out,of,bounds,exception,index,is,out,of,bounds,0,max,doc,if,index,previous,throw,new,illegal,argument,exception,this,bits,instance,can,only,be,consumed,in,order,got,called,on,index,while,previously,called,on,previous,if,index,previous,return,previous,matched,previous,index,int,doc,iterator,doc,id,if,doc,index,try,doc,iterator,advance,index,catch,ioexception,e,throw,new,illegal,state,exception,cannot,advance,iterator,e,if,index,doc,try,return,previous,matched,two,phase,null,two,phase,matches,catch,ioexception,e,throw,new,illegal,state,exception,cannot,validate,match,e,return,previous,matched,false,override,public,int,length,return,max,doc
Lucene -> public static Bits asSequentialAccessBits(final int maxDoc, @Nullable ScorerSupplier scorerSupplier) throws IOException;1544076142;Given a {@link ScorerSupplier}, return a {@link Bits} instance that will match_all documents contained in the set. Note that the returned {@link Bits}_instance MUST be consumed in order.;public static Bits asSequentialAccessBits(final int maxDoc, @Nullable ScorerSupplier scorerSupplier) throws IOException {_        if (scorerSupplier == null) {_            return new Bits.MatchNoBits(maxDoc)__        }_        _        final Scorer scorer = scorerSupplier.get(Long.MAX_VALUE)_ _        final TwoPhaseIterator twoPhase = scorer.twoPhaseIterator()__        final DocIdSetIterator iterator__        if (twoPhase == null) {_            iterator = scorer.iterator()__        } else {_            iterator = twoPhase.approximation()__        }__        return new Bits() {__            int previous = -1__            boolean previousMatched = false___            @Override_            public boolean get(int index) {_                if (index < 0 || index >= maxDoc) {_                    throw new IndexOutOfBoundsException(index + " is out of bounds: [" + 0 + "-" + maxDoc + "[")__                }_                if (index < previous) {_                    throw new IllegalArgumentException("This Bits instance can only be consumed in order. "_                            + "Got called on [" + index + "] while previously called on [" + previous + "]")__                }_                if (index == previous) {_                    _                    _                    return previousMatched__                }_                previous = index___                int doc = iterator.docID()__                if (doc < index) {_                    try {_                        doc = iterator.advance(index)__                    } catch (IOException e) {_                        throw new IllegalStateException("Cannot advance iterator", e)__                    }_                }_                if (index == doc) {_                    try {_                        return previousMatched = twoPhase == null || twoPhase.matches()__                    } catch (IOException e) {_                        throw new IllegalStateException("Cannot validate match", e)__                    }_                }_                return previousMatched = false__            }__            @Override_            public int length() {_                return maxDoc__            }_        }__    };given,a,link,scorer,supplier,return,a,link,bits,instance,that,will,match,all,documents,contained,in,the,set,note,that,the,returned,link,bits,instance,must,be,consumed,in,order;public,static,bits,as,sequential,access,bits,final,int,max,doc,nullable,scorer,supplier,scorer,supplier,throws,ioexception,if,scorer,supplier,null,return,new,bits,match,no,bits,max,doc,final,scorer,scorer,scorer,supplier,get,long,final,two,phase,iterator,two,phase,scorer,two,phase,iterator,final,doc,id,set,iterator,iterator,if,two,phase,null,iterator,scorer,iterator,else,iterator,two,phase,approximation,return,new,bits,int,previous,1,boolean,previous,matched,false,override,public,boolean,get,int,index,if,index,0,index,max,doc,throw,new,index,out,of,bounds,exception,index,is,out,of,bounds,0,max,doc,if,index,previous,throw,new,illegal,argument,exception,this,bits,instance,can,only,be,consumed,in,order,got,called,on,index,while,previously,called,on,previous,if,index,previous,return,previous,matched,previous,index,int,doc,iterator,doc,id,if,doc,index,try,doc,iterator,advance,index,catch,ioexception,e,throw,new,illegal,state,exception,cannot,advance,iterator,e,if,index,doc,try,return,previous,matched,two,phase,null,two,phase,matches,catch,ioexception,e,throw,new,illegal,state,exception,cannot,validate,match,e,return,previous,matched,false,override,public,int,length,return,max,doc
Lucene -> public static Bits asSequentialAccessBits(final int maxDoc, @Nullable ScorerSupplier scorerSupplier) throws IOException;1544322276;Given a {@link ScorerSupplier}, return a {@link Bits} instance that will match_all documents contained in the set. Note that the returned {@link Bits}_instance MUST be consumed in order.;public static Bits asSequentialAccessBits(final int maxDoc, @Nullable ScorerSupplier scorerSupplier) throws IOException {_        if (scorerSupplier == null) {_            return new Bits.MatchNoBits(maxDoc)__        }_        _        final Scorer scorer = scorerSupplier.get(Long.MAX_VALUE)_ _        final TwoPhaseIterator twoPhase = scorer.twoPhaseIterator()__        final DocIdSetIterator iterator__        if (twoPhase == null) {_            iterator = scorer.iterator()__        } else {_            iterator = twoPhase.approximation()__        }__        return new Bits() {__            int previous = -1__            boolean previousMatched = false___            @Override_            public boolean get(int index) {_                if (index < 0 || index >= maxDoc) {_                    throw new IndexOutOfBoundsException(index + " is out of bounds: [" + 0 + "-" + maxDoc + "[")__                }_                if (index < previous) {_                    throw new IllegalArgumentException("This Bits instance can only be consumed in order. "_                            + "Got called on [" + index + "] while previously called on [" + previous + "]")__                }_                if (index == previous) {_                    _                    _                    return previousMatched__                }_                previous = index___                int doc = iterator.docID()__                if (doc < index) {_                    try {_                        doc = iterator.advance(index)__                    } catch (IOException e) {_                        throw new IllegalStateException("Cannot advance iterator", e)__                    }_                }_                if (index == doc) {_                    try {_                        return previousMatched = twoPhase == null || twoPhase.matches()__                    } catch (IOException e) {_                        throw new IllegalStateException("Cannot validate match", e)__                    }_                }_                return previousMatched = false__            }__            @Override_            public int length() {_                return maxDoc__            }_        }__    };given,a,link,scorer,supplier,return,a,link,bits,instance,that,will,match,all,documents,contained,in,the,set,note,that,the,returned,link,bits,instance,must,be,consumed,in,order;public,static,bits,as,sequential,access,bits,final,int,max,doc,nullable,scorer,supplier,scorer,supplier,throws,ioexception,if,scorer,supplier,null,return,new,bits,match,no,bits,max,doc,final,scorer,scorer,scorer,supplier,get,long,final,two,phase,iterator,two,phase,scorer,two,phase,iterator,final,doc,id,set,iterator,iterator,if,two,phase,null,iterator,scorer,iterator,else,iterator,two,phase,approximation,return,new,bits,int,previous,1,boolean,previous,matched,false,override,public,boolean,get,int,index,if,index,0,index,max,doc,throw,new,index,out,of,bounds,exception,index,is,out,of,bounds,0,max,doc,if,index,previous,throw,new,illegal,argument,exception,this,bits,instance,can,only,be,consumed,in,order,got,called,on,index,while,previously,called,on,previous,if,index,previous,return,previous,matched,previous,index,int,doc,iterator,doc,id,if,doc,index,try,doc,iterator,advance,index,catch,ioexception,e,throw,new,illegal,state,exception,cannot,advance,iterator,e,if,index,doc,try,return,previous,matched,two,phase,null,two,phase,matches,catch,ioexception,e,throw,new,illegal,state,exception,cannot,validate,match,e,return,previous,matched,false,override,public,int,length,return,max,doc
Lucene -> public static Bits asSequentialAccessBits(final int maxDoc, @Nullable ScorerSupplier scorerSupplier) throws IOException;1544786574;Given a {@link ScorerSupplier}, return a {@link Bits} instance that will match_all documents contained in the set. Note that the returned {@link Bits}_instance MUST be consumed in order.;public static Bits asSequentialAccessBits(final int maxDoc, @Nullable ScorerSupplier scorerSupplier) throws IOException {_        if (scorerSupplier == null) {_            return new Bits.MatchNoBits(maxDoc)__        }_        _        final Scorer scorer = scorerSupplier.get(Long.MAX_VALUE)_ _        final TwoPhaseIterator twoPhase = scorer.twoPhaseIterator()__        final DocIdSetIterator iterator__        if (twoPhase == null) {_            iterator = scorer.iterator()__        } else {_            iterator = twoPhase.approximation()__        }__        return new Bits() {__            int previous = -1__            boolean previousMatched = false___            @Override_            public boolean get(int index) {_                if (index < 0 || index >= maxDoc) {_                    throw new IndexOutOfBoundsException(index + " is out of bounds: [" + 0 + "-" + maxDoc + "[")__                }_                if (index < previous) {_                    throw new IllegalArgumentException("This Bits instance can only be consumed in order. "_                            + "Got called on [" + index + "] while previously called on [" + previous + "]")__                }_                if (index == previous) {_                    _                    _                    return previousMatched__                }_                previous = index___                int doc = iterator.docID()__                if (doc < index) {_                    try {_                        doc = iterator.advance(index)__                    } catch (IOException e) {_                        throw new IllegalStateException("Cannot advance iterator", e)__                    }_                }_                if (index == doc) {_                    try {_                        return previousMatched = twoPhase == null || twoPhase.matches()__                    } catch (IOException e) {_                        throw new IllegalStateException("Cannot validate match", e)__                    }_                }_                return previousMatched = false__            }__            @Override_            public int length() {_                return maxDoc__            }_        }__    };given,a,link,scorer,supplier,return,a,link,bits,instance,that,will,match,all,documents,contained,in,the,set,note,that,the,returned,link,bits,instance,must,be,consumed,in,order;public,static,bits,as,sequential,access,bits,final,int,max,doc,nullable,scorer,supplier,scorer,supplier,throws,ioexception,if,scorer,supplier,null,return,new,bits,match,no,bits,max,doc,final,scorer,scorer,scorer,supplier,get,long,final,two,phase,iterator,two,phase,scorer,two,phase,iterator,final,doc,id,set,iterator,iterator,if,two,phase,null,iterator,scorer,iterator,else,iterator,two,phase,approximation,return,new,bits,int,previous,1,boolean,previous,matched,false,override,public,boolean,get,int,index,if,index,0,index,max,doc,throw,new,index,out,of,bounds,exception,index,is,out,of,bounds,0,max,doc,if,index,previous,throw,new,illegal,argument,exception,this,bits,instance,can,only,be,consumed,in,order,got,called,on,index,while,previously,called,on,previous,if,index,previous,return,previous,matched,previous,index,int,doc,iterator,doc,id,if,doc,index,try,doc,iterator,advance,index,catch,ioexception,e,throw,new,illegal,state,exception,cannot,advance,iterator,e,if,index,doc,try,return,previous,matched,two,phase,null,two,phase,matches,catch,ioexception,e,throw,new,illegal,state,exception,cannot,validate,match,e,return,previous,matched,false,override,public,int,length,return,max,doc
Lucene -> public static final boolean waitForIndex(final Directory directory, final long timeLimitMillis)             throws IOException;1524684173;Wait for an index to exist for up to {@code timeLimitMillis}. Returns_true if the index eventually exists, false if not.__Will retry the directory every second for at least {@code timeLimitMillis};public static final boolean waitForIndex(final Directory directory, final long timeLimitMillis)_            throws IOException {_        final long DELAY = 1000__        long waited = 0__        try {_            while (true) {_                if (waited >= timeLimitMillis) {_                    break__                }_                if (indexExists(directory)) {_                    return true__                }_                Thread.sleep(DELAY)__                waited += DELAY__            }_        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()__            return false__        }_        _        return indexExists(directory)__    };wait,for,an,index,to,exist,for,up,to,code,time,limit,millis,returns,true,if,the,index,eventually,exists,false,if,not,will,retry,the,directory,every,second,for,at,least,code,time,limit,millis;public,static,final,boolean,wait,for,index,final,directory,directory,final,long,time,limit,millis,throws,ioexception,final,long,delay,1000,long,waited,0,try,while,true,if,waited,time,limit,millis,break,if,index,exists,directory,return,true,thread,sleep,delay,waited,delay,catch,interrupted,exception,e,thread,current,thread,interrupt,return,false,return,index,exists,directory
Lucene -> public static final boolean waitForIndex(final Directory directory, final long timeLimitMillis)             throws IOException;1525334055;Wait for an index to exist for up to {@code timeLimitMillis}. Returns_true if the index eventually exists, false if not.__Will retry the directory every second for at least {@code timeLimitMillis};public static final boolean waitForIndex(final Directory directory, final long timeLimitMillis)_            throws IOException {_        final long DELAY = 1000__        long waited = 0__        try {_            while (true) {_                if (waited >= timeLimitMillis) {_                    break__                }_                if (indexExists(directory)) {_                    return true__                }_                Thread.sleep(DELAY)__                waited += DELAY__            }_        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()__            return false__        }_        _        return indexExists(directory)__    };wait,for,an,index,to,exist,for,up,to,code,time,limit,millis,returns,true,if,the,index,eventually,exists,false,if,not,will,retry,the,directory,every,second,for,at,least,code,time,limit,millis;public,static,final,boolean,wait,for,index,final,directory,directory,final,long,time,limit,millis,throws,ioexception,final,long,delay,1000,long,waited,0,try,while,true,if,waited,time,limit,millis,break,if,index,exists,directory,return,true,thread,sleep,delay,waited,delay,catch,interrupted,exception,e,thread,current,thread,interrupt,return,false,return,index,exists,directory
Lucene -> public static final boolean waitForIndex(final Directory directory, final long timeLimitMillis)             throws IOException;1535046779;Wait for an index to exist for up to {@code timeLimitMillis}. Returns_true if the index eventually exists, false if not.__Will retry the directory every second for at least {@code timeLimitMillis};public static final boolean waitForIndex(final Directory directory, final long timeLimitMillis)_            throws IOException {_        final long DELAY = 1000__        long waited = 0__        try {_            while (true) {_                if (waited >= timeLimitMillis) {_                    break__                }_                if (indexExists(directory)) {_                    return true__                }_                Thread.sleep(DELAY)__                waited += DELAY__            }_        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()__            return false__        }_        _        return indexExists(directory)__    };wait,for,an,index,to,exist,for,up,to,code,time,limit,millis,returns,true,if,the,index,eventually,exists,false,if,not,will,retry,the,directory,every,second,for,at,least,code,time,limit,millis;public,static,final,boolean,wait,for,index,final,directory,directory,final,long,time,limit,millis,throws,ioexception,final,long,delay,1000,long,waited,0,try,while,true,if,waited,time,limit,millis,break,if,index,exists,directory,return,true,thread,sleep,delay,waited,delay,catch,interrupted,exception,e,thread,current,thread,interrupt,return,false,return,index,exists,directory
Lucene -> public static final boolean waitForIndex(final Directory directory, final long timeLimitMillis)             throws IOException;1535723122;Wait for an index to exist for up to {@code timeLimitMillis}. Returns_true if the index eventually exists, false if not.__Will retry the directory every second for at least {@code timeLimitMillis};public static final boolean waitForIndex(final Directory directory, final long timeLimitMillis)_            throws IOException {_        final long DELAY = 1000__        long waited = 0__        try {_            while (true) {_                if (waited >= timeLimitMillis) {_                    break__                }_                if (indexExists(directory)) {_                    return true__                }_                Thread.sleep(DELAY)__                waited += DELAY__            }_        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()__            return false__        }_        _        return indexExists(directory)__    };wait,for,an,index,to,exist,for,up,to,code,time,limit,millis,returns,true,if,the,index,eventually,exists,false,if,not,will,retry,the,directory,every,second,for,at,least,code,time,limit,millis;public,static,final,boolean,wait,for,index,final,directory,directory,final,long,time,limit,millis,throws,ioexception,final,long,delay,1000,long,waited,0,try,while,true,if,waited,time,limit,millis,break,if,index,exists,directory,return,true,thread,sleep,delay,waited,delay,catch,interrupted,exception,e,thread,current,thread,interrupt,return,false,return,index,exists,directory
Lucene -> public static final boolean waitForIndex(final Directory directory, final long timeLimitMillis)             throws IOException;1536314350;Wait for an index to exist for up to {@code timeLimitMillis}. Returns_true if the index eventually exists, false if not.__Will retry the directory every second for at least {@code timeLimitMillis};public static final boolean waitForIndex(final Directory directory, final long timeLimitMillis)_            throws IOException {_        final long DELAY = 1000__        long waited = 0__        try {_            while (true) {_                if (waited >= timeLimitMillis) {_                    break__                }_                if (indexExists(directory)) {_                    return true__                }_                Thread.sleep(DELAY)__                waited += DELAY__            }_        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()__            return false__        }_        _        return indexExists(directory)__    };wait,for,an,index,to,exist,for,up,to,code,time,limit,millis,returns,true,if,the,index,eventually,exists,false,if,not,will,retry,the,directory,every,second,for,at,least,code,time,limit,millis;public,static,final,boolean,wait,for,index,final,directory,directory,final,long,time,limit,millis,throws,ioexception,final,long,delay,1000,long,waited,0,try,while,true,if,waited,time,limit,millis,break,if,index,exists,directory,return,true,thread,sleep,delay,waited,delay,catch,interrupted,exception,e,thread,current,thread,interrupt,return,false,return,index,exists,directory
Lucene -> public static final boolean waitForIndex(final Directory directory, final long timeLimitMillis)             throws IOException;1536611444;Wait for an index to exist for up to {@code timeLimitMillis}. Returns_true if the index eventually exists, false if not.__Will retry the directory every second for at least {@code timeLimitMillis};public static final boolean waitForIndex(final Directory directory, final long timeLimitMillis)_            throws IOException {_        final long DELAY = 1000__        long waited = 0__        try {_            while (true) {_                if (waited >= timeLimitMillis) {_                    break__                }_                if (indexExists(directory)) {_                    return true__                }_                Thread.sleep(DELAY)__                waited += DELAY__            }_        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()__            return false__        }_        _        return indexExists(directory)__    };wait,for,an,index,to,exist,for,up,to,code,time,limit,millis,returns,true,if,the,index,eventually,exists,false,if,not,will,retry,the,directory,every,second,for,at,least,code,time,limit,millis;public,static,final,boolean,wait,for,index,final,directory,directory,final,long,time,limit,millis,throws,ioexception,final,long,delay,1000,long,waited,0,try,while,true,if,waited,time,limit,millis,break,if,index,exists,directory,return,true,thread,sleep,delay,waited,delay,catch,interrupted,exception,e,thread,current,thread,interrupt,return,false,return,index,exists,directory
Lucene -> public static final boolean waitForIndex(final Directory directory, final long timeLimitMillis)             throws IOException;1537371806;Wait for an index to exist for up to {@code timeLimitMillis}. Returns_true if the index eventually exists, false if not.__Will retry the directory every second for at least {@code timeLimitMillis};public static final boolean waitForIndex(final Directory directory, final long timeLimitMillis)_            throws IOException {_        final long DELAY = 1000__        long waited = 0__        try {_            while (true) {_                if (waited >= timeLimitMillis) {_                    break__                }_                if (indexExists(directory)) {_                    return true__                }_                Thread.sleep(DELAY)__                waited += DELAY__            }_        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()__            return false__        }_        _        return indexExists(directory)__    };wait,for,an,index,to,exist,for,up,to,code,time,limit,millis,returns,true,if,the,index,eventually,exists,false,if,not,will,retry,the,directory,every,second,for,at,least,code,time,limit,millis;public,static,final,boolean,wait,for,index,final,directory,directory,final,long,time,limit,millis,throws,ioexception,final,long,delay,1000,long,waited,0,try,while,true,if,waited,time,limit,millis,break,if,index,exists,directory,return,true,thread,sleep,delay,waited,delay,catch,interrupted,exception,e,thread,current,thread,interrupt,return,false,return,index,exists,directory
Lucene -> public static final boolean waitForIndex(final Directory directory, final long timeLimitMillis)             throws IOException;1539815831;Wait for an index to exist for up to {@code timeLimitMillis}. Returns_true if the index eventually exists, false if not.__Will retry the directory every second for at least {@code timeLimitMillis};public static final boolean waitForIndex(final Directory directory, final long timeLimitMillis)_            throws IOException {_        final long DELAY = 1000__        long waited = 0__        try {_            while (true) {_                if (waited >= timeLimitMillis) {_                    break__                }_                if (indexExists(directory)) {_                    return true__                }_                Thread.sleep(DELAY)__                waited += DELAY__            }_        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()__            return false__        }_        _        return indexExists(directory)__    };wait,for,an,index,to,exist,for,up,to,code,time,limit,millis,returns,true,if,the,index,eventually,exists,false,if,not,will,retry,the,directory,every,second,for,at,least,code,time,limit,millis;public,static,final,boolean,wait,for,index,final,directory,directory,final,long,time,limit,millis,throws,ioexception,final,long,delay,1000,long,waited,0,try,while,true,if,waited,time,limit,millis,break,if,index,exists,directory,return,true,thread,sleep,delay,waited,delay,catch,interrupted,exception,e,thread,current,thread,interrupt,return,false,return,index,exists,directory
Lucene -> public static final boolean waitForIndex(final Directory directory, final long timeLimitMillis)             throws IOException;1540238977;Wait for an index to exist for up to {@code timeLimitMillis}. Returns_true if the index eventually exists, false if not.__Will retry the directory every second for at least {@code timeLimitMillis};public static final boolean waitForIndex(final Directory directory, final long timeLimitMillis)_            throws IOException {_        final long DELAY = 1000__        long waited = 0__        try {_            while (true) {_                if (waited >= timeLimitMillis) {_                    break__                }_                if (indexExists(directory)) {_                    return true__                }_                Thread.sleep(DELAY)__                waited += DELAY__            }_        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()__            return false__        }_        _        return indexExists(directory)__    };wait,for,an,index,to,exist,for,up,to,code,time,limit,millis,returns,true,if,the,index,eventually,exists,false,if,not,will,retry,the,directory,every,second,for,at,least,code,time,limit,millis;public,static,final,boolean,wait,for,index,final,directory,directory,final,long,time,limit,millis,throws,ioexception,final,long,delay,1000,long,waited,0,try,while,true,if,waited,time,limit,millis,break,if,index,exists,directory,return,true,thread,sleep,delay,waited,delay,catch,interrupted,exception,e,thread,current,thread,interrupt,return,false,return,index,exists,directory
Lucene -> public static final boolean waitForIndex(final Directory directory, final long timeLimitMillis)             throws IOException;1541592065;Wait for an index to exist for up to {@code timeLimitMillis}. Returns_true if the index eventually exists, false if not.__Will retry the directory every second for at least {@code timeLimitMillis};public static final boolean waitForIndex(final Directory directory, final long timeLimitMillis)_            throws IOException {_        final long DELAY = 1000__        long waited = 0__        try {_            while (true) {_                if (waited >= timeLimitMillis) {_                    break__                }_                if (indexExists(directory)) {_                    return true__                }_                Thread.sleep(DELAY)__                waited += DELAY__            }_        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()__            return false__        }_        _        return indexExists(directory)__    };wait,for,an,index,to,exist,for,up,to,code,time,limit,millis,returns,true,if,the,index,eventually,exists,false,if,not,will,retry,the,directory,every,second,for,at,least,code,time,limit,millis;public,static,final,boolean,wait,for,index,final,directory,directory,final,long,time,limit,millis,throws,ioexception,final,long,delay,1000,long,waited,0,try,while,true,if,waited,time,limit,millis,break,if,index,exists,directory,return,true,thread,sleep,delay,waited,delay,catch,interrupted,exception,e,thread,current,thread,interrupt,return,false,return,index,exists,directory
Lucene -> public static final boolean waitForIndex(final Directory directory, final long timeLimitMillis)             throws IOException;1541618615;Wait for an index to exist for up to {@code timeLimitMillis}. Returns_true if the index eventually exists, false if not.__Will retry the directory every second for at least {@code timeLimitMillis};public static final boolean waitForIndex(final Directory directory, final long timeLimitMillis)_            throws IOException {_        final long DELAY = 1000__        long waited = 0__        try {_            while (true) {_                if (waited >= timeLimitMillis) {_                    break__                }_                if (indexExists(directory)) {_                    return true__                }_                Thread.sleep(DELAY)__                waited += DELAY__            }_        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()__            return false__        }_        _        return indexExists(directory)__    };wait,for,an,index,to,exist,for,up,to,code,time,limit,millis,returns,true,if,the,index,eventually,exists,false,if,not,will,retry,the,directory,every,second,for,at,least,code,time,limit,millis;public,static,final,boolean,wait,for,index,final,directory,directory,final,long,time,limit,millis,throws,ioexception,final,long,delay,1000,long,waited,0,try,while,true,if,waited,time,limit,millis,break,if,index,exists,directory,return,true,thread,sleep,delay,waited,delay,catch,interrupted,exception,e,thread,current,thread,interrupt,return,false,return,index,exists,directory
Lucene -> public static final boolean waitForIndex(final Directory directory, final long timeLimitMillis)             throws IOException;1544076142;Wait for an index to exist for up to {@code timeLimitMillis}. Returns_true if the index eventually exists, false if not.__Will retry the directory every second for at least {@code timeLimitMillis};public static final boolean waitForIndex(final Directory directory, final long timeLimitMillis)_            throws IOException {_        final long DELAY = 1000__        long waited = 0__        try {_            while (true) {_                if (waited >= timeLimitMillis) {_                    break__                }_                if (indexExists(directory)) {_                    return true__                }_                Thread.sleep(DELAY)__                waited += DELAY__            }_        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()__            return false__        }_        _        return indexExists(directory)__    };wait,for,an,index,to,exist,for,up,to,code,time,limit,millis,returns,true,if,the,index,eventually,exists,false,if,not,will,retry,the,directory,every,second,for,at,least,code,time,limit,millis;public,static,final,boolean,wait,for,index,final,directory,directory,final,long,time,limit,millis,throws,ioexception,final,long,delay,1000,long,waited,0,try,while,true,if,waited,time,limit,millis,break,if,index,exists,directory,return,true,thread,sleep,delay,waited,delay,catch,interrupted,exception,e,thread,current,thread,interrupt,return,false,return,index,exists,directory
Lucene -> public static final boolean waitForIndex(final Directory directory, final long timeLimitMillis)             throws IOException;1544322276;Wait for an index to exist for up to {@code timeLimitMillis}. Returns_true if the index eventually exists, false if not.__Will retry the directory every second for at least {@code timeLimitMillis};public static final boolean waitForIndex(final Directory directory, final long timeLimitMillis)_            throws IOException {_        final long DELAY = 1000__        long waited = 0__        try {_            while (true) {_                if (waited >= timeLimitMillis) {_                    break__                }_                if (indexExists(directory)) {_                    return true__                }_                Thread.sleep(DELAY)__                waited += DELAY__            }_        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()__            return false__        }_        _        return indexExists(directory)__    };wait,for,an,index,to,exist,for,up,to,code,time,limit,millis,returns,true,if,the,index,eventually,exists,false,if,not,will,retry,the,directory,every,second,for,at,least,code,time,limit,millis;public,static,final,boolean,wait,for,index,final,directory,directory,final,long,time,limit,millis,throws,ioexception,final,long,delay,1000,long,waited,0,try,while,true,if,waited,time,limit,millis,break,if,index,exists,directory,return,true,thread,sleep,delay,waited,delay,catch,interrupted,exception,e,thread,current,thread,interrupt,return,false,return,index,exists,directory
Lucene -> public static DirectoryReader wrapAllDocsLive(DirectoryReader in) throws IOException;1535723122;Wraps a directory reader to make all documents live except those were rolled back_or hard-deleted due to non-aborting exceptions during indexing._The wrapped reader can be used to query all documents.__@param in the input directory reader_@return the wrapped reader;public static DirectoryReader wrapAllDocsLive(DirectoryReader in) throws IOException {_        return new DirectoryReaderWithAllLiveDocs(in)__    };wraps,a,directory,reader,to,make,all,documents,live,except,those,were,rolled,back,or,hard,deleted,due,to,non,aborting,exceptions,during,indexing,the,wrapped,reader,can,be,used,to,query,all,documents,param,in,the,input,directory,reader,return,the,wrapped,reader;public,static,directory,reader,wrap,all,docs,live,directory,reader,in,throws,ioexception,return,new,directory,reader,with,all,live,docs,in
Lucene -> public static DirectoryReader wrapAllDocsLive(DirectoryReader in) throws IOException;1536314350;Wraps a directory reader to make all documents live except those were rolled back_or hard-deleted due to non-aborting exceptions during indexing._The wrapped reader can be used to query all documents.__@param in the input directory reader_@return the wrapped reader;public static DirectoryReader wrapAllDocsLive(DirectoryReader in) throws IOException {_        return new DirectoryReaderWithAllLiveDocs(in)__    };wraps,a,directory,reader,to,make,all,documents,live,except,those,were,rolled,back,or,hard,deleted,due,to,non,aborting,exceptions,during,indexing,the,wrapped,reader,can,be,used,to,query,all,documents,param,in,the,input,directory,reader,return,the,wrapped,reader;public,static,directory,reader,wrap,all,docs,live,directory,reader,in,throws,ioexception,return,new,directory,reader,with,all,live,docs,in
Lucene -> public static DirectoryReader wrapAllDocsLive(DirectoryReader in) throws IOException;1536611444;Wraps a directory reader to make all documents live except those were rolled back_or hard-deleted due to non-aborting exceptions during indexing._The wrapped reader can be used to query all documents.__@param in the input directory reader_@return the wrapped reader;public static DirectoryReader wrapAllDocsLive(DirectoryReader in) throws IOException {_        return new DirectoryReaderWithAllLiveDocs(in)__    };wraps,a,directory,reader,to,make,all,documents,live,except,those,were,rolled,back,or,hard,deleted,due,to,non,aborting,exceptions,during,indexing,the,wrapped,reader,can,be,used,to,query,all,documents,param,in,the,input,directory,reader,return,the,wrapped,reader;public,static,directory,reader,wrap,all,docs,live,directory,reader,in,throws,ioexception,return,new,directory,reader,with,all,live,docs,in
Lucene -> public static DirectoryReader wrapAllDocsLive(DirectoryReader in) throws IOException;1537371806;Wraps a directory reader to make all documents live except those were rolled back_or hard-deleted due to non-aborting exceptions during indexing._The wrapped reader can be used to query all documents.__@param in the input directory reader_@return the wrapped reader;public static DirectoryReader wrapAllDocsLive(DirectoryReader in) throws IOException {_        return new DirectoryReaderWithAllLiveDocs(in)__    };wraps,a,directory,reader,to,make,all,documents,live,except,those,were,rolled,back,or,hard,deleted,due,to,non,aborting,exceptions,during,indexing,the,wrapped,reader,can,be,used,to,query,all,documents,param,in,the,input,directory,reader,return,the,wrapped,reader;public,static,directory,reader,wrap,all,docs,live,directory,reader,in,throws,ioexception,return,new,directory,reader,with,all,live,docs,in
Lucene -> public static DirectoryReader wrapAllDocsLive(DirectoryReader in) throws IOException;1539815831;Wraps a directory reader to make all documents live except those were rolled back_or hard-deleted due to non-aborting exceptions during indexing._The wrapped reader can be used to query all documents.__@param in the input directory reader_@return the wrapped reader;public static DirectoryReader wrapAllDocsLive(DirectoryReader in) throws IOException {_        return new DirectoryReaderWithAllLiveDocs(in)__    };wraps,a,directory,reader,to,make,all,documents,live,except,those,were,rolled,back,or,hard,deleted,due,to,non,aborting,exceptions,during,indexing,the,wrapped,reader,can,be,used,to,query,all,documents,param,in,the,input,directory,reader,return,the,wrapped,reader;public,static,directory,reader,wrap,all,docs,live,directory,reader,in,throws,ioexception,return,new,directory,reader,with,all,live,docs,in
Lucene -> public static DirectoryReader wrapAllDocsLive(DirectoryReader in) throws IOException;1540238977;Wraps a directory reader to make all documents live except those were rolled back_or hard-deleted due to non-aborting exceptions during indexing._The wrapped reader can be used to query all documents.__@param in the input directory reader_@return the wrapped reader;public static DirectoryReader wrapAllDocsLive(DirectoryReader in) throws IOException {_        return new DirectoryReaderWithAllLiveDocs(in)__    };wraps,a,directory,reader,to,make,all,documents,live,except,those,were,rolled,back,or,hard,deleted,due,to,non,aborting,exceptions,during,indexing,the,wrapped,reader,can,be,used,to,query,all,documents,param,in,the,input,directory,reader,return,the,wrapped,reader;public,static,directory,reader,wrap,all,docs,live,directory,reader,in,throws,ioexception,return,new,directory,reader,with,all,live,docs,in
Lucene -> public static DirectoryReader wrapAllDocsLive(DirectoryReader in) throws IOException;1541592065;Wraps a directory reader to make all documents live except those were rolled back_or hard-deleted due to non-aborting exceptions during indexing._The wrapped reader can be used to query all documents.__@param in the input directory reader_@return the wrapped reader;public static DirectoryReader wrapAllDocsLive(DirectoryReader in) throws IOException {_        return new DirectoryReaderWithAllLiveDocs(in)__    };wraps,a,directory,reader,to,make,all,documents,live,except,those,were,rolled,back,or,hard,deleted,due,to,non,aborting,exceptions,during,indexing,the,wrapped,reader,can,be,used,to,query,all,documents,param,in,the,input,directory,reader,return,the,wrapped,reader;public,static,directory,reader,wrap,all,docs,live,directory,reader,in,throws,ioexception,return,new,directory,reader,with,all,live,docs,in
Lucene -> public static DirectoryReader wrapAllDocsLive(DirectoryReader in) throws IOException;1541618615;Wraps a directory reader to make all documents live except those were rolled back_or hard-deleted due to non-aborting exceptions during indexing._The wrapped reader can be used to query all documents.__@param in the input directory reader_@return the wrapped reader;public static DirectoryReader wrapAllDocsLive(DirectoryReader in) throws IOException {_        return new DirectoryReaderWithAllLiveDocs(in)__    };wraps,a,directory,reader,to,make,all,documents,live,except,those,were,rolled,back,or,hard,deleted,due,to,non,aborting,exceptions,during,indexing,the,wrapped,reader,can,be,used,to,query,all,documents,param,in,the,input,directory,reader,return,the,wrapped,reader;public,static,directory,reader,wrap,all,docs,live,directory,reader,in,throws,ioexception,return,new,directory,reader,with,all,live,docs,in
Lucene -> public static DirectoryReader wrapAllDocsLive(DirectoryReader in) throws IOException;1544076142;Wraps a directory reader to make all documents live except those were rolled back_or hard-deleted due to non-aborting exceptions during indexing._The wrapped reader can be used to query all documents.__@param in the input directory reader_@return the wrapped reader;public static DirectoryReader wrapAllDocsLive(DirectoryReader in) throws IOException {_        return new DirectoryReaderWithAllLiveDocs(in)__    };wraps,a,directory,reader,to,make,all,documents,live,except,those,were,rolled,back,or,hard,deleted,due,to,non,aborting,exceptions,during,indexing,the,wrapped,reader,can,be,used,to,query,all,documents,param,in,the,input,directory,reader,return,the,wrapped,reader;public,static,directory,reader,wrap,all,docs,live,directory,reader,in,throws,ioexception,return,new,directory,reader,with,all,live,docs,in
Lucene -> public static DirectoryReader wrapAllDocsLive(DirectoryReader in) throws IOException;1544322276;Wraps a directory reader to make all documents live except those were rolled back_or hard-deleted due to non-aborting exceptions during indexing._The wrapped reader can be used to query all documents.__@param in the input directory reader_@return the wrapped reader;public static DirectoryReader wrapAllDocsLive(DirectoryReader in) throws IOException {_        return new DirectoryReaderWithAllLiveDocs(in)__    };wraps,a,directory,reader,to,make,all,documents,live,except,those,were,rolled,back,or,hard,deleted,due,to,non,aborting,exceptions,during,indexing,the,wrapped,reader,can,be,used,to,query,all,documents,param,in,the,input,directory,reader,return,the,wrapped,reader;public,static,directory,reader,wrap,all,docs,live,directory,reader,in,throws,ioexception,return,new,directory,reader,with,all,live,docs,in
Lucene -> public static DirectoryReader wrapAllDocsLive(DirectoryReader in) throws IOException;1544786574;Wraps a directory reader to make all documents live except those were rolled back_or hard-deleted due to non-aborting exceptions during indexing._The wrapped reader can be used to query all documents.__@param in the input directory reader_@return the wrapped reader;public static DirectoryReader wrapAllDocsLive(DirectoryReader in) throws IOException {_        return new DirectoryReaderWithAllLiveDocs(in)__    };wraps,a,directory,reader,to,make,all,documents,live,except,those,were,rolled,back,or,hard,deleted,due,to,non,aborting,exceptions,during,indexing,the,wrapped,reader,can,be,used,to,query,all,documents,param,in,the,input,directory,reader,return,the,wrapped,reader;public,static,directory,reader,wrap,all,docs,live,directory,reader,in,throws,ioexception,return,new,directory,reader,with,all,live,docs,in
Lucene -> public static SegmentInfos readSegmentInfos(IndexCommit commit) throws IOException;1524684173;Reads the segments infos from the given commit, failing if it fails to load;public static SegmentInfos readSegmentInfos(IndexCommit commit) throws IOException {_        _        _        String filename = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, "", commit.getGeneration())__        return SegmentInfos.readCommit(commit.getDirectory(), filename)__    };reads,the,segments,infos,from,the,given,commit,failing,if,it,fails,to,load;public,static,segment,infos,read,segment,infos,index,commit,commit,throws,ioexception,string,filename,index,file,names,file,name,from,generation,index,file,names,segments,commit,get,generation,return,segment,infos,read,commit,commit,get,directory,filename
Lucene -> public static SegmentInfos readSegmentInfos(IndexCommit commit) throws IOException;1525334055;Reads the segments infos from the given commit, failing if it fails to load;public static SegmentInfos readSegmentInfos(IndexCommit commit) throws IOException {_        _        _        String filename = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, "", commit.getGeneration())__        return SegmentInfos.readCommit(commit.getDirectory(), filename)__    };reads,the,segments,infos,from,the,given,commit,failing,if,it,fails,to,load;public,static,segment,infos,read,segment,infos,index,commit,commit,throws,ioexception,string,filename,index,file,names,file,name,from,generation,index,file,names,segments,commit,get,generation,return,segment,infos,read,commit,commit,get,directory,filename
Lucene -> public static SegmentInfos readSegmentInfos(IndexCommit commit) throws IOException;1535046779;Reads the segments infos from the given commit, failing if it fails to load;public static SegmentInfos readSegmentInfos(IndexCommit commit) throws IOException {_        _        _        String filename = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, "", commit.getGeneration())__        return SegmentInfos.readCommit(commit.getDirectory(), filename)__    };reads,the,segments,infos,from,the,given,commit,failing,if,it,fails,to,load;public,static,segment,infos,read,segment,infos,index,commit,commit,throws,ioexception,string,filename,index,file,names,file,name,from,generation,index,file,names,segments,commit,get,generation,return,segment,infos,read,commit,commit,get,directory,filename
Lucene -> public static SegmentInfos readSegmentInfos(IndexCommit commit) throws IOException;1535723122;Reads the segments infos from the given commit, failing if it fails to load;public static SegmentInfos readSegmentInfos(IndexCommit commit) throws IOException {_        _        _        String filename = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, "", commit.getGeneration())__        return SegmentInfos.readCommit(commit.getDirectory(), filename)__    };reads,the,segments,infos,from,the,given,commit,failing,if,it,fails,to,load;public,static,segment,infos,read,segment,infos,index,commit,commit,throws,ioexception,string,filename,index,file,names,file,name,from,generation,index,file,names,segments,commit,get,generation,return,segment,infos,read,commit,commit,get,directory,filename
Lucene -> public static SegmentInfos readSegmentInfos(IndexCommit commit) throws IOException;1536314350;Reads the segments infos from the given commit, failing if it fails to load;public static SegmentInfos readSegmentInfos(IndexCommit commit) throws IOException {_        _        _        String filename = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, "", commit.getGeneration())__        return SegmentInfos.readCommit(commit.getDirectory(), filename)__    };reads,the,segments,infos,from,the,given,commit,failing,if,it,fails,to,load;public,static,segment,infos,read,segment,infos,index,commit,commit,throws,ioexception,string,filename,index,file,names,file,name,from,generation,index,file,names,segments,commit,get,generation,return,segment,infos,read,commit,commit,get,directory,filename
Lucene -> public static SegmentInfos readSegmentInfos(IndexCommit commit) throws IOException;1536611444;Reads the segments infos from the given commit, failing if it fails to load;public static SegmentInfos readSegmentInfos(IndexCommit commit) throws IOException {_        _        _        String filename = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, "", commit.getGeneration())__        return SegmentInfos.readCommit(commit.getDirectory(), filename)__    };reads,the,segments,infos,from,the,given,commit,failing,if,it,fails,to,load;public,static,segment,infos,read,segment,infos,index,commit,commit,throws,ioexception,string,filename,index,file,names,file,name,from,generation,index,file,names,segments,commit,get,generation,return,segment,infos,read,commit,commit,get,directory,filename
Lucene -> public static SegmentInfos readSegmentInfos(IndexCommit commit) throws IOException;1537371806;Reads the segments infos from the given commit, failing if it fails to load;public static SegmentInfos readSegmentInfos(IndexCommit commit) throws IOException {_        _        _        String filename = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, "", commit.getGeneration())__        return SegmentInfos.readCommit(commit.getDirectory(), filename)__    };reads,the,segments,infos,from,the,given,commit,failing,if,it,fails,to,load;public,static,segment,infos,read,segment,infos,index,commit,commit,throws,ioexception,string,filename,index,file,names,file,name,from,generation,index,file,names,segments,commit,get,generation,return,segment,infos,read,commit,commit,get,directory,filename
Lucene -> public static SegmentInfos readSegmentInfos(IndexCommit commit) throws IOException;1539815831;Reads the segments infos from the given commit, failing if it fails to load;public static SegmentInfos readSegmentInfos(IndexCommit commit) throws IOException {_        _        _        String filename = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, "", commit.getGeneration())__        return SegmentInfos.readCommit(commit.getDirectory(), filename)__    };reads,the,segments,infos,from,the,given,commit,failing,if,it,fails,to,load;public,static,segment,infos,read,segment,infos,index,commit,commit,throws,ioexception,string,filename,index,file,names,file,name,from,generation,index,file,names,segments,commit,get,generation,return,segment,infos,read,commit,commit,get,directory,filename
Lucene -> public static SegmentInfos readSegmentInfos(IndexCommit commit) throws IOException;1540238977;Reads the segments infos from the given commit, failing if it fails to load;public static SegmentInfos readSegmentInfos(IndexCommit commit) throws IOException {_        _        _        String filename = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, "", commit.getGeneration())__        return SegmentInfos.readCommit(commit.getDirectory(), filename)__    };reads,the,segments,infos,from,the,given,commit,failing,if,it,fails,to,load;public,static,segment,infos,read,segment,infos,index,commit,commit,throws,ioexception,string,filename,index,file,names,file,name,from,generation,index,file,names,segments,commit,get,generation,return,segment,infos,read,commit,commit,get,directory,filename
Lucene -> public static SegmentInfos readSegmentInfos(IndexCommit commit) throws IOException;1541592065;Reads the segments infos from the given commit, failing if it fails to load;public static SegmentInfos readSegmentInfos(IndexCommit commit) throws IOException {_        _        _        String filename = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, "", commit.getGeneration())__        return SegmentInfos.readCommit(commit.getDirectory(), filename)__    };reads,the,segments,infos,from,the,given,commit,failing,if,it,fails,to,load;public,static,segment,infos,read,segment,infos,index,commit,commit,throws,ioexception,string,filename,index,file,names,file,name,from,generation,index,file,names,segments,commit,get,generation,return,segment,infos,read,commit,commit,get,directory,filename
Lucene -> public static SegmentInfos readSegmentInfos(IndexCommit commit) throws IOException;1541618615;Reads the segments infos from the given commit, failing if it fails to load;public static SegmentInfos readSegmentInfos(IndexCommit commit) throws IOException {_        _        _        String filename = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, "", commit.getGeneration())__        return SegmentInfos.readCommit(commit.getDirectory(), filename)__    };reads,the,segments,infos,from,the,given,commit,failing,if,it,fails,to,load;public,static,segment,infos,read,segment,infos,index,commit,commit,throws,ioexception,string,filename,index,file,names,file,name,from,generation,index,file,names,segments,commit,get,generation,return,segment,infos,read,commit,commit,get,directory,filename
Lucene -> public static SegmentInfos readSegmentInfos(IndexCommit commit) throws IOException;1544076142;Reads the segments infos from the given commit, failing if it fails to load;public static SegmentInfos readSegmentInfos(IndexCommit commit) throws IOException {_        _        _        String filename = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, "", commit.getGeneration())__        return SegmentInfos.readCommit(commit.getDirectory(), filename)__    };reads,the,segments,infos,from,the,given,commit,failing,if,it,fails,to,load;public,static,segment,infos,read,segment,infos,index,commit,commit,throws,ioexception,string,filename,index,file,names,file,name,from,generation,index,file,names,segments,commit,get,generation,return,segment,infos,read,commit,commit,get,directory,filename
Lucene -> public static SegmentInfos readSegmentInfos(IndexCommit commit) throws IOException;1544322276;Reads the segments infos from the given commit, failing if it fails to load;public static SegmentInfos readSegmentInfos(IndexCommit commit) throws IOException {_        _        _        String filename = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, "", commit.getGeneration())__        return SegmentInfos.readCommit(commit.getDirectory(), filename)__    };reads,the,segments,infos,from,the,given,commit,failing,if,it,fails,to,load;public,static,segment,infos,read,segment,infos,index,commit,commit,throws,ioexception,string,filename,index,file,names,file,name,from,generation,index,file,names,segments,commit,get,generation,return,segment,infos,read,commit,commit,get,directory,filename
Lucene -> public static SegmentInfos readSegmentInfos(IndexCommit commit) throws IOException;1544786574;Reads the segments infos from the given commit, failing if it fails to load;public static SegmentInfos readSegmentInfos(IndexCommit commit) throws IOException {_        _        _        String filename = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, "", commit.getGeneration())__        return SegmentInfos.readCommit(commit.getDirectory(), filename)__    };reads,the,segments,infos,from,the,given,commit,failing,if,it,fails,to,load;public,static,segment,infos,read,segment,infos,index,commit,commit,throws,ioexception,string,filename,index,file,names,file,name,from,generation,index,file,names,segments,commit,get,generation,return,segment,infos,read,commit,commit,get,directory,filename
Lucene -> public static void cleanLuceneIndex(Directory directory) throws IOException;1524684173;This method removes all lucene files from the given directory. It will first try to delete all commit points / segments_files to ensure broken commits or corrupted indices will not be opened in the future. If any of the segment files can't be deleted_this operation fails.;public static void cleanLuceneIndex(Directory directory) throws IOException {_        try (Lock writeLock = directory.obtainLock(IndexWriter.WRITE_LOCK_NAME)) {_            for (final String file : directory.listAll()) {_                if (file.startsWith(IndexFileNames.SEGMENTS) || file.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {_                    directory.deleteFile(file)_ _                }_            }_        }_        try (IndexWriter writer = new IndexWriter(directory, new IndexWriterConfig(Lucene.STANDARD_ANALYZER)_                .setMergePolicy(NoMergePolicy.INSTANCE) _                .setCommitOnClose(false) _                .setOpenMode(IndexWriterConfig.OpenMode.CREATE))) _        {_            _        }_    };this,method,removes,all,lucene,files,from,the,given,directory,it,will,first,try,to,delete,all,commit,points,segments,files,to,ensure,broken,commits,or,corrupted,indices,will,not,be,opened,in,the,future,if,any,of,the,segment,files,can,t,be,deleted,this,operation,fails;public,static,void,clean,lucene,index,directory,directory,throws,ioexception,try,lock,write,lock,directory,obtain,lock,index,writer,for,final,string,file,directory,list,all,if,file,starts,with,index,file,names,segments,file,equals,index,file,names,directory,delete,file,file,try,index,writer,writer,new,index,writer,directory,new,index,writer,config,lucene,set,merge,policy,no,merge,policy,instance,set,commit,on,close,false,set,open,mode,index,writer,config,open,mode,create
Lucene -> public static void cleanLuceneIndex(Directory directory) throws IOException;1525334055;This method removes all lucene files from the given directory. It will first try to delete all commit points / segments_files to ensure broken commits or corrupted indices will not be opened in the future. If any of the segment files can't be deleted_this operation fails.;public static void cleanLuceneIndex(Directory directory) throws IOException {_        try (Lock writeLock = directory.obtainLock(IndexWriter.WRITE_LOCK_NAME)) {_            for (final String file : directory.listAll()) {_                if (file.startsWith(IndexFileNames.SEGMENTS) || file.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {_                    directory.deleteFile(file)_ _                }_            }_        }_        try (IndexWriter writer = new IndexWriter(directory, new IndexWriterConfig(Lucene.STANDARD_ANALYZER)_                .setMergePolicy(NoMergePolicy.INSTANCE) _                .setCommitOnClose(false) _                .setOpenMode(IndexWriterConfig.OpenMode.CREATE))) _        {_            _        }_    };this,method,removes,all,lucene,files,from,the,given,directory,it,will,first,try,to,delete,all,commit,points,segments,files,to,ensure,broken,commits,or,corrupted,indices,will,not,be,opened,in,the,future,if,any,of,the,segment,files,can,t,be,deleted,this,operation,fails;public,static,void,clean,lucene,index,directory,directory,throws,ioexception,try,lock,write,lock,directory,obtain,lock,index,writer,for,final,string,file,directory,list,all,if,file,starts,with,index,file,names,segments,file,equals,index,file,names,directory,delete,file,file,try,index,writer,writer,new,index,writer,directory,new,index,writer,config,lucene,set,merge,policy,no,merge,policy,instance,set,commit,on,close,false,set,open,mode,index,writer,config,open,mode,create
Lucene -> public static void cleanLuceneIndex(Directory directory) throws IOException;1535046779;This method removes all lucene files from the given directory. It will first try to delete all commit points / segments_files to ensure broken commits or corrupted indices will not be opened in the future. If any of the segment files can't be deleted_this operation fails.;public static void cleanLuceneIndex(Directory directory) throws IOException {_        try (Lock writeLock = directory.obtainLock(IndexWriter.WRITE_LOCK_NAME)) {_            for (final String file : directory.listAll()) {_                if (file.startsWith(IndexFileNames.SEGMENTS) || file.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {_                    directory.deleteFile(file)_ _                }_            }_        }_        try (IndexWriter writer = new IndexWriter(directory, new IndexWriterConfig(Lucene.STANDARD_ANALYZER)_                .setMergePolicy(NoMergePolicy.INSTANCE) _                .setCommitOnClose(false) _                .setOpenMode(IndexWriterConfig.OpenMode.CREATE))) _        {_            _        }_    };this,method,removes,all,lucene,files,from,the,given,directory,it,will,first,try,to,delete,all,commit,points,segments,files,to,ensure,broken,commits,or,corrupted,indices,will,not,be,opened,in,the,future,if,any,of,the,segment,files,can,t,be,deleted,this,operation,fails;public,static,void,clean,lucene,index,directory,directory,throws,ioexception,try,lock,write,lock,directory,obtain,lock,index,writer,for,final,string,file,directory,list,all,if,file,starts,with,index,file,names,segments,file,equals,index,file,names,directory,delete,file,file,try,index,writer,writer,new,index,writer,directory,new,index,writer,config,lucene,set,merge,policy,no,merge,policy,instance,set,commit,on,close,false,set,open,mode,index,writer,config,open,mode,create
Lucene -> public static void cleanLuceneIndex(Directory directory) throws IOException;1535723122;This method removes all lucene files from the given directory. It will first try to delete all commit points / segments_files to ensure broken commits or corrupted indices will not be opened in the future. If any of the segment files can't be deleted_this operation fails.;public static void cleanLuceneIndex(Directory directory) throws IOException {_        try (Lock writeLock = directory.obtainLock(IndexWriter.WRITE_LOCK_NAME)) {_            for (final String file : directory.listAll()) {_                if (file.startsWith(IndexFileNames.SEGMENTS) || file.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {_                    directory.deleteFile(file)_ _                }_            }_        }_        try (IndexWriter writer = new IndexWriter(directory, new IndexWriterConfig(Lucene.STANDARD_ANALYZER)_                .setSoftDeletesField(Lucene.SOFT_DELETES_FIELD)_                .setMergePolicy(NoMergePolicy.INSTANCE) _                .setCommitOnClose(false) _                .setOpenMode(IndexWriterConfig.OpenMode.CREATE))) _        {_            _        }_    };this,method,removes,all,lucene,files,from,the,given,directory,it,will,first,try,to,delete,all,commit,points,segments,files,to,ensure,broken,commits,or,corrupted,indices,will,not,be,opened,in,the,future,if,any,of,the,segment,files,can,t,be,deleted,this,operation,fails;public,static,void,clean,lucene,index,directory,directory,throws,ioexception,try,lock,write,lock,directory,obtain,lock,index,writer,for,final,string,file,directory,list,all,if,file,starts,with,index,file,names,segments,file,equals,index,file,names,directory,delete,file,file,try,index,writer,writer,new,index,writer,directory,new,index,writer,config,lucene,set,soft,deletes,field,lucene,set,merge,policy,no,merge,policy,instance,set,commit,on,close,false,set,open,mode,index,writer,config,open,mode,create
Lucene -> public static void cleanLuceneIndex(Directory directory) throws IOException;1536314350;This method removes all lucene files from the given directory. It will first try to delete all commit points / segments_files to ensure broken commits or corrupted indices will not be opened in the future. If any of the segment files can't be deleted_this operation fails.;public static void cleanLuceneIndex(Directory directory) throws IOException {_        try (Lock writeLock = directory.obtainLock(IndexWriter.WRITE_LOCK_NAME)) {_            for (final String file : directory.listAll()) {_                if (file.startsWith(IndexFileNames.SEGMENTS) || file.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {_                    directory.deleteFile(file)_ _                }_            }_        }_        try (IndexWriter writer = new IndexWriter(directory, new IndexWriterConfig(Lucene.STANDARD_ANALYZER)_                .setSoftDeletesField(Lucene.SOFT_DELETES_FIELD)_                .setMergePolicy(NoMergePolicy.INSTANCE) _                .setCommitOnClose(false) _                .setOpenMode(IndexWriterConfig.OpenMode.CREATE))) _        {_            _        }_    };this,method,removes,all,lucene,files,from,the,given,directory,it,will,first,try,to,delete,all,commit,points,segments,files,to,ensure,broken,commits,or,corrupted,indices,will,not,be,opened,in,the,future,if,any,of,the,segment,files,can,t,be,deleted,this,operation,fails;public,static,void,clean,lucene,index,directory,directory,throws,ioexception,try,lock,write,lock,directory,obtain,lock,index,writer,for,final,string,file,directory,list,all,if,file,starts,with,index,file,names,segments,file,equals,index,file,names,directory,delete,file,file,try,index,writer,writer,new,index,writer,directory,new,index,writer,config,lucene,set,soft,deletes,field,lucene,set,merge,policy,no,merge,policy,instance,set,commit,on,close,false,set,open,mode,index,writer,config,open,mode,create
Lucene -> public static void cleanLuceneIndex(Directory directory) throws IOException;1536611444;This method removes all lucene files from the given directory. It will first try to delete all commit points / segments_files to ensure broken commits or corrupted indices will not be opened in the future. If any of the segment files can't be deleted_this operation fails.;public static void cleanLuceneIndex(Directory directory) throws IOException {_        try (Lock writeLock = directory.obtainLock(IndexWriter.WRITE_LOCK_NAME)) {_            for (final String file : directory.listAll()) {_                if (file.startsWith(IndexFileNames.SEGMENTS) || file.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {_                    directory.deleteFile(file)_ _                }_            }_        }_        try (IndexWriter writer = new IndexWriter(directory, new IndexWriterConfig(Lucene.STANDARD_ANALYZER)_                .setSoftDeletesField(Lucene.SOFT_DELETES_FIELD)_                .setMergePolicy(NoMergePolicy.INSTANCE) _                .setCommitOnClose(false) _                .setOpenMode(IndexWriterConfig.OpenMode.CREATE))) _        {_            _        }_    };this,method,removes,all,lucene,files,from,the,given,directory,it,will,first,try,to,delete,all,commit,points,segments,files,to,ensure,broken,commits,or,corrupted,indices,will,not,be,opened,in,the,future,if,any,of,the,segment,files,can,t,be,deleted,this,operation,fails;public,static,void,clean,lucene,index,directory,directory,throws,ioexception,try,lock,write,lock,directory,obtain,lock,index,writer,for,final,string,file,directory,list,all,if,file,starts,with,index,file,names,segments,file,equals,index,file,names,directory,delete,file,file,try,index,writer,writer,new,index,writer,directory,new,index,writer,config,lucene,set,soft,deletes,field,lucene,set,merge,policy,no,merge,policy,instance,set,commit,on,close,false,set,open,mode,index,writer,config,open,mode,create
Lucene -> public static void cleanLuceneIndex(Directory directory) throws IOException;1537371806;This method removes all lucene files from the given directory. It will first try to delete all commit points / segments_files to ensure broken commits or corrupted indices will not be opened in the future. If any of the segment files can't be deleted_this operation fails.;public static void cleanLuceneIndex(Directory directory) throws IOException {_        try (Lock writeLock = directory.obtainLock(IndexWriter.WRITE_LOCK_NAME)) {_            for (final String file : directory.listAll()) {_                if (file.startsWith(IndexFileNames.SEGMENTS) || file.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {_                    directory.deleteFile(file)_ _                }_            }_        }_        try (IndexWriter writer = new IndexWriter(directory, new IndexWriterConfig(Lucene.STANDARD_ANALYZER)_                .setSoftDeletesField(Lucene.SOFT_DELETES_FIELD)_                .setMergePolicy(NoMergePolicy.INSTANCE) _                .setCommitOnClose(false) _                .setOpenMode(IndexWriterConfig.OpenMode.CREATE))) _        {_            _        }_    };this,method,removes,all,lucene,files,from,the,given,directory,it,will,first,try,to,delete,all,commit,points,segments,files,to,ensure,broken,commits,or,corrupted,indices,will,not,be,opened,in,the,future,if,any,of,the,segment,files,can,t,be,deleted,this,operation,fails;public,static,void,clean,lucene,index,directory,directory,throws,ioexception,try,lock,write,lock,directory,obtain,lock,index,writer,for,final,string,file,directory,list,all,if,file,starts,with,index,file,names,segments,file,equals,index,file,names,directory,delete,file,file,try,index,writer,writer,new,index,writer,directory,new,index,writer,config,lucene,set,soft,deletes,field,lucene,set,merge,policy,no,merge,policy,instance,set,commit,on,close,false,set,open,mode,index,writer,config,open,mode,create
Lucene -> public static void cleanLuceneIndex(Directory directory) throws IOException;1539815831;This method removes all lucene files from the given directory. It will first try to delete all commit points / segments_files to ensure broken commits or corrupted indices will not be opened in the future. If any of the segment files can't be deleted_this operation fails.;public static void cleanLuceneIndex(Directory directory) throws IOException {_        try (Lock writeLock = directory.obtainLock(IndexWriter.WRITE_LOCK_NAME)) {_            for (final String file : directory.listAll()) {_                if (file.startsWith(IndexFileNames.SEGMENTS) || file.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {_                    directory.deleteFile(file)_ _                }_            }_        }_        try (IndexWriter writer = new IndexWriter(directory, new IndexWriterConfig(Lucene.STANDARD_ANALYZER)_                .setSoftDeletesField(Lucene.SOFT_DELETES_FIELD)_                .setMergePolicy(NoMergePolicy.INSTANCE) _                .setCommitOnClose(false) _                .setOpenMode(IndexWriterConfig.OpenMode.CREATE))) _        {_            _        }_    };this,method,removes,all,lucene,files,from,the,given,directory,it,will,first,try,to,delete,all,commit,points,segments,files,to,ensure,broken,commits,or,corrupted,indices,will,not,be,opened,in,the,future,if,any,of,the,segment,files,can,t,be,deleted,this,operation,fails;public,static,void,clean,lucene,index,directory,directory,throws,ioexception,try,lock,write,lock,directory,obtain,lock,index,writer,for,final,string,file,directory,list,all,if,file,starts,with,index,file,names,segments,file,equals,index,file,names,directory,delete,file,file,try,index,writer,writer,new,index,writer,directory,new,index,writer,config,lucene,set,soft,deletes,field,lucene,set,merge,policy,no,merge,policy,instance,set,commit,on,close,false,set,open,mode,index,writer,config,open,mode,create
Lucene -> public static void cleanLuceneIndex(Directory directory) throws IOException;1540238977;This method removes all lucene files from the given directory. It will first try to delete all commit points / segments_files to ensure broken commits or corrupted indices will not be opened in the future. If any of the segment files can't be deleted_this operation fails.;public static void cleanLuceneIndex(Directory directory) throws IOException {_        try (Lock writeLock = directory.obtainLock(IndexWriter.WRITE_LOCK_NAME)) {_            for (final String file : directory.listAll()) {_                if (file.startsWith(IndexFileNames.SEGMENTS) || file.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {_                    directory.deleteFile(file)_ _                }_            }_        }_        try (IndexWriter writer = new IndexWriter(directory, new IndexWriterConfig(Lucene.STANDARD_ANALYZER)_                .setSoftDeletesField(Lucene.SOFT_DELETES_FIELD)_                .setMergePolicy(NoMergePolicy.INSTANCE) _                .setCommitOnClose(false) _                .setOpenMode(IndexWriterConfig.OpenMode.CREATE))) _        {_            _        }_    };this,method,removes,all,lucene,files,from,the,given,directory,it,will,first,try,to,delete,all,commit,points,segments,files,to,ensure,broken,commits,or,corrupted,indices,will,not,be,opened,in,the,future,if,any,of,the,segment,files,can,t,be,deleted,this,operation,fails;public,static,void,clean,lucene,index,directory,directory,throws,ioexception,try,lock,write,lock,directory,obtain,lock,index,writer,for,final,string,file,directory,list,all,if,file,starts,with,index,file,names,segments,file,equals,index,file,names,directory,delete,file,file,try,index,writer,writer,new,index,writer,directory,new,index,writer,config,lucene,set,soft,deletes,field,lucene,set,merge,policy,no,merge,policy,instance,set,commit,on,close,false,set,open,mode,index,writer,config,open,mode,create
Lucene -> public static void cleanLuceneIndex(Directory directory) throws IOException;1541592065;This method removes all lucene files from the given directory. It will first try to delete all commit points / segments_files to ensure broken commits or corrupted indices will not be opened in the future. If any of the segment files can't be deleted_this operation fails.;public static void cleanLuceneIndex(Directory directory) throws IOException {_        try (Lock writeLock = directory.obtainLock(IndexWriter.WRITE_LOCK_NAME)) {_            for (final String file : directory.listAll()) {_                if (file.startsWith(IndexFileNames.SEGMENTS) || file.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {_                    directory.deleteFile(file)_ _                }_            }_        }_        try (IndexWriter writer = new IndexWriter(directory, new IndexWriterConfig(Lucene.STANDARD_ANALYZER)_                .setSoftDeletesField(Lucene.SOFT_DELETES_FIELD)_                .setMergePolicy(NoMergePolicy.INSTANCE) _                .setCommitOnClose(false) _                .setOpenMode(IndexWriterConfig.OpenMode.CREATE))) _        {_            _        }_    };this,method,removes,all,lucene,files,from,the,given,directory,it,will,first,try,to,delete,all,commit,points,segments,files,to,ensure,broken,commits,or,corrupted,indices,will,not,be,opened,in,the,future,if,any,of,the,segment,files,can,t,be,deleted,this,operation,fails;public,static,void,clean,lucene,index,directory,directory,throws,ioexception,try,lock,write,lock,directory,obtain,lock,index,writer,for,final,string,file,directory,list,all,if,file,starts,with,index,file,names,segments,file,equals,index,file,names,directory,delete,file,file,try,index,writer,writer,new,index,writer,directory,new,index,writer,config,lucene,set,soft,deletes,field,lucene,set,merge,policy,no,merge,policy,instance,set,commit,on,close,false,set,open,mode,index,writer,config,open,mode,create
Lucene -> public static void cleanLuceneIndex(Directory directory) throws IOException;1541618615;This method removes all lucene files from the given directory. It will first try to delete all commit points / segments_files to ensure broken commits or corrupted indices will not be opened in the future. If any of the segment files can't be deleted_this operation fails.;public static void cleanLuceneIndex(Directory directory) throws IOException {_        try (Lock writeLock = directory.obtainLock(IndexWriter.WRITE_LOCK_NAME)) {_            for (final String file : directory.listAll()) {_                if (file.startsWith(IndexFileNames.SEGMENTS) || file.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {_                    directory.deleteFile(file)_ _                }_            }_        }_        try (IndexWriter writer = new IndexWriter(directory, new IndexWriterConfig(Lucene.STANDARD_ANALYZER)_                .setSoftDeletesField(Lucene.SOFT_DELETES_FIELD)_                .setMergePolicy(NoMergePolicy.INSTANCE) _                .setCommitOnClose(false) _                .setOpenMode(IndexWriterConfig.OpenMode.CREATE))) _        {_            _        }_    };this,method,removes,all,lucene,files,from,the,given,directory,it,will,first,try,to,delete,all,commit,points,segments,files,to,ensure,broken,commits,or,corrupted,indices,will,not,be,opened,in,the,future,if,any,of,the,segment,files,can,t,be,deleted,this,operation,fails;public,static,void,clean,lucene,index,directory,directory,throws,ioexception,try,lock,write,lock,directory,obtain,lock,index,writer,for,final,string,file,directory,list,all,if,file,starts,with,index,file,names,segments,file,equals,index,file,names,directory,delete,file,file,try,index,writer,writer,new,index,writer,directory,new,index,writer,config,lucene,set,soft,deletes,field,lucene,set,merge,policy,no,merge,policy,instance,set,commit,on,close,false,set,open,mode,index,writer,config,open,mode,create
Lucene -> public static void cleanLuceneIndex(Directory directory) throws IOException;1544076142;This method removes all lucene files from the given directory. It will first try to delete all commit points / segments_files to ensure broken commits or corrupted indices will not be opened in the future. If any of the segment files can't be deleted_this operation fails.;public static void cleanLuceneIndex(Directory directory) throws IOException {_        try (Lock writeLock = directory.obtainLock(IndexWriter.WRITE_LOCK_NAME)) {_            for (final String file : directory.listAll()) {_                if (file.startsWith(IndexFileNames.SEGMENTS) || file.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {_                    directory.deleteFile(file)_ _                }_            }_        }_        try (IndexWriter writer = new IndexWriter(directory, new IndexWriterConfig(Lucene.STANDARD_ANALYZER)_                .setSoftDeletesField(Lucene.SOFT_DELETES_FIELD)_                .setMergePolicy(NoMergePolicy.INSTANCE) _                .setCommitOnClose(false) _                .setOpenMode(IndexWriterConfig.OpenMode.CREATE))) _        {_            _        }_    };this,method,removes,all,lucene,files,from,the,given,directory,it,will,first,try,to,delete,all,commit,points,segments,files,to,ensure,broken,commits,or,corrupted,indices,will,not,be,opened,in,the,future,if,any,of,the,segment,files,can,t,be,deleted,this,operation,fails;public,static,void,clean,lucene,index,directory,directory,throws,ioexception,try,lock,write,lock,directory,obtain,lock,index,writer,for,final,string,file,directory,list,all,if,file,starts,with,index,file,names,segments,file,equals,index,file,names,directory,delete,file,file,try,index,writer,writer,new,index,writer,directory,new,index,writer,config,lucene,set,soft,deletes,field,lucene,set,merge,policy,no,merge,policy,instance,set,commit,on,close,false,set,open,mode,index,writer,config,open,mode,create
Lucene -> public static void cleanLuceneIndex(Directory directory) throws IOException;1544322276;This method removes all lucene files from the given directory. It will first try to delete all commit points / segments_files to ensure broken commits or corrupted indices will not be opened in the future. If any of the segment files can't be deleted_this operation fails.;public static void cleanLuceneIndex(Directory directory) throws IOException {_        try (Lock writeLock = directory.obtainLock(IndexWriter.WRITE_LOCK_NAME)) {_            for (final String file : directory.listAll()) {_                if (file.startsWith(IndexFileNames.SEGMENTS) || file.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {_                    directory.deleteFile(file)_ _                }_            }_        }_        try (IndexWriter writer = new IndexWriter(directory, new IndexWriterConfig(Lucene.STANDARD_ANALYZER)_                .setSoftDeletesField(Lucene.SOFT_DELETES_FIELD)_                .setMergePolicy(NoMergePolicy.INSTANCE) _                .setCommitOnClose(false) _                .setOpenMode(IndexWriterConfig.OpenMode.CREATE))) _        {_            _        }_    };this,method,removes,all,lucene,files,from,the,given,directory,it,will,first,try,to,delete,all,commit,points,segments,files,to,ensure,broken,commits,or,corrupted,indices,will,not,be,opened,in,the,future,if,any,of,the,segment,files,can,t,be,deleted,this,operation,fails;public,static,void,clean,lucene,index,directory,directory,throws,ioexception,try,lock,write,lock,directory,obtain,lock,index,writer,for,final,string,file,directory,list,all,if,file,starts,with,index,file,names,segments,file,equals,index,file,names,directory,delete,file,file,try,index,writer,writer,new,index,writer,directory,new,index,writer,config,lucene,set,soft,deletes,field,lucene,set,merge,policy,no,merge,policy,instance,set,commit,on,close,false,set,open,mode,index,writer,config,open,mode,create
Lucene -> public static void cleanLuceneIndex(Directory directory) throws IOException;1544786574;This method removes all lucene files from the given directory. It will first try to delete all commit points / segments_files to ensure broken commits or corrupted indices will not be opened in the future. If any of the segment files can't be deleted_this operation fails.;public static void cleanLuceneIndex(Directory directory) throws IOException {_        try (Lock writeLock = directory.obtainLock(IndexWriter.WRITE_LOCK_NAME)) {_            for (final String file : directory.listAll()) {_                if (file.startsWith(IndexFileNames.SEGMENTS) || file.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {_                    directory.deleteFile(file)_ _                }_            }_        }_        try (IndexWriter writer = new IndexWriter(directory, new IndexWriterConfig(Lucene.STANDARD_ANALYZER)_                .setSoftDeletesField(Lucene.SOFT_DELETES_FIELD)_                .setMergePolicy(NoMergePolicy.INSTANCE) _                .setCommitOnClose(false) _                .setOpenMode(IndexWriterConfig.OpenMode.CREATE))) _        {_            _        }_    };this,method,removes,all,lucene,files,from,the,given,directory,it,will,first,try,to,delete,all,commit,points,segments,files,to,ensure,broken,commits,or,corrupted,indices,will,not,be,opened,in,the,future,if,any,of,the,segment,files,can,t,be,deleted,this,operation,fails;public,static,void,clean,lucene,index,directory,directory,throws,ioexception,try,lock,write,lock,directory,obtain,lock,index,writer,for,final,string,file,directory,list,all,if,file,starts,with,index,file,names,segments,file,equals,index,file,names,directory,delete,file,file,try,index,writer,writer,new,index,writer,directory,new,index,writer,config,lucene,set,soft,deletes,field,lucene,set,merge,policy,no,merge,policy,instance,set,commit,on,close,false,set,open,mode,index,writer,config,open,mode,create
Lucene -> public static SegmentReader segmentReader(LeafReader reader);1524684173;Tries to extract a segment reader from the given index reader._If no SegmentReader can be extracted an {@link IllegalStateException} is thrown.;public static SegmentReader segmentReader(LeafReader reader) {_        if (reader instanceof SegmentReader) {_            return (SegmentReader) reader__        } else if (reader instanceof FilterLeafReader) {_            final FilterLeafReader fReader = (FilterLeafReader) reader__            return segmentReader(FilterLeafReader.unwrap(fReader))__        }_        _        throw new IllegalStateException("Can not extract segment reader from given index reader [" + reader + "]")__    };tries,to,extract,a,segment,reader,from,the,given,index,reader,if,no,segment,reader,can,be,extracted,an,link,illegal,state,exception,is,thrown;public,static,segment,reader,segment,reader,leaf,reader,reader,if,reader,instanceof,segment,reader,return,segment,reader,reader,else,if,reader,instanceof,filter,leaf,reader,final,filter,leaf,reader,f,reader,filter,leaf,reader,reader,return,segment,reader,filter,leaf,reader,unwrap,f,reader,throw,new,illegal,state,exception,can,not,extract,segment,reader,from,given,index,reader,reader
Lucene -> public static SegmentReader segmentReader(LeafReader reader);1525334055;Tries to extract a segment reader from the given index reader._If no SegmentReader can be extracted an {@link IllegalStateException} is thrown.;public static SegmentReader segmentReader(LeafReader reader) {_        if (reader instanceof SegmentReader) {_            return (SegmentReader) reader__        } else if (reader instanceof FilterLeafReader) {_            final FilterLeafReader fReader = (FilterLeafReader) reader__            return segmentReader(FilterLeafReader.unwrap(fReader))__        }_        _        throw new IllegalStateException("Can not extract segment reader from given index reader [" + reader + "]")__    };tries,to,extract,a,segment,reader,from,the,given,index,reader,if,no,segment,reader,can,be,extracted,an,link,illegal,state,exception,is,thrown;public,static,segment,reader,segment,reader,leaf,reader,reader,if,reader,instanceof,segment,reader,return,segment,reader,reader,else,if,reader,instanceof,filter,leaf,reader,final,filter,leaf,reader,f,reader,filter,leaf,reader,reader,return,segment,reader,filter,leaf,reader,unwrap,f,reader,throw,new,illegal,state,exception,can,not,extract,segment,reader,from,given,index,reader,reader
Lucene -> public static SegmentReader segmentReader(LeafReader reader);1535046779;Tries to extract a segment reader from the given index reader._If no SegmentReader can be extracted an {@link IllegalStateException} is thrown.;public static SegmentReader segmentReader(LeafReader reader) {_        if (reader instanceof SegmentReader) {_            return (SegmentReader) reader__        } else if (reader instanceof FilterLeafReader) {_            final FilterLeafReader fReader = (FilterLeafReader) reader__            return segmentReader(FilterLeafReader.unwrap(fReader))__        }_        _        throw new IllegalStateException("Can not extract segment reader from given index reader [" + reader + "]")__    };tries,to,extract,a,segment,reader,from,the,given,index,reader,if,no,segment,reader,can,be,extracted,an,link,illegal,state,exception,is,thrown;public,static,segment,reader,segment,reader,leaf,reader,reader,if,reader,instanceof,segment,reader,return,segment,reader,reader,else,if,reader,instanceof,filter,leaf,reader,final,filter,leaf,reader,f,reader,filter,leaf,reader,reader,return,segment,reader,filter,leaf,reader,unwrap,f,reader,throw,new,illegal,state,exception,can,not,extract,segment,reader,from,given,index,reader,reader
Lucene -> public static SegmentReader segmentReader(LeafReader reader);1535723122;Tries to extract a segment reader from the given index reader._If no SegmentReader can be extracted an {@link IllegalStateException} is thrown.;public static SegmentReader segmentReader(LeafReader reader) {_        if (reader instanceof SegmentReader) {_            return (SegmentReader) reader__        } else if (reader instanceof FilterLeafReader) {_            final FilterLeafReader fReader = (FilterLeafReader) reader__            return segmentReader(FilterLeafReader.unwrap(fReader))__        }_        _        throw new IllegalStateException("Can not extract segment reader from given index reader [" + reader + "]")__    };tries,to,extract,a,segment,reader,from,the,given,index,reader,if,no,segment,reader,can,be,extracted,an,link,illegal,state,exception,is,thrown;public,static,segment,reader,segment,reader,leaf,reader,reader,if,reader,instanceof,segment,reader,return,segment,reader,reader,else,if,reader,instanceof,filter,leaf,reader,final,filter,leaf,reader,f,reader,filter,leaf,reader,reader,return,segment,reader,filter,leaf,reader,unwrap,f,reader,throw,new,illegal,state,exception,can,not,extract,segment,reader,from,given,index,reader,reader
Lucene -> public static SegmentReader segmentReader(LeafReader reader);1536314350;Tries to extract a segment reader from the given index reader._If no SegmentReader can be extracted an {@link IllegalStateException} is thrown.;public static SegmentReader segmentReader(LeafReader reader) {_        if (reader instanceof SegmentReader) {_            return (SegmentReader) reader__        } else if (reader instanceof FilterLeafReader) {_            final FilterLeafReader fReader = (FilterLeafReader) reader__            return segmentReader(FilterLeafReader.unwrap(fReader))__        }_        _        throw new IllegalStateException("Can not extract segment reader from given index reader [" + reader + "]")__    };tries,to,extract,a,segment,reader,from,the,given,index,reader,if,no,segment,reader,can,be,extracted,an,link,illegal,state,exception,is,thrown;public,static,segment,reader,segment,reader,leaf,reader,reader,if,reader,instanceof,segment,reader,return,segment,reader,reader,else,if,reader,instanceof,filter,leaf,reader,final,filter,leaf,reader,f,reader,filter,leaf,reader,reader,return,segment,reader,filter,leaf,reader,unwrap,f,reader,throw,new,illegal,state,exception,can,not,extract,segment,reader,from,given,index,reader,reader
Lucene -> public static SegmentReader segmentReader(LeafReader reader);1536611444;Tries to extract a segment reader from the given index reader._If no SegmentReader can be extracted an {@link IllegalStateException} is thrown.;public static SegmentReader segmentReader(LeafReader reader) {_        if (reader instanceof SegmentReader) {_            return (SegmentReader) reader__        } else if (reader instanceof FilterLeafReader) {_            final FilterLeafReader fReader = (FilterLeafReader) reader__            return segmentReader(FilterLeafReader.unwrap(fReader))__        }_        _        throw new IllegalStateException("Can not extract segment reader from given index reader [" + reader + "]")__    };tries,to,extract,a,segment,reader,from,the,given,index,reader,if,no,segment,reader,can,be,extracted,an,link,illegal,state,exception,is,thrown;public,static,segment,reader,segment,reader,leaf,reader,reader,if,reader,instanceof,segment,reader,return,segment,reader,reader,else,if,reader,instanceof,filter,leaf,reader,final,filter,leaf,reader,f,reader,filter,leaf,reader,reader,return,segment,reader,filter,leaf,reader,unwrap,f,reader,throw,new,illegal,state,exception,can,not,extract,segment,reader,from,given,index,reader,reader
Lucene -> public static SegmentReader segmentReader(LeafReader reader);1537371806;Tries to extract a segment reader from the given index reader._If no SegmentReader can be extracted an {@link IllegalStateException} is thrown.;public static SegmentReader segmentReader(LeafReader reader) {_        if (reader instanceof SegmentReader) {_            return (SegmentReader) reader__        } else if (reader instanceof FilterLeafReader) {_            final FilterLeafReader fReader = (FilterLeafReader) reader__            return segmentReader(FilterLeafReader.unwrap(fReader))__        } else if (reader instanceof FilterCodecReader) {_            final FilterCodecReader fReader = (FilterCodecReader) reader__            return segmentReader(FilterCodecReader.unwrap(fReader))__        }_        _        throw new IllegalStateException("Can not extract segment reader from given index reader [" + reader + "]")__    };tries,to,extract,a,segment,reader,from,the,given,index,reader,if,no,segment,reader,can,be,extracted,an,link,illegal,state,exception,is,thrown;public,static,segment,reader,segment,reader,leaf,reader,reader,if,reader,instanceof,segment,reader,return,segment,reader,reader,else,if,reader,instanceof,filter,leaf,reader,final,filter,leaf,reader,f,reader,filter,leaf,reader,reader,return,segment,reader,filter,leaf,reader,unwrap,f,reader,else,if,reader,instanceof,filter,codec,reader,final,filter,codec,reader,f,reader,filter,codec,reader,reader,return,segment,reader,filter,codec,reader,unwrap,f,reader,throw,new,illegal,state,exception,can,not,extract,segment,reader,from,given,index,reader,reader
Lucene -> public static SegmentReader segmentReader(LeafReader reader);1539815831;Tries to extract a segment reader from the given index reader._If no SegmentReader can be extracted an {@link IllegalStateException} is thrown.;public static SegmentReader segmentReader(LeafReader reader) {_        if (reader instanceof SegmentReader) {_            return (SegmentReader) reader__        } else if (reader instanceof FilterLeafReader) {_            final FilterLeafReader fReader = (FilterLeafReader) reader__            return segmentReader(FilterLeafReader.unwrap(fReader))__        } else if (reader instanceof FilterCodecReader) {_            final FilterCodecReader fReader = (FilterCodecReader) reader__            return segmentReader(FilterCodecReader.unwrap(fReader))__        }_        _        throw new IllegalStateException("Can not extract segment reader from given index reader [" + reader + "]")__    };tries,to,extract,a,segment,reader,from,the,given,index,reader,if,no,segment,reader,can,be,extracted,an,link,illegal,state,exception,is,thrown;public,static,segment,reader,segment,reader,leaf,reader,reader,if,reader,instanceof,segment,reader,return,segment,reader,reader,else,if,reader,instanceof,filter,leaf,reader,final,filter,leaf,reader,f,reader,filter,leaf,reader,reader,return,segment,reader,filter,leaf,reader,unwrap,f,reader,else,if,reader,instanceof,filter,codec,reader,final,filter,codec,reader,f,reader,filter,codec,reader,reader,return,segment,reader,filter,codec,reader,unwrap,f,reader,throw,new,illegal,state,exception,can,not,extract,segment,reader,from,given,index,reader,reader
Lucene -> public static SegmentReader segmentReader(LeafReader reader);1540238977;Tries to extract a segment reader from the given index reader._If no SegmentReader can be extracted an {@link IllegalStateException} is thrown.;public static SegmentReader segmentReader(LeafReader reader) {_        if (reader instanceof SegmentReader) {_            return (SegmentReader) reader__        } else if (reader instanceof FilterLeafReader) {_            final FilterLeafReader fReader = (FilterLeafReader) reader__            return segmentReader(FilterLeafReader.unwrap(fReader))__        } else if (reader instanceof FilterCodecReader) {_            final FilterCodecReader fReader = (FilterCodecReader) reader__            return segmentReader(FilterCodecReader.unwrap(fReader))__        }_        _        throw new IllegalStateException("Can not extract segment reader from given index reader [" + reader + "]")__    };tries,to,extract,a,segment,reader,from,the,given,index,reader,if,no,segment,reader,can,be,extracted,an,link,illegal,state,exception,is,thrown;public,static,segment,reader,segment,reader,leaf,reader,reader,if,reader,instanceof,segment,reader,return,segment,reader,reader,else,if,reader,instanceof,filter,leaf,reader,final,filter,leaf,reader,f,reader,filter,leaf,reader,reader,return,segment,reader,filter,leaf,reader,unwrap,f,reader,else,if,reader,instanceof,filter,codec,reader,final,filter,codec,reader,f,reader,filter,codec,reader,reader,return,segment,reader,filter,codec,reader,unwrap,f,reader,throw,new,illegal,state,exception,can,not,extract,segment,reader,from,given,index,reader,reader
Lucene -> public static SegmentReader segmentReader(LeafReader reader);1541592065;Tries to extract a segment reader from the given index reader._If no SegmentReader can be extracted an {@link IllegalStateException} is thrown.;public static SegmentReader segmentReader(LeafReader reader) {_        if (reader instanceof SegmentReader) {_            return (SegmentReader) reader__        } else if (reader instanceof FilterLeafReader) {_            final FilterLeafReader fReader = (FilterLeafReader) reader__            return segmentReader(FilterLeafReader.unwrap(fReader))__        } else if (reader instanceof FilterCodecReader) {_            final FilterCodecReader fReader = (FilterCodecReader) reader__            return segmentReader(FilterCodecReader.unwrap(fReader))__        }_        _        throw new IllegalStateException("Can not extract segment reader from given index reader [" + reader + "]")__    };tries,to,extract,a,segment,reader,from,the,given,index,reader,if,no,segment,reader,can,be,extracted,an,link,illegal,state,exception,is,thrown;public,static,segment,reader,segment,reader,leaf,reader,reader,if,reader,instanceof,segment,reader,return,segment,reader,reader,else,if,reader,instanceof,filter,leaf,reader,final,filter,leaf,reader,f,reader,filter,leaf,reader,reader,return,segment,reader,filter,leaf,reader,unwrap,f,reader,else,if,reader,instanceof,filter,codec,reader,final,filter,codec,reader,f,reader,filter,codec,reader,reader,return,segment,reader,filter,codec,reader,unwrap,f,reader,throw,new,illegal,state,exception,can,not,extract,segment,reader,from,given,index,reader,reader
Lucene -> public static SegmentReader segmentReader(LeafReader reader);1541618615;Tries to extract a segment reader from the given index reader._If no SegmentReader can be extracted an {@link IllegalStateException} is thrown.;public static SegmentReader segmentReader(LeafReader reader) {_        if (reader instanceof SegmentReader) {_            return (SegmentReader) reader__        } else if (reader instanceof FilterLeafReader) {_            final FilterLeafReader fReader = (FilterLeafReader) reader__            return segmentReader(FilterLeafReader.unwrap(fReader))__        } else if (reader instanceof FilterCodecReader) {_            final FilterCodecReader fReader = (FilterCodecReader) reader__            return segmentReader(FilterCodecReader.unwrap(fReader))__        }_        _        throw new IllegalStateException("Can not extract segment reader from given index reader [" + reader + "]")__    };tries,to,extract,a,segment,reader,from,the,given,index,reader,if,no,segment,reader,can,be,extracted,an,link,illegal,state,exception,is,thrown;public,static,segment,reader,segment,reader,leaf,reader,reader,if,reader,instanceof,segment,reader,return,segment,reader,reader,else,if,reader,instanceof,filter,leaf,reader,final,filter,leaf,reader,f,reader,filter,leaf,reader,reader,return,segment,reader,filter,leaf,reader,unwrap,f,reader,else,if,reader,instanceof,filter,codec,reader,final,filter,codec,reader,f,reader,filter,codec,reader,reader,return,segment,reader,filter,codec,reader,unwrap,f,reader,throw,new,illegal,state,exception,can,not,extract,segment,reader,from,given,index,reader,reader
Lucene -> public static SegmentReader segmentReader(LeafReader reader);1544076142;Tries to extract a segment reader from the given index reader._If no SegmentReader can be extracted an {@link IllegalStateException} is thrown.;public static SegmentReader segmentReader(LeafReader reader) {_        if (reader instanceof SegmentReader) {_            return (SegmentReader) reader__        } else if (reader instanceof FilterLeafReader) {_            final FilterLeafReader fReader = (FilterLeafReader) reader__            return segmentReader(FilterLeafReader.unwrap(fReader))__        } else if (reader instanceof FilterCodecReader) {_            final FilterCodecReader fReader = (FilterCodecReader) reader__            return segmentReader(FilterCodecReader.unwrap(fReader))__        }_        _        throw new IllegalStateException("Can not extract segment reader from given index reader [" + reader + "]")__    };tries,to,extract,a,segment,reader,from,the,given,index,reader,if,no,segment,reader,can,be,extracted,an,link,illegal,state,exception,is,thrown;public,static,segment,reader,segment,reader,leaf,reader,reader,if,reader,instanceof,segment,reader,return,segment,reader,reader,else,if,reader,instanceof,filter,leaf,reader,final,filter,leaf,reader,f,reader,filter,leaf,reader,reader,return,segment,reader,filter,leaf,reader,unwrap,f,reader,else,if,reader,instanceof,filter,codec,reader,final,filter,codec,reader,f,reader,filter,codec,reader,reader,return,segment,reader,filter,codec,reader,unwrap,f,reader,throw,new,illegal,state,exception,can,not,extract,segment,reader,from,given,index,reader,reader
Lucene -> public static SegmentReader segmentReader(LeafReader reader);1544322276;Tries to extract a segment reader from the given index reader._If no SegmentReader can be extracted an {@link IllegalStateException} is thrown.;public static SegmentReader segmentReader(LeafReader reader) {_        if (reader instanceof SegmentReader) {_            return (SegmentReader) reader__        } else if (reader instanceof FilterLeafReader) {_            final FilterLeafReader fReader = (FilterLeafReader) reader__            return segmentReader(FilterLeafReader.unwrap(fReader))__        } else if (reader instanceof FilterCodecReader) {_            final FilterCodecReader fReader = (FilterCodecReader) reader__            return segmentReader(FilterCodecReader.unwrap(fReader))__        }_        _        throw new IllegalStateException("Can not extract segment reader from given index reader [" + reader + "]")__    };tries,to,extract,a,segment,reader,from,the,given,index,reader,if,no,segment,reader,can,be,extracted,an,link,illegal,state,exception,is,thrown;public,static,segment,reader,segment,reader,leaf,reader,reader,if,reader,instanceof,segment,reader,return,segment,reader,reader,else,if,reader,instanceof,filter,leaf,reader,final,filter,leaf,reader,f,reader,filter,leaf,reader,reader,return,segment,reader,filter,leaf,reader,unwrap,f,reader,else,if,reader,instanceof,filter,codec,reader,final,filter,codec,reader,f,reader,filter,codec,reader,reader,return,segment,reader,filter,codec,reader,unwrap,f,reader,throw,new,illegal,state,exception,can,not,extract,segment,reader,from,given,index,reader,reader
Lucene -> public static SegmentReader segmentReader(LeafReader reader);1544786574;Tries to extract a segment reader from the given index reader._If no SegmentReader can be extracted an {@link IllegalStateException} is thrown.;public static SegmentReader segmentReader(LeafReader reader) {_        if (reader instanceof SegmentReader) {_            return (SegmentReader) reader__        } else if (reader instanceof FilterLeafReader) {_            final FilterLeafReader fReader = (FilterLeafReader) reader__            return segmentReader(FilterLeafReader.unwrap(fReader))__        } else if (reader instanceof FilterCodecReader) {_            final FilterCodecReader fReader = (FilterCodecReader) reader__            return segmentReader(FilterCodecReader.unwrap(fReader))__        }_        _        throw new IllegalStateException("Can not extract segment reader from given index reader [" + reader + "]")__    };tries,to,extract,a,segment,reader,from,the,given,index,reader,if,no,segment,reader,can,be,extracted,an,link,illegal,state,exception,is,thrown;public,static,segment,reader,segment,reader,leaf,reader,reader,if,reader,instanceof,segment,reader,return,segment,reader,reader,else,if,reader,instanceof,filter,leaf,reader,final,filter,leaf,reader,f,reader,filter,leaf,reader,reader,return,segment,reader,filter,leaf,reader,unwrap,f,reader,else,if,reader,instanceof,filter,codec,reader,final,filter,codec,reader,f,reader,filter,codec,reader,reader,return,segment,reader,filter,codec,reader,unwrap,f,reader,throw,new,illegal,state,exception,can,not,extract,segment,reader,from,given,index,reader,reader
Lucene -> public static Iterable<String> files(SegmentInfos infos) throws IOException;1524684173;Returns an iterable that allows to iterate over all files in this segments info;public static Iterable<String> files(SegmentInfos infos) throws IOException {_        final List<Collection<String>> list = new ArrayList<>()__        list.add(Collections.singleton(infos.getSegmentsFileName()))__        for (SegmentCommitInfo info : infos) {_            list.add(info.files())__        }_        return Iterables.flatten(list)__    };returns,an,iterable,that,allows,to,iterate,over,all,files,in,this,segments,info;public,static,iterable,string,files,segment,infos,infos,throws,ioexception,final,list,collection,string,list,new,array,list,list,add,collections,singleton,infos,get,segments,file,name,for,segment,commit,info,info,infos,list,add,info,files,return,iterables,flatten,list
Lucene -> public static Iterable<String> files(SegmentInfos infos) throws IOException;1525334055;Returns an iterable that allows to iterate over all files in this segments info;public static Iterable<String> files(SegmentInfos infos) throws IOException {_        final List<Collection<String>> list = new ArrayList<>()__        list.add(Collections.singleton(infos.getSegmentsFileName()))__        for (SegmentCommitInfo info : infos) {_            list.add(info.files())__        }_        return Iterables.flatten(list)__    };returns,an,iterable,that,allows,to,iterate,over,all,files,in,this,segments,info;public,static,iterable,string,files,segment,infos,infos,throws,ioexception,final,list,collection,string,list,new,array,list,list,add,collections,singleton,infos,get,segments,file,name,for,segment,commit,info,info,infos,list,add,info,files,return,iterables,flatten,list
Lucene -> public static Iterable<String> files(SegmentInfos infos) throws IOException;1535046779;Returns an iterable that allows to iterate over all files in this segments info;public static Iterable<String> files(SegmentInfos infos) throws IOException {_        final List<Collection<String>> list = new ArrayList<>()__        list.add(Collections.singleton(infos.getSegmentsFileName()))__        for (SegmentCommitInfo info : infos) {_            list.add(info.files())__        }_        return Iterables.flatten(list)__    };returns,an,iterable,that,allows,to,iterate,over,all,files,in,this,segments,info;public,static,iterable,string,files,segment,infos,infos,throws,ioexception,final,list,collection,string,list,new,array,list,list,add,collections,singleton,infos,get,segments,file,name,for,segment,commit,info,info,infos,list,add,info,files,return,iterables,flatten,list
Lucene -> public static Iterable<String> files(SegmentInfos infos) throws IOException;1535723122;Returns an iterable that allows to iterate over all files in this segments info;public static Iterable<String> files(SegmentInfos infos) throws IOException {_        final List<Collection<String>> list = new ArrayList<>()__        list.add(Collections.singleton(infos.getSegmentsFileName()))__        for (SegmentCommitInfo info : infos) {_            list.add(info.files())__        }_        return Iterables.flatten(list)__    };returns,an,iterable,that,allows,to,iterate,over,all,files,in,this,segments,info;public,static,iterable,string,files,segment,infos,infos,throws,ioexception,final,list,collection,string,list,new,array,list,list,add,collections,singleton,infos,get,segments,file,name,for,segment,commit,info,info,infos,list,add,info,files,return,iterables,flatten,list
Lucene -> public static Iterable<String> files(SegmentInfos infos) throws IOException;1536314350;Returns an iterable that allows to iterate over all files in this segments info;public static Iterable<String> files(SegmentInfos infos) throws IOException {_        final List<Collection<String>> list = new ArrayList<>()__        list.add(Collections.singleton(infos.getSegmentsFileName()))__        for (SegmentCommitInfo info : infos) {_            list.add(info.files())__        }_        return Iterables.flatten(list)__    };returns,an,iterable,that,allows,to,iterate,over,all,files,in,this,segments,info;public,static,iterable,string,files,segment,infos,infos,throws,ioexception,final,list,collection,string,list,new,array,list,list,add,collections,singleton,infos,get,segments,file,name,for,segment,commit,info,info,infos,list,add,info,files,return,iterables,flatten,list
Lucene -> public static Iterable<String> files(SegmentInfos infos) throws IOException;1536611444;Returns an iterable that allows to iterate over all files in this segments info;public static Iterable<String> files(SegmentInfos infos) throws IOException {_        final List<Collection<String>> list = new ArrayList<>()__        list.add(Collections.singleton(infos.getSegmentsFileName()))__        for (SegmentCommitInfo info : infos) {_            list.add(info.files())__        }_        return Iterables.flatten(list)__    };returns,an,iterable,that,allows,to,iterate,over,all,files,in,this,segments,info;public,static,iterable,string,files,segment,infos,infos,throws,ioexception,final,list,collection,string,list,new,array,list,list,add,collections,singleton,infos,get,segments,file,name,for,segment,commit,info,info,infos,list,add,info,files,return,iterables,flatten,list
Lucene -> public static Iterable<String> files(SegmentInfos infos) throws IOException;1537371806;Returns an iterable that allows to iterate over all files in this segments info;public static Iterable<String> files(SegmentInfos infos) throws IOException {_        final List<Collection<String>> list = new ArrayList<>()__        list.add(Collections.singleton(infos.getSegmentsFileName()))__        for (SegmentCommitInfo info : infos) {_            list.add(info.files())__        }_        return Iterables.flatten(list)__    };returns,an,iterable,that,allows,to,iterate,over,all,files,in,this,segments,info;public,static,iterable,string,files,segment,infos,infos,throws,ioexception,final,list,collection,string,list,new,array,list,list,add,collections,singleton,infos,get,segments,file,name,for,segment,commit,info,info,infos,list,add,info,files,return,iterables,flatten,list
Lucene -> public static Iterable<String> files(SegmentInfos infos) throws IOException;1539815831;Returns an iterable that allows to iterate over all files in this segments info;public static Iterable<String> files(SegmentInfos infos) throws IOException {_        final List<Collection<String>> list = new ArrayList<>()__        list.add(Collections.singleton(infos.getSegmentsFileName()))__        for (SegmentCommitInfo info : infos) {_            list.add(info.files())__        }_        return Iterables.flatten(list)__    };returns,an,iterable,that,allows,to,iterate,over,all,files,in,this,segments,info;public,static,iterable,string,files,segment,infos,infos,throws,ioexception,final,list,collection,string,list,new,array,list,list,add,collections,singleton,infos,get,segments,file,name,for,segment,commit,info,info,infos,list,add,info,files,return,iterables,flatten,list
Lucene -> public static Iterable<String> files(SegmentInfos infos) throws IOException;1540238977;Returns an iterable that allows to iterate over all files in this segments info;public static Iterable<String> files(SegmentInfos infos) throws IOException {_        final List<Collection<String>> list = new ArrayList<>()__        list.add(Collections.singleton(infos.getSegmentsFileName()))__        for (SegmentCommitInfo info : infos) {_            list.add(info.files())__        }_        return Iterables.flatten(list)__    };returns,an,iterable,that,allows,to,iterate,over,all,files,in,this,segments,info;public,static,iterable,string,files,segment,infos,infos,throws,ioexception,final,list,collection,string,list,new,array,list,list,add,collections,singleton,infos,get,segments,file,name,for,segment,commit,info,info,infos,list,add,info,files,return,iterables,flatten,list
Lucene -> public static Iterable<String> files(SegmentInfos infos) throws IOException;1541592065;Returns an iterable that allows to iterate over all files in this segments info;public static Iterable<String> files(SegmentInfos infos) throws IOException {_        final List<Collection<String>> list = new ArrayList<>()__        list.add(Collections.singleton(infos.getSegmentsFileName()))__        for (SegmentCommitInfo info : infos) {_            list.add(info.files())__        }_        return Iterables.flatten(list)__    };returns,an,iterable,that,allows,to,iterate,over,all,files,in,this,segments,info;public,static,iterable,string,files,segment,infos,infos,throws,ioexception,final,list,collection,string,list,new,array,list,list,add,collections,singleton,infos,get,segments,file,name,for,segment,commit,info,info,infos,list,add,info,files,return,iterables,flatten,list
Lucene -> public static Iterable<String> files(SegmentInfos infos) throws IOException;1541618615;Returns an iterable that allows to iterate over all files in this segments info;public static Iterable<String> files(SegmentInfos infos) throws IOException {_        final List<Collection<String>> list = new ArrayList<>()__        list.add(Collections.singleton(infos.getSegmentsFileName()))__        for (SegmentCommitInfo info : infos) {_            list.add(info.files())__        }_        return Iterables.flatten(list)__    };returns,an,iterable,that,allows,to,iterate,over,all,files,in,this,segments,info;public,static,iterable,string,files,segment,infos,infos,throws,ioexception,final,list,collection,string,list,new,array,list,list,add,collections,singleton,infos,get,segments,file,name,for,segment,commit,info,info,infos,list,add,info,files,return,iterables,flatten,list
Lucene -> public static Iterable<String> files(SegmentInfos infos) throws IOException;1544076142;Returns an iterable that allows to iterate over all files in this segments info;public static Iterable<String> files(SegmentInfos infos) throws IOException {_        final List<Collection<String>> list = new ArrayList<>()__        list.add(Collections.singleton(infos.getSegmentsFileName()))__        for (SegmentCommitInfo info : infos) {_            list.add(info.files())__        }_        return Iterables.flatten(list)__    };returns,an,iterable,that,allows,to,iterate,over,all,files,in,this,segments,info;public,static,iterable,string,files,segment,infos,infos,throws,ioexception,final,list,collection,string,list,new,array,list,list,add,collections,singleton,infos,get,segments,file,name,for,segment,commit,info,info,infos,list,add,info,files,return,iterables,flatten,list
Lucene -> public static Iterable<String> files(SegmentInfos infos) throws IOException;1544322276;Returns an iterable that allows to iterate over all files in this segments info;public static Iterable<String> files(SegmentInfos infos) throws IOException {_        final List<Collection<String>> list = new ArrayList<>()__        list.add(Collections.singleton(infos.getSegmentsFileName()))__        for (SegmentCommitInfo info : infos) {_            list.add(info.files())__        }_        return Iterables.flatten(list)__    };returns,an,iterable,that,allows,to,iterate,over,all,files,in,this,segments,info;public,static,iterable,string,files,segment,infos,infos,throws,ioexception,final,list,collection,string,list,new,array,list,list,add,collections,singleton,infos,get,segments,file,name,for,segment,commit,info,info,infos,list,add,info,files,return,iterables,flatten,list
Lucene -> public static Iterable<String> files(SegmentInfos infos) throws IOException;1544786574;Returns an iterable that allows to iterate over all files in this segments info;public static Iterable<String> files(SegmentInfos infos) throws IOException {_        final List<Collection<String>> list = new ArrayList<>()__        list.add(Collections.singleton(infos.getSegmentsFileName()))__        for (SegmentCommitInfo info : infos) {_            list.add(info.files())__        }_        return Iterables.flatten(list)__    };returns,an,iterable,that,allows,to,iterate,over,all,files,in,this,segments,info;public,static,iterable,string,files,segment,infos,infos,throws,ioexception,final,list,collection,string,list,new,array,list,list,add,collections,singleton,infos,get,segments,file,name,for,segment,commit,info,info,infos,list,add,info,files,return,iterables,flatten,list
Lucene -> public static IndexCommit getIndexCommit(SegmentInfos si, Directory directory) throws IOException;1541618615;Returns an index commit for the given {@link SegmentInfos} in the given directory.;public static IndexCommit getIndexCommit(SegmentInfos si, Directory directory) throws IOException {_        return new CommitPoint(si, directory)__    };returns,an,index,commit,for,the,given,link,segment,infos,in,the,given,directory;public,static,index,commit,get,index,commit,segment,infos,si,directory,directory,throws,ioexception,return,new,commit,point,si,directory
Lucene -> public static IndexCommit getIndexCommit(SegmentInfos si, Directory directory) throws IOException;1544076142;Returns an index commit for the given {@link SegmentInfos} in the given directory.;public static IndexCommit getIndexCommit(SegmentInfos si, Directory directory) throws IOException {_        return new CommitPoint(si, directory)__    };returns,an,index,commit,for,the,given,link,segment,infos,in,the,given,directory;public,static,index,commit,get,index,commit,segment,infos,si,directory,directory,throws,ioexception,return,new,commit,point,si,directory
Lucene -> public static IndexCommit getIndexCommit(SegmentInfos si, Directory directory) throws IOException;1544322276;Returns an index commit for the given {@link SegmentInfos} in the given directory.;public static IndexCommit getIndexCommit(SegmentInfos si, Directory directory) throws IOException {_        return new CommitPoint(si, directory)__    };returns,an,index,commit,for,the,given,link,segment,infos,in,the,given,directory;public,static,index,commit,get,index,commit,segment,infos,si,directory,directory,throws,ioexception,return,new,commit,point,si,directory
Lucene -> public static IndexCommit getIndexCommit(SegmentInfos si, Directory directory) throws IOException;1544786574;Returns an index commit for the given {@link SegmentInfos} in the given directory.;public static IndexCommit getIndexCommit(SegmentInfos si, Directory directory) throws IOException {_        return new CommitPoint(si, directory)__    };returns,an,index,commit,for,the,given,link,segment,infos,in,the,given,directory;public,static,index,commit,get,index,commit,segment,infos,si,directory,directory,throws,ioexception,return,new,commit,point,si,directory
Lucene -> private static SegmentInfos readSegmentInfos(String segmentsFileName, Directory directory) throws IOException;1524684173;Reads the segments infos from the given segments file name, failing if it fails to load;private static SegmentInfos readSegmentInfos(String segmentsFileName, Directory directory) throws IOException {_        return SegmentInfos.readCommit(directory, segmentsFileName)__    };reads,the,segments,infos,from,the,given,segments,file,name,failing,if,it,fails,to,load;private,static,segment,infos,read,segment,infos,string,segments,file,name,directory,directory,throws,ioexception,return,segment,infos,read,commit,directory,segments,file,name
Lucene -> private static SegmentInfos readSegmentInfos(String segmentsFileName, Directory directory) throws IOException;1525334055;Reads the segments infos from the given segments file name, failing if it fails to load;private static SegmentInfos readSegmentInfos(String segmentsFileName, Directory directory) throws IOException {_        return SegmentInfos.readCommit(directory, segmentsFileName)__    };reads,the,segments,infos,from,the,given,segments,file,name,failing,if,it,fails,to,load;private,static,segment,infos,read,segment,infos,string,segments,file,name,directory,directory,throws,ioexception,return,segment,infos,read,commit,directory,segments,file,name
Lucene -> private static SegmentInfos readSegmentInfos(String segmentsFileName, Directory directory) throws IOException;1535046779;Reads the segments infos from the given segments file name, failing if it fails to load;private static SegmentInfos readSegmentInfos(String segmentsFileName, Directory directory) throws IOException {_        return SegmentInfos.readCommit(directory, segmentsFileName)__    };reads,the,segments,infos,from,the,given,segments,file,name,failing,if,it,fails,to,load;private,static,segment,infos,read,segment,infos,string,segments,file,name,directory,directory,throws,ioexception,return,segment,infos,read,commit,directory,segments,file,name
Lucene -> private static SegmentInfos readSegmentInfos(String segmentsFileName, Directory directory) throws IOException;1535723122;Reads the segments infos from the given segments file name, failing if it fails to load;private static SegmentInfos readSegmentInfos(String segmentsFileName, Directory directory) throws IOException {_        return SegmentInfos.readCommit(directory, segmentsFileName)__    };reads,the,segments,infos,from,the,given,segments,file,name,failing,if,it,fails,to,load;private,static,segment,infos,read,segment,infos,string,segments,file,name,directory,directory,throws,ioexception,return,segment,infos,read,commit,directory,segments,file,name
Lucene -> private static SegmentInfos readSegmentInfos(String segmentsFileName, Directory directory) throws IOException;1536314350;Reads the segments infos from the given segments file name, failing if it fails to load;private static SegmentInfos readSegmentInfos(String segmentsFileName, Directory directory) throws IOException {_        return SegmentInfos.readCommit(directory, segmentsFileName)__    };reads,the,segments,infos,from,the,given,segments,file,name,failing,if,it,fails,to,load;private,static,segment,infos,read,segment,infos,string,segments,file,name,directory,directory,throws,ioexception,return,segment,infos,read,commit,directory,segments,file,name
Lucene -> private static SegmentInfos readSegmentInfos(String segmentsFileName, Directory directory) throws IOException;1536611444;Reads the segments infos from the given segments file name, failing if it fails to load;private static SegmentInfos readSegmentInfos(String segmentsFileName, Directory directory) throws IOException {_        return SegmentInfos.readCommit(directory, segmentsFileName)__    };reads,the,segments,infos,from,the,given,segments,file,name,failing,if,it,fails,to,load;private,static,segment,infos,read,segment,infos,string,segments,file,name,directory,directory,throws,ioexception,return,segment,infos,read,commit,directory,segments,file,name
Lucene -> private static SegmentInfos readSegmentInfos(String segmentsFileName, Directory directory) throws IOException;1537371806;Reads the segments infos from the given segments file name, failing if it fails to load;private static SegmentInfos readSegmentInfos(String segmentsFileName, Directory directory) throws IOException {_        return SegmentInfos.readCommit(directory, segmentsFileName)__    };reads,the,segments,infos,from,the,given,segments,file,name,failing,if,it,fails,to,load;private,static,segment,infos,read,segment,infos,string,segments,file,name,directory,directory,throws,ioexception,return,segment,infos,read,commit,directory,segments,file,name
Lucene -> private static SegmentInfos readSegmentInfos(String segmentsFileName, Directory directory) throws IOException;1539815831;Reads the segments infos from the given segments file name, failing if it fails to load;private static SegmentInfos readSegmentInfos(String segmentsFileName, Directory directory) throws IOException {_        return SegmentInfos.readCommit(directory, segmentsFileName)__    };reads,the,segments,infos,from,the,given,segments,file,name,failing,if,it,fails,to,load;private,static,segment,infos,read,segment,infos,string,segments,file,name,directory,directory,throws,ioexception,return,segment,infos,read,commit,directory,segments,file,name
Lucene -> private static SegmentInfos readSegmentInfos(String segmentsFileName, Directory directory) throws IOException;1540238977;Reads the segments infos from the given segments file name, failing if it fails to load;private static SegmentInfos readSegmentInfos(String segmentsFileName, Directory directory) throws IOException {_        return SegmentInfos.readCommit(directory, segmentsFileName)__    };reads,the,segments,infos,from,the,given,segments,file,name,failing,if,it,fails,to,load;private,static,segment,infos,read,segment,infos,string,segments,file,name,directory,directory,throws,ioexception,return,segment,infos,read,commit,directory,segments,file,name
Lucene -> private static SegmentInfos readSegmentInfos(String segmentsFileName, Directory directory) throws IOException;1541592065;Reads the segments infos from the given segments file name, failing if it fails to load;private static SegmentInfos readSegmentInfos(String segmentsFileName, Directory directory) throws IOException {_        return SegmentInfos.readCommit(directory, segmentsFileName)__    };reads,the,segments,infos,from,the,given,segments,file,name,failing,if,it,fails,to,load;private,static,segment,infos,read,segment,infos,string,segments,file,name,directory,directory,throws,ioexception,return,segment,infos,read,commit,directory,segments,file,name
Lucene -> private static SegmentInfos readSegmentInfos(String segmentsFileName, Directory directory) throws IOException;1541618615;Reads the segments infos from the given segments file name, failing if it fails to load;private static SegmentInfos readSegmentInfos(String segmentsFileName, Directory directory) throws IOException {_        return SegmentInfos.readCommit(directory, segmentsFileName)__    };reads,the,segments,infos,from,the,given,segments,file,name,failing,if,it,fails,to,load;private,static,segment,infos,read,segment,infos,string,segments,file,name,directory,directory,throws,ioexception,return,segment,infos,read,commit,directory,segments,file,name
Lucene -> private static SegmentInfos readSegmentInfos(String segmentsFileName, Directory directory) throws IOException;1544076142;Reads the segments infos from the given segments file name, failing if it fails to load;private static SegmentInfos readSegmentInfos(String segmentsFileName, Directory directory) throws IOException {_        return SegmentInfos.readCommit(directory, segmentsFileName)__    };reads,the,segments,infos,from,the,given,segments,file,name,failing,if,it,fails,to,load;private,static,segment,infos,read,segment,infos,string,segments,file,name,directory,directory,throws,ioexception,return,segment,infos,read,commit,directory,segments,file,name
Lucene -> private static SegmentInfos readSegmentInfos(String segmentsFileName, Directory directory) throws IOException;1544322276;Reads the segments infos from the given segments file name, failing if it fails to load;private static SegmentInfos readSegmentInfos(String segmentsFileName, Directory directory) throws IOException {_        return SegmentInfos.readCommit(directory, segmentsFileName)__    };reads,the,segments,infos,from,the,given,segments,file,name,failing,if,it,fails,to,load;private,static,segment,infos,read,segment,infos,string,segments,file,name,directory,directory,throws,ioexception,return,segment,infos,read,commit,directory,segments,file,name
Lucene -> private static SegmentInfos readSegmentInfos(String segmentsFileName, Directory directory) throws IOException;1544786574;Reads the segments infos from the given segments file name, failing if it fails to load;private static SegmentInfos readSegmentInfos(String segmentsFileName, Directory directory) throws IOException {_        return SegmentInfos.readCommit(directory, segmentsFileName)__    };reads,the,segments,infos,from,the,given,segments,file,name,failing,if,it,fails,to,load;private,static,segment,infos,read,segment,infos,string,segments,file,name,directory,directory,throws,ioexception,return,segment,infos,read,commit,directory,segments,file,name
Lucene -> public static int getNumDocs(SegmentInfos info);1524684173;Returns the number of documents in the index referenced by this {@link SegmentInfos};public static int getNumDocs(SegmentInfos info) {_        int numDocs = 0__        for (SegmentCommitInfo si : info) {_            numDocs += si.info.maxDoc() - si.getDelCount()__        }_        return numDocs__    };returns,the,number,of,documents,in,the,index,referenced,by,this,link,segment,infos;public,static,int,get,num,docs,segment,infos,info,int,num,docs,0,for,segment,commit,info,si,info,num,docs,si,info,max,doc,si,get,del,count,return,num,docs
Lucene -> public static int getNumDocs(SegmentInfos info);1525334055;Returns the number of documents in the index referenced by this {@link SegmentInfos};public static int getNumDocs(SegmentInfos info) {_        int numDocs = 0__        for (SegmentCommitInfo si : info) {_            numDocs += si.info.maxDoc() - si.getDelCount()__        }_        return numDocs__    };returns,the,number,of,documents,in,the,index,referenced,by,this,link,segment,infos;public,static,int,get,num,docs,segment,infos,info,int,num,docs,0,for,segment,commit,info,si,info,num,docs,si,info,max,doc,si,get,del,count,return,num,docs
Lucene -> public static int getNumDocs(SegmentInfos info);1535046779;Returns the number of documents in the index referenced by this {@link SegmentInfos};public static int getNumDocs(SegmentInfos info) {_        int numDocs = 0__        for (SegmentCommitInfo si : info) {_            numDocs += si.info.maxDoc() - si.getDelCount()__        }_        return numDocs__    };returns,the,number,of,documents,in,the,index,referenced,by,this,link,segment,infos;public,static,int,get,num,docs,segment,infos,info,int,num,docs,0,for,segment,commit,info,si,info,num,docs,si,info,max,doc,si,get,del,count,return,num,docs
Lucene -> public static int getNumDocs(SegmentInfos info);1535723122;Returns the number of documents in the index referenced by this {@link SegmentInfos};public static int getNumDocs(SegmentInfos info) {_        int numDocs = 0__        for (SegmentCommitInfo si : info) {_            numDocs += si.info.maxDoc() - si.getDelCount() - si.getSoftDelCount()__        }_        return numDocs__    };returns,the,number,of,documents,in,the,index,referenced,by,this,link,segment,infos;public,static,int,get,num,docs,segment,infos,info,int,num,docs,0,for,segment,commit,info,si,info,num,docs,si,info,max,doc,si,get,del,count,si,get,soft,del,count,return,num,docs
Lucene -> public static int getNumDocs(SegmentInfos info);1536314350;Returns the number of documents in the index referenced by this {@link SegmentInfos};public static int getNumDocs(SegmentInfos info) {_        int numDocs = 0__        for (SegmentCommitInfo si : info) {_            numDocs += si.info.maxDoc() - si.getDelCount() - si.getSoftDelCount()__        }_        return numDocs__    };returns,the,number,of,documents,in,the,index,referenced,by,this,link,segment,infos;public,static,int,get,num,docs,segment,infos,info,int,num,docs,0,for,segment,commit,info,si,info,num,docs,si,info,max,doc,si,get,del,count,si,get,soft,del,count,return,num,docs
Lucene -> public static int getNumDocs(SegmentInfos info);1536611444;Returns the number of documents in the index referenced by this {@link SegmentInfos};public static int getNumDocs(SegmentInfos info) {_        int numDocs = 0__        for (SegmentCommitInfo si : info) {_            numDocs += si.info.maxDoc() - si.getDelCount() - si.getSoftDelCount()__        }_        return numDocs__    };returns,the,number,of,documents,in,the,index,referenced,by,this,link,segment,infos;public,static,int,get,num,docs,segment,infos,info,int,num,docs,0,for,segment,commit,info,si,info,num,docs,si,info,max,doc,si,get,del,count,si,get,soft,del,count,return,num,docs
Lucene -> public static int getNumDocs(SegmentInfos info);1537371806;Returns the number of documents in the index referenced by this {@link SegmentInfos};public static int getNumDocs(SegmentInfos info) {_        int numDocs = 0__        for (SegmentCommitInfo si : info) {_            numDocs += si.info.maxDoc() - si.getDelCount() - si.getSoftDelCount()__        }_        return numDocs__    };returns,the,number,of,documents,in,the,index,referenced,by,this,link,segment,infos;public,static,int,get,num,docs,segment,infos,info,int,num,docs,0,for,segment,commit,info,si,info,num,docs,si,info,max,doc,si,get,del,count,si,get,soft,del,count,return,num,docs
Lucene -> public static int getNumDocs(SegmentInfos info);1539815831;Returns the number of documents in the index referenced by this {@link SegmentInfos};public static int getNumDocs(SegmentInfos info) {_        int numDocs = 0__        for (SegmentCommitInfo si : info) {_            numDocs += si.info.maxDoc() - si.getDelCount() - si.getSoftDelCount()__        }_        return numDocs__    };returns,the,number,of,documents,in,the,index,referenced,by,this,link,segment,infos;public,static,int,get,num,docs,segment,infos,info,int,num,docs,0,for,segment,commit,info,si,info,num,docs,si,info,max,doc,si,get,del,count,si,get,soft,del,count,return,num,docs
Lucene -> public static int getNumDocs(SegmentInfos info);1540238977;Returns the number of documents in the index referenced by this {@link SegmentInfos};public static int getNumDocs(SegmentInfos info) {_        int numDocs = 0__        for (SegmentCommitInfo si : info) {_            numDocs += si.info.maxDoc() - si.getDelCount() - si.getSoftDelCount()__        }_        return numDocs__    };returns,the,number,of,documents,in,the,index,referenced,by,this,link,segment,infos;public,static,int,get,num,docs,segment,infos,info,int,num,docs,0,for,segment,commit,info,si,info,num,docs,si,info,max,doc,si,get,del,count,si,get,soft,del,count,return,num,docs
Lucene -> public static int getNumDocs(SegmentInfos info);1541592065;Returns the number of documents in the index referenced by this {@link SegmentInfos};public static int getNumDocs(SegmentInfos info) {_        int numDocs = 0__        for (SegmentCommitInfo si : info) {_            numDocs += si.info.maxDoc() - si.getDelCount() - si.getSoftDelCount()__        }_        return numDocs__    };returns,the,number,of,documents,in,the,index,referenced,by,this,link,segment,infos;public,static,int,get,num,docs,segment,infos,info,int,num,docs,0,for,segment,commit,info,si,info,num,docs,si,info,max,doc,si,get,del,count,si,get,soft,del,count,return,num,docs
Lucene -> public static int getNumDocs(SegmentInfos info);1541618615;Returns the number of documents in the index referenced by this {@link SegmentInfos};public static int getNumDocs(SegmentInfos info) {_        int numDocs = 0__        for (SegmentCommitInfo si : info) {_            numDocs += si.info.maxDoc() - si.getDelCount() - si.getSoftDelCount()__        }_        return numDocs__    };returns,the,number,of,documents,in,the,index,referenced,by,this,link,segment,infos;public,static,int,get,num,docs,segment,infos,info,int,num,docs,0,for,segment,commit,info,si,info,num,docs,si,info,max,doc,si,get,del,count,si,get,soft,del,count,return,num,docs
Lucene -> public static int getNumDocs(SegmentInfos info);1544076142;Returns the number of documents in the index referenced by this {@link SegmentInfos};public static int getNumDocs(SegmentInfos info) {_        int numDocs = 0__        for (SegmentCommitInfo si : info) {_            numDocs += si.info.maxDoc() - si.getDelCount() - si.getSoftDelCount()__        }_        return numDocs__    };returns,the,number,of,documents,in,the,index,referenced,by,this,link,segment,infos;public,static,int,get,num,docs,segment,infos,info,int,num,docs,0,for,segment,commit,info,si,info,num,docs,si,info,max,doc,si,get,del,count,si,get,soft,del,count,return,num,docs
Lucene -> public static int getNumDocs(SegmentInfos info);1544322276;Returns the number of documents in the index referenced by this {@link SegmentInfos};public static int getNumDocs(SegmentInfos info) {_        int numDocs = 0__        for (SegmentCommitInfo si : info) {_            numDocs += si.info.maxDoc() - si.getDelCount() - si.getSoftDelCount()__        }_        return numDocs__    };returns,the,number,of,documents,in,the,index,referenced,by,this,link,segment,infos;public,static,int,get,num,docs,segment,infos,info,int,num,docs,0,for,segment,commit,info,si,info,num,docs,si,info,max,doc,si,get,del,count,si,get,soft,del,count,return,num,docs
Lucene -> public static int getNumDocs(SegmentInfos info);1544786574;Returns the number of documents in the index referenced by this {@link SegmentInfos};public static int getNumDocs(SegmentInfos info) {_        int numDocs = 0__        for (SegmentCommitInfo si : info) {_            numDocs += si.info.maxDoc() - si.getDelCount() - si.getSoftDelCount()__        }_        return numDocs__    };returns,the,number,of,documents,in,the,index,referenced,by,this,link,segment,infos;public,static,int,get,num,docs,segment,infos,info,int,num,docs,0,for,segment,commit,info,si,info,num,docs,si,info,max,doc,si,get,del,count,si,get,soft,del,count,return,num,docs
Lucene -> public static Version parseVersionLenient(String toParse, Version defaultValue);1524684173;Parses the version string lenient and returns the default value if the given string is null or empty;public static Version parseVersionLenient(String toParse, Version defaultValue) {_        return LenientParser.parse(toParse, defaultValue)__    };parses,the,version,string,lenient,and,returns,the,default,value,if,the,given,string,is,null,or,empty;public,static,version,parse,version,lenient,string,to,parse,version,default,value,return,lenient,parser,parse,to,parse,default,value
Lucene -> public static Version parseVersionLenient(String toParse, Version defaultValue);1525334055;Parses the version string lenient and returns the default value if the given string is null or empty;public static Version parseVersionLenient(String toParse, Version defaultValue) {_        return LenientParser.parse(toParse, defaultValue)__    };parses,the,version,string,lenient,and,returns,the,default,value,if,the,given,string,is,null,or,empty;public,static,version,parse,version,lenient,string,to,parse,version,default,value,return,lenient,parser,parse,to,parse,default,value
Lucene -> public static Version parseVersionLenient(String toParse, Version defaultValue);1535046779;Parses the version string lenient and returns the default value if the given string is null or empty;public static Version parseVersionLenient(String toParse, Version defaultValue) {_        return LenientParser.parse(toParse, defaultValue)__    };parses,the,version,string,lenient,and,returns,the,default,value,if,the,given,string,is,null,or,empty;public,static,version,parse,version,lenient,string,to,parse,version,default,value,return,lenient,parser,parse,to,parse,default,value
Lucene -> public static Version parseVersionLenient(String toParse, Version defaultValue);1535723122;Parses the version string lenient and returns the default value if the given string is null or empty;public static Version parseVersionLenient(String toParse, Version defaultValue) {_        return LenientParser.parse(toParse, defaultValue)__    };parses,the,version,string,lenient,and,returns,the,default,value,if,the,given,string,is,null,or,empty;public,static,version,parse,version,lenient,string,to,parse,version,default,value,return,lenient,parser,parse,to,parse,default,value
Lucene -> public static Version parseVersionLenient(String toParse, Version defaultValue);1536314350;Parses the version string lenient and returns the default value if the given string is null or empty;public static Version parseVersionLenient(String toParse, Version defaultValue) {_        return LenientParser.parse(toParse, defaultValue)__    };parses,the,version,string,lenient,and,returns,the,default,value,if,the,given,string,is,null,or,empty;public,static,version,parse,version,lenient,string,to,parse,version,default,value,return,lenient,parser,parse,to,parse,default,value
Lucene -> public static Version parseVersionLenient(String toParse, Version defaultValue);1536611444;Parses the version string lenient and returns the default value if the given string is null or empty;public static Version parseVersionLenient(String toParse, Version defaultValue) {_        return LenientParser.parse(toParse, defaultValue)__    };parses,the,version,string,lenient,and,returns,the,default,value,if,the,given,string,is,null,or,empty;public,static,version,parse,version,lenient,string,to,parse,version,default,value,return,lenient,parser,parse,to,parse,default,value
Lucene -> public static Version parseVersionLenient(String toParse, Version defaultValue);1537371806;Parses the version string lenient and returns the default value if the given string is null or empty;public static Version parseVersionLenient(String toParse, Version defaultValue) {_        return LenientParser.parse(toParse, defaultValue)__    };parses,the,version,string,lenient,and,returns,the,default,value,if,the,given,string,is,null,or,empty;public,static,version,parse,version,lenient,string,to,parse,version,default,value,return,lenient,parser,parse,to,parse,default,value
Lucene -> public static Version parseVersionLenient(String toParse, Version defaultValue);1539815831;Parses the version string lenient and returns the default value if the given string is null or empty;public static Version parseVersionLenient(String toParse, Version defaultValue) {_        return LenientParser.parse(toParse, defaultValue)__    };parses,the,version,string,lenient,and,returns,the,default,value,if,the,given,string,is,null,or,empty;public,static,version,parse,version,lenient,string,to,parse,version,default,value,return,lenient,parser,parse,to,parse,default,value
Lucene -> public static Version parseVersionLenient(String toParse, Version defaultValue);1540238977;Parses the version string lenient and returns the default value if the given string is null or empty;public static Version parseVersionLenient(String toParse, Version defaultValue) {_        return LenientParser.parse(toParse, defaultValue)__    };parses,the,version,string,lenient,and,returns,the,default,value,if,the,given,string,is,null,or,empty;public,static,version,parse,version,lenient,string,to,parse,version,default,value,return,lenient,parser,parse,to,parse,default,value
Lucene -> public static Version parseVersionLenient(String toParse, Version defaultValue);1541592065;Parses the version string lenient and returns the default value if the given string is null or empty;public static Version parseVersionLenient(String toParse, Version defaultValue) {_        return LenientParser.parse(toParse, defaultValue)__    };parses,the,version,string,lenient,and,returns,the,default,value,if,the,given,string,is,null,or,empty;public,static,version,parse,version,lenient,string,to,parse,version,default,value,return,lenient,parser,parse,to,parse,default,value
Lucene -> public static Version parseVersionLenient(String toParse, Version defaultValue);1541618615;Parses the version string lenient and returns the default value if the given string is null or empty;public static Version parseVersionLenient(String toParse, Version defaultValue) {_        return LenientParser.parse(toParse, defaultValue)__    };parses,the,version,string,lenient,and,returns,the,default,value,if,the,given,string,is,null,or,empty;public,static,version,parse,version,lenient,string,to,parse,version,default,value,return,lenient,parser,parse,to,parse,default,value
Lucene -> public static Version parseVersionLenient(String toParse, Version defaultValue);1544076142;Parses the version string lenient and returns the default value if the given string is null or empty;public static Version parseVersionLenient(String toParse, Version defaultValue) {_        return LenientParser.parse(toParse, defaultValue)__    };parses,the,version,string,lenient,and,returns,the,default,value,if,the,given,string,is,null,or,empty;public,static,version,parse,version,lenient,string,to,parse,version,default,value,return,lenient,parser,parse,to,parse,default,value
Lucene -> public static Version parseVersionLenient(String toParse, Version defaultValue);1544322276;Parses the version string lenient and returns the default value if the given string is null or empty;public static Version parseVersionLenient(String toParse, Version defaultValue) {_        return LenientParser.parse(toParse, defaultValue)__    };parses,the,version,string,lenient,and,returns,the,default,value,if,the,given,string,is,null,or,empty;public,static,version,parse,version,lenient,string,to,parse,version,default,value,return,lenient,parser,parse,to,parse,default,value
Lucene -> public static Version parseVersionLenient(String toParse, Version defaultValue);1544786574;Parses the version string lenient and returns the default value if the given string is null or empty;public static Version parseVersionLenient(String toParse, Version defaultValue) {_        return LenientParser.parse(toParse, defaultValue)__    };parses,the,version,string,lenient,and,returns,the,default,value,if,the,given,string,is,null,or,empty;public,static,version,parse,version,lenient,string,to,parse,version,default,value,return,lenient,parser,parse,to,parse,default,value
Lucene -> public static boolean canEarlyTerminate(Sort searchSort, Sort indexSort);1536314350;Whether a query sorted by {@code searchSort} can be early-terminated if the index is sorted by {@code indexSort}.;public static boolean canEarlyTerminate(Sort searchSort, Sort indexSort) {_        final SortField[] fields1 = searchSort.getSort()__        final SortField[] fields2 = indexSort.getSort()__        _        if (fields1.length > fields2.length) {_            return false__        }_        return Arrays.asList(fields1).equals(Arrays.asList(fields2).subList(0, fields1.length))__    };whether,a,query,sorted,by,code,search,sort,can,be,early,terminated,if,the,index,is,sorted,by,code,index,sort;public,static,boolean,can,early,terminate,sort,search,sort,sort,index,sort,final,sort,field,fields1,search,sort,get,sort,final,sort,field,fields2,index,sort,get,sort,if,fields1,length,fields2,length,return,false,return,arrays,as,list,fields1,equals,arrays,as,list,fields2,sub,list,0,fields1,length
Lucene -> public static boolean canEarlyTerminate(Sort searchSort, Sort indexSort);1536611444;Whether a query sorted by {@code searchSort} can be early-terminated if the index is sorted by {@code indexSort}.;public static boolean canEarlyTerminate(Sort searchSort, Sort indexSort) {_        final SortField[] fields1 = searchSort.getSort()__        final SortField[] fields2 = indexSort.getSort()__        _        if (fields1.length > fields2.length) {_            return false__        }_        return Arrays.asList(fields1).equals(Arrays.asList(fields2).subList(0, fields1.length))__    };whether,a,query,sorted,by,code,search,sort,can,be,early,terminated,if,the,index,is,sorted,by,code,index,sort;public,static,boolean,can,early,terminate,sort,search,sort,sort,index,sort,final,sort,field,fields1,search,sort,get,sort,final,sort,field,fields2,index,sort,get,sort,if,fields1,length,fields2,length,return,false,return,arrays,as,list,fields1,equals,arrays,as,list,fields2,sub,list,0,fields1,length
Lucene -> public static boolean canEarlyTerminate(Sort searchSort, Sort indexSort);1537371806;Whether a query sorted by {@code searchSort} can be early-terminated if the index is sorted by {@code indexSort}.;public static boolean canEarlyTerminate(Sort searchSort, Sort indexSort) {_        final SortField[] fields1 = searchSort.getSort()__        final SortField[] fields2 = indexSort.getSort()__        _        if (fields1.length > fields2.length) {_            return false__        }_        return Arrays.asList(fields1).equals(Arrays.asList(fields2).subList(0, fields1.length))__    };whether,a,query,sorted,by,code,search,sort,can,be,early,terminated,if,the,index,is,sorted,by,code,index,sort;public,static,boolean,can,early,terminate,sort,search,sort,sort,index,sort,final,sort,field,fields1,search,sort,get,sort,final,sort,field,fields2,index,sort,get,sort,if,fields1,length,fields2,length,return,false,return,arrays,as,list,fields1,equals,arrays,as,list,fields2,sub,list,0,fields1,length
Lucene -> public static boolean canEarlyTerminate(Sort searchSort, Sort indexSort);1539815831;Whether a query sorted by {@code searchSort} can be early-terminated if the index is sorted by {@code indexSort}.;public static boolean canEarlyTerminate(Sort searchSort, Sort indexSort) {_        final SortField[] fields1 = searchSort.getSort()__        final SortField[] fields2 = indexSort.getSort()__        _        if (fields1.length > fields2.length) {_            return false__        }_        return Arrays.asList(fields1).equals(Arrays.asList(fields2).subList(0, fields1.length))__    };whether,a,query,sorted,by,code,search,sort,can,be,early,terminated,if,the,index,is,sorted,by,code,index,sort;public,static,boolean,can,early,terminate,sort,search,sort,sort,index,sort,final,sort,field,fields1,search,sort,get,sort,final,sort,field,fields2,index,sort,get,sort,if,fields1,length,fields2,length,return,false,return,arrays,as,list,fields1,equals,arrays,as,list,fields2,sub,list,0,fields1,length
Lucene -> public static boolean canEarlyTerminate(Sort searchSort, Sort indexSort);1540238977;Whether a query sorted by {@code searchSort} can be early-terminated if the index is sorted by {@code indexSort}.;public static boolean canEarlyTerminate(Sort searchSort, Sort indexSort) {_        final SortField[] fields1 = searchSort.getSort()__        final SortField[] fields2 = indexSort.getSort()__        _        if (fields1.length > fields2.length) {_            return false__        }_        return Arrays.asList(fields1).equals(Arrays.asList(fields2).subList(0, fields1.length))__    };whether,a,query,sorted,by,code,search,sort,can,be,early,terminated,if,the,index,is,sorted,by,code,index,sort;public,static,boolean,can,early,terminate,sort,search,sort,sort,index,sort,final,sort,field,fields1,search,sort,get,sort,final,sort,field,fields2,index,sort,get,sort,if,fields1,length,fields2,length,return,false,return,arrays,as,list,fields1,equals,arrays,as,list,fields2,sub,list,0,fields1,length
Lucene -> public static boolean canEarlyTerminate(Sort searchSort, Sort indexSort);1541592065;Whether a query sorted by {@code searchSort} can be early-terminated if the index is sorted by {@code indexSort}.;public static boolean canEarlyTerminate(Sort searchSort, Sort indexSort) {_        final SortField[] fields1 = searchSort.getSort()__        final SortField[] fields2 = indexSort.getSort()__        _        if (fields1.length > fields2.length) {_            return false__        }_        return Arrays.asList(fields1).equals(Arrays.asList(fields2).subList(0, fields1.length))__    };whether,a,query,sorted,by,code,search,sort,can,be,early,terminated,if,the,index,is,sorted,by,code,index,sort;public,static,boolean,can,early,terminate,sort,search,sort,sort,index,sort,final,sort,field,fields1,search,sort,get,sort,final,sort,field,fields2,index,sort,get,sort,if,fields1,length,fields2,length,return,false,return,arrays,as,list,fields1,equals,arrays,as,list,fields2,sub,list,0,fields1,length
Lucene -> public static boolean canEarlyTerminate(Sort searchSort, Sort indexSort);1541618615;Whether a query sorted by {@code searchSort} can be early-terminated if the index is sorted by {@code indexSort}.;public static boolean canEarlyTerminate(Sort searchSort, Sort indexSort) {_        final SortField[] fields1 = searchSort.getSort()__        final SortField[] fields2 = indexSort.getSort()__        _        if (fields1.length > fields2.length) {_            return false__        }_        return Arrays.asList(fields1).equals(Arrays.asList(fields2).subList(0, fields1.length))__    };whether,a,query,sorted,by,code,search,sort,can,be,early,terminated,if,the,index,is,sorted,by,code,index,sort;public,static,boolean,can,early,terminate,sort,search,sort,sort,index,sort,final,sort,field,fields1,search,sort,get,sort,final,sort,field,fields2,index,sort,get,sort,if,fields1,length,fields2,length,return,false,return,arrays,as,list,fields1,equals,arrays,as,list,fields2,sub,list,0,fields1,length
Lucene -> public static boolean canEarlyTerminate(Sort searchSort, Sort indexSort);1544076142;Whether a query sorted by {@code searchSort} can be early-terminated if the index is sorted by {@code indexSort}.;public static boolean canEarlyTerminate(Sort searchSort, Sort indexSort) {_        final SortField[] fields1 = searchSort.getSort()__        final SortField[] fields2 = indexSort.getSort()__        _        if (fields1.length > fields2.length) {_            return false__        }_        return Arrays.asList(fields1).equals(Arrays.asList(fields2).subList(0, fields1.length))__    };whether,a,query,sorted,by,code,search,sort,can,be,early,terminated,if,the,index,is,sorted,by,code,index,sort;public,static,boolean,can,early,terminate,sort,search,sort,sort,index,sort,final,sort,field,fields1,search,sort,get,sort,final,sort,field,fields2,index,sort,get,sort,if,fields1,length,fields2,length,return,false,return,arrays,as,list,fields1,equals,arrays,as,list,fields2,sub,list,0,fields1,length
Lucene -> public static boolean canEarlyTerminate(Sort searchSort, Sort indexSort);1544322276;Whether a query sorted by {@code searchSort} can be early-terminated if the index is sorted by {@code indexSort}.;public static boolean canEarlyTerminate(Sort searchSort, Sort indexSort) {_        final SortField[] fields1 = searchSort.getSort()__        final SortField[] fields2 = indexSort.getSort()__        _        if (fields1.length > fields2.length) {_            return false__        }_        return Arrays.asList(fields1).equals(Arrays.asList(fields2).subList(0, fields1.length))__    };whether,a,query,sorted,by,code,search,sort,can,be,early,terminated,if,the,index,is,sorted,by,code,index,sort;public,static,boolean,can,early,terminate,sort,search,sort,sort,index,sort,final,sort,field,fields1,search,sort,get,sort,final,sort,field,fields2,index,sort,get,sort,if,fields1,length,fields2,length,return,false,return,arrays,as,list,fields1,equals,arrays,as,list,fields2,sub,list,0,fields1,length
Lucene -> public static boolean canEarlyTerminate(Sort searchSort, Sort indexSort);1544786574;Whether a query sorted by {@code searchSort} can be early-terminated if the index is sorted by {@code indexSort}.;public static boolean canEarlyTerminate(Sort searchSort, Sort indexSort) {_        final SortField[] fields1 = searchSort.getSort()__        final SortField[] fields2 = indexSort.getSort()__        _        if (fields1.length > fields2.length) {_            return false__        }_        return Arrays.asList(fields1).equals(Arrays.asList(fields2).subList(0, fields1.length))__    };whether,a,query,sorted,by,code,search,sort,can,be,early,terminated,if,the,index,is,sorted,by,code,index,sort;public,static,boolean,can,early,terminate,sort,search,sort,sort,index,sort,final,sort,field,fields1,search,sort,get,sort,final,sort,field,fields2,index,sort,get,sort,if,fields1,length,fields2,length,return,false,return,arrays,as,list,fields1,equals,arrays,as,list,fields2,sub,list,0,fields1,length
