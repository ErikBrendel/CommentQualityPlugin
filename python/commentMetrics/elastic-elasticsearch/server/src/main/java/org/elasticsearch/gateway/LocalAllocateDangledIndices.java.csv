commented;modifiers;parameterAmount;loc;comment;code
false;public;1;6;;@Override public AllocateDangledResponse read(StreamInput in) throws IOException {     final AllocateDangledResponse response = new AllocateDangledResponse().     response.readFrom(in).     return response. }
false;public;1;4;;@Override public void handleResponse(AllocateDangledResponse response) {     listener.onResponse(response). }
false;public;1;4;;@Override public void handleException(TransportException exp) {     listener.onFailure(exp). }
false;public;0;4;;@Override public String executor() {     return ThreadPool.Names.SAME. }
false;public;2;33;;public void allocateDangled(Collection<IndexMetaData> indices, final Listener listener) {     ClusterState clusterState = clusterService.state().     DiscoveryNode masterNode = clusterState.nodes().getMasterNode().     if (masterNode == null) {         listener.onFailure(new MasterNotDiscoveredException("no master to send allocate dangled request")).         return.     }     AllocateDangledRequest request = new AllocateDangledRequest(clusterService.localNode(), indices.toArray(new IndexMetaData[indices.size()])).     transportService.sendRequest(masterNode, ACTION_NAME, request, new TransportResponseHandler<AllocateDangledResponse>() {          @Override         public AllocateDangledResponse read(StreamInput in) throws IOException {             final AllocateDangledResponse response = new AllocateDangledResponse().             response.readFrom(in).             return response.         }          @Override         public void handleResponse(AllocateDangledResponse response) {             listener.onResponse(response).         }          @Override         public void handleException(TransportException exp) {             listener.onFailure(exp).         }          @Override         public String executor() {             return ThreadPool.Names.SAME.         }     }). }
false;;1;1;;void onResponse(AllocateDangledResponse response).
false;;1;1;;void onFailure(Throwable e).
false;public;1;64;;@Override public ClusterState execute(ClusterState currentState) {     if (currentState.blocks().disableStatePersistence()) {         return currentState.     }     MetaData.Builder metaData = MetaData.builder(currentState.metaData()).     ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(currentState.blocks()).     RoutingTable.Builder routingTableBuilder = RoutingTable.builder(currentState.routingTable()).     final Version minIndexCompatibilityVersion = currentState.getNodes().getMaxNodeVersion().minimumIndexCompatibilityVersion().     boolean importNeeded = false.     StringBuilder sb = new StringBuilder().     for (IndexMetaData indexMetaData : request.indices) {         if (indexMetaData.getCreationVersion().before(minIndexCompatibilityVersion)) {             logger.warn("ignoring dangled index [{}] on node [{}]" + " since it's created version [{}] is not supported by at least one node in the cluster minVersion [{}]", indexMetaData.getIndex(), request.fromNode, indexMetaData.getCreationVersion(), minIndexCompatibilityVersion).             continue.         }         if (currentState.metaData().hasIndex(indexMetaData.getIndex().getName())) {             continue.         }         if (currentState.metaData().hasAlias(indexMetaData.getIndex().getName())) {             logger.warn("ignoring dangled index [{}] on node [{}] due to an existing alias with the same name", indexMetaData.getIndex(), request.fromNode).             continue.         }         importNeeded = true.         IndexMetaData upgradedIndexMetaData.         try {             // The dangled index might be from an older version, we need to make sure it's compatible             // with the current version and upgrade it if needed.             upgradedIndexMetaData = metaDataIndexUpgradeService.upgradeIndexMetaData(indexMetaData, minIndexCompatibilityVersion).         } catch (Exception ex) {             // upgrade failed - adding index as closed             logger.warn(() -> new ParameterizedMessage("found dangled index [{}] on node [{}]. This index cannot be " + "upgraded to the latest version, adding as closed", indexMetaData.getIndex(), request.fromNode), ex).             upgradedIndexMetaData = IndexMetaData.builder(indexMetaData).state(IndexMetaData.State.CLOSE).version(indexMetaData.getVersion() + 1).build().         }         metaData.put(upgradedIndexMetaData, false).         blocks.addBlocks(upgradedIndexMetaData).         if (upgradedIndexMetaData.getState() == IndexMetaData.State.OPEN) {             routingTableBuilder.addAsFromDangling(upgradedIndexMetaData).         }         sb.append("[").append(upgradedIndexMetaData.getIndex()).append("/").append(upgradedIndexMetaData.getState()).append("]").     }     if (!importNeeded) {         return currentState.     }     logger.info("auto importing dangled indices {} from [{}]", sb.toString(), request.fromNode).     RoutingTable routingTable = routingTableBuilder.build().     ClusterState updatedState = ClusterState.builder(currentState).metaData(metaData).blocks(blocks).routingTable(routingTable).build().     // now, reroute     return allocationService.reroute(ClusterState.builder(updatedState).routingTable(routingTable).build(), "dangling indices allocated"). }
false;public;2;10;;@Override public void onFailure(String source, Exception e) {     logger.error(() -> new ParameterizedMessage("unexpected failure during [{}]", source), e).     try {         channel.sendResponse(e).     } catch (Exception inner) {         inner.addSuppressed(e).         logger.warn("failed send response for allocating dangled", inner).     } }
false;public;3;8;;@Override public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {     try {         channel.sendResponse(new AllocateDangledResponse(true)).     } catch (IOException e) {         logger.warn("failed send response for allocating dangled", e).     } }
false;public;3;93;;@Override public void messageReceived(final AllocateDangledRequest request, final TransportChannel channel, Task task) throws Exception {     String[] indexNames = new String[request.indices.length].     for (int i = 0. i < request.indices.length. i++) {         indexNames[i] = request.indices[i].getIndex().getName().     }     clusterService.submitStateUpdateTask("allocation dangled indices " + Arrays.toString(indexNames), new ClusterStateUpdateTask() {          @Override         public ClusterState execute(ClusterState currentState) {             if (currentState.blocks().disableStatePersistence()) {                 return currentState.             }             MetaData.Builder metaData = MetaData.builder(currentState.metaData()).             ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(currentState.blocks()).             RoutingTable.Builder routingTableBuilder = RoutingTable.builder(currentState.routingTable()).             final Version minIndexCompatibilityVersion = currentState.getNodes().getMaxNodeVersion().minimumIndexCompatibilityVersion().             boolean importNeeded = false.             StringBuilder sb = new StringBuilder().             for (IndexMetaData indexMetaData : request.indices) {                 if (indexMetaData.getCreationVersion().before(minIndexCompatibilityVersion)) {                     logger.warn("ignoring dangled index [{}] on node [{}]" + " since it's created version [{}] is not supported by at least one node in the cluster minVersion [{}]", indexMetaData.getIndex(), request.fromNode, indexMetaData.getCreationVersion(), minIndexCompatibilityVersion).                     continue.                 }                 if (currentState.metaData().hasIndex(indexMetaData.getIndex().getName())) {                     continue.                 }                 if (currentState.metaData().hasAlias(indexMetaData.getIndex().getName())) {                     logger.warn("ignoring dangled index [{}] on node [{}] due to an existing alias with the same name", indexMetaData.getIndex(), request.fromNode).                     continue.                 }                 importNeeded = true.                 IndexMetaData upgradedIndexMetaData.                 try {                     // The dangled index might be from an older version, we need to make sure it's compatible                     // with the current version and upgrade it if needed.                     upgradedIndexMetaData = metaDataIndexUpgradeService.upgradeIndexMetaData(indexMetaData, minIndexCompatibilityVersion).                 } catch (Exception ex) {                     // upgrade failed - adding index as closed                     logger.warn(() -> new ParameterizedMessage("found dangled index [{}] on node [{}]. This index cannot be " + "upgraded to the latest version, adding as closed", indexMetaData.getIndex(), request.fromNode), ex).                     upgradedIndexMetaData = IndexMetaData.builder(indexMetaData).state(IndexMetaData.State.CLOSE).version(indexMetaData.getVersion() + 1).build().                 }                 metaData.put(upgradedIndexMetaData, false).                 blocks.addBlocks(upgradedIndexMetaData).                 if (upgradedIndexMetaData.getState() == IndexMetaData.State.OPEN) {                     routingTableBuilder.addAsFromDangling(upgradedIndexMetaData).                 }                 sb.append("[").append(upgradedIndexMetaData.getIndex()).append("/").append(upgradedIndexMetaData.getState()).append("]").             }             if (!importNeeded) {                 return currentState.             }             logger.info("auto importing dangled indices {} from [{}]", sb.toString(), request.fromNode).             RoutingTable routingTable = routingTableBuilder.build().             ClusterState updatedState = ClusterState.builder(currentState).metaData(metaData).blocks(blocks).routingTable(routingTable).build().             // now, reroute             return allocationService.reroute(ClusterState.builder(updatedState).routingTable(routingTable).build(), "dangling indices allocated").         }          @Override         public void onFailure(String source, Exception e) {             logger.error(() -> new ParameterizedMessage("unexpected failure during [{}]", source), e).             try {                 channel.sendResponse(e).             } catch (Exception inner) {                 inner.addSuppressed(e).                 logger.warn("failed send response for allocating dangled", inner).             }         }          @Override         public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {             try {                 channel.sendResponse(new AllocateDangledResponse(true)).             } catch (IOException e) {                 logger.warn("failed send response for allocating dangled", e).             }         }     }). }
false;public;1;9;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     fromNode = new DiscoveryNode(in).     indices = new IndexMetaData[in.readVInt()].     for (int i = 0. i < indices.length. i++) {         indices[i] = IndexMetaData.readFrom(in).     } }
false;public;1;9;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     fromNode.writeTo(out).     out.writeVInt(indices.length).     for (IndexMetaData indexMetaData : indices) {         indexMetaData.writeTo(out).     } }
false;public;0;3;;public boolean ack() {     return ack. }
false;public;1;5;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     ack = in.readBoolean(). }
false;public;1;5;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeBoolean(ack). }
