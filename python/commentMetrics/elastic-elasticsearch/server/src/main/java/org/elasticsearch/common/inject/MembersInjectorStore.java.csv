commented;modifiers;parameterAmount;loc;comment;code
false;protected;2;5;;@Override protected MembersInjectorImpl<?> create(TypeLiteral<?> type, Errors errors) throws ErrorsException {     return createWithListeners(type, errors). }
true;public;0;3;/**  * Returns true if any type listeners are installed. Other code may take shortcuts when there  * aren't any type listeners.  */ ;/**  * Returns true if any type listeners are installed. Other code may take shortcuts when there  * aren't any type listeners.  */ public boolean hasTypeListeners() {     return !typeListenerBindings.isEmpty(). }
true;public;2;4;/**  * Returns a new complete members injector with injection listeners registered.  */ ;/**  * Returns a new complete members injector with injection listeners registered.  */ // the MembersInjector type always agrees with the passed type @SuppressWarnings("unchecked") public <T> MembersInjectorImpl<T> get(TypeLiteral<T> key, Errors errors) throws ErrorsException {     return (MembersInjectorImpl<T>) cache.get(key, errors). }
true;private;2;29;/**  * Creates a new members injector and attaches both injection listeners and method aspects.  */ ;/**  * Creates a new members injector and attaches both injection listeners and method aspects.  */ private <T> MembersInjectorImpl<T> createWithListeners(TypeLiteral<T> type, Errors errors) throws ErrorsException {     int numErrorsBefore = errors.size().     Set<InjectionPoint> injectionPoints.     try {         injectionPoints = InjectionPoint.forInstanceMethodsAndFields(type).     } catch (ConfigurationException e) {         errors.merge(e.getErrorMessages()).         injectionPoints = e.getPartialValue().     }     List<SingleMemberInjector> injectors = getInjectors(injectionPoints, errors).     errors.throwIfNewErrors(numErrorsBefore).     EncounterImpl<T> encounter = new EncounterImpl<>(errors, injector.lookups).     for (TypeListenerBinding typeListener : typeListenerBindings) {         if (typeListener.getTypeMatcher().matches(type)) {             try {                 typeListener.getListener().hear(type, encounter).             } catch (RuntimeException e) {                 errors.errorNotifyingTypeListener(typeListener, type, e).             }         }     }     encounter.invalidate().     errors.throwIfNewErrors(numErrorsBefore).     return new MembersInjectorImpl<>(injector, type, encounter, injectors). }
true;;2;18;/**  * Returns the injectors for the specified injection points.  */ ;/**  * Returns the injectors for the specified injection points.  */ List<SingleMemberInjector> getInjectors(Set<InjectionPoint> injectionPoints, Errors errors) {     List<SingleMemberInjector> injectors = new ArrayList<>().     for (InjectionPoint injectionPoint : injectionPoints) {         try {             Errors errorsForMember = injectionPoint.isOptional() ? new Errors(injectionPoint) : errors.withSource(injectionPoint).             SingleMemberInjector injector = injectionPoint.getMember() instanceof Field ? new SingleFieldInjector(this.injector, injectionPoint, errorsForMember) : new SingleMethodInjector(this.injector, injectionPoint, errorsForMember).             injectors.add(injector).         } catch (ErrorsException ignoredForNow) {         // ignored for now         }     }     return Collections.unmodifiableList(injectors). }
