commented;modifiers;parameterAmount;loc;comment;code
false;public;4;5;;@Override public PointBuilder getBuilder(CoordinateNode coordinates, DistanceUnit.Distance radius, Orientation orientation, boolean coerce) {     return new PointBuilder().coordinate(validate(coordinates, coerce).coordinate). }
false;;2;10;;@Override CoordinateNode validate(CoordinateNode coordinates, boolean coerce) {     if (coordinates.isEmpty()) {         throw new ElasticsearchParseException("invalid number of points (0) provided when expecting a single coordinate ([lat, lng])").     } else if (coordinates.children != null) {         throw new ElasticsearchParseException("multipoint data provided when single point data expected.").     }     return coordinates. }
false;public;4;10;;@Override public MultiPointBuilder getBuilder(CoordinateNode coordinates, DistanceUnit.Distance radius, Orientation orientation, boolean coerce) {     validate(coordinates, coerce).     CoordinatesBuilder coordinatesBuilder = new CoordinatesBuilder().     for (CoordinateNode node : coordinates.children) {         coordinatesBuilder.coordinate(node.coordinate).     }     return new MultiPointBuilder(coordinatesBuilder.build()). }
false;;2;16;;@Override CoordinateNode validate(CoordinateNode coordinates, boolean coerce) {     if (coordinates.children == null || coordinates.children.isEmpty()) {         if (coordinates.coordinate != null) {             throw new ElasticsearchParseException("single coordinate found when expecting an array of " + "coordinates. change type to point or change data to an array of >0 coordinates").         }         throw new ElasticsearchParseException("no data provided for multipoint object when expecting " + ">0 points (e.g., [[lat, lng]] or [[lat, lng], ...])").     } else {         for (CoordinateNode point : coordinates.children) {             POINT.validate(point, coerce).         }     }     return coordinates. }
false;public;4;10;;@Override public LineStringBuilder getBuilder(CoordinateNode coordinates, DistanceUnit.Distance radius, Orientation orientation, boolean coerce) {     validate(coordinates, coerce).     CoordinatesBuilder line = new CoordinatesBuilder().     for (CoordinateNode node : coordinates.children) {         line.coordinate(node.coordinate).     }     return new LineStringBuilder(line). }
false;;2;8;;@Override CoordinateNode validate(CoordinateNode coordinates, boolean coerce) {     if (coordinates.children.size() < 2) {         throw new ElasticsearchParseException("invalid number of points in LineString (found [{}] - must be >= 2)", coordinates.children.size()).     }     return coordinates. }
false;public;4;10;;@Override public MultiLineStringBuilder getBuilder(CoordinateNode coordinates, DistanceUnit.Distance radius, Orientation orientation, boolean coerce) {     validate(coordinates, coerce).     MultiLineStringBuilder multiline = new MultiLineStringBuilder().     for (CoordinateNode node : coordinates.children) {         multiline.linestring(LineStringBuilder.class.cast(LINESTRING.getBuilder(node, radius, orientation, coerce))).     }     return multiline. }
false;;2;8;;@Override CoordinateNode validate(CoordinateNode coordinates, boolean coerce) {     if (coordinates.children.size() < 1) {         throw new ElasticsearchParseException("invalid number of lines in MultiLineString (found [{}] - must be >= 1)", coordinates.children.size()).     }     return coordinates. }
false;public;4;16;;@Override public PolygonBuilder getBuilder(CoordinateNode coordinates, DistanceUnit.Distance radius, Orientation orientation, boolean coerce) {     validate(coordinates, coerce).     // build shell     LineStringBuilder shell = LineStringBuilder.class.cast(LINESTRING.getBuilder(coordinates.children.get(0), radius, orientation, coerce)).     // build polygon with shell and holes     PolygonBuilder polygon = new PolygonBuilder(shell, orientation).     for (int i = 1. i < coordinates.children.size(). ++i) {         CoordinateNode child = coordinates.children.get(i).         LineStringBuilder hole = LineStringBuilder.class.cast(LINESTRING.getBuilder(child, radius, orientation, coerce)).         polygon.hole(hole).     }     return polygon. }
false;;2;23;;void validateLinearRing(CoordinateNode coordinates, boolean coerce) {     if (coordinates.children == null || coordinates.children.isEmpty()) {         String error = "Invalid LinearRing found.".         error += (coordinates.coordinate == null) ? " No coordinate array provided" : " Found a single coordinate when expecting a coordinate array".         throw new ElasticsearchParseException(error).     }     int numValidPts = coerce ? 3 : 4.     if (coordinates.children.size() < numValidPts) {         throw new ElasticsearchParseException("invalid number of points in LinearRing (found [{}] - must be >= [{}])", coordinates.children.size(), numValidPts).     }     // close linear ring iff coerce is set and ring is open, otherwise throw parse exception     if (!coordinates.children.get(0).coordinate.equals(coordinates.children.get(coordinates.children.size() - 1).coordinate)) {         if (coerce == true) {             coordinates.children.add(coordinates.children.get(0)).         } else {             throw new ElasticsearchParseException("invalid LinearRing found (coordinates are not closed)").         }     } }
false;;2;18;;@Override CoordinateNode validate(CoordinateNode coordinates, boolean coerce) {     /**      * Per GeoJSON spec (http://geojson.org/geojson-spec.html#linestring)      * A LinearRing is closed LineString with 4 or more positions. The first and last positions      * are equivalent (they represent equivalent points). Though a LinearRing is not explicitly      * represented as a GeoJSON geometry type, it is referred to in the Polygon geometry type definition.      */     if (coordinates.children == null || coordinates.children.isEmpty()) {         throw new ElasticsearchParseException("invalid LinearRing provided for type polygon. Linear ring must be an array of coordinates").     }     for (CoordinateNode ring : coordinates.children) {         validateLinearRing(ring, coerce).     }     return coordinates. }
false;public;4;10;;@Override public MultiPolygonBuilder getBuilder(CoordinateNode coordinates, DistanceUnit.Distance radius, Orientation orientation, boolean coerce) {     validate(coordinates, coerce).     MultiPolygonBuilder polygons = new MultiPolygonBuilder(orientation).     for (CoordinateNode node : coordinates.children) {         polygons.polygon(PolygonBuilder.class.cast(POLYGON.getBuilder(node, radius, orientation, coerce))).     }     return polygons. }
false;;2;5;;@Override CoordinateNode validate(CoordinateNode coordinates, boolean coerce) {     // noop. todo validate at least 1 polygon to ensure valid multipolygon     return coordinates. }
false;public;4;9;;@Override public EnvelopeBuilder getBuilder(CoordinateNode coordinates, DistanceUnit.Distance radius, Orientation orientation, boolean coerce) {     validate(coordinates, coerce).     // verify coordinate bounds, correct if necessary     Coordinate uL = coordinates.children.get(0).coordinate.     Coordinate lR = coordinates.children.get(1).coordinate.     return new EnvelopeBuilder(uL, lR). }
false;;2;10;;@Override CoordinateNode validate(CoordinateNode coordinates, boolean coerce) {     // validate the coordinate array for envelope type     if (coordinates.children.size() != 2) {         throw new ElasticsearchParseException("invalid number of points [{}] provided for geo_shape [{}] when expecting an array of 2 coordinates", coordinates.children.size(), GeoShapeType.ENVELOPE.shapename).     }     return coordinates. }
false;public;0;4;;@Override public String wktName() {     return BBOX. }
false;public;4;6;;@Override public CircleBuilder getBuilder(CoordinateNode coordinates, DistanceUnit.Distance radius, Orientation orientation, boolean coerce) {     return new CircleBuilder().center(coordinates.coordinate).radius(radius). }
false;;2;5;;@Override CoordinateNode validate(CoordinateNode coordinates, boolean coerce) {     // noop     return coordinates. }
false;public;4;6;;@Override public ShapeBuilder<?, ?, ?> getBuilder(CoordinateNode coordinates, DistanceUnit.Distance radius, Orientation orientation, boolean coerce) {     // noop, handled in parser     return null. }
false;;2;5;;@Override CoordinateNode validate(CoordinateNode coordinates, boolean coerce) {     // noop     return null. }
false;public;0;3;;public String shapeName() {     return shapename. }
false;public,static;1;7;;public static GeoShapeType forName(String geoshapename) {     String typename = geoshapename.toLowerCase(Locale.ROOT).     if (shapeTypeMap.containsKey(typename)) {         return shapeTypeMap.get(typename).     }     throw new IllegalArgumentException("unknown geo_shape [" + geoshapename + "]"). }
false;public,abstract;4;2;;public abstract ShapeBuilder<?, ?, ?> getBuilder(CoordinateNode coordinates, DistanceUnit.Distance radius, ShapeBuilder.Orientation orientation, boolean coerce).
false;abstract;2;1;;abstract CoordinateNode validate(CoordinateNode coordinates, boolean coerce).
true;public;0;3;/**  * wkt shape name  */ ;/**  * wkt shape name  */ public String wktName() {     return this.shapename. }
false;public,static;0;13;;public static List<Entry> getShapeWriteables() {     List<Entry> namedWriteables = new ArrayList<>().     namedWriteables.add(new Entry(ShapeBuilder.class, PointBuilder.TYPE.shapeName(), PointBuilder::new)).     namedWriteables.add(new Entry(ShapeBuilder.class, CircleBuilder.TYPE.shapeName(), CircleBuilder::new)).     namedWriteables.add(new Entry(ShapeBuilder.class, EnvelopeBuilder.TYPE.shapeName(), EnvelopeBuilder::new)).     namedWriteables.add(new Entry(ShapeBuilder.class, MultiPointBuilder.TYPE.shapeName(), MultiPointBuilder::new)).     namedWriteables.add(new Entry(ShapeBuilder.class, LineStringBuilder.TYPE.shapeName(), LineStringBuilder::new)).     namedWriteables.add(new Entry(ShapeBuilder.class, MultiLineStringBuilder.TYPE.shapeName(), MultiLineStringBuilder::new)).     namedWriteables.add(new Entry(ShapeBuilder.class, PolygonBuilder.TYPE.shapeName(), PolygonBuilder::new)).     namedWriteables.add(new Entry(ShapeBuilder.class, MultiPolygonBuilder.TYPE.shapeName(), MultiPolygonBuilder::new)).     namedWriteables.add(new Entry(ShapeBuilder.class, GeometryCollectionBuilder.TYPE.shapeName(), GeometryCollectionBuilder::new)).     return namedWriteables. }
false;public;0;4;;@Override public String toString() {     return this.shapename. }
