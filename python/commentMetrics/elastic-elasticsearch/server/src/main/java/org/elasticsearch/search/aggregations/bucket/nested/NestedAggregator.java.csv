commented;modifiers;parameterAmount;loc;comment;code
false;public;2;18;;@Override public void collect(int parentDoc, long bucket) throws IOException {     // doc), so we can skip:     if (parentDoc == 0 || parentDocs == null || childDocs == null) {         return.     }     final int prevParentDoc = parentDocs.prevSetBit(parentDoc - 1).     int childDocId = childDocs.docID().     if (childDocId <= prevParentDoc) {         childDocId = childDocs.advance(prevParentDoc + 1).     }     for (. childDocId < parentDoc. childDocId = childDocs.nextDoc()) {         collectBucket(sub, childDocId, bucket).     } }
false;public;2;35;;@Override public LeafBucketCollector getLeafCollector(final LeafReaderContext ctx, final LeafBucketCollector sub) throws IOException {     IndexReaderContext topLevelContext = ReaderUtil.getTopLevelContext(ctx).     IndexSearcher searcher = new IndexSearcher(topLevelContext).     searcher.setQueryCache(null).     Weight weight = searcher.createWeight(searcher.rewrite(childFilter), ScoreMode.COMPLETE_NO_SCORES, 1f).     Scorer childDocsScorer = weight.scorer(ctx).     final BitSet parentDocs = parentFilter.getBitSet(ctx).     final DocIdSetIterator childDocs = childDocsScorer != null ? childDocsScorer.iterator() : null.     if (collectsFromSingleBucket) {         return new LeafBucketCollectorBase(sub, null) {              @Override             public void collect(int parentDoc, long bucket) throws IOException {                 // doc), so we can skip:                 if (parentDoc == 0 || parentDocs == null || childDocs == null) {                     return.                 }                 final int prevParentDoc = parentDocs.prevSetBit(parentDoc - 1).                 int childDocId = childDocs.docID().                 if (childDocId <= prevParentDoc) {                     childDocId = childDocs.advance(prevParentDoc + 1).                 }                 for (. childDocId < parentDoc. childDocId = childDocs.nextDoc()) {                     collectBucket(sub, childDocId, bucket).                 }             }         }.     } else {         return bufferingNestedLeafBucketCollector = new BufferingNestedLeafBucketCollector(sub, parentDocs, childDocs).     } }
false;protected;0;4;;@Override protected void preGetSubLeafCollectors() throws IOException {     processBufferedDocs(). }
false;protected;0;4;;@Override protected void doPostCollection() throws IOException {     processBufferedDocs(). }
false;private;0;5;;private void processBufferedDocs() throws IOException {     if (bufferingNestedLeafBucketCollector != null) {         bufferingNestedLeafBucketCollector.processBufferedChildBuckets().     } }
false;public;1;5;;@Override public InternalAggregation buildAggregation(long owningBucketOrdinal) throws IOException {     return new InternalNested(name, bucketDocCount(owningBucketOrdinal), bucketAggregations(owningBucketOrdinal), pipelineAggregators(), metaData()). }
false;public;0;4;;@Override public InternalAggregation buildEmptyAggregation() {     return new InternalNested(name, 0, buildEmptySubAggregations(), pipelineAggregators(), metaData()). }
false;public;1;5;;@Override public void setScorer(Scorable scorer) throws IOException {     this.scorer = scorer.     super.setScorer(cachedScorer). }
false;public;2;19;;@Override public void collect(int parentDoc, long bucket) throws IOException {     // doc), so we can skip:     if (parentDoc == 0 || parentDocs == null || childDocs == null) {         return.     }     if (currentParentDoc != parentDoc) {         processBufferedChildBuckets().         if (scoreMode().needsScores()) {             // cache the score of the current parent             cachedScorer.score = scorer.score().         }         currentParentDoc = parentDoc.     }     bucketBuffer.add(bucket). }
false;;0;22;;void processBufferedChildBuckets() throws IOException {     if (bucketBuffer.isEmpty()) {         return.     }     final int prevParentDoc = parentDocs.prevSetBit(currentParentDoc - 1).     int childDocId = childDocs.docID().     if (childDocId <= prevParentDoc) {         childDocId = childDocs.advance(prevParentDoc + 1).     }     for (. childDocId < currentParentDoc. childDocId = childDocs.nextDoc()) {         cachedScorer.doc = childDocId.         final long[] buffer = bucketBuffer.buffer.         final int size = bucketBuffer.size().         for (int i = 0. i < size. i++) {             collectBucket(sub, childDocId, buffer[i]).         }     }     bucketBuffer.clear(). }
false;public,final;0;2;;@Override public final float score() {     return score. }
false;public;0;4;;@Override public int docID() {     return doc. }
