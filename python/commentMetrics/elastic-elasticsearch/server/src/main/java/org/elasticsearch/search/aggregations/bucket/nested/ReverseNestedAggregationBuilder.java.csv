commented;modifiers;parameterAmount;loc;comment;code
false;protected;2;4;;@Override protected AggregationBuilder shallowCopy(Builder factoriesBuilder, Map<String, Object> metaData) {     return new ReverseNestedAggregationBuilder(this, factoriesBuilder, metaData). }
false;protected;1;4;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     out.writeOptionalString(path). }
true;public;1;7;/**  * Set the path to use for this nested aggregation. The path must match  * the path to a nested object in the mappings. If it is not specified  * then this aggregation will go back to the root document.  */ ;/**  * Set the path to use for this nested aggregation. The path must match  * the path to a nested object in the mappings. If it is not specified  * then this aggregation will go back to the root document.  */ public ReverseNestedAggregationBuilder path(String path) {     if (path == null) {         throw new IllegalArgumentException("[path] must not be null: [" + name + "]").     }     this.path = path.     return this. }
true;public;0;3;/**  * Get the path to use for this nested aggregation.  */ ;/**  * Get the path to use for this nested aggregation.  */ public String path() {     return path. }
false;protected;3;28;;@Override protected AggregatorFactory<?> doBuild(SearchContext context, AggregatorFactory<?> parent, Builder subFactoriesBuilder) throws IOException {     if (findNestedAggregatorFactory(parent) == null) {         throw new SearchParseException(context, "Reverse nested aggregation [" + name + "] can only be used inside a [nested] aggregation", null).     }     ObjectMapper parentObjectMapper = null.     if (path != null) {         parentObjectMapper = context.getObjectMapper(path).         if (parentObjectMapper == null) {             return new ReverseNestedAggregatorFactory(name, true, null, context, parent, subFactoriesBuilder, metaData).         }         if (parentObjectMapper.nested().isNested() == false) {             throw new AggregationExecutionException("[reverse_nested] nested path [" + path + "] is not nested").         }     }     NestedScope nestedScope = context.getQueryShardContext().nestedScope().     try {         nestedScope.nextLevel(parentObjectMapper).         return new ReverseNestedAggregatorFactory(name, false, parentObjectMapper, context, parent, subFactoriesBuilder, metaData).     } finally {         nestedScope.previousLevel().     } }
false;private,static;1;9;;private static NestedAggregatorFactory findNestedAggregatorFactory(AggregatorFactory<?> parent) {     if (parent == null) {         return null.     } else if (parent instanceof NestedAggregatorFactory) {         return (NestedAggregatorFactory) parent.     } else {         return findNestedAggregatorFactory(parent.getParent()).     } }
false;protected;2;9;;@Override protected XContentBuilder internalXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     if (path != null) {         builder.field(ReverseNestedAggregator.PATH_FIELD.getPreferredName(), path).     }     builder.endObject().     return builder. }
false;public,static;2;27;;public static ReverseNestedAggregationBuilder parse(String aggregationName, XContentParser parser) throws IOException {     String path = null.     XContentParser.Token token.     String currentFieldName = null.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token == XContentParser.Token.VALUE_STRING) {             if ("path".equals(currentFieldName)) {                 path = parser.text().             } else {                 throw new ParsingException(parser.getTokenLocation(), "Unknown key for a " + token + " in [" + aggregationName + "]: [" + currentFieldName + "].").             }         } else {             throw new ParsingException(parser.getTokenLocation(), "Unexpected token " + token + " in [" + aggregationName + "].").         }     }     ReverseNestedAggregationBuilder factory = new ReverseNestedAggregationBuilder(aggregationName).     if (path != null) {         factory.path(path).     }     return factory. }
false;protected;0;4;;@Override protected int doHashCode() {     return Objects.hash(path). }
false;protected;1;5;;@Override protected boolean doEquals(Object obj) {     ReverseNestedAggregationBuilder other = (ReverseNestedAggregationBuilder) obj.     return Objects.equals(path, other.path). }
false;public;0;4;;@Override public String getType() {     return NAME. }
