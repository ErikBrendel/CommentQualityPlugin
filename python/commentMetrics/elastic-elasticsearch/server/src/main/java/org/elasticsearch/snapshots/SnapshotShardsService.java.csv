# id;timestamp;commentText;codeText;commentWords;codeWords
SnapshotShardsService -> private void innerUpdateSnapshotState(final UpdateIndexShardSnapshotStatusRequest request, ActionListener<UpdateIndexShardSnapshotStatusResponse> listener);1524684173;Updates the shard status on master node__@param request update shard status request;private void innerUpdateSnapshotState(final UpdateIndexShardSnapshotStatusRequest request, ActionListener<UpdateIndexShardSnapshotStatusResponse> listener) {_        logger.trace("received updated snapshot restore state [{}]", request)__        clusterService.submitStateUpdateTask(_            "update snapshot state",_            request,_            ClusterStateTaskConfig.build(Priority.NORMAL),_            snapshotStateExecutor,_            new ClusterStateTaskListener() {_                @Override_                public void onFailure(String source, Exception e) {_                    listener.onFailure(e)__                }__                @Override_                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                    listener.onResponse(new UpdateIndexShardSnapshotStatusResponse())__                }_            })__    };updates,the,shard,status,on,master,node,param,request,update,shard,status,request;private,void,inner,update,snapshot,state,final,update,index,shard,snapshot,status,request,request,action,listener,update,index,shard,snapshot,status,response,listener,logger,trace,received,updated,snapshot,restore,state,request,cluster,service,submit,state,update,task,update,snapshot,state,request,cluster,state,task,config,build,priority,normal,snapshot,state,executor,new,cluster,state,task,listener,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,new,update,index,shard,snapshot,status,response
SnapshotShardsService -> private void innerUpdateSnapshotState(final UpdateIndexShardSnapshotStatusRequest request, ActionListener<UpdateIndexShardSnapshotStatusResponse> listener);1536828374;Updates the shard status on master node__@param request update shard status request;private void innerUpdateSnapshotState(final UpdateIndexShardSnapshotStatusRequest request, ActionListener<UpdateIndexShardSnapshotStatusResponse> listener) {_        logger.trace("received updated snapshot restore state [{}]", request)__        clusterService.submitStateUpdateTask(_            "update snapshot state",_            request,_            ClusterStateTaskConfig.build(Priority.NORMAL),_            snapshotStateExecutor,_            new ClusterStateTaskListener() {_                @Override_                public void onFailure(String source, Exception e) {_                    listener.onFailure(e)__                }__                @Override_                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                    listener.onResponse(new UpdateIndexShardSnapshotStatusResponse())__                }_            })__    };updates,the,shard,status,on,master,node,param,request,update,shard,status,request;private,void,inner,update,snapshot,state,final,update,index,shard,snapshot,status,request,request,action,listener,update,index,shard,snapshot,status,response,listener,logger,trace,received,updated,snapshot,restore,state,request,cluster,service,submit,state,update,task,update,snapshot,state,request,cluster,state,task,config,build,priority,normal,snapshot,state,executor,new,cluster,state,task,listener,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,new,update,index,shard,snapshot,status,response
SnapshotShardsService -> private void innerUpdateSnapshotState(final UpdateIndexShardSnapshotStatusRequest request, ActionListener<UpdateIndexShardSnapshotStatusResponse> listener);1541419698;Updates the shard status on master node__@param request update shard status request;private void innerUpdateSnapshotState(final UpdateIndexShardSnapshotStatusRequest request, ActionListener<UpdateIndexShardSnapshotStatusResponse> listener) {_        logger.trace("received updated snapshot restore state [{}]", request)__        clusterService.submitStateUpdateTask(_            "update snapshot state",_            request,_            ClusterStateTaskConfig.build(Priority.NORMAL),_            snapshotStateExecutor,_            new ClusterStateTaskListener() {_                @Override_                public void onFailure(String source, Exception e) {_                    listener.onFailure(e)__                }__                @Override_                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                    listener.onResponse(new UpdateIndexShardSnapshotStatusResponse())__                }_            })__    };updates,the,shard,status,on,master,node,param,request,update,shard,status,request;private,void,inner,update,snapshot,state,final,update,index,shard,snapshot,status,request,request,action,listener,update,index,shard,snapshot,status,response,listener,logger,trace,received,updated,snapshot,restore,state,request,cluster,service,submit,state,update,task,update,snapshot,state,request,cluster,state,task,config,build,priority,normal,snapshot,state,executor,new,cluster,state,task,listener,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,new,update,index,shard,snapshot,status,response
SnapshotShardsService -> private void innerUpdateSnapshotState(final UpdateIndexShardSnapshotStatusRequest request, ActionListener<UpdateIndexShardSnapshotStatusResponse> listener);1542646292;Updates the shard status on master node__@param request update shard status request;private void innerUpdateSnapshotState(final UpdateIndexShardSnapshotStatusRequest request, ActionListener<UpdateIndexShardSnapshotStatusResponse> listener) {_        logger.trace("received updated snapshot restore state [{}]", request)__        clusterService.submitStateUpdateTask(_            "update snapshot state",_            request,_            ClusterStateTaskConfig.build(Priority.NORMAL),_            snapshotStateExecutor,_            new ClusterStateTaskListener() {_                @Override_                public void onFailure(String source, Exception e) {_                    listener.onFailure(e)__                }__                @Override_                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                    listener.onResponse(new UpdateIndexShardSnapshotStatusResponse())__                }_            })__    };updates,the,shard,status,on,master,node,param,request,update,shard,status,request;private,void,inner,update,snapshot,state,final,update,index,shard,snapshot,status,request,request,action,listener,update,index,shard,snapshot,status,response,listener,logger,trace,received,updated,snapshot,restore,state,request,cluster,service,submit,state,update,task,update,snapshot,state,request,cluster,state,task,config,build,priority,normal,snapshot,state,executor,new,cluster,state,task,listener,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,new,update,index,shard,snapshot,status,response
SnapshotShardsService -> private void innerUpdateSnapshotState(final UpdateIndexShardSnapshotStatusRequest request, ActionListener<UpdateIndexShardSnapshotStatusResponse> listener);1542804617;Updates the shard status on master node__@param request update shard status request;private void innerUpdateSnapshotState(final UpdateIndexShardSnapshotStatusRequest request, ActionListener<UpdateIndexShardSnapshotStatusResponse> listener) {_        logger.trace("received updated snapshot restore state [{}]", request)__        clusterService.submitStateUpdateTask(_            "update snapshot state",_            request,_            ClusterStateTaskConfig.build(Priority.NORMAL),_            snapshotStateExecutor,_            new ClusterStateTaskListener() {_                @Override_                public void onFailure(String source, Exception e) {_                    listener.onFailure(e)__                }__                @Override_                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                    listener.onResponse(new UpdateIndexShardSnapshotStatusResponse())__                }_            })__    };updates,the,shard,status,on,master,node,param,request,update,shard,status,request;private,void,inner,update,snapshot,state,final,update,index,shard,snapshot,status,request,request,action,listener,update,index,shard,snapshot,status,response,listener,logger,trace,received,updated,snapshot,restore,state,request,cluster,service,submit,state,update,task,update,snapshot,state,request,cluster,state,task,config,build,priority,normal,snapshot,state,executor,new,cluster,state,task,listener,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,new,update,index,shard,snapshot,status,response
SnapshotShardsService -> private void innerUpdateSnapshotState(final UpdateIndexShardSnapshotStatusRequest request, ActionListener<UpdateIndexShardSnapshotStatusResponse> listener);1543851569;Updates the shard status on master node__@param request update shard status request;private void innerUpdateSnapshotState(final UpdateIndexShardSnapshotStatusRequest request, ActionListener<UpdateIndexShardSnapshotStatusResponse> listener) {_        logger.trace("received updated snapshot restore state [{}]", request)__        clusterService.submitStateUpdateTask(_            "update snapshot state",_            request,_            ClusterStateTaskConfig.build(Priority.NORMAL),_            snapshotStateExecutor,_            new ClusterStateTaskListener() {_                @Override_                public void onFailure(String source, Exception e) {_                    listener.onFailure(e)__                }__                @Override_                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                    listener.onResponse(new UpdateIndexShardSnapshotStatusResponse())__                }_            })__    };updates,the,shard,status,on,master,node,param,request,update,shard,status,request;private,void,inner,update,snapshot,state,final,update,index,shard,snapshot,status,request,request,action,listener,update,index,shard,snapshot,status,response,listener,logger,trace,received,updated,snapshot,restore,state,request,cluster,service,submit,state,update,task,update,snapshot,state,request,cluster,state,task,config,build,priority,normal,snapshot,state,executor,new,cluster,state,task,listener,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,new,update,index,shard,snapshot,status,response
SnapshotShardsService -> void notifySuccessfulSnapshotShard(final Snapshot snapshot, final ShardId shardId, final String localNodeId);1524684173;Notify the master node that the given shard has been successfully snapshotted *;void notifySuccessfulSnapshotShard(final Snapshot snapshot, final ShardId shardId, final String localNodeId) {_        sendSnapshotShardUpdate(snapshot, shardId, new ShardSnapshotStatus(localNodeId, State.SUCCESS))__    };notify,the,master,node,that,the,given,shard,has,been,successfully,snapshotted;void,notify,successful,snapshot,shard,final,snapshot,snapshot,final,shard,id,shard,id,final,string,local,node,id,send,snapshot,shard,update,snapshot,shard,id,new,shard,snapshot,status,local,node,id,state,success
SnapshotShardsService -> void notifySuccessfulSnapshotShard(final Snapshot snapshot, final ShardId shardId, final String localNodeId);1536828374;Notify the master node that the given shard has been successfully snapshotted *;void notifySuccessfulSnapshotShard(final Snapshot snapshot, final ShardId shardId, final String localNodeId) {_        sendSnapshotShardUpdate(snapshot, shardId, new ShardSnapshotStatus(localNodeId, State.SUCCESS))__    };notify,the,master,node,that,the,given,shard,has,been,successfully,snapshotted;void,notify,successful,snapshot,shard,final,snapshot,snapshot,final,shard,id,shard,id,final,string,local,node,id,send,snapshot,shard,update,snapshot,shard,id,new,shard,snapshot,status,local,node,id,state,success
SnapshotShardsService -> void notifySuccessfulSnapshotShard(final Snapshot snapshot, final ShardId shardId, final String localNodeId);1541419698;Notify the master node that the given shard has been successfully snapshotted *;void notifySuccessfulSnapshotShard(final Snapshot snapshot, final ShardId shardId, final String localNodeId) {_        sendSnapshotShardUpdate(snapshot, shardId, new ShardSnapshotStatus(localNodeId, State.SUCCESS))__    };notify,the,master,node,that,the,given,shard,has,been,successfully,snapshotted;void,notify,successful,snapshot,shard,final,snapshot,snapshot,final,shard,id,shard,id,final,string,local,node,id,send,snapshot,shard,update,snapshot,shard,id,new,shard,snapshot,status,local,node,id,state,success
SnapshotShardsService -> void notifySuccessfulSnapshotShard(final Snapshot snapshot, final ShardId shardId, final String localNodeId);1542646292;Notify the master node that the given shard has been successfully snapshotted *;void notifySuccessfulSnapshotShard(final Snapshot snapshot, final ShardId shardId, final String localNodeId) {_        sendSnapshotShardUpdate(snapshot, shardId, new ShardSnapshotStatus(localNodeId, State.SUCCESS))__    };notify,the,master,node,that,the,given,shard,has,been,successfully,snapshotted;void,notify,successful,snapshot,shard,final,snapshot,snapshot,final,shard,id,shard,id,final,string,local,node,id,send,snapshot,shard,update,snapshot,shard,id,new,shard,snapshot,status,local,node,id,state,success
SnapshotShardsService -> void notifySuccessfulSnapshotShard(final Snapshot snapshot, final ShardId shardId, final String localNodeId);1542804617;Notify the master node that the given shard has been successfully snapshotted *;void notifySuccessfulSnapshotShard(final Snapshot snapshot, final ShardId shardId, final String localNodeId) {_        sendSnapshotShardUpdate(snapshot, shardId, new ShardSnapshotStatus(localNodeId, State.SUCCESS))__    };notify,the,master,node,that,the,given,shard,has,been,successfully,snapshotted;void,notify,successful,snapshot,shard,final,snapshot,snapshot,final,shard,id,shard,id,final,string,local,node,id,send,snapshot,shard,update,snapshot,shard,id,new,shard,snapshot,status,local,node,id,state,success
SnapshotShardsService -> void notifySuccessfulSnapshotShard(final Snapshot snapshot, final ShardId shardId, final String localNodeId);1543851569;Notify the master node that the given shard has been successfully snapshotted *;void notifySuccessfulSnapshotShard(final Snapshot snapshot, final ShardId shardId, final String localNodeId) {_        sendSnapshotShardUpdate(snapshot, shardId, new ShardSnapshotStatus(localNodeId, State.SUCCESS))__    };notify,the,master,node,that,the,given,shard,has,been,successfully,snapshotted;void,notify,successful,snapshot,shard,final,snapshot,snapshot,final,shard,id,shard,id,final,string,local,node,id,send,snapshot,shard,update,snapshot,shard,id,new,shard,snapshot,status,local,node,id,state,success
SnapshotShardsService -> void notifySuccessfulSnapshotShard(final Snapshot snapshot, final ShardId shardId, final String localNodeId);1545215361;Notify the master node that the given shard has been successfully snapshotted *;void notifySuccessfulSnapshotShard(final Snapshot snapshot, final ShardId shardId, final String localNodeId) {_        sendSnapshotShardUpdate(snapshot, shardId, new ShardSnapshotStatus(localNodeId, State.SUCCESS))__    };notify,the,master,node,that,the,given,shard,has,been,successfully,snapshotted;void,notify,successful,snapshot,shard,final,snapshot,snapshot,final,shard,id,shard,id,final,string,local,node,id,send,snapshot,shard,update,snapshot,shard,id,new,shard,snapshot,status,local,node,id,state,success
SnapshotShardsService -> void notifySuccessfulSnapshotShard(final Snapshot snapshot, final ShardId shardId, final String localNodeId);1547023537;Notify the master node that the given shard has been successfully snapshotted *;void notifySuccessfulSnapshotShard(final Snapshot snapshot, final ShardId shardId, final String localNodeId) {_        sendSnapshotShardUpdate(snapshot, shardId, new ShardSnapshotStatus(localNodeId, State.SUCCESS))__    };notify,the,master,node,that,the,given,shard,has,been,successfully,snapshotted;void,notify,successful,snapshot,shard,final,snapshot,snapshot,final,shard,id,shard,id,final,string,local,node,id,send,snapshot,shard,update,snapshot,shard,id,new,shard,snapshot,status,local,node,id,state,success
SnapshotShardsService -> void notifySuccessfulSnapshotShard(final Snapshot snapshot, final ShardId shardId, final String localNodeId);1547625930;Notify the master node that the given shard has been successfully snapshotted *;void notifySuccessfulSnapshotShard(final Snapshot snapshot, final ShardId shardId, final String localNodeId) {_        sendSnapshotShardUpdate(snapshot, shardId, new ShardSnapshotStatus(localNodeId, State.SUCCESS))__    };notify,the,master,node,that,the,given,shard,has,been,successfully,snapshotted;void,notify,successful,snapshot,shard,final,snapshot,snapshot,final,shard,id,shard,id,final,string,local,node,id,send,snapshot,shard,update,snapshot,shard,id,new,shard,snapshot,status,local,node,id,state,success
SnapshotShardsService -> void notifySuccessfulSnapshotShard(final Snapshot snapshot, final ShardId shardId, final String localNodeId);1548996340;Notify the master node that the given shard has been successfully snapshotted *;void notifySuccessfulSnapshotShard(final Snapshot snapshot, final ShardId shardId, final String localNodeId) {_        sendSnapshotShardUpdate(snapshot, shardId, new ShardSnapshotStatus(localNodeId, State.SUCCESS))__    };notify,the,master,node,that,the,given,shard,has,been,successfully,snapshotted;void,notify,successful,snapshot,shard,final,snapshot,snapshot,final,shard,id,shard,id,final,string,local,node,id,send,snapshot,shard,update,snapshot,shard,id,new,shard,snapshot,status,local,node,id,state,success
SnapshotShardsService -> private void notifyFailedSnapshotShard(final Snapshot snapshot, final ShardId shardId, final String failure);1549050374;Notify the master node that the given shard failed to be snapshotted *;private void notifyFailedSnapshotShard(final Snapshot snapshot, final ShardId shardId, final String failure) {_        sendSnapshotShardUpdate(snapshot, shardId, new ShardSnapshotStatus(clusterService.localNode().getId(), State.FAILED, failure))__    };notify,the,master,node,that,the,given,shard,failed,to,be,snapshotted;private,void,notify,failed,snapshot,shard,final,snapshot,snapshot,final,shard,id,shard,id,final,string,failure,send,snapshot,shard,update,snapshot,shard,id,new,shard,snapshot,status,cluster,service,local,node,get,id,state,failed,failure
SnapshotShardsService -> private void notifyFailedSnapshotShard(final Snapshot snapshot, final ShardId shardId, final String failure);1549180095;Notify the master node that the given shard failed to be snapshotted *;private void notifyFailedSnapshotShard(final Snapshot snapshot, final ShardId shardId, final String failure) {_        sendSnapshotShardUpdate(snapshot, shardId, new ShardSnapshotStatus(clusterService.localNode().getId(), State.FAILED, failure))__    };notify,the,master,node,that,the,given,shard,failed,to,be,snapshotted;private,void,notify,failed,snapshot,shard,final,snapshot,snapshot,final,shard,id,shard,id,final,string,failure,send,snapshot,shard,update,snapshot,shard,id,new,shard,snapshot,status,cluster,service,local,node,get,id,state,failed,failure
SnapshotShardsService -> private void notifyFailedSnapshotShard(final Snapshot snapshot, final ShardId shardId, final String failure);1549267599;Notify the master node that the given shard failed to be snapshotted *;private void notifyFailedSnapshotShard(final Snapshot snapshot, final ShardId shardId, final String failure) {_        sendSnapshotShardUpdate(snapshot, shardId, new ShardSnapshotStatus(clusterService.localNode().getId(), State.FAILED, failure))__    };notify,the,master,node,that,the,given,shard,failed,to,be,snapshotted;private,void,notify,failed,snapshot,shard,final,snapshot,snapshot,final,shard,id,shard,id,final,string,failure,send,snapshot,shard,update,snapshot,shard,id,new,shard,snapshot,status,cluster,service,local,node,get,id,state,failed,failure
SnapshotShardsService -> private void notifyFailedSnapshotShard(final Snapshot snapshot, final ShardId shardId, final String failure);1549381458;Notify the master node that the given shard failed to be snapshotted *;private void notifyFailedSnapshotShard(final Snapshot snapshot, final ShardId shardId, final String failure) {_        sendSnapshotShardUpdate(snapshot, shardId, new ShardSnapshotStatus(clusterService.localNode().getId(), State.FAILED, failure))__    };notify,the,master,node,that,the,given,shard,failed,to,be,snapshotted;private,void,notify,failed,snapshot,shard,final,snapshot,snapshot,final,shard,id,shard,id,final,string,failure,send,snapshot,shard,update,snapshot,shard,id,new,shard,snapshot,status,cluster,service,local,node,get,id,state,failed,failure
SnapshotShardsService -> private void snapshot(final IndexShard indexShard, final Snapshot snapshot, final IndexId indexId, final IndexShardSnapshotStatus snapshotStatus);1524684173;Creates shard snapshot__@param snapshot       snapshot_@param snapshotStatus snapshot status;private void snapshot(final IndexShard indexShard, final Snapshot snapshot, final IndexId indexId, final IndexShardSnapshotStatus snapshotStatus) {_        final ShardId shardId = indexShard.shardId()__        if (indexShard.routingEntry().primary() == false) {_            throw new IndexShardSnapshotFailedException(shardId, "snapshot should be performed only on primary")__        }_        if (indexShard.routingEntry().relocating()) {_            _            throw new IndexShardSnapshotFailedException(shardId, "cannot snapshot while relocating")__        }__        final IndexShardState indexShardState = indexShard.state()__        if (indexShardState == IndexShardState.CREATED || indexShardState == IndexShardState.RECOVERING) {_            _            throw new IndexShardSnapshotFailedException(shardId, "shard didn't fully recover yet")__        }__        final Repository repository = snapshotsService.getRepositoriesService().repository(snapshot.getRepository())__        try {_            _            try (Engine.IndexCommitRef snapshotRef = indexShard.acquireLastIndexCommit(true)) {_                repository.snapshotShard(indexShard, snapshot.getSnapshotId(), indexId, snapshotRef.getIndexCommit(), snapshotStatus)__                if (logger.isDebugEnabled()) {_                    final IndexShardSnapshotStatus.Copy lastSnapshotStatus = snapshotStatus.asCopy()__                    logger.debug("snapshot ({}) completed to {} with {}", snapshot, repository, lastSnapshotStatus)__                }_            }_        } catch (SnapshotFailedEngineException | IndexShardSnapshotFailedException e) {_            throw e__        } catch (Exception e) {_            throw new IndexShardSnapshotFailedException(shardId, "Failed to snapshot", e)__        }_    };creates,shard,snapshot,param,snapshot,snapshot,param,snapshot,status,snapshot,status;private,void,snapshot,final,index,shard,index,shard,final,snapshot,snapshot,final,index,id,index,id,final,index,shard,snapshot,status,snapshot,status,final,shard,id,shard,id,index,shard,shard,id,if,index,shard,routing,entry,primary,false,throw,new,index,shard,snapshot,failed,exception,shard,id,snapshot,should,be,performed,only,on,primary,if,index,shard,routing,entry,relocating,throw,new,index,shard,snapshot,failed,exception,shard,id,cannot,snapshot,while,relocating,final,index,shard,state,index,shard,state,index,shard,state,if,index,shard,state,index,shard,state,created,index,shard,state,index,shard,state,recovering,throw,new,index,shard,snapshot,failed,exception,shard,id,shard,didn,t,fully,recover,yet,final,repository,repository,snapshots,service,get,repositories,service,repository,snapshot,get,repository,try,try,engine,index,commit,ref,snapshot,ref,index,shard,acquire,last,index,commit,true,repository,snapshot,shard,index,shard,snapshot,get,snapshot,id,index,id,snapshot,ref,get,index,commit,snapshot,status,if,logger,is,debug,enabled,final,index,shard,snapshot,status,copy,last,snapshot,status,snapshot,status,as,copy,logger,debug,snapshot,completed,to,with,snapshot,repository,last,snapshot,status,catch,snapshot,failed,engine,exception,index,shard,snapshot,failed,exception,e,throw,e,catch,exception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,snapshot,e
SnapshotShardsService -> private void snapshot(final IndexShard indexShard, final Snapshot snapshot, final IndexId indexId, final IndexShardSnapshotStatus snapshotStatus);1536828374;Creates shard snapshot__@param snapshot       snapshot_@param snapshotStatus snapshot status;private void snapshot(final IndexShard indexShard, final Snapshot snapshot, final IndexId indexId, final IndexShardSnapshotStatus snapshotStatus) {_        final ShardId shardId = indexShard.shardId()__        if (indexShard.routingEntry().primary() == false) {_            throw new IndexShardSnapshotFailedException(shardId, "snapshot should be performed only on primary")__        }_        if (indexShard.routingEntry().relocating()) {_            _            throw new IndexShardSnapshotFailedException(shardId, "cannot snapshot while relocating")__        }__        final IndexShardState indexShardState = indexShard.state()__        if (indexShardState == IndexShardState.CREATED || indexShardState == IndexShardState.RECOVERING) {_            _            throw new IndexShardSnapshotFailedException(shardId, "shard didn't fully recover yet")__        }__        final Repository repository = snapshotsService.getRepositoriesService().repository(snapshot.getRepository())__        try {_            _            try (Engine.IndexCommitRef snapshotRef = indexShard.acquireLastIndexCommit(true)) {_                repository.snapshotShard(indexShard, indexShard.store(), snapshot.getSnapshotId(), indexId, snapshotRef.getIndexCommit(),_                    snapshotStatus)__                if (logger.isDebugEnabled()) {_                    final IndexShardSnapshotStatus.Copy lastSnapshotStatus = snapshotStatus.asCopy()__                    logger.debug("snapshot ({}) completed to {} with {}", snapshot, repository, lastSnapshotStatus)__                }_            }_        } catch (SnapshotFailedEngineException | IndexShardSnapshotFailedException e) {_            throw e__        } catch (Exception e) {_            throw new IndexShardSnapshotFailedException(shardId, "Failed to snapshot", e)__        }_    };creates,shard,snapshot,param,snapshot,snapshot,param,snapshot,status,snapshot,status;private,void,snapshot,final,index,shard,index,shard,final,snapshot,snapshot,final,index,id,index,id,final,index,shard,snapshot,status,snapshot,status,final,shard,id,shard,id,index,shard,shard,id,if,index,shard,routing,entry,primary,false,throw,new,index,shard,snapshot,failed,exception,shard,id,snapshot,should,be,performed,only,on,primary,if,index,shard,routing,entry,relocating,throw,new,index,shard,snapshot,failed,exception,shard,id,cannot,snapshot,while,relocating,final,index,shard,state,index,shard,state,index,shard,state,if,index,shard,state,index,shard,state,created,index,shard,state,index,shard,state,recovering,throw,new,index,shard,snapshot,failed,exception,shard,id,shard,didn,t,fully,recover,yet,final,repository,repository,snapshots,service,get,repositories,service,repository,snapshot,get,repository,try,try,engine,index,commit,ref,snapshot,ref,index,shard,acquire,last,index,commit,true,repository,snapshot,shard,index,shard,index,shard,store,snapshot,get,snapshot,id,index,id,snapshot,ref,get,index,commit,snapshot,status,if,logger,is,debug,enabled,final,index,shard,snapshot,status,copy,last,snapshot,status,snapshot,status,as,copy,logger,debug,snapshot,completed,to,with,snapshot,repository,last,snapshot,status,catch,snapshot,failed,engine,exception,index,shard,snapshot,failed,exception,e,throw,e,catch,exception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,snapshot,e
SnapshotShardsService -> private void snapshot(final IndexShard indexShard, final Snapshot snapshot, final IndexId indexId, final IndexShardSnapshotStatus snapshotStatus);1541419698;Creates shard snapshot__@param snapshot       snapshot_@param snapshotStatus snapshot status;private void snapshot(final IndexShard indexShard, final Snapshot snapshot, final IndexId indexId, final IndexShardSnapshotStatus snapshotStatus) {_        final ShardId shardId = indexShard.shardId()__        if (indexShard.routingEntry().primary() == false) {_            throw new IndexShardSnapshotFailedException(shardId, "snapshot should be performed only on primary")__        }_        if (indexShard.routingEntry().relocating()) {_            _            throw new IndexShardSnapshotFailedException(shardId, "cannot snapshot while relocating")__        }__        final IndexShardState indexShardState = indexShard.state()__        if (indexShardState == IndexShardState.CREATED || indexShardState == IndexShardState.RECOVERING) {_            _            throw new IndexShardSnapshotFailedException(shardId, "shard didn't fully recover yet")__        }__        final Repository repository = snapshotsService.getRepositoriesService().repository(snapshot.getRepository())__        try {_            _            try (Engine.IndexCommitRef snapshotRef = indexShard.acquireLastIndexCommit(true)) {_                repository.snapshotShard(indexShard, indexShard.store(), snapshot.getSnapshotId(), indexId, snapshotRef.getIndexCommit(),_                    snapshotStatus)__                if (logger.isDebugEnabled()) {_                    final IndexShardSnapshotStatus.Copy lastSnapshotStatus = snapshotStatus.asCopy()__                    logger.debug("snapshot ({}) completed to {} with {}", snapshot, repository, lastSnapshotStatus)__                }_            }_        } catch (SnapshotFailedEngineException | IndexShardSnapshotFailedException e) {_            throw e__        } catch (Exception e) {_            throw new IndexShardSnapshotFailedException(shardId, "Failed to snapshot", e)__        }_    };creates,shard,snapshot,param,snapshot,snapshot,param,snapshot,status,snapshot,status;private,void,snapshot,final,index,shard,index,shard,final,snapshot,snapshot,final,index,id,index,id,final,index,shard,snapshot,status,snapshot,status,final,shard,id,shard,id,index,shard,shard,id,if,index,shard,routing,entry,primary,false,throw,new,index,shard,snapshot,failed,exception,shard,id,snapshot,should,be,performed,only,on,primary,if,index,shard,routing,entry,relocating,throw,new,index,shard,snapshot,failed,exception,shard,id,cannot,snapshot,while,relocating,final,index,shard,state,index,shard,state,index,shard,state,if,index,shard,state,index,shard,state,created,index,shard,state,index,shard,state,recovering,throw,new,index,shard,snapshot,failed,exception,shard,id,shard,didn,t,fully,recover,yet,final,repository,repository,snapshots,service,get,repositories,service,repository,snapshot,get,repository,try,try,engine,index,commit,ref,snapshot,ref,index,shard,acquire,last,index,commit,true,repository,snapshot,shard,index,shard,index,shard,store,snapshot,get,snapshot,id,index,id,snapshot,ref,get,index,commit,snapshot,status,if,logger,is,debug,enabled,final,index,shard,snapshot,status,copy,last,snapshot,status,snapshot,status,as,copy,logger,debug,snapshot,completed,to,with,snapshot,repository,last,snapshot,status,catch,snapshot,failed,engine,exception,index,shard,snapshot,failed,exception,e,throw,e,catch,exception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,snapshot,e
SnapshotShardsService -> private void snapshot(final IndexShard indexShard, final Snapshot snapshot, final IndexId indexId, final IndexShardSnapshotStatus snapshotStatus);1542646292;Creates shard snapshot__@param snapshot       snapshot_@param snapshotStatus snapshot status;private void snapshot(final IndexShard indexShard, final Snapshot snapshot, final IndexId indexId, final IndexShardSnapshotStatus snapshotStatus) {_        final ShardId shardId = indexShard.shardId()__        if (indexShard.routingEntry().primary() == false) {_            throw new IndexShardSnapshotFailedException(shardId, "snapshot should be performed only on primary")__        }_        if (indexShard.routingEntry().relocating()) {_            _            throw new IndexShardSnapshotFailedException(shardId, "cannot snapshot while relocating")__        }__        final IndexShardState indexShardState = indexShard.state()__        if (indexShardState == IndexShardState.CREATED || indexShardState == IndexShardState.RECOVERING) {_            _            throw new IndexShardSnapshotFailedException(shardId, "shard didn't fully recover yet")__        }__        final Repository repository = snapshotsService.getRepositoriesService().repository(snapshot.getRepository())__        try {_            _            try (Engine.IndexCommitRef snapshotRef = indexShard.acquireLastIndexCommit(true)) {_                repository.snapshotShard(indexShard, indexShard.store(), snapshot.getSnapshotId(), indexId, snapshotRef.getIndexCommit(),_                    snapshotStatus)__                if (logger.isDebugEnabled()) {_                    final IndexShardSnapshotStatus.Copy lastSnapshotStatus = snapshotStatus.asCopy()__                    logger.debug("snapshot ({}) completed to {} with {}", snapshot, repository, lastSnapshotStatus)__                }_            }_        } catch (SnapshotFailedEngineException | IndexShardSnapshotFailedException e) {_            throw e__        } catch (Exception e) {_            throw new IndexShardSnapshotFailedException(shardId, "Failed to snapshot", e)__        }_    };creates,shard,snapshot,param,snapshot,snapshot,param,snapshot,status,snapshot,status;private,void,snapshot,final,index,shard,index,shard,final,snapshot,snapshot,final,index,id,index,id,final,index,shard,snapshot,status,snapshot,status,final,shard,id,shard,id,index,shard,shard,id,if,index,shard,routing,entry,primary,false,throw,new,index,shard,snapshot,failed,exception,shard,id,snapshot,should,be,performed,only,on,primary,if,index,shard,routing,entry,relocating,throw,new,index,shard,snapshot,failed,exception,shard,id,cannot,snapshot,while,relocating,final,index,shard,state,index,shard,state,index,shard,state,if,index,shard,state,index,shard,state,created,index,shard,state,index,shard,state,recovering,throw,new,index,shard,snapshot,failed,exception,shard,id,shard,didn,t,fully,recover,yet,final,repository,repository,snapshots,service,get,repositories,service,repository,snapshot,get,repository,try,try,engine,index,commit,ref,snapshot,ref,index,shard,acquire,last,index,commit,true,repository,snapshot,shard,index,shard,index,shard,store,snapshot,get,snapshot,id,index,id,snapshot,ref,get,index,commit,snapshot,status,if,logger,is,debug,enabled,final,index,shard,snapshot,status,copy,last,snapshot,status,snapshot,status,as,copy,logger,debug,snapshot,completed,to,with,snapshot,repository,last,snapshot,status,catch,snapshot,failed,engine,exception,index,shard,snapshot,failed,exception,e,throw,e,catch,exception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,snapshot,e
SnapshotShardsService -> private void snapshot(final IndexShard indexShard, final Snapshot snapshot, final IndexId indexId, final IndexShardSnapshotStatus snapshotStatus);1542804617;Creates shard snapshot__@param snapshot       snapshot_@param snapshotStatus snapshot status;private void snapshot(final IndexShard indexShard, final Snapshot snapshot, final IndexId indexId, final IndexShardSnapshotStatus snapshotStatus) {_        final ShardId shardId = indexShard.shardId()__        if (indexShard.routingEntry().primary() == false) {_            throw new IndexShardSnapshotFailedException(shardId, "snapshot should be performed only on primary")__        }_        if (indexShard.routingEntry().relocating()) {_            _            throw new IndexShardSnapshotFailedException(shardId, "cannot snapshot while relocating")__        }__        final IndexShardState indexShardState = indexShard.state()__        if (indexShardState == IndexShardState.CREATED || indexShardState == IndexShardState.RECOVERING) {_            _            throw new IndexShardSnapshotFailedException(shardId, "shard didn't fully recover yet")__        }__        final Repository repository = snapshotsService.getRepositoriesService().repository(snapshot.getRepository())__        try {_            _            try (Engine.IndexCommitRef snapshotRef = indexShard.acquireLastIndexCommit(true)) {_                repository.snapshotShard(indexShard, indexShard.store(), snapshot.getSnapshotId(), indexId, snapshotRef.getIndexCommit(),_                    snapshotStatus)__                if (logger.isDebugEnabled()) {_                    final IndexShardSnapshotStatus.Copy lastSnapshotStatus = snapshotStatus.asCopy()__                    logger.debug("snapshot ({}) completed to {} with {}", snapshot, repository, lastSnapshotStatus)__                }_            }_        } catch (SnapshotFailedEngineException | IndexShardSnapshotFailedException e) {_            throw e__        } catch (Exception e) {_            throw new IndexShardSnapshotFailedException(shardId, "Failed to snapshot", e)__        }_    };creates,shard,snapshot,param,snapshot,snapshot,param,snapshot,status,snapshot,status;private,void,snapshot,final,index,shard,index,shard,final,snapshot,snapshot,final,index,id,index,id,final,index,shard,snapshot,status,snapshot,status,final,shard,id,shard,id,index,shard,shard,id,if,index,shard,routing,entry,primary,false,throw,new,index,shard,snapshot,failed,exception,shard,id,snapshot,should,be,performed,only,on,primary,if,index,shard,routing,entry,relocating,throw,new,index,shard,snapshot,failed,exception,shard,id,cannot,snapshot,while,relocating,final,index,shard,state,index,shard,state,index,shard,state,if,index,shard,state,index,shard,state,created,index,shard,state,index,shard,state,recovering,throw,new,index,shard,snapshot,failed,exception,shard,id,shard,didn,t,fully,recover,yet,final,repository,repository,snapshots,service,get,repositories,service,repository,snapshot,get,repository,try,try,engine,index,commit,ref,snapshot,ref,index,shard,acquire,last,index,commit,true,repository,snapshot,shard,index,shard,index,shard,store,snapshot,get,snapshot,id,index,id,snapshot,ref,get,index,commit,snapshot,status,if,logger,is,debug,enabled,final,index,shard,snapshot,status,copy,last,snapshot,status,snapshot,status,as,copy,logger,debug,snapshot,completed,to,with,snapshot,repository,last,snapshot,status,catch,snapshot,failed,engine,exception,index,shard,snapshot,failed,exception,e,throw,e,catch,exception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,snapshot,e
SnapshotShardsService -> private void snapshot(final IndexShard indexShard, final Snapshot snapshot, final IndexId indexId, final IndexShardSnapshotStatus snapshotStatus);1543851569;Creates shard snapshot__@param snapshot       snapshot_@param snapshotStatus snapshot status;private void snapshot(final IndexShard indexShard, final Snapshot snapshot, final IndexId indexId, final IndexShardSnapshotStatus snapshotStatus) {_        final ShardId shardId = indexShard.shardId()__        if (indexShard.routingEntry().primary() == false) {_            throw new IndexShardSnapshotFailedException(shardId, "snapshot should be performed only on primary")__        }_        if (indexShard.routingEntry().relocating()) {_            _            throw new IndexShardSnapshotFailedException(shardId, "cannot snapshot while relocating")__        }__        final IndexShardState indexShardState = indexShard.state()__        if (indexShardState == IndexShardState.CREATED || indexShardState == IndexShardState.RECOVERING) {_            _            throw new IndexShardSnapshotFailedException(shardId, "shard didn't fully recover yet")__        }__        final Repository repository = snapshotsService.getRepositoriesService().repository(snapshot.getRepository())__        try {_            _            try (Engine.IndexCommitRef snapshotRef = indexShard.acquireLastIndexCommit(true)) {_                repository.snapshotShard(indexShard, indexShard.store(), snapshot.getSnapshotId(), indexId, snapshotRef.getIndexCommit(),_                    snapshotStatus)__                if (logger.isDebugEnabled()) {_                    final IndexShardSnapshotStatus.Copy lastSnapshotStatus = snapshotStatus.asCopy()__                    logger.debug("snapshot ({}) completed to {} with {}", snapshot, repository, lastSnapshotStatus)__                }_            }_        } catch (SnapshotFailedEngineException | IndexShardSnapshotFailedException e) {_            throw e__        } catch (Exception e) {_            throw new IndexShardSnapshotFailedException(shardId, "Failed to snapshot", e)__        }_    };creates,shard,snapshot,param,snapshot,snapshot,param,snapshot,status,snapshot,status;private,void,snapshot,final,index,shard,index,shard,final,snapshot,snapshot,final,index,id,index,id,final,index,shard,snapshot,status,snapshot,status,final,shard,id,shard,id,index,shard,shard,id,if,index,shard,routing,entry,primary,false,throw,new,index,shard,snapshot,failed,exception,shard,id,snapshot,should,be,performed,only,on,primary,if,index,shard,routing,entry,relocating,throw,new,index,shard,snapshot,failed,exception,shard,id,cannot,snapshot,while,relocating,final,index,shard,state,index,shard,state,index,shard,state,if,index,shard,state,index,shard,state,created,index,shard,state,index,shard,state,recovering,throw,new,index,shard,snapshot,failed,exception,shard,id,shard,didn,t,fully,recover,yet,final,repository,repository,snapshots,service,get,repositories,service,repository,snapshot,get,repository,try,try,engine,index,commit,ref,snapshot,ref,index,shard,acquire,last,index,commit,true,repository,snapshot,shard,index,shard,index,shard,store,snapshot,get,snapshot,id,index,id,snapshot,ref,get,index,commit,snapshot,status,if,logger,is,debug,enabled,final,index,shard,snapshot,status,copy,last,snapshot,status,snapshot,status,as,copy,logger,debug,snapshot,completed,to,with,snapshot,repository,last,snapshot,status,catch,snapshot,failed,engine,exception,index,shard,snapshot,failed,exception,e,throw,e,catch,exception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,snapshot,e
SnapshotShardsService -> private void processIndexShardSnapshots(ClusterChangedEvent event);1524684173;Checks if any new shards should be snapshotted on this node__@param event cluster state changed event;private void processIndexShardSnapshots(ClusterChangedEvent event) {_        SnapshotsInProgress snapshotsInProgress = event.state().custom(SnapshotsInProgress.TYPE)__        Map<Snapshot, SnapshotShards> survivors = new HashMap<>()__        _        for (Map.Entry<Snapshot, SnapshotShards> entry : shardSnapshots.entrySet()) {_            final Snapshot snapshot = entry.getKey()__            if (snapshotsInProgress != null && snapshotsInProgress.snapshot(snapshot) != null) {_                survivors.put(entry.getKey(), entry.getValue())__            } else {_                _                _                _                _                for (IndexShardSnapshotStatus snapshotStatus : entry.getValue().shards.values()) {_                    snapshotStatus.abortIfNotCompleted("snapshot has been removed in cluster state, aborting")__                }_            }_        }__        _        _        Map<Snapshot, Map<ShardId, IndexShardSnapshotStatus>> newSnapshots = new HashMap<>()__        _        final String localNodeId = event.state().nodes().getLocalNodeId()__        final Map<Snapshot, Map<String, IndexId>> snapshotIndices = new HashMap<>()__        if (snapshotsInProgress != null) {_            for (SnapshotsInProgress.Entry entry : snapshotsInProgress.entries()) {_                snapshotIndices.put(entry.snapshot(),_                                    entry.indices().stream().collect(Collectors.toMap(IndexId::getName, Function.identity())))__                if (entry.state() == State.STARTED) {_                    Map<ShardId, IndexShardSnapshotStatus> startedShards = new HashMap<>()__                    SnapshotShards snapshotShards = shardSnapshots.get(entry.snapshot())__                    for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shard : entry.shards()) {_                        _                        if (localNodeId.equals(shard.value.nodeId())) {_                            if (shard.value.state() == State.INIT && (snapshotShards == null || !snapshotShards.shards.containsKey(shard.key))) {_                                logger.trace("[{}] - Adding shard to the queue", shard.key)__                                startedShards.put(shard.key, IndexShardSnapshotStatus.newInitializing())__                            }_                        }_                    }_                    if (!startedShards.isEmpty()) {_                        newSnapshots.put(entry.snapshot(), startedShards)__                        if (snapshotShards != null) {_                            _                            Map<ShardId, IndexShardSnapshotStatus> shards = new HashMap<>()__                            _                            shards.putAll(snapshotShards.shards)__                            _                            shards.putAll(startedShards)__                            survivors.put(entry.snapshot(), new SnapshotShards(unmodifiableMap(shards)))__                        } else {_                            _                            survivors.put(entry.snapshot(), new SnapshotShards(unmodifiableMap(startedShards)))__                        }_                    }_                } else if (entry.state() == State.ABORTED) {_                    _                    SnapshotShards snapshotShards = shardSnapshots.get(entry.snapshot())__                    if (snapshotShards != null) {_                        final String failure = "snapshot has been aborted"__                        for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shard : entry.shards()) {__                            final IndexShardSnapshotStatus snapshotStatus = snapshotShards.shards.get(shard.key)__                            if (snapshotStatus != null) {_                                final IndexShardSnapshotStatus.Copy lastSnapshotStatus = snapshotStatus.abortIfNotCompleted(failure)__                                final Stage stage = lastSnapshotStatus.getStage()__                                if (stage == Stage.FINALIZE) {_                                    logger.debug("[{}] trying to cancel snapshot on shard [{}] that is finalizing, " +_                                        "letting it finish", entry.snapshot(), shard.key)___                                } else if (stage == Stage.DONE) {_                                    logger.debug("[{}] trying to cancel snapshot on the shard [{}] that is already done, " +_                                        "updating status on the master", entry.snapshot(), shard.key)__                                    notifySuccessfulSnapshotShard(entry.snapshot(), shard.key, localNodeId)___                                }  else if (stage == Stage.FAILURE) {_                                    logger.debug("[{}] trying to cancel snapshot on the shard [{}] that has already failed, " +_                                        "updating status on the master", entry.snapshot(), shard.key)__                                    notifyFailedSnapshotShard(entry.snapshot(), shard.key, localNodeId, lastSnapshotStatus.getFailure())__                                }_                            }_                        }_                    }_                }_            }_        }__        _        _        shutdownLock.lock()__        try {_            shardSnapshots = unmodifiableMap(survivors)__            if (shardSnapshots.isEmpty()) {_                _                shutdownCondition.signalAll()__            }_        } finally {_            shutdownLock.unlock()__        }__        _        if (newSnapshots.isEmpty() == false) {_            Executor executor = threadPool.executor(ThreadPool.Names.SNAPSHOT)__            for (final Map.Entry<Snapshot, Map<ShardId, IndexShardSnapshotStatus>> entry : newSnapshots.entrySet()) {_                final Snapshot snapshot = entry.getKey()__                final Map<String, IndexId> indicesMap = snapshotIndices.get(snapshot)__                assert indicesMap != null___                for (final Map.Entry<ShardId, IndexShardSnapshotStatus> shardEntry : entry.getValue().entrySet()) {_                    final ShardId shardId = shardEntry.getKey()__                    final IndexShard indexShard = indicesService.indexServiceSafe(shardId.getIndex()).getShardOrNull(shardId.id())__                    final IndexId indexId = indicesMap.get(shardId.getIndexName())__                    assert indexId != null__                    executor.execute(new AbstractRunnable() {__                        final SetOnce<Exception> failure = new SetOnce<>()___                        @Override_                        public void doRun() {_                            snapshot(indexShard, snapshot, indexId, shardEntry.getValue())__                        }__                        @Override_                        public void onFailure(Exception e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to snapshot shard", shardId, snapshot), e)__                            failure.set(e)__                        }__                        @Override_                        public void onRejection(Exception e) {_                            failure.set(e)__                        }__                        @Override_                        public void onAfter() {_                            final Exception exception = failure.get()__                            if (exception != null) {_                                notifyFailedSnapshotShard(snapshot, shardId, localNodeId, ExceptionsHelper.detailedMessage(exception))__                            } else {_                                notifySuccessfulSnapshotShard(snapshot, shardId, localNodeId)__                            }_                        }_                    })__                }_            }_        }_    };checks,if,any,new,shards,should,be,snapshotted,on,this,node,param,event,cluster,state,changed,event;private,void,process,index,shard,snapshots,cluster,changed,event,event,snapshots,in,progress,snapshots,in,progress,event,state,custom,snapshots,in,progress,type,map,snapshot,snapshot,shards,survivors,new,hash,map,for,map,entry,snapshot,snapshot,shards,entry,shard,snapshots,entry,set,final,snapshot,snapshot,entry,get,key,if,snapshots,in,progress,null,snapshots,in,progress,snapshot,snapshot,null,survivors,put,entry,get,key,entry,get,value,else,for,index,shard,snapshot,status,snapshot,status,entry,get,value,shards,values,snapshot,status,abort,if,not,completed,snapshot,has,been,removed,in,cluster,state,aborting,map,snapshot,map,shard,id,index,shard,snapshot,status,new,snapshots,new,hash,map,final,string,local,node,id,event,state,nodes,get,local,node,id,final,map,snapshot,map,string,index,id,snapshot,indices,new,hash,map,if,snapshots,in,progress,null,for,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,snapshot,indices,put,entry,snapshot,entry,indices,stream,collect,collectors,to,map,index,id,get,name,function,identity,if,entry,state,state,started,map,shard,id,index,shard,snapshot,status,started,shards,new,hash,map,snapshot,shards,snapshot,shards,shard,snapshots,get,entry,snapshot,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,shards,if,local,node,id,equals,shard,value,node,id,if,shard,value,state,state,init,snapshot,shards,null,snapshot,shards,shards,contains,key,shard,key,logger,trace,adding,shard,to,the,queue,shard,key,started,shards,put,shard,key,index,shard,snapshot,status,new,initializing,if,started,shards,is,empty,new,snapshots,put,entry,snapshot,started,shards,if,snapshot,shards,null,map,shard,id,index,shard,snapshot,status,shards,new,hash,map,shards,put,all,snapshot,shards,shards,shards,put,all,started,shards,survivors,put,entry,snapshot,new,snapshot,shards,unmodifiable,map,shards,else,survivors,put,entry,snapshot,new,snapshot,shards,unmodifiable,map,started,shards,else,if,entry,state,state,aborted,snapshot,shards,snapshot,shards,shard,snapshots,get,entry,snapshot,if,snapshot,shards,null,final,string,failure,snapshot,has,been,aborted,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,shards,final,index,shard,snapshot,status,snapshot,status,snapshot,shards,shards,get,shard,key,if,snapshot,status,null,final,index,shard,snapshot,status,copy,last,snapshot,status,snapshot,status,abort,if,not,completed,failure,final,stage,stage,last,snapshot,status,get,stage,if,stage,stage,finalize,logger,debug,trying,to,cancel,snapshot,on,shard,that,is,finalizing,letting,it,finish,entry,snapshot,shard,key,else,if,stage,stage,done,logger,debug,trying,to,cancel,snapshot,on,the,shard,that,is,already,done,updating,status,on,the,master,entry,snapshot,shard,key,notify,successful,snapshot,shard,entry,snapshot,shard,key,local,node,id,else,if,stage,stage,failure,logger,debug,trying,to,cancel,snapshot,on,the,shard,that,has,already,failed,updating,status,on,the,master,entry,snapshot,shard,key,notify,failed,snapshot,shard,entry,snapshot,shard,key,local,node,id,last,snapshot,status,get,failure,shutdown,lock,lock,try,shard,snapshots,unmodifiable,map,survivors,if,shard,snapshots,is,empty,shutdown,condition,signal,all,finally,shutdown,lock,unlock,if,new,snapshots,is,empty,false,executor,executor,thread,pool,executor,thread,pool,names,snapshot,for,final,map,entry,snapshot,map,shard,id,index,shard,snapshot,status,entry,new,snapshots,entry,set,final,snapshot,snapshot,entry,get,key,final,map,string,index,id,indices,map,snapshot,indices,get,snapshot,assert,indices,map,null,for,final,map,entry,shard,id,index,shard,snapshot,status,shard,entry,entry,get,value,entry,set,final,shard,id,shard,id,shard,entry,get,key,final,index,shard,index,shard,indices,service,index,service,safe,shard,id,get,index,get,shard,or,null,shard,id,id,final,index,id,index,id,indices,map,get,shard,id,get,index,name,assert,index,id,null,executor,execute,new,abstract,runnable,final,set,once,exception,failure,new,set,once,override,public,void,do,run,snapshot,index,shard,snapshot,index,id,shard,entry,get,value,override,public,void,on,failure,exception,e,logger,warn,new,parameterized,message,failed,to,snapshot,shard,shard,id,snapshot,e,failure,set,e,override,public,void,on,rejection,exception,e,failure,set,e,override,public,void,on,after,final,exception,exception,failure,get,if,exception,null,notify,failed,snapshot,shard,snapshot,shard,id,local,node,id,exceptions,helper,detailed,message,exception,else,notify,successful,snapshot,shard,snapshot,shard,id,local,node,id
SnapshotShardsService -> private void processIndexShardSnapshots(ClusterChangedEvent event);1536828374;Checks if any new shards should be snapshotted on this node__@param event cluster state changed event;private void processIndexShardSnapshots(ClusterChangedEvent event) {_        SnapshotsInProgress snapshotsInProgress = event.state().custom(SnapshotsInProgress.TYPE)__        Map<Snapshot, SnapshotShards> survivors = new HashMap<>()__        _        for (Map.Entry<Snapshot, SnapshotShards> entry : shardSnapshots.entrySet()) {_            final Snapshot snapshot = entry.getKey()__            if (snapshotsInProgress != null && snapshotsInProgress.snapshot(snapshot) != null) {_                survivors.put(entry.getKey(), entry.getValue())__            } else {_                _                _                _                _                for (IndexShardSnapshotStatus snapshotStatus : entry.getValue().shards.values()) {_                    snapshotStatus.abortIfNotCompleted("snapshot has been removed in cluster state, aborting")__                }_            }_        }__        _        _        Map<Snapshot, Map<ShardId, IndexShardSnapshotStatus>> newSnapshots = new HashMap<>()__        _        final String localNodeId = event.state().nodes().getLocalNodeId()__        final Map<Snapshot, Map<String, IndexId>> snapshotIndices = new HashMap<>()__        if (snapshotsInProgress != null) {_            for (SnapshotsInProgress.Entry entry : snapshotsInProgress.entries()) {_                snapshotIndices.put(entry.snapshot(),_                                    entry.indices().stream().collect(Collectors.toMap(IndexId::getName, Function.identity())))__                if (entry.state() == State.STARTED) {_                    Map<ShardId, IndexShardSnapshotStatus> startedShards = new HashMap<>()__                    SnapshotShards snapshotShards = shardSnapshots.get(entry.snapshot())__                    for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shard : entry.shards()) {_                        _                        if (localNodeId.equals(shard.value.nodeId())) {_                            if (shard.value.state() == State.INIT && (snapshotShards == null || !snapshotShards.shards.containsKey(shard.key))) {_                                logger.trace("[{}] - Adding shard to the queue", shard.key)__                                startedShards.put(shard.key, IndexShardSnapshotStatus.newInitializing())__                            }_                        }_                    }_                    if (!startedShards.isEmpty()) {_                        newSnapshots.put(entry.snapshot(), startedShards)__                        if (snapshotShards != null) {_                            _                            Map<ShardId, IndexShardSnapshotStatus> shards = new HashMap<>()__                            _                            shards.putAll(snapshotShards.shards)__                            _                            shards.putAll(startedShards)__                            survivors.put(entry.snapshot(), new SnapshotShards(unmodifiableMap(shards)))__                        } else {_                            _                            survivors.put(entry.snapshot(), new SnapshotShards(unmodifiableMap(startedShards)))__                        }_                    }_                } else if (entry.state() == State.ABORTED) {_                    _                    SnapshotShards snapshotShards = shardSnapshots.get(entry.snapshot())__                    if (snapshotShards != null) {_                        final String failure = "snapshot has been aborted"__                        for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shard : entry.shards()) {__                            final IndexShardSnapshotStatus snapshotStatus = snapshotShards.shards.get(shard.key)__                            if (snapshotStatus != null) {_                                final IndexShardSnapshotStatus.Copy lastSnapshotStatus = snapshotStatus.abortIfNotCompleted(failure)__                                final Stage stage = lastSnapshotStatus.getStage()__                                if (stage == Stage.FINALIZE) {_                                    logger.debug("[{}] trying to cancel snapshot on shard [{}] that is finalizing, " +_                                        "letting it finish", entry.snapshot(), shard.key)___                                } else if (stage == Stage.DONE) {_                                    logger.debug("[{}] trying to cancel snapshot on the shard [{}] that is already done, " +_                                        "updating status on the master", entry.snapshot(), shard.key)__                                    notifySuccessfulSnapshotShard(entry.snapshot(), shard.key, localNodeId)___                                }  else if (stage == Stage.FAILURE) {_                                    logger.debug("[{}] trying to cancel snapshot on the shard [{}] that has already failed, " +_                                        "updating status on the master", entry.snapshot(), shard.key)__                                    notifyFailedSnapshotShard(entry.snapshot(), shard.key, localNodeId, lastSnapshotStatus.getFailure())__                                }_                            }_                        }_                    }_                }_            }_        }__        _        _        shutdownLock.lock()__        try {_            shardSnapshots = unmodifiableMap(survivors)__            if (shardSnapshots.isEmpty()) {_                _                shutdownCondition.signalAll()__            }_        } finally {_            shutdownLock.unlock()__        }__        _        if (newSnapshots.isEmpty() == false) {_            Executor executor = threadPool.executor(ThreadPool.Names.SNAPSHOT)__            for (final Map.Entry<Snapshot, Map<ShardId, IndexShardSnapshotStatus>> entry : newSnapshots.entrySet()) {_                final Snapshot snapshot = entry.getKey()__                final Map<String, IndexId> indicesMap = snapshotIndices.get(snapshot)__                assert indicesMap != null___                for (final Map.Entry<ShardId, IndexShardSnapshotStatus> shardEntry : entry.getValue().entrySet()) {_                    final ShardId shardId = shardEntry.getKey()__                    final IndexShard indexShard = indicesService.indexServiceSafe(shardId.getIndex()).getShardOrNull(shardId.id())__                    final IndexId indexId = indicesMap.get(shardId.getIndexName())__                    assert indexId != null__                    executor.execute(new AbstractRunnable() {__                        final SetOnce<Exception> failure = new SetOnce<>()___                        @Override_                        public void doRun() {_                            snapshot(indexShard, snapshot, indexId, shardEntry.getValue())__                        }__                        @Override_                        public void onFailure(Exception e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to snapshot shard", shardId, snapshot), e)__                            failure.set(e)__                        }__                        @Override_                        public void onRejection(Exception e) {_                            failure.set(e)__                        }__                        @Override_                        public void onAfter() {_                            final Exception exception = failure.get()__                            if (exception != null) {_                                notifyFailedSnapshotShard(snapshot, shardId, localNodeId, ExceptionsHelper.detailedMessage(exception))__                            } else {_                                notifySuccessfulSnapshotShard(snapshot, shardId, localNodeId)__                            }_                        }_                    })__                }_            }_        }_    };checks,if,any,new,shards,should,be,snapshotted,on,this,node,param,event,cluster,state,changed,event;private,void,process,index,shard,snapshots,cluster,changed,event,event,snapshots,in,progress,snapshots,in,progress,event,state,custom,snapshots,in,progress,type,map,snapshot,snapshot,shards,survivors,new,hash,map,for,map,entry,snapshot,snapshot,shards,entry,shard,snapshots,entry,set,final,snapshot,snapshot,entry,get,key,if,snapshots,in,progress,null,snapshots,in,progress,snapshot,snapshot,null,survivors,put,entry,get,key,entry,get,value,else,for,index,shard,snapshot,status,snapshot,status,entry,get,value,shards,values,snapshot,status,abort,if,not,completed,snapshot,has,been,removed,in,cluster,state,aborting,map,snapshot,map,shard,id,index,shard,snapshot,status,new,snapshots,new,hash,map,final,string,local,node,id,event,state,nodes,get,local,node,id,final,map,snapshot,map,string,index,id,snapshot,indices,new,hash,map,if,snapshots,in,progress,null,for,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,snapshot,indices,put,entry,snapshot,entry,indices,stream,collect,collectors,to,map,index,id,get,name,function,identity,if,entry,state,state,started,map,shard,id,index,shard,snapshot,status,started,shards,new,hash,map,snapshot,shards,snapshot,shards,shard,snapshots,get,entry,snapshot,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,shards,if,local,node,id,equals,shard,value,node,id,if,shard,value,state,state,init,snapshot,shards,null,snapshot,shards,shards,contains,key,shard,key,logger,trace,adding,shard,to,the,queue,shard,key,started,shards,put,shard,key,index,shard,snapshot,status,new,initializing,if,started,shards,is,empty,new,snapshots,put,entry,snapshot,started,shards,if,snapshot,shards,null,map,shard,id,index,shard,snapshot,status,shards,new,hash,map,shards,put,all,snapshot,shards,shards,shards,put,all,started,shards,survivors,put,entry,snapshot,new,snapshot,shards,unmodifiable,map,shards,else,survivors,put,entry,snapshot,new,snapshot,shards,unmodifiable,map,started,shards,else,if,entry,state,state,aborted,snapshot,shards,snapshot,shards,shard,snapshots,get,entry,snapshot,if,snapshot,shards,null,final,string,failure,snapshot,has,been,aborted,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,shards,final,index,shard,snapshot,status,snapshot,status,snapshot,shards,shards,get,shard,key,if,snapshot,status,null,final,index,shard,snapshot,status,copy,last,snapshot,status,snapshot,status,abort,if,not,completed,failure,final,stage,stage,last,snapshot,status,get,stage,if,stage,stage,finalize,logger,debug,trying,to,cancel,snapshot,on,shard,that,is,finalizing,letting,it,finish,entry,snapshot,shard,key,else,if,stage,stage,done,logger,debug,trying,to,cancel,snapshot,on,the,shard,that,is,already,done,updating,status,on,the,master,entry,snapshot,shard,key,notify,successful,snapshot,shard,entry,snapshot,shard,key,local,node,id,else,if,stage,stage,failure,logger,debug,trying,to,cancel,snapshot,on,the,shard,that,has,already,failed,updating,status,on,the,master,entry,snapshot,shard,key,notify,failed,snapshot,shard,entry,snapshot,shard,key,local,node,id,last,snapshot,status,get,failure,shutdown,lock,lock,try,shard,snapshots,unmodifiable,map,survivors,if,shard,snapshots,is,empty,shutdown,condition,signal,all,finally,shutdown,lock,unlock,if,new,snapshots,is,empty,false,executor,executor,thread,pool,executor,thread,pool,names,snapshot,for,final,map,entry,snapshot,map,shard,id,index,shard,snapshot,status,entry,new,snapshots,entry,set,final,snapshot,snapshot,entry,get,key,final,map,string,index,id,indices,map,snapshot,indices,get,snapshot,assert,indices,map,null,for,final,map,entry,shard,id,index,shard,snapshot,status,shard,entry,entry,get,value,entry,set,final,shard,id,shard,id,shard,entry,get,key,final,index,shard,index,shard,indices,service,index,service,safe,shard,id,get,index,get,shard,or,null,shard,id,id,final,index,id,index,id,indices,map,get,shard,id,get,index,name,assert,index,id,null,executor,execute,new,abstract,runnable,final,set,once,exception,failure,new,set,once,override,public,void,do,run,snapshot,index,shard,snapshot,index,id,shard,entry,get,value,override,public,void,on,failure,exception,e,logger,warn,new,parameterized,message,failed,to,snapshot,shard,shard,id,snapshot,e,failure,set,e,override,public,void,on,rejection,exception,e,failure,set,e,override,public,void,on,after,final,exception,exception,failure,get,if,exception,null,notify,failed,snapshot,shard,snapshot,shard,id,local,node,id,exceptions,helper,detailed,message,exception,else,notify,successful,snapshot,shard,snapshot,shard,id,local,node,id
SnapshotShardsService -> private void processIndexShardSnapshots(ClusterChangedEvent event);1541419698;Checks if any new shards should be snapshotted on this node__@param event cluster state changed event;private void processIndexShardSnapshots(ClusterChangedEvent event) {_        SnapshotsInProgress snapshotsInProgress = event.state().custom(SnapshotsInProgress.TYPE)__        Map<Snapshot, SnapshotShards> survivors = new HashMap<>()__        _        for (Map.Entry<Snapshot, SnapshotShards> entry : shardSnapshots.entrySet()) {_            final Snapshot snapshot = entry.getKey()__            if (snapshotsInProgress != null && snapshotsInProgress.snapshot(snapshot) != null) {_                survivors.put(entry.getKey(), entry.getValue())__            } else {_                _                _                _                _                for (IndexShardSnapshotStatus snapshotStatus : entry.getValue().shards.values()) {_                    snapshotStatus.abortIfNotCompleted("snapshot has been removed in cluster state, aborting")__                }_            }_        }__        _        _        Map<Snapshot, Map<ShardId, IndexShardSnapshotStatus>> newSnapshots = new HashMap<>()__        _        final String localNodeId = event.state().nodes().getLocalNodeId()__        final Map<Snapshot, Map<String, IndexId>> snapshotIndices = new HashMap<>()__        if (snapshotsInProgress != null) {_            for (SnapshotsInProgress.Entry entry : snapshotsInProgress.entries()) {_                snapshotIndices.put(entry.snapshot(),_                                    entry.indices().stream().collect(Collectors.toMap(IndexId::getName, Function.identity())))__                if (entry.state() == State.STARTED) {_                    Map<ShardId, IndexShardSnapshotStatus> startedShards = new HashMap<>()__                    SnapshotShards snapshotShards = shardSnapshots.get(entry.snapshot())__                    for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shard : entry.shards()) {_                        _                        if (localNodeId.equals(shard.value.nodeId())) {_                            if (shard.value.state() == State.INIT && (snapshotShards == null || !snapshotShards.shards.containsKey(shard.key))) {_                                logger.trace("[{}] - Adding shard to the queue", shard.key)__                                startedShards.put(shard.key, IndexShardSnapshotStatus.newInitializing())__                            }_                        }_                    }_                    if (!startedShards.isEmpty()) {_                        newSnapshots.put(entry.snapshot(), startedShards)__                        if (snapshotShards != null) {_                            _                            Map<ShardId, IndexShardSnapshotStatus> shards = new HashMap<>()__                            _                            shards.putAll(snapshotShards.shards)__                            _                            shards.putAll(startedShards)__                            survivors.put(entry.snapshot(), new SnapshotShards(unmodifiableMap(shards)))__                        } else {_                            _                            survivors.put(entry.snapshot(), new SnapshotShards(unmodifiableMap(startedShards)))__                        }_                    }_                } else if (entry.state() == State.ABORTED) {_                    _                    SnapshotShards snapshotShards = shardSnapshots.get(entry.snapshot())__                    if (snapshotShards != null) {_                        final String failure = "snapshot has been aborted"__                        for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shard : entry.shards()) {__                            final IndexShardSnapshotStatus snapshotStatus = snapshotShards.shards.get(shard.key)__                            if (snapshotStatus != null) {_                                final IndexShardSnapshotStatus.Copy lastSnapshotStatus = snapshotStatus.abortIfNotCompleted(failure)__                                final Stage stage = lastSnapshotStatus.getStage()__                                if (stage == Stage.FINALIZE) {_                                    logger.debug("[{}] trying to cancel snapshot on shard [{}] that is finalizing, " +_                                        "letting it finish", entry.snapshot(), shard.key)___                                } else if (stage == Stage.DONE) {_                                    logger.debug("[{}] trying to cancel snapshot on the shard [{}] that is already done, " +_                                        "updating status on the master", entry.snapshot(), shard.key)__                                    notifySuccessfulSnapshotShard(entry.snapshot(), shard.key, localNodeId)___                                }  else if (stage == Stage.FAILURE) {_                                    logger.debug("[{}] trying to cancel snapshot on the shard [{}] that has already failed, " +_                                        "updating status on the master", entry.snapshot(), shard.key)__                                    notifyFailedSnapshotShard(entry.snapshot(), shard.key, localNodeId, lastSnapshotStatus.getFailure())__                                }_                            }_                        }_                    }_                }_            }_        }__        _        _        shutdownLock.lock()__        try {_            shardSnapshots = unmodifiableMap(survivors)__            if (shardSnapshots.isEmpty()) {_                _                shutdownCondition.signalAll()__            }_        } finally {_            shutdownLock.unlock()__        }__        _        if (newSnapshots.isEmpty() == false) {_            Executor executor = threadPool.executor(ThreadPool.Names.SNAPSHOT)__            for (final Map.Entry<Snapshot, Map<ShardId, IndexShardSnapshotStatus>> entry : newSnapshots.entrySet()) {_                final Snapshot snapshot = entry.getKey()__                final Map<String, IndexId> indicesMap = snapshotIndices.get(snapshot)__                assert indicesMap != null___                for (final Map.Entry<ShardId, IndexShardSnapshotStatus> shardEntry : entry.getValue().entrySet()) {_                    final ShardId shardId = shardEntry.getKey()__                    final IndexShard indexShard = indicesService.indexServiceSafe(shardId.getIndex()).getShardOrNull(shardId.id())__                    final IndexId indexId = indicesMap.get(shardId.getIndexName())__                    assert indexId != null__                    executor.execute(new AbstractRunnable() {__                        final SetOnce<Exception> failure = new SetOnce<>()___                        @Override_                        public void doRun() {_                            snapshot(indexShard, snapshot, indexId, shardEntry.getValue())__                        }__                        @Override_                        public void onFailure(Exception e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to snapshot shard", shardId, snapshot), e)__                            failure.set(e)__                        }__                        @Override_                        public void onRejection(Exception e) {_                            failure.set(e)__                        }__                        @Override_                        public void onAfter() {_                            final Exception exception = failure.get()__                            if (exception != null) {_                                notifyFailedSnapshotShard(snapshot, shardId, localNodeId, ExceptionsHelper.detailedMessage(exception))__                            } else {_                                notifySuccessfulSnapshotShard(snapshot, shardId, localNodeId)__                            }_                        }_                    })__                }_            }_        }_    };checks,if,any,new,shards,should,be,snapshotted,on,this,node,param,event,cluster,state,changed,event;private,void,process,index,shard,snapshots,cluster,changed,event,event,snapshots,in,progress,snapshots,in,progress,event,state,custom,snapshots,in,progress,type,map,snapshot,snapshot,shards,survivors,new,hash,map,for,map,entry,snapshot,snapshot,shards,entry,shard,snapshots,entry,set,final,snapshot,snapshot,entry,get,key,if,snapshots,in,progress,null,snapshots,in,progress,snapshot,snapshot,null,survivors,put,entry,get,key,entry,get,value,else,for,index,shard,snapshot,status,snapshot,status,entry,get,value,shards,values,snapshot,status,abort,if,not,completed,snapshot,has,been,removed,in,cluster,state,aborting,map,snapshot,map,shard,id,index,shard,snapshot,status,new,snapshots,new,hash,map,final,string,local,node,id,event,state,nodes,get,local,node,id,final,map,snapshot,map,string,index,id,snapshot,indices,new,hash,map,if,snapshots,in,progress,null,for,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,snapshot,indices,put,entry,snapshot,entry,indices,stream,collect,collectors,to,map,index,id,get,name,function,identity,if,entry,state,state,started,map,shard,id,index,shard,snapshot,status,started,shards,new,hash,map,snapshot,shards,snapshot,shards,shard,snapshots,get,entry,snapshot,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,shards,if,local,node,id,equals,shard,value,node,id,if,shard,value,state,state,init,snapshot,shards,null,snapshot,shards,shards,contains,key,shard,key,logger,trace,adding,shard,to,the,queue,shard,key,started,shards,put,shard,key,index,shard,snapshot,status,new,initializing,if,started,shards,is,empty,new,snapshots,put,entry,snapshot,started,shards,if,snapshot,shards,null,map,shard,id,index,shard,snapshot,status,shards,new,hash,map,shards,put,all,snapshot,shards,shards,shards,put,all,started,shards,survivors,put,entry,snapshot,new,snapshot,shards,unmodifiable,map,shards,else,survivors,put,entry,snapshot,new,snapshot,shards,unmodifiable,map,started,shards,else,if,entry,state,state,aborted,snapshot,shards,snapshot,shards,shard,snapshots,get,entry,snapshot,if,snapshot,shards,null,final,string,failure,snapshot,has,been,aborted,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,shards,final,index,shard,snapshot,status,snapshot,status,snapshot,shards,shards,get,shard,key,if,snapshot,status,null,final,index,shard,snapshot,status,copy,last,snapshot,status,snapshot,status,abort,if,not,completed,failure,final,stage,stage,last,snapshot,status,get,stage,if,stage,stage,finalize,logger,debug,trying,to,cancel,snapshot,on,shard,that,is,finalizing,letting,it,finish,entry,snapshot,shard,key,else,if,stage,stage,done,logger,debug,trying,to,cancel,snapshot,on,the,shard,that,is,already,done,updating,status,on,the,master,entry,snapshot,shard,key,notify,successful,snapshot,shard,entry,snapshot,shard,key,local,node,id,else,if,stage,stage,failure,logger,debug,trying,to,cancel,snapshot,on,the,shard,that,has,already,failed,updating,status,on,the,master,entry,snapshot,shard,key,notify,failed,snapshot,shard,entry,snapshot,shard,key,local,node,id,last,snapshot,status,get,failure,shutdown,lock,lock,try,shard,snapshots,unmodifiable,map,survivors,if,shard,snapshots,is,empty,shutdown,condition,signal,all,finally,shutdown,lock,unlock,if,new,snapshots,is,empty,false,executor,executor,thread,pool,executor,thread,pool,names,snapshot,for,final,map,entry,snapshot,map,shard,id,index,shard,snapshot,status,entry,new,snapshots,entry,set,final,snapshot,snapshot,entry,get,key,final,map,string,index,id,indices,map,snapshot,indices,get,snapshot,assert,indices,map,null,for,final,map,entry,shard,id,index,shard,snapshot,status,shard,entry,entry,get,value,entry,set,final,shard,id,shard,id,shard,entry,get,key,final,index,shard,index,shard,indices,service,index,service,safe,shard,id,get,index,get,shard,or,null,shard,id,id,final,index,id,index,id,indices,map,get,shard,id,get,index,name,assert,index,id,null,executor,execute,new,abstract,runnable,final,set,once,exception,failure,new,set,once,override,public,void,do,run,snapshot,index,shard,snapshot,index,id,shard,entry,get,value,override,public,void,on,failure,exception,e,logger,warn,new,parameterized,message,failed,to,snapshot,shard,shard,id,snapshot,e,failure,set,e,override,public,void,on,rejection,exception,e,failure,set,e,override,public,void,on,after,final,exception,exception,failure,get,if,exception,null,notify,failed,snapshot,shard,snapshot,shard,id,local,node,id,exceptions,helper,detailed,message,exception,else,notify,successful,snapshot,shard,snapshot,shard,id,local,node,id
SnapshotShardsService -> private void processIndexShardSnapshots(ClusterChangedEvent event);1542646292;Checks if any new shards should be snapshotted on this node__@param event cluster state changed event;private void processIndexShardSnapshots(ClusterChangedEvent event) {_        SnapshotsInProgress snapshotsInProgress = event.state().custom(SnapshotsInProgress.TYPE)__        Map<Snapshot, SnapshotShards> survivors = new HashMap<>()__        _        for (Map.Entry<Snapshot, SnapshotShards> entry : shardSnapshots.entrySet()) {_            final Snapshot snapshot = entry.getKey()__            if (snapshotsInProgress != null && snapshotsInProgress.snapshot(snapshot) != null) {_                survivors.put(entry.getKey(), entry.getValue())__            } else {_                _                _                _                _                for (IndexShardSnapshotStatus snapshotStatus : entry.getValue().shards.values()) {_                    snapshotStatus.abortIfNotCompleted("snapshot has been removed in cluster state, aborting")__                }_            }_        }__        _        _        Map<Snapshot, Map<ShardId, IndexShardSnapshotStatus>> newSnapshots = new HashMap<>()__        _        final String localNodeId = event.state().nodes().getLocalNodeId()__        final Map<Snapshot, Map<String, IndexId>> snapshotIndices = new HashMap<>()__        if (snapshotsInProgress != null) {_            for (SnapshotsInProgress.Entry entry : snapshotsInProgress.entries()) {_                snapshotIndices.put(entry.snapshot(),_                                    entry.indices().stream().collect(Collectors.toMap(IndexId::getName, Function.identity())))__                if (entry.state() == State.STARTED) {_                    Map<ShardId, IndexShardSnapshotStatus> startedShards = new HashMap<>()__                    SnapshotShards snapshotShards = shardSnapshots.get(entry.snapshot())__                    for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shard : entry.shards()) {_                        _                        if (localNodeId.equals(shard.value.nodeId())) {_                            if (shard.value.state() == State.INIT && (snapshotShards == null || !snapshotShards.shards.containsKey(shard.key))) {_                                logger.trace("[{}] - Adding shard to the queue", shard.key)__                                startedShards.put(shard.key, IndexShardSnapshotStatus.newInitializing())__                            }_                        }_                    }_                    if (!startedShards.isEmpty()) {_                        newSnapshots.put(entry.snapshot(), startedShards)__                        if (snapshotShards != null) {_                            _                            Map<ShardId, IndexShardSnapshotStatus> shards = new HashMap<>()__                            _                            shards.putAll(snapshotShards.shards)__                            _                            shards.putAll(startedShards)__                            survivors.put(entry.snapshot(), new SnapshotShards(unmodifiableMap(shards)))__                        } else {_                            _                            survivors.put(entry.snapshot(), new SnapshotShards(unmodifiableMap(startedShards)))__                        }_                    }_                } else if (entry.state() == State.ABORTED) {_                    _                    SnapshotShards snapshotShards = shardSnapshots.get(entry.snapshot())__                    if (snapshotShards != null) {_                        final String failure = "snapshot has been aborted"__                        for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shard : entry.shards()) {__                            final IndexShardSnapshotStatus snapshotStatus = snapshotShards.shards.get(shard.key)__                            if (snapshotStatus != null) {_                                final IndexShardSnapshotStatus.Copy lastSnapshotStatus = snapshotStatus.abortIfNotCompleted(failure)__                                final Stage stage = lastSnapshotStatus.getStage()__                                if (stage == Stage.FINALIZE) {_                                    logger.debug("[{}] trying to cancel snapshot on shard [{}] that is finalizing, " +_                                        "letting it finish", entry.snapshot(), shard.key)___                                } else if (stage == Stage.DONE) {_                                    logger.debug("[{}] trying to cancel snapshot on the shard [{}] that is already done, " +_                                        "updating status on the master", entry.snapshot(), shard.key)__                                    notifySuccessfulSnapshotShard(entry.snapshot(), shard.key, localNodeId)___                                }  else if (stage == Stage.FAILURE) {_                                    logger.debug("[{}] trying to cancel snapshot on the shard [{}] that has already failed, " +_                                        "updating status on the master", entry.snapshot(), shard.key)__                                    notifyFailedSnapshotShard(entry.snapshot(), shard.key, localNodeId, lastSnapshotStatus.getFailure())__                                }_                            }_                        }_                    }_                }_            }_        }__        _        _        shutdownLock.lock()__        try {_            shardSnapshots = unmodifiableMap(survivors)__            if (shardSnapshots.isEmpty()) {_                _                shutdownCondition.signalAll()__            }_        } finally {_            shutdownLock.unlock()__        }__        _        if (newSnapshots.isEmpty() == false) {_            Executor executor = threadPool.executor(ThreadPool.Names.SNAPSHOT)__            for (final Map.Entry<Snapshot, Map<ShardId, IndexShardSnapshotStatus>> entry : newSnapshots.entrySet()) {_                final Snapshot snapshot = entry.getKey()__                final Map<String, IndexId> indicesMap = snapshotIndices.get(snapshot)__                assert indicesMap != null___                for (final Map.Entry<ShardId, IndexShardSnapshotStatus> shardEntry : entry.getValue().entrySet()) {_                    final ShardId shardId = shardEntry.getKey()__                    final IndexShard indexShard = indicesService.indexServiceSafe(shardId.getIndex()).getShardOrNull(shardId.id())__                    final IndexId indexId = indicesMap.get(shardId.getIndexName())__                    assert indexId != null__                    executor.execute(new AbstractRunnable() {__                        final SetOnce<Exception> failure = new SetOnce<>()___                        @Override_                        public void doRun() {_                            snapshot(indexShard, snapshot, indexId, shardEntry.getValue())__                        }__                        @Override_                        public void onFailure(Exception e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to snapshot shard", shardId, snapshot), e)__                            failure.set(e)__                        }__                        @Override_                        public void onRejection(Exception e) {_                            failure.set(e)__                        }__                        @Override_                        public void onAfter() {_                            final Exception exception = failure.get()__                            if (exception != null) {_                                notifyFailedSnapshotShard(snapshot, shardId, localNodeId, ExceptionsHelper.detailedMessage(exception))__                            } else {_                                notifySuccessfulSnapshotShard(snapshot, shardId, localNodeId)__                            }_                        }_                    })__                }_            }_        }_    };checks,if,any,new,shards,should,be,snapshotted,on,this,node,param,event,cluster,state,changed,event;private,void,process,index,shard,snapshots,cluster,changed,event,event,snapshots,in,progress,snapshots,in,progress,event,state,custom,snapshots,in,progress,type,map,snapshot,snapshot,shards,survivors,new,hash,map,for,map,entry,snapshot,snapshot,shards,entry,shard,snapshots,entry,set,final,snapshot,snapshot,entry,get,key,if,snapshots,in,progress,null,snapshots,in,progress,snapshot,snapshot,null,survivors,put,entry,get,key,entry,get,value,else,for,index,shard,snapshot,status,snapshot,status,entry,get,value,shards,values,snapshot,status,abort,if,not,completed,snapshot,has,been,removed,in,cluster,state,aborting,map,snapshot,map,shard,id,index,shard,snapshot,status,new,snapshots,new,hash,map,final,string,local,node,id,event,state,nodes,get,local,node,id,final,map,snapshot,map,string,index,id,snapshot,indices,new,hash,map,if,snapshots,in,progress,null,for,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,snapshot,indices,put,entry,snapshot,entry,indices,stream,collect,collectors,to,map,index,id,get,name,function,identity,if,entry,state,state,started,map,shard,id,index,shard,snapshot,status,started,shards,new,hash,map,snapshot,shards,snapshot,shards,shard,snapshots,get,entry,snapshot,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,shards,if,local,node,id,equals,shard,value,node,id,if,shard,value,state,state,init,snapshot,shards,null,snapshot,shards,shards,contains,key,shard,key,logger,trace,adding,shard,to,the,queue,shard,key,started,shards,put,shard,key,index,shard,snapshot,status,new,initializing,if,started,shards,is,empty,new,snapshots,put,entry,snapshot,started,shards,if,snapshot,shards,null,map,shard,id,index,shard,snapshot,status,shards,new,hash,map,shards,put,all,snapshot,shards,shards,shards,put,all,started,shards,survivors,put,entry,snapshot,new,snapshot,shards,unmodifiable,map,shards,else,survivors,put,entry,snapshot,new,snapshot,shards,unmodifiable,map,started,shards,else,if,entry,state,state,aborted,snapshot,shards,snapshot,shards,shard,snapshots,get,entry,snapshot,if,snapshot,shards,null,final,string,failure,snapshot,has,been,aborted,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,shards,final,index,shard,snapshot,status,snapshot,status,snapshot,shards,shards,get,shard,key,if,snapshot,status,null,final,index,shard,snapshot,status,copy,last,snapshot,status,snapshot,status,abort,if,not,completed,failure,final,stage,stage,last,snapshot,status,get,stage,if,stage,stage,finalize,logger,debug,trying,to,cancel,snapshot,on,shard,that,is,finalizing,letting,it,finish,entry,snapshot,shard,key,else,if,stage,stage,done,logger,debug,trying,to,cancel,snapshot,on,the,shard,that,is,already,done,updating,status,on,the,master,entry,snapshot,shard,key,notify,successful,snapshot,shard,entry,snapshot,shard,key,local,node,id,else,if,stage,stage,failure,logger,debug,trying,to,cancel,snapshot,on,the,shard,that,has,already,failed,updating,status,on,the,master,entry,snapshot,shard,key,notify,failed,snapshot,shard,entry,snapshot,shard,key,local,node,id,last,snapshot,status,get,failure,shutdown,lock,lock,try,shard,snapshots,unmodifiable,map,survivors,if,shard,snapshots,is,empty,shutdown,condition,signal,all,finally,shutdown,lock,unlock,if,new,snapshots,is,empty,false,executor,executor,thread,pool,executor,thread,pool,names,snapshot,for,final,map,entry,snapshot,map,shard,id,index,shard,snapshot,status,entry,new,snapshots,entry,set,final,snapshot,snapshot,entry,get,key,final,map,string,index,id,indices,map,snapshot,indices,get,snapshot,assert,indices,map,null,for,final,map,entry,shard,id,index,shard,snapshot,status,shard,entry,entry,get,value,entry,set,final,shard,id,shard,id,shard,entry,get,key,final,index,shard,index,shard,indices,service,index,service,safe,shard,id,get,index,get,shard,or,null,shard,id,id,final,index,id,index,id,indices,map,get,shard,id,get,index,name,assert,index,id,null,executor,execute,new,abstract,runnable,final,set,once,exception,failure,new,set,once,override,public,void,do,run,snapshot,index,shard,snapshot,index,id,shard,entry,get,value,override,public,void,on,failure,exception,e,logger,warn,new,parameterized,message,failed,to,snapshot,shard,shard,id,snapshot,e,failure,set,e,override,public,void,on,rejection,exception,e,failure,set,e,override,public,void,on,after,final,exception,exception,failure,get,if,exception,null,notify,failed,snapshot,shard,snapshot,shard,id,local,node,id,exceptions,helper,detailed,message,exception,else,notify,successful,snapshot,shard,snapshot,shard,id,local,node,id
SnapshotShardsService -> private void processIndexShardSnapshots(ClusterChangedEvent event);1542804617;Checks if any new shards should be snapshotted on this node__@param event cluster state changed event;private void processIndexShardSnapshots(ClusterChangedEvent event) {_        SnapshotsInProgress snapshotsInProgress = event.state().custom(SnapshotsInProgress.TYPE)__        Map<Snapshot, Map<ShardId, IndexShardSnapshotStatus>> survivors = new HashMap<>()__        _        for (Map.Entry<Snapshot, Map<ShardId, IndexShardSnapshotStatus>> entry : shardSnapshots.entrySet()) {_            final Snapshot snapshot = entry.getKey()__            if (snapshotsInProgress != null && snapshotsInProgress.snapshot(snapshot) != null) {_                survivors.put(entry.getKey(), entry.getValue())__            } else {_                _                _                _                _                for (IndexShardSnapshotStatus snapshotStatus : entry.getValue().values()) {_                    snapshotStatus.abortIfNotCompleted("snapshot has been removed in cluster state, aborting")__                }_            }_        }__        _        _        Map<Snapshot, Map<ShardId, IndexShardSnapshotStatus>> newSnapshots = new HashMap<>()__        _        final String localNodeId = event.state().nodes().getLocalNodeId()__        final Map<Snapshot, Map<String, IndexId>> snapshotIndices = new HashMap<>()__        if (snapshotsInProgress != null) {_            for (SnapshotsInProgress.Entry entry : snapshotsInProgress.entries()) {_                snapshotIndices.put(entry.snapshot(),_                                    entry.indices().stream().collect(Collectors.toMap(IndexId::getName, Function.identity())))__                if (entry.state() == State.STARTED) {_                    Map<ShardId, IndexShardSnapshotStatus> startedShards = new HashMap<>()__                    Map<ShardId, IndexShardSnapshotStatus> snapshotShards = shardSnapshots.get(entry.snapshot())__                    for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shard : entry.shards()) {_                        _                        if (localNodeId.equals(shard.value.nodeId())) {_                            if (shard.value.state() == State.INIT && (snapshotShards == null || !snapshotShards.containsKey(shard.key))) {_                                logger.trace("[{}] - Adding shard to the queue", shard.key)__                                startedShards.put(shard.key, IndexShardSnapshotStatus.newInitializing())__                            }_                        }_                    }_                    if (!startedShards.isEmpty()) {_                        newSnapshots.put(entry.snapshot(), startedShards)__                        if (snapshotShards != null) {_                            _                            Map<ShardId, IndexShardSnapshotStatus> shards = new HashMap<>()__                            _                            shards.putAll(snapshotShards)__                            _                            shards.putAll(startedShards)__                            survivors.put(entry.snapshot(), unmodifiableMap(shards))__                        } else {_                            _                            survivors.put(entry.snapshot(), unmodifiableMap(startedShards))__                        }_                    }_                } else if (entry.state() == State.ABORTED) {_                    _                    Map<ShardId, IndexShardSnapshotStatus> snapshotShards = shardSnapshots.get(entry.snapshot())__                    if (snapshotShards != null) {_                        final String failure = "snapshot has been aborted"__                        for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shard : entry.shards()) {__                            final IndexShardSnapshotStatus snapshotStatus = snapshotShards.get(shard.key)__                            if (snapshotStatus != null) {_                                final IndexShardSnapshotStatus.Copy lastSnapshotStatus = snapshotStatus.abortIfNotCompleted(failure)__                                final Stage stage = lastSnapshotStatus.getStage()__                                if (stage == Stage.FINALIZE) {_                                    logger.debug("[{}] trying to cancel snapshot on shard [{}] that is finalizing, " +_                                        "letting it finish", entry.snapshot(), shard.key)___                                } else if (stage == Stage.DONE) {_                                    logger.debug("[{}] trying to cancel snapshot on the shard [{}] that is already done, " +_                                        "updating status on the master", entry.snapshot(), shard.key)__                                    notifySuccessfulSnapshotShard(entry.snapshot(), shard.key, localNodeId)___                                }  else if (stage == Stage.FAILURE) {_                                    logger.debug("[{}] trying to cancel snapshot on the shard [{}] that has already failed, " +_                                        "updating status on the master", entry.snapshot(), shard.key)__                                    notifyFailedSnapshotShard(entry.snapshot(), shard.key, localNodeId, lastSnapshotStatus.getFailure())__                                }_                            }_                        }_                    }_                }_            }_        }__        _        _        shutdownLock.lock()__        try {_            shardSnapshots = unmodifiableMap(survivors)__            if (shardSnapshots.isEmpty()) {_                _                shutdownCondition.signalAll()__            }_        } finally {_            shutdownLock.unlock()__        }__        _        if (newSnapshots.isEmpty() == false) {_            Executor executor = threadPool.executor(ThreadPool.Names.SNAPSHOT)__            for (final Map.Entry<Snapshot, Map<ShardId, IndexShardSnapshotStatus>> entry : newSnapshots.entrySet()) {_                final Snapshot snapshot = entry.getKey()__                final Map<String, IndexId> indicesMap = snapshotIndices.get(snapshot)__                assert indicesMap != null___                for (final Map.Entry<ShardId, IndexShardSnapshotStatus> shardEntry : entry.getValue().entrySet()) {_                    final ShardId shardId = shardEntry.getKey()__                    final IndexShard indexShard = indicesService.indexServiceSafe(shardId.getIndex()).getShardOrNull(shardId.id())__                    final IndexId indexId = indicesMap.get(shardId.getIndexName())__                    assert indexId != null__                    executor.execute(new AbstractRunnable() {__                        final SetOnce<Exception> failure = new SetOnce<>()___                        @Override_                        public void doRun() {_                            snapshot(indexShard, snapshot, indexId, shardEntry.getValue())__                        }__                        @Override_                        public void onFailure(Exception e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to snapshot shard", shardId, snapshot), e)__                            failure.set(e)__                        }__                        @Override_                        public void onRejection(Exception e) {_                            failure.set(e)__                        }__                        @Override_                        public void onAfter() {_                            final Exception exception = failure.get()__                            if (exception != null) {_                                notifyFailedSnapshotShard(snapshot, shardId, localNodeId, ExceptionsHelper.detailedMessage(exception))__                            } else {_                                notifySuccessfulSnapshotShard(snapshot, shardId, localNodeId)__                            }_                        }_                    })__                }_            }_        }_    };checks,if,any,new,shards,should,be,snapshotted,on,this,node,param,event,cluster,state,changed,event;private,void,process,index,shard,snapshots,cluster,changed,event,event,snapshots,in,progress,snapshots,in,progress,event,state,custom,snapshots,in,progress,type,map,snapshot,map,shard,id,index,shard,snapshot,status,survivors,new,hash,map,for,map,entry,snapshot,map,shard,id,index,shard,snapshot,status,entry,shard,snapshots,entry,set,final,snapshot,snapshot,entry,get,key,if,snapshots,in,progress,null,snapshots,in,progress,snapshot,snapshot,null,survivors,put,entry,get,key,entry,get,value,else,for,index,shard,snapshot,status,snapshot,status,entry,get,value,values,snapshot,status,abort,if,not,completed,snapshot,has,been,removed,in,cluster,state,aborting,map,snapshot,map,shard,id,index,shard,snapshot,status,new,snapshots,new,hash,map,final,string,local,node,id,event,state,nodes,get,local,node,id,final,map,snapshot,map,string,index,id,snapshot,indices,new,hash,map,if,snapshots,in,progress,null,for,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,snapshot,indices,put,entry,snapshot,entry,indices,stream,collect,collectors,to,map,index,id,get,name,function,identity,if,entry,state,state,started,map,shard,id,index,shard,snapshot,status,started,shards,new,hash,map,map,shard,id,index,shard,snapshot,status,snapshot,shards,shard,snapshots,get,entry,snapshot,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,shards,if,local,node,id,equals,shard,value,node,id,if,shard,value,state,state,init,snapshot,shards,null,snapshot,shards,contains,key,shard,key,logger,trace,adding,shard,to,the,queue,shard,key,started,shards,put,shard,key,index,shard,snapshot,status,new,initializing,if,started,shards,is,empty,new,snapshots,put,entry,snapshot,started,shards,if,snapshot,shards,null,map,shard,id,index,shard,snapshot,status,shards,new,hash,map,shards,put,all,snapshot,shards,shards,put,all,started,shards,survivors,put,entry,snapshot,unmodifiable,map,shards,else,survivors,put,entry,snapshot,unmodifiable,map,started,shards,else,if,entry,state,state,aborted,map,shard,id,index,shard,snapshot,status,snapshot,shards,shard,snapshots,get,entry,snapshot,if,snapshot,shards,null,final,string,failure,snapshot,has,been,aborted,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,shards,final,index,shard,snapshot,status,snapshot,status,snapshot,shards,get,shard,key,if,snapshot,status,null,final,index,shard,snapshot,status,copy,last,snapshot,status,snapshot,status,abort,if,not,completed,failure,final,stage,stage,last,snapshot,status,get,stage,if,stage,stage,finalize,logger,debug,trying,to,cancel,snapshot,on,shard,that,is,finalizing,letting,it,finish,entry,snapshot,shard,key,else,if,stage,stage,done,logger,debug,trying,to,cancel,snapshot,on,the,shard,that,is,already,done,updating,status,on,the,master,entry,snapshot,shard,key,notify,successful,snapshot,shard,entry,snapshot,shard,key,local,node,id,else,if,stage,stage,failure,logger,debug,trying,to,cancel,snapshot,on,the,shard,that,has,already,failed,updating,status,on,the,master,entry,snapshot,shard,key,notify,failed,snapshot,shard,entry,snapshot,shard,key,local,node,id,last,snapshot,status,get,failure,shutdown,lock,lock,try,shard,snapshots,unmodifiable,map,survivors,if,shard,snapshots,is,empty,shutdown,condition,signal,all,finally,shutdown,lock,unlock,if,new,snapshots,is,empty,false,executor,executor,thread,pool,executor,thread,pool,names,snapshot,for,final,map,entry,snapshot,map,shard,id,index,shard,snapshot,status,entry,new,snapshots,entry,set,final,snapshot,snapshot,entry,get,key,final,map,string,index,id,indices,map,snapshot,indices,get,snapshot,assert,indices,map,null,for,final,map,entry,shard,id,index,shard,snapshot,status,shard,entry,entry,get,value,entry,set,final,shard,id,shard,id,shard,entry,get,key,final,index,shard,index,shard,indices,service,index,service,safe,shard,id,get,index,get,shard,or,null,shard,id,id,final,index,id,index,id,indices,map,get,shard,id,get,index,name,assert,index,id,null,executor,execute,new,abstract,runnable,final,set,once,exception,failure,new,set,once,override,public,void,do,run,snapshot,index,shard,snapshot,index,id,shard,entry,get,value,override,public,void,on,failure,exception,e,logger,warn,new,parameterized,message,failed,to,snapshot,shard,shard,id,snapshot,e,failure,set,e,override,public,void,on,rejection,exception,e,failure,set,e,override,public,void,on,after,final,exception,exception,failure,get,if,exception,null,notify,failed,snapshot,shard,snapshot,shard,id,local,node,id,exceptions,helper,detailed,message,exception,else,notify,successful,snapshot,shard,snapshot,shard,id,local,node,id
SnapshotShardsService -> private void processIndexShardSnapshots(ClusterChangedEvent event);1543851569;Checks if any new shards should be snapshotted on this node__@param event cluster state changed event;private void processIndexShardSnapshots(ClusterChangedEvent event) {_        SnapshotsInProgress snapshotsInProgress = event.state().custom(SnapshotsInProgress.TYPE)__        Map<Snapshot, Map<ShardId, IndexShardSnapshotStatus>> survivors = new HashMap<>()__        _        for (Map.Entry<Snapshot, Map<ShardId, IndexShardSnapshotStatus>> entry : shardSnapshots.entrySet()) {_            final Snapshot snapshot = entry.getKey()__            if (snapshotsInProgress != null && snapshotsInProgress.snapshot(snapshot) != null) {_                survivors.put(entry.getKey(), entry.getValue())__            } else {_                _                _                _                _                for (IndexShardSnapshotStatus snapshotStatus : entry.getValue().values()) {_                    snapshotStatus.abortIfNotCompleted("snapshot has been removed in cluster state, aborting")__                }_            }_        }__        _        _        Map<Snapshot, Map<ShardId, IndexShardSnapshotStatus>> newSnapshots = new HashMap<>()__        _        final String localNodeId = event.state().nodes().getLocalNodeId()__        final Map<Snapshot, Map<String, IndexId>> snapshotIndices = new HashMap<>()__        if (snapshotsInProgress != null) {_            for (SnapshotsInProgress.Entry entry : snapshotsInProgress.entries()) {_                snapshotIndices.put(entry.snapshot(),_                                    entry.indices().stream().collect(Collectors.toMap(IndexId::getName, Function.identity())))__                if (entry.state() == State.STARTED) {_                    Map<ShardId, IndexShardSnapshotStatus> startedShards = new HashMap<>()__                    Map<ShardId, IndexShardSnapshotStatus> snapshotShards = shardSnapshots.get(entry.snapshot())__                    for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shard : entry.shards()) {_                        _                        if (localNodeId.equals(shard.value.nodeId())) {_                            if (shard.value.state() == State.INIT && (snapshotShards == null || !snapshotShards.containsKey(shard.key))) {_                                logger.trace("[{}] - Adding shard to the queue", shard.key)__                                startedShards.put(shard.key, IndexShardSnapshotStatus.newInitializing())__                            }_                        }_                    }_                    if (!startedShards.isEmpty()) {_                        newSnapshots.put(entry.snapshot(), startedShards)__                        if (snapshotShards != null) {_                            _                            Map<ShardId, IndexShardSnapshotStatus> shards = new HashMap<>()__                            _                            shards.putAll(snapshotShards)__                            _                            shards.putAll(startedShards)__                            survivors.put(entry.snapshot(), unmodifiableMap(shards))__                        } else {_                            _                            survivors.put(entry.snapshot(), unmodifiableMap(startedShards))__                        }_                    }_                } else if (entry.state() == State.ABORTED) {_                    _                    Map<ShardId, IndexShardSnapshotStatus> snapshotShards = shardSnapshots.get(entry.snapshot())__                    if (snapshotShards != null) {_                        final String failure = "snapshot has been aborted"__                        for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shard : entry.shards()) {__                            final IndexShardSnapshotStatus snapshotStatus = snapshotShards.get(shard.key)__                            if (snapshotStatus != null) {_                                final IndexShardSnapshotStatus.Copy lastSnapshotStatus = snapshotStatus.abortIfNotCompleted(failure)__                                final Stage stage = lastSnapshotStatus.getStage()__                                if (stage == Stage.FINALIZE) {_                                    logger.debug("[{}] trying to cancel snapshot on shard [{}] that is finalizing, " +_                                        "letting it finish", entry.snapshot(), shard.key)___                                } else if (stage == Stage.DONE) {_                                    logger.debug("[{}] trying to cancel snapshot on the shard [{}] that is already done, " +_                                        "updating status on the master", entry.snapshot(), shard.key)__                                    notifySuccessfulSnapshotShard(entry.snapshot(), shard.key, localNodeId)___                                }  else if (stage == Stage.FAILURE) {_                                    logger.debug("[{}] trying to cancel snapshot on the shard [{}] that has already failed, " +_                                        "updating status on the master", entry.snapshot(), shard.key)__                                    notifyFailedSnapshotShard(entry.snapshot(), shard.key, localNodeId, lastSnapshotStatus.getFailure())__                                }_                            }_                        }_                    }_                }_            }_        }__        _        _        shutdownLock.lock()__        try {_            shardSnapshots = unmodifiableMap(survivors)__            if (shardSnapshots.isEmpty()) {_                _                shutdownCondition.signalAll()__            }_        } finally {_            shutdownLock.unlock()__        }__        _        if (newSnapshots.isEmpty() == false) {_            Executor executor = threadPool.executor(ThreadPool.Names.SNAPSHOT)__            for (final Map.Entry<Snapshot, Map<ShardId, IndexShardSnapshotStatus>> entry : newSnapshots.entrySet()) {_                final Snapshot snapshot = entry.getKey()__                final Map<String, IndexId> indicesMap = snapshotIndices.get(snapshot)__                assert indicesMap != null___                for (final Map.Entry<ShardId, IndexShardSnapshotStatus> shardEntry : entry.getValue().entrySet()) {_                    final ShardId shardId = shardEntry.getKey()__                    final IndexId indexId = indicesMap.get(shardId.getIndexName())__                    executor.execute(new AbstractRunnable() {__                        final SetOnce<Exception> failure = new SetOnce<>()___                        @Override_                        public void doRun() {_                            final IndexShard indexShard = indicesService.indexServiceSafe(shardId.getIndex()).getShardOrNull(shardId.id())__                            assert indexId != null__                            snapshot(indexShard, snapshot, indexId, shardEntry.getValue())__                        }__                        @Override_                        public void onFailure(Exception e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to snapshot shard", shardId, snapshot), e)__                            failure.set(e)__                        }__                        @Override_                        public void onRejection(Exception e) {_                            failure.set(e)__                        }__                        @Override_                        public void onAfter() {_                            final Exception exception = failure.get()__                            if (exception != null) {_                                notifyFailedSnapshotShard(snapshot, shardId, localNodeId, ExceptionsHelper.detailedMessage(exception))__                            } else {_                                notifySuccessfulSnapshotShard(snapshot, shardId, localNodeId)__                            }_                        }_                    })__                }_            }_        }_    };checks,if,any,new,shards,should,be,snapshotted,on,this,node,param,event,cluster,state,changed,event;private,void,process,index,shard,snapshots,cluster,changed,event,event,snapshots,in,progress,snapshots,in,progress,event,state,custom,snapshots,in,progress,type,map,snapshot,map,shard,id,index,shard,snapshot,status,survivors,new,hash,map,for,map,entry,snapshot,map,shard,id,index,shard,snapshot,status,entry,shard,snapshots,entry,set,final,snapshot,snapshot,entry,get,key,if,snapshots,in,progress,null,snapshots,in,progress,snapshot,snapshot,null,survivors,put,entry,get,key,entry,get,value,else,for,index,shard,snapshot,status,snapshot,status,entry,get,value,values,snapshot,status,abort,if,not,completed,snapshot,has,been,removed,in,cluster,state,aborting,map,snapshot,map,shard,id,index,shard,snapshot,status,new,snapshots,new,hash,map,final,string,local,node,id,event,state,nodes,get,local,node,id,final,map,snapshot,map,string,index,id,snapshot,indices,new,hash,map,if,snapshots,in,progress,null,for,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,snapshot,indices,put,entry,snapshot,entry,indices,stream,collect,collectors,to,map,index,id,get,name,function,identity,if,entry,state,state,started,map,shard,id,index,shard,snapshot,status,started,shards,new,hash,map,map,shard,id,index,shard,snapshot,status,snapshot,shards,shard,snapshots,get,entry,snapshot,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,shards,if,local,node,id,equals,shard,value,node,id,if,shard,value,state,state,init,snapshot,shards,null,snapshot,shards,contains,key,shard,key,logger,trace,adding,shard,to,the,queue,shard,key,started,shards,put,shard,key,index,shard,snapshot,status,new,initializing,if,started,shards,is,empty,new,snapshots,put,entry,snapshot,started,shards,if,snapshot,shards,null,map,shard,id,index,shard,snapshot,status,shards,new,hash,map,shards,put,all,snapshot,shards,shards,put,all,started,shards,survivors,put,entry,snapshot,unmodifiable,map,shards,else,survivors,put,entry,snapshot,unmodifiable,map,started,shards,else,if,entry,state,state,aborted,map,shard,id,index,shard,snapshot,status,snapshot,shards,shard,snapshots,get,entry,snapshot,if,snapshot,shards,null,final,string,failure,snapshot,has,been,aborted,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,shards,final,index,shard,snapshot,status,snapshot,status,snapshot,shards,get,shard,key,if,snapshot,status,null,final,index,shard,snapshot,status,copy,last,snapshot,status,snapshot,status,abort,if,not,completed,failure,final,stage,stage,last,snapshot,status,get,stage,if,stage,stage,finalize,logger,debug,trying,to,cancel,snapshot,on,shard,that,is,finalizing,letting,it,finish,entry,snapshot,shard,key,else,if,stage,stage,done,logger,debug,trying,to,cancel,snapshot,on,the,shard,that,is,already,done,updating,status,on,the,master,entry,snapshot,shard,key,notify,successful,snapshot,shard,entry,snapshot,shard,key,local,node,id,else,if,stage,stage,failure,logger,debug,trying,to,cancel,snapshot,on,the,shard,that,has,already,failed,updating,status,on,the,master,entry,snapshot,shard,key,notify,failed,snapshot,shard,entry,snapshot,shard,key,local,node,id,last,snapshot,status,get,failure,shutdown,lock,lock,try,shard,snapshots,unmodifiable,map,survivors,if,shard,snapshots,is,empty,shutdown,condition,signal,all,finally,shutdown,lock,unlock,if,new,snapshots,is,empty,false,executor,executor,thread,pool,executor,thread,pool,names,snapshot,for,final,map,entry,snapshot,map,shard,id,index,shard,snapshot,status,entry,new,snapshots,entry,set,final,snapshot,snapshot,entry,get,key,final,map,string,index,id,indices,map,snapshot,indices,get,snapshot,assert,indices,map,null,for,final,map,entry,shard,id,index,shard,snapshot,status,shard,entry,entry,get,value,entry,set,final,shard,id,shard,id,shard,entry,get,key,final,index,id,index,id,indices,map,get,shard,id,get,index,name,executor,execute,new,abstract,runnable,final,set,once,exception,failure,new,set,once,override,public,void,do,run,final,index,shard,index,shard,indices,service,index,service,safe,shard,id,get,index,get,shard,or,null,shard,id,id,assert,index,id,null,snapshot,index,shard,snapshot,index,id,shard,entry,get,value,override,public,void,on,failure,exception,e,logger,warn,new,parameterized,message,failed,to,snapshot,shard,shard,id,snapshot,e,failure,set,e,override,public,void,on,rejection,exception,e,failure,set,e,override,public,void,on,after,final,exception,exception,failure,get,if,exception,null,notify,failed,snapshot,shard,snapshot,shard,id,local,node,id,exceptions,helper,detailed,message,exception,else,notify,successful,snapshot,shard,snapshot,shard,id,local,node,id
SnapshotShardsService -> private void processIndexShardSnapshots(ClusterChangedEvent event);1545215361;Checks if any new shards should be snapshotted on this node__@param event cluster state changed event;private void processIndexShardSnapshots(ClusterChangedEvent event) {_        SnapshotsInProgress snapshotsInProgress = event.state().custom(SnapshotsInProgress.TYPE)__        Map<Snapshot, Map<ShardId, IndexShardSnapshotStatus>> survivors = new HashMap<>()__        _        for (Map.Entry<Snapshot, Map<ShardId, IndexShardSnapshotStatus>> entry : shardSnapshots.entrySet()) {_            final Snapshot snapshot = entry.getKey()__            if (snapshotsInProgress != null && snapshotsInProgress.snapshot(snapshot) != null) {_                survivors.put(entry.getKey(), entry.getValue())__            } else {_                _                _                _                _                for (IndexShardSnapshotStatus snapshotStatus : entry.getValue().values()) {_                    snapshotStatus.abortIfNotCompleted("snapshot has been removed in cluster state, aborting")__                }_            }_        }__        _        _        Map<Snapshot, Map<ShardId, IndexShardSnapshotStatus>> newSnapshots = new HashMap<>()__        _        final String localNodeId = event.state().nodes().getLocalNodeId()__        final Map<Snapshot, Map<String, IndexId>> snapshotIndices = new HashMap<>()__        if (snapshotsInProgress != null) {_            for (SnapshotsInProgress.Entry entry : snapshotsInProgress.entries()) {_                snapshotIndices.put(entry.snapshot(),_                                    entry.indices().stream().collect(Collectors.toMap(IndexId::getName, Function.identity())))__                if (entry.state() == State.STARTED) {_                    Map<ShardId, IndexShardSnapshotStatus> startedShards = new HashMap<>()__                    Map<ShardId, IndexShardSnapshotStatus> snapshotShards = shardSnapshots.get(entry.snapshot())__                    for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shard : entry.shards()) {_                        _                        if (localNodeId.equals(shard.value.nodeId())) {_                            if (shard.value.state() == State.INIT && (snapshotShards == null || !snapshotShards.containsKey(shard.key))) {_                                logger.trace("[{}] - Adding shard to the queue", shard.key)__                                startedShards.put(shard.key, IndexShardSnapshotStatus.newInitializing())__                            }_                        }_                    }_                    if (!startedShards.isEmpty()) {_                        newSnapshots.put(entry.snapshot(), startedShards)__                        if (snapshotShards != null) {_                            _                            Map<ShardId, IndexShardSnapshotStatus> shards = new HashMap<>()__                            _                            shards.putAll(snapshotShards)__                            _                            shards.putAll(startedShards)__                            survivors.put(entry.snapshot(), unmodifiableMap(shards))__                        } else {_                            _                            survivors.put(entry.snapshot(), unmodifiableMap(startedShards))__                        }_                    }_                } else if (entry.state() == State.ABORTED) {_                    _                    Map<ShardId, IndexShardSnapshotStatus> snapshotShards = shardSnapshots.get(entry.snapshot())__                    if (snapshotShards != null) {_                        final String failure = "snapshot has been aborted"__                        for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shard : entry.shards()) {__                            final IndexShardSnapshotStatus snapshotStatus = snapshotShards.get(shard.key)__                            if (snapshotStatus != null) {_                                final IndexShardSnapshotStatus.Copy lastSnapshotStatus = snapshotStatus.abortIfNotCompleted(failure)__                                final Stage stage = lastSnapshotStatus.getStage()__                                if (stage == Stage.FINALIZE) {_                                    logger.debug("[{}] trying to cancel snapshot on shard [{}] that is finalizing, " +_                                        "letting it finish", entry.snapshot(), shard.key)___                                } else if (stage == Stage.DONE) {_                                    logger.debug("[{}] trying to cancel snapshot on the shard [{}] that is already done, " +_                                        "updating status on the master", entry.snapshot(), shard.key)__                                    notifySuccessfulSnapshotShard(entry.snapshot(), shard.key, localNodeId)___                                }  else if (stage == Stage.FAILURE) {_                                    logger.debug("[{}] trying to cancel snapshot on the shard [{}] that has already failed, " +_                                        "updating status on the master", entry.snapshot(), shard.key)__                                    notifyFailedSnapshotShard(entry.snapshot(), shard.key, localNodeId, lastSnapshotStatus.getFailure())__                                }_                            }_                        }_                    }_                }_            }_        }__        _        _        shutdownLock.lock()__        try {_            shardSnapshots = unmodifiableMap(survivors)__            if (shardSnapshots.isEmpty()) {_                _                shutdownCondition.signalAll()__            }_        } finally {_            shutdownLock.unlock()__        }__        _        if (newSnapshots.isEmpty() == false) {_            Executor executor = threadPool.executor(ThreadPool.Names.SNAPSHOT)__            for (final Map.Entry<Snapshot, Map<ShardId, IndexShardSnapshotStatus>> entry : newSnapshots.entrySet()) {_                final Snapshot snapshot = entry.getKey()__                final Map<String, IndexId> indicesMap = snapshotIndices.get(snapshot)__                assert indicesMap != null___                for (final Map.Entry<ShardId, IndexShardSnapshotStatus> shardEntry : entry.getValue().entrySet()) {_                    final ShardId shardId = shardEntry.getKey()__                    final IndexId indexId = indicesMap.get(shardId.getIndexName())__                    executor.execute(new AbstractRunnable() {__                        final SetOnce<Exception> failure = new SetOnce<>()___                        @Override_                        public void doRun() {_                            final IndexShard indexShard = indicesService.indexServiceSafe(shardId.getIndex()).getShardOrNull(shardId.id())__                            assert indexId != null__                            snapshot(indexShard, snapshot, indexId, shardEntry.getValue())__                        }__                        @Override_                        public void onFailure(Exception e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to snapshot shard",_                                                                        shardId, snapshot), e)__                            failure.set(e)__                        }__                        @Override_                        public void onRejection(Exception e) {_                            failure.set(e)__                        }__                        @Override_                        public void onAfter() {_                            final Exception exception = failure.get()__                            if (exception != null) {_                                notifyFailedSnapshotShard(snapshot, shardId, localNodeId, ExceptionsHelper.detailedMessage(exception))__                            } else {_                                notifySuccessfulSnapshotShard(snapshot, shardId, localNodeId)__                            }_                        }_                    })__                }_            }_        }_    };checks,if,any,new,shards,should,be,snapshotted,on,this,node,param,event,cluster,state,changed,event;private,void,process,index,shard,snapshots,cluster,changed,event,event,snapshots,in,progress,snapshots,in,progress,event,state,custom,snapshots,in,progress,type,map,snapshot,map,shard,id,index,shard,snapshot,status,survivors,new,hash,map,for,map,entry,snapshot,map,shard,id,index,shard,snapshot,status,entry,shard,snapshots,entry,set,final,snapshot,snapshot,entry,get,key,if,snapshots,in,progress,null,snapshots,in,progress,snapshot,snapshot,null,survivors,put,entry,get,key,entry,get,value,else,for,index,shard,snapshot,status,snapshot,status,entry,get,value,values,snapshot,status,abort,if,not,completed,snapshot,has,been,removed,in,cluster,state,aborting,map,snapshot,map,shard,id,index,shard,snapshot,status,new,snapshots,new,hash,map,final,string,local,node,id,event,state,nodes,get,local,node,id,final,map,snapshot,map,string,index,id,snapshot,indices,new,hash,map,if,snapshots,in,progress,null,for,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,snapshot,indices,put,entry,snapshot,entry,indices,stream,collect,collectors,to,map,index,id,get,name,function,identity,if,entry,state,state,started,map,shard,id,index,shard,snapshot,status,started,shards,new,hash,map,map,shard,id,index,shard,snapshot,status,snapshot,shards,shard,snapshots,get,entry,snapshot,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,shards,if,local,node,id,equals,shard,value,node,id,if,shard,value,state,state,init,snapshot,shards,null,snapshot,shards,contains,key,shard,key,logger,trace,adding,shard,to,the,queue,shard,key,started,shards,put,shard,key,index,shard,snapshot,status,new,initializing,if,started,shards,is,empty,new,snapshots,put,entry,snapshot,started,shards,if,snapshot,shards,null,map,shard,id,index,shard,snapshot,status,shards,new,hash,map,shards,put,all,snapshot,shards,shards,put,all,started,shards,survivors,put,entry,snapshot,unmodifiable,map,shards,else,survivors,put,entry,snapshot,unmodifiable,map,started,shards,else,if,entry,state,state,aborted,map,shard,id,index,shard,snapshot,status,snapshot,shards,shard,snapshots,get,entry,snapshot,if,snapshot,shards,null,final,string,failure,snapshot,has,been,aborted,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,shards,final,index,shard,snapshot,status,snapshot,status,snapshot,shards,get,shard,key,if,snapshot,status,null,final,index,shard,snapshot,status,copy,last,snapshot,status,snapshot,status,abort,if,not,completed,failure,final,stage,stage,last,snapshot,status,get,stage,if,stage,stage,finalize,logger,debug,trying,to,cancel,snapshot,on,shard,that,is,finalizing,letting,it,finish,entry,snapshot,shard,key,else,if,stage,stage,done,logger,debug,trying,to,cancel,snapshot,on,the,shard,that,is,already,done,updating,status,on,the,master,entry,snapshot,shard,key,notify,successful,snapshot,shard,entry,snapshot,shard,key,local,node,id,else,if,stage,stage,failure,logger,debug,trying,to,cancel,snapshot,on,the,shard,that,has,already,failed,updating,status,on,the,master,entry,snapshot,shard,key,notify,failed,snapshot,shard,entry,snapshot,shard,key,local,node,id,last,snapshot,status,get,failure,shutdown,lock,lock,try,shard,snapshots,unmodifiable,map,survivors,if,shard,snapshots,is,empty,shutdown,condition,signal,all,finally,shutdown,lock,unlock,if,new,snapshots,is,empty,false,executor,executor,thread,pool,executor,thread,pool,names,snapshot,for,final,map,entry,snapshot,map,shard,id,index,shard,snapshot,status,entry,new,snapshots,entry,set,final,snapshot,snapshot,entry,get,key,final,map,string,index,id,indices,map,snapshot,indices,get,snapshot,assert,indices,map,null,for,final,map,entry,shard,id,index,shard,snapshot,status,shard,entry,entry,get,value,entry,set,final,shard,id,shard,id,shard,entry,get,key,final,index,id,index,id,indices,map,get,shard,id,get,index,name,executor,execute,new,abstract,runnable,final,set,once,exception,failure,new,set,once,override,public,void,do,run,final,index,shard,index,shard,indices,service,index,service,safe,shard,id,get,index,get,shard,or,null,shard,id,id,assert,index,id,null,snapshot,index,shard,snapshot,index,id,shard,entry,get,value,override,public,void,on,failure,exception,e,logger,warn,new,parameterized,message,failed,to,snapshot,shard,shard,id,snapshot,e,failure,set,e,override,public,void,on,rejection,exception,e,failure,set,e,override,public,void,on,after,final,exception,exception,failure,get,if,exception,null,notify,failed,snapshot,shard,snapshot,shard,id,local,node,id,exceptions,helper,detailed,message,exception,else,notify,successful,snapshot,shard,snapshot,shard,id,local,node,id
SnapshotShardsService -> private void processIndexShardSnapshots(ClusterChangedEvent event);1547023537;Checks if any new shards should be snapshotted on this node__@param event cluster state changed event;private void processIndexShardSnapshots(ClusterChangedEvent event) {_        SnapshotsInProgress snapshotsInProgress = event.state().custom(SnapshotsInProgress.TYPE)__        Map<Snapshot, Map<ShardId, IndexShardSnapshotStatus>> survivors = new HashMap<>()__        _        for (Map.Entry<Snapshot, Map<ShardId, IndexShardSnapshotStatus>> entry : shardSnapshots.entrySet()) {_            final Snapshot snapshot = entry.getKey()__            if (snapshotsInProgress != null && snapshotsInProgress.snapshot(snapshot) != null) {_                survivors.put(entry.getKey(), entry.getValue())__            } else {_                _                _                _                _                for (IndexShardSnapshotStatus snapshotStatus : entry.getValue().values()) {_                    snapshotStatus.abortIfNotCompleted("snapshot has been removed in cluster state, aborting")__                }_            }_        }__        _        _        Map<Snapshot, Map<ShardId, IndexShardSnapshotStatus>> newSnapshots = new HashMap<>()__        _        final String localNodeId = event.state().nodes().getLocalNodeId()__        final Map<Snapshot, Map<String, IndexId>> snapshotIndices = new HashMap<>()__        if (snapshotsInProgress != null) {_            for (SnapshotsInProgress.Entry entry : snapshotsInProgress.entries()) {_                snapshotIndices.put(entry.snapshot(),_                                    entry.indices().stream().collect(Collectors.toMap(IndexId::getName, Function.identity())))__                if (entry.state() == State.STARTED) {_                    Map<ShardId, IndexShardSnapshotStatus> startedShards = new HashMap<>()__                    Map<ShardId, IndexShardSnapshotStatus> snapshotShards = shardSnapshots.get(entry.snapshot())__                    for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shard : entry.shards()) {_                        _                        if (localNodeId.equals(shard.value.nodeId())) {_                            if (shard.value.state() == State.INIT && (snapshotShards == null || !snapshotShards.containsKey(shard.key))) {_                                logger.trace("[{}] - Adding shard to the queue", shard.key)__                                startedShards.put(shard.key, IndexShardSnapshotStatus.newInitializing())__                            }_                        }_                    }_                    if (!startedShards.isEmpty()) {_                        newSnapshots.put(entry.snapshot(), startedShards)__                        if (snapshotShards != null) {_                            _                            Map<ShardId, IndexShardSnapshotStatus> shards = new HashMap<>()__                            _                            shards.putAll(snapshotShards)__                            _                            shards.putAll(startedShards)__                            survivors.put(entry.snapshot(), unmodifiableMap(shards))__                        } else {_                            _                            survivors.put(entry.snapshot(), unmodifiableMap(startedShards))__                        }_                    }_                } else if (entry.state() == State.ABORTED) {_                    _                    Map<ShardId, IndexShardSnapshotStatus> snapshotShards = shardSnapshots.get(entry.snapshot())__                    if (snapshotShards != null) {_                        final String failure = "snapshot has been aborted"__                        for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shard : entry.shards()) {__                            final IndexShardSnapshotStatus snapshotStatus = snapshotShards.get(shard.key)__                            if (snapshotStatus != null) {_                                final IndexShardSnapshotStatus.Copy lastSnapshotStatus = snapshotStatus.abortIfNotCompleted(failure)__                                final Stage stage = lastSnapshotStatus.getStage()__                                if (stage == Stage.FINALIZE) {_                                    logger.debug("[{}] trying to cancel snapshot on shard [{}] that is finalizing, " +_                                        "letting it finish", entry.snapshot(), shard.key)___                                } else if (stage == Stage.DONE) {_                                    logger.debug("[{}] trying to cancel snapshot on the shard [{}] that is already done, " +_                                        "updating status on the master", entry.snapshot(), shard.key)__                                    notifySuccessfulSnapshotShard(entry.snapshot(), shard.key, localNodeId)___                                }  else if (stage == Stage.FAILURE) {_                                    logger.debug("[{}] trying to cancel snapshot on the shard [{}] that has already failed, " +_                                        "updating status on the master", entry.snapshot(), shard.key)__                                    notifyFailedSnapshotShard(entry.snapshot(), shard.key, localNodeId, lastSnapshotStatus.getFailure())__                                }_                            }_                        }_                    }_                }_            }_        }__        _        _        shutdownLock.lock()__        try {_            shardSnapshots = unmodifiableMap(survivors)__            if (shardSnapshots.isEmpty()) {_                _                shutdownCondition.signalAll()__            }_        } finally {_            shutdownLock.unlock()__        }__        _        if (newSnapshots.isEmpty() == false) {_            Executor executor = threadPool.executor(ThreadPool.Names.SNAPSHOT)__            for (final Map.Entry<Snapshot, Map<ShardId, IndexShardSnapshotStatus>> entry : newSnapshots.entrySet()) {_                final Snapshot snapshot = entry.getKey()__                final Map<String, IndexId> indicesMap = snapshotIndices.get(snapshot)__                assert indicesMap != null___                for (final Map.Entry<ShardId, IndexShardSnapshotStatus> shardEntry : entry.getValue().entrySet()) {_                    final ShardId shardId = shardEntry.getKey()__                    final IndexId indexId = indicesMap.get(shardId.getIndexName())__                    executor.execute(new AbstractRunnable() {__                        final SetOnce<Exception> failure = new SetOnce<>()___                        @Override_                        public void doRun() {_                            final IndexShard indexShard = indicesService.indexServiceSafe(shardId.getIndex()).getShardOrNull(shardId.id())__                            assert indexId != null__                            snapshot(indexShard, snapshot, indexId, shardEntry.getValue())__                        }__                        @Override_                        public void onFailure(Exception e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to snapshot shard",_                                                                        shardId, snapshot), e)__                            failure.set(e)__                        }__                        @Override_                        public void onRejection(Exception e) {_                            failure.set(e)__                        }__                        @Override_                        public void onAfter() {_                            final Exception exception = failure.get()__                            if (exception != null) {_                                notifyFailedSnapshotShard(snapshot, shardId, localNodeId, ExceptionsHelper.detailedMessage(exception))__                            } else {_                                notifySuccessfulSnapshotShard(snapshot, shardId, localNodeId)__                            }_                        }_                    })__                }_            }_        }_    };checks,if,any,new,shards,should,be,snapshotted,on,this,node,param,event,cluster,state,changed,event;private,void,process,index,shard,snapshots,cluster,changed,event,event,snapshots,in,progress,snapshots,in,progress,event,state,custom,snapshots,in,progress,type,map,snapshot,map,shard,id,index,shard,snapshot,status,survivors,new,hash,map,for,map,entry,snapshot,map,shard,id,index,shard,snapshot,status,entry,shard,snapshots,entry,set,final,snapshot,snapshot,entry,get,key,if,snapshots,in,progress,null,snapshots,in,progress,snapshot,snapshot,null,survivors,put,entry,get,key,entry,get,value,else,for,index,shard,snapshot,status,snapshot,status,entry,get,value,values,snapshot,status,abort,if,not,completed,snapshot,has,been,removed,in,cluster,state,aborting,map,snapshot,map,shard,id,index,shard,snapshot,status,new,snapshots,new,hash,map,final,string,local,node,id,event,state,nodes,get,local,node,id,final,map,snapshot,map,string,index,id,snapshot,indices,new,hash,map,if,snapshots,in,progress,null,for,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,snapshot,indices,put,entry,snapshot,entry,indices,stream,collect,collectors,to,map,index,id,get,name,function,identity,if,entry,state,state,started,map,shard,id,index,shard,snapshot,status,started,shards,new,hash,map,map,shard,id,index,shard,snapshot,status,snapshot,shards,shard,snapshots,get,entry,snapshot,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,shards,if,local,node,id,equals,shard,value,node,id,if,shard,value,state,state,init,snapshot,shards,null,snapshot,shards,contains,key,shard,key,logger,trace,adding,shard,to,the,queue,shard,key,started,shards,put,shard,key,index,shard,snapshot,status,new,initializing,if,started,shards,is,empty,new,snapshots,put,entry,snapshot,started,shards,if,snapshot,shards,null,map,shard,id,index,shard,snapshot,status,shards,new,hash,map,shards,put,all,snapshot,shards,shards,put,all,started,shards,survivors,put,entry,snapshot,unmodifiable,map,shards,else,survivors,put,entry,snapshot,unmodifiable,map,started,shards,else,if,entry,state,state,aborted,map,shard,id,index,shard,snapshot,status,snapshot,shards,shard,snapshots,get,entry,snapshot,if,snapshot,shards,null,final,string,failure,snapshot,has,been,aborted,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,shards,final,index,shard,snapshot,status,snapshot,status,snapshot,shards,get,shard,key,if,snapshot,status,null,final,index,shard,snapshot,status,copy,last,snapshot,status,snapshot,status,abort,if,not,completed,failure,final,stage,stage,last,snapshot,status,get,stage,if,stage,stage,finalize,logger,debug,trying,to,cancel,snapshot,on,shard,that,is,finalizing,letting,it,finish,entry,snapshot,shard,key,else,if,stage,stage,done,logger,debug,trying,to,cancel,snapshot,on,the,shard,that,is,already,done,updating,status,on,the,master,entry,snapshot,shard,key,notify,successful,snapshot,shard,entry,snapshot,shard,key,local,node,id,else,if,stage,stage,failure,logger,debug,trying,to,cancel,snapshot,on,the,shard,that,has,already,failed,updating,status,on,the,master,entry,snapshot,shard,key,notify,failed,snapshot,shard,entry,snapshot,shard,key,local,node,id,last,snapshot,status,get,failure,shutdown,lock,lock,try,shard,snapshots,unmodifiable,map,survivors,if,shard,snapshots,is,empty,shutdown,condition,signal,all,finally,shutdown,lock,unlock,if,new,snapshots,is,empty,false,executor,executor,thread,pool,executor,thread,pool,names,snapshot,for,final,map,entry,snapshot,map,shard,id,index,shard,snapshot,status,entry,new,snapshots,entry,set,final,snapshot,snapshot,entry,get,key,final,map,string,index,id,indices,map,snapshot,indices,get,snapshot,assert,indices,map,null,for,final,map,entry,shard,id,index,shard,snapshot,status,shard,entry,entry,get,value,entry,set,final,shard,id,shard,id,shard,entry,get,key,final,index,id,index,id,indices,map,get,shard,id,get,index,name,executor,execute,new,abstract,runnable,final,set,once,exception,failure,new,set,once,override,public,void,do,run,final,index,shard,index,shard,indices,service,index,service,safe,shard,id,get,index,get,shard,or,null,shard,id,id,assert,index,id,null,snapshot,index,shard,snapshot,index,id,shard,entry,get,value,override,public,void,on,failure,exception,e,logger,warn,new,parameterized,message,failed,to,snapshot,shard,shard,id,snapshot,e,failure,set,e,override,public,void,on,rejection,exception,e,failure,set,e,override,public,void,on,after,final,exception,exception,failure,get,if,exception,null,notify,failed,snapshot,shard,snapshot,shard,id,local,node,id,exceptions,helper,detailed,message,exception,else,notify,successful,snapshot,shard,snapshot,shard,id,local,node,id
SnapshotShardsService -> private void processIndexShardSnapshots(ClusterChangedEvent event);1547625930;Checks if any new shards should be snapshotted on this node__@param event cluster state changed event;private void processIndexShardSnapshots(ClusterChangedEvent event) {_        SnapshotsInProgress snapshotsInProgress = event.state().custom(SnapshotsInProgress.TYPE)__        Map<Snapshot, Map<ShardId, IndexShardSnapshotStatus>> survivors = new HashMap<>()__        _        for (Map.Entry<Snapshot, Map<ShardId, IndexShardSnapshotStatus>> entry : shardSnapshots.entrySet()) {_            final Snapshot snapshot = entry.getKey()__            if (snapshotsInProgress != null && snapshotsInProgress.snapshot(snapshot) != null) {_                survivors.put(entry.getKey(), entry.getValue())__            } else {_                _                _                _                _                for (IndexShardSnapshotStatus snapshotStatus : entry.getValue().values()) {_                    snapshotStatus.abortIfNotCompleted("snapshot has been removed in cluster state, aborting")__                }_            }_        }__        _        _        Map<Snapshot, Map<ShardId, IndexShardSnapshotStatus>> newSnapshots = new HashMap<>()__        _        final String localNodeId = event.state().nodes().getLocalNodeId()__        final Map<Snapshot, Map<String, IndexId>> snapshotIndices = new HashMap<>()__        if (snapshotsInProgress != null) {_            for (SnapshotsInProgress.Entry entry : snapshotsInProgress.entries()) {_                snapshotIndices.put(entry.snapshot(),_                                    entry.indices().stream().collect(Collectors.toMap(IndexId::getName, Function.identity())))__                if (entry.state() == State.STARTED) {_                    Map<ShardId, IndexShardSnapshotStatus> startedShards = new HashMap<>()__                    Map<ShardId, IndexShardSnapshotStatus> snapshotShards = shardSnapshots.get(entry.snapshot())__                    for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shard : entry.shards()) {_                        _                        if (localNodeId.equals(shard.value.nodeId())) {_                            if (shard.value.state() == State.INIT && (snapshotShards == null || !snapshotShards.containsKey(shard.key))) {_                                logger.trace("[{}] - Adding shard to the queue", shard.key)__                                startedShards.put(shard.key, IndexShardSnapshotStatus.newInitializing())__                            }_                        }_                    }_                    if (!startedShards.isEmpty()) {_                        newSnapshots.put(entry.snapshot(), startedShards)__                        if (snapshotShards != null) {_                            _                            Map<ShardId, IndexShardSnapshotStatus> shards = new HashMap<>()__                            _                            shards.putAll(snapshotShards)__                            _                            shards.putAll(startedShards)__                            survivors.put(entry.snapshot(), unmodifiableMap(shards))__                        } else {_                            _                            survivors.put(entry.snapshot(), unmodifiableMap(startedShards))__                        }_                    }_                } else if (entry.state() == State.ABORTED) {_                    _                    Map<ShardId, IndexShardSnapshotStatus> snapshotShards = shardSnapshots.get(entry.snapshot())__                    if (snapshotShards != null) {_                        final String failure = "snapshot has been aborted"__                        for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shard : entry.shards()) {__                            final IndexShardSnapshotStatus snapshotStatus = snapshotShards.get(shard.key)__                            if (snapshotStatus != null) {_                                final IndexShardSnapshotStatus.Copy lastSnapshotStatus = snapshotStatus.abortIfNotCompleted(failure)__                                final Stage stage = lastSnapshotStatus.getStage()__                                if (stage == Stage.FINALIZE) {_                                    logger.debug("[{}] trying to cancel snapshot on shard [{}] that is finalizing, " +_                                        "letting it finish", entry.snapshot(), shard.key)___                                } else if (stage == Stage.DONE) {_                                    logger.debug("[{}] trying to cancel snapshot on the shard [{}] that is already done, " +_                                        "updating status on the master", entry.snapshot(), shard.key)__                                    notifySuccessfulSnapshotShard(entry.snapshot(), shard.key, localNodeId)___                                }  else if (stage == Stage.FAILURE) {_                                    logger.debug("[{}] trying to cancel snapshot on the shard [{}] that has already failed, " +_                                        "updating status on the master", entry.snapshot(), shard.key)__                                    notifyFailedSnapshotShard(entry.snapshot(), shard.key, localNodeId, lastSnapshotStatus.getFailure())__                                }_                            }_                        }_                    }_                }_            }_        }__        _        _        shutdownLock.lock()__        try {_            shardSnapshots = unmodifiableMap(survivors)__            if (shardSnapshots.isEmpty()) {_                _                shutdownCondition.signalAll()__            }_        } finally {_            shutdownLock.unlock()__        }__        _        if (newSnapshots.isEmpty() == false) {_            Executor executor = threadPool.executor(ThreadPool.Names.SNAPSHOT)__            for (final Map.Entry<Snapshot, Map<ShardId, IndexShardSnapshotStatus>> entry : newSnapshots.entrySet()) {_                final Snapshot snapshot = entry.getKey()__                final Map<String, IndexId> indicesMap = snapshotIndices.get(snapshot)__                assert indicesMap != null___                for (final Map.Entry<ShardId, IndexShardSnapshotStatus> shardEntry : entry.getValue().entrySet()) {_                    final ShardId shardId = shardEntry.getKey()__                    final IndexId indexId = indicesMap.get(shardId.getIndexName())__                    executor.execute(new AbstractRunnable() {__                        final SetOnce<Exception> failure = new SetOnce<>()___                        @Override_                        public void doRun() {_                            final IndexShard indexShard = indicesService.indexServiceSafe(shardId.getIndex()).getShardOrNull(shardId.id())__                            assert indexId != null__                            snapshot(indexShard, snapshot, indexId, shardEntry.getValue())__                        }__                        @Override_                        public void onFailure(Exception e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to snapshot shard",_                                                                        shardId, snapshot), e)__                            failure.set(e)__                        }__                        @Override_                        public void onRejection(Exception e) {_                            failure.set(e)__                        }__                        @Override_                        public void onAfter() {_                            final Exception exception = failure.get()__                            if (exception != null) {_                                notifyFailedSnapshotShard(snapshot, shardId, localNodeId, ExceptionsHelper.detailedMessage(exception))__                            } else {_                                notifySuccessfulSnapshotShard(snapshot, shardId, localNodeId)__                            }_                        }_                    })__                }_            }_        }_    };checks,if,any,new,shards,should,be,snapshotted,on,this,node,param,event,cluster,state,changed,event;private,void,process,index,shard,snapshots,cluster,changed,event,event,snapshots,in,progress,snapshots,in,progress,event,state,custom,snapshots,in,progress,type,map,snapshot,map,shard,id,index,shard,snapshot,status,survivors,new,hash,map,for,map,entry,snapshot,map,shard,id,index,shard,snapshot,status,entry,shard,snapshots,entry,set,final,snapshot,snapshot,entry,get,key,if,snapshots,in,progress,null,snapshots,in,progress,snapshot,snapshot,null,survivors,put,entry,get,key,entry,get,value,else,for,index,shard,snapshot,status,snapshot,status,entry,get,value,values,snapshot,status,abort,if,not,completed,snapshot,has,been,removed,in,cluster,state,aborting,map,snapshot,map,shard,id,index,shard,snapshot,status,new,snapshots,new,hash,map,final,string,local,node,id,event,state,nodes,get,local,node,id,final,map,snapshot,map,string,index,id,snapshot,indices,new,hash,map,if,snapshots,in,progress,null,for,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,snapshot,indices,put,entry,snapshot,entry,indices,stream,collect,collectors,to,map,index,id,get,name,function,identity,if,entry,state,state,started,map,shard,id,index,shard,snapshot,status,started,shards,new,hash,map,map,shard,id,index,shard,snapshot,status,snapshot,shards,shard,snapshots,get,entry,snapshot,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,shards,if,local,node,id,equals,shard,value,node,id,if,shard,value,state,state,init,snapshot,shards,null,snapshot,shards,contains,key,shard,key,logger,trace,adding,shard,to,the,queue,shard,key,started,shards,put,shard,key,index,shard,snapshot,status,new,initializing,if,started,shards,is,empty,new,snapshots,put,entry,snapshot,started,shards,if,snapshot,shards,null,map,shard,id,index,shard,snapshot,status,shards,new,hash,map,shards,put,all,snapshot,shards,shards,put,all,started,shards,survivors,put,entry,snapshot,unmodifiable,map,shards,else,survivors,put,entry,snapshot,unmodifiable,map,started,shards,else,if,entry,state,state,aborted,map,shard,id,index,shard,snapshot,status,snapshot,shards,shard,snapshots,get,entry,snapshot,if,snapshot,shards,null,final,string,failure,snapshot,has,been,aborted,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,shards,final,index,shard,snapshot,status,snapshot,status,snapshot,shards,get,shard,key,if,snapshot,status,null,final,index,shard,snapshot,status,copy,last,snapshot,status,snapshot,status,abort,if,not,completed,failure,final,stage,stage,last,snapshot,status,get,stage,if,stage,stage,finalize,logger,debug,trying,to,cancel,snapshot,on,shard,that,is,finalizing,letting,it,finish,entry,snapshot,shard,key,else,if,stage,stage,done,logger,debug,trying,to,cancel,snapshot,on,the,shard,that,is,already,done,updating,status,on,the,master,entry,snapshot,shard,key,notify,successful,snapshot,shard,entry,snapshot,shard,key,local,node,id,else,if,stage,stage,failure,logger,debug,trying,to,cancel,snapshot,on,the,shard,that,has,already,failed,updating,status,on,the,master,entry,snapshot,shard,key,notify,failed,snapshot,shard,entry,snapshot,shard,key,local,node,id,last,snapshot,status,get,failure,shutdown,lock,lock,try,shard,snapshots,unmodifiable,map,survivors,if,shard,snapshots,is,empty,shutdown,condition,signal,all,finally,shutdown,lock,unlock,if,new,snapshots,is,empty,false,executor,executor,thread,pool,executor,thread,pool,names,snapshot,for,final,map,entry,snapshot,map,shard,id,index,shard,snapshot,status,entry,new,snapshots,entry,set,final,snapshot,snapshot,entry,get,key,final,map,string,index,id,indices,map,snapshot,indices,get,snapshot,assert,indices,map,null,for,final,map,entry,shard,id,index,shard,snapshot,status,shard,entry,entry,get,value,entry,set,final,shard,id,shard,id,shard,entry,get,key,final,index,id,index,id,indices,map,get,shard,id,get,index,name,executor,execute,new,abstract,runnable,final,set,once,exception,failure,new,set,once,override,public,void,do,run,final,index,shard,index,shard,indices,service,index,service,safe,shard,id,get,index,get,shard,or,null,shard,id,id,assert,index,id,null,snapshot,index,shard,snapshot,index,id,shard,entry,get,value,override,public,void,on,failure,exception,e,logger,warn,new,parameterized,message,failed,to,snapshot,shard,shard,id,snapshot,e,failure,set,e,override,public,void,on,rejection,exception,e,failure,set,e,override,public,void,on,after,final,exception,exception,failure,get,if,exception,null,notify,failed,snapshot,shard,snapshot,shard,id,local,node,id,exceptions,helper,detailed,message,exception,else,notify,successful,snapshot,shard,snapshot,shard,id,local,node,id
SnapshotShardsService -> private void processIndexShardSnapshots(ClusterChangedEvent event);1548996340;Checks if any new shards should be snapshotted on this node__@param event cluster state changed event;private void processIndexShardSnapshots(ClusterChangedEvent event) {_        SnapshotsInProgress snapshotsInProgress = event.state().custom(SnapshotsInProgress.TYPE)__        Map<Snapshot, Map<ShardId, IndexShardSnapshotStatus>> survivors = new HashMap<>()__        _        for (Map.Entry<Snapshot, Map<ShardId, IndexShardSnapshotStatus>> entry : shardSnapshots.entrySet()) {_            final Snapshot snapshot = entry.getKey()__            if (snapshotsInProgress != null && snapshotsInProgress.snapshot(snapshot) != null) {_                survivors.put(entry.getKey(), entry.getValue())__            } else {_                _                _                _                _                for (IndexShardSnapshotStatus snapshotStatus : entry.getValue().values()) {_                    snapshotStatus.abortIfNotCompleted("snapshot has been removed in cluster state, aborting")__                }_            }_        }__        _        _        Map<Snapshot, Map<ShardId, IndexShardSnapshotStatus>> newSnapshots = new HashMap<>()__        _        final String localNodeId = event.state().nodes().getLocalNodeId()__        final Map<Snapshot, Map<String, IndexId>> snapshotIndices = new HashMap<>()__        if (snapshotsInProgress != null) {_            for (SnapshotsInProgress.Entry entry : snapshotsInProgress.entries()) {_                snapshotIndices.put(entry.snapshot(),_                                    entry.indices().stream().collect(Collectors.toMap(IndexId::getName, Function.identity())))__                if (entry.state() == State.STARTED) {_                    Map<ShardId, IndexShardSnapshotStatus> startedShards = new HashMap<>()__                    Map<ShardId, IndexShardSnapshotStatus> snapshotShards = shardSnapshots.get(entry.snapshot())__                    for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shard : entry.shards()) {_                        _                        if (localNodeId.equals(shard.value.nodeId())) {_                            if (shard.value.state() == State.INIT && (snapshotShards == null || !snapshotShards.containsKey(shard.key))) {_                                logger.trace("[{}] - Adding shard to the queue", shard.key)__                                startedShards.put(shard.key, IndexShardSnapshotStatus.newInitializing())__                            }_                        }_                    }_                    if (!startedShards.isEmpty()) {_                        newSnapshots.put(entry.snapshot(), startedShards)__                        if (snapshotShards != null) {_                            _                            Map<ShardId, IndexShardSnapshotStatus> shards = new HashMap<>()__                            _                            shards.putAll(snapshotShards)__                            _                            shards.putAll(startedShards)__                            survivors.put(entry.snapshot(), unmodifiableMap(shards))__                        } else {_                            _                            survivors.put(entry.snapshot(), unmodifiableMap(startedShards))__                        }_                    }_                } else if (entry.state() == State.ABORTED) {_                    _                    Map<ShardId, IndexShardSnapshotStatus> snapshotShards = shardSnapshots.get(entry.snapshot())__                    if (snapshotShards != null) {_                        for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shard : entry.shards()) {_                            final IndexShardSnapshotStatus snapshotStatus = snapshotShards.get(shard.key)__                            if (snapshotStatus != null) {_                                final IndexShardSnapshotStatus.Copy lastSnapshotStatus =_                                    snapshotStatus.abortIfNotCompleted("snapshot has been aborted")__                                final Stage stage = lastSnapshotStatus.getStage()__                                if (stage == Stage.FINALIZE) {_                                    logger.debug("[{}] trying to cancel snapshot on shard [{}] that is finalizing, " +_                                        "letting it finish", entry.snapshot(), shard.key)___                                } else if (stage == Stage.DONE) {_                                    logger.debug("[{}] trying to cancel snapshot on the shard [{}] that is already done, " +_                                        "updating status on the master", entry.snapshot(), shard.key)__                                    notifySuccessfulSnapshotShard(entry.snapshot(), shard.key, localNodeId)___                                }  else if (stage == Stage.FAILURE) {_                                    logger.debug("[{}] trying to cancel snapshot on the shard [{}] that has already failed, " +_                                        "updating status on the master", entry.snapshot(), shard.key)__                                    notifyFailedSnapshotShard(entry.snapshot(), shard.key, localNodeId, lastSnapshotStatus.getFailure())__                                }_                            }_                        }_                    } else {_                        final Snapshot snapshot = entry.snapshot()__                        for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> curr : entry.shards()) {_                            _                            _                            if (curr.value.state() == State.ABORTED) {_                                notifyFailedSnapshotShard(snapshot, curr.key, localNodeId, curr.value.reason())__                            }_                        }_                    }_                }_            }_        }__        _        _        shutdownLock.lock()__        try {_            shardSnapshots = unmodifiableMap(survivors)__            if (shardSnapshots.isEmpty()) {_                _                shutdownCondition.signalAll()__            }_        } finally {_            shutdownLock.unlock()__        }__        _        if (newSnapshots.isEmpty() == false) {_            Executor executor = threadPool.executor(ThreadPool.Names.SNAPSHOT)__            for (final Map.Entry<Snapshot, Map<ShardId, IndexShardSnapshotStatus>> entry : newSnapshots.entrySet()) {_                final Snapshot snapshot = entry.getKey()__                final Map<String, IndexId> indicesMap = snapshotIndices.get(snapshot)__                assert indicesMap != null___                for (final Map.Entry<ShardId, IndexShardSnapshotStatus> shardEntry : entry.getValue().entrySet()) {_                    final ShardId shardId = shardEntry.getKey()__                    final IndexId indexId = indicesMap.get(shardId.getIndexName())__                    executor.execute(new AbstractRunnable() {__                        final SetOnce<Exception> failure = new SetOnce<>()___                        @Override_                        public void doRun() {_                            final IndexShard indexShard = indicesService.indexServiceSafe(shardId.getIndex()).getShardOrNull(shardId.id())__                            assert indexId != null__                            snapshot(indexShard, snapshot, indexId, shardEntry.getValue())__                        }__                        @Override_                        public void onFailure(Exception e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to snapshot shard",_                                                                        shardId, snapshot), e)__                            failure.set(e)__                        }__                        @Override_                        public void onRejection(Exception e) {_                            failure.set(e)__                        }__                        @Override_                        public void onAfter() {_                            final Exception exception = failure.get()__                            if (exception != null) {_                                notifyFailedSnapshotShard(snapshot, shardId, localNodeId, ExceptionsHelper.detailedMessage(exception))__                            } else {_                                notifySuccessfulSnapshotShard(snapshot, shardId, localNodeId)__                            }_                        }_                    })__                }_            }_        }_    };checks,if,any,new,shards,should,be,snapshotted,on,this,node,param,event,cluster,state,changed,event;private,void,process,index,shard,snapshots,cluster,changed,event,event,snapshots,in,progress,snapshots,in,progress,event,state,custom,snapshots,in,progress,type,map,snapshot,map,shard,id,index,shard,snapshot,status,survivors,new,hash,map,for,map,entry,snapshot,map,shard,id,index,shard,snapshot,status,entry,shard,snapshots,entry,set,final,snapshot,snapshot,entry,get,key,if,snapshots,in,progress,null,snapshots,in,progress,snapshot,snapshot,null,survivors,put,entry,get,key,entry,get,value,else,for,index,shard,snapshot,status,snapshot,status,entry,get,value,values,snapshot,status,abort,if,not,completed,snapshot,has,been,removed,in,cluster,state,aborting,map,snapshot,map,shard,id,index,shard,snapshot,status,new,snapshots,new,hash,map,final,string,local,node,id,event,state,nodes,get,local,node,id,final,map,snapshot,map,string,index,id,snapshot,indices,new,hash,map,if,snapshots,in,progress,null,for,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,snapshot,indices,put,entry,snapshot,entry,indices,stream,collect,collectors,to,map,index,id,get,name,function,identity,if,entry,state,state,started,map,shard,id,index,shard,snapshot,status,started,shards,new,hash,map,map,shard,id,index,shard,snapshot,status,snapshot,shards,shard,snapshots,get,entry,snapshot,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,shards,if,local,node,id,equals,shard,value,node,id,if,shard,value,state,state,init,snapshot,shards,null,snapshot,shards,contains,key,shard,key,logger,trace,adding,shard,to,the,queue,shard,key,started,shards,put,shard,key,index,shard,snapshot,status,new,initializing,if,started,shards,is,empty,new,snapshots,put,entry,snapshot,started,shards,if,snapshot,shards,null,map,shard,id,index,shard,snapshot,status,shards,new,hash,map,shards,put,all,snapshot,shards,shards,put,all,started,shards,survivors,put,entry,snapshot,unmodifiable,map,shards,else,survivors,put,entry,snapshot,unmodifiable,map,started,shards,else,if,entry,state,state,aborted,map,shard,id,index,shard,snapshot,status,snapshot,shards,shard,snapshots,get,entry,snapshot,if,snapshot,shards,null,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,shards,final,index,shard,snapshot,status,snapshot,status,snapshot,shards,get,shard,key,if,snapshot,status,null,final,index,shard,snapshot,status,copy,last,snapshot,status,snapshot,status,abort,if,not,completed,snapshot,has,been,aborted,final,stage,stage,last,snapshot,status,get,stage,if,stage,stage,finalize,logger,debug,trying,to,cancel,snapshot,on,shard,that,is,finalizing,letting,it,finish,entry,snapshot,shard,key,else,if,stage,stage,done,logger,debug,trying,to,cancel,snapshot,on,the,shard,that,is,already,done,updating,status,on,the,master,entry,snapshot,shard,key,notify,successful,snapshot,shard,entry,snapshot,shard,key,local,node,id,else,if,stage,stage,failure,logger,debug,trying,to,cancel,snapshot,on,the,shard,that,has,already,failed,updating,status,on,the,master,entry,snapshot,shard,key,notify,failed,snapshot,shard,entry,snapshot,shard,key,local,node,id,last,snapshot,status,get,failure,else,final,snapshot,snapshot,entry,snapshot,for,object,object,cursor,shard,id,shard,snapshot,status,curr,entry,shards,if,curr,value,state,state,aborted,notify,failed,snapshot,shard,snapshot,curr,key,local,node,id,curr,value,reason,shutdown,lock,lock,try,shard,snapshots,unmodifiable,map,survivors,if,shard,snapshots,is,empty,shutdown,condition,signal,all,finally,shutdown,lock,unlock,if,new,snapshots,is,empty,false,executor,executor,thread,pool,executor,thread,pool,names,snapshot,for,final,map,entry,snapshot,map,shard,id,index,shard,snapshot,status,entry,new,snapshots,entry,set,final,snapshot,snapshot,entry,get,key,final,map,string,index,id,indices,map,snapshot,indices,get,snapshot,assert,indices,map,null,for,final,map,entry,shard,id,index,shard,snapshot,status,shard,entry,entry,get,value,entry,set,final,shard,id,shard,id,shard,entry,get,key,final,index,id,index,id,indices,map,get,shard,id,get,index,name,executor,execute,new,abstract,runnable,final,set,once,exception,failure,new,set,once,override,public,void,do,run,final,index,shard,index,shard,indices,service,index,service,safe,shard,id,get,index,get,shard,or,null,shard,id,id,assert,index,id,null,snapshot,index,shard,snapshot,index,id,shard,entry,get,value,override,public,void,on,failure,exception,e,logger,warn,new,parameterized,message,failed,to,snapshot,shard,shard,id,snapshot,e,failure,set,e,override,public,void,on,rejection,exception,e,failure,set,e,override,public,void,on,after,final,exception,exception,failure,get,if,exception,null,notify,failed,snapshot,shard,snapshot,shard,id,local,node,id,exceptions,helper,detailed,message,exception,else,notify,successful,snapshot,shard,snapshot,shard,id,local,node,id
SnapshotShardsService -> void notifyFailedSnapshotShard(final Snapshot snapshot, final ShardId shardId, final String localNodeId, final String failure);1524684173;Notify the master node that the given shard failed to be snapshotted *;void notifyFailedSnapshotShard(final Snapshot snapshot, final ShardId shardId, final String localNodeId, final String failure) {_        sendSnapshotShardUpdate(snapshot, shardId, new ShardSnapshotStatus(localNodeId, State.FAILED, failure))__    };notify,the,master,node,that,the,given,shard,failed,to,be,snapshotted;void,notify,failed,snapshot,shard,final,snapshot,snapshot,final,shard,id,shard,id,final,string,local,node,id,final,string,failure,send,snapshot,shard,update,snapshot,shard,id,new,shard,snapshot,status,local,node,id,state,failed,failure
SnapshotShardsService -> void notifyFailedSnapshotShard(final Snapshot snapshot, final ShardId shardId, final String localNodeId, final String failure);1536828374;Notify the master node that the given shard failed to be snapshotted *;void notifyFailedSnapshotShard(final Snapshot snapshot, final ShardId shardId, final String localNodeId, final String failure) {_        sendSnapshotShardUpdate(snapshot, shardId, new ShardSnapshotStatus(localNodeId, State.FAILED, failure))__    };notify,the,master,node,that,the,given,shard,failed,to,be,snapshotted;void,notify,failed,snapshot,shard,final,snapshot,snapshot,final,shard,id,shard,id,final,string,local,node,id,final,string,failure,send,snapshot,shard,update,snapshot,shard,id,new,shard,snapshot,status,local,node,id,state,failed,failure
SnapshotShardsService -> void notifyFailedSnapshotShard(final Snapshot snapshot, final ShardId shardId, final String localNodeId, final String failure);1541419698;Notify the master node that the given shard failed to be snapshotted *;void notifyFailedSnapshotShard(final Snapshot snapshot, final ShardId shardId, final String localNodeId, final String failure) {_        sendSnapshotShardUpdate(snapshot, shardId, new ShardSnapshotStatus(localNodeId, State.FAILED, failure))__    };notify,the,master,node,that,the,given,shard,failed,to,be,snapshotted;void,notify,failed,snapshot,shard,final,snapshot,snapshot,final,shard,id,shard,id,final,string,local,node,id,final,string,failure,send,snapshot,shard,update,snapshot,shard,id,new,shard,snapshot,status,local,node,id,state,failed,failure
SnapshotShardsService -> void notifyFailedSnapshotShard(final Snapshot snapshot, final ShardId shardId, final String localNodeId, final String failure);1542646292;Notify the master node that the given shard failed to be snapshotted *;void notifyFailedSnapshotShard(final Snapshot snapshot, final ShardId shardId, final String localNodeId, final String failure) {_        sendSnapshotShardUpdate(snapshot, shardId, new ShardSnapshotStatus(localNodeId, State.FAILED, failure))__    };notify,the,master,node,that,the,given,shard,failed,to,be,snapshotted;void,notify,failed,snapshot,shard,final,snapshot,snapshot,final,shard,id,shard,id,final,string,local,node,id,final,string,failure,send,snapshot,shard,update,snapshot,shard,id,new,shard,snapshot,status,local,node,id,state,failed,failure
SnapshotShardsService -> void notifyFailedSnapshotShard(final Snapshot snapshot, final ShardId shardId, final String localNodeId, final String failure);1542804617;Notify the master node that the given shard failed to be snapshotted *;void notifyFailedSnapshotShard(final Snapshot snapshot, final ShardId shardId, final String localNodeId, final String failure) {_        sendSnapshotShardUpdate(snapshot, shardId, new ShardSnapshotStatus(localNodeId, State.FAILED, failure))__    };notify,the,master,node,that,the,given,shard,failed,to,be,snapshotted;void,notify,failed,snapshot,shard,final,snapshot,snapshot,final,shard,id,shard,id,final,string,local,node,id,final,string,failure,send,snapshot,shard,update,snapshot,shard,id,new,shard,snapshot,status,local,node,id,state,failed,failure
SnapshotShardsService -> void notifyFailedSnapshotShard(final Snapshot snapshot, final ShardId shardId, final String localNodeId, final String failure);1543851569;Notify the master node that the given shard failed to be snapshotted *;void notifyFailedSnapshotShard(final Snapshot snapshot, final ShardId shardId, final String localNodeId, final String failure) {_        sendSnapshotShardUpdate(snapshot, shardId, new ShardSnapshotStatus(localNodeId, State.FAILED, failure))__    };notify,the,master,node,that,the,given,shard,failed,to,be,snapshotted;void,notify,failed,snapshot,shard,final,snapshot,snapshot,final,shard,id,shard,id,final,string,local,node,id,final,string,failure,send,snapshot,shard,update,snapshot,shard,id,new,shard,snapshot,status,local,node,id,state,failed,failure
SnapshotShardsService -> void notifyFailedSnapshotShard(final Snapshot snapshot, final ShardId shardId, final String localNodeId, final String failure);1545215361;Notify the master node that the given shard failed to be snapshotted *;void notifyFailedSnapshotShard(final Snapshot snapshot, final ShardId shardId, final String localNodeId, final String failure) {_        sendSnapshotShardUpdate(snapshot, shardId, new ShardSnapshotStatus(localNodeId, State.FAILED, failure))__    };notify,the,master,node,that,the,given,shard,failed,to,be,snapshotted;void,notify,failed,snapshot,shard,final,snapshot,snapshot,final,shard,id,shard,id,final,string,local,node,id,final,string,failure,send,snapshot,shard,update,snapshot,shard,id,new,shard,snapshot,status,local,node,id,state,failed,failure
SnapshotShardsService -> void notifyFailedSnapshotShard(final Snapshot snapshot, final ShardId shardId, final String localNodeId, final String failure);1547023537;Notify the master node that the given shard failed to be snapshotted *;void notifyFailedSnapshotShard(final Snapshot snapshot, final ShardId shardId, final String localNodeId, final String failure) {_        sendSnapshotShardUpdate(snapshot, shardId, new ShardSnapshotStatus(localNodeId, State.FAILED, failure))__    };notify,the,master,node,that,the,given,shard,failed,to,be,snapshotted;void,notify,failed,snapshot,shard,final,snapshot,snapshot,final,shard,id,shard,id,final,string,local,node,id,final,string,failure,send,snapshot,shard,update,snapshot,shard,id,new,shard,snapshot,status,local,node,id,state,failed,failure
SnapshotShardsService -> void notifyFailedSnapshotShard(final Snapshot snapshot, final ShardId shardId, final String localNodeId, final String failure);1547625930;Notify the master node that the given shard failed to be snapshotted *;void notifyFailedSnapshotShard(final Snapshot snapshot, final ShardId shardId, final String localNodeId, final String failure) {_        sendSnapshotShardUpdate(snapshot, shardId, new ShardSnapshotStatus(localNodeId, State.FAILED, failure))__    };notify,the,master,node,that,the,given,shard,failed,to,be,snapshotted;void,notify,failed,snapshot,shard,final,snapshot,snapshot,final,shard,id,shard,id,final,string,local,node,id,final,string,failure,send,snapshot,shard,update,snapshot,shard,id,new,shard,snapshot,status,local,node,id,state,failed,failure
SnapshotShardsService -> void notifyFailedSnapshotShard(final Snapshot snapshot, final ShardId shardId, final String localNodeId, final String failure);1548996340;Notify the master node that the given shard failed to be snapshotted *;void notifyFailedSnapshotShard(final Snapshot snapshot, final ShardId shardId, final String localNodeId, final String failure) {_        sendSnapshotShardUpdate(snapshot, shardId, new ShardSnapshotStatus(localNodeId, State.FAILED, failure))__    };notify,the,master,node,that,the,given,shard,failed,to,be,snapshotted;void,notify,failed,snapshot,shard,final,snapshot,snapshot,final,shard,id,shard,id,final,string,local,node,id,final,string,failure,send,snapshot,shard,update,snapshot,shard,id,new,shard,snapshot,status,local,node,id,state,failed,failure
SnapshotShardsService -> public Map<ShardId, IndexShardSnapshotStatus> currentSnapshotShards(Snapshot snapshot);1524684173;Returns status of shards that are snapshotted on the node and belong to the given snapshot_<p>_This method is executed on data node_</p>__@param snapshot  snapshot_@return map of shard id to snapshot status;public Map<ShardId, IndexShardSnapshotStatus> currentSnapshotShards(Snapshot snapshot) {_        SnapshotShards snapshotShards = shardSnapshots.get(snapshot)__        if (snapshotShards == null) {_            return null__        } else {_            return snapshotShards.shards__        }_    };returns,status,of,shards,that,are,snapshotted,on,the,node,and,belong,to,the,given,snapshot,p,this,method,is,executed,on,data,node,p,param,snapshot,snapshot,return,map,of,shard,id,to,snapshot,status;public,map,shard,id,index,shard,snapshot,status,current,snapshot,shards,snapshot,snapshot,snapshot,shards,snapshot,shards,shard,snapshots,get,snapshot,if,snapshot,shards,null,return,null,else,return,snapshot,shards,shards
SnapshotShardsService -> public Map<ShardId, IndexShardSnapshotStatus> currentSnapshotShards(Snapshot snapshot);1536828374;Returns status of shards that are snapshotted on the node and belong to the given snapshot_<p>_This method is executed on data node_</p>__@param snapshot  snapshot_@return map of shard id to snapshot status;public Map<ShardId, IndexShardSnapshotStatus> currentSnapshotShards(Snapshot snapshot) {_        SnapshotShards snapshotShards = shardSnapshots.get(snapshot)__        if (snapshotShards == null) {_            return null__        } else {_            return snapshotShards.shards__        }_    };returns,status,of,shards,that,are,snapshotted,on,the,node,and,belong,to,the,given,snapshot,p,this,method,is,executed,on,data,node,p,param,snapshot,snapshot,return,map,of,shard,id,to,snapshot,status;public,map,shard,id,index,shard,snapshot,status,current,snapshot,shards,snapshot,snapshot,snapshot,shards,snapshot,shards,shard,snapshots,get,snapshot,if,snapshot,shards,null,return,null,else,return,snapshot,shards,shards
SnapshotShardsService -> public Map<ShardId, IndexShardSnapshotStatus> currentSnapshotShards(Snapshot snapshot);1541419698;Returns status of shards that are snapshotted on the node and belong to the given snapshot_<p>_This method is executed on data node_</p>__@param snapshot  snapshot_@return map of shard id to snapshot status;public Map<ShardId, IndexShardSnapshotStatus> currentSnapshotShards(Snapshot snapshot) {_        SnapshotShards snapshotShards = shardSnapshots.get(snapshot)__        if (snapshotShards == null) {_            return null__        } else {_            return snapshotShards.shards__        }_    };returns,status,of,shards,that,are,snapshotted,on,the,node,and,belong,to,the,given,snapshot,p,this,method,is,executed,on,data,node,p,param,snapshot,snapshot,return,map,of,shard,id,to,snapshot,status;public,map,shard,id,index,shard,snapshot,status,current,snapshot,shards,snapshot,snapshot,snapshot,shards,snapshot,shards,shard,snapshots,get,snapshot,if,snapshot,shards,null,return,null,else,return,snapshot,shards,shards
SnapshotShardsService -> public Map<ShardId, IndexShardSnapshotStatus> currentSnapshotShards(Snapshot snapshot);1542646292;Returns status of shards that are snapshotted on the node and belong to the given snapshot_<p>_This method is executed on data node_</p>__@param snapshot  snapshot_@return map of shard id to snapshot status;public Map<ShardId, IndexShardSnapshotStatus> currentSnapshotShards(Snapshot snapshot) {_        SnapshotShards snapshotShards = shardSnapshots.get(snapshot)__        if (snapshotShards == null) {_            return null__        } else {_            return snapshotShards.shards__        }_    };returns,status,of,shards,that,are,snapshotted,on,the,node,and,belong,to,the,given,snapshot,p,this,method,is,executed,on,data,node,p,param,snapshot,snapshot,return,map,of,shard,id,to,snapshot,status;public,map,shard,id,index,shard,snapshot,status,current,snapshot,shards,snapshot,snapshot,snapshot,shards,snapshot,shards,shard,snapshots,get,snapshot,if,snapshot,shards,null,return,null,else,return,snapshot,shards,shards
SnapshotShardsService -> public Map<ShardId, IndexShardSnapshotStatus> currentSnapshotShards(Snapshot snapshot);1542804617;Returns status of shards that are snapshotted on the node and belong to the given snapshot_<p>_This method is executed on data node_</p>__@param snapshot  snapshot_@return map of shard id to snapshot status;public Map<ShardId, IndexShardSnapshotStatus> currentSnapshotShards(Snapshot snapshot) {_        return shardSnapshots.get(snapshot)__    };returns,status,of,shards,that,are,snapshotted,on,the,node,and,belong,to,the,given,snapshot,p,this,method,is,executed,on,data,node,p,param,snapshot,snapshot,return,map,of,shard,id,to,snapshot,status;public,map,shard,id,index,shard,snapshot,status,current,snapshot,shards,snapshot,snapshot,return,shard,snapshots,get,snapshot
SnapshotShardsService -> public Map<ShardId, IndexShardSnapshotStatus> currentSnapshotShards(Snapshot snapshot);1543851569;Returns status of shards that are snapshotted on the node and belong to the given snapshot_<p>_This method is executed on data node_</p>__@param snapshot  snapshot_@return map of shard id to snapshot status;public Map<ShardId, IndexShardSnapshotStatus> currentSnapshotShards(Snapshot snapshot) {_        return shardSnapshots.get(snapshot)__    };returns,status,of,shards,that,are,snapshotted,on,the,node,and,belong,to,the,given,snapshot,p,this,method,is,executed,on,data,node,p,param,snapshot,snapshot,return,map,of,shard,id,to,snapshot,status;public,map,shard,id,index,shard,snapshot,status,current,snapshot,shards,snapshot,snapshot,return,shard,snapshots,get,snapshot
SnapshotShardsService -> public Map<ShardId, IndexShardSnapshotStatus> currentSnapshotShards(Snapshot snapshot);1545215361;Returns status of shards that are snapshotted on the node and belong to the given snapshot_<p>_This method is executed on data node_</p>__@param snapshot  snapshot_@return map of shard id to snapshot status;public Map<ShardId, IndexShardSnapshotStatus> currentSnapshotShards(Snapshot snapshot) {_        return shardSnapshots.get(snapshot)__    };returns,status,of,shards,that,are,snapshotted,on,the,node,and,belong,to,the,given,snapshot,p,this,method,is,executed,on,data,node,p,param,snapshot,snapshot,return,map,of,shard,id,to,snapshot,status;public,map,shard,id,index,shard,snapshot,status,current,snapshot,shards,snapshot,snapshot,return,shard,snapshots,get,snapshot
SnapshotShardsService -> public Map<ShardId, IndexShardSnapshotStatus> currentSnapshotShards(Snapshot snapshot);1547023537;Returns status of shards that are snapshotted on the node and belong to the given snapshot_<p>_This method is executed on data node_</p>__@param snapshot  snapshot_@return map of shard id to snapshot status;public Map<ShardId, IndexShardSnapshotStatus> currentSnapshotShards(Snapshot snapshot) {_        return shardSnapshots.get(snapshot)__    };returns,status,of,shards,that,are,snapshotted,on,the,node,and,belong,to,the,given,snapshot,p,this,method,is,executed,on,data,node,p,param,snapshot,snapshot,return,map,of,shard,id,to,snapshot,status;public,map,shard,id,index,shard,snapshot,status,current,snapshot,shards,snapshot,snapshot,return,shard,snapshots,get,snapshot
SnapshotShardsService -> public Map<ShardId, IndexShardSnapshotStatus> currentSnapshotShards(Snapshot snapshot);1547625930;Returns status of shards that are snapshotted on the node and belong to the given snapshot_<p>_This method is executed on data node_</p>__@param snapshot  snapshot_@return map of shard id to snapshot status;public Map<ShardId, IndexShardSnapshotStatus> currentSnapshotShards(Snapshot snapshot) {_        return shardSnapshots.get(snapshot)__    };returns,status,of,shards,that,are,snapshotted,on,the,node,and,belong,to,the,given,snapshot,p,this,method,is,executed,on,data,node,p,param,snapshot,snapshot,return,map,of,shard,id,to,snapshot,status;public,map,shard,id,index,shard,snapshot,status,current,snapshot,shards,snapshot,snapshot,return,shard,snapshots,get,snapshot
SnapshotShardsService -> public Map<ShardId, IndexShardSnapshotStatus> currentSnapshotShards(Snapshot snapshot);1548996340;Returns status of shards that are snapshotted on the node and belong to the given snapshot_<p>_This method is executed on data node_</p>__@param snapshot  snapshot_@return map of shard id to snapshot status;public Map<ShardId, IndexShardSnapshotStatus> currentSnapshotShards(Snapshot snapshot) {_        return shardSnapshots.get(snapshot)__    };returns,status,of,shards,that,are,snapshotted,on,the,node,and,belong,to,the,given,snapshot,p,this,method,is,executed,on,data,node,p,param,snapshot,snapshot,return,map,of,shard,id,to,snapshot,status;public,map,shard,id,index,shard,snapshot,status,current,snapshot,shards,snapshot,snapshot,return,shard,snapshots,get,snapshot
SnapshotShardsService -> public Map<ShardId, IndexShardSnapshotStatus> currentSnapshotShards(Snapshot snapshot);1549050374;Returns status of shards that are snapshotted on the node and belong to the given snapshot_<p>_This method is executed on data node_</p>__@param snapshot  snapshot_@return map of shard id to snapshot status;public Map<ShardId, IndexShardSnapshotStatus> currentSnapshotShards(Snapshot snapshot) {_        synchronized (shardSnapshots) {_            final Map<ShardId, IndexShardSnapshotStatus> current = shardSnapshots.get(snapshot)__            return current == null ? null : new HashMap<>(current)__        }_    };returns,status,of,shards,that,are,snapshotted,on,the,node,and,belong,to,the,given,snapshot,p,this,method,is,executed,on,data,node,p,param,snapshot,snapshot,return,map,of,shard,id,to,snapshot,status;public,map,shard,id,index,shard,snapshot,status,current,snapshot,shards,snapshot,snapshot,synchronized,shard,snapshots,final,map,shard,id,index,shard,snapshot,status,current,shard,snapshots,get,snapshot,return,current,null,null,new,hash,map,current
SnapshotShardsService -> public Map<ShardId, IndexShardSnapshotStatus> currentSnapshotShards(Snapshot snapshot);1549180095;Returns status of shards that are snapshotted on the node and belong to the given snapshot_<p>_This method is executed on data node_</p>__@param snapshot  snapshot_@return map of shard id to snapshot status;public Map<ShardId, IndexShardSnapshotStatus> currentSnapshotShards(Snapshot snapshot) {_        synchronized (shardSnapshots) {_            final Map<ShardId, IndexShardSnapshotStatus> current = shardSnapshots.get(snapshot)__            return current == null ? null : new HashMap<>(current)__        }_    };returns,status,of,shards,that,are,snapshotted,on,the,node,and,belong,to,the,given,snapshot,p,this,method,is,executed,on,data,node,p,param,snapshot,snapshot,return,map,of,shard,id,to,snapshot,status;public,map,shard,id,index,shard,snapshot,status,current,snapshot,shards,snapshot,snapshot,synchronized,shard,snapshots,final,map,shard,id,index,shard,snapshot,status,current,shard,snapshots,get,snapshot,return,current,null,null,new,hash,map,current
SnapshotShardsService -> public Map<ShardId, IndexShardSnapshotStatus> currentSnapshotShards(Snapshot snapshot);1549267599;Returns status of shards that are snapshotted on the node and belong to the given snapshot_<p>_This method is executed on data node_</p>__@param snapshot  snapshot_@return map of shard id to snapshot status;public Map<ShardId, IndexShardSnapshotStatus> currentSnapshotShards(Snapshot snapshot) {_        synchronized (shardSnapshots) {_            final Map<ShardId, IndexShardSnapshotStatus> current = shardSnapshots.get(snapshot)__            return current == null ? null : new HashMap<>(current)__        }_    };returns,status,of,shards,that,are,snapshotted,on,the,node,and,belong,to,the,given,snapshot,p,this,method,is,executed,on,data,node,p,param,snapshot,snapshot,return,map,of,shard,id,to,snapshot,status;public,map,shard,id,index,shard,snapshot,status,current,snapshot,shards,snapshot,snapshot,synchronized,shard,snapshots,final,map,shard,id,index,shard,snapshot,status,current,shard,snapshots,get,snapshot,return,current,null,null,new,hash,map,current
SnapshotShardsService -> public Map<ShardId, IndexShardSnapshotStatus> currentSnapshotShards(Snapshot snapshot);1549381458;Returns status of shards that are snapshotted on the node and belong to the given snapshot_<p>_This method is executed on data node_</p>__@param snapshot  snapshot_@return map of shard id to snapshot status;public Map<ShardId, IndexShardSnapshotStatus> currentSnapshotShards(Snapshot snapshot) {_        synchronized (shardSnapshots) {_            final Map<ShardId, IndexShardSnapshotStatus> current = shardSnapshots.get(snapshot)__            return current == null ? null : new HashMap<>(current)__        }_    };returns,status,of,shards,that,are,snapshotted,on,the,node,and,belong,to,the,given,snapshot,p,this,method,is,executed,on,data,node,p,param,snapshot,snapshot,return,map,of,shard,id,to,snapshot,status;public,map,shard,id,index,shard,snapshot,status,current,snapshot,shards,snapshot,snapshot,synchronized,shard,snapshots,final,map,shard,id,index,shard,snapshot,status,current,shard,snapshots,get,snapshot,return,current,null,null,new,hash,map,current
SnapshotShardsService -> private void snapshot(final IndexShard indexShard, final Snapshot snapshot, final IndexId indexId,                           final IndexShardSnapshotStatus snapshotStatus);1545215361;Creates shard snapshot__@param snapshot       snapshot_@param snapshotStatus snapshot status;private void snapshot(final IndexShard indexShard, final Snapshot snapshot, final IndexId indexId,_                          final IndexShardSnapshotStatus snapshotStatus) {_        final ShardId shardId = indexShard.shardId()__        if (indexShard.routingEntry().primary() == false) {_            throw new IndexShardSnapshotFailedException(shardId, "snapshot should be performed only on primary")__        }_        if (indexShard.routingEntry().relocating()) {_            _            throw new IndexShardSnapshotFailedException(shardId, "cannot snapshot while relocating")__        }__        final IndexShardState indexShardState = indexShard.state()__        if (indexShardState == IndexShardState.CREATED || indexShardState == IndexShardState.RECOVERING) {_            _            throw new IndexShardSnapshotFailedException(shardId, "shard didn't fully recover yet")__        }__        final Repository repository = snapshotsService.getRepositoriesService().repository(snapshot.getRepository())__        try {_            _            try (Engine.IndexCommitRef snapshotRef = indexShard.acquireLastIndexCommit(true)) {_                repository.snapshotShard(indexShard, indexShard.store(), snapshot.getSnapshotId(), indexId, snapshotRef.getIndexCommit(),_                    snapshotStatus)__                if (logger.isDebugEnabled()) {_                    final IndexShardSnapshotStatus.Copy lastSnapshotStatus = snapshotStatus.asCopy()__                    logger.debug("snapshot ({}) completed to {} with {}", snapshot, repository, lastSnapshotStatus)__                }_            }_        } catch (SnapshotFailedEngineException | IndexShardSnapshotFailedException e) {_            throw e__        } catch (Exception e) {_            throw new IndexShardSnapshotFailedException(shardId, "Failed to snapshot", e)__        }_    };creates,shard,snapshot,param,snapshot,snapshot,param,snapshot,status,snapshot,status;private,void,snapshot,final,index,shard,index,shard,final,snapshot,snapshot,final,index,id,index,id,final,index,shard,snapshot,status,snapshot,status,final,shard,id,shard,id,index,shard,shard,id,if,index,shard,routing,entry,primary,false,throw,new,index,shard,snapshot,failed,exception,shard,id,snapshot,should,be,performed,only,on,primary,if,index,shard,routing,entry,relocating,throw,new,index,shard,snapshot,failed,exception,shard,id,cannot,snapshot,while,relocating,final,index,shard,state,index,shard,state,index,shard,state,if,index,shard,state,index,shard,state,created,index,shard,state,index,shard,state,recovering,throw,new,index,shard,snapshot,failed,exception,shard,id,shard,didn,t,fully,recover,yet,final,repository,repository,snapshots,service,get,repositories,service,repository,snapshot,get,repository,try,try,engine,index,commit,ref,snapshot,ref,index,shard,acquire,last,index,commit,true,repository,snapshot,shard,index,shard,index,shard,store,snapshot,get,snapshot,id,index,id,snapshot,ref,get,index,commit,snapshot,status,if,logger,is,debug,enabled,final,index,shard,snapshot,status,copy,last,snapshot,status,snapshot,status,as,copy,logger,debug,snapshot,completed,to,with,snapshot,repository,last,snapshot,status,catch,snapshot,failed,engine,exception,index,shard,snapshot,failed,exception,e,throw,e,catch,exception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,snapshot,e
SnapshotShardsService -> private void snapshot(final IndexShard indexShard, final Snapshot snapshot, final IndexId indexId,                           final IndexShardSnapshotStatus snapshotStatus);1547023537;Creates shard snapshot__@param snapshot       snapshot_@param snapshotStatus snapshot status;private void snapshot(final IndexShard indexShard, final Snapshot snapshot, final IndexId indexId,_                          final IndexShardSnapshotStatus snapshotStatus) {_        final ShardId shardId = indexShard.shardId()__        if (indexShard.routingEntry().primary() == false) {_            throw new IndexShardSnapshotFailedException(shardId, "snapshot should be performed only on primary")__        }_        if (indexShard.routingEntry().relocating()) {_            _            throw new IndexShardSnapshotFailedException(shardId, "cannot snapshot while relocating")__        }__        final IndexShardState indexShardState = indexShard.state()__        if (indexShardState == IndexShardState.CREATED || indexShardState == IndexShardState.RECOVERING) {_            _            throw new IndexShardSnapshotFailedException(shardId, "shard didn't fully recover yet")__        }__        final Repository repository = snapshotsService.getRepositoriesService().repository(snapshot.getRepository())__        try {_            _            try (Engine.IndexCommitRef snapshotRef = indexShard.acquireLastIndexCommit(true)) {_                repository.snapshotShard(indexShard, indexShard.store(), snapshot.getSnapshotId(), indexId, snapshotRef.getIndexCommit(),_                    snapshotStatus)__                if (logger.isDebugEnabled()) {_                    final IndexShardSnapshotStatus.Copy lastSnapshotStatus = snapshotStatus.asCopy()__                    logger.debug("snapshot ({}) completed to {} with {}", snapshot, repository, lastSnapshotStatus)__                }_            }_        } catch (SnapshotFailedEngineException | IndexShardSnapshotFailedException e) {_            throw e__        } catch (Exception e) {_            throw new IndexShardSnapshotFailedException(shardId, "Failed to snapshot", e)__        }_    };creates,shard,snapshot,param,snapshot,snapshot,param,snapshot,status,snapshot,status;private,void,snapshot,final,index,shard,index,shard,final,snapshot,snapshot,final,index,id,index,id,final,index,shard,snapshot,status,snapshot,status,final,shard,id,shard,id,index,shard,shard,id,if,index,shard,routing,entry,primary,false,throw,new,index,shard,snapshot,failed,exception,shard,id,snapshot,should,be,performed,only,on,primary,if,index,shard,routing,entry,relocating,throw,new,index,shard,snapshot,failed,exception,shard,id,cannot,snapshot,while,relocating,final,index,shard,state,index,shard,state,index,shard,state,if,index,shard,state,index,shard,state,created,index,shard,state,index,shard,state,recovering,throw,new,index,shard,snapshot,failed,exception,shard,id,shard,didn,t,fully,recover,yet,final,repository,repository,snapshots,service,get,repositories,service,repository,snapshot,get,repository,try,try,engine,index,commit,ref,snapshot,ref,index,shard,acquire,last,index,commit,true,repository,snapshot,shard,index,shard,index,shard,store,snapshot,get,snapshot,id,index,id,snapshot,ref,get,index,commit,snapshot,status,if,logger,is,debug,enabled,final,index,shard,snapshot,status,copy,last,snapshot,status,snapshot,status,as,copy,logger,debug,snapshot,completed,to,with,snapshot,repository,last,snapshot,status,catch,snapshot,failed,engine,exception,index,shard,snapshot,failed,exception,e,throw,e,catch,exception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,snapshot,e
SnapshotShardsService -> private void snapshot(final IndexShard indexShard, final Snapshot snapshot, final IndexId indexId,                           final IndexShardSnapshotStatus snapshotStatus);1547625930;Creates shard snapshot__@param snapshot       snapshot_@param snapshotStatus snapshot status;private void snapshot(final IndexShard indexShard, final Snapshot snapshot, final IndexId indexId,_                          final IndexShardSnapshotStatus snapshotStatus) {_        final ShardId shardId = indexShard.shardId()__        if (indexShard.routingEntry().primary() == false) {_            throw new IndexShardSnapshotFailedException(shardId, "snapshot should be performed only on primary")__        }_        if (indexShard.routingEntry().relocating()) {_            _            throw new IndexShardSnapshotFailedException(shardId, "cannot snapshot while relocating")__        }__        final IndexShardState indexShardState = indexShard.state()__        if (indexShardState == IndexShardState.CREATED || indexShardState == IndexShardState.RECOVERING) {_            _            throw new IndexShardSnapshotFailedException(shardId, "shard didn't fully recover yet")__        }__        final Repository repository = snapshotsService.getRepositoriesService().repository(snapshot.getRepository())__        try {_            _            try (Engine.IndexCommitRef snapshotRef = indexShard.acquireLastIndexCommit(true)) {_                repository.snapshotShard(indexShard, indexShard.store(), snapshot.getSnapshotId(), indexId, snapshotRef.getIndexCommit(),_                    snapshotStatus)__                if (logger.isDebugEnabled()) {_                    final IndexShardSnapshotStatus.Copy lastSnapshotStatus = snapshotStatus.asCopy()__                    logger.debug("snapshot ({}) completed to {} with {}", snapshot, repository, lastSnapshotStatus)__                }_            }_        } catch (SnapshotFailedEngineException | IndexShardSnapshotFailedException e) {_            throw e__        } catch (Exception e) {_            throw new IndexShardSnapshotFailedException(shardId, "Failed to snapshot", e)__        }_    };creates,shard,snapshot,param,snapshot,snapshot,param,snapshot,status,snapshot,status;private,void,snapshot,final,index,shard,index,shard,final,snapshot,snapshot,final,index,id,index,id,final,index,shard,snapshot,status,snapshot,status,final,shard,id,shard,id,index,shard,shard,id,if,index,shard,routing,entry,primary,false,throw,new,index,shard,snapshot,failed,exception,shard,id,snapshot,should,be,performed,only,on,primary,if,index,shard,routing,entry,relocating,throw,new,index,shard,snapshot,failed,exception,shard,id,cannot,snapshot,while,relocating,final,index,shard,state,index,shard,state,index,shard,state,if,index,shard,state,index,shard,state,created,index,shard,state,index,shard,state,recovering,throw,new,index,shard,snapshot,failed,exception,shard,id,shard,didn,t,fully,recover,yet,final,repository,repository,snapshots,service,get,repositories,service,repository,snapshot,get,repository,try,try,engine,index,commit,ref,snapshot,ref,index,shard,acquire,last,index,commit,true,repository,snapshot,shard,index,shard,index,shard,store,snapshot,get,snapshot,id,index,id,snapshot,ref,get,index,commit,snapshot,status,if,logger,is,debug,enabled,final,index,shard,snapshot,status,copy,last,snapshot,status,snapshot,status,as,copy,logger,debug,snapshot,completed,to,with,snapshot,repository,last,snapshot,status,catch,snapshot,failed,engine,exception,index,shard,snapshot,failed,exception,e,throw,e,catch,exception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,snapshot,e
SnapshotShardsService -> private void snapshot(final IndexShard indexShard, final Snapshot snapshot, final IndexId indexId,                           final IndexShardSnapshotStatus snapshotStatus);1548996340;Creates shard snapshot__@param snapshot       snapshot_@param snapshotStatus snapshot status;private void snapshot(final IndexShard indexShard, final Snapshot snapshot, final IndexId indexId,_                          final IndexShardSnapshotStatus snapshotStatus) {_        final ShardId shardId = indexShard.shardId()__        if (indexShard.routingEntry().primary() == false) {_            throw new IndexShardSnapshotFailedException(shardId, "snapshot should be performed only on primary")__        }_        if (indexShard.routingEntry().relocating()) {_            _            throw new IndexShardSnapshotFailedException(shardId, "cannot snapshot while relocating")__        }__        final IndexShardState indexShardState = indexShard.state()__        if (indexShardState == IndexShardState.CREATED || indexShardState == IndexShardState.RECOVERING) {_            _            throw new IndexShardSnapshotFailedException(shardId, "shard didn't fully recover yet")__        }__        final Repository repository = snapshotsService.getRepositoriesService().repository(snapshot.getRepository())__        try {_            _            try (Engine.IndexCommitRef snapshotRef = indexShard.acquireLastIndexCommit(true)) {_                repository.snapshotShard(indexShard, indexShard.store(), snapshot.getSnapshotId(), indexId, snapshotRef.getIndexCommit(),_                    snapshotStatus)__                if (logger.isDebugEnabled()) {_                    final IndexShardSnapshotStatus.Copy lastSnapshotStatus = snapshotStatus.asCopy()__                    logger.debug("snapshot ({}) completed to {} with {}", snapshot, repository, lastSnapshotStatus)__                }_            }_        } catch (SnapshotFailedEngineException | IndexShardSnapshotFailedException e) {_            throw e__        } catch (Exception e) {_            throw new IndexShardSnapshotFailedException(shardId, "Failed to snapshot", e)__        }_    };creates,shard,snapshot,param,snapshot,snapshot,param,snapshot,status,snapshot,status;private,void,snapshot,final,index,shard,index,shard,final,snapshot,snapshot,final,index,id,index,id,final,index,shard,snapshot,status,snapshot,status,final,shard,id,shard,id,index,shard,shard,id,if,index,shard,routing,entry,primary,false,throw,new,index,shard,snapshot,failed,exception,shard,id,snapshot,should,be,performed,only,on,primary,if,index,shard,routing,entry,relocating,throw,new,index,shard,snapshot,failed,exception,shard,id,cannot,snapshot,while,relocating,final,index,shard,state,index,shard,state,index,shard,state,if,index,shard,state,index,shard,state,created,index,shard,state,index,shard,state,recovering,throw,new,index,shard,snapshot,failed,exception,shard,id,shard,didn,t,fully,recover,yet,final,repository,repository,snapshots,service,get,repositories,service,repository,snapshot,get,repository,try,try,engine,index,commit,ref,snapshot,ref,index,shard,acquire,last,index,commit,true,repository,snapshot,shard,index,shard,index,shard,store,snapshot,get,snapshot,id,index,id,snapshot,ref,get,index,commit,snapshot,status,if,logger,is,debug,enabled,final,index,shard,snapshot,status,copy,last,snapshot,status,snapshot,status,as,copy,logger,debug,snapshot,completed,to,with,snapshot,repository,last,snapshot,status,catch,snapshot,failed,engine,exception,index,shard,snapshot,failed,exception,e,throw,e,catch,exception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,snapshot,e
SnapshotShardsService -> private void snapshot(final IndexShard indexShard, final Snapshot snapshot, final IndexId indexId,                           final IndexShardSnapshotStatus snapshotStatus);1549050374;Creates shard snapshot__@param snapshot       snapshot_@param snapshotStatus snapshot status;private void snapshot(final IndexShard indexShard, final Snapshot snapshot, final IndexId indexId,_                          final IndexShardSnapshotStatus snapshotStatus) {_        final ShardId shardId = indexShard.shardId()__        if (indexShard.routingEntry().primary() == false) {_            throw new IndexShardSnapshotFailedException(shardId, "snapshot should be performed only on primary")__        }_        if (indexShard.routingEntry().relocating()) {_            _            throw new IndexShardSnapshotFailedException(shardId, "cannot snapshot while relocating")__        }__        final IndexShardState indexShardState = indexShard.state()__        if (indexShardState == IndexShardState.CREATED || indexShardState == IndexShardState.RECOVERING) {_            _            throw new IndexShardSnapshotFailedException(shardId, "shard didn't fully recover yet")__        }__        final Repository repository = snapshotsService.getRepositoriesService().repository(snapshot.getRepository())__        try {_            _            try (Engine.IndexCommitRef snapshotRef = indexShard.acquireLastIndexCommit(true)) {_                repository.snapshotShard(indexShard, indexShard.store(), snapshot.getSnapshotId(), indexId, snapshotRef.getIndexCommit(),_                    snapshotStatus)__                if (logger.isDebugEnabled()) {_                    final IndexShardSnapshotStatus.Copy lastSnapshotStatus = snapshotStatus.asCopy()__                    logger.debug("snapshot ({}) completed to {} with {}", snapshot, repository, lastSnapshotStatus)__                }_            }_        } catch (SnapshotFailedEngineException | IndexShardSnapshotFailedException e) {_            throw e__        } catch (Exception e) {_            throw new IndexShardSnapshotFailedException(shardId, "Failed to snapshot", e)__        }_    };creates,shard,snapshot,param,snapshot,snapshot,param,snapshot,status,snapshot,status;private,void,snapshot,final,index,shard,index,shard,final,snapshot,snapshot,final,index,id,index,id,final,index,shard,snapshot,status,snapshot,status,final,shard,id,shard,id,index,shard,shard,id,if,index,shard,routing,entry,primary,false,throw,new,index,shard,snapshot,failed,exception,shard,id,snapshot,should,be,performed,only,on,primary,if,index,shard,routing,entry,relocating,throw,new,index,shard,snapshot,failed,exception,shard,id,cannot,snapshot,while,relocating,final,index,shard,state,index,shard,state,index,shard,state,if,index,shard,state,index,shard,state,created,index,shard,state,index,shard,state,recovering,throw,new,index,shard,snapshot,failed,exception,shard,id,shard,didn,t,fully,recover,yet,final,repository,repository,snapshots,service,get,repositories,service,repository,snapshot,get,repository,try,try,engine,index,commit,ref,snapshot,ref,index,shard,acquire,last,index,commit,true,repository,snapshot,shard,index,shard,index,shard,store,snapshot,get,snapshot,id,index,id,snapshot,ref,get,index,commit,snapshot,status,if,logger,is,debug,enabled,final,index,shard,snapshot,status,copy,last,snapshot,status,snapshot,status,as,copy,logger,debug,snapshot,completed,to,with,snapshot,repository,last,snapshot,status,catch,snapshot,failed,engine,exception,index,shard,snapshot,failed,exception,e,throw,e,catch,exception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,snapshot,e
SnapshotShardsService -> private void snapshot(final IndexShard indexShard, final Snapshot snapshot, final IndexId indexId,                           final IndexShardSnapshotStatus snapshotStatus);1549180095;Creates shard snapshot__@param snapshot       snapshot_@param snapshotStatus snapshot status;private void snapshot(final IndexShard indexShard, final Snapshot snapshot, final IndexId indexId,_                          final IndexShardSnapshotStatus snapshotStatus) {_        final ShardId shardId = indexShard.shardId()__        if (indexShard.routingEntry().primary() == false) {_            throw new IndexShardSnapshotFailedException(shardId, "snapshot should be performed only on primary")__        }_        if (indexShard.routingEntry().relocating()) {_            _            throw new IndexShardSnapshotFailedException(shardId, "cannot snapshot while relocating")__        }__        final IndexShardState indexShardState = indexShard.state()__        if (indexShardState == IndexShardState.CREATED || indexShardState == IndexShardState.RECOVERING) {_            _            throw new IndexShardSnapshotFailedException(shardId, "shard didn't fully recover yet")__        }__        final Repository repository = snapshotsService.getRepositoriesService().repository(snapshot.getRepository())__        try {_            _            try (Engine.IndexCommitRef snapshotRef = indexShard.acquireLastIndexCommit(true)) {_                repository.snapshotShard(indexShard, indexShard.store(), snapshot.getSnapshotId(), indexId, snapshotRef.getIndexCommit(),_                    snapshotStatus)__                if (logger.isDebugEnabled()) {_                    final IndexShardSnapshotStatus.Copy lastSnapshotStatus = snapshotStatus.asCopy()__                    logger.debug("snapshot ({}) completed to {} with {}", snapshot, repository, lastSnapshotStatus)__                }_            }_        } catch (SnapshotFailedEngineException | IndexShardSnapshotFailedException e) {_            throw e__        } catch (Exception e) {_            throw new IndexShardSnapshotFailedException(shardId, "Failed to snapshot", e)__        }_    };creates,shard,snapshot,param,snapshot,snapshot,param,snapshot,status,snapshot,status;private,void,snapshot,final,index,shard,index,shard,final,snapshot,snapshot,final,index,id,index,id,final,index,shard,snapshot,status,snapshot,status,final,shard,id,shard,id,index,shard,shard,id,if,index,shard,routing,entry,primary,false,throw,new,index,shard,snapshot,failed,exception,shard,id,snapshot,should,be,performed,only,on,primary,if,index,shard,routing,entry,relocating,throw,new,index,shard,snapshot,failed,exception,shard,id,cannot,snapshot,while,relocating,final,index,shard,state,index,shard,state,index,shard,state,if,index,shard,state,index,shard,state,created,index,shard,state,index,shard,state,recovering,throw,new,index,shard,snapshot,failed,exception,shard,id,shard,didn,t,fully,recover,yet,final,repository,repository,snapshots,service,get,repositories,service,repository,snapshot,get,repository,try,try,engine,index,commit,ref,snapshot,ref,index,shard,acquire,last,index,commit,true,repository,snapshot,shard,index,shard,index,shard,store,snapshot,get,snapshot,id,index,id,snapshot,ref,get,index,commit,snapshot,status,if,logger,is,debug,enabled,final,index,shard,snapshot,status,copy,last,snapshot,status,snapshot,status,as,copy,logger,debug,snapshot,completed,to,with,snapshot,repository,last,snapshot,status,catch,snapshot,failed,engine,exception,index,shard,snapshot,failed,exception,e,throw,e,catch,exception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,snapshot,e
SnapshotShardsService -> private void snapshot(final IndexShard indexShard, final Snapshot snapshot, final IndexId indexId,                           final IndexShardSnapshotStatus snapshotStatus);1549267599;Creates shard snapshot__@param snapshot       snapshot_@param snapshotStatus snapshot status;private void snapshot(final IndexShard indexShard, final Snapshot snapshot, final IndexId indexId,_                          final IndexShardSnapshotStatus snapshotStatus) {_        final ShardId shardId = indexShard.shardId()__        if (indexShard.routingEntry().primary() == false) {_            throw new IndexShardSnapshotFailedException(shardId, "snapshot should be performed only on primary")__        }_        if (indexShard.routingEntry().relocating()) {_            _            throw new IndexShardSnapshotFailedException(shardId, "cannot snapshot while relocating")__        }__        final IndexShardState indexShardState = indexShard.state()__        if (indexShardState == IndexShardState.CREATED || indexShardState == IndexShardState.RECOVERING) {_            _            throw new IndexShardSnapshotFailedException(shardId, "shard didn't fully recover yet")__        }__        final Repository repository = snapshotsService.getRepositoriesService().repository(snapshot.getRepository())__        try {_            _            try (Engine.IndexCommitRef snapshotRef = indexShard.acquireLastIndexCommit(true)) {_                repository.snapshotShard(indexShard, indexShard.store(), snapshot.getSnapshotId(), indexId, snapshotRef.getIndexCommit(),_                    snapshotStatus)__                if (logger.isDebugEnabled()) {_                    final IndexShardSnapshotStatus.Copy lastSnapshotStatus = snapshotStatus.asCopy()__                    logger.debug("snapshot ({}) completed to {} with {}", snapshot, repository, lastSnapshotStatus)__                }_            }_        } catch (SnapshotFailedEngineException | IndexShardSnapshotFailedException e) {_            throw e__        } catch (Exception e) {_            throw new IndexShardSnapshotFailedException(shardId, "Failed to snapshot", e)__        }_    };creates,shard,snapshot,param,snapshot,snapshot,param,snapshot,status,snapshot,status;private,void,snapshot,final,index,shard,index,shard,final,snapshot,snapshot,final,index,id,index,id,final,index,shard,snapshot,status,snapshot,status,final,shard,id,shard,id,index,shard,shard,id,if,index,shard,routing,entry,primary,false,throw,new,index,shard,snapshot,failed,exception,shard,id,snapshot,should,be,performed,only,on,primary,if,index,shard,routing,entry,relocating,throw,new,index,shard,snapshot,failed,exception,shard,id,cannot,snapshot,while,relocating,final,index,shard,state,index,shard,state,index,shard,state,if,index,shard,state,index,shard,state,created,index,shard,state,index,shard,state,recovering,throw,new,index,shard,snapshot,failed,exception,shard,id,shard,didn,t,fully,recover,yet,final,repository,repository,snapshots,service,get,repositories,service,repository,snapshot,get,repository,try,try,engine,index,commit,ref,snapshot,ref,index,shard,acquire,last,index,commit,true,repository,snapshot,shard,index,shard,index,shard,store,snapshot,get,snapshot,id,index,id,snapshot,ref,get,index,commit,snapshot,status,if,logger,is,debug,enabled,final,index,shard,snapshot,status,copy,last,snapshot,status,snapshot,status,as,copy,logger,debug,snapshot,completed,to,with,snapshot,repository,last,snapshot,status,catch,snapshot,failed,engine,exception,index,shard,snapshot,failed,exception,e,throw,e,catch,exception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,snapshot,e
SnapshotShardsService -> private void snapshot(final IndexShard indexShard, final Snapshot snapshot, final IndexId indexId,                           final IndexShardSnapshotStatus snapshotStatus);1549381458;Creates shard snapshot__@param snapshot       snapshot_@param snapshotStatus snapshot status;private void snapshot(final IndexShard indexShard, final Snapshot snapshot, final IndexId indexId,_                          final IndexShardSnapshotStatus snapshotStatus) {_        final ShardId shardId = indexShard.shardId()__        if (indexShard.routingEntry().primary() == false) {_            throw new IndexShardSnapshotFailedException(shardId, "snapshot should be performed only on primary")__        }_        if (indexShard.routingEntry().relocating()) {_            _            throw new IndexShardSnapshotFailedException(shardId, "cannot snapshot while relocating")__        }__        final IndexShardState indexShardState = indexShard.state()__        if (indexShardState == IndexShardState.CREATED || indexShardState == IndexShardState.RECOVERING) {_            _            throw new IndexShardSnapshotFailedException(shardId, "shard didn't fully recover yet")__        }__        final Repository repository = snapshotsService.getRepositoriesService().repository(snapshot.getRepository())__        try {_            _            try (Engine.IndexCommitRef snapshotRef = indexShard.acquireLastIndexCommit(true)) {_                repository.snapshotShard(indexShard, indexShard.store(), snapshot.getSnapshotId(), indexId, snapshotRef.getIndexCommit(),_                    snapshotStatus)__                if (logger.isDebugEnabled()) {_                    final IndexShardSnapshotStatus.Copy lastSnapshotStatus = snapshotStatus.asCopy()__                    logger.debug("snapshot ({}) completed to {} with {}", snapshot, repository, lastSnapshotStatus)__                }_            }_        } catch (SnapshotFailedEngineException | IndexShardSnapshotFailedException e) {_            throw e__        } catch (Exception e) {_            throw new IndexShardSnapshotFailedException(shardId, "Failed to snapshot", e)__        }_    };creates,shard,snapshot,param,snapshot,snapshot,param,snapshot,status,snapshot,status;private,void,snapshot,final,index,shard,index,shard,final,snapshot,snapshot,final,index,id,index,id,final,index,shard,snapshot,status,snapshot,status,final,shard,id,shard,id,index,shard,shard,id,if,index,shard,routing,entry,primary,false,throw,new,index,shard,snapshot,failed,exception,shard,id,snapshot,should,be,performed,only,on,primary,if,index,shard,routing,entry,relocating,throw,new,index,shard,snapshot,failed,exception,shard,id,cannot,snapshot,while,relocating,final,index,shard,state,index,shard,state,index,shard,state,if,index,shard,state,index,shard,state,created,index,shard,state,index,shard,state,recovering,throw,new,index,shard,snapshot,failed,exception,shard,id,shard,didn,t,fully,recover,yet,final,repository,repository,snapshots,service,get,repositories,service,repository,snapshot,get,repository,try,try,engine,index,commit,ref,snapshot,ref,index,shard,acquire,last,index,commit,true,repository,snapshot,shard,index,shard,index,shard,store,snapshot,get,snapshot,id,index,id,snapshot,ref,get,index,commit,snapshot,status,if,logger,is,debug,enabled,final,index,shard,snapshot,status,copy,last,snapshot,status,snapshot,status,as,copy,logger,debug,snapshot,completed,to,with,snapshot,repository,last,snapshot,status,catch,snapshot,failed,engine,exception,index,shard,snapshot,failed,exception,e,throw,e,catch,exception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,snapshot,e
SnapshotShardsService -> private void processIndexShardSnapshots(SnapshotsInProgress snapshotsInProgress);1549050374;Checks if any new shards should be snapshotted on this node__@param snapshotsInProgress Current snapshots in progress in cluster state;private void processIndexShardSnapshots(SnapshotsInProgress snapshotsInProgress) {_        cancelRemoved(snapshotsInProgress)__        if (snapshotsInProgress != null) {_            startNewSnapshots(snapshotsInProgress)__        }_    };checks,if,any,new,shards,should,be,snapshotted,on,this,node,param,snapshots,in,progress,current,snapshots,in,progress,in,cluster,state;private,void,process,index,shard,snapshots,snapshots,in,progress,snapshots,in,progress,cancel,removed,snapshots,in,progress,if,snapshots,in,progress,null,start,new,snapshots,snapshots,in,progress
SnapshotShardsService -> private void processIndexShardSnapshots(SnapshotsInProgress snapshotsInProgress);1549180095;Checks if any new shards should be snapshotted on this node__@param snapshotsInProgress Current snapshots in progress in cluster state;private void processIndexShardSnapshots(SnapshotsInProgress snapshotsInProgress) {_        cancelRemoved(snapshotsInProgress)__        if (snapshotsInProgress != null) {_            startNewSnapshots(snapshotsInProgress)__        }_    };checks,if,any,new,shards,should,be,snapshotted,on,this,node,param,snapshots,in,progress,current,snapshots,in,progress,in,cluster,state;private,void,process,index,shard,snapshots,snapshots,in,progress,snapshots,in,progress,cancel,removed,snapshots,in,progress,if,snapshots,in,progress,null,start,new,snapshots,snapshots,in,progress
SnapshotShardsService -> private void processIndexShardSnapshots(SnapshotsInProgress snapshotsInProgress);1549267599;Checks if any new shards should be snapshotted on this node__@param snapshotsInProgress Current snapshots in progress in cluster state;private void processIndexShardSnapshots(SnapshotsInProgress snapshotsInProgress) {_        cancelRemoved(snapshotsInProgress)__        if (snapshotsInProgress != null) {_            startNewSnapshots(snapshotsInProgress)__        }_    };checks,if,any,new,shards,should,be,snapshotted,on,this,node,param,snapshots,in,progress,current,snapshots,in,progress,in,cluster,state;private,void,process,index,shard,snapshots,snapshots,in,progress,snapshots,in,progress,cancel,removed,snapshots,in,progress,if,snapshots,in,progress,null,start,new,snapshots,snapshots,in,progress
SnapshotShardsService -> private void processIndexShardSnapshots(SnapshotsInProgress snapshotsInProgress);1549381458;Checks if any new shards should be snapshotted on this node__@param snapshotsInProgress Current snapshots in progress in cluster state;private void processIndexShardSnapshots(SnapshotsInProgress snapshotsInProgress) {_        cancelRemoved(snapshotsInProgress)__        if (snapshotsInProgress != null) {_            startNewSnapshots(snapshotsInProgress)__        }_    };checks,if,any,new,shards,should,be,snapshotted,on,this,node,param,snapshots,in,progress,current,snapshots,in,progress,in,cluster,state;private,void,process,index,shard,snapshots,snapshots,in,progress,snapshots,in,progress,cancel,removed,snapshots,in,progress,if,snapshots,in,progress,null,start,new,snapshots,snapshots,in,progress
SnapshotShardsService -> private void syncShardStatsOnNewMaster(ClusterChangedEvent event);1524684173;Checks if any shards were processed that the new master doesn't know about;private void syncShardStatsOnNewMaster(ClusterChangedEvent event) {_        SnapshotsInProgress snapshotsInProgress = event.state().custom(SnapshotsInProgress.TYPE)__        if (snapshotsInProgress == null) {_            return__        }__        final String localNodeId = event.state().nodes().getLocalNodeId()__        for (SnapshotsInProgress.Entry snapshot : snapshotsInProgress.entries()) {_            if (snapshot.state() == State.STARTED || snapshot.state() == State.ABORTED) {_                Map<ShardId, IndexShardSnapshotStatus> localShards = currentSnapshotShards(snapshot.snapshot())__                if (localShards != null) {_                    ImmutableOpenMap<ShardId, ShardSnapshotStatus> masterShards = snapshot.shards()__                    for(Map.Entry<ShardId, IndexShardSnapshotStatus> localShard : localShards.entrySet()) {_                        ShardId shardId = localShard.getKey()__                        ShardSnapshotStatus masterShard = masterShards.get(shardId)__                        if (masterShard != null && masterShard.state().completed() == false) {_                            final IndexShardSnapshotStatus.Copy indexShardSnapshotStatus = localShard.getValue().asCopy()__                            final Stage stage = indexShardSnapshotStatus.getStage()__                            _                            if (stage == Stage.DONE) {_                                _                                logger.debug("[{}] new master thinks the shard [{}] is not completed but the shard is done locally, " +_                                             "updating status on the master", snapshot.snapshot(), shardId)__                                notifySuccessfulSnapshotShard(snapshot.snapshot(), shardId, localNodeId)___                            } else if (stage == Stage.FAILURE) {_                                _                                logger.debug("[{}] new master thinks the shard [{}] is not completed but the shard failed locally, " +_                                             "updating status on master", snapshot.snapshot(), shardId)__                                notifyFailedSnapshotShard(snapshot.snapshot(), shardId, localNodeId, indexShardSnapshotStatus.getFailure())__                            }_                        }_                    }_                }_            }_        }_    };checks,if,any,shards,were,processed,that,the,new,master,doesn,t,know,about;private,void,sync,shard,stats,on,new,master,cluster,changed,event,event,snapshots,in,progress,snapshots,in,progress,event,state,custom,snapshots,in,progress,type,if,snapshots,in,progress,null,return,final,string,local,node,id,event,state,nodes,get,local,node,id,for,snapshots,in,progress,entry,snapshot,snapshots,in,progress,entries,if,snapshot,state,state,started,snapshot,state,state,aborted,map,shard,id,index,shard,snapshot,status,local,shards,current,snapshot,shards,snapshot,snapshot,if,local,shards,null,immutable,open,map,shard,id,shard,snapshot,status,master,shards,snapshot,shards,for,map,entry,shard,id,index,shard,snapshot,status,local,shard,local,shards,entry,set,shard,id,shard,id,local,shard,get,key,shard,snapshot,status,master,shard,master,shards,get,shard,id,if,master,shard,null,master,shard,state,completed,false,final,index,shard,snapshot,status,copy,index,shard,snapshot,status,local,shard,get,value,as,copy,final,stage,stage,index,shard,snapshot,status,get,stage,if,stage,stage,done,logger,debug,new,master,thinks,the,shard,is,not,completed,but,the,shard,is,done,locally,updating,status,on,the,master,snapshot,snapshot,shard,id,notify,successful,snapshot,shard,snapshot,snapshot,shard,id,local,node,id,else,if,stage,stage,failure,logger,debug,new,master,thinks,the,shard,is,not,completed,but,the,shard,failed,locally,updating,status,on,master,snapshot,snapshot,shard,id,notify,failed,snapshot,shard,snapshot,snapshot,shard,id,local,node,id,index,shard,snapshot,status,get,failure
SnapshotShardsService -> private void syncShardStatsOnNewMaster(ClusterChangedEvent event);1536828374;Checks if any shards were processed that the new master doesn't know about;private void syncShardStatsOnNewMaster(ClusterChangedEvent event) {_        SnapshotsInProgress snapshotsInProgress = event.state().custom(SnapshotsInProgress.TYPE)__        if (snapshotsInProgress == null) {_            return__        }__        final String localNodeId = event.state().nodes().getLocalNodeId()__        for (SnapshotsInProgress.Entry snapshot : snapshotsInProgress.entries()) {_            if (snapshot.state() == State.STARTED || snapshot.state() == State.ABORTED) {_                Map<ShardId, IndexShardSnapshotStatus> localShards = currentSnapshotShards(snapshot.snapshot())__                if (localShards != null) {_                    ImmutableOpenMap<ShardId, ShardSnapshotStatus> masterShards = snapshot.shards()__                    for(Map.Entry<ShardId, IndexShardSnapshotStatus> localShard : localShards.entrySet()) {_                        ShardId shardId = localShard.getKey()__                        ShardSnapshotStatus masterShard = masterShards.get(shardId)__                        if (masterShard != null && masterShard.state().completed() == false) {_                            final IndexShardSnapshotStatus.Copy indexShardSnapshotStatus = localShard.getValue().asCopy()__                            final Stage stage = indexShardSnapshotStatus.getStage()__                            _                            if (stage == Stage.DONE) {_                                _                                logger.debug("[{}] new master thinks the shard [{}] is not completed but the shard is done locally, " +_                                             "updating status on the master", snapshot.snapshot(), shardId)__                                notifySuccessfulSnapshotShard(snapshot.snapshot(), shardId, localNodeId)___                            } else if (stage == Stage.FAILURE) {_                                _                                logger.debug("[{}] new master thinks the shard [{}] is not completed but the shard failed locally, " +_                                             "updating status on master", snapshot.snapshot(), shardId)__                                notifyFailedSnapshotShard(snapshot.snapshot(), shardId, localNodeId, indexShardSnapshotStatus.getFailure())__                            }_                        }_                    }_                }_            }_        }_    };checks,if,any,shards,were,processed,that,the,new,master,doesn,t,know,about;private,void,sync,shard,stats,on,new,master,cluster,changed,event,event,snapshots,in,progress,snapshots,in,progress,event,state,custom,snapshots,in,progress,type,if,snapshots,in,progress,null,return,final,string,local,node,id,event,state,nodes,get,local,node,id,for,snapshots,in,progress,entry,snapshot,snapshots,in,progress,entries,if,snapshot,state,state,started,snapshot,state,state,aborted,map,shard,id,index,shard,snapshot,status,local,shards,current,snapshot,shards,snapshot,snapshot,if,local,shards,null,immutable,open,map,shard,id,shard,snapshot,status,master,shards,snapshot,shards,for,map,entry,shard,id,index,shard,snapshot,status,local,shard,local,shards,entry,set,shard,id,shard,id,local,shard,get,key,shard,snapshot,status,master,shard,master,shards,get,shard,id,if,master,shard,null,master,shard,state,completed,false,final,index,shard,snapshot,status,copy,index,shard,snapshot,status,local,shard,get,value,as,copy,final,stage,stage,index,shard,snapshot,status,get,stage,if,stage,stage,done,logger,debug,new,master,thinks,the,shard,is,not,completed,but,the,shard,is,done,locally,updating,status,on,the,master,snapshot,snapshot,shard,id,notify,successful,snapshot,shard,snapshot,snapshot,shard,id,local,node,id,else,if,stage,stage,failure,logger,debug,new,master,thinks,the,shard,is,not,completed,but,the,shard,failed,locally,updating,status,on,master,snapshot,snapshot,shard,id,notify,failed,snapshot,shard,snapshot,snapshot,shard,id,local,node,id,index,shard,snapshot,status,get,failure
SnapshotShardsService -> private void syncShardStatsOnNewMaster(ClusterChangedEvent event);1541419698;Checks if any shards were processed that the new master doesn't know about;private void syncShardStatsOnNewMaster(ClusterChangedEvent event) {_        SnapshotsInProgress snapshotsInProgress = event.state().custom(SnapshotsInProgress.TYPE)__        if (snapshotsInProgress == null) {_            return__        }__        final String localNodeId = event.state().nodes().getLocalNodeId()__        for (SnapshotsInProgress.Entry snapshot : snapshotsInProgress.entries()) {_            if (snapshot.state() == State.STARTED || snapshot.state() == State.ABORTED) {_                Map<ShardId, IndexShardSnapshotStatus> localShards = currentSnapshotShards(snapshot.snapshot())__                if (localShards != null) {_                    ImmutableOpenMap<ShardId, ShardSnapshotStatus> masterShards = snapshot.shards()__                    for(Map.Entry<ShardId, IndexShardSnapshotStatus> localShard : localShards.entrySet()) {_                        ShardId shardId = localShard.getKey()__                        ShardSnapshotStatus masterShard = masterShards.get(shardId)__                        if (masterShard != null && masterShard.state().completed() == false) {_                            final IndexShardSnapshotStatus.Copy indexShardSnapshotStatus = localShard.getValue().asCopy()__                            final Stage stage = indexShardSnapshotStatus.getStage()__                            _                            if (stage == Stage.DONE) {_                                _                                logger.debug("[{}] new master thinks the shard [{}] is not completed but the shard is done locally, " +_                                             "updating status on the master", snapshot.snapshot(), shardId)__                                notifySuccessfulSnapshotShard(snapshot.snapshot(), shardId, localNodeId)___                            } else if (stage == Stage.FAILURE) {_                                _                                logger.debug("[{}] new master thinks the shard [{}] is not completed but the shard failed locally, " +_                                             "updating status on master", snapshot.snapshot(), shardId)__                                notifyFailedSnapshotShard(snapshot.snapshot(), shardId, localNodeId, indexShardSnapshotStatus.getFailure())__                            }_                        }_                    }_                }_            }_        }_    };checks,if,any,shards,were,processed,that,the,new,master,doesn,t,know,about;private,void,sync,shard,stats,on,new,master,cluster,changed,event,event,snapshots,in,progress,snapshots,in,progress,event,state,custom,snapshots,in,progress,type,if,snapshots,in,progress,null,return,final,string,local,node,id,event,state,nodes,get,local,node,id,for,snapshots,in,progress,entry,snapshot,snapshots,in,progress,entries,if,snapshot,state,state,started,snapshot,state,state,aborted,map,shard,id,index,shard,snapshot,status,local,shards,current,snapshot,shards,snapshot,snapshot,if,local,shards,null,immutable,open,map,shard,id,shard,snapshot,status,master,shards,snapshot,shards,for,map,entry,shard,id,index,shard,snapshot,status,local,shard,local,shards,entry,set,shard,id,shard,id,local,shard,get,key,shard,snapshot,status,master,shard,master,shards,get,shard,id,if,master,shard,null,master,shard,state,completed,false,final,index,shard,snapshot,status,copy,index,shard,snapshot,status,local,shard,get,value,as,copy,final,stage,stage,index,shard,snapshot,status,get,stage,if,stage,stage,done,logger,debug,new,master,thinks,the,shard,is,not,completed,but,the,shard,is,done,locally,updating,status,on,the,master,snapshot,snapshot,shard,id,notify,successful,snapshot,shard,snapshot,snapshot,shard,id,local,node,id,else,if,stage,stage,failure,logger,debug,new,master,thinks,the,shard,is,not,completed,but,the,shard,failed,locally,updating,status,on,master,snapshot,snapshot,shard,id,notify,failed,snapshot,shard,snapshot,snapshot,shard,id,local,node,id,index,shard,snapshot,status,get,failure
SnapshotShardsService -> private void syncShardStatsOnNewMaster(ClusterChangedEvent event);1542646292;Checks if any shards were processed that the new master doesn't know about;private void syncShardStatsOnNewMaster(ClusterChangedEvent event) {_        SnapshotsInProgress snapshotsInProgress = event.state().custom(SnapshotsInProgress.TYPE)__        if (snapshotsInProgress == null) {_            return__        }__        final String localNodeId = event.state().nodes().getLocalNodeId()__        for (SnapshotsInProgress.Entry snapshot : snapshotsInProgress.entries()) {_            if (snapshot.state() == State.STARTED || snapshot.state() == State.ABORTED) {_                Map<ShardId, IndexShardSnapshotStatus> localShards = currentSnapshotShards(snapshot.snapshot())__                if (localShards != null) {_                    ImmutableOpenMap<ShardId, ShardSnapshotStatus> masterShards = snapshot.shards()__                    for(Map.Entry<ShardId, IndexShardSnapshotStatus> localShard : localShards.entrySet()) {_                        ShardId shardId = localShard.getKey()__                        ShardSnapshotStatus masterShard = masterShards.get(shardId)__                        if (masterShard != null && masterShard.state().completed() == false) {_                            final IndexShardSnapshotStatus.Copy indexShardSnapshotStatus = localShard.getValue().asCopy()__                            final Stage stage = indexShardSnapshotStatus.getStage()__                            _                            if (stage == Stage.DONE) {_                                _                                logger.debug("[{}] new master thinks the shard [{}] is not completed but the shard is done locally, " +_                                             "updating status on the master", snapshot.snapshot(), shardId)__                                notifySuccessfulSnapshotShard(snapshot.snapshot(), shardId, localNodeId)___                            } else if (stage == Stage.FAILURE) {_                                _                                logger.debug("[{}] new master thinks the shard [{}] is not completed but the shard failed locally, " +_                                             "updating status on master", snapshot.snapshot(), shardId)__                                notifyFailedSnapshotShard(snapshot.snapshot(), shardId, localNodeId, indexShardSnapshotStatus.getFailure())__                            }_                        }_                    }_                }_            }_        }_    };checks,if,any,shards,were,processed,that,the,new,master,doesn,t,know,about;private,void,sync,shard,stats,on,new,master,cluster,changed,event,event,snapshots,in,progress,snapshots,in,progress,event,state,custom,snapshots,in,progress,type,if,snapshots,in,progress,null,return,final,string,local,node,id,event,state,nodes,get,local,node,id,for,snapshots,in,progress,entry,snapshot,snapshots,in,progress,entries,if,snapshot,state,state,started,snapshot,state,state,aborted,map,shard,id,index,shard,snapshot,status,local,shards,current,snapshot,shards,snapshot,snapshot,if,local,shards,null,immutable,open,map,shard,id,shard,snapshot,status,master,shards,snapshot,shards,for,map,entry,shard,id,index,shard,snapshot,status,local,shard,local,shards,entry,set,shard,id,shard,id,local,shard,get,key,shard,snapshot,status,master,shard,master,shards,get,shard,id,if,master,shard,null,master,shard,state,completed,false,final,index,shard,snapshot,status,copy,index,shard,snapshot,status,local,shard,get,value,as,copy,final,stage,stage,index,shard,snapshot,status,get,stage,if,stage,stage,done,logger,debug,new,master,thinks,the,shard,is,not,completed,but,the,shard,is,done,locally,updating,status,on,the,master,snapshot,snapshot,shard,id,notify,successful,snapshot,shard,snapshot,snapshot,shard,id,local,node,id,else,if,stage,stage,failure,logger,debug,new,master,thinks,the,shard,is,not,completed,but,the,shard,failed,locally,updating,status,on,master,snapshot,snapshot,shard,id,notify,failed,snapshot,shard,snapshot,snapshot,shard,id,local,node,id,index,shard,snapshot,status,get,failure
SnapshotShardsService -> private void syncShardStatsOnNewMaster(ClusterChangedEvent event);1542804617;Checks if any shards were processed that the new master doesn't know about;private void syncShardStatsOnNewMaster(ClusterChangedEvent event) {_        SnapshotsInProgress snapshotsInProgress = event.state().custom(SnapshotsInProgress.TYPE)__        if (snapshotsInProgress == null) {_            return__        }__        final String localNodeId = event.state().nodes().getLocalNodeId()__        for (SnapshotsInProgress.Entry snapshot : snapshotsInProgress.entries()) {_            if (snapshot.state() == State.STARTED || snapshot.state() == State.ABORTED) {_                Map<ShardId, IndexShardSnapshotStatus> localShards = currentSnapshotShards(snapshot.snapshot())__                if (localShards != null) {_                    ImmutableOpenMap<ShardId, ShardSnapshotStatus> masterShards = snapshot.shards()__                    for(Map.Entry<ShardId, IndexShardSnapshotStatus> localShard : localShards.entrySet()) {_                        ShardId shardId = localShard.getKey()__                        ShardSnapshotStatus masterShard = masterShards.get(shardId)__                        if (masterShard != null && masterShard.state().completed() == false) {_                            final IndexShardSnapshotStatus.Copy indexShardSnapshotStatus = localShard.getValue().asCopy()__                            final Stage stage = indexShardSnapshotStatus.getStage()__                            _                            if (stage == Stage.DONE) {_                                _                                logger.debug("[{}] new master thinks the shard [{}] is not completed but the shard is done locally, " +_                                             "updating status on the master", snapshot.snapshot(), shardId)__                                notifySuccessfulSnapshotShard(snapshot.snapshot(), shardId, localNodeId)___                            } else if (stage == Stage.FAILURE) {_                                _                                logger.debug("[{}] new master thinks the shard [{}] is not completed but the shard failed locally, " +_                                             "updating status on master", snapshot.snapshot(), shardId)__                                notifyFailedSnapshotShard(snapshot.snapshot(), shardId, localNodeId, indexShardSnapshotStatus.getFailure())__                            }_                        }_                    }_                }_            }_        }_    };checks,if,any,shards,were,processed,that,the,new,master,doesn,t,know,about;private,void,sync,shard,stats,on,new,master,cluster,changed,event,event,snapshots,in,progress,snapshots,in,progress,event,state,custom,snapshots,in,progress,type,if,snapshots,in,progress,null,return,final,string,local,node,id,event,state,nodes,get,local,node,id,for,snapshots,in,progress,entry,snapshot,snapshots,in,progress,entries,if,snapshot,state,state,started,snapshot,state,state,aborted,map,shard,id,index,shard,snapshot,status,local,shards,current,snapshot,shards,snapshot,snapshot,if,local,shards,null,immutable,open,map,shard,id,shard,snapshot,status,master,shards,snapshot,shards,for,map,entry,shard,id,index,shard,snapshot,status,local,shard,local,shards,entry,set,shard,id,shard,id,local,shard,get,key,shard,snapshot,status,master,shard,master,shards,get,shard,id,if,master,shard,null,master,shard,state,completed,false,final,index,shard,snapshot,status,copy,index,shard,snapshot,status,local,shard,get,value,as,copy,final,stage,stage,index,shard,snapshot,status,get,stage,if,stage,stage,done,logger,debug,new,master,thinks,the,shard,is,not,completed,but,the,shard,is,done,locally,updating,status,on,the,master,snapshot,snapshot,shard,id,notify,successful,snapshot,shard,snapshot,snapshot,shard,id,local,node,id,else,if,stage,stage,failure,logger,debug,new,master,thinks,the,shard,is,not,completed,but,the,shard,failed,locally,updating,status,on,master,snapshot,snapshot,shard,id,notify,failed,snapshot,shard,snapshot,snapshot,shard,id,local,node,id,index,shard,snapshot,status,get,failure
SnapshotShardsService -> private void syncShardStatsOnNewMaster(ClusterChangedEvent event);1543851569;Checks if any shards were processed that the new master doesn't know about;private void syncShardStatsOnNewMaster(ClusterChangedEvent event) {_        SnapshotsInProgress snapshotsInProgress = event.state().custom(SnapshotsInProgress.TYPE)__        if (snapshotsInProgress == null) {_            return__        }__        final String localNodeId = event.state().nodes().getLocalNodeId()__        for (SnapshotsInProgress.Entry snapshot : snapshotsInProgress.entries()) {_            if (snapshot.state() == State.STARTED || snapshot.state() == State.ABORTED) {_                Map<ShardId, IndexShardSnapshotStatus> localShards = currentSnapshotShards(snapshot.snapshot())__                if (localShards != null) {_                    ImmutableOpenMap<ShardId, ShardSnapshotStatus> masterShards = snapshot.shards()__                    for(Map.Entry<ShardId, IndexShardSnapshotStatus> localShard : localShards.entrySet()) {_                        ShardId shardId = localShard.getKey()__                        ShardSnapshotStatus masterShard = masterShards.get(shardId)__                        if (masterShard != null && masterShard.state().completed() == false) {_                            final IndexShardSnapshotStatus.Copy indexShardSnapshotStatus = localShard.getValue().asCopy()__                            final Stage stage = indexShardSnapshotStatus.getStage()__                            _                            if (stage == Stage.DONE) {_                                _                                logger.debug("[{}] new master thinks the shard [{}] is not completed but the shard is done locally, " +_                                             "updating status on the master", snapshot.snapshot(), shardId)__                                notifySuccessfulSnapshotShard(snapshot.snapshot(), shardId, localNodeId)___                            } else if (stage == Stage.FAILURE) {_                                _                                logger.debug("[{}] new master thinks the shard [{}] is not completed but the shard failed locally, " +_                                             "updating status on master", snapshot.snapshot(), shardId)__                                notifyFailedSnapshotShard(snapshot.snapshot(), shardId, localNodeId, indexShardSnapshotStatus.getFailure())__                            }_                        }_                    }_                }_            }_        }_    };checks,if,any,shards,were,processed,that,the,new,master,doesn,t,know,about;private,void,sync,shard,stats,on,new,master,cluster,changed,event,event,snapshots,in,progress,snapshots,in,progress,event,state,custom,snapshots,in,progress,type,if,snapshots,in,progress,null,return,final,string,local,node,id,event,state,nodes,get,local,node,id,for,snapshots,in,progress,entry,snapshot,snapshots,in,progress,entries,if,snapshot,state,state,started,snapshot,state,state,aborted,map,shard,id,index,shard,snapshot,status,local,shards,current,snapshot,shards,snapshot,snapshot,if,local,shards,null,immutable,open,map,shard,id,shard,snapshot,status,master,shards,snapshot,shards,for,map,entry,shard,id,index,shard,snapshot,status,local,shard,local,shards,entry,set,shard,id,shard,id,local,shard,get,key,shard,snapshot,status,master,shard,master,shards,get,shard,id,if,master,shard,null,master,shard,state,completed,false,final,index,shard,snapshot,status,copy,index,shard,snapshot,status,local,shard,get,value,as,copy,final,stage,stage,index,shard,snapshot,status,get,stage,if,stage,stage,done,logger,debug,new,master,thinks,the,shard,is,not,completed,but,the,shard,is,done,locally,updating,status,on,the,master,snapshot,snapshot,shard,id,notify,successful,snapshot,shard,snapshot,snapshot,shard,id,local,node,id,else,if,stage,stage,failure,logger,debug,new,master,thinks,the,shard,is,not,completed,but,the,shard,failed,locally,updating,status,on,master,snapshot,snapshot,shard,id,notify,failed,snapshot,shard,snapshot,snapshot,shard,id,local,node,id,index,shard,snapshot,status,get,failure
SnapshotShardsService -> private void syncShardStatsOnNewMaster(ClusterChangedEvent event);1545215361;Checks if any shards were processed that the new master doesn't know about;private void syncShardStatsOnNewMaster(ClusterChangedEvent event) {_        SnapshotsInProgress snapshotsInProgress = event.state().custom(SnapshotsInProgress.TYPE)__        if (snapshotsInProgress == null) {_            return__        }__        final String localNodeId = event.state().nodes().getLocalNodeId()__        for (SnapshotsInProgress.Entry snapshot : snapshotsInProgress.entries()) {_            if (snapshot.state() == State.STARTED || snapshot.state() == State.ABORTED) {_                Map<ShardId, IndexShardSnapshotStatus> localShards = currentSnapshotShards(snapshot.snapshot())__                if (localShards != null) {_                    ImmutableOpenMap<ShardId, ShardSnapshotStatus> masterShards = snapshot.shards()__                    for(Map.Entry<ShardId, IndexShardSnapshotStatus> localShard : localShards.entrySet()) {_                        ShardId shardId = localShard.getKey()__                        ShardSnapshotStatus masterShard = masterShards.get(shardId)__                        if (masterShard != null && masterShard.state().completed() == false) {_                            final IndexShardSnapshotStatus.Copy indexShardSnapshotStatus = localShard.getValue().asCopy()__                            final Stage stage = indexShardSnapshotStatus.getStage()__                            _                            if (stage == Stage.DONE) {_                                _                                logger.debug("[{}] new master thinks the shard [{}] is not completed but the shard is done locally, " +_                                             "updating status on the master", snapshot.snapshot(), shardId)__                                notifySuccessfulSnapshotShard(snapshot.snapshot(), shardId, localNodeId)___                            } else if (stage == Stage.FAILURE) {_                                _                                logger.debug("[{}] new master thinks the shard [{}] is not completed but the shard failed locally, " +_                                             "updating status on master", snapshot.snapshot(), shardId)__                                notifyFailedSnapshotShard(snapshot.snapshot(), shardId, localNodeId, indexShardSnapshotStatus.getFailure())__                            }_                        }_                    }_                }_            }_        }_    };checks,if,any,shards,were,processed,that,the,new,master,doesn,t,know,about;private,void,sync,shard,stats,on,new,master,cluster,changed,event,event,snapshots,in,progress,snapshots,in,progress,event,state,custom,snapshots,in,progress,type,if,snapshots,in,progress,null,return,final,string,local,node,id,event,state,nodes,get,local,node,id,for,snapshots,in,progress,entry,snapshot,snapshots,in,progress,entries,if,snapshot,state,state,started,snapshot,state,state,aborted,map,shard,id,index,shard,snapshot,status,local,shards,current,snapshot,shards,snapshot,snapshot,if,local,shards,null,immutable,open,map,shard,id,shard,snapshot,status,master,shards,snapshot,shards,for,map,entry,shard,id,index,shard,snapshot,status,local,shard,local,shards,entry,set,shard,id,shard,id,local,shard,get,key,shard,snapshot,status,master,shard,master,shards,get,shard,id,if,master,shard,null,master,shard,state,completed,false,final,index,shard,snapshot,status,copy,index,shard,snapshot,status,local,shard,get,value,as,copy,final,stage,stage,index,shard,snapshot,status,get,stage,if,stage,stage,done,logger,debug,new,master,thinks,the,shard,is,not,completed,but,the,shard,is,done,locally,updating,status,on,the,master,snapshot,snapshot,shard,id,notify,successful,snapshot,shard,snapshot,snapshot,shard,id,local,node,id,else,if,stage,stage,failure,logger,debug,new,master,thinks,the,shard,is,not,completed,but,the,shard,failed,locally,updating,status,on,master,snapshot,snapshot,shard,id,notify,failed,snapshot,shard,snapshot,snapshot,shard,id,local,node,id,index,shard,snapshot,status,get,failure
SnapshotShardsService -> private void syncShardStatsOnNewMaster(ClusterChangedEvent event);1547023537;Checks if any shards were processed that the new master doesn't know about;private void syncShardStatsOnNewMaster(ClusterChangedEvent event) {_        SnapshotsInProgress snapshotsInProgress = event.state().custom(SnapshotsInProgress.TYPE)__        if (snapshotsInProgress == null) {_            return__        }__        final String localNodeId = event.state().nodes().getLocalNodeId()__        for (SnapshotsInProgress.Entry snapshot : snapshotsInProgress.entries()) {_            if (snapshot.state() == State.STARTED || snapshot.state() == State.ABORTED) {_                Map<ShardId, IndexShardSnapshotStatus> localShards = currentSnapshotShards(snapshot.snapshot())__                if (localShards != null) {_                    ImmutableOpenMap<ShardId, ShardSnapshotStatus> masterShards = snapshot.shards()__                    for(Map.Entry<ShardId, IndexShardSnapshotStatus> localShard : localShards.entrySet()) {_                        ShardId shardId = localShard.getKey()__                        ShardSnapshotStatus masterShard = masterShards.get(shardId)__                        if (masterShard != null && masterShard.state().completed() == false) {_                            final IndexShardSnapshotStatus.Copy indexShardSnapshotStatus = localShard.getValue().asCopy()__                            final Stage stage = indexShardSnapshotStatus.getStage()__                            _                            if (stage == Stage.DONE) {_                                _                                logger.debug("[{}] new master thinks the shard [{}] is not completed but the shard is done locally, " +_                                             "updating status on the master", snapshot.snapshot(), shardId)__                                notifySuccessfulSnapshotShard(snapshot.snapshot(), shardId, localNodeId)___                            } else if (stage == Stage.FAILURE) {_                                _                                logger.debug("[{}] new master thinks the shard [{}] is not completed but the shard failed locally, " +_                                             "updating status on master", snapshot.snapshot(), shardId)__                                notifyFailedSnapshotShard(snapshot.snapshot(), shardId, localNodeId, indexShardSnapshotStatus.getFailure())__                            }_                        }_                    }_                }_            }_        }_    };checks,if,any,shards,were,processed,that,the,new,master,doesn,t,know,about;private,void,sync,shard,stats,on,new,master,cluster,changed,event,event,snapshots,in,progress,snapshots,in,progress,event,state,custom,snapshots,in,progress,type,if,snapshots,in,progress,null,return,final,string,local,node,id,event,state,nodes,get,local,node,id,for,snapshots,in,progress,entry,snapshot,snapshots,in,progress,entries,if,snapshot,state,state,started,snapshot,state,state,aborted,map,shard,id,index,shard,snapshot,status,local,shards,current,snapshot,shards,snapshot,snapshot,if,local,shards,null,immutable,open,map,shard,id,shard,snapshot,status,master,shards,snapshot,shards,for,map,entry,shard,id,index,shard,snapshot,status,local,shard,local,shards,entry,set,shard,id,shard,id,local,shard,get,key,shard,snapshot,status,master,shard,master,shards,get,shard,id,if,master,shard,null,master,shard,state,completed,false,final,index,shard,snapshot,status,copy,index,shard,snapshot,status,local,shard,get,value,as,copy,final,stage,stage,index,shard,snapshot,status,get,stage,if,stage,stage,done,logger,debug,new,master,thinks,the,shard,is,not,completed,but,the,shard,is,done,locally,updating,status,on,the,master,snapshot,snapshot,shard,id,notify,successful,snapshot,shard,snapshot,snapshot,shard,id,local,node,id,else,if,stage,stage,failure,logger,debug,new,master,thinks,the,shard,is,not,completed,but,the,shard,failed,locally,updating,status,on,master,snapshot,snapshot,shard,id,notify,failed,snapshot,shard,snapshot,snapshot,shard,id,local,node,id,index,shard,snapshot,status,get,failure
SnapshotShardsService -> private void syncShardStatsOnNewMaster(ClusterChangedEvent event);1547625930;Checks if any shards were processed that the new master doesn't know about;private void syncShardStatsOnNewMaster(ClusterChangedEvent event) {_        SnapshotsInProgress snapshotsInProgress = event.state().custom(SnapshotsInProgress.TYPE)__        if (snapshotsInProgress == null) {_            return__        }__        final String localNodeId = event.state().nodes().getLocalNodeId()__        for (SnapshotsInProgress.Entry snapshot : snapshotsInProgress.entries()) {_            if (snapshot.state() == State.STARTED || snapshot.state() == State.ABORTED) {_                Map<ShardId, IndexShardSnapshotStatus> localShards = currentSnapshotShards(snapshot.snapshot())__                if (localShards != null) {_                    ImmutableOpenMap<ShardId, ShardSnapshotStatus> masterShards = snapshot.shards()__                    for(Map.Entry<ShardId, IndexShardSnapshotStatus> localShard : localShards.entrySet()) {_                        ShardId shardId = localShard.getKey()__                        ShardSnapshotStatus masterShard = masterShards.get(shardId)__                        if (masterShard != null && masterShard.state().completed() == false) {_                            final IndexShardSnapshotStatus.Copy indexShardSnapshotStatus = localShard.getValue().asCopy()__                            final Stage stage = indexShardSnapshotStatus.getStage()__                            _                            if (stage == Stage.DONE) {_                                _                                logger.debug("[{}] new master thinks the shard [{}] is not completed but the shard is done locally, " +_                                             "updating status on the master", snapshot.snapshot(), shardId)__                                notifySuccessfulSnapshotShard(snapshot.snapshot(), shardId, localNodeId)___                            } else if (stage == Stage.FAILURE) {_                                _                                logger.debug("[{}] new master thinks the shard [{}] is not completed but the shard failed locally, " +_                                             "updating status on master", snapshot.snapshot(), shardId)__                                notifyFailedSnapshotShard(snapshot.snapshot(), shardId, localNodeId, indexShardSnapshotStatus.getFailure())__                            }_                        }_                    }_                }_            }_        }_    };checks,if,any,shards,were,processed,that,the,new,master,doesn,t,know,about;private,void,sync,shard,stats,on,new,master,cluster,changed,event,event,snapshots,in,progress,snapshots,in,progress,event,state,custom,snapshots,in,progress,type,if,snapshots,in,progress,null,return,final,string,local,node,id,event,state,nodes,get,local,node,id,for,snapshots,in,progress,entry,snapshot,snapshots,in,progress,entries,if,snapshot,state,state,started,snapshot,state,state,aborted,map,shard,id,index,shard,snapshot,status,local,shards,current,snapshot,shards,snapshot,snapshot,if,local,shards,null,immutable,open,map,shard,id,shard,snapshot,status,master,shards,snapshot,shards,for,map,entry,shard,id,index,shard,snapshot,status,local,shard,local,shards,entry,set,shard,id,shard,id,local,shard,get,key,shard,snapshot,status,master,shard,master,shards,get,shard,id,if,master,shard,null,master,shard,state,completed,false,final,index,shard,snapshot,status,copy,index,shard,snapshot,status,local,shard,get,value,as,copy,final,stage,stage,index,shard,snapshot,status,get,stage,if,stage,stage,done,logger,debug,new,master,thinks,the,shard,is,not,completed,but,the,shard,is,done,locally,updating,status,on,the,master,snapshot,snapshot,shard,id,notify,successful,snapshot,shard,snapshot,snapshot,shard,id,local,node,id,else,if,stage,stage,failure,logger,debug,new,master,thinks,the,shard,is,not,completed,but,the,shard,failed,locally,updating,status,on,master,snapshot,snapshot,shard,id,notify,failed,snapshot,shard,snapshot,snapshot,shard,id,local,node,id,index,shard,snapshot,status,get,failure
SnapshotShardsService -> private void syncShardStatsOnNewMaster(ClusterChangedEvent event);1548996340;Checks if any shards were processed that the new master doesn't know about;private void syncShardStatsOnNewMaster(ClusterChangedEvent event) {_        SnapshotsInProgress snapshotsInProgress = event.state().custom(SnapshotsInProgress.TYPE)__        if (snapshotsInProgress == null) {_            return__        }__        final String localNodeId = event.state().nodes().getLocalNodeId()__        for (SnapshotsInProgress.Entry snapshot : snapshotsInProgress.entries()) {_            if (snapshot.state() == State.STARTED || snapshot.state() == State.ABORTED) {_                Map<ShardId, IndexShardSnapshotStatus> localShards = currentSnapshotShards(snapshot.snapshot())__                if (localShards != null) {_                    ImmutableOpenMap<ShardId, ShardSnapshotStatus> masterShards = snapshot.shards()__                    for(Map.Entry<ShardId, IndexShardSnapshotStatus> localShard : localShards.entrySet()) {_                        ShardId shardId = localShard.getKey()__                        ShardSnapshotStatus masterShard = masterShards.get(shardId)__                        if (masterShard != null && masterShard.state().completed() == false) {_                            final IndexShardSnapshotStatus.Copy indexShardSnapshotStatus = localShard.getValue().asCopy()__                            final Stage stage = indexShardSnapshotStatus.getStage()__                            _                            if (stage == Stage.DONE) {_                                _                                logger.debug("[{}] new master thinks the shard [{}] is not completed but the shard is done locally, " +_                                             "updating status on the master", snapshot.snapshot(), shardId)__                                notifySuccessfulSnapshotShard(snapshot.snapshot(), shardId, localNodeId)___                            } else if (stage == Stage.FAILURE) {_                                _                                logger.debug("[{}] new master thinks the shard [{}] is not completed but the shard failed locally, " +_                                             "updating status on master", snapshot.snapshot(), shardId)__                                notifyFailedSnapshotShard(snapshot.snapshot(), shardId, localNodeId, indexShardSnapshotStatus.getFailure())__                            }_                        }_                    }_                }_            }_        }_    };checks,if,any,shards,were,processed,that,the,new,master,doesn,t,know,about;private,void,sync,shard,stats,on,new,master,cluster,changed,event,event,snapshots,in,progress,snapshots,in,progress,event,state,custom,snapshots,in,progress,type,if,snapshots,in,progress,null,return,final,string,local,node,id,event,state,nodes,get,local,node,id,for,snapshots,in,progress,entry,snapshot,snapshots,in,progress,entries,if,snapshot,state,state,started,snapshot,state,state,aborted,map,shard,id,index,shard,snapshot,status,local,shards,current,snapshot,shards,snapshot,snapshot,if,local,shards,null,immutable,open,map,shard,id,shard,snapshot,status,master,shards,snapshot,shards,for,map,entry,shard,id,index,shard,snapshot,status,local,shard,local,shards,entry,set,shard,id,shard,id,local,shard,get,key,shard,snapshot,status,master,shard,master,shards,get,shard,id,if,master,shard,null,master,shard,state,completed,false,final,index,shard,snapshot,status,copy,index,shard,snapshot,status,local,shard,get,value,as,copy,final,stage,stage,index,shard,snapshot,status,get,stage,if,stage,stage,done,logger,debug,new,master,thinks,the,shard,is,not,completed,but,the,shard,is,done,locally,updating,status,on,the,master,snapshot,snapshot,shard,id,notify,successful,snapshot,shard,snapshot,snapshot,shard,id,local,node,id,else,if,stage,stage,failure,logger,debug,new,master,thinks,the,shard,is,not,completed,but,the,shard,failed,locally,updating,status,on,master,snapshot,snapshot,shard,id,notify,failed,snapshot,shard,snapshot,snapshot,shard,id,local,node,id,index,shard,snapshot,status,get,failure
SnapshotShardsService -> private void syncShardStatsOnNewMaster(ClusterChangedEvent event);1549050374;Checks if any shards were processed that the new master doesn't know about;private void syncShardStatsOnNewMaster(ClusterChangedEvent event) {_        SnapshotsInProgress snapshotsInProgress = event.state().custom(SnapshotsInProgress.TYPE)__        if (snapshotsInProgress == null) {_            return__        }__        for (SnapshotsInProgress.Entry snapshot : snapshotsInProgress.entries()) {_            if (snapshot.state() == State.STARTED || snapshot.state() == State.ABORTED) {_                Map<ShardId, IndexShardSnapshotStatus> localShards = currentSnapshotShards(snapshot.snapshot())__                if (localShards != null) {_                    ImmutableOpenMap<ShardId, ShardSnapshotStatus> masterShards = snapshot.shards()__                    for(Map.Entry<ShardId, IndexShardSnapshotStatus> localShard : localShards.entrySet()) {_                        ShardId shardId = localShard.getKey()__                        ShardSnapshotStatus masterShard = masterShards.get(shardId)__                        if (masterShard != null && masterShard.state().completed() == false) {_                            final IndexShardSnapshotStatus.Copy indexShardSnapshotStatus = localShard.getValue().asCopy()__                            final Stage stage = indexShardSnapshotStatus.getStage()__                            _                            if (stage == Stage.DONE) {_                                _                                logger.debug("[{}] new master thinks the shard [{}] is not completed but the shard is done locally, " +_                                             "updating status on the master", snapshot.snapshot(), shardId)__                                notifySuccessfulSnapshotShard(snapshot.snapshot(), shardId)___                            } else if (stage == Stage.FAILURE) {_                                _                                logger.debug("[{}] new master thinks the shard [{}] is not completed but the shard failed locally, " +_                                             "updating status on master", snapshot.snapshot(), shardId)__                                notifyFailedSnapshotShard(snapshot.snapshot(), shardId, indexShardSnapshotStatus.getFailure())__                            }_                        }_                    }_                }_            }_        }_    };checks,if,any,shards,were,processed,that,the,new,master,doesn,t,know,about;private,void,sync,shard,stats,on,new,master,cluster,changed,event,event,snapshots,in,progress,snapshots,in,progress,event,state,custom,snapshots,in,progress,type,if,snapshots,in,progress,null,return,for,snapshots,in,progress,entry,snapshot,snapshots,in,progress,entries,if,snapshot,state,state,started,snapshot,state,state,aborted,map,shard,id,index,shard,snapshot,status,local,shards,current,snapshot,shards,snapshot,snapshot,if,local,shards,null,immutable,open,map,shard,id,shard,snapshot,status,master,shards,snapshot,shards,for,map,entry,shard,id,index,shard,snapshot,status,local,shard,local,shards,entry,set,shard,id,shard,id,local,shard,get,key,shard,snapshot,status,master,shard,master,shards,get,shard,id,if,master,shard,null,master,shard,state,completed,false,final,index,shard,snapshot,status,copy,index,shard,snapshot,status,local,shard,get,value,as,copy,final,stage,stage,index,shard,snapshot,status,get,stage,if,stage,stage,done,logger,debug,new,master,thinks,the,shard,is,not,completed,but,the,shard,is,done,locally,updating,status,on,the,master,snapshot,snapshot,shard,id,notify,successful,snapshot,shard,snapshot,snapshot,shard,id,else,if,stage,stage,failure,logger,debug,new,master,thinks,the,shard,is,not,completed,but,the,shard,failed,locally,updating,status,on,master,snapshot,snapshot,shard,id,notify,failed,snapshot,shard,snapshot,snapshot,shard,id,index,shard,snapshot,status,get,failure
SnapshotShardsService -> private void syncShardStatsOnNewMaster(ClusterChangedEvent event);1549180095;Checks if any shards were processed that the new master doesn't know about;private void syncShardStatsOnNewMaster(ClusterChangedEvent event) {_        SnapshotsInProgress snapshotsInProgress = event.state().custom(SnapshotsInProgress.TYPE)__        if (snapshotsInProgress == null) {_            return__        }__        for (SnapshotsInProgress.Entry snapshot : snapshotsInProgress.entries()) {_            if (snapshot.state() == State.STARTED || snapshot.state() == State.ABORTED) {_                Map<ShardId, IndexShardSnapshotStatus> localShards = currentSnapshotShards(snapshot.snapshot())__                if (localShards != null) {_                    ImmutableOpenMap<ShardId, ShardSnapshotStatus> masterShards = snapshot.shards()__                    for(Map.Entry<ShardId, IndexShardSnapshotStatus> localShard : localShards.entrySet()) {_                        ShardId shardId = localShard.getKey()__                        ShardSnapshotStatus masterShard = masterShards.get(shardId)__                        if (masterShard != null && masterShard.state().completed() == false) {_                            final IndexShardSnapshotStatus.Copy indexShardSnapshotStatus = localShard.getValue().asCopy()__                            final Stage stage = indexShardSnapshotStatus.getStage()__                            _                            if (stage == Stage.DONE) {_                                _                                logger.debug("[{}] new master thinks the shard [{}] is not completed but the shard is done locally, " +_                                             "updating status on the master", snapshot.snapshot(), shardId)__                                notifySuccessfulSnapshotShard(snapshot.snapshot(), shardId)___                            } else if (stage == Stage.FAILURE) {_                                _                                logger.debug("[{}] new master thinks the shard [{}] is not completed but the shard failed locally, " +_                                             "updating status on master", snapshot.snapshot(), shardId)__                                notifyFailedSnapshotShard(snapshot.snapshot(), shardId, indexShardSnapshotStatus.getFailure())__                            }_                        }_                    }_                }_            }_        }_    };checks,if,any,shards,were,processed,that,the,new,master,doesn,t,know,about;private,void,sync,shard,stats,on,new,master,cluster,changed,event,event,snapshots,in,progress,snapshots,in,progress,event,state,custom,snapshots,in,progress,type,if,snapshots,in,progress,null,return,for,snapshots,in,progress,entry,snapshot,snapshots,in,progress,entries,if,snapshot,state,state,started,snapshot,state,state,aborted,map,shard,id,index,shard,snapshot,status,local,shards,current,snapshot,shards,snapshot,snapshot,if,local,shards,null,immutable,open,map,shard,id,shard,snapshot,status,master,shards,snapshot,shards,for,map,entry,shard,id,index,shard,snapshot,status,local,shard,local,shards,entry,set,shard,id,shard,id,local,shard,get,key,shard,snapshot,status,master,shard,master,shards,get,shard,id,if,master,shard,null,master,shard,state,completed,false,final,index,shard,snapshot,status,copy,index,shard,snapshot,status,local,shard,get,value,as,copy,final,stage,stage,index,shard,snapshot,status,get,stage,if,stage,stage,done,logger,debug,new,master,thinks,the,shard,is,not,completed,but,the,shard,is,done,locally,updating,status,on,the,master,snapshot,snapshot,shard,id,notify,successful,snapshot,shard,snapshot,snapshot,shard,id,else,if,stage,stage,failure,logger,debug,new,master,thinks,the,shard,is,not,completed,but,the,shard,failed,locally,updating,status,on,master,snapshot,snapshot,shard,id,notify,failed,snapshot,shard,snapshot,snapshot,shard,id,index,shard,snapshot,status,get,failure
SnapshotShardsService -> private void syncShardStatsOnNewMaster(ClusterChangedEvent event);1549267599;Checks if any shards were processed that the new master doesn't know about;private void syncShardStatsOnNewMaster(ClusterChangedEvent event) {_        SnapshotsInProgress snapshotsInProgress = event.state().custom(SnapshotsInProgress.TYPE)__        if (snapshotsInProgress == null) {_            return__        }__        for (SnapshotsInProgress.Entry snapshot : snapshotsInProgress.entries()) {_            if (snapshot.state() == State.STARTED || snapshot.state() == State.ABORTED) {_                Map<ShardId, IndexShardSnapshotStatus> localShards = currentSnapshotShards(snapshot.snapshot())__                if (localShards != null) {_                    ImmutableOpenMap<ShardId, ShardSnapshotStatus> masterShards = snapshot.shards()__                    for(Map.Entry<ShardId, IndexShardSnapshotStatus> localShard : localShards.entrySet()) {_                        ShardId shardId = localShard.getKey()__                        ShardSnapshotStatus masterShard = masterShards.get(shardId)__                        if (masterShard != null && masterShard.state().completed() == false) {_                            final IndexShardSnapshotStatus.Copy indexShardSnapshotStatus = localShard.getValue().asCopy()__                            final Stage stage = indexShardSnapshotStatus.getStage()__                            _                            if (stage == Stage.DONE) {_                                _                                logger.debug("[{}] new master thinks the shard [{}] is not completed but the shard is done locally, " +_                                             "updating status on the master", snapshot.snapshot(), shardId)__                                notifySuccessfulSnapshotShard(snapshot.snapshot(), shardId)___                            } else if (stage == Stage.FAILURE) {_                                _                                logger.debug("[{}] new master thinks the shard [{}] is not completed but the shard failed locally, " +_                                             "updating status on master", snapshot.snapshot(), shardId)__                                notifyFailedSnapshotShard(snapshot.snapshot(), shardId, indexShardSnapshotStatus.getFailure())__                            }_                        }_                    }_                }_            }_        }_    };checks,if,any,shards,were,processed,that,the,new,master,doesn,t,know,about;private,void,sync,shard,stats,on,new,master,cluster,changed,event,event,snapshots,in,progress,snapshots,in,progress,event,state,custom,snapshots,in,progress,type,if,snapshots,in,progress,null,return,for,snapshots,in,progress,entry,snapshot,snapshots,in,progress,entries,if,snapshot,state,state,started,snapshot,state,state,aborted,map,shard,id,index,shard,snapshot,status,local,shards,current,snapshot,shards,snapshot,snapshot,if,local,shards,null,immutable,open,map,shard,id,shard,snapshot,status,master,shards,snapshot,shards,for,map,entry,shard,id,index,shard,snapshot,status,local,shard,local,shards,entry,set,shard,id,shard,id,local,shard,get,key,shard,snapshot,status,master,shard,master,shards,get,shard,id,if,master,shard,null,master,shard,state,completed,false,final,index,shard,snapshot,status,copy,index,shard,snapshot,status,local,shard,get,value,as,copy,final,stage,stage,index,shard,snapshot,status,get,stage,if,stage,stage,done,logger,debug,new,master,thinks,the,shard,is,not,completed,but,the,shard,is,done,locally,updating,status,on,the,master,snapshot,snapshot,shard,id,notify,successful,snapshot,shard,snapshot,snapshot,shard,id,else,if,stage,stage,failure,logger,debug,new,master,thinks,the,shard,is,not,completed,but,the,shard,failed,locally,updating,status,on,master,snapshot,snapshot,shard,id,notify,failed,snapshot,shard,snapshot,snapshot,shard,id,index,shard,snapshot,status,get,failure
SnapshotShardsService -> private void syncShardStatsOnNewMaster(ClusterChangedEvent event);1549381458;Checks if any shards were processed that the new master doesn't know about;private void syncShardStatsOnNewMaster(ClusterChangedEvent event) {_        SnapshotsInProgress snapshotsInProgress = event.state().custom(SnapshotsInProgress.TYPE)__        if (snapshotsInProgress == null) {_            return__        }__        for (SnapshotsInProgress.Entry snapshot : snapshotsInProgress.entries()) {_            if (snapshot.state() == State.STARTED || snapshot.state() == State.ABORTED) {_                Map<ShardId, IndexShardSnapshotStatus> localShards = currentSnapshotShards(snapshot.snapshot())__                if (localShards != null) {_                    ImmutableOpenMap<ShardId, ShardSnapshotStatus> masterShards = snapshot.shards()__                    for(Map.Entry<ShardId, IndexShardSnapshotStatus> localShard : localShards.entrySet()) {_                        ShardId shardId = localShard.getKey()__                        ShardSnapshotStatus masterShard = masterShards.get(shardId)__                        if (masterShard != null && masterShard.state().completed() == false) {_                            final IndexShardSnapshotStatus.Copy indexShardSnapshotStatus = localShard.getValue().asCopy()__                            final Stage stage = indexShardSnapshotStatus.getStage()__                            _                            if (stage == Stage.DONE) {_                                _                                logger.debug("[{}] new master thinks the shard [{}] is not completed but the shard is done locally, " +_                                             "updating status on the master", snapshot.snapshot(), shardId)__                                notifySuccessfulSnapshotShard(snapshot.snapshot(), shardId)___                            } else if (stage == Stage.FAILURE) {_                                _                                logger.debug("[{}] new master thinks the shard [{}] is not completed but the shard failed locally, " +_                                             "updating status on master", snapshot.snapshot(), shardId)__                                notifyFailedSnapshotShard(snapshot.snapshot(), shardId, indexShardSnapshotStatus.getFailure())__                            }_                        }_                    }_                }_            }_        }_    };checks,if,any,shards,were,processed,that,the,new,master,doesn,t,know,about;private,void,sync,shard,stats,on,new,master,cluster,changed,event,event,snapshots,in,progress,snapshots,in,progress,event,state,custom,snapshots,in,progress,type,if,snapshots,in,progress,null,return,for,snapshots,in,progress,entry,snapshot,snapshots,in,progress,entries,if,snapshot,state,state,started,snapshot,state,state,aborted,map,shard,id,index,shard,snapshot,status,local,shards,current,snapshot,shards,snapshot,snapshot,if,local,shards,null,immutable,open,map,shard,id,shard,snapshot,status,master,shards,snapshot,shards,for,map,entry,shard,id,index,shard,snapshot,status,local,shard,local,shards,entry,set,shard,id,shard,id,local,shard,get,key,shard,snapshot,status,master,shard,master,shards,get,shard,id,if,master,shard,null,master,shard,state,completed,false,final,index,shard,snapshot,status,copy,index,shard,snapshot,status,local,shard,get,value,as,copy,final,stage,stage,index,shard,snapshot,status,get,stage,if,stage,stage,done,logger,debug,new,master,thinks,the,shard,is,not,completed,but,the,shard,is,done,locally,updating,status,on,the,master,snapshot,snapshot,shard,id,notify,successful,snapshot,shard,snapshot,snapshot,shard,id,else,if,stage,stage,failure,logger,debug,new,master,thinks,the,shard,is,not,completed,but,the,shard,failed,locally,updating,status,on,master,snapshot,snapshot,shard,id,notify,failed,snapshot,shard,snapshot,snapshot,shard,id,index,shard,snapshot,status,get,failure
SnapshotShardsService -> private void notifySuccessfulSnapshotShard(final Snapshot snapshot, final ShardId shardId);1549050374;Notify the master node that the given shard has been successfully snapshotted *;private void notifySuccessfulSnapshotShard(final Snapshot snapshot, final ShardId shardId) {_        sendSnapshotShardUpdate(snapshot, shardId, new ShardSnapshotStatus(clusterService.localNode().getId(), State.SUCCESS))__    };notify,the,master,node,that,the,given,shard,has,been,successfully,snapshotted;private,void,notify,successful,snapshot,shard,final,snapshot,snapshot,final,shard,id,shard,id,send,snapshot,shard,update,snapshot,shard,id,new,shard,snapshot,status,cluster,service,local,node,get,id,state,success
SnapshotShardsService -> private void notifySuccessfulSnapshotShard(final Snapshot snapshot, final ShardId shardId);1549180095;Notify the master node that the given shard has been successfully snapshotted *;private void notifySuccessfulSnapshotShard(final Snapshot snapshot, final ShardId shardId) {_        sendSnapshotShardUpdate(snapshot, shardId, new ShardSnapshotStatus(clusterService.localNode().getId(), State.SUCCESS))__    };notify,the,master,node,that,the,given,shard,has,been,successfully,snapshotted;private,void,notify,successful,snapshot,shard,final,snapshot,snapshot,final,shard,id,shard,id,send,snapshot,shard,update,snapshot,shard,id,new,shard,snapshot,status,cluster,service,local,node,get,id,state,success
SnapshotShardsService -> private void notifySuccessfulSnapshotShard(final Snapshot snapshot, final ShardId shardId);1549267599;Notify the master node that the given shard has been successfully snapshotted *;private void notifySuccessfulSnapshotShard(final Snapshot snapshot, final ShardId shardId) {_        sendSnapshotShardUpdate(snapshot, shardId, new ShardSnapshotStatus(clusterService.localNode().getId(), State.SUCCESS))__    };notify,the,master,node,that,the,given,shard,has,been,successfully,snapshotted;private,void,notify,successful,snapshot,shard,final,snapshot,snapshot,final,shard,id,shard,id,send,snapshot,shard,update,snapshot,shard,id,new,shard,snapshot,status,cluster,service,local,node,get,id,state,success
SnapshotShardsService -> private void notifySuccessfulSnapshotShard(final Snapshot snapshot, final ShardId shardId);1549381458;Notify the master node that the given shard has been successfully snapshotted *;private void notifySuccessfulSnapshotShard(final Snapshot snapshot, final ShardId shardId) {_        sendSnapshotShardUpdate(snapshot, shardId, new ShardSnapshotStatus(clusterService.localNode().getId(), State.SUCCESS))__    };notify,the,master,node,that,the,given,shard,has,been,successfully,snapshotted;private,void,notify,successful,snapshot,shard,final,snapshot,snapshot,final,shard,id,shard,id,send,snapshot,shard,update,snapshot,shard,id,new,shard,snapshot,status,cluster,service,local,node,get,id,state,success
SnapshotShardsService -> void sendSnapshotShardUpdate(final Snapshot snapshot, final ShardId shardId, final ShardSnapshotStatus status);1524684173;Updates the shard snapshot status by sending a {@link UpdateIndexShardSnapshotStatusRequest} to the master node;void sendSnapshotShardUpdate(final Snapshot snapshot, final ShardId shardId, final ShardSnapshotStatus status) {_        try {_            UpdateIndexShardSnapshotStatusRequest request = new UpdateIndexShardSnapshotStatusRequest(snapshot, shardId, status)__            transportService.sendRequest(transportService.getLocalNode(), UPDATE_SNAPSHOT_STATUS_ACTION_NAME, request, INSTANCE_SAME)__        } catch (Exception e) {_            logger.warn(() -> new ParameterizedMessage("[{}] [{}] failed to update snapshot state", snapshot, status), e)__        }_    };updates,the,shard,snapshot,status,by,sending,a,link,update,index,shard,snapshot,status,request,to,the,master,node;void,send,snapshot,shard,update,final,snapshot,snapshot,final,shard,id,shard,id,final,shard,snapshot,status,status,try,update,index,shard,snapshot,status,request,request,new,update,index,shard,snapshot,status,request,snapshot,shard,id,status,transport,service,send,request,transport,service,get,local,node,request,catch,exception,e,logger,warn,new,parameterized,message,failed,to,update,snapshot,state,snapshot,status,e
SnapshotShardsService -> void sendSnapshotShardUpdate(final Snapshot snapshot, final ShardId shardId, final ShardSnapshotStatus status);1536828374;Updates the shard snapshot status by sending a {@link UpdateIndexShardSnapshotStatusRequest} to the master node;void sendSnapshotShardUpdate(final Snapshot snapshot, final ShardId shardId, final ShardSnapshotStatus status) {_        try {_            UpdateIndexShardSnapshotStatusRequest request = new UpdateIndexShardSnapshotStatusRequest(snapshot, shardId, status)__            transportService.sendRequest(transportService.getLocalNode(), UPDATE_SNAPSHOT_STATUS_ACTION_NAME, request, INSTANCE_SAME)__        } catch (Exception e) {_            logger.warn(() -> new ParameterizedMessage("[{}] [{}] failed to update snapshot state", snapshot, status), e)__        }_    };updates,the,shard,snapshot,status,by,sending,a,link,update,index,shard,snapshot,status,request,to,the,master,node;void,send,snapshot,shard,update,final,snapshot,snapshot,final,shard,id,shard,id,final,shard,snapshot,status,status,try,update,index,shard,snapshot,status,request,request,new,update,index,shard,snapshot,status,request,snapshot,shard,id,status,transport,service,send,request,transport,service,get,local,node,request,catch,exception,e,logger,warn,new,parameterized,message,failed,to,update,snapshot,state,snapshot,status,e
SnapshotShardsService -> void sendSnapshotShardUpdate(final Snapshot snapshot, final ShardId shardId, final ShardSnapshotStatus status);1541419698;Updates the shard snapshot status by sending a {@link UpdateIndexShardSnapshotStatusRequest} to the master node;void sendSnapshotShardUpdate(final Snapshot snapshot, final ShardId shardId, final ShardSnapshotStatus status) {_        try {_            UpdateIndexShardSnapshotStatusRequest request = new UpdateIndexShardSnapshotStatusRequest(snapshot, shardId, status)__            transportService.sendRequest(transportService.getLocalNode(), UPDATE_SNAPSHOT_STATUS_ACTION_NAME, request, INSTANCE_SAME)__        } catch (Exception e) {_            logger.warn(() -> new ParameterizedMessage("[{}] [{}] failed to update snapshot state", snapshot, status), e)__        }_    };updates,the,shard,snapshot,status,by,sending,a,link,update,index,shard,snapshot,status,request,to,the,master,node;void,send,snapshot,shard,update,final,snapshot,snapshot,final,shard,id,shard,id,final,shard,snapshot,status,status,try,update,index,shard,snapshot,status,request,request,new,update,index,shard,snapshot,status,request,snapshot,shard,id,status,transport,service,send,request,transport,service,get,local,node,request,catch,exception,e,logger,warn,new,parameterized,message,failed,to,update,snapshot,state,snapshot,status,e
SnapshotShardsService -> void sendSnapshotShardUpdate(final Snapshot snapshot, final ShardId shardId, final ShardSnapshotStatus status);1542646292;Updates the shard snapshot status by sending a {@link UpdateIndexShardSnapshotStatusRequest} to the master node;void sendSnapshotShardUpdate(final Snapshot snapshot, final ShardId shardId, final ShardSnapshotStatus status) {_        try {_            UpdateIndexShardSnapshotStatusRequest request = new UpdateIndexShardSnapshotStatusRequest(snapshot, shardId, status)__            transportService.sendRequest(transportService.getLocalNode(), UPDATE_SNAPSHOT_STATUS_ACTION_NAME, request, INSTANCE_SAME)__        } catch (Exception e) {_            logger.warn(() -> new ParameterizedMessage("[{}] [{}] failed to update snapshot state", snapshot, status), e)__        }_    };updates,the,shard,snapshot,status,by,sending,a,link,update,index,shard,snapshot,status,request,to,the,master,node;void,send,snapshot,shard,update,final,snapshot,snapshot,final,shard,id,shard,id,final,shard,snapshot,status,status,try,update,index,shard,snapshot,status,request,request,new,update,index,shard,snapshot,status,request,snapshot,shard,id,status,transport,service,send,request,transport,service,get,local,node,request,catch,exception,e,logger,warn,new,parameterized,message,failed,to,update,snapshot,state,snapshot,status,e
SnapshotShardsService -> void sendSnapshotShardUpdate(final Snapshot snapshot, final ShardId shardId, final ShardSnapshotStatus status);1542804617;Updates the shard snapshot status by sending a {@link UpdateIndexShardSnapshotStatusRequest} to the master node;void sendSnapshotShardUpdate(final Snapshot snapshot, final ShardId shardId, final ShardSnapshotStatus status) {_        try {_            UpdateIndexShardSnapshotStatusRequest request = new UpdateIndexShardSnapshotStatusRequest(snapshot, shardId, status)__            transportService.sendRequest(transportService.getLocalNode(), UPDATE_SNAPSHOT_STATUS_ACTION_NAME, request, INSTANCE_SAME)__        } catch (Exception e) {_            logger.warn(() -> new ParameterizedMessage("[{}] [{}] failed to update snapshot state", snapshot, status), e)__        }_    };updates,the,shard,snapshot,status,by,sending,a,link,update,index,shard,snapshot,status,request,to,the,master,node;void,send,snapshot,shard,update,final,snapshot,snapshot,final,shard,id,shard,id,final,shard,snapshot,status,status,try,update,index,shard,snapshot,status,request,request,new,update,index,shard,snapshot,status,request,snapshot,shard,id,status,transport,service,send,request,transport,service,get,local,node,request,catch,exception,e,logger,warn,new,parameterized,message,failed,to,update,snapshot,state,snapshot,status,e
SnapshotShardsService -> void sendSnapshotShardUpdate(final Snapshot snapshot, final ShardId shardId, final ShardSnapshotStatus status);1543851569;Updates the shard snapshot status by sending a {@link UpdateIndexShardSnapshotStatusRequest} to the master node;void sendSnapshotShardUpdate(final Snapshot snapshot, final ShardId shardId, final ShardSnapshotStatus status) {_        try {_            UpdateIndexShardSnapshotStatusRequest request = new UpdateIndexShardSnapshotStatusRequest(snapshot, shardId, status)__            transportService.sendRequest(transportService.getLocalNode(), UPDATE_SNAPSHOT_STATUS_ACTION_NAME, request, INSTANCE_SAME)__        } catch (Exception e) {_            logger.warn(() -> new ParameterizedMessage("[{}] [{}] failed to update snapshot state", snapshot, status), e)__        }_    };updates,the,shard,snapshot,status,by,sending,a,link,update,index,shard,snapshot,status,request,to,the,master,node;void,send,snapshot,shard,update,final,snapshot,snapshot,final,shard,id,shard,id,final,shard,snapshot,status,status,try,update,index,shard,snapshot,status,request,request,new,update,index,shard,snapshot,status,request,snapshot,shard,id,status,transport,service,send,request,transport,service,get,local,node,request,catch,exception,e,logger,warn,new,parameterized,message,failed,to,update,snapshot,state,snapshot,status,e
SnapshotShardsService -> void sendSnapshotShardUpdate(final Snapshot snapshot, final ShardId shardId, final ShardSnapshotStatus status);1545215361;Updates the shard snapshot status by sending a {@link UpdateIndexShardSnapshotStatusRequest} to the master node;void sendSnapshotShardUpdate(final Snapshot snapshot, final ShardId shardId, final ShardSnapshotStatus status) {_        try {_            UpdateIndexShardSnapshotStatusRequest request = new UpdateIndexShardSnapshotStatusRequest(snapshot, shardId, status)__            transportService.sendRequest(transportService.getLocalNode(), UPDATE_SNAPSHOT_STATUS_ACTION_NAME, request, INSTANCE_SAME)__        } catch (Exception e) {_            logger.warn(() -> new ParameterizedMessage("[{}] [{}] failed to update snapshot state", snapshot, status), e)__        }_    };updates,the,shard,snapshot,status,by,sending,a,link,update,index,shard,snapshot,status,request,to,the,master,node;void,send,snapshot,shard,update,final,snapshot,snapshot,final,shard,id,shard,id,final,shard,snapshot,status,status,try,update,index,shard,snapshot,status,request,request,new,update,index,shard,snapshot,status,request,snapshot,shard,id,status,transport,service,send,request,transport,service,get,local,node,request,catch,exception,e,logger,warn,new,parameterized,message,failed,to,update,snapshot,state,snapshot,status,e
SnapshotShardsService -> void sendSnapshotShardUpdate(final Snapshot snapshot, final ShardId shardId, final ShardSnapshotStatus status);1547023537;Updates the shard snapshot status by sending a {@link UpdateIndexShardSnapshotStatusRequest} to the master node;void sendSnapshotShardUpdate(final Snapshot snapshot, final ShardId shardId, final ShardSnapshotStatus status) {_        try {_            UpdateIndexShardSnapshotStatusRequest request = new UpdateIndexShardSnapshotStatusRequest(snapshot, shardId, status)__            transportService.sendRequest(transportService.getLocalNode(), UPDATE_SNAPSHOT_STATUS_ACTION_NAME, request, INSTANCE_SAME)__        } catch (Exception e) {_            logger.warn(() -> new ParameterizedMessage("[{}] [{}] failed to update snapshot state", snapshot, status), e)__        }_    };updates,the,shard,snapshot,status,by,sending,a,link,update,index,shard,snapshot,status,request,to,the,master,node;void,send,snapshot,shard,update,final,snapshot,snapshot,final,shard,id,shard,id,final,shard,snapshot,status,status,try,update,index,shard,snapshot,status,request,request,new,update,index,shard,snapshot,status,request,snapshot,shard,id,status,transport,service,send,request,transport,service,get,local,node,request,catch,exception,e,logger,warn,new,parameterized,message,failed,to,update,snapshot,state,snapshot,status,e
SnapshotShardsService -> void sendSnapshotShardUpdate(final Snapshot snapshot, final ShardId shardId, final ShardSnapshotStatus status);1547625930;Updates the shard snapshot status by sending a {@link UpdateIndexShardSnapshotStatusRequest} to the master node;void sendSnapshotShardUpdate(final Snapshot snapshot, final ShardId shardId, final ShardSnapshotStatus status) {_        try {_            UpdateIndexShardSnapshotStatusRequest request = new UpdateIndexShardSnapshotStatusRequest(snapshot, shardId, status)__            transportService.sendRequest(transportService.getLocalNode(), UPDATE_SNAPSHOT_STATUS_ACTION_NAME, request, INSTANCE_SAME)__        } catch (Exception e) {_            logger.warn(() -> new ParameterizedMessage("[{}] [{}] failed to update snapshot state", snapshot, status), e)__        }_    };updates,the,shard,snapshot,status,by,sending,a,link,update,index,shard,snapshot,status,request,to,the,master,node;void,send,snapshot,shard,update,final,snapshot,snapshot,final,shard,id,shard,id,final,shard,snapshot,status,status,try,update,index,shard,snapshot,status,request,request,new,update,index,shard,snapshot,status,request,snapshot,shard,id,status,transport,service,send,request,transport,service,get,local,node,request,catch,exception,e,logger,warn,new,parameterized,message,failed,to,update,snapshot,state,snapshot,status,e
SnapshotShardsService -> void sendSnapshotShardUpdate(final Snapshot snapshot, final ShardId shardId, final ShardSnapshotStatus status);1548996340;Updates the shard snapshot status by sending a {@link UpdateIndexShardSnapshotStatusRequest} to the master node;void sendSnapshotShardUpdate(final Snapshot snapshot, final ShardId shardId, final ShardSnapshotStatus status) {_        remoteFailedRequestDeduplicator.executeOnce(_            new UpdateIndexShardSnapshotStatusRequest(snapshot, shardId, status),_            new ActionListener<Void>() {_                @Override_                public void onResponse(Void aVoid) {_                    logger.trace("[{}] [{}] updated snapshot state", snapshot, status)__                }__                @Override_                public void onFailure(Exception e) {_                    logger.warn(_                        () -> new ParameterizedMessage("[{}] [{}] failed to update snapshot state", snapshot, status), e)__                }_            },_            (req, reqListener) -> transportService.sendRequest(transportService.getLocalNode(), UPDATE_SNAPSHOT_STATUS_ACTION_NAME, req,_                new EmptyTransportResponseHandler(ThreadPool.Names.SAME) {_                    @Override_                    public void handleResponse(TransportResponse.Empty response) {_                        reqListener.onResponse(null)__                    }__                    @Override_                    public void handleException(TransportException exp) {_                        reqListener.onFailure(exp)__                    }_                })_        )__    };updates,the,shard,snapshot,status,by,sending,a,link,update,index,shard,snapshot,status,request,to,the,master,node;void,send,snapshot,shard,update,final,snapshot,snapshot,final,shard,id,shard,id,final,shard,snapshot,status,status,remote,failed,request,deduplicator,execute,once,new,update,index,shard,snapshot,status,request,snapshot,shard,id,status,new,action,listener,void,override,public,void,on,response,void,a,void,logger,trace,updated,snapshot,state,snapshot,status,override,public,void,on,failure,exception,e,logger,warn,new,parameterized,message,failed,to,update,snapshot,state,snapshot,status,e,req,req,listener,transport,service,send,request,transport,service,get,local,node,req,new,empty,transport,response,handler,thread,pool,names,same,override,public,void,handle,response,transport,response,empty,response,req,listener,on,response,null,override,public,void,handle,exception,transport,exception,exp,req,listener,on,failure,exp
SnapshotShardsService -> void sendSnapshotShardUpdate(final Snapshot snapshot, final ShardId shardId, final ShardSnapshotStatus status);1549050374;Updates the shard snapshot status by sending a {@link UpdateIndexShardSnapshotStatusRequest} to the master node;void sendSnapshotShardUpdate(final Snapshot snapshot, final ShardId shardId, final ShardSnapshotStatus status) {_        remoteFailedRequestDeduplicator.executeOnce(_            new UpdateIndexShardSnapshotStatusRequest(snapshot, shardId, status),_            new ActionListener<Void>() {_                @Override_                public void onResponse(Void aVoid) {_                    logger.trace("[{}] [{}] updated snapshot state", snapshot, status)__                }__                @Override_                public void onFailure(Exception e) {_                    logger.warn(_                        () -> new ParameterizedMessage("[{}] [{}] failed to update snapshot state", snapshot, status), e)__                }_            },_            (req, reqListener) -> transportService.sendRequest(transportService.getLocalNode(), UPDATE_SNAPSHOT_STATUS_ACTION_NAME, req,_                new EmptyTransportResponseHandler(ThreadPool.Names.SAME) {_                    @Override_                    public void handleResponse(TransportResponse.Empty response) {_                        reqListener.onResponse(null)__                    }__                    @Override_                    public void handleException(TransportException exp) {_                        reqListener.onFailure(exp)__                    }_                })_        )__    };updates,the,shard,snapshot,status,by,sending,a,link,update,index,shard,snapshot,status,request,to,the,master,node;void,send,snapshot,shard,update,final,snapshot,snapshot,final,shard,id,shard,id,final,shard,snapshot,status,status,remote,failed,request,deduplicator,execute,once,new,update,index,shard,snapshot,status,request,snapshot,shard,id,status,new,action,listener,void,override,public,void,on,response,void,a,void,logger,trace,updated,snapshot,state,snapshot,status,override,public,void,on,failure,exception,e,logger,warn,new,parameterized,message,failed,to,update,snapshot,state,snapshot,status,e,req,req,listener,transport,service,send,request,transport,service,get,local,node,req,new,empty,transport,response,handler,thread,pool,names,same,override,public,void,handle,response,transport,response,empty,response,req,listener,on,response,null,override,public,void,handle,exception,transport,exception,exp,req,listener,on,failure,exp
SnapshotShardsService -> void sendSnapshotShardUpdate(final Snapshot snapshot, final ShardId shardId, final ShardSnapshotStatus status);1549180095;Updates the shard snapshot status by sending a {@link UpdateIndexShardSnapshotStatusRequest} to the master node;void sendSnapshotShardUpdate(final Snapshot snapshot, final ShardId shardId, final ShardSnapshotStatus status) {_        remoteFailedRequestDeduplicator.executeOnce(_            new UpdateIndexShardSnapshotStatusRequest(snapshot, shardId, status),_            new ActionListener<Void>() {_                @Override_                public void onResponse(Void aVoid) {_                    logger.trace("[{}] [{}] updated snapshot state", snapshot, status)__                }__                @Override_                public void onFailure(Exception e) {_                    logger.warn(_                        () -> new ParameterizedMessage("[{}] [{}] failed to update snapshot state", snapshot, status), e)__                }_            },_            (req, reqListener) -> transportService.sendRequest(transportService.getLocalNode(), UPDATE_SNAPSHOT_STATUS_ACTION_NAME, req,_                new TransportResponseHandler<UpdateIndexShardSnapshotStatusResponse>() {_                    @Override_                    public UpdateIndexShardSnapshotStatusResponse read(StreamInput in) throws IOException {_                        final UpdateIndexShardSnapshotStatusResponse response = new UpdateIndexShardSnapshotStatusResponse()__                        response.readFrom(in)__                        return response__                    }__                    @Override_                    public void handleResponse(UpdateIndexShardSnapshotStatusResponse response) {_                        reqListener.onResponse(null)__                    }__                    @Override_                    public void handleException(TransportException exp) {_                        reqListener.onFailure(exp)__                    }__                    @Override_                    public String executor() {_                        return ThreadPool.Names.SAME__                    }_                })_        )__    };updates,the,shard,snapshot,status,by,sending,a,link,update,index,shard,snapshot,status,request,to,the,master,node;void,send,snapshot,shard,update,final,snapshot,snapshot,final,shard,id,shard,id,final,shard,snapshot,status,status,remote,failed,request,deduplicator,execute,once,new,update,index,shard,snapshot,status,request,snapshot,shard,id,status,new,action,listener,void,override,public,void,on,response,void,a,void,logger,trace,updated,snapshot,state,snapshot,status,override,public,void,on,failure,exception,e,logger,warn,new,parameterized,message,failed,to,update,snapshot,state,snapshot,status,e,req,req,listener,transport,service,send,request,transport,service,get,local,node,req,new,transport,response,handler,update,index,shard,snapshot,status,response,override,public,update,index,shard,snapshot,status,response,read,stream,input,in,throws,ioexception,final,update,index,shard,snapshot,status,response,response,new,update,index,shard,snapshot,status,response,response,read,from,in,return,response,override,public,void,handle,response,update,index,shard,snapshot,status,response,response,req,listener,on,response,null,override,public,void,handle,exception,transport,exception,exp,req,listener,on,failure,exp,override,public,string,executor,return,thread,pool,names,same
SnapshotShardsService -> void sendSnapshotShardUpdate(final Snapshot snapshot, final ShardId shardId, final ShardSnapshotStatus status);1549267599;Updates the shard snapshot status by sending a {@link UpdateIndexShardSnapshotStatusRequest} to the master node;void sendSnapshotShardUpdate(final Snapshot snapshot, final ShardId shardId, final ShardSnapshotStatus status) {_        remoteFailedRequestDeduplicator.executeOnce(_            new UpdateIndexShardSnapshotStatusRequest(snapshot, shardId, status),_            new ActionListener<Void>() {_                @Override_                public void onResponse(Void aVoid) {_                    logger.trace("[{}] [{}] updated snapshot state", snapshot, status)__                }__                @Override_                public void onFailure(Exception e) {_                    logger.warn(_                        () -> new ParameterizedMessage("[{}] [{}] failed to update snapshot state", snapshot, status), e)__                }_            },_            (req, reqListener) -> transportService.sendRequest(transportService.getLocalNode(), UPDATE_SNAPSHOT_STATUS_ACTION_NAME, req,_                new TransportResponseHandler<UpdateIndexShardSnapshotStatusResponse>() {_                    @Override_                    public UpdateIndexShardSnapshotStatusResponse read(StreamInput in) throws IOException {_                        final UpdateIndexShardSnapshotStatusResponse response = new UpdateIndexShardSnapshotStatusResponse()__                        response.readFrom(in)__                        return response__                    }__                    @Override_                    public void handleResponse(UpdateIndexShardSnapshotStatusResponse response) {_                        reqListener.onResponse(null)__                    }__                    @Override_                    public void handleException(TransportException exp) {_                        reqListener.onFailure(exp)__                    }__                    @Override_                    public String executor() {_                        return ThreadPool.Names.SAME__                    }_                })_        )__    };updates,the,shard,snapshot,status,by,sending,a,link,update,index,shard,snapshot,status,request,to,the,master,node;void,send,snapshot,shard,update,final,snapshot,snapshot,final,shard,id,shard,id,final,shard,snapshot,status,status,remote,failed,request,deduplicator,execute,once,new,update,index,shard,snapshot,status,request,snapshot,shard,id,status,new,action,listener,void,override,public,void,on,response,void,a,void,logger,trace,updated,snapshot,state,snapshot,status,override,public,void,on,failure,exception,e,logger,warn,new,parameterized,message,failed,to,update,snapshot,state,snapshot,status,e,req,req,listener,transport,service,send,request,transport,service,get,local,node,req,new,transport,response,handler,update,index,shard,snapshot,status,response,override,public,update,index,shard,snapshot,status,response,read,stream,input,in,throws,ioexception,final,update,index,shard,snapshot,status,response,response,new,update,index,shard,snapshot,status,response,response,read,from,in,return,response,override,public,void,handle,response,update,index,shard,snapshot,status,response,response,req,listener,on,response,null,override,public,void,handle,exception,transport,exception,exp,req,listener,on,failure,exp,override,public,string,executor,return,thread,pool,names,same
SnapshotShardsService -> void sendSnapshotShardUpdate(final Snapshot snapshot, final ShardId shardId, final ShardSnapshotStatus status);1549381458;Updates the shard snapshot status by sending a {@link UpdateIndexShardSnapshotStatusRequest} to the master node;void sendSnapshotShardUpdate(final Snapshot snapshot, final ShardId shardId, final ShardSnapshotStatus status) {_        remoteFailedRequestDeduplicator.executeOnce(_            new UpdateIndexShardSnapshotStatusRequest(snapshot, shardId, status),_            new ActionListener<Void>() {_                @Override_                public void onResponse(Void aVoid) {_                    logger.trace("[{}] [{}] updated snapshot state", snapshot, status)__                }__                @Override_                public void onFailure(Exception e) {_                    logger.warn(_                        () -> new ParameterizedMessage("[{}] [{}] failed to update snapshot state", snapshot, status), e)__                }_            },_            (req, reqListener) -> transportService.sendRequest(transportService.getLocalNode(), UPDATE_SNAPSHOT_STATUS_ACTION_NAME, req,_                new TransportResponseHandler<UpdateIndexShardSnapshotStatusResponse>() {_                    @Override_                    public UpdateIndexShardSnapshotStatusResponse read(StreamInput in) throws IOException {_                        final UpdateIndexShardSnapshotStatusResponse response = new UpdateIndexShardSnapshotStatusResponse()__                        response.readFrom(in)__                        return response__                    }__                    @Override_                    public void handleResponse(UpdateIndexShardSnapshotStatusResponse response) {_                        reqListener.onResponse(null)__                    }__                    @Override_                    public void handleException(TransportException exp) {_                        reqListener.onFailure(exp)__                    }__                    @Override_                    public String executor() {_                        return ThreadPool.Names.SAME__                    }_                })_        )__    };updates,the,shard,snapshot,status,by,sending,a,link,update,index,shard,snapshot,status,request,to,the,master,node;void,send,snapshot,shard,update,final,snapshot,snapshot,final,shard,id,shard,id,final,shard,snapshot,status,status,remote,failed,request,deduplicator,execute,once,new,update,index,shard,snapshot,status,request,snapshot,shard,id,status,new,action,listener,void,override,public,void,on,response,void,a,void,logger,trace,updated,snapshot,state,snapshot,status,override,public,void,on,failure,exception,e,logger,warn,new,parameterized,message,failed,to,update,snapshot,state,snapshot,status,e,req,req,listener,transport,service,send,request,transport,service,get,local,node,req,new,transport,response,handler,update,index,shard,snapshot,status,response,override,public,update,index,shard,snapshot,status,response,read,stream,input,in,throws,ioexception,final,update,index,shard,snapshot,status,response,response,new,update,index,shard,snapshot,status,response,response,read,from,in,return,response,override,public,void,handle,response,update,index,shard,snapshot,status,response,response,req,listener,on,response,null,override,public,void,handle,exception,transport,exception,exp,req,listener,on,failure,exp,override,public,string,executor,return,thread,pool,names,same
SnapshotShardsService -> private void innerUpdateSnapshotState(final UpdateIndexShardSnapshotStatusRequest request,                                           ActionListener<UpdateIndexShardSnapshotStatusResponse> listener);1545215361;Updates the shard status on master node__@param request update shard status request;private void innerUpdateSnapshotState(final UpdateIndexShardSnapshotStatusRequest request,_                                          ActionListener<UpdateIndexShardSnapshotStatusResponse> listener) {_        logger.trace("received updated snapshot restore state [{}]", request)__        clusterService.submitStateUpdateTask(_            "update snapshot state",_            request,_            ClusterStateTaskConfig.build(Priority.NORMAL),_            snapshotStateExecutor,_            new ClusterStateTaskListener() {_                @Override_                public void onFailure(String source, Exception e) {_                    listener.onFailure(e)__                }__                @Override_                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                    listener.onResponse(new UpdateIndexShardSnapshotStatusResponse())__                }_            })__    };updates,the,shard,status,on,master,node,param,request,update,shard,status,request;private,void,inner,update,snapshot,state,final,update,index,shard,snapshot,status,request,request,action,listener,update,index,shard,snapshot,status,response,listener,logger,trace,received,updated,snapshot,restore,state,request,cluster,service,submit,state,update,task,update,snapshot,state,request,cluster,state,task,config,build,priority,normal,snapshot,state,executor,new,cluster,state,task,listener,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,new,update,index,shard,snapshot,status,response
SnapshotShardsService -> private void innerUpdateSnapshotState(final UpdateIndexShardSnapshotStatusRequest request,                                           ActionListener<UpdateIndexShardSnapshotStatusResponse> listener);1547023537;Updates the shard status on master node__@param request update shard status request;private void innerUpdateSnapshotState(final UpdateIndexShardSnapshotStatusRequest request,_                                          ActionListener<UpdateIndexShardSnapshotStatusResponse> listener) {_        logger.trace("received updated snapshot restore state [{}]", request)__        clusterService.submitStateUpdateTask(_            "update snapshot state",_            request,_            ClusterStateTaskConfig.build(Priority.NORMAL),_            snapshotStateExecutor,_            new ClusterStateTaskListener() {_                @Override_                public void onFailure(String source, Exception e) {_                    listener.onFailure(e)__                }__                @Override_                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                    listener.onResponse(new UpdateIndexShardSnapshotStatusResponse())__                }_            })__    };updates,the,shard,status,on,master,node,param,request,update,shard,status,request;private,void,inner,update,snapshot,state,final,update,index,shard,snapshot,status,request,request,action,listener,update,index,shard,snapshot,status,response,listener,logger,trace,received,updated,snapshot,restore,state,request,cluster,service,submit,state,update,task,update,snapshot,state,request,cluster,state,task,config,build,priority,normal,snapshot,state,executor,new,cluster,state,task,listener,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,new,update,index,shard,snapshot,status,response
SnapshotShardsService -> private void innerUpdateSnapshotState(final UpdateIndexShardSnapshotStatusRequest request,                                           ActionListener<UpdateIndexShardSnapshotStatusResponse> listener);1547625930;Updates the shard status on master node__@param request update shard status request;private void innerUpdateSnapshotState(final UpdateIndexShardSnapshotStatusRequest request,_                                          ActionListener<UpdateIndexShardSnapshotStatusResponse> listener) {_        logger.trace("received updated snapshot restore state [{}]", request)__        clusterService.submitStateUpdateTask(_            "update snapshot state",_            request,_            ClusterStateTaskConfig.build(Priority.NORMAL),_            snapshotStateExecutor,_            new ClusterStateTaskListener() {_                @Override_                public void onFailure(String source, Exception e) {_                    listener.onFailure(e)__                }__                @Override_                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                    listener.onResponse(new UpdateIndexShardSnapshotStatusResponse())__                }_            })__    };updates,the,shard,status,on,master,node,param,request,update,shard,status,request;private,void,inner,update,snapshot,state,final,update,index,shard,snapshot,status,request,request,action,listener,update,index,shard,snapshot,status,response,listener,logger,trace,received,updated,snapshot,restore,state,request,cluster,service,submit,state,update,task,update,snapshot,state,request,cluster,state,task,config,build,priority,normal,snapshot,state,executor,new,cluster,state,task,listener,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,new,update,index,shard,snapshot,status,response
SnapshotShardsService -> private void innerUpdateSnapshotState(final UpdateIndexShardSnapshotStatusRequest request,                                           ActionListener<UpdateIndexShardSnapshotStatusResponse> listener);1548996340;Updates the shard status on master node__@param request update shard status request;private void innerUpdateSnapshotState(final UpdateIndexShardSnapshotStatusRequest request,_                                          ActionListener<UpdateIndexShardSnapshotStatusResponse> listener) {_        logger.trace("received updated snapshot restore state [{}]", request)__        clusterService.submitStateUpdateTask(_            "update snapshot state",_            request,_            ClusterStateTaskConfig.build(Priority.NORMAL),_            snapshotStateExecutor,_            new ClusterStateTaskListener() {_                @Override_                public void onFailure(String source, Exception e) {_                    listener.onFailure(e)__                }__                @Override_                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                    listener.onResponse(new UpdateIndexShardSnapshotStatusResponse())__                }_            })__    };updates,the,shard,status,on,master,node,param,request,update,shard,status,request;private,void,inner,update,snapshot,state,final,update,index,shard,snapshot,status,request,request,action,listener,update,index,shard,snapshot,status,response,listener,logger,trace,received,updated,snapshot,restore,state,request,cluster,service,submit,state,update,task,update,snapshot,state,request,cluster,state,task,config,build,priority,normal,snapshot,state,executor,new,cluster,state,task,listener,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,new,update,index,shard,snapshot,status,response
SnapshotShardsService -> private void innerUpdateSnapshotState(final UpdateIndexShardSnapshotStatusRequest request,                                           ActionListener<UpdateIndexShardSnapshotStatusResponse> listener);1549050374;Updates the shard status on master node__@param request update shard status request;private void innerUpdateSnapshotState(final UpdateIndexShardSnapshotStatusRequest request,_                                          ActionListener<UpdateIndexShardSnapshotStatusResponse> listener) {_        logger.trace("received updated snapshot restore state [{}]", request)__        clusterService.submitStateUpdateTask(_            "update snapshot state",_            request,_            ClusterStateTaskConfig.build(Priority.NORMAL),_            snapshotStateExecutor,_            new ClusterStateTaskListener() {_                @Override_                public void onFailure(String source, Exception e) {_                    listener.onFailure(e)__                }__                @Override_                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                    listener.onResponse(new UpdateIndexShardSnapshotStatusResponse())__                }_            })__    };updates,the,shard,status,on,master,node,param,request,update,shard,status,request;private,void,inner,update,snapshot,state,final,update,index,shard,snapshot,status,request,request,action,listener,update,index,shard,snapshot,status,response,listener,logger,trace,received,updated,snapshot,restore,state,request,cluster,service,submit,state,update,task,update,snapshot,state,request,cluster,state,task,config,build,priority,normal,snapshot,state,executor,new,cluster,state,task,listener,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,new,update,index,shard,snapshot,status,response
SnapshotShardsService -> private void innerUpdateSnapshotState(final UpdateIndexShardSnapshotStatusRequest request,                                           ActionListener<UpdateIndexShardSnapshotStatusResponse> listener);1549180095;Updates the shard status on master node__@param request update shard status request;private void innerUpdateSnapshotState(final UpdateIndexShardSnapshotStatusRequest request,_                                          ActionListener<UpdateIndexShardSnapshotStatusResponse> listener) {_        logger.trace("received updated snapshot restore state [{}]", request)__        clusterService.submitStateUpdateTask(_            "update snapshot state",_            request,_            ClusterStateTaskConfig.build(Priority.NORMAL),_            snapshotStateExecutor,_            new ClusterStateTaskListener() {_                @Override_                public void onFailure(String source, Exception e) {_                    listener.onFailure(e)__                }__                @Override_                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                    listener.onResponse(new UpdateIndexShardSnapshotStatusResponse())__                }_            })__    };updates,the,shard,status,on,master,node,param,request,update,shard,status,request;private,void,inner,update,snapshot,state,final,update,index,shard,snapshot,status,request,request,action,listener,update,index,shard,snapshot,status,response,listener,logger,trace,received,updated,snapshot,restore,state,request,cluster,service,submit,state,update,task,update,snapshot,state,request,cluster,state,task,config,build,priority,normal,snapshot,state,executor,new,cluster,state,task,listener,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,new,update,index,shard,snapshot,status,response
SnapshotShardsService -> private void innerUpdateSnapshotState(final UpdateIndexShardSnapshotStatusRequest request,                                           ActionListener<UpdateIndexShardSnapshotStatusResponse> listener);1549267599;Updates the shard status on master node__@param request update shard status request;private void innerUpdateSnapshotState(final UpdateIndexShardSnapshotStatusRequest request,_                                          ActionListener<UpdateIndexShardSnapshotStatusResponse> listener) {_        logger.trace("received updated snapshot restore state [{}]", request)__        clusterService.submitStateUpdateTask(_            "update snapshot state",_            request,_            ClusterStateTaskConfig.build(Priority.NORMAL),_            snapshotStateExecutor,_            new ClusterStateTaskListener() {_                @Override_                public void onFailure(String source, Exception e) {_                    listener.onFailure(e)__                }__                @Override_                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                    listener.onResponse(new UpdateIndexShardSnapshotStatusResponse())__                }_            })__    };updates,the,shard,status,on,master,node,param,request,update,shard,status,request;private,void,inner,update,snapshot,state,final,update,index,shard,snapshot,status,request,request,action,listener,update,index,shard,snapshot,status,response,listener,logger,trace,received,updated,snapshot,restore,state,request,cluster,service,submit,state,update,task,update,snapshot,state,request,cluster,state,task,config,build,priority,normal,snapshot,state,executor,new,cluster,state,task,listener,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,new,update,index,shard,snapshot,status,response
SnapshotShardsService -> private void innerUpdateSnapshotState(final UpdateIndexShardSnapshotStatusRequest request,                                           ActionListener<UpdateIndexShardSnapshotStatusResponse> listener);1549381458;Updates the shard status on master node__@param request update shard status request;private void innerUpdateSnapshotState(final UpdateIndexShardSnapshotStatusRequest request,_                                          ActionListener<UpdateIndexShardSnapshotStatusResponse> listener) {_        logger.trace("received updated snapshot restore state [{}]", request)__        clusterService.submitStateUpdateTask(_            "update snapshot state",_            request,_            ClusterStateTaskConfig.build(Priority.NORMAL),_            snapshotStateExecutor,_            new ClusterStateTaskListener() {_                @Override_                public void onFailure(String source, Exception e) {_                    listener.onFailure(e)__                }__                @Override_                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                    listener.onResponse(new UpdateIndexShardSnapshotStatusResponse())__                }_            })__    };updates,the,shard,status,on,master,node,param,request,update,shard,status,request;private,void,inner,update,snapshot,state,final,update,index,shard,snapshot,status,request,request,action,listener,update,index,shard,snapshot,status,response,listener,logger,trace,received,updated,snapshot,restore,state,request,cluster,service,submit,state,update,task,update,snapshot,state,request,cluster,state,task,config,build,priority,normal,snapshot,state,executor,new,cluster,state,task,listener,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,new,update,index,shard,snapshot,status,response
