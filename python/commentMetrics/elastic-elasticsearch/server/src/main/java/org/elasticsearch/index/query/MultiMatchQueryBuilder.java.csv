commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public float tieBreaker() {     return this.tieBreaker. }
false;public;0;3;;public MatchQuery.Type matchQueryType() {     return matchQueryType. }
false;public;0;3;;public ParseField parseField() {     return parseField. }
false;public,static;2;14;;public static Type parse(String value, DeprecationHandler deprecationHandler) {     MultiMatchQueryBuilder.Type[] values = MultiMatchQueryBuilder.Type.values().     Type type = null.     for (MultiMatchQueryBuilder.Type t : values) {         if (t.parseField().match(value, deprecationHandler)) {             type = t.             break.         }     }     if (type == null) {         throw new ElasticsearchParseException("failed to parse [{}] query type [{}]. unknown type.", NAME, value).     }     return type. }
false;public,static;1;3;;public static Type readFromStream(StreamInput in) throws IOException {     return Type.values()[in.readVInt()]. }
false;public;1;4;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeVInt(this.ordinal()). }
true;public;0;3;/**  * Returns the type (for testing)  */ ;/**  * Returns the type (for testing)  */ public MultiMatchQueryBuilder.Type getType() {     return type. }
false;protected;1;33;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     out.writeGenericValue(value).     out.writeVInt(fieldsBoosts.size()).     for (Map.Entry<String, Float> fieldsEntry : fieldsBoosts.entrySet()) {         out.writeString(fieldsEntry.getKey()).         out.writeFloat(fieldsEntry.getValue()).     }     type.writeTo(out).     operator.writeTo(out).     out.writeOptionalString(analyzer).     out.writeVInt(slop).     out.writeOptionalWriteable(fuzziness).     out.writeVInt(prefixLength).     out.writeVInt(maxExpansions).     out.writeOptionalString(minimumShouldMatch).     out.writeOptionalString(fuzzyRewrite).     if (out.getVersion().before(Version.V_7_0_0)) {         out.writeOptionalBoolean(null).     }     out.writeOptionalFloat(tieBreaker).     if (out.getVersion().onOrAfter(Version.V_6_1_0)) {         out.writeOptionalBoolean(lenient).     } else {         out.writeBoolean(lenient == null ? MatchQuery.DEFAULT_LENIENCY : lenient).     }     out.writeOptionalFloat(cutoffFrequency).     zeroTermsQuery.writeTo(out).     if (out.getVersion().onOrAfter(Version.V_6_1_0)) {         out.writeBoolean(autoGenerateSynonymsPhraseQuery).         out.writeBoolean(fuzzyTranspositions).     } }
false;public;0;3;;public Object value() {     return value. }
true;public;1;7;/**  * Adds a field to run the multi match against.  */ ;/**  * Adds a field to run the multi match against.  */ public MultiMatchQueryBuilder field(String field) {     if (Strings.isEmpty(field)) {         throw new IllegalArgumentException("supplied field is null or empty.").     }     this.fieldsBoosts.put(field, AbstractQueryBuilder.DEFAULT_BOOST).     return this. }
true;public;2;8;/**  * Adds a field to run the multi match against with a specific boost.  */ ;/**  * Adds a field to run the multi match against with a specific boost.  */ public MultiMatchQueryBuilder field(String field, float boost) {     if (Strings.isEmpty(field)) {         throw new IllegalArgumentException("supplied field is null or empty.").     }     checkNegativeBoost(boost).     this.fieldsBoosts.put(field, boost).     return this. }
true;public;1;7;/**  * Add several fields to run the query against with a specific boost.  */ ;/**  * Add several fields to run the query against with a specific boost.  */ public MultiMatchQueryBuilder fields(Map<String, Float> fields) {     for (float fieldBoost : fields.values()) {         checkNegativeBoost(fieldBoost).     }     this.fieldsBoosts.putAll(fields).     return this. }
false;public;0;3;;public Map<String, Float> fields() {     return fieldsBoosts. }
true;public;1;7;/**  * Sets the type of the text query.  */ ;/**  * Sets the type of the text query.  */ public MultiMatchQueryBuilder type(MultiMatchQueryBuilder.Type type) {     if (type == null) {         throw new IllegalArgumentException("[" + NAME + "] requires type to be non-null").     }     this.type = type.     return this. }
true;public;1;7;/**  * Sets the type of the text query.  */ ;/**  * Sets the type of the text query.  */ public MultiMatchQueryBuilder type(Object type) {     if (type == null) {         throw new IllegalArgumentException("[" + NAME + "] requires type to be non-null").     }     this.type = Type.parse(type.toString().toLowerCase(Locale.ROOT), LoggingDeprecationHandler.INSTANCE).     return this. }
false;public;0;3;;public Type type() {     return type. }
true;public;1;7;/**  * Sets the operator to use when using a boolean query. Defaults to {@code OR}.  */ ;/**  * Sets the operator to use when using a boolean query. Defaults to {@code OR}.  */ public MultiMatchQueryBuilder operator(Operator operator) {     if (operator == null) {         throw new IllegalArgumentException("[" + NAME + "] requires operator to be non-null").     }     this.operator = operator.     return this. }
false;public;0;3;;public Operator operator() {     return operator. }
true;public;1;4;/**  * Explicitly set the analyzer to use. Defaults to use explicit mapping config for the field, or, if not  * set, the default search analyzer.  */ ;/**  * Explicitly set the analyzer to use. Defaults to use explicit mapping config for the field, or, if not  * set, the default search analyzer.  */ public MultiMatchQueryBuilder analyzer(String analyzer) {     this.analyzer = analyzer.     return this. }
false;public;0;3;;public String analyzer() {     return analyzer. }
true;public;1;7;/**  * Set the phrase slop if evaluated to a phrase query type.  */ ;/**  * Set the phrase slop if evaluated to a phrase query type.  */ public MultiMatchQueryBuilder slop(int slop) {     if (slop < 0) {         throw new IllegalArgumentException("No negative slop allowed.").     }     this.slop = slop.     return this. }
false;public;0;3;;public int slop() {     return slop. }
true;public;1;6;/**  * Sets the fuzziness used when evaluated to a fuzzy query type. Defaults to "AUTO".  */ ;/**  * Sets the fuzziness used when evaluated to a fuzzy query type. Defaults to "AUTO".  */ public MultiMatchQueryBuilder fuzziness(Object fuzziness) {     if (fuzziness != null) {         this.fuzziness = Fuzziness.build(fuzziness).     }     return this. }
false;public;0;3;;public Fuzziness fuzziness() {     return fuzziness. }
false;public;1;7;;public MultiMatchQueryBuilder prefixLength(int prefixLength) {     if (prefixLength < 0) {         throw new IllegalArgumentException("No negative prefix length allowed.").     }     this.prefixLength = prefixLength.     return this. }
false;public;0;3;;public int prefixLength() {     return prefixLength. }
true;public;1;7;/**  * When using fuzzy or prefix type query, the number of term expansions to use. Defaults to unbounded  * so its recommended to set it to a reasonable value for faster execution.  */ ;/**  * When using fuzzy or prefix type query, the number of term expansions to use. Defaults to unbounded  * so its recommended to set it to a reasonable value for faster execution.  */ public MultiMatchQueryBuilder maxExpansions(int maxExpansions) {     if (maxExpansions <= 0) {         throw new IllegalArgumentException("Max expansions must be strictly great than zero.").     }     this.maxExpansions = maxExpansions.     return this. }
false;public;0;3;;public int maxExpansions() {     return maxExpansions. }
false;public;1;4;;public MultiMatchQueryBuilder minimumShouldMatch(String minimumShouldMatch) {     this.minimumShouldMatch = minimumShouldMatch.     return this. }
false;public;0;3;;public String minimumShouldMatch() {     return minimumShouldMatch. }
false;public;1;4;;public MultiMatchQueryBuilder fuzzyRewrite(String fuzzyRewrite) {     this.fuzzyRewrite = fuzzyRewrite.     return this. }
false;public;0;3;;public String fuzzyRewrite() {     return fuzzyRewrite. }
true;public;1;4;/**  * <p>Tie-Breaker for "best-match" disjunction queries (OR-Queries).  * The tie breaker capability allows documents that match more than one query clause  * (in this case on more than one field) to be scored better than documents that  * match only the best of the fields, without confusing this with the better case of  * two distinct matches in the multiple fields.</p>  *  * <p>A tie-breaker value of {@code 1.0} is interpreted as a signal to score queries as  * "most-match" queries where all matching query clauses are considered for scoring.</p>  *  * @see Type  */ ;/**  * <p>Tie-Breaker for "best-match" disjunction queries (OR-Queries).  * The tie breaker capability allows documents that match more than one query clause  * (in this case on more than one field) to be scored better than documents that  * match only the best of the fields, without confusing this with the better case of  * two distinct matches in the multiple fields.</p>  *  * <p>A tie-breaker value of {@code 1.0} is interpreted as a signal to score queries as  * "most-match" queries where all matching query clauses are considered for scoring.</p>  *  * @see Type  */ public MultiMatchQueryBuilder tieBreaker(float tieBreaker) {     this.tieBreaker = tieBreaker.     return this. }
true;public;1;4;/**  * <p>Tie-Breaker for "best-match" disjunction queries (OR-Queries).  * The tie breaker capability allows documents that match more than one query clause  * (in this case on more than one field) to be scored better than documents that  * match only the best of the fields, without confusing this with the better case of  * two distinct matches in the multiple fields.</p>  *  * <p>A tie-breaker value of {@code 1.0} is interpreted as a signal to score queries as  * "most-match" queries where all matching query clauses are considered for scoring.</p>  *  * @see Type  */ ;/**  * <p>Tie-Breaker for "best-match" disjunction queries (OR-Queries).  * The tie breaker capability allows documents that match more than one query clause  * (in this case on more than one field) to be scored better than documents that  * match only the best of the fields, without confusing this with the better case of  * two distinct matches in the multiple fields.</p>  *  * <p>A tie-breaker value of {@code 1.0} is interpreted as a signal to score queries as  * "most-match" queries where all matching query clauses are considered for scoring.</p>  *  * @see Type  */ public MultiMatchQueryBuilder tieBreaker(Float tieBreaker) {     this.tieBreaker = tieBreaker.     return this. }
false;public;0;3;;public Float tieBreaker() {     return tieBreaker. }
true;public;1;4;/**  * Sets whether format based failures will be ignored.  */ ;/**  * Sets whether format based failures will be ignored.  */ public MultiMatchQueryBuilder lenient(boolean lenient) {     this.lenient = lenient.     return this. }
false;public;0;3;;public boolean lenient() {     return lenient == null ? MatchQuery.DEFAULT_LENIENCY : lenient. }
true;public;1;4;/**  * Set a cutoff value in [0..1] (or absolute number &gt.=1) representing the  * maximum threshold of a terms document frequency to be considered a low  * frequency term.  */ ;/**  * Set a cutoff value in [0..1] (or absolute number &gt.=1) representing the  * maximum threshold of a terms document frequency to be considered a low  * frequency term.  */ public MultiMatchQueryBuilder cutoffFrequency(float cutoff) {     this.cutoffFrequency = cutoff.     return this. }
true;public;1;4;/**  * Set a cutoff value in [0..1] (or absolute number &gt.=1) representing the  * maximum threshold of a terms document frequency to be considered a low  * frequency term.  */ ;/**  * Set a cutoff value in [0..1] (or absolute number &gt.=1) representing the  * maximum threshold of a terms document frequency to be considered a low  * frequency term.  */ public MultiMatchQueryBuilder cutoffFrequency(Float cutoff) {     this.cutoffFrequency = cutoff.     return this. }
false;public;0;3;;public Float cutoffFrequency() {     return cutoffFrequency. }
false;public;1;7;;public MultiMatchQueryBuilder zeroTermsQuery(MatchQuery.ZeroTermsQuery zeroTermsQuery) {     if (zeroTermsQuery == null) {         throw new IllegalArgumentException("[" + NAME + "] requires zero terms query to be non-null").     }     this.zeroTermsQuery = zeroTermsQuery.     return this. }
false;public;0;3;;public MatchQuery.ZeroTermsQuery zeroTermsQuery() {     return zeroTermsQuery. }
false;public;1;4;;public MultiMatchQueryBuilder autoGenerateSynonymsPhraseQuery(boolean enable) {     this.autoGenerateSynonymsPhraseQuery = enable.     return this. }
true;public;0;3;/**  * Whether phrase queries should be automatically generated for multi terms synonyms.  * Defaults to {@code true}.  */ ;/**  * Whether phrase queries should be automatically generated for multi terms synonyms.  * Defaults to {@code true}.  */ public boolean autoGenerateSynonymsPhraseQuery() {     return autoGenerateSynonymsPhraseQuery. }
false;public;0;3;;public boolean fuzzyTranspositions() {     return fuzzyTranspositions. }
true;public;1;4;/**  * Sets whether transpositions are supported in fuzzy queries.<p>  * The default metric used by fuzzy queries to determine a match is the Damerau-Levenshtein  * distance formula which supports transpositions. Setting transposition to false will  * switch to classic Levenshtein distance.<br>  * If not set, Damerau-Levenshtein distance metric will be used.  */ ;/**  * Sets whether transpositions are supported in fuzzy queries.<p>  * The default metric used by fuzzy queries to determine a match is the Damerau-Levenshtein  * distance formula which supports transpositions. Setting transposition to false will  * switch to classic Levenshtein distance.<br>  * If not set, Damerau-Levenshtein distance metric will be used.  */ public MultiMatchQueryBuilder fuzzyTranspositions(boolean fuzzyTranspositions) {     this.fuzzyTranspositions = fuzzyTranspositions.     return this. }
false;public;2;41;;@Override public void doXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject(NAME).     builder.field(QUERY_FIELD.getPreferredName(), value).     builder.startArray(FIELDS_FIELD.getPreferredName()).     for (Map.Entry<String, Float> fieldEntry : this.fieldsBoosts.entrySet()) {         builder.value(fieldEntry.getKey() + "^" + fieldEntry.getValue()).     }     builder.endArray().     builder.field(TYPE_FIELD.getPreferredName(), type.toString().toLowerCase(Locale.ENGLISH)).     builder.field(OPERATOR_FIELD.getPreferredName(), operator.toString()).     if (analyzer != null) {         builder.field(ANALYZER_FIELD.getPreferredName(), analyzer).     }     builder.field(SLOP_FIELD.getPreferredName(), slop).     if (fuzziness != null) {         fuzziness.toXContent(builder, params).     }     builder.field(PREFIX_LENGTH_FIELD.getPreferredName(), prefixLength).     builder.field(MAX_EXPANSIONS_FIELD.getPreferredName(), maxExpansions).     if (minimumShouldMatch != null) {         builder.field(MINIMUM_SHOULD_MATCH_FIELD.getPreferredName(), minimumShouldMatch).     }     if (fuzzyRewrite != null) {         builder.field(FUZZY_REWRITE_FIELD.getPreferredName(), fuzzyRewrite).     }     if (tieBreaker != null) {         builder.field(TIE_BREAKER_FIELD.getPreferredName(), tieBreaker).     }     if (lenient != null) {         builder.field(LENIENT_FIELD.getPreferredName(), lenient).     }     if (cutoffFrequency != null) {         builder.field(CUTOFF_FREQUENCY_FIELD.getPreferredName(), cutoffFrequency).     }     builder.field(ZERO_TERMS_QUERY_FIELD.getPreferredName(), zeroTermsQuery.toString()).     builder.field(GENERATE_SYNONYMS_PHRASE_QUERY.getPreferredName(), autoGenerateSynonymsPhraseQuery).     builder.field(FUZZY_TRANSPOSITIONS_FIELD.getPreferredName(), fuzzyTranspositions).     printBoostAndQueryName(builder).     builder.endObject(). }
false;public,static;1;126;;public static MultiMatchQueryBuilder fromXContent(XContentParser parser) throws IOException {     Object value = null.     Map<String, Float> fieldsBoosts = new HashMap<>().     MultiMatchQueryBuilder.Type type = DEFAULT_TYPE.     String analyzer = null.     int slop = DEFAULT_PHRASE_SLOP.     Fuzziness fuzziness = null.     int prefixLength = DEFAULT_PREFIX_LENGTH.     int maxExpansions = DEFAULT_MAX_EXPANSIONS.     Operator operator = DEFAULT_OPERATOR.     String minimumShouldMatch = null.     String fuzzyRewrite = null.     Boolean useDisMax = null.     Float tieBreaker = null.     Float cutoffFrequency = null.     Boolean lenient = null.     MatchQuery.ZeroTermsQuery zeroTermsQuery = DEFAULT_ZERO_TERMS_QUERY.     boolean autoGenerateSynonymsPhraseQuery = true.     boolean fuzzyTranspositions = DEFAULT_FUZZY_TRANSPOSITIONS.     float boost = AbstractQueryBuilder.DEFAULT_BOOST.     String queryName = null.     XContentParser.Token token.     String currentFieldName = null.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (FIELDS_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {             if (token == XContentParser.Token.START_ARRAY) {                 while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {                     parseFieldAndBoost(parser, fieldsBoosts).                 }             } else if (token.isValue()) {                 parseFieldAndBoost(parser, fieldsBoosts).             } else {                 throw new ParsingException(parser.getTokenLocation(), "[" + NAME + "] query does not support [" + currentFieldName + "]").             }         } else if (token.isValue()) {             if (QUERY_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 value = parser.objectText().             } else if (TYPE_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 type = MultiMatchQueryBuilder.Type.parse(parser.text(), parser.getDeprecationHandler()).             } else if (ANALYZER_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 analyzer = parser.text().             } else if (AbstractQueryBuilder.BOOST_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 boost = parser.floatValue().             } else if (SLOP_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 slop = parser.intValue().             } else if (Fuzziness.FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 fuzziness = Fuzziness.parse(parser).             } else if (PREFIX_LENGTH_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 prefixLength = parser.intValue().             } else if (MAX_EXPANSIONS_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 maxExpansions = parser.intValue().             } else if (OPERATOR_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 operator = Operator.fromString(parser.text()).             } else if (MINIMUM_SHOULD_MATCH_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 minimumShouldMatch = parser.textOrNull().             } else if (FUZZY_REWRITE_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 fuzzyRewrite = parser.textOrNull().             } else if (TIE_BREAKER_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 tieBreaker = parser.floatValue().             } else if (CUTOFF_FREQUENCY_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 cutoffFrequency = parser.floatValue().             } else if (LENIENT_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 lenient = parser.booleanValue().             } else if (ZERO_TERMS_QUERY_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 String zeroTermsValue = parser.text().                 if ("none".equalsIgnoreCase(zeroTermsValue)) {                     zeroTermsQuery = MatchQuery.ZeroTermsQuery.NONE.                 } else if ("all".equalsIgnoreCase(zeroTermsValue)) {                     zeroTermsQuery = MatchQuery.ZeroTermsQuery.ALL.                 } else {                     throw new ParsingException(parser.getTokenLocation(), "Unsupported zero_terms_query value [" + zeroTermsValue + "]").                 }             } else if (AbstractQueryBuilder.NAME_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 queryName = parser.text().             } else if (GENERATE_SYNONYMS_PHRASE_QUERY.match(currentFieldName, parser.getDeprecationHandler())) {                 autoGenerateSynonymsPhraseQuery = parser.booleanValue().             } else if (FUZZY_TRANSPOSITIONS_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 fuzzyTranspositions = parser.booleanValue().             } else {                 throw new ParsingException(parser.getTokenLocation(), "[" + NAME + "] query does not support [" + currentFieldName + "]").             }         } else {             throw new ParsingException(parser.getTokenLocation(), "[" + NAME + "] unknown token [" + token + "] after [" + currentFieldName + "]").         }     }     if (value == null) {         throw new ParsingException(parser.getTokenLocation(), "No text specified for multi_match query").     }     if (fuzziness != null && (type == Type.CROSS_FIELDS || type == Type.PHRASE || type == Type.PHRASE_PREFIX)) {         throw new ParsingException(parser.getTokenLocation(), "Fuzziness not allowed for type [" + type.parseField.getPreferredName() + "]").     }     MultiMatchQueryBuilder builder = new MultiMatchQueryBuilder(value).fields(fieldsBoosts).type(type).analyzer(analyzer).cutoffFrequency(cutoffFrequency).fuzziness(fuzziness).fuzzyRewrite(fuzzyRewrite).maxExpansions(maxExpansions).minimumShouldMatch(minimumShouldMatch).operator(operator).prefixLength(prefixLength).slop(slop).tieBreaker(tieBreaker).zeroTermsQuery(zeroTermsQuery).autoGenerateSynonymsPhraseQuery(autoGenerateSynonymsPhraseQuery).boost(boost).queryName(queryName).fuzzyTranspositions(fuzzyTranspositions).     if (lenient != null) {         builder.lenient(lenient).     }     return builder. }
false;private,static;2;18;;private static void parseFieldAndBoost(XContentParser parser, Map<String, Float> fieldsBoosts) throws IOException {     String fField = null.     Float fBoost = AbstractQueryBuilder.DEFAULT_BOOST.     char[] fieldText = parser.textCharacters().     int end = parser.textOffset() + parser.textLength().     for (int i = parser.textOffset(). i < end. i++) {         if (fieldText[i] == '^') {             int relativeLocation = i - parser.textOffset().             fField = new String(fieldText, parser.textOffset(), relativeLocation).             fBoost = Float.parseFloat(new String(fieldText, i + 1, parser.textLength() - relativeLocation - 1)).             break.         }     }     if (fField == null) {         fField = parser.text().     }     fieldsBoosts.put(fField, fBoost). }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
false;protected;1;48;;@Override protected Query doToQuery(QueryShardContext context) throws IOException {     MultiMatchQuery multiMatchQuery = new MultiMatchQuery(context).     if (analyzer != null) {         if (context.getIndexAnalyzers().get(analyzer) == null) {             throw new QueryShardException(context, "[" + NAME + "] analyzer [" + analyzer + "] not found").         }         multiMatchQuery.setAnalyzer(analyzer).     }     multiMatchQuery.setPhraseSlop(slop).     if (fuzziness != null) {         multiMatchQuery.setFuzziness(fuzziness).     }     multiMatchQuery.setFuzzyPrefixLength(prefixLength).     multiMatchQuery.setMaxExpansions(maxExpansions).     multiMatchQuery.setOccur(operator.toBooleanClauseOccur()).     if (fuzzyRewrite != null) {         multiMatchQuery.setFuzzyRewriteMethod(QueryParsers.parseRewriteMethod(fuzzyRewrite, null, LoggingDeprecationHandler.INSTANCE)).     }     if (tieBreaker != null) {         multiMatchQuery.setTieBreaker(tieBreaker).     }     if (cutoffFrequency != null) {         multiMatchQuery.setCommonTermsCutoff(cutoffFrequency).     }     if (lenient != null) {         multiMatchQuery.setLenient(lenient).     }     multiMatchQuery.setZeroTermsQuery(zeroTermsQuery).     multiMatchQuery.setAutoGenerateSynonymsPhraseQuery(autoGenerateSynonymsPhraseQuery).     multiMatchQuery.setTranspositions(fuzzyTranspositions).     Map<String, Float> newFieldsBoosts.     if (fieldsBoosts.isEmpty()) {         // no fields provided, defaults to index.query.default_field         List<String> defaultFields = context.defaultFields().         boolean isAllField = defaultFields.size() == 1 && Regex.isMatchAllPattern(defaultFields.get(0)).         if (isAllField && lenient == null) {             // Sets leniency to true if not explicitly             // set in the request             multiMatchQuery.setLenient(true).         }         newFieldsBoosts = QueryParserHelper.resolveMappingFields(context, QueryParserHelper.parseFieldsAndWeights(defaultFields)).     } else {         newFieldsBoosts = QueryParserHelper.resolveMappingFields(context, fieldsBoosts).     }     return multiMatchQuery.parse(type, newFieldsBoosts, value, minimumShouldMatch). }
false;protected;0;6;;@Override protected int doHashCode() {     return Objects.hash(value, fieldsBoosts, type, operator, analyzer, slop, fuzziness, prefixLength, maxExpansions, minimumShouldMatch, fuzzyRewrite, tieBreaker, lenient, cutoffFrequency, zeroTermsQuery, autoGenerateSynonymsPhraseQuery, fuzzyTranspositions). }
false;protected;1;20;;@Override protected boolean doEquals(MultiMatchQueryBuilder other) {     return Objects.equals(value, other.value) && Objects.equals(fieldsBoosts, other.fieldsBoosts) && Objects.equals(type, other.type) && Objects.equals(operator, other.operator) && Objects.equals(analyzer, other.analyzer) && Objects.equals(slop, other.slop) && Objects.equals(fuzziness, other.fuzziness) && Objects.equals(prefixLength, other.prefixLength) && Objects.equals(maxExpansions, other.maxExpansions) && Objects.equals(minimumShouldMatch, other.minimumShouldMatch) && Objects.equals(fuzzyRewrite, other.fuzzyRewrite) && Objects.equals(tieBreaker, other.tieBreaker) && Objects.equals(lenient, other.lenient) && Objects.equals(cutoffFrequency, other.cutoffFrequency) && Objects.equals(zeroTermsQuery, other.zeroTermsQuery) && Objects.equals(autoGenerateSynonymsPhraseQuery, other.autoGenerateSynonymsPhraseQuery) && Objects.equals(fuzzyTranspositions, other.fuzzyTranspositions). }
