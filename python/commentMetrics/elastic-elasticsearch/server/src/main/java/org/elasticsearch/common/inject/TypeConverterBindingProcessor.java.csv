commented;modifiers;parameterAmount;loc;comment;code
false;public;2;8;;@Override public Object convert(String value, TypeLiteral<?> toType) {     value = value.trim().     if (value.length() != 1) {         throw new RuntimeException("Length != 1.").     }     return value.charAt(0). }
false;public;0;4;;@Override public String toString() {     return "TypeConverter<Character>". }
false;public;2;5;;@Override @SuppressWarnings("unchecked") public Object convert(String value, TypeLiteral<?> toType) {     return Enum.valueOf((Class) toType.getRawType(), value). }
false;public;0;4;;@Override public String toString() {     return "TypeConverter<E extends Enum<E>>". }
false;public;1;4;;@Override public boolean matches(TypeLiteral<?> typeLiteral) {     return typeLiteral.getRawType() == Class.class. }
false;public;0;4;;@Override public String toString() {     return "Class<?>". }
false;public;2;8;;@Override public Object convert(String value, TypeLiteral<?> toType) {     try {         return Class.forName(value).     } catch (ClassNotFoundException e) {         throw new RuntimeException(e).     } }
false;public;0;4;;@Override public String toString() {     return "TypeConverter<Class<?>>". }
true;public;1;73;/**  * Installs default converters for primitives, enums, and class literals.  */ ;/**  * Installs default converters for primitives, enums, and class literals.  */ public void prepareBuiltInConverters(InjectorImpl injector) {     this.injector = injector.     try {         // Configure type converters.         convertToPrimitiveType(int.class, Integer.class).         convertToPrimitiveType(long.class, Long.class).         convertToPrimitiveType(boolean.class, Boolean.class).         convertToPrimitiveType(byte.class, Byte.class).         convertToPrimitiveType(short.class, Short.class).         convertToPrimitiveType(float.class, Float.class).         convertToPrimitiveType(double.class, Double.class).         convertToClass(Character.class, new TypeConverter() {              @Override             public Object convert(String value, TypeLiteral<?> toType) {                 value = value.trim().                 if (value.length() != 1) {                     throw new RuntimeException("Length != 1.").                 }                 return value.charAt(0).             }              @Override             public String toString() {                 return "TypeConverter<Character>".             }         }).         convertToClasses(Matchers.subclassesOf(Enum.class), new TypeConverter() {              @Override             @SuppressWarnings("unchecked")             public Object convert(String value, TypeLiteral<?> toType) {                 return Enum.valueOf((Class) toType.getRawType(), value).             }              @Override             public String toString() {                 return "TypeConverter<E extends Enum<E>>".             }         }).         internalConvertToTypes(new AbstractMatcher<TypeLiteral<?>>() {              @Override             public boolean matches(TypeLiteral<?> typeLiteral) {                 return typeLiteral.getRawType() == Class.class.             }              @Override             public String toString() {                 return "Class<?>".             }         }, new TypeConverter() {              @Override             public Object convert(String value, TypeLiteral<?> toType) {                 try {                     return Class.forName(value).                 } catch (ClassNotFoundException e) {                     throw new RuntimeException(e).                 }             }              @Override             public String toString() {                 return "TypeConverter<Class<?>>".             }         }).     } finally {         this.injector = null.     } }
false;public;2;10;;@Override public Object convert(String value, TypeLiteral<?> toType) {     try {         return parser.invoke(null, value).     } catch (IllegalAccessException e) {         throw new AssertionError(e).     } catch (InvocationTargetException e) {         throw new RuntimeException(e.getTargetException()).     } }
false;public;0;4;;@Override public String toString() {     return "TypeConverter<" + wrapperType.getSimpleName() + ">". }
false;private;2;28;;private <T> void convertToPrimitiveType(Class<T> primitiveType, final Class<T> wrapperType) {     try {         final Method parser = wrapperType.getMethod("parse" + Strings.capitalize(primitiveType.getName()), String.class).         TypeConverter typeConverter = new TypeConverter() {              @Override             public Object convert(String value, TypeLiteral<?> toType) {                 try {                     return parser.invoke(null, value).                 } catch (IllegalAccessException e) {                     throw new AssertionError(e).                 } catch (InvocationTargetException e) {                     throw new RuntimeException(e.getTargetException()).                 }             }              @Override             public String toString() {                 return "TypeConverter<" + wrapperType.getSimpleName() + ">".             }         }.         convertToClass(wrapperType, typeConverter).     } catch (NoSuchMethodException e) {         throw new AssertionError(e).     } }
false;private;2;3;;private <T> void convertToClass(Class<T> type, TypeConverter converter) {     convertToClasses(Matchers.identicalTo(type), converter). }
false;public;1;9;;@Override public boolean matches(TypeLiteral<?> typeLiteral) {     Type type = typeLiteral.getType().     if (!(type instanceof Class)) {         return false.     }     Class<?> clazz = (Class<?>) type.     return typeMatcher.matches(clazz). }
false;public;0;4;;@Override public String toString() {     return typeMatcher.toString(). }
false;private;2;19;;private void convertToClasses(final Matcher<? super Class<?>> typeMatcher, TypeConverter converter) {     internalConvertToTypes(new AbstractMatcher<TypeLiteral<?>>() {          @Override         public boolean matches(TypeLiteral<?> typeLiteral) {             Type type = typeLiteral.getType().             if (!(type instanceof Class)) {                 return false.             }             Class<?> clazz = (Class<?>) type.             return typeMatcher.matches(clazz).         }          @Override         public String toString() {             return typeMatcher.toString().         }     }, converter). }
false;private;2;5;;private void internalConvertToTypes(Matcher<? super TypeLiteral<?>> typeMatcher, TypeConverter converter) {     injector.state.addConverter(new MatcherAndConverter(typeMatcher, converter, SourceProvider.UNKNOWN_SOURCE)). }
false;public;1;6;;@Override public Boolean visit(TypeConverterBinding command) {     injector.state.addConverter(new MatcherAndConverter(command.getTypeMatcher(), command.getTypeConverter(), command.getSource())).     return true. }
