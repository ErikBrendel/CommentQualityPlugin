commented;modifiers;parameterAmount;loc;comment;code
false;public;1;5;;@Override public AB subAggregations(Builder subFactories) {     throw new AggregationInitializationException("Aggregator [" + name + "] of type [" + getType() + "] cannot accept sub-aggregations"). }
true;private;1;6;/**  * Read from a stream.  */ ;/**  * Read from a stream.  */ @SuppressWarnings("unchecked") private void read(StreamInput in) throws IOException {     fields = in.readMap(StreamInput::readString, MultiValuesSourceFieldConfig::new).     valueType = in.readOptionalWriteable(ValueType::readFromStream).     format = in.readOptionalString(). }
false;protected,final;1;10;;@Override protected final void doWriteTo(StreamOutput out) throws IOException {     if (serializeTargetValueType()) {         out.writeOptionalWriteable(targetValueType).     }     out.writeMap(fields, StreamOutput::writeString, (o, value) -> value.writeTo(o)).     out.writeOptionalWriteable(valueType).     out.writeOptionalString(format).     innerWriteTo(out). }
true;protected,abstract;1;1;/**  * Write subclass' state to the stream  */ ;/**  * Write subclass' state to the stream  */ protected abstract void innerWriteTo(StreamOutput out) throws IOException.
false;protected;2;8;;@SuppressWarnings("unchecked") protected AB field(String propertyName, MultiValuesSourceFieldConfig config) {     if (config == null) {         throw new IllegalArgumentException("[config] must not be null: [" + name + "]").     }     this.fields.put(propertyName, config).     return (AB) this. }
true;public;1;8;/**  * Sets the {@link ValueType} for the value produced by this aggregation  */ ;/**  * Sets the {@link ValueType} for the value produced by this aggregation  */ @SuppressWarnings("unchecked") public AB valueType(ValueType valueType) {     if (valueType == null) {         throw new IllegalArgumentException("[valueType] must not be null: [" + name + "]").     }     this.valueType = valueType.     return (AB) this. }
true;public;1;8;/**  * Sets the format to use for the output of the aggregation.  */ ;/**  * Sets the format to use for the output of the aggregation.  */ @SuppressWarnings("unchecked") public AB format(String format) {     if (format == null) {         throw new IllegalArgumentException("[format] must not be null: [" + name + "]").     }     this.format = format.     return (AB) this. }
false;protected,final;3;14;;@Override protected final MultiValuesSourceAggregatorFactory<VS, ?> doBuild(SearchContext context, AggregatorFactory<?> parent, AggregatorFactories.Builder subFactoriesBuilder) throws IOException {     ValueType finalValueType = this.valueType != null ? this.valueType : targetValueType.     Map<String, ValuesSourceConfig<VS>> configs = new HashMap<>(fields.size()).     fields.forEach((key, value) -> {         ValuesSourceConfig<VS> config = ValuesSourceConfig.resolve(context.getQueryShardContext(), finalValueType, value.getFieldName(), value.getScript(), value.getMissing(), value.getTimeZone(), format).         configs.put(key, config).     }).     DocValueFormat docValueFormat = resolveFormat(format, finalValueType).     return innerBuild(context, configs, docValueFormat, parent, subFactoriesBuilder). }
false;private,static;2;10;;private static DocValueFormat resolveFormat(@Nullable String format, @Nullable ValueType valueType) {     if (valueType == null) {         // we can't figure it out         return DocValueFormat.RAW.     }     DocValueFormat valueFormat = valueType.defaultFormat.     if (valueFormat instanceof DocValueFormat.Decimal && format != null) {         valueFormat = new DocValueFormat.Decimal(format).     }     return valueFormat. }
false;protected,abstract;5;3;;protected abstract MultiValuesSourceAggregatorFactory<VS, ?> innerBuild(SearchContext context, Map<String, ValuesSourceConfig<VS>> configs, DocValueFormat format, AggregatorFactory<?> parent, AggregatorFactories.Builder subFactoriesBuilder) throws IOException.
true;protected;0;3;/**  * Should this builder serialize its targetValueType? Defaults to false. All subclasses that override this to true  * should use the three argument read constructor rather than the four argument version.  */ ;/**  * Should this builder serialize its targetValueType? Defaults to false. All subclasses that override this to true  * should use the three argument read constructor rather than the four argument version.  */ protected boolean serializeTargetValueType() {     return false. }
false;public,final;2;18;;@Override public final XContentBuilder internalXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     if (fields != null) {         for (Map.Entry<String, MultiValuesSourceFieldConfig> fieldEntry : fields.entrySet()) {             builder.field(fieldEntry.getKey(), fieldEntry.getValue()).         }     }     if (format != null) {         builder.field(CommonFields.FORMAT.getPreferredName(), format).     }     if (valueType != null) {         builder.field(CommonFields.VALUE_TYPE.getPreferredName(), valueType.getPreferredName()).     }     doXContentBody(builder, params).     builder.endObject().     return builder. }
false;protected,abstract;2;1;;protected abstract XContentBuilder doXContentBody(XContentBuilder builder, Params params) throws IOException.
false;protected,final;0;4;;@Override protected final int doHashCode() {     return Objects.hash(fields, format, targetValueType, valueType, innerHashCode()). }
false;protected,abstract;0;1;;protected abstract int innerHashCode().
false;protected,final;1;16;;@Override protected final boolean doEquals(Object other) {     if (this == other) {         return true.     }     if (other == null || getClass() != other.getClass()) {         return false.     }     MultiValuesSourceAggregationBuilder that = (MultiValuesSourceAggregationBuilder) other.     return Objects.equals(this.fields, that.fields) && Objects.equals(this.format, that.format) && Objects.equals(this.valueType, that.valueType). }
false;protected,abstract;1;1;;protected abstract boolean innerEquals(Object obj).
