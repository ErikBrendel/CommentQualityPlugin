commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public MappedFieldType fieldType() {     return fieldType. }
false;public;1;23;;public T index(boolean index) {     if (index) {         if (fieldType.indexOptions() == IndexOptions.NONE) {             /*                      * the logic here is to reset to the default options only if we are not indexed ie. options are null                      * if the fieldType has a non-null option we are all good it might have been set through a different                      * call.                      */             IndexOptions options = getDefaultIndexOption().             if (options == IndexOptions.NONE) {                 // created on an index                 throw new IllegalArgumentException("mapper [" + name + "] has different [index] values from other types" + " of the same index").             }             fieldType.setIndexOptions(options).         }     } else {         fieldType.setIndexOptions(IndexOptions.NONE).     }     return builder. }
false;protected;0;3;;protected IndexOptions getDefaultIndexOption() {     return defaultOptions. }
false;public;1;4;;public T store(boolean store) {     this.fieldType.setStored(store).     return builder. }
false;public;1;5;;public T docValues(boolean docValues) {     this.fieldType.setHasDocValues(docValues).     this.docValuesSet = true.     return builder. }
false;public;1;6;;public T storeTermVectors(boolean termVectors) {     if (termVectors != this.fieldType.storeTermVectors()) {         this.fieldType.setStoreTermVectors(termVectors).     }     // don't set it to false, it is default and might be flipped by a more specific option     return builder. }
false;public;1;7;;public T storeTermVectorOffsets(boolean termVectorOffsets) {     if (termVectorOffsets) {         this.fieldType.setStoreTermVectors(termVectorOffsets).     }     this.fieldType.setStoreTermVectorOffsets(termVectorOffsets).     return builder. }
false;public;1;7;;public T storeTermVectorPositions(boolean termVectorPositions) {     if (termVectorPositions) {         this.fieldType.setStoreTermVectors(termVectorPositions).     }     this.fieldType.setStoreTermVectorPositions(termVectorPositions).     return builder. }
false;public;1;7;;public T storeTermVectorPayloads(boolean termVectorPayloads) {     if (termVectorPayloads) {         this.fieldType.setStoreTermVectors(termVectorPayloads).     }     this.fieldType.setStoreTermVectorPayloads(termVectorPayloads).     return builder. }
false;public;1;4;;public T boost(float boost) {     this.fieldType.setBoost(boost).     return builder. }
false;public;1;5;;public T omitNorms(boolean omitNorms) {     this.fieldType.setOmitNorms(omitNorms).     this.omitNormsSet = true.     return builder. }
false;public;1;5;;public T indexOptions(IndexOptions indexOptions) {     this.fieldType.setIndexOptions(indexOptions).     this.indexOptionsSet = true.     return builder. }
false;public;1;4;;public T indexAnalyzer(NamedAnalyzer indexAnalyzer) {     this.fieldType.setIndexAnalyzer(indexAnalyzer).     return builder. }
false;public;1;4;;public T searchAnalyzer(NamedAnalyzer searchAnalyzer) {     this.fieldType.setSearchAnalyzer(searchAnalyzer).     return builder. }
false;public;1;4;;public T searchQuoteAnalyzer(NamedAnalyzer searchQuoteAnalyzer) {     this.fieldType.setSearchQuoteAnalyzer(searchQuoteAnalyzer).     return builder. }
false;public;1;4;;public T similarity(SimilarityProvider similarity) {     this.fieldType.setSimilarity(similarity).     return builder. }
false;public;1;4;;public Builder nullValue(Object nullValue) {     this.fieldType.setNullValue(nullValue).     return this. }
false;public;1;4;;public T addMultiField(Mapper.Builder mapperBuilder) {     multiFieldsBuilder.add(mapperBuilder).     return builder. }
false;public;1;4;;public T copyTo(CopyTo copyTo) {     this.copyTo = copyTo.     return builder. }
false;protected;1;3;;protected String buildFullName(BuilderContext context) {     return context.path().pathAsText(name). }
false;protected;1;3;;protected boolean defaultDocValues(Version indexCreated) {     return fieldType.tokenized() == false. }
false;protected;1;12;;protected void setupFieldType(BuilderContext context) {     fieldType.setName(buildFullName(context)).     if (fieldType.indexAnalyzer() == null && fieldType.tokenized() == false && fieldType.indexOptions() != IndexOptions.NONE) {         fieldType.setIndexAnalyzer(Lucene.KEYWORD_ANALYZER).         fieldType.setSearchAnalyzer(Lucene.KEYWORD_ANALYZER).     }     boolean defaultDocValues = defaultDocValues(context.indexCreatedVersion()).     defaultFieldType.setHasDocValues(defaultDocValues).     if (docValuesSet == false) {         fieldType.setHasDocValues(defaultDocValues).     } }
false;public;0;4;;@Override public String name() {     return fieldType().name(). }
false;public;0;4;;@Override public String typeName() {     return fieldType.typeName(). }
false;public;0;3;;public MappedFieldType fieldType() {     return fieldType. }
true;public;0;3;/**  * List of fields where this field should be copied to  */ ;/**  * List of fields where this field should be copied to  */ public CopyTo copyTo() {     return copyTo. }
true;public;1;13;/**  * Parse the field value using the provided {@link ParseContext}.  */ ;/**  * Parse the field value using the provided {@link ParseContext}.  */ public void parse(ParseContext context) throws IOException {     final List<IndexableField> fields = new ArrayList<>(2).     try {         parseCreateField(context, fields).         for (IndexableField field : fields) {             context.doc().add(field).         }     } catch (Exception e) {         throw new MapperParsingException("failed to parse field [{}] of type [{}] in document with id '{}'", e, fieldType().name(), fieldType().typeName(), context.sourceToParse().id()).     }     multiFields.parse(this, context). }
true;protected,abstract;2;1;/**  * Parse the field value and populate <code>fields</code>.  */ ;/**  * Parse the field value and populate <code>fields</code>.  */ protected abstract void parseCreateField(ParseContext context, List<IndexableField> fields) throws IOException.
false;protected;2;9;;protected void createFieldNamesField(ParseContext context, List<IndexableField> fields) {     FieldNamesFieldType fieldNamesFieldType = (FieldNamesFieldMapper.FieldNamesFieldType) context.docMapper().metadataMapper(FieldNamesFieldMapper.class).fieldType().     if (fieldNamesFieldType != null && fieldNamesFieldType.isEnabled()) {         for (String fieldName : FieldNamesFieldMapper.extractFieldNames(fieldType().name())) {             fields.add(new Field(FieldNamesFieldMapper.NAME, fieldName, fieldNamesFieldType)).         }     } }
false;public;0;4;;@Override public Iterator<Mapper> iterator() {     return multiFields.iterator(). }
false;protected;0;8;;@Override protected FieldMapper clone() {     try {         return (FieldMapper) super.clone().     } catch (CloneNotSupportedException e) {         throw new AssertionError(e).     } }
false;public;1;6;;@Override public FieldMapper merge(Mapper mergeWith) {     FieldMapper merged = clone().     merged.doMerge(mergeWith).     return merged. }
true;protected;1;16;/**  * Merge changes coming from {@code mergeWith} in place.  */ ;/**  * Merge changes coming from {@code mergeWith} in place.  */ protected void doMerge(Mapper mergeWith) {     if (!this.getClass().equals(mergeWith.getClass())) {         String mergedType = mergeWith.getClass().getSimpleName().         if (mergeWith instanceof FieldMapper) {             mergedType = ((FieldMapper) mergeWith).contentType().         }         throw new IllegalArgumentException("mapper [" + fieldType().name() + "] of different type, current_type [" + contentType() + "], merged_type [" + mergedType + "]").     }     FieldMapper fieldMergeWith = (FieldMapper) mergeWith.     multiFields = multiFields.merge(fieldMergeWith.multiFields).     // apply changeable values     this.fieldType = fieldMergeWith.fieldType.     this.copyTo = fieldMergeWith.copyTo. }
false;public;1;20;;@Override public FieldMapper updateFieldType(Map<String, MappedFieldType> fullNameToFieldType) {     final MappedFieldType newFieldType = fullNameToFieldType.get(fieldType.name()).     if (newFieldType == null) {         // this can happen if this mapper represents a mapping update         return this.     } else if (fieldType.getClass() != newFieldType.getClass()) {         throw new IllegalStateException("Mixing up field types: " + fieldType.getClass() + " != " + newFieldType.getClass() + " on field " + fieldType.name()).     }     MultiFields updatedMultiFields = multiFields.updateFieldType(fullNameToFieldType).     if (fieldType == newFieldType && multiFields == updatedMultiFields) {         // no change         return this.     }     FieldMapper updated = clone().     updated.fieldType = newFieldType.     updated.multiFields = updatedMultiFields.     return updated. }
false;public;2;7;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject(simpleName()).     boolean includeDefaults = params.paramAsBoolean("include_defaults", false).     doXContentBody(builder, includeDefaults, params).     return builder.endObject(). }
false;protected;3;39;;protected void doXContentBody(XContentBuilder builder, boolean includeDefaults, Params params) throws IOException {     builder.field("type", contentType()).     if (includeDefaults || fieldType().boost() != 1.0f) {         builder.field("boost", fieldType().boost()).     }     boolean indexed = fieldType().indexOptions() != IndexOptions.NONE.     boolean defaultIndexed = defaultFieldType.indexOptions() != IndexOptions.NONE.     if (includeDefaults || indexed != defaultIndexed) {         builder.field("index", indexed).     }     if (includeDefaults || fieldType().stored() != defaultFieldType.stored()) {         builder.field("store", fieldType().stored()).     }     doXContentDocValues(builder, includeDefaults).     if (includeDefaults || fieldType().storeTermVectors() != defaultFieldType.storeTermVectors()) {         builder.field("term_vector", termVectorOptionsToString(fieldType())).     }     if (includeDefaults || fieldType().omitNorms() != defaultFieldType.omitNorms()) {         builder.field("norms", fieldType().omitNorms() == false).     }     if (indexed && (includeDefaults || fieldType().indexOptions() != defaultFieldType.indexOptions())) {         builder.field("index_options", indexOptionToString(fieldType().indexOptions())).     }     if (includeDefaults || fieldType().eagerGlobalOrdinals() != defaultFieldType.eagerGlobalOrdinals()) {         builder.field("eager_global_ordinals", fieldType().eagerGlobalOrdinals()).     }     if (fieldType().similarity() != null) {         builder.field("similarity", fieldType().similarity().name()).     } else if (includeDefaults) {         builder.field("similarity", SimilarityService.DEFAULT_SIMILARITY).     }     multiFields.toXContent(builder, params).     copyTo.toXContent(builder, params). }
false;protected,final;2;24;;protected final void doXContentAnalyzers(XContentBuilder builder, boolean includeDefaults) throws IOException {     if (fieldType.tokenized() == false) {         return.     }     if (fieldType().indexAnalyzer() == null) {         if (includeDefaults) {             builder.field("analyzer", "default").         }     } else {         boolean hasDefaultIndexAnalyzer = fieldType().indexAnalyzer().name().equals("default").         final String searchAnalyzerName = fieldType().searchAnalyzer().name().         boolean hasDifferentSearchAnalyzer = searchAnalyzerName.equals(fieldType().indexAnalyzer().name()) == false.         boolean hasDifferentSearchQuoteAnalyzer = searchAnalyzerName.equals(fieldType().searchQuoteAnalyzer().name()) == false.         if (includeDefaults || hasDefaultIndexAnalyzer == false || hasDifferentSearchAnalyzer || hasDifferentSearchQuoteAnalyzer) {             builder.field("analyzer", fieldType().indexAnalyzer().name()).             if (includeDefaults || hasDifferentSearchAnalyzer || hasDifferentSearchQuoteAnalyzer) {                 builder.field("search_analyzer", searchAnalyzerName).                 if (includeDefaults || hasDifferentSearchQuoteAnalyzer) {                     builder.field("search_quote_analyzer", fieldType().searchQuoteAnalyzer().name()).                 }             }         }     } }
false;protected;2;5;;protected void doXContentDocValues(XContentBuilder builder, boolean includeDefaults) throws IOException {     if (includeDefaults || defaultFieldType.hasDocValues() != fieldType().hasDocValues()) {         builder.field("doc_values", fieldType().hasDocValues()).     } }
false;protected,static;1;14;;protected static String indexOptionToString(IndexOptions indexOption) {     switch(indexOption) {         case DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS:             return TypeParsers.INDEX_OPTIONS_OFFSETS.         case DOCS_AND_FREQS:             return TypeParsers.INDEX_OPTIONS_FREQS.         case DOCS_AND_FREQS_AND_POSITIONS:             return TypeParsers.INDEX_OPTIONS_POSITIONS.         case DOCS:             return TypeParsers.INDEX_OPTIONS_DOCS.         default:             throw new IllegalArgumentException("Unknown IndexOptions [" + indexOption + "]").     } }
false;public,static;1;21;;public static String termVectorOptionsToString(FieldType fieldType) {     if (!fieldType.storeTermVectors()) {         return "no".     } else if (!fieldType.storeTermVectorOffsets() && !fieldType.storeTermVectorPositions()) {         return "yes".     } else if (fieldType.storeTermVectorOffsets() && !fieldType.storeTermVectorPositions()) {         return "with_offsets".     } else {         StringBuilder builder = new StringBuilder("with").         if (fieldType.storeTermVectorPositions()) {             builder.append("_positions").         }         if (fieldType.storeTermVectorOffsets()) {             builder.append("_offsets").         }         if (fieldType.storeTermVectorPayloads()) {             builder.append("_payloads").         }         return builder.toString().     } }
false;protected,abstract;0;1;;protected abstract String contentType().
false;public,static;0;3;;public static MultiFields empty() {     return new MultiFields(ImmutableOpenMap.<String, FieldMapper>of()). }
false;public;1;4;;public Builder add(Mapper.Builder builder) {     mapperBuilders.put(builder.name(), builder).     return this. }
false;public;2;19;;@SuppressWarnings("unchecked") public MultiFields build(FieldMapper.Builder mainFieldBuilder, BuilderContext context) {     if (mapperBuilders.isEmpty()) {         return empty().     } else {         context.path().add(mainFieldBuilder.name()).         ImmutableOpenMap.Builder mapperBuilders = this.mapperBuilders.         for (ObjectObjectCursor<String, Mapper.Builder> cursor : this.mapperBuilders) {             String key = cursor.key.             Mapper.Builder value = cursor.value.             Mapper mapper = value.build(context).             assert mapper instanceof FieldMapper.             mapperBuilders.put(key, mapper).         }         context.path().remove().         ImmutableOpenMap.Builder<String, FieldMapper> mappers = mapperBuilders.cast().         return new MultiFields(mappers.build()).     } }
false;public;2;15;;public void parse(FieldMapper mainField, ParseContext context) throws IOException {     // of the mappings     if (mappers.isEmpty()) {         return.     }     context = context.createMultiFieldContext().     context.path().add(mainField.simpleName()).     for (ObjectCursor<FieldMapper> cursor : mappers.values()) {         cursor.value.parse(context).     }     context.path().remove(). }
false;public;1;17;;public MultiFields merge(MultiFields mergeWith) {     ImmutableOpenMap.Builder<String, FieldMapper> newMappersBuilder = ImmutableOpenMap.builder(mappers).     for (ObjectCursor<FieldMapper> cursor : mergeWith.mappers.values()) {         FieldMapper mergeWithMapper = cursor.value.         FieldMapper mergeIntoMapper = mappers.get(mergeWithMapper.simpleName()).         if (mergeIntoMapper == null) {             newMappersBuilder.put(mergeWithMapper.simpleName(), mergeWithMapper).         } else {             FieldMapper merged = mergeIntoMapper.merge(mergeWithMapper).             // override previous definition             newMappersBuilder.put(merged.simpleName(), merged).         }     }     ImmutableOpenMap<String, FieldMapper> mappers = newMappersBuilder.build().     return new MultiFields(mappers). }
false;public;1;20;;public MultiFields updateFieldType(Map<String, MappedFieldType> fullNameToFieldType) {     ImmutableOpenMap.Builder<String, FieldMapper> newMappersBuilder = null.     for (ObjectCursor<FieldMapper> cursor : mappers.values()) {         FieldMapper updated = cursor.value.updateFieldType(fullNameToFieldType).         if (updated != cursor.value) {             if (newMappersBuilder == null) {                 newMappersBuilder = ImmutableOpenMap.builder(mappers).             }             newMappersBuilder.put(updated.simpleName(), updated).         }     }     if (newMappersBuilder == null) {         return this.     }     ImmutableOpenMap<String, FieldMapper> mappers = newMappersBuilder.build().     return new MultiFields(mappers). }
false;public;0;3;;public Iterator<Mapper> iterator() {     return StreamSupport.stream(mappers.values().spliterator(), false).map((p) -> (Mapper) p.value).iterator(). }
false;public;2;4;;@Override public int compare(Mapper o1, Mapper o2) {     return o1.name().compareTo(o2.name()). }
false;public;2;18;;public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     if (!mappers.isEmpty()) {         // sort the mappers so we get consistent serialization format         Mapper[] sortedMappers = mappers.values().toArray(Mapper.class).         Arrays.sort(sortedMappers, new Comparator<Mapper>() {              @Override             public int compare(Mapper o1, Mapper o2) {                 return o1.name().compareTo(o2.name()).             }         }).         builder.startObject("fields").         for (Mapper mapper : sortedMappers) {             mapper.toXContent(builder, params).         }         builder.endObject().     }     return builder. }
false;public,static;0;3;;public static CopyTo empty() {     return EMPTY. }
false;public;2;10;;public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     if (!copyToFields.isEmpty()) {         builder.startArray("copy_to").         for (String field : copyToFields) {             builder.value(field).         }         builder.endArray().     }     return builder. }
false;public;1;4;;public Builder add(String field) {     copyToBuilders.add(field).     return this. }
false;public;0;6;;public CopyTo build() {     if (copyToBuilders.isEmpty()) {         return EMPTY.     }     return new CopyTo(Collections.unmodifiableList(copyToBuilders)). }
false;public;0;3;;public List<String> copyToFields() {     return copyToFields. }
