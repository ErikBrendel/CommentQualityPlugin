# id;timestamp;commentText;codeText;commentWords;codeWords
IndexShardRoutingTable -> public List<ShardRouting> getShards();1524684173;Returns a {@link List} of shards__@return a {@link List} of shards;public List<ShardRouting> getShards() {_        return shards()__    };returns,a,link,list,of,shards,return,a,link,list,of,shards;public,list,shard,routing,get,shards,return,shards
IndexShardRoutingTable -> public List<ShardRouting> getShards();1526467406;Returns a {@link List} of shards__@return a {@link List} of shards;public List<ShardRouting> getShards() {_        return shards()__    };returns,a,link,list,of,shards,return,a,link,list,of,shards;public,list,shard,routing,get,shards,return,shards
IndexShardRoutingTable -> public List<ShardRouting> getShards();1528762805;Returns a {@link List} of shards__@return a {@link List} of shards;public List<ShardRouting> getShards() {_        return shards()__    };returns,a,link,list,of,shards,return,a,link,list,of,shards;public,list,shard,routing,get,shards,return,shards
IndexShardRoutingTable -> public List<ShardRouting> getShards();1539615817;Returns a {@link List} of shards__@return a {@link List} of shards;public List<ShardRouting> getShards() {_        return shards()__    };returns,a,link,list,of,shards,return,a,link,list,of,shards;public,list,shard,routing,get,shards,return,shards
IndexShardRoutingTable -> public List<ShardRouting> getShards();1540847035;Returns a {@link List} of shards__@return a {@link List} of shards;public List<ShardRouting> getShards() {_        return shards()__    };returns,a,link,list,of,shards,return,a,link,list,of,shards;public,list,shard,routing,get,shards,return,shards
IndexShardRoutingTable -> public List<ShardRouting> getShards();1541446827;Returns a {@link List} of shards__@return a {@link List} of shards;public List<ShardRouting> getShards() {_        return shards()__    };returns,a,link,list,of,shards,return,a,link,list,of,shards;public,list,shard,routing,get,shards,return,shards
IndexShardRoutingTable -> public List<ShardRouting> assignedShards();1524684173;Returns a {@link List} of assigned shards__@return a {@link List} of shards;public List<ShardRouting> assignedShards() {_        return this.assignedShards__    };returns,a,link,list,of,assigned,shards,return,a,link,list,of,shards;public,list,shard,routing,assigned,shards,return,this,assigned,shards
IndexShardRoutingTable -> public List<ShardRouting> assignedShards();1526467406;Returns a {@link List} of assigned shards__@return a {@link List} of shards;public List<ShardRouting> assignedShards() {_        return this.assignedShards__    };returns,a,link,list,of,assigned,shards,return,a,link,list,of,shards;public,list,shard,routing,assigned,shards,return,this,assigned,shards
IndexShardRoutingTable -> public List<ShardRouting> assignedShards();1528762805;Returns a {@link List} of assigned shards__@return a {@link List} of shards;public List<ShardRouting> assignedShards() {_        return this.assignedShards__    };returns,a,link,list,of,assigned,shards,return,a,link,list,of,shards;public,list,shard,routing,assigned,shards,return,this,assigned,shards
IndexShardRoutingTable -> public List<ShardRouting> assignedShards();1539615817;Returns a {@link List} of assigned shards__@return a {@link List} of shards;public List<ShardRouting> assignedShards() {_        return this.assignedShards__    };returns,a,link,list,of,assigned,shards,return,a,link,list,of,shards;public,list,shard,routing,assigned,shards,return,this,assigned,shards
IndexShardRoutingTable -> public List<ShardRouting> assignedShards();1540847035;Returns a {@link List} of assigned shards__@return a {@link List} of shards;public List<ShardRouting> assignedShards() {_        return this.assignedShards__    };returns,a,link,list,of,assigned,shards,return,a,link,list,of,shards;public,list,shard,routing,assigned,shards,return,this,assigned,shards
IndexShardRoutingTable -> public List<ShardRouting> assignedShards();1541446827;Returns a {@link List} of assigned shards__@return a {@link List} of shards;public List<ShardRouting> assignedShards() {_        return this.assignedShards__    };returns,a,link,list,of,assigned,shards,return,a,link,list,of,shards;public,list,shard,routing,assigned,shards,return,this,assigned,shards
IndexShardRoutingTable -> public List<ShardRouting> shards();1524684173;Returns a {@link List} of shards__@return a {@link List} of shards;public List<ShardRouting> shards() {_        return this.shards__    };returns,a,link,list,of,shards,return,a,link,list,of,shards;public,list,shard,routing,shards,return,this,shards
IndexShardRoutingTable -> public List<ShardRouting> shards();1526467406;Returns a {@link List} of shards__@return a {@link List} of shards;public List<ShardRouting> shards() {_        return this.shards__    };returns,a,link,list,of,shards,return,a,link,list,of,shards;public,list,shard,routing,shards,return,this,shards
IndexShardRoutingTable -> public List<ShardRouting> shards();1528762805;Returns a {@link List} of shards__@return a {@link List} of shards;public List<ShardRouting> shards() {_        return this.shards__    };returns,a,link,list,of,shards,return,a,link,list,of,shards;public,list,shard,routing,shards,return,this,shards
IndexShardRoutingTable -> public List<ShardRouting> shards();1539615817;Returns a {@link List} of shards__@return a {@link List} of shards;public List<ShardRouting> shards() {_        return this.shards__    };returns,a,link,list,of,shards,return,a,link,list,of,shards;public,list,shard,routing,shards,return,this,shards
IndexShardRoutingTable -> public List<ShardRouting> shards();1540847035;Returns a {@link List} of shards__@return a {@link List} of shards;public List<ShardRouting> shards() {_        return this.shards__    };returns,a,link,list,of,shards,return,a,link,list,of,shards;public,list,shard,routing,shards,return,this,shards
IndexShardRoutingTable -> public List<ShardRouting> shards();1541446827;Returns a {@link List} of shards__@return a {@link List} of shards;public List<ShardRouting> shards() {_        return this.shards__    };returns,a,link,list,of,shards,return,a,link,list,of,shards;public,list,shard,routing,shards,return,this,shards
IndexShardRoutingTable -> public List<ShardRouting> activeShards();1524684173;Returns a {@link List} of active shards__@return a {@link List} of shards;public List<ShardRouting> activeShards() {_        return this.activeShards__    };returns,a,link,list,of,active,shards,return,a,link,list,of,shards;public,list,shard,routing,active,shards,return,this,active,shards
IndexShardRoutingTable -> public List<ShardRouting> activeShards();1526467406;Returns a {@link List} of active shards__@return a {@link List} of shards;public List<ShardRouting> activeShards() {_        return this.activeShards__    };returns,a,link,list,of,active,shards,return,a,link,list,of,shards;public,list,shard,routing,active,shards,return,this,active,shards
IndexShardRoutingTable -> public List<ShardRouting> activeShards();1528762805;Returns a {@link List} of active shards__@return a {@link List} of shards;public List<ShardRouting> activeShards() {_        return this.activeShards__    };returns,a,link,list,of,active,shards,return,a,link,list,of,shards;public,list,shard,routing,active,shards,return,this,active,shards
IndexShardRoutingTable -> public List<ShardRouting> activeShards();1539615817;Returns a {@link List} of active shards__@return a {@link List} of shards;public List<ShardRouting> activeShards() {_        return this.activeShards__    };returns,a,link,list,of,active,shards,return,a,link,list,of,shards;public,list,shard,routing,active,shards,return,this,active,shards
IndexShardRoutingTable -> public List<ShardRouting> activeShards();1540847035;Returns a {@link List} of active shards__@return a {@link List} of shards;public List<ShardRouting> activeShards() {_        return this.activeShards__    };returns,a,link,list,of,active,shards,return,a,link,list,of,shards;public,list,shard,routing,active,shards,return,this,active,shards
IndexShardRoutingTable -> public List<ShardRouting> activeShards();1541446827;Returns a {@link List} of active shards__@return a {@link List} of shards;public List<ShardRouting> activeShards() {_        return this.activeShards__    };returns,a,link,list,of,active,shards,return,a,link,list,of,shards;public,list,shard,routing,active,shards,return,this,active,shards
IndexShardRoutingTable -> public List<ShardRouting> getAllInitializingShards();1524684173;Returns a {@link List} of all initializing shards, including target shards of relocations__@return a {@link List} of shards;public List<ShardRouting> getAllInitializingShards() {_        return this.allInitializingShards__    };returns,a,link,list,of,all,initializing,shards,including,target,shards,of,relocations,return,a,link,list,of,shards;public,list,shard,routing,get,all,initializing,shards,return,this,all,initializing,shards
IndexShardRoutingTable -> public List<ShardRouting> getAllInitializingShards();1526467406;Returns a {@link List} of all initializing shards, including target shards of relocations__@return a {@link List} of shards;public List<ShardRouting> getAllInitializingShards() {_        return this.allInitializingShards__    };returns,a,link,list,of,all,initializing,shards,including,target,shards,of,relocations,return,a,link,list,of,shards;public,list,shard,routing,get,all,initializing,shards,return,this,all,initializing,shards
IndexShardRoutingTable -> public List<ShardRouting> getAllInitializingShards();1528762805;Returns a {@link List} of all initializing shards, including target shards of relocations__@return a {@link List} of shards;public List<ShardRouting> getAllInitializingShards() {_        return this.allInitializingShards__    };returns,a,link,list,of,all,initializing,shards,including,target,shards,of,relocations,return,a,link,list,of,shards;public,list,shard,routing,get,all,initializing,shards,return,this,all,initializing,shards
IndexShardRoutingTable -> public List<ShardRouting> getAllInitializingShards();1539615817;Returns a {@link List} of all initializing shards, including target shards of relocations__@return a {@link List} of shards;public List<ShardRouting> getAllInitializingShards() {_        return this.allInitializingShards__    };returns,a,link,list,of,all,initializing,shards,including,target,shards,of,relocations,return,a,link,list,of,shards;public,list,shard,routing,get,all,initializing,shards,return,this,all,initializing,shards
IndexShardRoutingTable -> public List<ShardRouting> getAllInitializingShards();1540847035;Returns a {@link List} of all initializing shards, including target shards of relocations__@return a {@link List} of shards;public List<ShardRouting> getAllInitializingShards() {_        return this.allInitializingShards__    };returns,a,link,list,of,all,initializing,shards,including,target,shards,of,relocations,return,a,link,list,of,shards;public,list,shard,routing,get,all,initializing,shards,return,this,all,initializing,shards
IndexShardRoutingTable -> public List<ShardRouting> getAllInitializingShards();1541446827;Returns a {@link List} of all initializing shards, including target shards of relocations__@return a {@link List} of shards;public List<ShardRouting> getAllInitializingShards() {_        return this.allInitializingShards__    };returns,a,link,list,of,all,initializing,shards,including,target,shards,of,relocations,return,a,link,list,of,shards;public,list,shard,routing,get,all,initializing,shards,return,this,all,initializing,shards
IndexShardRoutingTable -> public int size();1524684173;Returns the number of this shards instances.;public int size() {_        return shards.size()__    };returns,the,number,of,this,shards,instances;public,int,size,return,shards,size
IndexShardRoutingTable -> public int size();1526467406;Returns the number of this shards instances.;public int size() {_        return shards.size()__    };returns,the,number,of,this,shards,instances;public,int,size,return,shards,size
IndexShardRoutingTable -> public int size();1528762805;Returns the number of this shards instances.;public int size() {_        return shards.size()__    };returns,the,number,of,this,shards,instances;public,int,size,return,shards,size
IndexShardRoutingTable -> public int size();1539615817;Returns the number of this shards instances.;public int size() {_        return shards.size()__    };returns,the,number,of,this,shards,instances;public,int,size,return,shards,size
IndexShardRoutingTable -> public int size();1540847035;Returns the number of this shards instances.;public int size() {_        return shards.size()__    };returns,the,number,of,this,shards,instances;public,int,size,return,shards,size
IndexShardRoutingTable -> public int size();1541446827;Returns the number of this shards instances.;public int size() {_        return shards.size()__    };returns,the,number,of,this,shards,instances;public,int,size,return,shards,size
IndexShardRoutingTable -> public List<ShardRouting> getAssignedShards();1524684173;Returns a {@link List} of assigned shards__@return a {@link List} of shards;public List<ShardRouting> getAssignedShards() {_        return this.assignedShards__    };returns,a,link,list,of,assigned,shards,return,a,link,list,of,shards;public,list,shard,routing,get,assigned,shards,return,this,assigned,shards
IndexShardRoutingTable -> public List<ShardRouting> getAssignedShards();1526467406;Returns a {@link List} of assigned shards__@return a {@link List} of shards;public List<ShardRouting> getAssignedShards() {_        return this.assignedShards__    };returns,a,link,list,of,assigned,shards,return,a,link,list,of,shards;public,list,shard,routing,get,assigned,shards,return,this,assigned,shards
IndexShardRoutingTable -> public List<ShardRouting> getAssignedShards();1528762805;Returns a {@link List} of assigned shards__@return a {@link List} of shards;public List<ShardRouting> getAssignedShards() {_        return this.assignedShards__    };returns,a,link,list,of,assigned,shards,return,a,link,list,of,shards;public,list,shard,routing,get,assigned,shards,return,this,assigned,shards
IndexShardRoutingTable -> public List<ShardRouting> getAssignedShards();1539615817;Returns a {@link List} of assigned shards__@return a {@link List} of shards;public List<ShardRouting> getAssignedShards() {_        return this.assignedShards__    };returns,a,link,list,of,assigned,shards,return,a,link,list,of,shards;public,list,shard,routing,get,assigned,shards,return,this,assigned,shards
IndexShardRoutingTable -> public List<ShardRouting> getAssignedShards();1540847035;Returns a {@link List} of assigned shards__@return a {@link List} of shards;public List<ShardRouting> getAssignedShards() {_        return this.assignedShards__    };returns,a,link,list,of,assigned,shards,return,a,link,list,of,shards;public,list,shard,routing,get,assigned,shards,return,this,assigned,shards
IndexShardRoutingTable -> private static void adjustStats(final ResponseCollectorService collector,                                     final Map<String, Optional<ResponseCollectorService.ComputedNodeStats>> nodeStats,                                     final String minNodeId,                                     final ResponseCollectorService.ComputedNodeStats minStats);1524684173;Adjust the for all other nodes' collected stats. In the original ranking paper there is no need to adjust other nodes' stats because_Cassandra sends occasional requests to all copies of the data, so their stats will be updated during that broadcast phase. In_Elasticsearch, however, we do not have that sort of broadcast-to-all behavior. In order to prevent a node that gets a high score and_then never gets any more requests, we must ensure it eventually returns to a more normal score and can be a candidate for serving_requests.__This adjustment takes the "winning" node's statistics and adds the average of those statistics with each non-winning node. Let's say_the winning node had a queue size of 10 and a non-winning node had a queue of 18. The average queue size is (10 + 18) / 2 = 14 so the_non-winning node will have statistics added for a queue size of 14. This is repeated for the response time and service times as well.;private static void adjustStats(final ResponseCollectorService collector,_                                    final Map<String, Optional<ResponseCollectorService.ComputedNodeStats>> nodeStats,_                                    final String minNodeId,_                                    final ResponseCollectorService.ComputedNodeStats minStats) {_        if (minNodeId != null) {_            for (Map.Entry<String, Optional<ResponseCollectorService.ComputedNodeStats>> entry : nodeStats.entrySet()) {_                final String nodeId = entry.getKey()__                final Optional<ResponseCollectorService.ComputedNodeStats> maybeStats = entry.getValue()__                if (nodeId.equals(minNodeId) == false && maybeStats.isPresent()) {_                    final ResponseCollectorService.ComputedNodeStats stats = maybeStats.get()__                    final int updatedQueue = (minStats.queueSize + stats.queueSize) / 2__                    final long updatedResponse = (long) (minStats.responseTime + stats.responseTime) / 2__                    final long updatedService = (long) (minStats.serviceTime + stats.serviceTime) / 2__                    collector.addNodeStatistics(nodeId, updatedQueue, updatedResponse, updatedService)__                }_            }_        }_    };adjust,the,for,all,other,nodes,collected,stats,in,the,original,ranking,paper,there,is,no,need,to,adjust,other,nodes,stats,because,cassandra,sends,occasional,requests,to,all,copies,of,the,data,so,their,stats,will,be,updated,during,that,broadcast,phase,in,elasticsearch,however,we,do,not,have,that,sort,of,broadcast,to,all,behavior,in,order,to,prevent,a,node,that,gets,a,high,score,and,then,never,gets,any,more,requests,we,must,ensure,it,eventually,returns,to,a,more,normal,score,and,can,be,a,candidate,for,serving,requests,this,adjustment,takes,the,winning,node,s,statistics,and,adds,the,average,of,those,statistics,with,each,non,winning,node,let,s,say,the,winning,node,had,a,queue,size,of,10,and,a,non,winning,node,had,a,queue,of,18,the,average,queue,size,is,10,18,2,14,so,the,non,winning,node,will,have,statistics,added,for,a,queue,size,of,14,this,is,repeated,for,the,response,time,and,service,times,as,well;private,static,void,adjust,stats,final,response,collector,service,collector,final,map,string,optional,response,collector,service,computed,node,stats,node,stats,final,string,min,node,id,final,response,collector,service,computed,node,stats,min,stats,if,min,node,id,null,for,map,entry,string,optional,response,collector,service,computed,node,stats,entry,node,stats,entry,set,final,string,node,id,entry,get,key,final,optional,response,collector,service,computed,node,stats,maybe,stats,entry,get,value,if,node,id,equals,min,node,id,false,maybe,stats,is,present,final,response,collector,service,computed,node,stats,stats,maybe,stats,get,final,int,updated,queue,min,stats,queue,size,stats,queue,size,2,final,long,updated,response,long,min,stats,response,time,stats,response,time,2,final,long,updated,service,long,min,stats,service,time,stats,service,time,2,collector,add,node,statistics,node,id,updated,queue,updated,response,updated,service
IndexShardRoutingTable -> private static void adjustStats(final ResponseCollectorService collector,                                     final Map<String, Optional<ResponseCollectorService.ComputedNodeStats>> nodeStats,                                     final String minNodeId,                                     final ResponseCollectorService.ComputedNodeStats minStats);1526467406;Adjust the for all other nodes' collected stats. In the original ranking paper there is no need to adjust other nodes' stats because_Cassandra sends occasional requests to all copies of the data, so their stats will be updated during that broadcast phase. In_Elasticsearch, however, we do not have that sort of broadcast-to-all behavior. In order to prevent a node that gets a high score and_then never gets any more requests, we must ensure it eventually returns to a more normal score and can be a candidate for serving_requests.__This adjustment takes the "winning" node's statistics and adds the average of those statistics with each non-winning node. Let's say_the winning node had a queue size of 10 and a non-winning node had a queue of 18. The average queue size is (10 + 18) / 2 = 14 so the_non-winning node will have statistics added for a queue size of 14. This is repeated for the response time and service times as well.;private static void adjustStats(final ResponseCollectorService collector,_                                    final Map<String, Optional<ResponseCollectorService.ComputedNodeStats>> nodeStats,_                                    final String minNodeId,_                                    final ResponseCollectorService.ComputedNodeStats minStats) {_        if (minNodeId != null) {_            for (Map.Entry<String, Optional<ResponseCollectorService.ComputedNodeStats>> entry : nodeStats.entrySet()) {_                final String nodeId = entry.getKey()__                final Optional<ResponseCollectorService.ComputedNodeStats> maybeStats = entry.getValue()__                if (nodeId.equals(minNodeId) == false && maybeStats.isPresent()) {_                    final ResponseCollectorService.ComputedNodeStats stats = maybeStats.get()__                    final int updatedQueue = (minStats.queueSize + stats.queueSize) / 2__                    final long updatedResponse = (long) (minStats.responseTime + stats.responseTime) / 2__                    final long updatedService = (long) (minStats.serviceTime + stats.serviceTime) / 2__                    collector.addNodeStatistics(nodeId, updatedQueue, updatedResponse, updatedService)__                }_            }_        }_    };adjust,the,for,all,other,nodes,collected,stats,in,the,original,ranking,paper,there,is,no,need,to,adjust,other,nodes,stats,because,cassandra,sends,occasional,requests,to,all,copies,of,the,data,so,their,stats,will,be,updated,during,that,broadcast,phase,in,elasticsearch,however,we,do,not,have,that,sort,of,broadcast,to,all,behavior,in,order,to,prevent,a,node,that,gets,a,high,score,and,then,never,gets,any,more,requests,we,must,ensure,it,eventually,returns,to,a,more,normal,score,and,can,be,a,candidate,for,serving,requests,this,adjustment,takes,the,winning,node,s,statistics,and,adds,the,average,of,those,statistics,with,each,non,winning,node,let,s,say,the,winning,node,had,a,queue,size,of,10,and,a,non,winning,node,had,a,queue,of,18,the,average,queue,size,is,10,18,2,14,so,the,non,winning,node,will,have,statistics,added,for,a,queue,size,of,14,this,is,repeated,for,the,response,time,and,service,times,as,well;private,static,void,adjust,stats,final,response,collector,service,collector,final,map,string,optional,response,collector,service,computed,node,stats,node,stats,final,string,min,node,id,final,response,collector,service,computed,node,stats,min,stats,if,min,node,id,null,for,map,entry,string,optional,response,collector,service,computed,node,stats,entry,node,stats,entry,set,final,string,node,id,entry,get,key,final,optional,response,collector,service,computed,node,stats,maybe,stats,entry,get,value,if,node,id,equals,min,node,id,false,maybe,stats,is,present,final,response,collector,service,computed,node,stats,stats,maybe,stats,get,final,int,updated,queue,min,stats,queue,size,stats,queue,size,2,final,long,updated,response,long,min,stats,response,time,stats,response,time,2,final,long,updated,service,long,min,stats,service,time,stats,service,time,2,collector,add,node,statistics,node,id,updated,queue,updated,response,updated,service
IndexShardRoutingTable -> private static void adjustStats(final ResponseCollectorService collector,                                     final Map<String, Optional<ResponseCollectorService.ComputedNodeStats>> nodeStats,                                     final String minNodeId,                                     final ResponseCollectorService.ComputedNodeStats minStats);1528762805;Adjust the for all other nodes' collected stats. In the original ranking paper there is no need to adjust other nodes' stats because_Cassandra sends occasional requests to all copies of the data, so their stats will be updated during that broadcast phase. In_Elasticsearch, however, we do not have that sort of broadcast-to-all behavior. In order to prevent a node that gets a high score and_then never gets any more requests, we must ensure it eventually returns to a more normal score and can be a candidate for serving_requests.__This adjustment takes the "winning" node's statistics and adds the average of those statistics with each non-winning node. Let's say_the winning node had a queue size of 10 and a non-winning node had a queue of 18. The average queue size is (10 + 18) / 2 = 14 so the_non-winning node will have statistics added for a queue size of 14. This is repeated for the response time and service times as well.;private static void adjustStats(final ResponseCollectorService collector,_                                    final Map<String, Optional<ResponseCollectorService.ComputedNodeStats>> nodeStats,_                                    final String minNodeId,_                                    final ResponseCollectorService.ComputedNodeStats minStats) {_        if (minNodeId != null) {_            for (Map.Entry<String, Optional<ResponseCollectorService.ComputedNodeStats>> entry : nodeStats.entrySet()) {_                final String nodeId = entry.getKey()__                final Optional<ResponseCollectorService.ComputedNodeStats> maybeStats = entry.getValue()__                if (nodeId.equals(minNodeId) == false && maybeStats.isPresent()) {_                    final ResponseCollectorService.ComputedNodeStats stats = maybeStats.get()__                    final int updatedQueue = (minStats.queueSize + stats.queueSize) / 2__                    final long updatedResponse = (long) (minStats.responseTime + stats.responseTime) / 2__                    final long updatedService = (long) (minStats.serviceTime + stats.serviceTime) / 2__                    collector.addNodeStatistics(nodeId, updatedQueue, updatedResponse, updatedService)__                }_            }_        }_    };adjust,the,for,all,other,nodes,collected,stats,in,the,original,ranking,paper,there,is,no,need,to,adjust,other,nodes,stats,because,cassandra,sends,occasional,requests,to,all,copies,of,the,data,so,their,stats,will,be,updated,during,that,broadcast,phase,in,elasticsearch,however,we,do,not,have,that,sort,of,broadcast,to,all,behavior,in,order,to,prevent,a,node,that,gets,a,high,score,and,then,never,gets,any,more,requests,we,must,ensure,it,eventually,returns,to,a,more,normal,score,and,can,be,a,candidate,for,serving,requests,this,adjustment,takes,the,winning,node,s,statistics,and,adds,the,average,of,those,statistics,with,each,non,winning,node,let,s,say,the,winning,node,had,a,queue,size,of,10,and,a,non,winning,node,had,a,queue,of,18,the,average,queue,size,is,10,18,2,14,so,the,non,winning,node,will,have,statistics,added,for,a,queue,size,of,14,this,is,repeated,for,the,response,time,and,service,times,as,well;private,static,void,adjust,stats,final,response,collector,service,collector,final,map,string,optional,response,collector,service,computed,node,stats,node,stats,final,string,min,node,id,final,response,collector,service,computed,node,stats,min,stats,if,min,node,id,null,for,map,entry,string,optional,response,collector,service,computed,node,stats,entry,node,stats,entry,set,final,string,node,id,entry,get,key,final,optional,response,collector,service,computed,node,stats,maybe,stats,entry,get,value,if,node,id,equals,min,node,id,false,maybe,stats,is,present,final,response,collector,service,computed,node,stats,stats,maybe,stats,get,final,int,updated,queue,min,stats,queue,size,stats,queue,size,2,final,long,updated,response,long,min,stats,response,time,stats,response,time,2,final,long,updated,service,long,min,stats,service,time,stats,service,time,2,collector,add,node,statistics,node,id,updated,queue,updated,response,updated,service
IndexShardRoutingTable -> private static void adjustStats(final ResponseCollectorService collector,                                     final Map<String, Optional<ResponseCollectorService.ComputedNodeStats>> nodeStats,                                     final String minNodeId,                                     final ResponseCollectorService.ComputedNodeStats minStats);1539615817;Adjust the for all other nodes' collected stats. In the original ranking paper there is no need to adjust other nodes' stats because_Cassandra sends occasional requests to all copies of the data, so their stats will be updated during that broadcast phase. In_Elasticsearch, however, we do not have that sort of broadcast-to-all behavior. In order to prevent a node that gets a high score and_then never gets any more requests, we must ensure it eventually returns to a more normal score and can be a candidate for serving_requests.__This adjustment takes the "winning" node's statistics and adds the average of those statistics with each non-winning node. Let's say_the winning node had a queue size of 10 and a non-winning node had a queue of 18. The average queue size is (10 + 18) / 2 = 14 so the_non-winning node will have statistics added for a queue size of 14. This is repeated for the response time and service times as well.;private static void adjustStats(final ResponseCollectorService collector,_                                    final Map<String, Optional<ResponseCollectorService.ComputedNodeStats>> nodeStats,_                                    final String minNodeId,_                                    final ResponseCollectorService.ComputedNodeStats minStats) {_        if (minNodeId != null) {_            for (Map.Entry<String, Optional<ResponseCollectorService.ComputedNodeStats>> entry : nodeStats.entrySet()) {_                final String nodeId = entry.getKey()__                final Optional<ResponseCollectorService.ComputedNodeStats> maybeStats = entry.getValue()__                if (nodeId.equals(minNodeId) == false && maybeStats.isPresent()) {_                    final ResponseCollectorService.ComputedNodeStats stats = maybeStats.get()__                    final int updatedQueue = (minStats.queueSize + stats.queueSize) / 2__                    final long updatedResponse = (long) (minStats.responseTime + stats.responseTime) / 2__                    final long updatedService = (long) (minStats.serviceTime + stats.serviceTime) / 2__                    collector.addNodeStatistics(nodeId, updatedQueue, updatedResponse, updatedService)__                }_            }_        }_    };adjust,the,for,all,other,nodes,collected,stats,in,the,original,ranking,paper,there,is,no,need,to,adjust,other,nodes,stats,because,cassandra,sends,occasional,requests,to,all,copies,of,the,data,so,their,stats,will,be,updated,during,that,broadcast,phase,in,elasticsearch,however,we,do,not,have,that,sort,of,broadcast,to,all,behavior,in,order,to,prevent,a,node,that,gets,a,high,score,and,then,never,gets,any,more,requests,we,must,ensure,it,eventually,returns,to,a,more,normal,score,and,can,be,a,candidate,for,serving,requests,this,adjustment,takes,the,winning,node,s,statistics,and,adds,the,average,of,those,statistics,with,each,non,winning,node,let,s,say,the,winning,node,had,a,queue,size,of,10,and,a,non,winning,node,had,a,queue,of,18,the,average,queue,size,is,10,18,2,14,so,the,non,winning,node,will,have,statistics,added,for,a,queue,size,of,14,this,is,repeated,for,the,response,time,and,service,times,as,well;private,static,void,adjust,stats,final,response,collector,service,collector,final,map,string,optional,response,collector,service,computed,node,stats,node,stats,final,string,min,node,id,final,response,collector,service,computed,node,stats,min,stats,if,min,node,id,null,for,map,entry,string,optional,response,collector,service,computed,node,stats,entry,node,stats,entry,set,final,string,node,id,entry,get,key,final,optional,response,collector,service,computed,node,stats,maybe,stats,entry,get,value,if,node,id,equals,min,node,id,false,maybe,stats,is,present,final,response,collector,service,computed,node,stats,stats,maybe,stats,get,final,int,updated,queue,min,stats,queue,size,stats,queue,size,2,final,long,updated,response,long,min,stats,response,time,stats,response,time,2,final,long,updated,service,long,min,stats,service,time,stats,service,time,2,collector,add,node,statistics,node,id,updated,queue,updated,response,updated,service
IndexShardRoutingTable -> private static void adjustStats(final ResponseCollectorService collector,                                     final Map<String, Optional<ResponseCollectorService.ComputedNodeStats>> nodeStats,                                     final String minNodeId,                                     final ResponseCollectorService.ComputedNodeStats minStats);1540847035;Adjust the for all other nodes' collected stats. In the original ranking paper there is no need to adjust other nodes' stats because_Cassandra sends occasional requests to all copies of the data, so their stats will be updated during that broadcast phase. In_Elasticsearch, however, we do not have that sort of broadcast-to-all behavior. In order to prevent a node that gets a high score and_then never gets any more requests, we must ensure it eventually returns to a more normal score and can be a candidate for serving_requests.__This adjustment takes the "winning" node's statistics and adds the average of those statistics with each non-winning node. Let's say_the winning node had a queue size of 10 and a non-winning node had a queue of 18. The average queue size is (10 + 18) / 2 = 14 so the_non-winning node will have statistics added for a queue size of 14. This is repeated for the response time and service times as well.;private static void adjustStats(final ResponseCollectorService collector,_                                    final Map<String, Optional<ResponseCollectorService.ComputedNodeStats>> nodeStats,_                                    final String minNodeId,_                                    final ResponseCollectorService.ComputedNodeStats minStats) {_        if (minNodeId != null) {_            for (Map.Entry<String, Optional<ResponseCollectorService.ComputedNodeStats>> entry : nodeStats.entrySet()) {_                final String nodeId = entry.getKey()__                final Optional<ResponseCollectorService.ComputedNodeStats> maybeStats = entry.getValue()__                if (nodeId.equals(minNodeId) == false && maybeStats.isPresent()) {_                    final ResponseCollectorService.ComputedNodeStats stats = maybeStats.get()__                    final int updatedQueue = (minStats.queueSize + stats.queueSize) / 2__                    final long updatedResponse = (long) (minStats.responseTime + stats.responseTime) / 2__                    final long updatedService = (long) (minStats.serviceTime + stats.serviceTime) / 2__                    collector.addNodeStatistics(nodeId, updatedQueue, updatedResponse, updatedService)__                }_            }_        }_    };adjust,the,for,all,other,nodes,collected,stats,in,the,original,ranking,paper,there,is,no,need,to,adjust,other,nodes,stats,because,cassandra,sends,occasional,requests,to,all,copies,of,the,data,so,their,stats,will,be,updated,during,that,broadcast,phase,in,elasticsearch,however,we,do,not,have,that,sort,of,broadcast,to,all,behavior,in,order,to,prevent,a,node,that,gets,a,high,score,and,then,never,gets,any,more,requests,we,must,ensure,it,eventually,returns,to,a,more,normal,score,and,can,be,a,candidate,for,serving,requests,this,adjustment,takes,the,winning,node,s,statistics,and,adds,the,average,of,those,statistics,with,each,non,winning,node,let,s,say,the,winning,node,had,a,queue,size,of,10,and,a,non,winning,node,had,a,queue,of,18,the,average,queue,size,is,10,18,2,14,so,the,non,winning,node,will,have,statistics,added,for,a,queue,size,of,14,this,is,repeated,for,the,response,time,and,service,times,as,well;private,static,void,adjust,stats,final,response,collector,service,collector,final,map,string,optional,response,collector,service,computed,node,stats,node,stats,final,string,min,node,id,final,response,collector,service,computed,node,stats,min,stats,if,min,node,id,null,for,map,entry,string,optional,response,collector,service,computed,node,stats,entry,node,stats,entry,set,final,string,node,id,entry,get,key,final,optional,response,collector,service,computed,node,stats,maybe,stats,entry,get,value,if,node,id,equals,min,node,id,false,maybe,stats,is,present,final,response,collector,service,computed,node,stats,stats,maybe,stats,get,final,int,updated,queue,min,stats,queue,size,stats,queue,size,2,final,long,updated,response,long,min,stats,response,time,stats,response,time,2,final,long,updated,service,long,min,stats,service,time,stats,service,time,2,collector,add,node,statistics,node,id,updated,queue,updated,response,updated,service
IndexShardRoutingTable -> private static void adjustStats(final ResponseCollectorService collector,                                     final Map<String, Optional<ResponseCollectorService.ComputedNodeStats>> nodeStats,                                     final String minNodeId,                                     final ResponseCollectorService.ComputedNodeStats minStats);1541446827;Adjust the for all other nodes' collected stats. In the original ranking paper there is no need to adjust other nodes' stats because_Cassandra sends occasional requests to all copies of the data, so their stats will be updated during that broadcast phase. In_Elasticsearch, however, we do not have that sort of broadcast-to-all behavior. In order to prevent a node that gets a high score and_then never gets any more requests, we must ensure it eventually returns to a more normal score and can be a candidate for serving_requests.__This adjustment takes the "winning" node's statistics and adds the average of those statistics with each non-winning node. Let's say_the winning node had a queue size of 10 and a non-winning node had a queue of 18. The average queue size is (10 + 18) / 2 = 14 so the_non-winning node will have statistics added for a queue size of 14. This is repeated for the response time and service times as well.;private static void adjustStats(final ResponseCollectorService collector,_                                    final Map<String, Optional<ResponseCollectorService.ComputedNodeStats>> nodeStats,_                                    final String minNodeId,_                                    final ResponseCollectorService.ComputedNodeStats minStats) {_        if (minNodeId != null) {_            for (Map.Entry<String, Optional<ResponseCollectorService.ComputedNodeStats>> entry : nodeStats.entrySet()) {_                final String nodeId = entry.getKey()__                final Optional<ResponseCollectorService.ComputedNodeStats> maybeStats = entry.getValue()__                if (nodeId.equals(minNodeId) == false && maybeStats.isPresent()) {_                    final ResponseCollectorService.ComputedNodeStats stats = maybeStats.get()__                    final int updatedQueue = (minStats.queueSize + stats.queueSize) / 2__                    final long updatedResponse = (long) (minStats.responseTime + stats.responseTime) / 2__                    final long updatedService = (long) (minStats.serviceTime + stats.serviceTime) / 2__                    collector.addNodeStatistics(nodeId, updatedQueue, updatedResponse, updatedService)__                }_            }_        }_    };adjust,the,for,all,other,nodes,collected,stats,in,the,original,ranking,paper,there,is,no,need,to,adjust,other,nodes,stats,because,cassandra,sends,occasional,requests,to,all,copies,of,the,data,so,their,stats,will,be,updated,during,that,broadcast,phase,in,elasticsearch,however,we,do,not,have,that,sort,of,broadcast,to,all,behavior,in,order,to,prevent,a,node,that,gets,a,high,score,and,then,never,gets,any,more,requests,we,must,ensure,it,eventually,returns,to,a,more,normal,score,and,can,be,a,candidate,for,serving,requests,this,adjustment,takes,the,winning,node,s,statistics,and,adds,the,average,of,those,statistics,with,each,non,winning,node,let,s,say,the,winning,node,had,a,queue,size,of,10,and,a,non,winning,node,had,a,queue,of,18,the,average,queue,size,is,10,18,2,14,so,the,non,winning,node,will,have,statistics,added,for,a,queue,size,of,14,this,is,repeated,for,the,response,time,and,service,times,as,well;private,static,void,adjust,stats,final,response,collector,service,collector,final,map,string,optional,response,collector,service,computed,node,stats,node,stats,final,string,min,node,id,final,response,collector,service,computed,node,stats,min,stats,if,min,node,id,null,for,map,entry,string,optional,response,collector,service,computed,node,stats,entry,node,stats,entry,set,final,string,node,id,entry,get,key,final,optional,response,collector,service,computed,node,stats,maybe,stats,entry,get,value,if,node,id,equals,min,node,id,false,maybe,stats,is,present,final,response,collector,service,computed,node,stats,stats,maybe,stats,get,final,int,updated,queue,min,stats,queue,size,stats,queue,size,2,final,long,updated,response,long,min,stats,response,time,stats,response,time,2,final,long,updated,service,long,min,stats,service,time,stats,service,time,2,collector,add,node,statistics,node,id,updated,queue,updated,response,updated,service
IndexShardRoutingTable -> public int getSize();1524684173;Returns the number of this shards instances.;public int getSize() {_        return size()__    };returns,the,number,of,this,shards,instances;public,int,get,size,return,size
IndexShardRoutingTable -> public int getSize();1526467406;Returns the number of this shards instances.;public int getSize() {_        return size()__    };returns,the,number,of,this,shards,instances;public,int,get,size,return,size
IndexShardRoutingTable -> public int getSize();1528762805;Returns the number of this shards instances.;public int getSize() {_        return size()__    };returns,the,number,of,this,shards,instances;public,int,get,size,return,size
IndexShardRoutingTable -> public int getSize();1539615817;Returns the number of this shards instances.;public int getSize() {_        return size()__    };returns,the,number,of,this,shards,instances;public,int,get,size,return,size
IndexShardRoutingTable -> public int getSize();1540847035;Returns the number of this shards instances.;public int getSize() {_        return size()__    };returns,the,number,of,this,shards,instances;public,int,get,size,return,size
IndexShardRoutingTable -> public int getSize();1541446827;Returns the number of this shards instances.;public int getSize() {_        return size()__    };returns,the,number,of,this,shards,instances;public,int,get,size,return,size
IndexShardRoutingTable -> public ShardIterator primaryShardIt();1524684173;Returns an iterator only on the primary shard.;public ShardIterator primaryShardIt() {_        return new PlainShardIterator(shardId, primaryAsList)__    };returns,an,iterator,only,on,the,primary,shard;public,shard,iterator,primary,shard,it,return,new,plain,shard,iterator,shard,id,primary,as,list
IndexShardRoutingTable -> public ShardIterator primaryShardIt();1526467406;Returns an iterator only on the primary shard.;public ShardIterator primaryShardIt() {_        return new PlainShardIterator(shardId, primaryAsList)__    };returns,an,iterator,only,on,the,primary,shard;public,shard,iterator,primary,shard,it,return,new,plain,shard,iterator,shard,id,primary,as,list
IndexShardRoutingTable -> public ShardIterator primaryShardIt();1528762805;Returns an iterator only on the primary shard.;public ShardIterator primaryShardIt() {_        return new PlainShardIterator(shardId, primaryAsList)__    };returns,an,iterator,only,on,the,primary,shard;public,shard,iterator,primary,shard,it,return,new,plain,shard,iterator,shard,id,primary,as,list
IndexShardRoutingTable -> public ShardIterator primaryShardIt();1539615817;Returns an iterator only on the primary shard.;public ShardIterator primaryShardIt() {_        return new PlainShardIterator(shardId, primaryAsList)__    };returns,an,iterator,only,on,the,primary,shard;public,shard,iterator,primary,shard,it,return,new,plain,shard,iterator,shard,id,primary,as,list
IndexShardRoutingTable -> public ShardIterator primaryShardIt();1540847035;Returns an iterator only on the primary shard.;public ShardIterator primaryShardIt() {_        return new PlainShardIterator(shardId, primaryAsList)__    };returns,an,iterator,only,on,the,primary,shard;public,shard,iterator,primary,shard,it,return,new,plain,shard,iterator,shard,id,primary,as,list
IndexShardRoutingTable -> public ShardIterator primaryShardIt();1541446827;Returns an iterator only on the primary shard.;public ShardIterator primaryShardIt() {_        return new PlainShardIterator(shardId, primaryAsList)__    };returns,an,iterator,only,on,the,primary,shard;public,shard,iterator,primary,shard,it,return,new,plain,shard,iterator,shard,id,primary,as,list
IndexShardRoutingTable -> public ShardIterator activeInitializingShardsIt(int seed);1524684173;Returns an iterator over active and initializing shards. Making sure though that_its random within the active shards, and initializing shards are the last to iterate through.;public ShardIterator activeInitializingShardsIt(int seed) {_        if (allInitializingShards.isEmpty()) {_            return new PlainShardIterator(shardId, shuffler.shuffle(activeShards, seed))__        }_        ArrayList<ShardRouting> ordered = new ArrayList<>(activeShards.size() + allInitializingShards.size())__        ordered.addAll(shuffler.shuffle(activeShards, seed))__        ordered.addAll(allInitializingShards)__        return new PlainShardIterator(shardId, ordered)__    };returns,an,iterator,over,active,and,initializing,shards,making,sure,though,that,its,random,within,the,active,shards,and,initializing,shards,are,the,last,to,iterate,through;public,shard,iterator,active,initializing,shards,it,int,seed,if,all,initializing,shards,is,empty,return,new,plain,shard,iterator,shard,id,shuffler,shuffle,active,shards,seed,array,list,shard,routing,ordered,new,array,list,active,shards,size,all,initializing,shards,size,ordered,add,all,shuffler,shuffle,active,shards,seed,ordered,add,all,all,initializing,shards,return,new,plain,shard,iterator,shard,id,ordered
IndexShardRoutingTable -> public ShardIterator activeInitializingShardsIt(int seed);1526467406;Returns an iterator over active and initializing shards. Making sure though that_its random within the active shards, and initializing shards are the last to iterate through.;public ShardIterator activeInitializingShardsIt(int seed) {_        if (allInitializingShards.isEmpty()) {_            return new PlainShardIterator(shardId, shuffler.shuffle(activeShards, seed))__        }_        ArrayList<ShardRouting> ordered = new ArrayList<>(activeShards.size() + allInitializingShards.size())__        ordered.addAll(shuffler.shuffle(activeShards, seed))__        ordered.addAll(allInitializingShards)__        return new PlainShardIterator(shardId, ordered)__    };returns,an,iterator,over,active,and,initializing,shards,making,sure,though,that,its,random,within,the,active,shards,and,initializing,shards,are,the,last,to,iterate,through;public,shard,iterator,active,initializing,shards,it,int,seed,if,all,initializing,shards,is,empty,return,new,plain,shard,iterator,shard,id,shuffler,shuffle,active,shards,seed,array,list,shard,routing,ordered,new,array,list,active,shards,size,all,initializing,shards,size,ordered,add,all,shuffler,shuffle,active,shards,seed,ordered,add,all,all,initializing,shards,return,new,plain,shard,iterator,shard,id,ordered
IndexShardRoutingTable -> public ShardIterator activeInitializingShardsIt(int seed);1528762805;Returns an iterator over active and initializing shards. Making sure though that_its random within the active shards, and initializing shards are the last to iterate through.;public ShardIterator activeInitializingShardsIt(int seed) {_        if (allInitializingShards.isEmpty()) {_            return new PlainShardIterator(shardId, shuffler.shuffle(activeShards, seed))__        }_        ArrayList<ShardRouting> ordered = new ArrayList<>(activeShards.size() + allInitializingShards.size())__        ordered.addAll(shuffler.shuffle(activeShards, seed))__        ordered.addAll(allInitializingShards)__        return new PlainShardIterator(shardId, ordered)__    };returns,an,iterator,over,active,and,initializing,shards,making,sure,though,that,its,random,within,the,active,shards,and,initializing,shards,are,the,last,to,iterate,through;public,shard,iterator,active,initializing,shards,it,int,seed,if,all,initializing,shards,is,empty,return,new,plain,shard,iterator,shard,id,shuffler,shuffle,active,shards,seed,array,list,shard,routing,ordered,new,array,list,active,shards,size,all,initializing,shards,size,ordered,add,all,shuffler,shuffle,active,shards,seed,ordered,add,all,all,initializing,shards,return,new,plain,shard,iterator,shard,id,ordered
IndexShardRoutingTable -> public ShardIterator activeInitializingShardsIt(int seed);1539615817;Returns an iterator over active and initializing shards. Making sure though that_its random within the active shards, and initializing shards are the last to iterate through.;public ShardIterator activeInitializingShardsIt(int seed) {_        if (allInitializingShards.isEmpty()) {_            return new PlainShardIterator(shardId, shuffler.shuffle(activeShards, seed))__        }_        ArrayList<ShardRouting> ordered = new ArrayList<>(activeShards.size() + allInitializingShards.size())__        ordered.addAll(shuffler.shuffle(activeShards, seed))__        ordered.addAll(allInitializingShards)__        return new PlainShardIterator(shardId, ordered)__    };returns,an,iterator,over,active,and,initializing,shards,making,sure,though,that,its,random,within,the,active,shards,and,initializing,shards,are,the,last,to,iterate,through;public,shard,iterator,active,initializing,shards,it,int,seed,if,all,initializing,shards,is,empty,return,new,plain,shard,iterator,shard,id,shuffler,shuffle,active,shards,seed,array,list,shard,routing,ordered,new,array,list,active,shards,size,all,initializing,shards,size,ordered,add,all,shuffler,shuffle,active,shards,seed,ordered,add,all,all,initializing,shards,return,new,plain,shard,iterator,shard,id,ordered
IndexShardRoutingTable -> public ShardIterator activeInitializingShardsIt(int seed);1540847035;Returns an iterator over active and initializing shards. Making sure though that_its random within the active shards, and initializing shards are the last to iterate through.;public ShardIterator activeInitializingShardsIt(int seed) {_        if (allInitializingShards.isEmpty()) {_            return new PlainShardIterator(shardId, shuffler.shuffle(activeShards, seed))__        }_        ArrayList<ShardRouting> ordered = new ArrayList<>(activeShards.size() + allInitializingShards.size())__        ordered.addAll(shuffler.shuffle(activeShards, seed))__        ordered.addAll(allInitializingShards)__        return new PlainShardIterator(shardId, ordered)__    };returns,an,iterator,over,active,and,initializing,shards,making,sure,though,that,its,random,within,the,active,shards,and,initializing,shards,are,the,last,to,iterate,through;public,shard,iterator,active,initializing,shards,it,int,seed,if,all,initializing,shards,is,empty,return,new,plain,shard,iterator,shard,id,shuffler,shuffle,active,shards,seed,array,list,shard,routing,ordered,new,array,list,active,shards,size,all,initializing,shards,size,ordered,add,all,shuffler,shuffle,active,shards,seed,ordered,add,all,all,initializing,shards,return,new,plain,shard,iterator,shard,id,ordered
IndexShardRoutingTable -> public ShardIterator activeInitializingShardsIt(int seed);1541446827;Returns an iterator over active and initializing shards. Making sure though that_its random within the active shards, and initializing shards are the last to iterate through.;public ShardIterator activeInitializingShardsIt(int seed) {_        if (allInitializingShards.isEmpty()) {_            return new PlainShardIterator(shardId, shuffler.shuffle(activeShards, seed))__        }_        ArrayList<ShardRouting> ordered = new ArrayList<>(activeShards.size() + allInitializingShards.size())__        ordered.addAll(shuffler.shuffle(activeShards, seed))__        ordered.addAll(allInitializingShards)__        return new PlainShardIterator(shardId, ordered)__    };returns,an,iterator,over,active,and,initializing,shards,making,sure,though,that,its,random,within,the,active,shards,and,initializing,shards,are,the,last,to,iterate,through;public,shard,iterator,active,initializing,shards,it,int,seed,if,all,initializing,shards,is,empty,return,new,plain,shard,iterator,shard,id,shuffler,shuffle,active,shards,seed,array,list,shard,routing,ordered,new,array,list,active,shards,size,all,initializing,shards,size,ordered,add,all,shuffler,shuffle,active,shards,seed,ordered,add,all,all,initializing,shards,return,new,plain,shard,iterator,shard,id,ordered
IndexShardRoutingTable -> public ShardId shardId();1524684173;Returns the shards id__@return id of the shard;public ShardId shardId() {_        return shardId__    };returns,the,shards,id,return,id,of,the,shard;public,shard,id,shard,id,return,shard,id
IndexShardRoutingTable -> public ShardId shardId();1526467406;Returns the shards id__@return id of the shard;public ShardId shardId() {_        return shardId__    };returns,the,shards,id,return,id,of,the,shard;public,shard,id,shard,id,return,shard,id
IndexShardRoutingTable -> public ShardId shardId();1528762805;Returns the shards id__@return id of the shard;public ShardId shardId() {_        return shardId__    };returns,the,shards,id,return,id,of,the,shard;public,shard,id,shard,id,return,shard,id
IndexShardRoutingTable -> public ShardId shardId();1539615817;Returns the shards id__@return id of the shard;public ShardId shardId() {_        return shardId__    };returns,the,shards,id,return,id,of,the,shard;public,shard,id,shard,id,return,shard,id
IndexShardRoutingTable -> public ShardId shardId();1540847035;Returns the shards id__@return id of the shard;public ShardId shardId() {_        return shardId__    };returns,the,shards,id,return,id,of,the,shard;public,shard,id,shard,id,return,shard,id
IndexShardRoutingTable -> public ShardId shardId();1541446827;Returns the shards id__@return id of the shard;public ShardId shardId() {_        return shardId__    };returns,the,shards,id,return,id,of,the,shard;public,shard,id,shard,id,return,shard,id
IndexShardRoutingTable -> public ShardId getShardId();1524684173;Returns the shards id__@return id of the shard;public ShardId getShardId() {_        return shardId()__    };returns,the,shards,id,return,id,of,the,shard;public,shard,id,get,shard,id,return,shard,id
IndexShardRoutingTable -> public ShardId getShardId();1526467406;Returns the shards id__@return id of the shard;public ShardId getShardId() {_        return shardId()__    };returns,the,shards,id,return,id,of,the,shard;public,shard,id,get,shard,id,return,shard,id
IndexShardRoutingTable -> public ShardId getShardId();1528762805;Returns the shards id__@return id of the shard;public ShardId getShardId() {_        return shardId()__    };returns,the,shards,id,return,id,of,the,shard;public,shard,id,get,shard,id,return,shard,id
IndexShardRoutingTable -> public ShardId getShardId();1539615817;Returns the shards id__@return id of the shard;public ShardId getShardId() {_        return shardId()__    };returns,the,shards,id,return,id,of,the,shard;public,shard,id,get,shard,id,return,shard,id
IndexShardRoutingTable -> public ShardId getShardId();1540847035;Returns the shards id__@return id of the shard;public ShardId getShardId() {_        return shardId()__    };returns,the,shards,id,return,id,of,the,shard;public,shard,id,get,shard,id,return,shard,id
IndexShardRoutingTable -> public ShardId getShardId();1541446827;Returns the shards id__@return id of the shard;public ShardId getShardId() {_        return shardId()__    };returns,the,shards,id,return,id,of,the,shard;public,shard,id,get,shard,id,return,shard,id
IndexShardRoutingTable -> public ShardIterator activeInitializingShardsRankedIt(@Nullable ResponseCollectorService collector,                                                           @Nullable Map<String, Long> nodeSearchCounts);1524684173;Returns an iterator over active and initializing shards, ordered by the adaptive replica_selection forumla. Making sure though that its random within the active shards of the same_(or missing) rank, and initializing shards are the last to iterate through.;public ShardIterator activeInitializingShardsRankedIt(@Nullable ResponseCollectorService collector,_                                                          @Nullable Map<String, Long> nodeSearchCounts) {_        final int seed = shuffler.nextSeed()__        if (allInitializingShards.isEmpty()) {_            return new PlainShardIterator(shardId,_                    rankShardsAndUpdateStats(shuffler.shuffle(activeShards, seed), collector, nodeSearchCounts))__        }__        ArrayList<ShardRouting> ordered = new ArrayList<>(activeShards.size() + allInitializingShards.size())__        List<ShardRouting> rankedActiveShards =_                rankShardsAndUpdateStats(shuffler.shuffle(activeShards, seed), collector, nodeSearchCounts)__        ordered.addAll(rankedActiveShards)__        List<ShardRouting> rankedInitializingShards =_                rankShardsAndUpdateStats(allInitializingShards, collector, nodeSearchCounts)__        ordered.addAll(rankedInitializingShards)__        return new PlainShardIterator(shardId, ordered)__    };returns,an,iterator,over,active,and,initializing,shards,ordered,by,the,adaptive,replica,selection,forumla,making,sure,though,that,its,random,within,the,active,shards,of,the,same,or,missing,rank,and,initializing,shards,are,the,last,to,iterate,through;public,shard,iterator,active,initializing,shards,ranked,it,nullable,response,collector,service,collector,nullable,map,string,long,node,search,counts,final,int,seed,shuffler,next,seed,if,all,initializing,shards,is,empty,return,new,plain,shard,iterator,shard,id,rank,shards,and,update,stats,shuffler,shuffle,active,shards,seed,collector,node,search,counts,array,list,shard,routing,ordered,new,array,list,active,shards,size,all,initializing,shards,size,list,shard,routing,ranked,active,shards,rank,shards,and,update,stats,shuffler,shuffle,active,shards,seed,collector,node,search,counts,ordered,add,all,ranked,active,shards,list,shard,routing,ranked,initializing,shards,rank,shards,and,update,stats,all,initializing,shards,collector,node,search,counts,ordered,add,all,ranked,initializing,shards,return,new,plain,shard,iterator,shard,id,ordered
IndexShardRoutingTable -> public ShardIterator activeInitializingShardsRankedIt(@Nullable ResponseCollectorService collector,                                                           @Nullable Map<String, Long> nodeSearchCounts);1526467406;Returns an iterator over active and initializing shards, ordered by the adaptive replica_selection forumla. Making sure though that its random within the active shards of the same_(or missing) rank, and initializing shards are the last to iterate through.;public ShardIterator activeInitializingShardsRankedIt(@Nullable ResponseCollectorService collector,_                                                          @Nullable Map<String, Long> nodeSearchCounts) {_        final int seed = shuffler.nextSeed()__        if (allInitializingShards.isEmpty()) {_            return new PlainShardIterator(shardId,_                    rankShardsAndUpdateStats(shuffler.shuffle(activeShards, seed), collector, nodeSearchCounts))__        }__        ArrayList<ShardRouting> ordered = new ArrayList<>(activeShards.size() + allInitializingShards.size())__        List<ShardRouting> rankedActiveShards =_                rankShardsAndUpdateStats(shuffler.shuffle(activeShards, seed), collector, nodeSearchCounts)__        ordered.addAll(rankedActiveShards)__        List<ShardRouting> rankedInitializingShards =_                rankShardsAndUpdateStats(allInitializingShards, collector, nodeSearchCounts)__        ordered.addAll(rankedInitializingShards)__        return new PlainShardIterator(shardId, ordered)__    };returns,an,iterator,over,active,and,initializing,shards,ordered,by,the,adaptive,replica,selection,forumla,making,sure,though,that,its,random,within,the,active,shards,of,the,same,or,missing,rank,and,initializing,shards,are,the,last,to,iterate,through;public,shard,iterator,active,initializing,shards,ranked,it,nullable,response,collector,service,collector,nullable,map,string,long,node,search,counts,final,int,seed,shuffler,next,seed,if,all,initializing,shards,is,empty,return,new,plain,shard,iterator,shard,id,rank,shards,and,update,stats,shuffler,shuffle,active,shards,seed,collector,node,search,counts,array,list,shard,routing,ordered,new,array,list,active,shards,size,all,initializing,shards,size,list,shard,routing,ranked,active,shards,rank,shards,and,update,stats,shuffler,shuffle,active,shards,seed,collector,node,search,counts,ordered,add,all,ranked,active,shards,list,shard,routing,ranked,initializing,shards,rank,shards,and,update,stats,all,initializing,shards,collector,node,search,counts,ordered,add,all,ranked,initializing,shards,return,new,plain,shard,iterator,shard,id,ordered
IndexShardRoutingTable -> public ShardIterator activeInitializingShardsRankedIt(@Nullable ResponseCollectorService collector,                                                           @Nullable Map<String, Long> nodeSearchCounts);1528762805;Returns an iterator over active and initializing shards, ordered by the adaptive replica_selection forumla. Making sure though that its random within the active shards of the same_(or missing) rank, and initializing shards are the last to iterate through.;public ShardIterator activeInitializingShardsRankedIt(@Nullable ResponseCollectorService collector,_                                                          @Nullable Map<String, Long> nodeSearchCounts) {_        final int seed = shuffler.nextSeed()__        if (allInitializingShards.isEmpty()) {_            return new PlainShardIterator(shardId,_                    rankShardsAndUpdateStats(shuffler.shuffle(activeShards, seed), collector, nodeSearchCounts))__        }__        ArrayList<ShardRouting> ordered = new ArrayList<>(activeShards.size() + allInitializingShards.size())__        List<ShardRouting> rankedActiveShards =_                rankShardsAndUpdateStats(shuffler.shuffle(activeShards, seed), collector, nodeSearchCounts)__        ordered.addAll(rankedActiveShards)__        List<ShardRouting> rankedInitializingShards =_                rankShardsAndUpdateStats(allInitializingShards, collector, nodeSearchCounts)__        ordered.addAll(rankedInitializingShards)__        return new PlainShardIterator(shardId, ordered)__    };returns,an,iterator,over,active,and,initializing,shards,ordered,by,the,adaptive,replica,selection,forumla,making,sure,though,that,its,random,within,the,active,shards,of,the,same,or,missing,rank,and,initializing,shards,are,the,last,to,iterate,through;public,shard,iterator,active,initializing,shards,ranked,it,nullable,response,collector,service,collector,nullable,map,string,long,node,search,counts,final,int,seed,shuffler,next,seed,if,all,initializing,shards,is,empty,return,new,plain,shard,iterator,shard,id,rank,shards,and,update,stats,shuffler,shuffle,active,shards,seed,collector,node,search,counts,array,list,shard,routing,ordered,new,array,list,active,shards,size,all,initializing,shards,size,list,shard,routing,ranked,active,shards,rank,shards,and,update,stats,shuffler,shuffle,active,shards,seed,collector,node,search,counts,ordered,add,all,ranked,active,shards,list,shard,routing,ranked,initializing,shards,rank,shards,and,update,stats,all,initializing,shards,collector,node,search,counts,ordered,add,all,ranked,initializing,shards,return,new,plain,shard,iterator,shard,id,ordered
IndexShardRoutingTable -> public ShardIterator activeInitializingShardsRankedIt(@Nullable ResponseCollectorService collector,                                                           @Nullable Map<String, Long> nodeSearchCounts);1539615817;Returns an iterator over active and initializing shards, ordered by the adaptive replica_selection formula. Making sure though that its random within the active shards of the same_(or missing) rank, and initializing shards are the last to iterate through.;public ShardIterator activeInitializingShardsRankedIt(@Nullable ResponseCollectorService collector,_                                                          @Nullable Map<String, Long> nodeSearchCounts) {_        final int seed = shuffler.nextSeed()__        if (allInitializingShards.isEmpty()) {_            return new PlainShardIterator(shardId,_                    rankShardsAndUpdateStats(shuffler.shuffle(activeShards, seed), collector, nodeSearchCounts))__        }__        ArrayList<ShardRouting> ordered = new ArrayList<>(activeShards.size() + allInitializingShards.size())__        List<ShardRouting> rankedActiveShards =_                rankShardsAndUpdateStats(shuffler.shuffle(activeShards, seed), collector, nodeSearchCounts)__        ordered.addAll(rankedActiveShards)__        List<ShardRouting> rankedInitializingShards =_                rankShardsAndUpdateStats(allInitializingShards, collector, nodeSearchCounts)__        ordered.addAll(rankedInitializingShards)__        return new PlainShardIterator(shardId, ordered)__    };returns,an,iterator,over,active,and,initializing,shards,ordered,by,the,adaptive,replica,selection,formula,making,sure,though,that,its,random,within,the,active,shards,of,the,same,or,missing,rank,and,initializing,shards,are,the,last,to,iterate,through;public,shard,iterator,active,initializing,shards,ranked,it,nullable,response,collector,service,collector,nullable,map,string,long,node,search,counts,final,int,seed,shuffler,next,seed,if,all,initializing,shards,is,empty,return,new,plain,shard,iterator,shard,id,rank,shards,and,update,stats,shuffler,shuffle,active,shards,seed,collector,node,search,counts,array,list,shard,routing,ordered,new,array,list,active,shards,size,all,initializing,shards,size,list,shard,routing,ranked,active,shards,rank,shards,and,update,stats,shuffler,shuffle,active,shards,seed,collector,node,search,counts,ordered,add,all,ranked,active,shards,list,shard,routing,ranked,initializing,shards,rank,shards,and,update,stats,all,initializing,shards,collector,node,search,counts,ordered,add,all,ranked,initializing,shards,return,new,plain,shard,iterator,shard,id,ordered
IndexShardRoutingTable -> public ShardIterator activeInitializingShardsRankedIt(@Nullable ResponseCollectorService collector,                                                           @Nullable Map<String, Long> nodeSearchCounts);1540847035;Returns an iterator over active and initializing shards, ordered by the adaptive replica_selection formula. Making sure though that its random within the active shards of the same_(or missing) rank, and initializing shards are the last to iterate through.;public ShardIterator activeInitializingShardsRankedIt(@Nullable ResponseCollectorService collector,_                                                          @Nullable Map<String, Long> nodeSearchCounts) {_        final int seed = shuffler.nextSeed()__        if (allInitializingShards.isEmpty()) {_            return new PlainShardIterator(shardId,_                    rankShardsAndUpdateStats(shuffler.shuffle(activeShards, seed), collector, nodeSearchCounts))__        }__        ArrayList<ShardRouting> ordered = new ArrayList<>(activeShards.size() + allInitializingShards.size())__        List<ShardRouting> rankedActiveShards =_                rankShardsAndUpdateStats(shuffler.shuffle(activeShards, seed), collector, nodeSearchCounts)__        ordered.addAll(rankedActiveShards)__        List<ShardRouting> rankedInitializingShards =_                rankShardsAndUpdateStats(allInitializingShards, collector, nodeSearchCounts)__        ordered.addAll(rankedInitializingShards)__        return new PlainShardIterator(shardId, ordered)__    };returns,an,iterator,over,active,and,initializing,shards,ordered,by,the,adaptive,replica,selection,formula,making,sure,though,that,its,random,within,the,active,shards,of,the,same,or,missing,rank,and,initializing,shards,are,the,last,to,iterate,through;public,shard,iterator,active,initializing,shards,ranked,it,nullable,response,collector,service,collector,nullable,map,string,long,node,search,counts,final,int,seed,shuffler,next,seed,if,all,initializing,shards,is,empty,return,new,plain,shard,iterator,shard,id,rank,shards,and,update,stats,shuffler,shuffle,active,shards,seed,collector,node,search,counts,array,list,shard,routing,ordered,new,array,list,active,shards,size,all,initializing,shards,size,list,shard,routing,ranked,active,shards,rank,shards,and,update,stats,shuffler,shuffle,active,shards,seed,collector,node,search,counts,ordered,add,all,ranked,active,shards,list,shard,routing,ranked,initializing,shards,rank,shards,and,update,stats,all,initializing,shards,collector,node,search,counts,ordered,add,all,ranked,initializing,shards,return,new,plain,shard,iterator,shard,id,ordered
IndexShardRoutingTable -> public ShardIterator activeInitializingShardsRankedIt(@Nullable ResponseCollectorService collector,                                                           @Nullable Map<String, Long> nodeSearchCounts);1541446827;Returns an iterator over active and initializing shards, ordered by the adaptive replica_selection formula. Making sure though that its random within the active shards of the same_(or missing) rank, and initializing shards are the last to iterate through.;public ShardIterator activeInitializingShardsRankedIt(@Nullable ResponseCollectorService collector,_                                                          @Nullable Map<String, Long> nodeSearchCounts) {_        final int seed = shuffler.nextSeed()__        if (allInitializingShards.isEmpty()) {_            return new PlainShardIterator(shardId,_                    rankShardsAndUpdateStats(shuffler.shuffle(activeShards, seed), collector, nodeSearchCounts))__        }__        ArrayList<ShardRouting> ordered = new ArrayList<>(activeShards.size() + allInitializingShards.size())__        List<ShardRouting> rankedActiveShards =_                rankShardsAndUpdateStats(shuffler.shuffle(activeShards, seed), collector, nodeSearchCounts)__        ordered.addAll(rankedActiveShards)__        List<ShardRouting> rankedInitializingShards =_                rankShardsAndUpdateStats(allInitializingShards, collector, nodeSearchCounts)__        ordered.addAll(rankedInitializingShards)__        return new PlainShardIterator(shardId, ordered)__    };returns,an,iterator,over,active,and,initializing,shards,ordered,by,the,adaptive,replica,selection,formula,making,sure,though,that,its,random,within,the,active,shards,of,the,same,or,missing,rank,and,initializing,shards,are,the,last,to,iterate,through;public,shard,iterator,active,initializing,shards,ranked,it,nullable,response,collector,service,collector,nullable,map,string,long,node,search,counts,final,int,seed,shuffler,next,seed,if,all,initializing,shards,is,empty,return,new,plain,shard,iterator,shard,id,rank,shards,and,update,stats,shuffler,shuffle,active,shards,seed,collector,node,search,counts,array,list,shard,routing,ordered,new,array,list,active,shards,size,all,initializing,shards,size,list,shard,routing,ranked,active,shards,rank,shards,and,update,stats,shuffler,shuffle,active,shards,seed,collector,node,search,counts,ordered,add,all,ranked,active,shards,list,shard,routing,ranked,initializing,shards,rank,shards,and,update,stats,all,initializing,shards,collector,node,search,counts,ordered,add,all,ranked,initializing,shards,return,new,plain,shard,iterator,shard,id,ordered
IndexShardRoutingTable -> public ShardIterator onlyNodeSelectorActiveInitializingShardsIt(String[] nodeAttributes, DiscoveryNodes discoveryNodes);1524684173;Returns shards based on nodeAttributes given  such as node name , node attribute, node IP_Supports node specifications in cluster API;public ShardIterator onlyNodeSelectorActiveInitializingShardsIt(String[] nodeAttributes, DiscoveryNodes discoveryNodes) {_        ArrayList<ShardRouting> ordered = new ArrayList<>(activeShards.size() + allInitializingShards.size())__        Set<String> selectedNodes = Sets.newHashSet(discoveryNodes.resolveNodes(nodeAttributes))__        int seed = shuffler.nextSeed()__        for (ShardRouting shardRouting : shuffler.shuffle(activeShards, seed)) {_            if (selectedNodes.contains(shardRouting.currentNodeId())) {_                ordered.add(shardRouting)__            }_        }_        for (ShardRouting shardRouting : shuffler.shuffle(allInitializingShards, seed)) {_            if (selectedNodes.contains(shardRouting.currentNodeId())) {_                ordered.add(shardRouting)__            }_        }_        if (ordered.isEmpty()) {_            final String message = String.format(_                    Locale.ROOT,_                    "no data nodes with %s [%s] found for shard: %s",_                    nodeAttributes.length == 1 ? "criteria" : "criterion",_                    String.join(",", nodeAttributes),_                    shardId())__            throw new IllegalArgumentException(message)__        }_        return new PlainShardIterator(shardId, ordered)__    };returns,shards,based,on,node,attributes,given,such,as,node,name,node,attribute,node,ip,supports,node,specifications,in,cluster,api;public,shard,iterator,only,node,selector,active,initializing,shards,it,string,node,attributes,discovery,nodes,discovery,nodes,array,list,shard,routing,ordered,new,array,list,active,shards,size,all,initializing,shards,size,set,string,selected,nodes,sets,new,hash,set,discovery,nodes,resolve,nodes,node,attributes,int,seed,shuffler,next,seed,for,shard,routing,shard,routing,shuffler,shuffle,active,shards,seed,if,selected,nodes,contains,shard,routing,current,node,id,ordered,add,shard,routing,for,shard,routing,shard,routing,shuffler,shuffle,all,initializing,shards,seed,if,selected,nodes,contains,shard,routing,current,node,id,ordered,add,shard,routing,if,ordered,is,empty,final,string,message,string,format,locale,root,no,data,nodes,with,s,s,found,for,shard,s,node,attributes,length,1,criteria,criterion,string,join,node,attributes,shard,id,throw,new,illegal,argument,exception,message,return,new,plain,shard,iterator,shard,id,ordered
IndexShardRoutingTable -> public ShardIterator onlyNodeSelectorActiveInitializingShardsIt(String[] nodeAttributes, DiscoveryNodes discoveryNodes);1526467406;Returns shards based on nodeAttributes given  such as node name , node attribute, node IP_Supports node specifications in cluster API;public ShardIterator onlyNodeSelectorActiveInitializingShardsIt(String[] nodeAttributes, DiscoveryNodes discoveryNodes) {_        ArrayList<ShardRouting> ordered = new ArrayList<>(activeShards.size() + allInitializingShards.size())__        Set<String> selectedNodes = Sets.newHashSet(discoveryNodes.resolveNodes(nodeAttributes))__        int seed = shuffler.nextSeed()__        for (ShardRouting shardRouting : shuffler.shuffle(activeShards, seed)) {_            if (selectedNodes.contains(shardRouting.currentNodeId())) {_                ordered.add(shardRouting)__            }_        }_        for (ShardRouting shardRouting : shuffler.shuffle(allInitializingShards, seed)) {_            if (selectedNodes.contains(shardRouting.currentNodeId())) {_                ordered.add(shardRouting)__            }_        }_        if (ordered.isEmpty()) {_            final String message = String.format(_                    Locale.ROOT,_                    "no data nodes with %s [%s] found for shard: %s",_                    nodeAttributes.length == 1 ? "criteria" : "criterion",_                    String.join(",", nodeAttributes),_                    shardId())__            throw new IllegalArgumentException(message)__        }_        return new PlainShardIterator(shardId, ordered)__    };returns,shards,based,on,node,attributes,given,such,as,node,name,node,attribute,node,ip,supports,node,specifications,in,cluster,api;public,shard,iterator,only,node,selector,active,initializing,shards,it,string,node,attributes,discovery,nodes,discovery,nodes,array,list,shard,routing,ordered,new,array,list,active,shards,size,all,initializing,shards,size,set,string,selected,nodes,sets,new,hash,set,discovery,nodes,resolve,nodes,node,attributes,int,seed,shuffler,next,seed,for,shard,routing,shard,routing,shuffler,shuffle,active,shards,seed,if,selected,nodes,contains,shard,routing,current,node,id,ordered,add,shard,routing,for,shard,routing,shard,routing,shuffler,shuffle,all,initializing,shards,seed,if,selected,nodes,contains,shard,routing,current,node,id,ordered,add,shard,routing,if,ordered,is,empty,final,string,message,string,format,locale,root,no,data,nodes,with,s,s,found,for,shard,s,node,attributes,length,1,criteria,criterion,string,join,node,attributes,shard,id,throw,new,illegal,argument,exception,message,return,new,plain,shard,iterator,shard,id,ordered
IndexShardRoutingTable -> public ShardIterator onlyNodeSelectorActiveInitializingShardsIt(String[] nodeAttributes, DiscoveryNodes discoveryNodes);1528762805;Returns shards based on nodeAttributes given  such as node name , node attribute, node IP_Supports node specifications in cluster API;public ShardIterator onlyNodeSelectorActiveInitializingShardsIt(String[] nodeAttributes, DiscoveryNodes discoveryNodes) {_        ArrayList<ShardRouting> ordered = new ArrayList<>(activeShards.size() + allInitializingShards.size())__        Set<String> selectedNodes = Sets.newHashSet(discoveryNodes.resolveNodes(nodeAttributes))__        int seed = shuffler.nextSeed()__        for (ShardRouting shardRouting : shuffler.shuffle(activeShards, seed)) {_            if (selectedNodes.contains(shardRouting.currentNodeId())) {_                ordered.add(shardRouting)__            }_        }_        for (ShardRouting shardRouting : shuffler.shuffle(allInitializingShards, seed)) {_            if (selectedNodes.contains(shardRouting.currentNodeId())) {_                ordered.add(shardRouting)__            }_        }_        if (ordered.isEmpty()) {_            final String message = String.format(_                    Locale.ROOT,_                    "no data nodes with %s [%s] found for shard: %s",_                    nodeAttributes.length == 1 ? "criteria" : "criterion",_                    String.join(",", nodeAttributes),_                    shardId())__            throw new IllegalArgumentException(message)__        }_        return new PlainShardIterator(shardId, ordered)__    };returns,shards,based,on,node,attributes,given,such,as,node,name,node,attribute,node,ip,supports,node,specifications,in,cluster,api;public,shard,iterator,only,node,selector,active,initializing,shards,it,string,node,attributes,discovery,nodes,discovery,nodes,array,list,shard,routing,ordered,new,array,list,active,shards,size,all,initializing,shards,size,set,string,selected,nodes,sets,new,hash,set,discovery,nodes,resolve,nodes,node,attributes,int,seed,shuffler,next,seed,for,shard,routing,shard,routing,shuffler,shuffle,active,shards,seed,if,selected,nodes,contains,shard,routing,current,node,id,ordered,add,shard,routing,for,shard,routing,shard,routing,shuffler,shuffle,all,initializing,shards,seed,if,selected,nodes,contains,shard,routing,current,node,id,ordered,add,shard,routing,if,ordered,is,empty,final,string,message,string,format,locale,root,no,data,nodes,with,s,s,found,for,shard,s,node,attributes,length,1,criteria,criterion,string,join,node,attributes,shard,id,throw,new,illegal,argument,exception,message,return,new,plain,shard,iterator,shard,id,ordered
IndexShardRoutingTable -> public ShardIterator onlyNodeSelectorActiveInitializingShardsIt(String[] nodeAttributes, DiscoveryNodes discoveryNodes);1539615817;Returns shards based on nodeAttributes given  such as node name , node attribute, node IP_Supports node specifications in cluster API;public ShardIterator onlyNodeSelectorActiveInitializingShardsIt(String[] nodeAttributes, DiscoveryNodes discoveryNodes) {_        ArrayList<ShardRouting> ordered = new ArrayList<>(activeShards.size() + allInitializingShards.size())__        Set<String> selectedNodes = Sets.newHashSet(discoveryNodes.resolveNodes(nodeAttributes))__        int seed = shuffler.nextSeed()__        for (ShardRouting shardRouting : shuffler.shuffle(activeShards, seed)) {_            if (selectedNodes.contains(shardRouting.currentNodeId())) {_                ordered.add(shardRouting)__            }_        }_        for (ShardRouting shardRouting : shuffler.shuffle(allInitializingShards, seed)) {_            if (selectedNodes.contains(shardRouting.currentNodeId())) {_                ordered.add(shardRouting)__            }_        }_        if (ordered.isEmpty()) {_            final String message = String.format(_                    Locale.ROOT,_                    "no data nodes with %s [%s] found for shard: %s",_                    nodeAttributes.length == 1 ? "criteria" : "criterion",_                    String.join(",", nodeAttributes),_                    shardId())__            throw new IllegalArgumentException(message)__        }_        return new PlainShardIterator(shardId, ordered)__    };returns,shards,based,on,node,attributes,given,such,as,node,name,node,attribute,node,ip,supports,node,specifications,in,cluster,api;public,shard,iterator,only,node,selector,active,initializing,shards,it,string,node,attributes,discovery,nodes,discovery,nodes,array,list,shard,routing,ordered,new,array,list,active,shards,size,all,initializing,shards,size,set,string,selected,nodes,sets,new,hash,set,discovery,nodes,resolve,nodes,node,attributes,int,seed,shuffler,next,seed,for,shard,routing,shard,routing,shuffler,shuffle,active,shards,seed,if,selected,nodes,contains,shard,routing,current,node,id,ordered,add,shard,routing,for,shard,routing,shard,routing,shuffler,shuffle,all,initializing,shards,seed,if,selected,nodes,contains,shard,routing,current,node,id,ordered,add,shard,routing,if,ordered,is,empty,final,string,message,string,format,locale,root,no,data,nodes,with,s,s,found,for,shard,s,node,attributes,length,1,criteria,criterion,string,join,node,attributes,shard,id,throw,new,illegal,argument,exception,message,return,new,plain,shard,iterator,shard,id,ordered
IndexShardRoutingTable -> public ShardIterator onlyNodeSelectorActiveInitializingShardsIt(String[] nodeAttributes, DiscoveryNodes discoveryNodes);1540847035;Returns shards based on nodeAttributes given  such as node name , node attribute, node IP_Supports node specifications in cluster API;public ShardIterator onlyNodeSelectorActiveInitializingShardsIt(String[] nodeAttributes, DiscoveryNodes discoveryNodes) {_        ArrayList<ShardRouting> ordered = new ArrayList<>(activeShards.size() + allInitializingShards.size())__        Set<String> selectedNodes = Sets.newHashSet(discoveryNodes.resolveNodes(nodeAttributes))__        int seed = shuffler.nextSeed()__        for (ShardRouting shardRouting : shuffler.shuffle(activeShards, seed)) {_            if (selectedNodes.contains(shardRouting.currentNodeId())) {_                ordered.add(shardRouting)__            }_        }_        for (ShardRouting shardRouting : shuffler.shuffle(allInitializingShards, seed)) {_            if (selectedNodes.contains(shardRouting.currentNodeId())) {_                ordered.add(shardRouting)__            }_        }_        if (ordered.isEmpty()) {_            final String message = String.format(_                    Locale.ROOT,_                    "no data nodes with %s [%s] found for shard: %s",_                    nodeAttributes.length == 1 ? "criteria" : "criterion",_                    String.join(",", nodeAttributes),_                    shardId())__            throw new IllegalArgumentException(message)__        }_        return new PlainShardIterator(shardId, ordered)__    };returns,shards,based,on,node,attributes,given,such,as,node,name,node,attribute,node,ip,supports,node,specifications,in,cluster,api;public,shard,iterator,only,node,selector,active,initializing,shards,it,string,node,attributes,discovery,nodes,discovery,nodes,array,list,shard,routing,ordered,new,array,list,active,shards,size,all,initializing,shards,size,set,string,selected,nodes,sets,new,hash,set,discovery,nodes,resolve,nodes,node,attributes,int,seed,shuffler,next,seed,for,shard,routing,shard,routing,shuffler,shuffle,active,shards,seed,if,selected,nodes,contains,shard,routing,current,node,id,ordered,add,shard,routing,for,shard,routing,shard,routing,shuffler,shuffle,all,initializing,shards,seed,if,selected,nodes,contains,shard,routing,current,node,id,ordered,add,shard,routing,if,ordered,is,empty,final,string,message,string,format,locale,root,no,data,nodes,with,s,s,found,for,shard,s,node,attributes,length,1,criteria,criterion,string,join,node,attributes,shard,id,throw,new,illegal,argument,exception,message,return,new,plain,shard,iterator,shard,id,ordered
IndexShardRoutingTable -> public ShardIterator onlyNodeSelectorActiveInitializingShardsIt(String[] nodeAttributes, DiscoveryNodes discoveryNodes);1541446827;Returns shards based on nodeAttributes given  such as node name , node attribute, node IP_Supports node specifications in cluster API;public ShardIterator onlyNodeSelectorActiveInitializingShardsIt(String[] nodeAttributes, DiscoveryNodes discoveryNodes) {_        ArrayList<ShardRouting> ordered = new ArrayList<>(activeShards.size() + allInitializingShards.size())__        Set<String> selectedNodes = Sets.newHashSet(discoveryNodes.resolveNodes(nodeAttributes))__        int seed = shuffler.nextSeed()__        for (ShardRouting shardRouting : shuffler.shuffle(activeShards, seed)) {_            if (selectedNodes.contains(shardRouting.currentNodeId())) {_                ordered.add(shardRouting)__            }_        }_        for (ShardRouting shardRouting : shuffler.shuffle(allInitializingShards, seed)) {_            if (selectedNodes.contains(shardRouting.currentNodeId())) {_                ordered.add(shardRouting)__            }_        }_        if (ordered.isEmpty()) {_            final String message = String.format(_                    Locale.ROOT,_                    "no data nodes with %s [%s] found for shard: %s",_                    nodeAttributes.length == 1 ? "criteria" : "criterion",_                    String.join(",", nodeAttributes),_                    shardId())__            throw new IllegalArgumentException(message)__        }_        return new PlainShardIterator(shardId, ordered)__    };returns,shards,based,on,node,attributes,given,such,as,node,name,node,attribute,node,ip,supports,node,specifications,in,cluster,api;public,shard,iterator,only,node,selector,active,initializing,shards,it,string,node,attributes,discovery,nodes,discovery,nodes,array,list,shard,routing,ordered,new,array,list,active,shards,size,all,initializing,shards,size,set,string,selected,nodes,sets,new,hash,set,discovery,nodes,resolve,nodes,node,attributes,int,seed,shuffler,next,seed,for,shard,routing,shard,routing,shuffler,shuffle,active,shards,seed,if,selected,nodes,contains,shard,routing,current,node,id,ordered,add,shard,routing,for,shard,routing,shard,routing,shuffler,shuffle,all,initializing,shards,seed,if,selected,nodes,contains,shard,routing,current,node,id,ordered,add,shard,routing,if,ordered,is,empty,final,string,message,string,format,locale,root,no,data,nodes,with,s,s,found,for,shard,s,node,attributes,length,1,criteria,criterion,string,join,node,attributes,shard,id,throw,new,illegal,argument,exception,message,return,new,plain,shard,iterator,shard,id,ordered
IndexShardRoutingTable -> public List<ShardRouting> getActiveShards();1524684173;Returns a {@link List} of active shards__@return a {@link List} of shards;public List<ShardRouting> getActiveShards() {_        return activeShards()__    };returns,a,link,list,of,active,shards,return,a,link,list,of,shards;public,list,shard,routing,get,active,shards,return,active,shards
IndexShardRoutingTable -> public List<ShardRouting> getActiveShards();1526467406;Returns a {@link List} of active shards__@return a {@link List} of shards;public List<ShardRouting> getActiveShards() {_        return activeShards()__    };returns,a,link,list,of,active,shards,return,a,link,list,of,shards;public,list,shard,routing,get,active,shards,return,active,shards
IndexShardRoutingTable -> public List<ShardRouting> getActiveShards();1528762805;Returns a {@link List} of active shards__@return a {@link List} of shards;public List<ShardRouting> getActiveShards() {_        return activeShards()__    };returns,a,link,list,of,active,shards,return,a,link,list,of,shards;public,list,shard,routing,get,active,shards,return,active,shards
IndexShardRoutingTable -> public List<ShardRouting> getActiveShards();1539615817;Returns a {@link List} of active shards__@return a {@link List} of shards;public List<ShardRouting> getActiveShards() {_        return activeShards()__    };returns,a,link,list,of,active,shards,return,a,link,list,of,shards;public,list,shard,routing,get,active,shards,return,active,shards
IndexShardRoutingTable -> public List<ShardRouting> getActiveShards();1540847035;Returns a {@link List} of active shards__@return a {@link List} of shards;public List<ShardRouting> getActiveShards() {_        return activeShards()__    };returns,a,link,list,of,active,shards,return,a,link,list,of,shards;public,list,shard,routing,get,active,shards,return,active,shards
IndexShardRoutingTable -> public List<ShardRouting> getActiveShards();1541446827;Returns a {@link List} of active shards__@return a {@link List} of shards;public List<ShardRouting> getActiveShards() {_        return activeShards()__    };returns,a,link,list,of,active,shards,return,a,link,list,of,shards;public,list,shard,routing,get,active,shards,return,active,shards
IndexShardRoutingTable -> public ShardIterator activeInitializingShardsRandomIt();1524684173;Returns an iterator over active and initializing shards. Making sure though that_its random within the active shards, and initializing shards are the last to iterate through.;public ShardIterator activeInitializingShardsRandomIt() {_        return activeInitializingShardsIt(shuffler.nextSeed())__    };returns,an,iterator,over,active,and,initializing,shards,making,sure,though,that,its,random,within,the,active,shards,and,initializing,shards,are,the,last,to,iterate,through;public,shard,iterator,active,initializing,shards,random,it,return,active,initializing,shards,it,shuffler,next,seed
IndexShardRoutingTable -> public ShardIterator activeInitializingShardsRandomIt();1526467406;Returns an iterator over active and initializing shards. Making sure though that_its random within the active shards, and initializing shards are the last to iterate through.;public ShardIterator activeInitializingShardsRandomIt() {_        return activeInitializingShardsIt(shuffler.nextSeed())__    };returns,an,iterator,over,active,and,initializing,shards,making,sure,though,that,its,random,within,the,active,shards,and,initializing,shards,are,the,last,to,iterate,through;public,shard,iterator,active,initializing,shards,random,it,return,active,initializing,shards,it,shuffler,next,seed
IndexShardRoutingTable -> public ShardIterator activeInitializingShardsRandomIt();1528762805;Returns an iterator over active and initializing shards. Making sure though that_its random within the active shards, and initializing shards are the last to iterate through.;public ShardIterator activeInitializingShardsRandomIt() {_        return activeInitializingShardsIt(shuffler.nextSeed())__    };returns,an,iterator,over,active,and,initializing,shards,making,sure,though,that,its,random,within,the,active,shards,and,initializing,shards,are,the,last,to,iterate,through;public,shard,iterator,active,initializing,shards,random,it,return,active,initializing,shards,it,shuffler,next,seed
IndexShardRoutingTable -> public ShardIterator activeInitializingShardsRandomIt();1539615817;Returns an iterator over active and initializing shards. Making sure though that_its random within the active shards, and initializing shards are the last to iterate through.;public ShardIterator activeInitializingShardsRandomIt() {_        return activeInitializingShardsIt(shuffler.nextSeed())__    };returns,an,iterator,over,active,and,initializing,shards,making,sure,though,that,its,random,within,the,active,shards,and,initializing,shards,are,the,last,to,iterate,through;public,shard,iterator,active,initializing,shards,random,it,return,active,initializing,shards,it,shuffler,next,seed
IndexShardRoutingTable -> public ShardIterator activeInitializingShardsRandomIt();1540847035;Returns an iterator over active and initializing shards. Making sure though that_its random within the active shards, and initializing shards are the last to iterate through.;public ShardIterator activeInitializingShardsRandomIt() {_        return activeInitializingShardsIt(shuffler.nextSeed())__    };returns,an,iterator,over,active,and,initializing,shards,making,sure,though,that,its,random,within,the,active,shards,and,initializing,shards,are,the,last,to,iterate,through;public,shard,iterator,active,initializing,shards,random,it,return,active,initializing,shards,it,shuffler,next,seed
IndexShardRoutingTable -> public ShardIterator activeInitializingShardsRandomIt();1541446827;Returns an iterator over active and initializing shards. Making sure though that_its random within the active shards, and initializing shards are the last to iterate through.;public ShardIterator activeInitializingShardsRandomIt() {_        return activeInitializingShardsIt(shuffler.nextSeed())__    };returns,an,iterator,over,active,and,initializing,shards,making,sure,though,that,its,random,within,the,active,shards,and,initializing,shards,are,the,last,to,iterate,through;public,shard,iterator,active,initializing,shards,random,it,return,active,initializing,shards,it,shuffler,next,seed
IndexShardRoutingTable -> public boolean allShardsStarted();1524684173;Returns <code>true</code> iff all shards in the routing table are started otherwise <code>false</code>;public boolean allShardsStarted() {_        return allShardsStarted__    };returns,code,true,code,iff,all,shards,in,the,routing,table,are,started,otherwise,code,false,code;public,boolean,all,shards,started,return,all,shards,started
IndexShardRoutingTable -> public boolean allShardsStarted();1526467406;Returns <code>true</code> iff all shards in the routing table are started otherwise <code>false</code>;public boolean allShardsStarted() {_        return allShardsStarted__    };returns,code,true,code,iff,all,shards,in,the,routing,table,are,started,otherwise,code,false,code;public,boolean,all,shards,started,return,all,shards,started
IndexShardRoutingTable -> public boolean allShardsStarted();1528762805;Returns <code>true</code> iff all shards in the routing table are started otherwise <code>false</code>;public boolean allShardsStarted() {_        return allShardsStarted__    };returns,code,true,code,iff,all,shards,in,the,routing,table,are,started,otherwise,code,false,code;public,boolean,all,shards,started,return,all,shards,started
IndexShardRoutingTable -> public boolean allShardsStarted();1539615817;Returns <code>true</code> iff all shards in the routing table are started otherwise <code>false</code>;public boolean allShardsStarted() {_        return allShardsStarted__    };returns,code,true,code,iff,all,shards,in,the,routing,table,are,started,otherwise,code,false,code;public,boolean,all,shards,started,return,all,shards,started
IndexShardRoutingTable -> public boolean allShardsStarted();1540847035;Returns <code>true</code> iff all shards in the routing table are started otherwise <code>false</code>;public boolean allShardsStarted() {_        return allShardsStarted__    };returns,code,true,code,iff,all,shards,in,the,routing,table,are,started,otherwise,code,false,code;public,boolean,all,shards,started,return,all,shards,started
IndexShardRoutingTable -> public boolean allShardsStarted();1541446827;Returns <code>true</code> iff all shards in the routing table are started otherwise <code>false</code>;public boolean allShardsStarted() {_        return allShardsStarted__    };returns,code,true,code,iff,all,shards,in,the,routing,table,are,started,otherwise,code,false,code;public,boolean,all,shards,started,return,all,shards,started
