commented;modifiers;parameterAmount;loc;comment;code
false;public;1;3;;public void addListener(TransportConnectionListener listener) {     this.connectionListener.listeners.addIfAbsent(listener). }
false;public;1;3;;public void removeListener(TransportConnectionListener listener) {     this.connectionListener.listeners.remove(listener). }
false;public;2;4;;public Transport.Connection openConnection(DiscoveryNode node, ConnectionProfile connectionProfile) {     ConnectionProfile resolvedProfile = ConnectionProfile.resolveConnectionProfile(connectionProfile, defaultProfile).     return internalOpenConnection(node, resolvedProfile). }
true;public;3;52;/**  * Connects to a node with the given connection profile. If the node is already connected this method has no effect.  * Once a successful is established, it can be validated before being exposed.  */ ;/**  * Connects to a node with the given connection profile. If the node is already connected this method has no effect.  * Once a successful is established, it can be validated before being exposed.  */ public void connectToNode(DiscoveryNode node, ConnectionProfile connectionProfile, CheckedBiConsumer<Transport.Connection, ConnectionProfile, IOException> connectionValidator) throws ConnectTransportException {     ConnectionProfile resolvedProfile = ConnectionProfile.resolveConnectionProfile(connectionProfile, defaultProfile).     if (node == null) {         throw new ConnectTransportException(null, "can't connect to a null node").     }     // ensure we don't open connections while we are closing     closeLock.readLock().lock().     try {         ensureOpen().         try (Releasable ignored = connectionLock.acquire(node.getId())) {             Transport.Connection connection = connectedNodes.get(node).             if (connection != null) {                 return.             }             boolean success = false.             try {                 connection = internalOpenConnection(node, resolvedProfile).                 connectionValidator.accept(connection, resolvedProfile).                 // we acquire a connection lock, so no way there is an existing connection                 connectedNodes.put(node, connection).                 if (logger.isDebugEnabled()) {                     logger.debug("connected to node [{}]", node).                 }                 try {                     connectionListener.onNodeConnected(node).                 } finally {                     final Transport.Connection finalConnection = connection.                     connection.addCloseListener(ActionListener.wrap(() -> {                         connectedNodes.remove(node, finalConnection).                         connectionListener.onNodeDisconnected(node).                     })).                 }                 if (connection.isClosed()) {                     throw new NodeNotConnectedException(node, "connection concurrently closed").                 }                 success = true.             } catch (ConnectTransportException e) {                 throw e.             } catch (Exception e) {                 throw new ConnectTransportException(node, "general node connection failure", e).             } finally {                 if (success == false) {                     // close the connection if there is a failure                     logger.trace(() -> new ParameterizedMessage("failed to connect to [{}], cleaning dangling connections", node)).                     IOUtils.closeWhileHandlingException(connection).                 }             }         }     } finally {         closeLock.readLock().unlock().     } }
true;public;1;7;/**  * Returns a connection for the given node if the node is connected.  * Connections returned from this method must not be closed. The lifecycle of this connection is  * maintained by this connection manager  *  * @throws NodeNotConnectedException if the node is not connected  * @see #connectToNode(DiscoveryNode, ConnectionProfile, CheckedBiConsumer)  */ ;/**  * Returns a connection for the given node if the node is connected.  * Connections returned from this method must not be closed. The lifecycle of this connection is  * maintained by this connection manager  *  * @throws NodeNotConnectedException if the node is not connected  * @see #connectToNode(DiscoveryNode, ConnectionProfile, CheckedBiConsumer)  */ public Transport.Connection getConnection(DiscoveryNode node) {     Transport.Connection connection = connectedNodes.get(node).     if (connection == null) {         throw new NodeNotConnectedException(node, "Node not connected").     }     return connection. }
true;public;1;3;/**  * Returns {@code true} if the node is connected.  */ ;/**  * Returns {@code true} if the node is connected.  */ public boolean nodeConnected(DiscoveryNode node) {     return connectedNodes.containsKey(node). }
true;public;1;7;/**  * Disconnected from the given node, if not connected, will do nothing.  */ ;/**  * Disconnected from the given node, if not connected, will do nothing.  */ public void disconnectFromNode(DiscoveryNode node) {     Transport.Connection nodeChannels = connectedNodes.remove(node).     if (nodeChannels != null) {         // if we found it and removed it we close         nodeChannels.close().     } }
true;public;0;3;/**  * Returns the number of nodes this manager is connected to.  */ ;/**  * Returns the number of nodes this manager is connected to.  */ public int size() {     return connectedNodes.size(). }
false;public;0;22;;@Override public void close() {     Transports.assertNotTransportThread("Closing ConnectionManager").     if (isClosed.compareAndSet(false, true)) {         closeLock.writeLock().lock().         try {             // we are holding a write lock so nobody adds to the connectedNodes / openConnections map - it's safe to first close             // all instances and then clear them maps             Iterator<Map.Entry<DiscoveryNode, Transport.Connection>> iterator = connectedNodes.entrySet().iterator().             while (iterator.hasNext()) {                 Map.Entry<DiscoveryNode, Transport.Connection> next = iterator.next().                 try {                     IOUtils.closeWhileHandlingException(next.getValue()).                 } finally {                     iterator.remove().                 }             }         } finally {             closeLock.writeLock().unlock().         }     } }
false;private;2;23;;private Transport.Connection internalOpenConnection(DiscoveryNode node, ConnectionProfile connectionProfile) {     PlainActionFuture<Transport.Connection> future = PlainActionFuture.newFuture().     Releasable pendingConnection = transport.openConnection(node, connectionProfile, future).     Transport.Connection connection.     try {         connection = future.actionGet().     } catch (IllegalStateException e) {         // If the future was interrupted we must cancel the pending connection to avoid channels leaking         if (e.getCause() instanceof InterruptedException) {             pendingConnection.close().         }         throw e.     }     try {         connectionListener.onConnectionOpened(connection).     } finally {         connection.addCloseListener(ActionListener.wrap(() -> connectionListener.onConnectionClosed(connection))).     }     if (connection.isClosed()) {         throw new ConnectTransportException(node, "a channel closed while connecting").     }     return connection. }
false;private;0;5;;private void ensureOpen() {     if (isClosed.get()) {         throw new IllegalStateException("connection manager is closed").     } }
false;;0;3;;ConnectionProfile getConnectionProfile() {     return defaultProfile. }
false;public;1;6;;@Override public void onNodeDisconnected(DiscoveryNode key) {     for (TransportConnectionListener listener : listeners) {         listener.onNodeDisconnected(key).     } }
false;public;1;6;;@Override public void onNodeConnected(DiscoveryNode node) {     for (TransportConnectionListener listener : listeners) {         listener.onNodeConnected(node).     } }
false;public;1;6;;@Override public void onConnectionOpened(Transport.Connection connection) {     for (TransportConnectionListener listener : listeners) {         listener.onConnectionOpened(connection).     } }
false;public;1;6;;@Override public void onConnectionClosed(Transport.Connection connection) {     for (TransportConnectionListener listener : listeners) {         listener.onConnectionClosed(connection).     } }
