commented;modifiers;parameterAmount;loc;comment;code
false;public;1;6;;@Override public void doWriteTo(StreamOutput out) throws IOException {     out.writeNamedWriteable(formatter).     gapPolicy.writeTo(out).     out.writeVInt(lag). }
false;public;0;4;;@Override public String getWriteableName() {     return SerialDiffPipelineAggregationBuilder.NAME. }
false;public;2;46;;@Override public InternalAggregation reduce(InternalAggregation aggregation, ReduceContext reduceContext) {     InternalMultiBucketAggregation<? extends InternalMultiBucketAggregation, ? extends InternalMultiBucketAggregation.InternalBucket> histo = (InternalMultiBucketAggregation<? extends InternalMultiBucketAggregation, ? extends InternalMultiBucketAggregation.InternalBucket>) aggregation.     List<? extends InternalMultiBucketAggregation.InternalBucket> buckets = histo.getBuckets().     HistogramFactory factory = (HistogramFactory) histo.     List<Bucket> newBuckets = new ArrayList<>().     EvictingQueue<Double> lagWindow = new EvictingQueue<>(lag).     int counter = 0.     for (InternalMultiBucketAggregation.InternalBucket bucket : buckets) {         Double thisBucketValue = resolveBucketValue(histo, bucket, bucketsPaths()[0], gapPolicy).         Bucket newBucket = bucket.         counter += 1.         // Still under the initial lag period, add nothing and move on         Double lagValue.         if (counter <= lag) {             lagValue = Double.NaN.         } else {             // Peek here, because we rely on add'ing to always move the window             lagValue = lagWindow.peek().         }         // Normalize null's to NaN         if (thisBucketValue == null) {             thisBucketValue = Double.NaN.         }         // Both have values, calculate diff and replace the "empty" bucket         if (!Double.isNaN(thisBucketValue) && !Double.isNaN(lagValue)) {             double diff = thisBucketValue - lagValue.             List<InternalAggregation> aggs = StreamSupport.stream(bucket.getAggregations().spliterator(), false).map((p) -> (InternalAggregation) p).collect(Collectors.toList()).             aggs.add(new InternalSimpleValue(name(), diff, formatter, new ArrayList<>(), metaData())).             newBucket = factory.createBucket(factory.getKey(bucket), bucket.getDocCount(), new InternalAggregations(aggs)).         }         newBuckets.add(newBucket).         lagWindow.add(thisBucketValue).     }     return factory.createAggregation(newBuckets). }
