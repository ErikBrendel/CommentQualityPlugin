commented;modifiers;parameterAmount;loc;comment;code
false;private;1;10;;private void write(DataOutput out) throws IOException {     out.writeLong(offset).     out.writeInt(numOps).     out.writeLong(generation).     out.writeLong(minSeqNo).     out.writeLong(maxSeqNo).     out.writeLong(globalCheckpoint).     out.writeLong(minTranslogGeneration).     out.writeLong(trimmedAboveSeqNo). }
false;static;4;7;;static Checkpoint emptyTranslogCheckpoint(final long offset, final long generation, final long globalCheckpoint, long minTranslogGeneration) {     final long minSeqNo = SequenceNumbers.NO_OPS_PERFORMED.     final long maxSeqNo = SequenceNumbers.NO_OPS_PERFORMED.     final long trimmedAboveSeqNo = SequenceNumbers.UNASSIGNED_SEQ_NO.     return new Checkpoint(offset, 0, generation, minSeqNo, maxSeqNo, globalCheckpoint, minTranslogGeneration, trimmedAboveSeqNo). }
false;static;1;11;;static Checkpoint readCheckpointV6_4_0(final DataInput in) throws IOException {     final long offset = in.readLong().     final int numOps = in.readInt().     final long generation = in.readLong().     final long minSeqNo = in.readLong().     final long maxSeqNo = in.readLong().     final long globalCheckpoint = in.readLong().     final long minTranslogGeneration = in.readLong().     final long trimmedAboveSeqNo = in.readLong().     return new Checkpoint(offset, numOps, generation, minSeqNo, maxSeqNo, globalCheckpoint, minTranslogGeneration, trimmedAboveSeqNo). }
false;static;1;11;;static Checkpoint readCheckpointV6_0_0(final DataInput in) throws IOException {     final long offset = in.readLong().     final int numOps = in.readInt().     final long generation = in.readLong().     final long minSeqNo = in.readLong().     final long maxSeqNo = in.readLong().     final long globalCheckpoint = in.readLong().     final long minTranslogGeneration = in.readLong().     final long trimmedAboveSeqNo = SequenceNumbers.UNASSIGNED_SEQ_NO.     return new Checkpoint(offset, numOps, generation, minSeqNo, maxSeqNo, globalCheckpoint, minTranslogGeneration, trimmedAboveSeqNo). }
true;static;1;11;// reads a checksummed checkpoint introduced in ES 5.0.0 ;// reads a checksummed checkpoint introduced in ES 5.0.0 static Checkpoint readCheckpointV5_0_0(final DataInput in) throws IOException {     final long offset = in.readLong().     final int numOps = in.readInt().     final long generation = in.readLong().     final long minSeqNo = SequenceNumbers.NO_OPS_PERFORMED.     final long maxSeqNo = SequenceNumbers.NO_OPS_PERFORMED.     final long globalCheckpoint = SequenceNumbers.UNASSIGNED_SEQ_NO.     final long minTranslogGeneration = -1.     final long trimmedAboveSeqNo = SequenceNumbers.UNASSIGNED_SEQ_NO.     return new Checkpoint(offset, numOps, generation, minSeqNo, maxSeqNo, globalCheckpoint, minTranslogGeneration, trimmedAboveSeqNo). }
false;public;0;13;;@Override public String toString() {     return "Checkpoint{" + "offset=" + offset + ", numOps=" + numOps + ", generation=" + generation + ", minSeqNo=" + minSeqNo + ", maxSeqNo=" + maxSeqNo + ", globalCheckpoint=" + globalCheckpoint + ", minTranslogGeneration=" + minTranslogGeneration + ", trimmedAboveSeqNo=" + trimmedAboveSeqNo + '}'. }
false;public,static;1;20;;public static Checkpoint read(Path path) throws IOException {     try (Directory dir = new SimpleFSDirectory(path.getParent())) {         try (IndexInput indexInput = dir.openInput(path.getFileName().toString(), IOContext.DEFAULT)) {             // We checksum the entire file before we even go and parse it. If it's corrupted we barf right here.             CodecUtil.checksumEntireFile(indexInput).             final int fileVersion = CodecUtil.checkHeader(indexInput, CHECKPOINT_CODEC, INITIAL_VERSION, CURRENT_VERSION).             if (fileVersion == INITIAL_VERSION) {                 assert indexInput.length() == V1_FILE_SIZE : indexInput.length().                 return Checkpoint.readCheckpointV5_0_0(indexInput).             } else if (fileVersion == VERSION_6_0_0) {                 assert indexInput.length() == V2_FILE_SIZE : indexInput.length().                 return Checkpoint.readCheckpointV6_0_0(indexInput).             } else {                 assert fileVersion == CURRENT_VERSION : fileVersion.                 assert indexInput.length() == V3_FILE_SIZE : indexInput.length().                 return Checkpoint.readCheckpointV6_4_0(indexInput).             }         }     } }
false;public,synchronized;0;5;;@Override public synchronized byte[] toByteArray() {     // don't clone     return buf. }
false;public,static;4;29;;public static void write(ChannelFactory factory, Path checkpointFile, Checkpoint checkpoint, OpenOption... options) throws IOException {     final ByteArrayOutputStream byteOutputStream = new ByteArrayOutputStream(V3_FILE_SIZE) {          @Override         public synchronized byte[] toByteArray() {             // don't clone             return buf.         }     }.     final String resourceDesc = "checkpoint(path=\"" + checkpointFile + "\", gen=" + checkpoint + ")".     try (OutputStreamIndexOutput indexOutput = new OutputStreamIndexOutput(resourceDesc, checkpointFile.toString(), byteOutputStream, V3_FILE_SIZE)) {         CodecUtil.writeHeader(indexOutput, CHECKPOINT_CODEC, CURRENT_VERSION).         checkpoint.write(indexOutput).         CodecUtil.writeFooter(indexOutput).         assert indexOutput.getFilePointer() == V3_FILE_SIZE : "get you numbers straight. bytes written: " + indexOutput.getFilePointer() + ", buffer size: " + V3_FILE_SIZE.         assert indexOutput.getFilePointer() < 512 : "checkpoint files have to be smaller than 512 bytes for atomic writes. size: " + indexOutput.getFilePointer().     }     // now go and write to the channel, in one go.     try (FileChannel channel = factory.open(checkpointFile, options)) {         Channels.writeToChannel(byteOutputStream.toByteArray(), channel).         // no need to force metadata, file size stays the same and we did the full fsync         // when we first created the file, so the directory entry doesn't change as well         channel.force(false).     } }
false;public;1;15;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     Checkpoint that = (Checkpoint) o.     if (offset != that.offset)         return false.     if (numOps != that.numOps)         return false.     if (generation != that.generation)         return false.     if (minSeqNo != that.minSeqNo)         return false.     if (maxSeqNo != that.maxSeqNo)         return false.     if (globalCheckpoint != that.globalCheckpoint)         return false.     return trimmedAboveSeqNo == that.trimmedAboveSeqNo. }
false;public;0;11;;@Override public int hashCode() {     int result = Long.hashCode(offset).     result = 31 * result + numOps.     result = 31 * result + Long.hashCode(generation).     result = 31 * result + Long.hashCode(minSeqNo).     result = 31 * result + Long.hashCode(maxSeqNo).     result = 31 * result + Long.hashCode(globalCheckpoint).     result = 31 * result + Long.hashCode(trimmedAboveSeqNo).     return result. }
