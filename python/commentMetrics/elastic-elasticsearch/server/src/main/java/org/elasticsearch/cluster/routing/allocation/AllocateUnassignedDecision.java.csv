commented;modifiers;parameterAmount;loc;comment;code
true;public,static;2;3;/**  * Returns a NO decision with the given {@link AllocationStatus}, and the individual node-level  * decisions that comprised the final NO decision if in explain mode.  */ ;/**  * Returns a NO decision with the given {@link AllocationStatus}, and the individual node-level  * decisions that comprised the final NO decision if in explain mode.  */ public static AllocateUnassignedDecision no(AllocationStatus allocationStatus, @Nullable List<NodeAllocationResult> decisions) {     return no(allocationStatus, decisions, false). }
true;public,static;3;4;/**  * Returns a NO decision for a delayed shard allocation on a replica shard, with the individual node-level  * decisions that comprised the final NO decision, if in explain mode.  Instances created with this  * method will return {@link AllocationStatus#DELAYED_ALLOCATION} for {@link #getAllocationStatus()}.  */ ;/**  * Returns a NO decision for a delayed shard allocation on a replica shard, with the individual node-level  * decisions that comprised the final NO decision, if in explain mode.  Instances created with this  * method will return {@link AllocationStatus#DELAYED_ALLOCATION} for {@link #getAllocationStatus()}.  */ public static AllocateUnassignedDecision delayed(long remainingDelay, long totalDelay, @Nullable List<NodeAllocationResult> decisions) {     return no(AllocationStatus.DELAYED_ALLOCATION, decisions, false, remainingDelay, totalDelay). }
true;public,static;3;4;/**  * Returns a NO decision with the given {@link AllocationStatus}, and the individual node-level  * decisions that comprised the final NO decision if in explain mode.  */ ;/**  * Returns a NO decision with the given {@link AllocationStatus}, and the individual node-level  * decisions that comprised the final NO decision if in explain mode.  */ public static AllocateUnassignedDecision no(AllocationStatus allocationStatus, @Nullable List<NodeAllocationResult> decisions, boolean reuseStore) {     return no(allocationStatus, decisions, reuseStore, 0L, 0L). }
false;private,static;5;8;;private static AllocateUnassignedDecision no(AllocationStatus allocationStatus, @Nullable List<NodeAllocationResult> decisions, boolean reuseStore, long remainingDelay, long totalDelay) {     if (decisions != null) {         return new AllocateUnassignedDecision(allocationStatus, null, null, decisions, reuseStore, remainingDelay, totalDelay).     } else {         return getCachedDecision(allocationStatus).     } }
true;public,static;1;7;/**  * Returns a THROTTLE decision, with the individual node-level decisions that  * comprised the final THROTTLE decision if in explain mode.  */ ;/**  * Returns a THROTTLE decision, with the individual node-level decisions that  * comprised the final THROTTLE decision if in explain mode.  */ public static AllocateUnassignedDecision throttle(@Nullable List<NodeAllocationResult> decisions) {     if (decisions != null) {         return new AllocateUnassignedDecision(AllocationStatus.DECIDERS_THROTTLED, null, null, decisions, false, 0L, 0L).     } else {         return getCachedDecision(AllocationStatus.DECIDERS_THROTTLED).     } }
true;public,static;4;4;/**  * Creates a YES decision with the given individual node-level decisions that  * comprised the final YES decision, along with the node id to which the shard is assigned and  * the allocation id for the shard, if available.  */ ;/**  * Creates a YES decision with the given individual node-level decisions that  * comprised the final YES decision, along with the node id to which the shard is assigned and  * the allocation id for the shard, if available.  */ public static AllocateUnassignedDecision yes(DiscoveryNode assignedNode, @Nullable String allocationId, @Nullable List<NodeAllocationResult> decisions, boolean reuseStore) {     return new AllocateUnassignedDecision(null, assignedNode, allocationId, decisions, reuseStore, 0L, 0L). }
true;public,static;3;6;/**  * Creates a {@link AllocateUnassignedDecision} from the given {@link Decision} and the assigned node, if any.  */ ;/**  * Creates a {@link AllocateUnassignedDecision} from the given {@link Decision} and the assigned node, if any.  */ public static AllocateUnassignedDecision fromDecision(Decision decision, @Nullable DiscoveryNode assignedNode, @Nullable List<NodeAllocationResult> nodeDecisions) {     final Type decisionType = decision.type().     AllocationStatus allocationStatus = decisionType != Type.YES ? AllocationStatus.fromDecision(decisionType) : null.     return new AllocateUnassignedDecision(allocationStatus, assignedNode, null, nodeDecisions, false, 0L, 0L). }
false;private,static;1;4;;private static AllocateUnassignedDecision getCachedDecision(AllocationStatus allocationStatus) {     AllocateUnassignedDecision decision = CACHED_DECISIONS.get(allocationStatus).     return Objects.requireNonNull(decision, "precomputed decision not found for " + allocationStatus). }
false;public;0;4;;@Override public boolean isDecisionTaken() {     return allocationStatus != AllocationStatus.NO_ATTEMPT. }
true;public;0;4;/**  * Returns the {@link AllocationDecision} denoting the result of an allocation attempt.  * If {@link #isDecisionTaken()} returns {@code false}, then invoking this method will  * throw an {@code IllegalStateException}.  */ ;/**  * Returns the {@link AllocationDecision} denoting the result of an allocation attempt.  * If {@link #isDecisionTaken()} returns {@code false}, then invoking this method will  * throw an {@code IllegalStateException}.  */ public AllocationDecision getAllocationDecision() {     checkDecisionState().     return AllocationDecision.fromAllocationStatus(allocationStatus). }
true;public;0;5;/**  * Returns the status of an unsuccessful allocation attempt.  This value will be {@code null} if  * no decision was taken or if the decision was {@link Decision.Type#YES}.  If {@link #isDecisionTaken()}  * returns {@code false}, then invoking this method will throw an {@code IllegalStateException}.  */ ;/**  * Returns the status of an unsuccessful allocation attempt.  This value will be {@code null} if  * no decision was taken or if the decision was {@link Decision.Type#YES}.  If {@link #isDecisionTaken()}  * returns {@code false}, then invoking this method will throw an {@code IllegalStateException}.  */ @Nullable public AllocationStatus getAllocationStatus() {     checkDecisionState().     return allocationStatus. }
true;public;0;5;/**  * Gets the allocation id for the existing shard copy that the allocator is assigning the shard to.  * This method returns a non-null value iff {@link #getTargetNode()} returns a non-null value  * and the node on which the shard is assigned already has a shard copy with an in-sync allocation id  * that we can re-use.  If {@link #isDecisionTaken()} returns {@code false}, then invoking this method  * will throw an {@code IllegalStateException}.  */ ;/**  * Gets the allocation id for the existing shard copy that the allocator is assigning the shard to.  * This method returns a non-null value iff {@link #getTargetNode()} returns a non-null value  * and the node on which the shard is assigned already has a shard copy with an in-sync allocation id  * that we can re-use.  If {@link #isDecisionTaken()} returns {@code false}, then invoking this method  * will throw an {@code IllegalStateException}.  */ @Nullable public String getAllocationId() {     checkDecisionState().     return allocationId. }
true;public;0;4;/**  * Gets the remaining delay for allocating the replica shard when a node holding the replica left  * the cluster and the deciders are waiting to see if the node returns before allocating the replica  * elsewhere.  Only returns a meaningful positive value if {@link #getAllocationStatus()} returns  * {@link AllocationStatus#DELAYED_ALLOCATION}.  If {@link #isDecisionTaken()} returns {@code false},  * then invoking this method will throw an {@code IllegalStateException}.  */ ;/**  * Gets the remaining delay for allocating the replica shard when a node holding the replica left  * the cluster and the deciders are waiting to see if the node returns before allocating the replica  * elsewhere.  Only returns a meaningful positive value if {@link #getAllocationStatus()} returns  * {@link AllocationStatus#DELAYED_ALLOCATION}.  If {@link #isDecisionTaken()} returns {@code false},  * then invoking this method will throw an {@code IllegalStateException}.  */ public long getRemainingDelayInMillis() {     checkDecisionState().     return remainingDelayInMillis. }
true;public;0;4;/**  * Gets the total configured delay for allocating the replica shard when a node holding the replica left  * the cluster and the deciders are waiting to see if the node returns before allocating the replica  * elsewhere.  Only returns a meaningful positive value if {@link #getAllocationStatus()} returns  * {@link AllocationStatus#DELAYED_ALLOCATION}.  If {@link #isDecisionTaken()} returns {@code false},  * then invoking this method will throw an {@code IllegalStateException}.  */ ;/**  * Gets the total configured delay for allocating the replica shard when a node holding the replica left  * the cluster and the deciders are waiting to see if the node returns before allocating the replica  * elsewhere.  Only returns a meaningful positive value if {@link #getAllocationStatus()} returns  * {@link AllocationStatus#DELAYED_ALLOCATION}.  If {@link #isDecisionTaken()} returns {@code false},  * then invoking this method will throw an {@code IllegalStateException}.  */ public long getConfiguredDelayInMillis() {     checkDecisionState().     return configuredDelayInMillis. }
false;public;0;32;;@Override public String getExplanation() {     checkDecisionState().     AllocationDecision allocationDecision = getAllocationDecision().     if (allocationDecision == AllocationDecision.YES) {         return "can allocate the shard".     } else if (allocationDecision == AllocationDecision.THROTTLED) {         return "allocation temporarily throttled".     } else if (allocationDecision == AllocationDecision.AWAITING_INFO) {         return "cannot allocate because information about existing shard data is still being retrieved from some of the nodes".     } else if (allocationDecision == AllocationDecision.NO_VALID_SHARD_COPY) {         if (hasNodeWithStaleOrCorruptShard()) {             return "cannot allocate because all found copies of the shard are either stale or corrupt".         } else {             return "cannot allocate because a previous copy of the primary shard existed but can no longer be found on " + "the nodes in the cluster".         }     } else if (allocationDecision == AllocationDecision.ALLOCATION_DELAYED) {         return "cannot allocate because the cluster is still waiting " + TimeValue.timeValueMillis(remainingDelayInMillis) + " for the departed node holding a replica to rejoin" + (atLeastOneNodeWithYesDecision() ? ", despite being allowed to allocate the shard to at least one other node" : "").     } else {         assert allocationDecision == AllocationDecision.NO.         if (reuseStore) {             return "cannot allocate because allocation is not permitted to any of the nodes that hold an in-sync shard copy".         } else {             return "cannot allocate because allocation is not permitted to any of the nodes".         }     } }
false;private;0;6;;private boolean hasNodeWithStaleOrCorruptShard() {     return getNodeDecisions() != null && getNodeDecisions().stream().anyMatch(result -> result.getShardStoreInfo() != null && (result.getShardStoreInfo().getAllocationId() != null || result.getShardStoreInfo().getStoreException() != null)). }
false;public;2;22;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     checkDecisionState().     builder.field("can_allocate", getAllocationDecision()).     builder.field("allocate_explanation", getExplanation()).     if (targetNode != null) {         builder.startObject("target_node").         discoveryNodeToXContent(targetNode, true, builder).         builder.endObject().     }     if (allocationId != null) {         builder.field("allocation_id", allocationId).     }     if (allocationStatus == AllocationStatus.DELAYED_ALLOCATION) {         builder.humanReadableField("configured_delay_in_millis", "configured_delay", TimeValue.timeValueMillis(configuredDelayInMillis)).         builder.humanReadableField("remaining_delay_in_millis", "remaining_delay", TimeValue.timeValueMillis(remainingDelayInMillis)).     }     nodeDecisionsToXContent(nodeDecisions, builder, params).     return builder. }
false;public;1;9;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeOptionalWriteable(allocationStatus).     out.writeOptionalString(allocationId).     out.writeBoolean(reuseStore).     out.writeVLong(remainingDelayInMillis).     out.writeVLong(configuredDelayInMillis). }
false;public;1;15;;@Override public boolean equals(Object other) {     if (super.equals(other) == false) {         return false.     }     if (other instanceof AllocateUnassignedDecision == false) {         return false.     }     AllocateUnassignedDecision that = (AllocateUnassignedDecision) other.     return Objects.equals(allocationStatus, that.allocationStatus) && Objects.equals(allocationId, that.allocationId) && reuseStore == that.reuseStore && configuredDelayInMillis == that.configuredDelayInMillis && remainingDelayInMillis == that.remainingDelayInMillis. }
false;public;0;5;;@Override public int hashCode() {     return 31 * super.hashCode() + Objects.hash(allocationStatus, allocationId, reuseStore, configuredDelayInMillis, remainingDelayInMillis). }
