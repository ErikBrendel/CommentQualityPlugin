commented;modifiers;parameterAmount;loc;comment;code
false;public,static;4;21;;public static Pipeline create(String id, Map<String, Object> config, Map<String, Processor.Factory> processorFactories, ScriptService scriptService) throws Exception {     String description = ConfigurationUtils.readOptionalStringProperty(null, null, config, DESCRIPTION_KEY).     Integer version = ConfigurationUtils.readIntProperty(null, null, config, VERSION_KEY, null).     List<Map<String, Object>> processorConfigs = ConfigurationUtils.readList(null, null, config, PROCESSORS_KEY).     List<Processor> processors = ConfigurationUtils.readProcessorConfigs(processorConfigs, scriptService, processorFactories).     List<Map<String, Object>> onFailureProcessorConfigs = ConfigurationUtils.readOptionalList(null, null, config, ON_FAILURE_KEY).     List<Processor> onFailureProcessors = ConfigurationUtils.readProcessorConfigs(onFailureProcessorConfigs, scriptService, processorFactories).     if (config.isEmpty() == false) {         throw new ElasticsearchParseException("pipeline [" + id + "] doesn't support one or more provided configuration parameters " + Arrays.toString(config.keySet().toArray())).     }     if (onFailureProcessorConfigs != null && onFailureProcessors.isEmpty()) {         throw new ElasticsearchParseException("pipeline [" + id + "] cannot have an empty on_failure option defined").     }     CompoundProcessor compoundProcessor = new CompoundProcessor(false, Collections.unmodifiableList(processors), Collections.unmodifiableList(onFailureProcessors)).     return new Pipeline(id, description, version, compoundProcessor). }
true;public;1;13;/**  * Modifies the data of a document to be indexed based on the processor this pipeline holds  */ ;/**  * Modifies the data of a document to be indexed based on the processor this pipeline holds  */ public IngestDocument execute(IngestDocument ingestDocument) throws Exception {     long startTimeInNanos = relativeTimeProvider.getAsLong().     try {         metrics.preIngest().         return compoundProcessor.execute(ingestDocument).     } catch (Exception e) {         metrics.ingestFailed().         throw e.     } finally {         long ingestTimeInMillis = TimeUnit.NANOSECONDS.toMillis(relativeTimeProvider.getAsLong() - startTimeInNanos).         metrics.postIngest(ingestTimeInMillis).     } }
true;public;0;3;/**  * The unique id of this pipeline  */ ;/**  * The unique id of this pipeline  */ public String getId() {     return id. }
true;public;0;4;/**  * An optional description of what this pipeline is doing to the data gets processed by this pipeline.  */ ;/**  * An optional description of what this pipeline is doing to the data gets processed by this pipeline.  */ @Nullable public String getDescription() {     return description. }
true;public;0;4;/**  * An optional version stored with the pipeline so that it can be used to determine if the pipeline should be updated / replaced.  *  * @return {@code null} if not supplied.  */ ;/**  * An optional version stored with the pipeline so that it can be used to determine if the pipeline should be updated / replaced.  *  * @return {@code null} if not supplied.  */ @Nullable public Integer getVersion() {     return version. }
true;public;0;3;/**  * Get the underlying {@link CompoundProcessor} containing the Pipeline's processors  */ ;/**  * Get the underlying {@link CompoundProcessor} containing the Pipeline's processors  */ public CompoundProcessor getCompoundProcessor() {     return compoundProcessor. }
true;public;0;3;/**  * Unmodifiable list containing each processor that operates on the data.  */ ;/**  * Unmodifiable list containing each processor that operates on the data.  */ public List<Processor> getProcessors() {     return compoundProcessor.getProcessors(). }
true;public;0;3;/**  * Unmodifiable list containing each on_failure processor that operates on the data in case of  * exception thrown in pipeline processors  */ ;/**  * Unmodifiable list containing each on_failure processor that operates on the data in case of  * exception thrown in pipeline processors  */ public List<Processor> getOnFailureProcessors() {     return compoundProcessor.getOnFailureProcessors(). }
true;public;0;3;/**  * Flattens the normal and on failure processors into a single list. The original order is lost.  * This can be useful for pipeline validation purposes.  */ ;/**  * Flattens the normal and on failure processors into a single list. The original order is lost.  * This can be useful for pipeline validation purposes.  */ public List<Processor> flattenAllProcessors() {     return compoundProcessor.flattenProcessors(). }
true;public;0;3;/**  * The metrics associated with this pipeline.  */ ;/**  * The metrics associated with this pipeline.  */ public IngestMetric getMetrics() {     return metrics. }
