commented;modifiers;parameterAmount;loc;comment;code
false;;1;7;;void setExpireAfterAccessNanos(long expireAfterAccessNanos) {     if (expireAfterAccessNanos <= 0) {         throw new IllegalArgumentException("expireAfterAccessNanos <= 0").     }     this.expireAfterAccessNanos = expireAfterAccessNanos.     this.entriesExpireAfterAccess = true. }
true;;0;3;// pkg-private for testing ;// pkg-private for testing long getExpireAfterAccessNanos() {     return this.expireAfterAccessNanos. }
false;;1;7;;void setExpireAfterWriteNanos(long expireAfterWriteNanos) {     if (expireAfterWriteNanos <= 0) {         throw new IllegalArgumentException("expireAfterWriteNanos <= 0").     }     this.expireAfterWriteNanos = expireAfterWriteNanos.     this.entriesExpireAfterWrite = true. }
true;;0;3;// pkg-private for testing ;// pkg-private for testing long getExpireAfterWriteNanos() {     return this.expireAfterWriteNanos. }
false;;1;6;;void setMaximumWeight(long maximumWeight) {     if (maximumWeight < 0) {         throw new IllegalArgumentException("maximumWeight < 0").     }     this.maximumWeight = maximumWeight. }
false;;1;4;;void setWeigher(ToLongBiFunction<K, V> weigher) {     Objects.requireNonNull(weigher).     this.weigher = weigher. }
false;;1;4;;void setRemovalListener(RemovalListener<K, V> removalListener) {     Objects.requireNonNull(removalListener).     this.removalListener = removalListener. }
true;protected;0;5;/**  * The relative time used to track time-based evictions.  *  * @return the current relative time  */ ;/**  * The relative time used to track time-based evictions.  *  * @return the current relative time  */ protected long now() {     // use System.nanoTime because we want relative time, not absolute time     return entriesExpireAfterAccess || entriesExpireAfterWrite ? System.nanoTime() : 0. }
true;;4;30;/**  * get an entry from the segment. expired entries will be returned as null but not removed from the cache until the LRU list is  * pruned or a manual {@link Cache#refresh()} is performed however a caller can take action using the provided callback  *  * @param key       the key of the entry to get from the cache  * @param now       the access time of this entry  * @param isExpired test if the entry is expired  * @param onExpiration a callback if the entry associated to the key is expired  * @return the entry if there was one, otherwise null  */ ;/**  * get an entry from the segment. expired entries will be returned as null but not removed from the cache until the LRU list is  * pruned or a manual {@link Cache#refresh()} is performed however a caller can take action using the provided callback  *  * @param key       the key of the entry to get from the cache  * @param now       the access time of this entry  * @param isExpired test if the entry is expired  * @param onExpiration a callback if the entry associated to the key is expired  * @return the entry if there was one, otherwise null  */ Entry<K, V> get(K key, long now, Predicate<Entry<K, V>> isExpired, Consumer<Entry<K, V>> onExpiration) {     CompletableFuture<Entry<K, V>> future.     try (ReleasableLock ignored = readLock.acquire()) {         future = map.get(key).     }     if (future != null) {         Entry<K, V> entry.         try {             entry = future.get().         } catch (ExecutionException e) {             assert future.isCompletedExceptionally().             segmentStats.miss().             return null.         } catch (InterruptedException e) {             throw new IllegalStateException(e).         }         if (isExpired.test(entry)) {             segmentStats.miss().             onExpiration.accept(entry).             return null.         } else {             segmentStats.hit().             entry.accessTime = now.             return entry.         }     } else {         segmentStats.miss().         return null.     } }
true;;3;21;/**  * put an entry into the segment  *  * @param key   the key of the entry to add to the cache  * @param value the value of the entry to add to the cache  * @param now   the access time of this entry  * @return a tuple of the new entry and the existing entry, if there was one otherwise null  */ ;/**  * put an entry into the segment  *  * @param key   the key of the entry to add to the cache  * @param value the value of the entry to add to the cache  * @param now   the access time of this entry  * @return a tuple of the new entry and the existing entry, if there was one otherwise null  */ Tuple<Entry<K, V>, Entry<K, V>> put(K key, V value, long now) {     Entry<K, V> entry = new Entry<>(key, value, now).     Entry<K, V> existing = null.     try (ReleasableLock ignored = writeLock.acquire()) {         try {             CompletableFuture<Entry<K, V>> future = map.put(key, CompletableFuture.completedFuture(entry)).             if (future != null) {                 existing = future.handle((ok, ex) -> {                     if (ok != null) {                         return ok.                     } else {                         return null.                     }                 }).get().             }         } catch (ExecutionException | InterruptedException e) {             throw new IllegalStateException(e).         }     }     return Tuple.tuple(entry, existing). }
true;;2;10;/**  * remove an entry from the segment  *  * @param key       the key of the entry to remove from the cache  * @param onRemoval a callback for the removed entry  */ ;/**  * remove an entry from the segment  *  * @param key       the key of the entry to remove from the cache  * @param onRemoval a callback for the removed entry  */ void remove(K key, Consumer<CompletableFuture<Entry<K, V>>> onRemoval) {     CompletableFuture<Entry<K, V>> future.     try (ReleasableLock ignored = writeLock.acquire()) {         future = map.remove(key).     }     if (future != null) {         segmentStats.eviction().         onRemoval.accept(future).     } }
true;;3;24;/**  * remove an entry from the segment iff the future is done and the value is equal to the  * expected value  *  * @param key the key of the entry to remove from the cache  * @param value the value expected to be associated with the key  * @param onRemoval a callback for the removed entry  */ ;/**  * remove an entry from the segment iff the future is done and the value is equal to the  * expected value  *  * @param key the key of the entry to remove from the cache  * @param value the value expected to be associated with the key  * @param onRemoval a callback for the removed entry  */ void remove(K key, V value, Consumer<CompletableFuture<Entry<K, V>>> onRemoval) {     CompletableFuture<Entry<K, V>> future.     boolean removed = false.     try (ReleasableLock ignored = writeLock.acquire()) {         future = map.get(key).         try {             if (future != null) {                 if (future.isDone()) {                     Entry<K, V> entry = future.get().                     if (Objects.equals(value, entry.value)) {                         removed = map.remove(key, future).                     }                 }             }         } catch (ExecutionException | InterruptedException e) {             throw new IllegalStateException(e).         }     }     if (future != null && removed) {         segmentStats.eviction().         onRemoval.accept(future).     } }
false;;0;3;;void hit() {     hits.increment(). }
false;;0;3;;void miss() {     misses.increment(). }
false;;0;3;;void eviction() {     evictions.increment(). }
true;public;1;3;/**  * Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key.  *  * @param key the key whose associated value is to be returned  * @return the value to which the specified key is mapped, or null if this map contains no mapping for the key  */ ;/**  * Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key.  *  * @param key the key whose associated value is to be returned  * @return the value to which the specified key is mapped, or null if this map contains no mapping for the key  */ public V get(K key) {     return get(key, now(), e -> {     }). }
false;private;3;10;;private V get(K key, long now, Consumer<Entry<K, V>> onExpiration) {     CacheSegment<K, V> segment = getCacheSegment(key).     Entry<K, V> entry = segment.get(key, now, e -> isExpired(e, now), onExpiration).     if (entry == null) {         return null.     } else {         promote(entry, now).         return entry.value.     } }
true;public;2;74;/**  * If the specified key is not already associated with a value (or is mapped to null), attempts to compute its  * value using the given mapping function and enters it into this map unless null. The load method for a given key  * will be invoked at most once.  *  * Use of different {@link CacheLoader} implementations on the same key concurrently may result in only the first  * loader function being called and the second will be returned the result provided by the first including any exceptions  * thrown during the execution of the first.  *  * @param key    the key whose associated value is to be returned or computed for if non-existent  * @param loader the function to compute a value given a key  * @return the current (existing or computed) non-null value associated with the specified key  * @throws ExecutionException thrown if loader throws an exception or returns a null value  */ ;/**  * If the specified key is not already associated with a value (or is mapped to null), attempts to compute its  * value using the given mapping function and enters it into this map unless null. The load method for a given key  * will be invoked at most once.  *  * Use of different {@link CacheLoader} implementations on the same key concurrently may result in only the first  * loader function being called and the second will be returned the result provided by the first including any exceptions  * thrown during the execution of the first.  *  * @param key    the key whose associated value is to be returned or computed for if non-existent  * @param loader the function to compute a value given a key  * @return the current (existing or computed) non-null value associated with the specified key  * @throws ExecutionException thrown if loader throws an exception or returns a null value  */ public V computeIfAbsent(K key, CacheLoader<K, V> loader) throws ExecutionException {     long now = now().     // we have to eagerly evict expired entries or our putIfAbsent call below will fail     V value = get(key, now, e -> {         try (ReleasableLock ignored = lruLock.acquire()) {             evictEntry(e).         }     }).     if (value == null) {         // we need to synchronize loading of a value for a given key. however, holding the segment lock while         // invoking load can lead to deadlock against another thread due to dependent key loading. therefore, we         // need a mechanism to ensure that load is invoked at most once, but we are not invoking load while holding         // the segment lock. to do this, we atomically put a future in the map that can load the value, and then         // get the value from this future on the thread that won the race to place the future into the segment map         CacheSegment<K, V> segment = getCacheSegment(key).         CompletableFuture<Entry<K, V>> future.         CompletableFuture<Entry<K, V>> completableFuture = new CompletableFuture<>().         try (ReleasableLock ignored = segment.writeLock.acquire()) {             future = segment.map.putIfAbsent(key, completableFuture).         }         BiFunction<? super Entry<K, V>, Throwable, ? extends V> handler = (ok, ex) -> {             if (ok != null) {                 try (ReleasableLock ignored = lruLock.acquire()) {                     promote(ok, now).                 }                 return ok.value.             } else {                 try (ReleasableLock ignored = segment.writeLock.acquire()) {                     CompletableFuture<Entry<K, V>> sanity = segment.map.get(key).                     if (sanity != null && sanity.isCompletedExceptionally()) {                         segment.map.remove(key).                     }                 }                 return null.             }         }.         CompletableFuture<V> completableValue.         if (future == null) {             future = completableFuture.             completableValue = future.handle(handler).             V loaded.             try {                 loaded = loader.load(key).             } catch (Exception e) {                 future.completeExceptionally(e).                 throw new ExecutionException(e).             }             if (loaded == null) {                 NullPointerException npe = new NullPointerException("loader returned a null value").                 future.completeExceptionally(npe).                 throw new ExecutionException(npe).             } else {                 future.complete(new Entry<>(key, loaded, now)).             }         } else {             completableValue = future.handle(handler).         }         try {             value = completableValue.get().             // check to ensure the future hasn't been completed with an exception             if (future.isCompletedExceptionally()) {                 // call get to force the exception to be thrown for other concurrent callers                 future.get().                 throw new IllegalStateException("the future was completed exceptionally but no exception was thrown").             }         } catch (InterruptedException e) {             throw new IllegalStateException(e).         }     }     return value. }
true;public;2;4;/**  * Associates the specified value with the specified key in this map. If the map previously contained a mapping for  * the key, the old value is replaced.  *  * @param key   key with which the specified value is to be associated  * @param value value to be associated with the specified key  */ ;/**  * Associates the specified value with the specified key in this map. If the map previously contained a mapping for  * the key, the old value is replaced.  *  * @param key   key with which the specified value is to be associated  * @param value value to be associated with the specified key  */ public void put(K key, V value) {     long now = now().     put(key, value, now). }
false;private;3;17;;private void put(K key, V value, long now) {     CacheSegment<K, V> segment = getCacheSegment(key).     Tuple<Entry<K, V>, Entry<K, V>> tuple = segment.put(key, value, now).     boolean replaced = false.     try (ReleasableLock ignored = lruLock.acquire()) {         if (tuple.v2() != null && tuple.v2().state == State.EXISTING) {             if (unlink(tuple.v2())) {                 replaced = true.             }         }         promote(tuple.v1(), now).     }     if (replaced) {         removalListener.onRemoval(new RemovalNotification<>(tuple.v2().key, tuple.v2().value, RemovalNotification.RemovalReason.REPLACED)).     } }
true;public;1;4;/**  * Invalidate the association for the specified key. A removal notification will be issued for invalidated  * entries with {@link org.elasticsearch.common.cache.RemovalNotification.RemovalReason} INVALIDATED.  *  * @param key the key whose mapping is to be invalidated from the cache  */ ;/**  * Invalidate the association for the specified key. A removal notification will be issued for invalidated  * entries with {@link org.elasticsearch.common.cache.RemovalNotification.RemovalReason} INVALIDATED.  *  * @param key the key whose mapping is to be invalidated from the cache  */ public void invalidate(K key) {     CacheSegment<K, V> segment = getCacheSegment(key).     segment.remove(key, invalidationConsumer). }
true;public;2;4;/**  * Invalidate the entry for the specified key and value. If the value provided is not equal to the value in  * the cache, no removal will occur. A removal notification will be issued for invalidated  * entries with {@link org.elasticsearch.common.cache.RemovalNotification.RemovalReason} INVALIDATED.  *  * @param key the key whose mapping is to be invalidated from the cache  * @param value the expected value that should be associated with the key  */ ;/**  * Invalidate the entry for the specified key and value. If the value provided is not equal to the value in  * the cache, no removal will occur. A removal notification will be issued for invalidated  * entries with {@link org.elasticsearch.common.cache.RemovalNotification.RemovalReason} INVALIDATED.  *  * @param key the key whose mapping is to be invalidated from the cache  * @param value the expected value that should be associated with the key  */ public void invalidate(K key, V value) {     CacheSegment<K, V> segment = getCacheSegment(key).     segment.remove(key, value, invalidationConsumer). }
true;public;0;33;/**  * Invalidate all cache entries. A removal notification will be issued for invalidated entries with  * {@link org.elasticsearch.common.cache.RemovalNotification.RemovalReason} INVALIDATED.  */ ;/**  * Invalidate all cache entries. A removal notification will be issued for invalidated entries with  * {@link org.elasticsearch.common.cache.RemovalNotification.RemovalReason} INVALIDATED.  */ public void invalidateAll() {     Entry<K, V> h.     boolean[] haveSegmentLock = new boolean[NUMBER_OF_SEGMENTS].     try {         for (int i = 0. i < NUMBER_OF_SEGMENTS. i++) {             segments[i].segmentLock.writeLock().lock().             haveSegmentLock[i] = true.         }         try (ReleasableLock ignored = lruLock.acquire()) {             h = head.             Arrays.stream(segments).forEach(segment -> segment.map = new HashMap<>()).             Entry<K, V> current = head.             while (current != null) {                 current.state = State.DELETED.                 current = current.after.             }             head = tail = null.             count = 0.             weight = 0.         }     } finally {         for (int i = NUMBER_OF_SEGMENTS - 1. i >= 0. i--) {             if (haveSegmentLock[i]) {                 segments[i].segmentLock.writeLock().unlock().             }         }     }     while (h != null) {         removalListener.onRemoval(new RemovalNotification<>(h.key, h.value, RemovalNotification.RemovalReason.INVALIDATED)).         h = h.after.     } }
true;public;0;6;/**  * Force any outstanding size-based and time-based evictions to occur  */ ;/**  * Force any outstanding size-based and time-based evictions to occur  */ public void refresh() {     long now = now().     try (ReleasableLock ignored = lruLock.acquire()) {         evict(now).     } }
true;public;0;3;/**  * The number of entries in the cache.  *  * @return the number of entries in the cache  */ ;/**  * The number of entries in the cache.  *  * @return the number of entries in the cache  */ public int count() {     return count. }
true;public;0;3;/**  * The weight of the entries in the cache.  *  * @return the weight of the entries in the cache  */ ;/**  * The weight of the entries in the cache.  *  * @return the weight of the entries in the cache  */ public long weight() {     return weight. }
false;public;0;4;;@Override public boolean hasNext() {     return iterator.hasNext(). }
false;public;0;4;;@Override public K next() {     return iterator.next().key. }
false;public;0;4;;@Override public void remove() {     iterator.remove(). }
true;public;0;20;/**  * An LRU sequencing of the keys in the cache that supports removal. This sequence is not protected from mutations  * to the cache (except for {@link Iterator#remove()}. The result of iteration under any other mutation is  * undefined.  *  * @return an LRU-ordered {@link Iterable} over the keys in the cache  */ ;/**  * An LRU sequencing of the keys in the cache that supports removal. This sequence is not protected from mutations  * to the cache (except for {@link Iterator#remove()}. The result of iteration under any other mutation is  * undefined.  *  * @return an LRU-ordered {@link Iterable} over the keys in the cache  */ public Iterable<K> keys() {     return () -> new Iterator<K>() {          private CacheIterator iterator = new CacheIterator(head).          @Override         public boolean hasNext() {             return iterator.hasNext().         }          @Override         public K next() {             return iterator.next().key.         }          @Override         public void remove() {             iterator.remove().         }     }. }
false;public;0;4;;@Override public boolean hasNext() {     return iterator.hasNext(). }
false;public;0;4;;@Override public V next() {     return iterator.next().value. }
false;public;0;4;;@Override public void remove() {     iterator.remove(). }
true;public;0;20;/**  * An LRU sequencing of the values in the cache. This sequence is not protected from mutations  * to the cache (except for {@link Iterator#remove()}. The result of iteration under any other mutation is  * undefined.  *  * @return an LRU-ordered {@link Iterable} over the values in the cache  */ ;/**  * An LRU sequencing of the values in the cache. This sequence is not protected from mutations  * to the cache (except for {@link Iterator#remove()}. The result of iteration under any other mutation is  * undefined.  *  * @return an LRU-ordered {@link Iterable} over the values in the cache  */ public Iterable<V> values() {     return () -> new Iterator<V>() {          private CacheIterator iterator = new CacheIterator(head).          @Override         public boolean hasNext() {             return iterator.hasNext().         }          @Override         public V next() {             return iterator.next().value.         }          @Override         public void remove() {             iterator.remove().         }     }. }
false;public;0;4;;@Override public boolean hasNext() {     return next != null. }
false;public;0;6;;@Override public Entry<K, V> next() {     current = next.     next = next.after.     return current. }
false;public;0;12;;@Override public void remove() {     Entry<K, V> entry = current.     if (entry != null) {         CacheSegment<K, V> segment = getCacheSegment(entry.key).         segment.remove(entry.key, entry.value, f -> {         }).         try (ReleasableLock ignored = lruLock.acquire()) {             current = null.             delete(entry, RemovalNotification.RemovalReason.INVALIDATED).         }     } }
true;public;0;11;/**  * The cache statistics tracking hits, misses and evictions. These are taken on a best-effort basis meaning that  * they could be out-of-date mid-flight.  *  * @return the current cache statistics  */ ;/**  * The cache statistics tracking hits, misses and evictions. These are taken on a best-effort basis meaning that  * they could be out-of-date mid-flight.  *  * @return the current cache statistics  */ public CacheStats stats() {     long hits = 0.     long misses = 0.     long evictions = 0.     for (int i = 0. i < segments.length. i++) {         hits += segments[i].segmentStats.hits.longValue().         misses += segments[i].segmentStats.misses.longValue().         evictions += segments[i].segmentStats.evictions.longValue().     }     return new CacheStats(hits, misses, evictions). }
false;public;0;3;;public long getHits() {     return hits. }
false;public;0;3;;public long getMisses() {     return misses. }
false;public;0;3;;public long getEvictions() {     return evictions. }
false;private;2;20;;private boolean promote(Entry<K, V> entry, long now) {     boolean promoted = true.     try (ReleasableLock ignored = lruLock.acquire()) {         switch(entry.state) {             case DELETED:                 promoted = false.                 break.             case EXISTING:                 relinkAtHead(entry).                 break.             case NEW:                 linkAtHead(entry).                 break.         }         if (promoted) {             evict(now).         }     }     return promoted. }
false;private;1;7;;private void evict(long now) {     assert lruLock.isHeldByCurrentThread().     while (tail != null && shouldPrune(tail, now)) {         evictEntry(tail).     } }
false;private;1;9;;private void evictEntry(Entry<K, V> entry) {     assert lruLock.isHeldByCurrentThread().     CacheSegment<K, V> segment = getCacheSegment(entry.key).     if (segment != null) {         segment.remove(entry.key, entry.value, f -> {         }).     }     delete(entry, RemovalNotification.RemovalReason.EVICTED). }
false;private;2;7;;private void delete(Entry<K, V> entry, RemovalNotification.RemovalReason removalReason) {     assert lruLock.isHeldByCurrentThread().     if (unlink(entry)) {         removalListener.onRemoval(new RemovalNotification<>(entry.key, entry.value, removalReason)).     } }
false;private;2;3;;private boolean shouldPrune(Entry<K, V> entry, long now) {     return exceedsWeight() || isExpired(entry, now). }
false;private;0;3;;private boolean exceedsWeight() {     return maximumWeight != -1 && weight > maximumWeight. }
false;private;2;4;;private boolean isExpired(Entry<K, V> entry, long now) {     return (entriesExpireAfterAccess && now - entry.accessTime > expireAfterAccessNanos) || (entriesExpireAfterWrite && now - entry.writeTime > expireAfterWriteNanos). }
false;private;1;41;;private boolean unlink(Entry<K, V> entry) {     assert lruLock.isHeldByCurrentThread().     if (entry.state == State.EXISTING) {         final Entry<K, V> before = entry.before.         final Entry<K, V> after = entry.after.         if (before == null) {             // removing the head             assert head == entry.             head = after.             if (head != null) {                 head.before = null.             }         } else {             // removing inner element             before.after = after.             entry.before = null.         }         if (after == null) {             // removing tail             assert tail == entry.             tail = before.             if (tail != null) {                 tail.after = null.             }         } else {             // removing inner element             after.before = before.             entry.after = null.         }         count--.         weight -= weigher.applyAsLong(entry.key, entry.value).         entry.state = State.DELETED.         return true.     } else {         return false.     } }
false;private;1;17;;private void linkAtHead(Entry<K, V> entry) {     assert lruLock.isHeldByCurrentThread().     Entry<K, V> h = head.     entry.before = null.     entry.after = head.     head = entry.     if (h == null) {         tail = entry.     } else {         h.before = entry.     }     count++.     weight += weigher.applyAsLong(entry.key, entry.value).     entry.state = State.EXISTING. }
false;private;1;8;;private void relinkAtHead(Entry<K, V> entry) {     assert lruLock.isHeldByCurrentThread().     if (head != entry) {         unlink(entry).         linkAtHead(entry).     } }
false;private;1;3;;private CacheSegment<K, V> getCacheSegment(K key) {     return segments[key.hashCode() & 0xff]. }
