# id;timestamp;commentText;codeText;commentWords;codeWords
Cache -> public int count();1524684173;The number of entries in the cache.__@return the number of entries in the cache;public int count() {_        return count__    };the,number,of,entries,in,the,cache,return,the,number,of,entries,in,the,cache;public,int,count,return,count
Cache -> public int count();1526029249;The number of entries in the cache.__@return the number of entries in the cache;public int count() {_        return count__    };the,number,of,entries,in,the,cache,return,the,number,of,entries,in,the,cache;public,int,count,return,count
Cache -> public int count();1527207653;The number of entries in the cache.__@return the number of entries in the cache;public int count() {_        return count__    };the,number,of,entries,in,the,cache,return,the,number,of,entries,in,the,cache;public,int,count,return,count
Cache -> public int count();1540583181;The number of entries in the cache.__@return the number of entries in the cache;public int count() {_        return count__    };the,number,of,entries,in,the,cache,return,the,number,of,entries,in,the,cache;public,int,count,return,count
Cache -> public void invalidate(K key, V value);1527207653;Invalidate the entry for the specified key and value. If the value provided is not equal to the value in_the cache, no removal will occur. A removal notification will be issued for invalidated_entries with {@link org.elasticsearch.common.cache.RemovalNotification.RemovalReason} INVALIDATED.__@param key the key whose mapping is to be invalidated from the cache_@param value the expected value that should be associated with the key;public void invalidate(K key, V value) {_        CacheSegment<K, V> segment = getCacheSegment(key)__        segment.remove(key, value, invalidationConsumer)__    };invalidate,the,entry,for,the,specified,key,and,value,if,the,value,provided,is,not,equal,to,the,value,in,the,cache,no,removal,will,occur,a,removal,notification,will,be,issued,for,invalidated,entries,with,link,org,elasticsearch,common,cache,removal,notification,removal,reason,invalidated,param,key,the,key,whose,mapping,is,to,be,invalidated,from,the,cache,param,value,the,expected,value,that,should,be,associated,with,the,key;public,void,invalidate,k,key,v,value,cache,segment,k,v,segment,get,cache,segment,key,segment,remove,key,value,invalidation,consumer
Cache -> public void invalidate(K key, V value);1540583181;Invalidate the entry for the specified key and value. If the value provided is not equal to the value in_the cache, no removal will occur. A removal notification will be issued for invalidated_entries with {@link org.elasticsearch.common.cache.RemovalNotification.RemovalReason} INVALIDATED.__@param key the key whose mapping is to be invalidated from the cache_@param value the expected value that should be associated with the key;public void invalidate(K key, V value) {_        CacheSegment<K, V> segment = getCacheSegment(key)__        segment.remove(key, value, invalidationConsumer)__    };invalidate,the,entry,for,the,specified,key,and,value,if,the,value,provided,is,not,equal,to,the,value,in,the,cache,no,removal,will,occur,a,removal,notification,will,be,issued,for,invalidated,entries,with,link,org,elasticsearch,common,cache,removal,notification,removal,reason,invalidated,param,key,the,key,whose,mapping,is,to,be,invalidated,from,the,cache,param,value,the,expected,value,that,should,be,associated,with,the,key;public,void,invalidate,k,key,v,value,cache,segment,k,v,segment,get,cache,segment,key,segment,remove,key,value,invalidation,consumer
Cache -> CacheSegment -> void remove(K key, Consumer<CompletableFuture<Entry<K, V>>> onRemoval);1526029249;remove an entry from the segment__@param key       the key of the entry to remove from the cache_@param onRemoval a callback for the removed entry;void remove(K key, Consumer<CompletableFuture<Entry<K, V>>> onRemoval) {_            CompletableFuture<Entry<K, V>> future__            try (ReleasableLock ignored = writeLock.acquire()) {_                future = map.remove(key)__            }_            if (future != null) {_                segmentStats.eviction()__                onRemoval.accept(future)__            }_        };remove,an,entry,from,the,segment,param,key,the,key,of,the,entry,to,remove,from,the,cache,param,on,removal,a,callback,for,the,removed,entry;void,remove,k,key,consumer,completable,future,entry,k,v,on,removal,completable,future,entry,k,v,future,try,releasable,lock,ignored,write,lock,acquire,future,map,remove,key,if,future,null,segment,stats,eviction,on,removal,accept,future
Cache -> CacheSegment -> void remove(K key, Consumer<CompletableFuture<Entry<K, V>>> onRemoval);1527207653;remove an entry from the segment__@param key       the key of the entry to remove from the cache_@param onRemoval a callback for the removed entry;void remove(K key, Consumer<CompletableFuture<Entry<K, V>>> onRemoval) {_            CompletableFuture<Entry<K, V>> future__            try (ReleasableLock ignored = writeLock.acquire()) {_                future = map.remove(key)__            }_            if (future != null) {_                segmentStats.eviction()__                onRemoval.accept(future)__            }_        };remove,an,entry,from,the,segment,param,key,the,key,of,the,entry,to,remove,from,the,cache,param,on,removal,a,callback,for,the,removed,entry;void,remove,k,key,consumer,completable,future,entry,k,v,on,removal,completable,future,entry,k,v,future,try,releasable,lock,ignored,write,lock,acquire,future,map,remove,key,if,future,null,segment,stats,eviction,on,removal,accept,future
Cache -> CacheSegment -> void remove(K key, Consumer<CompletableFuture<Entry<K, V>>> onRemoval);1540583181;remove an entry from the segment__@param key       the key of the entry to remove from the cache_@param onRemoval a callback for the removed entry;void remove(K key, Consumer<CompletableFuture<Entry<K, V>>> onRemoval) {_            CompletableFuture<Entry<K, V>> future__            try (ReleasableLock ignored = writeLock.acquire()) {_                future = map.remove(key)__            }_            if (future != null) {_                segmentStats.eviction()__                onRemoval.accept(future)__            }_        };remove,an,entry,from,the,segment,param,key,the,key,of,the,entry,to,remove,from,the,cache,param,on,removal,a,callback,for,the,removed,entry;void,remove,k,key,consumer,completable,future,entry,k,v,on,removal,completable,future,entry,k,v,future,try,releasable,lock,ignored,write,lock,acquire,future,map,remove,key,if,future,null,segment,stats,eviction,on,removal,accept,future
Cache -> CacheSegment -> Entry<K, V> get(K key, long now, Predicate<Entry<K, V>> isExpired, Consumer<Entry<K, V>> onExpiration);1524684173;get an entry from the segment_ expired entries will be returned as null but not removed from the cache until the LRU list is_pruned or a manual {@link Cache#refresh()} is performed however a caller can take action using the provided callback__@param key       the key of the entry to get from the cache_@param now       the access time of this entry_@param isExpired test if the entry is expired_@param onExpiration a callback if the entry associated to the key is expired_@return the entry if there was one, otherwise null;Entry<K, V> get(K key, long now, Predicate<Entry<K, V>> isExpired, Consumer<Entry<K, V>> onExpiration) {_            CompletableFuture<Entry<K, V>> future__            Entry<K, V> entry = null__            try (ReleasableLock ignored = readLock.acquire()) {_                future = map.get(key)__            }_            if (future != null) {_                try {_                    entry = future.handle((ok, ex) -> {_                        if (ok != null && !isExpired.test(ok)) {_                            segmentStats.hit()__                            ok.accessTime = now__                            return ok__                        } else {_                            segmentStats.miss()__                            if (ok != null) {_                                assert isExpired.test(ok)__                                onExpiration.accept(ok)__                            }_                            return null__                        }_                    }).get()__                } catch (ExecutionException | InterruptedException e) {_                    throw new IllegalStateException(e)__                }_            }_            else {_                segmentStats.miss()__            }_            return entry__        };get,an,entry,from,the,segment,expired,entries,will,be,returned,as,null,but,not,removed,from,the,cache,until,the,lru,list,is,pruned,or,a,manual,link,cache,refresh,is,performed,however,a,caller,can,take,action,using,the,provided,callback,param,key,the,key,of,the,entry,to,get,from,the,cache,param,now,the,access,time,of,this,entry,param,is,expired,test,if,the,entry,is,expired,param,on,expiration,a,callback,if,the,entry,associated,to,the,key,is,expired,return,the,entry,if,there,was,one,otherwise,null;entry,k,v,get,k,key,long,now,predicate,entry,k,v,is,expired,consumer,entry,k,v,on,expiration,completable,future,entry,k,v,future,entry,k,v,entry,null,try,releasable,lock,ignored,read,lock,acquire,future,map,get,key,if,future,null,try,entry,future,handle,ok,ex,if,ok,null,is,expired,test,ok,segment,stats,hit,ok,access,time,now,return,ok,else,segment,stats,miss,if,ok,null,assert,is,expired,test,ok,on,expiration,accept,ok,return,null,get,catch,execution,exception,interrupted,exception,e,throw,new,illegal,state,exception,e,else,segment,stats,miss,return,entry
Cache -> CacheSegment -> Entry<K, V> get(K key, long now, Predicate<Entry<K, V>> isExpired, Consumer<Entry<K, V>> onExpiration);1526029249;get an entry from the segment_ expired entries will be returned as null but not removed from the cache until the LRU list is_pruned or a manual {@link Cache#refresh()} is performed however a caller can take action using the provided callback__@param key       the key of the entry to get from the cache_@param now       the access time of this entry_@param isExpired test if the entry is expired_@param onExpiration a callback if the entry associated to the key is expired_@return the entry if there was one, otherwise null;Entry<K, V> get(K key, long now, Predicate<Entry<K, V>> isExpired, Consumer<Entry<K, V>> onExpiration) {_            CompletableFuture<Entry<K, V>> future__            try (ReleasableLock ignored = readLock.acquire()) {_                future = map.get(key)__            }_            if (future != null) {_                Entry<K, V> entry__                try {_                    entry = future.get()__                } catch (ExecutionException e) {_                    assert future.isCompletedExceptionally()__                    segmentStats.miss()__                    return null__                } catch (InterruptedException e) {_                    throw new IllegalStateException(e)__                }_                if (isExpired.test(entry)) {_                    segmentStats.miss()__                    onExpiration.accept(entry)__                    return null__                } else {_                    segmentStats.hit()__                    entry.accessTime = now__                    return entry__                }_            } else {_                segmentStats.miss()__                return null__            }_        };get,an,entry,from,the,segment,expired,entries,will,be,returned,as,null,but,not,removed,from,the,cache,until,the,lru,list,is,pruned,or,a,manual,link,cache,refresh,is,performed,however,a,caller,can,take,action,using,the,provided,callback,param,key,the,key,of,the,entry,to,get,from,the,cache,param,now,the,access,time,of,this,entry,param,is,expired,test,if,the,entry,is,expired,param,on,expiration,a,callback,if,the,entry,associated,to,the,key,is,expired,return,the,entry,if,there,was,one,otherwise,null;entry,k,v,get,k,key,long,now,predicate,entry,k,v,is,expired,consumer,entry,k,v,on,expiration,completable,future,entry,k,v,future,try,releasable,lock,ignored,read,lock,acquire,future,map,get,key,if,future,null,entry,k,v,entry,try,entry,future,get,catch,execution,exception,e,assert,future,is,completed,exceptionally,segment,stats,miss,return,null,catch,interrupted,exception,e,throw,new,illegal,state,exception,e,if,is,expired,test,entry,segment,stats,miss,on,expiration,accept,entry,return,null,else,segment,stats,hit,entry,access,time,now,return,entry,else,segment,stats,miss,return,null
Cache -> CacheSegment -> Entry<K, V> get(K key, long now, Predicate<Entry<K, V>> isExpired, Consumer<Entry<K, V>> onExpiration);1527207653;get an entry from the segment_ expired entries will be returned as null but not removed from the cache until the LRU list is_pruned or a manual {@link Cache#refresh()} is performed however a caller can take action using the provided callback__@param key       the key of the entry to get from the cache_@param now       the access time of this entry_@param isExpired test if the entry is expired_@param onExpiration a callback if the entry associated to the key is expired_@return the entry if there was one, otherwise null;Entry<K, V> get(K key, long now, Predicate<Entry<K, V>> isExpired, Consumer<Entry<K, V>> onExpiration) {_            CompletableFuture<Entry<K, V>> future__            try (ReleasableLock ignored = readLock.acquire()) {_                future = map.get(key)__            }_            if (future != null) {_                Entry<K, V> entry__                try {_                    entry = future.get()__                } catch (ExecutionException e) {_                    assert future.isCompletedExceptionally()__                    segmentStats.miss()__                    return null__                } catch (InterruptedException e) {_                    throw new IllegalStateException(e)__                }_                if (isExpired.test(entry)) {_                    segmentStats.miss()__                    onExpiration.accept(entry)__                    return null__                } else {_                    segmentStats.hit()__                    entry.accessTime = now__                    return entry__                }_            } else {_                segmentStats.miss()__                return null__            }_        };get,an,entry,from,the,segment,expired,entries,will,be,returned,as,null,but,not,removed,from,the,cache,until,the,lru,list,is,pruned,or,a,manual,link,cache,refresh,is,performed,however,a,caller,can,take,action,using,the,provided,callback,param,key,the,key,of,the,entry,to,get,from,the,cache,param,now,the,access,time,of,this,entry,param,is,expired,test,if,the,entry,is,expired,param,on,expiration,a,callback,if,the,entry,associated,to,the,key,is,expired,return,the,entry,if,there,was,one,otherwise,null;entry,k,v,get,k,key,long,now,predicate,entry,k,v,is,expired,consumer,entry,k,v,on,expiration,completable,future,entry,k,v,future,try,releasable,lock,ignored,read,lock,acquire,future,map,get,key,if,future,null,entry,k,v,entry,try,entry,future,get,catch,execution,exception,e,assert,future,is,completed,exceptionally,segment,stats,miss,return,null,catch,interrupted,exception,e,throw,new,illegal,state,exception,e,if,is,expired,test,entry,segment,stats,miss,on,expiration,accept,entry,return,null,else,segment,stats,hit,entry,access,time,now,return,entry,else,segment,stats,miss,return,null
Cache -> CacheSegment -> Entry<K, V> get(K key, long now, Predicate<Entry<K, V>> isExpired, Consumer<Entry<K, V>> onExpiration);1540583181;get an entry from the segment_ expired entries will be returned as null but not removed from the cache until the LRU list is_pruned or a manual {@link Cache#refresh()} is performed however a caller can take action using the provided callback__@param key       the key of the entry to get from the cache_@param now       the access time of this entry_@param isExpired test if the entry is expired_@param onExpiration a callback if the entry associated to the key is expired_@return the entry if there was one, otherwise null;Entry<K, V> get(K key, long now, Predicate<Entry<K, V>> isExpired, Consumer<Entry<K, V>> onExpiration) {_            CompletableFuture<Entry<K, V>> future__            try (ReleasableLock ignored = readLock.acquire()) {_                future = map.get(key)__            }_            if (future != null) {_                Entry<K, V> entry__                try {_                    entry = future.get()__                } catch (ExecutionException e) {_                    assert future.isCompletedExceptionally()__                    segmentStats.miss()__                    return null__                } catch (InterruptedException e) {_                    throw new IllegalStateException(e)__                }_                if (isExpired.test(entry)) {_                    segmentStats.miss()__                    onExpiration.accept(entry)__                    return null__                } else {_                    segmentStats.hit()__                    entry.accessTime = now__                    return entry__                }_            } else {_                segmentStats.miss()__                return null__            }_        };get,an,entry,from,the,segment,expired,entries,will,be,returned,as,null,but,not,removed,from,the,cache,until,the,lru,list,is,pruned,or,a,manual,link,cache,refresh,is,performed,however,a,caller,can,take,action,using,the,provided,callback,param,key,the,key,of,the,entry,to,get,from,the,cache,param,now,the,access,time,of,this,entry,param,is,expired,test,if,the,entry,is,expired,param,on,expiration,a,callback,if,the,entry,associated,to,the,key,is,expired,return,the,entry,if,there,was,one,otherwise,null;entry,k,v,get,k,key,long,now,predicate,entry,k,v,is,expired,consumer,entry,k,v,on,expiration,completable,future,entry,k,v,future,try,releasable,lock,ignored,read,lock,acquire,future,map,get,key,if,future,null,entry,k,v,entry,try,entry,future,get,catch,execution,exception,e,assert,future,is,completed,exceptionally,segment,stats,miss,return,null,catch,interrupted,exception,e,throw,new,illegal,state,exception,e,if,is,expired,test,entry,segment,stats,miss,on,expiration,accept,entry,return,null,else,segment,stats,hit,entry,access,time,now,return,entry,else,segment,stats,miss,return,null
Cache -> public void refresh();1524684173;Force any outstanding size-based and time-based evictions to occur;public void refresh() {_        long now = now()__        try (ReleasableLock ignored = lruLock.acquire()) {_            evict(now)__        }_    };force,any,outstanding,size,based,and,time,based,evictions,to,occur;public,void,refresh,long,now,now,try,releasable,lock,ignored,lru,lock,acquire,evict,now
Cache -> public void refresh();1526029249;Force any outstanding size-based and time-based evictions to occur;public void refresh() {_        long now = now()__        try (ReleasableLock ignored = lruLock.acquire()) {_            evict(now)__        }_    };force,any,outstanding,size,based,and,time,based,evictions,to,occur;public,void,refresh,long,now,now,try,releasable,lock,ignored,lru,lock,acquire,evict,now
Cache -> public void refresh();1527207653;Force any outstanding size-based and time-based evictions to occur;public void refresh() {_        long now = now()__        try (ReleasableLock ignored = lruLock.acquire()) {_            evict(now)__        }_    };force,any,outstanding,size,based,and,time,based,evictions,to,occur;public,void,refresh,long,now,now,try,releasable,lock,ignored,lru,lock,acquire,evict,now
Cache -> public void refresh();1540583181;Force any outstanding size-based and time-based evictions to occur;public void refresh() {_        long now = now()__        try (ReleasableLock ignored = lruLock.acquire()) {_            evict(now)__        }_    };force,any,outstanding,size,based,and,time,based,evictions,to,occur;public,void,refresh,long,now,now,try,releasable,lock,ignored,lru,lock,acquire,evict,now
Cache -> protected long now();1524684173;The relative time used to track time-based evictions.__@return the current relative time;protected long now() {_        _        _        return entriesExpireAfterAccess || entriesExpireAfterWrite ? System.nanoTime() : 0__    };the,relative,time,used,to,track,time,based,evictions,return,the,current,relative,time;protected,long,now,return,entries,expire,after,access,entries,expire,after,write,system,nano,time,0
Cache -> protected long now();1526029249;The relative time used to track time-based evictions.__@return the current relative time;protected long now() {_        _        _        return entriesExpireAfterAccess || entriesExpireAfterWrite ? System.nanoTime() : 0__    };the,relative,time,used,to,track,time,based,evictions,return,the,current,relative,time;protected,long,now,return,entries,expire,after,access,entries,expire,after,write,system,nano,time,0
Cache -> protected long now();1527207653;The relative time used to track time-based evictions.__@return the current relative time;protected long now() {_        _        _        return entriesExpireAfterAccess || entriesExpireAfterWrite ? System.nanoTime() : 0__    };the,relative,time,used,to,track,time,based,evictions,return,the,current,relative,time;protected,long,now,return,entries,expire,after,access,entries,expire,after,write,system,nano,time,0
Cache -> protected long now();1540583181;The relative time used to track time-based evictions.__@return the current relative time;protected long now() {_        _        _        return entriesExpireAfterAccess || entriesExpireAfterWrite ? System.nanoTime() : 0__    };the,relative,time,used,to,track,time,based,evictions,return,the,current,relative,time;protected,long,now,return,entries,expire,after,access,entries,expire,after,write,system,nano,time,0
Cache -> CacheSegment -> void remove(K key, V value, Consumer<CompletableFuture<Entry<K, V>>> onRemoval);1527207653;remove an entry from the segment iff the future is done and the value is equal to the_expected value__@param key the key of the entry to remove from the cache_@param value the value expected to be associated with the key_@param onRemoval a callback for the removed entry;void remove(K key, V value, Consumer<CompletableFuture<Entry<K, V>>> onRemoval) {_            CompletableFuture<Entry<K, V>> future__            boolean removed = false__            try (ReleasableLock ignored = writeLock.acquire()) {_                future = map.get(key)__                try {_                    if (future != null) {_                        if (future.isDone()) {_                            Entry<K, V> entry = future.get()__                            if (Objects.equals(value, entry.value)) {_                                removed = map.remove(key, future)__                            }_                        }_                    }_                } catch (ExecutionException | InterruptedException e) {_                    throw new IllegalStateException(e)__                }_            }__            if (future != null && removed) {_                segmentStats.eviction()__                onRemoval.accept(future)__            }_        };remove,an,entry,from,the,segment,iff,the,future,is,done,and,the,value,is,equal,to,the,expected,value,param,key,the,key,of,the,entry,to,remove,from,the,cache,param,value,the,value,expected,to,be,associated,with,the,key,param,on,removal,a,callback,for,the,removed,entry;void,remove,k,key,v,value,consumer,completable,future,entry,k,v,on,removal,completable,future,entry,k,v,future,boolean,removed,false,try,releasable,lock,ignored,write,lock,acquire,future,map,get,key,try,if,future,null,if,future,is,done,entry,k,v,entry,future,get,if,objects,equals,value,entry,value,removed,map,remove,key,future,catch,execution,exception,interrupted,exception,e,throw,new,illegal,state,exception,e,if,future,null,removed,segment,stats,eviction,on,removal,accept,future
Cache -> CacheSegment -> void remove(K key, V value, Consumer<CompletableFuture<Entry<K, V>>> onRemoval);1540583181;remove an entry from the segment iff the future is done and the value is equal to the_expected value__@param key the key of the entry to remove from the cache_@param value the value expected to be associated with the key_@param onRemoval a callback for the removed entry;void remove(K key, V value, Consumer<CompletableFuture<Entry<K, V>>> onRemoval) {_            CompletableFuture<Entry<K, V>> future__            boolean removed = false__            try (ReleasableLock ignored = writeLock.acquire()) {_                future = map.get(key)__                try {_                    if (future != null) {_                        if (future.isDone()) {_                            Entry<K, V> entry = future.get()__                            if (Objects.equals(value, entry.value)) {_                                removed = map.remove(key, future)__                            }_                        }_                    }_                } catch (ExecutionException | InterruptedException e) {_                    throw new IllegalStateException(e)__                }_            }__            if (future != null && removed) {_                segmentStats.eviction()__                onRemoval.accept(future)__            }_        };remove,an,entry,from,the,segment,iff,the,future,is,done,and,the,value,is,equal,to,the,expected,value,param,key,the,key,of,the,entry,to,remove,from,the,cache,param,value,the,value,expected,to,be,associated,with,the,key,param,on,removal,a,callback,for,the,removed,entry;void,remove,k,key,v,value,consumer,completable,future,entry,k,v,on,removal,completable,future,entry,k,v,future,boolean,removed,false,try,releasable,lock,ignored,write,lock,acquire,future,map,get,key,try,if,future,null,if,future,is,done,entry,k,v,entry,future,get,if,objects,equals,value,entry,value,removed,map,remove,key,future,catch,execution,exception,interrupted,exception,e,throw,new,illegal,state,exception,e,if,future,null,removed,segment,stats,eviction,on,removal,accept,future
Cache -> public void invalidateAll();1524684173;Invalidate all cache entries. A removal notification will be issued for invalidated entries with_{@link org.elasticsearch.common.cache.RemovalNotification.RemovalReason} INVALIDATED.;public void invalidateAll() {_        Entry<K, V> h___        boolean[] haveSegmentLock = new boolean[NUMBER_OF_SEGMENTS]__        try {_            for (int i = 0_ i < NUMBER_OF_SEGMENTS_ i++) {_                segments[i].segmentLock.writeLock().lock()__                haveSegmentLock[i] = true__            }_            try (ReleasableLock ignored = lruLock.acquire()) {_                h = head__                Arrays.stream(segments).forEach(segment -> segment.map = new HashMap<>())__                Entry<K, V> current = head__                while (current != null) {_                    current.state = State.DELETED__                    current = current.after__                }_                head = tail = null__                count = 0__                weight = 0__            }_        } finally {_            for (int i = NUMBER_OF_SEGMENTS - 1_ i >= 0_ i--) {_                if (haveSegmentLock[i]) {_                    segments[i].segmentLock.writeLock().unlock()__                }_            }_        }_        while (h != null) {_            removalListener.onRemoval(new RemovalNotification<>(h.key, h.value, RemovalNotification.RemovalReason.INVALIDATED))__            h = h.after__        }_    };invalidate,all,cache,entries,a,removal,notification,will,be,issued,for,invalidated,entries,with,link,org,elasticsearch,common,cache,removal,notification,removal,reason,invalidated;public,void,invalidate,all,entry,k,v,h,boolean,have,segment,lock,new,boolean,try,for,int,i,0,i,i,segments,i,segment,lock,write,lock,lock,have,segment,lock,i,true,try,releasable,lock,ignored,lru,lock,acquire,h,head,arrays,stream,segments,for,each,segment,segment,map,new,hash,map,entry,k,v,current,head,while,current,null,current,state,state,deleted,current,current,after,head,tail,null,count,0,weight,0,finally,for,int,i,1,i,0,i,if,have,segment,lock,i,segments,i,segment,lock,write,lock,unlock,while,h,null,removal,listener,on,removal,new,removal,notification,h,key,h,value,removal,notification,removal,reason,invalidated,h,h,after
Cache -> public void invalidateAll();1526029249;Invalidate all cache entries. A removal notification will be issued for invalidated entries with_{@link org.elasticsearch.common.cache.RemovalNotification.RemovalReason} INVALIDATED.;public void invalidateAll() {_        Entry<K, V> h___        boolean[] haveSegmentLock = new boolean[NUMBER_OF_SEGMENTS]__        try {_            for (int i = 0_ i < NUMBER_OF_SEGMENTS_ i++) {_                segments[i].segmentLock.writeLock().lock()__                haveSegmentLock[i] = true__            }_            try (ReleasableLock ignored = lruLock.acquire()) {_                h = head__                Arrays.stream(segments).forEach(segment -> segment.map = new HashMap<>())__                Entry<K, V> current = head__                while (current != null) {_                    current.state = State.DELETED__                    current = current.after__                }_                head = tail = null__                count = 0__                weight = 0__            }_        } finally {_            for (int i = NUMBER_OF_SEGMENTS - 1_ i >= 0_ i--) {_                if (haveSegmentLock[i]) {_                    segments[i].segmentLock.writeLock().unlock()__                }_            }_        }_        while (h != null) {_            removalListener.onRemoval(new RemovalNotification<>(h.key, h.value, RemovalNotification.RemovalReason.INVALIDATED))__            h = h.after__        }_    };invalidate,all,cache,entries,a,removal,notification,will,be,issued,for,invalidated,entries,with,link,org,elasticsearch,common,cache,removal,notification,removal,reason,invalidated;public,void,invalidate,all,entry,k,v,h,boolean,have,segment,lock,new,boolean,try,for,int,i,0,i,i,segments,i,segment,lock,write,lock,lock,have,segment,lock,i,true,try,releasable,lock,ignored,lru,lock,acquire,h,head,arrays,stream,segments,for,each,segment,segment,map,new,hash,map,entry,k,v,current,head,while,current,null,current,state,state,deleted,current,current,after,head,tail,null,count,0,weight,0,finally,for,int,i,1,i,0,i,if,have,segment,lock,i,segments,i,segment,lock,write,lock,unlock,while,h,null,removal,listener,on,removal,new,removal,notification,h,key,h,value,removal,notification,removal,reason,invalidated,h,h,after
Cache -> public void invalidateAll();1527207653;Invalidate all cache entries. A removal notification will be issued for invalidated entries with_{@link org.elasticsearch.common.cache.RemovalNotification.RemovalReason} INVALIDATED.;public void invalidateAll() {_        Entry<K, V> h___        boolean[] haveSegmentLock = new boolean[NUMBER_OF_SEGMENTS]__        try {_            for (int i = 0_ i < NUMBER_OF_SEGMENTS_ i++) {_                segments[i].segmentLock.writeLock().lock()__                haveSegmentLock[i] = true__            }_            try (ReleasableLock ignored = lruLock.acquire()) {_                h = head__                Arrays.stream(segments).forEach(segment -> segment.map = new HashMap<>())__                Entry<K, V> current = head__                while (current != null) {_                    current.state = State.DELETED__                    current = current.after__                }_                head = tail = null__                count = 0__                weight = 0__            }_        } finally {_            for (int i = NUMBER_OF_SEGMENTS - 1_ i >= 0_ i--) {_                if (haveSegmentLock[i]) {_                    segments[i].segmentLock.writeLock().unlock()__                }_            }_        }_        while (h != null) {_            removalListener.onRemoval(new RemovalNotification<>(h.key, h.value, RemovalNotification.RemovalReason.INVALIDATED))__            h = h.after__        }_    };invalidate,all,cache,entries,a,removal,notification,will,be,issued,for,invalidated,entries,with,link,org,elasticsearch,common,cache,removal,notification,removal,reason,invalidated;public,void,invalidate,all,entry,k,v,h,boolean,have,segment,lock,new,boolean,try,for,int,i,0,i,i,segments,i,segment,lock,write,lock,lock,have,segment,lock,i,true,try,releasable,lock,ignored,lru,lock,acquire,h,head,arrays,stream,segments,for,each,segment,segment,map,new,hash,map,entry,k,v,current,head,while,current,null,current,state,state,deleted,current,current,after,head,tail,null,count,0,weight,0,finally,for,int,i,1,i,0,i,if,have,segment,lock,i,segments,i,segment,lock,write,lock,unlock,while,h,null,removal,listener,on,removal,new,removal,notification,h,key,h,value,removal,notification,removal,reason,invalidated,h,h,after
Cache -> public void invalidateAll();1540583181;Invalidate all cache entries. A removal notification will be issued for invalidated entries with_{@link org.elasticsearch.common.cache.RemovalNotification.RemovalReason} INVALIDATED.;public void invalidateAll() {_        Entry<K, V> h___        boolean[] haveSegmentLock = new boolean[NUMBER_OF_SEGMENTS]__        try {_            for (int i = 0_ i < NUMBER_OF_SEGMENTS_ i++) {_                segments[i].segmentLock.writeLock().lock()__                haveSegmentLock[i] = true__            }_            try (ReleasableLock ignored = lruLock.acquire()) {_                h = head__                Arrays.stream(segments).forEach(segment -> segment.map = new HashMap<>())__                Entry<K, V> current = head__                while (current != null) {_                    current.state = State.DELETED__                    current = current.after__                }_                head = tail = null__                count = 0__                weight = 0__            }_        } finally {_            for (int i = NUMBER_OF_SEGMENTS - 1_ i >= 0_ i--) {_                if (haveSegmentLock[i]) {_                    segments[i].segmentLock.writeLock().unlock()__                }_            }_        }_        while (h != null) {_            removalListener.onRemoval(new RemovalNotification<>(h.key, h.value, RemovalNotification.RemovalReason.INVALIDATED))__            h = h.after__        }_    };invalidate,all,cache,entries,a,removal,notification,will,be,issued,for,invalidated,entries,with,link,org,elasticsearch,common,cache,removal,notification,removal,reason,invalidated;public,void,invalidate,all,entry,k,v,h,boolean,have,segment,lock,new,boolean,try,for,int,i,0,i,i,segments,i,segment,lock,write,lock,lock,have,segment,lock,i,true,try,releasable,lock,ignored,lru,lock,acquire,h,head,arrays,stream,segments,for,each,segment,segment,map,new,hash,map,entry,k,v,current,head,while,current,null,current,state,state,deleted,current,current,after,head,tail,null,count,0,weight,0,finally,for,int,i,1,i,0,i,if,have,segment,lock,i,segments,i,segment,lock,write,lock,unlock,while,h,null,removal,listener,on,removal,new,removal,notification,h,key,h,value,removal,notification,removal,reason,invalidated,h,h,after
Cache -> public Iterable<K> keys();1524684173;An LRU sequencing of the keys in the cache that supports removal. This sequence is not protected from mutations_to the cache (except for {@link Iterator#remove()}. The result of iteration under any other mutation is_undefined.__@return an LRU-ordered {@link Iterable} over the keys in the cache;public Iterable<K> keys() {_        return () -> new Iterator<K>() {_            private CacheIterator iterator = new CacheIterator(head)___            @Override_            public boolean hasNext() {_                return iterator.hasNext()__            }__            @Override_            public K next() {_                return iterator.next().key__            }__            @Override_            public void remove() {_                iterator.remove()__            }_        }__    };an,lru,sequencing,of,the,keys,in,the,cache,that,supports,removal,this,sequence,is,not,protected,from,mutations,to,the,cache,except,for,link,iterator,remove,the,result,of,iteration,under,any,other,mutation,is,undefined,return,an,lru,ordered,link,iterable,over,the,keys,in,the,cache;public,iterable,k,keys,return,new,iterator,k,private,cache,iterator,iterator,new,cache,iterator,head,override,public,boolean,has,next,return,iterator,has,next,override,public,k,next,return,iterator,next,key,override,public,void,remove,iterator,remove
Cache -> public Iterable<K> keys();1526029249;An LRU sequencing of the keys in the cache that supports removal. This sequence is not protected from mutations_to the cache (except for {@link Iterator#remove()}. The result of iteration under any other mutation is_undefined.__@return an LRU-ordered {@link Iterable} over the keys in the cache;public Iterable<K> keys() {_        return () -> new Iterator<K>() {_            private CacheIterator iterator = new CacheIterator(head)___            @Override_            public boolean hasNext() {_                return iterator.hasNext()__            }__            @Override_            public K next() {_                return iterator.next().key__            }__            @Override_            public void remove() {_                iterator.remove()__            }_        }__    };an,lru,sequencing,of,the,keys,in,the,cache,that,supports,removal,this,sequence,is,not,protected,from,mutations,to,the,cache,except,for,link,iterator,remove,the,result,of,iteration,under,any,other,mutation,is,undefined,return,an,lru,ordered,link,iterable,over,the,keys,in,the,cache;public,iterable,k,keys,return,new,iterator,k,private,cache,iterator,iterator,new,cache,iterator,head,override,public,boolean,has,next,return,iterator,has,next,override,public,k,next,return,iterator,next,key,override,public,void,remove,iterator,remove
Cache -> public Iterable<K> keys();1527207653;An LRU sequencing of the keys in the cache that supports removal. This sequence is not protected from mutations_to the cache (except for {@link Iterator#remove()}. The result of iteration under any other mutation is_undefined.__@return an LRU-ordered {@link Iterable} over the keys in the cache;public Iterable<K> keys() {_        return () -> new Iterator<K>() {_            private CacheIterator iterator = new CacheIterator(head)___            @Override_            public boolean hasNext() {_                return iterator.hasNext()__            }__            @Override_            public K next() {_                return iterator.next().key__            }__            @Override_            public void remove() {_                iterator.remove()__            }_        }__    };an,lru,sequencing,of,the,keys,in,the,cache,that,supports,removal,this,sequence,is,not,protected,from,mutations,to,the,cache,except,for,link,iterator,remove,the,result,of,iteration,under,any,other,mutation,is,undefined,return,an,lru,ordered,link,iterable,over,the,keys,in,the,cache;public,iterable,k,keys,return,new,iterator,k,private,cache,iterator,iterator,new,cache,iterator,head,override,public,boolean,has,next,return,iterator,has,next,override,public,k,next,return,iterator,next,key,override,public,void,remove,iterator,remove
Cache -> public Iterable<K> keys();1540583181;An LRU sequencing of the keys in the cache that supports removal. This sequence is not protected from mutations_to the cache (except for {@link Iterator#remove()}. The result of iteration under any other mutation is_undefined.__@return an LRU-ordered {@link Iterable} over the keys in the cache;public Iterable<K> keys() {_        return () -> new Iterator<K>() {_            private CacheIterator iterator = new CacheIterator(head)___            @Override_            public boolean hasNext() {_                return iterator.hasNext()__            }__            @Override_            public K next() {_                return iterator.next().key__            }__            @Override_            public void remove() {_                iterator.remove()__            }_        }__    };an,lru,sequencing,of,the,keys,in,the,cache,that,supports,removal,this,sequence,is,not,protected,from,mutations,to,the,cache,except,for,link,iterator,remove,the,result,of,iteration,under,any,other,mutation,is,undefined,return,an,lru,ordered,link,iterable,over,the,keys,in,the,cache;public,iterable,k,keys,return,new,iterator,k,private,cache,iterator,iterator,new,cache,iterator,head,override,public,boolean,has,next,return,iterator,has,next,override,public,k,next,return,iterator,next,key,override,public,void,remove,iterator,remove
Cache -> public long weight();1524684173;The weight of the entries in the cache.__@return the weight of the entries in the cache;public long weight() {_        return weight__    };the,weight,of,the,entries,in,the,cache,return,the,weight,of,the,entries,in,the,cache;public,long,weight,return,weight
Cache -> public long weight();1526029249;The weight of the entries in the cache.__@return the weight of the entries in the cache;public long weight() {_        return weight__    };the,weight,of,the,entries,in,the,cache,return,the,weight,of,the,entries,in,the,cache;public,long,weight,return,weight
Cache -> public long weight();1527207653;The weight of the entries in the cache.__@return the weight of the entries in the cache;public long weight() {_        return weight__    };the,weight,of,the,entries,in,the,cache,return,the,weight,of,the,entries,in,the,cache;public,long,weight,return,weight
Cache -> public long weight();1540583181;The weight of the entries in the cache.__@return the weight of the entries in the cache;public long weight() {_        return weight__    };the,weight,of,the,entries,in,the,cache,return,the,weight,of,the,entries,in,the,cache;public,long,weight,return,weight
Cache -> CacheSegment -> Tuple<Entry<K, V>, Entry<K, V>> put(K key, V value, long now);1524684173;put an entry into the segment__@param key   the key of the entry to add to the cache_@param value the value of the entry to add to the cache_@param now   the access time of this entry_@return a tuple of the new entry and the existing entry, if there was one otherwise null;Tuple<Entry<K, V>, Entry<K, V>> put(K key, V value, long now) {_            Entry<K, V> entry = new Entry<>(key, value, now)__            Entry<K, V> existing = null__            try (ReleasableLock ignored = writeLock.acquire()) {_                try {_                    CompletableFuture<Entry<K, V>> future = map.put(key, CompletableFuture.completedFuture(entry))__                    if (future != null) {_                        existing = future.handle((ok, ex) -> {_                            if (ok != null) {_                                return ok__                            } else {_                                return null__                            }_                        }).get()__                    }_                } catch (ExecutionException | InterruptedException e) {_                    throw new IllegalStateException(e)__                }_            }_            return Tuple.tuple(entry, existing)__        };put,an,entry,into,the,segment,param,key,the,key,of,the,entry,to,add,to,the,cache,param,value,the,value,of,the,entry,to,add,to,the,cache,param,now,the,access,time,of,this,entry,return,a,tuple,of,the,new,entry,and,the,existing,entry,if,there,was,one,otherwise,null;tuple,entry,k,v,entry,k,v,put,k,key,v,value,long,now,entry,k,v,entry,new,entry,key,value,now,entry,k,v,existing,null,try,releasable,lock,ignored,write,lock,acquire,try,completable,future,entry,k,v,future,map,put,key,completable,future,completed,future,entry,if,future,null,existing,future,handle,ok,ex,if,ok,null,return,ok,else,return,null,get,catch,execution,exception,interrupted,exception,e,throw,new,illegal,state,exception,e,return,tuple,tuple,entry,existing
Cache -> CacheSegment -> Tuple<Entry<K, V>, Entry<K, V>> put(K key, V value, long now);1526029249;put an entry into the segment__@param key   the key of the entry to add to the cache_@param value the value of the entry to add to the cache_@param now   the access time of this entry_@return a tuple of the new entry and the existing entry, if there was one otherwise null;Tuple<Entry<K, V>, Entry<K, V>> put(K key, V value, long now) {_            Entry<K, V> entry = new Entry<>(key, value, now)__            Entry<K, V> existing = null__            try (ReleasableLock ignored = writeLock.acquire()) {_                try {_                    CompletableFuture<Entry<K, V>> future = map.put(key, CompletableFuture.completedFuture(entry))__                    if (future != null) {_                        existing = future.handle((ok, ex) -> {_                            if (ok != null) {_                                return ok__                            } else {_                                return null__                            }_                        }).get()__                    }_                } catch (ExecutionException | InterruptedException e) {_                    throw new IllegalStateException(e)__                }_            }_            return Tuple.tuple(entry, existing)__        };put,an,entry,into,the,segment,param,key,the,key,of,the,entry,to,add,to,the,cache,param,value,the,value,of,the,entry,to,add,to,the,cache,param,now,the,access,time,of,this,entry,return,a,tuple,of,the,new,entry,and,the,existing,entry,if,there,was,one,otherwise,null;tuple,entry,k,v,entry,k,v,put,k,key,v,value,long,now,entry,k,v,entry,new,entry,key,value,now,entry,k,v,existing,null,try,releasable,lock,ignored,write,lock,acquire,try,completable,future,entry,k,v,future,map,put,key,completable,future,completed,future,entry,if,future,null,existing,future,handle,ok,ex,if,ok,null,return,ok,else,return,null,get,catch,execution,exception,interrupted,exception,e,throw,new,illegal,state,exception,e,return,tuple,tuple,entry,existing
Cache -> CacheSegment -> Tuple<Entry<K, V>, Entry<K, V>> put(K key, V value, long now);1527207653;put an entry into the segment__@param key   the key of the entry to add to the cache_@param value the value of the entry to add to the cache_@param now   the access time of this entry_@return a tuple of the new entry and the existing entry, if there was one otherwise null;Tuple<Entry<K, V>, Entry<K, V>> put(K key, V value, long now) {_            Entry<K, V> entry = new Entry<>(key, value, now)__            Entry<K, V> existing = null__            try (ReleasableLock ignored = writeLock.acquire()) {_                try {_                    CompletableFuture<Entry<K, V>> future = map.put(key, CompletableFuture.completedFuture(entry))__                    if (future != null) {_                        existing = future.handle((ok, ex) -> {_                            if (ok != null) {_                                return ok__                            } else {_                                return null__                            }_                        }).get()__                    }_                } catch (ExecutionException | InterruptedException e) {_                    throw new IllegalStateException(e)__                }_            }_            return Tuple.tuple(entry, existing)__        };put,an,entry,into,the,segment,param,key,the,key,of,the,entry,to,add,to,the,cache,param,value,the,value,of,the,entry,to,add,to,the,cache,param,now,the,access,time,of,this,entry,return,a,tuple,of,the,new,entry,and,the,existing,entry,if,there,was,one,otherwise,null;tuple,entry,k,v,entry,k,v,put,k,key,v,value,long,now,entry,k,v,entry,new,entry,key,value,now,entry,k,v,existing,null,try,releasable,lock,ignored,write,lock,acquire,try,completable,future,entry,k,v,future,map,put,key,completable,future,completed,future,entry,if,future,null,existing,future,handle,ok,ex,if,ok,null,return,ok,else,return,null,get,catch,execution,exception,interrupted,exception,e,throw,new,illegal,state,exception,e,return,tuple,tuple,entry,existing
Cache -> CacheSegment -> Tuple<Entry<K, V>, Entry<K, V>> put(K key, V value, long now);1540583181;put an entry into the segment__@param key   the key of the entry to add to the cache_@param value the value of the entry to add to the cache_@param now   the access time of this entry_@return a tuple of the new entry and the existing entry, if there was one otherwise null;Tuple<Entry<K, V>, Entry<K, V>> put(K key, V value, long now) {_            Entry<K, V> entry = new Entry<>(key, value, now)__            Entry<K, V> existing = null__            try (ReleasableLock ignored = writeLock.acquire()) {_                try {_                    CompletableFuture<Entry<K, V>> future = map.put(key, CompletableFuture.completedFuture(entry))__                    if (future != null) {_                        existing = future.handle((ok, ex) -> {_                            if (ok != null) {_                                return ok__                            } else {_                                return null__                            }_                        }).get()__                    }_                } catch (ExecutionException | InterruptedException e) {_                    throw new IllegalStateException(e)__                }_            }_            return Tuple.tuple(entry, existing)__        };put,an,entry,into,the,segment,param,key,the,key,of,the,entry,to,add,to,the,cache,param,value,the,value,of,the,entry,to,add,to,the,cache,param,now,the,access,time,of,this,entry,return,a,tuple,of,the,new,entry,and,the,existing,entry,if,there,was,one,otherwise,null;tuple,entry,k,v,entry,k,v,put,k,key,v,value,long,now,entry,k,v,entry,new,entry,key,value,now,entry,k,v,existing,null,try,releasable,lock,ignored,write,lock,acquire,try,completable,future,entry,k,v,future,map,put,key,completable,future,completed,future,entry,if,future,null,existing,future,handle,ok,ex,if,ok,null,return,ok,else,return,null,get,catch,execution,exception,interrupted,exception,e,throw,new,illegal,state,exception,e,return,tuple,tuple,entry,existing
Cache -> public void put(K key, V value);1524684173;Associates the specified value with the specified key in this map. If the map previously contained a mapping for_the key, the old value is replaced.__@param key   key with which the specified value is to be associated_@param value value to be associated with the specified key;public void put(K key, V value) {_        long now = now()__        put(key, value, now)__    };associates,the,specified,value,with,the,specified,key,in,this,map,if,the,map,previously,contained,a,mapping,for,the,key,the,old,value,is,replaced,param,key,key,with,which,the,specified,value,is,to,be,associated,param,value,value,to,be,associated,with,the,specified,key;public,void,put,k,key,v,value,long,now,now,put,key,value,now
Cache -> public void put(K key, V value);1526029249;Associates the specified value with the specified key in this map. If the map previously contained a mapping for_the key, the old value is replaced.__@param key   key with which the specified value is to be associated_@param value value to be associated with the specified key;public void put(K key, V value) {_        long now = now()__        put(key, value, now)__    };associates,the,specified,value,with,the,specified,key,in,this,map,if,the,map,previously,contained,a,mapping,for,the,key,the,old,value,is,replaced,param,key,key,with,which,the,specified,value,is,to,be,associated,param,value,value,to,be,associated,with,the,specified,key;public,void,put,k,key,v,value,long,now,now,put,key,value,now
Cache -> public void put(K key, V value);1527207653;Associates the specified value with the specified key in this map. If the map previously contained a mapping for_the key, the old value is replaced.__@param key   key with which the specified value is to be associated_@param value value to be associated with the specified key;public void put(K key, V value) {_        long now = now()__        put(key, value, now)__    };associates,the,specified,value,with,the,specified,key,in,this,map,if,the,map,previously,contained,a,mapping,for,the,key,the,old,value,is,replaced,param,key,key,with,which,the,specified,value,is,to,be,associated,param,value,value,to,be,associated,with,the,specified,key;public,void,put,k,key,v,value,long,now,now,put,key,value,now
Cache -> public void put(K key, V value);1540583181;Associates the specified value with the specified key in this map. If the map previously contained a mapping for_the key, the old value is replaced.__@param key   key with which the specified value is to be associated_@param value value to be associated with the specified key;public void put(K key, V value) {_        long now = now()__        put(key, value, now)__    };associates,the,specified,value,with,the,specified,key,in,this,map,if,the,map,previously,contained,a,mapping,for,the,key,the,old,value,is,replaced,param,key,key,with,which,the,specified,value,is,to,be,associated,param,value,value,to,be,associated,with,the,specified,key;public,void,put,k,key,v,value,long,now,now,put,key,value,now
Cache -> public Iterable<V> values();1524684173;An LRU sequencing of the values in the cache. This sequence is not protected from mutations_to the cache (except for {@link Iterator#remove()}. The result of iteration under any other mutation is_undefined.__@return an LRU-ordered {@link Iterable} over the values in the cache;public Iterable<V> values() {_        return () -> new Iterator<V>() {_            private CacheIterator iterator = new CacheIterator(head)___            @Override_            public boolean hasNext() {_                return iterator.hasNext()__            }__            @Override_            public V next() {_                return iterator.next().value__            }__            @Override_            public void remove() {_                iterator.remove()__            }_        }__    };an,lru,sequencing,of,the,values,in,the,cache,this,sequence,is,not,protected,from,mutations,to,the,cache,except,for,link,iterator,remove,the,result,of,iteration,under,any,other,mutation,is,undefined,return,an,lru,ordered,link,iterable,over,the,values,in,the,cache;public,iterable,v,values,return,new,iterator,v,private,cache,iterator,iterator,new,cache,iterator,head,override,public,boolean,has,next,return,iterator,has,next,override,public,v,next,return,iterator,next,value,override,public,void,remove,iterator,remove
Cache -> public Iterable<V> values();1526029249;An LRU sequencing of the values in the cache. This sequence is not protected from mutations_to the cache (except for {@link Iterator#remove()}. The result of iteration under any other mutation is_undefined.__@return an LRU-ordered {@link Iterable} over the values in the cache;public Iterable<V> values() {_        return () -> new Iterator<V>() {_            private CacheIterator iterator = new CacheIterator(head)___            @Override_            public boolean hasNext() {_                return iterator.hasNext()__            }__            @Override_            public V next() {_                return iterator.next().value__            }__            @Override_            public void remove() {_                iterator.remove()__            }_        }__    };an,lru,sequencing,of,the,values,in,the,cache,this,sequence,is,not,protected,from,mutations,to,the,cache,except,for,link,iterator,remove,the,result,of,iteration,under,any,other,mutation,is,undefined,return,an,lru,ordered,link,iterable,over,the,values,in,the,cache;public,iterable,v,values,return,new,iterator,v,private,cache,iterator,iterator,new,cache,iterator,head,override,public,boolean,has,next,return,iterator,has,next,override,public,v,next,return,iterator,next,value,override,public,void,remove,iterator,remove
Cache -> public Iterable<V> values();1527207653;An LRU sequencing of the values in the cache. This sequence is not protected from mutations_to the cache (except for {@link Iterator#remove()}. The result of iteration under any other mutation is_undefined.__@return an LRU-ordered {@link Iterable} over the values in the cache;public Iterable<V> values() {_        return () -> new Iterator<V>() {_            private CacheIterator iterator = new CacheIterator(head)___            @Override_            public boolean hasNext() {_                return iterator.hasNext()__            }__            @Override_            public V next() {_                return iterator.next().value__            }__            @Override_            public void remove() {_                iterator.remove()__            }_        }__    };an,lru,sequencing,of,the,values,in,the,cache,this,sequence,is,not,protected,from,mutations,to,the,cache,except,for,link,iterator,remove,the,result,of,iteration,under,any,other,mutation,is,undefined,return,an,lru,ordered,link,iterable,over,the,values,in,the,cache;public,iterable,v,values,return,new,iterator,v,private,cache,iterator,iterator,new,cache,iterator,head,override,public,boolean,has,next,return,iterator,has,next,override,public,v,next,return,iterator,next,value,override,public,void,remove,iterator,remove
Cache -> public Iterable<V> values();1540583181;An LRU sequencing of the values in the cache. This sequence is not protected from mutations_to the cache (except for {@link Iterator#remove()}. The result of iteration under any other mutation is_undefined.__@return an LRU-ordered {@link Iterable} over the values in the cache;public Iterable<V> values() {_        return () -> new Iterator<V>() {_            private CacheIterator iterator = new CacheIterator(head)___            @Override_            public boolean hasNext() {_                return iterator.hasNext()__            }__            @Override_            public V next() {_                return iterator.next().value__            }__            @Override_            public void remove() {_                iterator.remove()__            }_        }__    };an,lru,sequencing,of,the,values,in,the,cache,this,sequence,is,not,protected,from,mutations,to,the,cache,except,for,link,iterator,remove,the,result,of,iteration,under,any,other,mutation,is,undefined,return,an,lru,ordered,link,iterable,over,the,values,in,the,cache;public,iterable,v,values,return,new,iterator,v,private,cache,iterator,iterator,new,cache,iterator,head,override,public,boolean,has,next,return,iterator,has,next,override,public,v,next,return,iterator,next,value,override,public,void,remove,iterator,remove
Cache -> public void invalidate(K key);1524684173;Invalidate the association for the specified key. A removal notification will be issued for invalidated_entries with {@link org.elasticsearch.common.cache.RemovalNotification.RemovalReason} INVALIDATED.__@param key the key whose mapping is to be invalidated from the cache;public void invalidate(K key) {_        CacheSegment<K, V> segment = getCacheSegment(key)__        Entry<K, V> entry = segment.remove(key)__        if (entry != null) {_            try (ReleasableLock ignored = lruLock.acquire()) {_                delete(entry, RemovalNotification.RemovalReason.INVALIDATED)__            }_        }_    };invalidate,the,association,for,the,specified,key,a,removal,notification,will,be,issued,for,invalidated,entries,with,link,org,elasticsearch,common,cache,removal,notification,removal,reason,invalidated,param,key,the,key,whose,mapping,is,to,be,invalidated,from,the,cache;public,void,invalidate,k,key,cache,segment,k,v,segment,get,cache,segment,key,entry,k,v,entry,segment,remove,key,if,entry,null,try,releasable,lock,ignored,lru,lock,acquire,delete,entry,removal,notification,removal,reason,invalidated
Cache -> public void invalidate(K key);1526029249;Invalidate the association for the specified key. A removal notification will be issued for invalidated_entries with {@link org.elasticsearch.common.cache.RemovalNotification.RemovalReason} INVALIDATED.__@param key the key whose mapping is to be invalidated from the cache;public void invalidate(K key) {_        CacheSegment<K, V> segment = getCacheSegment(key)__        segment.remove(key, f -> {_            try {_                Entry<K, V> entry = f.get()__                try (ReleasableLock ignored = lruLock.acquire()) {_                    delete(entry, RemovalNotification.RemovalReason.INVALIDATED)__                }_            } catch (ExecutionException e) {_                _            } catch (InterruptedException e) {_                throw new IllegalStateException(e)__            }_        })__    };invalidate,the,association,for,the,specified,key,a,removal,notification,will,be,issued,for,invalidated,entries,with,link,org,elasticsearch,common,cache,removal,notification,removal,reason,invalidated,param,key,the,key,whose,mapping,is,to,be,invalidated,from,the,cache;public,void,invalidate,k,key,cache,segment,k,v,segment,get,cache,segment,key,segment,remove,key,f,try,entry,k,v,entry,f,get,try,releasable,lock,ignored,lru,lock,acquire,delete,entry,removal,notification,removal,reason,invalidated,catch,execution,exception,e,catch,interrupted,exception,e,throw,new,illegal,state,exception,e
Cache -> public void invalidate(K key);1527207653;Invalidate the association for the specified key. A removal notification will be issued for invalidated_entries with {@link org.elasticsearch.common.cache.RemovalNotification.RemovalReason} INVALIDATED.__@param key the key whose mapping is to be invalidated from the cache;public void invalidate(K key) {_        CacheSegment<K, V> segment = getCacheSegment(key)__        segment.remove(key, invalidationConsumer)__    };invalidate,the,association,for,the,specified,key,a,removal,notification,will,be,issued,for,invalidated,entries,with,link,org,elasticsearch,common,cache,removal,notification,removal,reason,invalidated,param,key,the,key,whose,mapping,is,to,be,invalidated,from,the,cache;public,void,invalidate,k,key,cache,segment,k,v,segment,get,cache,segment,key,segment,remove,key,invalidation,consumer
Cache -> public void invalidate(K key);1540583181;Invalidate the association for the specified key. A removal notification will be issued for invalidated_entries with {@link org.elasticsearch.common.cache.RemovalNotification.RemovalReason} INVALIDATED.__@param key the key whose mapping is to be invalidated from the cache;public void invalidate(K key) {_        CacheSegment<K, V> segment = getCacheSegment(key)__        segment.remove(key, invalidationConsumer)__    };invalidate,the,association,for,the,specified,key,a,removal,notification,will,be,issued,for,invalidated,entries,with,link,org,elasticsearch,common,cache,removal,notification,removal,reason,invalidated,param,key,the,key,whose,mapping,is,to,be,invalidated,from,the,cache;public,void,invalidate,k,key,cache,segment,k,v,segment,get,cache,segment,key,segment,remove,key,invalidation,consumer
Cache -> public V get(K key);1524684173;Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key.__@param key the key whose associated value is to be returned_@return the value to which the specified key is mapped, or null if this map contains no mapping for the key;public V get(K key) {_        return get(key, now(), e -> {})__    };returns,the,value,to,which,the,specified,key,is,mapped,or,null,if,this,map,contains,no,mapping,for,the,key,param,key,the,key,whose,associated,value,is,to,be,returned,return,the,value,to,which,the,specified,key,is,mapped,or,null,if,this,map,contains,no,mapping,for,the,key;public,v,get,k,key,return,get,key,now,e
Cache -> public V get(K key);1526029249;Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key.__@param key the key whose associated value is to be returned_@return the value to which the specified key is mapped, or null if this map contains no mapping for the key;public V get(K key) {_        return get(key, now(), e -> {})__    };returns,the,value,to,which,the,specified,key,is,mapped,or,null,if,this,map,contains,no,mapping,for,the,key,param,key,the,key,whose,associated,value,is,to,be,returned,return,the,value,to,which,the,specified,key,is,mapped,or,null,if,this,map,contains,no,mapping,for,the,key;public,v,get,k,key,return,get,key,now,e
Cache -> public V get(K key);1527207653;Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key.__@param key the key whose associated value is to be returned_@return the value to which the specified key is mapped, or null if this map contains no mapping for the key;public V get(K key) {_        return get(key, now(), e -> {})__    };returns,the,value,to,which,the,specified,key,is,mapped,or,null,if,this,map,contains,no,mapping,for,the,key,param,key,the,key,whose,associated,value,is,to,be,returned,return,the,value,to,which,the,specified,key,is,mapped,or,null,if,this,map,contains,no,mapping,for,the,key;public,v,get,k,key,return,get,key,now,e
Cache -> public V get(K key);1540583181;Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key.__@param key the key whose associated value is to be returned_@return the value to which the specified key is mapped, or null if this map contains no mapping for the key;public V get(K key) {_        return get(key, now(), e -> {})__    };returns,the,value,to,which,the,specified,key,is,mapped,or,null,if,this,map,contains,no,mapping,for,the,key,param,key,the,key,whose,associated,value,is,to,be,returned,return,the,value,to,which,the,specified,key,is,mapped,or,null,if,this,map,contains,no,mapping,for,the,key;public,v,get,k,key,return,get,key,now,e
Cache -> public CacheStats stats();1524684173;The cache statistics tracking hits, misses and evictions. These are taken on a best-effort basis meaning that_they could be out-of-date mid-flight.__@return the current cache statistics;public CacheStats stats() {_        long hits = 0__        long misses = 0__        long evictions = 0__        for (int i = 0_ i < segments.length_ i++) {_            hits += segments[i].segmentStats.hits.longValue()__            misses += segments[i].segmentStats.misses.longValue()__            evictions += segments[i].segmentStats.evictions.longValue()__        }_        return new CacheStats(hits, misses, evictions)__    };the,cache,statistics,tracking,hits,misses,and,evictions,these,are,taken,on,a,best,effort,basis,meaning,that,they,could,be,out,of,date,mid,flight,return,the,current,cache,statistics;public,cache,stats,stats,long,hits,0,long,misses,0,long,evictions,0,for,int,i,0,i,segments,length,i,hits,segments,i,segment,stats,hits,long,value,misses,segments,i,segment,stats,misses,long,value,evictions,segments,i,segment,stats,evictions,long,value,return,new,cache,stats,hits,misses,evictions
Cache -> public CacheStats stats();1526029249;The cache statistics tracking hits, misses and evictions. These are taken on a best-effort basis meaning that_they could be out-of-date mid-flight.__@return the current cache statistics;public CacheStats stats() {_        long hits = 0__        long misses = 0__        long evictions = 0__        for (int i = 0_ i < segments.length_ i++) {_            hits += segments[i].segmentStats.hits.longValue()__            misses += segments[i].segmentStats.misses.longValue()__            evictions += segments[i].segmentStats.evictions.longValue()__        }_        return new CacheStats(hits, misses, evictions)__    };the,cache,statistics,tracking,hits,misses,and,evictions,these,are,taken,on,a,best,effort,basis,meaning,that,they,could,be,out,of,date,mid,flight,return,the,current,cache,statistics;public,cache,stats,stats,long,hits,0,long,misses,0,long,evictions,0,for,int,i,0,i,segments,length,i,hits,segments,i,segment,stats,hits,long,value,misses,segments,i,segment,stats,misses,long,value,evictions,segments,i,segment,stats,evictions,long,value,return,new,cache,stats,hits,misses,evictions
Cache -> public CacheStats stats();1527207653;The cache statistics tracking hits, misses and evictions. These are taken on a best-effort basis meaning that_they could be out-of-date mid-flight.__@return the current cache statistics;public CacheStats stats() {_        long hits = 0__        long misses = 0__        long evictions = 0__        for (int i = 0_ i < segments.length_ i++) {_            hits += segments[i].segmentStats.hits.longValue()__            misses += segments[i].segmentStats.misses.longValue()__            evictions += segments[i].segmentStats.evictions.longValue()__        }_        return new CacheStats(hits, misses, evictions)__    };the,cache,statistics,tracking,hits,misses,and,evictions,these,are,taken,on,a,best,effort,basis,meaning,that,they,could,be,out,of,date,mid,flight,return,the,current,cache,statistics;public,cache,stats,stats,long,hits,0,long,misses,0,long,evictions,0,for,int,i,0,i,segments,length,i,hits,segments,i,segment,stats,hits,long,value,misses,segments,i,segment,stats,misses,long,value,evictions,segments,i,segment,stats,evictions,long,value,return,new,cache,stats,hits,misses,evictions
Cache -> public CacheStats stats();1540583181;The cache statistics tracking hits, misses and evictions. These are taken on a best-effort basis meaning that_they could be out-of-date mid-flight.__@return the current cache statistics;public CacheStats stats() {_        long hits = 0__        long misses = 0__        long evictions = 0__        for (int i = 0_ i < segments.length_ i++) {_            hits += segments[i].segmentStats.hits.longValue()__            misses += segments[i].segmentStats.misses.longValue()__            evictions += segments[i].segmentStats.evictions.longValue()__        }_        return new CacheStats(hits, misses, evictions)__    };the,cache,statistics,tracking,hits,misses,and,evictions,these,are,taken,on,a,best,effort,basis,meaning,that,they,could,be,out,of,date,mid,flight,return,the,current,cache,statistics;public,cache,stats,stats,long,hits,0,long,misses,0,long,evictions,0,for,int,i,0,i,segments,length,i,hits,segments,i,segment,stats,hits,long,value,misses,segments,i,segment,stats,misses,long,value,evictions,segments,i,segment,stats,evictions,long,value,return,new,cache,stats,hits,misses,evictions
Cache -> public V computeIfAbsent(K key, CacheLoader<K, V> loader) throws ExecutionException;1524684173;If the specified key is not already associated with a value (or is mapped to null), attempts to compute its_value using the given mapping function and enters it into this map unless null. The load method for a given key_will be invoked at most once.__Use of different {@link CacheLoader} implementations on the same key concurrently may result in only the first_loader function being called and the second will be returned the result provided by the first including any exceptions_thrown during the execution of the first.__@param key    the key whose associated value is to be returned or computed for if non-existent_@param loader the function to compute a value given a key_@return the current (existing or computed) non-null value associated with the specified key_@throws ExecutionException thrown if loader throws an exception or returns a null value;public V computeIfAbsent(K key, CacheLoader<K, V> loader) throws ExecutionException {_        long now = now()__        _        V value = get(key, now, e -> {_            try (ReleasableLock ignored = lruLock.acquire()) {_                evictEntry(e)__            }_        })__        if (value == null) {_            _            _            _            _            _            CacheSegment<K, V> segment = getCacheSegment(key)__            CompletableFuture<Entry<K, V>> future__            CompletableFuture<Entry<K, V>> completableFuture = new CompletableFuture<>()___            try (ReleasableLock ignored = segment.writeLock.acquire()) {_                future = segment.map.putIfAbsent(key, completableFuture)__            }__            BiFunction<? super Entry<K, V>, Throwable, ? extends V> handler = (ok, ex) -> {_                if (ok != null) {_                    try (ReleasableLock ignored = lruLock.acquire()) {_                        promote(ok, now)__                    }_                    return ok.value__                } else {_                    try (ReleasableLock ignored = segment.writeLock.acquire()) {_                        CompletableFuture<Entry<K, V>> sanity = segment.map.get(key)__                        if (sanity != null && sanity.isCompletedExceptionally()) {_                            segment.map.remove(key)__                        }_                    }_                    return null__                }_            }___            CompletableFuture<V> completableValue__            if (future == null) {_                future = completableFuture__                completableValue = future.handle(handler)__                V loaded__                try {_                    loaded = loader.load(key)__                } catch (Exception e) {_                    future.completeExceptionally(e)__                    throw new ExecutionException(e)__                }_                if (loaded == null) {_                    NullPointerException npe = new NullPointerException("loader returned a null value")__                    future.completeExceptionally(npe)__                    throw new ExecutionException(npe)__                } else {_                    future.complete(new Entry<>(key, loaded, now))__                }_            } else {_                completableValue = future.handle(handler)__            }__            try {_                value = completableValue.get()__                _                if (future.isCompletedExceptionally()) {_                    future.get()_ _                    throw new IllegalStateException("the future was completed exceptionally but no exception was thrown")__                }_            } catch (InterruptedException e) {_                throw new IllegalStateException(e)__            }_        }_        return value__    };if,the,specified,key,is,not,already,associated,with,a,value,or,is,mapped,to,null,attempts,to,compute,its,value,using,the,given,mapping,function,and,enters,it,into,this,map,unless,null,the,load,method,for,a,given,key,will,be,invoked,at,most,once,use,of,different,link,cache,loader,implementations,on,the,same,key,concurrently,may,result,in,only,the,first,loader,function,being,called,and,the,second,will,be,returned,the,result,provided,by,the,first,including,any,exceptions,thrown,during,the,execution,of,the,first,param,key,the,key,whose,associated,value,is,to,be,returned,or,computed,for,if,non,existent,param,loader,the,function,to,compute,a,value,given,a,key,return,the,current,existing,or,computed,non,null,value,associated,with,the,specified,key,throws,execution,exception,thrown,if,loader,throws,an,exception,or,returns,a,null,value;public,v,compute,if,absent,k,key,cache,loader,k,v,loader,throws,execution,exception,long,now,now,v,value,get,key,now,e,try,releasable,lock,ignored,lru,lock,acquire,evict,entry,e,if,value,null,cache,segment,k,v,segment,get,cache,segment,key,completable,future,entry,k,v,future,completable,future,entry,k,v,completable,future,new,completable,future,try,releasable,lock,ignored,segment,write,lock,acquire,future,segment,map,put,if,absent,key,completable,future,bi,function,super,entry,k,v,throwable,extends,v,handler,ok,ex,if,ok,null,try,releasable,lock,ignored,lru,lock,acquire,promote,ok,now,return,ok,value,else,try,releasable,lock,ignored,segment,write,lock,acquire,completable,future,entry,k,v,sanity,segment,map,get,key,if,sanity,null,sanity,is,completed,exceptionally,segment,map,remove,key,return,null,completable,future,v,completable,value,if,future,null,future,completable,future,completable,value,future,handle,handler,v,loaded,try,loaded,loader,load,key,catch,exception,e,future,complete,exceptionally,e,throw,new,execution,exception,e,if,loaded,null,null,pointer,exception,npe,new,null,pointer,exception,loader,returned,a,null,value,future,complete,exceptionally,npe,throw,new,execution,exception,npe,else,future,complete,new,entry,key,loaded,now,else,completable,value,future,handle,handler,try,value,completable,value,get,if,future,is,completed,exceptionally,future,get,throw,new,illegal,state,exception,the,future,was,completed,exceptionally,but,no,exception,was,thrown,catch,interrupted,exception,e,throw,new,illegal,state,exception,e,return,value
Cache -> public V computeIfAbsent(K key, CacheLoader<K, V> loader) throws ExecutionException;1526029249;If the specified key is not already associated with a value (or is mapped to null), attempts to compute its_value using the given mapping function and enters it into this map unless null. The load method for a given key_will be invoked at most once.__Use of different {@link CacheLoader} implementations on the same key concurrently may result in only the first_loader function being called and the second will be returned the result provided by the first including any exceptions_thrown during the execution of the first.__@param key    the key whose associated value is to be returned or computed for if non-existent_@param loader the function to compute a value given a key_@return the current (existing or computed) non-null value associated with the specified key_@throws ExecutionException thrown if loader throws an exception or returns a null value;public V computeIfAbsent(K key, CacheLoader<K, V> loader) throws ExecutionException {_        long now = now()__        _        V value = get(key, now, e -> {_            try (ReleasableLock ignored = lruLock.acquire()) {_                evictEntry(e)__            }_        })__        if (value == null) {_            _            _            _            _            _            CacheSegment<K, V> segment = getCacheSegment(key)__            CompletableFuture<Entry<K, V>> future__            CompletableFuture<Entry<K, V>> completableFuture = new CompletableFuture<>()___            try (ReleasableLock ignored = segment.writeLock.acquire()) {_                future = segment.map.putIfAbsent(key, completableFuture)__            }__            BiFunction<? super Entry<K, V>, Throwable, ? extends V> handler = (ok, ex) -> {_                if (ok != null) {_                    try (ReleasableLock ignored = lruLock.acquire()) {_                        promote(ok, now)__                    }_                    return ok.value__                } else {_                    try (ReleasableLock ignored = segment.writeLock.acquire()) {_                        CompletableFuture<Entry<K, V>> sanity = segment.map.get(key)__                        if (sanity != null && sanity.isCompletedExceptionally()) {_                            segment.map.remove(key)__                        }_                    }_                    return null__                }_            }___            CompletableFuture<V> completableValue__            if (future == null) {_                future = completableFuture__                completableValue = future.handle(handler)__                V loaded__                try {_                    loaded = loader.load(key)__                } catch (Exception e) {_                    future.completeExceptionally(e)__                    throw new ExecutionException(e)__                }_                if (loaded == null) {_                    NullPointerException npe = new NullPointerException("loader returned a null value")__                    future.completeExceptionally(npe)__                    throw new ExecutionException(npe)__                } else {_                    future.complete(new Entry<>(key, loaded, now))__                }_            } else {_                completableValue = future.handle(handler)__            }__            try {_                value = completableValue.get()__                _                if (future.isCompletedExceptionally()) {_                    future.get()_ _                    throw new IllegalStateException("the future was completed exceptionally but no exception was thrown")__                }_            } catch (InterruptedException e) {_                throw new IllegalStateException(e)__            }_        }_        return value__    };if,the,specified,key,is,not,already,associated,with,a,value,or,is,mapped,to,null,attempts,to,compute,its,value,using,the,given,mapping,function,and,enters,it,into,this,map,unless,null,the,load,method,for,a,given,key,will,be,invoked,at,most,once,use,of,different,link,cache,loader,implementations,on,the,same,key,concurrently,may,result,in,only,the,first,loader,function,being,called,and,the,second,will,be,returned,the,result,provided,by,the,first,including,any,exceptions,thrown,during,the,execution,of,the,first,param,key,the,key,whose,associated,value,is,to,be,returned,or,computed,for,if,non,existent,param,loader,the,function,to,compute,a,value,given,a,key,return,the,current,existing,or,computed,non,null,value,associated,with,the,specified,key,throws,execution,exception,thrown,if,loader,throws,an,exception,or,returns,a,null,value;public,v,compute,if,absent,k,key,cache,loader,k,v,loader,throws,execution,exception,long,now,now,v,value,get,key,now,e,try,releasable,lock,ignored,lru,lock,acquire,evict,entry,e,if,value,null,cache,segment,k,v,segment,get,cache,segment,key,completable,future,entry,k,v,future,completable,future,entry,k,v,completable,future,new,completable,future,try,releasable,lock,ignored,segment,write,lock,acquire,future,segment,map,put,if,absent,key,completable,future,bi,function,super,entry,k,v,throwable,extends,v,handler,ok,ex,if,ok,null,try,releasable,lock,ignored,lru,lock,acquire,promote,ok,now,return,ok,value,else,try,releasable,lock,ignored,segment,write,lock,acquire,completable,future,entry,k,v,sanity,segment,map,get,key,if,sanity,null,sanity,is,completed,exceptionally,segment,map,remove,key,return,null,completable,future,v,completable,value,if,future,null,future,completable,future,completable,value,future,handle,handler,v,loaded,try,loaded,loader,load,key,catch,exception,e,future,complete,exceptionally,e,throw,new,execution,exception,e,if,loaded,null,null,pointer,exception,npe,new,null,pointer,exception,loader,returned,a,null,value,future,complete,exceptionally,npe,throw,new,execution,exception,npe,else,future,complete,new,entry,key,loaded,now,else,completable,value,future,handle,handler,try,value,completable,value,get,if,future,is,completed,exceptionally,future,get,throw,new,illegal,state,exception,the,future,was,completed,exceptionally,but,no,exception,was,thrown,catch,interrupted,exception,e,throw,new,illegal,state,exception,e,return,value
Cache -> public V computeIfAbsent(K key, CacheLoader<K, V> loader) throws ExecutionException;1527207653;If the specified key is not already associated with a value (or is mapped to null), attempts to compute its_value using the given mapping function and enters it into this map unless null. The load method for a given key_will be invoked at most once.__Use of different {@link CacheLoader} implementations on the same key concurrently may result in only the first_loader function being called and the second will be returned the result provided by the first including any exceptions_thrown during the execution of the first.__@param key    the key whose associated value is to be returned or computed for if non-existent_@param loader the function to compute a value given a key_@return the current (existing or computed) non-null value associated with the specified key_@throws ExecutionException thrown if loader throws an exception or returns a null value;public V computeIfAbsent(K key, CacheLoader<K, V> loader) throws ExecutionException {_        long now = now()__        _        V value = get(key, now, e -> {_            try (ReleasableLock ignored = lruLock.acquire()) {_                evictEntry(e)__            }_        })__        if (value == null) {_            _            _            _            _            _            CacheSegment<K, V> segment = getCacheSegment(key)__            CompletableFuture<Entry<K, V>> future__            CompletableFuture<Entry<K, V>> completableFuture = new CompletableFuture<>()___            try (ReleasableLock ignored = segment.writeLock.acquire()) {_                future = segment.map.putIfAbsent(key, completableFuture)__            }__            BiFunction<? super Entry<K, V>, Throwable, ? extends V> handler = (ok, ex) -> {_                if (ok != null) {_                    try (ReleasableLock ignored = lruLock.acquire()) {_                        promote(ok, now)__                    }_                    return ok.value__                } else {_                    try (ReleasableLock ignored = segment.writeLock.acquire()) {_                        CompletableFuture<Entry<K, V>> sanity = segment.map.get(key)__                        if (sanity != null && sanity.isCompletedExceptionally()) {_                            segment.map.remove(key)__                        }_                    }_                    return null__                }_            }___            CompletableFuture<V> completableValue__            if (future == null) {_                future = completableFuture__                completableValue = future.handle(handler)__                V loaded__                try {_                    loaded = loader.load(key)__                } catch (Exception e) {_                    future.completeExceptionally(e)__                    throw new ExecutionException(e)__                }_                if (loaded == null) {_                    NullPointerException npe = new NullPointerException("loader returned a null value")__                    future.completeExceptionally(npe)__                    throw new ExecutionException(npe)__                } else {_                    future.complete(new Entry<>(key, loaded, now))__                }_            } else {_                completableValue = future.handle(handler)__            }__            try {_                value = completableValue.get()__                _                if (future.isCompletedExceptionally()) {_                    future.get()_ _                    throw new IllegalStateException("the future was completed exceptionally but no exception was thrown")__                }_            } catch (InterruptedException e) {_                throw new IllegalStateException(e)__            }_        }_        return value__    };if,the,specified,key,is,not,already,associated,with,a,value,or,is,mapped,to,null,attempts,to,compute,its,value,using,the,given,mapping,function,and,enters,it,into,this,map,unless,null,the,load,method,for,a,given,key,will,be,invoked,at,most,once,use,of,different,link,cache,loader,implementations,on,the,same,key,concurrently,may,result,in,only,the,first,loader,function,being,called,and,the,second,will,be,returned,the,result,provided,by,the,first,including,any,exceptions,thrown,during,the,execution,of,the,first,param,key,the,key,whose,associated,value,is,to,be,returned,or,computed,for,if,non,existent,param,loader,the,function,to,compute,a,value,given,a,key,return,the,current,existing,or,computed,non,null,value,associated,with,the,specified,key,throws,execution,exception,thrown,if,loader,throws,an,exception,or,returns,a,null,value;public,v,compute,if,absent,k,key,cache,loader,k,v,loader,throws,execution,exception,long,now,now,v,value,get,key,now,e,try,releasable,lock,ignored,lru,lock,acquire,evict,entry,e,if,value,null,cache,segment,k,v,segment,get,cache,segment,key,completable,future,entry,k,v,future,completable,future,entry,k,v,completable,future,new,completable,future,try,releasable,lock,ignored,segment,write,lock,acquire,future,segment,map,put,if,absent,key,completable,future,bi,function,super,entry,k,v,throwable,extends,v,handler,ok,ex,if,ok,null,try,releasable,lock,ignored,lru,lock,acquire,promote,ok,now,return,ok,value,else,try,releasable,lock,ignored,segment,write,lock,acquire,completable,future,entry,k,v,sanity,segment,map,get,key,if,sanity,null,sanity,is,completed,exceptionally,segment,map,remove,key,return,null,completable,future,v,completable,value,if,future,null,future,completable,future,completable,value,future,handle,handler,v,loaded,try,loaded,loader,load,key,catch,exception,e,future,complete,exceptionally,e,throw,new,execution,exception,e,if,loaded,null,null,pointer,exception,npe,new,null,pointer,exception,loader,returned,a,null,value,future,complete,exceptionally,npe,throw,new,execution,exception,npe,else,future,complete,new,entry,key,loaded,now,else,completable,value,future,handle,handler,try,value,completable,value,get,if,future,is,completed,exceptionally,future,get,throw,new,illegal,state,exception,the,future,was,completed,exceptionally,but,no,exception,was,thrown,catch,interrupted,exception,e,throw,new,illegal,state,exception,e,return,value
Cache -> public V computeIfAbsent(K key, CacheLoader<K, V> loader) throws ExecutionException;1540583181;If the specified key is not already associated with a value (or is mapped to null), attempts to compute its_value using the given mapping function and enters it into this map unless null. The load method for a given key_will be invoked at most once.__Use of different {@link CacheLoader} implementations on the same key concurrently may result in only the first_loader function being called and the second will be returned the result provided by the first including any exceptions_thrown during the execution of the first.__@param key    the key whose associated value is to be returned or computed for if non-existent_@param loader the function to compute a value given a key_@return the current (existing or computed) non-null value associated with the specified key_@throws ExecutionException thrown if loader throws an exception or returns a null value;public V computeIfAbsent(K key, CacheLoader<K, V> loader) throws ExecutionException {_        long now = now()__        _        V value = get(key, now, e -> {_            try (ReleasableLock ignored = lruLock.acquire()) {_                evictEntry(e)__            }_        })__        if (value == null) {_            _            _            _            _            _            CacheSegment<K, V> segment = getCacheSegment(key)__            CompletableFuture<Entry<K, V>> future__            CompletableFuture<Entry<K, V>> completableFuture = new CompletableFuture<>()___            try (ReleasableLock ignored = segment.writeLock.acquire()) {_                future = segment.map.putIfAbsent(key, completableFuture)__            }__            BiFunction<? super Entry<K, V>, Throwable, ? extends V> handler = (ok, ex) -> {_                if (ok != null) {_                    try (ReleasableLock ignored = lruLock.acquire()) {_                        promote(ok, now)__                    }_                    return ok.value__                } else {_                    try (ReleasableLock ignored = segment.writeLock.acquire()) {_                        CompletableFuture<Entry<K, V>> sanity = segment.map.get(key)__                        if (sanity != null && sanity.isCompletedExceptionally()) {_                            segment.map.remove(key)__                        }_                    }_                    return null__                }_            }___            CompletableFuture<V> completableValue__            if (future == null) {_                future = completableFuture__                completableValue = future.handle(handler)__                V loaded__                try {_                    loaded = loader.load(key)__                } catch (Exception e) {_                    future.completeExceptionally(e)__                    throw new ExecutionException(e)__                }_                if (loaded == null) {_                    NullPointerException npe = new NullPointerException("loader returned a null value")__                    future.completeExceptionally(npe)__                    throw new ExecutionException(npe)__                } else {_                    future.complete(new Entry<>(key, loaded, now))__                }_            } else {_                completableValue = future.handle(handler)__            }__            try {_                value = completableValue.get()__                _                if (future.isCompletedExceptionally()) {_                    future.get()_ _                    throw new IllegalStateException("the future was completed exceptionally but no exception was thrown")__                }_            } catch (InterruptedException e) {_                throw new IllegalStateException(e)__            }_        }_        return value__    };if,the,specified,key,is,not,already,associated,with,a,value,or,is,mapped,to,null,attempts,to,compute,its,value,using,the,given,mapping,function,and,enters,it,into,this,map,unless,null,the,load,method,for,a,given,key,will,be,invoked,at,most,once,use,of,different,link,cache,loader,implementations,on,the,same,key,concurrently,may,result,in,only,the,first,loader,function,being,called,and,the,second,will,be,returned,the,result,provided,by,the,first,including,any,exceptions,thrown,during,the,execution,of,the,first,param,key,the,key,whose,associated,value,is,to,be,returned,or,computed,for,if,non,existent,param,loader,the,function,to,compute,a,value,given,a,key,return,the,current,existing,or,computed,non,null,value,associated,with,the,specified,key,throws,execution,exception,thrown,if,loader,throws,an,exception,or,returns,a,null,value;public,v,compute,if,absent,k,key,cache,loader,k,v,loader,throws,execution,exception,long,now,now,v,value,get,key,now,e,try,releasable,lock,ignored,lru,lock,acquire,evict,entry,e,if,value,null,cache,segment,k,v,segment,get,cache,segment,key,completable,future,entry,k,v,future,completable,future,entry,k,v,completable,future,new,completable,future,try,releasable,lock,ignored,segment,write,lock,acquire,future,segment,map,put,if,absent,key,completable,future,bi,function,super,entry,k,v,throwable,extends,v,handler,ok,ex,if,ok,null,try,releasable,lock,ignored,lru,lock,acquire,promote,ok,now,return,ok,value,else,try,releasable,lock,ignored,segment,write,lock,acquire,completable,future,entry,k,v,sanity,segment,map,get,key,if,sanity,null,sanity,is,completed,exceptionally,segment,map,remove,key,return,null,completable,future,v,completable,value,if,future,null,future,completable,future,completable,value,future,handle,handler,v,loaded,try,loaded,loader,load,key,catch,exception,e,future,complete,exceptionally,e,throw,new,execution,exception,e,if,loaded,null,null,pointer,exception,npe,new,null,pointer,exception,loader,returned,a,null,value,future,complete,exceptionally,npe,throw,new,execution,exception,npe,else,future,complete,new,entry,key,loaded,now,else,completable,value,future,handle,handler,try,value,completable,value,get,if,future,is,completed,exceptionally,future,get,throw,new,illegal,state,exception,the,future,was,completed,exceptionally,but,no,exception,was,thrown,catch,interrupted,exception,e,throw,new,illegal,state,exception,e,return,value
