commented;modifiers;parameterAmount;loc;comment;code
false;public;3;3;;@Override public void onCache(ShardId shardId, String fieldName, Accountable ramUsage) { }
false;public;4;3;;@Override public void onRemoval(ShardId shardId, String fieldName, boolean wasEvicted, long sizeInBytes) { }
false;public,synchronized;0;13;;public synchronized void clear() {     List<Exception> exceptions = new ArrayList<>(0).     final Collection<IndexFieldDataCache> fieldDataCacheValues = fieldDataCaches.values().     for (IndexFieldDataCache cache : fieldDataCacheValues) {         try {             cache.clear().         } catch (Exception e) {             exceptions.add(e).         }     }     fieldDataCacheValues.clear().     ExceptionsHelper.maybeThrowRuntimeAndSuppress(exceptions). }
false;public,synchronized;1;12;;public synchronized void clearField(final String fieldName) {     List<Exception> exceptions = new ArrayList<>(0).     final IndexFieldDataCache cache = fieldDataCaches.remove(fieldName).     if (cache != null) {         try {             cache.clear(fieldName).         } catch (Exception e) {             exceptions.add(e).         }     }     ExceptionsHelper.maybeThrowRuntimeAndSuppress(exceptions). }
false;public;1;3;;public <IFD extends IndexFieldData<?>> IFD getForField(MappedFieldType fieldType) {     return getForField(fieldType, index().getName()). }
false;public;2;23;;@SuppressWarnings("unchecked") public <IFD extends IndexFieldData<?>> IFD getForField(MappedFieldType fieldType, String fullyQualifiedIndexName) {     final String fieldName = fieldType.name().     IndexFieldData.Builder builder = fieldType.fielddataBuilder(fullyQualifiedIndexName).     IndexFieldDataCache cache.     synchronized (this) {         cache = fieldDataCaches.get(fieldName).         if (cache == null) {             String cacheType = indexSettings.getValue(INDEX_FIELDDATA_CACHE_KEY).             if (FIELDDATA_CACHE_VALUE_NODE.equals(cacheType)) {                 cache = indicesFieldDataCache.buildIndexFieldDataCache(listener, index(), fieldName).             } else if ("none".equals(cacheType)) {                 cache = new IndexFieldDataCache.None().             } else {                 throw new IllegalArgumentException("cache type not supported [" + cacheType + "] for field [" + fieldName + "]").             }             fieldDataCaches.put(fieldName, cache).         }     }     return (IFD) builder.build(indexSettings, fieldType, cache, circuitBreakerService, mapperService). }
true;public;1;9;/**  * Sets a {@link org.elasticsearch.index.fielddata.IndexFieldDataCache.Listener} passed to each {@link IndexFieldData}  * creation to capture onCache and onRemoval events. Setting a listener on this method will override any previously  * set listeners.  * @throws IllegalStateException if the listener is set more than once  */ ;/**  * Sets a {@link org.elasticsearch.index.fielddata.IndexFieldDataCache.Listener} passed to each {@link IndexFieldData}  * creation to capture onCache and onRemoval events. Setting a listener on this method will override any previously  * set listeners.  * @throws IllegalStateException if the listener is set more than once  */ public void setListener(IndexFieldDataCache.Listener listener) {     if (listener == null) {         throw new IllegalArgumentException("listener must not be null").     }     if (this.listener != DEFAULT_NOOP_LISTENER) {         throw new IllegalStateException("can't set listener more than once").     }     this.listener = listener. }
false;public;0;4;;@Override public void close() throws IOException {     clear(). }
