commented;modifiers;parameterAmount;loc;comment;code
false;private,static;2;41;;private static PerThreadIDVersionAndSeqNoLookup[] getLookupState(IndexReader reader, String uidField) throws IOException {     // We cache on the top level     // This means cache entries have a shorter lifetime, maybe as low as 1s with the     // default refresh interval and a steady indexing rate, but on the other hand it     // proved to be cheaper than having to perform a CHM and a TL get for every segment.     // See https://github.com/elastic/elasticsearch/pull/19856.     IndexReader.CacheHelper cacheHelper = reader.getReaderCacheHelper().     CloseableThreadLocal<PerThreadIDVersionAndSeqNoLookup[]> ctl = lookupStates.get(cacheHelper.getKey()).     if (ctl == null) {         // First time we are seeing this reader's core. make a new CTL:         ctl = new CloseableThreadLocal<>().         CloseableThreadLocal<PerThreadIDVersionAndSeqNoLookup[]> other = lookupStates.putIfAbsent(cacheHelper.getKey(), ctl).         if (other == null) {             // Our CTL won, we must remove it when the reader is closed:             cacheHelper.addClosedListener(removeLookupState).         } else {             // Another thread beat us to it: just use their CTL:             ctl = other.         }     }     PerThreadIDVersionAndSeqNoLookup[] lookupState = ctl.get().     if (lookupState == null) {         lookupState = new PerThreadIDVersionAndSeqNoLookup[reader.leaves().size()].         for (LeafReaderContext leaf : reader.leaves()) {             lookupState[leaf.ord] = new PerThreadIDVersionAndSeqNoLookup(leaf.reader(), uidField).         }         ctl.set(lookupState).     }     if (lookupState.length != reader.leaves().size()) {         throw new AssertionError("Mismatched numbers of leaves: " + lookupState.length + " != " + reader.leaves().size()).     }     if (lookupState.length > 0 && Objects.equals(lookupState[0].uidField, uidField) == false) {         throw new AssertionError("Index does not consistently use the same uid field: [" + uidField + "] != [" + lookupState[0].uidField + "]").     }     return lookupState. }
true;public,static;3;15;/**  * Load the internal doc ID and version for the uid from the reader, returning<ul>  * <li>null if the uid wasn't found,  * <li>a doc ID and a version otherwise  * </ul>  */ ;/**  * Load the internal doc ID and version for the uid from the reader, returning<ul>  * <li>null if the uid wasn't found,  * <li>a doc ID and a version otherwise  * </ul>  */ public static DocIdAndVersion loadDocIdAndVersion(IndexReader reader, Term term, boolean loadSeqNo) throws IOException {     PerThreadIDVersionAndSeqNoLookup[] lookups = getLookupState(reader, term.field()).     List<LeafReaderContext> leaves = reader.leaves().     // which are likely to be in the last segments     for (int i = leaves.size() - 1. i >= 0. i--) {         final LeafReaderContext leaf = leaves.get(i).         PerThreadIDVersionAndSeqNoLookup lookup = lookups[leaf.ord].         DocIdAndVersion result = lookup.lookupVersion(term.bytes(), loadSeqNo, leaf).         if (result != null) {             return result.         }     }     return null. }
true;public,static;2;25;/**  * Loads the internal docId and sequence number of the latest copy for a given uid from the provided reader.  * The flag {@link DocIdAndSeqNo#isLive} indicates whether the returned document is live or (soft)deleted.  * This returns {@code null} if no such document matching the given term uid.  */ ;/**  * Loads the internal docId and sequence number of the latest copy for a given uid from the provided reader.  * The flag {@link DocIdAndSeqNo#isLive} indicates whether the returned document is live or (soft)deleted.  * This returns {@code null} if no such document matching the given term uid.  */ public static DocIdAndSeqNo loadDocIdAndSeqNo(IndexReader reader, Term term) throws IOException {     final PerThreadIDVersionAndSeqNoLookup[] lookups = getLookupState(reader, term.field()).     final List<LeafReaderContext> leaves = reader.leaves().     DocIdAndSeqNo latest = null.     // which are likely to be in the last segments     for (int i = leaves.size() - 1. i >= 0. i--) {         final LeafReaderContext leaf = leaves.get(i).         final PerThreadIDVersionAndSeqNoLookup lookup = lookups[leaf.ord].         final DocIdAndSeqNo result = lookup.lookupSeqNo(term.bytes(), leaf).         if (result == null) {             continue.         }         if (result.isLive) {             // The live document must always be the latest copy, thus we can early terminate here.             assert latest == null || latest.seqNo <= result.seqNo : "the live doc does not have the highest seq_no. live_seq_no=" + result.seqNo + " < deleted_seq_no=" + latest.seqNo.             return result.         }         if (latest == null || latest.seqNo < result.seqNo) {             latest = result.         }     }     return latest. }
