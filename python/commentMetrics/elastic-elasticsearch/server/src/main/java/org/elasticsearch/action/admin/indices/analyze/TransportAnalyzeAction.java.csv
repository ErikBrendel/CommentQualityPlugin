# id;timestamp;commentText;codeText;commentWords;codeWords
TransportAnalyzeAction -> private static Map<String, Object> extractExtendedAttributes(TokenStream stream, final Set<String> includeAttributes);1524684173;other attribute extract object._Extracted object group by AttributeClassName__@param stream current TokenStream_@param includeAttributes filtering attributes_@return Map&lt_key value&gt_;private static Map<String, Object> extractExtendedAttributes(TokenStream stream, final Set<String> includeAttributes) {_        final Map<String, Object> extendedAttributes = new TreeMap<>()___        stream.reflectWith((attClass, key, value) -> {_            if (CharTermAttribute.class.isAssignableFrom(attClass)) {_                return__            }_            if (PositionIncrementAttribute.class.isAssignableFrom(attClass)) {_                return__            }_            if (OffsetAttribute.class.isAssignableFrom(attClass)) {_                return__            }_            if (TypeAttribute.class.isAssignableFrom(attClass)) {_                return__            }_            if (includeAttributes == null || includeAttributes.isEmpty() || includeAttributes.contains(key.toLowerCase(Locale.ROOT))) {_                if (value instanceof BytesRef) {_                    final BytesRef p = (BytesRef) value__                    value = p.toString()__                }_                extendedAttributes.put(key, value)__            }_        })___        return extendedAttributes__    };other,attribute,extract,object,extracted,object,group,by,attribute,class,name,param,stream,current,token,stream,param,include,attributes,filtering,attributes,return,map,lt,key,value,gt;private,static,map,string,object,extract,extended,attributes,token,stream,stream,final,set,string,include,attributes,final,map,string,object,extended,attributes,new,tree,map,stream,reflect,with,att,class,key,value,if,char,term,attribute,class,is,assignable,from,att,class,return,if,position,increment,attribute,class,is,assignable,from,att,class,return,if,offset,attribute,class,is,assignable,from,att,class,return,if,type,attribute,class,is,assignable,from,att,class,return,if,include,attributes,null,include,attributes,is,empty,include,attributes,contains,key,to,lower,case,locale,root,if,value,instanceof,bytes,ref,final,bytes,ref,p,bytes,ref,value,value,p,to,string,extended,attributes,put,key,value,return,extended,attributes
TransportAnalyzeAction -> private static Map<String, Object> extractExtendedAttributes(TokenStream stream, final Set<String> includeAttributes);1531937412;other attribute extract object._Extracted object group by AttributeClassName__@param stream current TokenStream_@param includeAttributes filtering attributes_@return Map&lt_key value&gt_;private static Map<String, Object> extractExtendedAttributes(TokenStream stream, final Set<String> includeAttributes) {_        final Map<String, Object> extendedAttributes = new TreeMap<>()___        stream.reflectWith((attClass, key, value) -> {_            if (CharTermAttribute.class.isAssignableFrom(attClass)) {_                return__            }_            if (PositionIncrementAttribute.class.isAssignableFrom(attClass)) {_                return__            }_            if (OffsetAttribute.class.isAssignableFrom(attClass)) {_                return__            }_            if (TypeAttribute.class.isAssignableFrom(attClass)) {_                return__            }_            if (includeAttributes == null || includeAttributes.isEmpty() || includeAttributes.contains(key.toLowerCase(Locale.ROOT))) {_                if (value instanceof BytesRef) {_                    final BytesRef p = (BytesRef) value__                    value = p.toString()__                }_                extendedAttributes.put(key, value)__            }_        })___        return extendedAttributes__    };other,attribute,extract,object,extracted,object,group,by,attribute,class,name,param,stream,current,token,stream,param,include,attributes,filtering,attributes,return,map,lt,key,value,gt;private,static,map,string,object,extract,extended,attributes,token,stream,stream,final,set,string,include,attributes,final,map,string,object,extended,attributes,new,tree,map,stream,reflect,with,att,class,key,value,if,char,term,attribute,class,is,assignable,from,att,class,return,if,position,increment,attribute,class,is,assignable,from,att,class,return,if,offset,attribute,class,is,assignable,from,att,class,return,if,type,attribute,class,is,assignable,from,att,class,return,if,include,attributes,null,include,attributes,is,empty,include,attributes,contains,key,to,lower,case,locale,root,if,value,instanceof,bytes,ref,final,bytes,ref,p,bytes,ref,value,value,p,to,string,extended,attributes,put,key,value,return,extended,attributes
TransportAnalyzeAction -> private static Map<String, Object> extractExtendedAttributes(TokenStream stream, final Set<String> includeAttributes);1537371806;other attribute extract object._Extracted object group by AttributeClassName__@param stream current TokenStream_@param includeAttributes filtering attributes_@return Map&lt_key value&gt_;private static Map<String, Object> extractExtendedAttributes(TokenStream stream, final Set<String> includeAttributes) {_        final Map<String, Object> extendedAttributes = new TreeMap<>()___        stream.reflectWith((attClass, key, value) -> {_            if (CharTermAttribute.class.isAssignableFrom(attClass)) {_                return__            }_            if (PositionIncrementAttribute.class.isAssignableFrom(attClass)) {_                return__            }_            if (OffsetAttribute.class.isAssignableFrom(attClass)) {_                return__            }_            if (TypeAttribute.class.isAssignableFrom(attClass)) {_                return__            }_            if (includeAttributes == null || includeAttributes.isEmpty() || includeAttributes.contains(key.toLowerCase(Locale.ROOT))) {_                if (value instanceof BytesRef) {_                    final BytesRef p = (BytesRef) value__                    value = p.toString()__                }_                extendedAttributes.put(key, value)__            }_        })___        return extendedAttributes__    };other,attribute,extract,object,extracted,object,group,by,attribute,class,name,param,stream,current,token,stream,param,include,attributes,filtering,attributes,return,map,lt,key,value,gt;private,static,map,string,object,extract,extended,attributes,token,stream,stream,final,set,string,include,attributes,final,map,string,object,extended,attributes,new,tree,map,stream,reflect,with,att,class,key,value,if,char,term,attribute,class,is,assignable,from,att,class,return,if,position,increment,attribute,class,is,assignable,from,att,class,return,if,offset,attribute,class,is,assignable,from,att,class,return,if,type,attribute,class,is,assignable,from,att,class,return,if,include,attributes,null,include,attributes,is,empty,include,attributes,contains,key,to,lower,case,locale,root,if,value,instanceof,bytes,ref,final,bytes,ref,p,bytes,ref,value,value,p,to,string,extended,attributes,put,key,value,return,extended,attributes
TransportAnalyzeAction -> private static Map<String, Object> extractExtendedAttributes(TokenStream stream, final Set<String> includeAttributes);1540583181;other attribute extract object._Extracted object group by AttributeClassName__@param stream current TokenStream_@param includeAttributes filtering attributes_@return Map&lt_key value&gt_;private static Map<String, Object> extractExtendedAttributes(TokenStream stream, final Set<String> includeAttributes) {_        final Map<String, Object> extendedAttributes = new TreeMap<>()___        stream.reflectWith((attClass, key, value) -> {_            if (CharTermAttribute.class.isAssignableFrom(attClass)) {_                return__            }_            if (PositionIncrementAttribute.class.isAssignableFrom(attClass)) {_                return__            }_            if (OffsetAttribute.class.isAssignableFrom(attClass)) {_                return__            }_            if (TypeAttribute.class.isAssignableFrom(attClass)) {_                return__            }_            if (includeAttributes == null || includeAttributes.isEmpty() || includeAttributes.contains(key.toLowerCase(Locale.ROOT))) {_                if (value instanceof BytesRef) {_                    final BytesRef p = (BytesRef) value__                    value = p.toString()__                }_                extendedAttributes.put(key, value)__            }_        })___        return extendedAttributes__    };other,attribute,extract,object,extracted,object,group,by,attribute,class,name,param,stream,current,token,stream,param,include,attributes,filtering,attributes,return,map,lt,key,value,gt;private,static,map,string,object,extract,extended,attributes,token,stream,stream,final,set,string,include,attributes,final,map,string,object,extended,attributes,new,tree,map,stream,reflect,with,att,class,key,value,if,char,term,attribute,class,is,assignable,from,att,class,return,if,position,increment,attribute,class,is,assignable,from,att,class,return,if,offset,attribute,class,is,assignable,from,att,class,return,if,type,attribute,class,is,assignable,from,att,class,return,if,include,attributes,null,include,attributes,is,empty,include,attributes,contains,key,to,lower,case,locale,root,if,value,instanceof,bytes,ref,final,bytes,ref,p,bytes,ref,value,value,p,to,string,extended,attributes,put,key,value,return,extended,attributes
TransportAnalyzeAction -> private static Map<String, Object> extractExtendedAttributes(TokenStream stream, final Set<String> includeAttributes);1541008027;other attribute extract object._Extracted object group by AttributeClassName__@param stream current TokenStream_@param includeAttributes filtering attributes_@return Map&lt_key value&gt_;private static Map<String, Object> extractExtendedAttributes(TokenStream stream, final Set<String> includeAttributes) {_        final Map<String, Object> extendedAttributes = new TreeMap<>()___        stream.reflectWith((attClass, key, value) -> {_            if (CharTermAttribute.class.isAssignableFrom(attClass)) {_                return__            }_            if (PositionIncrementAttribute.class.isAssignableFrom(attClass)) {_                return__            }_            if (OffsetAttribute.class.isAssignableFrom(attClass)) {_                return__            }_            if (TypeAttribute.class.isAssignableFrom(attClass)) {_                return__            }_            if (includeAttributes == null || includeAttributes.isEmpty() || includeAttributes.contains(key.toLowerCase(Locale.ROOT))) {_                if (value instanceof BytesRef) {_                    final BytesRef p = (BytesRef) value__                    value = p.toString()__                }_                extendedAttributes.put(key, value)__            }_        })___        return extendedAttributes__    };other,attribute,extract,object,extracted,object,group,by,attribute,class,name,param,stream,current,token,stream,param,include,attributes,filtering,attributes,return,map,lt,key,value,gt;private,static,map,string,object,extract,extended,attributes,token,stream,stream,final,set,string,include,attributes,final,map,string,object,extended,attributes,new,tree,map,stream,reflect,with,att,class,key,value,if,char,term,attribute,class,is,assignable,from,att,class,return,if,position,increment,attribute,class,is,assignable,from,att,class,return,if,offset,attribute,class,is,assignable,from,att,class,return,if,type,attribute,class,is,assignable,from,att,class,return,if,include,attributes,null,include,attributes,is,empty,include,attributes,contains,key,to,lower,case,locale,root,if,value,instanceof,bytes,ref,final,bytes,ref,p,bytes,ref,value,value,p,to,string,extended,attributes,put,key,value,return,extended,attributes
TransportAnalyzeAction -> private static Map<String, Object> extractExtendedAttributes(TokenStream stream, final Set<String> includeAttributes);1541419698;other attribute extract object._Extracted object group by AttributeClassName__@param stream current TokenStream_@param includeAttributes filtering attributes_@return Map&lt_key value&gt_;private static Map<String, Object> extractExtendedAttributes(TokenStream stream, final Set<String> includeAttributes) {_        final Map<String, Object> extendedAttributes = new TreeMap<>()___        stream.reflectWith((attClass, key, value) -> {_            if (CharTermAttribute.class.isAssignableFrom(attClass)) {_                return__            }_            if (PositionIncrementAttribute.class.isAssignableFrom(attClass)) {_                return__            }_            if (OffsetAttribute.class.isAssignableFrom(attClass)) {_                return__            }_            if (TypeAttribute.class.isAssignableFrom(attClass)) {_                return__            }_            if (includeAttributes == null || includeAttributes.isEmpty() || includeAttributes.contains(key.toLowerCase(Locale.ROOT))) {_                if (value instanceof BytesRef) {_                    final BytesRef p = (BytesRef) value__                    value = p.toString()__                }_                extendedAttributes.put(key, value)__            }_        })___        return extendedAttributes__    };other,attribute,extract,object,extracted,object,group,by,attribute,class,name,param,stream,current,token,stream,param,include,attributes,filtering,attributes,return,map,lt,key,value,gt;private,static,map,string,object,extract,extended,attributes,token,stream,stream,final,set,string,include,attributes,final,map,string,object,extended,attributes,new,tree,map,stream,reflect,with,att,class,key,value,if,char,term,attribute,class,is,assignable,from,att,class,return,if,position,increment,attribute,class,is,assignable,from,att,class,return,if,offset,attribute,class,is,assignable,from,att,class,return,if,type,attribute,class,is,assignable,from,att,class,return,if,include,attributes,null,include,attributes,is,empty,include,attributes,contains,key,to,lower,case,locale,root,if,value,instanceof,bytes,ref,final,bytes,ref,p,bytes,ref,value,value,p,to,string,extended,attributes,put,key,value,return,extended,attributes
TransportAnalyzeAction -> private static Map<String, Object> extractExtendedAttributes(TokenStream stream, final Set<String> includeAttributes);1542897779;other attribute extract object._Extracted object group by AttributeClassName__@param stream current TokenStream_@param includeAttributes filtering attributes_@return Map&lt_key value&gt_;private static Map<String, Object> extractExtendedAttributes(TokenStream stream, final Set<String> includeAttributes) {_        final Map<String, Object> extendedAttributes = new TreeMap<>()___        stream.reflectWith((attClass, key, value) -> {_            if (CharTermAttribute.class.isAssignableFrom(attClass)) {_                return__            }_            if (PositionIncrementAttribute.class.isAssignableFrom(attClass)) {_                return__            }_            if (OffsetAttribute.class.isAssignableFrom(attClass)) {_                return__            }_            if (TypeAttribute.class.isAssignableFrom(attClass)) {_                return__            }_            if (includeAttributes == null || includeAttributes.isEmpty() || includeAttributes.contains(key.toLowerCase(Locale.ROOT))) {_                if (value instanceof BytesRef) {_                    final BytesRef p = (BytesRef) value__                    value = p.toString()__                }_                extendedAttributes.put(key, value)__            }_        })___        return extendedAttributes__    };other,attribute,extract,object,extracted,object,group,by,attribute,class,name,param,stream,current,token,stream,param,include,attributes,filtering,attributes,return,map,lt,key,value,gt;private,static,map,string,object,extract,extended,attributes,token,stream,stream,final,set,string,include,attributes,final,map,string,object,extended,attributes,new,tree,map,stream,reflect,with,att,class,key,value,if,char,term,attribute,class,is,assignable,from,att,class,return,if,position,increment,attribute,class,is,assignable,from,att,class,return,if,offset,attribute,class,is,assignable,from,att,class,return,if,type,attribute,class,is,assignable,from,att,class,return,if,include,attributes,null,include,attributes,is,empty,include,attributes,contains,key,to,lower,case,locale,root,if,value,instanceof,bytes,ref,final,bytes,ref,p,bytes,ref,value,value,p,to,string,extended,attributes,put,key,value,return,extended,attributes
