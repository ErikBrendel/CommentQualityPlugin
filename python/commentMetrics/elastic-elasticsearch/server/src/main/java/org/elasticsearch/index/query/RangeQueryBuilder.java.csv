commented;modifiers;parameterAmount;loc;comment;code
false;private;1;5;;private boolean isRelationAllowed(ShapeRelation relation) {     return relation == ShapeRelation.INTERSECTS || relation == ShapeRelation.CONTAINS || relation == ShapeRelation.WITHIN. }
false;protected;1;15;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     out.writeString(this.fieldName).     out.writeGenericValue(this.from).     out.writeGenericValue(this.to).     out.writeBoolean(this.includeLower).     out.writeBoolean(this.includeUpper).     out.writeOptionalZoneId(timeZone).     out.writeOptionalString(format).     String relationString = null.     if (this.relation != null) {         relationString = this.relation.getRelationName().     }     out.writeOptionalString(relationString). }
true;public;0;4;/**  * Get the field name for this query.  */ ;/**  * Get the field name for this query.  */ @Override public String fieldName() {     return this.fieldName. }
true;public;2;5;/**  * The from part of the range query. Null indicates unbounded.  * In case lower bound is assigned to a string, we internally convert it to a {@link BytesRef} because  * in {@link RangeQueryBuilder} field are later parsed as {@link BytesRef} and we need internal representation  * of query to be equal regardless of whether it was created from XContent or via Java API.  */ ;/**  * The from part of the range query. Null indicates unbounded.  * In case lower bound is assigned to a string, we internally convert it to a {@link BytesRef} because  * in {@link RangeQueryBuilder} field are later parsed as {@link BytesRef} and we need internal representation  * of query to be equal regardless of whether it was created from XContent or via Java API.  */ public RangeQueryBuilder from(Object from, boolean includeLower) {     this.from = maybeConvertToBytesRef(from).     this.includeLower = includeLower.     return this. }
true;public;1;3;/**  * The from part of the range query. Null indicates unbounded.  */ ;/**  * The from part of the range query. Null indicates unbounded.  */ public RangeQueryBuilder from(Object from) {     return from(from, this.includeLower). }
true;public;0;3;/**  * Gets the lower range value for this query.  */ ;/**  * Gets the lower range value for this query.  */ public Object from() {     return maybeConvertToString(this.from). }
true;public;1;3;/**  * The from part of the range query. Null indicates unbounded.  */ ;/**  * The from part of the range query. Null indicates unbounded.  */ public RangeQueryBuilder gt(Object from) {     return from(from, false). }
true;public;1;3;/**  * The from part of the range query. Null indicates unbounded.  */ ;/**  * The from part of the range query. Null indicates unbounded.  */ public RangeQueryBuilder gte(Object from) {     return from(from, true). }
true;public;2;5;/**  * The to part of the range query. Null indicates unbounded.  */ ;/**  * The to part of the range query. Null indicates unbounded.  */ public RangeQueryBuilder to(Object to, boolean includeUpper) {     this.to = maybeConvertToBytesRef(to).     this.includeUpper = includeUpper.     return this. }
true;public;1;3;/**  * The to part of the range query. Null indicates unbounded.  */ ;/**  * The to part of the range query. Null indicates unbounded.  */ public RangeQueryBuilder to(Object to) {     return to(to, this.includeUpper). }
true;public;0;3;/**  * Gets the upper range value for this query.  * In case upper bound is assigned to a string, we internally convert it to a {@link BytesRef} because  * in {@link RangeQueryBuilder} field are later parsed as {@link BytesRef} and we need internal representation  * of query to be equal regardless of whether it was created from XContent or via Java API.  */ ;/**  * Gets the upper range value for this query.  * In case upper bound is assigned to a string, we internally convert it to a {@link BytesRef} because  * in {@link RangeQueryBuilder} field are later parsed as {@link BytesRef} and we need internal representation  * of query to be equal regardless of whether it was created from XContent or via Java API.  */ public Object to() {     return maybeConvertToString(this.to). }
true;public;1;3;/**  * The to part of the range query. Null indicates unbounded.  */ ;/**  * The to part of the range query. Null indicates unbounded.  */ public RangeQueryBuilder lt(Object to) {     return to(to, false). }
true;public;1;3;/**  * The to part of the range query. Null indicates unbounded.  */ ;/**  * The to part of the range query. Null indicates unbounded.  */ public RangeQueryBuilder lte(Object to) {     return to(to, true). }
true;public;1;4;/**  * Should the lower bound be included or not. Defaults to {@code true}.  */ ;/**  * Should the lower bound be included or not. Defaults to {@code true}.  */ public RangeQueryBuilder includeLower(boolean includeLower) {     this.includeLower = includeLower.     return this. }
true;public;0;3;/**  * Gets the includeLower flag for this query.  */ ;/**  * Gets the includeLower flag for this query.  */ public boolean includeLower() {     return this.includeLower. }
true;public;1;4;/**  * Should the upper bound be included or not. Defaults to {@code true}.  */ ;/**  * Should the upper bound be included or not. Defaults to {@code true}.  */ public RangeQueryBuilder includeUpper(boolean includeUpper) {     this.includeUpper = includeUpper.     return this. }
true;public;0;3;/**  * Gets the includeUpper flag for this query.  */ ;/**  * Gets the includeUpper flag for this query.  */ public boolean includeUpper() {     return this.includeUpper. }
true;public;1;11;/**  * In case of date field, we can adjust the from/to fields using a timezone  */ ;/**  * In case of date field, we can adjust the from/to fields using a timezone  */ public RangeQueryBuilder timeZone(String timeZone) {     if (timeZone == null) {         throw new IllegalArgumentException("timezone cannot be null").     }     try {         this.timeZone = ZoneId.of(timeZone).     } catch (DateTimeException e) {         throw new IllegalArgumentException(e).     }     return this. }
true;public;0;3;/**  * In case of date field, gets the from/to fields timezone adjustment  */ ;/**  * In case of date field, gets the from/to fields timezone adjustment  */ public String timeZone() {     return this.timeZone == null ? null : this.timeZone.getId(). }
false;;0;3;;ZoneId getDateTimeZone() {     // for testing     return timeZone. }
true;public;1;9;/**  * In case of format field, we can parse the from/to fields using this time format  */ ;/**  * In case of format field, we can parse the from/to fields using this time format  */ public RangeQueryBuilder format(String format) {     if (format == null) {         throw new IllegalArgumentException("format cannot be null").     }     // this just ensure that the pattern is actually valid, no need to keep it here     DateFormatter.forPattern(format).     this.format = format.     return this. }
true;public;0;3;/**  * Gets the format field to parse the from/to fields  */ ;/**  * Gets the format field to parse the from/to fields  */ public String format() {     return format. }
false;;0;6;;DateMathParser getForceDateParser() {     // pkg private for testing     if (Strings.hasText(format)) {         return DateFormatter.forPattern(this.format).toDateMathParser().     }     return null. }
false;public;0;3;;public ShapeRelation relation() {     return this.relation. }
false;public;1;13;;public RangeQueryBuilder relation(String relation) {     if (relation == null) {         throw new IllegalArgumentException("relation cannot be null").     }     this.relation = ShapeRelation.getRelationByName(relation).     if (this.relation == null) {         throw new IllegalArgumentException(relation + " is not a valid relation").     }     if (!isRelationAllowed(this.relation)) {         throw new IllegalArgumentException("[range] query does not support relation [" + relation + "]").     }     return this. }
false;protected;2;21;;@Override protected void doXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject(NAME).     builder.startObject(fieldName).     builder.field(FROM_FIELD.getPreferredName(), maybeConvertToString(this.from)).     builder.field(TO_FIELD.getPreferredName(), maybeConvertToString(this.to)).     builder.field(INCLUDE_LOWER_FIELD.getPreferredName(), includeLower).     builder.field(INCLUDE_UPPER_FIELD.getPreferredName(), includeUpper).     if (timeZone != null) {         builder.field(TIME_ZONE_FIELD.getPreferredName(), timeZone.getId()).     }     if (Strings.hasText(format)) {         builder.field(FORMAT_FIELD.getPreferredName(), format).     }     if (relation != null) {         builder.field(RELATION_FIELD.getPreferredName(), relation.getRelationName()).     }     printBoostAndQueryName(builder).     builder.endObject().     builder.endObject(). }
false;public,static;1;83;;public static RangeQueryBuilder fromXContent(XContentParser parser) throws IOException {     String fieldName = null.     Object from = null.     Object to = null.     boolean includeLower = RangeQueryBuilder.DEFAULT_INCLUDE_LOWER.     boolean includeUpper = RangeQueryBuilder.DEFAULT_INCLUDE_UPPER.     String timeZone = null.     float boost = AbstractQueryBuilder.DEFAULT_BOOST.     String queryName = null.     String format = null.     String relation = null.     String currentFieldName = null.     XContentParser.Token token.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token == XContentParser.Token.START_OBJECT) {             throwParsingExceptionOnMultipleFields(NAME, parser.getTokenLocation(), fieldName, currentFieldName).             fieldName = currentFieldName.             while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {                 if (token == XContentParser.Token.FIELD_NAME) {                     currentFieldName = parser.currentName().                 } else {                     if (FROM_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                         from = maybeConvertToBytesRef(parser.objectBytes()).                     } else if (TO_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                         to = maybeConvertToBytesRef(parser.objectBytes()).                     } else if (INCLUDE_LOWER_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                         includeLower = parser.booleanValue().                     } else if (INCLUDE_UPPER_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                         includeUpper = parser.booleanValue().                     } else if (AbstractQueryBuilder.BOOST_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                         boost = parser.floatValue().                     } else if (GT_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                         from = maybeConvertToBytesRef(parser.objectBytes()).                         includeLower = false.                     } else if (GTE_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                         from = maybeConvertToBytesRef(parser.objectBytes()).                         includeLower = true.                     } else if (LT_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                         to = maybeConvertToBytesRef(parser.objectBytes()).                         includeUpper = false.                     } else if (LTE_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                         to = maybeConvertToBytesRef(parser.objectBytes()).                         includeUpper = true.                     } else if (TIME_ZONE_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                         timeZone = parser.text().                     } else if (FORMAT_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                         format = parser.text().                     } else if (RELATION_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                         relation = parser.text().                     } else if (AbstractQueryBuilder.NAME_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                         queryName = parser.text().                     } else {                         throw new ParsingException(parser.getTokenLocation(), "[range] query does not support [" + currentFieldName + "]").                     }                 }             }         } else if (token.isValue()) {             throw new ParsingException(parser.getTokenLocation(), "[range] query does not support [" + currentFieldName + "]").         }     }     RangeQueryBuilder rangeQuery = new RangeQueryBuilder(fieldName).     rangeQuery.from(from).     rangeQuery.to(to).     rangeQuery.includeLower(includeLower).     rangeQuery.includeUpper(includeUpper).     if (timeZone != null) {         rangeQuery.timeZone(timeZone).     }     rangeQuery.boost(boost).     rangeQuery.queryName(queryName).     if (format != null) {         rangeQuery.format(format).     }     if (relation != null) {         rangeQuery.relation(relation).     }     return rangeQuery. }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
true;protected;1;18;// Overridable for testing only ;// Overridable for testing only protected MappedFieldType.Relation getRelation(QueryRewriteContext queryRewriteContext) throws IOException {     QueryShardContext shardContext = queryRewriteContext.convertToShardContext().     // rewrite so just pretend there is an intersection so that the rewrite is a noop     if (shardContext == null || shardContext.getIndexReader() == null) {         return MappedFieldType.Relation.INTERSECTS.     }     final MapperService mapperService = shardContext.getMapperService().     final MappedFieldType fieldType = mapperService.fullName(fieldName).     if (fieldType == null) {         // no field means we have no values         return MappedFieldType.Relation.DISJOINT.     } else {         DateMathParser dateMathParser = getForceDateParser().         return fieldType.isFieldWithinQuery(shardContext.getIndexReader(), from, to, includeLower, includeUpper, timeZone, dateMathParser, queryRewriteContext).     } }
false;protected;1;33;;@Override protected QueryBuilder doRewrite(QueryRewriteContext queryRewriteContext) throws IOException {     // the pre-processing uses that to pre-process. This can then lead to mismatches at query time.     if (queryRewriteContext.convertNowRangeToMatchAll()) {         if ((from() != null && from().toString().contains("now")) || (to() != null && to().toString().contains("now"))) {             return new MatchAllQueryBuilder().         }     }     final MappedFieldType.Relation relation = getRelation(queryRewriteContext).     switch(relation) {         case DISJOINT:             return new MatchNoneQueryBuilder().         case WITHIN:             if (from != null || to != null || format != null || timeZone != null) {                 RangeQueryBuilder newRangeQuery = new RangeQueryBuilder(fieldName).                 newRangeQuery.from(null).                 newRangeQuery.to(null).                 newRangeQuery.format = null.                 newRangeQuery.timeZone = null.                 return newRangeQuery.             } else {                 return this.             }         case INTERSECTS:             return this.         default:             throw new AssertionError().     } }
false;protected;1;38;;@Override protected Query doToQuery(QueryShardContext context) throws IOException {     if (from == null && to == null) {         /**          * Open bounds on both side, we can rewrite to an exists query          * if the {@link FieldNamesFieldMapper} is enabled.          */         final FieldNamesFieldMapper.FieldNamesFieldType fieldNamesFieldType = (FieldNamesFieldMapper.FieldNamesFieldType) context.getMapperService().fullName(FieldNamesFieldMapper.NAME).         if (fieldNamesFieldType == null) {             return new MatchNoDocsQuery("No mappings yet").         }         // Exists query would fail if the fieldNames field is disabled.         if (fieldNamesFieldType.isEnabled()) {             return ExistsQueryBuilder.newFilter(context, fieldName).         }     }     Query query = null.     MappedFieldType mapper = context.fieldMapper(this.fieldName).     if (mapper != null) {         DateMathParser forcedDateParser = getForceDateParser().         query = mapper.rangeQuery(from, to, includeLower, includeUpper, relation, timeZone, forcedDateParser, context).     } else {         if (timeZone != null) {             throw new QueryShardException(context, "[range] time_zone can not be applied to non unmapped field [" + fieldName + "]").         }     }     if (query == null) {         query = new TermRangeQuery(this.fieldName, BytesRefs.toBytesRef(from), BytesRefs.toBytesRef(to), includeLower, includeUpper).     }     return query. }
false;protected;0;4;;@Override protected int doHashCode() {     return Objects.hash(fieldName, from, to, timeZone, includeLower, includeUpper, format). }
false;protected;1;10;;@Override protected boolean doEquals(RangeQueryBuilder other) {     return Objects.equals(fieldName, other.fieldName) && Objects.equals(from, other.from) && Objects.equals(to, other.to) && Objects.equals(timeZone, other.timeZone) && Objects.equals(includeLower, other.includeLower) && Objects.equals(includeUpper, other.includeUpper) && Objects.equals(format, other.format). }
