# id;timestamp;commentText;codeText;commentWords;codeWords
DanglingIndicesState -> void cleanupAllocatedDangledIndices(MetaData metaData);1524684173;Cleans dangling indices if they are already allocated on the provided meta data.;void cleanupAllocatedDangledIndices(MetaData metaData) {_        for (Index index : danglingIndices.keySet()) {_            final IndexMetaData indexMetaData = metaData.index(index)__            if (indexMetaData != null && indexMetaData.getIndex().getName().equals(index.getName())) {_                if (indexMetaData.getIndex().getUUID().equals(index.getUUID()) == false) {_                    logger.warn("[{}] can not be imported as a dangling index, as there is already another index " +_                        "with the same name but a different uuid. local index will be ignored (but not deleted)", index)__                } else {_                    logger.debug("[{}] no longer dangling (created), removing from dangling list", index)__                }_                danglingIndices.remove(index)__            }_        }_    };cleans,dangling,indices,if,they,are,already,allocated,on,the,provided,meta,data;void,cleanup,allocated,dangled,indices,meta,data,meta,data,for,index,index,dangling,indices,key,set,final,index,meta,data,index,meta,data,meta,data,index,index,if,index,meta,data,null,index,meta,data,get,index,get,name,equals,index,get,name,if,index,meta,data,get,index,get,uuid,equals,index,get,uuid,false,logger,warn,can,not,be,imported,as,a,dangling,index,as,there,is,already,another,index,with,the,same,name,but,a,different,uuid,local,index,will,be,ignored,but,not,deleted,index,else,logger,debug,no,longer,dangling,created,removing,from,dangling,list,index,dangling,indices,remove,index
DanglingIndicesState -> void cleanupAllocatedDangledIndices(MetaData metaData);1541092382;Cleans dangling indices if they are already allocated on the provided meta data.;void cleanupAllocatedDangledIndices(MetaData metaData) {_        for (Index index : danglingIndices.keySet()) {_            final IndexMetaData indexMetaData = metaData.index(index)__            if (indexMetaData != null && indexMetaData.getIndex().getName().equals(index.getName())) {_                if (indexMetaData.getIndex().getUUID().equals(index.getUUID()) == false) {_                    logger.warn("[{}] can not be imported as a dangling index, as there is already another index " +_                        "with the same name but a different uuid. local index will be ignored (but not deleted)", index)__                } else {_                    logger.debug("[{}] no longer dangling (created), removing from dangling list", index)__                }_                danglingIndices.remove(index)__            }_        }_    };cleans,dangling,indices,if,they,are,already,allocated,on,the,provided,meta,data;void,cleanup,allocated,dangled,indices,meta,data,meta,data,for,index,index,dangling,indices,key,set,final,index,meta,data,index,meta,data,meta,data,index,index,if,index,meta,data,null,index,meta,data,get,index,get,name,equals,index,get,name,if,index,meta,data,get,index,get,uuid,equals,index,get,uuid,false,logger,warn,can,not,be,imported,as,a,dangling,index,as,there,is,already,another,index,with,the,same,name,but,a,different,uuid,local,index,will,be,ignored,but,not,deleted,index,else,logger,debug,no,longer,dangling,created,removing,from,dangling,list,index,dangling,indices,remove,index
DanglingIndicesState -> void cleanupAllocatedDangledIndices(MetaData metaData);1542402632;Cleans dangling indices if they are already allocated on the provided meta data.;void cleanupAllocatedDangledIndices(MetaData metaData) {_        for (Index index : danglingIndices.keySet()) {_            final IndexMetaData indexMetaData = metaData.index(index)__            if (indexMetaData != null && indexMetaData.getIndex().getName().equals(index.getName())) {_                if (indexMetaData.getIndex().getUUID().equals(index.getUUID()) == false) {_                    logger.warn("[{}] can not be imported as a dangling index, as there is already another index " +_                        "with the same name but a different uuid. local index will be ignored (but not deleted)", index)__                } else {_                    logger.debug("[{}] no longer dangling (created), removing from dangling list", index)__                }_                danglingIndices.remove(index)__            }_        }_    };cleans,dangling,indices,if,they,are,already,allocated,on,the,provided,meta,data;void,cleanup,allocated,dangled,indices,meta,data,meta,data,for,index,index,dangling,indices,key,set,final,index,meta,data,index,meta,data,meta,data,index,index,if,index,meta,data,null,index,meta,data,get,index,get,name,equals,index,get,name,if,index,meta,data,get,index,get,uuid,equals,index,get,uuid,false,logger,warn,can,not,be,imported,as,a,dangling,index,as,there,is,already,another,index,with,the,same,name,but,a,different,uuid,local,index,will,be,ignored,but,not,deleted,index,else,logger,debug,no,longer,dangling,created,removing,from,dangling,list,index,dangling,indices,remove,index
DanglingIndicesState -> private void allocateDanglingIndices();1524684173;Allocates the provided list of the dangled indices by sending them to the master node_for allocation.;private void allocateDanglingIndices() {_        if (danglingIndices.isEmpty()) {_            return__        }_        try {_            allocateDangledIndices.allocateDangled(Collections.unmodifiableCollection(new ArrayList<>(danglingIndices.values())),_                new LocalAllocateDangledIndices.Listener() {_                    @Override_                    public void onResponse(LocalAllocateDangledIndices.AllocateDangledResponse response) {_                        logger.trace("allocated dangled")__                    }__                    @Override_                    public void onFailure(Throwable e) {_                        logger.info("failed to send allocated dangled", e)__                    }_                }_            )__        } catch (Exception e) {_            logger.warn("failed to send allocate dangled", e)__        }_    };allocates,the,provided,list,of,the,dangled,indices,by,sending,them,to,the,master,node,for,allocation;private,void,allocate,dangling,indices,if,dangling,indices,is,empty,return,try,allocate,dangled,indices,allocate,dangled,collections,unmodifiable,collection,new,array,list,dangling,indices,values,new,local,allocate,dangled,indices,listener,override,public,void,on,response,local,allocate,dangled,indices,allocate,dangled,response,response,logger,trace,allocated,dangled,override,public,void,on,failure,throwable,e,logger,info,failed,to,send,allocated,dangled,e,catch,exception,e,logger,warn,failed,to,send,allocate,dangled,e
DanglingIndicesState -> private void allocateDanglingIndices();1541092382;Allocates the provided list of the dangled indices by sending them to the master node_for allocation.;private void allocateDanglingIndices() {_        if (danglingIndices.isEmpty()) {_            return__        }_        try {_            allocateDangledIndices.allocateDangled(Collections.unmodifiableCollection(new ArrayList<>(danglingIndices.values())),_                new LocalAllocateDangledIndices.Listener() {_                    @Override_                    public void onResponse(LocalAllocateDangledIndices.AllocateDangledResponse response) {_                        logger.trace("allocated dangled")__                    }__                    @Override_                    public void onFailure(Throwable e) {_                        logger.info("failed to send allocated dangled", e)__                    }_                }_            )__        } catch (Exception e) {_            logger.warn("failed to send allocate dangled", e)__        }_    };allocates,the,provided,list,of,the,dangled,indices,by,sending,them,to,the,master,node,for,allocation;private,void,allocate,dangling,indices,if,dangling,indices,is,empty,return,try,allocate,dangled,indices,allocate,dangled,collections,unmodifiable,collection,new,array,list,dangling,indices,values,new,local,allocate,dangled,indices,listener,override,public,void,on,response,local,allocate,dangled,indices,allocate,dangled,response,response,logger,trace,allocated,dangled,override,public,void,on,failure,throwable,e,logger,info,failed,to,send,allocated,dangled,e,catch,exception,e,logger,warn,failed,to,send,allocate,dangled,e
DanglingIndicesState -> private void allocateDanglingIndices();1542402632;Allocates the provided list of the dangled indices by sending them to the master node_for allocation.;private void allocateDanglingIndices() {_        if (danglingIndices.isEmpty()) {_            return__        }_        try {_            allocateDangledIndices.allocateDangled(Collections.unmodifiableCollection(new ArrayList<>(danglingIndices.values())),_                new LocalAllocateDangledIndices.Listener() {_                    @Override_                    public void onResponse(LocalAllocateDangledIndices.AllocateDangledResponse response) {_                        logger.trace("allocated dangled")__                    }__                    @Override_                    public void onFailure(Throwable e) {_                        logger.info("failed to send allocated dangled", e)__                    }_                }_            )__        } catch (Exception e) {_            logger.warn("failed to send allocate dangled", e)__        }_    };allocates,the,provided,list,of,the,dangled,indices,by,sending,them,to,the,master,node,for,allocation;private,void,allocate,dangling,indices,if,dangling,indices,is,empty,return,try,allocate,dangled,indices,allocate,dangled,collections,unmodifiable,collection,new,array,list,dangling,indices,values,new,local,allocate,dangled,indices,listener,override,public,void,on,response,local,allocate,dangled,indices,allocate,dangled,response,response,logger,trace,allocated,dangled,override,public,void,on,failure,throwable,e,logger,info,failed,to,send,allocated,dangled,e,catch,exception,e,logger,warn,failed,to,send,allocate,dangled,e
DanglingIndicesState -> void findNewAndAddDanglingIndices(final MetaData metaData);1524684173;Finds (@{link #findNewAndAddDanglingIndices}) and adds the new dangling indices_to the currently tracked dangling indices.;void findNewAndAddDanglingIndices(final MetaData metaData) {_        danglingIndices.putAll(findNewDanglingIndices(metaData))__    };finds,link,find,new,and,add,dangling,indices,and,adds,the,new,dangling,indices,to,the,currently,tracked,dangling,indices;void,find,new,and,add,dangling,indices,final,meta,data,meta,data,dangling,indices,put,all,find,new,dangling,indices,meta,data
DanglingIndicesState -> void findNewAndAddDanglingIndices(final MetaData metaData);1541092382;Finds (@{link #findNewAndAddDanglingIndices}) and adds the new dangling indices_to the currently tracked dangling indices.;void findNewAndAddDanglingIndices(final MetaData metaData) {_        danglingIndices.putAll(findNewDanglingIndices(metaData))__    };finds,link,find,new,and,add,dangling,indices,and,adds,the,new,dangling,indices,to,the,currently,tracked,dangling,indices;void,find,new,and,add,dangling,indices,final,meta,data,meta,data,dangling,indices,put,all,find,new,dangling,indices,meta,data
DanglingIndicesState -> void findNewAndAddDanglingIndices(final MetaData metaData);1542402632;Finds (@{link #findNewAndAddDanglingIndices}) and adds the new dangling indices_to the currently tracked dangling indices.;void findNewAndAddDanglingIndices(final MetaData metaData) {_        danglingIndices.putAll(findNewDanglingIndices(metaData))__    };finds,link,find,new,and,add,dangling,indices,and,adds,the,new,dangling,indices,to,the,currently,tracked,dangling,indices;void,find,new,and,add,dangling,indices,final,meta,data,meta,data,dangling,indices,put,all,find,new,dangling,indices,meta,data
DanglingIndicesState -> public void processDanglingIndices(final MetaData metaData);1524684173;Process dangling indices based on the provided meta data, handling cleanup, finding_new dangling indices, and allocating outstanding ones.;public void processDanglingIndices(final MetaData metaData) {_        if (nodeEnv.hasNodeFile() == false) {_            return__        }_        cleanupAllocatedDangledIndices(metaData)__        findNewAndAddDanglingIndices(metaData)__        allocateDanglingIndices()__    };process,dangling,indices,based,on,the,provided,meta,data,handling,cleanup,finding,new,dangling,indices,and,allocating,outstanding,ones;public,void,process,dangling,indices,final,meta,data,meta,data,if,node,env,has,node,file,false,return,cleanup,allocated,dangled,indices,meta,data,find,new,and,add,dangling,indices,meta,data,allocate,dangling,indices
DanglingIndicesState -> public void processDanglingIndices(final MetaData metaData);1541092382;Process dangling indices based on the provided meta data, handling cleanup, finding_new dangling indices, and allocating outstanding ones.;public void processDanglingIndices(final MetaData metaData) {_        if (nodeEnv.hasNodeFile() == false) {_            return__        }_        cleanupAllocatedDangledIndices(metaData)__        findNewAndAddDanglingIndices(metaData)__        allocateDanglingIndices()__    };process,dangling,indices,based,on,the,provided,meta,data,handling,cleanup,finding,new,dangling,indices,and,allocating,outstanding,ones;public,void,process,dangling,indices,final,meta,data,meta,data,if,node,env,has,node,file,false,return,cleanup,allocated,dangled,indices,meta,data,find,new,and,add,dangling,indices,meta,data,allocate,dangling,indices
DanglingIndicesState -> public void processDanglingIndices(final MetaData metaData);1542402632;Process dangling indices based on the provided meta data, handling cleanup, finding_new dangling indices, and allocating outstanding ones.;public void processDanglingIndices(final MetaData metaData) {_        if (nodeEnv.hasNodeFile() == false) {_            return__        }_        cleanupAllocatedDangledIndices(metaData)__        findNewAndAddDanglingIndices(metaData)__        allocateDanglingIndices()__    };process,dangling,indices,based,on,the,provided,meta,data,handling,cleanup,finding,new,dangling,indices,and,allocating,outstanding,ones;public,void,process,dangling,indices,final,meta,data,meta,data,if,node,env,has,node,file,false,return,cleanup,allocated,dangled,indices,meta,data,find,new,and,add,dangling,indices,meta,data,allocate,dangling,indices
DanglingIndicesState -> Map<Index, IndexMetaData> getDanglingIndices();1524684173;The current set of dangling indices.;Map<Index, IndexMetaData> getDanglingIndices() {_        _        return unmodifiableMap(new HashMap<>(danglingIndices))__    };the,current,set,of,dangling,indices;map,index,index,meta,data,get,dangling,indices,return,unmodifiable,map,new,hash,map,dangling,indices
DanglingIndicesState -> Map<Index, IndexMetaData> getDanglingIndices();1541092382;The current set of dangling indices.;Map<Index, IndexMetaData> getDanglingIndices() {_        _        return unmodifiableMap(new HashMap<>(danglingIndices))__    };the,current,set,of,dangling,indices;map,index,index,meta,data,get,dangling,indices,return,unmodifiable,map,new,hash,map,dangling,indices
DanglingIndicesState -> Map<Index, IndexMetaData> getDanglingIndices();1542402632;The current set of dangling indices.;Map<Index, IndexMetaData> getDanglingIndices() {_        _        return unmodifiableMap(new HashMap<>(danglingIndices))__    };the,current,set,of,dangling,indices;map,index,index,meta,data,get,dangling,indices,return,unmodifiable,map,new,hash,map,dangling,indices
DanglingIndicesState -> Map<Index, IndexMetaData> findNewDanglingIndices(final MetaData metaData);1524684173;Finds new dangling indices by iterating over the indices and trying to find indices_that have state on disk, but are not part of the provided meta data, or not detected_as dangled already.;Map<Index, IndexMetaData> findNewDanglingIndices(final MetaData metaData) {_        final Set<String> excludeIndexPathIds = new HashSet<>(metaData.indices().size() + danglingIndices.size())__        for (ObjectCursor<IndexMetaData> cursor : metaData.indices().values()) {_            excludeIndexPathIds.add(cursor.value.getIndex().getUUID())__        }_        excludeIndexPathIds.addAll(danglingIndices.keySet().stream().map(Index::getUUID).collect(Collectors.toList()))__        try {_            final List<IndexMetaData> indexMetaDataList = metaStateService.loadIndicesStates(excludeIndexPathIds::contains)__            Map<Index, IndexMetaData> newIndices = new HashMap<>(indexMetaDataList.size())__            final IndexGraveyard graveyard = metaData.indexGraveyard()__            for (IndexMetaData indexMetaData : indexMetaDataList) {_                if (metaData.hasIndex(indexMetaData.getIndex().getName())) {_                    logger.warn("[{}] can not be imported as a dangling index, as index with same name already exists in cluster metadata",_                        indexMetaData.getIndex())__                } else if (graveyard.containsIndex(indexMetaData.getIndex())) {_                    logger.warn("[{}] can not be imported as a dangling index, as an index with the same name and UUID exist in the " +_                                "index tombstones.  This situation is likely caused by copying over the data directory for an index " +_                                "that was previously deleted.", indexMetaData.getIndex())__                } else {_                    logger.info("[{}] dangling index exists on local file system, but not in cluster metadata, " +_                                "auto import to cluster state", indexMetaData.getIndex())__                    newIndices.put(indexMetaData.getIndex(), indexMetaData)__                }_            }_            return newIndices__        } catch (IOException e) {_            logger.warn("failed to list dangling indices", e)__            return emptyMap()__        }_    };finds,new,dangling,indices,by,iterating,over,the,indices,and,trying,to,find,indices,that,have,state,on,disk,but,are,not,part,of,the,provided,meta,data,or,not,detected,as,dangled,already;map,index,index,meta,data,find,new,dangling,indices,final,meta,data,meta,data,final,set,string,exclude,index,path,ids,new,hash,set,meta,data,indices,size,dangling,indices,size,for,object,cursor,index,meta,data,cursor,meta,data,indices,values,exclude,index,path,ids,add,cursor,value,get,index,get,uuid,exclude,index,path,ids,add,all,dangling,indices,key,set,stream,map,index,get,uuid,collect,collectors,to,list,try,final,list,index,meta,data,index,meta,data,list,meta,state,service,load,indices,states,exclude,index,path,ids,contains,map,index,index,meta,data,new,indices,new,hash,map,index,meta,data,list,size,final,index,graveyard,graveyard,meta,data,index,graveyard,for,index,meta,data,index,meta,data,index,meta,data,list,if,meta,data,has,index,index,meta,data,get,index,get,name,logger,warn,can,not,be,imported,as,a,dangling,index,as,index,with,same,name,already,exists,in,cluster,metadata,index,meta,data,get,index,else,if,graveyard,contains,index,index,meta,data,get,index,logger,warn,can,not,be,imported,as,a,dangling,index,as,an,index,with,the,same,name,and,uuid,exist,in,the,index,tombstones,this,situation,is,likely,caused,by,copying,over,the,data,directory,for,an,index,that,was,previously,deleted,index,meta,data,get,index,else,logger,info,dangling,index,exists,on,local,file,system,but,not,in,cluster,metadata,auto,import,to,cluster,state,index,meta,data,get,index,new,indices,put,index,meta,data,get,index,index,meta,data,return,new,indices,catch,ioexception,e,logger,warn,failed,to,list,dangling,indices,e,return,empty,map
DanglingIndicesState -> Map<Index, IndexMetaData> findNewDanglingIndices(final MetaData metaData);1541092382;Finds new dangling indices by iterating over the indices and trying to find indices_that have state on disk, but are not part of the provided meta data, or not detected_as dangled already.;Map<Index, IndexMetaData> findNewDanglingIndices(final MetaData metaData) {_        final Set<String> excludeIndexPathIds = new HashSet<>(metaData.indices().size() + danglingIndices.size())__        for (ObjectCursor<IndexMetaData> cursor : metaData.indices().values()) {_            excludeIndexPathIds.add(cursor.value.getIndex().getUUID())__        }_        excludeIndexPathIds.addAll(danglingIndices.keySet().stream().map(Index::getUUID).collect(Collectors.toList()))__        try {_            final List<IndexMetaData> indexMetaDataList = metaStateService.loadIndicesStates(excludeIndexPathIds::contains)__            Map<Index, IndexMetaData> newIndices = new HashMap<>(indexMetaDataList.size())__            final IndexGraveyard graveyard = metaData.indexGraveyard()__            for (IndexMetaData indexMetaData : indexMetaDataList) {_                if (metaData.hasIndex(indexMetaData.getIndex().getName())) {_                    logger.warn("[{}] can not be imported as a dangling index, as index with same name already exists in cluster metadata",_                        indexMetaData.getIndex())__                } else if (graveyard.containsIndex(indexMetaData.getIndex())) {_                    logger.warn("[{}] can not be imported as a dangling index, as an index with the same name and UUID exist in the " +_                                "index tombstones.  This situation is likely caused by copying over the data directory for an index " +_                                "that was previously deleted.", indexMetaData.getIndex())__                } else {_                    logger.info("[{}] dangling index exists on local file system, but not in cluster metadata, " +_                                "auto import to cluster state", indexMetaData.getIndex())__                    newIndices.put(indexMetaData.getIndex(), indexMetaData)__                }_            }_            return newIndices__        } catch (IOException e) {_            logger.warn("failed to list dangling indices", e)__            return emptyMap()__        }_    };finds,new,dangling,indices,by,iterating,over,the,indices,and,trying,to,find,indices,that,have,state,on,disk,but,are,not,part,of,the,provided,meta,data,or,not,detected,as,dangled,already;map,index,index,meta,data,find,new,dangling,indices,final,meta,data,meta,data,final,set,string,exclude,index,path,ids,new,hash,set,meta,data,indices,size,dangling,indices,size,for,object,cursor,index,meta,data,cursor,meta,data,indices,values,exclude,index,path,ids,add,cursor,value,get,index,get,uuid,exclude,index,path,ids,add,all,dangling,indices,key,set,stream,map,index,get,uuid,collect,collectors,to,list,try,final,list,index,meta,data,index,meta,data,list,meta,state,service,load,indices,states,exclude,index,path,ids,contains,map,index,index,meta,data,new,indices,new,hash,map,index,meta,data,list,size,final,index,graveyard,graveyard,meta,data,index,graveyard,for,index,meta,data,index,meta,data,index,meta,data,list,if,meta,data,has,index,index,meta,data,get,index,get,name,logger,warn,can,not,be,imported,as,a,dangling,index,as,index,with,same,name,already,exists,in,cluster,metadata,index,meta,data,get,index,else,if,graveyard,contains,index,index,meta,data,get,index,logger,warn,can,not,be,imported,as,a,dangling,index,as,an,index,with,the,same,name,and,uuid,exist,in,the,index,tombstones,this,situation,is,likely,caused,by,copying,over,the,data,directory,for,an,index,that,was,previously,deleted,index,meta,data,get,index,else,logger,info,dangling,index,exists,on,local,file,system,but,not,in,cluster,metadata,auto,import,to,cluster,state,index,meta,data,get,index,new,indices,put,index,meta,data,get,index,index,meta,data,return,new,indices,catch,ioexception,e,logger,warn,failed,to,list,dangling,indices,e,return,empty,map
DanglingIndicesState -> Map<Index, IndexMetaData> findNewDanglingIndices(final MetaData metaData);1542402632;Finds new dangling indices by iterating over the indices and trying to find indices_that have state on disk, but are not part of the provided meta data, or not detected_as dangled already.;Map<Index, IndexMetaData> findNewDanglingIndices(final MetaData metaData) {_        final Set<String> excludeIndexPathIds = new HashSet<>(metaData.indices().size() + danglingIndices.size())__        for (ObjectCursor<IndexMetaData> cursor : metaData.indices().values()) {_            excludeIndexPathIds.add(cursor.value.getIndex().getUUID())__        }_        excludeIndexPathIds.addAll(danglingIndices.keySet().stream().map(Index::getUUID).collect(Collectors.toList()))__        try {_            final List<IndexMetaData> indexMetaDataList = metaStateService.loadIndicesStates(excludeIndexPathIds::contains)__            Map<Index, IndexMetaData> newIndices = new HashMap<>(indexMetaDataList.size())__            final IndexGraveyard graveyard = metaData.indexGraveyard()__            for (IndexMetaData indexMetaData : indexMetaDataList) {_                if (metaData.hasIndex(indexMetaData.getIndex().getName())) {_                    logger.warn("[{}] can not be imported as a dangling index, as index with same name already exists in cluster metadata",_                        indexMetaData.getIndex())__                } else if (graveyard.containsIndex(indexMetaData.getIndex())) {_                    logger.warn("[{}] can not be imported as a dangling index, as an index with the same name and UUID exist in the " +_                                "index tombstones.  This situation is likely caused by copying over the data directory for an index " +_                                "that was previously deleted.", indexMetaData.getIndex())__                } else {_                    logger.info("[{}] dangling index exists on local file system, but not in cluster metadata, " +_                                "auto import to cluster state", indexMetaData.getIndex())__                    newIndices.put(indexMetaData.getIndex(), indexMetaData)__                }_            }_            return newIndices__        } catch (IOException e) {_            logger.warn("failed to list dangling indices", e)__            return emptyMap()__        }_    };finds,new,dangling,indices,by,iterating,over,the,indices,and,trying,to,find,indices,that,have,state,on,disk,but,are,not,part,of,the,provided,meta,data,or,not,detected,as,dangled,already;map,index,index,meta,data,find,new,dangling,indices,final,meta,data,meta,data,final,set,string,exclude,index,path,ids,new,hash,set,meta,data,indices,size,dangling,indices,size,for,object,cursor,index,meta,data,cursor,meta,data,indices,values,exclude,index,path,ids,add,cursor,value,get,index,get,uuid,exclude,index,path,ids,add,all,dangling,indices,key,set,stream,map,index,get,uuid,collect,collectors,to,list,try,final,list,index,meta,data,index,meta,data,list,meta,state,service,load,indices,states,exclude,index,path,ids,contains,map,index,index,meta,data,new,indices,new,hash,map,index,meta,data,list,size,final,index,graveyard,graveyard,meta,data,index,graveyard,for,index,meta,data,index,meta,data,index,meta,data,list,if,meta,data,has,index,index,meta,data,get,index,get,name,logger,warn,can,not,be,imported,as,a,dangling,index,as,index,with,same,name,already,exists,in,cluster,metadata,index,meta,data,get,index,else,if,graveyard,contains,index,index,meta,data,get,index,logger,warn,can,not,be,imported,as,a,dangling,index,as,an,index,with,the,same,name,and,uuid,exist,in,the,index,tombstones,this,situation,is,likely,caused,by,copying,over,the,data,directory,for,an,index,that,was,previously,deleted,index,meta,data,get,index,else,logger,info,dangling,index,exists,on,local,file,system,but,not,in,cluster,metadata,auto,import,to,cluster,state,index,meta,data,get,index,new,indices,put,index,meta,data,get,index,index,meta,data,return,new,indices,catch,ioexception,e,logger,warn,failed,to,list,dangling,indices,e,return,empty,map
