commented;modifiers;parameterAmount;loc;comment;code
false;public;4;5;;@Override public SortField sortField(@Nullable Object missingValue, MultiValueMode sortMode, XFieldComparatorSource.Nested nested, boolean reverse) {     throw new IllegalArgumentException("can't sort on geo_point field without using specific sorting feature, like geo_distance"). }
false;public;1;9;;@Override public AtomicGeoPointFieldData load(LeafReaderContext context) {     LeafReader reader = context.reader().     FieldInfo info = reader.getFieldInfos().fieldInfo(fieldName).     if (info != null) {         checkCompatible(info).     }     return new LatLonPointDVAtomicFieldData(reader, fieldName). }
false;public;1;4;;@Override public AtomicGeoPointFieldData loadDirect(LeafReaderContext context) throws Exception {     return load(context). }
true;static;1;9;/**  * helper: checks a fieldinfo and throws exception if its definitely not a LatLonDocValuesField  */ ;/**  * helper: checks a fieldinfo and throws exception if its definitely not a LatLonDocValuesField  */ static void checkCompatible(FieldInfo fieldInfo) {     // dv properties could be "unset", if you e.g. used only StoredField with this same name in the segment.     if (fieldInfo.getDocValuesType() != DocValuesType.NONE && fieldInfo.getDocValuesType() != LatLonDocValuesField.TYPE.docValuesType()) {         throw new IllegalArgumentException("field=\"" + fieldInfo.name + "\" was indexed with docValuesType=" + fieldInfo.getDocValuesType() + " but this type has docValuesType=" + LatLonDocValuesField.TYPE.docValuesType() + ", is the field really a LatLonDocValuesField?").     } }
false;public;5;6;;@Override public IndexFieldData<?> build(IndexSettings indexSettings, MappedFieldType fieldType, IndexFieldDataCache cache, CircuitBreakerService breakerService, MapperService mapperService) {     // ignore breaker     return new LatLonPointDVIndexFieldData(indexSettings.getIndex(), fieldType.name()). }
