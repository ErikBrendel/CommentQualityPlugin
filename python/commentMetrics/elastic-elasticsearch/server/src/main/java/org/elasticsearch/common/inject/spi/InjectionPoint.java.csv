commented;modifiers;parameterAmount;loc;comment;code
false;private;3;22;;private List<Dependency<?>> forMember(Member member, TypeLiteral<?> type, Annotation[][] parameterAnnotations) {     Errors errors = new Errors(member).     Iterator<Annotation[]> annotationsIterator = Arrays.asList(parameterAnnotations).iterator().     List<Dependency<?>> dependencies = new ArrayList<>().     int index = 0.     for (TypeLiteral<?> parameterType : type.getParameterTypes(member)) {         try {             Annotation[] paramAnnotations = annotationsIterator.next().             Key<?> key = Annotations.getKey(parameterType, member, paramAnnotations, errors).             dependencies.add(newDependency(key, Nullability.allowsNull(paramAnnotations), index)).             index++.         } catch (ErrorsException e) {             errors.merge(e.getErrors()).         }     }     errors.throwConfigurationExceptionIfErrorsExist().     return Collections.unmodifiableList(dependencies). }
true;private;3;3;// This method is necessary to create a Dependency<T> with proper generic type information ;// This method is necessary to create a Dependency<T> with proper generic type information private <T> Dependency<T> newDependency(Key<T> key, boolean allowsNull, int parameterIndex) {     return new Dependency<>(this, key, allowsNull, parameterIndex). }
true;public;0;3;/**  * Returns the injected constructor, field, or method.  */ ;/**  * Returns the injected constructor, field, or method.  */ public Member getMember() {     return member. }
true;public;0;3;/**  * Returns the dependencies for this injection point. If the injection point is for a method or  * constructor, the dependencies will correspond to that member's parameters. Field injection  * points always have a single dependency for the field itself.  *  * @return a possibly-empty list  */ ;/**  * Returns the dependencies for this injection point. If the injection point is for a method or  * constructor, the dependencies will correspond to that member's parameters. Field injection  * points always have a single dependency for the field itself.  *  * @return a possibly-empty list  */ public List<Dependency<?>> getDependencies() {     return dependencies. }
true;public;0;3;/**  * Returns true if this injection point shall be skipped if the injector cannot resolve bindings  * for all required dependencies. Both explicit bindings (as specified in a module), and implicit  * bindings ({@literal @}{@link org.elasticsearch.common.inject.ImplementedBy ImplementedBy}, default  * constructors etc.) may be used to satisfy optional injection points.  */ ;/**  * Returns true if this injection point shall be skipped if the injector cannot resolve bindings  * for all required dependencies. Both explicit bindings (as specified in a module), and implicit  * bindings ({@literal @}{@link org.elasticsearch.common.inject.ImplementedBy ImplementedBy}, default  * constructors etc.) may be used to satisfy optional injection points.  */ public boolean isOptional() {     return optional. }
false;public;1;5;;@Override public boolean equals(Object o) {     return o instanceof InjectionPoint && member.equals(((InjectionPoint) o).member). }
false;public;0;4;;@Override public int hashCode() {     return member.hashCode(). }
false;public;0;4;;@Override public String toString() {     return MoreTypes.toString(member). }
true;public,static;1;45;/**  * Returns a new injection point for the injectable constructor of {@code type}.  *  * @param type a concrete type with exactly one constructor annotated {@literal @}{@link Inject},  *             or a no-arguments constructor that is not private.  * @throws ConfigurationException if there is no injectable constructor, more than one injectable  *                                constructor, or if parameters of the injectable constructor are malformed, such as a  *                                parameter with multiple binding annotations.  */ ;/**  * Returns a new injection point for the injectable constructor of {@code type}.  *  * @param type a concrete type with exactly one constructor annotated {@literal @}{@link Inject},  *             or a no-arguments constructor that is not private.  * @throws ConfigurationException if there is no injectable constructor, more than one injectable  *                                constructor, or if parameters of the injectable constructor are malformed, such as a  *                                parameter with multiple binding annotations.  */ public static InjectionPoint forConstructorOf(TypeLiteral<?> type) {     Class<?> rawType = getRawType(type.getType()).     Errors errors = new Errors(rawType).     Constructor<?> injectableConstructor = null.     for (Constructor<?> constructor : rawType.getConstructors()) {         Inject inject = constructor.getAnnotation(Inject.class).         if (inject != null) {             if (inject.optional()) {                 errors.optionalConstructor(constructor).             }             if (injectableConstructor != null) {                 errors.tooManyConstructors(rawType).             }             injectableConstructor = constructor.             checkForMisplacedBindingAnnotations(injectableConstructor, errors).         }     }     errors.throwConfigurationExceptionIfErrorsExist().     if (injectableConstructor != null) {         return new InjectionPoint(type, injectableConstructor).     }     // If no annotated constructor is found, look for a no-arg constructor instead.     try {         Constructor<?> noArgConstructor = rawType.getConstructor().         // Disallow private constructors on non-private classes (unless they have @Inject)         if (Modifier.isPrivate(noArgConstructor.getModifiers()) && !Modifier.isPrivate(rawType.getModifiers())) {             errors.missingConstructor(rawType).             throw new ConfigurationException(errors.getMessages()).         }         checkForMisplacedBindingAnnotations(noArgConstructor, errors).         return new InjectionPoint(type, noArgConstructor).     } catch (NoSuchMethodException e) {         errors.missingConstructor(rawType).         throw new ConfigurationException(errors.getMessages()).     } }
true;public,static;1;3;/**  * Returns a new injection point for the injectable constructor of {@code type}.  *  * @param type a concrete type with exactly one constructor annotated {@literal @}{@link Inject},  *             or a no-arguments constructor that is not private.  * @throws ConfigurationException if there is no injectable constructor, more than one injectable  *                                constructor, or if parameters of the injectable constructor are malformed, such as a  *                                parameter with multiple binding annotations.  */ ;/**  * Returns a new injection point for the injectable constructor of {@code type}.  *  * @param type a concrete type with exactly one constructor annotated {@literal @}{@link Inject},  *             or a no-arguments constructor that is not private.  * @throws ConfigurationException if there is no injectable constructor, more than one injectable  *                                constructor, or if parameters of the injectable constructor are malformed, such as a  *                                parameter with multiple binding annotations.  */ public static InjectionPoint forConstructorOf(Class<?> type) {     return forConstructorOf(TypeLiteral.get(type)). }
true;public,static;1;13;/**  * Returns all static method and field injection points on {@code type}.  *  * @return a possibly empty set of injection points. The set has a specified iteration order. All  *         fields are returned and then all methods. Within the fields, supertype fields are returned  *         before subtype fields. Similarly, supertype methods are returned before subtype methods.  * @throws ConfigurationException if there is a malformed injection point on {@code type}, such as  *                                a field with multiple binding annotations. The exception's {@link  *                                ConfigurationException#getPartialValue() partial value} is a {@code Set<InjectionPoint>}  *                                of the valid injection points.  */ ;/**  * Returns all static method and field injection points on {@code type}.  *  * @return a possibly empty set of injection points. The set has a specified iteration order. All  *         fields are returned and then all methods. Within the fields, supertype fields are returned  *         before subtype fields. Similarly, supertype methods are returned before subtype methods.  * @throws ConfigurationException if there is a malformed injection point on {@code type}, such as  *                                a field with multiple binding annotations. The exception's {@link  *                                ConfigurationException#getPartialValue() partial value} is a {@code Set<InjectionPoint>}  *                                of the valid injection points.  */ public static Set<InjectionPoint> forStaticMethodsAndFields(TypeLiteral type) {     Set<InjectionPoint> result = new HashSet<>().     Errors errors = new Errors().     addInjectionPoints(type, Factory.FIELDS, true, result, errors).     addInjectionPoints(type, Factory.METHODS, true, result, errors).     result = unmodifiableSet(result).     if (errors.hasErrors()) {         throw new ConfigurationException(errors.getMessages()).withPartialValue(result).     }     return result. }
true;public,static;1;3;/**  * Returns all static method and field injection points on {@code type}.  *  * @return a possibly empty set of injection points. The set has a specified iteration order. All  *         fields are returned and then all methods. Within the fields, supertype fields are returned  *         before subtype fields. Similarly, supertype methods are returned before subtype methods.  * @throws ConfigurationException if there is a malformed injection point on {@code type}, such as  *                                a field with multiple binding annotations. The exception's {@link  *                                ConfigurationException#getPartialValue() partial value} is a {@code Set<InjectionPoint>}  *                                of the valid injection points.  */ ;/**  * Returns all static method and field injection points on {@code type}.  *  * @return a possibly empty set of injection points. The set has a specified iteration order. All  *         fields are returned and then all methods. Within the fields, supertype fields are returned  *         before subtype fields. Similarly, supertype methods are returned before subtype methods.  * @throws ConfigurationException if there is a malformed injection point on {@code type}, such as  *                                a field with multiple binding annotations. The exception's {@link  *                                ConfigurationException#getPartialValue() partial value} is a {@code Set<InjectionPoint>}  *                                of the valid injection points.  */ public static Set<InjectionPoint> forStaticMethodsAndFields(Class<?> type) {     return forStaticMethodsAndFields(TypeLiteral.get(type)). }
true;public,static;1;14;/**  * Returns all instance method and field injection points on {@code type}.  *  * @return a possibly empty set of injection points. The set has a specified iteration order. All  *         fields are returned and then all methods. Within the fields, supertype fields are returned  *         before subtype fields. Similarly, supertype methods are returned before subtype methods.  * @throws ConfigurationException if there is a malformed injection point on {@code type}, such as  *                                a field with multiple binding annotations. The exception's {@link  *                                ConfigurationException#getPartialValue() partial value} is a {@code Set<InjectionPoint>}  *                                of the valid injection points.  */ ;/**  * Returns all instance method and field injection points on {@code type}.  *  * @return a possibly empty set of injection points. The set has a specified iteration order. All  *         fields are returned and then all methods. Within the fields, supertype fields are returned  *         before subtype fields. Similarly, supertype methods are returned before subtype methods.  * @throws ConfigurationException if there is a malformed injection point on {@code type}, such as  *                                a field with multiple binding annotations. The exception's {@link  *                                ConfigurationException#getPartialValue() partial value} is a {@code Set<InjectionPoint>}  *                                of the valid injection points.  */ public static Set<InjectionPoint> forInstanceMethodsAndFields(TypeLiteral<?> type) {     Set<InjectionPoint> result = new HashSet<>().     Errors errors = new Errors().     // TODO (crazybob): Filter out overridden members.     addInjectionPoints(type, Factory.FIELDS, false, result, errors).     addInjectionPoints(type, Factory.METHODS, false, result, errors).     result = unmodifiableSet(result).     if (errors.hasErrors()) {         throw new ConfigurationException(errors.getMessages()).withPartialValue(result).     }     return result. }
true;public,static;1;3;/**  * Returns all instance method and field injection points on {@code type}.  *  * @return a possibly empty set of injection points. The set has a specified iteration order. All  *         fields are returned and then all methods. Within the fields, supertype fields are returned  *         before subtype fields. Similarly, supertype methods are returned before subtype methods.  * @throws ConfigurationException if there is a malformed injection point on {@code type}, such as  *                                a field with multiple binding annotations. The exception's {@link  *                                ConfigurationException#getPartialValue() partial value} is a {@code Set<InjectionPoint>}  *                                of the valid injection points.  */ ;/**  * Returns all instance method and field injection points on {@code type}.  *  * @return a possibly empty set of injection points. The set has a specified iteration order. All  *         fields are returned and then all methods. Within the fields, supertype fields are returned  *         before subtype fields. Similarly, supertype methods are returned before subtype methods.  * @throws ConfigurationException if there is a malformed injection point on {@code type}, such as  *                                a field with multiple binding annotations. The exception's {@link  *                                ConfigurationException#getPartialValue() partial value} is a {@code Set<InjectionPoint>}  *                                of the valid injection points.  */ public static Set<InjectionPoint> forInstanceMethodsAndFields(Class<?> type) {     return forInstanceMethodsAndFields(TypeLiteral.get(type)). }
false;private,static;2;20;;private static void checkForMisplacedBindingAnnotations(Member member, Errors errors) {     Annotation misplacedBindingAnnotation = Annotations.findBindingAnnotation(errors, member, ((AnnotatedElement) member).getAnnotations()).     if (misplacedBindingAnnotation == null) {         return.     }     // name. In Scala, fields always get accessor methods (that we need to ignore). See bug 242.     if (member instanceof Method) {         try {             if (member.getDeclaringClass().getField(member.getName()) != null) {                 return.             }         } catch (NoSuchFieldException ignore) {         }     }     errors.misplacedBindingAnnotation(member, misplacedBindingAnnotation). }
false;private,static;5;15;;private static <M extends Member & AnnotatedElement> void addInjectionPoints(TypeLiteral<?> type, Factory<M> factory, boolean statics, Collection<InjectionPoint> injectionPoints, Errors errors) {     if (type.getType() == Object.class) {         return.     }     // Add injectors for superclass first.     TypeLiteral<?> superType = type.getSupertype(type.getRawType().getSuperclass()).     addInjectionPoints(superType, factory, statics, injectionPoints, errors).     // Add injectors for all members next     addInjectorsForMembers(type, factory, statics, injectionPoints, errors). }
false;private,static;5;22;;private static <M extends Member & AnnotatedElement> void addInjectorsForMembers(TypeLiteral<?> typeLiteral, Factory<M> factory, boolean statics, Collection<InjectionPoint> injectionPoints, Errors errors) {     for (M member : factory.getMembers(getRawType(typeLiteral.getType()))) {         if (isStatic(member) != statics) {             continue.         }         Inject inject = member.getAnnotation(Inject.class).         if (inject == null) {             continue.         }         try {             injectionPoints.add(factory.create(typeLiteral, member, errors)).         } catch (ConfigurationException ignorable) {             if (!inject.optional()) {                 errors.merge(ignorable.getErrorMessages()).             }         }     } }
false;private,static;1;3;;private static boolean isStatic(Member member) {     return Modifier.isStatic(member.getModifiers()). }
false;public;1;4;;@Override public Field[] getMembers(Class<?> type) {     return type.getFields(). }
false;public;3;4;;@Override public InjectionPoint create(TypeLiteral<?> typeLiteral, Field member, Errors errors) {     return new InjectionPoint(typeLiteral, member). }
false;public;1;4;;@Override public Method[] getMembers(Class<?> type) {     return type.getMethods(). }
false;public;3;5;;@Override public InjectionPoint create(TypeLiteral<?> typeLiteral, Method member, Errors errors) {     checkForMisplacedBindingAnnotations(member, errors).     return new InjectionPoint(typeLiteral, member). }
false;;1;1;;M[] getMembers(Class<?> type).
false;;3;1;;InjectionPoint create(TypeLiteral<?> typeLiteral, M member, Errors errors).
