commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;9;/**  * Convert an {@link XContentBuilder} into a BytesReference. This method closes the builder,  * so no further fields may be added.  */ ;/**  * Convert an {@link XContentBuilder} into a BytesReference. This method closes the builder,  * so no further fields may be added.  */ public static BytesReference bytes(XContentBuilder xContentBuilder) {     xContentBuilder.close().     OutputStream stream = xContentBuilder.getOutputStream().     if (stream instanceof ByteArrayOutputStream) {         return new BytesArray(((ByteArrayOutputStream) stream).toByteArray()).     } else {         return ((BytesStream) stream).bytes().     } }
true;public,abstract;1;1;/**  * Returns the byte at the specified index. Need to be between 0 and length.  */ ;/**  * Returns the byte at the specified index. Need to be between 0 and length.  */ public abstract byte get(int index).
true;public,abstract;0;1;/**  * The length.  */ ;/**  * The length.  */ public abstract int length().
true;public,abstract;2;1;/**  * Slice the bytes from the {@code from} index up to {@code length}.  */ ;/**  * Slice the bytes from the {@code from} index up to {@code length}.  */ public abstract BytesReference slice(int from, int length).
true;public,abstract;0;1;/**  * The amount of memory used by this BytesReference  */ ;/**  * The amount of memory used by this BytesReference  */ public abstract long ramBytesUsed().
true;public;0;3;/**  * A stream input of the bytes.  */ ;/**  * A stream input of the bytes.  */ public StreamInput streamInput() throws IOException {     return new MarkSupportingStreamInputWrapper(this). }
true;public;1;7;/**  * Writes the bytes directly to the output stream.  */ ;/**  * Writes the bytes directly to the output stream.  */ public void writeTo(OutputStream os) throws IOException {     final BytesRefIterator iterator = iterator().     BytesRef ref.     while ((ref = iterator.next()) != null) {         os.write(ref.bytes, ref.offset, ref.length).     } }
true;public;0;3;/**  * Interprets the referenced bytes as UTF8 bytes, returning the resulting string  */ ;/**  * Interprets the referenced bytes as UTF8 bytes, returning the resulting string  */ public String utf8ToString() {     return toBytesRef().utf8ToString(). }
true;public,abstract;0;1;/**  * Converts to Lucene BytesRef.  */ ;/**  * Converts to Lucene BytesRef.  */ public abstract BytesRef toBytesRef().
false;public;0;6;;@Override public BytesRef next() throws IOException {     BytesRef r = ref.     // only return it once...     ref = null.     return r. }
true;public;0;11;/**  * Returns a BytesRefIterator for this BytesReference. This method allows  * access to the internal pages of this reference without copying them. Use with care!  * @see BytesRefIterator  */ ;/**  * Returns a BytesRefIterator for this BytesReference. This method allows  * access to the internal pages of this reference without copying them. Use with care!  * @see BytesRefIterator  */ public BytesRefIterator iterator() {     return new BytesRefIterator() {          BytesRef ref = length() == 0 ? null : toBytesRef().          @Override         public BytesRef next() throws IOException {             BytesRef r = ref.             // only return it once...             ref = null.             return r.         }     }. }
false;public;1;16;;@Override public boolean equals(Object other) {     if (this == other) {         return true.     }     if (other instanceof BytesReference) {         final BytesReference otherRef = (BytesReference) other.         if (length() != otherRef.length()) {             return false.         }         return compareIterators(this, otherRef, (a, b) -> a.bytesEquals(b) ? 0 : 1) == 0.     }     return false. }
false;public;0;20;;@Override public int hashCode() {     if (hash == null) {         final BytesRefIterator iterator = iterator().         BytesRef ref.         int result = 1.         try {             while ((ref = iterator.next()) != null) {                 for (int i = 0. i < ref.length. i++) {                     result = 31 * result + ref.bytes[ref.offset + i].                 }             }         } catch (IOException ex) {             throw new AssertionError("wont happen", ex).         }         return hash = result.     } else {         return hash.intValue().     } }
true;public,static;1;7;/**  * Returns a compact array from the given BytesReference. The returned array won't be copied unless necessary. If you need  * to modify the returned array use {@code BytesRef.deepCopyOf(reference.toBytesRef()} instead  */ ;/**  * Returns a compact array from the given BytesReference. The returned array won't be copied unless necessary. If you need  * to modify the returned array use {@code BytesRef.deepCopyOf(reference.toBytesRef()} instead  */ public static byte[] toBytes(BytesReference reference) {     final BytesRef bytesRef = reference.toBytesRef().     if (bytesRef.offset == 0 && bytesRef.length == bytesRef.bytes.length) {         return bytesRef.bytes.     }     return BytesRef.deepCopyOf(bytesRef).bytes. }
true;public,static;1;15;/**  * Returns an array of byte buffers from the given BytesReference.  */ ;/**  * Returns an array of byte buffers from the given BytesReference.  */ public static ByteBuffer[] toByteBuffers(BytesReference reference) {     BytesRefIterator byteRefIterator = reference.iterator().     BytesRef r.     try {         ArrayList<ByteBuffer> buffers = new ArrayList<>().         while ((r = byteRefIterator.next()) != null) {             buffers.add(ByteBuffer.wrap(r.bytes, r.offset, r.length)).         }         return buffers.toArray(new ByteBuffer[buffers.size()]).     } catch (IOException e) {         // this is really an error since we don't do IO in our bytesreferences         throw new AssertionError("won't happen", e).     } }
true;public,static;1;15;/**  * Returns BytesReference composed of the provided ByteBuffers.  */ ;/**  * Returns BytesReference composed of the provided ByteBuffers.  */ public static BytesReference fromByteBuffers(ByteBuffer[] buffers) {     int bufferCount = buffers.length.     if (bufferCount == 0) {         return BytesArray.EMPTY.     } else if (bufferCount == 1) {         return new ByteBufferReference(buffers[0]).     } else {         ByteBufferReference[] references = new ByteBufferReference[bufferCount].         for (int i = 0. i < bufferCount. ++i) {             references[i] = new ByteBufferReference(buffers[i]).         }         return new CompositeBytesReference(references).     } }
false;public;1;4;;@Override public int compareTo(final BytesReference other) {     return compareIterators(this, other, BytesRef::compareTo). }
true;private,static;3;45;/**  * Compares the two references using the given int function.  */ ;/**  * Compares the two references using the given int function.  */ private static int compareIterators(final BytesReference a, final BytesReference b, final ToIntBiFunction<BytesRef, BytesRef> f) {     try {         // we use the iterators since it's a 0-copy comparison where possible!         final long lengthToCompare = Math.min(a.length(), b.length()).         final BytesRefIterator aIter = a.iterator().         final BytesRefIterator bIter = b.iterator().         BytesRef aRef = aIter.next().         BytesRef bRef = bIter.next().         if (aRef != null && bRef != null) {             // do we have any data?             // we clone since we modify the offsets and length in the iteration below             aRef = aRef.clone().             bRef = bRef.clone().             if (aRef.length == a.length() && bRef.length == b.length()) {                 // is it only one array slice we are comparing?                 return f.applyAsInt(aRef, bRef).             } else {                 for (int i = 0. i < lengthToCompare. ) {                     if (aRef.length == 0) {                         // must be non null otherwise we have a bug                         aRef = aIter.next().clone().                     }                     if (bRef.length == 0) {                         // must be non null otherwise we have a bug                         bRef = bIter.next().clone().                     }                     final int aLength = aRef.length.                     final int bLength = bRef.length.                     // shrink to the same length and use the fast compare in lucene                     final int length = Math.min(aLength, bLength).                     aRef.length = bRef.length = length.                     // now we move to the fast comparison - this is the hot part of the loop                     int diff = f.applyAsInt(aRef, bRef).                     aRef.length = aLength.                     bRef.length = bLength.                     if (diff != 0) {                         return diff.                     }                     advance(aRef, length).                     advance(bRef, length).                     i += length.                 }             }         }         // One is a prefix of the other, or, they are equal:         return a.length() - b.length().     } catch (IOException ex) {         throw new AssertionError("can not happen", ex).     } }
false;private,static;2;7;;private static void advance(final BytesRef ref, final int length) {     assert ref.length >= length : " ref.length: " + ref.length + " length: " + length.     assert ref.offset + length < ref.bytes.length || (ref.offset + length == ref.bytes.length && ref.length - length == 0) : "offset: " + ref.offset + " ref.bytes.length: " + ref.bytes.length + " length: " + length + " ref.length: " + ref.length.     ref.length -= length.     ref.offset += length. }
false;public;0;4;;@Override public byte readByte() throws IOException {     return input.readByte(). }
false;public;3;4;;@Override public void readBytes(byte[] b, int offset, int len) throws IOException {     input.readBytes(b, offset, len). }
false;public;3;4;;@Override public int read(byte[] b, int off, int len) throws IOException {     return input.read(b, off, len). }
false;public;0;4;;@Override public void close() throws IOException {     input.close(). }
false;public;0;4;;@Override public int read() throws IOException {     return input.read(). }
false;public;0;4;;@Override public int available() throws IOException {     return input.available(). }
false;protected;1;4;;@Override protected void ensureCanReadBytes(int length) throws EOFException {     input.ensureCanReadBytes(length). }
false;public;0;5;;@Override public void reset() throws IOException {     input = new BytesReferenceStreamInput(reference.iterator(), reference.length()).     input.skip(mark). }
false;public;0;4;;@Override public boolean markSupported() {     return true. }
false;public;1;6;;@Override public void mark(int readLimit) {     // readLimit is optional it only guarantees that the stream remembers data upto this limit but it can remember more     // which we do in our case     this.mark = input.getOffset(). }
false;public;1;4;;@Override public long skip(long n) throws IOException {     return input.skip(n). }
false;public;2;5;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     BytesRef bytes = toBytesRef().     return builder.value(bytes.bytes, bytes.offset, bytes.length). }
