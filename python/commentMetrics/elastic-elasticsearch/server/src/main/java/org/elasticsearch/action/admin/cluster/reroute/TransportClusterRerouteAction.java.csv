commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;5;;@Override protected String executor() {     // we go async right away     return ThreadPool.Names.SAME. }
false;protected;2;4;;@Override protected ClusterBlockException checkBlock(ClusterRerouteRequest request, ClusterState state) {     return state.blocks().globalBlockedException(ClusterBlockLevel.METADATA_WRITE). }
false;protected;0;4;;@Override protected ClusterRerouteResponse newResponse() {     return new ClusterRerouteResponse(). }
false;protected;3;16;;@Override protected void masterOperation(final ClusterRerouteRequest request, final ClusterState state, final ActionListener<ClusterRerouteResponse> listener) {     Map<String, List<AbstractAllocateAllocationCommand>> stalePrimaryAllocations = new HashMap<>().     for (AllocationCommand command : request.getCommands().commands()) {         if (command instanceof AllocateStalePrimaryAllocationCommand) {             final AllocateStalePrimaryAllocationCommand cmd = (AllocateStalePrimaryAllocationCommand) command.             stalePrimaryAllocations.computeIfAbsent(cmd.index(), k -> new ArrayList<>()).add(cmd).         }     }     if (stalePrimaryAllocations.isEmpty()) {         submitStateUpdate(request, listener).     } else {         verifyThenSubmitUpdate(request, listener, stalePrimaryAllocations).     } }
false;private;3;44;;private void verifyThenSubmitUpdate(ClusterRerouteRequest request, ActionListener<ClusterRerouteResponse> listener, Map<String, List<AbstractAllocateAllocationCommand>> stalePrimaryAllocations) {     transportService.sendRequest(transportService.getLocalNode(), IndicesShardStoresAction.NAME, new IndicesShardStoresRequest().indices(stalePrimaryAllocations.keySet().toArray(Strings.EMPTY_ARRAY)), new ActionListenerResponseHandler<>(ActionListener.wrap(response -> {         ImmutableOpenMap<String, ImmutableOpenIntMap<List<IndicesShardStoresResponse.StoreStatus>>> status = response.getStoreStatuses().         Exception e = null.         for (Map.Entry<String, List<AbstractAllocateAllocationCommand>> entry : stalePrimaryAllocations.entrySet()) {             final String index = entry.getKey().             final ImmutableOpenIntMap<List<IndicesShardStoresResponse.StoreStatus>> indexStatus = status.get(index).             if (indexStatus == null) {                 // request. We ignore it here since the relevant exception will be thrown by the reroute action later on.                 continue.             }             for (AbstractAllocateAllocationCommand command : entry.getValue()) {                 final List<IndicesShardStoresResponse.StoreStatus> shardStatus = indexStatus.get(command.shardId()).                 if (shardStatus == null || shardStatus.isEmpty()) {                     e = ExceptionsHelper.useOrSuppress(e, new IllegalArgumentException("No data for shard [" + command.shardId() + "] of index [" + index + "] found on any node")).                 } else if (shardStatus.stream().noneMatch(storeStatus -> {                     final DiscoveryNode node = storeStatus.getNode().                     final String nodeInCommand = command.node().                     return nodeInCommand.equals(node.getName()) || nodeInCommand.equals(node.getId()).                 })) {                     e = ExceptionsHelper.useOrSuppress(e, new IllegalArgumentException("No data for shard [" + command.shardId() + "] of index [" + index + "] found on node [" + command.node() + ']')).                 }             }         }         if (e == null) {             submitStateUpdate(request, listener).         } else {             listener.onFailure(e).         }     }, listener::onFailure), IndicesShardStoresResponse::new)). }
false;private;2;11;;private void submitStateUpdate(final ClusterRerouteRequest request, final ActionListener<ClusterRerouteResponse> listener) {     clusterService.submitStateUpdateTask("cluster_reroute (api)", new ClusterRerouteResponseAckedClusterStateUpdateTask(logger, allocationService, request, ActionListener.wrap(response -> {         if (request.dryRun() == false) {             response.getExplanations().getYesDecisionMessages().forEach(logger::info).         }         listener.onResponse(response).     }, listener::onFailure))). }
false;protected;1;4;;@Override protected ClusterRerouteResponse newResponse(boolean acknowledged) {     return new ClusterRerouteResponse(acknowledged, clusterStateToSend, explanations). }
false;public;0;4;;@Override public void onAckTimeout() {     listener.onResponse(new ClusterRerouteResponse(false, clusterStateToSend, new RoutingExplanations())). }
false;public;2;5;;@Override public void onFailure(String source, Exception e) {     logger.debug(() -> new ParameterizedMessage("failed to perform [{}]", source), e).     super.onFailure(source, e). }
false;public;1;11;;@Override public ClusterState execute(ClusterState currentState) {     AllocationService.CommandsResult commandsResult = allocationService.reroute(currentState, request.getCommands(), request.explain(), request.isRetryFailed()).     clusterStateToSend = commandsResult.getClusterState().     explanations = commandsResult.explanations().     if (request.dryRun()) {         return currentState.     }     return commandsResult.getClusterState(). }
