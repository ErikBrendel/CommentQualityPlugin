# id;timestamp;commentText;codeText;commentWords;codeWords
PeerRecoveryTargetService -> private Store.MetadataSnapshot getStoreMetadataSnapshot(final RecoveryTarget recoveryTarget);1524684173;Obtains a snapshot of the store metadata for the recovery target.__@param recoveryTarget the target of the recovery_@return a snapshot of the store metadata;private Store.MetadataSnapshot getStoreMetadataSnapshot(final RecoveryTarget recoveryTarget) {_        try {_            return recoveryTarget.indexShard().snapshotStoreMetadata()__        } catch (final org.apache.lucene.index.IndexNotFoundException e) {_            _            logger.trace("{} shard folder empty, recovering all files", recoveryTarget)__            return Store.MetadataSnapshot.EMPTY__        } catch (final IOException e) {_            logger.warn("error while listing local files, recovering as if there are none", e)__            return Store.MetadataSnapshot.EMPTY__        }_    };obtains,a,snapshot,of,the,store,metadata,for,the,recovery,target,param,recovery,target,the,target,of,the,recovery,return,a,snapshot,of,the,store,metadata;private,store,metadata,snapshot,get,store,metadata,snapshot,final,recovery,target,recovery,target,try,return,recovery,target,index,shard,snapshot,store,metadata,catch,final,org,apache,lucene,index,index,not,found,exception,e,logger,trace,shard,folder,empty,recovering,all,files,recovery,target,return,store,metadata,snapshot,empty,catch,final,ioexception,e,logger,warn,error,while,listing,local,files,recovering,as,if,there,are,none,e,return,store,metadata,snapshot,empty
PeerRecoveryTargetService -> private Store.MetadataSnapshot getStoreMetadataSnapshot(final RecoveryTarget recoveryTarget);1529687475;Obtains a snapshot of the store metadata for the recovery target.__@param recoveryTarget the target of the recovery_@return a snapshot of the store metadata;private Store.MetadataSnapshot getStoreMetadataSnapshot(final RecoveryTarget recoveryTarget) {_        try {_            return recoveryTarget.indexShard().snapshotStoreMetadata()__        } catch (final org.apache.lucene.index.IndexNotFoundException e) {_            _            logger.trace("{} shard folder empty, recovering all files", recoveryTarget)__            return Store.MetadataSnapshot.EMPTY__        } catch (final IOException e) {_            logger.warn("error while listing local files, recovering as if there are none", e)__            return Store.MetadataSnapshot.EMPTY__        }_    };obtains,a,snapshot,of,the,store,metadata,for,the,recovery,target,param,recovery,target,the,target,of,the,recovery,return,a,snapshot,of,the,store,metadata;private,store,metadata,snapshot,get,store,metadata,snapshot,final,recovery,target,recovery,target,try,return,recovery,target,index,shard,snapshot,store,metadata,catch,final,org,apache,lucene,index,index,not,found,exception,e,logger,trace,shard,folder,empty,recovering,all,files,recovery,target,return,store,metadata,snapshot,empty,catch,final,ioexception,e,logger,warn,error,while,listing,local,files,recovering,as,if,there,are,none,e,return,store,metadata,snapshot,empty
PeerRecoveryTargetService -> private Store.MetadataSnapshot getStoreMetadataSnapshot(final RecoveryTarget recoveryTarget);1537806831;Obtains a snapshot of the store metadata for the recovery target.__@param recoveryTarget the target of the recovery_@return a snapshot of the store metadata;private Store.MetadataSnapshot getStoreMetadataSnapshot(final RecoveryTarget recoveryTarget) {_        try {_            return recoveryTarget.indexShard().snapshotStoreMetadata()__        } catch (final org.apache.lucene.index.IndexNotFoundException e) {_            _            logger.trace("{} shard folder empty, recovering all files", recoveryTarget)__            return Store.MetadataSnapshot.EMPTY__        } catch (final IOException e) {_            logger.warn("error while listing local files, recovering as if there are none", e)__            return Store.MetadataSnapshot.EMPTY__        }_    };obtains,a,snapshot,of,the,store,metadata,for,the,recovery,target,param,recovery,target,the,target,of,the,recovery,return,a,snapshot,of,the,store,metadata;private,store,metadata,snapshot,get,store,metadata,snapshot,final,recovery,target,recovery,target,try,return,recovery,target,index,shard,snapshot,store,metadata,catch,final,org,apache,lucene,index,index,not,found,exception,e,logger,trace,shard,folder,empty,recovering,all,files,recovery,target,return,store,metadata,snapshot,empty,catch,final,ioexception,e,logger,warn,error,while,listing,local,files,recovering,as,if,there,are,none,e,return,store,metadata,snapshot,empty
PeerRecoveryTargetService -> private Store.MetadataSnapshot getStoreMetadataSnapshot(final RecoveryTarget recoveryTarget);1538067637;Obtains a snapshot of the store metadata for the recovery target.__@param recoveryTarget the target of the recovery_@return a snapshot of the store metadata;private Store.MetadataSnapshot getStoreMetadataSnapshot(final RecoveryTarget recoveryTarget) {_        try {_            return recoveryTarget.indexShard().snapshotStoreMetadata()__        } catch (final org.apache.lucene.index.IndexNotFoundException e) {_            _            logger.trace("{} shard folder empty, recovering all files", recoveryTarget)__            return Store.MetadataSnapshot.EMPTY__        } catch (final IOException e) {_            logger.warn("error while listing local files, recovering as if there are none", e)__            return Store.MetadataSnapshot.EMPTY__        }_    };obtains,a,snapshot,of,the,store,metadata,for,the,recovery,target,param,recovery,target,the,target,of,the,recovery,return,a,snapshot,of,the,store,metadata;private,store,metadata,snapshot,get,store,metadata,snapshot,final,recovery,target,recovery,target,try,return,recovery,target,index,shard,snapshot,store,metadata,catch,final,org,apache,lucene,index,index,not,found,exception,e,logger,trace,shard,folder,empty,recovering,all,files,recovery,target,return,store,metadata,snapshot,empty,catch,final,ioexception,e,logger,warn,error,while,listing,local,files,recovering,as,if,there,are,none,e,return,store,metadata,snapshot,empty
PeerRecoveryTargetService -> private Store.MetadataSnapshot getStoreMetadataSnapshot(final RecoveryTarget recoveryTarget);1540583181;Obtains a snapshot of the store metadata for the recovery target.__@param recoveryTarget the target of the recovery_@return a snapshot of the store metadata;private Store.MetadataSnapshot getStoreMetadataSnapshot(final RecoveryTarget recoveryTarget) {_        try {_            return recoveryTarget.indexShard().snapshotStoreMetadata()__        } catch (final org.apache.lucene.index.IndexNotFoundException e) {_            _            logger.trace("{} shard folder empty, recovering all files", recoveryTarget)__            return Store.MetadataSnapshot.EMPTY__        } catch (final IOException e) {_            logger.warn("error while listing local files, recovering as if there are none", e)__            return Store.MetadataSnapshot.EMPTY__        }_    };obtains,a,snapshot,of,the,store,metadata,for,the,recovery,target,param,recovery,target,the,target,of,the,recovery,return,a,snapshot,of,the,store,metadata;private,store,metadata,snapshot,get,store,metadata,snapshot,final,recovery,target,recovery,target,try,return,recovery,target,index,shard,snapshot,store,metadata,catch,final,org,apache,lucene,index,index,not,found,exception,e,logger,trace,shard,folder,empty,recovering,all,files,recovery,target,return,store,metadata,snapshot,empty,catch,final,ioexception,e,logger,warn,error,while,listing,local,files,recovering,as,if,there,are,none,e,return,store,metadata,snapshot,empty
PeerRecoveryTargetService -> private Store.MetadataSnapshot getStoreMetadataSnapshot(final RecoveryTarget recoveryTarget);1541092382;Obtains a snapshot of the store metadata for the recovery target.__@param recoveryTarget the target of the recovery_@return a snapshot of the store metadata;private Store.MetadataSnapshot getStoreMetadataSnapshot(final RecoveryTarget recoveryTarget) {_        try {_            return recoveryTarget.indexShard().snapshotStoreMetadata()__        } catch (final org.apache.lucene.index.IndexNotFoundException e) {_            _            logger.trace("{} shard folder empty, recovering all files", recoveryTarget)__            return Store.MetadataSnapshot.EMPTY__        } catch (final IOException e) {_            logger.warn("error while listing local files, recovering as if there are none", e)__            return Store.MetadataSnapshot.EMPTY__        }_    };obtains,a,snapshot,of,the,store,metadata,for,the,recovery,target,param,recovery,target,the,target,of,the,recovery,return,a,snapshot,of,the,store,metadata;private,store,metadata,snapshot,get,store,metadata,snapshot,final,recovery,target,recovery,target,try,return,recovery,target,index,shard,snapshot,store,metadata,catch,final,org,apache,lucene,index,index,not,found,exception,e,logger,trace,shard,folder,empty,recovering,all,files,recovery,target,return,store,metadata,snapshot,empty,catch,final,ioexception,e,logger,warn,error,while,listing,local,files,recovering,as,if,there,are,none,e,return,store,metadata,snapshot,empty
PeerRecoveryTargetService -> private Store.MetadataSnapshot getStoreMetadataSnapshot(final RecoveryTarget recoveryTarget);1542402632;Obtains a snapshot of the store metadata for the recovery target.__@param recoveryTarget the target of the recovery_@return a snapshot of the store metadata;private Store.MetadataSnapshot getStoreMetadataSnapshot(final RecoveryTarget recoveryTarget) {_        try {_            return recoveryTarget.indexShard().snapshotStoreMetadata()__        } catch (final org.apache.lucene.index.IndexNotFoundException e) {_            _            logger.trace("{} shard folder empty, recovering all files", recoveryTarget)__            return Store.MetadataSnapshot.EMPTY__        } catch (final IOException e) {_            logger.warn("error while listing local files, recovering as if there are none", e)__            return Store.MetadataSnapshot.EMPTY__        }_    };obtains,a,snapshot,of,the,store,metadata,for,the,recovery,target,param,recovery,target,the,target,of,the,recovery,return,a,snapshot,of,the,store,metadata;private,store,metadata,snapshot,get,store,metadata,snapshot,final,recovery,target,recovery,target,try,return,recovery,target,index,shard,snapshot,store,metadata,catch,final,org,apache,lucene,index,index,not,found,exception,e,logger,trace,shard,folder,empty,recovering,all,files,recovery,target,return,store,metadata,snapshot,empty,catch,final,ioexception,e,logger,warn,error,while,listing,local,files,recovering,as,if,there,are,none,e,return,store,metadata,snapshot,empty
PeerRecoveryTargetService -> private Store.MetadataSnapshot getStoreMetadataSnapshot(final RecoveryTarget recoveryTarget);1546606266;Obtains a snapshot of the store metadata for the recovery target.__@param recoveryTarget the target of the recovery_@return a snapshot of the store metadata;private Store.MetadataSnapshot getStoreMetadataSnapshot(final RecoveryTarget recoveryTarget) {_        try {_            return recoveryTarget.indexShard().snapshotStoreMetadata()__        } catch (final org.apache.lucene.index.IndexNotFoundException e) {_            _            logger.trace("{} shard folder empty, recovering all files", recoveryTarget)__            return Store.MetadataSnapshot.EMPTY__        } catch (final IOException e) {_            logger.warn("error while listing local files, recovering as if there are none", e)__            return Store.MetadataSnapshot.EMPTY__        }_    };obtains,a,snapshot,of,the,store,metadata,for,the,recovery,target,param,recovery,target,the,target,of,the,recovery,return,a,snapshot,of,the,store,metadata;private,store,metadata,snapshot,get,store,metadata,snapshot,final,recovery,target,recovery,target,try,return,recovery,target,index,shard,snapshot,store,metadata,catch,final,org,apache,lucene,index,index,not,found,exception,e,logger,trace,shard,folder,empty,recovering,all,files,recovery,target,return,store,metadata,snapshot,empty,catch,final,ioexception,e,logger,warn,error,while,listing,local,files,recovering,as,if,there,are,none,e,return,store,metadata,snapshot,empty
PeerRecoveryTargetService -> private Store.MetadataSnapshot getStoreMetadataSnapshot(final RecoveryTarget recoveryTarget);1546981938;Obtains a snapshot of the store metadata for the recovery target.__@param recoveryTarget the target of the recovery_@return a snapshot of the store metadata;private Store.MetadataSnapshot getStoreMetadataSnapshot(final RecoveryTarget recoveryTarget) {_        try {_            return recoveryTarget.indexShard().snapshotStoreMetadata()__        } catch (final org.apache.lucene.index.IndexNotFoundException e) {_            _            logger.trace("{} shard folder empty, recovering all files", recoveryTarget)__            return Store.MetadataSnapshot.EMPTY__        } catch (final IOException e) {_            logger.warn("error while listing local files, recovering as if there are none", e)__            return Store.MetadataSnapshot.EMPTY__        }_    };obtains,a,snapshot,of,the,store,metadata,for,the,recovery,target,param,recovery,target,the,target,of,the,recovery,return,a,snapshot,of,the,store,metadata;private,store,metadata,snapshot,get,store,metadata,snapshot,final,recovery,target,recovery,target,try,return,recovery,target,index,shard,snapshot,store,metadata,catch,final,org,apache,lucene,index,index,not,found,exception,e,logger,trace,shard,folder,empty,recovering,all,files,recovery,target,return,store,metadata,snapshot,empty,catch,final,ioexception,e,logger,warn,error,while,listing,local,files,recovering,as,if,there,are,none,e,return,store,metadata,snapshot,empty
PeerRecoveryTargetService -> private Store.MetadataSnapshot getStoreMetadataSnapshot(final RecoveryTarget recoveryTarget);1547496886;Obtains a snapshot of the store metadata for the recovery target.__@param recoveryTarget the target of the recovery_@return a snapshot of the store metadata;private Store.MetadataSnapshot getStoreMetadataSnapshot(final RecoveryTarget recoveryTarget) {_        try {_            return recoveryTarget.indexShard().snapshotStoreMetadata()__        } catch (final org.apache.lucene.index.IndexNotFoundException e) {_            _            logger.trace("{} shard folder empty, recovering all files", recoveryTarget)__            return Store.MetadataSnapshot.EMPTY__        } catch (final IOException e) {_            logger.warn("error while listing local files, recovering as if there are none", e)__            return Store.MetadataSnapshot.EMPTY__        }_    };obtains,a,snapshot,of,the,store,metadata,for,the,recovery,target,param,recovery,target,the,target,of,the,recovery,return,a,snapshot,of,the,store,metadata;private,store,metadata,snapshot,get,store,metadata,snapshot,final,recovery,target,recovery,target,try,return,recovery,target,index,shard,snapshot,store,metadata,catch,final,org,apache,lucene,index,index,not,found,exception,e,logger,trace,shard,folder,empty,recovering,all,files,recovery,target,return,store,metadata,snapshot,empty,catch,final,ioexception,e,logger,warn,error,while,listing,local,files,recovering,as,if,there,are,none,e,return,store,metadata,snapshot,empty
PeerRecoveryTargetService -> private Store.MetadataSnapshot getStoreMetadataSnapshot(final RecoveryTarget recoveryTarget);1547508054;Obtains a snapshot of the store metadata for the recovery target.__@param recoveryTarget the target of the recovery_@return a snapshot of the store metadata;private Store.MetadataSnapshot getStoreMetadataSnapshot(final RecoveryTarget recoveryTarget) {_        try {_            return recoveryTarget.indexShard().snapshotStoreMetadata()__        } catch (final org.apache.lucene.index.IndexNotFoundException e) {_            _            logger.trace("{} shard folder empty, recovering all files", recoveryTarget)__            return Store.MetadataSnapshot.EMPTY__        } catch (final IOException e) {_            logger.warn("error while listing local files, recovering as if there are none", e)__            return Store.MetadataSnapshot.EMPTY__        }_    };obtains,a,snapshot,of,the,store,metadata,for,the,recovery,target,param,recovery,target,the,target,of,the,recovery,return,a,snapshot,of,the,store,metadata;private,store,metadata,snapshot,get,store,metadata,snapshot,final,recovery,target,recovery,target,try,return,recovery,target,index,shard,snapshot,store,metadata,catch,final,org,apache,lucene,index,index,not,found,exception,e,logger,trace,shard,folder,empty,recovering,all,files,recovery,target,return,store,metadata,snapshot,empty,catch,final,ioexception,e,logger,warn,error,while,listing,local,files,recovering,as,if,there,are,none,e,return,store,metadata,snapshot,empty
PeerRecoveryTargetService -> private Store.MetadataSnapshot getStoreMetadataSnapshot(final RecoveryTarget recoveryTarget);1547576245;Obtains a snapshot of the store metadata for the recovery target.__@param recoveryTarget the target of the recovery_@return a snapshot of the store metadata;private Store.MetadataSnapshot getStoreMetadataSnapshot(final RecoveryTarget recoveryTarget) {_        try {_            return recoveryTarget.indexShard().snapshotStoreMetadata()__        } catch (final org.apache.lucene.index.IndexNotFoundException e) {_            _            logger.trace("{} shard folder empty, recovering all files", recoveryTarget)__            return Store.MetadataSnapshot.EMPTY__        } catch (final IOException e) {_            logger.warn("error while listing local files, recovering as if there are none", e)__            return Store.MetadataSnapshot.EMPTY__        }_    };obtains,a,snapshot,of,the,store,metadata,for,the,recovery,target,param,recovery,target,the,target,of,the,recovery,return,a,snapshot,of,the,store,metadata;private,store,metadata,snapshot,get,store,metadata,snapshot,final,recovery,target,recovery,target,try,return,recovery,target,index,shard,snapshot,store,metadata,catch,final,org,apache,lucene,index,index,not,found,exception,e,logger,trace,shard,folder,empty,recovering,all,files,recovery,target,return,store,metadata,snapshot,empty,catch,final,ioexception,e,logger,warn,error,while,listing,local,files,recovering,as,if,there,are,none,e,return,store,metadata,snapshot,empty
PeerRecoveryTargetService -> private Store.MetadataSnapshot getStoreMetadataSnapshot(final RecoveryTarget recoveryTarget);1548124510;Obtains a snapshot of the store metadata for the recovery target.__@param recoveryTarget the target of the recovery_@return a snapshot of the store metadata;private Store.MetadataSnapshot getStoreMetadataSnapshot(final RecoveryTarget recoveryTarget) {_        try {_            return recoveryTarget.indexShard().snapshotStoreMetadata()__        } catch (final org.apache.lucene.index.IndexNotFoundException e) {_            _            logger.trace("{} shard folder empty, recovering all files", recoveryTarget)__            return Store.MetadataSnapshot.EMPTY__        } catch (final IOException e) {_            logger.warn("error while listing local files, recovering as if there are none", e)__            return Store.MetadataSnapshot.EMPTY__        }_    };obtains,a,snapshot,of,the,store,metadata,for,the,recovery,target,param,recovery,target,the,target,of,the,recovery,return,a,snapshot,of,the,store,metadata;private,store,metadata,snapshot,get,store,metadata,snapshot,final,recovery,target,recovery,target,try,return,recovery,target,index,shard,snapshot,store,metadata,catch,final,org,apache,lucene,index,index,not,found,exception,e,logger,trace,shard,folder,empty,recovering,all,files,recovery,target,return,store,metadata,snapshot,empty,catch,final,ioexception,e,logger,warn,error,while,listing,local,files,recovering,as,if,there,are,none,e,return,store,metadata,snapshot,empty
PeerRecoveryTargetService -> private Store.MetadataSnapshot getStoreMetadataSnapshot(final RecoveryTarget recoveryTarget);1548558090;Obtains a snapshot of the store metadata for the recovery target.__@param recoveryTarget the target of the recovery_@return a snapshot of the store metadata;private Store.MetadataSnapshot getStoreMetadataSnapshot(final RecoveryTarget recoveryTarget) {_        try {_            return recoveryTarget.indexShard().snapshotStoreMetadata()__        } catch (final org.apache.lucene.index.IndexNotFoundException e) {_            _            logger.trace("{} shard folder empty, recovering all files", recoveryTarget)__            return Store.MetadataSnapshot.EMPTY__        } catch (final IOException e) {_            logger.warn("error while listing local files, recovering as if there are none", e)__            return Store.MetadataSnapshot.EMPTY__        }_    };obtains,a,snapshot,of,the,store,metadata,for,the,recovery,target,param,recovery,target,the,target,of,the,recovery,return,a,snapshot,of,the,store,metadata;private,store,metadata,snapshot,get,store,metadata,snapshot,final,recovery,target,recovery,target,try,return,recovery,target,index,shard,snapshot,store,metadata,catch,final,org,apache,lucene,index,index,not,found,exception,e,logger,trace,shard,folder,empty,recovering,all,files,recovery,target,return,store,metadata,snapshot,empty,catch,final,ioexception,e,logger,warn,error,while,listing,local,files,recovering,as,if,there,are,none,e,return,store,metadata,snapshot,empty
PeerRecoveryTargetService -> private Store.MetadataSnapshot getStoreMetadataSnapshot(final RecoveryTarget recoveryTarget);1548953505;Obtains a snapshot of the store metadata for the recovery target.__@param recoveryTarget the target of the recovery_@return a snapshot of the store metadata;private Store.MetadataSnapshot getStoreMetadataSnapshot(final RecoveryTarget recoveryTarget) {_        try {_            return recoveryTarget.indexShard().snapshotStoreMetadata()__        } catch (final org.apache.lucene.index.IndexNotFoundException e) {_            _            logger.trace("{} shard folder empty, recovering all files", recoveryTarget)__            return Store.MetadataSnapshot.EMPTY__        } catch (final IOException e) {_            logger.warn("error while listing local files, recovering as if there are none", e)__            return Store.MetadataSnapshot.EMPTY__        }_    };obtains,a,snapshot,of,the,store,metadata,for,the,recovery,target,param,recovery,target,the,target,of,the,recovery,return,a,snapshot,of,the,store,metadata;private,store,metadata,snapshot,get,store,metadata,snapshot,final,recovery,target,recovery,target,try,return,recovery,target,index,shard,snapshot,store,metadata,catch,final,org,apache,lucene,index,index,not,found,exception,e,logger,trace,shard,folder,empty,recovering,all,files,recovery,target,return,store,metadata,snapshot,empty,catch,final,ioexception,e,logger,warn,error,while,listing,local,files,recovering,as,if,there,are,none,e,return,store,metadata,snapshot,empty
PeerRecoveryTargetService -> private Store.MetadataSnapshot getStoreMetadataSnapshot(final RecoveryTarget recoveryTarget);1549406621;Obtains a snapshot of the store metadata for the recovery target.__@param recoveryTarget the target of the recovery_@return a snapshot of the store metadata;private Store.MetadataSnapshot getStoreMetadataSnapshot(final RecoveryTarget recoveryTarget) {_        try {_            return recoveryTarget.indexShard().snapshotStoreMetadata()__        } catch (final org.apache.lucene.index.IndexNotFoundException e) {_            _            logger.trace("{} shard folder empty, recovering all files", recoveryTarget)__            return Store.MetadataSnapshot.EMPTY__        } catch (final IOException e) {_            logger.warn("error while listing local files, recovering as if there are none", e)__            return Store.MetadataSnapshot.EMPTY__        }_    };obtains,a,snapshot,of,the,store,metadata,for,the,recovery,target,param,recovery,target,the,target,of,the,recovery,return,a,snapshot,of,the,store,metadata;private,store,metadata,snapshot,get,store,metadata,snapshot,final,recovery,target,recovery,target,try,return,recovery,target,index,shard,snapshot,store,metadata,catch,final,org,apache,lucene,index,index,not,found,exception,e,logger,trace,shard,folder,empty,recovering,all,files,recovery,target,return,store,metadata,snapshot,empty,catch,final,ioexception,e,logger,warn,error,while,listing,local,files,recovering,as,if,there,are,none,e,return,store,metadata,snapshot,empty
PeerRecoveryTargetService -> private StartRecoveryRequest getStartRecoveryRequest(final RecoveryTarget recoveryTarget);1524684173;Prepare the start recovery request.__@param recoveryTarget the target of the recovery_@return a start recovery request;private StartRecoveryRequest getStartRecoveryRequest(final RecoveryTarget recoveryTarget) {_        final StartRecoveryRequest request__        logger.trace("{} collecting local files for [{}]", recoveryTarget.shardId(), recoveryTarget.sourceNode())___        final Store.MetadataSnapshot metadataSnapshot = getStoreMetadataSnapshot(recoveryTarget)__        logger.trace("{} local file count [{}]", recoveryTarget.shardId(), metadataSnapshot.size())___        final long startingSeqNo__        if (metadataSnapshot.size() > 0) {_            startingSeqNo = getStartingSeqNo(logger, recoveryTarget)__        } else {_            startingSeqNo = SequenceNumbers.UNASSIGNED_SEQ_NO__        }__        if (startingSeqNo == SequenceNumbers.UNASSIGNED_SEQ_NO) {_            logger.trace("{} preparing for file-based recovery from [{}]", recoveryTarget.shardId(), recoveryTarget.sourceNode())__        } else {_            logger.trace(_                "{} preparing for sequence-number-based recovery starting at local checkpoint [{}] from [{}]",_                recoveryTarget.shardId(),_                startingSeqNo,_                recoveryTarget.sourceNode())__        }__        request = new StartRecoveryRequest(_            recoveryTarget.shardId(),_            recoveryTarget.indexShard().routingEntry().allocationId().getId(),_            recoveryTarget.sourceNode(),_            clusterService.localNode(),_            metadataSnapshot,_            recoveryTarget.state().getPrimary(),_            recoveryTarget.recoveryId(),_            startingSeqNo)__        return request__    };prepare,the,start,recovery,request,param,recovery,target,the,target,of,the,recovery,return,a,start,recovery,request;private,start,recovery,request,get,start,recovery,request,final,recovery,target,recovery,target,final,start,recovery,request,request,logger,trace,collecting,local,files,for,recovery,target,shard,id,recovery,target,source,node,final,store,metadata,snapshot,metadata,snapshot,get,store,metadata,snapshot,recovery,target,logger,trace,local,file,count,recovery,target,shard,id,metadata,snapshot,size,final,long,starting,seq,no,if,metadata,snapshot,size,0,starting,seq,no,get,starting,seq,no,logger,recovery,target,else,starting,seq,no,sequence,numbers,if,starting,seq,no,sequence,numbers,logger,trace,preparing,for,file,based,recovery,from,recovery,target,shard,id,recovery,target,source,node,else,logger,trace,preparing,for,sequence,number,based,recovery,starting,at,local,checkpoint,from,recovery,target,shard,id,starting,seq,no,recovery,target,source,node,request,new,start,recovery,request,recovery,target,shard,id,recovery,target,index,shard,routing,entry,allocation,id,get,id,recovery,target,source,node,cluster,service,local,node,metadata,snapshot,recovery,target,state,get,primary,recovery,target,recovery,id,starting,seq,no,return,request
PeerRecoveryTargetService -> private StartRecoveryRequest getStartRecoveryRequest(final RecoveryTarget recoveryTarget);1529687475;Prepare the start recovery request.__@param recoveryTarget the target of the recovery_@return a start recovery request;private StartRecoveryRequest getStartRecoveryRequest(final RecoveryTarget recoveryTarget) {_        final StartRecoveryRequest request__        logger.trace("{} collecting local files for [{}]", recoveryTarget.shardId(), recoveryTarget.sourceNode())___        final Store.MetadataSnapshot metadataSnapshot = getStoreMetadataSnapshot(recoveryTarget)__        logger.trace("{} local file count [{}]", recoveryTarget.shardId(), metadataSnapshot.size())___        final long startingSeqNo__        if (metadataSnapshot.size() > 0) {_            startingSeqNo = getStartingSeqNo(logger, recoveryTarget)__        } else {_            startingSeqNo = SequenceNumbers.UNASSIGNED_SEQ_NO__        }__        if (startingSeqNo == SequenceNumbers.UNASSIGNED_SEQ_NO) {_            logger.trace("{} preparing for file-based recovery from [{}]", recoveryTarget.shardId(), recoveryTarget.sourceNode())__        } else {_            logger.trace(_                "{} preparing for sequence-number-based recovery starting at local checkpoint [{}] from [{}]",_                recoveryTarget.shardId(),_                startingSeqNo,_                recoveryTarget.sourceNode())__        }__        request = new StartRecoveryRequest(_            recoveryTarget.shardId(),_            recoveryTarget.indexShard().routingEntry().allocationId().getId(),_            recoveryTarget.sourceNode(),_            clusterService.localNode(),_            metadataSnapshot,_            recoveryTarget.state().getPrimary(),_            recoveryTarget.recoveryId(),_            startingSeqNo)__        return request__    };prepare,the,start,recovery,request,param,recovery,target,the,target,of,the,recovery,return,a,start,recovery,request;private,start,recovery,request,get,start,recovery,request,final,recovery,target,recovery,target,final,start,recovery,request,request,logger,trace,collecting,local,files,for,recovery,target,shard,id,recovery,target,source,node,final,store,metadata,snapshot,metadata,snapshot,get,store,metadata,snapshot,recovery,target,logger,trace,local,file,count,recovery,target,shard,id,metadata,snapshot,size,final,long,starting,seq,no,if,metadata,snapshot,size,0,starting,seq,no,get,starting,seq,no,logger,recovery,target,else,starting,seq,no,sequence,numbers,if,starting,seq,no,sequence,numbers,logger,trace,preparing,for,file,based,recovery,from,recovery,target,shard,id,recovery,target,source,node,else,logger,trace,preparing,for,sequence,number,based,recovery,starting,at,local,checkpoint,from,recovery,target,shard,id,starting,seq,no,recovery,target,source,node,request,new,start,recovery,request,recovery,target,shard,id,recovery,target,index,shard,routing,entry,allocation,id,get,id,recovery,target,source,node,cluster,service,local,node,metadata,snapshot,recovery,target,state,get,primary,recovery,target,recovery,id,starting,seq,no,return,request
PeerRecoveryTargetService -> private StartRecoveryRequest getStartRecoveryRequest(final RecoveryTarget recoveryTarget);1537806831;Prepare the start recovery request.__@param recoveryTarget the target of the recovery_@return a start recovery request;private StartRecoveryRequest getStartRecoveryRequest(final RecoveryTarget recoveryTarget) {_        final StartRecoveryRequest request__        logger.trace("{} collecting local files for [{}]", recoveryTarget.shardId(), recoveryTarget.sourceNode())___        final Store.MetadataSnapshot metadataSnapshot = getStoreMetadataSnapshot(recoveryTarget)__        logger.trace("{} local file count [{}]", recoveryTarget.shardId(), metadataSnapshot.size())___        final long startingSeqNo__        if (metadataSnapshot.size() > 0) {_            startingSeqNo = getStartingSeqNo(logger, recoveryTarget)__        } else {_            startingSeqNo = SequenceNumbers.UNASSIGNED_SEQ_NO__        }__        if (startingSeqNo == SequenceNumbers.UNASSIGNED_SEQ_NO) {_            logger.trace("{} preparing for file-based recovery from [{}]", recoveryTarget.shardId(), recoveryTarget.sourceNode())__        } else {_            logger.trace(_                "{} preparing for sequence-number-based recovery starting at local checkpoint [{}] from [{}]",_                recoveryTarget.shardId(),_                startingSeqNo,_                recoveryTarget.sourceNode())__        }__        request = new StartRecoveryRequest(_            recoveryTarget.shardId(),_            recoveryTarget.indexShard().routingEntry().allocationId().getId(),_            recoveryTarget.sourceNode(),_            clusterService.localNode(),_            metadataSnapshot,_            recoveryTarget.state().getPrimary(),_            recoveryTarget.recoveryId(),_            startingSeqNo)__        return request__    };prepare,the,start,recovery,request,param,recovery,target,the,target,of,the,recovery,return,a,start,recovery,request;private,start,recovery,request,get,start,recovery,request,final,recovery,target,recovery,target,final,start,recovery,request,request,logger,trace,collecting,local,files,for,recovery,target,shard,id,recovery,target,source,node,final,store,metadata,snapshot,metadata,snapshot,get,store,metadata,snapshot,recovery,target,logger,trace,local,file,count,recovery,target,shard,id,metadata,snapshot,size,final,long,starting,seq,no,if,metadata,snapshot,size,0,starting,seq,no,get,starting,seq,no,logger,recovery,target,else,starting,seq,no,sequence,numbers,if,starting,seq,no,sequence,numbers,logger,trace,preparing,for,file,based,recovery,from,recovery,target,shard,id,recovery,target,source,node,else,logger,trace,preparing,for,sequence,number,based,recovery,starting,at,local,checkpoint,from,recovery,target,shard,id,starting,seq,no,recovery,target,source,node,request,new,start,recovery,request,recovery,target,shard,id,recovery,target,index,shard,routing,entry,allocation,id,get,id,recovery,target,source,node,cluster,service,local,node,metadata,snapshot,recovery,target,state,get,primary,recovery,target,recovery,id,starting,seq,no,return,request
PeerRecoveryTargetService -> private StartRecoveryRequest getStartRecoveryRequest(final RecoveryTarget recoveryTarget);1538067637;Prepare the start recovery request.__@param recoveryTarget the target of the recovery_@return a start recovery request;private StartRecoveryRequest getStartRecoveryRequest(final RecoveryTarget recoveryTarget) {_        final StartRecoveryRequest request__        logger.trace("{} collecting local files for [{}]", recoveryTarget.shardId(), recoveryTarget.sourceNode())___        final Store.MetadataSnapshot metadataSnapshot = getStoreMetadataSnapshot(recoveryTarget)__        logger.trace("{} local file count [{}]", recoveryTarget.shardId(), metadataSnapshot.size())___        final long startingSeqNo__        if (metadataSnapshot.size() > 0) {_            startingSeqNo = getStartingSeqNo(logger, recoveryTarget)__        } else {_            startingSeqNo = SequenceNumbers.UNASSIGNED_SEQ_NO__        }__        if (startingSeqNo == SequenceNumbers.UNASSIGNED_SEQ_NO) {_            logger.trace("{} preparing for file-based recovery from [{}]", recoveryTarget.shardId(), recoveryTarget.sourceNode())__        } else {_            logger.trace(_                "{} preparing for sequence-number-based recovery starting at local checkpoint [{}] from [{}]",_                recoveryTarget.shardId(),_                startingSeqNo,_                recoveryTarget.sourceNode())__        }__        request = new StartRecoveryRequest(_            recoveryTarget.shardId(),_            recoveryTarget.indexShard().routingEntry().allocationId().getId(),_            recoveryTarget.sourceNode(),_            clusterService.localNode(),_            metadataSnapshot,_            recoveryTarget.state().getPrimary(),_            recoveryTarget.recoveryId(),_            startingSeqNo)__        return request__    };prepare,the,start,recovery,request,param,recovery,target,the,target,of,the,recovery,return,a,start,recovery,request;private,start,recovery,request,get,start,recovery,request,final,recovery,target,recovery,target,final,start,recovery,request,request,logger,trace,collecting,local,files,for,recovery,target,shard,id,recovery,target,source,node,final,store,metadata,snapshot,metadata,snapshot,get,store,metadata,snapshot,recovery,target,logger,trace,local,file,count,recovery,target,shard,id,metadata,snapshot,size,final,long,starting,seq,no,if,metadata,snapshot,size,0,starting,seq,no,get,starting,seq,no,logger,recovery,target,else,starting,seq,no,sequence,numbers,if,starting,seq,no,sequence,numbers,logger,trace,preparing,for,file,based,recovery,from,recovery,target,shard,id,recovery,target,source,node,else,logger,trace,preparing,for,sequence,number,based,recovery,starting,at,local,checkpoint,from,recovery,target,shard,id,starting,seq,no,recovery,target,source,node,request,new,start,recovery,request,recovery,target,shard,id,recovery,target,index,shard,routing,entry,allocation,id,get,id,recovery,target,source,node,cluster,service,local,node,metadata,snapshot,recovery,target,state,get,primary,recovery,target,recovery,id,starting,seq,no,return,request
PeerRecoveryTargetService -> private StartRecoveryRequest getStartRecoveryRequest(final RecoveryTarget recoveryTarget);1540583181;Prepare the start recovery request.__@param recoveryTarget the target of the recovery_@return a start recovery request;private StartRecoveryRequest getStartRecoveryRequest(final RecoveryTarget recoveryTarget) {_        final StartRecoveryRequest request__        logger.trace("{} collecting local files for [{}]", recoveryTarget.shardId(), recoveryTarget.sourceNode())___        final Store.MetadataSnapshot metadataSnapshot = getStoreMetadataSnapshot(recoveryTarget)__        logger.trace("{} local file count [{}]", recoveryTarget.shardId(), metadataSnapshot.size())___        final long startingSeqNo__        if (metadataSnapshot.size() > 0) {_            startingSeqNo = getStartingSeqNo(logger, recoveryTarget)__        } else {_            startingSeqNo = SequenceNumbers.UNASSIGNED_SEQ_NO__        }__        if (startingSeqNo == SequenceNumbers.UNASSIGNED_SEQ_NO) {_            logger.trace("{} preparing for file-based recovery from [{}]", recoveryTarget.shardId(), recoveryTarget.sourceNode())__        } else {_            logger.trace(_                "{} preparing for sequence-number-based recovery starting at local checkpoint [{}] from [{}]",_                recoveryTarget.shardId(),_                startingSeqNo,_                recoveryTarget.sourceNode())__        }__        request = new StartRecoveryRequest(_            recoveryTarget.shardId(),_            recoveryTarget.indexShard().routingEntry().allocationId().getId(),_            recoveryTarget.sourceNode(),_            clusterService.localNode(),_            metadataSnapshot,_            recoveryTarget.state().getPrimary(),_            recoveryTarget.recoveryId(),_            startingSeqNo)__        return request__    };prepare,the,start,recovery,request,param,recovery,target,the,target,of,the,recovery,return,a,start,recovery,request;private,start,recovery,request,get,start,recovery,request,final,recovery,target,recovery,target,final,start,recovery,request,request,logger,trace,collecting,local,files,for,recovery,target,shard,id,recovery,target,source,node,final,store,metadata,snapshot,metadata,snapshot,get,store,metadata,snapshot,recovery,target,logger,trace,local,file,count,recovery,target,shard,id,metadata,snapshot,size,final,long,starting,seq,no,if,metadata,snapshot,size,0,starting,seq,no,get,starting,seq,no,logger,recovery,target,else,starting,seq,no,sequence,numbers,if,starting,seq,no,sequence,numbers,logger,trace,preparing,for,file,based,recovery,from,recovery,target,shard,id,recovery,target,source,node,else,logger,trace,preparing,for,sequence,number,based,recovery,starting,at,local,checkpoint,from,recovery,target,shard,id,starting,seq,no,recovery,target,source,node,request,new,start,recovery,request,recovery,target,shard,id,recovery,target,index,shard,routing,entry,allocation,id,get,id,recovery,target,source,node,cluster,service,local,node,metadata,snapshot,recovery,target,state,get,primary,recovery,target,recovery,id,starting,seq,no,return,request
PeerRecoveryTargetService -> private StartRecoveryRequest getStartRecoveryRequest(final RecoveryTarget recoveryTarget);1541092382;Prepare the start recovery request.__@param recoveryTarget the target of the recovery_@return a start recovery request;private StartRecoveryRequest getStartRecoveryRequest(final RecoveryTarget recoveryTarget) {_        final StartRecoveryRequest request__        logger.trace("{} collecting local files for [{}]", recoveryTarget.shardId(), recoveryTarget.sourceNode())___        final Store.MetadataSnapshot metadataSnapshot = getStoreMetadataSnapshot(recoveryTarget)__        logger.trace("{} local file count [{}]", recoveryTarget.shardId(), metadataSnapshot.size())___        final long startingSeqNo__        if (metadataSnapshot.size() > 0) {_            startingSeqNo = getStartingSeqNo(logger, recoveryTarget)__        } else {_            startingSeqNo = SequenceNumbers.UNASSIGNED_SEQ_NO__        }__        if (startingSeqNo == SequenceNumbers.UNASSIGNED_SEQ_NO) {_            logger.trace("{} preparing for file-based recovery from [{}]", recoveryTarget.shardId(), recoveryTarget.sourceNode())__        } else {_            logger.trace(_                "{} preparing for sequence-number-based recovery starting at local checkpoint [{}] from [{}]",_                recoveryTarget.shardId(),_                startingSeqNo,_                recoveryTarget.sourceNode())__        }__        request = new StartRecoveryRequest(_            recoveryTarget.shardId(),_            recoveryTarget.indexShard().routingEntry().allocationId().getId(),_            recoveryTarget.sourceNode(),_            clusterService.localNode(),_            metadataSnapshot,_            recoveryTarget.state().getPrimary(),_            recoveryTarget.recoveryId(),_            startingSeqNo)__        return request__    };prepare,the,start,recovery,request,param,recovery,target,the,target,of,the,recovery,return,a,start,recovery,request;private,start,recovery,request,get,start,recovery,request,final,recovery,target,recovery,target,final,start,recovery,request,request,logger,trace,collecting,local,files,for,recovery,target,shard,id,recovery,target,source,node,final,store,metadata,snapshot,metadata,snapshot,get,store,metadata,snapshot,recovery,target,logger,trace,local,file,count,recovery,target,shard,id,metadata,snapshot,size,final,long,starting,seq,no,if,metadata,snapshot,size,0,starting,seq,no,get,starting,seq,no,logger,recovery,target,else,starting,seq,no,sequence,numbers,if,starting,seq,no,sequence,numbers,logger,trace,preparing,for,file,based,recovery,from,recovery,target,shard,id,recovery,target,source,node,else,logger,trace,preparing,for,sequence,number,based,recovery,starting,at,local,checkpoint,from,recovery,target,shard,id,starting,seq,no,recovery,target,source,node,request,new,start,recovery,request,recovery,target,shard,id,recovery,target,index,shard,routing,entry,allocation,id,get,id,recovery,target,source,node,cluster,service,local,node,metadata,snapshot,recovery,target,state,get,primary,recovery,target,recovery,id,starting,seq,no,return,request
PeerRecoveryTargetService -> private StartRecoveryRequest getStartRecoveryRequest(final RecoveryTarget recoveryTarget);1542402632;Prepare the start recovery request.__@param recoveryTarget the target of the recovery_@return a start recovery request;private StartRecoveryRequest getStartRecoveryRequest(final RecoveryTarget recoveryTarget) {_        final StartRecoveryRequest request__        logger.trace("{} collecting local files for [{}]", recoveryTarget.shardId(), recoveryTarget.sourceNode())___        final Store.MetadataSnapshot metadataSnapshot = getStoreMetadataSnapshot(recoveryTarget)__        logger.trace("{} local file count [{}]", recoveryTarget.shardId(), metadataSnapshot.size())___        final long startingSeqNo__        if (metadataSnapshot.size() > 0) {_            startingSeqNo = getStartingSeqNo(logger, recoveryTarget)__        } else {_            startingSeqNo = SequenceNumbers.UNASSIGNED_SEQ_NO__        }__        if (startingSeqNo == SequenceNumbers.UNASSIGNED_SEQ_NO) {_            logger.trace("{} preparing for file-based recovery from [{}]", recoveryTarget.shardId(), recoveryTarget.sourceNode())__        } else {_            logger.trace(_                "{} preparing for sequence-number-based recovery starting at local checkpoint [{}] from [{}]",_                recoveryTarget.shardId(),_                startingSeqNo,_                recoveryTarget.sourceNode())__        }__        request = new StartRecoveryRequest(_            recoveryTarget.shardId(),_            recoveryTarget.indexShard().routingEntry().allocationId().getId(),_            recoveryTarget.sourceNode(),_            clusterService.localNode(),_            metadataSnapshot,_            recoveryTarget.state().getPrimary(),_            recoveryTarget.recoveryId(),_            startingSeqNo)__        return request__    };prepare,the,start,recovery,request,param,recovery,target,the,target,of,the,recovery,return,a,start,recovery,request;private,start,recovery,request,get,start,recovery,request,final,recovery,target,recovery,target,final,start,recovery,request,request,logger,trace,collecting,local,files,for,recovery,target,shard,id,recovery,target,source,node,final,store,metadata,snapshot,metadata,snapshot,get,store,metadata,snapshot,recovery,target,logger,trace,local,file,count,recovery,target,shard,id,metadata,snapshot,size,final,long,starting,seq,no,if,metadata,snapshot,size,0,starting,seq,no,get,starting,seq,no,logger,recovery,target,else,starting,seq,no,sequence,numbers,if,starting,seq,no,sequence,numbers,logger,trace,preparing,for,file,based,recovery,from,recovery,target,shard,id,recovery,target,source,node,else,logger,trace,preparing,for,sequence,number,based,recovery,starting,at,local,checkpoint,from,recovery,target,shard,id,starting,seq,no,recovery,target,source,node,request,new,start,recovery,request,recovery,target,shard,id,recovery,target,index,shard,routing,entry,allocation,id,get,id,recovery,target,source,node,cluster,service,local,node,metadata,snapshot,recovery,target,state,get,primary,recovery,target,recovery,id,starting,seq,no,return,request
PeerRecoveryTargetService -> private StartRecoveryRequest getStartRecoveryRequest(final RecoveryTarget recoveryTarget);1546606266;Prepare the start recovery request.__@param recoveryTarget the target of the recovery_@return a start recovery request;private StartRecoveryRequest getStartRecoveryRequest(final RecoveryTarget recoveryTarget) {_        final StartRecoveryRequest request__        logger.trace("{} collecting local files for [{}]", recoveryTarget.shardId(), recoveryTarget.sourceNode())___        final Store.MetadataSnapshot metadataSnapshot = getStoreMetadataSnapshot(recoveryTarget)__        logger.trace("{} local file count [{}]", recoveryTarget.shardId(), metadataSnapshot.size())___        final long startingSeqNo__        if (metadataSnapshot.size() > 0) {_            startingSeqNo = getStartingSeqNo(logger, recoveryTarget)__        } else {_            startingSeqNo = SequenceNumbers.UNASSIGNED_SEQ_NO__        }__        if (startingSeqNo == SequenceNumbers.UNASSIGNED_SEQ_NO) {_            logger.trace("{} preparing for file-based recovery from [{}]", recoveryTarget.shardId(), recoveryTarget.sourceNode())__        } else {_            logger.trace(_                "{} preparing for sequence-number-based recovery starting at local checkpoint [{}] from [{}]",_                recoveryTarget.shardId(),_                startingSeqNo,_                recoveryTarget.sourceNode())__        }__        request = new StartRecoveryRequest(_            recoveryTarget.shardId(),_            recoveryTarget.indexShard().routingEntry().allocationId().getId(),_            recoveryTarget.sourceNode(),_            clusterService.localNode(),_            metadataSnapshot,_            recoveryTarget.state().getPrimary(),_            recoveryTarget.recoveryId(),_            startingSeqNo)__        return request__    };prepare,the,start,recovery,request,param,recovery,target,the,target,of,the,recovery,return,a,start,recovery,request;private,start,recovery,request,get,start,recovery,request,final,recovery,target,recovery,target,final,start,recovery,request,request,logger,trace,collecting,local,files,for,recovery,target,shard,id,recovery,target,source,node,final,store,metadata,snapshot,metadata,snapshot,get,store,metadata,snapshot,recovery,target,logger,trace,local,file,count,recovery,target,shard,id,metadata,snapshot,size,final,long,starting,seq,no,if,metadata,snapshot,size,0,starting,seq,no,get,starting,seq,no,logger,recovery,target,else,starting,seq,no,sequence,numbers,if,starting,seq,no,sequence,numbers,logger,trace,preparing,for,file,based,recovery,from,recovery,target,shard,id,recovery,target,source,node,else,logger,trace,preparing,for,sequence,number,based,recovery,starting,at,local,checkpoint,from,recovery,target,shard,id,starting,seq,no,recovery,target,source,node,request,new,start,recovery,request,recovery,target,shard,id,recovery,target,index,shard,routing,entry,allocation,id,get,id,recovery,target,source,node,cluster,service,local,node,metadata,snapshot,recovery,target,state,get,primary,recovery,target,recovery,id,starting,seq,no,return,request
PeerRecoveryTargetService -> private StartRecoveryRequest getStartRecoveryRequest(final RecoveryTarget recoveryTarget);1546981938;Prepare the start recovery request.__@param recoveryTarget the target of the recovery_@return a start recovery request;private StartRecoveryRequest getStartRecoveryRequest(final RecoveryTarget recoveryTarget) {_        final StartRecoveryRequest request__        logger.trace("{} collecting local files for [{}]", recoveryTarget.shardId(), recoveryTarget.sourceNode())___        final Store.MetadataSnapshot metadataSnapshot = getStoreMetadataSnapshot(recoveryTarget)__        logger.trace("{} local file count [{}]", recoveryTarget.shardId(), metadataSnapshot.size())___        final long startingSeqNo__        if (metadataSnapshot.size() > 0) {_            startingSeqNo = getStartingSeqNo(logger, recoveryTarget)__        } else {_            startingSeqNo = SequenceNumbers.UNASSIGNED_SEQ_NO__        }__        if (startingSeqNo == SequenceNumbers.UNASSIGNED_SEQ_NO) {_            logger.trace("{} preparing for file-based recovery from [{}]", recoveryTarget.shardId(), recoveryTarget.sourceNode())__        } else {_            logger.trace(_                "{} preparing for sequence-number-based recovery starting at local checkpoint [{}] from [{}]",_                recoveryTarget.shardId(),_                startingSeqNo,_                recoveryTarget.sourceNode())__        }__        request = new StartRecoveryRequest(_            recoveryTarget.shardId(),_            recoveryTarget.indexShard().routingEntry().allocationId().getId(),_            recoveryTarget.sourceNode(),_            clusterService.localNode(),_            metadataSnapshot,_            recoveryTarget.state().getPrimary(),_            recoveryTarget.recoveryId(),_            startingSeqNo)__        return request__    };prepare,the,start,recovery,request,param,recovery,target,the,target,of,the,recovery,return,a,start,recovery,request;private,start,recovery,request,get,start,recovery,request,final,recovery,target,recovery,target,final,start,recovery,request,request,logger,trace,collecting,local,files,for,recovery,target,shard,id,recovery,target,source,node,final,store,metadata,snapshot,metadata,snapshot,get,store,metadata,snapshot,recovery,target,logger,trace,local,file,count,recovery,target,shard,id,metadata,snapshot,size,final,long,starting,seq,no,if,metadata,snapshot,size,0,starting,seq,no,get,starting,seq,no,logger,recovery,target,else,starting,seq,no,sequence,numbers,if,starting,seq,no,sequence,numbers,logger,trace,preparing,for,file,based,recovery,from,recovery,target,shard,id,recovery,target,source,node,else,logger,trace,preparing,for,sequence,number,based,recovery,starting,at,local,checkpoint,from,recovery,target,shard,id,starting,seq,no,recovery,target,source,node,request,new,start,recovery,request,recovery,target,shard,id,recovery,target,index,shard,routing,entry,allocation,id,get,id,recovery,target,source,node,cluster,service,local,node,metadata,snapshot,recovery,target,state,get,primary,recovery,target,recovery,id,starting,seq,no,return,request
PeerRecoveryTargetService -> private StartRecoveryRequest getStartRecoveryRequest(final RecoveryTarget recoveryTarget);1547496886;Prepare the start recovery request.__@param recoveryTarget the target of the recovery_@return a start recovery request;private StartRecoveryRequest getStartRecoveryRequest(final RecoveryTarget recoveryTarget) {_        final StartRecoveryRequest request__        logger.trace("{} collecting local files for [{}]", recoveryTarget.shardId(), recoveryTarget.sourceNode())___        final Store.MetadataSnapshot metadataSnapshot = getStoreMetadataSnapshot(recoveryTarget)__        logger.trace("{} local file count [{}]", recoveryTarget.shardId(), metadataSnapshot.size())___        final long startingSeqNo__        if (metadataSnapshot.size() > 0) {_            startingSeqNo = getStartingSeqNo(logger, recoveryTarget)__        } else {_            startingSeqNo = SequenceNumbers.UNASSIGNED_SEQ_NO__        }__        if (startingSeqNo == SequenceNumbers.UNASSIGNED_SEQ_NO) {_            logger.trace("{} preparing for file-based recovery from [{}]", recoveryTarget.shardId(), recoveryTarget.sourceNode())__        } else {_            logger.trace(_                "{} preparing for sequence-number-based recovery starting at local checkpoint [{}] from [{}]",_                recoveryTarget.shardId(),_                startingSeqNo,_                recoveryTarget.sourceNode())__        }__        request = new StartRecoveryRequest(_            recoveryTarget.shardId(),_            recoveryTarget.indexShard().routingEntry().allocationId().getId(),_            recoveryTarget.sourceNode(),_            clusterService.localNode(),_            metadataSnapshot,_            recoveryTarget.state().getPrimary(),_            recoveryTarget.recoveryId(),_            startingSeqNo)__        return request__    };prepare,the,start,recovery,request,param,recovery,target,the,target,of,the,recovery,return,a,start,recovery,request;private,start,recovery,request,get,start,recovery,request,final,recovery,target,recovery,target,final,start,recovery,request,request,logger,trace,collecting,local,files,for,recovery,target,shard,id,recovery,target,source,node,final,store,metadata,snapshot,metadata,snapshot,get,store,metadata,snapshot,recovery,target,logger,trace,local,file,count,recovery,target,shard,id,metadata,snapshot,size,final,long,starting,seq,no,if,metadata,snapshot,size,0,starting,seq,no,get,starting,seq,no,logger,recovery,target,else,starting,seq,no,sequence,numbers,if,starting,seq,no,sequence,numbers,logger,trace,preparing,for,file,based,recovery,from,recovery,target,shard,id,recovery,target,source,node,else,logger,trace,preparing,for,sequence,number,based,recovery,starting,at,local,checkpoint,from,recovery,target,shard,id,starting,seq,no,recovery,target,source,node,request,new,start,recovery,request,recovery,target,shard,id,recovery,target,index,shard,routing,entry,allocation,id,get,id,recovery,target,source,node,cluster,service,local,node,metadata,snapshot,recovery,target,state,get,primary,recovery,target,recovery,id,starting,seq,no,return,request
PeerRecoveryTargetService -> private StartRecoveryRequest getStartRecoveryRequest(final RecoveryTarget recoveryTarget);1547508054;Prepare the start recovery request.__@param recoveryTarget the target of the recovery_@return a start recovery request;private StartRecoveryRequest getStartRecoveryRequest(final RecoveryTarget recoveryTarget) {_        final StartRecoveryRequest request__        logger.trace("{} collecting local files for [{}]", recoveryTarget.shardId(), recoveryTarget.sourceNode())___        final Store.MetadataSnapshot metadataSnapshot = getStoreMetadataSnapshot(recoveryTarget)__        logger.trace("{} local file count [{}]", recoveryTarget.shardId(), metadataSnapshot.size())___        final long startingSeqNo__        if (metadataSnapshot.size() > 0) {_            startingSeqNo = getStartingSeqNo(logger, recoveryTarget)__        } else {_            startingSeqNo = SequenceNumbers.UNASSIGNED_SEQ_NO__        }__        if (startingSeqNo == SequenceNumbers.UNASSIGNED_SEQ_NO) {_            logger.trace("{} preparing for file-based recovery from [{}]", recoveryTarget.shardId(), recoveryTarget.sourceNode())__        } else {_            logger.trace(_                "{} preparing for sequence-number-based recovery starting at local checkpoint [{}] from [{}]",_                recoveryTarget.shardId(),_                startingSeqNo,_                recoveryTarget.sourceNode())__        }__        request = new StartRecoveryRequest(_            recoveryTarget.shardId(),_            recoveryTarget.indexShard().routingEntry().allocationId().getId(),_            recoveryTarget.sourceNode(),_            clusterService.localNode(),_            metadataSnapshot,_            recoveryTarget.state().getPrimary(),_            recoveryTarget.recoveryId(),_            startingSeqNo)__        return request__    };prepare,the,start,recovery,request,param,recovery,target,the,target,of,the,recovery,return,a,start,recovery,request;private,start,recovery,request,get,start,recovery,request,final,recovery,target,recovery,target,final,start,recovery,request,request,logger,trace,collecting,local,files,for,recovery,target,shard,id,recovery,target,source,node,final,store,metadata,snapshot,metadata,snapshot,get,store,metadata,snapshot,recovery,target,logger,trace,local,file,count,recovery,target,shard,id,metadata,snapshot,size,final,long,starting,seq,no,if,metadata,snapshot,size,0,starting,seq,no,get,starting,seq,no,logger,recovery,target,else,starting,seq,no,sequence,numbers,if,starting,seq,no,sequence,numbers,logger,trace,preparing,for,file,based,recovery,from,recovery,target,shard,id,recovery,target,source,node,else,logger,trace,preparing,for,sequence,number,based,recovery,starting,at,local,checkpoint,from,recovery,target,shard,id,starting,seq,no,recovery,target,source,node,request,new,start,recovery,request,recovery,target,shard,id,recovery,target,index,shard,routing,entry,allocation,id,get,id,recovery,target,source,node,cluster,service,local,node,metadata,snapshot,recovery,target,state,get,primary,recovery,target,recovery,id,starting,seq,no,return,request
PeerRecoveryTargetService -> private StartRecoveryRequest getStartRecoveryRequest(final RecoveryTarget recoveryTarget);1547576245;Prepare the start recovery request.__@param recoveryTarget the target of the recovery_@return a start recovery request;private StartRecoveryRequest getStartRecoveryRequest(final RecoveryTarget recoveryTarget) {_        final StartRecoveryRequest request__        logger.trace("{} collecting local files for [{}]", recoveryTarget.shardId(), recoveryTarget.sourceNode())___        final Store.MetadataSnapshot metadataSnapshot = getStoreMetadataSnapshot(recoveryTarget)__        logger.trace("{} local file count [{}]", recoveryTarget.shardId(), metadataSnapshot.size())___        final long startingSeqNo__        if (metadataSnapshot.size() > 0) {_            startingSeqNo = getStartingSeqNo(logger, recoveryTarget)__        } else {_            startingSeqNo = SequenceNumbers.UNASSIGNED_SEQ_NO__        }__        if (startingSeqNo == SequenceNumbers.UNASSIGNED_SEQ_NO) {_            logger.trace("{} preparing for file-based recovery from [{}]", recoveryTarget.shardId(), recoveryTarget.sourceNode())__        } else {_            logger.trace(_                "{} preparing for sequence-number-based recovery starting at local checkpoint [{}] from [{}]",_                recoveryTarget.shardId(),_                startingSeqNo,_                recoveryTarget.sourceNode())__        }__        request = new StartRecoveryRequest(_            recoveryTarget.shardId(),_            recoveryTarget.indexShard().routingEntry().allocationId().getId(),_            recoveryTarget.sourceNode(),_            clusterService.localNode(),_            metadataSnapshot,_            recoveryTarget.state().getPrimary(),_            recoveryTarget.recoveryId(),_            startingSeqNo)__        return request__    };prepare,the,start,recovery,request,param,recovery,target,the,target,of,the,recovery,return,a,start,recovery,request;private,start,recovery,request,get,start,recovery,request,final,recovery,target,recovery,target,final,start,recovery,request,request,logger,trace,collecting,local,files,for,recovery,target,shard,id,recovery,target,source,node,final,store,metadata,snapshot,metadata,snapshot,get,store,metadata,snapshot,recovery,target,logger,trace,local,file,count,recovery,target,shard,id,metadata,snapshot,size,final,long,starting,seq,no,if,metadata,snapshot,size,0,starting,seq,no,get,starting,seq,no,logger,recovery,target,else,starting,seq,no,sequence,numbers,if,starting,seq,no,sequence,numbers,logger,trace,preparing,for,file,based,recovery,from,recovery,target,shard,id,recovery,target,source,node,else,logger,trace,preparing,for,sequence,number,based,recovery,starting,at,local,checkpoint,from,recovery,target,shard,id,starting,seq,no,recovery,target,source,node,request,new,start,recovery,request,recovery,target,shard,id,recovery,target,index,shard,routing,entry,allocation,id,get,id,recovery,target,source,node,cluster,service,local,node,metadata,snapshot,recovery,target,state,get,primary,recovery,target,recovery,id,starting,seq,no,return,request
PeerRecoveryTargetService -> private StartRecoveryRequest getStartRecoveryRequest(final RecoveryTarget recoveryTarget);1548124510;Prepare the start recovery request.__@param recoveryTarget the target of the recovery_@return a start recovery request;private StartRecoveryRequest getStartRecoveryRequest(final RecoveryTarget recoveryTarget) {_        final StartRecoveryRequest request__        logger.trace("{} collecting local files for [{}]", recoveryTarget.shardId(), recoveryTarget.sourceNode())___        final Store.MetadataSnapshot metadataSnapshot = getStoreMetadataSnapshot(recoveryTarget)__        logger.trace("{} local file count [{}]", recoveryTarget.shardId(), metadataSnapshot.size())___        final long startingSeqNo__        if (metadataSnapshot.size() > 0) {_            startingSeqNo = getStartingSeqNo(logger, recoveryTarget)__        } else {_            startingSeqNo = SequenceNumbers.UNASSIGNED_SEQ_NO__        }__        if (startingSeqNo == SequenceNumbers.UNASSIGNED_SEQ_NO) {_            logger.trace("{} preparing for file-based recovery from [{}]", recoveryTarget.shardId(), recoveryTarget.sourceNode())__        } else {_            logger.trace(_                "{} preparing for sequence-number-based recovery starting at local checkpoint [{}] from [{}]",_                recoveryTarget.shardId(),_                startingSeqNo,_                recoveryTarget.sourceNode())__        }__        request = new StartRecoveryRequest(_            recoveryTarget.shardId(),_            recoveryTarget.indexShard().routingEntry().allocationId().getId(),_            recoveryTarget.sourceNode(),_            clusterService.localNode(),_            metadataSnapshot,_            recoveryTarget.state().getPrimary(),_            recoveryTarget.recoveryId(),_            startingSeqNo)__        return request__    };prepare,the,start,recovery,request,param,recovery,target,the,target,of,the,recovery,return,a,start,recovery,request;private,start,recovery,request,get,start,recovery,request,final,recovery,target,recovery,target,final,start,recovery,request,request,logger,trace,collecting,local,files,for,recovery,target,shard,id,recovery,target,source,node,final,store,metadata,snapshot,metadata,snapshot,get,store,metadata,snapshot,recovery,target,logger,trace,local,file,count,recovery,target,shard,id,metadata,snapshot,size,final,long,starting,seq,no,if,metadata,snapshot,size,0,starting,seq,no,get,starting,seq,no,logger,recovery,target,else,starting,seq,no,sequence,numbers,if,starting,seq,no,sequence,numbers,logger,trace,preparing,for,file,based,recovery,from,recovery,target,shard,id,recovery,target,source,node,else,logger,trace,preparing,for,sequence,number,based,recovery,starting,at,local,checkpoint,from,recovery,target,shard,id,starting,seq,no,recovery,target,source,node,request,new,start,recovery,request,recovery,target,shard,id,recovery,target,index,shard,routing,entry,allocation,id,get,id,recovery,target,source,node,cluster,service,local,node,metadata,snapshot,recovery,target,state,get,primary,recovery,target,recovery,id,starting,seq,no,return,request
PeerRecoveryTargetService -> private StartRecoveryRequest getStartRecoveryRequest(final RecoveryTarget recoveryTarget);1548558090;Prepare the start recovery request.__@param recoveryTarget the target of the recovery_@return a start recovery request;private StartRecoveryRequest getStartRecoveryRequest(final RecoveryTarget recoveryTarget) {_        final StartRecoveryRequest request__        logger.trace("{} collecting local files for [{}]", recoveryTarget.shardId(), recoveryTarget.sourceNode())___        final Store.MetadataSnapshot metadataSnapshot = getStoreMetadataSnapshot(recoveryTarget)__        logger.trace("{} local file count [{}]", recoveryTarget.shardId(), metadataSnapshot.size())___        final long startingSeqNo__        if (metadataSnapshot.size() > 0) {_            startingSeqNo = getStartingSeqNo(logger, recoveryTarget)__        } else {_            startingSeqNo = SequenceNumbers.UNASSIGNED_SEQ_NO__        }__        if (startingSeqNo == SequenceNumbers.UNASSIGNED_SEQ_NO) {_            logger.trace("{} preparing for file-based recovery from [{}]", recoveryTarget.shardId(), recoveryTarget.sourceNode())__        } else {_            logger.trace(_                "{} preparing for sequence-number-based recovery starting at local checkpoint [{}] from [{}]",_                recoveryTarget.shardId(),_                startingSeqNo,_                recoveryTarget.sourceNode())__        }__        request = new StartRecoveryRequest(_            recoveryTarget.shardId(),_            recoveryTarget.indexShard().routingEntry().allocationId().getId(),_            recoveryTarget.sourceNode(),_            clusterService.localNode(),_            metadataSnapshot,_            recoveryTarget.state().getPrimary(),_            recoveryTarget.recoveryId(),_            startingSeqNo)__        return request__    };prepare,the,start,recovery,request,param,recovery,target,the,target,of,the,recovery,return,a,start,recovery,request;private,start,recovery,request,get,start,recovery,request,final,recovery,target,recovery,target,final,start,recovery,request,request,logger,trace,collecting,local,files,for,recovery,target,shard,id,recovery,target,source,node,final,store,metadata,snapshot,metadata,snapshot,get,store,metadata,snapshot,recovery,target,logger,trace,local,file,count,recovery,target,shard,id,metadata,snapshot,size,final,long,starting,seq,no,if,metadata,snapshot,size,0,starting,seq,no,get,starting,seq,no,logger,recovery,target,else,starting,seq,no,sequence,numbers,if,starting,seq,no,sequence,numbers,logger,trace,preparing,for,file,based,recovery,from,recovery,target,shard,id,recovery,target,source,node,else,logger,trace,preparing,for,sequence,number,based,recovery,starting,at,local,checkpoint,from,recovery,target,shard,id,starting,seq,no,recovery,target,source,node,request,new,start,recovery,request,recovery,target,shard,id,recovery,target,index,shard,routing,entry,allocation,id,get,id,recovery,target,source,node,cluster,service,local,node,metadata,snapshot,recovery,target,state,get,primary,recovery,target,recovery,id,starting,seq,no,return,request
PeerRecoveryTargetService -> private StartRecoveryRequest getStartRecoveryRequest(final RecoveryTarget recoveryTarget);1548953505;Prepare the start recovery request.__@param recoveryTarget the target of the recovery_@return a start recovery request;private StartRecoveryRequest getStartRecoveryRequest(final RecoveryTarget recoveryTarget) {_        final StartRecoveryRequest request__        logger.trace("{} collecting local files for [{}]", recoveryTarget.shardId(), recoveryTarget.sourceNode())___        final Store.MetadataSnapshot metadataSnapshot = getStoreMetadataSnapshot(recoveryTarget)__        logger.trace("{} local file count [{}]", recoveryTarget.shardId(), metadataSnapshot.size())___        final long startingSeqNo__        if (metadataSnapshot.size() > 0) {_            startingSeqNo = getStartingSeqNo(logger, recoveryTarget)__        } else {_            startingSeqNo = SequenceNumbers.UNASSIGNED_SEQ_NO__        }__        if (startingSeqNo == SequenceNumbers.UNASSIGNED_SEQ_NO) {_            logger.trace("{} preparing for file-based recovery from [{}]", recoveryTarget.shardId(), recoveryTarget.sourceNode())__        } else {_            logger.trace(_                "{} preparing for sequence-number-based recovery starting at local checkpoint [{}] from [{}]",_                recoveryTarget.shardId(),_                startingSeqNo,_                recoveryTarget.sourceNode())__        }__        request = new StartRecoveryRequest(_            recoveryTarget.shardId(),_            recoveryTarget.indexShard().routingEntry().allocationId().getId(),_            recoveryTarget.sourceNode(),_            clusterService.localNode(),_            metadataSnapshot,_            recoveryTarget.state().getPrimary(),_            recoveryTarget.recoveryId(),_            startingSeqNo)__        return request__    };prepare,the,start,recovery,request,param,recovery,target,the,target,of,the,recovery,return,a,start,recovery,request;private,start,recovery,request,get,start,recovery,request,final,recovery,target,recovery,target,final,start,recovery,request,request,logger,trace,collecting,local,files,for,recovery,target,shard,id,recovery,target,source,node,final,store,metadata,snapshot,metadata,snapshot,get,store,metadata,snapshot,recovery,target,logger,trace,local,file,count,recovery,target,shard,id,metadata,snapshot,size,final,long,starting,seq,no,if,metadata,snapshot,size,0,starting,seq,no,get,starting,seq,no,logger,recovery,target,else,starting,seq,no,sequence,numbers,if,starting,seq,no,sequence,numbers,logger,trace,preparing,for,file,based,recovery,from,recovery,target,shard,id,recovery,target,source,node,else,logger,trace,preparing,for,sequence,number,based,recovery,starting,at,local,checkpoint,from,recovery,target,shard,id,starting,seq,no,recovery,target,source,node,request,new,start,recovery,request,recovery,target,shard,id,recovery,target,index,shard,routing,entry,allocation,id,get,id,recovery,target,source,node,cluster,service,local,node,metadata,snapshot,recovery,target,state,get,primary,recovery,target,recovery,id,starting,seq,no,return,request
PeerRecoveryTargetService -> private StartRecoveryRequest getStartRecoveryRequest(final RecoveryTarget recoveryTarget);1549406621;Prepare the start recovery request.__@param recoveryTarget the target of the recovery_@return a start recovery request;private StartRecoveryRequest getStartRecoveryRequest(final RecoveryTarget recoveryTarget) {_        final StartRecoveryRequest request__        logger.trace("{} collecting local files for [{}]", recoveryTarget.shardId(), recoveryTarget.sourceNode())___        final Store.MetadataSnapshot metadataSnapshot = getStoreMetadataSnapshot(recoveryTarget)__        logger.trace("{} local file count [{}]", recoveryTarget.shardId(), metadataSnapshot.size())___        final long startingSeqNo__        if (metadataSnapshot.size() > 0) {_            startingSeqNo = getStartingSeqNo(logger, recoveryTarget)__        } else {_            startingSeqNo = SequenceNumbers.UNASSIGNED_SEQ_NO__        }__        if (startingSeqNo == SequenceNumbers.UNASSIGNED_SEQ_NO) {_            logger.trace("{} preparing for file-based recovery from [{}]", recoveryTarget.shardId(), recoveryTarget.sourceNode())__        } else {_            logger.trace(_                "{} preparing for sequence-number-based recovery starting at local checkpoint [{}] from [{}]",_                recoveryTarget.shardId(),_                startingSeqNo,_                recoveryTarget.sourceNode())__        }__        request = new StartRecoveryRequest(_            recoveryTarget.shardId(),_            recoveryTarget.indexShard().routingEntry().allocationId().getId(),_            recoveryTarget.sourceNode(),_            clusterService.localNode(),_            metadataSnapshot,_            recoveryTarget.state().getPrimary(),_            recoveryTarget.recoveryId(),_            startingSeqNo)__        return request__    };prepare,the,start,recovery,request,param,recovery,target,the,target,of,the,recovery,return,a,start,recovery,request;private,start,recovery,request,get,start,recovery,request,final,recovery,target,recovery,target,final,start,recovery,request,request,logger,trace,collecting,local,files,for,recovery,target,shard,id,recovery,target,source,node,final,store,metadata,snapshot,metadata,snapshot,get,store,metadata,snapshot,recovery,target,logger,trace,local,file,count,recovery,target,shard,id,metadata,snapshot,size,final,long,starting,seq,no,if,metadata,snapshot,size,0,starting,seq,no,get,starting,seq,no,logger,recovery,target,else,starting,seq,no,sequence,numbers,if,starting,seq,no,sequence,numbers,logger,trace,preparing,for,file,based,recovery,from,recovery,target,shard,id,recovery,target,source,node,else,logger,trace,preparing,for,sequence,number,based,recovery,starting,at,local,checkpoint,from,recovery,target,shard,id,starting,seq,no,recovery,target,source,node,request,new,start,recovery,request,recovery,target,shard,id,recovery,target,index,shard,routing,entry,allocation,id,get,id,recovery,target,source,node,cluster,service,local,node,metadata,snapshot,recovery,target,state,get,primary,recovery,target,recovery,id,starting,seq,no,return,request
PeerRecoveryTargetService -> public static long getStartingSeqNo(final Logger logger, final RecoveryTarget recoveryTarget);1524684173;Get the starting sequence number for a sequence-number-based request.__@param recoveryTarget the target of the recovery_@return the starting sequence number or {@link SequenceNumbers#UNASSIGNED_SEQ_NO} if obtaining the starting sequence number_failed;public static long getStartingSeqNo(final Logger logger, final RecoveryTarget recoveryTarget) {_        try {_            final Store store = recoveryTarget.store()__            final String translogUUID = store.readLastCommittedSegmentsInfo().getUserData().get(Translog.TRANSLOG_UUID_KEY)__            final long globalCheckpoint = Translog.readGlobalCheckpoint(recoveryTarget.translogLocation(), translogUUID)__            final List<IndexCommit> existingCommits = DirectoryReader.listCommits(store.directory())__            final IndexCommit safeCommit = CombinedDeletionPolicy.findSafeCommitPoint(existingCommits, globalCheckpoint)__            final SequenceNumbers.CommitInfo seqNoStats = Store.loadSeqNoInfo(safeCommit)__            if (logger.isTraceEnabled()) {_                final StringJoiner descriptionOfExistingCommits = new StringJoiner(",")__                for (IndexCommit commit : existingCommits) {_                    descriptionOfExistingCommits.add(CombinedDeletionPolicy.commitDescription(commit))__                }_                logger.trace("Calculate starting seqno based on global checkpoint [{}], safe commit [{}], existing commits [{}]",_                    globalCheckpoint, CombinedDeletionPolicy.commitDescription(safeCommit), descriptionOfExistingCommits)__            }_            if (seqNoStats.maxSeqNo <= globalCheckpoint) {_                assert seqNoStats.localCheckpoint <= globalCheckpoint__                _                return seqNoStats.localCheckpoint + 1__            } else {_                return SequenceNumbers.UNASSIGNED_SEQ_NO__            }_        } catch (final TranslogCorruptedException | IOException e) {_            _            return SequenceNumbers.UNASSIGNED_SEQ_NO__        }_    };get,the,starting,sequence,number,for,a,sequence,number,based,request,param,recovery,target,the,target,of,the,recovery,return,the,starting,sequence,number,or,link,sequence,numbers,if,obtaining,the,starting,sequence,number,failed;public,static,long,get,starting,seq,no,final,logger,logger,final,recovery,target,recovery,target,try,final,store,store,recovery,target,store,final,string,translog,uuid,store,read,last,committed,segments,info,get,user,data,get,translog,final,long,global,checkpoint,translog,read,global,checkpoint,recovery,target,translog,location,translog,uuid,final,list,index,commit,existing,commits,directory,reader,list,commits,store,directory,final,index,commit,safe,commit,combined,deletion,policy,find,safe,commit,point,existing,commits,global,checkpoint,final,sequence,numbers,commit,info,seq,no,stats,store,load,seq,no,info,safe,commit,if,logger,is,trace,enabled,final,string,joiner,description,of,existing,commits,new,string,joiner,for,index,commit,commit,existing,commits,description,of,existing,commits,add,combined,deletion,policy,commit,description,commit,logger,trace,calculate,starting,seqno,based,on,global,checkpoint,safe,commit,existing,commits,global,checkpoint,combined,deletion,policy,commit,description,safe,commit,description,of,existing,commits,if,seq,no,stats,max,seq,no,global,checkpoint,assert,seq,no,stats,local,checkpoint,global,checkpoint,return,seq,no,stats,local,checkpoint,1,else,return,sequence,numbers,catch,final,translog,corrupted,exception,ioexception,e,return,sequence,numbers
PeerRecoveryTargetService -> public static long getStartingSeqNo(final Logger logger, final RecoveryTarget recoveryTarget);1529687475;Get the starting sequence number for a sequence-number-based request.__@param recoveryTarget the target of the recovery_@return the starting sequence number or {@link SequenceNumbers#UNASSIGNED_SEQ_NO} if obtaining the starting sequence number_failed;public static long getStartingSeqNo(final Logger logger, final RecoveryTarget recoveryTarget) {_        try {_            final Store store = recoveryTarget.store()__            final String translogUUID = store.readLastCommittedSegmentsInfo().getUserData().get(Translog.TRANSLOG_UUID_KEY)__            final long globalCheckpoint = Translog.readGlobalCheckpoint(recoveryTarget.translogLocation(), translogUUID)__            final List<IndexCommit> existingCommits = DirectoryReader.listCommits(store.directory())__            final IndexCommit safeCommit = CombinedDeletionPolicy.findSafeCommitPoint(existingCommits, globalCheckpoint)__            final SequenceNumbers.CommitInfo seqNoStats = Store.loadSeqNoInfo(safeCommit)__            if (logger.isTraceEnabled()) {_                final StringJoiner descriptionOfExistingCommits = new StringJoiner(",")__                for (IndexCommit commit : existingCommits) {_                    descriptionOfExistingCommits.add(CombinedDeletionPolicy.commitDescription(commit))__                }_                logger.trace("Calculate starting seqno based on global checkpoint [{}], safe commit [{}], existing commits [{}]",_                    globalCheckpoint, CombinedDeletionPolicy.commitDescription(safeCommit), descriptionOfExistingCommits)__            }_            if (seqNoStats.maxSeqNo <= globalCheckpoint) {_                assert seqNoStats.localCheckpoint <= globalCheckpoint__                _                return seqNoStats.localCheckpoint + 1__            } else {_                return SequenceNumbers.UNASSIGNED_SEQ_NO__            }_        } catch (final TranslogCorruptedException | IOException e) {_            _            return SequenceNumbers.UNASSIGNED_SEQ_NO__        }_    };get,the,starting,sequence,number,for,a,sequence,number,based,request,param,recovery,target,the,target,of,the,recovery,return,the,starting,sequence,number,or,link,sequence,numbers,if,obtaining,the,starting,sequence,number,failed;public,static,long,get,starting,seq,no,final,logger,logger,final,recovery,target,recovery,target,try,final,store,store,recovery,target,store,final,string,translog,uuid,store,read,last,committed,segments,info,get,user,data,get,translog,final,long,global,checkpoint,translog,read,global,checkpoint,recovery,target,translog,location,translog,uuid,final,list,index,commit,existing,commits,directory,reader,list,commits,store,directory,final,index,commit,safe,commit,combined,deletion,policy,find,safe,commit,point,existing,commits,global,checkpoint,final,sequence,numbers,commit,info,seq,no,stats,store,load,seq,no,info,safe,commit,if,logger,is,trace,enabled,final,string,joiner,description,of,existing,commits,new,string,joiner,for,index,commit,commit,existing,commits,description,of,existing,commits,add,combined,deletion,policy,commit,description,commit,logger,trace,calculate,starting,seqno,based,on,global,checkpoint,safe,commit,existing,commits,global,checkpoint,combined,deletion,policy,commit,description,safe,commit,description,of,existing,commits,if,seq,no,stats,max,seq,no,global,checkpoint,assert,seq,no,stats,local,checkpoint,global,checkpoint,return,seq,no,stats,local,checkpoint,1,else,return,sequence,numbers,catch,final,translog,corrupted,exception,ioexception,e,return,sequence,numbers
PeerRecoveryTargetService -> public static long getStartingSeqNo(final Logger logger, final RecoveryTarget recoveryTarget);1537806831;Get the starting sequence number for a sequence-number-based request.__@param recoveryTarget the target of the recovery_@return the starting sequence number or {@link SequenceNumbers#UNASSIGNED_SEQ_NO} if obtaining the starting sequence number_failed;public static long getStartingSeqNo(final Logger logger, final RecoveryTarget recoveryTarget) {_        try {_            final Store store = recoveryTarget.store()__            final String translogUUID = store.readLastCommittedSegmentsInfo().getUserData().get(Translog.TRANSLOG_UUID_KEY)__            final long globalCheckpoint = Translog.readGlobalCheckpoint(recoveryTarget.translogLocation(), translogUUID)__            final List<IndexCommit> existingCommits = DirectoryReader.listCommits(store.directory())__            final IndexCommit safeCommit = CombinedDeletionPolicy.findSafeCommitPoint(existingCommits, globalCheckpoint)__            final SequenceNumbers.CommitInfo seqNoStats = Store.loadSeqNoInfo(safeCommit)__            if (logger.isTraceEnabled()) {_                final StringJoiner descriptionOfExistingCommits = new StringJoiner(",")__                for (IndexCommit commit : existingCommits) {_                    descriptionOfExistingCommits.add(CombinedDeletionPolicy.commitDescription(commit))__                }_                logger.trace("Calculate starting seqno based on global checkpoint [{}], safe commit [{}], existing commits [{}]",_                    globalCheckpoint, CombinedDeletionPolicy.commitDescription(safeCommit), descriptionOfExistingCommits)__            }_            if (seqNoStats.maxSeqNo <= globalCheckpoint) {_                assert seqNoStats.localCheckpoint <= globalCheckpoint__                _                return seqNoStats.localCheckpoint + 1__            } else {_                return SequenceNumbers.UNASSIGNED_SEQ_NO__            }_        } catch (final TranslogCorruptedException | IOException e) {_            _            return SequenceNumbers.UNASSIGNED_SEQ_NO__        }_    };get,the,starting,sequence,number,for,a,sequence,number,based,request,param,recovery,target,the,target,of,the,recovery,return,the,starting,sequence,number,or,link,sequence,numbers,if,obtaining,the,starting,sequence,number,failed;public,static,long,get,starting,seq,no,final,logger,logger,final,recovery,target,recovery,target,try,final,store,store,recovery,target,store,final,string,translog,uuid,store,read,last,committed,segments,info,get,user,data,get,translog,final,long,global,checkpoint,translog,read,global,checkpoint,recovery,target,translog,location,translog,uuid,final,list,index,commit,existing,commits,directory,reader,list,commits,store,directory,final,index,commit,safe,commit,combined,deletion,policy,find,safe,commit,point,existing,commits,global,checkpoint,final,sequence,numbers,commit,info,seq,no,stats,store,load,seq,no,info,safe,commit,if,logger,is,trace,enabled,final,string,joiner,description,of,existing,commits,new,string,joiner,for,index,commit,commit,existing,commits,description,of,existing,commits,add,combined,deletion,policy,commit,description,commit,logger,trace,calculate,starting,seqno,based,on,global,checkpoint,safe,commit,existing,commits,global,checkpoint,combined,deletion,policy,commit,description,safe,commit,description,of,existing,commits,if,seq,no,stats,max,seq,no,global,checkpoint,assert,seq,no,stats,local,checkpoint,global,checkpoint,return,seq,no,stats,local,checkpoint,1,else,return,sequence,numbers,catch,final,translog,corrupted,exception,ioexception,e,return,sequence,numbers
PeerRecoveryTargetService -> public static long getStartingSeqNo(final Logger logger, final RecoveryTarget recoveryTarget);1538067637;Get the starting sequence number for a sequence-number-based request.__@param recoveryTarget the target of the recovery_@return the starting sequence number or {@link SequenceNumbers#UNASSIGNED_SEQ_NO} if obtaining the starting sequence number_failed;public static long getStartingSeqNo(final Logger logger, final RecoveryTarget recoveryTarget) {_        try {_            final Store store = recoveryTarget.store()__            final String translogUUID = store.readLastCommittedSegmentsInfo().getUserData().get(Translog.TRANSLOG_UUID_KEY)__            final long globalCheckpoint = Translog.readGlobalCheckpoint(recoveryTarget.translogLocation(), translogUUID)__            final List<IndexCommit> existingCommits = DirectoryReader.listCommits(store.directory())__            final IndexCommit safeCommit = CombinedDeletionPolicy.findSafeCommitPoint(existingCommits, globalCheckpoint)__            final SequenceNumbers.CommitInfo seqNoStats = Store.loadSeqNoInfo(safeCommit)__            if (logger.isTraceEnabled()) {_                final StringJoiner descriptionOfExistingCommits = new StringJoiner(",")__                for (IndexCommit commit : existingCommits) {_                    descriptionOfExistingCommits.add(CombinedDeletionPolicy.commitDescription(commit))__                }_                logger.trace("Calculate starting seqno based on global checkpoint [{}], safe commit [{}], existing commits [{}]",_                    globalCheckpoint, CombinedDeletionPolicy.commitDescription(safeCommit), descriptionOfExistingCommits)__            }_            if (seqNoStats.maxSeqNo <= globalCheckpoint) {_                assert seqNoStats.localCheckpoint <= globalCheckpoint__                _                return seqNoStats.localCheckpoint + 1__            } else {_                return SequenceNumbers.UNASSIGNED_SEQ_NO__            }_        } catch (final TranslogCorruptedException | IOException e) {_            _            return SequenceNumbers.UNASSIGNED_SEQ_NO__        }_    };get,the,starting,sequence,number,for,a,sequence,number,based,request,param,recovery,target,the,target,of,the,recovery,return,the,starting,sequence,number,or,link,sequence,numbers,if,obtaining,the,starting,sequence,number,failed;public,static,long,get,starting,seq,no,final,logger,logger,final,recovery,target,recovery,target,try,final,store,store,recovery,target,store,final,string,translog,uuid,store,read,last,committed,segments,info,get,user,data,get,translog,final,long,global,checkpoint,translog,read,global,checkpoint,recovery,target,translog,location,translog,uuid,final,list,index,commit,existing,commits,directory,reader,list,commits,store,directory,final,index,commit,safe,commit,combined,deletion,policy,find,safe,commit,point,existing,commits,global,checkpoint,final,sequence,numbers,commit,info,seq,no,stats,store,load,seq,no,info,safe,commit,if,logger,is,trace,enabled,final,string,joiner,description,of,existing,commits,new,string,joiner,for,index,commit,commit,existing,commits,description,of,existing,commits,add,combined,deletion,policy,commit,description,commit,logger,trace,calculate,starting,seqno,based,on,global,checkpoint,safe,commit,existing,commits,global,checkpoint,combined,deletion,policy,commit,description,safe,commit,description,of,existing,commits,if,seq,no,stats,max,seq,no,global,checkpoint,assert,seq,no,stats,local,checkpoint,global,checkpoint,return,seq,no,stats,local,checkpoint,1,else,return,sequence,numbers,catch,final,translog,corrupted,exception,ioexception,e,return,sequence,numbers
PeerRecoveryTargetService -> public static long getStartingSeqNo(final Logger logger, final RecoveryTarget recoveryTarget);1540583181;Get the starting sequence number for a sequence-number-based request.__@param recoveryTarget the target of the recovery_@return the starting sequence number or {@link SequenceNumbers#UNASSIGNED_SEQ_NO} if obtaining the starting sequence number_failed;public static long getStartingSeqNo(final Logger logger, final RecoveryTarget recoveryTarget) {_        try {_            final Store store = recoveryTarget.store()__            final String translogUUID = store.readLastCommittedSegmentsInfo().getUserData().get(Translog.TRANSLOG_UUID_KEY)__            final long globalCheckpoint = Translog.readGlobalCheckpoint(recoveryTarget.translogLocation(), translogUUID)__            final List<IndexCommit> existingCommits = DirectoryReader.listCommits(store.directory())__            final IndexCommit safeCommit = CombinedDeletionPolicy.findSafeCommitPoint(existingCommits, globalCheckpoint)__            final SequenceNumbers.CommitInfo seqNoStats = Store.loadSeqNoInfo(safeCommit)__            if (logger.isTraceEnabled()) {_                final StringJoiner descriptionOfExistingCommits = new StringJoiner(",")__                for (IndexCommit commit : existingCommits) {_                    descriptionOfExistingCommits.add(CombinedDeletionPolicy.commitDescription(commit))__                }_                logger.trace("Calculate starting seqno based on global checkpoint [{}], safe commit [{}], existing commits [{}]",_                    globalCheckpoint, CombinedDeletionPolicy.commitDescription(safeCommit), descriptionOfExistingCommits)__            }_            if (seqNoStats.maxSeqNo <= globalCheckpoint) {_                assert seqNoStats.localCheckpoint <= globalCheckpoint__                _                return seqNoStats.localCheckpoint + 1__            } else {_                return SequenceNumbers.UNASSIGNED_SEQ_NO__            }_        } catch (final TranslogCorruptedException | IOException e) {_            _            return SequenceNumbers.UNASSIGNED_SEQ_NO__        }_    };get,the,starting,sequence,number,for,a,sequence,number,based,request,param,recovery,target,the,target,of,the,recovery,return,the,starting,sequence,number,or,link,sequence,numbers,if,obtaining,the,starting,sequence,number,failed;public,static,long,get,starting,seq,no,final,logger,logger,final,recovery,target,recovery,target,try,final,store,store,recovery,target,store,final,string,translog,uuid,store,read,last,committed,segments,info,get,user,data,get,translog,final,long,global,checkpoint,translog,read,global,checkpoint,recovery,target,translog,location,translog,uuid,final,list,index,commit,existing,commits,directory,reader,list,commits,store,directory,final,index,commit,safe,commit,combined,deletion,policy,find,safe,commit,point,existing,commits,global,checkpoint,final,sequence,numbers,commit,info,seq,no,stats,store,load,seq,no,info,safe,commit,if,logger,is,trace,enabled,final,string,joiner,description,of,existing,commits,new,string,joiner,for,index,commit,commit,existing,commits,description,of,existing,commits,add,combined,deletion,policy,commit,description,commit,logger,trace,calculate,starting,seqno,based,on,global,checkpoint,safe,commit,existing,commits,global,checkpoint,combined,deletion,policy,commit,description,safe,commit,description,of,existing,commits,if,seq,no,stats,max,seq,no,global,checkpoint,assert,seq,no,stats,local,checkpoint,global,checkpoint,return,seq,no,stats,local,checkpoint,1,else,return,sequence,numbers,catch,final,translog,corrupted,exception,ioexception,e,return,sequence,numbers
PeerRecoveryTargetService -> public static long getStartingSeqNo(final Logger logger, final RecoveryTarget recoveryTarget);1541092382;Get the starting sequence number for a sequence-number-based request.__@param recoveryTarget the target of the recovery_@return the starting sequence number or {@link SequenceNumbers#UNASSIGNED_SEQ_NO} if obtaining the starting sequence number_failed;public static long getStartingSeqNo(final Logger logger, final RecoveryTarget recoveryTarget) {_        try {_            final Store store = recoveryTarget.store()__            final String translogUUID = store.readLastCommittedSegmentsInfo().getUserData().get(Translog.TRANSLOG_UUID_KEY)__            final long globalCheckpoint = Translog.readGlobalCheckpoint(recoveryTarget.translogLocation(), translogUUID)__            final List<IndexCommit> existingCommits = DirectoryReader.listCommits(store.directory())__            final IndexCommit safeCommit = CombinedDeletionPolicy.findSafeCommitPoint(existingCommits, globalCheckpoint)__            final SequenceNumbers.CommitInfo seqNoStats = Store.loadSeqNoInfo(safeCommit)__            if (logger.isTraceEnabled()) {_                final StringJoiner descriptionOfExistingCommits = new StringJoiner(",")__                for (IndexCommit commit : existingCommits) {_                    descriptionOfExistingCommits.add(CombinedDeletionPolicy.commitDescription(commit))__                }_                logger.trace("Calculate starting seqno based on global checkpoint [{}], safe commit [{}], existing commits [{}]",_                    globalCheckpoint, CombinedDeletionPolicy.commitDescription(safeCommit), descriptionOfExistingCommits)__            }_            if (seqNoStats.maxSeqNo <= globalCheckpoint) {_                assert seqNoStats.localCheckpoint <= globalCheckpoint__                _                return seqNoStats.localCheckpoint + 1__            } else {_                return SequenceNumbers.UNASSIGNED_SEQ_NO__            }_        } catch (final TranslogCorruptedException | IOException e) {_            _            return SequenceNumbers.UNASSIGNED_SEQ_NO__        }_    };get,the,starting,sequence,number,for,a,sequence,number,based,request,param,recovery,target,the,target,of,the,recovery,return,the,starting,sequence,number,or,link,sequence,numbers,if,obtaining,the,starting,sequence,number,failed;public,static,long,get,starting,seq,no,final,logger,logger,final,recovery,target,recovery,target,try,final,store,store,recovery,target,store,final,string,translog,uuid,store,read,last,committed,segments,info,get,user,data,get,translog,final,long,global,checkpoint,translog,read,global,checkpoint,recovery,target,translog,location,translog,uuid,final,list,index,commit,existing,commits,directory,reader,list,commits,store,directory,final,index,commit,safe,commit,combined,deletion,policy,find,safe,commit,point,existing,commits,global,checkpoint,final,sequence,numbers,commit,info,seq,no,stats,store,load,seq,no,info,safe,commit,if,logger,is,trace,enabled,final,string,joiner,description,of,existing,commits,new,string,joiner,for,index,commit,commit,existing,commits,description,of,existing,commits,add,combined,deletion,policy,commit,description,commit,logger,trace,calculate,starting,seqno,based,on,global,checkpoint,safe,commit,existing,commits,global,checkpoint,combined,deletion,policy,commit,description,safe,commit,description,of,existing,commits,if,seq,no,stats,max,seq,no,global,checkpoint,assert,seq,no,stats,local,checkpoint,global,checkpoint,return,seq,no,stats,local,checkpoint,1,else,return,sequence,numbers,catch,final,translog,corrupted,exception,ioexception,e,return,sequence,numbers
PeerRecoveryTargetService -> public static long getStartingSeqNo(final Logger logger, final RecoveryTarget recoveryTarget);1542402632;Get the starting sequence number for a sequence-number-based request.__@param recoveryTarget the target of the recovery_@return the starting sequence number or {@link SequenceNumbers#UNASSIGNED_SEQ_NO} if obtaining the starting sequence number_failed;public static long getStartingSeqNo(final Logger logger, final RecoveryTarget recoveryTarget) {_        try {_            final Store store = recoveryTarget.store()__            final String translogUUID = store.readLastCommittedSegmentsInfo().getUserData().get(Translog.TRANSLOG_UUID_KEY)__            final long globalCheckpoint = Translog.readGlobalCheckpoint(recoveryTarget.translogLocation(), translogUUID)__            final List<IndexCommit> existingCommits = DirectoryReader.listCommits(store.directory())__            final IndexCommit safeCommit = CombinedDeletionPolicy.findSafeCommitPoint(existingCommits, globalCheckpoint)__            final SequenceNumbers.CommitInfo seqNoStats = Store.loadSeqNoInfo(safeCommit)__            if (logger.isTraceEnabled()) {_                final StringJoiner descriptionOfExistingCommits = new StringJoiner(",")__                for (IndexCommit commit : existingCommits) {_                    descriptionOfExistingCommits.add(CombinedDeletionPolicy.commitDescription(commit))__                }_                logger.trace("Calculate starting seqno based on global checkpoint [{}], safe commit [{}], existing commits [{}]",_                    globalCheckpoint, CombinedDeletionPolicy.commitDescription(safeCommit), descriptionOfExistingCommits)__            }_            if (seqNoStats.maxSeqNo <= globalCheckpoint) {_                assert seqNoStats.localCheckpoint <= globalCheckpoint__                _                return seqNoStats.localCheckpoint + 1__            } else {_                return SequenceNumbers.UNASSIGNED_SEQ_NO__            }_        } catch (final TranslogCorruptedException | IOException e) {_            _            return SequenceNumbers.UNASSIGNED_SEQ_NO__        }_    };get,the,starting,sequence,number,for,a,sequence,number,based,request,param,recovery,target,the,target,of,the,recovery,return,the,starting,sequence,number,or,link,sequence,numbers,if,obtaining,the,starting,sequence,number,failed;public,static,long,get,starting,seq,no,final,logger,logger,final,recovery,target,recovery,target,try,final,store,store,recovery,target,store,final,string,translog,uuid,store,read,last,committed,segments,info,get,user,data,get,translog,final,long,global,checkpoint,translog,read,global,checkpoint,recovery,target,translog,location,translog,uuid,final,list,index,commit,existing,commits,directory,reader,list,commits,store,directory,final,index,commit,safe,commit,combined,deletion,policy,find,safe,commit,point,existing,commits,global,checkpoint,final,sequence,numbers,commit,info,seq,no,stats,store,load,seq,no,info,safe,commit,if,logger,is,trace,enabled,final,string,joiner,description,of,existing,commits,new,string,joiner,for,index,commit,commit,existing,commits,description,of,existing,commits,add,combined,deletion,policy,commit,description,commit,logger,trace,calculate,starting,seqno,based,on,global,checkpoint,safe,commit,existing,commits,global,checkpoint,combined,deletion,policy,commit,description,safe,commit,description,of,existing,commits,if,seq,no,stats,max,seq,no,global,checkpoint,assert,seq,no,stats,local,checkpoint,global,checkpoint,return,seq,no,stats,local,checkpoint,1,else,return,sequence,numbers,catch,final,translog,corrupted,exception,ioexception,e,return,sequence,numbers
PeerRecoveryTargetService -> public static long getStartingSeqNo(final Logger logger, final RecoveryTarget recoveryTarget);1546606266;Get the starting sequence number for a sequence-number-based request.__@param recoveryTarget the target of the recovery_@return the starting sequence number or {@link SequenceNumbers#UNASSIGNED_SEQ_NO} if obtaining the starting sequence number_failed;public static long getStartingSeqNo(final Logger logger, final RecoveryTarget recoveryTarget) {_        try {_            final Store store = recoveryTarget.store()__            final String translogUUID = store.readLastCommittedSegmentsInfo().getUserData().get(Translog.TRANSLOG_UUID_KEY)__            final long globalCheckpoint = Translog.readGlobalCheckpoint(recoveryTarget.translogLocation(), translogUUID)__            final List<IndexCommit> existingCommits = DirectoryReader.listCommits(store.directory())__            final IndexCommit safeCommit = CombinedDeletionPolicy.findSafeCommitPoint(existingCommits, globalCheckpoint)__            final SequenceNumbers.CommitInfo seqNoStats = Store.loadSeqNoInfo(safeCommit)__            if (logger.isTraceEnabled()) {_                final StringJoiner descriptionOfExistingCommits = new StringJoiner(",")__                for (IndexCommit commit : existingCommits) {_                    descriptionOfExistingCommits.add(CombinedDeletionPolicy.commitDescription(commit))__                }_                logger.trace("Calculate starting seqno based on global checkpoint [{}], safe commit [{}], existing commits [{}]",_                    globalCheckpoint, CombinedDeletionPolicy.commitDescription(safeCommit), descriptionOfExistingCommits)__            }_            if (seqNoStats.maxSeqNo <= globalCheckpoint) {_                assert seqNoStats.localCheckpoint <= globalCheckpoint__                _                return seqNoStats.localCheckpoint + 1__            } else {_                return SequenceNumbers.UNASSIGNED_SEQ_NO__            }_        } catch (final TranslogCorruptedException | IOException e) {_            _            return SequenceNumbers.UNASSIGNED_SEQ_NO__        }_    };get,the,starting,sequence,number,for,a,sequence,number,based,request,param,recovery,target,the,target,of,the,recovery,return,the,starting,sequence,number,or,link,sequence,numbers,if,obtaining,the,starting,sequence,number,failed;public,static,long,get,starting,seq,no,final,logger,logger,final,recovery,target,recovery,target,try,final,store,store,recovery,target,store,final,string,translog,uuid,store,read,last,committed,segments,info,get,user,data,get,translog,final,long,global,checkpoint,translog,read,global,checkpoint,recovery,target,translog,location,translog,uuid,final,list,index,commit,existing,commits,directory,reader,list,commits,store,directory,final,index,commit,safe,commit,combined,deletion,policy,find,safe,commit,point,existing,commits,global,checkpoint,final,sequence,numbers,commit,info,seq,no,stats,store,load,seq,no,info,safe,commit,if,logger,is,trace,enabled,final,string,joiner,description,of,existing,commits,new,string,joiner,for,index,commit,commit,existing,commits,description,of,existing,commits,add,combined,deletion,policy,commit,description,commit,logger,trace,calculate,starting,seqno,based,on,global,checkpoint,safe,commit,existing,commits,global,checkpoint,combined,deletion,policy,commit,description,safe,commit,description,of,existing,commits,if,seq,no,stats,max,seq,no,global,checkpoint,assert,seq,no,stats,local,checkpoint,global,checkpoint,return,seq,no,stats,local,checkpoint,1,else,return,sequence,numbers,catch,final,translog,corrupted,exception,ioexception,e,return,sequence,numbers
PeerRecoveryTargetService -> public static long getStartingSeqNo(final Logger logger, final RecoveryTarget recoveryTarget);1546981938;Get the starting sequence number for a sequence-number-based request.__@param recoveryTarget the target of the recovery_@return the starting sequence number or {@link SequenceNumbers#UNASSIGNED_SEQ_NO} if obtaining the starting sequence number_failed;public static long getStartingSeqNo(final Logger logger, final RecoveryTarget recoveryTarget) {_        try {_            final Store store = recoveryTarget.store()__            final String translogUUID = store.readLastCommittedSegmentsInfo().getUserData().get(Translog.TRANSLOG_UUID_KEY)__            final long globalCheckpoint = Translog.readGlobalCheckpoint(recoveryTarget.translogLocation(), translogUUID)__            final List<IndexCommit> existingCommits = DirectoryReader.listCommits(store.directory())__            final IndexCommit safeCommit = CombinedDeletionPolicy.findSafeCommitPoint(existingCommits, globalCheckpoint)__            final SequenceNumbers.CommitInfo seqNoStats = Store.loadSeqNoInfo(safeCommit)__            if (logger.isTraceEnabled()) {_                final StringJoiner descriptionOfExistingCommits = new StringJoiner(",")__                for (IndexCommit commit : existingCommits) {_                    descriptionOfExistingCommits.add(CombinedDeletionPolicy.commitDescription(commit))__                }_                logger.trace("Calculate starting seqno based on global checkpoint [{}], safe commit [{}], existing commits [{}]",_                    globalCheckpoint, CombinedDeletionPolicy.commitDescription(safeCommit), descriptionOfExistingCommits)__            }_            if (seqNoStats.maxSeqNo <= globalCheckpoint) {_                assert seqNoStats.localCheckpoint <= globalCheckpoint__                _                return seqNoStats.localCheckpoint + 1__            } else {_                return SequenceNumbers.UNASSIGNED_SEQ_NO__            }_        } catch (final TranslogCorruptedException | IOException e) {_            _            return SequenceNumbers.UNASSIGNED_SEQ_NO__        }_    };get,the,starting,sequence,number,for,a,sequence,number,based,request,param,recovery,target,the,target,of,the,recovery,return,the,starting,sequence,number,or,link,sequence,numbers,if,obtaining,the,starting,sequence,number,failed;public,static,long,get,starting,seq,no,final,logger,logger,final,recovery,target,recovery,target,try,final,store,store,recovery,target,store,final,string,translog,uuid,store,read,last,committed,segments,info,get,user,data,get,translog,final,long,global,checkpoint,translog,read,global,checkpoint,recovery,target,translog,location,translog,uuid,final,list,index,commit,existing,commits,directory,reader,list,commits,store,directory,final,index,commit,safe,commit,combined,deletion,policy,find,safe,commit,point,existing,commits,global,checkpoint,final,sequence,numbers,commit,info,seq,no,stats,store,load,seq,no,info,safe,commit,if,logger,is,trace,enabled,final,string,joiner,description,of,existing,commits,new,string,joiner,for,index,commit,commit,existing,commits,description,of,existing,commits,add,combined,deletion,policy,commit,description,commit,logger,trace,calculate,starting,seqno,based,on,global,checkpoint,safe,commit,existing,commits,global,checkpoint,combined,deletion,policy,commit,description,safe,commit,description,of,existing,commits,if,seq,no,stats,max,seq,no,global,checkpoint,assert,seq,no,stats,local,checkpoint,global,checkpoint,return,seq,no,stats,local,checkpoint,1,else,return,sequence,numbers,catch,final,translog,corrupted,exception,ioexception,e,return,sequence,numbers
PeerRecoveryTargetService -> public static long getStartingSeqNo(final Logger logger, final RecoveryTarget recoveryTarget);1547496886;Get the starting sequence number for a sequence-number-based request.__@param recoveryTarget the target of the recovery_@return the starting sequence number or {@link SequenceNumbers#UNASSIGNED_SEQ_NO} if obtaining the starting sequence number_failed;public static long getStartingSeqNo(final Logger logger, final RecoveryTarget recoveryTarget) {_        try {_            final Store store = recoveryTarget.store()__            final String translogUUID = store.readLastCommittedSegmentsInfo().getUserData().get(Translog.TRANSLOG_UUID_KEY)__            final long globalCheckpoint = Translog.readGlobalCheckpoint(recoveryTarget.translogLocation(), translogUUID)__            final List<IndexCommit> existingCommits = DirectoryReader.listCommits(store.directory())__            final IndexCommit safeCommit = CombinedDeletionPolicy.findSafeCommitPoint(existingCommits, globalCheckpoint)__            final SequenceNumbers.CommitInfo seqNoStats = Store.loadSeqNoInfo(safeCommit)__            if (logger.isTraceEnabled()) {_                final StringJoiner descriptionOfExistingCommits = new StringJoiner(",")__                for (IndexCommit commit : existingCommits) {_                    descriptionOfExistingCommits.add(CombinedDeletionPolicy.commitDescription(commit))__                }_                logger.trace("Calculate starting seqno based on global checkpoint [{}], safe commit [{}], existing commits [{}]",_                    globalCheckpoint, CombinedDeletionPolicy.commitDescription(safeCommit), descriptionOfExistingCommits)__            }_            if (seqNoStats.maxSeqNo <= globalCheckpoint) {_                assert seqNoStats.localCheckpoint <= globalCheckpoint__                _                return seqNoStats.localCheckpoint + 1__            } else {_                return SequenceNumbers.UNASSIGNED_SEQ_NO__            }_        } catch (final TranslogCorruptedException | IOException e) {_            _            return SequenceNumbers.UNASSIGNED_SEQ_NO__        }_    };get,the,starting,sequence,number,for,a,sequence,number,based,request,param,recovery,target,the,target,of,the,recovery,return,the,starting,sequence,number,or,link,sequence,numbers,if,obtaining,the,starting,sequence,number,failed;public,static,long,get,starting,seq,no,final,logger,logger,final,recovery,target,recovery,target,try,final,store,store,recovery,target,store,final,string,translog,uuid,store,read,last,committed,segments,info,get,user,data,get,translog,final,long,global,checkpoint,translog,read,global,checkpoint,recovery,target,translog,location,translog,uuid,final,list,index,commit,existing,commits,directory,reader,list,commits,store,directory,final,index,commit,safe,commit,combined,deletion,policy,find,safe,commit,point,existing,commits,global,checkpoint,final,sequence,numbers,commit,info,seq,no,stats,store,load,seq,no,info,safe,commit,if,logger,is,trace,enabled,final,string,joiner,description,of,existing,commits,new,string,joiner,for,index,commit,commit,existing,commits,description,of,existing,commits,add,combined,deletion,policy,commit,description,commit,logger,trace,calculate,starting,seqno,based,on,global,checkpoint,safe,commit,existing,commits,global,checkpoint,combined,deletion,policy,commit,description,safe,commit,description,of,existing,commits,if,seq,no,stats,max,seq,no,global,checkpoint,assert,seq,no,stats,local,checkpoint,global,checkpoint,return,seq,no,stats,local,checkpoint,1,else,return,sequence,numbers,catch,final,translog,corrupted,exception,ioexception,e,return,sequence,numbers
PeerRecoveryTargetService -> public static long getStartingSeqNo(final Logger logger, final RecoveryTarget recoveryTarget);1547508054;Get the starting sequence number for a sequence-number-based request.__@param recoveryTarget the target of the recovery_@return the starting sequence number or {@link SequenceNumbers#UNASSIGNED_SEQ_NO} if obtaining the starting sequence number_failed;public static long getStartingSeqNo(final Logger logger, final RecoveryTarget recoveryTarget) {_        try {_            final Store store = recoveryTarget.store()__            final String translogUUID = store.readLastCommittedSegmentsInfo().getUserData().get(Translog.TRANSLOG_UUID_KEY)__            final long globalCheckpoint = Translog.readGlobalCheckpoint(recoveryTarget.translogLocation(), translogUUID)__            final List<IndexCommit> existingCommits = DirectoryReader.listCommits(store.directory())__            final IndexCommit safeCommit = CombinedDeletionPolicy.findSafeCommitPoint(existingCommits, globalCheckpoint)__            final SequenceNumbers.CommitInfo seqNoStats = Store.loadSeqNoInfo(safeCommit)__            if (logger.isTraceEnabled()) {_                final StringJoiner descriptionOfExistingCommits = new StringJoiner(",")__                for (IndexCommit commit : existingCommits) {_                    descriptionOfExistingCommits.add(CombinedDeletionPolicy.commitDescription(commit))__                }_                logger.trace("Calculate starting seqno based on global checkpoint [{}], safe commit [{}], existing commits [{}]",_                    globalCheckpoint, CombinedDeletionPolicy.commitDescription(safeCommit), descriptionOfExistingCommits)__            }_            if (seqNoStats.maxSeqNo <= globalCheckpoint) {_                assert seqNoStats.localCheckpoint <= globalCheckpoint__                _                return seqNoStats.localCheckpoint + 1__            } else {_                return SequenceNumbers.UNASSIGNED_SEQ_NO__            }_        } catch (final TranslogCorruptedException | IOException e) {_            _            return SequenceNumbers.UNASSIGNED_SEQ_NO__        }_    };get,the,starting,sequence,number,for,a,sequence,number,based,request,param,recovery,target,the,target,of,the,recovery,return,the,starting,sequence,number,or,link,sequence,numbers,if,obtaining,the,starting,sequence,number,failed;public,static,long,get,starting,seq,no,final,logger,logger,final,recovery,target,recovery,target,try,final,store,store,recovery,target,store,final,string,translog,uuid,store,read,last,committed,segments,info,get,user,data,get,translog,final,long,global,checkpoint,translog,read,global,checkpoint,recovery,target,translog,location,translog,uuid,final,list,index,commit,existing,commits,directory,reader,list,commits,store,directory,final,index,commit,safe,commit,combined,deletion,policy,find,safe,commit,point,existing,commits,global,checkpoint,final,sequence,numbers,commit,info,seq,no,stats,store,load,seq,no,info,safe,commit,if,logger,is,trace,enabled,final,string,joiner,description,of,existing,commits,new,string,joiner,for,index,commit,commit,existing,commits,description,of,existing,commits,add,combined,deletion,policy,commit,description,commit,logger,trace,calculate,starting,seqno,based,on,global,checkpoint,safe,commit,existing,commits,global,checkpoint,combined,deletion,policy,commit,description,safe,commit,description,of,existing,commits,if,seq,no,stats,max,seq,no,global,checkpoint,assert,seq,no,stats,local,checkpoint,global,checkpoint,return,seq,no,stats,local,checkpoint,1,else,return,sequence,numbers,catch,final,translog,corrupted,exception,ioexception,e,return,sequence,numbers
PeerRecoveryTargetService -> public static long getStartingSeqNo(final Logger logger, final RecoveryTarget recoveryTarget);1547576245;Get the starting sequence number for a sequence-number-based request.__@param recoveryTarget the target of the recovery_@return the starting sequence number or {@link SequenceNumbers#UNASSIGNED_SEQ_NO} if obtaining the starting sequence number_failed;public static long getStartingSeqNo(final Logger logger, final RecoveryTarget recoveryTarget) {_        try {_            final Store store = recoveryTarget.store()__            final String translogUUID = store.readLastCommittedSegmentsInfo().getUserData().get(Translog.TRANSLOG_UUID_KEY)__            final long globalCheckpoint = Translog.readGlobalCheckpoint(recoveryTarget.translogLocation(), translogUUID)__            final List<IndexCommit> existingCommits = DirectoryReader.listCommits(store.directory())__            final IndexCommit safeCommit = CombinedDeletionPolicy.findSafeCommitPoint(existingCommits, globalCheckpoint)__            final SequenceNumbers.CommitInfo seqNoStats = Store.loadSeqNoInfo(safeCommit)__            if (logger.isTraceEnabled()) {_                final StringJoiner descriptionOfExistingCommits = new StringJoiner(",")__                for (IndexCommit commit : existingCommits) {_                    descriptionOfExistingCommits.add(CombinedDeletionPolicy.commitDescription(commit))__                }_                logger.trace("Calculate starting seqno based on global checkpoint [{}], safe commit [{}], existing commits [{}]",_                    globalCheckpoint, CombinedDeletionPolicy.commitDescription(safeCommit), descriptionOfExistingCommits)__            }_            if (seqNoStats.maxSeqNo <= globalCheckpoint) {_                assert seqNoStats.localCheckpoint <= globalCheckpoint__                _                return seqNoStats.localCheckpoint + 1__            } else {_                return SequenceNumbers.UNASSIGNED_SEQ_NO__            }_        } catch (final TranslogCorruptedException | IOException e) {_            _            return SequenceNumbers.UNASSIGNED_SEQ_NO__        }_    };get,the,starting,sequence,number,for,a,sequence,number,based,request,param,recovery,target,the,target,of,the,recovery,return,the,starting,sequence,number,or,link,sequence,numbers,if,obtaining,the,starting,sequence,number,failed;public,static,long,get,starting,seq,no,final,logger,logger,final,recovery,target,recovery,target,try,final,store,store,recovery,target,store,final,string,translog,uuid,store,read,last,committed,segments,info,get,user,data,get,translog,final,long,global,checkpoint,translog,read,global,checkpoint,recovery,target,translog,location,translog,uuid,final,list,index,commit,existing,commits,directory,reader,list,commits,store,directory,final,index,commit,safe,commit,combined,deletion,policy,find,safe,commit,point,existing,commits,global,checkpoint,final,sequence,numbers,commit,info,seq,no,stats,store,load,seq,no,info,safe,commit,if,logger,is,trace,enabled,final,string,joiner,description,of,existing,commits,new,string,joiner,for,index,commit,commit,existing,commits,description,of,existing,commits,add,combined,deletion,policy,commit,description,commit,logger,trace,calculate,starting,seqno,based,on,global,checkpoint,safe,commit,existing,commits,global,checkpoint,combined,deletion,policy,commit,description,safe,commit,description,of,existing,commits,if,seq,no,stats,max,seq,no,global,checkpoint,assert,seq,no,stats,local,checkpoint,global,checkpoint,return,seq,no,stats,local,checkpoint,1,else,return,sequence,numbers,catch,final,translog,corrupted,exception,ioexception,e,return,sequence,numbers
PeerRecoveryTargetService -> public static long getStartingSeqNo(final Logger logger, final RecoveryTarget recoveryTarget);1548124510;Get the starting sequence number for a sequence-number-based request.__@param recoveryTarget the target of the recovery_@return the starting sequence number or {@link SequenceNumbers#UNASSIGNED_SEQ_NO} if obtaining the starting sequence number_failed;public static long getStartingSeqNo(final Logger logger, final RecoveryTarget recoveryTarget) {_        try {_            final Store store = recoveryTarget.store()__            final String translogUUID = store.readLastCommittedSegmentsInfo().getUserData().get(Translog.TRANSLOG_UUID_KEY)__            final long globalCheckpoint = Translog.readGlobalCheckpoint(recoveryTarget.translogLocation(), translogUUID)__            final List<IndexCommit> existingCommits = DirectoryReader.listCommits(store.directory())__            final IndexCommit safeCommit = CombinedDeletionPolicy.findSafeCommitPoint(existingCommits, globalCheckpoint)__            final SequenceNumbers.CommitInfo seqNoStats = Store.loadSeqNoInfo(safeCommit)__            if (logger.isTraceEnabled()) {_                final StringJoiner descriptionOfExistingCommits = new StringJoiner(",")__                for (IndexCommit commit : existingCommits) {_                    descriptionOfExistingCommits.add(CombinedDeletionPolicy.commitDescription(commit))__                }_                logger.trace("Calculate starting seqno based on global checkpoint [{}], safe commit [{}], existing commits [{}]",_                    globalCheckpoint, CombinedDeletionPolicy.commitDescription(safeCommit), descriptionOfExistingCommits)__            }_            if (seqNoStats.maxSeqNo <= globalCheckpoint) {_                assert seqNoStats.localCheckpoint <= globalCheckpoint__                _                return seqNoStats.localCheckpoint + 1__            } else {_                return SequenceNumbers.UNASSIGNED_SEQ_NO__            }_        } catch (final TranslogCorruptedException | IOException e) {_            _            return SequenceNumbers.UNASSIGNED_SEQ_NO__        }_    };get,the,starting,sequence,number,for,a,sequence,number,based,request,param,recovery,target,the,target,of,the,recovery,return,the,starting,sequence,number,or,link,sequence,numbers,if,obtaining,the,starting,sequence,number,failed;public,static,long,get,starting,seq,no,final,logger,logger,final,recovery,target,recovery,target,try,final,store,store,recovery,target,store,final,string,translog,uuid,store,read,last,committed,segments,info,get,user,data,get,translog,final,long,global,checkpoint,translog,read,global,checkpoint,recovery,target,translog,location,translog,uuid,final,list,index,commit,existing,commits,directory,reader,list,commits,store,directory,final,index,commit,safe,commit,combined,deletion,policy,find,safe,commit,point,existing,commits,global,checkpoint,final,sequence,numbers,commit,info,seq,no,stats,store,load,seq,no,info,safe,commit,if,logger,is,trace,enabled,final,string,joiner,description,of,existing,commits,new,string,joiner,for,index,commit,commit,existing,commits,description,of,existing,commits,add,combined,deletion,policy,commit,description,commit,logger,trace,calculate,starting,seqno,based,on,global,checkpoint,safe,commit,existing,commits,global,checkpoint,combined,deletion,policy,commit,description,safe,commit,description,of,existing,commits,if,seq,no,stats,max,seq,no,global,checkpoint,assert,seq,no,stats,local,checkpoint,global,checkpoint,return,seq,no,stats,local,checkpoint,1,else,return,sequence,numbers,catch,final,translog,corrupted,exception,ioexception,e,return,sequence,numbers
PeerRecoveryTargetService -> public static long getStartingSeqNo(final Logger logger, final RecoveryTarget recoveryTarget);1548558090;Get the starting sequence number for a sequence-number-based request.__@param recoveryTarget the target of the recovery_@return the starting sequence number or {@link SequenceNumbers#UNASSIGNED_SEQ_NO} if obtaining the starting sequence number_failed;public static long getStartingSeqNo(final Logger logger, final RecoveryTarget recoveryTarget) {_        try {_            final Store store = recoveryTarget.store()__            final String translogUUID = store.readLastCommittedSegmentsInfo().getUserData().get(Translog.TRANSLOG_UUID_KEY)__            final long globalCheckpoint = Translog.readGlobalCheckpoint(recoveryTarget.translogLocation(), translogUUID)__            final List<IndexCommit> existingCommits = DirectoryReader.listCommits(store.directory())__            final IndexCommit safeCommit = CombinedDeletionPolicy.findSafeCommitPoint(existingCommits, globalCheckpoint)__            final SequenceNumbers.CommitInfo seqNoStats = Store.loadSeqNoInfo(safeCommit)__            if (logger.isTraceEnabled()) {_                final StringJoiner descriptionOfExistingCommits = new StringJoiner(",")__                for (IndexCommit commit : existingCommits) {_                    descriptionOfExistingCommits.add(CombinedDeletionPolicy.commitDescription(commit))__                }_                logger.trace("Calculate starting seqno based on global checkpoint [{}], safe commit [{}], existing commits [{}]",_                    globalCheckpoint, CombinedDeletionPolicy.commitDescription(safeCommit), descriptionOfExistingCommits)__            }_            if (seqNoStats.maxSeqNo <= globalCheckpoint) {_                assert seqNoStats.localCheckpoint <= globalCheckpoint__                _                return seqNoStats.localCheckpoint + 1__            } else {_                return SequenceNumbers.UNASSIGNED_SEQ_NO__            }_        } catch (final TranslogCorruptedException | IOException e) {_            _            return SequenceNumbers.UNASSIGNED_SEQ_NO__        }_    };get,the,starting,sequence,number,for,a,sequence,number,based,request,param,recovery,target,the,target,of,the,recovery,return,the,starting,sequence,number,or,link,sequence,numbers,if,obtaining,the,starting,sequence,number,failed;public,static,long,get,starting,seq,no,final,logger,logger,final,recovery,target,recovery,target,try,final,store,store,recovery,target,store,final,string,translog,uuid,store,read,last,committed,segments,info,get,user,data,get,translog,final,long,global,checkpoint,translog,read,global,checkpoint,recovery,target,translog,location,translog,uuid,final,list,index,commit,existing,commits,directory,reader,list,commits,store,directory,final,index,commit,safe,commit,combined,deletion,policy,find,safe,commit,point,existing,commits,global,checkpoint,final,sequence,numbers,commit,info,seq,no,stats,store,load,seq,no,info,safe,commit,if,logger,is,trace,enabled,final,string,joiner,description,of,existing,commits,new,string,joiner,for,index,commit,commit,existing,commits,description,of,existing,commits,add,combined,deletion,policy,commit,description,commit,logger,trace,calculate,starting,seqno,based,on,global,checkpoint,safe,commit,existing,commits,global,checkpoint,combined,deletion,policy,commit,description,safe,commit,description,of,existing,commits,if,seq,no,stats,max,seq,no,global,checkpoint,assert,seq,no,stats,local,checkpoint,global,checkpoint,return,seq,no,stats,local,checkpoint,1,else,return,sequence,numbers,catch,final,translog,corrupted,exception,ioexception,e,return,sequence,numbers
PeerRecoveryTargetService -> public static long getStartingSeqNo(final Logger logger, final RecoveryTarget recoveryTarget);1548953505;Get the starting sequence number for a sequence-number-based request.__@param recoveryTarget the target of the recovery_@return the starting sequence number or {@link SequenceNumbers#UNASSIGNED_SEQ_NO} if obtaining the starting sequence number_failed;public static long getStartingSeqNo(final Logger logger, final RecoveryTarget recoveryTarget) {_        try {_            final Store store = recoveryTarget.store()__            final String translogUUID = store.readLastCommittedSegmentsInfo().getUserData().get(Translog.TRANSLOG_UUID_KEY)__            final long globalCheckpoint = Translog.readGlobalCheckpoint(recoveryTarget.translogLocation(), translogUUID)__            final List<IndexCommit> existingCommits = DirectoryReader.listCommits(store.directory())__            final IndexCommit safeCommit = CombinedDeletionPolicy.findSafeCommitPoint(existingCommits, globalCheckpoint)__            final SequenceNumbers.CommitInfo seqNoStats = Store.loadSeqNoInfo(safeCommit)__            if (logger.isTraceEnabled()) {_                final StringJoiner descriptionOfExistingCommits = new StringJoiner(",")__                for (IndexCommit commit : existingCommits) {_                    descriptionOfExistingCommits.add(CombinedDeletionPolicy.commitDescription(commit))__                }_                logger.trace("Calculate starting seqno based on global checkpoint [{}], safe commit [{}], existing commits [{}]",_                    globalCheckpoint, CombinedDeletionPolicy.commitDescription(safeCommit), descriptionOfExistingCommits)__            }_            if (seqNoStats.maxSeqNo <= globalCheckpoint) {_                assert seqNoStats.localCheckpoint <= globalCheckpoint__                _                return seqNoStats.localCheckpoint + 1__            } else {_                return SequenceNumbers.UNASSIGNED_SEQ_NO__            }_        } catch (final TranslogCorruptedException | IOException e) {_            _            return SequenceNumbers.UNASSIGNED_SEQ_NO__        }_    };get,the,starting,sequence,number,for,a,sequence,number,based,request,param,recovery,target,the,target,of,the,recovery,return,the,starting,sequence,number,or,link,sequence,numbers,if,obtaining,the,starting,sequence,number,failed;public,static,long,get,starting,seq,no,final,logger,logger,final,recovery,target,recovery,target,try,final,store,store,recovery,target,store,final,string,translog,uuid,store,read,last,committed,segments,info,get,user,data,get,translog,final,long,global,checkpoint,translog,read,global,checkpoint,recovery,target,translog,location,translog,uuid,final,list,index,commit,existing,commits,directory,reader,list,commits,store,directory,final,index,commit,safe,commit,combined,deletion,policy,find,safe,commit,point,existing,commits,global,checkpoint,final,sequence,numbers,commit,info,seq,no,stats,store,load,seq,no,info,safe,commit,if,logger,is,trace,enabled,final,string,joiner,description,of,existing,commits,new,string,joiner,for,index,commit,commit,existing,commits,description,of,existing,commits,add,combined,deletion,policy,commit,description,commit,logger,trace,calculate,starting,seqno,based,on,global,checkpoint,safe,commit,existing,commits,global,checkpoint,combined,deletion,policy,commit,description,safe,commit,description,of,existing,commits,if,seq,no,stats,max,seq,no,global,checkpoint,assert,seq,no,stats,local,checkpoint,global,checkpoint,return,seq,no,stats,local,checkpoint,1,else,return,sequence,numbers,catch,final,translog,corrupted,exception,ioexception,e,return,sequence,numbers
PeerRecoveryTargetService -> public static long getStartingSeqNo(final Logger logger, final RecoveryTarget recoveryTarget);1549406621;Get the starting sequence number for a sequence-number-based request.__@param recoveryTarget the target of the recovery_@return the starting sequence number or {@link SequenceNumbers#UNASSIGNED_SEQ_NO} if obtaining the starting sequence number_failed;public static long getStartingSeqNo(final Logger logger, final RecoveryTarget recoveryTarget) {_        try {_            final Store store = recoveryTarget.store()__            final String translogUUID = store.readLastCommittedSegmentsInfo().getUserData().get(Translog.TRANSLOG_UUID_KEY)__            final long globalCheckpoint = Translog.readGlobalCheckpoint(recoveryTarget.translogLocation(), translogUUID)__            final List<IndexCommit> existingCommits = DirectoryReader.listCommits(store.directory())__            final IndexCommit safeCommit = CombinedDeletionPolicy.findSafeCommitPoint(existingCommits, globalCheckpoint)__            final SequenceNumbers.CommitInfo seqNoStats = Store.loadSeqNoInfo(safeCommit)__            if (logger.isTraceEnabled()) {_                final StringJoiner descriptionOfExistingCommits = new StringJoiner(",")__                for (IndexCommit commit : existingCommits) {_                    descriptionOfExistingCommits.add(CombinedDeletionPolicy.commitDescription(commit))__                }_                logger.trace("Calculate starting seqno based on global checkpoint [{}], safe commit [{}], existing commits [{}]",_                    globalCheckpoint, CombinedDeletionPolicy.commitDescription(safeCommit), descriptionOfExistingCommits)__            }_            if (seqNoStats.maxSeqNo <= globalCheckpoint) {_                assert seqNoStats.localCheckpoint <= globalCheckpoint__                _                return seqNoStats.localCheckpoint + 1__            } else {_                return SequenceNumbers.UNASSIGNED_SEQ_NO__            }_        } catch (final TranslogCorruptedException | IOException e) {_            _            return SequenceNumbers.UNASSIGNED_SEQ_NO__        }_    };get,the,starting,sequence,number,for,a,sequence,number,based,request,param,recovery,target,the,target,of,the,recovery,return,the,starting,sequence,number,or,link,sequence,numbers,if,obtaining,the,starting,sequence,number,failed;public,static,long,get,starting,seq,no,final,logger,logger,final,recovery,target,recovery,target,try,final,store,store,recovery,target,store,final,string,translog,uuid,store,read,last,committed,segments,info,get,user,data,get,translog,final,long,global,checkpoint,translog,read,global,checkpoint,recovery,target,translog,location,translog,uuid,final,list,index,commit,existing,commits,directory,reader,list,commits,store,directory,final,index,commit,safe,commit,combined,deletion,policy,find,safe,commit,point,existing,commits,global,checkpoint,final,sequence,numbers,commit,info,seq,no,stats,store,load,seq,no,info,safe,commit,if,logger,is,trace,enabled,final,string,joiner,description,of,existing,commits,new,string,joiner,for,index,commit,commit,existing,commits,description,of,existing,commits,add,combined,deletion,policy,commit,description,commit,logger,trace,calculate,starting,seqno,based,on,global,checkpoint,safe,commit,existing,commits,global,checkpoint,combined,deletion,policy,commit,description,safe,commit,description,of,existing,commits,if,seq,no,stats,max,seq,no,global,checkpoint,assert,seq,no,stats,local,checkpoint,global,checkpoint,return,seq,no,stats,local,checkpoint,1,else,return,sequence,numbers,catch,final,translog,corrupted,exception,ioexception,e,return,sequence,numbers
