commented;modifiers;parameterAmount;loc;comment;code
true;public;0;22;/**  * Force-refreshes newly added listeners and forces a refresh if there are currently listeners registered. See {@link #refreshForcers}.  */ ;/**  * Force-refreshes newly added listeners and forces a refresh if there are currently listeners registered. See {@link #refreshForcers}.  */ public Releasable forceRefreshes() {     synchronized (this) {         assert refreshForcers >= 0.         refreshForcers += 1.     }     final RunOnce runOnce = new RunOnce(() -> {         synchronized (RefreshListeners.this) {             assert refreshForcers > 0.             refreshForcers -= 1.         }     }).     if (refreshNeeded()) {         try {             forceRefresh.run().         } catch (Exception e) {             runOnce.run().             throw e.         }     }     assert refreshListeners == null.     return () -> runOnce.run(). }
true;public;2;37;/**  * Add a listener for refreshes, calling it immediately if the location is already visible. If this runs out of listener slots then it  * forces a refresh and calls the listener immediately as well.  *  * @param location the location to listen for  * @param listener for the refresh. Called with true if registering the listener ran it out of slots and forced a refresh. Called with  *        false otherwise.  * @return did we call the listener (true) or register the listener to call later (false)?  */ ;/**  * Add a listener for refreshes, calling it immediately if the location is already visible. If this runs out of listener slots then it  * forces a refresh and calls the listener immediately as well.  *  * @param location the location to listen for  * @param listener for the refresh. Called with true if registering the listener ran it out of slots and forced a refresh. Called with  *        false otherwise.  * @return did we call the listener (true) or register the listener to call later (false)?  */ public boolean addOrNotify(Translog.Location location, Consumer<Boolean> listener) {     requireNonNull(listener, "listener cannot be null").     requireNonNull(location, "location cannot be null").     if (lastRefreshedLocation != null && lastRefreshedLocation.compareTo(location) >= 0) {         // Location already visible, just call the listener         listener.accept(false).         return true.     }     synchronized (this) {         if (closed) {             throw new IllegalStateException("can't wait for refresh on a closed index").         }         List<Tuple<Translog.Location, Consumer<Boolean>>> listeners = refreshListeners.         final int maxRefreshes = getMaxRefreshListeners.getAsInt().         if (refreshForcers == 0 && maxRefreshes > 0 && (listeners == null || listeners.size() < maxRefreshes)) {             ThreadContext.StoredContext storedContext = threadContext.newStoredContext(true).             Consumer<Boolean> contextPreservingListener = forced -> {                 try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {                     storedContext.restore().                     listener.accept(forced).                 }             }.             if (listeners == null) {                 listeners = new ArrayList<>().             }             // We have a free slot so register the listener             listeners.add(new Tuple<>(location, contextPreservingListener)).             refreshListeners = listeners.             return false.         }     }     // No free slot so force a refresh and call the listener in this thread     forceRefresh.run().     listener.accept(true).     return true. }
false;public;0;11;;@Override public void close() throws IOException {     List<Tuple<Translog.Location, Consumer<Boolean>>> oldListeners.     synchronized (this) {         oldListeners = refreshListeners.         refreshListeners = null.         closed = true.     }     // Fire any listeners we might have had     fireListeners(oldListeners). }
true;public;0;4;/**  * Returns true if there are pending listeners.  */ ;/**  * Returns true if there are pending listeners.  */ public boolean refreshNeeded() {     // A null list doesn't need a refresh. If we're closed we don't need a refresh either.     return refreshListeners != null && false == closed. }
true;public;0;6;/**  * The number of pending listeners.  */ ;/**  * The number of pending listeners.  */ public int pendingCount() {     // No need to synchronize here because we're doing a single volatile read     List<Tuple<Translog.Location, Consumer<Boolean>>> listeners = refreshListeners.     // A null list means we haven't accumulated any listeners. Otherwise we need the size.     return listeners == null ? 0 : listeners.size(). }
true;public;1;3;/**  * Setup the translog used to find the last refreshed location.  */ ;/**  * Setup the translog used to find the last refreshed location.  */ public void setCurrentRefreshLocationSupplier(Supplier<Translog.Location> currentRefreshLocationSupplier) {     this.currentRefreshLocationSupplier = currentRefreshLocationSupplier. }
false;public;0;4;;@Override public void beforeRefresh() throws IOException {     currentRefreshLocation = currentRefreshLocationSupplier.get(). }
false;public;1;67;;@Override public void afterRefresh(boolean didRefresh) throws IOException {     /* We intentionally ignore didRefresh here because our timing is a little off. It'd be a useful flag if we knew everything that made          * it into the refresh, but the way we snapshot the translog position before the refresh, things can sneak into the refresh that we          * don't know about. */     if (null == currentRefreshLocation) {         /* The translog had an empty last write location at the start of the refresh so we can't alert anyone to anything. This              * usually happens during recovery. The next refresh cycle out to pick up this refresh. */         return.     }     /* Set the lastRefreshedLocation so listeners that come in for locations before that will just execute inline without messing          * around with refreshListeners or synchronizing at all. Note that it is not safe for us to abort early if we haven't advanced the          * position here because we set and read lastRefreshedLocation outside of a synchronized block. We do that so that waiting for a          * refresh that has already passed is just a volatile read but the cost is that any check whether or not we've advanced the          * position will introduce a race between adding the listener and the position check. We could work around this by moving this          * assignment into the synchronized block below and double checking lastRefreshedLocation in addOrNotify's synchronized block but          * that doesn't seem worth it given that we already skip this process early if there aren't any listeners to iterate. */     lastRefreshedLocation = currentRefreshLocation.     /* Grab the current refresh listeners and replace them with null while synchronized. Any listeners that come in after this won't be          * in the list we iterate over and very likely won't be candidates for refresh anyway because we've already moved the          * lastRefreshedLocation. */     List<Tuple<Translog.Location, Consumer<Boolean>>> candidates.     synchronized (this) {         candidates = refreshListeners.         // No listeners to check so just bail early         if (candidates == null) {             return.         }         refreshListeners = null.     }     // Iterate the list of listeners, copying the listeners to fire to one list and those to preserve to another list.     List<Tuple<Translog.Location, Consumer<Boolean>>> listenersToFire = null.     List<Tuple<Translog.Location, Consumer<Boolean>>> preservedListeners = null.     for (Tuple<Translog.Location, Consumer<Boolean>> tuple : candidates) {         Translog.Location location = tuple.v1().         if (location.compareTo(currentRefreshLocation) <= 0) {             if (listenersToFire == null) {                 listenersToFire = new ArrayList<>().             }             listenersToFire.add(tuple).         } else {             if (preservedListeners == null) {                 preservedListeners = new ArrayList<>().             }             preservedListeners.add(tuple).         }     }     /* Now deal with the listeners that it isn't time yet to fire. We need to do this under lock so we don't miss a concurrent close or          * newly registered listener. If we're not closed we just add the listeners to the list of listeners we check next time. If we are          * closed we fire the listeners even though it isn't time for them. */     if (preservedListeners != null) {         synchronized (this) {             if (refreshListeners == null) {                 if (closed) {                     listenersToFire.addAll(preservedListeners).                 } else {                     refreshListeners = preservedListeners.                 }             } else {                 assert closed == false : "Can't be closed and have non-null refreshListeners".                 refreshListeners.addAll(preservedListeners).             }         }     }     // Lastly, fire the listeners that are ready on the listener thread pool     fireListeners(listenersToFire). }
true;private;1;13;/**  * Fire some listeners. Does nothing if the list of listeners is null.  */ ;/**  * Fire some listeners. Does nothing if the list of listeners is null.  */ private void fireListeners(List<Tuple<Translog.Location, Consumer<Boolean>>> listenersToFire) {     if (listenersToFire != null) {         listenerExecutor.execute(() -> {             for (Tuple<Translog.Location, Consumer<Boolean>> listener : listenersToFire) {                 try {                     listener.v2().accept(false).                 } catch (Exception e) {                     logger.warn("Error firing refresh listener", e).                 }             }         }).     } }
