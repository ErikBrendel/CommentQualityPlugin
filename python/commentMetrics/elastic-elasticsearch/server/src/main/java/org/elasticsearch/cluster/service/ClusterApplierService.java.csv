commented;modifiers;parameterAmount;loc;comment;code
false;public;1;3;;public void setSlowTaskLoggingThreshold(TimeValue slowTaskLoggingThreshold) {     this.slowTaskLoggingThreshold = slowTaskLoggingThreshold. }
false;public,synchronized;1;4;;public synchronized void setNodeConnectionsService(NodeConnectionsService nodeConnectionsService) {     assert this.nodeConnectionsService == null : "nodeConnectionsService is already set".     this.nodeConnectionsService = nodeConnectionsService. }
false;public;1;8;;@Override public void setInitialState(ClusterState initialState) {     if (lifecycle.started()) {         throw new IllegalStateException("can't set initial state when started").     }     assert state.get() == null : "state is already set".     state.set(initialState). }
false;protected,synchronized;0;7;;@Override protected synchronized void doStart() {     Objects.requireNonNull(nodeConnectionsService, "please set the node connection service before starting").     Objects.requireNonNull(state.get(), "please set initial state before starting").     addListener(localNodeMasterListeners).     threadPoolExecutor = createThreadPoolExecutor(). }
false;protected;0;7;;protected PrioritizedEsThreadPoolExecutor createThreadPoolExecutor() {     return EsExecutors.newSinglePrioritizing(nodeName + "/" + CLUSTER_UPDATE_THREAD_NAME, daemonThreadFactory(nodeName, CLUSTER_UPDATE_THREAD_NAME), threadPool.getThreadContext(), threadPool.scheduler()). }
false;public;1;4;;@Override public ClusterState apply(ClusterState clusterState) {     return updateFunction.apply(clusterState). }
false;public;0;4;;@Override public void run() {     runTask(this). }
false;protected,synchronized;0;16;;@Override protected synchronized void doStop() {     for (NotifyTimeout onGoingTimeout : onGoingTimeouts) {         onGoingTimeout.cancel().         try {             onGoingTimeout.cancel().             onGoingTimeout.listener.onClose().         } catch (Exception ex) {             logger.debug("failed to notify listeners on shutdown", ex).         }     }     ThreadPool.terminate(threadPoolExecutor, 10, TimeUnit.SECONDS).     // close timeout listeners that did not have an ongoing timeout     timeoutClusterStateListeners.forEach(TimeoutClusterStateListener::onClose).     removeListener(localNodeMasterListeners). }
false;protected,synchronized;0;3;;@Override protected synchronized void doClose() { }
true;public;0;6;/**  * The current cluster state.  * Should be renamed to appliedClusterState  */ ;/**  * The current cluster state.  * Should be renamed to appliedClusterState  */ public ClusterState state() {     assert assertNotCalledFromClusterStateApplier("the applied cluster state is not yet available").     ClusterState clusterState = this.state.get().     assert clusterState != null : "initial cluster state not set yet".     return clusterState. }
true;public;1;3;/**  * Adds a high priority applier of updated cluster states.  */ ;/**  * Adds a high priority applier of updated cluster states.  */ public void addHighPriorityApplier(ClusterStateApplier applier) {     highPriorityStateAppliers.add(applier). }
true;public;1;3;/**  * Adds an applier which will be called after all high priority and normal appliers have been called.  */ ;/**  * Adds an applier which will be called after all high priority and normal appliers have been called.  */ public void addLowPriorityApplier(ClusterStateApplier applier) {     lowPriorityStateAppliers.add(applier). }
true;public;1;3;/**  * Adds a applier of updated cluster states.  */ ;/**  * Adds a applier of updated cluster states.  */ public void addStateApplier(ClusterStateApplier applier) {     normalPriorityStateAppliers.add(applier). }
true;public;1;5;/**  * Removes an applier of updated cluster states.  */ ;/**  * Removes an applier of updated cluster states.  */ public void removeApplier(ClusterStateApplier applier) {     normalPriorityStateAppliers.remove(applier).     highPriorityStateAppliers.remove(applier).     lowPriorityStateAppliers.remove(applier). }
true;public;1;3;/**  * Add a listener for updated cluster states  */ ;/**  * Add a listener for updated cluster states  */ public void addListener(ClusterStateListener listener) {     clusterStateListeners.add(listener). }
true;public;1;3;/**  * Removes a listener for updated cluster states.  */ ;/**  * Removes a listener for updated cluster states.  */ public void removeListener(ClusterStateListener listener) {     clusterStateListeners.remove(listener). }
true;public;1;10;/**  * Removes a timeout listener for updated cluster states.  */ ;/**  * Removes a timeout listener for updated cluster states.  */ public void removeTimeoutListener(TimeoutClusterStateListener listener) {     timeoutClusterStateListeners.remove(listener).     for (Iterator<NotifyTimeout> it = onGoingTimeouts.iterator(). it.hasNext(). ) {         NotifyTimeout timeout = it.next().         if (timeout.listener.equals(listener)) {             timeout.cancel().             it.remove().         }     } }
true;public;1;3;/**  * Add a listener for on/off local node master events  */ ;/**  * Add a listener for on/off local node master events  */ public void addLocalNodeMasterListener(LocalNodeMasterListener listener) {     localNodeMasterListeners.add(listener). }
false;public;0;10;;@Override public void run() {     if (timeout != null) {         NotifyTimeout notifyTimeout = new NotifyTimeout(listener, timeout).         notifyTimeout.cancellable = threadPool.schedule(notifyTimeout, timeout, ThreadPool.Names.GENERIC).         onGoingTimeouts.add(notifyTimeout).     }     timeoutClusterStateListeners.add(listener).     listener.postAdded(). }
true;public;2;27;/**  * Adds a cluster state listener that is expected to be removed during a short period of time.  * If provided, the listener will be notified once a specific time has elapsed.  *  * NOTE: the listener is not removed on timeout. This is the responsibility of the caller.  */ ;/**  * Adds a cluster state listener that is expected to be removed during a short period of time.  * If provided, the listener will be notified once a specific time has elapsed.  *  * NOTE: the listener is not removed on timeout. This is the responsibility of the caller.  */ public void addTimeoutListener(@Nullable final TimeValue timeout, final TimeoutClusterStateListener listener) {     if (lifecycle.stoppedOrClosed()) {         listener.onClose().         return.     }     // call the post added notification on the same event thread     try {         threadPoolExecutor.execute(new SourcePrioritizedRunnable(Priority.HIGH, "_add_listener_") {              @Override             public void run() {                 if (timeout != null) {                     NotifyTimeout notifyTimeout = new NotifyTimeout(listener, timeout).                     notifyTimeout.cancellable = threadPool.schedule(notifyTimeout, timeout, ThreadPool.Names.GENERIC).                     onGoingTimeouts.add(notifyTimeout).                 }                 timeoutClusterStateListeners.add(listener).                 listener.postAdded().             }         }).     } catch (EsRejectedExecutionException e) {         if (lifecycle.stoppedOrClosed()) {             listener.onClose().         } else {             throw e.         }     } }
false;public;4;9;;public void runOnApplierThread(final String source, Consumer<ClusterState> clusterStateConsumer, final ClusterApplyListener listener, Priority priority) {     submitStateUpdateTask(source, ClusterStateTaskConfig.build(priority), (clusterState) -> {         clusterStateConsumer.accept(clusterState).         return clusterState.     }, listener). }
false;public;3;4;;public void runOnApplierThread(final String source, Consumer<ClusterState> clusterStateConsumer, final ClusterApplyListener listener) {     runOnApplierThread(source, clusterStateConsumer, listener, Priority.HIGH). }
false;public;3;13;;@Override public void onNewClusterState(final String source, final Supplier<ClusterState> clusterStateSupplier, final ClusterApplyListener listener) {     Function<ClusterState, ClusterState> applyFunction = currentState -> {         ClusterState nextState = clusterStateSupplier.get().         if (nextState != null) {             return nextState.         } else {             return currentState.         }     }.     submitStateUpdateTask(source, ClusterStateTaskConfig.build(Priority.HIGH), applyFunction, listener). }
false;private;4;23;;private void submitStateUpdateTask(final String source, final ClusterStateTaskConfig config, final Function<ClusterState, ClusterState> executor, final ClusterApplyListener listener) {     if (!lifecycle.started()) {         return.     }     try {         UpdateTask updateTask = new UpdateTask(config.priority(), source, new SafeClusterApplyListener(listener, logger), executor).         if (config.timeout() != null) {             threadPoolExecutor.execute(updateTask, config.timeout(), () -> threadPool.generic().execute(() -> listener.onFailure(source, new ProcessClusterEventTimeoutException(config.timeout(), source)))).         } else {             threadPoolExecutor.execute(updateTask).         }     } catch (EsRejectedExecutionException e) {         // to be done here...         if (!lifecycle.stoppedOrClosed()) {             throw e.         }     } }
true;public,static;1;5;/**  * asserts that the current thread is <b>NOT</b> the cluster state update thread  */ ;/**  * asserts that the current thread is <b>NOT</b> the cluster state update thread  */ public static boolean assertNotClusterStateUpdateThread(String reason) {     assert Thread.currentThread().getName().contains(CLUSTER_UPDATE_THREAD_NAME) == false : "Expected current thread [" + Thread.currentThread() + "] to not be the cluster state update thread. Reason: [" + reason + "]".     return true. }
true;private,static;1;16;/**  * asserts that the current stack trace does <b>NOT</b> involve a cluster state applier  */ ;/**  * asserts that the current stack trace does <b>NOT</b> involve a cluster state applier  */ private static boolean assertNotCalledFromClusterStateApplier(String reason) {     if (Thread.currentThread().getName().contains(CLUSTER_UPDATE_THREAD_NAME)) {         for (StackTraceElement element : Thread.currentThread().getStackTrace()) {             final String className = element.getClassName().             final String methodName = element.getMethodName().             if (className.equals(ClusterStateObserver.class.getName())) {                 // people may start an observer from an applier                 return true.             } else if (className.equals(ClusterApplierService.class.getName()) && methodName.equals("callClusterStateAppliers")) {                 throw new AssertionError("should not be called by a cluster state applier. reason [" + reason + "]").             }         }     }     return true. }
false;protected;1;58;;protected void runTask(UpdateTask task) {     if (!lifecycle.started()) {         logger.debug("processing [{}]: ignoring, cluster applier service not started", task.source).         return.     }     logger.debug("processing [{}]: execute", task.source).     final ClusterState previousClusterState = state.get().     long startTimeNS = currentTimeInNanos().     final ClusterState newClusterState.     try {         newClusterState = task.apply(previousClusterState).     } catch (Exception e) {         TimeValue executionTime = TimeValue.timeValueMillis(Math.max(0, TimeValue.nsecToMSec(currentTimeInNanos() - startTimeNS))).         logger.trace(() -> new ParameterizedMessage("failed to execute cluster state applier in [{}], state:\nversion [{}], source [{}]\n{}", executionTime, previousClusterState.version(), task.source, previousClusterState), e).         warnAboutSlowTaskIfNeeded(executionTime, task.source).         task.listener.onFailure(task.source, e).         return.     }     if (previousClusterState == newClusterState) {         TimeValue executionTime = TimeValue.timeValueMillis(Math.max(0, TimeValue.nsecToMSec(currentTimeInNanos() - startTimeNS))).         logger.debug("processing [{}]: took [{}] no change in cluster state", task.source, executionTime).         warnAboutSlowTaskIfNeeded(executionTime, task.source).         task.listener.onSuccess(task.source).     } else {         if (logger.isTraceEnabled()) {             logger.debug("cluster state updated, version [{}], source [{}]\n{}", newClusterState.version(), task.source, newClusterState).         } else {             logger.debug("cluster state updated, version [{}], source [{}]", newClusterState.version(), task.source).         }         try {             applyChanges(task, previousClusterState, newClusterState).             TimeValue executionTime = TimeValue.timeValueMillis(Math.max(0, TimeValue.nsecToMSec(currentTimeInNanos() - startTimeNS))).             logger.debug("processing [{}]: took [{}] done applying updated cluster state (version: {}, uuid: {})", task.source, executionTime, newClusterState.version(), newClusterState.stateUUID()).             warnAboutSlowTaskIfNeeded(executionTime, task.source).             task.listener.onSuccess(task.source).         } catch (Exception e) {             TimeValue executionTime = TimeValue.timeValueMillis(Math.max(0, TimeValue.nsecToMSec(currentTimeInNanos() - startTimeNS))).             if (logger.isTraceEnabled()) {                 logger.warn(new ParameterizedMessage("failed to apply updated cluster state in [{}]:\nversion [{}], uuid [{}], source [{}]\n{}", executionTime, newClusterState.version(), newClusterState.stateUUID(), task.source, newClusterState), e).             } else {                 logger.warn(new ParameterizedMessage("failed to apply updated cluster state in [{}]:\nversion [{}], uuid [{}], source [{}]", executionTime, newClusterState.version(), newClusterState.stateUUID(), task.source), e).             }             task.listener.onFailure(task.source, e).         }     } }
false;private;3;32;;private void applyChanges(UpdateTask task, ClusterState previousClusterState, ClusterState newClusterState) {     ClusterChangedEvent clusterChangedEvent = new ClusterChangedEvent(task.source, newClusterState, previousClusterState).     // new cluster state, notify all listeners     final DiscoveryNodes.Delta nodesDelta = clusterChangedEvent.nodesDelta().     if (nodesDelta.hasChanges() && logger.isInfoEnabled()) {         String summary = nodesDelta.shortSummary().         if (summary.length() > 0) {             logger.info("{}, term: {}, version: {}, reason: {}", summary, newClusterState.term(), newClusterState.version(), task.source).         }     }     logger.trace("connecting to nodes of cluster state with version {}", newClusterState.version()).     nodeConnectionsService.connectToNodes(newClusterState.nodes()).     // nothing to do until we actually recover from the gateway or any other block indicates we need to disable persistency     if (clusterChangedEvent.state().blocks().disableStatePersistence() == false && clusterChangedEvent.metaDataChanged()) {         logger.debug("applying settings from cluster state with version {}", newClusterState.version()).         final Settings incomingSettings = clusterChangedEvent.state().metaData().settings().         clusterSettings.applySettings(incomingSettings).     }     logger.debug("apply cluster state with version {}", newClusterState.version()).     callClusterStateAppliers(clusterChangedEvent).     nodeConnectionsService.disconnectFromNodesExcept(newClusterState.nodes()).     logger.debug("set locally applied cluster state to version {}", newClusterState.version()).     state.set(newClusterState).     callClusterStateListeners(clusterChangedEvent). }
false;private;1;6;;private void callClusterStateAppliers(ClusterChangedEvent clusterChangedEvent) {     clusterStateAppliers.forEach(applier -> {         logger.trace("calling [{}] with change to version [{}]", applier, clusterChangedEvent.state().version()).         applier.applyClusterState(clusterChangedEvent).     }). }
false;private;1;10;;private void callClusterStateListeners(ClusterChangedEvent clusterChangedEvent) {     Stream.concat(clusterStateListeners.stream(), timeoutClusterStateListeners.stream()).forEach(listener -> {         try {             logger.trace("calling [{}] with change to version [{}]", listener, clusterChangedEvent.state().version()).             listener.clusterChanged(clusterChangedEvent).         } catch (Exception ex) {             logger.warn("failed to notify ClusterStateListener", ex).         }     }). }
false;public;2;10;;@Override public void onFailure(String source, Exception e) {     try {         listener.onFailure(source, e).     } catch (Exception inner) {         inner.addSuppressed(e).         logger.error(new ParameterizedMessage("exception thrown by listener notifying of failure from [{}]", source), inner).     } }
false;public;1;9;;@Override public void onSuccess(String source) {     try {         listener.onSuccess(source).     } catch (Exception e) {         logger.error(new ParameterizedMessage("exception thrown by listener while notifying of cluster state processed from [{}]", source), e).     } }
false;protected;2;6;;protected void warnAboutSlowTaskIfNeeded(TimeValue executionTime, String source) {     if (executionTime.getMillis() > slowTaskLoggingThreshold.getMillis()) {         logger.warn("cluster state applier task [{}] took [{}] which is above the warn threshold of {}", source, executionTime, slowTaskLoggingThreshold).     } }
false;public;0;5;;public void cancel() {     if (cancellable != null) {         cancellable.cancel().     } }
false;public;0;12;;@Override public void run() {     if (cancellable != null && cancellable.isCancelled()) {         return.     }     if (lifecycle.stoppedOrClosed()) {         listener.onClose().     } else {         listener.onTimeout(this.timeout).     } // note, we rely on the listener to remove itself in case of timeout if needed }
false;public;1;19;;@Override public void clusterChanged(ClusterChangedEvent event) {     if (!master && event.localNodeMaster()) {         master = true.         for (LocalNodeMasterListener listener : listeners) {             java.util.concurrent.Executor executor = threadPool.executor(listener.executorName()).             executor.execute(new OnMasterRunnable(listener)).         }         return.     }     if (master && !event.localNodeMaster()) {         master = false.         for (LocalNodeMasterListener listener : listeners) {             java.util.concurrent.Executor executor = threadPool.executor(listener.executorName()).             executor.execute(new OffMasterRunnable(listener)).         }     } }
false;private;1;3;;private void add(LocalNodeMasterListener listener) {     listeners.add(listener). }
false;public;0;4;;@Override public void run() {     listener.onMaster(). }
false;public;0;4;;@Override public void run() {     listener.offMaster(). }
true;protected;0;3;// this one is overridden in tests so we can control time ;// this one is overridden in tests so we can control time protected long currentTimeInNanos() {     return System.nanoTime(). }
