commented;modifiers;parameterAmount;loc;comment;code
true;public,abstract;1;1;/**  * Create a new copy of this {@link Aggregation} with the same settings as  * this {@link Aggregation} and contains the provided buckets.  *  * @param buckets  *            the buckets to use in the new {@link Aggregation}  * @return the new {@link Aggregation}  */ ;/**  * Create a new copy of this {@link Aggregation} with the same settings as  * this {@link Aggregation} and contains the provided buckets.  *  * @param buckets  *            the buckets to use in the new {@link Aggregation}  * @return the new {@link Aggregation}  */ public abstract A create(List<B> buckets).
true;public,abstract;2;1;/**  * Create a new {@link InternalBucket} using the provided prototype bucket  * and aggregations.  *  * @param aggregations  *            the aggregations for the new bucket  * @param prototype  *            the bucket to use as a prototype  * @return the new bucket  */ ;/**  * Create a new {@link InternalBucket} using the provided prototype bucket  * and aggregations.  *  * @param aggregations  *            the aggregations for the new bucket  * @param prototype  *            the bucket to use as a prototype  * @return the new bucket  */ public abstract B createBucket(InternalAggregations aggregations, B prototype).
false;public,abstract;0;2;;@Override public abstract List<? extends InternalBucket> getBuckets().
false;public;1;15;;@Override public Object getProperty(List<String> path) {     if (path.isEmpty()) {         return this.     } else if (path.get(0).equals("_bucket_count")) {         return getBuckets().size().     } else {         List<? extends InternalBucket> buckets = getBuckets().         Object[] propertyArray = new Object[buckets.size()].         for (int i = 0. i < buckets.size(). i++) {             propertyArray[i] = buckets.get(i).getProperty(getName(), path).         }         return propertyArray.     } }
true;public,static;1;7;/**  * Counts the number of inner buckets inside the provided {@link InternalBucket}  */ ;/**  * Counts the number of inner buckets inside the provided {@link InternalBucket}  */ public static int countInnerBucket(InternalBucket bucket) {     int count = 0.     for (Aggregation agg : bucket.getAggregations().asList()) {         count += countInnerBucket(agg).     }     return count. }
true;public,static;1;18;/**  * Counts the number of inner buckets inside the provided {@link Aggregation}  */ ;/**  * Counts the number of inner buckets inside the provided {@link Aggregation}  */ public static int countInnerBucket(Aggregation agg) {     int size = 0.     if (agg instanceof MultiBucketsAggregation) {         MultiBucketsAggregation multi = (MultiBucketsAggregation) agg.         for (MultiBucketsAggregation.Bucket bucket : multi.getBuckets()) {             ++size.             for (Aggregation bucketAgg : bucket.getAggregations().asList()) {                 size += countInnerBucket(bucketAgg).             }         }     } else if (agg instanceof SingleBucketAggregation) {         SingleBucketAggregation single = (SingleBucketAggregation) agg.         for (Aggregation bucketAgg : single.getAggregations().asList()) {             size += countInnerBucket(bucketAgg).         }     }     return size. }
false;public;2;24;;public Object getProperty(String containingAggName, List<String> path) {     if (path.isEmpty()) {         return this.     }     Aggregations aggregations = getAggregations().     String aggName = path.get(0).     if (aggName.equals("_count")) {         if (path.size() > 1) {             throw new InvalidAggregationPathException("_count must be the last element in the path").         }         return getDocCount().     } else if (aggName.equals("_key")) {         if (path.size() > 1) {             throw new InvalidAggregationPathException("_key must be the last element in the path").         }         return getKey().     }     InternalAggregation aggregation = aggregations.get(aggName).     if (aggregation == null) {         throw new InvalidAggregationPathException("Cannot find an aggregation named [" + aggName + "] in [" + containingAggName + "]").     }     return aggregation.getProperty(path.subList(1, path.size())). }
