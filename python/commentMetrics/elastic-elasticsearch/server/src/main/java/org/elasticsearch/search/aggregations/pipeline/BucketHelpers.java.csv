commented;modifiers;parameterAmount;loc;comment;code
true;public,static;2;21;/**  * Parse a string GapPolicy into the byte enum  *  * @param text  *            GapPolicy in string format (e.g. "ignore")  * @return GapPolicy enum  */ ;/**  * Parse a string GapPolicy into the byte enum  *  * @param text  *            GapPolicy in string format (e.g. "ignore")  * @return GapPolicy enum  */ public static GapPolicy parse(String text, XContentLocation tokenLocation) {     GapPolicy result = null.     for (GapPolicy policy : values()) {         if (policy.parseField.match(text, LoggingDeprecationHandler.INSTANCE)) {             if (result == null) {                 result = policy.             } else {                 throw new IllegalStateException("Text can be parsed to 2 different gap policies: text=[" + text + "], " + "policies=" + Arrays.asList(result, policy)).             }         }     }     if (result == null) {         final List<String> validNames = new ArrayList<>().         for (GapPolicy policy : values()) {             validNames.add(policy.getName()).         }         throw new ParsingException(tokenLocation, "Invalid gap policy: [" + text + "], accepted values: " + validNames).     }     return result. }
true;public;1;3;/**  * Serialize the GapPolicy to the output stream  */ ;/**  * Serialize the GapPolicy to the output stream  */ public void writeTo(StreamOutput out) throws IOException {     out.writeByte(id). }
true;public,static;1;9;/**  * Deserialize the GapPolicy from the input stream  *  * @return    GapPolicy Enum  */ ;/**  * Deserialize the GapPolicy from the input stream  *  * @return    GapPolicy Enum  */ public static GapPolicy readFrom(StreamInput in) throws IOException {     byte id = in.readByte().     for (GapPolicy gapPolicy : values()) {         if (id == gapPolicy.id) {             return gapPolicy.         }     }     throw new IllegalStateException("Unknown GapPolicy with id [" + id + "]"). }
true;public;0;3;/**  * Return the english-formatted name of the GapPolicy  *  * @return English representation of GapPolicy  */ ;/**  * Return the english-formatted name of the GapPolicy  *  * @return English representation of GapPolicy  */ public String getName() {     return parseField.getPreferredName(). }
true;public,static;4;5;/**  * Given a path and a set of buckets, this method will return the value  * inside the agg at that path. This is used to extract values for use by  * pipeline aggregations (e.g. a derivative might need the price for each  * bucket). If the bucket is empty, the configured GapPolicy is invoked to  * resolve the missing bucket  *  * @param agg  *            A series of agg buckets in the form of a histogram  * @param bucket  *            A specific bucket that a value needs to be extracted from.  *            This bucket should be present in the <code>histo</code>  *            parameter  * @param aggPath  *            The path to a particular value that needs to be extracted.  *            This path should point to a metric inside the  *            <code>bucket</code>  * @param gapPolicy  *            The gap policy to apply if empty buckets are found  * @return The value extracted from <code>bucket</code> found at  *         <code>aggPath</code>  */ ;/**  * Given a path and a set of buckets, this method will return the value  * inside the agg at that path. This is used to extract values for use by  * pipeline aggregations (e.g. a derivative might need the price for each  * bucket). If the bucket is empty, the configured GapPolicy is invoked to  * resolve the missing bucket  *  * @param agg  *            A series of agg buckets in the form of a histogram  * @param bucket  *            A specific bucket that a value needs to be extracted from.  *            This bucket should be present in the <code>histo</code>  *            parameter  * @param aggPath  *            The path to a particular value that needs to be extracted.  *            This path should point to a metric inside the  *            <code>bucket</code>  * @param gapPolicy  *            The gap policy to apply if empty buckets are found  * @return The value extracted from <code>bucket</code> found at  *         <code>aggPath</code>  */ public static Double resolveBucketValue(MultiBucketsAggregation agg, InternalMultiBucketAggregation.InternalBucket bucket, String aggPath, GapPolicy gapPolicy) {     List<String> aggPathsList = AggregationPath.parse(aggPath).getPathElementsAsStringList().     return resolveBucketValue(agg, bucket, aggPathsList, gapPolicy). }
false;public,static;4;36;;public static Double resolveBucketValue(MultiBucketsAggregation agg, InternalMultiBucketAggregation.InternalBucket bucket, List<String> aggPathAsList, GapPolicy gapPolicy) {     try {         Object propertyValue = bucket.getProperty(agg.getName(), aggPathAsList).         if (propertyValue == null) {             throw new AggregationExecutionException(AbstractPipelineAggregationBuilder.BUCKETS_PATH_FIELD.getPreferredName() + " must reference either a number value or a single value numeric metric aggregation").         } else {             double value.             if (propertyValue instanceof Number) {                 value = ((Number) propertyValue).doubleValue().             } else if (propertyValue instanceof InternalNumericMetricsAggregation.SingleValue) {                 value = ((InternalNumericMetricsAggregation.SingleValue) propertyValue).value().             } else {                 throw new AggregationExecutionException(AbstractPipelineAggregationBuilder.BUCKETS_PATH_FIELD.getPreferredName() + " must reference either a number value or a single value numeric metric aggregation, got: " + propertyValue.getClass().getCanonicalName()).             }             // doc count never has missing values so gap policy doesn't apply here             boolean isDocCountProperty = aggPathAsList.size() == 1 && "_count".equals(aggPathAsList.get(0)).             if (Double.isInfinite(value) || Double.isNaN(value) || (bucket.getDocCount() == 0 && !isDocCountProperty)) {                 switch(gapPolicy) {                     case INSERT_ZEROS:                         return 0.0.                     case SKIP:                     default:                         return Double.NaN.                 }             } else {                 return value.             }         }     } catch (InvalidAggregationPathException e) {         return null.     } }
