commented;modifiers;parameterAmount;loc;comment;code
true;private;1;20;/**  * Since inline scripts can accept code rather than just an id, they must also be able  * to handle template parsing, hence the need for custom parsing code.  Templates can  * consist of either an {@link String} or a JSON object.  If a JSON object is discovered  * then the content type option must also be saved as a compiler option.  */ ;/**  * Since inline scripts can accept code rather than just an id, they must also be able  * to handle template parsing, hence the need for custom parsing code.  Templates can  * consist of either an {@link String} or a JSON object.  If a JSON object is discovered  * then the content type option must also be saved as a compiler option.  */ private void setInline(XContentParser parser) {     try {         if (type != null) {             throwOnlyOneOfType().         }         type = ScriptType.INLINE.         if (parser.currentToken() == Token.START_OBJECT) {             // this is really for search templates, that need to be converted to json format             XContentBuilder builder = XContentFactory.jsonBuilder().             idOrCode = Strings.toString(builder.copyCurrentStructure(parser)).             options.put(CONTENT_TYPE_OPTION, XContentType.JSON.mediaType()).         } else {             idOrCode = parser.text().         }     } catch (IOException exception) {         throw new UncheckedIOException(exception).     } }
true;private;1;8;/**  * Set both the id and the type of the stored script.  */ ;/**  * Set both the id and the type of the stored script.  */ private void setStored(String idOrCode) {     if (type != null) {         throwOnlyOneOfType().     }     type = ScriptType.STORED.     this.idOrCode = idOrCode. }
true;private;0;6;/**  * Helper method to throw an exception if more than one type of {@link Script} is specified.  */ ;/**  * Helper method to throw an exception if more than one type of {@link Script} is specified.  */ private void throwOnlyOneOfType() {     throw new IllegalArgumentException("must only use one of [" + ScriptType.INLINE.getParseField().getPreferredName() + ", " + ScriptType.STORED.getParseField().getPreferredName() + "]" + " when specifying a script"). }
false;private;1;3;;private void setLang(String lang) {     this.lang = lang. }
true;private;1;3;/**  * Options may have already been added if an inline template was specified.  * Appends the user-defined compiler options with the internal compiler options.  */ ;/**  * Options may have already been added if an inline template was specified.  * Appends the user-defined compiler options with the internal compiler options.  */ private void setOptions(Map<String, String> options) {     this.options.putAll(options). }
false;private;1;3;;private void setParams(Map<String, Object> params) {     this.params = params. }
true;private;1;41;/**  * Validates the parameters and creates an {@link Script}.  * @param defaultLang The default lang is not a compile-time constant and must be provided  *                    at run-time this way in case a legacy default language is used from  *                    previously stored queries.  */ ;/**  * Validates the parameters and creates an {@link Script}.  * @param defaultLang The default lang is not a compile-time constant and must be provided  *                    at run-time this way in case a legacy default language is used from  *                    previously stored queries.  */ private Script build(String defaultLang) {     if (type == null) {         throw new IllegalArgumentException("must specify either [source] for an inline script or [id] for a stored script").     }     if (type == ScriptType.INLINE) {         if (lang == null) {             lang = defaultLang.         }         if (idOrCode == null) {             throw new IllegalArgumentException("must specify <id> for an inline script").         }         if (options.size() > 1 || options.size() == 1 && options.get(CONTENT_TYPE_OPTION) == null) {             options.remove(CONTENT_TYPE_OPTION).             throw new IllegalArgumentException("illegal compiler options [" + options + "] specified").         }     } else if (type == ScriptType.STORED) {         if (lang != null) {             throw new IllegalArgumentException("illegally specified <lang> for a stored script").         }         if (idOrCode == null) {             throw new IllegalArgumentException("must specify <code> for a stored script").         }         if (options.isEmpty()) {             options = null.         } else {             throw new IllegalArgumentException("field [" + OPTIONS_PARSE_FIELD.getPreferredName() + "] " + "cannot be specified using a stored script").         }     }     return new Script(type, lang, idOrCode, options, params). }
true;public,static;1;3;/**  * Convenience method to call {@link Script#parse(XContentParser, String)}  * using the default scripting language.  */ ;/**  * Convenience method to call {@link Script#parse(XContentParser, String)}  * using the default scripting language.  */ public static Script parse(XContentParser parser) throws IOException {     return parse(parser, DEFAULT_SCRIPT_LANG). }
true;public,static;1;15;/**  * Parse the script configured in the given settings.  */ ;/**  * Parse the script configured in the given settings.  */ public static Script parse(Settings settings) {     try (XContentBuilder builder = JsonXContent.contentBuilder()) {         builder.startObject().         settings.toXContent(builder, ToXContent.EMPTY_PARAMS).         builder.endObject().         try (InputStream stream = BytesReference.bytes(builder).streamInput().             XContentParser parser = JsonXContent.jsonXContent.createParser(NamedXContentRegistry.EMPTY, LoggingDeprecationHandler.INSTANCE, stream)) {             return parse(parser).         }     } catch (IOException e) {         // it should not happen since we are not actually reading from a stream but an in-memory byte[]         throw new IllegalStateException(e).     } }
true;public,static;2;15;/**  * This will parse XContent into a {@link Script}.  The following formats can be parsed:  *  * The simple format defaults to an {@link ScriptType#INLINE} with no compiler options or user-defined params:  *  * Example:  * {@code  * "return Math.log(doc.popularity) * 100."  * }  *  * The complex format where {@link ScriptType} and idOrCode are required while lang, options and params are not required.  *  * {@code  * {  *     // Exactly one of "id" or "source" must be specified  *     "id" : "<id>",  *     // OR  *     "source": "<source>",  *     "lang" : "<lang>",  *     "options" : {  *         "option0" : "<option0>",  *         "option1" : "<option1>",  *         ...  *     },  *     "params" : {  *         "param0" : "<param0>",  *         "param1" : "<param1>",  *         ...  *     }  * }  * }  *  * Example:  * {@code  * {  *     "source" : "return Math.log(doc.popularity) * params.multiplier",  *     "lang" : "painless",  *     "params" : {  *         "multiplier" : 100.0  *     }  * }  * }  *  * This also handles templates in a special way.  If a complexly formatted query is specified as another complex  * JSON object the query is assumed to be a template, and the format will be preserved.  *  * {@code  * {  *     "source" : { "query" : ... },  *     "lang" : "<lang>",  *     "options" : {  *         "option0" : "<option0>",  *         "option1" : "<option1>",  *         ...  *     },  *     "params" : {  *         "param0" : "<param0>",  *         "param1" : "<param1>",  *         ...  *     }  * }  * }  *  * @param parser       The {@link XContentParser} to be used.  * @param defaultLang  The default language to use if no language is specified.  The default language isn't necessarily  *                     the one defined by {@link Script#DEFAULT_SCRIPT_LANG} due to backwards compatibility requirements  *                     related to stored queries using previously default languages.  *  * @return             The parsed {@link Script}.  */ ;/**  * This will parse XContent into a {@link Script}.  The following formats can be parsed:  *  * The simple format defaults to an {@link ScriptType#INLINE} with no compiler options or user-defined params:  *  * Example:  * {@code  * "return Math.log(doc.popularity) * 100."  * }  *  * The complex format where {@link ScriptType} and idOrCode are required while lang, options and params are not required.  *  * {@code  * {  *     // Exactly one of "id" or "source" must be specified  *     "id" : "<id>",  *     // OR  *     "source": "<source>",  *     "lang" : "<lang>",  *     "options" : {  *         "option0" : "<option0>",  *         "option1" : "<option1>",  *         ...  *     },  *     "params" : {  *         "param0" : "<param0>",  *         "param1" : "<param1>",  *         ...  *     }  * }  * }  *  * Example:  * {@code  * {  *     "source" : "return Math.log(doc.popularity) * params.multiplier",  *     "lang" : "painless",  *     "params" : {  *         "multiplier" : 100.0  *     }  * }  * }  *  * This also handles templates in a special way.  If a complexly formatted query is specified as another complex  * JSON object the query is assumed to be a template, and the format will be preserved.  *  * {@code  * {  *     "source" : { "query" : ... },  *     "lang" : "<lang>",  *     "options" : {  *         "option0" : "<option0>",  *         "option1" : "<option1>",  *         ...  *     },  *     "params" : {  *         "param0" : "<param0>",  *         "param1" : "<param1>",  *         ...  *     }  * }  * }  *  * @param parser       The {@link XContentParser} to be used.  * @param defaultLang  The default language to use if no language is specified.  The default language isn't necessarily  *                     the one defined by {@link Script#DEFAULT_SCRIPT_LANG} due to backwards compatibility requirements  *                     related to stored queries using previously default languages.  *  * @return             The parsed {@link Script}.  */ public static Script parse(XContentParser parser, String defaultLang) throws IOException {     Objects.requireNonNull(defaultLang).     Token token = parser.currentToken().     if (token == null) {         token = parser.nextToken().     }     if (token == Token.VALUE_STRING) {         return new Script(ScriptType.INLINE, defaultLang, parser.text(), Collections.emptyMap()).     }     return PARSER.apply(parser, null).build(defaultLang). }
false;public;1;10;;@Override public void writeTo(StreamOutput out) throws IOException {     type.writeTo(out).     out.writeOptionalString(lang).     out.writeString(idOrCode).     @SuppressWarnings("unchecked")     Map<String, Object> options = (Map<String, Object>) (Map) this.options.     out.writeMap(options).     out.writeMap(params). }
true;public;2;34;/**  * This will build scripts into the following XContent structure:  *  * {@code  * {  *     "<(id, source)>" : "<idOrCode>",  *     "lang" : "<lang>",  *     "options" : {  *         "option0" : "<option0>",  *         "option1" : "<option1>",  *         ...  *     },  *     "params" : {  *         "param0" : "<param0>",  *         "param1" : "<param1>",  *         ...  *     }  * }  * }  *  * Example:  * {@code  * {  *     "source" : "return Math.log(doc.popularity) * params.multiplier.",  *     "lang" : "painless",  *     "params" : {  *         "multiplier" : 100.0  *     }  * }  * }  *  * Note that lang, options, and params will only be included if there have been any specified.  *  * This also handles templates in a special way.  If the {@link Script#CONTENT_TYPE_OPTION} option  * is provided and the {@link ScriptType#INLINE} is specified then the template will be preserved as a raw field.  *  * {@code  * {  *     "source" : { "query" : ... },  *     "lang" : "<lang>",  *     "options" : {  *         "option0" : "<option0>",  *         "option1" : "<option1>",  *         ...  *     },  *     "params" : {  *         "param0" : "<param0>",  *         "param1" : "<param1>",  *         ...  *     }  * }  * }  */ ;/**  * This will build scripts into the following XContent structure:  *  * {@code  * {  *     "<(id, source)>" : "<idOrCode>",  *     "lang" : "<lang>",  *     "options" : {  *         "option0" : "<option0>",  *         "option1" : "<option1>",  *         ...  *     },  *     "params" : {  *         "param0" : "<param0>",  *         "param1" : "<param1>",  *         ...  *     }  * }  * }  *  * Example:  * {@code  * {  *     "source" : "return Math.log(doc.popularity) * params.multiplier.",  *     "lang" : "painless",  *     "params" : {  *         "multiplier" : 100.0  *     }  * }  * }  *  * Note that lang, options, and params will only be included if there have been any specified.  *  * This also handles templates in a special way.  If the {@link Script#CONTENT_TYPE_OPTION} option  * is provided and the {@link ScriptType#INLINE} is specified then the template will be preserved as a raw field.  *  * {@code  * {  *     "source" : { "query" : ... },  *     "lang" : "<lang>",  *     "options" : {  *         "option0" : "<option0>",  *         "option1" : "<option1>",  *         ...  *     },  *     "params" : {  *         "param0" : "<param0>",  *         "param1" : "<param1>",  *         ...  *     }  * }  * }  */ @Override public XContentBuilder toXContent(XContentBuilder builder, Params builderParams) throws IOException {     builder.startObject().     String contentType = options == null ? null : options.get(CONTENT_TYPE_OPTION).     if (type == ScriptType.INLINE) {         if (contentType != null && builder.contentType().mediaType().equals(contentType)) {             try (InputStream stream = new BytesArray(idOrCode).streamInput()) {                 builder.rawField(SOURCE_PARSE_FIELD.getPreferredName(), stream).             }         } else {             builder.field(SOURCE_PARSE_FIELD.getPreferredName(), idOrCode).         }     } else {         builder.field("id", idOrCode).     }     if (lang != null) {         builder.field(LANG_PARSE_FIELD.getPreferredName(), lang).     }     if (options != null && !options.isEmpty()) {         builder.field(OPTIONS_PARSE_FIELD.getPreferredName(), options).     }     if (!params.isEmpty()) {         builder.field(PARAMS_PARSE_FIELD.getPreferredName(), params).     }     builder.endObject().     return builder. }
true;public;0;3;/**  * @return The {@link ScriptType} for this {@link Script}.  */ ;/**  * @return The {@link ScriptType} for this {@link Script}.  */ public ScriptType getType() {     return type. }
true;public;0;3;/**  * @return The language for this {@link Script} if the {@link ScriptType} is {@link ScriptType#INLINE}.  *         For {@link ScriptType#STORED} scripts this should be null, but can  *         be specified to access scripts stored as part of the stored scripts deprecated API.  */ ;/**  * @return The language for this {@link Script} if the {@link ScriptType} is {@link ScriptType#INLINE}.  *         For {@link ScriptType#STORED} scripts this should be null, but can  *         be specified to access scripts stored as part of the stored scripts deprecated API.  */ public String getLang() {     return lang. }
true;public;0;3;/**  * @return The id for this {@link Script} if the {@link ScriptType} is {@link ScriptType#STORED}.  *         The code for this {@link Script} if the {@link ScriptType} is {@link ScriptType#INLINE}.  */ ;/**  * @return The id for this {@link Script} if the {@link ScriptType} is {@link ScriptType#STORED}.  *         The code for this {@link Script} if the {@link ScriptType} is {@link ScriptType#INLINE}.  */ public String getIdOrCode() {     return idOrCode. }
true;public;0;3;/**  * @return The map of compiler options for this {@link Script} if the {@link ScriptType}  *         is {@link ScriptType#INLINE}, {@code null} otherwise.  */ ;/**  * @return The map of compiler options for this {@link Script} if the {@link ScriptType}  *         is {@link ScriptType#INLINE}, {@code null} otherwise.  */ public Map<String, String> getOptions() {     return options. }
true;public;0;3;/**  * @return The map of user-defined params for this {@link Script}.  */ ;/**  * @return The map of user-defined params for this {@link Script}.  */ public Map<String, Object> getParams() {     return params. }
false;public;1;14;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     Script script = (Script) o.     if (type != script.type)         return false.     if (lang != null ? !lang.equals(script.lang) : script.lang != null)         return false.     if (!idOrCode.equals(script.idOrCode))         return false.     if (options != null ? !options.equals(script.options) : script.options != null)         return false.     return params.equals(script.params). }
false;public;0;9;;@Override public int hashCode() {     int result = type.hashCode().     result = 31 * result + (lang != null ? lang.hashCode() : 0).     result = 31 * result + idOrCode.hashCode().     result = 31 * result + (options != null ? options.hashCode() : 0).     result = 31 * result + params.hashCode().     return result. }
false;public;0;10;;@Override public String toString() {     return "Script{" + "type=" + type + ", lang='" + lang + '\'' + ", idOrCode='" + idOrCode + '\'' + ", options=" + options + ", params=" + params + '}'. }
