commented;modifiers;parameterAmount;loc;comment;code
true;protected;0;3;/**  * A feature exposed by the plugin. This should be used if a plugin exposes {@link ClusterState.Custom} or {@link MetaData.Custom}. see  * also {@link ClusterState.FeatureAware}.  *  * @return a feature set represented by this plugin, or the empty optional if the plugin does not expose cluster state or metadata  * customs  */ ;/**  * A feature exposed by the plugin. This should be used if a plugin exposes {@link ClusterState.Custom} or {@link MetaData.Custom}. see  * also {@link ClusterState.FeatureAware}.  *  * @return a feature set represented by this plugin, or the empty optional if the plugin does not expose cluster state or metadata  * customs  */ protected Optional<String> getFeature() {     return Optional.empty(). }
true;public;0;3;/**  * Node level guice modules.  */ ;/**  * Node level guice modules.  */ public Collection<Module> createGuiceModules() {     return Collections.emptyList(). }
true;public;0;3;/**  * Node level services that will be automatically started/stopped/closed. This classes must be constructed  * by injection with guice.  */ ;/**  * Node level services that will be automatically started/stopped/closed. This classes must be constructed  * by injection with guice.  */ public Collection<Class<? extends LifecycleComponent>> getGuiceServiceClasses() {     return Collections.emptyList(). }
true;public;9;6;/**  * Returns components added by this plugin.  *  * Any components returned that implement {@link LifecycleComponent} will have their lifecycle managed.  * Note: To aid in the migration away from guice, all objects returned as components will be bound in guice  * to themselves.  *  * @param client A client to make requests to the system  * @param clusterService A service to allow watching and updating cluster state  * @param threadPool A service to allow retrieving an executor to run an async action  * @param resourceWatcherService A service to watch for changes to node local files  * @param scriptService A service to allow running scripts on the local node  * @param xContentRegistry the registry for extensible xContent parsing  * @param environment the environment for path and setting configurations  * @param nodeEnvironment the node environment used coordinate access to the data paths  * @param namedWriteableRegistry the registry for {@link NamedWriteable} object parsing  */ ;/**  * Returns components added by this plugin.  *  * Any components returned that implement {@link LifecycleComponent} will have their lifecycle managed.  * Note: To aid in the migration away from guice, all objects returned as components will be bound in guice  * to themselves.  *  * @param client A client to make requests to the system  * @param clusterService A service to allow watching and updating cluster state  * @param threadPool A service to allow retrieving an executor to run an async action  * @param resourceWatcherService A service to watch for changes to node local files  * @param scriptService A service to allow running scripts on the local node  * @param xContentRegistry the registry for extensible xContent parsing  * @param environment the environment for path and setting configurations  * @param nodeEnvironment the node environment used coordinate access to the data paths  * @param namedWriteableRegistry the registry for {@link NamedWriteable} object parsing  */ public Collection<Object> createComponents(Client client, ClusterService clusterService, ThreadPool threadPool, ResourceWatcherService resourceWatcherService, ScriptService scriptService, NamedXContentRegistry xContentRegistry, Environment environment, NodeEnvironment nodeEnvironment, NamedWriteableRegistry namedWriteableRegistry) {     return Collections.emptyList(). }
true;public;0;3;/**  * Additional node settings loaded by the plugin. Note that settings that are explicit in the nodes settings can't be  * overwritten with the additional settings. These settings added if they don't exist.  */ ;/**  * Additional node settings loaded by the plugin. Note that settings that are explicit in the nodes settings can't be  * overwritten with the additional settings. These settings added if they don't exist.  */ public Settings additionalSettings() {     return Settings.Builder.EMPTY_SETTINGS. }
true;public;0;3;/**  * Returns parsers for {@link NamedWriteable} this plugin will use over the transport protocol.  * @see NamedWriteableRegistry  */ ;/**  * Returns parsers for {@link NamedWriteable} this plugin will use over the transport protocol.  * @see NamedWriteableRegistry  */ public List<NamedWriteableRegistry.Entry> getNamedWriteables() {     return Collections.emptyList(). }
true;public;0;3;/**  * Returns parsers for named objects this plugin will parse from {@link XContentParser#namedObject(Class, String, Object)}.  * @see NamedWriteableRegistry  */ ;/**  * Returns parsers for named objects this plugin will parse from {@link XContentParser#namedObject(Class, String, Object)}.  * @see NamedWriteableRegistry  */ public List<NamedXContentRegistry.Entry> getNamedXContent() {     return Collections.emptyList(). }
true;public;1;1;/**  * Called before a new index is created on a node. The given module can be used to register index-level  * extensions.  */ ;/**  * Called before a new index is created on a node. The given module can be used to register index-level  * extensions.  */ public void onIndexModule(IndexModule indexModule) { }
true;public;0;1;/**  * Returns a list of additional {@link Setting} definitions for this plugin.  */ ;/**  * Returns a list of additional {@link Setting} definitions for this plugin.  */ public List<Setting<?>> getSettings() {     return Collections.emptyList(). }
true;public;0;1;/**  * Returns a list of additional settings filter for this plugin  */ ;/**  * Returns a list of additional settings filter for this plugin  */ public List<String> getSettingsFilter() {     return Collections.emptyList(). }
true;public;0;3;/**  * Get the setting upgraders provided by this plugin.  *  * @return the settings upgraders  */ ;/**  * Get the setting upgraders provided by this plugin.  *  * @return the settings upgraders  */ public List<SettingUpgrader<?>> getSettingUpgraders() {     return Collections.emptyList(). }
true;public;0;3;/**  * Provides a function to modify global custom meta data on startup.  * <p>  * Plugins should return the input custom map via {@link UnaryOperator#identity()} if no upgrade is required.  * <p>  * The order of custom meta data upgraders calls is undefined and can change between runs so, it is expected that  * plugins will modify only data owned by them to avoid conflicts.  * <p>  * @return Never {@code null}. The same or upgraded {@code MetaData.Custom} map.  * @throws IllegalStateException if the node should not start because at least one {@code MetaData.Custom}  *                               is unsupported  */ ;/**  * Provides a function to modify global custom meta data on startup.  * <p>  * Plugins should return the input custom map via {@link UnaryOperator#identity()} if no upgrade is required.  * <p>  * The order of custom meta data upgraders calls is undefined and can change between runs so, it is expected that  * plugins will modify only data owned by them to avoid conflicts.  * <p>  * @return Never {@code null}. The same or upgraded {@code MetaData.Custom} map.  * @throws IllegalStateException if the node should not start because at least one {@code MetaData.Custom}  *                               is unsupported  */ public UnaryOperator<Map<String, MetaData.Custom>> getCustomMetaDataUpgrader() {     return UnaryOperator.identity(). }
true;public;0;3;/**  * Provides a function to modify index template meta data on startup.  * <p>  * Plugins should return the input template map via {@link UnaryOperator#identity()} if no upgrade is required.  * <p>  * The order of the template upgrader calls is undefined and can change between runs so, it is expected that  * plugins will modify only templates owned by them to avoid conflicts.  * <p>  * @return Never {@code null}. The same or upgraded {@code IndexTemplateMetaData} map.  * @throws IllegalStateException if the node should not start because at least one {@code IndexTemplateMetaData}  *                               cannot be upgraded  */ ;/**  * Provides a function to modify index template meta data on startup.  * <p>  * Plugins should return the input template map via {@link UnaryOperator#identity()} if no upgrade is required.  * <p>  * The order of the template upgrader calls is undefined and can change between runs so, it is expected that  * plugins will modify only templates owned by them to avoid conflicts.  * <p>  * @return Never {@code null}. The same or upgraded {@code IndexTemplateMetaData} map.  * @throws IllegalStateException if the node should not start because at least one {@code IndexTemplateMetaData}  *                               cannot be upgraded  */ public UnaryOperator<Map<String, IndexTemplateMetaData>> getIndexTemplateMetaDataUpgrader() {     return UnaryOperator.identity(). }
true;public;0;3;/**  * Provides a function to modify index meta data when an index is introduced into the cluster state for the first time.  * <p>  * Plugins should return the input index metadata via {@link UnaryOperator#identity()} if no upgrade is required.  * <p>  * The order of the index upgrader calls for the same index is undefined and can change between runs so, it is expected that  * plugins will modify only indices owned by them to avoid conflicts.  * <p>  * @return Never {@code null}. The same or upgraded {@code IndexMetaData}.  * @throws IllegalStateException if the node should not start because the index is unsupported  */ ;/**  * Provides a function to modify index meta data when an index is introduced into the cluster state for the first time.  * <p>  * Plugins should return the input index metadata via {@link UnaryOperator#identity()} if no upgrade is required.  * <p>  * The order of the index upgrader calls for the same index is undefined and can change between runs so, it is expected that  * plugins will modify only indices owned by them to avoid conflicts.  * <p>  * @return Never {@code null}. The same or upgraded {@code IndexMetaData}.  * @throws IllegalStateException if the node should not start because the index is unsupported  */ public UnaryOperator<IndexMetaData> getIndexMetaDataUpgrader() {     return UnaryOperator.identity(). }
true;public;1;3;/**  * Provides the list of this plugin's custom thread pools, empty if  * none.  *  * @param settings the current settings  * @return executors builders for this plugin's custom thread pools  */ ;/**  * Provides the list of this plugin's custom thread pools, empty if  * none.  *  * @param settings the current settings  * @return executors builders for this plugin's custom thread pools  */ public List<ExecutorBuilder<?>> getExecutorBuilders(Settings settings) {     return Collections.emptyList(). }
true;public;0;1;/**  * Returns a list of checks that are enforced when a node starts up once a node has the transport protocol bound to a non-loopback  * interface. In this case we assume the node is running in production and all bootstrap checks must pass. This allows plugins  * to provide a better out of the box experience by pre-configuring otherwise (in production) mandatory settings or to enforce certain  * configurations like OS settings or 3rd party resources.  */ ;/**  * Returns a list of checks that are enforced when a node starts up once a node has the transport protocol bound to a non-loopback  * interface. In this case we assume the node is running in production and all bootstrap checks must pass. This allows plugins  * to provide a better out of the box experience by pre-configuring otherwise (in production) mandatory settings or to enforce certain  * configurations like OS settings or 3rd party resources.  */ public List<BootstrapCheck> getBootstrapChecks() {     return Collections.emptyList(). }
true;public;0;4;/**  * Close the resources opened by this plugin.  *  * @throws IOException if the plugin failed to close its resources  */ ;/**  * Close the resources opened by this plugin.  *  * @throws IOException if the plugin failed to close its resources  */ @Override public void close() throws IOException { }
