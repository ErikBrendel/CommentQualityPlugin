commented;modifiers;parameterAmount;loc;comment;code
false;protected;2;4;;@Override protected AggregationBuilder shallowCopy(Builder factoriesBuilder, Map<String, Object> metaData) {     return new TopHitsAggregationBuilder(this, factoriesBuilder, metaData). }
false;protected;1;38;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     out.writeBoolean(explain).     out.writeOptionalWriteable(fetchSourceContext).     boolean hasFieldDataFields = docValueFields != null.     out.writeBoolean(hasFieldDataFields).     if (hasFieldDataFields) {         out.writeVInt(docValueFields.size()).         for (FieldAndFormat ff : docValueFields) {             ff.writeTo(out).         }     }     out.writeOptionalWriteable(storedFieldsContext).     out.writeVInt(from).     out.writeOptionalWriteable(highlightBuilder).     boolean hasScriptFields = scriptFields != null.     out.writeBoolean(hasScriptFields).     if (hasScriptFields) {         out.writeVInt(scriptFields.size()).         for (ScriptField scriptField : scriptFields) {             scriptField.writeTo(out).         }     }     out.writeVInt(size).     boolean hasSorts = sorts != null.     out.writeBoolean(hasSorts).     if (hasSorts) {         out.writeVInt(sorts.size()).         for (SortBuilder<?> sort : sorts) {             out.writeNamedWriteable(sort).         }     }     out.writeBoolean(trackScores).     out.writeBoolean(version).     if (out.getVersion().onOrAfter(Version.V_6_7_0)) {         out.writeBoolean(seqNoAndPrimaryTerm).     } }
true;public;1;7;/**  * From index to start the search from. Defaults to {@code 0}.  */ ;/**  * From index to start the search from. Defaults to {@code 0}.  */ public TopHitsAggregationBuilder from(int from) {     if (from < 0) {         throw new IllegalArgumentException("[from] must be greater than or equal to 0. Found [" + from + "] in [" + name + "]").     }     this.from = from.     return this. }
true;public;0;3;/**  * Gets the from index to start the search from.  */ ;/**  * Gets the from index to start the search from.  */ public int from() {     return from. }
true;public;1;7;/**  * The number of search hits to return. Defaults to {@code 10}.  */ ;/**  * The number of search hits to return. Defaults to {@code 10}.  */ public TopHitsAggregationBuilder size(int size) {     if (size < 0) {         throw new IllegalArgumentException("[size] must be greater than or equal to 0. Found [" + size + "] in [" + name + "]").     }     this.size = size.     return this. }
true;public;0;3;/**  * Gets the number of search hits to return.  */ ;/**  * Gets the number of search hits to return.  */ public int size() {     return size. }
true;public;2;13;/**  * Adds a sort against the given field name and the sort ordering.  *  * @param name  *            The name of the field  * @param order  *            The sort ordering  */ ;/**  * Adds a sort against the given field name and the sort ordering.  *  * @param name  *            The name of the field  * @param order  *            The sort ordering  */ public TopHitsAggregationBuilder sort(String name, SortOrder order) {     if (name == null) {         throw new IllegalArgumentException("sort [name] must not be null: [" + name + "]").     }     if (order == null) {         throw new IllegalArgumentException("sort [order] must not be null: [" + name + "]").     }     if (name.equals(ScoreSortBuilder.NAME)) {         sort(SortBuilders.scoreSort().order(order)).     }     sort(SortBuilders.fieldSort(name).order(order)).     return this. }
true;public;1;10;/**  * Add a sort against the given field name.  *  * @param name  *            The name of the field to sort by  */ ;/**  * Add a sort against the given field name.  *  * @param name  *            The name of the field to sort by  */ public TopHitsAggregationBuilder sort(String name) {     if (name == null) {         throw new IllegalArgumentException("sort [name] must not be null: [" + name + "]").     }     if (name.equals(ScoreSortBuilder.NAME)) {         sort(SortBuilders.scoreSort()).     }     sort(SortBuilders.fieldSort(name)).     return this. }
true;public;1;10;/**  * Adds a sort builder.  */ ;/**  * Adds a sort builder.  */ public TopHitsAggregationBuilder sort(SortBuilder<?> sort) {     if (sort == null) {         throw new IllegalArgumentException("[sort] must not be null: [" + name + "]").     }     if (sorts == null) {         sorts = new ArrayList<>().     }     sorts.add(sort).     return this. }
true;public;1;12;/**  * Adds a sort builder.  */ ;/**  * Adds a sort builder.  */ public TopHitsAggregationBuilder sorts(List<SortBuilder<?>> sorts) {     if (sorts == null) {         throw new IllegalArgumentException("[sorts] must not be null: [" + name + "]").     }     if (this.sorts == null) {         this.sorts = new ArrayList<>().     }     for (SortBuilder<?> sort : sorts) {         this.sorts.add(sort).     }     return this. }
true;public;0;3;/**  * Gets the bytes representing the sort builders for this request.  */ ;/**  * Gets the bytes representing the sort builders for this request.  */ public List<SortBuilder<?>> sorts() {     return sorts. }
true;public;1;7;/**  * Adds highlight to perform as part of the search.  */ ;/**  * Adds highlight to perform as part of the search.  */ public TopHitsAggregationBuilder highlighter(HighlightBuilder highlightBuilder) {     if (highlightBuilder == null) {         throw new IllegalArgumentException("[highlightBuilder] must not be null: [" + name + "]").     }     this.highlightBuilder = highlightBuilder.     return this. }
true;public;0;3;/**  * Gets the highlighter builder for this request.  */ ;/**  * Gets the highlighter builder for this request.  */ public HighlightBuilder highlighter() {     return highlightBuilder. }
true;public;1;6;/**  * Indicates whether the response should contain the stored _source for  * every hit  */ ;/**  * Indicates whether the response should contain the stored _source for  * every hit  */ public TopHitsAggregationBuilder fetchSource(boolean fetch) {     FetchSourceContext fetchSourceContext = this.fetchSourceContext != null ? this.fetchSourceContext : FetchSourceContext.FETCH_SOURCE.     this.fetchSourceContext = new FetchSourceContext(fetch, fetchSourceContext.includes(), fetchSourceContext.excludes()).     return this. }
true;public;2;5;/**  * Indicate that _source should be returned with every hit, with an  * "include" and/or "exclude" set which can include simple wildcard  * elements.  *  * @param include  *            An optional include (optionally wildcarded) pattern to  *            filter the returned _source  * @param exclude  *            An optional exclude (optionally wildcarded) pattern to  *            filter the returned _source  */ ;/**  * Indicate that _source should be returned with every hit, with an  * "include" and/or "exclude" set which can include simple wildcard  * elements.  *  * @param include  *            An optional include (optionally wildcarded) pattern to  *            filter the returned _source  * @param exclude  *            An optional exclude (optionally wildcarded) pattern to  *            filter the returned _source  */ public TopHitsAggregationBuilder fetchSource(@Nullable String include, @Nullable String exclude) {     fetchSource(include == null ? Strings.EMPTY_ARRAY : new String[] { include }, exclude == null ? Strings.EMPTY_ARRAY : new String[] { exclude }).     return this. }
true;public;2;6;/**  * Indicate that _source should be returned with every hit, with an  * "include" and/or "exclude" set which can include simple wildcard  * elements.  *  * @param includes  *            An optional list of include (optionally wildcarded)  *            pattern to filter the returned _source  * @param excludes  *            An optional list of exclude (optionally wildcarded)  *            pattern to filter the returned _source  */ ;/**  * Indicate that _source should be returned with every hit, with an  * "include" and/or "exclude" set which can include simple wildcard  * elements.  *  * @param includes  *            An optional list of include (optionally wildcarded)  *            pattern to filter the returned _source  * @param excludes  *            An optional list of exclude (optionally wildcarded)  *            pattern to filter the returned _source  */ public TopHitsAggregationBuilder fetchSource(@Nullable String[] includes, @Nullable String[] excludes) {     FetchSourceContext fetchSourceContext = this.fetchSourceContext != null ? this.fetchSourceContext : FetchSourceContext.FETCH_SOURCE.     this.fetchSourceContext = new FetchSourceContext(fetchSourceContext.fetchSource(), includes, excludes).     return this. }
true;public;1;7;/**  * Indicate how the _source should be fetched.  */ ;/**  * Indicate how the _source should be fetched.  */ public TopHitsAggregationBuilder fetchSource(@Nullable FetchSourceContext fetchSourceContext) {     if (fetchSourceContext == null) {         throw new IllegalArgumentException("[fetchSourceContext] must not be null: [" + name + "]").     }     this.fetchSourceContext = fetchSourceContext.     return this. }
true;public;0;3;/**  * Gets the {@link FetchSourceContext} which defines how the _source  * should be fetched.  */ ;/**  * Gets the {@link FetchSourceContext} which defines how the _source  * should be fetched.  */ public FetchSourceContext fetchSource() {     return fetchSourceContext. }
true;public;1;3;/**  * Adds a stored field to load and return (note, it must be stored) as part of the search request.  * To disable the stored fields entirely (source and metadata fields) use {@code storedField("_none_")}.  */ ;/**  * Adds a stored field to load and return (note, it must be stored) as part of the search request.  * To disable the stored fields entirely (source and metadata fields) use {@code storedField("_none_")}.  */ public TopHitsAggregationBuilder storedField(String field) {     return storedFields(Collections.singletonList(field)). }
true;public;1;11;/**  * Sets the stored fields to load and return as part of the search request.  * To disable the stored fields entirely (source and metadata fields) use {@code storedField("_none_")}.  */ ;/**  * Sets the stored fields to load and return as part of the search request.  * To disable the stored fields entirely (source and metadata fields) use {@code storedField("_none_")}.  */ public TopHitsAggregationBuilder storedFields(List<String> fields) {     if (fields == null) {         throw new IllegalArgumentException("[fields] must not be null: [" + name + "]").     }     if (storedFieldsContext == null) {         storedFieldsContext = StoredFieldsContext.fromList(fields).     } else {         storedFieldsContext.addFieldNames(fields).     }     return this. }
true;public;0;3;/**  * Gets the stored fields context  */ ;/**  * Gets the stored fields context  */ public StoredFieldsContext storedFields() {     return storedFieldsContext. }
true;public;2;10;/**  * Adds a field to load from doc values and return as part of  * the search request.  */ ;/**  * Adds a field to load from doc values and return as part of  * the search request.  */ public TopHitsAggregationBuilder docValueField(String docValueField, String format) {     if (docValueField == null) {         throw new IllegalArgumentException("[docValueField] must not be null: [" + name + "]").     }     if (docValueFields == null) {         docValueFields = new ArrayList<>().     }     docValueFields.add(new FieldAndFormat(docValueField, format)).     return this. }
true;public;1;3;/**  * Adds a field to load from doc values and return as part of  * the search request.  */ ;/**  * Adds a field to load from doc values and return as part of  * the search request.  */ public TopHitsAggregationBuilder docValueField(String docValueField) {     return docValueField(docValueField, null). }
true;public;0;3;/**  * Gets the field-data fields.  */ ;/**  * Gets the field-data fields.  */ public List<FieldAndFormat> fieldDataFields() {     return docValueFields. }
true;public;2;10;/**  * Adds a script field under the given name with the provided script.  *  * @param name  *            The name of the field  * @param script  *            The script  */ ;/**  * Adds a script field under the given name with the provided script.  *  * @param name  *            The name of the field  * @param script  *            The script  */ public TopHitsAggregationBuilder scriptField(String name, Script script) {     if (name == null) {         throw new IllegalArgumentException("scriptField [name] must not be null: [" + name + "]").     }     if (script == null) {         throw new IllegalArgumentException("scriptField [script] must not be null: [" + name + "]").     }     scriptField(name, script, false).     return this. }
true;public;3;13;/**  * Adds a script field under the given name with the provided script.  *  * @param name  *            The name of the field  * @param script  *            The script  */ ;/**  * Adds a script field under the given name with the provided script.  *  * @param name  *            The name of the field  * @param script  *            The script  */ public TopHitsAggregationBuilder scriptField(String name, Script script, boolean ignoreFailure) {     if (name == null) {         throw new IllegalArgumentException("scriptField [name] must not be null: [" + name + "]").     }     if (script == null) {         throw new IllegalArgumentException("scriptField [script] must not be null: [" + name + "]").     }     if (scriptFields == null) {         scriptFields = new HashSet<>().     }     scriptFields.add(new ScriptField(name, script, ignoreFailure)).     return this. }
false;public;1;10;;public TopHitsAggregationBuilder scriptFields(List<ScriptField> scriptFields) {     if (scriptFields == null) {         throw new IllegalArgumentException("[scriptFields] must not be null: [" + name + "]").     }     if (this.scriptFields == null) {         this.scriptFields = new HashSet<>().     }     this.scriptFields.addAll(scriptFields).     return this. }
true;public;0;3;/**  * Gets the script fields.  */ ;/**  * Gets the script fields.  */ public Set<ScriptField> scriptFields() {     return scriptFields. }
true;public;1;4;/**  * Should each {@link org.elasticsearch.search.SearchHit} be returned  * with an explanation of the hit (ranking).  */ ;/**  * Should each {@link org.elasticsearch.search.SearchHit} be returned  * with an explanation of the hit (ranking).  */ public TopHitsAggregationBuilder explain(boolean explain) {     this.explain = explain.     return this. }
true;public;0;3;/**  * Indicates whether each search hit will be returned with an  * explanation of the hit (ranking)  */ ;/**  * Indicates whether each search hit will be returned with an  * explanation of the hit (ranking)  */ public boolean explain() {     return explain. }
true;public;1;4;/**  * Should each {@link org.elasticsearch.search.SearchHit} be returned  * with a version associated with it.  */ ;/**  * Should each {@link org.elasticsearch.search.SearchHit} be returned  * with a version associated with it.  */ public TopHitsAggregationBuilder version(boolean version) {     this.version = version.     return this. }
true;public;0;3;/**  * Indicates whether the document's version will be included in the  * search hits.  */ ;/**  * Indicates whether the document's version will be included in the  * search hits.  */ public boolean version() {     return version. }
true;public;1;4;/**  * Should each {@link org.elasticsearch.search.SearchHit} be returned with the  * sequence number and primary term of the last modification of the document.  */ ;/**  * Should each {@link org.elasticsearch.search.SearchHit} be returned with the  * sequence number and primary term of the last modification of the document.  */ public TopHitsAggregationBuilder seqNoAndPrimaryTerm(Boolean seqNoAndPrimaryTerm) {     this.seqNoAndPrimaryTerm = seqNoAndPrimaryTerm.     return this. }
true;public;0;3;/**  * Indicates whether {@link org.elasticsearch.search.SearchHit}s should be returned with the  * sequence number and primary term of the last modification of the document.  */ ;/**  * Indicates whether {@link org.elasticsearch.search.SearchHit}s should be returned with the  * sequence number and primary term of the last modification of the document.  */ public Boolean seqNoAndPrimaryTerm() {     return seqNoAndPrimaryTerm. }
true;public;1;4;/**  * Applies when sorting, and controls if scores will be tracked as well.  * Defaults to {@code false}.  */ ;/**  * Applies when sorting, and controls if scores will be tracked as well.  * Defaults to {@code false}.  */ public TopHitsAggregationBuilder trackScores(boolean trackScores) {     this.trackScores = trackScores.     return this. }
true;public;0;3;/**  * Indicates whether scores will be tracked for this request.  */ ;/**  * Indicates whether scores will be tracked for this request.  */ public boolean trackScores() {     return trackScores. }
false;public;1;5;;@Override public TopHitsAggregationBuilder subAggregations(Builder subFactories) {     throw new AggregationInitializationException("Aggregator [" + name + "] of type [" + getType() + "] cannot accept sub-aggregations"). }
false;protected;3;35;;@Override protected TopHitsAggregatorFactory doBuild(SearchContext context, AggregatorFactory<?> parent, Builder subfactoriesBuilder) throws IOException {     long innerResultWindow = from() + size().     int maxInnerResultWindow = context.mapperService().getIndexSettings().getMaxInnerResultWindow().     if (innerResultWindow > maxInnerResultWindow) {         throw new IllegalArgumentException("Top hits result window is too large, the top hits aggregator [" + name + "]'s from + size must be less " + "than or equal to: [" + maxInnerResultWindow + "] but was [" + innerResultWindow + "]. This limit can be set by changing the [" + IndexSettings.MAX_INNER_RESULT_WINDOW_SETTING.getKey() + "] index level setting.").     }     List<ScriptFieldsContext.ScriptField> fields = new ArrayList<>().     if (scriptFields != null) {         for (ScriptField field : scriptFields) {             QueryShardContext shardContext = context.getQueryShardContext().             FieldScript.Factory factory = shardContext.getScriptService().compile(field.script(), FieldScript.CONTEXT).             FieldScript.LeafFactory searchScript = factory.newFactory(field.script().getParams(), shardContext.lookup()).             fields.add(new org.elasticsearch.search.fetch.subphase.ScriptFieldsContext.ScriptField(field.fieldName(), searchScript, field.ignoreFailure())).         }     }     final Optional<SortAndFormats> optionalSort.     if (sorts == null) {         optionalSort = Optional.empty().     } else {         optionalSort = SortBuilder.buildSort(sorts, context.getQueryShardContext()).     }     return new TopHitsAggregatorFactory(name, from, size, explain, version, seqNoAndPrimaryTerm, trackScores, optionalSort, highlightBuilder, storedFieldsContext, docValueFields, fields, fetchSourceContext, context, parent, subfactoriesBuilder, metaData). }
false;protected;2;49;;@Override protected XContentBuilder internalXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.field(SearchSourceBuilder.FROM_FIELD.getPreferredName(), from).     builder.field(SearchSourceBuilder.SIZE_FIELD.getPreferredName(), size).     builder.field(SearchSourceBuilder.VERSION_FIELD.getPreferredName(), version).     builder.field(SearchSourceBuilder.SEQ_NO_PRIMARY_TERM_FIELD.getPreferredName(), seqNoAndPrimaryTerm).     builder.field(SearchSourceBuilder.EXPLAIN_FIELD.getPreferredName(), explain).     if (fetchSourceContext != null) {         builder.field(SearchSourceBuilder._SOURCE_FIELD.getPreferredName(), fetchSourceContext).     }     if (storedFieldsContext != null) {         storedFieldsContext.toXContent(SearchSourceBuilder.STORED_FIELDS_FIELD.getPreferredName(), builder).     }     if (docValueFields != null) {         builder.startArray(SearchSourceBuilder.DOCVALUE_FIELDS_FIELD.getPreferredName()).         for (FieldAndFormat dvField : docValueFields) {             builder.startObject().field("field", dvField.field).             if (dvField.format != null) {                 builder.field("format", dvField.format).             }             builder.endObject().         }         builder.endArray().     }     if (scriptFields != null) {         builder.startObject(SearchSourceBuilder.SCRIPT_FIELDS_FIELD.getPreferredName()).         for (ScriptField scriptField : scriptFields) {             scriptField.toXContent(builder, params).         }         builder.endObject().     }     if (sorts != null) {         builder.startArray(SearchSourceBuilder.SORT_FIELD.getPreferredName()).         for (SortBuilder<?> sort : sorts) {             sort.toXContent(builder, params).         }         builder.endArray().     }     if (trackScores) {         builder.field(SearchSourceBuilder.TRACK_SCORES_FIELD.getPreferredName(), true).     }     if (highlightBuilder != null) {         builder.field(SearchSourceBuilder.HIGHLIGHT_FIELD.getPreferredName(), highlightBuilder).     }     builder.endObject().     return builder. }
false;public,static;2;111;;public static TopHitsAggregationBuilder parse(String aggregationName, XContentParser parser) throws IOException {     TopHitsAggregationBuilder factory = new TopHitsAggregationBuilder(aggregationName).     XContentParser.Token token.     String currentFieldName = null.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token.isValue()) {             if (SearchSourceBuilder.FROM_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 factory.from(parser.intValue()).             } else if (SearchSourceBuilder.SIZE_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 factory.size(parser.intValue()).             } else if (SearchSourceBuilder.VERSION_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 factory.version(parser.booleanValue()).             } else if (SearchSourceBuilder.SEQ_NO_PRIMARY_TERM_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 factory.seqNoAndPrimaryTerm(parser.booleanValue()).             } else if (SearchSourceBuilder.EXPLAIN_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 factory.explain(parser.booleanValue()).             } else if (SearchSourceBuilder.TRACK_SCORES_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 factory.trackScores(parser.booleanValue()).             } else if (SearchSourceBuilder._SOURCE_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 factory.fetchSource(FetchSourceContext.fromXContent(parser)).             } else if (SearchSourceBuilder.STORED_FIELDS_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 factory.storedFieldsContext = StoredFieldsContext.fromXContent(SearchSourceBuilder.STORED_FIELDS_FIELD.getPreferredName(), parser).             } else if (SearchSourceBuilder.SORT_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 factory.sort(parser.text()).             } else {                 throw new ParsingException(parser.getTokenLocation(), "Unknown key for a " + token + " in [" + currentFieldName + "].", parser.getTokenLocation()).             }         } else if (token == XContentParser.Token.START_OBJECT) {             if (SearchSourceBuilder._SOURCE_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 factory.fetchSource(FetchSourceContext.fromXContent(parser)).             } else if (SearchSourceBuilder.SCRIPT_FIELDS_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 List<ScriptField> scriptFields = new ArrayList<>().                 while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {                     String scriptFieldName = parser.currentName().                     token = parser.nextToken().                     if (token == XContentParser.Token.START_OBJECT) {                         Script script = null.                         boolean ignoreFailure = false.                         while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {                             if (token == XContentParser.Token.FIELD_NAME) {                                 currentFieldName = parser.currentName().                             } else if (token.isValue()) {                                 if (SearchSourceBuilder.SCRIPT_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                                     script = Script.parse(parser).                                 } else if (SearchSourceBuilder.IGNORE_FAILURE_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                                     ignoreFailure = parser.booleanValue().                                 } else {                                     throw new ParsingException(parser.getTokenLocation(), "Unknown key for a " + token + " in [" + currentFieldName + "].", parser.getTokenLocation()).                                 }                             } else if (token == XContentParser.Token.START_OBJECT) {                                 if (SearchSourceBuilder.SCRIPT_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                                     script = Script.parse(parser).                                 } else {                                     throw new ParsingException(parser.getTokenLocation(), "Unknown key for a " + token + " in [" + currentFieldName + "].", parser.getTokenLocation()).                                 }                             } else {                                 throw new ParsingException(parser.getTokenLocation(), "Unknown key for a " + token + " in [" + currentFieldName + "].", parser.getTokenLocation()).                             }                         }                         scriptFields.add(new ScriptField(scriptFieldName, script, ignoreFailure)).                     } else {                         throw new ParsingException(parser.getTokenLocation(), "Expected [" + XContentParser.Token.START_OBJECT + "] in [" + currentFieldName + "] but found [" + token + "]", parser.getTokenLocation()).                     }                 }                 factory.scriptFields(scriptFields).             } else if (SearchSourceBuilder.HIGHLIGHT_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 factory.highlighter(HighlightBuilder.fromXContent(parser)).             } else if (SearchSourceBuilder.SORT_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 List<SortBuilder<?>> sorts = SortBuilder.fromXContent(parser).                 factory.sorts(sorts).             } else {                 throw new ParsingException(parser.getTokenLocation(), "Unknown key for a " + token + " in [" + currentFieldName + "].", parser.getTokenLocation()).             }         } else if (token == XContentParser.Token.START_ARRAY) {             if (SearchSourceBuilder.STORED_FIELDS_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 factory.storedFieldsContext = StoredFieldsContext.fromXContent(SearchSourceBuilder.STORED_FIELDS_FIELD.getPreferredName(), parser).             } else if (SearchSourceBuilder.DOCVALUE_FIELDS_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {                     FieldAndFormat ff = FieldAndFormat.fromXContent(parser).                     factory.docValueField(ff.field, ff.format).                 }             } else if (SearchSourceBuilder.SORT_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 List<SortBuilder<?>> sorts = SortBuilder.fromXContent(parser).                 factory.sorts(sorts).             } else if (SearchSourceBuilder._SOURCE_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 factory.fetchSource(FetchSourceContext.fromXContent(parser)).             } else {                 throw new ParsingException(parser.getTokenLocation(), "Unknown key for a " + token + " in [" + currentFieldName + "].", parser.getTokenLocation()).             }         } else {             throw new ParsingException(parser.getTokenLocation(), "Unknown key for a " + token + " in [" + currentFieldName + "].", parser.getTokenLocation()).         }     }     return factory. }
false;protected;0;5;;@Override protected int doHashCode() {     return Objects.hash(explain, fetchSourceContext, docValueFields, storedFieldsContext, from, highlightBuilder, scriptFields, size, sorts, trackScores, version, seqNoAndPrimaryTerm). }
false;protected;1;16;;@Override protected boolean doEquals(Object obj) {     TopHitsAggregationBuilder other = (TopHitsAggregationBuilder) obj.     return Objects.equals(explain, other.explain) && Objects.equals(fetchSourceContext, other.fetchSourceContext) && Objects.equals(docValueFields, other.docValueFields) && Objects.equals(storedFieldsContext, other.storedFieldsContext) && Objects.equals(from, other.from) && Objects.equals(highlightBuilder, other.highlightBuilder) && Objects.equals(scriptFields, other.scriptFields) && Objects.equals(size, other.size) && Objects.equals(sorts, other.sorts) && Objects.equals(trackScores, other.trackScores) && Objects.equals(version, other.version) && Objects.equals(seqNoAndPrimaryTerm, other.seqNoAndPrimaryTerm). }
false;public;0;4;;@Override public String getType() {     return NAME. }
