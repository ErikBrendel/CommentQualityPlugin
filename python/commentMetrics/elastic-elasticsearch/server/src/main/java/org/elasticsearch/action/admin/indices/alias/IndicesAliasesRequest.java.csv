commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public byte value() {     return value. }
false;public,static;1;8;;public static Type fromValue(byte value) {     switch(value) {         case 0:             return ADD.         case 1:             return REMOVE.         case 2:             return REMOVE_INDEX.         default:             throw new IllegalArgumentException("No type for action [" + value + "]").     } }
true;public,static;0;3;/**  * Build a new {@link AliasAction} to add aliases.  */ ;/**  * Build a new {@link AliasAction} to add aliases.  */ public static AliasActions add() {     return new AliasActions(AliasActions.Type.ADD). }
true;public,static;0;3;/**  * Build a new {@link AliasAction} to remove aliases.  */ ;/**  * Build a new {@link AliasAction} to remove aliases.  */ public static AliasActions remove() {     return new AliasActions(AliasActions.Type.REMOVE). }
true;public,static;0;3;/**  * Build a new {@link AliasAction} to remove an index.  */ ;/**  * Build a new {@link AliasAction} to remove an index.  */ public static AliasActions removeIndex() {     return new AliasActions(AliasActions.Type.REMOVE_INDEX). }
false;private,static;2;28;;private static ObjectParser<AliasActions, Void> parser(String name, Supplier<AliasActions> supplier) {     ObjectParser<AliasActions, Void> parser = new ObjectParser<>(name, supplier).     parser.declareString((action, index) -> {         if (action.indices() != null) {             throw new IllegalArgumentException("Only one of [index] and [indices] is supported").         }         action.index(index).     }, INDEX).     parser.declareStringArray(fromList(String.class, (action, indices) -> {         if (action.indices() != null) {             throw new IllegalArgumentException("Only one of [index] and [indices] is supported").         }         action.indices(indices).     }), INDICES).     parser.declareString((action, alias) -> {         if (action.aliases() != null && action.aliases().length != 0) {             throw new IllegalArgumentException("Only one of [alias] and [aliases] is supported").         }         action.alias(alias).     }, ALIAS).     parser.declareStringArray(fromList(String.class, (action, aliases) -> {         if (action.aliases() != null && action.aliases().length != 0) {             throw new IllegalArgumentException("Only one of [alias] and [aliases] is supported").         }         action.aliases(aliases).     }), ALIASES).     return parser. }
false;public;1;16;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeByte(type.value()).     out.writeStringArray(indices).     out.writeStringArray(aliases).     out.writeOptionalString(filter).     out.writeOptionalString(routing).     out.writeOptionalString(searchRouting).     out.writeOptionalString(indexRouting).     if (out.getVersion().onOrAfter(Version.V_6_4_0)) {         out.writeOptionalBoolean(writeIndex).     }     if (out.getVersion().onOrAfter(Version.V_7_0_0)) {         out.writeStringArray(originalAliases).     } }
true;;0;8;/**  * Validate that the action is sane. Called when the action is added to the request because actions can be invalid while being  * built.  */ ;/**  * Validate that the action is sane. Called when the action is added to the request because actions can be invalid while being  * built.  */ void validate() {     if (indices == null) {         throw new IllegalArgumentException("One of [index] or [indices] is required").     }     if (type != AliasActions.Type.REMOVE_INDEX && (aliases == null || aliases.length == 0)) {         throw new IllegalArgumentException("One of [alias] or [aliases] is required").     } }
true;public;0;3;/**  * Type of the action to perform.  */ ;/**  * Type of the action to perform.  */ public AliasActions.Type actionType() {     return type. }
false;public;1;13;;@Override public AliasActions indices(String... indices) {     if (indices == null || indices.length == 0) {         throw new IllegalArgumentException("[indices] can't be empty").     }     for (String index : indices) {         if (false == Strings.hasLength(index)) {             throw new IllegalArgumentException("[indices] can't contain empty string").         }     }     this.indices = indices.     return this. }
true;public;1;7;/**  * Set the index this action is operating on.  */ ;/**  * Set the index this action is operating on.  */ public AliasActions index(String index) {     if (false == Strings.hasLength(index)) {         throw new IllegalArgumentException("[index] can't be empty string").     }     this.indices = new String[] { index }.     return this. }
true;public;1;16;/**  * Aliases to use with this action.  */ ;/**  * Aliases to use with this action.  */ public AliasActions aliases(String... aliases) {     if (type == AliasActions.Type.REMOVE_INDEX) {         throw new IllegalArgumentException("[aliases] is unsupported for [" + type + "]").     }     if (aliases == null || aliases.length == 0) {         throw new IllegalArgumentException("[aliases] can't be empty").     }     for (String alias : aliases) {         if (false == Strings.hasLength(alias)) {             throw new IllegalArgumentException("[aliases] can't contain empty string").         }     }     this.aliases = aliases.     this.originalAliases = aliases.     return this. }
true;public;1;11;/**  * Set the alias this action is operating on.  */ ;/**  * Set the alias this action is operating on.  */ public AliasActions alias(String alias) {     if (type == AliasActions.Type.REMOVE_INDEX) {         throw new IllegalArgumentException("[alias] is unsupported for [" + type + "]").     }     if (false == Strings.hasLength(alias)) {         throw new IllegalArgumentException("[alias] can't be empty string").     }     this.aliases = new String[] { alias }.     this.originalAliases = aliases.     return this. }
true;public;1;7;/**  * Set the default routing.  */ ;/**  * Set the default routing.  */ public AliasActions routing(String routing) {     if (type != AliasActions.Type.ADD) {         throw new IllegalArgumentException("[routing] is unsupported for [" + type + "]").     }     this.routing = routing.     return this. }
false;public;0;3;;public String searchRouting() {     return searchRouting == null ? routing : searchRouting. }
false;public;1;7;;public AliasActions searchRouting(String searchRouting) {     if (type != AliasActions.Type.ADD) {         throw new IllegalArgumentException("[search_routing] is unsupported for [" + type + "]").     }     this.searchRouting = searchRouting.     return this. }
false;public;0;3;;public String indexRouting() {     return indexRouting == null ? routing : indexRouting. }
false;public;1;7;;public AliasActions indexRouting(String indexRouting) {     if (type != AliasActions.Type.ADD) {         throw new IllegalArgumentException("[index_routing] is unsupported for [" + type + "]").     }     this.indexRouting = indexRouting.     return this. }
false;public;0;3;;public String filter() {     return filter. }
false;public;1;7;;public AliasActions filter(String filter) {     if (type != AliasActions.Type.ADD) {         throw new IllegalArgumentException("[filter] is unsupported for [" + type + "]").     }     this.filter = filter.     return this. }
false;public;1;14;;public AliasActions filter(Map<String, Object> filter) {     if (filter == null || filter.isEmpty()) {         this.filter = null.         return this.     }     try {         XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON).         builder.map(filter).         this.filter = Strings.toString(builder).         return this.     } catch (IOException e) {         throw new ElasticsearchGenerationException("Failed to generate [" + filter + "]", e).     } }
false;public;1;15;;public AliasActions filter(QueryBuilder filter) {     if (filter == null) {         this.filter = null.         return this.     }     try {         XContentBuilder builder = XContentFactory.jsonBuilder().         filter.toXContent(builder, ToXContent.EMPTY_PARAMS).         builder.close().         this.filter = Strings.toString(builder).         return this.     } catch (IOException e) {         throw new ElasticsearchGenerationException("Failed to build json for alias request", e).     } }
false;public;1;7;;public AliasActions writeIndex(Boolean writeIndex) {     if (type != AliasActions.Type.ADD) {         throw new IllegalArgumentException("[is_write_index] is unsupported for [" + type + "]").     }     this.writeIndex = writeIndex.     return this. }
false;public;0;3;;public Boolean writeIndex() {     return writeIndex. }
false;public;0;4;;@Override public String[] aliases() {     return aliases. }
false;public;1;4;;@Override public void replaceAliases(String... aliases) {     this.aliases = aliases. }
false;public;0;4;;@Override public String[] getOriginalAliases() {     return originalAliases. }
false;public;0;5;;@Override public boolean expandAliasesWildcards() {     // remove operations support wildcards among aliases, add operations don't     return type == Type.REMOVE. }
false;public;0;4;;@Override public String[] indices() {     return indices. }
false;public;0;4;;@Override public IndicesOptions indicesOptions() {     return INDICES_OPTIONS. }
false;public;2;31;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.startObject(type.fieldName).     if (null != indices && 0 != indices.length) {         builder.array(INDICES.getPreferredName(), indices).     }     if (0 != aliases.length) {         builder.array(ALIASES.getPreferredName(), aliases).     }     if (false == Strings.isEmpty(filter)) {         try (InputStream stream = new BytesArray(filter).streamInput()) {             builder.rawField(FILTER.getPreferredName(), stream, XContentType.JSON).         }     }     if (false == Strings.isEmpty(routing)) {         builder.field(ROUTING.getPreferredName(), routing).     }     if (false == Strings.isEmpty(indexRouting)) {         builder.field(INDEX_ROUTING.getPreferredName(), indexRouting).     }     if (false == Strings.isEmpty(searchRouting)) {         builder.field(SEARCH_ROUTING.getPreferredName(), searchRouting).     }     if (null != writeIndex) {         builder.field(IS_WRITE_INDEX.getPreferredName(), writeIndex).     }     builder.endObject().     builder.endObject().     return builder. }
false;public,static;1;3;;public static AliasActions fromXContent(XContentParser parser) throws IOException {     return PARSER.apply(parser, null). }
false;public;0;13;;@Override public String toString() {     return "AliasActions[" + "type=" + type + ",indices=" + Arrays.toString(indices) + ",aliases=" + Arrays.deepToString(aliases) + ",filter=" + filter + ",routing=" + routing + ",indexRouting=" + indexRouting + ",searchRouting=" + searchRouting + ",writeIndex=" + writeIndex + "]". }
true;public;1;15;// equals, and hashCode implemented for easy testing of round trip ;// equals, and hashCode implemented for easy testing of round trip @Override public boolean equals(Object obj) {     if (obj == null || obj.getClass() != getClass()) {         return false.     }     AliasActions other = (AliasActions) obj.     return Objects.equals(type, other.type) && Arrays.equals(indices, other.indices) && Arrays.equals(aliases, other.aliases) && Objects.equals(filter, other.filter) && Objects.equals(routing, other.routing) && Objects.equals(indexRouting, other.indexRouting) && Objects.equals(searchRouting, other.searchRouting) && Objects.equals(writeIndex, other.writeIndex). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(type, indices, aliases, filter, routing, indexRouting, searchRouting, writeIndex). }
true;public;1;5;/**  * Add the action to this request and validate it.  */ ;/**  * Add the action to this request and validate it.  */ public IndicesAliasesRequest addAliasAction(AliasActions aliasAction) {     aliasAction.validate().     allAliasActions.add(aliasAction).     return this. }
false;;0;3;;List<AliasActions> aliasActions() {     return this.allAliasActions. }
false;public;0;3;;public List<AliasActions> getAliasActions() {     return aliasActions(). }
false;public;0;8;;@Override public ActionRequestValidationException validate() {     ActionRequestValidationException validationException = null.     if (allAliasActions.isEmpty()) {         return addValidationError("Must specify at least one alias action", validationException).     }     return validationException. }
false;public;1;5;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     allAliasActions = in.readList(AliasActions::new). }
false;public;1;5;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeList(allAliasActions). }
false;public;0;3;;public IndicesOptions indicesOptions() {     return INDICES_OPTIONS. }
false;public;2;11;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.startArray("actions").     for (AliasActions action : allAliasActions) {         action.toXContent(builder, params).     }     builder.endArray().     builder.endObject().     return builder. }
false;public,static;1;3;;public static IndicesAliasesRequest fromXContent(XContentParser parser) {     return PARSER.apply(parser, null). }
