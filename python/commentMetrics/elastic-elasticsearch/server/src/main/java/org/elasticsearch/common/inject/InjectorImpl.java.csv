commented;modifiers;parameterAmount;loc;comment;code
true;;0;5;/**  * Indexes bindings by type.  */ ;/**  * Indexes bindings by type.  */ void index() {     for (Binding<?> binding : state.getExplicitBindingsThisLevel().values()) {         index(binding).     } }
false;;1;3;;<T> void index(Binding<T> binding) {     bindingsMultimap.put(binding.getKey().getTypeLiteral(), binding). }
false;public;1;4;;@Override public <T> List<Binding<T>> findBindingsByType(TypeLiteral<T> type) {     return bindingsMultimap.getAll(type). }
true;public;2;11;/**  * Gets a binding implementation.  First, it check to see if the parent has a binding.  If the  * parent has a binding and the binding is scoped, it will use that binding.  Otherwise, this  * checks for an explicit binding. If no explicit binding is found, it looks for a just-in-time  * binding.  */ ;/**  * Gets a binding implementation.  First, it check to see if the parent has a binding.  If the  * parent has a binding and the binding is scoped, it will use that binding.  Otherwise, this  * checks for an explicit binding. If no explicit binding is found, it looks for a just-in-time  * binding.  */ public <T> BindingImpl<T> getBindingOrThrow(Key<T> key, Errors errors) throws ErrorsException {     // Check explicit bindings, i.e. bindings created by modules.     BindingImpl<T> binding = state.getExplicitBinding(key).     if (binding != null) {         return binding.     }     // Look for an on-demand binding.     return getJustInTimeBinding(key, errors). }
true;private;2;14;/**  * Returns a just-in-time binding for {@code key}, creating it if necessary.  *  * @throws ErrorsException if the binding could not be created.  */ ;/**  * Returns a just-in-time binding for {@code key}, creating it if necessary.  *  * @throws ErrorsException if the binding could not be created.  */ private <T> BindingImpl<T> getJustInTimeBinding(Key<T> key, Errors errors) throws ErrorsException {     synchronized (state.lock()) {         // first try to find a JIT binding that we've already created         // we only store bindings that match their key         @SuppressWarnings("unchecked")         BindingImpl<T> binding = (BindingImpl<T>) jitBindings.get(key).         if (binding != null) {             return binding.         }         return createJustInTimeBindingRecursive(key, errors).     } }
true;static;1;3;/**  * Returns true if the key type is Provider (but not a subclass of Provider).  */ ;/**  * Returns true if the key type is Provider (but not a subclass of Provider).  */ static boolean isProvider(Key<?> key) {     return key.getTypeLiteral().getRawType().equals(Provider.class). }
true;static;1;4;/**  * Returns true if the key type is MembersInjector (but not a subclass of MembersInjector).  */ ;/**  * Returns true if the key type is MembersInjector (but not a subclass of MembersInjector).  */ static boolean isMembersInjector(Key<?> key) {     return key.getTypeLiteral().getRawType().equals(MembersInjector.class) && !key.hasAnnotationType(). }
false;private;2;19;;private <T> BindingImpl<MembersInjector<T>> createMembersInjectorBinding(Key<MembersInjector<T>> key, Errors errors) throws ErrorsException {     Type membersInjectorType = key.getTypeLiteral().getType().     if (!(membersInjectorType instanceof ParameterizedType)) {         throw errors.cannotInjectRawMembersInjector().toException().     }     // safe because T came from Key<MembersInjector<T>>     @SuppressWarnings("unchecked")     TypeLiteral<T> instanceType = (TypeLiteral<T>) TypeLiteral.get(((ParameterizedType) membersInjectorType).getActualTypeArguments()[0]).     MembersInjector<T> membersInjector = membersInjectorStore.get(instanceType, errors).     InternalFactory<MembersInjector<T>> factory = new ConstantFactory<>(Initializables.of(membersInjector)).     return new InstanceBindingImpl<>(this, key, SourceProvider.UNKNOWN_SOURCE, factory, emptySet(), membersInjector). }
true;private;2;17;/**  * Creates a synthetic binding to {@code Provider<T>}, i.e. a binding to the provider from  * {@code Binding<T>}.  */ ;/**  * Creates a synthetic binding to {@code Provider<T>}, i.e. a binding to the provider from  * {@code Binding<T>}.  */ private <T> BindingImpl<Provider<T>> createProviderBinding(Key<Provider<T>> key, Errors errors) throws ErrorsException {     Type providerType = key.getTypeLiteral().getType().     // If the Provider has no type parameter (raw Provider)...     if (!(providerType instanceof ParameterizedType)) {         throw errors.cannotInjectRawProvider().toException().     }     Type entryType = ((ParameterizedType) providerType).getActualTypeArguments()[0].     // safe because T came from Key<Provider<T>>     @SuppressWarnings("unchecked")     Key<T> providedKey = (Key<T>) key.ofType(entryType).     BindingImpl<T> delegate = getBindingOrThrow(providedKey, errors).     return new ProviderBindingImpl<>(this, key, delegate). }
false;public;3;4;;@Override public Provider<T> get(Errors errors, InternalContext context, Dependency dependency) {     return provider. }
false;static;1;9;;static <T> InternalFactory<Provider<T>> createInternalFactory(Binding<T> providedBinding) {     final Provider<T> provider = providedBinding.getProvider().     return new InternalFactory<Provider<T>>() {          @Override         public Provider<T> get(Errors errors, InternalContext context, Dependency dependency) {             return provider.         }     }. }
false;public;0;4;;@Override public Key<? extends T> getProvidedKey() {     return providedBinding.getKey(). }
false;public;1;4;;@Override public <V> V acceptTargetVisitor(BindingTargetVisitor<? super Provider<T>, V> visitor) {     return visitor.visit(this). }
false;public;1;4;;@Override public void applyTo(Binder binder) {     throw new UnsupportedOperationException("This element represents a synthetic binding."). }
false;public;0;7;;@Override public String toString() {     return new ToStringBuilder(ProviderKeyBinding.class).add("key", getKey()).add("providedKey", getProvidedKey()).toString(). }
true;private;2;44;/**  * Converts a constant string binding to the required type.  *  * @return the binding if it could be resolved, or null if the binding doesn't exist  * @throws org.elasticsearch.common.inject.internal.ErrorsException  *          if there was an error resolving the binding  */ ;/**  * Converts a constant string binding to the required type.  *  * @return the binding if it could be resolved, or null if the binding doesn't exist  * @throws org.elasticsearch.common.inject.internal.ErrorsException  *          if there was an error resolving the binding  */ private <T> BindingImpl<T> convertConstantStringBinding(Key<T> key, Errors errors) throws ErrorsException {     // Find a constant string binding.     Key<String> stringKey = key.ofType(String.class).     BindingImpl<String> stringBinding = state.getExplicitBinding(stringKey).     if (stringBinding == null || !stringBinding.isConstant()) {         return null.     }     String stringValue = stringBinding.getProvider().get().     Object source = stringBinding.getSource().     // Find a matching type converter.     TypeLiteral<T> type = key.getTypeLiteral().     MatcherAndConverter matchingConverter = state.getConverter(stringValue, type, errors, source).     if (matchingConverter == null) {         // No converter can handle the given type.         return null.     }     // Try to convert the string. A failed conversion results in an error.     try {         // This cast is safe because we double check below.         @SuppressWarnings("unchecked")         T converted = (T) matchingConverter.getTypeConverter().convert(stringValue, type).         if (converted == null) {             throw errors.converterReturnedNull(stringValue, source, type, matchingConverter).toException().         }         if (!type.getRawType().isInstance(converted)) {             throw errors.conversionTypeError(stringValue, source, type, matchingConverter, converted).toException().         }         return new ConvertedConstantBindingImpl<>(this, key, converted, stringBinding).     } catch (ErrorsException e) {         throw e.     } catch (RuntimeException e) {         throw errors.conversionError(stringValue, source, type, matchingConverter, e).toException().     } }
false;public;0;4;;@Override public Provider<T> getProvider() {     return provider. }
false;public;1;4;;@Override public <V> V acceptTargetVisitor(BindingTargetVisitor<? super T, V> visitor) {     return visitor.visit(this). }
false;public;0;4;;@Override public T getValue() {     return value. }
false;public;0;4;;@Override public Key<String> getSourceKey() {     return originalBinding.getKey(). }
false;public;0;4;;@Override public Set<Dependency<?>> getDependencies() {     return singleton(Dependency.get(getSourceKey())). }
false;public;1;4;;@Override public void applyTo(Binder binder) {     throw new UnsupportedOperationException("This element represents a synthetic binding."). }
false;public;0;8;;@Override public String toString() {     return new ToStringBuilder(ConvertedConstantBinding.class).add("key", getKey()).add("sourceKey", getSourceKey()).add("value", value).toString(). }
false;;2;19;;<T> void initializeBinding(BindingImpl<T> binding, Errors errors) throws ErrorsException {     // TODO: for the above example, remove the binding for BarImpl if the binding for FooImpl fails     if (binding instanceof ConstructorBindingImpl<?>) {         Key<T> key = binding.getKey().         jitBindings.put(key, binding).         boolean successful = false.         try {             ((ConstructorBindingImpl) binding).initialize(this, errors).             successful = true.         } finally {             if (!successful) {                 jitBindings.remove(key).             }         }     } }
true;;4;53;/**  * Creates a binding for an injectable type with the given scope. Looks for a scope on the type if  * none is specified.  */ ;/**  * Creates a binding for an injectable type with the given scope. Looks for a scope on the type if  * none is specified.  */ <T> BindingImpl<T> createUnitializedBinding(Key<T> key, Scoping scoping, Object source, Errors errors) throws ErrorsException {     Class<?> rawType = key.getTypeLiteral().getRawType().     // Don't try to inject arrays, or enums.     if (rawType.isArray() || rawType.isEnum()) {         throw errors.missingImplementation(key).toException().     }     // Handle TypeLiteral<T> by binding the inner type     if (rawType == TypeLiteral.class) {         // we have to fudge the inner type as Object         @SuppressWarnings("unchecked")         BindingImpl<T> binding = (BindingImpl<T>) createTypeLiteralBinding((Key<TypeLiteral<Object>>) key, errors).         return binding.     }     // Handle @ImplementedBy     ImplementedBy implementedBy = rawType.getAnnotation(ImplementedBy.class).     if (implementedBy != null) {         Annotations.checkForMisplacedScopeAnnotations(rawType, source, errors).         return createImplementedByBinding(key, scoping, implementedBy, errors).     }     // Handle @ProvidedBy.     ProvidedBy providedBy = rawType.getAnnotation(ProvidedBy.class).     if (providedBy != null) {         Annotations.checkForMisplacedScopeAnnotations(rawType, source, errors).         return createProvidedByBinding(key, scoping, providedBy, errors).     }     // abstract types. Should we remove this restriction?     if (Modifier.isAbstract(rawType.getModifiers())) {         throw errors.missingImplementation(key).toException().     }     // Error: Inner class.     if (Classes.isInnerClass(rawType)) {         throw errors.cannotInjectInnerClass(rawType).toException().     }     if (!scoping.isExplicitlyScoped()) {         Class<? extends Annotation> scopeAnnotation = findScopeAnnotation(errors, rawType).         if (scopeAnnotation != null) {             scoping = Scopes.makeInjectable(Scoping.forAnnotation(scopeAnnotation), this, errors.withSource(rawType)).         }     }     return ConstructorBindingImpl.create(this, key, source, scoping). }
true;private;2;25;/**  * Converts a binding for a {@code Key<TypeLiteral<T>>} to the value {@code TypeLiteral<T>}. It's  * a bit awkward because we have to pull out the inner type in the type literal.  */ ;/**  * Converts a binding for a {@code Key<TypeLiteral<T>>} to the value {@code TypeLiteral<T>}. It's  * a bit awkward because we have to pull out the inner type in the type literal.  */ private <T> BindingImpl<TypeLiteral<T>> createTypeLiteralBinding(Key<TypeLiteral<T>> key, Errors errors) throws ErrorsException {     Type typeLiteralType = key.getTypeLiteral().getType().     if (!(typeLiteralType instanceof ParameterizedType)) {         throw errors.cannotInjectRawTypeLiteral().toException().     }     ParameterizedType parameterizedType = (ParameterizedType) typeLiteralType.     Type innerType = parameterizedType.getActualTypeArguments()[0].     // this proves problematic, we can probably fix TypeLiteral to support type variables     if (!(innerType instanceof Class) && !(innerType instanceof GenericArrayType) && !(innerType instanceof ParameterizedType)) {         throw errors.cannotInjectTypeLiteralOf(innerType).toException().     }     // by definition, innerType == T, so this is safe     @SuppressWarnings("unchecked")     TypeLiteral<T> value = (TypeLiteral<T>) TypeLiteral.get(innerType).     InternalFactory<TypeLiteral<T>> factory = new ConstantFactory<>(Initializables.of(value)).     return new InstanceBindingImpl<>(this, key, SourceProvider.UNKNOWN_SOURCE, factory, emptySet(), value). }
false;public;3;18;;@Override public T get(Errors errors, InternalContext context, Dependency dependency) throws ErrorsException {     errors = errors.withSource(providerKey).     Provider<?> provider = providerBinding.getInternalFactory().get(errors, context, dependency).     try {         Object o = provider.get().         if (o != null && !rawType.isInstance(o)) {             throw errors.subtypeNotProvided(providerType, rawType).toException().         }         // protected by isInstance() check above         @SuppressWarnings("unchecked")         T t = (T) o.         return t.     } catch (RuntimeException e) {         throw errors.errorInProvider(e).toException().     } }
true;;4;46;/**  * Creates a binding for a type annotated with @ProvidedBy.  */ ;/**  * Creates a binding for a type annotated with @ProvidedBy.  */ <T> BindingImpl<T> createProvidedByBinding(Key<T> key, Scoping scoping, ProvidedBy providedBy, Errors errors) throws ErrorsException {     final Class<?> rawType = key.getTypeLiteral().getRawType().     final Class<? extends Provider<?>> providerType = providedBy.value().     // Make sure it's not the same type. TODO: Can we check for deeper loops?     if (providerType == rawType) {         throw errors.recursiveProviderType().toException().     }     // Assume the provider provides an appropriate type. We double check at runtime.     @SuppressWarnings("unchecked")     final Key<? extends Provider<T>> providerKey = (Key<? extends Provider<T>>) Key.get(providerType).     final BindingImpl<? extends Provider<?>> providerBinding = getBindingOrThrow(providerKey, errors).     InternalFactory<T> internalFactory = new InternalFactory<T>() {          @Override         public T get(Errors errors, InternalContext context, Dependency dependency) throws ErrorsException {             errors = errors.withSource(providerKey).             Provider<?> provider = providerBinding.getInternalFactory().get(errors, context, dependency).             try {                 Object o = provider.get().                 if (o != null && !rawType.isInstance(o)) {                     throw errors.subtypeNotProvided(providerType, rawType).toException().                 }                 // protected by isInstance() check above                 @SuppressWarnings("unchecked")                 T t = (T) o.                 return t.             } catch (RuntimeException e) {                 throw errors.errorInProvider(e).toException().             }         }     }.     return new LinkedProviderBindingImpl<>(this, key, rawType, /* source */     Scopes.<T>scope(key, this, internalFactory, scoping), scoping, providerKey). }
false;public;3;6;;@Override public T get(Errors errors, InternalContext context, Dependency<?> dependency) throws ErrorsException {     return targetBinding.getInternalFactory().get(errors.withSource(targetKey), context, dependency). }
true;;4;40;/**  * Creates a binding for a type annotated with @ImplementedBy.  */ ;/**  * Creates a binding for a type annotated with @ImplementedBy.  */ <T> BindingImpl<T> createImplementedByBinding(Key<T> key, Scoping scoping, ImplementedBy implementedBy, Errors errors) throws ErrorsException {     Class<?> rawType = key.getTypeLiteral().getRawType().     Class<?> implementationType = implementedBy.value().     // Make sure it's not the same type. TODO: Can we check for deeper cycles?     if (implementationType == rawType) {         throw errors.recursiveImplementationType().toException().     }     // Make sure implementationType extends type.     if (!rawType.isAssignableFrom(implementationType)) {         throw errors.notASubtype(implementationType, rawType).toException().     }     // After the preceding check, this cast is safe.     @SuppressWarnings("unchecked")     Class<? extends T> subclass = (Class<? extends T>) implementationType.     // Look up the target binding.     final Key<? extends T> targetKey = Key.get(subclass).     final BindingImpl<? extends T> targetBinding = getBindingOrThrow(targetKey, errors).     InternalFactory<T> internalFactory = new InternalFactory<T>() {          @Override         public T get(Errors errors, InternalContext context, Dependency<?> dependency) throws ErrorsException {             return targetBinding.getInternalFactory().get(errors.withSource(targetKey), context, dependency).         }     }.     return new LinkedBindingImpl<>(this, key, rawType, /* source */     Scopes.<T>scope(key, this, internalFactory, scoping), scoping, targetKey). }
true;private;2;11;/**  * Attempts to create a just-in-time binding for {@code key} in the root injector, falling back to  * other ancestor injectors until this injector is tried.  */ ;/**  * Attempts to create a just-in-time binding for {@code key} in the root injector, falling back to  * other ancestor injectors until this injector is tried.  */ private <T> BindingImpl<T> createJustInTimeBindingRecursive(Key<T> key, Errors errors) throws ErrorsException {     if (state.isBlacklisted(key)) {         throw errors.childBindingAlreadySet(key).toException().     }     BindingImpl<T> binding = createJustInTimeBinding(key, errors).     state.parent().blacklist(key).     jitBindings.put(key, binding).     return binding. }
true;;2;48;/**  * Returns a new just-in-time binding created by resolving {@code key}. The strategies used to  * create just-in-time bindings are:  * <ol>  * <li>Internalizing Providers. If the requested binding is for {@code Provider<T>}, we delegate  * to the binding for {@code T}.  * <li>Converting constants.  * <li>ImplementedBy and ProvidedBy annotations. Only for unannotated keys.  * <li>The constructor of the raw type. Only for unannotated keys.  * </ol>  *  * @throws org.elasticsearch.common.inject.internal.ErrorsException  *          if the binding cannot be created.  */ ;/**  * Returns a new just-in-time binding created by resolving {@code key}. The strategies used to  * create just-in-time bindings are:  * <ol>  * <li>Internalizing Providers. If the requested binding is for {@code Provider<T>}, we delegate  * to the binding for {@code T}.  * <li>Converting constants.  * <li>ImplementedBy and ProvidedBy annotations. Only for unannotated keys.  * <li>The constructor of the raw type. Only for unannotated keys.  * </ol>  *  * @throws org.elasticsearch.common.inject.internal.ErrorsException  *          if the binding cannot be created.  */ <T> BindingImpl<T> createJustInTimeBinding(Key<T> key, Errors errors) throws ErrorsException {     if (state.isBlacklisted(key)) {         throw errors.childBindingAlreadySet(key).toException().     }     // Handle cases where T is a Provider<?>.     if (isProvider(key)) {         // These casts are safe. We know T extends Provider<X> and that given Key<Provider<X>>,         // createProviderBinding() will return BindingImpl<Provider<X>>.         @SuppressWarnings("unchecked")         BindingImpl binding = createProviderBinding((Key) key, errors).         return binding.     }     // Handle cases where T is a MembersInjector<?>     if (isMembersInjector(key)) {         // These casts are safe. T extends MembersInjector<X> and that given Key<MembersInjector<X>>,         // createMembersInjectorBinding() will return BindingImpl<MembersInjector<X>>.         @SuppressWarnings("unchecked")         BindingImpl binding = createMembersInjectorBinding((Key) key, errors).         return binding.     }     // Try to convert a constant string binding to the requested type.     BindingImpl<T> convertedBinding = convertConstantStringBinding(key, errors).     if (convertedBinding != null) {         return convertedBinding.     }     // If the key has an annotation...     if (key.hasAnnotationType()) {         // Look for a binding without annotation attributes or return null.         if (key.hasAttributes()) {             try {                 Errors ignored = new Errors().                 return getBindingOrThrow(key.withoutAttributes(), ignored).             } catch (ErrorsException ignored) {             // throw with a more appropriate message below             }         }         throw errors.missingImplementation(key).toException().     }     Object source = key.getTypeLiteral().getRawType().     BindingImpl<T> binding = createUnitializedBinding(key, Scoping.UNSCOPED, source, errors).     initializeBinding(binding, errors).     return binding. }
false;;2;4;;<T> InternalFactory<? extends T> getInternalFactory(Key<T> key, Errors errors) throws ErrorsException {     return getBindingOrThrow(key, errors).getInternalFactory(). }
false;;2;8;;<T> void put(TypeLiteral<T> type, Binding<T> binding) {     List<Binding<?>> bindingsForType = multimap.get(type).     if (bindingsForType == null) {         bindingsForType = new ArrayList<>().         multimap.put(type, bindingsForType).     }     bindingsForType.add(binding). }
false;;1;8;;@SuppressWarnings("unchecked") <// safe because we only put matching entries into the map T> List<Binding<T>> getAll(TypeLiteral<T> type) {     List<Binding<?>> bindings = multimap.get(type).     return bindings != null ? Collections.<Binding<T>>unmodifiableList((List) multimap.get(type)) : Collections.<Binding<T>>emptyList(). }
true;;2;20;/**  * Returns parameter injectors, or {@code null} if there are no parameters.  */ ;/**  * Returns parameter injectors, or {@code null} if there are no parameters.  */ SingleParameterInjector<?>[] getParametersInjectors(List<Dependency<?>> parameters, Errors errors) throws ErrorsException {     if (parameters.isEmpty()) {         return null.     }     int numErrorsBefore = errors.size().     SingleParameterInjector<?>[] result = new SingleParameterInjector<?>[parameters.size()].     int i = 0.     for (Dependency<?> parameter : parameters) {         try {             result[i++] = createParameterInjector(parameter, errors.withSource(parameter)).         } catch (ErrorsException rethrownBelow) {         // rethrown below         }     }     errors.throwIfNewErrors(numErrorsBefore).     return result. }
false;;2;5;;<T> SingleParameterInjector<T> createParameterInjector(final Dependency<T> dependency, final Errors errors) throws ErrorsException {     InternalFactory<? extends T> factory = getInternalFactory(dependency.getKey(), errors).     return new SingleParameterInjector<>(dependency, factory). }
false;;2;2;;Object invoke(Object target, Object... parameters) throws IllegalAccessException, InvocationTargetException.
false;public;1;6;;@Override // the members injector type is consistent with instance's type @SuppressWarnings("unchecked") public void injectMembers(Object instance) {     MembersInjector membersInjector = getMembersInjector(instance.getClass()).     membersInjector.injectMembers(instance). }
false;public;1;9;;@Override public <T> MembersInjector<T> getMembersInjector(TypeLiteral<T> typeLiteral) {     Errors errors = new Errors(typeLiteral).     try {         return membersInjectorStore.get(typeLiteral, errors).     } catch (ErrorsException e) {         throw new ConfigurationException(errors.merge(e.getErrors()).getMessages()).     } }
false;public;1;4;;@Override public <T> MembersInjector<T> getMembersInjector(Class<T> type) {     return getMembersInjector(TypeLiteral.get(type)). }
false;public;1;4;;@Override public <T> Provider<T> getProvider(Class<T> type) {     return getProvider(Key.get(type)). }
false;public;0;11;;@Override public T get() {     try {         return (T) ((InternalFactory.Instance) factory).get(null, null, null).     } catch (ErrorsException e) {     // ignore     }     // should never happen...     assert false.     return null. }
false;public;1;9;;@Override public T call(InternalContext context) throws ErrorsException {     context.setDependency(dependency).     try {         return factory.get(errors, context, dependency).     } finally {         context.setDependency(null).     } }
false;public;0;21;;@Override public T get() {     final Errors errors = new Errors(dependency).     try {         T t = callInContext(new ContextualCallable<T>() {              @Override             public T call(InternalContext context) throws ErrorsException {                 context.setDependency(dependency).                 try {                     return factory.get(errors, context, dependency).                 } finally {                     context.setDependency(null).                 }             }         }).         errors.throwIfNewErrors(0).         return t.     } catch (ErrorsException e) {         throw new ProvisionException(errors.merge(e.getErrors()).getMessages()).     } }
false;public;0;4;;@Override public String toString() {     return factory.toString(). }
false;;2;49;;<T> Provider<T> getProviderOrThrow(final Key<T> key, Errors errors) throws ErrorsException {     final InternalFactory<? extends T> factory = getInternalFactory(key, errors).     // ES: optimize for a common case of read only instance getting from the parent...     if (factory instanceof InternalFactory.Instance) {         return new Provider<T>() {              @Override             public T get() {                 try {                     return (T) ((InternalFactory.Instance) factory).get(null, null, null).                 } catch (ErrorsException e) {                 // ignore                 }                 // should never happen...                 assert false.                 return null.             }         }.     }     final Dependency<T> dependency = Dependency.get(key).     return new Provider<T>() {          @Override         public T get() {             final Errors errors = new Errors(dependency).             try {                 T t = callInContext(new ContextualCallable<T>() {                      @Override                     public T call(InternalContext context) throws ErrorsException {                         context.setDependency(dependency).                         try {                             return factory.get(errors, context, dependency).                         } finally {                             context.setDependency(null).                         }                     }                 }).                 errors.throwIfNewErrors(0).                 return t.             } catch (ErrorsException e) {                 throw new ProvisionException(errors.merge(e.getErrors()).getMessages()).             }         }          @Override         public String toString() {             return factory.toString().         }     }. }
false;public;1;11;;@Override public <T> Provider<T> getProvider(final Key<T> key) {     Errors errors = new Errors(key).     try {         Provider<T> result = getProviderOrThrow(key, errors).         errors.throwIfNewErrors(0).         return result.     } catch (ErrorsException e) {         throw new ConfigurationException(errors.merge(e.getErrors()).getMessages()).     } }
false;public;1;4;;@Override public <T> T getInstance(Key<T> key) {     return getProvider(key).get(). }
false;public;1;4;;@Override public <T> T getInstance(Class<T> type) {     return getProvider(type).get(). }
true;;1;19;/**  * Looks up thread local context. Creates (and removes) a new context if necessary.  */ ;/**  * Looks up thread local context. Creates (and removes) a new context if necessary.  */ <T> T callInContext(ContextualCallable<T> callable) throws ErrorsException {     Object[] reference = localContext.get().     if (reference == null) {         reference = new Object[1].         localContext.set(reference).     }     if (reference[0] == null) {         reference[0] = new InternalContext().         try {             return callable.call((InternalContext) reference[0]).         } finally {             // Only clear the context if this call created it.             reference[0] = null.         }     } else {         // Someone else will clean up this context.         return callable.call((InternalContext) reference[0]).     } }
false;public;0;6;;@Override public String toString() {     return new ToStringBuilder(Injector.class).add("bindings", state.getExplicitBindingsThisLevel().values()).toString(). }
true;public;0;6;// ES_GUICE: clear caches ;// ES_GUICE: clear caches public void clearCache() {     state.clearBlacklisted().     constructors = new ConstructorInjectorStore(this).     membersInjectorStore = new MembersInjectorStore(this, state.getTypeListenerBindings()).     jitBindings = new HashMap<>(). }
true;public;0;7;// ES_GUICE: make all registered bindings act as eager singletons ;// ES_GUICE: make all registered bindings act as eager singletons public void readOnlyAllSingletons() {     readOnly = true.     state.makeAllBindingsToEagerSingletons(this).     bindingsMultimap = new BindingsMultimap().     // reindex the bindings     index(). }
