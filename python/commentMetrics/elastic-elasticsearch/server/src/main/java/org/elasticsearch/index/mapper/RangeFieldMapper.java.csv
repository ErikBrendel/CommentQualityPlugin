commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public RangeFieldType fieldType() {     return (RangeFieldType) fieldType. }
false;public;1;7;;@Override public Builder docValues(boolean docValues) {     if (docValues == true) {         throw new IllegalArgumentException("field [" + name + "] does not currently support " + TypeParsers.DOC_VALUES).     }     return super.docValues(docValues). }
false;public;1;4;;public Builder coerce(boolean coerce) {     this.coerce = coerce.     return builder. }
false;protected;1;9;;protected Explicit<Boolean> coerce(BuilderContext context) {     if (coerce != null) {         return new Explicit<>(coerce, true).     }     if (context.indexSettings() != null) {         return new Explicit<>(COERCE_SETTING.get(context.indexSettings()), false).     }     return Defaults.COERCE. }
false;public;1;4;;public Builder format(String format) {     this.pattern = format.     return this. }
false;public;1;4;;@Override public Builder nullValue(Object nullValue) {     throw new IllegalArgumentException("Field [" + name() + "] does not support null value."). }
false;public;1;3;;public void locale(Locale locale) {     this.locale = locale. }
false;protected;1;16;;@Override protected void setupFieldType(BuilderContext context) {     super.setupFieldType(context).     DateFormatter formatter = fieldType().dateTimeFormatter.     if (fieldType().rangeType == RangeType.DATE) {         boolean hasPatternChanged = Strings.hasLength(builder.pattern) && Objects.equals(builder.pattern, formatter.pattern()) == false.         if (hasPatternChanged || Objects.equals(builder.locale, formatter.locale()) == false) {             fieldType().setDateTimeFormatter(DateFormatter.forPattern(pattern).withLocale(locale)).         }     } else if (pattern != null) {         throw new IllegalArgumentException("field [" + name() + "] of type [" + fieldType().rangeType + "] should not define a dateTimeFormatter unless it is a " + RangeType.DATE + " type").     } }
false;public;1;6;;@Override public RangeFieldMapper build(BuilderContext context) {     setupFieldType(context).     return new RangeFieldMapper(name, fieldType, defaultFieldType, coerce(context), context.indexSettings(), multiFieldsBuilder.build(this, context), copyTo). }
false;public;3;27;;@Override public Mapper.Builder<?, ?> parse(String name, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {     Builder builder = new Builder(name, type).     TypeParsers.parseField(builder, name, node, parserContext).     for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(). iterator.hasNext(). ) {         Map.Entry<String, Object> entry = iterator.next().         String propName = entry.getKey().         Object propNode = entry.getValue().         if (propName.equals("null_value")) {             throw new MapperParsingException("Property [null_value] is not supported for [" + this.type.name + "] field types.").         } else if (propName.equals("coerce")) {             builder.coerce(XContentMapValues.nodeBooleanValue(propNode, name + ".coerce")).             iterator.remove().         } else if (propName.equals("locale")) {             builder.locale(LocaleUtils.parse(propNode.toString())).             iterator.remove().         } else if (propName.equals("format")) {             builder.format(propNode.toString()).             iterator.remove().         } else if (TypeParsers.parseMultiField(builder, name, parserContext, propName, propNode)) {             iterator.remove().         }     }     return builder. }
false;public;0;4;;@Override public MappedFieldType clone() {     return new RangeFieldType(this). }
false;public;1;9;;@Override public boolean equals(Object o) {     if (!super.equals(o))         return false.     RangeFieldType that = (RangeFieldType) o.     return Objects.equals(rangeType, that.rangeType) && (rangeType == RangeType.DATE) ? Objects.equals(dateTimeFormatter, that.dateTimeFormatter) : dateTimeFormatter == null && that.dateTimeFormatter == null. }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(super.hashCode(), rangeType, dateTimeFormatter). }
false;public;0;4;;@Override public String typeName() {     return rangeType.name. }
false;public;0;3;;public DateFormatter dateTimeFormatter() {     return dateTimeFormatter. }
false;public;1;5;;public void setDateTimeFormatter(DateFormatter dateTimeFormatter) {     checkIfFrozen().     this.dateTimeFormatter = dateTimeFormatter.     this.dateMathParser = dateTimeFormatter.toDateMathParser(). }
false;protected;0;3;;protected DateMathParser dateMathParser() {     return dateMathParser. }
false;public;1;8;;@Override public Query existsQuery(QueryShardContext context) {     if (hasDocValues()) {         return new DocValuesFieldExistsQuery(name()).     } else {         return new TermQuery(new Term(FieldNamesFieldMapper.NAME, name())).     } }
false;public;2;8;;@Override public Query termQuery(Object value, QueryShardContext context) {     Query query = rangeQuery(value, value, true, true, ShapeRelation.INTERSECTS, null, null, context).     if (boost() != 1f) {         query = new BoostQuery(query, boost()).     }     return query. }
false;public;8;10;;@Override public Query rangeQuery(Object lowerTerm, Object upperTerm, boolean includeLower, boolean includeUpper, ShapeRelation relation, ZoneId timeZone, DateMathParser parser, QueryShardContext context) {     failIfNotIndexed().     if (parser == null) {         parser = dateMathParser().     }     return rangeType.rangeQuery(name(), hasDocValues(), lowerTerm, upperTerm, includeLower, includeUpper, relation, timeZone, parser, context). }
false;public;0;4;;@Override public RangeFieldType fieldType() {     return (RangeFieldType) super.fieldType(). }
false;protected;0;4;;@Override protected String contentType() {     return fieldType.typeName(). }
false;protected;0;4;;@Override protected RangeFieldMapper clone() {     return (RangeFieldMapper) super.clone(). }
false;protected;2;65;;@Override protected void parseCreateField(ParseContext context, List<IndexableField> fields) throws IOException {     Range range.     if (context.externalValueSet()) {         range = context.parseExternalValue(Range.class).     } else {         XContentParser parser = context.parser().         final XContentParser.Token start = parser.currentToken().         if (start == XContentParser.Token.VALUE_NULL) {             return.         } else if (start == XContentParser.Token.START_OBJECT) {             RangeFieldType fieldType = fieldType().             RangeType rangeType = fieldType.rangeType.             String fieldName = null.             Object from = rangeType.minValue().             Object to = rangeType.maxValue().             boolean includeFrom = DEFAULT_INCLUDE_LOWER.             boolean includeTo = DEFAULT_INCLUDE_UPPER.             XContentParser.Token token.             while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {                 if (token == XContentParser.Token.FIELD_NAME) {                     fieldName = parser.currentName().                 } else {                     if (fieldName.equals(GT_FIELD.getPreferredName())) {                         includeFrom = false.                         if (parser.currentToken() != XContentParser.Token.VALUE_NULL) {                             from = rangeType.parseFrom(fieldType, parser, coerce.value(), includeFrom).                         }                     } else if (fieldName.equals(GTE_FIELD.getPreferredName())) {                         includeFrom = true.                         if (parser.currentToken() != XContentParser.Token.VALUE_NULL) {                             from = rangeType.parseFrom(fieldType, parser, coerce.value(), includeFrom).                         }                     } else if (fieldName.equals(LT_FIELD.getPreferredName())) {                         includeTo = false.                         if (parser.currentToken() != XContentParser.Token.VALUE_NULL) {                             to = rangeType.parseTo(fieldType, parser, coerce.value(), includeTo).                         }                     } else if (fieldName.equals(LTE_FIELD.getPreferredName())) {                         includeTo = true.                         if (parser.currentToken() != XContentParser.Token.VALUE_NULL) {                             to = rangeType.parseTo(fieldType, parser, coerce.value(), includeTo).                         }                     } else {                         throw new MapperParsingException("error parsing field [" + name() + "], with unknown parameter [" + fieldName + "]").                     }                 }             }             range = new Range(rangeType, from, to, includeFrom, includeTo).         } else if (fieldType().rangeType == RangeType.IP && start == XContentParser.Token.VALUE_STRING) {             range = parseIpRangeFromCidr(parser).         } else {             throw new MapperParsingException("error parsing field [" + name() + "], expected an object but got " + parser.currentName()).         }     }     boolean indexed = fieldType.indexOptions() != IndexOptions.NONE.     boolean docValued = fieldType.hasDocValues().     boolean stored = fieldType.stored().     fields.addAll(fieldType().rangeType.createFields(context, name(), range, indexed, docValued, stored)).     if (docValued == false && (indexed || stored)) {         createFieldNamesField(context, fields).     } }
false;protected;1;8;;@Override protected void doMerge(Mapper mergeWith) {     super.doMerge(mergeWith).     RangeFieldMapper other = (RangeFieldMapper) mergeWith.     if (other.coerce.explicit()) {         this.coerce = other.coerce.     } }
false;protected;3;18;;@Override protected void doXContentBody(XContentBuilder builder, boolean includeDefaults, Params params) throws IOException {     super.doXContentBody(builder, includeDefaults, params).     if (fieldType().rangeType == RangeType.DATE && (includeDefaults || (fieldType().dateTimeFormatter() != null && fieldType().dateTimeFormatter().pattern().equals(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.pattern()) == false))) {         builder.field("format", fieldType().dateTimeFormatter().pattern()).     }     if (fieldType().rangeType == RangeType.DATE && (includeDefaults || (fieldType().dateTimeFormatter() != null && fieldType().dateTimeFormatter().locale() != Locale.ROOT))) {         builder.field("locale", fieldType().dateTimeFormatter().locale()).     }     if (includeDefaults || coerce.explicit()) {         builder.field("coerce", coerce.value()).     } }
false;private,static;1;16;;private static Range parseIpRangeFromCidr(final XContentParser parser) throws IOException {     final Tuple<InetAddress, Integer> cidr = InetAddresses.parseCidr(parser.text()).     // create the lower value by zeroing out the host portion, upper value by filling it with all ones.     byte[] lower = cidr.v1().getAddress().     byte[] upper = lower.clone().     for (int i = cidr.v2(). i < 8 * lower.length. i++) {         int m = 1 << 7 - (i & 7).         lower[i >> 3] &= ~m.         upper[i >> 3] |= m.     }     try {         return new Range(RangeType.IP, InetAddress.getByAddress(lower), InetAddress.getByAddress(upper), true, true).     } catch (UnknownHostException bogus) {         throw new AssertionError(bogus).     } }
false;public;2;4;;@Override public Field getRangeField(String name, Range r) {     return new InetAddressRange(name, (InetAddress) r.from, (InetAddress) r.to). }
false;public;4;6;;@Override public InetAddress parseFrom(RangeFieldType fieldType, XContentParser parser, boolean coerce, boolean included) throws IOException {     InetAddress address = InetAddresses.forString(parser.text()).     return included ? address : nextUp(address). }
false;public;4;6;;@Override public InetAddress parseTo(RangeFieldType fieldType, XContentParser parser, boolean coerce, boolean included) throws IOException {     InetAddress address = InetAddresses.forString(parser.text()).     return included ? address : nextDown(address). }
false;public;2;11;;@Override public InetAddress parse(Object value, boolean coerce) {     if (value instanceof InetAddress) {         return (InetAddress) value.     } else {         if (value instanceof BytesRef) {             value = ((BytesRef) value).utf8ToString().         }         return InetAddresses.forString(value.toString()).     } }
false;public;0;4;;@Override public InetAddress minValue() {     return InetAddressPoint.MIN_VALUE. }
false;public;0;4;;@Override public InetAddress maxValue() {     return InetAddressPoint.MAX_VALUE. }
false;public;1;4;;@Override public InetAddress nextUp(Object value) {     return InetAddressPoint.nextUp((InetAddress) value). }
false;public;1;4;;@Override public InetAddress nextDown(Object value) {     return InetAddressPoint.nextDown((InetAddress) value). }
false;public;1;16;;@Override public BytesRef encodeRanges(Set<Range> ranges) throws IOException {     final byte[] encoded = new byte[5 + (16 * 2) * ranges.size()].     ByteArrayDataOutput out = new ByteArrayDataOutput(encoded).     out.writeVInt(ranges.size()).     for (Range range : ranges) {         InetAddress fromValue = (InetAddress) range.from.         byte[] encodedFromValue = InetAddressPoint.encode(fromValue).         out.writeBytes(encodedFromValue, 0, encodedFromValue.length).         InetAddress toValue = (InetAddress) range.to.         byte[] encodedToValue = InetAddressPoint.encode(toValue).         out.writeBytes(encodedToValue, 0, encodedToValue.length).     }     return new BytesRef(encoded, 0, out.getPosition()). }
false;public;6;15;;@Override public Query dvRangeQuery(String field, QueryType queryType, Object from, Object to, boolean includeFrom, boolean includeTo) {     if (includeFrom == false) {         from = nextUp(from).     }     if (includeTo == false) {         to = nextDown(to).     }     byte[] encodedFrom = InetAddressPoint.encode((InetAddress) from).     byte[] encodedTo = InetAddressPoint.encode((InetAddress) to).     return new BinaryDocValuesRangeQuery(field, queryType, BinaryDocValuesRangeQuery.LengthType.FIXED_16, new BytesRef(encodedFrom), new BytesRef(encodedTo), from, to). }
false;public;5;7;;@Override public Query withinQuery(String field, Object from, Object to, boolean includeLower, boolean includeUpper) {     InetAddress lower = (InetAddress) from.     InetAddress upper = (InetAddress) to.     return InetAddressRange.newWithinQuery(field, includeLower ? lower : nextUp(lower), includeUpper ? upper : nextDown(upper)). }
false;public;5;7;;@Override public Query containsQuery(String field, Object from, Object to, boolean includeLower, boolean includeUpper) {     InetAddress lower = (InetAddress) from.     InetAddress upper = (InetAddress) to.     return InetAddressRange.newContainsQuery(field, includeLower ? lower : nextUp(lower), includeUpper ? upper : nextDown(upper)). }
false;public;5;7;;@Override public Query intersectsQuery(String field, Object from, Object to, boolean includeLower, boolean includeUpper) {     InetAddress lower = (InetAddress) from.     InetAddress upper = (InetAddress) to.     return InetAddressRange.newIntersectsQuery(field, includeLower ? lower : nextUp(lower), includeUpper ? upper : nextDown(upper)). }
false;public;2;4;;@Override public Field getRangeField(String name, Range r) {     return new LongRange(name, new long[] { ((Number) r.from).longValue() }, new long[] { ((Number) r.to).longValue() }). }
false;private;2;4;;private Number parse(DateMathParser dateMathParser, String dateStr) {     return dateMathParser.parse(dateStr, () -> {         throw new IllegalArgumentException("now is not used at indexing time").     }).toEpochMilli(). }
false;public;4;6;;@Override public Number parseFrom(RangeFieldType fieldType, XContentParser parser, boolean coerce, boolean included) throws IOException {     Number value = parse(fieldType.dateMathParser, parser.text()).     return included ? value : nextUp(value). }
false;public;4;6;;@Override public Number parseTo(RangeFieldType fieldType, XContentParser parser, boolean coerce, boolean included) throws IOException {     Number value = parse(fieldType.dateMathParser, parser.text()).     return included ? value : nextDown(value). }
false;public;0;4;;@Override public Long minValue() {     return Long.MIN_VALUE. }
false;public;0;4;;@Override public Long maxValue() {     return Long.MAX_VALUE. }
false;public;1;4;;@Override public Long nextUp(Object value) {     return (long) LONG.nextUp(value). }
false;public;1;4;;@Override public Long nextDown(Object value) {     return (long) LONG.nextDown(value). }
false;public;1;4;;@Override public BytesRef encodeRanges(Set<Range> ranges) throws IOException {     return LONG.encodeRanges(ranges). }
false;public;6;4;;@Override public Query dvRangeQuery(String field, QueryType queryType, Object from, Object to, boolean includeFrom, boolean includeTo) {     return LONG.dvRangeQuery(field, queryType, from, to, includeFrom, includeTo). }
false;public;10;18;;@Override public Query rangeQuery(String field, boolean hasDocValues, Object lowerTerm, Object upperTerm, boolean includeLower, boolean includeUpper, ShapeRelation relation, @Nullable ZoneId timeZone, @Nullable DateMathParser parser, QueryShardContext context) {     ZoneId zone = (timeZone == null) ? ZoneOffset.UTC : timeZone.     DateMathParser dateMathParser = (parser == null) ? DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.toDateMathParser() : parser.     Long low = lowerTerm == null ? Long.MIN_VALUE : dateMathParser.parse(lowerTerm instanceof BytesRef ? ((BytesRef) lowerTerm).utf8ToString() : lowerTerm.toString(), context::nowInMillis, false, zone).toEpochMilli().     Long high = upperTerm == null ? Long.MAX_VALUE : dateMathParser.parse(upperTerm instanceof BytesRef ? ((BytesRef) upperTerm).utf8ToString() : upperTerm.toString(), context::nowInMillis, false, zone).toEpochMilli().     return super.rangeQuery(field, hasDocValues, low, high, includeLower, includeUpper, relation, zone, dateMathParser, context). }
false;public;5;4;;@Override public Query withinQuery(String field, Object from, Object to, boolean includeLower, boolean includeUpper) {     return LONG.withinQuery(field, from, to, includeLower, includeUpper). }
false;public;5;4;;@Override public Query containsQuery(String field, Object from, Object to, boolean includeLower, boolean includeUpper) {     return LONG.containsQuery(field, from, to, includeLower, includeUpper). }
false;public;5;4;;@Override public Query intersectsQuery(String field, Object from, Object to, boolean includeLower, boolean includeUpper) {     return LONG.intersectsQuery(field, from, to, includeLower, includeUpper). }
false;public;0;4;;@Override public Float minValue() {     return Float.NEGATIVE_INFINITY. }
false;public;0;4;;@Override public Float maxValue() {     return Float.POSITIVE_INFINITY. }
false;public;1;4;;@Override public Float nextUp(Object value) {     return Math.nextUp(((Number) value).floatValue()). }
false;public;1;4;;@Override public Float nextDown(Object value) {     return Math.nextDown(((Number) value).floatValue()). }
false;public;1;4;;@Override public BytesRef encodeRanges(Set<Range> ranges) throws IOException {     return BinaryRangeUtil.encodeFloatRanges(ranges). }
false;public;6;15;;@Override public Query dvRangeQuery(String field, QueryType queryType, Object from, Object to, boolean includeFrom, boolean includeTo) {     if (includeFrom == false) {         from = nextUp(from).     }     if (includeTo == false) {         to = nextDown(to).     }     byte[] encodedFrom = BinaryRangeUtil.encodeFloat((Float) from).     byte[] encodedTo = BinaryRangeUtil.encodeFloat((Float) to).     return new BinaryDocValuesRangeQuery(field, queryType, BinaryDocValuesRangeQuery.LengthType.FIXED_4, new BytesRef(encodedFrom), new BytesRef(encodedTo), from, to). }
false;public;2;4;;@Override public Field getRangeField(String name, Range r) {     return new FloatRange(name, new float[] { ((Number) r.from).floatValue() }, new float[] { ((Number) r.to).floatValue() }). }
false;public;5;6;;@Override public Query withinQuery(String field, Object from, Object to, boolean includeFrom, boolean includeTo) {     return FloatRange.newWithinQuery(field, new float[] { includeFrom ? (Float) from : Math.nextUp((Float) from) }, new float[] { includeTo ? (Float) to : Math.nextDown((Float) to) }). }
false;public;5;6;;@Override public Query containsQuery(String field, Object from, Object to, boolean includeFrom, boolean includeTo) {     return FloatRange.newContainsQuery(field, new float[] { includeFrom ? (Float) from : Math.nextUp((Float) from) }, new float[] { includeTo ? (Float) to : Math.nextDown((Float) to) }). }
false;public;5;6;;@Override public Query intersectsQuery(String field, Object from, Object to, boolean includeFrom, boolean includeTo) {     return FloatRange.newIntersectsQuery(field, new float[] { includeFrom ? (Float) from : Math.nextUp((Float) from) }, new float[] { includeTo ? (Float) to : Math.nextDown((Float) to) }). }
false;public;0;4;;@Override public Double minValue() {     return Double.NEGATIVE_INFINITY. }
false;public;0;4;;@Override public Double maxValue() {     return Double.POSITIVE_INFINITY. }
false;public;1;4;;@Override public Double nextUp(Object value) {     return Math.nextUp(((Number) value).doubleValue()). }
false;public;1;4;;@Override public Double nextDown(Object value) {     return Math.nextDown(((Number) value).doubleValue()). }
false;public;1;4;;@Override public BytesRef encodeRanges(Set<Range> ranges) throws IOException {     return BinaryRangeUtil.encodeDoubleRanges(ranges). }
false;public;6;15;;@Override public Query dvRangeQuery(String field, QueryType queryType, Object from, Object to, boolean includeFrom, boolean includeTo) {     if (includeFrom == false) {         from = nextUp(from).     }     if (includeTo == false) {         to = nextDown(to).     }     byte[] encodedFrom = BinaryRangeUtil.encodeDouble((Double) from).     byte[] encodedTo = BinaryRangeUtil.encodeDouble((Double) to).     return new BinaryDocValuesRangeQuery(field, queryType, BinaryDocValuesRangeQuery.LengthType.FIXED_8, new BytesRef(encodedFrom), new BytesRef(encodedTo), from, to). }
false;public;2;4;;@Override public Field getRangeField(String name, Range r) {     return new DoubleRange(name, new double[] { ((Number) r.from).doubleValue() }, new double[] { ((Number) r.to).doubleValue() }). }
false;public;5;6;;@Override public Query withinQuery(String field, Object from, Object to, boolean includeFrom, boolean includeTo) {     return DoubleRange.newWithinQuery(field, new double[] { includeFrom ? (Double) from : Math.nextUp((Double) from) }, new double[] { includeTo ? (Double) to : Math.nextDown((Double) to) }). }
false;public;5;6;;@Override public Query containsQuery(String field, Object from, Object to, boolean includeFrom, boolean includeTo) {     return DoubleRange.newContainsQuery(field, new double[] { includeFrom ? (Double) from : Math.nextUp((Double) from) }, new double[] { includeTo ? (Double) to : Math.nextDown((Double) to) }). }
false;public;5;6;;@Override public Query intersectsQuery(String field, Object from, Object to, boolean includeFrom, boolean includeTo) {     return DoubleRange.newIntersectsQuery(field, new double[] { includeFrom ? (Double) from : Math.nextUp((Double) from) }, new double[] { includeTo ? (Double) to : Math.nextDown((Double) to) }). }
false;public;0;4;;@Override public Integer minValue() {     return Integer.MIN_VALUE. }
false;public;0;4;;@Override public Integer maxValue() {     return Integer.MAX_VALUE. }
false;public;1;4;;@Override public Integer nextUp(Object value) {     return ((Number) value).intValue() + 1. }
false;public;1;4;;@Override public Integer nextDown(Object value) {     return ((Number) value).intValue() - 1. }
false;public;1;4;;@Override public BytesRef encodeRanges(Set<Range> ranges) throws IOException {     return LONG.encodeRanges(ranges). }
false;public;6;4;;@Override public Query dvRangeQuery(String field, QueryType queryType, Object from, Object to, boolean includeFrom, boolean includeTo) {     return LONG.dvRangeQuery(field, queryType, from, to, includeFrom, includeTo). }
false;public;2;4;;@Override public Field getRangeField(String name, Range r) {     return new IntRange(name, new int[] { ((Number) r.from).intValue() }, new int[] { ((Number) r.to).intValue() }). }
false;public;5;5;;@Override public Query withinQuery(String field, Object from, Object to, boolean includeFrom, boolean includeTo) {     return IntRange.newWithinQuery(field, new int[] { (Integer) from + (includeFrom ? 0 : 1) }, new int[] { (Integer) to - (includeTo ? 0 : 1) }). }
false;public;5;5;;@Override public Query containsQuery(String field, Object from, Object to, boolean includeFrom, boolean includeTo) {     return IntRange.newContainsQuery(field, new int[] { (Integer) from + (includeFrom ? 0 : 1) }, new int[] { (Integer) to - (includeTo ? 0 : 1) }). }
false;public;5;5;;@Override public Query intersectsQuery(String field, Object from, Object to, boolean includeFrom, boolean includeTo) {     return IntRange.newIntersectsQuery(field, new int[] { (Integer) from + (includeFrom ? 0 : 1) }, new int[] { (Integer) to - (includeTo ? 0 : 1) }). }
false;public;0;4;;@Override public Long minValue() {     return Long.MIN_VALUE. }
false;public;0;4;;@Override public Long maxValue() {     return Long.MAX_VALUE. }
false;public;1;4;;@Override public Long nextUp(Object value) {     return ((Number) value).longValue() + 1. }
false;public;1;4;;@Override public Long nextDown(Object value) {     return ((Number) value).longValue() - 1. }
false;public;1;4;;@Override public BytesRef encodeRanges(Set<Range> ranges) throws IOException {     return BinaryRangeUtil.encodeLongRanges(ranges). }
false;public;6;15;;@Override public Query dvRangeQuery(String field, QueryType queryType, Object from, Object to, boolean includeFrom, boolean includeTo) {     if (includeFrom == false) {         from = nextUp(from).     }     if (includeTo == false) {         to = nextDown(to).     }     byte[] encodedFrom = BinaryRangeUtil.encodeLong(((Number) from).longValue()).     byte[] encodedTo = BinaryRangeUtil.encodeLong(((Number) to).longValue()).     return new BinaryDocValuesRangeQuery(field, queryType, BinaryDocValuesRangeQuery.LengthType.VARIABLE, new BytesRef(encodedFrom), new BytesRef(encodedTo), from, to). }
false;public;2;5;;@Override public Field getRangeField(String name, Range r) {     return new LongRange(name, new long[] { ((Number) r.from).longValue() }, new long[] { ((Number) r.to).longValue() }). }
false;public;5;5;;@Override public Query withinQuery(String field, Object from, Object to, boolean includeFrom, boolean includeTo) {     return LongRange.newWithinQuery(field, new long[] { (Long) from + (includeFrom ? 0 : 1) }, new long[] { (Long) to - (includeTo ? 0 : 1) }). }
false;public;5;5;;@Override public Query containsQuery(String field, Object from, Object to, boolean includeFrom, boolean includeTo) {     return LongRange.newContainsQuery(field, new long[] { (Long) from + (includeFrom ? 0 : 1) }, new long[] { (Long) to - (includeTo ? 0 : 1) }). }
false;public;5;5;;@Override public Query intersectsQuery(String field, Object from, Object to, boolean includeFrom, boolean includeTo) {     return LongRange.newIntersectsQuery(field, new long[] { (Long) from + (includeFrom ? 0 : 1) }, new long[] { (Long) to - (includeTo ? 0 : 1) }). }
true;public,final;0;3;/**  * Get the associated type name.  */ ;/**  * Get the associated type name.  */ public final String typeName() {     return name. }
false;public,abstract;2;1;;public abstract Field getRangeField(String name, Range range).
false;public;6;21;;public List<IndexableField> createFields(ParseContext context, String name, Range range, boolean indexed, boolean docValued, boolean stored) {     assert range != null : "range cannot be null when creating fields".     List<IndexableField> fields = new ArrayList<>().     if (indexed) {         fields.add(getRangeField(name, range)).     }     if (docValued) {         BinaryRangesDocValuesField field = (BinaryRangesDocValuesField) context.doc().getByKey(name).         if (field == null) {             field = new BinaryRangesDocValuesField(name, range, this).             context.doc().addWithKey(name, field).         } else {             field.add(range).         }     }     if (stored) {         fields.add(new StoredField(name, range.toString())).     }     return fields. }
true;public;4;4;/**  * parses from value. rounds according to included flag  */ ;/**  * parses from value. rounds according to included flag  */ public Object parseFrom(RangeFieldType fieldType, XContentParser parser, boolean coerce, boolean included) throws IOException {     Number value = numberType.parse(parser, coerce).     return included ? value : (Number) nextUp(value). }
true;public;4;4;/**  * parses to value. rounds according to included flag  */ ;/**  * parses to value. rounds according to included flag  */ public Object parseTo(RangeFieldType fieldType, XContentParser parser, boolean coerce, boolean included) throws IOException {     Number value = numberType.parse(parser, coerce).     return included ? value : (Number) nextDown(value). }
false;public,abstract;0;1;;public abstract Object minValue().
false;public,abstract;0;1;;public abstract Object maxValue().
false;public,abstract;1;1;;public abstract Object nextUp(Object value).
false;public,abstract;1;1;;public abstract Object nextDown(Object value).
false;public,abstract;5;1;;public abstract Query withinQuery(String field, Object from, Object to, boolean includeFrom, boolean includeTo).
false;public,abstract;5;1;;public abstract Query containsQuery(String field, Object from, Object to, boolean includeFrom, boolean includeTo).
false;public,abstract;5;1;;public abstract Query intersectsQuery(String field, Object from, Object to, boolean includeFrom, boolean includeTo).
false;public;2;3;;public Object parse(Object value, boolean coerce) {     return numberType.parse(value, coerce). }
false;public;10;28;;public Query rangeQuery(String field, boolean hasDocValues, Object from, Object to, boolean includeFrom, boolean includeTo, ShapeRelation relation, @Nullable ZoneId timeZone, @Nullable DateMathParser dateMathParser, QueryShardContext context) {     Object lower = from == null ? minValue() : parse(from, false).     Object upper = to == null ? maxValue() : parse(to, false).     Query indexQuery.     if (relation == ShapeRelation.WITHIN) {         indexQuery = withinQuery(field, lower, upper, includeFrom, includeTo).     } else if (relation == ShapeRelation.CONTAINS) {         indexQuery = containsQuery(field, lower, upper, includeFrom, includeTo).     } else {         indexQuery = intersectsQuery(field, lower, upper, includeFrom, includeTo).     }     if (hasDocValues) {         final QueryType queryType.         if (relation == ShapeRelation.WITHIN) {             queryType = QueryType.WITHIN.         } else if (relation == ShapeRelation.CONTAINS) {             queryType = QueryType.CONTAINS.         } else {             queryType = QueryType.INTERSECTS.         }         Query dvQuery = dvRangeQuery(field, queryType, lower, upper, includeFrom, includeTo).         return new IndexOrDocValuesQuery(indexQuery, dvQuery).     } else {         return indexQuery.     } }
true;public,abstract;1;1;// rounded up via parseFrom and parseTo methods. ;// No need to take into account Range#includeFrom or Range#includeTo, because from and to have already been // rounded up via parseFrom and parseTo methods. public abstract BytesRef encodeRanges(Set<Range> ranges) throws IOException.
false;public,abstract;6;2;;public abstract Query dvRangeQuery(String field, QueryType queryType, Object from, Object to, boolean includeFrom, boolean includeTo).
false;public;0;12;;@Override public String toString() {     StringBuilder sb = new StringBuilder().     sb.append(includeFrom ? '[' : '(').     Object f = includeFrom || from.equals(type.minValue()) ? from : type.nextDown(from).     Object t = includeTo || to.equals(type.maxValue()) ? to : type.nextUp(to).     sb.append(type == RangeType.IP ? InetAddresses.toAddrString((InetAddress) f) : f.toString()).     sb.append(" : ").     sb.append(type == RangeType.IP ? InetAddresses.toAddrString((InetAddress) t) : t.toString()).     sb.append(includeTo ? ']' : ')').     return sb.toString(). }
false;;1;3;;void add(Range range) {     ranges.add(range). }
false;public;0;8;;@Override public BytesRef binaryValue() {     try {         return rangeType.encodeRanges(ranges).     } catch (IOException e) {         throw new ElasticsearchException("failed to encode ranges", e).     } }
