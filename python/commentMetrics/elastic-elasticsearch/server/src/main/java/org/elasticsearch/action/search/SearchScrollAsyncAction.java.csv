commented;modifiers;parameterAmount;loc;comment;code
true;private;0;5;/**  * Builds how long it took to execute the search.  */ ;/**  * Builds how long it took to execute the search.  */ private long buildTookInMillis() {     // negative values don't make sense and we want to be able to serialize that thing as a vLong     return Math.max(1, System.currentTimeMillis() - startTime). }
false;public,final;0;9;;public final void run() {     final ScrollIdForNode[] context = scrollId.getContext().     if (context.length == 0) {         listener.onFailure(new SearchPhaseExecutionException("query", "no nodes to search on", ShardSearchFailure.EMPTY_ARRAY)).     } else {         collectNodesAndRun(Arrays.asList(context), nodes, searchTransportService, ActionListener.wrap(lookup -> run(lookup, context), listener::onFailure)).     } }
true;static;4;25;/**  * This method collects nodes from the remote clusters asynchronously if any of the scroll IDs references a remote cluster.  * Otherwise the action listener will be invoked immediately with a function based on the given discovery nodes.  */ ;/**  * This method collects nodes from the remote clusters asynchronously if any of the scroll IDs references a remote cluster.  * Otherwise the action listener will be invoked immediately with a function based on the given discovery nodes.  */ static void collectNodesAndRun(final Iterable<ScrollIdForNode> scrollIds, DiscoveryNodes nodes, SearchTransportService searchTransportService, ActionListener<BiFunction<String, String, DiscoveryNode>> listener) {     Set<String> clusters = new HashSet<>().     for (ScrollIdForNode target : scrollIds) {         if (target.getClusterAlias() != null) {             clusters.add(target.getClusterAlias()).         }     }     if (clusters.isEmpty()) {         // no remote clusters         listener.onResponse((cluster, node) -> nodes.get(node)).     } else {         RemoteClusterService remoteClusterService = searchTransportService.getRemoteClusterService().         remoteClusterService.collectNodes(clusters, ActionListener.wrap(nodeFunction -> {             final BiFunction<String, String, DiscoveryNode> clusterNodeLookup = (clusterAlias, node) -> {                 if (clusterAlias == null) {                     return nodes.get(node).                 } else {                     return nodeFunction.apply(clusterAlias, node).                 }             }.             listener.onResponse(clusterNodeLookup).         }, listener::onFailure)).     } }
false;protected;1;12;;@Override protected void setSearchShardTarget(T response) {     // don't do this - it's part of the response...     assert response.getSearchShardTarget() != null : "search shard target must not be null".     if (target.getClusterAlias() != null) {         // re-create the search target and add the cluster alias if there is any,         // we need this down the road for subseq. phases         SearchShardTarget searchShardTarget = response.getSearchShardTarget().         response.setSearchShardTarget(new SearchShardTarget(searchShardTarget.getNodeId(), searchShardTarget.getShardId(), target.getClusterAlias(), null)).     } }
false;protected;1;18;;@Override protected void innerOnResponse(T result) {     assert shardIndex == result.getShardIndex() : "shard index mismatch: " + shardIndex + " but got: " + result.getShardIndex().     onFirstPhaseResult(shardIndex, result).     if (counter.countDown()) {         SearchPhase phase = moveToNextPhase(clusterNodeLookup).         try {             phase.run().         } catch (Exception e) {             // we need to fail the entire request here - the entire phase just blew up             // don't call onShardFailure or onFailure here since otherwise we'd countDown the counter             // again which would result in an exception             listener.onFailure(new SearchPhaseExecutionException(phase.getName(), "Phase failed", e, ShardSearchFailure.EMPTY_ARRAY)).         }     } }
false;public;1;5;;@Override public void onFailure(Exception t) {     onShardFailure("query", counter, target.getScrollId(), t, null, () -> SearchScrollAsyncAction.this.moveToNextPhase(clusterNodeLookup)). }
false;private;2;64;;private void run(BiFunction<String, String, DiscoveryNode> clusterNodeLookup, final ScrollIdForNode[] context) {     final CountDown counter = new CountDown(scrollId.getContext().length).     for (int i = 0. i < context.length. i++) {         ScrollIdForNode target = context[i].         final int shardIndex = i.         final Transport.Connection connection.         try {             DiscoveryNode node = clusterNodeLookup.apply(target.getClusterAlias(), target.getNode()).             if (node == null) {                 throw new IllegalStateException("node [" + target.getNode() + "] is not available").             }             connection = getConnection(target.getClusterAlias(), node).         } catch (Exception ex) {             onShardFailure("query", counter, target.getScrollId(), ex, null, () -> SearchScrollAsyncAction.this.moveToNextPhase(clusterNodeLookup)).             continue.         }         final InternalScrollSearchRequest internalRequest = internalScrollSearchRequest(target.getScrollId(), request).         // we can't create a SearchShardTarget here since we don't know the index and shard ID we are talking to         // we only know the node and the search context ID. Yet, the response will contain the SearchShardTarget         // from the target node instead...that's why we pass null here         SearchActionListener<T> searchActionListener = new SearchActionListener<T>(null, shardIndex) {              @Override             protected void setSearchShardTarget(T response) {                 // don't do this - it's part of the response...                 assert response.getSearchShardTarget() != null : "search shard target must not be null".                 if (target.getClusterAlias() != null) {                     // re-create the search target and add the cluster alias if there is any,                     // we need this down the road for subseq. phases                     SearchShardTarget searchShardTarget = response.getSearchShardTarget().                     response.setSearchShardTarget(new SearchShardTarget(searchShardTarget.getNodeId(), searchShardTarget.getShardId(), target.getClusterAlias(), null)).                 }             }              @Override             protected void innerOnResponse(T result) {                 assert shardIndex == result.getShardIndex() : "shard index mismatch: " + shardIndex + " but got: " + result.getShardIndex().                 onFirstPhaseResult(shardIndex, result).                 if (counter.countDown()) {                     SearchPhase phase = moveToNextPhase(clusterNodeLookup).                     try {                         phase.run().                     } catch (Exception e) {                         // we need to fail the entire request here - the entire phase just blew up                         // don't call onShardFailure or onFailure here since otherwise we'd countDown the counter                         // again which would result in an exception                         listener.onFailure(new SearchPhaseExecutionException(phase.getName(), "Phase failed", e, ShardSearchFailure.EMPTY_ARRAY)).                     }                 }             }              @Override             public void onFailure(Exception t) {                 onShardFailure("query", counter, target.getScrollId(), t, null, () -> SearchScrollAsyncAction.this.moveToNextPhase(clusterNodeLookup)).             }         }.         executeInitialPhase(connection, internalRequest, searchActionListener).     } }
false;synchronized;0;6;;synchronized ShardSearchFailure[] buildShardFailures() {     // pkg private for testing     if (shardFailures.isEmpty()) {         return ShardSearchFailure.EMPTY_ARRAY.     }     return shardFailures.toArray(new ShardSearchFailure[shardFailures.size()]). }
true;private,synchronized;1;3;// we simply try and return as much as possible ;// we do our best to return the shard failures, but its ok if its not fully concurrently safe // we simply try and return as much as possible private synchronized void addShardFailure(ShardSearchFailure failure) {     shardFailures.add(failure). }
false;protected,abstract;3;2;;protected abstract void executeInitialPhase(Transport.Connection connection, InternalScrollSearchRequest internalRequest, SearchActionListener<T> searchActionListener).
false;protected,abstract;1;1;;protected abstract SearchPhase moveToNextPhase(BiFunction<String, String, DiscoveryNode> clusterNodeLookup).
false;protected,abstract;2;1;;protected abstract void onFirstPhaseResult(int shardId, T result).
false;public;0;4;;@Override public void run() throws IOException {     sendResponse(queryPhase, fetchResults). }
false;protected;2;9;;protected SearchPhase sendResponsePhase(SearchPhaseController.ReducedQueryPhase queryPhase, final AtomicArray<? extends SearchPhaseResult> fetchResults) {     return new SearchPhase("fetch") {          @Override         public void run() throws IOException {             sendResponse(queryPhase, fetchResults).         }     }. }
false;protected,final;2;17;;protected final void sendResponse(SearchPhaseController.ReducedQueryPhase queryPhase, final AtomicArray<? extends SearchPhaseResult> fetchResults) {     try {         final InternalSearchResponse internalResponse = searchPhaseController.merge(true, queryPhase, fetchResults.asList(), fetchResults::get).         // the scroll ID never changes we always return the same ID. This ID contains all the shards and their context ids         // such that we can talk to them abgain in the next roundtrip.         String scrollId = null.         if (request.scroll() != null) {             scrollId = request.scrollId().         }         listener.onResponse(new SearchResponse(internalResponse, scrollId, this.scrollId.getContext().length, successfulOps.get(), 0, buildTookInMillis(), buildShardFailures(), SearchResponse.Clusters.EMPTY)).     } catch (Exception e) {         listener.onFailure(new ReduceSearchPhaseException("fetch", "inner finish failed", e, buildShardFailures())).     } }
false;protected;6;24;;protected void onShardFailure(String phaseName, final CountDown counter, final long searchId, Exception failure, @Nullable SearchShardTarget searchShardTarget, Supplier<SearchPhase> nextPhaseSupplier) {     if (logger.isDebugEnabled()) {         logger.debug(new ParameterizedMessage("[{}] Failed to execute {} phase", searchId, phaseName), failure).     }     addShardFailure(new ShardSearchFailure(failure, searchShardTarget)).     int successfulOperations = successfulOps.decrementAndGet().     assert successfulOperations >= 0 : "successfulOperations must be >= 0 but was: " + successfulOperations.     if (counter.countDown()) {         if (successfulOps.get() == 0) {             listener.onFailure(new SearchPhaseExecutionException(phaseName, "all shards failed", failure, buildShardFailures())).         } else {             SearchPhase phase = nextPhaseSupplier.get().             try {                 phase.run().             } catch (Exception e) {                 e.addSuppressed(failure).                 listener.onFailure(new SearchPhaseExecutionException(phase.getName(), "Phase failed", e, ShardSearchFailure.EMPTY_ARRAY)).             }         }     } }
false;protected;2;3;;protected Transport.Connection getConnection(String clusterAlias, DiscoveryNode node) {     return searchTransportService.getConnection(clusterAlias, node). }
