commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public ScoreMode scoreMode() {     return valuesSource != null && valuesSource.needsScores() ? ScoreMode.COMPLETE : ScoreMode.COMPLETE_NO_SCORES. }
false;private;1;30;;private Collector pickCollector(LeafReaderContext ctx) throws IOException {     if (valuesSource == null) {         return new EmptyCollector().     }     if (valuesSource instanceof ValuesSource.Numeric) {         ValuesSource.Numeric source = (ValuesSource.Numeric) valuesSource.         MurmurHash3Values hashValues = source.isFloatingPoint() ? MurmurHash3Values.hash(source.doubleValues(ctx)) : MurmurHash3Values.hash(source.longValues(ctx)).         return new DirectCollector(counts, hashValues).     }     if (valuesSource instanceof ValuesSource.Bytes.WithOrdinals) {         ValuesSource.Bytes.WithOrdinals source = (ValuesSource.Bytes.WithOrdinals) valuesSource.         final SortedSetDocValues ordinalValues = source.ordinalsValues(ctx).         final long maxOrd = ordinalValues.getValueCount().         if (maxOrd == 0) {             return new EmptyCollector().         }         final long ordinalsMemoryUsage = OrdinalsCollector.memoryOverhead(maxOrd).         final long countsMemoryUsage = HyperLogLogPlusPlus.memoryUsage(precision).         // only use ordinals if they don't increase memory usage by more than 25%         if (ordinalsMemoryUsage < countsMemoryUsage / 4) {             return new OrdinalsCollector(counts, ordinalValues, context.bigArrays()).         }     }     return new DirectCollector(counts, MurmurHash3Values.hash(valuesSource.bytesValues(ctx))). }
false;public;2;8;;@Override public LeafBucketCollector getLeafCollector(LeafReaderContext ctx, final LeafBucketCollector sub) throws IOException {     postCollectLastCollector().     collector = pickCollector(ctx).     return collector. }
false;private;0;10;;private void postCollectLastCollector() throws IOException {     if (collector != null) {         try {             collector.postCollect().             collector.close().         } finally {             collector = null.         }     } }
false;protected;0;4;;@Override protected void doPostCollection() throws IOException {     postCollectLastCollector(). }
false;public;1;4;;@Override public double metric(long owningBucketOrd) {     return counts == null ? 0 : counts.cardinality(owningBucketOrd). }
false;public;1;11;;@Override public InternalAggregation buildAggregation(long owningBucketOrdinal) {     if (counts == null || owningBucketOrdinal >= counts.maxBucket() || counts.cardinality(owningBucketOrdinal) == 0) {         return buildEmptyAggregation().     }     // We need to build a copy because the returned Aggregation needs remain usable after     // this Aggregator (and its HLL++ counters) is released.     HyperLogLogPlusPlus copy = new HyperLogLogPlusPlus(precision, BigArrays.NON_RECYCLING_INSTANCE, 1).     copy.merge(0, counts, owningBucketOrdinal).     return new InternalCardinality(name, copy, pipelineAggregators(), metaData()). }
false;public;0;4;;@Override public InternalAggregation buildEmptyAggregation() {     return new InternalCardinality(name, null, pipelineAggregators(), metaData()). }
false;protected;0;4;;@Override protected void doClose() {     Releasables.close(counts, collector). }
false;public,abstract;0;1;;public abstract void postCollect() throws IOException.
false;public;2;4;;@Override public void collect(int doc, long bucketOrd) { // no-op }
false;public;0;4;;@Override public void postCollect() { // no-op }
false;public;0;4;;@Override public void close() { // no-op }
false;public;2;9;;@Override public void collect(int doc, long bucketOrd) throws IOException {     if (hashes.advanceExact(doc)) {         final int valueCount = hashes.count().         for (int i = 0. i < valueCount. ++i) {             counts.collect(bucketOrd, hashes.nextValue()).         }     } }
false;public;0;4;;@Override public void postCollect() { // no-op }
false;public;0;4;;@Override public void close() { // no-op }
true;public,static;1;3;/**  * Return an approximate memory overhead per bucket for this collector.  */ ;/**  * Return an approximate memory overhead per bucket for this collector.  */ public static long memoryOverhead(long maxOrd) {     // 1 bit per ord     return RamUsageEstimator.NUM_BYTES_OBJECT_REF + SHALLOW_FIXEDBITSET_SIZE + (maxOrd + 7) / 8. }
false;public;2;14;;@Override public void collect(int doc, long bucketOrd) throws IOException {     visitedOrds = bigArrays.grow(visitedOrds, bucketOrd + 1).     FixedBitSet bits = visitedOrds.get(bucketOrd).     if (bits == null) {         bits = new FixedBitSet(maxOrd).         visitedOrds.set(bucketOrd, bits).     }     if (values.advanceExact(doc)) {         for (long ord = values.nextOrd(). ord != SortedSetDocValues.NO_MORE_ORDS. ord = values.nextOrd()) {             bits.set((int) ord).         }     } }
false;public;0;30;;@Override public void postCollect() throws IOException {     final FixedBitSet allVisitedOrds = new FixedBitSet(maxOrd).     for (long bucket = visitedOrds.size() - 1. bucket >= 0. --bucket) {         final FixedBitSet bits = visitedOrds.get(bucket).         if (bits != null) {             allVisitedOrds.or(bits).         }     }     final org.elasticsearch.common.hash.MurmurHash3.Hash128 hash = new org.elasticsearch.common.hash.MurmurHash3.Hash128().     try (LongArray hashes = bigArrays.newLongArray(maxOrd, false)) {         for (int ord = allVisitedOrds.nextSetBit(0). ord < DocIdSetIterator.NO_MORE_DOCS. ord = ord + 1 < maxOrd ? allVisitedOrds.nextSetBit(ord + 1) : DocIdSetIterator.NO_MORE_DOCS) {             final BytesRef value = values.lookupOrd(ord).             org.elasticsearch.common.hash.MurmurHash3.hash128(value.bytes, value.offset, value.length, 0, hash).             hashes.set(ord, hash.h1).         }         for (long bucket = visitedOrds.size() - 1. bucket >= 0. --bucket) {             final FixedBitSet bits = visitedOrds.get(bucket).             if (bits != null) {                 for (int ord = bits.nextSetBit(0). ord < DocIdSetIterator.NO_MORE_DOCS. ord = ord + 1 < maxOrd ? bits.nextSetBit(ord + 1) : DocIdSetIterator.NO_MORE_DOCS) {                     counts.collect(bucket, hashes.get(ord)).                 }             }         }     } }
false;public;0;4;;@Override public void close() {     Releasables.close(visitedOrds). }
false;public,abstract;1;1;;public abstract boolean advanceExact(int docId) throws IOException.
false;public,abstract;0;1;;public abstract int count().
false;public,abstract;0;1;;public abstract long nextValue() throws IOException.
true;public,static;1;3;/**  * Return a {@link MurmurHash3Values} instance that computes hashes on the fly for each double value.  */ ;/**  * Return a {@link MurmurHash3Values} instance that computes hashes on the fly for each double value.  */ public static MurmurHash3Values hash(SortedNumericDoubleValues values) {     return new Double(values). }
true;public,static;1;3;/**  * Return a {@link MurmurHash3Values} instance that computes hashes on the fly for each long value.  */ ;/**  * Return a {@link MurmurHash3Values} instance that computes hashes on the fly for each long value.  */ public static MurmurHash3Values hash(SortedNumericDocValues values) {     return new Long(values). }
true;public,static;1;3;/**  * Return a {@link MurmurHash3Values} instance that computes hashes on the fly for each binary value.  */ ;/**  * Return a {@link MurmurHash3Values} instance that computes hashes on the fly for each binary value.  */ public static MurmurHash3Values hash(SortedBinaryDocValues values) {     return new Bytes(values). }
false;public;1;4;;@Override public boolean advanceExact(int docId) throws IOException {     return values.advanceExact(docId). }
false;public;0;4;;@Override public int count() {     return values.docValueCount(). }
false;public;0;4;;@Override public long nextValue() throws IOException {     return BitMixer.mix64(values.nextValue()). }
false;public;1;4;;@Override public boolean advanceExact(int docId) throws IOException {     return values.advanceExact(docId). }
false;public;0;4;;@Override public int count() {     return values.docValueCount(). }
false;public;0;4;;@Override public long nextValue() throws IOException {     return BitMixer.mix64(java.lang.Double.doubleToLongBits(values.nextValue())). }
false;public;1;4;;@Override public boolean advanceExact(int docId) throws IOException {     return values.advanceExact(docId). }
false;public;0;4;;@Override public int count() {     return values.docValueCount(). }
false;public;0;6;;@Override public long nextValue() throws IOException {     final BytesRef bytes = values.nextValue().     org.elasticsearch.common.hash.MurmurHash3.hash128(bytes.bytes, bytes.offset, bytes.length, 0, hash).     return hash.h1. }
