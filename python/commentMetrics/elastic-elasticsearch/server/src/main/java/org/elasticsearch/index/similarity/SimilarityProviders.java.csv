commented;modifiers;parameterAmount;loc;comment;code
true;private,static;2;24;/**  * Parses the given Settings and creates the appropriate {@link BasicModel}  *  * @param settings Settings to parse  * @return {@link BasicModel} referred to in the Settings  */ ;/**  * Parses the given Settings and creates the appropriate {@link BasicModel}  *  * @param settings Settings to parse  * @return {@link BasicModel} referred to in the Settings  */ private static BasicModel parseBasicModel(Version indexCreatedVersion, Settings settings) {     String basicModel = settings.get("basic_model").     BasicModel model = BASIC_MODELS.get(basicModel).     if (model == null) {         String replacement = LEGACY_BASIC_MODELS.get(basicModel).         if (replacement != null) {             if (indexCreatedVersion.onOrAfter(Version.V_7_0_0)) {                 throw new IllegalArgumentException("Basic model [" + basicModel + "] isn't supported anymore, " + "please use another model.").             } else {                 deprecationLogger.deprecated("Basic model [" + basicModel + "] isn't supported anymore and has arbitrarily been replaced with [" + replacement + "].").                 model = BASIC_MODELS.get(replacement).                 assert model != null.             }         }     }     if (model == null) {         throw new IllegalArgumentException("Unsupported BasicModel [" + basicModel + "], expected one of " + BASIC_MODELS.keySet()).     }     return model. }
true;private,static;2;24;/**  * Parses the given Settings and creates the appropriate {@link AfterEffect}  *  * @param settings Settings to parse  * @return {@link AfterEffect} referred to in the Settings  */ ;/**  * Parses the given Settings and creates the appropriate {@link AfterEffect}  *  * @param settings Settings to parse  * @return {@link AfterEffect} referred to in the Settings  */ private static AfterEffect parseAfterEffect(Version indexCreatedVersion, Settings settings) {     String afterEffect = settings.get("after_effect").     AfterEffect effect = AFTER_EFFECTS.get(afterEffect).     if (effect == null) {         String replacement = LEGACY_AFTER_EFFECTS.get(afterEffect).         if (replacement != null) {             if (indexCreatedVersion.onOrAfter(Version.V_7_0_0)) {                 throw new IllegalArgumentException("After effect [" + afterEffect + "] isn't supported anymore, please use another effect.").             } else {                 deprecationLogger.deprecated("After effect [" + afterEffect + "] isn't supported anymore and has arbitrarily been replaced with [" + replacement + "].").                 effect = AFTER_EFFECTS.get(replacement).                 assert effect != null.             }         }     }     if (effect == null) {         throw new IllegalArgumentException("Unsupported AfterEffect [" + afterEffect + "], expected one of " + AFTER_EFFECTS.keySet()).     }     return effect. }
true;private,static;1;21;/**  * Parses the given Settings and creates the appropriate {@link Normalization}  *  * @param settings Settings to parse  * @return {@link Normalization} referred to in the Settings  */ ;/**  * Parses the given Settings and creates the appropriate {@link Normalization}  *  * @param settings Settings to parse  * @return {@link Normalization} referred to in the Settings  */ private static Normalization parseNormalization(Settings settings) {     String normalization = settings.get("normalization").     if ("no".equals(normalization)) {         return new Normalization.NoNormalization().     } else if ("h1".equals(normalization)) {         float c = settings.getAsFloat("normalization.h1.c", 1f).         return new NormalizationH1(c).     } else if ("h2".equals(normalization)) {         float c = settings.getAsFloat("normalization.h2.c", 1f).         return new NormalizationH2(c).     } else if ("h3".equals(normalization)) {         float c = settings.getAsFloat("normalization.h3.c", 800f).         return new NormalizationH3(c).     } else if ("z".equals(normalization)) {         float z = settings.getAsFloat("normalization.z.z", 0.30f).         return new NormalizationZ(z).     } else {         throw new IllegalArgumentException("Unsupported Normalization [" + normalization + "]").     } }
false;private,static;1;9;;private static Independence parseIndependence(Settings settings) {     String name = settings.get("independence_measure").     Independence measure = INDEPENDENCE_MEASURES.get(name).     if (measure == null) {         throw new IllegalArgumentException("Unsupported IndependenceMeasure [" + name + "], expected one of " + INDEPENDENCE_MEASURES.keySet()).     }     return measure. }
true;private,static;1;8;/**  * Parses the given Settings and creates the appropriate {@link Distribution}  *  * @param settings Settings to parse  * @return {@link Normalization} referred to in the Settings  */ ;/**  * Parses the given Settings and creates the appropriate {@link Distribution}  *  * @param settings Settings to parse  * @return {@link Normalization} referred to in the Settings  */ private static Distribution parseDistribution(Settings settings) {     String rawDistribution = settings.get("distribution").     Distribution distribution = DISTRIBUTIONS.get(rawDistribution).     if (distribution == null) {         throw new IllegalArgumentException("Unsupported Distribution [" + rawDistribution + "]").     }     return distribution. }
true;private,static;1;8;/**  * Parses the given Settings and creates the appropriate {@link Lambda}  *  * @param settings Settings to parse  * @return {@link Normalization} referred to in the Settings  */ ;/**  * Parses the given Settings and creates the appropriate {@link Lambda}  *  * @param settings Settings to parse  * @return {@link Normalization} referred to in the Settings  */ private static Lambda parseLambda(Settings settings) {     String rawLambda = settings.get("lambda").     Lambda lambda = LAMBDAS.get(rawLambda).     if (lambda == null) {         throw new IllegalArgumentException("Unsupported Lambda [" + rawLambda + "]").     }     return lambda. }
false;static;4;12;;static void assertSettingsIsSubsetOf(String type, Version version, Settings settings, String... supportedSettings) {     Set<String> unknownSettings = new HashSet<>(settings.keySet()).     unknownSettings.removeAll(Arrays.asList(supportedSettings)).     // used to figure out which sim this is     unknownSettings.remove("type").     if (unknownSettings.isEmpty() == false) {         if (version.onOrAfter(Version.V_7_0_0)) {             throw new IllegalArgumentException("Unknown settings for similarity of type [" + type + "]: " + unknownSettings).         } else {             deprecationLogger.deprecated("Unknown settings for similarity of type [" + type + "]: " + unknownSettings).         }     } }
false;public,static;2;11;;public static LegacyBM25Similarity createBM25Similarity(Settings settings, Version indexCreatedVersion) {     assertSettingsIsSubsetOf("BM25", indexCreatedVersion, settings, "k1", "b", DISCOUNT_OVERLAPS).     float k1 = settings.getAsFloat("k1", 1.2f).     float b = settings.getAsFloat("b", 0.75f).     boolean discountOverlaps = settings.getAsBoolean(DISCOUNT_OVERLAPS, true).     LegacyBM25Similarity similarity = new LegacyBM25Similarity(k1, b).     similarity.setDiscountOverlaps(discountOverlaps).     return similarity. }
false;public,static;2;4;;public static BooleanSimilarity createBooleanSimilarity(Settings settings, Version indexCreatedVersion) {     assertSettingsIsSubsetOf("boolean", indexCreatedVersion, settings).     return new BooleanSimilarity(). }
false;public,static;2;9;;public static ClassicSimilarity createClassicSimilarity(Settings settings, Version indexCreatedVersion) {     assertSettingsIsSubsetOf("classic", indexCreatedVersion, settings, DISCOUNT_OVERLAPS).     boolean discountOverlaps = settings.getAsBoolean(DISCOUNT_OVERLAPS, true).     ClassicSimilarity similarity = new ClassicSimilarity().     similarity.setDiscountOverlaps(discountOverlaps).     return similarity. }
false;public,static;2;11;;public static DFRSimilarity createDfrSimilarity(Settings settings, Version indexCreatedVersion) {     assertSettingsIsSubsetOf("DFR", indexCreatedVersion, settings, "basic_model", "after_effect", "normalization", "normalization.h1.c", "normalization.h2.c", "normalization.h3.c", "normalization.z.z").     return new DFRSimilarity(parseBasicModel(indexCreatedVersion, settings), parseAfterEffect(indexCreatedVersion, settings), parseNormalization(settings)). }
false;public,static;2;5;;public static DFISimilarity createDfiSimilarity(Settings settings, Version indexCreatedVersion) {     assertSettingsIsSubsetOf("DFI", indexCreatedVersion, settings, "independence_measure").     return new DFISimilarity(parseIndependence(settings)). }
false;public,static;2;9;;public static IBSimilarity createIBSimilarity(Settings settings, Version indexCreatedVersion) {     assertSettingsIsSubsetOf("IB", indexCreatedVersion, settings, "distribution", "lambda", "normalization", "normalization.h1.c", "normalization.h2.c", "normalization.h3.c", "normalization.z.z").     return new IBSimilarity(parseDistribution(settings), parseLambda(settings), parseNormalization(settings)). }
false;public,static;2;6;;public static LMDirichletSimilarity createLMDirichletSimilarity(Settings settings, Version indexCreatedVersion) {     assertSettingsIsSubsetOf("LMDirichlet", indexCreatedVersion, settings, "mu").     float mu = settings.getAsFloat("mu", 2000f).     return new LMDirichletSimilarity(mu). }
false;public,static;2;6;;public static LMJelinekMercerSimilarity createLMJelinekMercerSimilarity(Settings settings, Version indexCreatedVersion) {     assertSettingsIsSubsetOf("LMJelinekMercer", indexCreatedVersion, settings, "lambda").     float lambda = settings.getAsFloat("lambda", 0.1f).     return new LMJelinekMercerSimilarity(lambda). }
