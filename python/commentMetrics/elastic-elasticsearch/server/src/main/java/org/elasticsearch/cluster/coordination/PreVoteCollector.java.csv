commented;modifiers;parameterAmount;loc;comment;code
true;public;2;5;/**  * Start a new pre-voting round.  *  * @param clusterState   the last-accepted cluster state  * @param broadcastNodes the nodes from whom to request pre-votes  * @return the pre-voting round, which can be closed to end the round early.  */ ;/**  * Start a new pre-voting round.  *  * @param clusterState   the last-accepted cluster state  * @param broadcastNodes the nodes from whom to request pre-votes  * @return the pre-voting round, which can be closed to end the round early.  */ public Releasable start(final ClusterState clusterState, final Iterable<DiscoveryNode> broadcastNodes) {     PreVotingRound preVotingRound = new PreVotingRound(clusterState, state.v2().getCurrentTerm()).     preVotingRound.start(broadcastNodes).     return preVotingRound. }
true;;0;3;// only for testing ;// only for testing PreVoteResponse getPreVoteResponse() {     return state.v2(). }
true;;0;4;// only for testing ;// only for testing @Nullable DiscoveryNode getLeader() {     return state.v1(). }
false;public;2;4;;public void update(final PreVoteResponse preVoteResponse, @Nullable final DiscoveryNode leader) {     logger.trace("updating with preVoteResponse={}, leader={}", preVoteResponse, leader).     state = new Tuple<>(leader, preVoteResponse). }
false;private;1;24;;private PreVoteResponse handlePreVoteRequest(final PreVoteRequest request) {     updateMaxTermSeen.accept(request.getCurrentTerm()).     Tuple<DiscoveryNode, PreVoteResponse> state = this.state.     assert state != null : "received pre-vote request before fully initialised".     final DiscoveryNode leader = state.v1().     final PreVoteResponse response = state.v2().     if (leader == null) {         return response.     }     if (leader.equals(request.getSourceNode())) {         // to also detect its failure.         return response.     }     throw new CoordinationStateRejectedException("rejecting " + request + " as there is already a leader"). }
false;public;0;6;;@Override public String toString() {     return "PreVoteCollector{" + "state=" + state + '}'. }
false;public;1;4;;@Override public PreVoteResponse read(StreamInput in) throws IOException {     return new PreVoteResponse(in). }
false;public;1;4;;@Override public void handleResponse(PreVoteResponse response) {     handlePreVoteResponse(response, n). }
false;public;1;4;;@Override public void handleException(TransportException exp) {     logger.debug(new ParameterizedMessage("{} failed", this), exp). }
false;public;0;4;;@Override public String executor() {     return Names.GENERIC. }
false;public;0;4;;@Override public String toString() {     return "TransportResponseHandler{" + PreVoteCollector.this + ", node=" + n + '}'. }
false;;1;31;;void start(final Iterable<DiscoveryNode> broadcastNodes) {     assert StreamSupport.stream(broadcastNodes.spliterator(), false).noneMatch(Coordinator::isZen1Node) : broadcastNodes.     logger.debug("{} requesting pre-votes from {}", this, broadcastNodes).     broadcastNodes.forEach(n -> transportService.sendRequest(n, REQUEST_PRE_VOTE_ACTION_NAME, preVoteRequest, new TransportResponseHandler<PreVoteResponse>() {          @Override         public PreVoteResponse read(StreamInput in) throws IOException {             return new PreVoteResponse(in).         }          @Override         public void handleResponse(PreVoteResponse response) {             handlePreVoteResponse(response, n).         }          @Override         public void handleException(TransportException exp) {             logger.debug(new ParameterizedMessage("{} failed", this), exp).         }          @Override         public String executor() {             return Names.GENERIC.         }          @Override         public String toString() {             return "TransportResponseHandler{" + PreVoteCollector.this + ", node=" + n + '}'.         }     })). }
false;private;2;32;;private void handlePreVoteResponse(final PreVoteResponse response, final DiscoveryNode sender) {     if (isClosed.get()) {         logger.debug("{} is closed, ignoring {} from {}", this, response, sender).         return.     }     updateMaxTermSeen.accept(response.getCurrentTerm()).     if (response.getLastAcceptedTerm() > clusterState.term() || (response.getLastAcceptedTerm() == clusterState.term() && response.getLastAcceptedVersion() > clusterState.getVersionOrMetaDataVersion())) {         logger.debug("{} ignoring {} from {} as it is fresher", this, response, sender).         return.     }     preVotesReceived.add(sender).     final VoteCollection voteCollection = new VoteCollection().     preVotesReceived.forEach(voteCollection::addVote).     if (isElectionQuorum(voteCollection, clusterState) == false) {         logger.debug("{} added {} from {}, no quorum yet", this, response, sender).         return.     }     if (electionStarted.compareAndSet(false, true) == false) {         logger.debug("{} added {} from {} but election has already started", this, response, sender).         return.     }     logger.debug("{} added {} from {}, starting election", this, response, sender).     startElection.run(). }
false;public;0;9;;@Override public String toString() {     return "PreVotingRound{" + "preVotesReceived=" + preVotesReceived + ", electionStarted=" + electionStarted + ", preVoteRequest=" + preVoteRequest + ", isClosed=" + isClosed + '}'. }
false;public;0;5;;@Override public void close() {     final boolean isNotAlreadyClosed = isClosed.compareAndSet(false, true).     assert isNotAlreadyClosed. }
