commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public Map<String, ProfileShardResult> getShardResults() {     return this.shardResults. }
false;public;1;8;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeInt(shardResults.size()).     for (Map.Entry<String, ProfileShardResult> entry : shardResults.entrySet()) {         out.writeString(entry.getKey()).         entry.getValue().writeTo(out).     } }
false;public;2;21;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject(PROFILE_FIELD).startArray(SHARDS_FIELD).     // shardResults is a map, but we print entries in a json array, which is ordered.     // we sort the keys of the map, so that toXContent always prints out the same array order     TreeSet<String> sortedKeys = new TreeSet<>(shardResults.keySet()).     for (String key : sortedKeys) {         builder.startObject().         builder.field(ID_FIELD, key).         builder.startArray(SEARCHES_FIELD).         ProfileShardResult profileShardResult = shardResults.get(key).         for (QueryProfileShardResult result : profileShardResult.getQueryProfileResults()) {             result.toXContent(builder, params).         }         builder.endArray().         profileShardResult.getAggregationProfileResults().toXContent(builder, params).         builder.endObject().     }     builder.endArray().endObject().     return builder. }
false;public,static;1;19;;public static SearchProfileShardResults fromXContent(XContentParser parser) throws IOException {     XContentParser.Token token = parser.currentToken().     ensureExpectedToken(XContentParser.Token.START_OBJECT, token, parser::getTokenLocation).     Map<String, ProfileShardResult> searchProfileResults = new HashMap<>().     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.START_ARRAY) {             if (SHARDS_FIELD.equals(parser.currentName())) {                 while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {                     parseSearchProfileResultsEntry(parser, searchProfileResults).                 }             } else {                 parser.skipChildren().             }         } else if (token == XContentParser.Token.START_OBJECT) {             parser.skipChildren().         }     }     return new SearchProfileShardResults(searchProfileResults). }
false;private,static;2;33;;private static void parseSearchProfileResultsEntry(XContentParser parser, Map<String, ProfileShardResult> searchProfileResults) throws IOException {     XContentParser.Token token = parser.currentToken().     ensureExpectedToken(XContentParser.Token.START_OBJECT, token, parser::getTokenLocation).     List<QueryProfileShardResult> queryProfileResults = new ArrayList<>().     AggregationProfileShardResult aggProfileShardResult = null.     String id = null.     String currentFieldName = null.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token.isValue()) {             if (ID_FIELD.equals(currentFieldName)) {                 id = parser.text().             } else {                 parser.skipChildren().             }         } else if (token == XContentParser.Token.START_ARRAY) {             if (SEARCHES_FIELD.equals(currentFieldName)) {                 while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {                     queryProfileResults.add(QueryProfileShardResult.fromXContent(parser)).                 }             } else if (AggregationProfileShardResult.AGGREGATIONS.equals(currentFieldName)) {                 aggProfileShardResult = AggregationProfileShardResult.fromXContent(parser).             } else {                 parser.skipChildren().             }         } else {             parser.skipChildren().         }     }     searchProfileResults.put(id, new ProfileShardResult(queryProfileResults, aggProfileShardResult)). }
true;public,static;1;12;/**  * Helper method to convert Profiler into InternalProfileShardResults, which  * can be serialized to other nodes, emitted as JSON, etc.  *  * @param profilers  *            The {@link Profilers} to convert into results  * @return A {@link ProfileShardResult} representing the results for this  *         shard  */ ;/**  * Helper method to convert Profiler into InternalProfileShardResults, which  * can be serialized to other nodes, emitted as JSON, etc.  *  * @param profilers  *            The {@link Profilers} to convert into results  * @return A {@link ProfileShardResult} representing the results for this  *         shard  */ public static ProfileShardResult buildShardResults(Profilers profilers) {     List<QueryProfiler> queryProfilers = profilers.getQueryProfilers().     AggregationProfiler aggProfiler = profilers.getAggregationProfiler().     List<QueryProfileShardResult> queryResults = new ArrayList<>(queryProfilers.size()).     for (QueryProfiler queryProfiler : queryProfilers) {         QueryProfileShardResult result = new QueryProfileShardResult(queryProfiler.getTree(), queryProfiler.getRewriteTime(), queryProfiler.getCollector()).         queryResults.add(result).     }     AggregationProfileShardResult aggResults = new AggregationProfileShardResult(aggProfiler.getTree()).     return new ProfileShardResult(queryResults, aggResults). }
