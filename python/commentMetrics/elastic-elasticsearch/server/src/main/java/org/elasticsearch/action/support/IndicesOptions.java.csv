commented;modifiers;parameterAmount;loc;comment;code
false;public,static;2;24;;public static EnumSet<WildcardStates> parseParameter(Object value, EnumSet<WildcardStates> defaultStates) {     if (value == null) {         return defaultStates.     }     Set<WildcardStates> states = new HashSet<>().     String[] wildcards = nodeStringArrayValue(value).     for (String wildcard : wildcards) {         if ("open".equals(wildcard)) {             states.add(OPEN).         } else if ("closed".equals(wildcard)) {             states.add(CLOSED).         } else if ("none".equals(wildcard)) {             states.clear().         } else if ("all".equals(wildcard)) {             states.add(OPEN).             states.add(CLOSED).         } else {             throw new IllegalArgumentException("No valid expand wildcard value [" + wildcard + "]").         }     }     return states.isEmpty() ? NONE : EnumSet.copyOf(states). }
true;static;1;34;// Package visible for testing ;// Package visible for testing static IndicesOptions fromByte(final byte id) {     // IGNORE_UNAVAILABLE = 1.     // ALLOW_NO_INDICES = 2.     // EXPAND_WILDCARDS_OPEN = 4.     // EXPAND_WILDCARDS_CLOSED = 8.     // FORBID_ALIASES_TO_MULTIPLE_INDICES = 16.     // FORBID_CLOSED_INDICES = 32.     // IGNORE_ALIASES = 64.     Set<Option> opts = new HashSet<>().     Set<WildcardStates> wildcards = new HashSet<>().     if ((id & 1) != 0) {         opts.add(Option.IGNORE_UNAVAILABLE).     }     if ((id & 2) != 0) {         opts.add(Option.ALLOW_NO_INDICES).     }     if ((id & 4) != 0) {         wildcards.add(WildcardStates.OPEN).     }     if ((id & 8) != 0) {         wildcards.add(WildcardStates.CLOSED).     }     if ((id & 16) != 0) {         opts.add(Option.FORBID_ALIASES_TO_MULTIPLE_INDICES).     }     if ((id & 32) != 0) {         opts.add(Option.FORBID_CLOSED_INDICES).     }     if ((id & 64) != 0) {         opts.add(Option.IGNORE_ALIASES).     }     return new IndicesOptions(opts, wildcards). }
true;private,static;1;27;/**  * See: {@link #fromByte(byte)}  */ ;/**  * See: {@link #fromByte(byte)}  */ private static byte toByte(IndicesOptions options) {     byte id = 0.     if (options.ignoreUnavailable()) {         id |= 1.     }     if (options.allowNoIndices()) {         id |= 2.     }     if (options.expandWildcardsOpen()) {         id |= 4.     }     if (options.expandWildcardsClosed()) {         id |= 8.     }     // in the array same as before + the default value for the new flag     if (options.allowAliasesToMultipleIndices() == false) {         id |= 16.     }     if (options.forbidClosedIndices()) {         id |= 32.     }     if (options.ignoreAliases()) {         id |= 64.     }     return id. }
true;public;0;3;/**  * @return Whether specified concrete indices should be ignored when unavailable (missing or closed)  */ ;/**  * @return Whether specified concrete indices should be ignored when unavailable (missing or closed)  */ public boolean ignoreUnavailable() {     return options.contains(Option.IGNORE_UNAVAILABLE). }
true;public;0;3;/**  * @return Whether to ignore if a wildcard expression resolves to no concrete indices.  *         The `_all` string or empty list of indices count as wildcard expressions too.  *         Also when an alias points to a closed index this option decides if no concrete indices  *         are allowed.  */ ;/**  * @return Whether to ignore if a wildcard expression resolves to no concrete indices.  *         The `_all` string or empty list of indices count as wildcard expressions too.  *         Also when an alias points to a closed index this option decides if no concrete indices  *         are allowed.  */ public boolean allowNoIndices() {     return options.contains(Option.ALLOW_NO_INDICES). }
true;public;0;3;/**  * @return Whether wildcard expressions should get expanded to open indices  */ ;/**  * @return Whether wildcard expressions should get expanded to open indices  */ public boolean expandWildcardsOpen() {     return expandWildcards.contains(WildcardStates.OPEN). }
true;public;0;3;/**  * @return Whether wildcard expressions should get expanded to closed indices  */ ;/**  * @return Whether wildcard expressions should get expanded to closed indices  */ public boolean expandWildcardsClosed() {     return expandWildcards.contains(WildcardStates.CLOSED). }
true;public;0;3;/**  * @return Whether execution on closed indices is allowed.  */ ;/**  * @return Whether execution on closed indices is allowed.  */ public boolean forbidClosedIndices() {     return options.contains(Option.FORBID_CLOSED_INDICES). }
true;public;0;5;/**  * @return whether aliases pointing to multiple indices are allowed  */ ;/**  * @return whether aliases pointing to multiple indices are allowed  */ public boolean allowAliasesToMultipleIndices() {     // in the array same as before + the default value for the new flag     return options.contains(Option.FORBID_ALIASES_TO_MULTIPLE_INDICES) == false. }
true;public;0;3;/**  * @return whether aliases should be ignored (when resolving a wildcard)  */ ;/**  * @return whether aliases should be ignored (when resolving a wildcard)  */ public boolean ignoreAliases() {     return options.contains(Option.IGNORE_ALIASES). }
true;public;0;3;/**  * @return whether indices that are marked as throttled should be ignored  */ ;/**  * @return whether indices that are marked as throttled should be ignored  */ public boolean ignoreThrottled() {     return options.contains(Option.IGNORE_THROTTLED). }
false;public;1;14;;public void writeIndicesOptions(StreamOutput out) throws IOException {     EnumSet<Option> options = this.options.     // never write this out to a pre 6.6 version     if (out.getVersion().before(Version.V_6_6_0) && options.contains(Option.IGNORE_THROTTLED)) {         options = EnumSet.copyOf(options).         options.remove(Option.IGNORE_THROTTLED).     }     if (out.getVersion().onOrAfter(Version.V_6_4_0)) {         out.writeEnumSet(options).         out.writeEnumSet(expandWildcards).     } else {         out.write(IndicesOptions.toByte(this)).     } }
false;public,static;1;11;;public static IndicesOptions readIndicesOptions(StreamInput in) throws IOException {     if (in.getVersion().onOrAfter(Version.V_6_4_0)) {         return new IndicesOptions(in.readEnumSet(Option.class), in.readEnumSet(WildcardStates.class)).     } else {         byte id = in.readByte().         if (id >= OLD_VALUES.length) {             throw new IllegalArgumentException("No valid missing index type id: " + id).         }         return OLD_VALUES[id].     } }
false;public,static;4;4;;public static IndicesOptions fromOptions(boolean ignoreUnavailable, boolean allowNoIndices, boolean expandToOpenIndices, boolean expandToClosedIndices) {     return fromOptions(ignoreUnavailable, allowNoIndices, expandToOpenIndices, expandToClosedIndices, true, false, false, false). }
false;public,static;5;6;;public static IndicesOptions fromOptions(boolean ignoreUnavailable, boolean allowNoIndices, boolean expandToOpenIndices, boolean expandToClosedIndices, IndicesOptions defaultOptions) {     return fromOptions(ignoreUnavailable, allowNoIndices, expandToOpenIndices, expandToClosedIndices, defaultOptions.allowAliasesToMultipleIndices(), defaultOptions.forbidClosedIndices(), defaultOptions.ignoreAliases(), defaultOptions.ignoreThrottled()). }
false;public,static;8;33;;public static IndicesOptions fromOptions(boolean ignoreUnavailable, boolean allowNoIndices, boolean expandToOpenIndices, boolean expandToClosedIndices, boolean allowAliasesToMultipleIndices, boolean forbidClosedIndices, boolean ignoreAliases, boolean ignoreThrottled) {     final Set<Option> opts = new HashSet<>().     final Set<WildcardStates> wildcards = new HashSet<>().     if (ignoreUnavailable) {         opts.add(Option.IGNORE_UNAVAILABLE).     }     if (allowNoIndices) {         opts.add(Option.ALLOW_NO_INDICES).     }     if (expandToOpenIndices) {         wildcards.add(WildcardStates.OPEN).     }     if (expandToClosedIndices) {         wildcards.add(WildcardStates.CLOSED).     }     if (allowAliasesToMultipleIndices == false) {         opts.add(Option.FORBID_ALIASES_TO_MULTIPLE_INDICES).     }     if (forbidClosedIndices) {         opts.add(Option.FORBID_CLOSED_INDICES).     }     if (ignoreAliases) {         opts.add(Option.IGNORE_ALIASES).     }     if (ignoreThrottled) {         opts.add(Option.IGNORE_THROTTLED).     }     return new IndicesOptions(opts, wildcards). }
false;public,static;2;8;;public static IndicesOptions fromRequest(RestRequest request, IndicesOptions defaultSettings) {     return fromParameters(request.param("expand_wildcards"), request.param("ignore_unavailable"), request.param("allow_no_indices"), request.param("ignore_throttled"), defaultSettings). }
false;public,static;2;8;;public static IndicesOptions fromMap(Map<String, Object> map, IndicesOptions defaultSettings) {     return fromParameters(map.containsKey("expand_wildcards") ? map.get("expand_wildcards") : map.get("expandWildcards"), map.containsKey("ignore_unavailable") ? map.get("ignore_unavailable") : map.get("ignoreUnavailable"), map.containsKey("allow_no_indices") ? map.get("allow_no_indices") : map.get("allowNoIndices"), map.containsKey("ignore_throttled") ? map.get("ignore_throttled") : map.get("ignoreThrottled"), defaultSettings). }
true;public,static;1;6;/**  * Returns true if the name represents a valid name for one of the indices option  * false otherwise  */ ;/**  * Returns true if the name represents a valid name for one of the indices option  * false otherwise  */ public static boolean isIndicesOptions(String name) {     return "expand_wildcards".equals(name) || "expandWildcards".equals(name) || "ignore_unavailable".equals(name) || "ignoreUnavailable".equals(name) || "ignore_throttled".equals(name) || "ignoreThrottled".equals(name) || "allow_no_indices".equals(name) || "allowNoIndices".equals(name). }
false;public,static;5;20;;public static IndicesOptions fromParameters(Object wildcardsString, Object ignoreUnavailableString, Object allowNoIndicesString, Object ignoreThrottled, IndicesOptions defaultSettings) {     if (wildcardsString == null && ignoreUnavailableString == null && allowNoIndicesString == null && ignoreThrottled == null) {         return defaultSettings.     }     EnumSet<WildcardStates> wildcards = WildcardStates.parseParameter(wildcardsString, defaultSettings.expandWildcards).     // note that allowAliasesToMultipleIndices is not exposed, always true (only for internal use)     return fromOptions(nodeBooleanValue(ignoreUnavailableString, "ignore_unavailable", defaultSettings.ignoreUnavailable()), nodeBooleanValue(allowNoIndicesString, "allow_no_indices", defaultSettings.allowNoIndices()), wildcards.contains(WildcardStates.OPEN), wildcards.contains(WildcardStates.CLOSED), defaultSettings.allowAliasesToMultipleIndices(), defaultSettings.forbidClosedIndices(), defaultSettings.ignoreAliases(), nodeBooleanValue(ignoreThrottled, "ignore_throttled", defaultSettings.ignoreThrottled())). }
false;public;2;12;;@Override public XContentBuilder toXContent(XContentBuilder builder, ToXContent.Params params) throws IOException {     builder.startArray("expand_wildcards").     for (WildcardStates expandWildcard : expandWildcards) {         builder.value(expandWildcard.toString().toLowerCase(Locale.ROOT)).     }     builder.endArray().     builder.field("ignore_unavailable", ignoreUnavailable()).     builder.field("allow_no_indices", allowNoIndices()).     builder.field("ignore_throttled", ignoreThrottled()).     return builder. }
true;public,static;0;3;/**  * @return indices options that requires every specified index to exist, expands wildcards only to open indices and  *         allows that no indices are resolved from wildcard expressions (not returning an error).  */ ;/**  * @return indices options that requires every specified index to exist, expands wildcards only to open indices and  *         allows that no indices are resolved from wildcard expressions (not returning an error).  */ public static IndicesOptions strictExpandOpen() {     return STRICT_EXPAND_OPEN. }
true;public,static;0;3;/**  * @return indices options that requires every specified index to exist, expands wildcards only to open indices,  *         allows that no indices are resolved from wildcard expressions (not returning an error) and forbids the  *         use of closed indices by throwing an error.  */ ;/**  * @return indices options that requires every specified index to exist, expands wildcards only to open indices,  *         allows that no indices are resolved from wildcard expressions (not returning an error) and forbids the  *         use of closed indices by throwing an error.  */ public static IndicesOptions strictExpandOpenAndForbidClosed() {     return STRICT_EXPAND_OPEN_FORBID_CLOSED. }
true;public,static;0;3;/**  * @return indices options that requires every specified index to exist, expands wildcards only to open indices,  *         allows that no indices are resolved from wildcard expressions (not returning an error) and forbids the  *         use of closed indices by throwing an error and ignores indices that are throttled.  */ ;/**  * @return indices options that requires every specified index to exist, expands wildcards only to open indices,  *         allows that no indices are resolved from wildcard expressions (not returning an error) and forbids the  *         use of closed indices by throwing an error and ignores indices that are throttled.  */ public static IndicesOptions strictExpandOpenAndForbidClosedIgnoreThrottled() {     return STRICT_EXPAND_OPEN_FORBID_CLOSED_IGNORE_THROTTLED. }
true;public,static;0;3;/**  * @return indices option that requires every specified index to exist, expands wildcards to both open and closed  * indices and allows that no indices are resolved from wildcard expressions (not returning an error).  */ ;/**  * @return indices option that requires every specified index to exist, expands wildcards to both open and closed  * indices and allows that no indices are resolved from wildcard expressions (not returning an error).  */ public static IndicesOptions strictExpand() {     return STRICT_EXPAND_OPEN_CLOSED. }
true;public,static;0;3;/**  * @return indices option that requires each specified index or alias to exist, doesn't expand wildcards and  * throws error if any of the aliases resolves to multiple indices  */ ;/**  * @return indices option that requires each specified index or alias to exist, doesn't expand wildcards and  * throws error if any of the aliases resolves to multiple indices  */ public static IndicesOptions strictSingleIndexNoExpandForbidClosed() {     return STRICT_SINGLE_INDEX_NO_EXPAND_FORBID_CLOSED. }
true;public,static;0;3;/**  * @return indices options that ignores unavailable indices, expands wildcards only to open indices and  *         allows that no indices are resolved from wildcard expressions (not returning an error).  */ ;/**  * @return indices options that ignores unavailable indices, expands wildcards only to open indices and  *         allows that no indices are resolved from wildcard expressions (not returning an error).  */ public static IndicesOptions lenientExpandOpen() {     return LENIENT_EXPAND_OPEN. }
true;public,static;0;3;/**  * @return indices options that ignores unavailable indices,  expands wildcards to both open and closed  * indices and allows that no indices are resolved from wildcard expressions (not returning an error).  */ ;/**  * @return indices options that ignores unavailable indices,  expands wildcards to both open and closed  * indices and allows that no indices are resolved from wildcard expressions (not returning an error).  */ public static IndicesOptions lenientExpand() {     return LENIENT_EXPAND_OPEN_CLOSED. }
false;public;1;13;;@Override public boolean equals(Object obj) {     if (obj == null) {         return false.     }     if (obj.getClass() != getClass()) {         return false.     }     IndicesOptions other = (IndicesOptions) obj.     return options.equals(other.options) && expandWildcards.equals(other.expandWildcards). }
false;public;0;5;;@Override public int hashCode() {     int result = options.hashCode().     return 31 * result + expandWildcards.hashCode(). }
false;public;0;13;;@Override public String toString() {     return "IndicesOptions[" + "ignore_unavailable=" + ignoreUnavailable() + ", allow_no_indices=" + allowNoIndices() + ", expand_wildcards_open=" + expandWildcardsOpen() + ", expand_wildcards_closed=" + expandWildcardsClosed() + ", allow_aliases_to_multiple_indices=" + allowAliasesToMultipleIndices() + ", forbid_closed_indices=" + forbidClosedIndices() + ", ignore_aliases=" + ignoreAliases() + ", ignore_throttled=" + ignoreThrottled() + ']'. }
