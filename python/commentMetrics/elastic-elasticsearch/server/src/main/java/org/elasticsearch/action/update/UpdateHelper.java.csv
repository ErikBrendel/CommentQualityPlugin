commented;modifiers;parameterAmount;loc;comment;code
true;public;3;5;/**  * Prepares an update request by converting it into an index or delete request or an update response (no action).  */ ;/**  * Prepares an update request by converting it into an index or delete request or an update response (no action).  */ public Result prepare(UpdateRequest request, IndexShard indexShard, LongSupplier nowInMillis) {     final GetResult getResult = indexShard.getService().getForUpdate(request.type(), request.id(), request.ifSeqNo(), request.ifPrimaryTerm()).     return prepare(indexShard.shardId(), request, getResult, nowInMillis). }
true;protected;4;15;/**  * Prepares an update request by converting it into an index or delete request or an update response (no action, in the event of a  * noop).  */ ;/**  * Prepares an update request by converting it into an index or delete request or an update response (no action, in the event of a  * noop).  */ protected Result prepare(ShardId shardId, UpdateRequest request, final GetResult getResult, LongSupplier nowInMillis) {     if (getResult.isExists() == false) {         // If the document didn't exist, execute the update request as an upsert         return prepareUpsert(shardId, request, getResult, nowInMillis).     } else if (getResult.internalSourceRef() == null) {         // no source, we can't do anything, throw a failure...         throw new DocumentSourceMissingException(shardId, request.type(), request.id()).     } else if (request.script() == null && request.doc() != null) {         // The request has no script, it is a new doc that should be merged with the old document         return prepareUpdateIndexRequest(shardId, request, getResult, request.detectNoop()).     } else {         // The request has a script (or empty script), execute the script and prepare a new index request         return prepareUpdateScriptRequest(shardId, request, getResult, nowInMillis).     } }
true;;3;21;/**  * Execute a scripted upsert, where there is an existing upsert document and a script to be executed. The script is executed and a new  * Tuple of operation and updated {@code _source} is returned.  */ ;/**  * Execute a scripted upsert, where there is an existing upsert document and a script to be executed. The script is executed and a new  * Tuple of operation and updated {@code _source} is returned.  */ Tuple<UpdateOpType, Map<String, Object>> executeScriptedUpsert(IndexRequest upsert, Script script, LongSupplier nowInMillis) {     Map<String, Object> upsertDoc = upsert.sourceAsMap().     Map<String, Object> ctx = new HashMap<>(3).     // Tell the script that this is a create and not an update     ctx.put(ContextFields.OP, UpdateOpType.CREATE.toString()).     ctx.put(ContextFields.SOURCE, upsertDoc).     ctx.put(ContextFields.NOW, nowInMillis.getAsLong()).     ctx = executeScript(script, ctx).     UpdateOpType operation = UpdateOpType.lenientFromString((String) ctx.get(ContextFields.OP), logger, script.getIdOrCode()).     @SuppressWarnings("unchecked")     Map<String, Object> newSource = (Map<String, Object>) ctx.get(ContextFields.SOURCE).     if (operation != UpdateOpType.CREATE && operation != UpdateOpType.NONE) {         // Only valid options for an upsert script are "create" (the default) or "none", meaning abort upsert         logger.warn("Invalid upsert operation [{}] for script [{}], doing nothing...", operation, script.getIdOrCode()).         operation = UpdateOpType.NONE.     }     return new Tuple<>(operation, newSource). }
true;;4;38;/**  * Prepare the request for upsert, executing the upsert script if present, and returning a {@code Result} containing a new  * {@code IndexRequest} to be executed on the primary and replicas.  */ ;/**  * Prepare the request for upsert, executing the upsert script if present, and returning a {@code Result} containing a new  * {@code IndexRequest} to be executed on the primary and replicas.  */ Result prepareUpsert(ShardId shardId, UpdateRequest request, final GetResult getResult, LongSupplier nowInMillis) {     if (request.upsertRequest() == null && !request.docAsUpsert()) {         throw new DocumentMissingException(shardId, request.type(), request.id()).     }     IndexRequest indexRequest = request.docAsUpsert() ? request.doc() : request.upsertRequest().     if (request.scriptedUpsert() && request.script() != null) {         // Run the script to perform the create logic         IndexRequest upsert = request.upsertRequest().         Tuple<UpdateOpType, Map<String, Object>> upsertResult = executeScriptedUpsert(upsert, request.script, nowInMillis).         switch(upsertResult.v1()) {             case CREATE:                 // Update the index request with the new "_source"                 indexRequest.source(upsertResult.v2()).                 break.             case NONE:                 UpdateResponse update = new UpdateResponse(shardId, getResult.getType(), getResult.getId(), getResult.getVersion(), DocWriteResponse.Result.NOOP).                 update.setGetResult(getResult).                 return new Result(update, DocWriteResponse.Result.NOOP, upsertResult.v2(), XContentType.JSON).             default:                 // It's fine to throw an exception here, the leniency is handled/logged by `executeScriptedUpsert`                 throw new IllegalArgumentException("unknown upsert operation, got: " + upsertResult.v1()).         }     }     indexRequest.index(request.index()).type(request.type()).id(request.id()).setRefreshPolicy(request.getRefreshPolicy()).routing(request.routing()).timeout(request.timeout()).waitForActiveShards(request.waitForActiveShards()).create(true).     if (request.versionType() != VersionType.INTERNAL) {         // in all but the internal versioning mode, we want to create the new document using the given version.         indexRequest.version(request.version()).versionType(request.versionType()).     }     return new Result(indexRequest, DocWriteResponse.Result.CREATED, null, null). }
true;static;2;10;/**  * Calculate a routing value to be used, either the included index request's routing, or retrieved document's routing when defined.  */ ;/**  * Calculate a routing value to be used, either the included index request's routing, or retrieved document's routing when defined.  */ @Nullable static String calculateRouting(GetResult getResult, @Nullable IndexRequest updateIndexRequest) {     if (updateIndexRequest != null && updateIndexRequest.routing() != null) {         return updateIndexRequest.routing().     } else if (getResult.getFields().containsKey(RoutingFieldMapper.NAME)) {         return getResult.field(RoutingFieldMapper.NAME).getValue().toString().     } else {         return null.     } }
true;;4;27;/**  * Prepare the request for merging the existing document with a new one, can optionally detect a noop change. Returns a {@code Result}  * containing a new {@code IndexRequest} to be executed on the primary and replicas.  */ ;/**  * Prepare the request for merging the existing document with a new one, can optionally detect a noop change. Returns a {@code Result}  * containing a new {@code IndexRequest} to be executed on the primary and replicas.  */ Result prepareUpdateIndexRequest(ShardId shardId, UpdateRequest request, GetResult getResult, boolean detectNoop) {     final IndexRequest currentRequest = request.doc().     final String routing = calculateRouting(getResult, currentRequest).     final Tuple<XContentType, Map<String, Object>> sourceAndContent = XContentHelper.convertToMap(getResult.internalSourceRef(), true).     final XContentType updateSourceContentType = sourceAndContent.v1().     final Map<String, Object> updatedSourceAsMap = sourceAndContent.v2().     final boolean noop = !XContentHelper.update(updatedSourceAsMap, currentRequest.sourceAsMap(), detectNoop).     // where users repopulating multi-fields or adding synonyms, etc.     if (detectNoop && noop) {         UpdateResponse update = new UpdateResponse(shardId, getResult.getType(), getResult.getId(), getResult.getVersion(), DocWriteResponse.Result.NOOP).         update.setGetResult(extractGetResult(request, request.index(), getResult.getSeqNo(), getResult.getPrimaryTerm(), getResult.getVersion(), updatedSourceAsMap, updateSourceContentType, getResult.internalSourceRef())).         return new Result(update, DocWriteResponse.Result.NOOP, updatedSourceAsMap, updateSourceContentType).     } else {         final IndexRequest finalIndexRequest = Requests.indexRequest(request.index()).type(request.type()).id(request.id()).routing(routing).source(updatedSourceAsMap, updateSourceContentType).setIfSeqNo(getResult.getSeqNo()).setIfPrimaryTerm(getResult.getPrimaryTerm()).waitForActiveShards(request.waitForActiveShards()).timeout(request.timeout()).setRefreshPolicy(request.getRefreshPolicy()).         return new Result(finalIndexRequest, DocWriteResponse.Result.UPDATED, updatedSourceAsMap, updateSourceContentType).     } }
true;;4;49;/**  * Prepare the request for updating an existing document using a script. Executes the script and returns a {@code Result} containing  * either a new {@code IndexRequest} or {@code DeleteRequest} (depending on the script's returned "op" value) to be executed on the  * primary and replicas.  */ ;/**  * Prepare the request for updating an existing document using a script. Executes the script and returns a {@code Result} containing  * either a new {@code IndexRequest} or {@code DeleteRequest} (depending on the script's returned "op" value) to be executed on the  * primary and replicas.  */ Result prepareUpdateScriptRequest(ShardId shardId, UpdateRequest request, GetResult getResult, LongSupplier nowInMillis) {     final IndexRequest currentRequest = request.doc().     final String routing = calculateRouting(getResult, currentRequest).     final Tuple<XContentType, Map<String, Object>> sourceAndContent = XContentHelper.convertToMap(getResult.internalSourceRef(), true).     final XContentType updateSourceContentType = sourceAndContent.v1().     final Map<String, Object> sourceAsMap = sourceAndContent.v2().     Map<String, Object> ctx = new HashMap<>(16).     // The default operation is "index"     ctx.put(ContextFields.OP, UpdateOpType.INDEX.toString()).     ctx.put(ContextFields.INDEX, getResult.getIndex()).     ctx.put(ContextFields.TYPE, getResult.getType()).     ctx.put(ContextFields.ID, getResult.getId()).     ctx.put(ContextFields.VERSION, getResult.getVersion()).     ctx.put(ContextFields.ROUTING, routing).     ctx.put(ContextFields.SOURCE, sourceAsMap).     ctx.put(ContextFields.NOW, nowInMillis.getAsLong()).     ctx = executeScript(request.script, ctx).     UpdateOpType operation = UpdateOpType.lenientFromString((String) ctx.get(ContextFields.OP), logger, request.script.getIdOrCode()).     @SuppressWarnings("unchecked")     final Map<String, Object> updatedSourceAsMap = (Map<String, Object>) ctx.get(ContextFields.SOURCE).     switch(operation) {         case INDEX:             final IndexRequest indexRequest = Requests.indexRequest(request.index()).type(request.type()).id(request.id()).routing(routing).source(updatedSourceAsMap, updateSourceContentType).setIfSeqNo(getResult.getSeqNo()).setIfPrimaryTerm(getResult.getPrimaryTerm()).waitForActiveShards(request.waitForActiveShards()).timeout(request.timeout()).setRefreshPolicy(request.getRefreshPolicy()).             return new Result(indexRequest, DocWriteResponse.Result.UPDATED, updatedSourceAsMap, updateSourceContentType).         case DELETE:             DeleteRequest deleteRequest = Requests.deleteRequest(request.index()).type(request.type()).id(request.id()).routing(routing).setIfSeqNo(getResult.getSeqNo()).setIfPrimaryTerm(getResult.getPrimaryTerm()).waitForActiveShards(request.waitForActiveShards()).timeout(request.timeout()).setRefreshPolicy(request.getRefreshPolicy()).             return new Result(deleteRequest, DocWriteResponse.Result.DELETED, updatedSourceAsMap, updateSourceContentType).         default:             // If it was neither an INDEX or DELETE operation, treat it as a noop             UpdateResponse update = new UpdateResponse(shardId, getResult.getType(), getResult.getId(), getResult.getVersion(), DocWriteResponse.Result.NOOP).             update.setGetResult(extractGetResult(request, request.index(), getResult.getSeqNo(), getResult.getPrimaryTerm(), getResult.getVersion(), updatedSourceAsMap, updateSourceContentType, getResult.internalSourceRef())).             return new Result(update, DocWriteResponse.Result.NOOP, updatedSourceAsMap, updateSourceContentType).     } }
false;private;2;12;;private Map<String, Object> executeScript(Script script, Map<String, Object> ctx) {     try {         if (scriptService != null) {             UpdateScript.Factory factory = scriptService.compile(script, UpdateScript.CONTEXT).             UpdateScript executableScript = factory.newInstance(script.getParams(), ctx).             executableScript.execute().         }     } catch (Exception e) {         throw new IllegalArgumentException("failed to execute script", e).     }     return ctx. }
true;public,static;8;28;/**  * Applies {@link UpdateRequest#fetchSource()} to the _source of the updated document to be returned in a update response.  */ ;/**  * Applies {@link UpdateRequest#fetchSource()} to the _source of the updated document to be returned in a update response.  */ public static GetResult extractGetResult(final UpdateRequest request, String concreteIndex, long seqNo, long primaryTerm, long version, final Map<String, Object> source, XContentType sourceContentType, @Nullable final BytesReference sourceAsBytes) {     if (request.fetchSource() == null || request.fetchSource().fetchSource() == false) {         return null.     }     BytesReference sourceFilteredAsBytes = sourceAsBytes.     if (request.fetchSource().includes().length > 0 || request.fetchSource().excludes().length > 0) {         SourceLookup sourceLookup = new SourceLookup().         sourceLookup.setSource(source).         Object value = sourceLookup.filter(request.fetchSource()).         try {             final int initialCapacity = Math.min(1024, sourceAsBytes.length()).             BytesStreamOutput streamOutput = new BytesStreamOutput(initialCapacity).             try (XContentBuilder builder = new XContentBuilder(sourceContentType.xContent(), streamOutput)) {                 builder.value(value).                 sourceFilteredAsBytes = BytesReference.bytes(builder).             }         } catch (IOException e) {             throw new ElasticsearchException("Error filtering source", e).         }     }     // TODO when using delete/none, we can still return the source as bytes by generating it (using the sourceContentType)     return new GetResult(concreteIndex, request.type(), request.id(), seqNo, primaryTerm, version, true, sourceFilteredAsBytes, Collections.emptyMap()). }
false;public;0;4;;@SuppressWarnings("unchecked") public <T extends Streamable> T action() {     return (T) action. }
false;public;0;3;;public DocWriteResponse.Result getResponseResult() {     return result. }
false;public;0;3;;public Map<String, Object> updatedSourceAsMap() {     return updatedSourceAsMap. }
false;public;0;3;;public XContentType updateSourceContentType() {     return updateSourceContentType. }
false;public,static;3;16;;public static UpdateOpType lenientFromString(String operation, Logger logger, String scriptId) {     switch(operation) {         case "create":             return UpdateOpType.CREATE.         case "index":             return UpdateOpType.INDEX.         case "delete":             return UpdateOpType.DELETE.         case "none":             return UpdateOpType.NONE.         default:             // TODO: can we remove this leniency yet??             logger.warn("Used upsert operation [{}] for script [{}], doing nothing...", operation, scriptId).             return UpdateOpType.NONE.     } }
false;public;0;4;;@Override public String toString() {     return name. }
