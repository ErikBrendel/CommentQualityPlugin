commented;modifiers;parameterAmount;loc;comment;code
true;public,static;3;35;/**  * Runs the simulated annealing algorithm and produces a model with new coefficients that, theoretically  * fit the data better and generalizes to future forecasts without overfitting.  *  * @param model         The MovAvgModel to be optimized for  * @param train         A training set provided to the model, which predictions will be  *                      generated from  * @param test          A test set of data to compare the predictions against and derive  *                      a cost for the model  * @return              A new, minimized model that (theoretically) better fits the data  */ ;/**  * Runs the simulated annealing algorithm and produces a model with new coefficients that, theoretically  * fit the data better and generalizes to future forecasts without overfitting.  *  * @param model         The MovAvgModel to be optimized for  * @param train         A training set provided to the model, which predictions will be  *                      generated from  * @param test          A test set of data to compare the predictions against and derive  *                      a cost for the model  * @return              A new, minimized model that (theoretically) better fits the data  */ public static MovAvgModel minimize(MovAvgModel model, EvictingQueue<Double> train, double[] test) {     double temp = 1.     double minTemp = 0.0001.     int iterations = 100.     double alpha = 0.9.     MovAvgModel bestModel = model.     MovAvgModel oldModel = model.     double oldCost = cost(model, train, test).     double bestCost = oldCost.     while (temp > minTemp) {         for (int i = 0. i < iterations. i++) {             MovAvgModel newModel = oldModel.neighboringModel().             double newCost = cost(newModel, train, test).             double ap = acceptanceProbability(oldCost, newCost, temp).             if (ap > Math.random()) {                 oldModel = newModel.                 oldCost = newCost.                 if (newCost < bestCost) {                     bestCost = newCost.                     bestModel = newModel.                 }             }         }         temp *= alpha.     }     return bestModel. }
true;private,static;3;3;/**  * If the new cost is better than old, return 1.0.  Otherwise, return a double that increases  * as the two costs are closer to each other.  *  * @param oldCost   Old model cost  * @param newCost   New model cost  * @param temp      Current annealing temperature  * @return          The probability of accepting the new cost over the old  */ ;/**  * If the new cost is better than old, return 1.0.  Otherwise, return a double that increases  * as the two costs are closer to each other.  *  * @param oldCost   Old model cost  * @param newCost   New model cost  * @param temp      Current annealing temperature  * @return          The probability of accepting the new cost over the old  */ private static double acceptanceProbability(double oldCost, double newCost, double temp) {     return newCost < oldCost ? 1.0 : Math.exp(-(newCost - oldCost) / temp). }
true;private,static;3;12;/**  * Calculates the "cost" of a model.  E.g. when run on the training data, how closely do the  predictions  * match the test data  *  * Uses Least Absolute Differences to calculate error.  Note that this is not scale free, but seems  * to work fairly well in practice  *  * @param model     The MovAvgModel we are fitting  * @param train     A training set of data given to the model, which will then generate predictions from  * @param test      A test set of data to compare against the predictions  * @return          A cost, or error, of the model  */ ;/**  * Calculates the "cost" of a model.  E.g. when run on the training data, how closely do the  predictions  * match the test data  *  * Uses Least Absolute Differences to calculate error.  Note that this is not scale free, but seems  * to work fairly well in practice  *  * @param model     The MovAvgModel we are fitting  * @param train     A training set of data given to the model, which will then generate predictions from  * @param test      A test set of data to compare against the predictions  * @return          A cost, or error, of the model  */ private static double cost(MovAvgModel model, EvictingQueue<Double> train, double[] test) {     double error = 0.     double[] predictions = model.predict(train, test.length).     assert (predictions.length == test.length).     for (int i = 0. i < predictions.length. i++) {         error += Math.abs(test[i] - predictions[i]).     }     return error. }
