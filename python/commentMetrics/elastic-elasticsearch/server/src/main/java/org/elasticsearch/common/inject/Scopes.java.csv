commented;modifiers;parameterAmount;loc;comment;code
true;public;0;18;// DCL on a volatile is safe as of Java 5, which we obviously require. ;// DCL on a volatile is safe as of Java 5, which we obviously require. @Override @SuppressWarnings("DoubleCheckedLocking") public T get() {     if (instance == null) {         /*                         * Use a pretty coarse lock. We don't want to run into deadlocks                         * when two threads try to load circularly-dependent objects.                         * Maybe one of these days we will identify independent graphs of                         * objects and offer to load them in parallel.                         */         synchronized (InjectorImpl.class) {             if (instance == null) {                 instance = creator.get().             }         }     }     return instance. }
false;public;0;4;;@Override public String toString() {     return String.format(Locale.ROOT, "%s[%s]", creator, SINGLETON). }
false;public;2;32;;@Override public <T> Provider<T> scope(Key<T> key, final Provider<T> creator) {     return new Provider<T>() {          private volatile T instance.          // DCL on a volatile is safe as of Java 5, which we obviously require.         @Override         @SuppressWarnings("DoubleCheckedLocking")         public T get() {             if (instance == null) {                 /*                         * Use a pretty coarse lock. We don't want to run into deadlocks                         * when two threads try to load circularly-dependent objects.                         * Maybe one of these days we will identify independent graphs of                         * objects and offer to load them in parallel.                         */                 synchronized (InjectorImpl.class) {                     if (instance == null) {                         instance = creator.get().                     }                 }             }             return instance.         }          @Override         public String toString() {             return String.format(Locale.ROOT, "%s[%s]", creator, SINGLETON).         }     }. }
false;public;0;4;;@Override public String toString() {     return "Scopes.SINGLETON". }
false;public;2;4;;@Override public <T> Provider<T> scope(Key<T> key, Provider<T> unscoped) {     return unscoped. }
false;public;0;4;;@Override public String toString() {     return "Scopes.NO_SCOPE". }
true;static;4;15;/**  * Scopes an internal factory.  */ ;/**  * Scopes an internal factory.  */ static <T> InternalFactory<? extends T> scope(Key<T> key, InjectorImpl injector, InternalFactory<? extends T> creator, Scoping scoping) {     if (scoping.isNoScope()) {         return creator.     }     Scope scope = scoping.getScopeInstance().     // TODO: use diamond operator once JI-9019884 is fixed     Provider<T> scoped = scope.scope(key, new ProviderToInternalFactoryAdapter<T>(injector, creator)).     return new InternalFactoryToProviderAdapter<>(Initializables.<Provider<? extends T>>of(scoped)). }
true;static;3;14;/**  * Replaces annotation scopes with instance scopes using the Injector's annotation-to-instance  * map. If the scope annotation has no corresponding instance, an error will be added and unscoped  * will be retuned.  */ ;/**  * Replaces annotation scopes with instance scopes using the Injector's annotation-to-instance  * map. If the scope annotation has no corresponding instance, an error will be added and unscoped  * will be retuned.  */ static Scoping makeInjectable(Scoping scoping, InjectorImpl injector, Errors errors) {     Class<? extends Annotation> scopeAnnotation = scoping.getScopeAnnotation().     if (scopeAnnotation == null) {         return scoping.     }     Scope scope = injector.state.getScope(scopeAnnotation).     if (scope != null) {         return Scoping.forInstance(scope).     }     errors.scopeNotFound(scopeAnnotation).     return Scoping.UNSCOPED. }
