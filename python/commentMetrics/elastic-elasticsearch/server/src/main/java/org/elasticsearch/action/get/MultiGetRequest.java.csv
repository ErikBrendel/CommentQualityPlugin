commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public String index() {     return this.index. }
false;public;0;4;;@Override public String[] indices() {     return new String[] { index }. }
false;public;0;4;;@Override public IndicesOptions indicesOptions() {     return GetRequest.INDICES_OPTIONS. }
false;public;1;4;;public Item index(String index) {     this.index = index.     return this. }
false;public;0;3;;public String type() {     return this.type. }
false;public;0;3;;public String id() {     return this.id. }
true;public;1;4;/**  * The routing associated with this document.  */ ;/**  * The routing associated with this document.  */ public Item routing(String routing) {     this.routing = routing.     return this. }
false;public;0;3;;public String routing() {     return this.routing. }
false;public;1;4;;public Item storedFields(String... fields) {     this.storedFields = fields.     return this. }
false;public;0;3;;public String[] storedFields() {     return this.storedFields. }
false;public;0;3;;public long version() {     return version. }
false;public;1;4;;public Item version(long version) {     this.version = version.     return this. }
false;public;0;3;;public VersionType versionType() {     return versionType. }
false;public;1;4;;public Item versionType(VersionType versionType) {     this.versionType = versionType.     return this. }
false;public;0;3;;public FetchSourceContext fetchSourceContext() {     return this.fetchSourceContext. }
true;public;1;4;/**  * Allows setting the {@link FetchSourceContext} for this request, controlling if and how _source should be returned.  */ ;/**  * Allows setting the {@link FetchSourceContext} for this request, controlling if and how _source should be returned.  */ public Item fetchSourceContext(FetchSourceContext fetchSourceContext) {     this.fetchSourceContext = fetchSourceContext.     return this. }
false;public,static;1;5;;public static Item readItem(StreamInput in) throws IOException {     Item item = new Item().     item.readFrom(in).     return item. }
false;public;1;15;;@Override public void readFrom(StreamInput in) throws IOException {     index = in.readString().     type = in.readOptionalString().     id = in.readString().     routing = in.readOptionalString().     if (in.getVersion().before(Version.V_7_0_0)) {         // _parent         in.readOptionalString().     }     storedFields = in.readOptionalStringArray().     version = in.readLong().     versionType = VersionType.fromValue(in.readByte()).     fetchSourceContext = in.readOptionalWriteable(FetchSourceContext::new). }
false;public;1;15;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeString(index).     out.writeOptionalString(type).     out.writeString(id).     out.writeOptionalString(routing).     if (out.getVersion().before(Version.V_7_0_0)) {         // _parent         out.writeOptionalString(null).     }     out.writeOptionalStringArray(storedFields).     out.writeLong(version).     out.writeByte(versionType.getValue()).     out.writeOptionalWriteable(fetchSourceContext). }
false;public;2;14;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.field(INDEX.getPreferredName(), index).     builder.field(TYPE.getPreferredName(), type).     builder.field(ID.getPreferredName(), id).     builder.field(ROUTING.getPreferredName(), routing).     builder.field(STORED_FIELDS.getPreferredName(), storedFields).     builder.field(VERSION.getPreferredName(), version).     builder.field(VERSION_TYPE.getPreferredName(), VersionType.toString(versionType)).     builder.field(SOURCE.getPreferredName(), fetchSourceContext).     builder.endObject().     return builder. }
false;public;1;19;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (!(o instanceof Item))         return false.     Item item = (Item) o.     if (version != item.version)         return false.     if (fetchSourceContext != null ? !fetchSourceContext.equals(item.fetchSourceContext) : item.fetchSourceContext != null)         return false.     if (!Arrays.equals(storedFields, item.storedFields))         return false.     if (!id.equals(item.id))         return false.     if (!index.equals(item.index))         return false.     if (routing != null ? !routing.equals(item.routing) : item.routing != null)         return false.     if (type != null ? !type.equals(item.type) : item.type != null)         return false.     if (versionType != item.versionType)         return false.     return true. }
false;public;0;12;;@Override public int hashCode() {     int result = index.hashCode().     result = 31 * result + (type != null ? type.hashCode() : 0).     result = 31 * result + id.hashCode().     result = 31 * result + (routing != null ? routing.hashCode() : 0).     result = 31 * result + (storedFields != null ? Arrays.hashCode(storedFields) : 0).     result = 31 * result + Long.hashCode(version).     result = 31 * result + versionType.hashCode().     result = 31 * result + (fetchSourceContext != null ? fetchSourceContext.hashCode() : 0).     return result. }
false;public;0;3;;public String toString() {     return Strings.toString(this). }
false;public;0;3;;public List<Item> getItems() {     return this.items. }
false;public;1;4;;public MultiGetRequest add(Item item) {     items.add(item).     return this. }
true;public;3;5;/**  * @deprecated Types are in the process of being removed, use  * {@link MultiGetRequest#add(String, String)} instead.  */ ;/**  * @deprecated Types are in the process of being removed, use  * {@link MultiGetRequest#add(String, String)} instead.  */ @Deprecated public MultiGetRequest add(String index, @Nullable String type, String id) {     items.add(new Item(index, type, id)).     return this. }
false;public;2;4;;public MultiGetRequest add(String index, String id) {     items.add(new Item(index, id)).     return this. }
false;public;0;18;;@Override public ActionRequestValidationException validate() {     ActionRequestValidationException validationException = null.     if (items.isEmpty()) {         validationException = ValidateActions.addValidationError("no documents to get", validationException).     } else {         for (int i = 0. i < items.size(). i++) {             Item item = items.get(i).             if (item.index() == null) {                 validationException = ValidateActions.addValidationError("index is missing for doc " + i, validationException).             }             if (item.id() == null) {                 validationException = ValidateActions.addValidationError("id is missing for doc " + i, validationException).             }         }     }     return validationException. }
true;public;1;4;/**  * Sets the preference to execute the search. Defaults to randomize across shards. Can be set to  * {@code _local} to prefer local shards or a custom value, which guarantees that the same order  * will be used across different requests.  */ ;/**  * Sets the preference to execute the search. Defaults to randomize across shards. Can be set to  * {@code _local} to prefer local shards or a custom value, which guarantees that the same order  * will be used across different requests.  */ public MultiGetRequest preference(String preference) {     this.preference = preference.     return this. }
false;public;0;3;;public String preference() {     return this.preference. }
false;public;0;3;;public boolean realtime() {     return this.realtime. }
false;public;1;5;;@Override public MultiGetRequest realtime(boolean realtime) {     this.realtime = realtime.     return this. }
false;public;0;3;;public boolean refresh() {     return this.refresh. }
false;public;1;4;;public MultiGetRequest refresh(boolean refresh) {     this.refresh = refresh.     return this. }
false;public;7;42;;public MultiGetRequest add(@Nullable String defaultIndex, @Nullable String defaultType, @Nullable String[] defaultFields, @Nullable FetchSourceContext defaultFetchSource, @Nullable String defaultRouting, XContentParser parser, boolean allowExplicitIndex) throws IOException {     Token token.     String currentFieldName = null.     if ((token = parser.nextToken()) != Token.START_OBJECT) {         final String message = String.format(Locale.ROOT, "unexpected token [%s], expected [%s]", token, Token.START_OBJECT).         throw new ParsingException(parser.getTokenLocation(), message).     }     while ((token = parser.nextToken()) != Token.END_OBJECT) {         if (token == Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token == Token.START_ARRAY) {             if ("docs".equals(currentFieldName)) {                 parseDocuments(parser, this.items, defaultIndex, defaultType, defaultFields, defaultFetchSource, defaultRouting, allowExplicitIndex).             } else if ("ids".equals(currentFieldName)) {                 parseIds(parser, this.items, defaultIndex, defaultType, defaultFields, defaultFetchSource, defaultRouting).             } else {                 final String message = String.format(Locale.ROOT, "unknown key [%s] for a %s, expected [docs] or [ids]", currentFieldName, token).                 throw new ParsingException(parser.getTokenLocation(), message).             }         } else {             final String message = String.format(Locale.ROOT, "unexpected token [%s], expected [%s] or [%s]", token, Token.FIELD_NAME, Token.START_ARRAY).             throw new ParsingException(parser.getTokenLocation(), message).         }     }     return this. }
false;private,static;8;116;;private static void parseDocuments(XContentParser parser, List<Item> items, @Nullable String defaultIndex, @Nullable String defaultType, @Nullable String[] defaultFields, @Nullable FetchSourceContext defaultFetchSource, @Nullable String defaultRouting, boolean allowExplicitIndex) throws IOException {     String currentFieldName = null.     Token token.     while ((token = parser.nextToken()) != Token.END_ARRAY) {         if (token != Token.START_OBJECT) {             throw new IllegalArgumentException("docs array element should include an object").         }         String index = defaultIndex.         String type = defaultType.         String id = null.         String routing = defaultRouting.         List<String> storedFields = null.         long version = Versions.MATCH_ANY.         VersionType versionType = VersionType.INTERNAL.         FetchSourceContext fetchSourceContext = FetchSourceContext.FETCH_SOURCE.         while ((token = parser.nextToken()) != Token.END_OBJECT) {             if (token == Token.FIELD_NAME) {                 currentFieldName = parser.currentName().             } else if (token.isValue()) {                 if (INDEX.match(currentFieldName, parser.getDeprecationHandler())) {                     if (!allowExplicitIndex) {                         throw new IllegalArgumentException("explicit index in multi get is not allowed").                     }                     index = parser.text().                 } else if (TYPE.match(currentFieldName, parser.getDeprecationHandler())) {                     type = parser.text().                 } else if (ID.match(currentFieldName, parser.getDeprecationHandler())) {                     id = parser.text().                 } else if (ROUTING.match(currentFieldName, parser.getDeprecationHandler())) {                     routing = parser.text().                 } else if (FIELDS.match(currentFieldName, parser.getDeprecationHandler())) {                     throw new ParsingException(parser.getTokenLocation(), "Unsupported field [fields] used, expected [stored_fields] instead").                 } else if (STORED_FIELDS.match(currentFieldName, parser.getDeprecationHandler())) {                     storedFields = new ArrayList<>().                     storedFields.add(parser.text()).                 } else if (VERSION.match(currentFieldName, parser.getDeprecationHandler())) {                     version = parser.longValue().                 } else if (VERSION_TYPE.match(currentFieldName, parser.getDeprecationHandler())) {                     versionType = VersionType.fromString(parser.text()).                 } else if (SOURCE.match(currentFieldName, parser.getDeprecationHandler())) {                     if (parser.isBooleanValue()) {                         fetchSourceContext = new FetchSourceContext(parser.booleanValue(), fetchSourceContext.includes(), fetchSourceContext.excludes()).                     } else if (token == Token.VALUE_STRING) {                         fetchSourceContext = new FetchSourceContext(fetchSourceContext.fetchSource(), new String[] { parser.text() }, fetchSourceContext.excludes()).                     } else {                         throw new ElasticsearchParseException("illegal type for _source: [{}]", token).                     }                 } else {                     throw new ElasticsearchParseException("failed to parse multi get request. unknown field [{}]", currentFieldName).                 }             } else if (token == Token.START_ARRAY) {                 if (FIELDS.match(currentFieldName, parser.getDeprecationHandler())) {                     throw new ParsingException(parser.getTokenLocation(), "Unsupported field [fields] used, expected [stored_fields] instead").                 } else if (STORED_FIELDS.match(currentFieldName, parser.getDeprecationHandler())) {                     storedFields = new ArrayList<>().                     while ((token = parser.nextToken()) != Token.END_ARRAY) {                         storedFields.add(parser.text()).                     }                 } else if (SOURCE.match(currentFieldName, parser.getDeprecationHandler())) {                     ArrayList<String> includes = new ArrayList<>().                     while ((token = parser.nextToken()) != Token.END_ARRAY) {                         includes.add(parser.text()).                     }                     fetchSourceContext = new FetchSourceContext(fetchSourceContext.fetchSource(), includes.toArray(Strings.EMPTY_ARRAY), fetchSourceContext.excludes()).                 }             } else if (token == Token.START_OBJECT) {                 if (SOURCE.match(currentFieldName, parser.getDeprecationHandler())) {                     List<String> currentList = null, includes = null, excludes = null.                     while ((token = parser.nextToken()) != Token.END_OBJECT) {                         if (token == Token.FIELD_NAME) {                             currentFieldName = parser.currentName().                             if ("includes".equals(currentFieldName) || "include".equals(currentFieldName)) {                                 currentList = includes != null ? includes : (includes = new ArrayList<>(2)).                             } else if ("excludes".equals(currentFieldName) || "exclude".equals(currentFieldName)) {                                 currentList = excludes != null ? excludes : (excludes = new ArrayList<>(2)).                             } else {                                 throw new ElasticsearchParseException("source definition may not contain [{}]", parser.text()).                             }                         } else if (token == Token.START_ARRAY) {                             while ((token = parser.nextToken()) != Token.END_ARRAY) {                                 currentList.add(parser.text()).                             }                         } else if (token.isValue()) {                             currentList.add(parser.text()).                         } else {                             throw new ElasticsearchParseException("unexpected token while parsing source settings").                         }                     }                     fetchSourceContext = new FetchSourceContext(fetchSourceContext.fetchSource(), includes == null ? Strings.EMPTY_ARRAY : includes.toArray(new String[includes.size()]), excludes == null ? Strings.EMPTY_ARRAY : excludes.toArray(new String[excludes.size()])).                 }             }         }         String[] aFields.         if (storedFields != null) {             aFields = storedFields.toArray(new String[storedFields.size()]).         } else {             aFields = defaultFields.         }         items.add(new Item(index, type, id).routing(routing).storedFields(aFields).version(version).versionType(versionType).fetchSourceContext(fetchSourceContext == FetchSourceContext.FETCH_SOURCE ? defaultFetchSource : fetchSourceContext)).     } }
false;public,static;7;12;;public static void parseIds(XContentParser parser, List<Item> items, @Nullable String defaultIndex, @Nullable String defaultType, @Nullable String[] defaultFields, @Nullable FetchSourceContext defaultFetchSource, @Nullable String defaultRouting) throws IOException {     Token token.     while ((token = parser.nextToken()) != Token.END_ARRAY) {         if (!token.isValue()) {             throw new IllegalArgumentException("ids array element should only contain ids").         }         items.add(new Item(defaultIndex, defaultType, parser.text()).storedFields(defaultFields).fetchSourceContext(defaultFetchSource).routing(defaultRouting)).     } }
false;public,static;2;3;;public static void parseIds(XContentParser parser, List<Item> items) throws IOException {     parseIds(parser, items, null, null, null, null, null). }
false;public;0;4;;@Override public Iterator<Item> iterator() {     return Collections.unmodifiableCollection(items).iterator(). }
false;public;1;13;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     preference = in.readOptionalString().     refresh = in.readBoolean().     realtime = in.readBoolean().     int size = in.readVInt().     items = new ArrayList<>(size).     for (int i = 0. i < size. i++) {         items.add(Item.readItem(in)).     } }
false;public;1;12;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeOptionalString(preference).     out.writeBoolean(refresh).     out.writeBoolean(realtime).     out.writeVInt(items.size()).     for (Item item : items) {         item.writeTo(out).     } }
false;public;2;11;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.startArray(DOCS.getPreferredName()).     for (Item item : items) {         builder.value(item).     }     builder.endArray().     builder.endObject().     return builder. }
