commented;modifiers;parameterAmount;loc;comment;code
true;public;0;4;/**  * Reset the sequence detection logic to avoid any continuation of the  * immediately previous bytes. A minimum of dupSequenceSize bytes need to be  * added before any new duplicate sequences will be reported.  * Hit counts are not reset by calling this method.  */ ;/**  * Reset the sequence detection logic to avoid any continuation of the  * immediately previous bytes. A minimum of dupSequenceSize bytes need to be  * added before any new duplicate sequences will be reported.  * Hit counts are not reset by calling this method.  */ public void startNewSequence() {     sequenceBufferFilled = false.     nextFreePos = 0. }
true;public;1;36;/**  * Add a byte to the sequence.  * @param b  *            the next byte in a sequence  * @return number of times this byte and the preceding 6 bytes have been  *         seen before as a sequence (only counts up to 255)  */ ;/**  * Add a byte to the sequence.  * @param b  *            the next byte in a sequence  * @return number of times this byte and the preceding 6 bytes have been  *         seen before as a sequence (only counts up to 255)  */ public short addByte(byte b) {     // Add latest byte to circular buffer     sequenceBuffer[nextFreePos] = b.     nextFreePos++.     if (nextFreePos >= sequenceBuffer.length) {         nextFreePos = 0.         sequenceBufferFilled = true.     }     if (sequenceBufferFilled == false) {         return 0.     }     TreeNode node = root.     // replay updated sequence of bytes represented in the circular     // buffer starting from the tail     int p = nextFreePos.     // The first tier of nodes are addressed using individual bytes from the     // sequence     node = node.add(sequenceBuffer[p], 0).     p = nextBufferPos(p).     node = node.add(sequenceBuffer[p], 1).     p = nextBufferPos(p).     node = node.add(sequenceBuffer[p], 2).     // The final 3 bytes in the sequence are represented in an int     // where the 4th byte will contain a hit count.     p = nextBufferPos(p).     int sequence = 0xFF & sequenceBuffer[p].     p = nextBufferPos(p).     sequence = sequence << 8 | (0xFF & sequenceBuffer[p]).     p = nextBufferPos(p).     sequence = sequence << 8 | (0xFF & sequenceBuffer[p]).     return (short) (node.add(sequence << 8) - 1). }
false;private;1;7;;private int nextBufferPos(int p) {     p++.     if (p >= sequenceBuffer.length) {         p = 0.     }     return p. }
false;public,abstract;2;1;;public abstract TreeNode add(byte b, int depth).
true;public,abstract;1;1;/**  * @param byteSequence  *            a sequence of bytes encoded as an int  * @return the number of times the full sequence has been seen (counting  *         up to a maximum of 32767).  */ ;/**  * @param byteSequence  *            a sequence of bytes encoded as an int  * @return the number of times the full sequence has been seen (counting  *         up to a maximum of 32767).  */ public abstract short add(int byteSequence).
false;public;2;21;;public TreeNode add(byte b, int depth) {     if (children == null) {         children = new TreeNode[256].         bytesAllocated += (RamUsageEstimator.NUM_BYTES_OBJECT_REF * 256).     }     int bIndex = 0xFF & b.     TreeNode node = children[bIndex].     if (node == null) {         if (depth <= 1) {             // Depths 0 and 1 use RootTreeNode impl and create             // RootTreeNodeImpl children             node = new RootTreeNode(b, this, depth).         } else {             // Deeper-level nodes are less visited but more numerous             // so use a more space-friendly data structure             node = new LightweightTreeNode(b, this, depth).         }         children[bIndex] = node.     }     return node. }
false;public;1;4;;@Override public short add(int byteSequence) {     throw new UnsupportedOperationException("Root nodes do not support byte sequences encoded as integers"). }
false;public;1;33;;@Override public short add(int byteSequence) {     if (children == null) {         // Create array adding new child with the byte sequence combined with hitcount of 1.         // Most nodes at this level we expect to have only 1 child so we start with the         // smallest possible child array.         children = new int[1].         bytesAllocated += RamUsageEstimator.NUM_BYTES_ARRAY_HEADER + Integer.BYTES.         children[0] = byteSequence + 1.         return 1.     }     // Find existing child and if discovered increment count     for (int i = 0. i < children.length. i++) {         int child = children[i].         if (byteSequence == (child & 0xFFFFFF00)) {             int hitCount = child & 0xFF.             if (hitCount < MAX_HIT_COUNT) {                 children[i]++.             }             return (short) (hitCount + 1).         }     }     // Grow array adding new child     int[] newChildren = new int[children.length + 1].     bytesAllocated += Integer.BYTES.     System.arraycopy(children, 0, newChildren, 0, children.length).     children = newChildren.     // Combine the byte sequence with a hit count of 1 into an int.     children[newChildren.length - 1] = byteSequence + 1.     nodesResizedByDepth++.     return 1. }
false;public;2;4;;@Override public TreeNode add(byte b, int depth) {     throw new UnsupportedOperationException("Leaf nodes do not take byte sequences"). }
false;public,final;0;3;;public final long getEstimatedSizeInBytes() {     return bytesAllocated. }
true;public;0;3;/**  * @return Performance info - the number of nodes allocated at each depth  */ ;/**  * @return Performance info - the number of nodes allocated at each depth  */ public int[] getNodesAllocatedByDepth() {     return nodesAllocatedByDepth.clone(). }
true;public;0;3;/**  * @return Performance info - the number of resizing of children arrays, at  *         each depth  */ ;/**  * @return Performance info - the number of resizing of children arrays, at  *         each depth  */ public int getNodesResizedByDepth() {     return nodesResizedByDepth. }
