commented;modifiers;parameterAmount;loc;comment;code
true;public;1;10;/**  * Get the value that is associated with <code>key</code> or null if <code>key</code>  * was not present in the hash table.  */ ;/**  * Get the value that is associated with <code>key</code> or null if <code>key</code>  * was not present in the hash table.  */ public T get(long key) {     for (long i = slot(hash(key), mask). . i = nextSlot(i, mask)) {         final T value = values.get(i).         if (value == null) {             return null.         } else if (keys.get(i) == key) {             return value.         }     } }
true;public;2;8;/**  * Put this new (key, value) pair into this hash table and return the value  * that was previously associated with <code>key</code> or null in case of  * an insertion.  */ ;/**  * Put this new (key, value) pair into this hash table and return the value  * that was previously associated with <code>key</code> or null in case of  * an insertion.  */ public T put(long key, T value) {     if (size >= maxSize) {         assert size == maxSize.         grow().     }     assert size < maxSize.     return set(key, value). }
true;public;1;17;/**  * Remove the entry which has this key in the hash table and return the  * associated value or null if there was no entry associated with this key.  */ ;/**  * Remove the entry which has this key in the hash table and return the  * associated value or null if there was no entry associated with this key.  */ public T remove(long key) {     for (long i = slot(hash(key), mask). . i = nextSlot(i, mask)) {         final T previous = values.set(i, null).         if (previous == null) {             return null.         } else if (keys.get(i) == key) {             --size.             for (long j = nextSlot(i, mask). used(j). j = nextSlot(j, mask)) {                 removeAndAdd(j).             }             return previous.         } else {             // repair and continue             values.set(i, previous).         }     } }
false;private;2;20;;private T set(long key, T value) {     if (value == null) {         throw new IllegalArgumentException("Null values are not supported").     }     for (long i = slot(hash(key), mask). . i = nextSlot(i, mask)) {         final T previous = values.set(i, value).         if (previous == null) {             // slot was free             keys.set(i, key).             ++size.             return null.         } else if (key == keys.get(i)) {             // we just updated the value             return previous.         } else {             // not the right key, repair and continue             values.set(i, previous).         }     } }
false;public;0;17;;@Override public boolean hasNext() {     if (!cached) {         while (true) {             ++cursor.index.             if (cursor.index >= capacity()) {                 break.             } else if (used(cursor.index)) {                 cursor.key = keys.get(cursor.index).                 cursor.value = values.get(cursor.index).                 break.             }         }         cached = true.     }     return cursor.index < capacity(). }
false;public;0;8;;@Override public Cursor<T> next() {     if (!hasNext()) {         throw new NoSuchElementException().     }     cached = false.     return cursor. }
false;public;0;4;;@Override public void remove() {     throw new UnsupportedOperationException(). }
false;public;0;46;;@Override public Iterator<Cursor<T>> iterator() {     return new Iterator<Cursor<T>>() {          boolean cached.          final Cursor<T> cursor.          {             cursor = new Cursor<>().             cursor.index = -1.             cached = false.         }          @Override         public boolean hasNext() {             if (!cached) {                 while (true) {                     ++cursor.index.                     if (cursor.index >= capacity()) {                         break.                     } else if (used(cursor.index)) {                         cursor.key = keys.get(cursor.index).                         cursor.value = values.get(cursor.index).                         break.                     }                 }                 cached = true.             }             return cursor.index < capacity().         }          @Override         public Cursor<T> next() {             if (!hasNext()) {                 throw new NoSuchElementException().             }             cached = false.             return cursor.         }          @Override         public void remove() {             throw new UnsupportedOperationException().         }     }. }
false;public;0;4;;@Override public void close() {     Releasables.close(keys, values). }
false;protected;1;5;;@Override protected void resize(long capacity) {     keys = bigArrays.resize(keys, capacity).     values = bigArrays.resize(values, capacity). }
false;protected;1;4;;@Override protected boolean used(long bucket) {     return values.get(bucket) != null. }
false;protected;1;8;;@Override protected void removeAndAdd(long index) {     final long key = keys.get(index).     final T value = values.set(index, null).     --size.     final T removed = set(key, value).     assert removed == null. }
