commented;modifiers;parameterAmount;loc;comment;code
false;public;1;16;;public void add(Stats stats) {     indexCount += stats.indexCount.     indexTimeInMillis += stats.indexTimeInMillis.     indexCurrent += stats.indexCurrent.     indexFailedCount += stats.indexFailedCount.     deleteCount += stats.deleteCount.     deleteTimeInMillis += stats.deleteTimeInMillis.     deleteCurrent += stats.deleteCurrent.     noopUpdateCount += stats.noopUpdateCount.     throttleTimeInMillis += stats.throttleTimeInMillis.     if (isThrottled != stats.isThrottled) {         // When combining if one is throttled set result to throttled.         isThrottled = true.     } }
true;public;0;1;/**  * The total number of indexing operations  */ ;/**  * The total number of indexing operations  */ public long getIndexCount() {     return indexCount. }
true;public;0;1;/**  * The number of failed indexing operations  */ ;/**  * The number of failed indexing operations  */ public long getIndexFailedCount() {     return indexFailedCount. }
true;public;0;1;/**  * The total amount of time spend on executing index operations.  */ ;/**  * The total amount of time spend on executing index operations.  */ public TimeValue getIndexTime() {     return new TimeValue(indexTimeInMillis). }
true;public;0;1;/**  * Returns the currently in-flight indexing operations.  */ ;/**  * Returns the currently in-flight indexing operations.  */ public long getIndexCurrent() {     return indexCurrent. }
true;public;0;3;/**  * Returns the number of delete operation executed  */ ;/**  * Returns the number of delete operation executed  */ public long getDeleteCount() {     return deleteCount. }
true;public;0;1;/**  * Returns if the index is under merge throttling control  */ ;/**  * Returns if the index is under merge throttling control  */ public boolean isThrottled() {     return isThrottled. }
true;public;0;1;/**  * Gets the amount of time in a TimeValue that the index has been under merge throttling control  */ ;/**  * Gets the amount of time in a TimeValue that the index has been under merge throttling control  */ public TimeValue getThrottleTime() {     return new TimeValue(throttleTimeInMillis). }
true;public;0;1;/**  * The total amount of time spend on executing delete operations.  */ ;/**  * The total amount of time spend on executing delete operations.  */ public TimeValue getDeleteTime() {     return new TimeValue(deleteTimeInMillis). }
true;public;0;3;/**  * Returns the currently in-flight delete operations  */ ;/**  * Returns the currently in-flight delete operations  */ public long getDeleteCurrent() {     return deleteCurrent. }
false;public;0;3;;public long getNoopUpdateCount() {     return noopUpdateCount. }
false;public,static;1;5;;public static Stats readStats(StreamInput in) throws IOException {     Stats stats = new Stats().     stats.readFrom(in).     return stats. }
false;public;1;13;;@Override public void readFrom(StreamInput in) throws IOException {     indexCount = in.readVLong().     indexTimeInMillis = in.readVLong().     indexCurrent = in.readVLong().     indexFailedCount = in.readVLong().     deleteCount = in.readVLong().     deleteTimeInMillis = in.readVLong().     deleteCurrent = in.readVLong().     noopUpdateCount = in.readVLong().     isThrottled = in.readBoolean().     throttleTimeInMillis = in.readLong(). }
false;public;1;14;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeVLong(indexCount).     out.writeVLong(indexTimeInMillis).     out.writeVLong(indexCurrent).     out.writeVLong(indexFailedCount).     out.writeVLong(deleteCount).     out.writeVLong(deleteTimeInMillis).     out.writeVLong(deleteCurrent).     out.writeVLong(noopUpdateCount).     out.writeBoolean(isThrottled).     out.writeLong(throttleTimeInMillis). }
false;public;2;17;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.field(Fields.INDEX_TOTAL, indexCount).     builder.humanReadableField(Fields.INDEX_TIME_IN_MILLIS, Fields.INDEX_TIME, getIndexTime()).     builder.field(Fields.INDEX_CURRENT, indexCurrent).     builder.field(Fields.INDEX_FAILED, indexFailedCount).     builder.field(Fields.DELETE_TOTAL, deleteCount).     builder.humanReadableField(Fields.DELETE_TIME_IN_MILLIS, Fields.DELETE_TIME, getDeleteTime()).     builder.field(Fields.DELETE_CURRENT, deleteCurrent).     builder.field(Fields.NOOP_UPDATE_TOTAL, noopUpdateCount).     builder.field(Fields.IS_THROTTLED, isThrottled).     builder.humanReadableField(Fields.THROTTLED_TIME_IN_MILLIS, Fields.THROTTLED_TIME, getThrottleTime()).     return builder. }
false;public;1;3;;public void add(IndexingStats indexingStats) {     add(indexingStats, true). }
false;public;2;19;;public void add(IndexingStats indexingStats, boolean includeTypes) {     if (indexingStats == null) {         return.     }     addTotals(indexingStats).     if (includeTypes && indexingStats.typeStats != null && !indexingStats.typeStats.isEmpty()) {         if (typeStats == null) {             typeStats = new HashMap<>(indexingStats.typeStats.size()).         }         for (Map.Entry<String, Stats> entry : indexingStats.typeStats.entrySet()) {             Stats stats = typeStats.get(entry.getKey()).             if (stats == null) {                 typeStats.put(entry.getKey(), entry.getValue()).             } else {                 stats.add(entry.getValue()).             }         }     } }
false;public;1;6;;public void addTotals(IndexingStats indexingStats) {     if (indexingStats == null) {         return.     }     totalStats.add(indexingStats.totalStats). }
false;public;0;3;;public Stats getTotal() {     return this.totalStats. }
false;public;0;4;;@Nullable public Map<String, Stats> getTypeStats() {     return this.typeStats. }
false;public;2;16;;@Override public XContentBuilder toXContent(XContentBuilder builder, ToXContent.Params params) throws IOException {     builder.startObject(Fields.INDEXING).     totalStats.toXContent(builder, params).     if (typeStats != null && !typeStats.isEmpty()) {         builder.startObject(Fields.TYPES).         for (Map.Entry<String, Stats> entry : typeStats.entrySet()) {             builder.startObject(entry.getKey()).             entry.getValue().toXContent(builder, params).             builder.endObject().         }         builder.endObject().     }     builder.endObject().     return builder. }
false;public;1;7;;@Override public void readFrom(StreamInput in) throws IOException {     totalStats = Stats.readStats(in).     if (in.readBoolean()) {         typeStats = in.readMap(StreamInput::readString, Stats::readStats).     } }
false;public;1;10;;@Override public void writeTo(StreamOutput out) throws IOException {     totalStats.writeTo(out).     if (typeStats == null || typeStats.isEmpty()) {         out.writeBoolean(false).     } else {         out.writeBoolean(true).         out.writeMap(typeStats, StreamOutput::writeString, (stream, stats) -> stats.writeTo(stream)).     } }
