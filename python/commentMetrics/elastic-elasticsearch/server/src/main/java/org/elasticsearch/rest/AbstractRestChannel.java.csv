commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public XContentBuilder newBuilder() throws IOException {     return newBuilder(request.getXContentType(), true). }
false;public;0;5;;@Override public XContentBuilder newErrorBuilder() throws IOException {     // Disable filtering when building error responses     return newBuilder(request.getXContentType(), false). }
true;public;2;34;/**  * Creates a new {@link XContentBuilder} for a response to be sent using this channel. The builder's type is determined by the following  * logic. If the request has a format parameter that will be used to attempt to map to an {@link XContentType}. If there is no format  * parameter, the HTTP Accept header is checked to see if it can be matched to a {@link XContentType}. If this first attempt to map  * fails, the request content type will be used if the value is not {@code null}. if the value is {@code null} the output format falls  * back to JSON.  */ ;/**  * Creates a new {@link XContentBuilder} for a response to be sent using this channel. The builder's type is determined by the following  * logic. If the request has a format parameter that will be used to attempt to map to an {@link XContentType}. If there is no format  * parameter, the HTTP Accept header is checked to see if it can be matched to a {@link XContentType}. If this first attempt to map  * fails, the request content type will be used if the value is not {@code null}. if the value is {@code null} the output format falls  * back to JSON.  */ @Override public XContentBuilder newBuilder(@Nullable XContentType requestContentType, boolean useFiltering) throws IOException {     // try to determine the response content type from the media type or the format query string parameter, with the format parameter     // taking precedence over the Accept header     XContentType responseContentType = XContentType.fromMediaTypeOrFormat(format).     if (responseContentType == null) {         if (requestContentType != null) {             // if there was a parsed content-type for the incoming request use that since no format was specified using the query             // string parameter or the HTTP Accept header             responseContentType = requestContentType.         } else {             // default to JSON output when all else fails             responseContentType = XContentType.JSON.         }     }     Set<String> includes = Collections.emptySet().     Set<String> excludes = Collections.emptySet().     if (useFiltering) {         Set<String> filters = Strings.tokenizeByCommaToSet(filterPath).         includes = filters.stream().filter(INCLUDE_FILTER).collect(toSet()).         excludes = filters.stream().filter(EXCLUDE_FILTER).map(f -> f.substring(1)).collect(toSet()).     }     OutputStream unclosableOutputStream = Streams.flushOnCloseStream(bytesOutput()).     XContentBuilder builder = new XContentBuilder(XContentFactory.xContent(responseContentType), unclosableOutputStream, includes, excludes).     if (pretty) {         builder.prettyPrint().lfAtEnd().     }     builder.humanReadable(human).     return builder. }
true;public,final;0;9;/**  * A channel level bytes output that can be reused. The bytes output is lazily instantiated  * by a call to {@link #newBytesOutput()}. Once the stream is created, it gets reset on each  * call to this method.  */ ;/**  * A channel level bytes output that can be reused. The bytes output is lazily instantiated  * by a call to {@link #newBytesOutput()}. Once the stream is created, it gets reset on each  * call to this method.  */ @Override public final BytesStreamOutput bytesOutput() {     if (bytesOut == null) {         bytesOut = newBytesOutput().     } else {         bytesOut.reset().     }     return bytesOut. }
true;protected,final;0;3;/**  * An accessor to the raw value of the channel bytes output. This method will not instantiate  * a new stream if one does not exist and this method will not reset the stream.  */ ;/**  * An accessor to the raw value of the channel bytes output. This method will not instantiate  * a new stream if one does not exist and this method will not reset the stream.  */ protected final BytesStreamOutput bytesOutputOrNull() {     return bytesOut. }
false;protected;0;3;;protected BytesStreamOutput newBytesOutput() {     return new BytesStreamOutput(). }
false;public;0;4;;@Override public RestRequest request() {     return this.request. }
false;public;0;4;;@Override public boolean detailedErrorsEnabled() {     return detailedErrorsEnabled. }
