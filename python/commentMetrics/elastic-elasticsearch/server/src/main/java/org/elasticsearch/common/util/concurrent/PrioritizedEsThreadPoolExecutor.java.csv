commented;modifiers;parameterAmount;loc;comment;code
false;public;0;6;;public Pending[] getPending() {     List<Pending> pending = new ArrayList<>().     addPending(new ArrayList<>(current), pending, true).     addPending(new ArrayList<>(getQueue()), pending, false).     return pending.toArray(new Pending[pending.size()]). }
false;public;0;5;;public int getNumberOfPendingTasks() {     int size = current.size().     size += getQueue().size().     return size. }
true;public;0;16;/**  * Returns the waiting time of the first task in the queue  */ ;/**  * Returns the waiting time of the first task in the queue  */ public TimeValue getMaxTaskWaitTime() {     if (getQueue().size() == 0) {         return NO_WAIT_TIME_VALUE.     }     long now = System.nanoTime().     long oldestCreationDateInNanos = now.     for (Runnable queuedRunnable : getQueue()) {         if (queuedRunnable instanceof PrioritizedRunnable) {             oldestCreationDateInNanos = Math.min(oldestCreationDateInNanos, ((PrioritizedRunnable) queuedRunnable).getCreationDateInNanos()).         }     }     return TimeValue.timeValueNanos(now - oldestCreationDateInNanos). }
false;private;3;21;;private void addPending(List<Runnable> runnables, List<Pending> pending, boolean executing) {     for (Runnable runnable : runnables) {         if (runnable instanceof TieBreakingPrioritizedRunnable) {             TieBreakingPrioritizedRunnable t = (TieBreakingPrioritizedRunnable) runnable.             Runnable innerRunnable = t.runnable.             if (innerRunnable != null) {                 /**                  * innerRunnable can be null if task is finished but not removed from executor yet,                  * see {@link TieBreakingPrioritizedRunnable#run} and {@link TieBreakingPrioritizedRunnable#runAndClean}                  */                 pending.add(new Pending(super.unwrap(innerRunnable), t.priority(), t.insertionOrder, executing)).             }         } else if (runnable instanceof PrioritizedFutureTask) {             PrioritizedFutureTask t = (PrioritizedFutureTask) runnable.             Object task = t.task.             if (t.task instanceof Runnable) {                 task = super.unwrap((Runnable) t.task).             }             pending.add(new Pending(task, t.priority, t.insertionOrder, executing)).         }     } }
false;protected;2;4;;@Override protected void beforeExecute(Thread t, Runnable r) {     current.add(r). }
false;protected;2;5;;@Override protected void afterExecute(Runnable r, Throwable t) {     super.afterExecute(r, t).     current.remove(r). }
false;public;3;13;;public void execute(Runnable command, final TimeValue timeout, final Runnable timeoutCallback) {     command = wrapRunnable(command).     execute(command).     if (timeout.nanos() >= 0) {         if (command instanceof TieBreakingPrioritizedRunnable) {             ((TieBreakingPrioritizedRunnable) command).scheduleTimeout(timer, timeoutCallback, timeout).         } else {             // and passed it to execute, which doesn't make much sense             throw new UnsupportedOperationException("Execute with timeout is not supported for future tasks").         }     } }
false;protected;1;14;;@Override protected Runnable wrapRunnable(Runnable command) {     if (command instanceof PrioritizedRunnable) {         if (command instanceof TieBreakingPrioritizedRunnable) {             return command.         }         Priority priority = ((PrioritizedRunnable) command).priority().         return new TieBreakingPrioritizedRunnable(super.wrapRunnable(command), priority, insertionOrder.incrementAndGet()).     } else if (command instanceof PrioritizedFutureTask) {         return command.     } else {         // it might be a callable wrapper...         return new TieBreakingPrioritizedRunnable(super.wrapRunnable(command), Priority.NORMAL, insertionOrder.incrementAndGet()).     } }
false;protected;1;8;;@Override protected Runnable unwrap(Runnable runnable) {     if (runnable instanceof WrappedRunnable) {         return super.unwrap(((WrappedRunnable) runnable).unwrap()).     } else {         return super.unwrap(runnable).     } }
false;protected;2;8;;@Override protected <T> RunnableFuture<T> newTaskFor(Runnable runnable, T value) {     if (!(runnable instanceof PrioritizedRunnable)) {         runnable = PrioritizedRunnable.wrap(runnable, Priority.NORMAL).     }     Priority priority = ((PrioritizedRunnable) runnable).priority().     return new PrioritizedFutureTask<>(runnable, priority, value, insertionOrder.incrementAndGet()). }
false;protected;1;7;;@Override protected <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {     if (!(callable instanceof PrioritizedCallable)) {         callable = PrioritizedCallable.wrap(callable, Priority.NORMAL).     }     return new PrioritizedFutureTask<>((PrioritizedCallable) callable, insertionOrder.incrementAndGet()). }
false;public;0;10;;@Override public void run() {     synchronized (this) {         // make the task as stared. This is needed for synchronization with the timeout handling         // see  #scheduleTimeout()         started = true.         FutureUtils.cancel(timeoutFuture).     }     runAndClean(runnable). }
false;public;1;8;;@Override public int compareTo(PrioritizedRunnable pr) {     int res = super.compareTo(pr).     if (res != 0 || !(pr instanceof TieBreakingPrioritizedRunnable)) {         return res.     }     return insertionOrder < ((TieBreakingPrioritizedRunnable) pr).insertionOrder ? -1 : 1. }
false;public;0;6;;@Override public void run() {     if (remove(TieBreakingPrioritizedRunnable.this)) {         runAndClean(timeoutCallback).     } }
false;public;3;17;;public void scheduleTimeout(ScheduledExecutorService timer, final Runnable timeoutCallback, TimeValue timeValue) {     synchronized (this) {         if (timeoutFuture != null) {             throw new IllegalStateException("scheduleTimeout may only be called once").         }         if (started == false) {             timeoutFuture = timer.schedule(new Runnable() {                  @Override                 public void run() {                     if (remove(TieBreakingPrioritizedRunnable.this)) {                         runAndClean(timeoutCallback).                     }                 }             }, timeValue.nanos(), TimeUnit.NANOSECONDS).         }     } }
true;private;1;8;/**  * Timeout callback might remain in the timer scheduling queue for some time and it might hold  * the pointers to other objects. As a result it's possible to run out of memory if a large number of  * tasks are executed  */ ;/**  * Timeout callback might remain in the timer scheduling queue for some time and it might hold  * the pointers to other objects. As a result it's possible to run out of memory if a large number of  * tasks are executed  */ private void runAndClean(Runnable run) {     try {         run.run().     } finally {         runnable = null.         timeoutFuture = null.     } }
false;public;0;4;;@Override public Runnable unwrap() {     return runnable. }
false;public;1;8;;@Override public int compareTo(PrioritizedFutureTask pft) {     int res = priority.compareTo(pft.priority).     if (res != 0) {         return res.     }     return insertionOrder < pft.insertionOrder ? -1 : 1. }
