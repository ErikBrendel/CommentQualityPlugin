commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;4;/**  * Returns true if the given annotation is retained at runtime.  */ ;/**  * Returns true if the given annotation is retained at runtime.  */ public static boolean isRetainedAtRuntime(Class<? extends Annotation> annotationType) {     Retention retention = annotationType.getAnnotation(Retention.class).     return retention != null && retention.value() == RetentionPolicy.RUNTIME. }
true;public,static;2;4;/**  * Returns the scope annotation on {@code type}, or null if none is specified.  */ ;/**  * Returns the scope annotation on {@code type}, or null if none is specified.  */ public static Class<? extends Annotation> findScopeAnnotation(Errors errors, Class<?> implementation) {     return findScopeAnnotation(errors, implementation.getAnnotations()). }
true;public,static;2;15;/**  * Returns the scoping annotation, or null if there isn't one.  */ ;/**  * Returns the scoping annotation, or null if there isn't one.  */ public static Class<? extends Annotation> findScopeAnnotation(Errors errors, Annotation[] annotations) {     Class<? extends Annotation> found = null.     for (Annotation annotation : annotations) {         if (annotation.annotationType().getAnnotation(ScopeAnnotation.class) != null) {             if (found != null) {                 errors.duplicateScopeAnnotations(found, annotation.annotationType()).             } else {                 found = annotation.annotationType().             }         }     }     return found. }
false;public,static;1;3;;public static boolean isScopeAnnotation(Class<? extends Annotation> annotationType) {     return annotationType.getAnnotation(ScopeAnnotation.class) != null. }
true;public,static;3;11;/**  * Adds an error if there is a misplaced annotations on {@code type}. Scoping  * annotations are not allowed on abstract classes or interfaces.  */ ;/**  * Adds an error if there is a misplaced annotations on {@code type}. Scoping  * annotations are not allowed on abstract classes or interfaces.  */ public static void checkForMisplacedScopeAnnotations(Class<?> type, Object source, Errors errors) {     if (Classes.isConcrete(type)) {         return.     }     Class<? extends Annotation> scopeAnnotation = findScopeAnnotation(errors, type).     if (scopeAnnotation != null) {         errors.withSource(type).scopeAnnotationOnAbstractType(scopeAnnotation, type, source).     } }
true;public,static;4;7;/**  * Gets a key for the given type, member and annotations.  */ ;/**  * Gets a key for the given type, member and annotations.  */ public static Key<?> getKey(TypeLiteral<?> type, Member member, Annotation[] annotations, Errors errors) throws ErrorsException {     int numErrorsBefore = errors.size().     Annotation found = findBindingAnnotation(errors, member, annotations).     errors.throwIfNewErrors(numErrorsBefore).     return found == null ? Key.get(type) : Key.get(type, found). }
true;public,static;3;17;/**  * Returns the binding annotation on {@code member}, or null if there isn't one.  */ ;/**  * Returns the binding annotation on {@code member}, or null if there isn't one.  */ public static Annotation findBindingAnnotation(Errors errors, Member member, Annotation[] annotations) {     Annotation found = null.     for (Annotation annotation : annotations) {         if (annotation.annotationType().getAnnotation(BindingAnnotation.class) != null) {             if (found != null) {                 errors.duplicateBindingAnnotations(member, found.annotationType(), annotation.annotationType()).             } else {                 found = annotation.             }         }     }     return found. }
