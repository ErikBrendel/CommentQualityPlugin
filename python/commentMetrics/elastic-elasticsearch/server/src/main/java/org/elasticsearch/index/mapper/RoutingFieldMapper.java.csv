commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;public Builder required(boolean required) {     this.required = required.     return builder. }
false;public;1;4;;@Override public RoutingFieldMapper build(BuilderContext context) {     return new RoutingFieldMapper(fieldType, required, context.indexSettings()). }
false;public;3;15;;@Override public MetadataFieldMapper.Builder<?, ?> parse(String name, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {     Builder builder = new Builder(parserContext.mapperService().fullName(NAME)).     for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(). iterator.hasNext(). ) {         Map.Entry<String, Object> entry = iterator.next().         String fieldName = entry.getKey().         Object fieldNode = entry.getValue().         if (fieldName.equals("required")) {             builder.required(XContentMapValues.nodeBooleanValue(fieldNode, name + ".required")).             iterator.remove().         }     }     return builder. }
false;public;2;10;;@Override public MetadataFieldMapper getDefault(MappedFieldType fieldType, ParserContext context) {     final Settings indexSettings = context.mapperService().getIndexSettings().getSettings().     if (fieldType != null) {         return new RoutingFieldMapper(indexSettings, fieldType).     } else {         return parse(NAME, Collections.emptyMap(), context).build(new BuilderContext(indexSettings, new ContentPath(1))).     } }
false;public;0;4;;@Override public MappedFieldType clone() {     return new RoutingFieldType(this). }
false;public;0;4;;@Override public String typeName() {     return CONTENT_TYPE. }
false;public;1;4;;@Override public Query existsQuery(QueryShardContext context) {     return new TermQuery(new Term(FieldNamesFieldMapper.NAME, name())). }
false;public;0;3;;public void markAsRequired() {     this.required = true. }
false;public;0;3;;public boolean required() {     return this.required. }
false;public;1;4;;@Override public void preParse(ParseContext context) throws IOException {     super.parse(context). }
false;public;1;6;;@Override public void parse(ParseContext context) throws IOException { // no need ot parse here, we either get the routing in the sourceToParse // or we don't have routing, if we get it in sourceToParse, we process it in preParse // which will always be called }
false;protected;2;10;;@Override protected void parseCreateField(ParseContext context, List<IndexableField> fields) throws IOException {     String routing = context.sourceToParse().routing().     if (routing != null) {         if (fieldType().indexOptions() != IndexOptions.NONE || fieldType().stored()) {             fields.add(new Field(fieldType().name(), routing, fieldType())).             createFieldNamesField(context, fields).         }     } }
false;protected;0;4;;@Override protected String contentType() {     return CONTENT_TYPE. }
false;public;2;15;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     boolean includeDefaults = params.paramAsBoolean("include_defaults", false).     // if all are defaults, no sense to write it at all     if (!includeDefaults && required == Defaults.REQUIRED) {         return builder.     }     builder.startObject(CONTENT_TYPE).     if (includeDefaults || required != Defaults.REQUIRED) {         builder.field("required", required).     }     builder.endObject().     return builder. }
false;protected;1;4;;@Override protected void doMerge(Mapper mergeWith) { // do nothing here, no merging, but also no exception }
