commented;modifiers;parameterAmount;loc;comment;code
true;;1;4;/**  * Add a search response to the list of responses to be merged together into one.  * Merges currently happen at once when all responses are available and {@link #getMergedResponse(Clusters)} )} is called.  * That may change in the future as it's possible to introduce incremental merges as responses come in if necessary.  */ ;/**  * Add a search response to the list of responses to be merged together into one.  * Merges currently happen at once when all responses are available and {@link #getMergedResponse(Clusters)} )} is called.  * That may change in the future as it's possible to introduce incremental merges as responses come in if necessary.  */ void add(SearchResponse searchResponse) {     assert searchResponse.getScrollId() == null : "merging scroll results is not supported".     searchResponses.add(searchResponse). }
false;;0;3;;int numResponses() {     return searchResponses.size(). }
true;;1;78;/**  * Returns the merged response. To be called once all responses have been added through {@link #add(SearchResponse)}  * so that all responses are merged into a single one.  */ ;/**  * Returns the merged response. To be called once all responses have been added through {@link #add(SearchResponse)}  * so that all responses are merged into a single one.  */ SearchResponse getMergedResponse(Clusters clusters) {     // we end up calling merge without anything to merge, we just return an empty search response     if (searchResponses.size() == 0) {         return SearchResponse.empty(searchTimeProvider::buildTookInMillis, clusters).     }     int totalShards = 0.     int skippedShards = 0.     int successfulShards = 0.     // the current reduce phase counts as one     int numReducePhases = 1.     List<ShardSearchFailure> failures = new ArrayList<>().     Map<String, ProfileShardResult> profileResults = new HashMap<>().     List<InternalAggregations> aggs = new ArrayList<>().     Map<ShardIdAndClusterAlias, Integer> shards = new TreeMap<>().     List<TopDocs> topDocsList = new ArrayList<>(searchResponses.size()).     Map<String, List<Suggest.Suggestion>> groupedSuggestions = new HashMap<>().     Boolean trackTotalHits = null.     TopDocsStats topDocsStats = new TopDocsStats(trackTotalHitsUpTo).     for (SearchResponse searchResponse : searchResponses) {         totalShards += searchResponse.getTotalShards().         skippedShards += searchResponse.getSkippedShards().         successfulShards += searchResponse.getSuccessfulShards().         numReducePhases += searchResponse.getNumReducePhases().         Collections.addAll(failures, searchResponse.getShardFailures()).         profileResults.putAll(searchResponse.getProfileResults()).         if (searchResponse.getAggregations() != null) {             InternalAggregations internalAggs = (InternalAggregations) searchResponse.getAggregations().             aggs.add(internalAggs).         }         Suggest suggest = searchResponse.getSuggest().         if (suggest != null) {             for (Suggest.Suggestion<? extends Suggest.Suggestion.Entry<? extends Suggest.Suggestion.Entry.Option>> entries : suggest) {                 List<Suggest.Suggestion> suggestionList = groupedSuggestions.computeIfAbsent(entries.getName(), s -> new ArrayList<>()).                 suggestionList.add(entries).             }         }         SearchHits searchHits = searchResponse.getHits().         final TotalHits totalHits.         if (searchHits.getTotalHits() == null) {             // in case we didn't track total hits, we get null from each cluster, but we need to set 0 eq to the TopDocs             totalHits = new TotalHits(0, TotalHits.Relation.EQUAL_TO).             assert trackTotalHits == null || trackTotalHits == false.             trackTotalHits = false.         } else {             totalHits = searchHits.getTotalHits().             assert trackTotalHits == null || trackTotalHits.             trackTotalHits = true.         }         TopDocs topDocs = searchHitsToTopDocs(searchHits, totalHits, shards).         topDocsStats.add(new TopDocsAndMaxScore(topDocs, searchHits.getMaxScore()), searchResponse.isTimedOut(), searchResponse.isTerminatedEarly()).         topDocsList.add(topDocs).     }     // after going through all the hits and collecting all their distinct shards, we can assign shardIndex and set it to the ScoreDocs     setShardIndex(shards, topDocsList).     TopDocs topDocs = mergeTopDocs(topDocsList, size, from).     SearchHits mergedSearchHits = topDocsToSearchHits(topDocs, topDocsStats).     Suggest suggest = groupedSuggestions.isEmpty() ? null : new Suggest(Suggest.reduce(groupedSuggestions)).     InternalAggregations reducedAggs = InternalAggregations.reduce(aggs, reduceContextFunction.apply(true)).     ShardSearchFailure[] shardFailures = failures.toArray(ShardSearchFailure.EMPTY_ARRAY).     SearchProfileShardResults profileShardResults = profileResults.isEmpty() ? null : new SearchProfileShardResults(profileResults).     // make failures ordering consistent with ordinary search and CCS     Arrays.sort(shardFailures, FAILURES_COMPARATOR).     InternalSearchResponse response = new InternalSearchResponse(mergedSearchHits, reducedAggs, suggest, profileShardResults, topDocsStats.timedOut, topDocsStats.terminatedEarly, numReducePhases).     long tookInMillis = searchTimeProvider.buildTookInMillis().     return new SearchResponse(response, null, totalShards, successfulShards, skippedShards, tookInMillis, shardFailures, clusters). }
false;public;2;33;;@Override public int compare(ShardSearchFailure o1, ShardSearchFailure o2) {     ShardId shardId1 = extractShardId(o1).     ShardId shardId2 = extractShardId(o2).     if (shardId1 == null && shardId2 == null) {         return 0.     }     if (shardId1 == null) {         return -1.     }     if (shardId2 == null) {         return 1.     }     int shardIdCompare = shardId1.compareTo(shardId2).     // we may get failures from the same index, yet with a different cluster alias in their shard target.     if (shardIdCompare != 0) {         return shardIdCompare.     }     String clusterAlias1 = o1.shard() == null ? null : o1.shard().getClusterAlias().     String clusterAlias2 = o2.shard() == null ? null : o2.shard().getClusterAlias().     if (clusterAlias1 == null && clusterAlias2 == null) {         return 0.     }     if (clusterAlias1 == null) {         return -1.     }     if (clusterAlias2 == null) {         return 1.     }     return clusterAlias1.compareTo(clusterAlias2). }
false;private;1;12;;private ShardId extractShardId(ShardSearchFailure failure) {     SearchShardTarget shard = failure.shard().     if (shard != null) {         return shard.getShardId().     }     Throwable cause = failure.getCause().     if (cause instanceof ElasticsearchException) {         ElasticsearchException e = (ElasticsearchException) cause.         return e.getShardId().     }     return null. }
false;private,static;3;36;;private static TopDocs searchHitsToTopDocs(SearchHits searchHits, TotalHits totalHits, Map<ShardIdAndClusterAlias, Integer> shards) {     SearchHit[] hits = searchHits.getHits().     ScoreDoc[] scoreDocs = new ScoreDoc[hits.length].     final TopDocs topDocs.     if (searchHits.getSortFields() != null) {         if (searchHits.getCollapseField() != null) {             assert searchHits.getCollapseValues() != null.             topDocs = new CollapseTopFieldDocs(searchHits.getCollapseField(), totalHits, scoreDocs, searchHits.getSortFields(), searchHits.getCollapseValues()).         } else {             topDocs = new TopFieldDocs(totalHits, scoreDocs, searchHits.getSortFields()).         }     } else {         topDocs = new TopDocs(totalHits, scoreDocs).     }     for (int i = 0. i < hits.length. i++) {         SearchHit hit = hits[i].         SearchShardTarget shard = hit.getShard().         ShardIdAndClusterAlias shardId = new ShardIdAndClusterAlias(shard.getShardId(), shard.getClusterAlias()).         shards.putIfAbsent(shardId, null).         final SortField[] sortFields = searchHits.getSortFields().         final Object[] sortValues.         if (sortFields == null) {             sortValues = null.         } else {             if (sortFields.length == 1 && sortFields[0].getType() == SortField.Type.SCORE) {                 sortValues = new Object[] { hit.getScore() }.             } else {                 sortValues = hit.getRawSortValues().             }         }         scoreDocs[i] = new FieldDocAndSearchHit(hit.docId(), hit.getScore(), sortValues, hit).     }     return topDocs. }
false;private,static;2;19;;private static void setShardIndex(Map<ShardIdAndClusterAlias, Integer> shards, List<TopDocs> topDocsList) {     {         // assign a different shardIndex to each shard, based on their shardId natural ordering and their cluster alias         int shardIndex = 0.         for (Map.Entry<ShardIdAndClusterAlias, Integer> shard : shards.entrySet()) {             shard.setValue(shardIndex++).         }     }     // go through all the scoreDocs from each cluster and set their corresponding shardIndex     for (TopDocs topDocs : topDocsList) {         for (ScoreDoc scoreDoc : topDocs.scoreDocs) {             FieldDocAndSearchHit fieldDocAndSearchHit = (FieldDocAndSearchHit) scoreDoc.             SearchShardTarget shard = fieldDocAndSearchHit.searchHit.getShard().             ShardIdAndClusterAlias shardId = new ShardIdAndClusterAlias(shard.getShardId(), shard.getClusterAlias()).             assert shards.containsKey(shardId).             fieldDocAndSearchHit.shardIndex = shards.get(shardId).         }     } }
false;private,static;2;21;;private static SearchHits topDocsToSearchHits(TopDocs topDocs, TopDocsStats topDocsStats) {     SearchHit[] searchHits = new SearchHit[topDocs.scoreDocs.length].     for (int i = 0. i < topDocs.scoreDocs.length. i++) {         FieldDocAndSearchHit scoreDoc = (FieldDocAndSearchHit) topDocs.scoreDocs[i].         searchHits[i] = scoreDoc.searchHit.     }     SortField[] sortFields = null.     String collapseField = null.     Object[] collapseValues = null.     if (topDocs instanceof TopFieldDocs) {         sortFields = ((TopFieldDocs) topDocs).fields.         if (topDocs instanceof CollapseTopFieldDocs) {             CollapseTopFieldDocs collapseTopFieldDocs = (CollapseTopFieldDocs) topDocs.             collapseField = collapseTopFieldDocs.field.             collapseValues = collapseTopFieldDocs.collapseValues.         }     }     return new SearchHits(searchHits, topDocsStats.getTotalHits(), topDocsStats.getMaxScore(), sortFields, collapseField, collapseValues). }
false;public;1;12;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (o == null || getClass() != o.getClass()) {         return false.     }     ShardIdAndClusterAlias that = (ShardIdAndClusterAlias) o.     return shardId.equals(that.shardId) && clusterAlias.equals(that.clusterAlias). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(shardId, clusterAlias). }
false;public;1;8;;@Override public int compareTo(ShardIdAndClusterAlias o) {     int shardIdCompareTo = shardId.compareTo(o.shardId).     if (shardIdCompareTo != 0) {         return shardIdCompareTo.     }     return clusterAlias.compareTo(o.clusterAlias). }
