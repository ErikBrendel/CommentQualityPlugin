# id;timestamp;commentText;codeText;commentWords;codeWords
MetaData -> public IndexGraveyard indexGraveyard();1524684173;The collection of index deletions in the cluster.;public IndexGraveyard indexGraveyard() {_        return custom(IndexGraveyard.TYPE)__    };the,collection,of,index,deletions,in,the,cluster;public,index,graveyard,index,graveyard,return,custom,index,graveyard,type
MetaData -> public IndexGraveyard indexGraveyard();1527878678;The collection of index deletions in the cluster.;public IndexGraveyard indexGraveyard() {_        return custom(IndexGraveyard.TYPE)__    };the,collection,of,index,deletions,in,the,cluster;public,index,graveyard,index,graveyard,return,custom,index,graveyard,type
MetaData -> public IndexGraveyard indexGraveyard();1528103657;The collection of index deletions in the cluster.;public IndexGraveyard indexGraveyard() {_        return custom(IndexGraveyard.TYPE)__    };the,collection,of,index,deletions,in,the,cluster;public,index,graveyard,index,graveyard,return,custom,index,graveyard,type
MetaData -> public IndexGraveyard indexGraveyard();1529082965;The collection of index deletions in the cluster.;public IndexGraveyard indexGraveyard() {_        return custom(IndexGraveyard.TYPE)__    };the,collection,of,index,deletions,in,the,cluster;public,index,graveyard,index,graveyard,return,custom,index,graveyard,type
MetaData -> public IndexGraveyard indexGraveyard();1531179852;The collection of index deletions in the cluster.;public IndexGraveyard indexGraveyard() {_        return custom(IndexGraveyard.TYPE)__    };the,collection,of,index,deletions,in,the,cluster;public,index,graveyard,index,graveyard,return,custom,index,graveyard,type
MetaData -> public IndexGraveyard indexGraveyard();1532028790;The collection of index deletions in the cluster.;public IndexGraveyard indexGraveyard() {_        return custom(IndexGraveyard.TYPE)__    };the,collection,of,index,deletions,in,the,cluster;public,index,graveyard,index,graveyard,return,custom,index,graveyard,type
MetaData -> public IndexGraveyard indexGraveyard();1532353780;The collection of index deletions in the cluster.;public IndexGraveyard indexGraveyard() {_        return custom(IndexGraveyard.TYPE)__    };the,collection,of,index,deletions,in,the,cluster;public,index,graveyard,index,graveyard,return,custom,index,graveyard,type
MetaData -> public IndexGraveyard indexGraveyard();1536611444;The collection of index deletions in the cluster.;public IndexGraveyard indexGraveyard() {_        return custom(IndexGraveyard.TYPE)__    };the,collection,of,index,deletions,in,the,cluster;public,index,graveyard,index,graveyard,return,custom,index,graveyard,type
MetaData -> public IndexGraveyard indexGraveyard();1539723533;The collection of index deletions in the cluster.;public IndexGraveyard indexGraveyard() {_        return custom(IndexGraveyard.TYPE)__    };the,collection,of,index,deletions,in,the,cluster;public,index,graveyard,index,graveyard,return,custom,index,graveyard,type
MetaData -> public IndexGraveyard indexGraveyard();1540313026;The collection of index deletions in the cluster.;public IndexGraveyard indexGraveyard() {_        return custom(IndexGraveyard.TYPE)__    };the,collection,of,index,deletions,in,the,cluster;public,index,graveyard,index,graveyard,return,custom,index,graveyard,type
MetaData -> public IndexGraveyard indexGraveyard();1540486836;The collection of index deletions in the cluster.;public IndexGraveyard indexGraveyard() {_        return custom(IndexGraveyard.TYPE)__    };the,collection,of,index,deletions,in,the,cluster;public,index,graveyard,index,graveyard,return,custom,index,graveyard,type
MetaData -> public IndexGraveyard indexGraveyard();1540847035;The collection of index deletions in the cluster.;public IndexGraveyard indexGraveyard() {_        return custom(IndexGraveyard.TYPE)__    };the,collection,of,index,deletions,in,the,cluster;public,index,graveyard,index,graveyard,return,custom,index,graveyard,type
MetaData -> public IndexGraveyard indexGraveyard();1543947737;The collection of index deletions in the cluster.;public IndexGraveyard indexGraveyard() {_        return custom(IndexGraveyard.TYPE)__    };the,collection,of,index,deletions,in,the,cluster;public,index,graveyard,index,graveyard,return,custom,index,graveyard,type
MetaData -> public IndexGraveyard indexGraveyard();1544081506;The collection of index deletions in the cluster.;public IndexGraveyard indexGraveyard() {_        return custom(IndexGraveyard.TYPE)__    };the,collection,of,index,deletions,in,the,cluster;public,index,graveyard,index,graveyard,return,custom,index,graveyard,type
MetaData -> public IndexGraveyard indexGraveyard();1544702062;The collection of index deletions in the cluster.;public IndexGraveyard indexGraveyard() {_        return custom(IndexGraveyard.TYPE)__    };the,collection,of,index,deletions,in,the,cluster;public,index,graveyard,index,graveyard,return,custom,index,graveyard,type
MetaData -> public IndexGraveyard indexGraveyard();1547500081;The collection of index deletions in the cluster.;public IndexGraveyard indexGraveyard() {_        return custom(IndexGraveyard.TYPE)__    };the,collection,of,index,deletions,in,the,cluster;public,index,graveyard,index,graveyard,return,custom,index,graveyard,type
MetaData -> public IndexGraveyard indexGraveyard();1548772865;The collection of index deletions in the cluster.;public IndexGraveyard indexGraveyard() {_        return custom(IndexGraveyard.TYPE)__    };the,collection,of,index,deletions,in,the,cluster;public,index,graveyard,index,graveyard,return,custom,index,graveyard,type
MetaData -> public int getTotalOpenIndexShards();1540486836;Gets the total number of open shards from all indices. Includes_replicas, but does not include shards that are part of closed indices._@return The total number of open shards from all indices.;public int getTotalOpenIndexShards() {_        return this.totalOpenIndexShards__    };gets,the,total,number,of,open,shards,from,all,indices,includes,replicas,but,does,not,include,shards,that,are,part,of,closed,indices,return,the,total,number,of,open,shards,from,all,indices;public,int,get,total,open,index,shards,return,this,total,open,index,shards
MetaData -> public int getTotalOpenIndexShards();1540847035;Gets the total number of open shards from all indices. Includes_replicas, but does not include shards that are part of closed indices._@return The total number of open shards from all indices.;public int getTotalOpenIndexShards() {_        return this.totalOpenIndexShards__    };gets,the,total,number,of,open,shards,from,all,indices,includes,replicas,but,does,not,include,shards,that,are,part,of,closed,indices,return,the,total,number,of,open,shards,from,all,indices;public,int,get,total,open,index,shards,return,this,total,open,index,shards
MetaData -> public int getTotalOpenIndexShards();1543947737;Gets the total number of open shards from all indices. Includes_replicas, but does not include shards that are part of closed indices._@return The total number of open shards from all indices.;public int getTotalOpenIndexShards() {_        return this.totalOpenIndexShards__    };gets,the,total,number,of,open,shards,from,all,indices,includes,replicas,but,does,not,include,shards,that,are,part,of,closed,indices,return,the,total,number,of,open,shards,from,all,indices;public,int,get,total,open,index,shards,return,this,total,open,index,shards
MetaData -> public int getTotalOpenIndexShards();1544081506;Gets the total number of open shards from all indices. Includes_replicas, but does not include shards that are part of closed indices._@return The total number of open shards from all indices.;public int getTotalOpenIndexShards() {_        return this.totalOpenIndexShards__    };gets,the,total,number,of,open,shards,from,all,indices,includes,replicas,but,does,not,include,shards,that,are,part,of,closed,indices,return,the,total,number,of,open,shards,from,all,indices;public,int,get,total,open,index,shards,return,this,total,open,index,shards
MetaData -> public int getTotalOpenIndexShards();1544702062;Gets the total number of open shards from all indices. Includes_replicas, but does not include shards that are part of closed indices._@return The total number of open shards from all indices.;public int getTotalOpenIndexShards() {_        return this.totalOpenIndexShards__    };gets,the,total,number,of,open,shards,from,all,indices,includes,replicas,but,does,not,include,shards,that,are,part,of,closed,indices,return,the,total,number,of,open,shards,from,all,indices;public,int,get,total,open,index,shards,return,this,total,open,index,shards
MetaData -> public int getTotalOpenIndexShards();1547500081;Gets the total number of open shards from all indices. Includes_replicas, but does not include shards that are part of closed indices._@return The total number of open shards from all indices.;public int getTotalOpenIndexShards() {_        return this.totalOpenIndexShards__    };gets,the,total,number,of,open,shards,from,all,indices,includes,replicas,but,does,not,include,shards,that,are,part,of,closed,indices,return,the,total,number,of,open,shards,from,all,indices;public,int,get,total,open,index,shards,return,this,total,open,index,shards
MetaData -> public int getTotalOpenIndexShards();1548772865;Gets the total number of open shards from all indices. Includes_replicas, but does not include shards that are part of closed indices._@return The total number of open shards from all indices.;public int getTotalOpenIndexShards() {_        return this.totalOpenIndexShards__    };gets,the,total,number,of,open,shards,from,all,indices,includes,replicas,but,does,not,include,shards,that,are,part,of,closed,indices,return,the,total,number,of,open,shards,from,all,indices;public,int,get,total,open,index,shards,return,this,total,open,index,shards
MetaData -> public ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final AliasesRequest aliasesRequest, final String[] concreteIndices);1540313026;Finds the specific index aliases that match with the specified aliases directly or partially via wildcards, and_that point to the specified concrete indices (directly or matching indices via wildcards).__@param aliasesRequest The request to find aliases for_@param concreteIndices The concrete indices that the aliases must point to in order to be returned._@return A map of index name to the list of aliases metadata. If a concrete index does not have matching_aliases then the result will <b>not</b> include the index's key.;public ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final AliasesRequest aliasesRequest, final String[] concreteIndices) {_        return findAliases(aliasesRequest.aliases(), concreteIndices)__    };finds,the,specific,index,aliases,that,match,with,the,specified,aliases,directly,or,partially,via,wildcards,and,that,point,to,the,specified,concrete,indices,directly,or,matching,indices,via,wildcards,param,aliases,request,the,request,to,find,aliases,for,param,concrete,indices,the,concrete,indices,that,the,aliases,must,point,to,in,order,to,be,returned,return,a,map,of,index,name,to,the,list,of,aliases,metadata,if,a,concrete,index,does,not,have,matching,aliases,then,the,result,will,b,not,b,include,the,index,s,key;public,immutable,open,map,string,list,alias,meta,data,find,aliases,final,aliases,request,aliases,request,final,string,concrete,indices,return,find,aliases,aliases,request,aliases,concrete,indices
MetaData -> public ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final AliasesRequest aliasesRequest, final String[] concreteIndices);1540486836;Finds the specific index aliases that match with the specified aliases directly or partially via wildcards, and_that point to the specified concrete indices (directly or matching indices via wildcards).__@param aliasesRequest The request to find aliases for_@param concreteIndices The concrete indices that the aliases must point to in order to be returned._@return A map of index name to the list of aliases metadata. If a concrete index does not have matching_aliases then the result will <b>not</b> include the index's key.;public ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final AliasesRequest aliasesRequest, final String[] concreteIndices) {_        return findAliases(aliasesRequest.aliases(), concreteIndices)__    };finds,the,specific,index,aliases,that,match,with,the,specified,aliases,directly,or,partially,via,wildcards,and,that,point,to,the,specified,concrete,indices,directly,or,matching,indices,via,wildcards,param,aliases,request,the,request,to,find,aliases,for,param,concrete,indices,the,concrete,indices,that,the,aliases,must,point,to,in,order,to,be,returned,return,a,map,of,index,name,to,the,list,of,aliases,metadata,if,a,concrete,index,does,not,have,matching,aliases,then,the,result,will,b,not,b,include,the,index,s,key;public,immutable,open,map,string,list,alias,meta,data,find,aliases,final,aliases,request,aliases,request,final,string,concrete,indices,return,find,aliases,aliases,request,aliases,concrete,indices
MetaData -> public ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final AliasesRequest aliasesRequest, final String[] concreteIndices);1540847035;Finds the specific index aliases that match with the specified aliases directly or partially via wildcards, and_that point to the specified concrete indices (directly or matching indices via wildcards).__@param aliasesRequest The request to find aliases for_@param concreteIndices The concrete indices that the aliases must point to in order to be returned._@return A map of index name to the list of aliases metadata. If a concrete index does not have matching_aliases then the result will <b>not</b> include the index's key.;public ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final AliasesRequest aliasesRequest, final String[] concreteIndices) {_        return findAliases(aliasesRequest.aliases(), concreteIndices)__    };finds,the,specific,index,aliases,that,match,with,the,specified,aliases,directly,or,partially,via,wildcards,and,that,point,to,the,specified,concrete,indices,directly,or,matching,indices,via,wildcards,param,aliases,request,the,request,to,find,aliases,for,param,concrete,indices,the,concrete,indices,that,the,aliases,must,point,to,in,order,to,be,returned,return,a,map,of,index,name,to,the,list,of,aliases,metadata,if,a,concrete,index,does,not,have,matching,aliases,then,the,result,will,b,not,b,include,the,index,s,key;public,immutable,open,map,string,list,alias,meta,data,find,aliases,final,aliases,request,aliases,request,final,string,concrete,indices,return,find,aliases,aliases,request,aliases,concrete,indices
MetaData -> public ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final AliasesRequest aliasesRequest, final String[] concreteIndices);1543947737;Finds the specific index aliases that match with the specified aliases directly or partially via wildcards, and_that point to the specified concrete indices (directly or matching indices via wildcards).__@param aliasesRequest The request to find aliases for_@param concreteIndices The concrete indices that the aliases must point to in order to be returned._@return A map of index name to the list of aliases metadata. If a concrete index does not have matching_aliases then the result will <b>not</b> include the index's key.;public ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final AliasesRequest aliasesRequest, final String[] concreteIndices) {_        return findAliases(aliasesRequest.aliases(), concreteIndices)__    };finds,the,specific,index,aliases,that,match,with,the,specified,aliases,directly,or,partially,via,wildcards,and,that,point,to,the,specified,concrete,indices,directly,or,matching,indices,via,wildcards,param,aliases,request,the,request,to,find,aliases,for,param,concrete,indices,the,concrete,indices,that,the,aliases,must,point,to,in,order,to,be,returned,return,a,map,of,index,name,to,the,list,of,aliases,metadata,if,a,concrete,index,does,not,have,matching,aliases,then,the,result,will,b,not,b,include,the,index,s,key;public,immutable,open,map,string,list,alias,meta,data,find,aliases,final,aliases,request,aliases,request,final,string,concrete,indices,return,find,aliases,aliases,request,aliases,concrete,indices
MetaData -> public ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final AliasesRequest aliasesRequest, final String[] concreteIndices);1544081506;Finds the specific index aliases that match with the specified aliases directly or partially via wildcards, and_that point to the specified concrete indices (directly or matching indices via wildcards).__@param aliasesRequest The request to find aliases for_@param concreteIndices The concrete indices that the aliases must point to in order to be returned._@return A map of index name to the list of aliases metadata. If a concrete index does not have matching_aliases then the result will <b>not</b> include the index's key.;public ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final AliasesRequest aliasesRequest, final String[] concreteIndices) {_        return findAliases(aliasesRequest.aliases(), concreteIndices)__    };finds,the,specific,index,aliases,that,match,with,the,specified,aliases,directly,or,partially,via,wildcards,and,that,point,to,the,specified,concrete,indices,directly,or,matching,indices,via,wildcards,param,aliases,request,the,request,to,find,aliases,for,param,concrete,indices,the,concrete,indices,that,the,aliases,must,point,to,in,order,to,be,returned,return,a,map,of,index,name,to,the,list,of,aliases,metadata,if,a,concrete,index,does,not,have,matching,aliases,then,the,result,will,b,not,b,include,the,index,s,key;public,immutable,open,map,string,list,alias,meta,data,find,aliases,final,aliases,request,aliases,request,final,string,concrete,indices,return,find,aliases,aliases,request,aliases,concrete,indices
MetaData -> public ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final AliasesRequest aliasesRequest, final String[] concreteIndices);1544702062;Finds the specific index aliases that match with the specified aliases directly or partially via wildcards, and_that point to the specified concrete indices (directly or matching indices via wildcards).__@param aliasesRequest The request to find aliases for_@param concreteIndices The concrete indices that the aliases must point to in order to be returned._@return A map of index name to the list of aliases metadata. If a concrete index does not have matching_aliases then the result will <b>not</b> include the index's key.;public ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final AliasesRequest aliasesRequest, final String[] concreteIndices) {_        return findAliases(aliasesRequest.aliases(), concreteIndices)__    };finds,the,specific,index,aliases,that,match,with,the,specified,aliases,directly,or,partially,via,wildcards,and,that,point,to,the,specified,concrete,indices,directly,or,matching,indices,via,wildcards,param,aliases,request,the,request,to,find,aliases,for,param,concrete,indices,the,concrete,indices,that,the,aliases,must,point,to,in,order,to,be,returned,return,a,map,of,index,name,to,the,list,of,aliases,metadata,if,a,concrete,index,does,not,have,matching,aliases,then,the,result,will,b,not,b,include,the,index,s,key;public,immutable,open,map,string,list,alias,meta,data,find,aliases,final,aliases,request,aliases,request,final,string,concrete,indices,return,find,aliases,aliases,request,aliases,concrete,indices
MetaData -> public ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final AliasesRequest aliasesRequest, final String[] concreteIndices);1547500081;Finds the specific index aliases that match with the specified aliases directly or partially via wildcards, and_that point to the specified concrete indices (directly or matching indices via wildcards).__@param aliasesRequest The request to find aliases for_@param concreteIndices The concrete indices that the aliases must point to in order to be returned._@return A map of index name to the list of aliases metadata. If a concrete index does not have matching_aliases then the result will <b>not</b> include the index's key.;public ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final AliasesRequest aliasesRequest, final String[] concreteIndices) {_        return findAliases(aliasesRequest.aliases(), concreteIndices)__    };finds,the,specific,index,aliases,that,match,with,the,specified,aliases,directly,or,partially,via,wildcards,and,that,point,to,the,specified,concrete,indices,directly,or,matching,indices,via,wildcards,param,aliases,request,the,request,to,find,aliases,for,param,concrete,indices,the,concrete,indices,that,the,aliases,must,point,to,in,order,to,be,returned,return,a,map,of,index,name,to,the,list,of,aliases,metadata,if,a,concrete,index,does,not,have,matching,aliases,then,the,result,will,b,not,b,include,the,index,s,key;public,immutable,open,map,string,list,alias,meta,data,find,aliases,final,aliases,request,aliases,request,final,string,concrete,indices,return,find,aliases,aliases,request,aliases,concrete,indices
MetaData -> public ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final AliasesRequest aliasesRequest, final String[] concreteIndices);1548772865;Finds the specific index aliases that match with the specified aliases directly or partially via wildcards, and_that point to the specified concrete indices (directly or matching indices via wildcards).__@param aliasesRequest The request to find aliases for_@param concreteIndices The concrete indices that the aliases must point to in order to be returned._@return A map of index name to the list of aliases metadata. If a concrete index does not have matching_aliases then the result will <b>not</b> include the index's key.;public ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final AliasesRequest aliasesRequest, final String[] concreteIndices) {_        return findAliases(aliasesRequest.aliases(), concreteIndices)__    };finds,the,specific,index,aliases,that,match,with,the,specified,aliases,directly,or,partially,via,wildcards,and,that,point,to,the,specified,concrete,indices,directly,or,matching,indices,via,wildcards,param,aliases,request,the,request,to,find,aliases,for,param,concrete,indices,the,concrete,indices,that,the,aliases,must,point,to,in,order,to,be,returned,return,a,map,of,index,name,to,the,list,of,aliases,metadata,if,a,concrete,index,does,not,have,matching,aliases,then,the,result,will,b,not,b,include,the,index,s,key;public,immutable,open,map,string,list,alias,meta,data,find,aliases,final,aliases,request,aliases,request,final,string,concrete,indices,return,find,aliases,aliases,request,aliases,concrete,indices
MetaData -> public boolean routingRequired(String concreteIndex);1543947737;@param concreteIndex The concrete index to check if routing is required_@return Whether routing is required according to the mapping for the specified index and type;public boolean routingRequired(String concreteIndex) {_        IndexMetaData indexMetaData = indices.get(concreteIndex)__        if (indexMetaData != null) {_            MappingMetaData mappingMetaData = indexMetaData.mapping()__            if (mappingMetaData != null) {_                return mappingMetaData.routing().required()__            }_        }_        return false__    };param,concrete,index,the,concrete,index,to,check,if,routing,is,required,return,whether,routing,is,required,according,to,the,mapping,for,the,specified,index,and,type;public,boolean,routing,required,string,concrete,index,index,meta,data,index,meta,data,indices,get,concrete,index,if,index,meta,data,null,mapping,meta,data,mapping,meta,data,index,meta,data,mapping,if,mapping,meta,data,null,return,mapping,meta,data,routing,required,return,false
MetaData -> public boolean routingRequired(String concreteIndex);1544081506;@param concreteIndex The concrete index to check if routing is required_@return Whether routing is required according to the mapping for the specified index and type;public boolean routingRequired(String concreteIndex) {_        IndexMetaData indexMetaData = indices.get(concreteIndex)__        if (indexMetaData != null) {_            MappingMetaData mappingMetaData = indexMetaData.mapping()__            if (mappingMetaData != null) {_                return mappingMetaData.routing().required()__            }_        }_        return false__    };param,concrete,index,the,concrete,index,to,check,if,routing,is,required,return,whether,routing,is,required,according,to,the,mapping,for,the,specified,index,and,type;public,boolean,routing,required,string,concrete,index,index,meta,data,index,meta,data,indices,get,concrete,index,if,index,meta,data,null,mapping,meta,data,mapping,meta,data,index,meta,data,mapping,if,mapping,meta,data,null,return,mapping,meta,data,routing,required,return,false
MetaData -> public boolean routingRequired(String concreteIndex);1544702062;@param concreteIndex The concrete index to check if routing is required_@return Whether routing is required according to the mapping for the specified index and type;public boolean routingRequired(String concreteIndex) {_        IndexMetaData indexMetaData = indices.get(concreteIndex)__        if (indexMetaData != null) {_            MappingMetaData mappingMetaData = indexMetaData.mapping()__            if (mappingMetaData != null) {_                return mappingMetaData.routing().required()__            }_        }_        return false__    };param,concrete,index,the,concrete,index,to,check,if,routing,is,required,return,whether,routing,is,required,according,to,the,mapping,for,the,specified,index,and,type;public,boolean,routing,required,string,concrete,index,index,meta,data,index,meta,data,indices,get,concrete,index,if,index,meta,data,null,mapping,meta,data,mapping,meta,data,index,meta,data,mapping,if,mapping,meta,data,null,return,mapping,meta,data,routing,required,return,false
MetaData -> public boolean routingRequired(String concreteIndex);1547500081;@param concreteIndex The concrete index to check if routing is required_@return Whether routing is required according to the mapping for the specified index and type;public boolean routingRequired(String concreteIndex) {_        IndexMetaData indexMetaData = indices.get(concreteIndex)__        if (indexMetaData != null) {_            MappingMetaData mappingMetaData = indexMetaData.mapping()__            if (mappingMetaData != null) {_                return mappingMetaData.routing().required()__            }_        }_        return false__    };param,concrete,index,the,concrete,index,to,check,if,routing,is,required,return,whether,routing,is,required,according,to,the,mapping,for,the,specified,index,and,type;public,boolean,routing,required,string,concrete,index,index,meta,data,index,meta,data,indices,get,concrete,index,if,index,meta,data,null,mapping,meta,data,mapping,meta,data,index,meta,data,mapping,if,mapping,meta,data,null,return,mapping,meta,data,routing,required,return,false
MetaData -> public boolean routingRequired(String concreteIndex);1548772865;@param concreteIndex The concrete index to check if routing is required_@return Whether routing is required according to the mapping for the specified index and type;public boolean routingRequired(String concreteIndex) {_        IndexMetaData indexMetaData = indices.get(concreteIndex)__        if (indexMetaData != null) {_            MappingMetaData mappingMetaData = indexMetaData.mapping()__            if (mappingMetaData != null) {_                return mappingMetaData.routing().required()__            }_        }_        return false__    };param,concrete,index,the,concrete,index,to,check,if,routing,is,required,return,whether,routing,is,required,according,to,the,mapping,for,the,specified,index,and,type;public,boolean,routing,required,string,concrete,index,index,meta,data,index,meta,data,indices,get,concrete,index,if,index,meta,data,null,mapping,meta,data,mapping,meta,data,index,meta,data,mapping,if,mapping,meta,data,null,return,mapping,meta,data,routing,required,return,false
MetaData -> public ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final AliasesRequest aliasesRequest, String[] concreteIndices);1532353780;Finds the specific index aliases that match with the specified aliases directly or partially via wildcards and_that point to the specified concrete indices or match partially with the indices via wildcards.__@param aliasesRequest The request to find aliases for_@param concreteIndices The concrete indexes the index aliases must point to order to be returned._@return a map of index to a list of alias metadata, the list corresponding to a concrete index will be empty if no aliases are_present for that index;public ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final AliasesRequest aliasesRequest, String[] concreteIndices) {_        return findAliases(aliasesRequest.getOriginalAliases(), aliasesRequest.aliases(), concreteIndices)__    };finds,the,specific,index,aliases,that,match,with,the,specified,aliases,directly,or,partially,via,wildcards,and,that,point,to,the,specified,concrete,indices,or,match,partially,with,the,indices,via,wildcards,param,aliases,request,the,request,to,find,aliases,for,param,concrete,indices,the,concrete,indexes,the,index,aliases,must,point,to,order,to,be,returned,return,a,map,of,index,to,a,list,of,alias,metadata,the,list,corresponding,to,a,concrete,index,will,be,empty,if,no,aliases,are,present,for,that,index;public,immutable,open,map,string,list,alias,meta,data,find,aliases,final,aliases,request,aliases,request,string,concrete,indices,return,find,aliases,aliases,request,get,original,aliases,aliases,request,aliases,concrete,indices
MetaData -> public ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final AliasesRequest aliasesRequest, String[] concreteIndices);1536611444;Finds the specific index aliases that match with the specified aliases directly or partially via wildcards and_that point to the specified concrete indices or match partially with the indices via wildcards.__@param aliasesRequest The request to find aliases for_@param concreteIndices The concrete indexes the index aliases must point to order to be returned._@return a map of index to a list of alias metadata, the list corresponding to a concrete index will be empty if no aliases are_present for that index;public ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final AliasesRequest aliasesRequest, String[] concreteIndices) {_        return findAliases(aliasesRequest.getOriginalAliases(), aliasesRequest.aliases(), concreteIndices)__    };finds,the,specific,index,aliases,that,match,with,the,specified,aliases,directly,or,partially,via,wildcards,and,that,point,to,the,specified,concrete,indices,or,match,partially,with,the,indices,via,wildcards,param,aliases,request,the,request,to,find,aliases,for,param,concrete,indices,the,concrete,indexes,the,index,aliases,must,point,to,order,to,be,returned,return,a,map,of,index,to,a,list,of,alias,metadata,the,list,corresponding,to,a,concrete,index,will,be,empty,if,no,aliases,are,present,for,that,index;public,immutable,open,map,string,list,alias,meta,data,find,aliases,final,aliases,request,aliases,request,string,concrete,indices,return,find,aliases,aliases,request,get,original,aliases,aliases,request,aliases,concrete,indices
MetaData -> public ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final AliasesRequest aliasesRequest, String[] concreteIndices);1539723533;Finds the specific index aliases that match with the specified aliases directly or partially via wildcards and_that point to the specified concrete indices or match partially with the indices via wildcards.__@param aliasesRequest The request to find aliases for_@param concreteIndices The concrete indexes the index aliases must point to order to be returned._@return a map of index to a list of alias metadata, the list corresponding to a concrete index will be empty if no aliases are_present for that index;public ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final AliasesRequest aliasesRequest, String[] concreteIndices) {_        return findAliases(aliasesRequest.getOriginalAliases(), aliasesRequest.aliases(), concreteIndices)__    };finds,the,specific,index,aliases,that,match,with,the,specified,aliases,directly,or,partially,via,wildcards,and,that,point,to,the,specified,concrete,indices,or,match,partially,with,the,indices,via,wildcards,param,aliases,request,the,request,to,find,aliases,for,param,concrete,indices,the,concrete,indexes,the,index,aliases,must,point,to,order,to,be,returned,return,a,map,of,index,to,a,list,of,alias,metadata,the,list,corresponding,to,a,concrete,index,will,be,empty,if,no,aliases,are,present,for,that,index;public,immutable,open,map,string,list,alias,meta,data,find,aliases,final,aliases,request,aliases,request,string,concrete,indices,return,find,aliases,aliases,request,get,original,aliases,aliases,request,aliases,concrete,indices
MetaData -> public IndexMetaData getIndexSafe(Index index);1524684173;Returns the {@link IndexMetaData} for this index._@throws IndexNotFoundException if no metadata for this index is found;public IndexMetaData getIndexSafe(Index index) {_        IndexMetaData metaData = index(index.getName())__        if (metaData != null) {_            if(metaData.getIndexUUID().equals(index.getUUID())) {_                return metaData__            }_            throw new IndexNotFoundException(index,_                new IllegalStateException("index uuid doesn't match expected: [" + index.getUUID()_                    + "] but got: [" + metaData.getIndexUUID() +"]"))__        }_        throw new IndexNotFoundException(index)__    };returns,the,link,index,meta,data,for,this,index,throws,index,not,found,exception,if,no,metadata,for,this,index,is,found;public,index,meta,data,get,index,safe,index,index,index,meta,data,meta,data,index,index,get,name,if,meta,data,null,if,meta,data,get,index,uuid,equals,index,get,uuid,return,meta,data,throw,new,index,not,found,exception,index,new,illegal,state,exception,index,uuid,doesn,t,match,expected,index,get,uuid,but,got,meta,data,get,index,uuid,throw,new,index,not,found,exception,index
MetaData -> public IndexMetaData getIndexSafe(Index index);1527878678;Returns the {@link IndexMetaData} for this index._@throws IndexNotFoundException if no metadata for this index is found;public IndexMetaData getIndexSafe(Index index) {_        IndexMetaData metaData = index(index.getName())__        if (metaData != null) {_            if(metaData.getIndexUUID().equals(index.getUUID())) {_                return metaData__            }_            throw new IndexNotFoundException(index,_                new IllegalStateException("index uuid doesn't match expected: [" + index.getUUID()_                    + "] but got: [" + metaData.getIndexUUID() +"]"))__        }_        throw new IndexNotFoundException(index)__    };returns,the,link,index,meta,data,for,this,index,throws,index,not,found,exception,if,no,metadata,for,this,index,is,found;public,index,meta,data,get,index,safe,index,index,index,meta,data,meta,data,index,index,get,name,if,meta,data,null,if,meta,data,get,index,uuid,equals,index,get,uuid,return,meta,data,throw,new,index,not,found,exception,index,new,illegal,state,exception,index,uuid,doesn,t,match,expected,index,get,uuid,but,got,meta,data,get,index,uuid,throw,new,index,not,found,exception,index
MetaData -> public IndexMetaData getIndexSafe(Index index);1528103657;Returns the {@link IndexMetaData} for this index._@throws IndexNotFoundException if no metadata for this index is found;public IndexMetaData getIndexSafe(Index index) {_        IndexMetaData metaData = index(index.getName())__        if (metaData != null) {_            if(metaData.getIndexUUID().equals(index.getUUID())) {_                return metaData__            }_            throw new IndexNotFoundException(index,_                new IllegalStateException("index uuid doesn't match expected: [" + index.getUUID()_                    + "] but got: [" + metaData.getIndexUUID() +"]"))__        }_        throw new IndexNotFoundException(index)__    };returns,the,link,index,meta,data,for,this,index,throws,index,not,found,exception,if,no,metadata,for,this,index,is,found;public,index,meta,data,get,index,safe,index,index,index,meta,data,meta,data,index,index,get,name,if,meta,data,null,if,meta,data,get,index,uuid,equals,index,get,uuid,return,meta,data,throw,new,index,not,found,exception,index,new,illegal,state,exception,index,uuid,doesn,t,match,expected,index,get,uuid,but,got,meta,data,get,index,uuid,throw,new,index,not,found,exception,index
MetaData -> public IndexMetaData getIndexSafe(Index index);1529082965;Returns the {@link IndexMetaData} for this index._@throws IndexNotFoundException if no metadata for this index is found;public IndexMetaData getIndexSafe(Index index) {_        IndexMetaData metaData = index(index.getName())__        if (metaData != null) {_            if(metaData.getIndexUUID().equals(index.getUUID())) {_                return metaData__            }_            throw new IndexNotFoundException(index,_                new IllegalStateException("index uuid doesn't match expected: [" + index.getUUID()_                    + "] but got: [" + metaData.getIndexUUID() +"]"))__        }_        throw new IndexNotFoundException(index)__    };returns,the,link,index,meta,data,for,this,index,throws,index,not,found,exception,if,no,metadata,for,this,index,is,found;public,index,meta,data,get,index,safe,index,index,index,meta,data,meta,data,index,index,get,name,if,meta,data,null,if,meta,data,get,index,uuid,equals,index,get,uuid,return,meta,data,throw,new,index,not,found,exception,index,new,illegal,state,exception,index,uuid,doesn,t,match,expected,index,get,uuid,but,got,meta,data,get,index,uuid,throw,new,index,not,found,exception,index
MetaData -> public IndexMetaData getIndexSafe(Index index);1531179852;Returns the {@link IndexMetaData} for this index._@throws IndexNotFoundException if no metadata for this index is found;public IndexMetaData getIndexSafe(Index index) {_        IndexMetaData metaData = index(index.getName())__        if (metaData != null) {_            if(metaData.getIndexUUID().equals(index.getUUID())) {_                return metaData__            }_            throw new IndexNotFoundException(index,_                new IllegalStateException("index uuid doesn't match expected: [" + index.getUUID()_                    + "] but got: [" + metaData.getIndexUUID() +"]"))__        }_        throw new IndexNotFoundException(index)__    };returns,the,link,index,meta,data,for,this,index,throws,index,not,found,exception,if,no,metadata,for,this,index,is,found;public,index,meta,data,get,index,safe,index,index,index,meta,data,meta,data,index,index,get,name,if,meta,data,null,if,meta,data,get,index,uuid,equals,index,get,uuid,return,meta,data,throw,new,index,not,found,exception,index,new,illegal,state,exception,index,uuid,doesn,t,match,expected,index,get,uuid,but,got,meta,data,get,index,uuid,throw,new,index,not,found,exception,index
MetaData -> public IndexMetaData getIndexSafe(Index index);1532028790;Returns the {@link IndexMetaData} for this index._@throws IndexNotFoundException if no metadata for this index is found;public IndexMetaData getIndexSafe(Index index) {_        IndexMetaData metaData = index(index.getName())__        if (metaData != null) {_            if(metaData.getIndexUUID().equals(index.getUUID())) {_                return metaData__            }_            throw new IndexNotFoundException(index,_                new IllegalStateException("index uuid doesn't match expected: [" + index.getUUID()_                    + "] but got: [" + metaData.getIndexUUID() +"]"))__        }_        throw new IndexNotFoundException(index)__    };returns,the,link,index,meta,data,for,this,index,throws,index,not,found,exception,if,no,metadata,for,this,index,is,found;public,index,meta,data,get,index,safe,index,index,index,meta,data,meta,data,index,index,get,name,if,meta,data,null,if,meta,data,get,index,uuid,equals,index,get,uuid,return,meta,data,throw,new,index,not,found,exception,index,new,illegal,state,exception,index,uuid,doesn,t,match,expected,index,get,uuid,but,got,meta,data,get,index,uuid,throw,new,index,not,found,exception,index
MetaData -> public IndexMetaData getIndexSafe(Index index);1532353780;Returns the {@link IndexMetaData} for this index._@throws IndexNotFoundException if no metadata for this index is found;public IndexMetaData getIndexSafe(Index index) {_        IndexMetaData metaData = index(index.getName())__        if (metaData != null) {_            if(metaData.getIndexUUID().equals(index.getUUID())) {_                return metaData__            }_            throw new IndexNotFoundException(index,_                new IllegalStateException("index uuid doesn't match expected: [" + index.getUUID()_                    + "] but got: [" + metaData.getIndexUUID() +"]"))__        }_        throw new IndexNotFoundException(index)__    };returns,the,link,index,meta,data,for,this,index,throws,index,not,found,exception,if,no,metadata,for,this,index,is,found;public,index,meta,data,get,index,safe,index,index,index,meta,data,meta,data,index,index,get,name,if,meta,data,null,if,meta,data,get,index,uuid,equals,index,get,uuid,return,meta,data,throw,new,index,not,found,exception,index,new,illegal,state,exception,index,uuid,doesn,t,match,expected,index,get,uuid,but,got,meta,data,get,index,uuid,throw,new,index,not,found,exception,index
MetaData -> public IndexMetaData getIndexSafe(Index index);1536611444;Returns the {@link IndexMetaData} for this index._@throws IndexNotFoundException if no metadata for this index is found;public IndexMetaData getIndexSafe(Index index) {_        IndexMetaData metaData = index(index.getName())__        if (metaData != null) {_            if(metaData.getIndexUUID().equals(index.getUUID())) {_                return metaData__            }_            throw new IndexNotFoundException(index,_                new IllegalStateException("index uuid doesn't match expected: [" + index.getUUID()_                    + "] but got: [" + metaData.getIndexUUID() +"]"))__        }_        throw new IndexNotFoundException(index)__    };returns,the,link,index,meta,data,for,this,index,throws,index,not,found,exception,if,no,metadata,for,this,index,is,found;public,index,meta,data,get,index,safe,index,index,index,meta,data,meta,data,index,index,get,name,if,meta,data,null,if,meta,data,get,index,uuid,equals,index,get,uuid,return,meta,data,throw,new,index,not,found,exception,index,new,illegal,state,exception,index,uuid,doesn,t,match,expected,index,get,uuid,but,got,meta,data,get,index,uuid,throw,new,index,not,found,exception,index
MetaData -> public IndexMetaData getIndexSafe(Index index);1539723533;Returns the {@link IndexMetaData} for this index._@throws IndexNotFoundException if no metadata for this index is found;public IndexMetaData getIndexSafe(Index index) {_        IndexMetaData metaData = index(index.getName())__        if (metaData != null) {_            if(metaData.getIndexUUID().equals(index.getUUID())) {_                return metaData__            }_            throw new IndexNotFoundException(index,_                new IllegalStateException("index uuid doesn't match expected: [" + index.getUUID()_                    + "] but got: [" + metaData.getIndexUUID() +"]"))__        }_        throw new IndexNotFoundException(index)__    };returns,the,link,index,meta,data,for,this,index,throws,index,not,found,exception,if,no,metadata,for,this,index,is,found;public,index,meta,data,get,index,safe,index,index,index,meta,data,meta,data,index,index,get,name,if,meta,data,null,if,meta,data,get,index,uuid,equals,index,get,uuid,return,meta,data,throw,new,index,not,found,exception,index,new,illegal,state,exception,index,uuid,doesn,t,match,expected,index,get,uuid,but,got,meta,data,get,index,uuid,throw,new,index,not,found,exception,index
MetaData -> public IndexMetaData getIndexSafe(Index index);1540313026;Returns the {@link IndexMetaData} for this index._@throws IndexNotFoundException if no metadata for this index is found;public IndexMetaData getIndexSafe(Index index) {_        IndexMetaData metaData = index(index.getName())__        if (metaData != null) {_            if(metaData.getIndexUUID().equals(index.getUUID())) {_                return metaData__            }_            throw new IndexNotFoundException(index,_                new IllegalStateException("index uuid doesn't match expected: [" + index.getUUID()_                    + "] but got: [" + metaData.getIndexUUID() +"]"))__        }_        throw new IndexNotFoundException(index)__    };returns,the,link,index,meta,data,for,this,index,throws,index,not,found,exception,if,no,metadata,for,this,index,is,found;public,index,meta,data,get,index,safe,index,index,index,meta,data,meta,data,index,index,get,name,if,meta,data,null,if,meta,data,get,index,uuid,equals,index,get,uuid,return,meta,data,throw,new,index,not,found,exception,index,new,illegal,state,exception,index,uuid,doesn,t,match,expected,index,get,uuid,but,got,meta,data,get,index,uuid,throw,new,index,not,found,exception,index
MetaData -> public IndexMetaData getIndexSafe(Index index);1540486836;Returns the {@link IndexMetaData} for this index._@throws IndexNotFoundException if no metadata for this index is found;public IndexMetaData getIndexSafe(Index index) {_        IndexMetaData metaData = index(index.getName())__        if (metaData != null) {_            if(metaData.getIndexUUID().equals(index.getUUID())) {_                return metaData__            }_            throw new IndexNotFoundException(index,_                new IllegalStateException("index uuid doesn't match expected: [" + index.getUUID()_                    + "] but got: [" + metaData.getIndexUUID() +"]"))__        }_        throw new IndexNotFoundException(index)__    };returns,the,link,index,meta,data,for,this,index,throws,index,not,found,exception,if,no,metadata,for,this,index,is,found;public,index,meta,data,get,index,safe,index,index,index,meta,data,meta,data,index,index,get,name,if,meta,data,null,if,meta,data,get,index,uuid,equals,index,get,uuid,return,meta,data,throw,new,index,not,found,exception,index,new,illegal,state,exception,index,uuid,doesn,t,match,expected,index,get,uuid,but,got,meta,data,get,index,uuid,throw,new,index,not,found,exception,index
MetaData -> public IndexMetaData getIndexSafe(Index index);1540847035;Returns the {@link IndexMetaData} for this index._@throws IndexNotFoundException if no metadata for this index is found;public IndexMetaData getIndexSafe(Index index) {_        IndexMetaData metaData = index(index.getName())__        if (metaData != null) {_            if(metaData.getIndexUUID().equals(index.getUUID())) {_                return metaData__            }_            throw new IndexNotFoundException(index,_                new IllegalStateException("index uuid doesn't match expected: [" + index.getUUID()_                    + "] but got: [" + metaData.getIndexUUID() +"]"))__        }_        throw new IndexNotFoundException(index)__    };returns,the,link,index,meta,data,for,this,index,throws,index,not,found,exception,if,no,metadata,for,this,index,is,found;public,index,meta,data,get,index,safe,index,index,index,meta,data,meta,data,index,index,get,name,if,meta,data,null,if,meta,data,get,index,uuid,equals,index,get,uuid,return,meta,data,throw,new,index,not,found,exception,index,new,illegal,state,exception,index,uuid,doesn,t,match,expected,index,get,uuid,but,got,meta,data,get,index,uuid,throw,new,index,not,found,exception,index
MetaData -> public IndexMetaData getIndexSafe(Index index);1543947737;Returns the {@link IndexMetaData} for this index._@throws IndexNotFoundException if no metadata for this index is found;public IndexMetaData getIndexSafe(Index index) {_        IndexMetaData metaData = index(index.getName())__        if (metaData != null) {_            if(metaData.getIndexUUID().equals(index.getUUID())) {_                return metaData__            }_            throw new IndexNotFoundException(index,_                new IllegalStateException("index uuid doesn't match expected: [" + index.getUUID()_                    + "] but got: [" + metaData.getIndexUUID() +"]"))__        }_        throw new IndexNotFoundException(index)__    };returns,the,link,index,meta,data,for,this,index,throws,index,not,found,exception,if,no,metadata,for,this,index,is,found;public,index,meta,data,get,index,safe,index,index,index,meta,data,meta,data,index,index,get,name,if,meta,data,null,if,meta,data,get,index,uuid,equals,index,get,uuid,return,meta,data,throw,new,index,not,found,exception,index,new,illegal,state,exception,index,uuid,doesn,t,match,expected,index,get,uuid,but,got,meta,data,get,index,uuid,throw,new,index,not,found,exception,index
MetaData -> public IndexMetaData getIndexSafe(Index index);1544081506;Returns the {@link IndexMetaData} for this index._@throws IndexNotFoundException if no metadata for this index is found;public IndexMetaData getIndexSafe(Index index) {_        IndexMetaData metaData = index(index.getName())__        if (metaData != null) {_            if(metaData.getIndexUUID().equals(index.getUUID())) {_                return metaData__            }_            throw new IndexNotFoundException(index,_                new IllegalStateException("index uuid doesn't match expected: [" + index.getUUID()_                    + "] but got: [" + metaData.getIndexUUID() +"]"))__        }_        throw new IndexNotFoundException(index)__    };returns,the,link,index,meta,data,for,this,index,throws,index,not,found,exception,if,no,metadata,for,this,index,is,found;public,index,meta,data,get,index,safe,index,index,index,meta,data,meta,data,index,index,get,name,if,meta,data,null,if,meta,data,get,index,uuid,equals,index,get,uuid,return,meta,data,throw,new,index,not,found,exception,index,new,illegal,state,exception,index,uuid,doesn,t,match,expected,index,get,uuid,but,got,meta,data,get,index,uuid,throw,new,index,not,found,exception,index
MetaData -> public IndexMetaData getIndexSafe(Index index);1544702062;Returns the {@link IndexMetaData} for this index._@throws IndexNotFoundException if no metadata for this index is found;public IndexMetaData getIndexSafe(Index index) {_        IndexMetaData metaData = index(index.getName())__        if (metaData != null) {_            if(metaData.getIndexUUID().equals(index.getUUID())) {_                return metaData__            }_            throw new IndexNotFoundException(index,_                new IllegalStateException("index uuid doesn't match expected: [" + index.getUUID()_                    + "] but got: [" + metaData.getIndexUUID() +"]"))__        }_        throw new IndexNotFoundException(index)__    };returns,the,link,index,meta,data,for,this,index,throws,index,not,found,exception,if,no,metadata,for,this,index,is,found;public,index,meta,data,get,index,safe,index,index,index,meta,data,meta,data,index,index,get,name,if,meta,data,null,if,meta,data,get,index,uuid,equals,index,get,uuid,return,meta,data,throw,new,index,not,found,exception,index,new,illegal,state,exception,index,uuid,doesn,t,match,expected,index,get,uuid,but,got,meta,data,get,index,uuid,throw,new,index,not,found,exception,index
MetaData -> public IndexMetaData getIndexSafe(Index index);1547500081;Returns the {@link IndexMetaData} for this index._@throws IndexNotFoundException if no metadata for this index is found;public IndexMetaData getIndexSafe(Index index) {_        IndexMetaData metaData = index(index.getName())__        if (metaData != null) {_            if(metaData.getIndexUUID().equals(index.getUUID())) {_                return metaData__            }_            throw new IndexNotFoundException(index,_                new IllegalStateException("index uuid doesn't match expected: [" + index.getUUID()_                    + "] but got: [" + metaData.getIndexUUID() +"]"))__        }_        throw new IndexNotFoundException(index)__    };returns,the,link,index,meta,data,for,this,index,throws,index,not,found,exception,if,no,metadata,for,this,index,is,found;public,index,meta,data,get,index,safe,index,index,index,meta,data,meta,data,index,index,get,name,if,meta,data,null,if,meta,data,get,index,uuid,equals,index,get,uuid,return,meta,data,throw,new,index,not,found,exception,index,new,illegal,state,exception,index,uuid,doesn,t,match,expected,index,get,uuid,but,got,meta,data,get,index,uuid,throw,new,index,not,found,exception,index
MetaData -> public IndexMetaData getIndexSafe(Index index);1548772865;Returns the {@link IndexMetaData} for this index._@throws IndexNotFoundException if no metadata for this index is found;public IndexMetaData getIndexSafe(Index index) {_        IndexMetaData metaData = index(index.getName())__        if (metaData != null) {_            if(metaData.getIndexUUID().equals(index.getUUID())) {_                return metaData__            }_            throw new IndexNotFoundException(index,_                new IllegalStateException("index uuid doesn't match expected: [" + index.getUUID()_                    + "] but got: [" + metaData.getIndexUUID() +"]"))__        }_        throw new IndexNotFoundException(index)__    };returns,the,link,index,meta,data,for,this,index,throws,index,not,found,exception,if,no,metadata,for,this,index,is,found;public,index,meta,data,get,index,safe,index,index,index,meta,data,meta,data,index,index,get,name,if,meta,data,null,if,meta,data,get,index,uuid,equals,index,get,uuid,return,meta,data,throw,new,index,not,found,exception,index,new,illegal,state,exception,index,uuid,doesn,t,match,expected,index,get,uuid,but,got,meta,data,get,index,uuid,throw,new,index,not,found,exception,index
MetaData -> public ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final String[] aliases, String[] concreteIndices);1524684173;Finds the specific index aliases that match with the specified aliases directly or partially via wildcards and_that point to the specified concrete indices or match partially with the indices via wildcards.__@param aliases         The names of the index aliases to find_@param concreteIndices The concrete indexes the index aliases must point to order to be returned._@return a map of index to a list of alias metadata, the list corresponding to a concrete index will be empty if no aliases are_present for that index;public ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final String[] aliases, String[] concreteIndices) {_        assert aliases != null__        assert concreteIndices != null__        if (concreteIndices.length == 0) {_            return ImmutableOpenMap.of()__        }__        boolean matchAllAliases = matchAllAliases(aliases)__        ImmutableOpenMap.Builder<String, List<AliasMetaData>> mapBuilder = ImmutableOpenMap.builder()__        Iterable<String> intersection = HppcMaps.intersection(ObjectHashSet.from(concreteIndices), indices.keys())__        for (String index : intersection) {_            IndexMetaData indexMetaData = indices.get(index)__            List<AliasMetaData> filteredValues = new ArrayList<>()__            for (ObjectCursor<AliasMetaData> cursor : indexMetaData.getAliases().values()) {_                AliasMetaData value = cursor.value__                if (matchAllAliases || Regex.simpleMatch(aliases, value.alias())) {_                    filteredValues.add(value)__                }_            }__            if (!filteredValues.isEmpty()) {_                _                CollectionUtil.timSort(filteredValues, Comparator.comparing(AliasMetaData::alias))__            }_            mapBuilder.put(index, Collections.unmodifiableList(filteredValues))__        }_        return mapBuilder.build()__    };finds,the,specific,index,aliases,that,match,with,the,specified,aliases,directly,or,partially,via,wildcards,and,that,point,to,the,specified,concrete,indices,or,match,partially,with,the,indices,via,wildcards,param,aliases,the,names,of,the,index,aliases,to,find,param,concrete,indices,the,concrete,indexes,the,index,aliases,must,point,to,order,to,be,returned,return,a,map,of,index,to,a,list,of,alias,metadata,the,list,corresponding,to,a,concrete,index,will,be,empty,if,no,aliases,are,present,for,that,index;public,immutable,open,map,string,list,alias,meta,data,find,aliases,final,string,aliases,string,concrete,indices,assert,aliases,null,assert,concrete,indices,null,if,concrete,indices,length,0,return,immutable,open,map,of,boolean,match,all,aliases,match,all,aliases,aliases,immutable,open,map,builder,string,list,alias,meta,data,map,builder,immutable,open,map,builder,iterable,string,intersection,hppc,maps,intersection,object,hash,set,from,concrete,indices,indices,keys,for,string,index,intersection,index,meta,data,index,meta,data,indices,get,index,list,alias,meta,data,filtered,values,new,array,list,for,object,cursor,alias,meta,data,cursor,index,meta,data,get,aliases,values,alias,meta,data,value,cursor,value,if,match,all,aliases,regex,simple,match,aliases,value,alias,filtered,values,add,value,if,filtered,values,is,empty,collection,util,tim,sort,filtered,values,comparator,comparing,alias,meta,data,alias,map,builder,put,index,collections,unmodifiable,list,filtered,values,return,map,builder,build
MetaData -> public ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final String[] aliases, String[] concreteIndices);1527878678;Finds the specific index aliases that match with the specified aliases directly or partially via wildcards and_that point to the specified concrete indices or match partially with the indices via wildcards.__@param aliases         The names of the index aliases to find_@param concreteIndices The concrete indexes the index aliases must point to order to be returned._@return a map of index to a list of alias metadata, the list corresponding to a concrete index will be empty if no aliases are_present for that index;public ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final String[] aliases, String[] concreteIndices) {_        assert aliases != null__        assert concreteIndices != null__        if (concreteIndices.length == 0) {_            return ImmutableOpenMap.of()__        }__        boolean matchAllAliases = matchAllAliases(aliases)__        ImmutableOpenMap.Builder<String, List<AliasMetaData>> mapBuilder = ImmutableOpenMap.builder()__        Iterable<String> intersection = HppcMaps.intersection(ObjectHashSet.from(concreteIndices), indices.keys())__        for (String index : intersection) {_            IndexMetaData indexMetaData = indices.get(index)__            List<AliasMetaData> filteredValues = new ArrayList<>()__            for (ObjectCursor<AliasMetaData> cursor : indexMetaData.getAliases().values()) {_                AliasMetaData value = cursor.value__                if (matchAllAliases || Regex.simpleMatch(aliases, value.alias())) {_                    filteredValues.add(value)__                }_            }__            if (!filteredValues.isEmpty()) {_                _                CollectionUtil.timSort(filteredValues, Comparator.comparing(AliasMetaData::alias))__            }_            mapBuilder.put(index, Collections.unmodifiableList(filteredValues))__        }_        return mapBuilder.build()__    };finds,the,specific,index,aliases,that,match,with,the,specified,aliases,directly,or,partially,via,wildcards,and,that,point,to,the,specified,concrete,indices,or,match,partially,with,the,indices,via,wildcards,param,aliases,the,names,of,the,index,aliases,to,find,param,concrete,indices,the,concrete,indexes,the,index,aliases,must,point,to,order,to,be,returned,return,a,map,of,index,to,a,list,of,alias,metadata,the,list,corresponding,to,a,concrete,index,will,be,empty,if,no,aliases,are,present,for,that,index;public,immutable,open,map,string,list,alias,meta,data,find,aliases,final,string,aliases,string,concrete,indices,assert,aliases,null,assert,concrete,indices,null,if,concrete,indices,length,0,return,immutable,open,map,of,boolean,match,all,aliases,match,all,aliases,aliases,immutable,open,map,builder,string,list,alias,meta,data,map,builder,immutable,open,map,builder,iterable,string,intersection,hppc,maps,intersection,object,hash,set,from,concrete,indices,indices,keys,for,string,index,intersection,index,meta,data,index,meta,data,indices,get,index,list,alias,meta,data,filtered,values,new,array,list,for,object,cursor,alias,meta,data,cursor,index,meta,data,get,aliases,values,alias,meta,data,value,cursor,value,if,match,all,aliases,regex,simple,match,aliases,value,alias,filtered,values,add,value,if,filtered,values,is,empty,collection,util,tim,sort,filtered,values,comparator,comparing,alias,meta,data,alias,map,builder,put,index,collections,unmodifiable,list,filtered,values,return,map,builder,build
MetaData -> public ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final String[] aliases, String[] concreteIndices);1528103657;Finds the specific index aliases that match with the specified aliases directly or partially via wildcards and_that point to the specified concrete indices or match partially with the indices via wildcards.__@param aliases         The names of the index aliases to find_@param concreteIndices The concrete indexes the index aliases must point to order to be returned._@return a map of index to a list of alias metadata, the list corresponding to a concrete index will be empty if no aliases are_present for that index;public ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final String[] aliases, String[] concreteIndices) {_        assert aliases != null__        assert concreteIndices != null__        if (concreteIndices.length == 0) {_            return ImmutableOpenMap.of()__        }__        boolean matchAllAliases = matchAllAliases(aliases)__        ImmutableOpenMap.Builder<String, List<AliasMetaData>> mapBuilder = ImmutableOpenMap.builder()__        Iterable<String> intersection = HppcMaps.intersection(ObjectHashSet.from(concreteIndices), indices.keys())__        for (String index : intersection) {_            IndexMetaData indexMetaData = indices.get(index)__            List<AliasMetaData> filteredValues = new ArrayList<>()__            for (ObjectCursor<AliasMetaData> cursor : indexMetaData.getAliases().values()) {_                AliasMetaData value = cursor.value__                if (matchAllAliases || Regex.simpleMatch(aliases, value.alias())) {_                    filteredValues.add(value)__                }_            }__            if (!filteredValues.isEmpty()) {_                _                CollectionUtil.timSort(filteredValues, Comparator.comparing(AliasMetaData::alias))__            }_            mapBuilder.put(index, Collections.unmodifiableList(filteredValues))__        }_        return mapBuilder.build()__    };finds,the,specific,index,aliases,that,match,with,the,specified,aliases,directly,or,partially,via,wildcards,and,that,point,to,the,specified,concrete,indices,or,match,partially,with,the,indices,via,wildcards,param,aliases,the,names,of,the,index,aliases,to,find,param,concrete,indices,the,concrete,indexes,the,index,aliases,must,point,to,order,to,be,returned,return,a,map,of,index,to,a,list,of,alias,metadata,the,list,corresponding,to,a,concrete,index,will,be,empty,if,no,aliases,are,present,for,that,index;public,immutable,open,map,string,list,alias,meta,data,find,aliases,final,string,aliases,string,concrete,indices,assert,aliases,null,assert,concrete,indices,null,if,concrete,indices,length,0,return,immutable,open,map,of,boolean,match,all,aliases,match,all,aliases,aliases,immutable,open,map,builder,string,list,alias,meta,data,map,builder,immutable,open,map,builder,iterable,string,intersection,hppc,maps,intersection,object,hash,set,from,concrete,indices,indices,keys,for,string,index,intersection,index,meta,data,index,meta,data,indices,get,index,list,alias,meta,data,filtered,values,new,array,list,for,object,cursor,alias,meta,data,cursor,index,meta,data,get,aliases,values,alias,meta,data,value,cursor,value,if,match,all,aliases,regex,simple,match,aliases,value,alias,filtered,values,add,value,if,filtered,values,is,empty,collection,util,tim,sort,filtered,values,comparator,comparing,alias,meta,data,alias,map,builder,put,index,collections,unmodifiable,list,filtered,values,return,map,builder,build
MetaData -> public ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final String[] aliases, String[] concreteIndices);1529082965;Finds the specific index aliases that match with the specified aliases directly or partially via wildcards and_that point to the specified concrete indices or match partially with the indices via wildcards.__@param aliases         The names of the index aliases to find_@param concreteIndices The concrete indexes the index aliases must point to order to be returned._@return a map of index to a list of alias metadata, the list corresponding to a concrete index will be empty if no aliases are_present for that index;public ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final String[] aliases, String[] concreteIndices) {_        assert aliases != null__        assert concreteIndices != null__        if (concreteIndices.length == 0) {_            return ImmutableOpenMap.of()__        }__        boolean matchAllAliases = matchAllAliases(aliases)__        ImmutableOpenMap.Builder<String, List<AliasMetaData>> mapBuilder = ImmutableOpenMap.builder()__        Iterable<String> intersection = HppcMaps.intersection(ObjectHashSet.from(concreteIndices), indices.keys())__        for (String index : intersection) {_            IndexMetaData indexMetaData = indices.get(index)__            List<AliasMetaData> filteredValues = new ArrayList<>()__            for (ObjectCursor<AliasMetaData> cursor : indexMetaData.getAliases().values()) {_                AliasMetaData value = cursor.value__                if (matchAllAliases || Regex.simpleMatch(aliases, value.alias())) {_                    filteredValues.add(value)__                }_            }__            if (!filteredValues.isEmpty()) {_                _                CollectionUtil.timSort(filteredValues, Comparator.comparing(AliasMetaData::alias))__            }_            mapBuilder.put(index, Collections.unmodifiableList(filteredValues))__        }_        return mapBuilder.build()__    };finds,the,specific,index,aliases,that,match,with,the,specified,aliases,directly,or,partially,via,wildcards,and,that,point,to,the,specified,concrete,indices,or,match,partially,with,the,indices,via,wildcards,param,aliases,the,names,of,the,index,aliases,to,find,param,concrete,indices,the,concrete,indexes,the,index,aliases,must,point,to,order,to,be,returned,return,a,map,of,index,to,a,list,of,alias,metadata,the,list,corresponding,to,a,concrete,index,will,be,empty,if,no,aliases,are,present,for,that,index;public,immutable,open,map,string,list,alias,meta,data,find,aliases,final,string,aliases,string,concrete,indices,assert,aliases,null,assert,concrete,indices,null,if,concrete,indices,length,0,return,immutable,open,map,of,boolean,match,all,aliases,match,all,aliases,aliases,immutable,open,map,builder,string,list,alias,meta,data,map,builder,immutable,open,map,builder,iterable,string,intersection,hppc,maps,intersection,object,hash,set,from,concrete,indices,indices,keys,for,string,index,intersection,index,meta,data,index,meta,data,indices,get,index,list,alias,meta,data,filtered,values,new,array,list,for,object,cursor,alias,meta,data,cursor,index,meta,data,get,aliases,values,alias,meta,data,value,cursor,value,if,match,all,aliases,regex,simple,match,aliases,value,alias,filtered,values,add,value,if,filtered,values,is,empty,collection,util,tim,sort,filtered,values,comparator,comparing,alias,meta,data,alias,map,builder,put,index,collections,unmodifiable,list,filtered,values,return,map,builder,build
MetaData -> public ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final String[] aliases, String[] concreteIndices);1531179852;Finds the specific index aliases that match with the specified aliases directly or partially via wildcards and_that point to the specified concrete indices or match partially with the indices via wildcards.__@param aliases         The names of the index aliases to find_@param concreteIndices The concrete indexes the index aliases must point to order to be returned._@return a map of index to a list of alias metadata, the list corresponding to a concrete index will be empty if no aliases are_present for that index;public ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final String[] aliases, String[] concreteIndices) {_        assert aliases != null__        assert concreteIndices != null__        if (concreteIndices.length == 0) {_            return ImmutableOpenMap.of()__        }__        boolean matchAllAliases = matchAllAliases(aliases)__        ImmutableOpenMap.Builder<String, List<AliasMetaData>> mapBuilder = ImmutableOpenMap.builder()__        for (String index : concreteIndices) {_            IndexMetaData indexMetaData = indices.get(index)__            List<AliasMetaData> filteredValues = new ArrayList<>()__            for (ObjectCursor<AliasMetaData> cursor : indexMetaData.getAliases().values()) {_                AliasMetaData value = cursor.value__                if (matchAllAliases || Regex.simpleMatch(aliases, value.alias())) {_                    filteredValues.add(value)__                }_            }__            if (filteredValues.isEmpty() == false) {_                _                CollectionUtil.timSort(filteredValues, Comparator.comparing(AliasMetaData::alias))__                mapBuilder.put(index, Collections.unmodifiableList(filteredValues))__            }_        }_        return mapBuilder.build()__    };finds,the,specific,index,aliases,that,match,with,the,specified,aliases,directly,or,partially,via,wildcards,and,that,point,to,the,specified,concrete,indices,or,match,partially,with,the,indices,via,wildcards,param,aliases,the,names,of,the,index,aliases,to,find,param,concrete,indices,the,concrete,indexes,the,index,aliases,must,point,to,order,to,be,returned,return,a,map,of,index,to,a,list,of,alias,metadata,the,list,corresponding,to,a,concrete,index,will,be,empty,if,no,aliases,are,present,for,that,index;public,immutable,open,map,string,list,alias,meta,data,find,aliases,final,string,aliases,string,concrete,indices,assert,aliases,null,assert,concrete,indices,null,if,concrete,indices,length,0,return,immutable,open,map,of,boolean,match,all,aliases,match,all,aliases,aliases,immutable,open,map,builder,string,list,alias,meta,data,map,builder,immutable,open,map,builder,for,string,index,concrete,indices,index,meta,data,index,meta,data,indices,get,index,list,alias,meta,data,filtered,values,new,array,list,for,object,cursor,alias,meta,data,cursor,index,meta,data,get,aliases,values,alias,meta,data,value,cursor,value,if,match,all,aliases,regex,simple,match,aliases,value,alias,filtered,values,add,value,if,filtered,values,is,empty,false,collection,util,tim,sort,filtered,values,comparator,comparing,alias,meta,data,alias,map,builder,put,index,collections,unmodifiable,list,filtered,values,return,map,builder,build
MetaData -> public ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final String[] aliases, String[] concreteIndices);1532028790;Finds the specific index aliases that match with the specified aliases directly or partially via wildcards and_that point to the specified concrete indices or match partially with the indices via wildcards.__@param aliases         The names of the index aliases to find_@param concreteIndices The concrete indexes the index aliases must point to order to be returned._@return a map of index to a list of alias metadata, the list corresponding to a concrete index will be empty if no aliases are_present for that index;public ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final String[] aliases, String[] concreteIndices) {_        assert aliases != null__        assert concreteIndices != null__        if (concreteIndices.length == 0) {_            return ImmutableOpenMap.of()__        }__        boolean matchAllAliases = matchAllAliases(aliases)__        ImmutableOpenMap.Builder<String, List<AliasMetaData>> mapBuilder = ImmutableOpenMap.builder()__        for (String index : concreteIndices) {_            IndexMetaData indexMetaData = indices.get(index)__            List<AliasMetaData> filteredValues = new ArrayList<>()__            for (ObjectCursor<AliasMetaData> cursor : indexMetaData.getAliases().values()) {_                AliasMetaData value = cursor.value__                if (matchAllAliases || Regex.simpleMatch(aliases, value.alias())) {_                    filteredValues.add(value)__                }_            }__            if (filteredValues.isEmpty() == false) {_                _                CollectionUtil.timSort(filteredValues, Comparator.comparing(AliasMetaData::alias))__                mapBuilder.put(index, Collections.unmodifiableList(filteredValues))__            }_        }_        return mapBuilder.build()__    };finds,the,specific,index,aliases,that,match,with,the,specified,aliases,directly,or,partially,via,wildcards,and,that,point,to,the,specified,concrete,indices,or,match,partially,with,the,indices,via,wildcards,param,aliases,the,names,of,the,index,aliases,to,find,param,concrete,indices,the,concrete,indexes,the,index,aliases,must,point,to,order,to,be,returned,return,a,map,of,index,to,a,list,of,alias,metadata,the,list,corresponding,to,a,concrete,index,will,be,empty,if,no,aliases,are,present,for,that,index;public,immutable,open,map,string,list,alias,meta,data,find,aliases,final,string,aliases,string,concrete,indices,assert,aliases,null,assert,concrete,indices,null,if,concrete,indices,length,0,return,immutable,open,map,of,boolean,match,all,aliases,match,all,aliases,aliases,immutable,open,map,builder,string,list,alias,meta,data,map,builder,immutable,open,map,builder,for,string,index,concrete,indices,index,meta,data,index,meta,data,indices,get,index,list,alias,meta,data,filtered,values,new,array,list,for,object,cursor,alias,meta,data,cursor,index,meta,data,get,aliases,values,alias,meta,data,value,cursor,value,if,match,all,aliases,regex,simple,match,aliases,value,alias,filtered,values,add,value,if,filtered,values,is,empty,false,collection,util,tim,sort,filtered,values,comparator,comparing,alias,meta,data,alias,map,builder,put,index,collections,unmodifiable,list,filtered,values,return,map,builder,build
MetaData -> public String resolveIndexRouting(@Nullable String routing, String aliasOrIndex);1524684173;Returns indexing routing for the given index.;public String resolveIndexRouting(@Nullable String routing, String aliasOrIndex) {_        if (aliasOrIndex == null) {_            return routing__        }__        AliasOrIndex result = getAliasAndIndexLookup().get(aliasOrIndex)__        if (result == null || result.isAlias() == false) {_            return routing__        }_        AliasOrIndex.Alias alias = (AliasOrIndex.Alias) result__        if (result.getIndices().size() > 1) {_            rejectSingleIndexOperation(aliasOrIndex, result)__        }_        AliasMetaData aliasMd = alias.getFirstAliasMetaData()__        if (aliasMd.indexRouting() != null) {_            if (aliasMd.indexRouting().indexOf(',') != -1) {_                throw new IllegalArgumentException("index/alias [" + aliasOrIndex + "] provided with routing value [" + aliasMd.getIndexRouting() + "] that resolved to several routing values, rejecting operation")__            }_            if (routing != null) {_                if (!routing.equals(aliasMd.indexRouting())) {_                    throw new IllegalArgumentException("Alias [" + aliasOrIndex + "] has index routing associated with it [" + aliasMd.indexRouting() + "], and was provided with routing value [" + routing + "], rejecting operation")__                }_            }_            _            return aliasMd.indexRouting()__        }_        return routing__    };returns,indexing,routing,for,the,given,index;public,string,resolve,index,routing,nullable,string,routing,string,alias,or,index,if,alias,or,index,null,return,routing,alias,or,index,result,get,alias,and,index,lookup,get,alias,or,index,if,result,null,result,is,alias,false,return,routing,alias,or,index,alias,alias,alias,or,index,alias,result,if,result,get,indices,size,1,reject,single,index,operation,alias,or,index,result,alias,meta,data,alias,md,alias,get,first,alias,meta,data,if,alias,md,index,routing,null,if,alias,md,index,routing,index,of,1,throw,new,illegal,argument,exception,index,alias,alias,or,index,provided,with,routing,value,alias,md,get,index,routing,that,resolved,to,several,routing,values,rejecting,operation,if,routing,null,if,routing,equals,alias,md,index,routing,throw,new,illegal,argument,exception,alias,alias,or,index,has,index,routing,associated,with,it,alias,md,index,routing,and,was,provided,with,routing,value,routing,rejecting,operation,return,alias,md,index,routing,return,routing
MetaData -> public String resolveIndexRouting(@Nullable String routing, String aliasOrIndex);1527878678;Returns indexing routing for the given index.;public String resolveIndexRouting(@Nullable String routing, String aliasOrIndex) {_        if (aliasOrIndex == null) {_            return routing__        }__        AliasOrIndex result = getAliasAndIndexLookup().get(aliasOrIndex)__        if (result == null || result.isAlias() == false) {_            return routing__        }_        AliasOrIndex.Alias alias = (AliasOrIndex.Alias) result__        if (result.getIndices().size() > 1) {_            rejectSingleIndexOperation(aliasOrIndex, result)__        }_        AliasMetaData aliasMd = alias.getFirstAliasMetaData()__        if (aliasMd.indexRouting() != null) {_            if (aliasMd.indexRouting().indexOf(',') != -1) {_                throw new IllegalArgumentException("index/alias [" + aliasOrIndex + "] provided with routing value [" + aliasMd.getIndexRouting() + "] that resolved to several routing values, rejecting operation")__            }_            if (routing != null) {_                if (!routing.equals(aliasMd.indexRouting())) {_                    throw new IllegalArgumentException("Alias [" + aliasOrIndex + "] has index routing associated with it [" + aliasMd.indexRouting() + "], and was provided with routing value [" + routing + "], rejecting operation")__                }_            }_            _            return aliasMd.indexRouting()__        }_        return routing__    };returns,indexing,routing,for,the,given,index;public,string,resolve,index,routing,nullable,string,routing,string,alias,or,index,if,alias,or,index,null,return,routing,alias,or,index,result,get,alias,and,index,lookup,get,alias,or,index,if,result,null,result,is,alias,false,return,routing,alias,or,index,alias,alias,alias,or,index,alias,result,if,result,get,indices,size,1,reject,single,index,operation,alias,or,index,result,alias,meta,data,alias,md,alias,get,first,alias,meta,data,if,alias,md,index,routing,null,if,alias,md,index,routing,index,of,1,throw,new,illegal,argument,exception,index,alias,alias,or,index,provided,with,routing,value,alias,md,get,index,routing,that,resolved,to,several,routing,values,rejecting,operation,if,routing,null,if,routing,equals,alias,md,index,routing,throw,new,illegal,argument,exception,alias,alias,or,index,has,index,routing,associated,with,it,alias,md,index,routing,and,was,provided,with,routing,value,routing,rejecting,operation,return,alias,md,index,routing,return,routing
MetaData -> public String resolveIndexRouting(@Nullable String routing, String aliasOrIndex);1528103657;Returns indexing routing for the given index.;public String resolveIndexRouting(@Nullable String routing, String aliasOrIndex) {_        if (aliasOrIndex == null) {_            return routing__        }__        AliasOrIndex result = getAliasAndIndexLookup().get(aliasOrIndex)__        if (result == null || result.isAlias() == false) {_            return routing__        }_        AliasOrIndex.Alias alias = (AliasOrIndex.Alias) result__        if (result.getIndices().size() > 1) {_            rejectSingleIndexOperation(aliasOrIndex, result)__        }_        AliasMetaData aliasMd = alias.getFirstAliasMetaData()__        if (aliasMd.indexRouting() != null) {_            if (aliasMd.indexRouting().indexOf(',') != -1) {_                throw new IllegalArgumentException("index/alias [" + aliasOrIndex + "] provided with routing value [" + aliasMd.getIndexRouting() + "] that resolved to several routing values, rejecting operation")__            }_            if (routing != null) {_                if (!routing.equals(aliasMd.indexRouting())) {_                    throw new IllegalArgumentException("Alias [" + aliasOrIndex + "] has index routing associated with it [" + aliasMd.indexRouting() + "], and was provided with routing value [" + routing + "], rejecting operation")__                }_            }_            _            return aliasMd.indexRouting()__        }_        return routing__    };returns,indexing,routing,for,the,given,index;public,string,resolve,index,routing,nullable,string,routing,string,alias,or,index,if,alias,or,index,null,return,routing,alias,or,index,result,get,alias,and,index,lookup,get,alias,or,index,if,result,null,result,is,alias,false,return,routing,alias,or,index,alias,alias,alias,or,index,alias,result,if,result,get,indices,size,1,reject,single,index,operation,alias,or,index,result,alias,meta,data,alias,md,alias,get,first,alias,meta,data,if,alias,md,index,routing,null,if,alias,md,index,routing,index,of,1,throw,new,illegal,argument,exception,index,alias,alias,or,index,provided,with,routing,value,alias,md,get,index,routing,that,resolved,to,several,routing,values,rejecting,operation,if,routing,null,if,routing,equals,alias,md,index,routing,throw,new,illegal,argument,exception,alias,alias,or,index,has,index,routing,associated,with,it,alias,md,index,routing,and,was,provided,with,routing,value,routing,rejecting,operation,return,alias,md,index,routing,return,routing
MetaData -> public String resolveIndexRouting(@Nullable String routing, String aliasOrIndex);1529082965;Returns indexing routing for the given index.;public String resolveIndexRouting(@Nullable String routing, String aliasOrIndex) {_        if (aliasOrIndex == null) {_            return routing__        }__        AliasOrIndex result = getAliasAndIndexLookup().get(aliasOrIndex)__        if (result == null || result.isAlias() == false) {_            return routing__        }_        AliasOrIndex.Alias alias = (AliasOrIndex.Alias) result__        if (result.getIndices().size() > 1) {_            rejectSingleIndexOperation(aliasOrIndex, result)__        }_        AliasMetaData aliasMd = alias.getFirstAliasMetaData()__        if (aliasMd.indexRouting() != null) {_            if (aliasMd.indexRouting().indexOf(',') != -1) {_                throw new IllegalArgumentException("index/alias [" + aliasOrIndex + "] provided with routing value [" + aliasMd.getIndexRouting() + "] that resolved to several routing values, rejecting operation")__            }_            if (routing != null) {_                if (!routing.equals(aliasMd.indexRouting())) {_                    throw new IllegalArgumentException("Alias [" + aliasOrIndex + "] has index routing associated with it [" + aliasMd.indexRouting() + "], and was provided with routing value [" + routing + "], rejecting operation")__                }_            }_            _            return aliasMd.indexRouting()__        }_        return routing__    };returns,indexing,routing,for,the,given,index;public,string,resolve,index,routing,nullable,string,routing,string,alias,or,index,if,alias,or,index,null,return,routing,alias,or,index,result,get,alias,and,index,lookup,get,alias,or,index,if,result,null,result,is,alias,false,return,routing,alias,or,index,alias,alias,alias,or,index,alias,result,if,result,get,indices,size,1,reject,single,index,operation,alias,or,index,result,alias,meta,data,alias,md,alias,get,first,alias,meta,data,if,alias,md,index,routing,null,if,alias,md,index,routing,index,of,1,throw,new,illegal,argument,exception,index,alias,alias,or,index,provided,with,routing,value,alias,md,get,index,routing,that,resolved,to,several,routing,values,rejecting,operation,if,routing,null,if,routing,equals,alias,md,index,routing,throw,new,illegal,argument,exception,alias,alias,or,index,has,index,routing,associated,with,it,alias,md,index,routing,and,was,provided,with,routing,value,routing,rejecting,operation,return,alias,md,index,routing,return,routing
MetaData -> public String resolveIndexRouting(@Nullable String routing, String aliasOrIndex);1531179852;Returns indexing routing for the given index.;public String resolveIndexRouting(@Nullable String routing, String aliasOrIndex) {_        if (aliasOrIndex == null) {_            return routing__        }__        AliasOrIndex result = getAliasAndIndexLookup().get(aliasOrIndex)__        if (result == null || result.isAlias() == false) {_            return routing__        }_        AliasOrIndex.Alias alias = (AliasOrIndex.Alias) result__        if (result.getIndices().size() > 1) {_            rejectSingleIndexOperation(aliasOrIndex, result)__        }_        AliasMetaData aliasMd = alias.getFirstAliasMetaData()__        if (aliasMd.indexRouting() != null) {_            if (aliasMd.indexRouting().indexOf(',') != -1) {_                throw new IllegalArgumentException("index/alias [" + aliasOrIndex + "] provided with routing value [" + aliasMd.getIndexRouting() + "] that resolved to several routing values, rejecting operation")__            }_            if (routing != null) {_                if (!routing.equals(aliasMd.indexRouting())) {_                    throw new IllegalArgumentException("Alias [" + aliasOrIndex + "] has index routing associated with it [" + aliasMd.indexRouting() + "], and was provided with routing value [" + routing + "], rejecting operation")__                }_            }_            _            return aliasMd.indexRouting()__        }_        return routing__    };returns,indexing,routing,for,the,given,index;public,string,resolve,index,routing,nullable,string,routing,string,alias,or,index,if,alias,or,index,null,return,routing,alias,or,index,result,get,alias,and,index,lookup,get,alias,or,index,if,result,null,result,is,alias,false,return,routing,alias,or,index,alias,alias,alias,or,index,alias,result,if,result,get,indices,size,1,reject,single,index,operation,alias,or,index,result,alias,meta,data,alias,md,alias,get,first,alias,meta,data,if,alias,md,index,routing,null,if,alias,md,index,routing,index,of,1,throw,new,illegal,argument,exception,index,alias,alias,or,index,provided,with,routing,value,alias,md,get,index,routing,that,resolved,to,several,routing,values,rejecting,operation,if,routing,null,if,routing,equals,alias,md,index,routing,throw,new,illegal,argument,exception,alias,alias,or,index,has,index,routing,associated,with,it,alias,md,index,routing,and,was,provided,with,routing,value,routing,rejecting,operation,return,alias,md,index,routing,return,routing
MetaData -> public String resolveIndexRouting(@Nullable String routing, String aliasOrIndex);1532028790;Returns indexing routing for the given index.;public String resolveIndexRouting(@Nullable String routing, String aliasOrIndex) {_        if (aliasOrIndex == null) {_            return routing__        }__        AliasOrIndex result = getAliasAndIndexLookup().get(aliasOrIndex)__        if (result == null || result.isAlias() == false) {_            return routing__        }_        AliasOrIndex.Alias alias = (AliasOrIndex.Alias) result__        if (result.getIndices().size() > 1) {_            rejectSingleIndexOperation(aliasOrIndex, result)__        }_        AliasMetaData aliasMd = alias.getFirstAliasMetaData()__        if (aliasMd.indexRouting() != null) {_            if (aliasMd.indexRouting().indexOf(',') != -1) {_                throw new IllegalArgumentException("index/alias [" + aliasOrIndex + "] provided with routing value [" + aliasMd.getIndexRouting() + "] that resolved to several routing values, rejecting operation")__            }_            if (routing != null) {_                if (!routing.equals(aliasMd.indexRouting())) {_                    throw new IllegalArgumentException("Alias [" + aliasOrIndex + "] has index routing associated with it [" + aliasMd.indexRouting() + "], and was provided with routing value [" + routing + "], rejecting operation")__                }_            }_            _            return aliasMd.indexRouting()__        }_        return routing__    };returns,indexing,routing,for,the,given,index;public,string,resolve,index,routing,nullable,string,routing,string,alias,or,index,if,alias,or,index,null,return,routing,alias,or,index,result,get,alias,and,index,lookup,get,alias,or,index,if,result,null,result,is,alias,false,return,routing,alias,or,index,alias,alias,alias,or,index,alias,result,if,result,get,indices,size,1,reject,single,index,operation,alias,or,index,result,alias,meta,data,alias,md,alias,get,first,alias,meta,data,if,alias,md,index,routing,null,if,alias,md,index,routing,index,of,1,throw,new,illegal,argument,exception,index,alias,alias,or,index,provided,with,routing,value,alias,md,get,index,routing,that,resolved,to,several,routing,values,rejecting,operation,if,routing,null,if,routing,equals,alias,md,index,routing,throw,new,illegal,argument,exception,alias,alias,or,index,has,index,routing,associated,with,it,alias,md,index,routing,and,was,provided,with,routing,value,routing,rejecting,operation,return,alias,md,index,routing,return,routing
MetaData -> public String resolveIndexRouting(@Nullable String routing, String aliasOrIndex);1532353780;Returns indexing routing for the given index.;public String resolveIndexRouting(@Nullable String routing, String aliasOrIndex) {_        if (aliasOrIndex == null) {_            return routing__        }__        AliasOrIndex result = getAliasAndIndexLookup().get(aliasOrIndex)__        if (result == null || result.isAlias() == false) {_            return routing__        }_        AliasOrIndex.Alias alias = (AliasOrIndex.Alias) result__        if (result.getIndices().size() > 1) {_            rejectSingleIndexOperation(aliasOrIndex, result)__        }_        AliasMetaData aliasMd = alias.getFirstAliasMetaData()__        if (aliasMd.indexRouting() != null) {_            if (aliasMd.indexRouting().indexOf(',') != -1) {_                throw new IllegalArgumentException("index/alias [" + aliasOrIndex + "] provided with routing value [" + aliasMd.getIndexRouting() + "] that resolved to several routing values, rejecting operation")__            }_            if (routing != null) {_                if (!routing.equals(aliasMd.indexRouting())) {_                    throw new IllegalArgumentException("Alias [" + aliasOrIndex + "] has index routing associated with it [" + aliasMd.indexRouting() + "], and was provided with routing value [" + routing + "], rejecting operation")__                }_            }_            _            return aliasMd.indexRouting()__        }_        return routing__    };returns,indexing,routing,for,the,given,index;public,string,resolve,index,routing,nullable,string,routing,string,alias,or,index,if,alias,or,index,null,return,routing,alias,or,index,result,get,alias,and,index,lookup,get,alias,or,index,if,result,null,result,is,alias,false,return,routing,alias,or,index,alias,alias,alias,or,index,alias,result,if,result,get,indices,size,1,reject,single,index,operation,alias,or,index,result,alias,meta,data,alias,md,alias,get,first,alias,meta,data,if,alias,md,index,routing,null,if,alias,md,index,routing,index,of,1,throw,new,illegal,argument,exception,index,alias,alias,or,index,provided,with,routing,value,alias,md,get,index,routing,that,resolved,to,several,routing,values,rejecting,operation,if,routing,null,if,routing,equals,alias,md,index,routing,throw,new,illegal,argument,exception,alias,alias,or,index,has,index,routing,associated,with,it,alias,md,index,routing,and,was,provided,with,routing,value,routing,rejecting,operation,return,alias,md,index,routing,return,routing
MetaData -> public String resolveIndexRouting(@Nullable String routing, String aliasOrIndex);1536611444;Returns indexing routing for the given index.;public String resolveIndexRouting(@Nullable String routing, String aliasOrIndex) {_        if (aliasOrIndex == null) {_            return routing__        }__        AliasOrIndex result = getAliasAndIndexLookup().get(aliasOrIndex)__        if (result == null || result.isAlias() == false) {_            return routing__        }_        AliasOrIndex.Alias alias = (AliasOrIndex.Alias) result__        if (result.getIndices().size() > 1) {_            rejectSingleIndexOperation(aliasOrIndex, result)__        }_        AliasMetaData aliasMd = alias.getFirstAliasMetaData()__        if (aliasMd.indexRouting() != null) {_            if (aliasMd.indexRouting().indexOf(',') != -1) {_                throw new IllegalArgumentException("index/alias [" + aliasOrIndex + "] provided with routing value [" + aliasMd.getIndexRouting() + "] that resolved to several routing values, rejecting operation")__            }_            if (routing != null) {_                if (!routing.equals(aliasMd.indexRouting())) {_                    throw new IllegalArgumentException("Alias [" + aliasOrIndex + "] has index routing associated with it [" + aliasMd.indexRouting() + "], and was provided with routing value [" + routing + "], rejecting operation")__                }_            }_            _            return aliasMd.indexRouting()__        }_        return routing__    };returns,indexing,routing,for,the,given,index;public,string,resolve,index,routing,nullable,string,routing,string,alias,or,index,if,alias,or,index,null,return,routing,alias,or,index,result,get,alias,and,index,lookup,get,alias,or,index,if,result,null,result,is,alias,false,return,routing,alias,or,index,alias,alias,alias,or,index,alias,result,if,result,get,indices,size,1,reject,single,index,operation,alias,or,index,result,alias,meta,data,alias,md,alias,get,first,alias,meta,data,if,alias,md,index,routing,null,if,alias,md,index,routing,index,of,1,throw,new,illegal,argument,exception,index,alias,alias,or,index,provided,with,routing,value,alias,md,get,index,routing,that,resolved,to,several,routing,values,rejecting,operation,if,routing,null,if,routing,equals,alias,md,index,routing,throw,new,illegal,argument,exception,alias,alias,or,index,has,index,routing,associated,with,it,alias,md,index,routing,and,was,provided,with,routing,value,routing,rejecting,operation,return,alias,md,index,routing,return,routing
MetaData -> public String resolveIndexRouting(@Nullable String routing, String aliasOrIndex);1539723533;Returns indexing routing for the given index.;public String resolveIndexRouting(@Nullable String routing, String aliasOrIndex) {_        if (aliasOrIndex == null) {_            return routing__        }__        AliasOrIndex result = getAliasAndIndexLookup().get(aliasOrIndex)__        if (result == null || result.isAlias() == false) {_            return routing__        }_        AliasOrIndex.Alias alias = (AliasOrIndex.Alias) result__        if (result.getIndices().size() > 1) {_            rejectSingleIndexOperation(aliasOrIndex, result)__        }_        AliasMetaData aliasMd = alias.getFirstAliasMetaData()__        if (aliasMd.indexRouting() != null) {_            if (aliasMd.indexRouting().indexOf(',') != -1) {_                throw new IllegalArgumentException("index/alias [" + aliasOrIndex + "] provided with routing value [" + aliasMd.getIndexRouting() + "] that resolved to several routing values, rejecting operation")__            }_            if (routing != null) {_                if (!routing.equals(aliasMd.indexRouting())) {_                    throw new IllegalArgumentException("Alias [" + aliasOrIndex + "] has index routing associated with it [" + aliasMd.indexRouting() + "], and was provided with routing value [" + routing + "], rejecting operation")__                }_            }_            _            return aliasMd.indexRouting()__        }_        return routing__    };returns,indexing,routing,for,the,given,index;public,string,resolve,index,routing,nullable,string,routing,string,alias,or,index,if,alias,or,index,null,return,routing,alias,or,index,result,get,alias,and,index,lookup,get,alias,or,index,if,result,null,result,is,alias,false,return,routing,alias,or,index,alias,alias,alias,or,index,alias,result,if,result,get,indices,size,1,reject,single,index,operation,alias,or,index,result,alias,meta,data,alias,md,alias,get,first,alias,meta,data,if,alias,md,index,routing,null,if,alias,md,index,routing,index,of,1,throw,new,illegal,argument,exception,index,alias,alias,or,index,provided,with,routing,value,alias,md,get,index,routing,that,resolved,to,several,routing,values,rejecting,operation,if,routing,null,if,routing,equals,alias,md,index,routing,throw,new,illegal,argument,exception,alias,alias,or,index,has,index,routing,associated,with,it,alias,md,index,routing,and,was,provided,with,routing,value,routing,rejecting,operation,return,alias,md,index,routing,return,routing
MetaData -> public String resolveIndexRouting(@Nullable String routing, String aliasOrIndex);1540313026;Returns indexing routing for the given index.;public String resolveIndexRouting(@Nullable String routing, String aliasOrIndex) {_        if (aliasOrIndex == null) {_            return routing__        }__        AliasOrIndex result = getAliasAndIndexLookup().get(aliasOrIndex)__        if (result == null || result.isAlias() == false) {_            return routing__        }_        AliasOrIndex.Alias alias = (AliasOrIndex.Alias) result__        if (result.getIndices().size() > 1) {_            rejectSingleIndexOperation(aliasOrIndex, result)__        }_        AliasMetaData aliasMd = alias.getFirstAliasMetaData()__        if (aliasMd.indexRouting() != null) {_            if (aliasMd.indexRouting().indexOf(',') != -1) {_                throw new IllegalArgumentException("index/alias [" + aliasOrIndex + "] provided with routing value [" + aliasMd.getIndexRouting() + "] that resolved to several routing values, rejecting operation")__            }_            if (routing != null) {_                if (!routing.equals(aliasMd.indexRouting())) {_                    throw new IllegalArgumentException("Alias [" + aliasOrIndex + "] has index routing associated with it [" + aliasMd.indexRouting() + "], and was provided with routing value [" + routing + "], rejecting operation")__                }_            }_            _            return aliasMd.indexRouting()__        }_        return routing__    };returns,indexing,routing,for,the,given,index;public,string,resolve,index,routing,nullable,string,routing,string,alias,or,index,if,alias,or,index,null,return,routing,alias,or,index,result,get,alias,and,index,lookup,get,alias,or,index,if,result,null,result,is,alias,false,return,routing,alias,or,index,alias,alias,alias,or,index,alias,result,if,result,get,indices,size,1,reject,single,index,operation,alias,or,index,result,alias,meta,data,alias,md,alias,get,first,alias,meta,data,if,alias,md,index,routing,null,if,alias,md,index,routing,index,of,1,throw,new,illegal,argument,exception,index,alias,alias,or,index,provided,with,routing,value,alias,md,get,index,routing,that,resolved,to,several,routing,values,rejecting,operation,if,routing,null,if,routing,equals,alias,md,index,routing,throw,new,illegal,argument,exception,alias,alias,or,index,has,index,routing,associated,with,it,alias,md,index,routing,and,was,provided,with,routing,value,routing,rejecting,operation,return,alias,md,index,routing,return,routing
MetaData -> public String resolveIndexRouting(@Nullable String routing, String aliasOrIndex);1540486836;Returns indexing routing for the given index.;public String resolveIndexRouting(@Nullable String routing, String aliasOrIndex) {_        if (aliasOrIndex == null) {_            return routing__        }__        AliasOrIndex result = getAliasAndIndexLookup().get(aliasOrIndex)__        if (result == null || result.isAlias() == false) {_            return routing__        }_        AliasOrIndex.Alias alias = (AliasOrIndex.Alias) result__        if (result.getIndices().size() > 1) {_            rejectSingleIndexOperation(aliasOrIndex, result)__        }_        AliasMetaData aliasMd = alias.getFirstAliasMetaData()__        if (aliasMd.indexRouting() != null) {_            if (aliasMd.indexRouting().indexOf(',') != -1) {_                throw new IllegalArgumentException("index/alias [" + aliasOrIndex + "] provided with routing value [" + aliasMd.getIndexRouting() + "] that resolved to several routing values, rejecting operation")__            }_            if (routing != null) {_                if (!routing.equals(aliasMd.indexRouting())) {_                    throw new IllegalArgumentException("Alias [" + aliasOrIndex + "] has index routing associated with it [" + aliasMd.indexRouting() + "], and was provided with routing value [" + routing + "], rejecting operation")__                }_            }_            _            return aliasMd.indexRouting()__        }_        return routing__    };returns,indexing,routing,for,the,given,index;public,string,resolve,index,routing,nullable,string,routing,string,alias,or,index,if,alias,or,index,null,return,routing,alias,or,index,result,get,alias,and,index,lookup,get,alias,or,index,if,result,null,result,is,alias,false,return,routing,alias,or,index,alias,alias,alias,or,index,alias,result,if,result,get,indices,size,1,reject,single,index,operation,alias,or,index,result,alias,meta,data,alias,md,alias,get,first,alias,meta,data,if,alias,md,index,routing,null,if,alias,md,index,routing,index,of,1,throw,new,illegal,argument,exception,index,alias,alias,or,index,provided,with,routing,value,alias,md,get,index,routing,that,resolved,to,several,routing,values,rejecting,operation,if,routing,null,if,routing,equals,alias,md,index,routing,throw,new,illegal,argument,exception,alias,alias,or,index,has,index,routing,associated,with,it,alias,md,index,routing,and,was,provided,with,routing,value,routing,rejecting,operation,return,alias,md,index,routing,return,routing
MetaData -> public String resolveIndexRouting(@Nullable String routing, String aliasOrIndex);1540847035;Returns indexing routing for the given index.;public String resolveIndexRouting(@Nullable String routing, String aliasOrIndex) {_        if (aliasOrIndex == null) {_            return routing__        }__        AliasOrIndex result = getAliasAndIndexLookup().get(aliasOrIndex)__        if (result == null || result.isAlias() == false) {_            return routing__        }_        AliasOrIndex.Alias alias = (AliasOrIndex.Alias) result__        if (result.getIndices().size() > 1) {_            rejectSingleIndexOperation(aliasOrIndex, result)__        }_        AliasMetaData aliasMd = alias.getFirstAliasMetaData()__        if (aliasMd.indexRouting() != null) {_            if (aliasMd.indexRouting().indexOf(',') != -1) {_                throw new IllegalArgumentException("index/alias [" + aliasOrIndex + "] provided with routing value [" +_                    aliasMd.getIndexRouting() + "] that resolved to several routing values, rejecting operation")__            }_            if (routing != null) {_                if (!routing.equals(aliasMd.indexRouting())) {_                    throw new IllegalArgumentException("Alias [" + aliasOrIndex + "] has index routing associated with it [" +_                        aliasMd.indexRouting() + "], and was provided with routing value [" + routing + "], rejecting operation")__                }_            }_            _            return aliasMd.indexRouting()__        }_        return routing__    };returns,indexing,routing,for,the,given,index;public,string,resolve,index,routing,nullable,string,routing,string,alias,or,index,if,alias,or,index,null,return,routing,alias,or,index,result,get,alias,and,index,lookup,get,alias,or,index,if,result,null,result,is,alias,false,return,routing,alias,or,index,alias,alias,alias,or,index,alias,result,if,result,get,indices,size,1,reject,single,index,operation,alias,or,index,result,alias,meta,data,alias,md,alias,get,first,alias,meta,data,if,alias,md,index,routing,null,if,alias,md,index,routing,index,of,1,throw,new,illegal,argument,exception,index,alias,alias,or,index,provided,with,routing,value,alias,md,get,index,routing,that,resolved,to,several,routing,values,rejecting,operation,if,routing,null,if,routing,equals,alias,md,index,routing,throw,new,illegal,argument,exception,alias,alias,or,index,has,index,routing,associated,with,it,alias,md,index,routing,and,was,provided,with,routing,value,routing,rejecting,operation,return,alias,md,index,routing,return,routing
MetaData -> public String resolveIndexRouting(@Nullable String routing, String aliasOrIndex);1543947737;Returns indexing routing for the given index.;public String resolveIndexRouting(@Nullable String routing, String aliasOrIndex) {_        if (aliasOrIndex == null) {_            return routing__        }__        AliasOrIndex result = getAliasAndIndexLookup().get(aliasOrIndex)__        if (result == null || result.isAlias() == false) {_            return routing__        }_        AliasOrIndex.Alias alias = (AliasOrIndex.Alias) result__        if (result.getIndices().size() > 1) {_            rejectSingleIndexOperation(aliasOrIndex, result)__        }_        AliasMetaData aliasMd = alias.getFirstAliasMetaData()__        if (aliasMd.indexRouting() != null) {_            if (aliasMd.indexRouting().indexOf(',') != -1) {_                throw new IllegalArgumentException("index/alias [" + aliasOrIndex + "] provided with routing value [" +_                    aliasMd.getIndexRouting() + "] that resolved to several routing values, rejecting operation")__            }_            if (routing != null) {_                if (!routing.equals(aliasMd.indexRouting())) {_                    throw new IllegalArgumentException("Alias [" + aliasOrIndex + "] has index routing associated with it [" +_                        aliasMd.indexRouting() + "], and was provided with routing value [" + routing + "], rejecting operation")__                }_            }_            _            return aliasMd.indexRouting()__        }_        return routing__    };returns,indexing,routing,for,the,given,index;public,string,resolve,index,routing,nullable,string,routing,string,alias,or,index,if,alias,or,index,null,return,routing,alias,or,index,result,get,alias,and,index,lookup,get,alias,or,index,if,result,null,result,is,alias,false,return,routing,alias,or,index,alias,alias,alias,or,index,alias,result,if,result,get,indices,size,1,reject,single,index,operation,alias,or,index,result,alias,meta,data,alias,md,alias,get,first,alias,meta,data,if,alias,md,index,routing,null,if,alias,md,index,routing,index,of,1,throw,new,illegal,argument,exception,index,alias,alias,or,index,provided,with,routing,value,alias,md,get,index,routing,that,resolved,to,several,routing,values,rejecting,operation,if,routing,null,if,routing,equals,alias,md,index,routing,throw,new,illegal,argument,exception,alias,alias,or,index,has,index,routing,associated,with,it,alias,md,index,routing,and,was,provided,with,routing,value,routing,rejecting,operation,return,alias,md,index,routing,return,routing
MetaData -> public String resolveIndexRouting(@Nullable String routing, String aliasOrIndex);1544081506;Returns indexing routing for the given index.;public String resolveIndexRouting(@Nullable String routing, String aliasOrIndex) {_        if (aliasOrIndex == null) {_            return routing__        }__        AliasOrIndex result = getAliasAndIndexLookup().get(aliasOrIndex)__        if (result == null || result.isAlias() == false) {_            return routing__        }_        AliasOrIndex.Alias alias = (AliasOrIndex.Alias) result__        if (result.getIndices().size() > 1) {_            rejectSingleIndexOperation(aliasOrIndex, result)__        }_        AliasMetaData aliasMd = alias.getFirstAliasMetaData()__        if (aliasMd.indexRouting() != null) {_            if (aliasMd.indexRouting().indexOf(',') != -1) {_                throw new IllegalArgumentException("index/alias [" + aliasOrIndex + "] provided with routing value [" +_                    aliasMd.getIndexRouting() + "] that resolved to several routing values, rejecting operation")__            }_            if (routing != null) {_                if (!routing.equals(aliasMd.indexRouting())) {_                    throw new IllegalArgumentException("Alias [" + aliasOrIndex + "] has index routing associated with it [" +_                        aliasMd.indexRouting() + "], and was provided with routing value [" + routing + "], rejecting operation")__                }_            }_            _            return aliasMd.indexRouting()__        }_        return routing__    };returns,indexing,routing,for,the,given,index;public,string,resolve,index,routing,nullable,string,routing,string,alias,or,index,if,alias,or,index,null,return,routing,alias,or,index,result,get,alias,and,index,lookup,get,alias,or,index,if,result,null,result,is,alias,false,return,routing,alias,or,index,alias,alias,alias,or,index,alias,result,if,result,get,indices,size,1,reject,single,index,operation,alias,or,index,result,alias,meta,data,alias,md,alias,get,first,alias,meta,data,if,alias,md,index,routing,null,if,alias,md,index,routing,index,of,1,throw,new,illegal,argument,exception,index,alias,alias,or,index,provided,with,routing,value,alias,md,get,index,routing,that,resolved,to,several,routing,values,rejecting,operation,if,routing,null,if,routing,equals,alias,md,index,routing,throw,new,illegal,argument,exception,alias,alias,or,index,has,index,routing,associated,with,it,alias,md,index,routing,and,was,provided,with,routing,value,routing,rejecting,operation,return,alias,md,index,routing,return,routing
MetaData -> public String resolveIndexRouting(@Nullable String routing, String aliasOrIndex);1544702062;Returns indexing routing for the given index.;public String resolveIndexRouting(@Nullable String routing, String aliasOrIndex) {_        if (aliasOrIndex == null) {_            return routing__        }__        AliasOrIndex result = getAliasAndIndexLookup().get(aliasOrIndex)__        if (result == null || result.isAlias() == false) {_            return routing__        }_        AliasOrIndex.Alias alias = (AliasOrIndex.Alias) result__        if (result.getIndices().size() > 1) {_            rejectSingleIndexOperation(aliasOrIndex, result)__        }_        AliasMetaData aliasMd = alias.getFirstAliasMetaData()__        if (aliasMd.indexRouting() != null) {_            if (aliasMd.indexRouting().indexOf(',') != -1) {_                throw new IllegalArgumentException("index/alias [" + aliasOrIndex + "] provided with routing value [" +_                    aliasMd.getIndexRouting() + "] that resolved to several routing values, rejecting operation")__            }_            if (routing != null) {_                if (!routing.equals(aliasMd.indexRouting())) {_                    throw new IllegalArgumentException("Alias [" + aliasOrIndex + "] has index routing associated with it [" +_                        aliasMd.indexRouting() + "], and was provided with routing value [" + routing + "], rejecting operation")__                }_            }_            _            return aliasMd.indexRouting()__        }_        return routing__    };returns,indexing,routing,for,the,given,index;public,string,resolve,index,routing,nullable,string,routing,string,alias,or,index,if,alias,or,index,null,return,routing,alias,or,index,result,get,alias,and,index,lookup,get,alias,or,index,if,result,null,result,is,alias,false,return,routing,alias,or,index,alias,alias,alias,or,index,alias,result,if,result,get,indices,size,1,reject,single,index,operation,alias,or,index,result,alias,meta,data,alias,md,alias,get,first,alias,meta,data,if,alias,md,index,routing,null,if,alias,md,index,routing,index,of,1,throw,new,illegal,argument,exception,index,alias,alias,or,index,provided,with,routing,value,alias,md,get,index,routing,that,resolved,to,several,routing,values,rejecting,operation,if,routing,null,if,routing,equals,alias,md,index,routing,throw,new,illegal,argument,exception,alias,alias,or,index,has,index,routing,associated,with,it,alias,md,index,routing,and,was,provided,with,routing,value,routing,rejecting,operation,return,alias,md,index,routing,return,routing
MetaData -> public String resolveIndexRouting(@Nullable String routing, String aliasOrIndex);1547500081;Returns indexing routing for the given index.;public String resolveIndexRouting(@Nullable String routing, String aliasOrIndex) {_        if (aliasOrIndex == null) {_            return routing__        }__        AliasOrIndex result = getAliasAndIndexLookup().get(aliasOrIndex)__        if (result == null || result.isAlias() == false) {_            return routing__        }_        AliasOrIndex.Alias alias = (AliasOrIndex.Alias) result__        if (result.getIndices().size() > 1) {_            rejectSingleIndexOperation(aliasOrIndex, result)__        }_        AliasMetaData aliasMd = alias.getFirstAliasMetaData()__        if (aliasMd.indexRouting() != null) {_            if (aliasMd.indexRouting().indexOf(',') != -1) {_                throw new IllegalArgumentException("index/alias [" + aliasOrIndex + "] provided with routing value [" +_                    aliasMd.getIndexRouting() + "] that resolved to several routing values, rejecting operation")__            }_            if (routing != null) {_                if (!routing.equals(aliasMd.indexRouting())) {_                    throw new IllegalArgumentException("Alias [" + aliasOrIndex + "] has index routing associated with it [" +_                        aliasMd.indexRouting() + "], and was provided with routing value [" + routing + "], rejecting operation")__                }_            }_            _            return aliasMd.indexRouting()__        }_        return routing__    };returns,indexing,routing,for,the,given,index;public,string,resolve,index,routing,nullable,string,routing,string,alias,or,index,if,alias,or,index,null,return,routing,alias,or,index,result,get,alias,and,index,lookup,get,alias,or,index,if,result,null,result,is,alias,false,return,routing,alias,or,index,alias,alias,alias,or,index,alias,result,if,result,get,indices,size,1,reject,single,index,operation,alias,or,index,result,alias,meta,data,alias,md,alias,get,first,alias,meta,data,if,alias,md,index,routing,null,if,alias,md,index,routing,index,of,1,throw,new,illegal,argument,exception,index,alias,alias,or,index,provided,with,routing,value,alias,md,get,index,routing,that,resolved,to,several,routing,values,rejecting,operation,if,routing,null,if,routing,equals,alias,md,index,routing,throw,new,illegal,argument,exception,alias,alias,or,index,has,index,routing,associated,with,it,alias,md,index,routing,and,was,provided,with,routing,value,routing,rejecting,operation,return,alias,md,index,routing,return,routing
MetaData -> public String resolveIndexRouting(@Nullable String routing, String aliasOrIndex);1548772865;Returns indexing routing for the given index.;public String resolveIndexRouting(@Nullable String routing, String aliasOrIndex) {_        if (aliasOrIndex == null) {_            return routing__        }__        AliasOrIndex result = getAliasAndIndexLookup().get(aliasOrIndex)__        if (result == null || result.isAlias() == false) {_            return routing__        }_        AliasOrIndex.Alias alias = (AliasOrIndex.Alias) result__        if (result.getIndices().size() > 1) {_            rejectSingleIndexOperation(aliasOrIndex, result)__        }_        AliasMetaData aliasMd = alias.getFirstAliasMetaData()__        if (aliasMd.indexRouting() != null) {_            if (aliasMd.indexRouting().indexOf(',') != -1) {_                throw new IllegalArgumentException("index/alias [" + aliasOrIndex + "] provided with routing value [" +_                    aliasMd.getIndexRouting() + "] that resolved to several routing values, rejecting operation")__            }_            if (routing != null) {_                if (!routing.equals(aliasMd.indexRouting())) {_                    throw new IllegalArgumentException("Alias [" + aliasOrIndex + "] has index routing associated with it [" +_                        aliasMd.indexRouting() + "], and was provided with routing value [" + routing + "], rejecting operation")__                }_            }_            _            return aliasMd.indexRouting()__        }_        return routing__    };returns,indexing,routing,for,the,given,index;public,string,resolve,index,routing,nullable,string,routing,string,alias,or,index,if,alias,or,index,null,return,routing,alias,or,index,result,get,alias,and,index,lookup,get,alias,or,index,if,result,null,result,is,alias,false,return,routing,alias,or,index,alias,alias,alias,or,index,alias,result,if,result,get,indices,size,1,reject,single,index,operation,alias,or,index,result,alias,meta,data,alias,md,alias,get,first,alias,meta,data,if,alias,md,index,routing,null,if,alias,md,index,routing,index,of,1,throw,new,illegal,argument,exception,index,alias,alias,or,index,provided,with,routing,value,alias,md,get,index,routing,that,resolved,to,several,routing,values,rejecting,operation,if,routing,null,if,routing,equals,alias,md,index,routing,throw,new,illegal,argument,exception,alias,alias,or,index,has,index,routing,associated,with,it,alias,md,index,routing,and,was,provided,with,routing,value,routing,rejecting,operation,return,alias,md,index,routing,return,routing
MetaData -> public int getNumberOfShards();1540486836;Gets the number of primary shards from all indices, not including_replicas._@return The number of primary shards from all indices.;public int getNumberOfShards() {_        return this.numberOfShards__    };gets,the,number,of,primary,shards,from,all,indices,not,including,replicas,return,the,number,of,primary,shards,from,all,indices;public,int,get,number,of,shards,return,this,number,of,shards
MetaData -> public int getNumberOfShards();1540847035;Gets the number of primary shards from all indices, not including_replicas._@return The number of primary shards from all indices.;public int getNumberOfShards() {_        return this.numberOfShards__    };gets,the,number,of,primary,shards,from,all,indices,not,including,replicas,return,the,number,of,primary,shards,from,all,indices;public,int,get,number,of,shards,return,this,number,of,shards
MetaData -> public int getNumberOfShards();1543947737;Gets the number of primary shards from all indices, not including_replicas._@return The number of primary shards from all indices.;public int getNumberOfShards() {_        return this.numberOfShards__    };gets,the,number,of,primary,shards,from,all,indices,not,including,replicas,return,the,number,of,primary,shards,from,all,indices;public,int,get,number,of,shards,return,this,number,of,shards
MetaData -> public int getNumberOfShards();1544081506;Gets the number of primary shards from all indices, not including_replicas._@return The number of primary shards from all indices.;public int getNumberOfShards() {_        return this.numberOfShards__    };gets,the,number,of,primary,shards,from,all,indices,not,including,replicas,return,the,number,of,primary,shards,from,all,indices;public,int,get,number,of,shards,return,this,number,of,shards
MetaData -> public ImmutableOpenMap<String, List<AliasMetaData>> findAllAliases(String[] concreteIndices);1532353780;Finds the specific index aliases that point to the specified concrete indices or match partially with the indices via wildcards.__@param concreteIndices The concrete indexes the index aliases must point to order to be returned._@return a map of index to a list of alias metadata, the list corresponding to a concrete index will be empty if no aliases are_present for that index;public ImmutableOpenMap<String, List<AliasMetaData>> findAllAliases(String[] concreteIndices) {_        return findAliases(Strings.EMPTY_ARRAY, Strings.EMPTY_ARRAY, concreteIndices)__    };finds,the,specific,index,aliases,that,point,to,the,specified,concrete,indices,or,match,partially,with,the,indices,via,wildcards,param,concrete,indices,the,concrete,indexes,the,index,aliases,must,point,to,order,to,be,returned,return,a,map,of,index,to,a,list,of,alias,metadata,the,list,corresponding,to,a,concrete,index,will,be,empty,if,no,aliases,are,present,for,that,index;public,immutable,open,map,string,list,alias,meta,data,find,all,aliases,string,concrete,indices,return,find,aliases,strings,strings,concrete,indices
MetaData -> public ImmutableOpenMap<String, List<AliasMetaData>> findAllAliases(String[] concreteIndices);1536611444;Finds the specific index aliases that point to the specified concrete indices or match partially with the indices via wildcards.__@param concreteIndices The concrete indexes the index aliases must point to order to be returned._@return a map of index to a list of alias metadata, the list corresponding to a concrete index will be empty if no aliases are_present for that index;public ImmutableOpenMap<String, List<AliasMetaData>> findAllAliases(String[] concreteIndices) {_        return findAliases(Strings.EMPTY_ARRAY, Strings.EMPTY_ARRAY, concreteIndices)__    };finds,the,specific,index,aliases,that,point,to,the,specified,concrete,indices,or,match,partially,with,the,indices,via,wildcards,param,concrete,indices,the,concrete,indexes,the,index,aliases,must,point,to,order,to,be,returned,return,a,map,of,index,to,a,list,of,alias,metadata,the,list,corresponding,to,a,concrete,index,will,be,empty,if,no,aliases,are,present,for,that,index;public,immutable,open,map,string,list,alias,meta,data,find,all,aliases,string,concrete,indices,return,find,aliases,strings,strings,concrete,indices
MetaData -> public ImmutableOpenMap<String, List<AliasMetaData>> findAllAliases(String[] concreteIndices);1539723533;Finds the specific index aliases that point to the specified concrete indices or match partially with the indices via wildcards.__@param concreteIndices The concrete indexes the index aliases must point to order to be returned._@return a map of index to a list of alias metadata, the list corresponding to a concrete index will be empty if no aliases are_present for that index;public ImmutableOpenMap<String, List<AliasMetaData>> findAllAliases(String[] concreteIndices) {_        return findAliases(Strings.EMPTY_ARRAY, Strings.EMPTY_ARRAY, concreteIndices)__    };finds,the,specific,index,aliases,that,point,to,the,specified,concrete,indices,or,match,partially,with,the,indices,via,wildcards,param,concrete,indices,the,concrete,indexes,the,index,aliases,must,point,to,order,to,be,returned,return,a,map,of,index,to,a,list,of,alias,metadata,the,list,corresponding,to,a,concrete,index,will,be,empty,if,no,aliases,are,present,for,that,index;public,immutable,open,map,string,list,alias,meta,data,find,all,aliases,string,concrete,indices,return,find,aliases,strings,strings,concrete,indices
MetaData -> public boolean hasIndexMetaData(final IndexMetaData indexMetaData);1524684173;Returns true iff existing index has the same {@link IndexMetaData} instance;public boolean hasIndexMetaData(final IndexMetaData indexMetaData) {_        return indices.get(indexMetaData.getIndex().getName()) == indexMetaData__    };returns,true,iff,existing,index,has,the,same,link,index,meta,data,instance;public,boolean,has,index,meta,data,final,index,meta,data,index,meta,data,return,indices,get,index,meta,data,get,index,get,name,index,meta,data
MetaData -> public boolean hasIndexMetaData(final IndexMetaData indexMetaData);1527878678;Returns true iff existing index has the same {@link IndexMetaData} instance;public boolean hasIndexMetaData(final IndexMetaData indexMetaData) {_        return indices.get(indexMetaData.getIndex().getName()) == indexMetaData__    };returns,true,iff,existing,index,has,the,same,link,index,meta,data,instance;public,boolean,has,index,meta,data,final,index,meta,data,index,meta,data,return,indices,get,index,meta,data,get,index,get,name,index,meta,data
MetaData -> public boolean hasIndexMetaData(final IndexMetaData indexMetaData);1528103657;Returns true iff existing index has the same {@link IndexMetaData} instance;public boolean hasIndexMetaData(final IndexMetaData indexMetaData) {_        return indices.get(indexMetaData.getIndex().getName()) == indexMetaData__    };returns,true,iff,existing,index,has,the,same,link,index,meta,data,instance;public,boolean,has,index,meta,data,final,index,meta,data,index,meta,data,return,indices,get,index,meta,data,get,index,get,name,index,meta,data
MetaData -> public boolean hasIndexMetaData(final IndexMetaData indexMetaData);1529082965;Returns true iff existing index has the same {@link IndexMetaData} instance;public boolean hasIndexMetaData(final IndexMetaData indexMetaData) {_        return indices.get(indexMetaData.getIndex().getName()) == indexMetaData__    };returns,true,iff,existing,index,has,the,same,link,index,meta,data,instance;public,boolean,has,index,meta,data,final,index,meta,data,index,meta,data,return,indices,get,index,meta,data,get,index,get,name,index,meta,data
MetaData -> public boolean hasIndexMetaData(final IndexMetaData indexMetaData);1531179852;Returns true iff existing index has the same {@link IndexMetaData} instance;public boolean hasIndexMetaData(final IndexMetaData indexMetaData) {_        return indices.get(indexMetaData.getIndex().getName()) == indexMetaData__    };returns,true,iff,existing,index,has,the,same,link,index,meta,data,instance;public,boolean,has,index,meta,data,final,index,meta,data,index,meta,data,return,indices,get,index,meta,data,get,index,get,name,index,meta,data
MetaData -> public boolean hasIndexMetaData(final IndexMetaData indexMetaData);1532028790;Returns true iff existing index has the same {@link IndexMetaData} instance;public boolean hasIndexMetaData(final IndexMetaData indexMetaData) {_        return indices.get(indexMetaData.getIndex().getName()) == indexMetaData__    };returns,true,iff,existing,index,has,the,same,link,index,meta,data,instance;public,boolean,has,index,meta,data,final,index,meta,data,index,meta,data,return,indices,get,index,meta,data,get,index,get,name,index,meta,data
MetaData -> public boolean hasIndexMetaData(final IndexMetaData indexMetaData);1532353780;Returns true iff existing index has the same {@link IndexMetaData} instance;public boolean hasIndexMetaData(final IndexMetaData indexMetaData) {_        return indices.get(indexMetaData.getIndex().getName()) == indexMetaData__    };returns,true,iff,existing,index,has,the,same,link,index,meta,data,instance;public,boolean,has,index,meta,data,final,index,meta,data,index,meta,data,return,indices,get,index,meta,data,get,index,get,name,index,meta,data
MetaData -> public boolean hasIndexMetaData(final IndexMetaData indexMetaData);1536611444;Returns true iff existing index has the same {@link IndexMetaData} instance;public boolean hasIndexMetaData(final IndexMetaData indexMetaData) {_        return indices.get(indexMetaData.getIndex().getName()) == indexMetaData__    };returns,true,iff,existing,index,has,the,same,link,index,meta,data,instance;public,boolean,has,index,meta,data,final,index,meta,data,index,meta,data,return,indices,get,index,meta,data,get,index,get,name,index,meta,data
MetaData -> public boolean hasIndexMetaData(final IndexMetaData indexMetaData);1539723533;Returns true iff existing index has the same {@link IndexMetaData} instance;public boolean hasIndexMetaData(final IndexMetaData indexMetaData) {_        return indices.get(indexMetaData.getIndex().getName()) == indexMetaData__    };returns,true,iff,existing,index,has,the,same,link,index,meta,data,instance;public,boolean,has,index,meta,data,final,index,meta,data,index,meta,data,return,indices,get,index,meta,data,get,index,get,name,index,meta,data
MetaData -> public boolean hasIndexMetaData(final IndexMetaData indexMetaData);1540313026;Returns true iff existing index has the same {@link IndexMetaData} instance;public boolean hasIndexMetaData(final IndexMetaData indexMetaData) {_        return indices.get(indexMetaData.getIndex().getName()) == indexMetaData__    };returns,true,iff,existing,index,has,the,same,link,index,meta,data,instance;public,boolean,has,index,meta,data,final,index,meta,data,index,meta,data,return,indices,get,index,meta,data,get,index,get,name,index,meta,data
MetaData -> public boolean hasIndexMetaData(final IndexMetaData indexMetaData);1540486836;Returns true iff existing index has the same {@link IndexMetaData} instance;public boolean hasIndexMetaData(final IndexMetaData indexMetaData) {_        return indices.get(indexMetaData.getIndex().getName()) == indexMetaData__    };returns,true,iff,existing,index,has,the,same,link,index,meta,data,instance;public,boolean,has,index,meta,data,final,index,meta,data,index,meta,data,return,indices,get,index,meta,data,get,index,get,name,index,meta,data
MetaData -> public boolean hasIndexMetaData(final IndexMetaData indexMetaData);1540847035;Returns true iff existing index has the same {@link IndexMetaData} instance;public boolean hasIndexMetaData(final IndexMetaData indexMetaData) {_        return indices.get(indexMetaData.getIndex().getName()) == indexMetaData__    };returns,true,iff,existing,index,has,the,same,link,index,meta,data,instance;public,boolean,has,index,meta,data,final,index,meta,data,index,meta,data,return,indices,get,index,meta,data,get,index,get,name,index,meta,data
MetaData -> public boolean hasIndexMetaData(final IndexMetaData indexMetaData);1543947737;Returns true iff existing index has the same {@link IndexMetaData} instance;public boolean hasIndexMetaData(final IndexMetaData indexMetaData) {_        return indices.get(indexMetaData.getIndex().getName()) == indexMetaData__    };returns,true,iff,existing,index,has,the,same,link,index,meta,data,instance;public,boolean,has,index,meta,data,final,index,meta,data,index,meta,data,return,indices,get,index,meta,data,get,index,get,name,index,meta,data
MetaData -> public boolean hasIndexMetaData(final IndexMetaData indexMetaData);1544081506;Returns true iff existing index has the same {@link IndexMetaData} instance;public boolean hasIndexMetaData(final IndexMetaData indexMetaData) {_        return indices.get(indexMetaData.getIndex().getName()) == indexMetaData__    };returns,true,iff,existing,index,has,the,same,link,index,meta,data,instance;public,boolean,has,index,meta,data,final,index,meta,data,index,meta,data,return,indices,get,index,meta,data,get,index,get,name,index,meta,data
MetaData -> public boolean hasIndexMetaData(final IndexMetaData indexMetaData);1544702062;Returns true iff existing index has the same {@link IndexMetaData} instance;public boolean hasIndexMetaData(final IndexMetaData indexMetaData) {_        return indices.get(indexMetaData.getIndex().getName()) == indexMetaData__    };returns,true,iff,existing,index,has,the,same,link,index,meta,data,instance;public,boolean,has,index,meta,data,final,index,meta,data,index,meta,data,return,indices,get,index,meta,data,get,index,get,name,index,meta,data
MetaData -> public boolean hasIndexMetaData(final IndexMetaData indexMetaData);1547500081;Returns true iff existing index has the same {@link IndexMetaData} instance;public boolean hasIndexMetaData(final IndexMetaData indexMetaData) {_        return indices.get(indexMetaData.getIndex().getName()) == indexMetaData__    };returns,true,iff,existing,index,has,the,same,link,index,meta,data,instance;public,boolean,has,index,meta,data,final,index,meta,data,index,meta,data,return,indices,get,index,meta,data,get,index,get,name,index,meta,data
MetaData -> public boolean hasIndexMetaData(final IndexMetaData indexMetaData);1548772865;Returns true iff existing index has the same {@link IndexMetaData} instance;public boolean hasIndexMetaData(final IndexMetaData indexMetaData) {_        return indices.get(indexMetaData.getIndex().getName()) == indexMetaData__    };returns,true,iff,existing,index,has,the,same,link,index,meta,data,instance;public,boolean,has,index,meta,data,final,index,meta,data,index,meta,data,return,indices,get,index,meta,data,get,index,get,name,index,meta,data
MetaData -> public String resolveWriteIndexRouting(@Nullable String routing, String aliasOrIndex);1532028790;Returns indexing routing for the given <code>aliasOrIndex</code>. Resolves routing from the alias metadata used_in the write index.;public String resolveWriteIndexRouting(@Nullable String routing, String aliasOrIndex) {_        if (aliasOrIndex == null) {_            return routing__        }__        AliasOrIndex result = getAliasAndIndexLookup().get(aliasOrIndex)__        if (result == null || result.isAlias() == false) {_            return routing__        }_        AliasOrIndex.Alias alias = (AliasOrIndex.Alias) result__        IndexMetaData writeIndex = alias.getWriteIndex()__        if (writeIndex == null) {_            throw new IllegalArgumentException("alias [" + aliasOrIndex + "] does not have a write index")__        }_        AliasMetaData aliasMd = writeIndex.getAliases().get(alias.getAliasName())__        if (aliasMd.indexRouting() != null) {_            if (aliasMd.indexRouting().indexOf(',') != -1) {_                throw new IllegalArgumentException("index/alias [" + aliasOrIndex + "] provided with routing value ["_                    + aliasMd.getIndexRouting() + "] that resolved to several routing values, rejecting operation")__            }_            if (routing != null) {_                if (!routing.equals(aliasMd.indexRouting())) {_                    throw new IllegalArgumentException("Alias [" + aliasOrIndex + "] has index routing associated with it ["_                        + aliasMd.indexRouting() + "], and was provided with routing value [" + routing + "], rejecting operation")__                }_            }_            _            return aliasMd.indexRouting()__        }_        return routing__    };returns,indexing,routing,for,the,given,code,alias,or,index,code,resolves,routing,from,the,alias,metadata,used,in,the,write,index;public,string,resolve,write,index,routing,nullable,string,routing,string,alias,or,index,if,alias,or,index,null,return,routing,alias,or,index,result,get,alias,and,index,lookup,get,alias,or,index,if,result,null,result,is,alias,false,return,routing,alias,or,index,alias,alias,alias,or,index,alias,result,index,meta,data,write,index,alias,get,write,index,if,write,index,null,throw,new,illegal,argument,exception,alias,alias,or,index,does,not,have,a,write,index,alias,meta,data,alias,md,write,index,get,aliases,get,alias,get,alias,name,if,alias,md,index,routing,null,if,alias,md,index,routing,index,of,1,throw,new,illegal,argument,exception,index,alias,alias,or,index,provided,with,routing,value,alias,md,get,index,routing,that,resolved,to,several,routing,values,rejecting,operation,if,routing,null,if,routing,equals,alias,md,index,routing,throw,new,illegal,argument,exception,alias,alias,or,index,has,index,routing,associated,with,it,alias,md,index,routing,and,was,provided,with,routing,value,routing,rejecting,operation,return,alias,md,index,routing,return,routing
MetaData -> public String resolveWriteIndexRouting(@Nullable String routing, String aliasOrIndex);1532353780;Returns indexing routing for the given <code>aliasOrIndex</code>. Resolves routing from the alias metadata used_in the write index.;public String resolveWriteIndexRouting(@Nullable String routing, String aliasOrIndex) {_        if (aliasOrIndex == null) {_            return routing__        }__        AliasOrIndex result = getAliasAndIndexLookup().get(aliasOrIndex)__        if (result == null || result.isAlias() == false) {_            return routing__        }_        AliasOrIndex.Alias alias = (AliasOrIndex.Alias) result__        IndexMetaData writeIndex = alias.getWriteIndex()__        if (writeIndex == null) {_            throw new IllegalArgumentException("alias [" + aliasOrIndex + "] does not have a write index")__        }_        AliasMetaData aliasMd = writeIndex.getAliases().get(alias.getAliasName())__        if (aliasMd.indexRouting() != null) {_            if (aliasMd.indexRouting().indexOf(',') != -1) {_                throw new IllegalArgumentException("index/alias [" + aliasOrIndex + "] provided with routing value ["_                    + aliasMd.getIndexRouting() + "] that resolved to several routing values, rejecting operation")__            }_            if (routing != null) {_                if (!routing.equals(aliasMd.indexRouting())) {_                    throw new IllegalArgumentException("Alias [" + aliasOrIndex + "] has index routing associated with it ["_                        + aliasMd.indexRouting() + "], and was provided with routing value [" + routing + "], rejecting operation")__                }_            }_            _            return aliasMd.indexRouting()__        }_        return routing__    };returns,indexing,routing,for,the,given,code,alias,or,index,code,resolves,routing,from,the,alias,metadata,used,in,the,write,index;public,string,resolve,write,index,routing,nullable,string,routing,string,alias,or,index,if,alias,or,index,null,return,routing,alias,or,index,result,get,alias,and,index,lookup,get,alias,or,index,if,result,null,result,is,alias,false,return,routing,alias,or,index,alias,alias,alias,or,index,alias,result,index,meta,data,write,index,alias,get,write,index,if,write,index,null,throw,new,illegal,argument,exception,alias,alias,or,index,does,not,have,a,write,index,alias,meta,data,alias,md,write,index,get,aliases,get,alias,get,alias,name,if,alias,md,index,routing,null,if,alias,md,index,routing,index,of,1,throw,new,illegal,argument,exception,index,alias,alias,or,index,provided,with,routing,value,alias,md,get,index,routing,that,resolved,to,several,routing,values,rejecting,operation,if,routing,null,if,routing,equals,alias,md,index,routing,throw,new,illegal,argument,exception,alias,alias,or,index,has,index,routing,associated,with,it,alias,md,index,routing,and,was,provided,with,routing,value,routing,rejecting,operation,return,alias,md,index,routing,return,routing
MetaData -> public String resolveWriteIndexRouting(@Nullable String routing, String aliasOrIndex);1536611444;Returns indexing routing for the given <code>aliasOrIndex</code>. Resolves routing from the alias metadata used_in the write index.;public String resolveWriteIndexRouting(@Nullable String routing, String aliasOrIndex) {_        if (aliasOrIndex == null) {_            return routing__        }__        AliasOrIndex result = getAliasAndIndexLookup().get(aliasOrIndex)__        if (result == null || result.isAlias() == false) {_            return routing__        }_        AliasOrIndex.Alias alias = (AliasOrIndex.Alias) result__        IndexMetaData writeIndex = alias.getWriteIndex()__        if (writeIndex == null) {_            throw new IllegalArgumentException("alias [" + aliasOrIndex + "] does not have a write index")__        }_        AliasMetaData aliasMd = writeIndex.getAliases().get(alias.getAliasName())__        if (aliasMd.indexRouting() != null) {_            if (aliasMd.indexRouting().indexOf(',') != -1) {_                throw new IllegalArgumentException("index/alias [" + aliasOrIndex + "] provided with routing value ["_                    + aliasMd.getIndexRouting() + "] that resolved to several routing values, rejecting operation")__            }_            if (routing != null) {_                if (!routing.equals(aliasMd.indexRouting())) {_                    throw new IllegalArgumentException("Alias [" + aliasOrIndex + "] has index routing associated with it ["_                        + aliasMd.indexRouting() + "], and was provided with routing value [" + routing + "], rejecting operation")__                }_            }_            _            return aliasMd.indexRouting()__        }_        return routing__    };returns,indexing,routing,for,the,given,code,alias,or,index,code,resolves,routing,from,the,alias,metadata,used,in,the,write,index;public,string,resolve,write,index,routing,nullable,string,routing,string,alias,or,index,if,alias,or,index,null,return,routing,alias,or,index,result,get,alias,and,index,lookup,get,alias,or,index,if,result,null,result,is,alias,false,return,routing,alias,or,index,alias,alias,alias,or,index,alias,result,index,meta,data,write,index,alias,get,write,index,if,write,index,null,throw,new,illegal,argument,exception,alias,alias,or,index,does,not,have,a,write,index,alias,meta,data,alias,md,write,index,get,aliases,get,alias,get,alias,name,if,alias,md,index,routing,null,if,alias,md,index,routing,index,of,1,throw,new,illegal,argument,exception,index,alias,alias,or,index,provided,with,routing,value,alias,md,get,index,routing,that,resolved,to,several,routing,values,rejecting,operation,if,routing,null,if,routing,equals,alias,md,index,routing,throw,new,illegal,argument,exception,alias,alias,or,index,has,index,routing,associated,with,it,alias,md,index,routing,and,was,provided,with,routing,value,routing,rejecting,operation,return,alias,md,index,routing,return,routing
MetaData -> public String resolveWriteIndexRouting(@Nullable String routing, String aliasOrIndex);1539723533;Returns indexing routing for the given <code>aliasOrIndex</code>. Resolves routing from the alias metadata used_in the write index.;public String resolveWriteIndexRouting(@Nullable String routing, String aliasOrIndex) {_        if (aliasOrIndex == null) {_            return routing__        }__        AliasOrIndex result = getAliasAndIndexLookup().get(aliasOrIndex)__        if (result == null || result.isAlias() == false) {_            return routing__        }_        AliasOrIndex.Alias alias = (AliasOrIndex.Alias) result__        IndexMetaData writeIndex = alias.getWriteIndex()__        if (writeIndex == null) {_            throw new IllegalArgumentException("alias [" + aliasOrIndex + "] does not have a write index")__        }_        AliasMetaData aliasMd = writeIndex.getAliases().get(alias.getAliasName())__        if (aliasMd.indexRouting() != null) {_            if (aliasMd.indexRouting().indexOf(',') != -1) {_                throw new IllegalArgumentException("index/alias [" + aliasOrIndex + "] provided with routing value ["_                    + aliasMd.getIndexRouting() + "] that resolved to several routing values, rejecting operation")__            }_            if (routing != null) {_                if (!routing.equals(aliasMd.indexRouting())) {_                    throw new IllegalArgumentException("Alias [" + aliasOrIndex + "] has index routing associated with it ["_                        + aliasMd.indexRouting() + "], and was provided with routing value [" + routing + "], rejecting operation")__                }_            }_            _            return aliasMd.indexRouting()__        }_        return routing__    };returns,indexing,routing,for,the,given,code,alias,or,index,code,resolves,routing,from,the,alias,metadata,used,in,the,write,index;public,string,resolve,write,index,routing,nullable,string,routing,string,alias,or,index,if,alias,or,index,null,return,routing,alias,or,index,result,get,alias,and,index,lookup,get,alias,or,index,if,result,null,result,is,alias,false,return,routing,alias,or,index,alias,alias,alias,or,index,alias,result,index,meta,data,write,index,alias,get,write,index,if,write,index,null,throw,new,illegal,argument,exception,alias,alias,or,index,does,not,have,a,write,index,alias,meta,data,alias,md,write,index,get,aliases,get,alias,get,alias,name,if,alias,md,index,routing,null,if,alias,md,index,routing,index,of,1,throw,new,illegal,argument,exception,index,alias,alias,or,index,provided,with,routing,value,alias,md,get,index,routing,that,resolved,to,several,routing,values,rejecting,operation,if,routing,null,if,routing,equals,alias,md,index,routing,throw,new,illegal,argument,exception,alias,alias,or,index,has,index,routing,associated,with,it,alias,md,index,routing,and,was,provided,with,routing,value,routing,rejecting,operation,return,alias,md,index,routing,return,routing
MetaData -> public String resolveWriteIndexRouting(@Nullable String routing, String aliasOrIndex);1540313026;Returns indexing routing for the given <code>aliasOrIndex</code>. Resolves routing from the alias metadata used_in the write index.;public String resolveWriteIndexRouting(@Nullable String routing, String aliasOrIndex) {_        if (aliasOrIndex == null) {_            return routing__        }__        AliasOrIndex result = getAliasAndIndexLookup().get(aliasOrIndex)__        if (result == null || result.isAlias() == false) {_            return routing__        }_        AliasOrIndex.Alias alias = (AliasOrIndex.Alias) result__        IndexMetaData writeIndex = alias.getWriteIndex()__        if (writeIndex == null) {_            throw new IllegalArgumentException("alias [" + aliasOrIndex + "] does not have a write index")__        }_        AliasMetaData aliasMd = writeIndex.getAliases().get(alias.getAliasName())__        if (aliasMd.indexRouting() != null) {_            if (aliasMd.indexRouting().indexOf(',') != -1) {_                throw new IllegalArgumentException("index/alias [" + aliasOrIndex + "] provided with routing value ["_                    + aliasMd.getIndexRouting() + "] that resolved to several routing values, rejecting operation")__            }_            if (routing != null) {_                if (!routing.equals(aliasMd.indexRouting())) {_                    throw new IllegalArgumentException("Alias [" + aliasOrIndex + "] has index routing associated with it ["_                        + aliasMd.indexRouting() + "], and was provided with routing value [" + routing + "], rejecting operation")__                }_            }_            _            return aliasMd.indexRouting()__        }_        return routing__    };returns,indexing,routing,for,the,given,code,alias,or,index,code,resolves,routing,from,the,alias,metadata,used,in,the,write,index;public,string,resolve,write,index,routing,nullable,string,routing,string,alias,or,index,if,alias,or,index,null,return,routing,alias,or,index,result,get,alias,and,index,lookup,get,alias,or,index,if,result,null,result,is,alias,false,return,routing,alias,or,index,alias,alias,alias,or,index,alias,result,index,meta,data,write,index,alias,get,write,index,if,write,index,null,throw,new,illegal,argument,exception,alias,alias,or,index,does,not,have,a,write,index,alias,meta,data,alias,md,write,index,get,aliases,get,alias,get,alias,name,if,alias,md,index,routing,null,if,alias,md,index,routing,index,of,1,throw,new,illegal,argument,exception,index,alias,alias,or,index,provided,with,routing,value,alias,md,get,index,routing,that,resolved,to,several,routing,values,rejecting,operation,if,routing,null,if,routing,equals,alias,md,index,routing,throw,new,illegal,argument,exception,alias,alias,or,index,has,index,routing,associated,with,it,alias,md,index,routing,and,was,provided,with,routing,value,routing,rejecting,operation,return,alias,md,index,routing,return,routing
MetaData -> public String resolveWriteIndexRouting(@Nullable String routing, String aliasOrIndex);1540486836;Returns indexing routing for the given <code>aliasOrIndex</code>. Resolves routing from the alias metadata used_in the write index.;public String resolveWriteIndexRouting(@Nullable String routing, String aliasOrIndex) {_        if (aliasOrIndex == null) {_            return routing__        }__        AliasOrIndex result = getAliasAndIndexLookup().get(aliasOrIndex)__        if (result == null || result.isAlias() == false) {_            return routing__        }_        AliasOrIndex.Alias alias = (AliasOrIndex.Alias) result__        IndexMetaData writeIndex = alias.getWriteIndex()__        if (writeIndex == null) {_            throw new IllegalArgumentException("alias [" + aliasOrIndex + "] does not have a write index")__        }_        AliasMetaData aliasMd = writeIndex.getAliases().get(alias.getAliasName())__        if (aliasMd.indexRouting() != null) {_            if (aliasMd.indexRouting().indexOf(',') != -1) {_                throw new IllegalArgumentException("index/alias [" + aliasOrIndex + "] provided with routing value ["_                    + aliasMd.getIndexRouting() + "] that resolved to several routing values, rejecting operation")__            }_            if (routing != null) {_                if (!routing.equals(aliasMd.indexRouting())) {_                    throw new IllegalArgumentException("Alias [" + aliasOrIndex + "] has index routing associated with it ["_                        + aliasMd.indexRouting() + "], and was provided with routing value [" + routing + "], rejecting operation")__                }_            }_            _            return aliasMd.indexRouting()__        }_        return routing__    };returns,indexing,routing,for,the,given,code,alias,or,index,code,resolves,routing,from,the,alias,metadata,used,in,the,write,index;public,string,resolve,write,index,routing,nullable,string,routing,string,alias,or,index,if,alias,or,index,null,return,routing,alias,or,index,result,get,alias,and,index,lookup,get,alias,or,index,if,result,null,result,is,alias,false,return,routing,alias,or,index,alias,alias,alias,or,index,alias,result,index,meta,data,write,index,alias,get,write,index,if,write,index,null,throw,new,illegal,argument,exception,alias,alias,or,index,does,not,have,a,write,index,alias,meta,data,alias,md,write,index,get,aliases,get,alias,get,alias,name,if,alias,md,index,routing,null,if,alias,md,index,routing,index,of,1,throw,new,illegal,argument,exception,index,alias,alias,or,index,provided,with,routing,value,alias,md,get,index,routing,that,resolved,to,several,routing,values,rejecting,operation,if,routing,null,if,routing,equals,alias,md,index,routing,throw,new,illegal,argument,exception,alias,alias,or,index,has,index,routing,associated,with,it,alias,md,index,routing,and,was,provided,with,routing,value,routing,rejecting,operation,return,alias,md,index,routing,return,routing
MetaData -> public String resolveWriteIndexRouting(@Nullable String routing, String aliasOrIndex);1540847035;Returns indexing routing for the given <code>aliasOrIndex</code>. Resolves routing from the alias metadata used_in the write index.;public String resolveWriteIndexRouting(@Nullable String routing, String aliasOrIndex) {_        if (aliasOrIndex == null) {_            return routing__        }__        AliasOrIndex result = getAliasAndIndexLookup().get(aliasOrIndex)__        if (result == null || result.isAlias() == false) {_            return routing__        }_        AliasOrIndex.Alias alias = (AliasOrIndex.Alias) result__        IndexMetaData writeIndex = alias.getWriteIndex()__        if (writeIndex == null) {_            throw new IllegalArgumentException("alias [" + aliasOrIndex + "] does not have a write index")__        }_        AliasMetaData aliasMd = writeIndex.getAliases().get(alias.getAliasName())__        if (aliasMd.indexRouting() != null) {_            if (aliasMd.indexRouting().indexOf(',') != -1) {_                throw new IllegalArgumentException("index/alias [" + aliasOrIndex + "] provided with routing value ["_                    + aliasMd.getIndexRouting() + "] that resolved to several routing values, rejecting operation")__            }_            if (routing != null) {_                if (!routing.equals(aliasMd.indexRouting())) {_                    throw new IllegalArgumentException("Alias [" + aliasOrIndex + "] has index routing associated with it ["_                        + aliasMd.indexRouting() + "], and was provided with routing value [" + routing + "], rejecting operation")__                }_            }_            _            return aliasMd.indexRouting()__        }_        return routing__    };returns,indexing,routing,for,the,given,code,alias,or,index,code,resolves,routing,from,the,alias,metadata,used,in,the,write,index;public,string,resolve,write,index,routing,nullable,string,routing,string,alias,or,index,if,alias,or,index,null,return,routing,alias,or,index,result,get,alias,and,index,lookup,get,alias,or,index,if,result,null,result,is,alias,false,return,routing,alias,or,index,alias,alias,alias,or,index,alias,result,index,meta,data,write,index,alias,get,write,index,if,write,index,null,throw,new,illegal,argument,exception,alias,alias,or,index,does,not,have,a,write,index,alias,meta,data,alias,md,write,index,get,aliases,get,alias,get,alias,name,if,alias,md,index,routing,null,if,alias,md,index,routing,index,of,1,throw,new,illegal,argument,exception,index,alias,alias,or,index,provided,with,routing,value,alias,md,get,index,routing,that,resolved,to,several,routing,values,rejecting,operation,if,routing,null,if,routing,equals,alias,md,index,routing,throw,new,illegal,argument,exception,alias,alias,or,index,has,index,routing,associated,with,it,alias,md,index,routing,and,was,provided,with,routing,value,routing,rejecting,operation,return,alias,md,index,routing,return,routing
MetaData -> public String resolveWriteIndexRouting(@Nullable String routing, String aliasOrIndex);1543947737;Returns indexing routing for the given <code>aliasOrIndex</code>. Resolves routing from the alias metadata used_in the write index.;public String resolveWriteIndexRouting(@Nullable String routing, String aliasOrIndex) {_        if (aliasOrIndex == null) {_            return routing__        }__        AliasOrIndex result = getAliasAndIndexLookup().get(aliasOrIndex)__        if (result == null || result.isAlias() == false) {_            return routing__        }_        AliasOrIndex.Alias alias = (AliasOrIndex.Alias) result__        IndexMetaData writeIndex = alias.getWriteIndex()__        if (writeIndex == null) {_            throw new IllegalArgumentException("alias [" + aliasOrIndex + "] does not have a write index")__        }_        AliasMetaData aliasMd = writeIndex.getAliases().get(alias.getAliasName())__        if (aliasMd.indexRouting() != null) {_            if (aliasMd.indexRouting().indexOf(',') != -1) {_                throw new IllegalArgumentException("index/alias [" + aliasOrIndex + "] provided with routing value ["_                    + aliasMd.getIndexRouting() + "] that resolved to several routing values, rejecting operation")__            }_            if (routing != null) {_                if (!routing.equals(aliasMd.indexRouting())) {_                    throw new IllegalArgumentException("Alias [" + aliasOrIndex + "] has index routing associated with it ["_                        + aliasMd.indexRouting() + "], and was provided with routing value [" + routing + "], rejecting operation")__                }_            }_            _            return aliasMd.indexRouting()__        }_        return routing__    };returns,indexing,routing,for,the,given,code,alias,or,index,code,resolves,routing,from,the,alias,metadata,used,in,the,write,index;public,string,resolve,write,index,routing,nullable,string,routing,string,alias,or,index,if,alias,or,index,null,return,routing,alias,or,index,result,get,alias,and,index,lookup,get,alias,or,index,if,result,null,result,is,alias,false,return,routing,alias,or,index,alias,alias,alias,or,index,alias,result,index,meta,data,write,index,alias,get,write,index,if,write,index,null,throw,new,illegal,argument,exception,alias,alias,or,index,does,not,have,a,write,index,alias,meta,data,alias,md,write,index,get,aliases,get,alias,get,alias,name,if,alias,md,index,routing,null,if,alias,md,index,routing,index,of,1,throw,new,illegal,argument,exception,index,alias,alias,or,index,provided,with,routing,value,alias,md,get,index,routing,that,resolved,to,several,routing,values,rejecting,operation,if,routing,null,if,routing,equals,alias,md,index,routing,throw,new,illegal,argument,exception,alias,alias,or,index,has,index,routing,associated,with,it,alias,md,index,routing,and,was,provided,with,routing,value,routing,rejecting,operation,return,alias,md,index,routing,return,routing
MetaData -> public String resolveWriteIndexRouting(@Nullable String routing, String aliasOrIndex);1544081506;Returns indexing routing for the given <code>aliasOrIndex</code>. Resolves routing from the alias metadata used_in the write index.;public String resolveWriteIndexRouting(@Nullable String routing, String aliasOrIndex) {_        if (aliasOrIndex == null) {_            return routing__        }__        AliasOrIndex result = getAliasAndIndexLookup().get(aliasOrIndex)__        if (result == null || result.isAlias() == false) {_            return routing__        }_        AliasOrIndex.Alias alias = (AliasOrIndex.Alias) result__        IndexMetaData writeIndex = alias.getWriteIndex()__        if (writeIndex == null) {_            throw new IllegalArgumentException("alias [" + aliasOrIndex + "] does not have a write index")__        }_        AliasMetaData aliasMd = writeIndex.getAliases().get(alias.getAliasName())__        if (aliasMd.indexRouting() != null) {_            if (aliasMd.indexRouting().indexOf(',') != -1) {_                throw new IllegalArgumentException("index/alias [" + aliasOrIndex + "] provided with routing value ["_                    + aliasMd.getIndexRouting() + "] that resolved to several routing values, rejecting operation")__            }_            if (routing != null) {_                if (!routing.equals(aliasMd.indexRouting())) {_                    throw new IllegalArgumentException("Alias [" + aliasOrIndex + "] has index routing associated with it ["_                        + aliasMd.indexRouting() + "], and was provided with routing value [" + routing + "], rejecting operation")__                }_            }_            _            return aliasMd.indexRouting()__        }_        return routing__    };returns,indexing,routing,for,the,given,code,alias,or,index,code,resolves,routing,from,the,alias,metadata,used,in,the,write,index;public,string,resolve,write,index,routing,nullable,string,routing,string,alias,or,index,if,alias,or,index,null,return,routing,alias,or,index,result,get,alias,and,index,lookup,get,alias,or,index,if,result,null,result,is,alias,false,return,routing,alias,or,index,alias,alias,alias,or,index,alias,result,index,meta,data,write,index,alias,get,write,index,if,write,index,null,throw,new,illegal,argument,exception,alias,alias,or,index,does,not,have,a,write,index,alias,meta,data,alias,md,write,index,get,aliases,get,alias,get,alias,name,if,alias,md,index,routing,null,if,alias,md,index,routing,index,of,1,throw,new,illegal,argument,exception,index,alias,alias,or,index,provided,with,routing,value,alias,md,get,index,routing,that,resolved,to,several,routing,values,rejecting,operation,if,routing,null,if,routing,equals,alias,md,index,routing,throw,new,illegal,argument,exception,alias,alias,or,index,has,index,routing,associated,with,it,alias,md,index,routing,and,was,provided,with,routing,value,routing,rejecting,operation,return,alias,md,index,routing,return,routing
MetaData -> public String resolveWriteIndexRouting(@Nullable String routing, String aliasOrIndex);1544702062;Returns indexing routing for the given <code>aliasOrIndex</code>. Resolves routing from the alias metadata used_in the write index.;public String resolveWriteIndexRouting(@Nullable String routing, String aliasOrIndex) {_        if (aliasOrIndex == null) {_            return routing__        }__        AliasOrIndex result = getAliasAndIndexLookup().get(aliasOrIndex)__        if (result == null || result.isAlias() == false) {_            return routing__        }_        AliasOrIndex.Alias alias = (AliasOrIndex.Alias) result__        IndexMetaData writeIndex = alias.getWriteIndex()__        if (writeIndex == null) {_            throw new IllegalArgumentException("alias [" + aliasOrIndex + "] does not have a write index")__        }_        AliasMetaData aliasMd = writeIndex.getAliases().get(alias.getAliasName())__        if (aliasMd.indexRouting() != null) {_            if (aliasMd.indexRouting().indexOf(',') != -1) {_                throw new IllegalArgumentException("index/alias [" + aliasOrIndex + "] provided with routing value ["_                    + aliasMd.getIndexRouting() + "] that resolved to several routing values, rejecting operation")__            }_            if (routing != null) {_                if (!routing.equals(aliasMd.indexRouting())) {_                    throw new IllegalArgumentException("Alias [" + aliasOrIndex + "] has index routing associated with it ["_                        + aliasMd.indexRouting() + "], and was provided with routing value [" + routing + "], rejecting operation")__                }_            }_            _            return aliasMd.indexRouting()__        }_        return routing__    };returns,indexing,routing,for,the,given,code,alias,or,index,code,resolves,routing,from,the,alias,metadata,used,in,the,write,index;public,string,resolve,write,index,routing,nullable,string,routing,string,alias,or,index,if,alias,or,index,null,return,routing,alias,or,index,result,get,alias,and,index,lookup,get,alias,or,index,if,result,null,result,is,alias,false,return,routing,alias,or,index,alias,alias,alias,or,index,alias,result,index,meta,data,write,index,alias,get,write,index,if,write,index,null,throw,new,illegal,argument,exception,alias,alias,or,index,does,not,have,a,write,index,alias,meta,data,alias,md,write,index,get,aliases,get,alias,get,alias,name,if,alias,md,index,routing,null,if,alias,md,index,routing,index,of,1,throw,new,illegal,argument,exception,index,alias,alias,or,index,provided,with,routing,value,alias,md,get,index,routing,that,resolved,to,several,routing,values,rejecting,operation,if,routing,null,if,routing,equals,alias,md,index,routing,throw,new,illegal,argument,exception,alias,alias,or,index,has,index,routing,associated,with,it,alias,md,index,routing,and,was,provided,with,routing,value,routing,rejecting,operation,return,alias,md,index,routing,return,routing
MetaData -> public String resolveWriteIndexRouting(@Nullable String routing, String aliasOrIndex);1547500081;Returns indexing routing for the given <code>aliasOrIndex</code>. Resolves routing from the alias metadata used_in the write index.;public String resolveWriteIndexRouting(@Nullable String routing, String aliasOrIndex) {_        if (aliasOrIndex == null) {_            return routing__        }__        AliasOrIndex result = getAliasAndIndexLookup().get(aliasOrIndex)__        if (result == null || result.isAlias() == false) {_            return routing__        }_        AliasOrIndex.Alias alias = (AliasOrIndex.Alias) result__        IndexMetaData writeIndex = alias.getWriteIndex()__        if (writeIndex == null) {_            throw new IllegalArgumentException("alias [" + aliasOrIndex + "] does not have a write index")__        }_        AliasMetaData aliasMd = writeIndex.getAliases().get(alias.getAliasName())__        if (aliasMd.indexRouting() != null) {_            if (aliasMd.indexRouting().indexOf(',') != -1) {_                throw new IllegalArgumentException("index/alias [" + aliasOrIndex + "] provided with routing value ["_                    + aliasMd.getIndexRouting() + "] that resolved to several routing values, rejecting operation")__            }_            if (routing != null) {_                if (!routing.equals(aliasMd.indexRouting())) {_                    throw new IllegalArgumentException("Alias [" + aliasOrIndex + "] has index routing associated with it ["_                        + aliasMd.indexRouting() + "], and was provided with routing value [" + routing + "], rejecting operation")__                }_            }_            _            return aliasMd.indexRouting()__        }_        return routing__    };returns,indexing,routing,for,the,given,code,alias,or,index,code,resolves,routing,from,the,alias,metadata,used,in,the,write,index;public,string,resolve,write,index,routing,nullable,string,routing,string,alias,or,index,if,alias,or,index,null,return,routing,alias,or,index,result,get,alias,and,index,lookup,get,alias,or,index,if,result,null,result,is,alias,false,return,routing,alias,or,index,alias,alias,alias,or,index,alias,result,index,meta,data,write,index,alias,get,write,index,if,write,index,null,throw,new,illegal,argument,exception,alias,alias,or,index,does,not,have,a,write,index,alias,meta,data,alias,md,write,index,get,aliases,get,alias,get,alias,name,if,alias,md,index,routing,null,if,alias,md,index,routing,index,of,1,throw,new,illegal,argument,exception,index,alias,alias,or,index,provided,with,routing,value,alias,md,get,index,routing,that,resolved,to,several,routing,values,rejecting,operation,if,routing,null,if,routing,equals,alias,md,index,routing,throw,new,illegal,argument,exception,alias,alias,or,index,has,index,routing,associated,with,it,alias,md,index,routing,and,was,provided,with,routing,value,routing,rejecting,operation,return,alias,md,index,routing,return,routing
MetaData -> public String resolveWriteIndexRouting(@Nullable String routing, String aliasOrIndex);1548772865;Returns indexing routing for the given <code>aliasOrIndex</code>. Resolves routing from the alias metadata used_in the write index.;public String resolveWriteIndexRouting(@Nullable String routing, String aliasOrIndex) {_        if (aliasOrIndex == null) {_            return routing__        }__        AliasOrIndex result = getAliasAndIndexLookup().get(aliasOrIndex)__        if (result == null || result.isAlias() == false) {_            return routing__        }_        AliasOrIndex.Alias alias = (AliasOrIndex.Alias) result__        IndexMetaData writeIndex = alias.getWriteIndex()__        if (writeIndex == null) {_            throw new IllegalArgumentException("alias [" + aliasOrIndex + "] does not have a write index")__        }_        AliasMetaData aliasMd = writeIndex.getAliases().get(alias.getAliasName())__        if (aliasMd.indexRouting() != null) {_            if (aliasMd.indexRouting().indexOf(',') != -1) {_                throw new IllegalArgumentException("index/alias [" + aliasOrIndex + "] provided with routing value ["_                    + aliasMd.getIndexRouting() + "] that resolved to several routing values, rejecting operation")__            }_            if (routing != null) {_                if (!routing.equals(aliasMd.indexRouting())) {_                    throw new IllegalArgumentException("Alias [" + aliasOrIndex + "] has index routing associated with it ["_                        + aliasMd.indexRouting() + "], and was provided with routing value [" + routing + "], rejecting operation")__                }_            }_            _            return aliasMd.indexRouting()__        }_        return routing__    };returns,indexing,routing,for,the,given,code,alias,or,index,code,resolves,routing,from,the,alias,metadata,used,in,the,write,index;public,string,resolve,write,index,routing,nullable,string,routing,string,alias,or,index,if,alias,or,index,null,return,routing,alias,or,index,result,get,alias,and,index,lookup,get,alias,or,index,if,result,null,result,is,alias,false,return,routing,alias,or,index,alias,alias,alias,or,index,alias,result,index,meta,data,write,index,alias,get,write,index,if,write,index,null,throw,new,illegal,argument,exception,alias,alias,or,index,does,not,have,a,write,index,alias,meta,data,alias,md,write,index,get,aliases,get,alias,get,alias,name,if,alias,md,index,routing,null,if,alias,md,index,routing,index,of,1,throw,new,illegal,argument,exception,index,alias,alias,or,index,provided,with,routing,value,alias,md,get,index,routing,that,resolved,to,several,routing,values,rejecting,operation,if,routing,null,if,routing,equals,alias,md,index,routing,throw,new,illegal,argument,exception,alias,alias,or,index,has,index,routing,associated,with,it,alias,md,index,routing,and,was,provided,with,routing,value,routing,rejecting,operation,return,alias,md,index,routing,return,routing
MetaData -> public int getTotalNumberOfShards();1540486836;Gets the total number of shards from all indices, including replicas and_closed indices._@return The total number shards from all indices.;public int getTotalNumberOfShards() {_        return this.totalNumberOfShards__    };gets,the,total,number,of,shards,from,all,indices,including,replicas,and,closed,indices,return,the,total,number,shards,from,all,indices;public,int,get,total,number,of,shards,return,this,total,number,of,shards
MetaData -> public int getTotalNumberOfShards();1540847035;Gets the total number of shards from all indices, including replicas and_closed indices._@return The total number shards from all indices.;public int getTotalNumberOfShards() {_        return this.totalNumberOfShards__    };gets,the,total,number,of,shards,from,all,indices,including,replicas,and,closed,indices,return,the,total,number,shards,from,all,indices;public,int,get,total,number,of,shards,return,this,total,number,of,shards
MetaData -> public int getTotalNumberOfShards();1543947737;Gets the total number of shards from all indices, including replicas and_closed indices._@return The total number shards from all indices.;public int getTotalNumberOfShards() {_        return this.totalNumberOfShards__    };gets,the,total,number,of,shards,from,all,indices,including,replicas,and,closed,indices,return,the,total,number,shards,from,all,indices;public,int,get,total,number,of,shards,return,this,total,number,of,shards
MetaData -> public int getTotalNumberOfShards();1544081506;Gets the total number of shards from all indices, including replicas and_closed indices._@return The total number shards from all indices.;public int getTotalNumberOfShards() {_        return this.totalNumberOfShards__    };gets,the,total,number,of,shards,from,all,indices,including,replicas,and,closed,indices,return,the,total,number,shards,from,all,indices;public,int,get,total,number,of,shards,return,this,total,number,of,shards
MetaData -> public int getTotalNumberOfShards();1544702062;Gets the total number of shards from all indices, including replicas and_closed indices._@return The total number shards from all indices.;public int getTotalNumberOfShards() {_        return this.totalNumberOfShards__    };gets,the,total,number,of,shards,from,all,indices,including,replicas,and,closed,indices,return,the,total,number,shards,from,all,indices;public,int,get,total,number,of,shards,return,this,total,number,of,shards
MetaData -> public int getTotalNumberOfShards();1547500081;Gets the total number of shards from all indices, including replicas and_closed indices._@return The total number shards from all indices.;public int getTotalNumberOfShards() {_        return this.totalNumberOfShards__    };gets,the,total,number,of,shards,from,all,indices,including,replicas,and,closed,indices,return,the,total,number,shards,from,all,indices;public,int,get,total,number,of,shards,return,this,total,number,of,shards
MetaData -> public int getTotalNumberOfShards();1548772865;Gets the total number of shards from all indices, including replicas and_closed indices._@return The total number shards from all indices.;public int getTotalNumberOfShards() {_        return this.totalNumberOfShards__    };gets,the,total,number,of,shards,from,all,indices,including,replicas,and,closed,indices,return,the,total,number,shards,from,all,indices;public,int,get,total,number,of,shards,return,this,total,number,of,shards
MetaData -> Builder -> public Builder updateNumberOfReplicas(final int numberOfReplicas, final String[] indices);1539723533;Update the number of replicas for the specified indices.__@param numberOfReplicas the number of replicas_@param indices          the indices to update the number of replicas for_@return the builder;public Builder updateNumberOfReplicas(final int numberOfReplicas, final String[] indices) {_            for (String index : indices) {_                IndexMetaData indexMetaData = this.indices.get(index)__                if (indexMetaData == null) {_                    throw new IndexNotFoundException(index)__                }_                put(IndexMetaData.builder(indexMetaData).numberOfReplicas(numberOfReplicas))__            }_            return this__        };update,the,number,of,replicas,for,the,specified,indices,param,number,of,replicas,the,number,of,replicas,param,indices,the,indices,to,update,the,number,of,replicas,for,return,the,builder;public,builder,update,number,of,replicas,final,int,number,of,replicas,final,string,indices,for,string,index,indices,index,meta,data,index,meta,data,this,indices,get,index,if,index,meta,data,null,throw,new,index,not,found,exception,index,put,index,meta,data,builder,index,meta,data,number,of,replicas,number,of,replicas,return,this
MetaData -> Builder -> public Builder updateNumberOfReplicas(final int numberOfReplicas, final String[] indices);1540313026;Update the number of replicas for the specified indices.__@param numberOfReplicas the number of replicas_@param indices          the indices to update the number of replicas for_@return the builder;public Builder updateNumberOfReplicas(final int numberOfReplicas, final String[] indices) {_            for (String index : indices) {_                IndexMetaData indexMetaData = this.indices.get(index)__                if (indexMetaData == null) {_                    throw new IndexNotFoundException(index)__                }_                put(IndexMetaData.builder(indexMetaData).numberOfReplicas(numberOfReplicas))__            }_            return this__        };update,the,number,of,replicas,for,the,specified,indices,param,number,of,replicas,the,number,of,replicas,param,indices,the,indices,to,update,the,number,of,replicas,for,return,the,builder;public,builder,update,number,of,replicas,final,int,number,of,replicas,final,string,indices,for,string,index,indices,index,meta,data,index,meta,data,this,indices,get,index,if,index,meta,data,null,throw,new,index,not,found,exception,index,put,index,meta,data,builder,index,meta,data,number,of,replicas,number,of,replicas,return,this
MetaData -> Builder -> public Builder updateNumberOfReplicas(final int numberOfReplicas, final String[] indices);1540486836;Update the number of replicas for the specified indices.__@param numberOfReplicas the number of replicas_@param indices          the indices to update the number of replicas for_@return the builder;public Builder updateNumberOfReplicas(final int numberOfReplicas, final String[] indices) {_            for (String index : indices) {_                IndexMetaData indexMetaData = this.indices.get(index)__                if (indexMetaData == null) {_                    throw new IndexNotFoundException(index)__                }_                put(IndexMetaData.builder(indexMetaData).numberOfReplicas(numberOfReplicas))__            }_            return this__        };update,the,number,of,replicas,for,the,specified,indices,param,number,of,replicas,the,number,of,replicas,param,indices,the,indices,to,update,the,number,of,replicas,for,return,the,builder;public,builder,update,number,of,replicas,final,int,number,of,replicas,final,string,indices,for,string,index,indices,index,meta,data,index,meta,data,this,indices,get,index,if,index,meta,data,null,throw,new,index,not,found,exception,index,put,index,meta,data,builder,index,meta,data,number,of,replicas,number,of,replicas,return,this
MetaData -> Builder -> public Builder updateNumberOfReplicas(final int numberOfReplicas, final String[] indices);1540847035;Update the number of replicas for the specified indices.__@param numberOfReplicas the number of replicas_@param indices          the indices to update the number of replicas for_@return the builder;public Builder updateNumberOfReplicas(final int numberOfReplicas, final String[] indices) {_            for (String index : indices) {_                IndexMetaData indexMetaData = this.indices.get(index)__                if (indexMetaData == null) {_                    throw new IndexNotFoundException(index)__                }_                put(IndexMetaData.builder(indexMetaData).numberOfReplicas(numberOfReplicas))__            }_            return this__        };update,the,number,of,replicas,for,the,specified,indices,param,number,of,replicas,the,number,of,replicas,param,indices,the,indices,to,update,the,number,of,replicas,for,return,the,builder;public,builder,update,number,of,replicas,final,int,number,of,replicas,final,string,indices,for,string,index,indices,index,meta,data,index,meta,data,this,indices,get,index,if,index,meta,data,null,throw,new,index,not,found,exception,index,put,index,meta,data,builder,index,meta,data,number,of,replicas,number,of,replicas,return,this
MetaData -> Builder -> public Builder updateNumberOfReplicas(final int numberOfReplicas, final String[] indices);1543947737;Update the number of replicas for the specified indices.__@param numberOfReplicas the number of replicas_@param indices          the indices to update the number of replicas for_@return the builder;public Builder updateNumberOfReplicas(final int numberOfReplicas, final String[] indices) {_            for (String index : indices) {_                IndexMetaData indexMetaData = this.indices.get(index)__                if (indexMetaData == null) {_                    throw new IndexNotFoundException(index)__                }_                put(IndexMetaData.builder(indexMetaData).numberOfReplicas(numberOfReplicas))__            }_            return this__        };update,the,number,of,replicas,for,the,specified,indices,param,number,of,replicas,the,number,of,replicas,param,indices,the,indices,to,update,the,number,of,replicas,for,return,the,builder;public,builder,update,number,of,replicas,final,int,number,of,replicas,final,string,indices,for,string,index,indices,index,meta,data,index,meta,data,this,indices,get,index,if,index,meta,data,null,throw,new,index,not,found,exception,index,put,index,meta,data,builder,index,meta,data,number,of,replicas,number,of,replicas,return,this
MetaData -> Builder -> public Builder updateNumberOfReplicas(final int numberOfReplicas, final String[] indices);1544081506;Update the number of replicas for the specified indices.__@param numberOfReplicas the number of replicas_@param indices          the indices to update the number of replicas for_@return the builder;public Builder updateNumberOfReplicas(final int numberOfReplicas, final String[] indices) {_            for (String index : indices) {_                IndexMetaData indexMetaData = this.indices.get(index)__                if (indexMetaData == null) {_                    throw new IndexNotFoundException(index)__                }_                put(IndexMetaData.builder(indexMetaData).numberOfReplicas(numberOfReplicas))__            }_            return this__        };update,the,number,of,replicas,for,the,specified,indices,param,number,of,replicas,the,number,of,replicas,param,indices,the,indices,to,update,the,number,of,replicas,for,return,the,builder;public,builder,update,number,of,replicas,final,int,number,of,replicas,final,string,indices,for,string,index,indices,index,meta,data,index,meta,data,this,indices,get,index,if,index,meta,data,null,throw,new,index,not,found,exception,index,put,index,meta,data,builder,index,meta,data,number,of,replicas,number,of,replicas,return,this
MetaData -> Builder -> public Builder updateNumberOfReplicas(final int numberOfReplicas, final String[] indices);1544702062;Update the number of replicas for the specified indices.__@param numberOfReplicas the number of replicas_@param indices          the indices to update the number of replicas for_@return the builder;public Builder updateNumberOfReplicas(final int numberOfReplicas, final String[] indices) {_            for (String index : indices) {_                IndexMetaData indexMetaData = this.indices.get(index)__                if (indexMetaData == null) {_                    throw new IndexNotFoundException(index)__                }_                put(IndexMetaData.builder(indexMetaData).numberOfReplicas(numberOfReplicas))__            }_            return this__        };update,the,number,of,replicas,for,the,specified,indices,param,number,of,replicas,the,number,of,replicas,param,indices,the,indices,to,update,the,number,of,replicas,for,return,the,builder;public,builder,update,number,of,replicas,final,int,number,of,replicas,final,string,indices,for,string,index,indices,index,meta,data,index,meta,data,this,indices,get,index,if,index,meta,data,null,throw,new,index,not,found,exception,index,put,index,meta,data,builder,index,meta,data,number,of,replicas,number,of,replicas,return,this
MetaData -> Builder -> public Builder updateNumberOfReplicas(final int numberOfReplicas, final String[] indices);1547500081;Update the number of replicas for the specified indices.__@param numberOfReplicas the number of replicas_@param indices          the indices to update the number of replicas for_@return the builder;public Builder updateNumberOfReplicas(final int numberOfReplicas, final String[] indices) {_            for (String index : indices) {_                IndexMetaData indexMetaData = this.indices.get(index)__                if (indexMetaData == null) {_                    throw new IndexNotFoundException(index)__                }_                put(IndexMetaData.builder(indexMetaData).numberOfReplicas(numberOfReplicas))__            }_            return this__        };update,the,number,of,replicas,for,the,specified,indices,param,number,of,replicas,the,number,of,replicas,param,indices,the,indices,to,update,the,number,of,replicas,for,return,the,builder;public,builder,update,number,of,replicas,final,int,number,of,replicas,final,string,indices,for,string,index,indices,index,meta,data,index,meta,data,this,indices,get,index,if,index,meta,data,null,throw,new,index,not,found,exception,index,put,index,meta,data,builder,index,meta,data,number,of,replicas,number,of,replicas,return,this
MetaData -> Builder -> public Builder updateNumberOfReplicas(final int numberOfReplicas, final String[] indices);1548772865;Update the number of replicas for the specified indices.__@param numberOfReplicas the number of replicas_@param indices          the indices to update the number of replicas for_@return the builder;public Builder updateNumberOfReplicas(final int numberOfReplicas, final String[] indices) {_            for (String index : indices) {_                IndexMetaData indexMetaData = this.indices.get(index)__                if (indexMetaData == null) {_                    throw new IndexNotFoundException(index)__                }_                put(IndexMetaData.builder(indexMetaData).numberOfReplicas(numberOfReplicas))__            }_            return this__        };update,the,number,of,replicas,for,the,specified,indices,param,number,of,replicas,the,number,of,replicas,param,indices,the,indices,to,update,the,number,of,replicas,for,return,the,builder;public,builder,update,number,of,replicas,final,int,number,of,replicas,final,string,indices,for,string,index,indices,index,meta,data,index,meta,data,this,indices,get,index,if,index,meta,data,null,throw,new,index,not,found,exception,index,put,index,meta,data,builder,index,meta,data,number,of,replicas,number,of,replicas,return,this
MetaData -> public Settings settings();1524684173;Returns the merged transient and persistent settings.;public Settings settings() {_        return this.settings__    };returns,the,merged,transient,and,persistent,settings;public,settings,settings,return,this,settings
MetaData -> public Settings settings();1527878678;Returns the merged transient and persistent settings.;public Settings settings() {_        return this.settings__    };returns,the,merged,transient,and,persistent,settings;public,settings,settings,return,this,settings
MetaData -> public Settings settings();1528103657;Returns the merged transient and persistent settings.;public Settings settings() {_        return this.settings__    };returns,the,merged,transient,and,persistent,settings;public,settings,settings,return,this,settings
MetaData -> public Settings settings();1529082965;Returns the merged transient and persistent settings.;public Settings settings() {_        return this.settings__    };returns,the,merged,transient,and,persistent,settings;public,settings,settings,return,this,settings
MetaData -> public Settings settings();1531179852;Returns the merged transient and persistent settings.;public Settings settings() {_        return this.settings__    };returns,the,merged,transient,and,persistent,settings;public,settings,settings,return,this,settings
MetaData -> public Settings settings();1532028790;Returns the merged transient and persistent settings.;public Settings settings() {_        return this.settings__    };returns,the,merged,transient,and,persistent,settings;public,settings,settings,return,this,settings
MetaData -> public Settings settings();1532353780;Returns the merged transient and persistent settings.;public Settings settings() {_        return this.settings__    };returns,the,merged,transient,and,persistent,settings;public,settings,settings,return,this,settings
MetaData -> public Settings settings();1536611444;Returns the merged transient and persistent settings.;public Settings settings() {_        return this.settings__    };returns,the,merged,transient,and,persistent,settings;public,settings,settings,return,this,settings
MetaData -> public Settings settings();1539723533;Returns the merged transient and persistent settings.;public Settings settings() {_        return this.settings__    };returns,the,merged,transient,and,persistent,settings;public,settings,settings,return,this,settings
MetaData -> public Settings settings();1540313026;Returns the merged transient and persistent settings.;public Settings settings() {_        return this.settings__    };returns,the,merged,transient,and,persistent,settings;public,settings,settings,return,this,settings
MetaData -> public Settings settings();1540486836;Returns the merged transient and persistent settings.;public Settings settings() {_        return this.settings__    };returns,the,merged,transient,and,persistent,settings;public,settings,settings,return,this,settings
MetaData -> public Settings settings();1540847035;Returns the merged transient and persistent settings.;public Settings settings() {_        return this.settings__    };returns,the,merged,transient,and,persistent,settings;public,settings,settings,return,this,settings
MetaData -> public Settings settings();1543947737;Returns the merged transient and persistent settings.;public Settings settings() {_        return this.settings__    };returns,the,merged,transient,and,persistent,settings;public,settings,settings,return,this,settings
MetaData -> public Settings settings();1544081506;Returns the merged transient and persistent settings.;public Settings settings() {_        return this.settings__    };returns,the,merged,transient,and,persistent,settings;public,settings,settings,return,this,settings
MetaData -> public Settings settings();1544702062;Returns the merged transient and persistent settings.;public Settings settings() {_        return this.settings__    };returns,the,merged,transient,and,persistent,settings;public,settings,settings,return,this,settings
MetaData -> public Settings settings();1547500081;Returns the merged transient and persistent settings.;public Settings settings() {_        return this.settings__    };returns,the,merged,transient,and,persistent,settings;public,settings,settings,return,this,settings
MetaData -> public Settings settings();1548772865;Returns the merged transient and persistent settings.;public Settings settings() {_        return this.settings__    };returns,the,merged,transient,and,persistent,settings;public,settings,settings,return,this,settings
MetaData -> public static boolean isAllTypes(String[] types);1524684173;Identifies whether the array containing type names given as argument refers to all types_The empty or null array identifies all types__@param types the array containing types_@return true if the provided array maps to all types, false otherwise;public static boolean isAllTypes(String[] types) {_        return types == null || types.length == 0 || isExplicitAllType(types)__    };identifies,whether,the,array,containing,type,names,given,as,argument,refers,to,all,types,the,empty,or,null,array,identifies,all,types,param,types,the,array,containing,types,return,true,if,the,provided,array,maps,to,all,types,false,otherwise;public,static,boolean,is,all,types,string,types,return,types,null,types,length,0,is,explicit,all,type,types
MetaData -> public static boolean isAllTypes(String[] types);1527878678;Identifies whether the array containing type names given as argument refers to all types_The empty or null array identifies all types__@param types the array containing types_@return true if the provided array maps to all types, false otherwise;public static boolean isAllTypes(String[] types) {_        return types == null || types.length == 0 || isExplicitAllType(types)__    };identifies,whether,the,array,containing,type,names,given,as,argument,refers,to,all,types,the,empty,or,null,array,identifies,all,types,param,types,the,array,containing,types,return,true,if,the,provided,array,maps,to,all,types,false,otherwise;public,static,boolean,is,all,types,string,types,return,types,null,types,length,0,is,explicit,all,type,types
MetaData -> public static boolean isAllTypes(String[] types);1528103657;Identifies whether the array containing type names given as argument refers to all types_The empty or null array identifies all types__@param types the array containing types_@return true if the provided array maps to all types, false otherwise;public static boolean isAllTypes(String[] types) {_        return types == null || types.length == 0 || isExplicitAllType(types)__    };identifies,whether,the,array,containing,type,names,given,as,argument,refers,to,all,types,the,empty,or,null,array,identifies,all,types,param,types,the,array,containing,types,return,true,if,the,provided,array,maps,to,all,types,false,otherwise;public,static,boolean,is,all,types,string,types,return,types,null,types,length,0,is,explicit,all,type,types
MetaData -> public static boolean isAllTypes(String[] types);1529082965;Identifies whether the array containing type names given as argument refers to all types_The empty or null array identifies all types__@param types the array containing types_@return true if the provided array maps to all types, false otherwise;public static boolean isAllTypes(String[] types) {_        return types == null || types.length == 0 || isExplicitAllType(types)__    };identifies,whether,the,array,containing,type,names,given,as,argument,refers,to,all,types,the,empty,or,null,array,identifies,all,types,param,types,the,array,containing,types,return,true,if,the,provided,array,maps,to,all,types,false,otherwise;public,static,boolean,is,all,types,string,types,return,types,null,types,length,0,is,explicit,all,type,types
MetaData -> public static boolean isAllTypes(String[] types);1531179852;Identifies whether the array containing type names given as argument refers to all types_The empty or null array identifies all types__@param types the array containing types_@return true if the provided array maps to all types, false otherwise;public static boolean isAllTypes(String[] types) {_        return types == null || types.length == 0 || isExplicitAllType(types)__    };identifies,whether,the,array,containing,type,names,given,as,argument,refers,to,all,types,the,empty,or,null,array,identifies,all,types,param,types,the,array,containing,types,return,true,if,the,provided,array,maps,to,all,types,false,otherwise;public,static,boolean,is,all,types,string,types,return,types,null,types,length,0,is,explicit,all,type,types
MetaData -> public static boolean isAllTypes(String[] types);1532028790;Identifies whether the array containing type names given as argument refers to all types_The empty or null array identifies all types__@param types the array containing types_@return true if the provided array maps to all types, false otherwise;public static boolean isAllTypes(String[] types) {_        return types == null || types.length == 0 || isExplicitAllType(types)__    };identifies,whether,the,array,containing,type,names,given,as,argument,refers,to,all,types,the,empty,or,null,array,identifies,all,types,param,types,the,array,containing,types,return,true,if,the,provided,array,maps,to,all,types,false,otherwise;public,static,boolean,is,all,types,string,types,return,types,null,types,length,0,is,explicit,all,type,types
MetaData -> public static boolean isAllTypes(String[] types);1532353780;Identifies whether the array containing type names given as argument refers to all types_The empty or null array identifies all types__@param types the array containing types_@return true if the provided array maps to all types, false otherwise;public static boolean isAllTypes(String[] types) {_        return types == null || types.length == 0 || isExplicitAllType(types)__    };identifies,whether,the,array,containing,type,names,given,as,argument,refers,to,all,types,the,empty,or,null,array,identifies,all,types,param,types,the,array,containing,types,return,true,if,the,provided,array,maps,to,all,types,false,otherwise;public,static,boolean,is,all,types,string,types,return,types,null,types,length,0,is,explicit,all,type,types
MetaData -> public static boolean isAllTypes(String[] types);1536611444;Identifies whether the array containing type names given as argument refers to all types_The empty or null array identifies all types__@param types the array containing types_@return true if the provided array maps to all types, false otherwise;public static boolean isAllTypes(String[] types) {_        return types == null || types.length == 0 || isExplicitAllType(types)__    };identifies,whether,the,array,containing,type,names,given,as,argument,refers,to,all,types,the,empty,or,null,array,identifies,all,types,param,types,the,array,containing,types,return,true,if,the,provided,array,maps,to,all,types,false,otherwise;public,static,boolean,is,all,types,string,types,return,types,null,types,length,0,is,explicit,all,type,types
MetaData -> public static boolean isAllTypes(String[] types);1539723533;Identifies whether the array containing type names given as argument refers to all types_The empty or null array identifies all types__@param types the array containing types_@return true if the provided array maps to all types, false otherwise;public static boolean isAllTypes(String[] types) {_        return types == null || types.length == 0 || isExplicitAllType(types)__    };identifies,whether,the,array,containing,type,names,given,as,argument,refers,to,all,types,the,empty,or,null,array,identifies,all,types,param,types,the,array,containing,types,return,true,if,the,provided,array,maps,to,all,types,false,otherwise;public,static,boolean,is,all,types,string,types,return,types,null,types,length,0,is,explicit,all,type,types
MetaData -> public static boolean isAllTypes(String[] types);1540313026;Identifies whether the array containing type names given as argument refers to all types_The empty or null array identifies all types__@param types the array containing types_@return true if the provided array maps to all types, false otherwise;public static boolean isAllTypes(String[] types) {_        return types == null || types.length == 0 || isExplicitAllType(types)__    };identifies,whether,the,array,containing,type,names,given,as,argument,refers,to,all,types,the,empty,or,null,array,identifies,all,types,param,types,the,array,containing,types,return,true,if,the,provided,array,maps,to,all,types,false,otherwise;public,static,boolean,is,all,types,string,types,return,types,null,types,length,0,is,explicit,all,type,types
MetaData -> public static boolean isAllTypes(String[] types);1540486836;Identifies whether the array containing type names given as argument refers to all types_The empty or null array identifies all types__@param types the array containing types_@return true if the provided array maps to all types, false otherwise;public static boolean isAllTypes(String[] types) {_        return types == null || types.length == 0 || isExplicitAllType(types)__    };identifies,whether,the,array,containing,type,names,given,as,argument,refers,to,all,types,the,empty,or,null,array,identifies,all,types,param,types,the,array,containing,types,return,true,if,the,provided,array,maps,to,all,types,false,otherwise;public,static,boolean,is,all,types,string,types,return,types,null,types,length,0,is,explicit,all,type,types
MetaData -> public static boolean isAllTypes(String[] types);1540847035;Identifies whether the array containing type names given as argument refers to all types_The empty or null array identifies all types__@param types the array containing types_@return true if the provided array maps to all types, false otherwise;public static boolean isAllTypes(String[] types) {_        return types == null || types.length == 0 || isExplicitAllType(types)__    };identifies,whether,the,array,containing,type,names,given,as,argument,refers,to,all,types,the,empty,or,null,array,identifies,all,types,param,types,the,array,containing,types,return,true,if,the,provided,array,maps,to,all,types,false,otherwise;public,static,boolean,is,all,types,string,types,return,types,null,types,length,0,is,explicit,all,type,types
MetaData -> public static boolean isAllTypes(String[] types);1543947737;Identifies whether the array containing type names given as argument refers to all types_The empty or null array identifies all types__@param types the array containing types_@return true if the provided array maps to all types, false otherwise;public static boolean isAllTypes(String[] types) {_        return types == null || types.length == 0 || isExplicitAllType(types)__    };identifies,whether,the,array,containing,type,names,given,as,argument,refers,to,all,types,the,empty,or,null,array,identifies,all,types,param,types,the,array,containing,types,return,true,if,the,provided,array,maps,to,all,types,false,otherwise;public,static,boolean,is,all,types,string,types,return,types,null,types,length,0,is,explicit,all,type,types
MetaData -> public static boolean isAllTypes(String[] types);1544081506;Identifies whether the array containing type names given as argument refers to all types_The empty or null array identifies all types__@param types the array containing types_@return true if the provided array maps to all types, false otherwise;public static boolean isAllTypes(String[] types) {_        return types == null || types.length == 0 || isExplicitAllType(types)__    };identifies,whether,the,array,containing,type,names,given,as,argument,refers,to,all,types,the,empty,or,null,array,identifies,all,types,param,types,the,array,containing,types,return,true,if,the,provided,array,maps,to,all,types,false,otherwise;public,static,boolean,is,all,types,string,types,return,types,null,types,length,0,is,explicit,all,type,types
MetaData -> public static boolean isAllTypes(String[] types);1544702062;Identifies whether the array containing type names given as argument refers to all types_The empty or null array identifies all types__@param types the array containing types_@return true if the provided array maps to all types, false otherwise;public static boolean isAllTypes(String[] types) {_        return types == null || types.length == 0 || isExplicitAllType(types)__    };identifies,whether,the,array,containing,type,names,given,as,argument,refers,to,all,types,the,empty,or,null,array,identifies,all,types,param,types,the,array,containing,types,return,true,if,the,provided,array,maps,to,all,types,false,otherwise;public,static,boolean,is,all,types,string,types,return,types,null,types,length,0,is,explicit,all,type,types
MetaData -> public static boolean isAllTypes(String[] types);1547500081;Identifies whether the array containing type names given as argument refers to all types_The empty or null array identifies all types__@param types the array containing types_@return true if the provided array maps to all types, false otherwise;public static boolean isAllTypes(String[] types) {_        return types == null || types.length == 0 || isExplicitAllType(types)__    };identifies,whether,the,array,containing,type,names,given,as,argument,refers,to,all,types,the,empty,or,null,array,identifies,all,types,param,types,the,array,containing,types,return,true,if,the,provided,array,maps,to,all,types,false,otherwise;public,static,boolean,is,all,types,string,types,return,types,null,types,length,0,is,explicit,all,type,types
MetaData -> public static boolean isAllTypes(String[] types);1548772865;Identifies whether the array containing type names given as argument refers to all types_The empty or null array identifies all types__@param types the array containing types_@return true if the provided array maps to all types, false otherwise;public static boolean isAllTypes(String[] types) {_        return types == null || types.length == 0 || isExplicitAllType(types)__    };identifies,whether,the,array,containing,type,names,given,as,argument,refers,to,all,types,the,empty,or,null,array,identifies,all,types,param,types,the,array,containing,types,return,true,if,the,provided,array,maps,to,all,types,false,otherwise;public,static,boolean,is,all,types,string,types,return,types,null,types,length,0,is,explicit,all,type,types
MetaData -> private ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final String[] aliases, final String[] concreteIndices);1540313026;Finds the specific index aliases that match with the specified aliases directly or partially via wildcards, and_that point to the specified concrete indices (directly or matching indices via wildcards).__@param aliases The aliases to look for. Might contain include or exclude wildcards._@param concreteIndices The concrete indices that the aliases must point to in order to be returned_@return A map of index name to the list of aliases metadata. If a concrete index does not have matching_aliases then the result will <b>not</b> include the index's key.;private ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final String[] aliases, final String[] concreteIndices) {_        assert aliases != null__        assert concreteIndices != null__        if (concreteIndices.length == 0) {_            return ImmutableOpenMap.of()__        }_        String[] patterns = new String[aliases.length]__        boolean[] include = new boolean[aliases.length]__        for (int i = 0_ i < aliases.length_ i++) {_            String alias = aliases[i]__            if (alias.charAt(0) == '-') {_                patterns[i] = alias.substring(1)__                include[i] = false__            } else {_                patterns[i] = alias__                include[i] = true__            }_        }_        boolean matchAllAliases = patterns.length == 0__        ImmutableOpenMap.Builder<String, List<AliasMetaData>> mapBuilder = ImmutableOpenMap.builder()__        for (String index : concreteIndices) {_            IndexMetaData indexMetaData = indices.get(index)__            List<AliasMetaData> filteredValues = new ArrayList<>()__            for (ObjectCursor<AliasMetaData> cursor : indexMetaData.getAliases().values()) {_                AliasMetaData value = cursor.value__                boolean matched = matchAllAliases__                String alias = value.alias()__                for (int i = 0_ i < patterns.length_ i++) {_                    if (include[i]) {_                        if (matched == false) {_                            String pattern = patterns[i]__                            matched = ALL.equals(pattern) || Regex.simpleMatch(pattern, alias)__                        }_                    } else if (matched) {_                        matched = Regex.simpleMatch(patterns[i], alias) == false__                    }_                }_                if (matched) {_                    filteredValues.add(value)__                }_            }_            if (filteredValues.isEmpty() == false) {_                _                CollectionUtil.timSort(filteredValues, Comparator.comparing(AliasMetaData::alias))__                mapBuilder.put(index, Collections.unmodifiableList(filteredValues))__            }_        }_        return mapBuilder.build()__    };finds,the,specific,index,aliases,that,match,with,the,specified,aliases,directly,or,partially,via,wildcards,and,that,point,to,the,specified,concrete,indices,directly,or,matching,indices,via,wildcards,param,aliases,the,aliases,to,look,for,might,contain,include,or,exclude,wildcards,param,concrete,indices,the,concrete,indices,that,the,aliases,must,point,to,in,order,to,be,returned,return,a,map,of,index,name,to,the,list,of,aliases,metadata,if,a,concrete,index,does,not,have,matching,aliases,then,the,result,will,b,not,b,include,the,index,s,key;private,immutable,open,map,string,list,alias,meta,data,find,aliases,final,string,aliases,final,string,concrete,indices,assert,aliases,null,assert,concrete,indices,null,if,concrete,indices,length,0,return,immutable,open,map,of,string,patterns,new,string,aliases,length,boolean,include,new,boolean,aliases,length,for,int,i,0,i,aliases,length,i,string,alias,aliases,i,if,alias,char,at,0,patterns,i,alias,substring,1,include,i,false,else,patterns,i,alias,include,i,true,boolean,match,all,aliases,patterns,length,0,immutable,open,map,builder,string,list,alias,meta,data,map,builder,immutable,open,map,builder,for,string,index,concrete,indices,index,meta,data,index,meta,data,indices,get,index,list,alias,meta,data,filtered,values,new,array,list,for,object,cursor,alias,meta,data,cursor,index,meta,data,get,aliases,values,alias,meta,data,value,cursor,value,boolean,matched,match,all,aliases,string,alias,value,alias,for,int,i,0,i,patterns,length,i,if,include,i,if,matched,false,string,pattern,patterns,i,matched,all,equals,pattern,regex,simple,match,pattern,alias,else,if,matched,matched,regex,simple,match,patterns,i,alias,false,if,matched,filtered,values,add,value,if,filtered,values,is,empty,false,collection,util,tim,sort,filtered,values,comparator,comparing,alias,meta,data,alias,map,builder,put,index,collections,unmodifiable,list,filtered,values,return,map,builder,build
MetaData -> private ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final String[] aliases, final String[] concreteIndices);1540486836;Finds the specific index aliases that match with the specified aliases directly or partially via wildcards, and_that point to the specified concrete indices (directly or matching indices via wildcards).__@param aliases The aliases to look for. Might contain include or exclude wildcards._@param concreteIndices The concrete indices that the aliases must point to in order to be returned_@return A map of index name to the list of aliases metadata. If a concrete index does not have matching_aliases then the result will <b>not</b> include the index's key.;private ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final String[] aliases, final String[] concreteIndices) {_        assert aliases != null__        assert concreteIndices != null__        if (concreteIndices.length == 0) {_            return ImmutableOpenMap.of()__        }_        String[] patterns = new String[aliases.length]__        boolean[] include = new boolean[aliases.length]__        for (int i = 0_ i < aliases.length_ i++) {_            String alias = aliases[i]__            if (alias.charAt(0) == '-') {_                patterns[i] = alias.substring(1)__                include[i] = false__            } else {_                patterns[i] = alias__                include[i] = true__            }_        }_        boolean matchAllAliases = patterns.length == 0__        ImmutableOpenMap.Builder<String, List<AliasMetaData>> mapBuilder = ImmutableOpenMap.builder()__        for (String index : concreteIndices) {_            IndexMetaData indexMetaData = indices.get(index)__            List<AliasMetaData> filteredValues = new ArrayList<>()__            for (ObjectCursor<AliasMetaData> cursor : indexMetaData.getAliases().values()) {_                AliasMetaData value = cursor.value__                boolean matched = matchAllAliases__                String alias = value.alias()__                for (int i = 0_ i < patterns.length_ i++) {_                    if (include[i]) {_                        if (matched == false) {_                            String pattern = patterns[i]__                            matched = ALL.equals(pattern) || Regex.simpleMatch(pattern, alias)__                        }_                    } else if (matched) {_                        matched = Regex.simpleMatch(patterns[i], alias) == false__                    }_                }_                if (matched) {_                    filteredValues.add(value)__                }_            }_            if (filteredValues.isEmpty() == false) {_                _                CollectionUtil.timSort(filteredValues, Comparator.comparing(AliasMetaData::alias))__                mapBuilder.put(index, Collections.unmodifiableList(filteredValues))__            }_        }_        return mapBuilder.build()__    };finds,the,specific,index,aliases,that,match,with,the,specified,aliases,directly,or,partially,via,wildcards,and,that,point,to,the,specified,concrete,indices,directly,or,matching,indices,via,wildcards,param,aliases,the,aliases,to,look,for,might,contain,include,or,exclude,wildcards,param,concrete,indices,the,concrete,indices,that,the,aliases,must,point,to,in,order,to,be,returned,return,a,map,of,index,name,to,the,list,of,aliases,metadata,if,a,concrete,index,does,not,have,matching,aliases,then,the,result,will,b,not,b,include,the,index,s,key;private,immutable,open,map,string,list,alias,meta,data,find,aliases,final,string,aliases,final,string,concrete,indices,assert,aliases,null,assert,concrete,indices,null,if,concrete,indices,length,0,return,immutable,open,map,of,string,patterns,new,string,aliases,length,boolean,include,new,boolean,aliases,length,for,int,i,0,i,aliases,length,i,string,alias,aliases,i,if,alias,char,at,0,patterns,i,alias,substring,1,include,i,false,else,patterns,i,alias,include,i,true,boolean,match,all,aliases,patterns,length,0,immutable,open,map,builder,string,list,alias,meta,data,map,builder,immutable,open,map,builder,for,string,index,concrete,indices,index,meta,data,index,meta,data,indices,get,index,list,alias,meta,data,filtered,values,new,array,list,for,object,cursor,alias,meta,data,cursor,index,meta,data,get,aliases,values,alias,meta,data,value,cursor,value,boolean,matched,match,all,aliases,string,alias,value,alias,for,int,i,0,i,patterns,length,i,if,include,i,if,matched,false,string,pattern,patterns,i,matched,all,equals,pattern,regex,simple,match,pattern,alias,else,if,matched,matched,regex,simple,match,patterns,i,alias,false,if,matched,filtered,values,add,value,if,filtered,values,is,empty,false,collection,util,tim,sort,filtered,values,comparator,comparing,alias,meta,data,alias,map,builder,put,index,collections,unmodifiable,list,filtered,values,return,map,builder,build
MetaData -> private ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final String[] aliases, final String[] concreteIndices);1540847035;Finds the specific index aliases that match with the specified aliases directly or partially via wildcards, and_that point to the specified concrete indices (directly or matching indices via wildcards).__@param aliases The aliases to look for. Might contain include or exclude wildcards._@param concreteIndices The concrete indices that the aliases must point to in order to be returned_@return A map of index name to the list of aliases metadata. If a concrete index does not have matching_aliases then the result will <b>not</b> include the index's key.;private ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final String[] aliases, final String[] concreteIndices) {_        assert aliases != null__        assert concreteIndices != null__        if (concreteIndices.length == 0) {_            return ImmutableOpenMap.of()__        }_        String[] patterns = new String[aliases.length]__        boolean[] include = new boolean[aliases.length]__        for (int i = 0_ i < aliases.length_ i++) {_            String alias = aliases[i]__            if (alias.charAt(0) == '-') {_                patterns[i] = alias.substring(1)__                include[i] = false__            } else {_                patterns[i] = alias__                include[i] = true__            }_        }_        boolean matchAllAliases = patterns.length == 0__        ImmutableOpenMap.Builder<String, List<AliasMetaData>> mapBuilder = ImmutableOpenMap.builder()__        for (String index : concreteIndices) {_            IndexMetaData indexMetaData = indices.get(index)__            List<AliasMetaData> filteredValues = new ArrayList<>()__            for (ObjectCursor<AliasMetaData> cursor : indexMetaData.getAliases().values()) {_                AliasMetaData value = cursor.value__                boolean matched = matchAllAliases__                String alias = value.alias()__                for (int i = 0_ i < patterns.length_ i++) {_                    if (include[i]) {_                        if (matched == false) {_                            String pattern = patterns[i]__                            matched = ALL.equals(pattern) || Regex.simpleMatch(pattern, alias)__                        }_                    } else if (matched) {_                        matched = Regex.simpleMatch(patterns[i], alias) == false__                    }_                }_                if (matched) {_                    filteredValues.add(value)__                }_            }_            if (filteredValues.isEmpty() == false) {_                _                CollectionUtil.timSort(filteredValues, Comparator.comparing(AliasMetaData::alias))__                mapBuilder.put(index, Collections.unmodifiableList(filteredValues))__            }_        }_        return mapBuilder.build()__    };finds,the,specific,index,aliases,that,match,with,the,specified,aliases,directly,or,partially,via,wildcards,and,that,point,to,the,specified,concrete,indices,directly,or,matching,indices,via,wildcards,param,aliases,the,aliases,to,look,for,might,contain,include,or,exclude,wildcards,param,concrete,indices,the,concrete,indices,that,the,aliases,must,point,to,in,order,to,be,returned,return,a,map,of,index,name,to,the,list,of,aliases,metadata,if,a,concrete,index,does,not,have,matching,aliases,then,the,result,will,b,not,b,include,the,index,s,key;private,immutable,open,map,string,list,alias,meta,data,find,aliases,final,string,aliases,final,string,concrete,indices,assert,aliases,null,assert,concrete,indices,null,if,concrete,indices,length,0,return,immutable,open,map,of,string,patterns,new,string,aliases,length,boolean,include,new,boolean,aliases,length,for,int,i,0,i,aliases,length,i,string,alias,aliases,i,if,alias,char,at,0,patterns,i,alias,substring,1,include,i,false,else,patterns,i,alias,include,i,true,boolean,match,all,aliases,patterns,length,0,immutable,open,map,builder,string,list,alias,meta,data,map,builder,immutable,open,map,builder,for,string,index,concrete,indices,index,meta,data,index,meta,data,indices,get,index,list,alias,meta,data,filtered,values,new,array,list,for,object,cursor,alias,meta,data,cursor,index,meta,data,get,aliases,values,alias,meta,data,value,cursor,value,boolean,matched,match,all,aliases,string,alias,value,alias,for,int,i,0,i,patterns,length,i,if,include,i,if,matched,false,string,pattern,patterns,i,matched,all,equals,pattern,regex,simple,match,pattern,alias,else,if,matched,matched,regex,simple,match,patterns,i,alias,false,if,matched,filtered,values,add,value,if,filtered,values,is,empty,false,collection,util,tim,sort,filtered,values,comparator,comparing,alias,meta,data,alias,map,builder,put,index,collections,unmodifiable,list,filtered,values,return,map,builder,build
MetaData -> private ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final String[] aliases, final String[] concreteIndices);1543947737;Finds the specific index aliases that match with the specified aliases directly or partially via wildcards, and_that point to the specified concrete indices (directly or matching indices via wildcards).__@param aliases The aliases to look for. Might contain include or exclude wildcards._@param concreteIndices The concrete indices that the aliases must point to in order to be returned_@return A map of index name to the list of aliases metadata. If a concrete index does not have matching_aliases then the result will <b>not</b> include the index's key.;private ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final String[] aliases, final String[] concreteIndices) {_        assert aliases != null__        assert concreteIndices != null__        if (concreteIndices.length == 0) {_            return ImmutableOpenMap.of()__        }_        String[] patterns = new String[aliases.length]__        boolean[] include = new boolean[aliases.length]__        for (int i = 0_ i < aliases.length_ i++) {_            String alias = aliases[i]__            if (alias.charAt(0) == '-') {_                patterns[i] = alias.substring(1)__                include[i] = false__            } else {_                patterns[i] = alias__                include[i] = true__            }_        }_        boolean matchAllAliases = patterns.length == 0__        ImmutableOpenMap.Builder<String, List<AliasMetaData>> mapBuilder = ImmutableOpenMap.builder()__        for (String index : concreteIndices) {_            IndexMetaData indexMetaData = indices.get(index)__            List<AliasMetaData> filteredValues = new ArrayList<>()__            for (ObjectCursor<AliasMetaData> cursor : indexMetaData.getAliases().values()) {_                AliasMetaData value = cursor.value__                boolean matched = matchAllAliases__                String alias = value.alias()__                for (int i = 0_ i < patterns.length_ i++) {_                    if (include[i]) {_                        if (matched == false) {_                            String pattern = patterns[i]__                            matched = ALL.equals(pattern) || Regex.simpleMatch(pattern, alias)__                        }_                    } else if (matched) {_                        matched = Regex.simpleMatch(patterns[i], alias) == false__                    }_                }_                if (matched) {_                    filteredValues.add(value)__                }_            }_            if (filteredValues.isEmpty() == false) {_                _                CollectionUtil.timSort(filteredValues, Comparator.comparing(AliasMetaData::alias))__                mapBuilder.put(index, Collections.unmodifiableList(filteredValues))__            }_        }_        return mapBuilder.build()__    };finds,the,specific,index,aliases,that,match,with,the,specified,aliases,directly,or,partially,via,wildcards,and,that,point,to,the,specified,concrete,indices,directly,or,matching,indices,via,wildcards,param,aliases,the,aliases,to,look,for,might,contain,include,or,exclude,wildcards,param,concrete,indices,the,concrete,indices,that,the,aliases,must,point,to,in,order,to,be,returned,return,a,map,of,index,name,to,the,list,of,aliases,metadata,if,a,concrete,index,does,not,have,matching,aliases,then,the,result,will,b,not,b,include,the,index,s,key;private,immutable,open,map,string,list,alias,meta,data,find,aliases,final,string,aliases,final,string,concrete,indices,assert,aliases,null,assert,concrete,indices,null,if,concrete,indices,length,0,return,immutable,open,map,of,string,patterns,new,string,aliases,length,boolean,include,new,boolean,aliases,length,for,int,i,0,i,aliases,length,i,string,alias,aliases,i,if,alias,char,at,0,patterns,i,alias,substring,1,include,i,false,else,patterns,i,alias,include,i,true,boolean,match,all,aliases,patterns,length,0,immutable,open,map,builder,string,list,alias,meta,data,map,builder,immutable,open,map,builder,for,string,index,concrete,indices,index,meta,data,index,meta,data,indices,get,index,list,alias,meta,data,filtered,values,new,array,list,for,object,cursor,alias,meta,data,cursor,index,meta,data,get,aliases,values,alias,meta,data,value,cursor,value,boolean,matched,match,all,aliases,string,alias,value,alias,for,int,i,0,i,patterns,length,i,if,include,i,if,matched,false,string,pattern,patterns,i,matched,all,equals,pattern,regex,simple,match,pattern,alias,else,if,matched,matched,regex,simple,match,patterns,i,alias,false,if,matched,filtered,values,add,value,if,filtered,values,is,empty,false,collection,util,tim,sort,filtered,values,comparator,comparing,alias,meta,data,alias,map,builder,put,index,collections,unmodifiable,list,filtered,values,return,map,builder,build
MetaData -> private ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final String[] aliases, final String[] concreteIndices);1544081506;Finds the specific index aliases that match with the specified aliases directly or partially via wildcards, and_that point to the specified concrete indices (directly or matching indices via wildcards).__@param aliases The aliases to look for. Might contain include or exclude wildcards._@param concreteIndices The concrete indices that the aliases must point to in order to be returned_@return A map of index name to the list of aliases metadata. If a concrete index does not have matching_aliases then the result will <b>not</b> include the index's key.;private ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final String[] aliases, final String[] concreteIndices) {_        assert aliases != null__        assert concreteIndices != null__        if (concreteIndices.length == 0) {_            return ImmutableOpenMap.of()__        }_        String[] patterns = new String[aliases.length]__        boolean[] include = new boolean[aliases.length]__        for (int i = 0_ i < aliases.length_ i++) {_            String alias = aliases[i]__            if (alias.charAt(0) == '-') {_                patterns[i] = alias.substring(1)__                include[i] = false__            } else {_                patterns[i] = alias__                include[i] = true__            }_        }_        boolean matchAllAliases = patterns.length == 0__        ImmutableOpenMap.Builder<String, List<AliasMetaData>> mapBuilder = ImmutableOpenMap.builder()__        for (String index : concreteIndices) {_            IndexMetaData indexMetaData = indices.get(index)__            List<AliasMetaData> filteredValues = new ArrayList<>()__            for (ObjectCursor<AliasMetaData> cursor : indexMetaData.getAliases().values()) {_                AliasMetaData value = cursor.value__                boolean matched = matchAllAliases__                String alias = value.alias()__                for (int i = 0_ i < patterns.length_ i++) {_                    if (include[i]) {_                        if (matched == false) {_                            String pattern = patterns[i]__                            matched = ALL.equals(pattern) || Regex.simpleMatch(pattern, alias)__                        }_                    } else if (matched) {_                        matched = Regex.simpleMatch(patterns[i], alias) == false__                    }_                }_                if (matched) {_                    filteredValues.add(value)__                }_            }_            if (filteredValues.isEmpty() == false) {_                _                CollectionUtil.timSort(filteredValues, Comparator.comparing(AliasMetaData::alias))__                mapBuilder.put(index, Collections.unmodifiableList(filteredValues))__            }_        }_        return mapBuilder.build()__    };finds,the,specific,index,aliases,that,match,with,the,specified,aliases,directly,or,partially,via,wildcards,and,that,point,to,the,specified,concrete,indices,directly,or,matching,indices,via,wildcards,param,aliases,the,aliases,to,look,for,might,contain,include,or,exclude,wildcards,param,concrete,indices,the,concrete,indices,that,the,aliases,must,point,to,in,order,to,be,returned,return,a,map,of,index,name,to,the,list,of,aliases,metadata,if,a,concrete,index,does,not,have,matching,aliases,then,the,result,will,b,not,b,include,the,index,s,key;private,immutable,open,map,string,list,alias,meta,data,find,aliases,final,string,aliases,final,string,concrete,indices,assert,aliases,null,assert,concrete,indices,null,if,concrete,indices,length,0,return,immutable,open,map,of,string,patterns,new,string,aliases,length,boolean,include,new,boolean,aliases,length,for,int,i,0,i,aliases,length,i,string,alias,aliases,i,if,alias,char,at,0,patterns,i,alias,substring,1,include,i,false,else,patterns,i,alias,include,i,true,boolean,match,all,aliases,patterns,length,0,immutable,open,map,builder,string,list,alias,meta,data,map,builder,immutable,open,map,builder,for,string,index,concrete,indices,index,meta,data,index,meta,data,indices,get,index,list,alias,meta,data,filtered,values,new,array,list,for,object,cursor,alias,meta,data,cursor,index,meta,data,get,aliases,values,alias,meta,data,value,cursor,value,boolean,matched,match,all,aliases,string,alias,value,alias,for,int,i,0,i,patterns,length,i,if,include,i,if,matched,false,string,pattern,patterns,i,matched,all,equals,pattern,regex,simple,match,pattern,alias,else,if,matched,matched,regex,simple,match,patterns,i,alias,false,if,matched,filtered,values,add,value,if,filtered,values,is,empty,false,collection,util,tim,sort,filtered,values,comparator,comparing,alias,meta,data,alias,map,builder,put,index,collections,unmodifiable,list,filtered,values,return,map,builder,build
MetaData -> private ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final String[] aliases, final String[] concreteIndices);1544702062;Finds the specific index aliases that match with the specified aliases directly or partially via wildcards, and_that point to the specified concrete indices (directly or matching indices via wildcards).__@param aliases The aliases to look for. Might contain include or exclude wildcards._@param concreteIndices The concrete indices that the aliases must point to in order to be returned_@return A map of index name to the list of aliases metadata. If a concrete index does not have matching_aliases then the result will <b>not</b> include the index's key.;private ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final String[] aliases, final String[] concreteIndices) {_        assert aliases != null__        assert concreteIndices != null__        if (concreteIndices.length == 0) {_            return ImmutableOpenMap.of()__        }_        String[] patterns = new String[aliases.length]__        boolean[] include = new boolean[aliases.length]__        for (int i = 0_ i < aliases.length_ i++) {_            String alias = aliases[i]__            if (alias.charAt(0) == '-') {_                patterns[i] = alias.substring(1)__                include[i] = false__            } else {_                patterns[i] = alias__                include[i] = true__            }_        }_        boolean matchAllAliases = patterns.length == 0__        ImmutableOpenMap.Builder<String, List<AliasMetaData>> mapBuilder = ImmutableOpenMap.builder()__        for (String index : concreteIndices) {_            IndexMetaData indexMetaData = indices.get(index)__            List<AliasMetaData> filteredValues = new ArrayList<>()__            for (ObjectCursor<AliasMetaData> cursor : indexMetaData.getAliases().values()) {_                AliasMetaData value = cursor.value__                boolean matched = matchAllAliases__                String alias = value.alias()__                for (int i = 0_ i < patterns.length_ i++) {_                    if (include[i]) {_                        if (matched == false) {_                            String pattern = patterns[i]__                            matched = ALL.equals(pattern) || Regex.simpleMatch(pattern, alias)__                        }_                    } else if (matched) {_                        matched = Regex.simpleMatch(patterns[i], alias) == false__                    }_                }_                if (matched) {_                    filteredValues.add(value)__                }_            }_            if (filteredValues.isEmpty() == false) {_                _                CollectionUtil.timSort(filteredValues, Comparator.comparing(AliasMetaData::alias))__                mapBuilder.put(index, Collections.unmodifiableList(filteredValues))__            }_        }_        return mapBuilder.build()__    };finds,the,specific,index,aliases,that,match,with,the,specified,aliases,directly,or,partially,via,wildcards,and,that,point,to,the,specified,concrete,indices,directly,or,matching,indices,via,wildcards,param,aliases,the,aliases,to,look,for,might,contain,include,or,exclude,wildcards,param,concrete,indices,the,concrete,indices,that,the,aliases,must,point,to,in,order,to,be,returned,return,a,map,of,index,name,to,the,list,of,aliases,metadata,if,a,concrete,index,does,not,have,matching,aliases,then,the,result,will,b,not,b,include,the,index,s,key;private,immutable,open,map,string,list,alias,meta,data,find,aliases,final,string,aliases,final,string,concrete,indices,assert,aliases,null,assert,concrete,indices,null,if,concrete,indices,length,0,return,immutable,open,map,of,string,patterns,new,string,aliases,length,boolean,include,new,boolean,aliases,length,for,int,i,0,i,aliases,length,i,string,alias,aliases,i,if,alias,char,at,0,patterns,i,alias,substring,1,include,i,false,else,patterns,i,alias,include,i,true,boolean,match,all,aliases,patterns,length,0,immutable,open,map,builder,string,list,alias,meta,data,map,builder,immutable,open,map,builder,for,string,index,concrete,indices,index,meta,data,index,meta,data,indices,get,index,list,alias,meta,data,filtered,values,new,array,list,for,object,cursor,alias,meta,data,cursor,index,meta,data,get,aliases,values,alias,meta,data,value,cursor,value,boolean,matched,match,all,aliases,string,alias,value,alias,for,int,i,0,i,patterns,length,i,if,include,i,if,matched,false,string,pattern,patterns,i,matched,all,equals,pattern,regex,simple,match,pattern,alias,else,if,matched,matched,regex,simple,match,patterns,i,alias,false,if,matched,filtered,values,add,value,if,filtered,values,is,empty,false,collection,util,tim,sort,filtered,values,comparator,comparing,alias,meta,data,alias,map,builder,put,index,collections,unmodifiable,list,filtered,values,return,map,builder,build
MetaData -> private ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final String[] aliases, final String[] concreteIndices);1547500081;Finds the specific index aliases that match with the specified aliases directly or partially via wildcards, and_that point to the specified concrete indices (directly or matching indices via wildcards).__@param aliases The aliases to look for. Might contain include or exclude wildcards._@param concreteIndices The concrete indices that the aliases must point to in order to be returned_@return A map of index name to the list of aliases metadata. If a concrete index does not have matching_aliases then the result will <b>not</b> include the index's key.;private ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final String[] aliases, final String[] concreteIndices) {_        assert aliases != null__        assert concreteIndices != null__        if (concreteIndices.length == 0) {_            return ImmutableOpenMap.of()__        }_        String[] patterns = new String[aliases.length]__        boolean[] include = new boolean[aliases.length]__        for (int i = 0_ i < aliases.length_ i++) {_            String alias = aliases[i]__            if (alias.charAt(0) == '-') {_                patterns[i] = alias.substring(1)__                include[i] = false__            } else {_                patterns[i] = alias__                include[i] = true__            }_        }_        boolean matchAllAliases = patterns.length == 0__        ImmutableOpenMap.Builder<String, List<AliasMetaData>> mapBuilder = ImmutableOpenMap.builder()__        for (String index : concreteIndices) {_            IndexMetaData indexMetaData = indices.get(index)__            List<AliasMetaData> filteredValues = new ArrayList<>()__            for (ObjectCursor<AliasMetaData> cursor : indexMetaData.getAliases().values()) {_                AliasMetaData value = cursor.value__                boolean matched = matchAllAliases__                String alias = value.alias()__                for (int i = 0_ i < patterns.length_ i++) {_                    if (include[i]) {_                        if (matched == false) {_                            String pattern = patterns[i]__                            matched = ALL.equals(pattern) || Regex.simpleMatch(pattern, alias)__                        }_                    } else if (matched) {_                        matched = Regex.simpleMatch(patterns[i], alias) == false__                    }_                }_                if (matched) {_                    filteredValues.add(value)__                }_            }_            if (filteredValues.isEmpty() == false) {_                _                CollectionUtil.timSort(filteredValues, Comparator.comparing(AliasMetaData::alias))__                mapBuilder.put(index, Collections.unmodifiableList(filteredValues))__            }_        }_        return mapBuilder.build()__    };finds,the,specific,index,aliases,that,match,with,the,specified,aliases,directly,or,partially,via,wildcards,and,that,point,to,the,specified,concrete,indices,directly,or,matching,indices,via,wildcards,param,aliases,the,aliases,to,look,for,might,contain,include,or,exclude,wildcards,param,concrete,indices,the,concrete,indices,that,the,aliases,must,point,to,in,order,to,be,returned,return,a,map,of,index,name,to,the,list,of,aliases,metadata,if,a,concrete,index,does,not,have,matching,aliases,then,the,result,will,b,not,b,include,the,index,s,key;private,immutable,open,map,string,list,alias,meta,data,find,aliases,final,string,aliases,final,string,concrete,indices,assert,aliases,null,assert,concrete,indices,null,if,concrete,indices,length,0,return,immutable,open,map,of,string,patterns,new,string,aliases,length,boolean,include,new,boolean,aliases,length,for,int,i,0,i,aliases,length,i,string,alias,aliases,i,if,alias,char,at,0,patterns,i,alias,substring,1,include,i,false,else,patterns,i,alias,include,i,true,boolean,match,all,aliases,patterns,length,0,immutable,open,map,builder,string,list,alias,meta,data,map,builder,immutable,open,map,builder,for,string,index,concrete,indices,index,meta,data,index,meta,data,indices,get,index,list,alias,meta,data,filtered,values,new,array,list,for,object,cursor,alias,meta,data,cursor,index,meta,data,get,aliases,values,alias,meta,data,value,cursor,value,boolean,matched,match,all,aliases,string,alias,value,alias,for,int,i,0,i,patterns,length,i,if,include,i,if,matched,false,string,pattern,patterns,i,matched,all,equals,pattern,regex,simple,match,pattern,alias,else,if,matched,matched,regex,simple,match,patterns,i,alias,false,if,matched,filtered,values,add,value,if,filtered,values,is,empty,false,collection,util,tim,sort,filtered,values,comparator,comparing,alias,meta,data,alias,map,builder,put,index,collections,unmodifiable,list,filtered,values,return,map,builder,build
MetaData -> private ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final String[] aliases, final String[] concreteIndices);1548772865;Finds the specific index aliases that match with the specified aliases directly or partially via wildcards, and_that point to the specified concrete indices (directly or matching indices via wildcards).__@param aliases The aliases to look for. Might contain include or exclude wildcards._@param concreteIndices The concrete indices that the aliases must point to in order to be returned_@return A map of index name to the list of aliases metadata. If a concrete index does not have matching_aliases then the result will <b>not</b> include the index's key.;private ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final String[] aliases, final String[] concreteIndices) {_        assert aliases != null__        assert concreteIndices != null__        if (concreteIndices.length == 0) {_            return ImmutableOpenMap.of()__        }_        String[] patterns = new String[aliases.length]__        boolean[] include = new boolean[aliases.length]__        for (int i = 0_ i < aliases.length_ i++) {_            String alias = aliases[i]__            if (alias.charAt(0) == '-') {_                patterns[i] = alias.substring(1)__                include[i] = false__            } else {_                patterns[i] = alias__                include[i] = true__            }_        }_        boolean matchAllAliases = patterns.length == 0__        ImmutableOpenMap.Builder<String, List<AliasMetaData>> mapBuilder = ImmutableOpenMap.builder()__        for (String index : concreteIndices) {_            IndexMetaData indexMetaData = indices.get(index)__            List<AliasMetaData> filteredValues = new ArrayList<>()__            for (ObjectCursor<AliasMetaData> cursor : indexMetaData.getAliases().values()) {_                AliasMetaData value = cursor.value__                boolean matched = matchAllAliases__                String alias = value.alias()__                for (int i = 0_ i < patterns.length_ i++) {_                    if (include[i]) {_                        if (matched == false) {_                            String pattern = patterns[i]__                            matched = ALL.equals(pattern) || Regex.simpleMatch(pattern, alias)__                        }_                    } else if (matched) {_                        matched = Regex.simpleMatch(patterns[i], alias) == false__                    }_                }_                if (matched) {_                    filteredValues.add(value)__                }_            }_            if (filteredValues.isEmpty() == false) {_                _                CollectionUtil.timSort(filteredValues, Comparator.comparing(AliasMetaData::alias))__                mapBuilder.put(index, Collections.unmodifiableList(filteredValues))__            }_        }_        return mapBuilder.build()__    };finds,the,specific,index,aliases,that,match,with,the,specified,aliases,directly,or,partially,via,wildcards,and,that,point,to,the,specified,concrete,indices,directly,or,matching,indices,via,wildcards,param,aliases,the,aliases,to,look,for,might,contain,include,or,exclude,wildcards,param,concrete,indices,the,concrete,indices,that,the,aliases,must,point,to,in,order,to,be,returned,return,a,map,of,index,name,to,the,list,of,aliases,metadata,if,a,concrete,index,does,not,have,matching,aliases,then,the,result,will,b,not,b,include,the,index,s,key;private,immutable,open,map,string,list,alias,meta,data,find,aliases,final,string,aliases,final,string,concrete,indices,assert,aliases,null,assert,concrete,indices,null,if,concrete,indices,length,0,return,immutable,open,map,of,string,patterns,new,string,aliases,length,boolean,include,new,boolean,aliases,length,for,int,i,0,i,aliases,length,i,string,alias,aliases,i,if,alias,char,at,0,patterns,i,alias,substring,1,include,i,false,else,patterns,i,alias,include,i,true,boolean,match,all,aliases,patterns,length,0,immutable,open,map,builder,string,list,alias,meta,data,map,builder,immutable,open,map,builder,for,string,index,concrete,indices,index,meta,data,index,meta,data,indices,get,index,list,alias,meta,data,filtered,values,new,array,list,for,object,cursor,alias,meta,data,cursor,index,meta,data,get,aliases,values,alias,meta,data,value,cursor,value,boolean,matched,match,all,aliases,string,alias,value,alias,for,int,i,0,i,patterns,length,i,if,include,i,if,matched,false,string,pattern,patterns,i,matched,all,equals,pattern,regex,simple,match,pattern,alias,else,if,matched,matched,regex,simple,match,patterns,i,alias,false,if,matched,filtered,values,add,value,if,filtered,values,is,empty,false,collection,util,tim,sort,filtered,values,comparator,comparing,alias,meta,data,alias,map,builder,put,index,collections,unmodifiable,list,filtered,values,return,map,builder,build
MetaData -> public ImmutableOpenMap<String, List<AliasMetaData>> findAllAliases(final String[] concreteIndices);1540313026;Finds the specific index aliases that point to the requested concrete indices directly_or that match with the indices via wildcards.__@param concreteIndices The concrete indices that the aliases must point to in order to be returned._@return A map of index name to the list of aliases metadata. If a concrete index does not have matching_aliases then the result will <b>not</b> include the index's key.;public ImmutableOpenMap<String, List<AliasMetaData>> findAllAliases(final String[] concreteIndices) {_        return findAliases(Strings.EMPTY_ARRAY, concreteIndices)__    };finds,the,specific,index,aliases,that,point,to,the,requested,concrete,indices,directly,or,that,match,with,the,indices,via,wildcards,param,concrete,indices,the,concrete,indices,that,the,aliases,must,point,to,in,order,to,be,returned,return,a,map,of,index,name,to,the,list,of,aliases,metadata,if,a,concrete,index,does,not,have,matching,aliases,then,the,result,will,b,not,b,include,the,index,s,key;public,immutable,open,map,string,list,alias,meta,data,find,all,aliases,final,string,concrete,indices,return,find,aliases,strings,concrete,indices
MetaData -> public ImmutableOpenMap<String, List<AliasMetaData>> findAllAliases(final String[] concreteIndices);1540486836;Finds the specific index aliases that point to the requested concrete indices directly_or that match with the indices via wildcards.__@param concreteIndices The concrete indices that the aliases must point to in order to be returned._@return A map of index name to the list of aliases metadata. If a concrete index does not have matching_aliases then the result will <b>not</b> include the index's key.;public ImmutableOpenMap<String, List<AliasMetaData>> findAllAliases(final String[] concreteIndices) {_        return findAliases(Strings.EMPTY_ARRAY, concreteIndices)__    };finds,the,specific,index,aliases,that,point,to,the,requested,concrete,indices,directly,or,that,match,with,the,indices,via,wildcards,param,concrete,indices,the,concrete,indices,that,the,aliases,must,point,to,in,order,to,be,returned,return,a,map,of,index,name,to,the,list,of,aliases,metadata,if,a,concrete,index,does,not,have,matching,aliases,then,the,result,will,b,not,b,include,the,index,s,key;public,immutable,open,map,string,list,alias,meta,data,find,all,aliases,final,string,concrete,indices,return,find,aliases,strings,concrete,indices
MetaData -> public ImmutableOpenMap<String, List<AliasMetaData>> findAllAliases(final String[] concreteIndices);1540847035;Finds the specific index aliases that point to the requested concrete indices directly_or that match with the indices via wildcards.__@param concreteIndices The concrete indices that the aliases must point to in order to be returned._@return A map of index name to the list of aliases metadata. If a concrete index does not have matching_aliases then the result will <b>not</b> include the index's key.;public ImmutableOpenMap<String, List<AliasMetaData>> findAllAliases(final String[] concreteIndices) {_        return findAliases(Strings.EMPTY_ARRAY, concreteIndices)__    };finds,the,specific,index,aliases,that,point,to,the,requested,concrete,indices,directly,or,that,match,with,the,indices,via,wildcards,param,concrete,indices,the,concrete,indices,that,the,aliases,must,point,to,in,order,to,be,returned,return,a,map,of,index,name,to,the,list,of,aliases,metadata,if,a,concrete,index,does,not,have,matching,aliases,then,the,result,will,b,not,b,include,the,index,s,key;public,immutable,open,map,string,list,alias,meta,data,find,all,aliases,final,string,concrete,indices,return,find,aliases,strings,concrete,indices
MetaData -> public ImmutableOpenMap<String, List<AliasMetaData>> findAllAliases(final String[] concreteIndices);1543947737;Finds the specific index aliases that point to the requested concrete indices directly_or that match with the indices via wildcards.__@param concreteIndices The concrete indices that the aliases must point to in order to be returned._@return A map of index name to the list of aliases metadata. If a concrete index does not have matching_aliases then the result will <b>not</b> include the index's key.;public ImmutableOpenMap<String, List<AliasMetaData>> findAllAliases(final String[] concreteIndices) {_        return findAliases(Strings.EMPTY_ARRAY, concreteIndices)__    };finds,the,specific,index,aliases,that,point,to,the,requested,concrete,indices,directly,or,that,match,with,the,indices,via,wildcards,param,concrete,indices,the,concrete,indices,that,the,aliases,must,point,to,in,order,to,be,returned,return,a,map,of,index,name,to,the,list,of,aliases,metadata,if,a,concrete,index,does,not,have,matching,aliases,then,the,result,will,b,not,b,include,the,index,s,key;public,immutable,open,map,string,list,alias,meta,data,find,all,aliases,final,string,concrete,indices,return,find,aliases,strings,concrete,indices
MetaData -> public ImmutableOpenMap<String, List<AliasMetaData>> findAllAliases(final String[] concreteIndices);1544081506;Finds the specific index aliases that point to the requested concrete indices directly_or that match with the indices via wildcards.__@param concreteIndices The concrete indices that the aliases must point to in order to be returned._@return A map of index name to the list of aliases metadata. If a concrete index does not have matching_aliases then the result will <b>not</b> include the index's key.;public ImmutableOpenMap<String, List<AliasMetaData>> findAllAliases(final String[] concreteIndices) {_        return findAliases(Strings.EMPTY_ARRAY, concreteIndices)__    };finds,the,specific,index,aliases,that,point,to,the,requested,concrete,indices,directly,or,that,match,with,the,indices,via,wildcards,param,concrete,indices,the,concrete,indices,that,the,aliases,must,point,to,in,order,to,be,returned,return,a,map,of,index,name,to,the,list,of,aliases,metadata,if,a,concrete,index,does,not,have,matching,aliases,then,the,result,will,b,not,b,include,the,index,s,key;public,immutable,open,map,string,list,alias,meta,data,find,all,aliases,final,string,concrete,indices,return,find,aliases,strings,concrete,indices
MetaData -> public ImmutableOpenMap<String, List<AliasMetaData>> findAllAliases(final String[] concreteIndices);1544702062;Finds the specific index aliases that point to the requested concrete indices directly_or that match with the indices via wildcards.__@param concreteIndices The concrete indices that the aliases must point to in order to be returned._@return A map of index name to the list of aliases metadata. If a concrete index does not have matching_aliases then the result will <b>not</b> include the index's key.;public ImmutableOpenMap<String, List<AliasMetaData>> findAllAliases(final String[] concreteIndices) {_        return findAliases(Strings.EMPTY_ARRAY, concreteIndices)__    };finds,the,specific,index,aliases,that,point,to,the,requested,concrete,indices,directly,or,that,match,with,the,indices,via,wildcards,param,concrete,indices,the,concrete,indices,that,the,aliases,must,point,to,in,order,to,be,returned,return,a,map,of,index,name,to,the,list,of,aliases,metadata,if,a,concrete,index,does,not,have,matching,aliases,then,the,result,will,b,not,b,include,the,index,s,key;public,immutable,open,map,string,list,alias,meta,data,find,all,aliases,final,string,concrete,indices,return,find,aliases,strings,concrete,indices
MetaData -> public ImmutableOpenMap<String, List<AliasMetaData>> findAllAliases(final String[] concreteIndices);1547500081;Finds the specific index aliases that point to the requested concrete indices directly_or that match with the indices via wildcards.__@param concreteIndices The concrete indices that the aliases must point to in order to be returned._@return A map of index name to the list of aliases metadata. If a concrete index does not have matching_aliases then the result will <b>not</b> include the index's key.;public ImmutableOpenMap<String, List<AliasMetaData>> findAllAliases(final String[] concreteIndices) {_        return findAliases(Strings.EMPTY_ARRAY, concreteIndices)__    };finds,the,specific,index,aliases,that,point,to,the,requested,concrete,indices,directly,or,that,match,with,the,indices,via,wildcards,param,concrete,indices,the,concrete,indices,that,the,aliases,must,point,to,in,order,to,be,returned,return,a,map,of,index,name,to,the,list,of,aliases,metadata,if,a,concrete,index,does,not,have,matching,aliases,then,the,result,will,b,not,b,include,the,index,s,key;public,immutable,open,map,string,list,alias,meta,data,find,all,aliases,final,string,concrete,indices,return,find,aliases,strings,concrete,indices
MetaData -> public ImmutableOpenMap<String, List<AliasMetaData>> findAllAliases(final String[] concreteIndices);1548772865;Finds the specific index aliases that point to the requested concrete indices directly_or that match with the indices via wildcards.__@param concreteIndices The concrete indices that the aliases must point to in order to be returned._@return A map of index name to the list of aliases metadata. If a concrete index does not have matching_aliases then the result will <b>not</b> include the index's key.;public ImmutableOpenMap<String, List<AliasMetaData>> findAllAliases(final String[] concreteIndices) {_        return findAliases(Strings.EMPTY_ARRAY, concreteIndices)__    };finds,the,specific,index,aliases,that,point,to,the,requested,concrete,indices,directly,or,that,match,with,the,indices,via,wildcards,param,concrete,indices,the,concrete,indices,that,the,aliases,must,point,to,in,order,to,be,returned,return,a,map,of,index,name,to,the,list,of,aliases,metadata,if,a,concrete,index,does,not,have,matching,aliases,then,the,result,will,b,not,b,include,the,index,s,key;public,immutable,open,map,string,list,alias,meta,data,find,all,aliases,final,string,concrete,indices,return,find,aliases,strings,concrete,indices
MetaData -> public static boolean isExplicitAllType(String[] types);1524684173;Identifies whether the array containing type names given as argument explicitly refers to all types_The empty or null array doesn't explicitly map to all types__@param types the array containing index names_@return true if the provided array explicitly maps to all types, false otherwise;public static boolean isExplicitAllType(String[] types) {_        return types != null && types.length == 1 && ALL.equals(types[0])__    };identifies,whether,the,array,containing,type,names,given,as,argument,explicitly,refers,to,all,types,the,empty,or,null,array,doesn,t,explicitly,map,to,all,types,param,types,the,array,containing,index,names,return,true,if,the,provided,array,explicitly,maps,to,all,types,false,otherwise;public,static,boolean,is,explicit,all,type,string,types,return,types,null,types,length,1,all,equals,types,0
MetaData -> public static boolean isExplicitAllType(String[] types);1527878678;Identifies whether the array containing type names given as argument explicitly refers to all types_The empty or null array doesn't explicitly map to all types__@param types the array containing index names_@return true if the provided array explicitly maps to all types, false otherwise;public static boolean isExplicitAllType(String[] types) {_        return types != null && types.length == 1 && ALL.equals(types[0])__    };identifies,whether,the,array,containing,type,names,given,as,argument,explicitly,refers,to,all,types,the,empty,or,null,array,doesn,t,explicitly,map,to,all,types,param,types,the,array,containing,index,names,return,true,if,the,provided,array,explicitly,maps,to,all,types,false,otherwise;public,static,boolean,is,explicit,all,type,string,types,return,types,null,types,length,1,all,equals,types,0
MetaData -> public static boolean isExplicitAllType(String[] types);1528103657;Identifies whether the array containing type names given as argument explicitly refers to all types_The empty or null array doesn't explicitly map to all types__@param types the array containing index names_@return true if the provided array explicitly maps to all types, false otherwise;public static boolean isExplicitAllType(String[] types) {_        return types != null && types.length == 1 && ALL.equals(types[0])__    };identifies,whether,the,array,containing,type,names,given,as,argument,explicitly,refers,to,all,types,the,empty,or,null,array,doesn,t,explicitly,map,to,all,types,param,types,the,array,containing,index,names,return,true,if,the,provided,array,explicitly,maps,to,all,types,false,otherwise;public,static,boolean,is,explicit,all,type,string,types,return,types,null,types,length,1,all,equals,types,0
MetaData -> public static boolean isExplicitAllType(String[] types);1529082965;Identifies whether the array containing type names given as argument explicitly refers to all types_The empty or null array doesn't explicitly map to all types__@param types the array containing index names_@return true if the provided array explicitly maps to all types, false otherwise;public static boolean isExplicitAllType(String[] types) {_        return types != null && types.length == 1 && ALL.equals(types[0])__    };identifies,whether,the,array,containing,type,names,given,as,argument,explicitly,refers,to,all,types,the,empty,or,null,array,doesn,t,explicitly,map,to,all,types,param,types,the,array,containing,index,names,return,true,if,the,provided,array,explicitly,maps,to,all,types,false,otherwise;public,static,boolean,is,explicit,all,type,string,types,return,types,null,types,length,1,all,equals,types,0
MetaData -> public static boolean isExplicitAllType(String[] types);1531179852;Identifies whether the array containing type names given as argument explicitly refers to all types_The empty or null array doesn't explicitly map to all types__@param types the array containing index names_@return true if the provided array explicitly maps to all types, false otherwise;public static boolean isExplicitAllType(String[] types) {_        return types != null && types.length == 1 && ALL.equals(types[0])__    };identifies,whether,the,array,containing,type,names,given,as,argument,explicitly,refers,to,all,types,the,empty,or,null,array,doesn,t,explicitly,map,to,all,types,param,types,the,array,containing,index,names,return,true,if,the,provided,array,explicitly,maps,to,all,types,false,otherwise;public,static,boolean,is,explicit,all,type,string,types,return,types,null,types,length,1,all,equals,types,0
MetaData -> public static boolean isExplicitAllType(String[] types);1532028790;Identifies whether the array containing type names given as argument explicitly refers to all types_The empty or null array doesn't explicitly map to all types__@param types the array containing index names_@return true if the provided array explicitly maps to all types, false otherwise;public static boolean isExplicitAllType(String[] types) {_        return types != null && types.length == 1 && ALL.equals(types[0])__    };identifies,whether,the,array,containing,type,names,given,as,argument,explicitly,refers,to,all,types,the,empty,or,null,array,doesn,t,explicitly,map,to,all,types,param,types,the,array,containing,index,names,return,true,if,the,provided,array,explicitly,maps,to,all,types,false,otherwise;public,static,boolean,is,explicit,all,type,string,types,return,types,null,types,length,1,all,equals,types,0
MetaData -> public static boolean isExplicitAllType(String[] types);1532353780;Identifies whether the array containing type names given as argument explicitly refers to all types_The empty or null array doesn't explicitly map to all types__@param types the array containing index names_@return true if the provided array explicitly maps to all types, false otherwise;public static boolean isExplicitAllType(String[] types) {_        return types != null && types.length == 1 && ALL.equals(types[0])__    };identifies,whether,the,array,containing,type,names,given,as,argument,explicitly,refers,to,all,types,the,empty,or,null,array,doesn,t,explicitly,map,to,all,types,param,types,the,array,containing,index,names,return,true,if,the,provided,array,explicitly,maps,to,all,types,false,otherwise;public,static,boolean,is,explicit,all,type,string,types,return,types,null,types,length,1,all,equals,types,0
MetaData -> public static boolean isExplicitAllType(String[] types);1536611444;Identifies whether the array containing type names given as argument explicitly refers to all types_The empty or null array doesn't explicitly map to all types__@param types the array containing index names_@return true if the provided array explicitly maps to all types, false otherwise;public static boolean isExplicitAllType(String[] types) {_        return types != null && types.length == 1 && ALL.equals(types[0])__    };identifies,whether,the,array,containing,type,names,given,as,argument,explicitly,refers,to,all,types,the,empty,or,null,array,doesn,t,explicitly,map,to,all,types,param,types,the,array,containing,index,names,return,true,if,the,provided,array,explicitly,maps,to,all,types,false,otherwise;public,static,boolean,is,explicit,all,type,string,types,return,types,null,types,length,1,all,equals,types,0
MetaData -> public static boolean isExplicitAllType(String[] types);1539723533;Identifies whether the array containing type names given as argument explicitly refers to all types_The empty or null array doesn't explicitly map to all types__@param types the array containing index names_@return true if the provided array explicitly maps to all types, false otherwise;public static boolean isExplicitAllType(String[] types) {_        return types != null && types.length == 1 && ALL.equals(types[0])__    };identifies,whether,the,array,containing,type,names,given,as,argument,explicitly,refers,to,all,types,the,empty,or,null,array,doesn,t,explicitly,map,to,all,types,param,types,the,array,containing,index,names,return,true,if,the,provided,array,explicitly,maps,to,all,types,false,otherwise;public,static,boolean,is,explicit,all,type,string,types,return,types,null,types,length,1,all,equals,types,0
MetaData -> public static boolean isExplicitAllType(String[] types);1540313026;Identifies whether the array containing type names given as argument explicitly refers to all types_The empty or null array doesn't explicitly map to all types__@param types the array containing index names_@return true if the provided array explicitly maps to all types, false otherwise;public static boolean isExplicitAllType(String[] types) {_        return types != null && types.length == 1 && ALL.equals(types[0])__    };identifies,whether,the,array,containing,type,names,given,as,argument,explicitly,refers,to,all,types,the,empty,or,null,array,doesn,t,explicitly,map,to,all,types,param,types,the,array,containing,index,names,return,true,if,the,provided,array,explicitly,maps,to,all,types,false,otherwise;public,static,boolean,is,explicit,all,type,string,types,return,types,null,types,length,1,all,equals,types,0
MetaData -> public static boolean isExplicitAllType(String[] types);1540486836;Identifies whether the array containing type names given as argument explicitly refers to all types_The empty or null array doesn't explicitly map to all types__@param types the array containing index names_@return true if the provided array explicitly maps to all types, false otherwise;public static boolean isExplicitAllType(String[] types) {_        return types != null && types.length == 1 && ALL.equals(types[0])__    };identifies,whether,the,array,containing,type,names,given,as,argument,explicitly,refers,to,all,types,the,empty,or,null,array,doesn,t,explicitly,map,to,all,types,param,types,the,array,containing,index,names,return,true,if,the,provided,array,explicitly,maps,to,all,types,false,otherwise;public,static,boolean,is,explicit,all,type,string,types,return,types,null,types,length,1,all,equals,types,0
MetaData -> public static boolean isExplicitAllType(String[] types);1540847035;Identifies whether the array containing type names given as argument explicitly refers to all types_The empty or null array doesn't explicitly map to all types__@param types the array containing index names_@return true if the provided array explicitly maps to all types, false otherwise;public static boolean isExplicitAllType(String[] types) {_        return types != null && types.length == 1 && ALL.equals(types[0])__    };identifies,whether,the,array,containing,type,names,given,as,argument,explicitly,refers,to,all,types,the,empty,or,null,array,doesn,t,explicitly,map,to,all,types,param,types,the,array,containing,index,names,return,true,if,the,provided,array,explicitly,maps,to,all,types,false,otherwise;public,static,boolean,is,explicit,all,type,string,types,return,types,null,types,length,1,all,equals,types,0
MetaData -> public static boolean isExplicitAllType(String[] types);1543947737;Identifies whether the array containing type names given as argument explicitly refers to all types_The empty or null array doesn't explicitly map to all types__@param types the array containing index names_@return true if the provided array explicitly maps to all types, false otherwise;public static boolean isExplicitAllType(String[] types) {_        return types != null && types.length == 1 && ALL.equals(types[0])__    };identifies,whether,the,array,containing,type,names,given,as,argument,explicitly,refers,to,all,types,the,empty,or,null,array,doesn,t,explicitly,map,to,all,types,param,types,the,array,containing,index,names,return,true,if,the,provided,array,explicitly,maps,to,all,types,false,otherwise;public,static,boolean,is,explicit,all,type,string,types,return,types,null,types,length,1,all,equals,types,0
MetaData -> public static boolean isExplicitAllType(String[] types);1544081506;Identifies whether the array containing type names given as argument explicitly refers to all types_The empty or null array doesn't explicitly map to all types__@param types the array containing index names_@return true if the provided array explicitly maps to all types, false otherwise;public static boolean isExplicitAllType(String[] types) {_        return types != null && types.length == 1 && ALL.equals(types[0])__    };identifies,whether,the,array,containing,type,names,given,as,argument,explicitly,refers,to,all,types,the,empty,or,null,array,doesn,t,explicitly,map,to,all,types,param,types,the,array,containing,index,names,return,true,if,the,provided,array,explicitly,maps,to,all,types,false,otherwise;public,static,boolean,is,explicit,all,type,string,types,return,types,null,types,length,1,all,equals,types,0
MetaData -> public static boolean isExplicitAllType(String[] types);1544702062;Identifies whether the array containing type names given as argument explicitly refers to all types_The empty or null array doesn't explicitly map to all types__@param types the array containing index names_@return true if the provided array explicitly maps to all types, false otherwise;public static boolean isExplicitAllType(String[] types) {_        return types != null && types.length == 1 && ALL.equals(types[0])__    };identifies,whether,the,array,containing,type,names,given,as,argument,explicitly,refers,to,all,types,the,empty,or,null,array,doesn,t,explicitly,map,to,all,types,param,types,the,array,containing,index,names,return,true,if,the,provided,array,explicitly,maps,to,all,types,false,otherwise;public,static,boolean,is,explicit,all,type,string,types,return,types,null,types,length,1,all,equals,types,0
MetaData -> public static boolean isExplicitAllType(String[] types);1547500081;Identifies whether the array containing type names given as argument explicitly refers to all types_The empty or null array doesn't explicitly map to all types__@param types the array containing index names_@return true if the provided array explicitly maps to all types, false otherwise;public static boolean isExplicitAllType(String[] types) {_        return types != null && types.length == 1 && ALL.equals(types[0])__    };identifies,whether,the,array,containing,type,names,given,as,argument,explicitly,refers,to,all,types,the,empty,or,null,array,doesn,t,explicitly,map,to,all,types,param,types,the,array,containing,index,names,return,true,if,the,provided,array,explicitly,maps,to,all,types,false,otherwise;public,static,boolean,is,explicit,all,type,string,types,return,types,null,types,length,1,all,equals,types,0
MetaData -> public static boolean isExplicitAllType(String[] types);1548772865;Identifies whether the array containing type names given as argument explicitly refers to all types_The empty or null array doesn't explicitly map to all types__@param types the array containing index names_@return true if the provided array explicitly maps to all types, false otherwise;public static boolean isExplicitAllType(String[] types) {_        return types != null && types.length == 1 && ALL.equals(types[0])__    };identifies,whether,the,array,containing,type,names,given,as,argument,explicitly,refers,to,all,types,the,empty,or,null,array,doesn,t,explicitly,map,to,all,types,param,types,the,array,containing,index,names,return,true,if,the,provided,array,explicitly,maps,to,all,types,false,otherwise;public,static,boolean,is,explicit,all,type,string,types,return,types,null,types,length,1,all,equals,types,0
MetaData -> public ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> findMappings(String[] concreteIndices,                                                                                             final String[] types,                                                                                             Function<String, Predicate<String>> fieldFilter)             throws IOException;1524684173;Finds all mappings for types and concrete indices. Types are expanded to include all types that match the glob_patterns in the types array. Empty types array, null or {"_all"} will be expanded to all types available for_the given indices. Only fields that match the provided field filter will be returned (default is a predicate_that always returns true, which can be overridden via plugins)__@see MapperPlugin#getFieldFilter();public ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> findMappings(String[] concreteIndices,_                                                                                            final String[] types,_                                                                                            Function<String, Predicate<String>> fieldFilter)_            throws IOException {_        assert types != null__        assert concreteIndices != null__        if (concreteIndices.length == 0) {_            return ImmutableOpenMap.of()__        }__        boolean isAllTypes = isAllTypes(types)__        ImmutableOpenMap.Builder<String, ImmutableOpenMap<String, MappingMetaData>> indexMapBuilder = ImmutableOpenMap.builder()__        Iterable<String> intersection = HppcMaps.intersection(ObjectHashSet.from(concreteIndices), indices.keys())__        for (String index : intersection) {_            IndexMetaData indexMetaData = indices.get(index)__            Predicate<String> fieldPredicate = fieldFilter.apply(index)__            if (isAllTypes) {_                indexMapBuilder.put(index, filterFields(indexMetaData.getMappings(), fieldPredicate))__            } else {_                ImmutableOpenMap.Builder<String, MappingMetaData> filteredMappings = ImmutableOpenMap.builder()__                for (ObjectObjectCursor<String, MappingMetaData> cursor : indexMetaData.getMappings()) {_                    if (Regex.simpleMatch(types, cursor.key)) {_                        filteredMappings.put(cursor.key, filterFields(cursor.value, fieldPredicate))__                    }_                }_                if (!filteredMappings.isEmpty()) {_                    indexMapBuilder.put(index, filteredMappings.build())__                }_            }_        }_        return indexMapBuilder.build()__    };finds,all,mappings,for,types,and,concrete,indices,types,are,expanded,to,include,all,types,that,match,the,glob,patterns,in,the,types,array,empty,types,array,null,or,will,be,expanded,to,all,types,available,for,the,given,indices,only,fields,that,match,the,provided,field,filter,will,be,returned,default,is,a,predicate,that,always,returns,true,which,can,be,overridden,via,plugins,see,mapper,plugin,get,field,filter;public,immutable,open,map,string,immutable,open,map,string,mapping,meta,data,find,mappings,string,concrete,indices,final,string,types,function,string,predicate,string,field,filter,throws,ioexception,assert,types,null,assert,concrete,indices,null,if,concrete,indices,length,0,return,immutable,open,map,of,boolean,is,all,types,is,all,types,types,immutable,open,map,builder,string,immutable,open,map,string,mapping,meta,data,index,map,builder,immutable,open,map,builder,iterable,string,intersection,hppc,maps,intersection,object,hash,set,from,concrete,indices,indices,keys,for,string,index,intersection,index,meta,data,index,meta,data,indices,get,index,predicate,string,field,predicate,field,filter,apply,index,if,is,all,types,index,map,builder,put,index,filter,fields,index,meta,data,get,mappings,field,predicate,else,immutable,open,map,builder,string,mapping,meta,data,filtered,mappings,immutable,open,map,builder,for,object,object,cursor,string,mapping,meta,data,cursor,index,meta,data,get,mappings,if,regex,simple,match,types,cursor,key,filtered,mappings,put,cursor,key,filter,fields,cursor,value,field,predicate,if,filtered,mappings,is,empty,index,map,builder,put,index,filtered,mappings,build,return,index,map,builder,build
MetaData -> public ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> findMappings(String[] concreteIndices,                                                                                             final String[] types,                                                                                             Function<String, Predicate<String>> fieldFilter)             throws IOException;1527878678;Finds all mappings for types and concrete indices. Types are expanded to include all types that match the glob_patterns in the types array. Empty types array, null or {"_all"} will be expanded to all types available for_the given indices. Only fields that match the provided field filter will be returned (default is a predicate_that always returns true, which can be overridden via plugins)__@see MapperPlugin#getFieldFilter();public ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> findMappings(String[] concreteIndices,_                                                                                            final String[] types,_                                                                                            Function<String, Predicate<String>> fieldFilter)_            throws IOException {_        assert types != null__        assert concreteIndices != null__        if (concreteIndices.length == 0) {_            return ImmutableOpenMap.of()__        }__        boolean isAllTypes = isAllTypes(types)__        ImmutableOpenMap.Builder<String, ImmutableOpenMap<String, MappingMetaData>> indexMapBuilder = ImmutableOpenMap.builder()__        Iterable<String> intersection = HppcMaps.intersection(ObjectHashSet.from(concreteIndices), indices.keys())__        for (String index : intersection) {_            IndexMetaData indexMetaData = indices.get(index)__            Predicate<String> fieldPredicate = fieldFilter.apply(index)__            if (isAllTypes) {_                indexMapBuilder.put(index, filterFields(indexMetaData.getMappings(), fieldPredicate))__            } else {_                ImmutableOpenMap.Builder<String, MappingMetaData> filteredMappings = ImmutableOpenMap.builder()__                for (ObjectObjectCursor<String, MappingMetaData> cursor : indexMetaData.getMappings()) {_                    if (Regex.simpleMatch(types, cursor.key)) {_                        filteredMappings.put(cursor.key, filterFields(cursor.value, fieldPredicate))__                    }_                }_                if (!filteredMappings.isEmpty()) {_                    indexMapBuilder.put(index, filteredMappings.build())__                }_            }_        }_        return indexMapBuilder.build()__    };finds,all,mappings,for,types,and,concrete,indices,types,are,expanded,to,include,all,types,that,match,the,glob,patterns,in,the,types,array,empty,types,array,null,or,will,be,expanded,to,all,types,available,for,the,given,indices,only,fields,that,match,the,provided,field,filter,will,be,returned,default,is,a,predicate,that,always,returns,true,which,can,be,overridden,via,plugins,see,mapper,plugin,get,field,filter;public,immutable,open,map,string,immutable,open,map,string,mapping,meta,data,find,mappings,string,concrete,indices,final,string,types,function,string,predicate,string,field,filter,throws,ioexception,assert,types,null,assert,concrete,indices,null,if,concrete,indices,length,0,return,immutable,open,map,of,boolean,is,all,types,is,all,types,types,immutable,open,map,builder,string,immutable,open,map,string,mapping,meta,data,index,map,builder,immutable,open,map,builder,iterable,string,intersection,hppc,maps,intersection,object,hash,set,from,concrete,indices,indices,keys,for,string,index,intersection,index,meta,data,index,meta,data,indices,get,index,predicate,string,field,predicate,field,filter,apply,index,if,is,all,types,index,map,builder,put,index,filter,fields,index,meta,data,get,mappings,field,predicate,else,immutable,open,map,builder,string,mapping,meta,data,filtered,mappings,immutable,open,map,builder,for,object,object,cursor,string,mapping,meta,data,cursor,index,meta,data,get,mappings,if,regex,simple,match,types,cursor,key,filtered,mappings,put,cursor,key,filter,fields,cursor,value,field,predicate,if,filtered,mappings,is,empty,index,map,builder,put,index,filtered,mappings,build,return,index,map,builder,build
MetaData -> public ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> findMappings(String[] concreteIndices,                                                                                             final String[] types,                                                                                             Function<String, Predicate<String>> fieldFilter)             throws IOException;1528103657;Finds all mappings for types and concrete indices. Types are expanded to include all types that match the glob_patterns in the types array. Empty types array, null or {"_all"} will be expanded to all types available for_the given indices. Only fields that match the provided field filter will be returned (default is a predicate_that always returns true, which can be overridden via plugins)__@see MapperPlugin#getFieldFilter();public ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> findMappings(String[] concreteIndices,_                                                                                            final String[] types,_                                                                                            Function<String, Predicate<String>> fieldFilter)_            throws IOException {_        assert types != null__        assert concreteIndices != null__        if (concreteIndices.length == 0) {_            return ImmutableOpenMap.of()__        }__        boolean isAllTypes = isAllTypes(types)__        ImmutableOpenMap.Builder<String, ImmutableOpenMap<String, MappingMetaData>> indexMapBuilder = ImmutableOpenMap.builder()__        Iterable<String> intersection = HppcMaps.intersection(ObjectHashSet.from(concreteIndices), indices.keys())__        for (String index : intersection) {_            IndexMetaData indexMetaData = indices.get(index)__            Predicate<String> fieldPredicate = fieldFilter.apply(index)__            if (isAllTypes) {_                indexMapBuilder.put(index, filterFields(indexMetaData.getMappings(), fieldPredicate))__            } else {_                ImmutableOpenMap.Builder<String, MappingMetaData> filteredMappings = ImmutableOpenMap.builder()__                for (ObjectObjectCursor<String, MappingMetaData> cursor : indexMetaData.getMappings()) {_                    if (Regex.simpleMatch(types, cursor.key)) {_                        filteredMappings.put(cursor.key, filterFields(cursor.value, fieldPredicate))__                    }_                }_                if (!filteredMappings.isEmpty()) {_                    indexMapBuilder.put(index, filteredMappings.build())__                }_            }_        }_        return indexMapBuilder.build()__    };finds,all,mappings,for,types,and,concrete,indices,types,are,expanded,to,include,all,types,that,match,the,glob,patterns,in,the,types,array,empty,types,array,null,or,will,be,expanded,to,all,types,available,for,the,given,indices,only,fields,that,match,the,provided,field,filter,will,be,returned,default,is,a,predicate,that,always,returns,true,which,can,be,overridden,via,plugins,see,mapper,plugin,get,field,filter;public,immutable,open,map,string,immutable,open,map,string,mapping,meta,data,find,mappings,string,concrete,indices,final,string,types,function,string,predicate,string,field,filter,throws,ioexception,assert,types,null,assert,concrete,indices,null,if,concrete,indices,length,0,return,immutable,open,map,of,boolean,is,all,types,is,all,types,types,immutable,open,map,builder,string,immutable,open,map,string,mapping,meta,data,index,map,builder,immutable,open,map,builder,iterable,string,intersection,hppc,maps,intersection,object,hash,set,from,concrete,indices,indices,keys,for,string,index,intersection,index,meta,data,index,meta,data,indices,get,index,predicate,string,field,predicate,field,filter,apply,index,if,is,all,types,index,map,builder,put,index,filter,fields,index,meta,data,get,mappings,field,predicate,else,immutable,open,map,builder,string,mapping,meta,data,filtered,mappings,immutable,open,map,builder,for,object,object,cursor,string,mapping,meta,data,cursor,index,meta,data,get,mappings,if,regex,simple,match,types,cursor,key,filtered,mappings,put,cursor,key,filter,fields,cursor,value,field,predicate,if,filtered,mappings,is,empty,index,map,builder,put,index,filtered,mappings,build,return,index,map,builder,build
MetaData -> public ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> findMappings(String[] concreteIndices,                                                                                             final String[] types,                                                                                             Function<String, Predicate<String>> fieldFilter)             throws IOException;1529082965;Finds all mappings for types and concrete indices. Types are expanded to include all types that match the glob_patterns in the types array. Empty types array, null or {"_all"} will be expanded to all types available for_the given indices. Only fields that match the provided field filter will be returned (default is a predicate_that always returns true, which can be overridden via plugins)__@see MapperPlugin#getFieldFilter();public ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> findMappings(String[] concreteIndices,_                                                                                            final String[] types,_                                                                                            Function<String, Predicate<String>> fieldFilter)_            throws IOException {_        assert types != null__        assert concreteIndices != null__        if (concreteIndices.length == 0) {_            return ImmutableOpenMap.of()__        }__        boolean isAllTypes = isAllTypes(types)__        ImmutableOpenMap.Builder<String, ImmutableOpenMap<String, MappingMetaData>> indexMapBuilder = ImmutableOpenMap.builder()__        Iterable<String> intersection = HppcMaps.intersection(ObjectHashSet.from(concreteIndices), indices.keys())__        for (String index : intersection) {_            IndexMetaData indexMetaData = indices.get(index)__            Predicate<String> fieldPredicate = fieldFilter.apply(index)__            if (isAllTypes) {_                indexMapBuilder.put(index, filterFields(indexMetaData.getMappings(), fieldPredicate))__            } else {_                ImmutableOpenMap.Builder<String, MappingMetaData> filteredMappings = ImmutableOpenMap.builder()__                for (ObjectObjectCursor<String, MappingMetaData> cursor : indexMetaData.getMappings()) {_                    if (Regex.simpleMatch(types, cursor.key)) {_                        filteredMappings.put(cursor.key, filterFields(cursor.value, fieldPredicate))__                    }_                }_                if (!filteredMappings.isEmpty()) {_                    indexMapBuilder.put(index, filteredMappings.build())__                }_            }_        }_        return indexMapBuilder.build()__    };finds,all,mappings,for,types,and,concrete,indices,types,are,expanded,to,include,all,types,that,match,the,glob,patterns,in,the,types,array,empty,types,array,null,or,will,be,expanded,to,all,types,available,for,the,given,indices,only,fields,that,match,the,provided,field,filter,will,be,returned,default,is,a,predicate,that,always,returns,true,which,can,be,overridden,via,plugins,see,mapper,plugin,get,field,filter;public,immutable,open,map,string,immutable,open,map,string,mapping,meta,data,find,mappings,string,concrete,indices,final,string,types,function,string,predicate,string,field,filter,throws,ioexception,assert,types,null,assert,concrete,indices,null,if,concrete,indices,length,0,return,immutable,open,map,of,boolean,is,all,types,is,all,types,types,immutable,open,map,builder,string,immutable,open,map,string,mapping,meta,data,index,map,builder,immutable,open,map,builder,iterable,string,intersection,hppc,maps,intersection,object,hash,set,from,concrete,indices,indices,keys,for,string,index,intersection,index,meta,data,index,meta,data,indices,get,index,predicate,string,field,predicate,field,filter,apply,index,if,is,all,types,index,map,builder,put,index,filter,fields,index,meta,data,get,mappings,field,predicate,else,immutable,open,map,builder,string,mapping,meta,data,filtered,mappings,immutable,open,map,builder,for,object,object,cursor,string,mapping,meta,data,cursor,index,meta,data,get,mappings,if,regex,simple,match,types,cursor,key,filtered,mappings,put,cursor,key,filter,fields,cursor,value,field,predicate,if,filtered,mappings,is,empty,index,map,builder,put,index,filtered,mappings,build,return,index,map,builder,build
MetaData -> public ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> findMappings(String[] concreteIndices,                                                                                             final String[] types,                                                                                             Function<String, Predicate<String>> fieldFilter)             throws IOException;1531179852;Finds all mappings for types and concrete indices. Types are expanded to include all types that match the glob_patterns in the types array. Empty types array, null or {"_all"} will be expanded to all types available for_the given indices. Only fields that match the provided field filter will be returned (default is a predicate_that always returns true, which can be overridden via plugins)__@see MapperPlugin#getFieldFilter();public ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> findMappings(String[] concreteIndices,_                                                                                            final String[] types,_                                                                                            Function<String, Predicate<String>> fieldFilter)_            throws IOException {_        assert types != null__        assert concreteIndices != null__        if (concreteIndices.length == 0) {_            return ImmutableOpenMap.of()__        }__        boolean isAllTypes = isAllTypes(types)__        ImmutableOpenMap.Builder<String, ImmutableOpenMap<String, MappingMetaData>> indexMapBuilder = ImmutableOpenMap.builder()__        Iterable<String> intersection = HppcMaps.intersection(ObjectHashSet.from(concreteIndices), indices.keys())__        for (String index : intersection) {_            IndexMetaData indexMetaData = indices.get(index)__            Predicate<String> fieldPredicate = fieldFilter.apply(index)__            if (isAllTypes) {_                indexMapBuilder.put(index, filterFields(indexMetaData.getMappings(), fieldPredicate))__            } else {_                ImmutableOpenMap.Builder<String, MappingMetaData> filteredMappings = ImmutableOpenMap.builder()__                for (ObjectObjectCursor<String, MappingMetaData> cursor : indexMetaData.getMappings()) {_                    if (Regex.simpleMatch(types, cursor.key)) {_                        filteredMappings.put(cursor.key, filterFields(cursor.value, fieldPredicate))__                    }_                }_                if (!filteredMappings.isEmpty()) {_                    indexMapBuilder.put(index, filteredMappings.build())__                }_            }_        }_        return indexMapBuilder.build()__    };finds,all,mappings,for,types,and,concrete,indices,types,are,expanded,to,include,all,types,that,match,the,glob,patterns,in,the,types,array,empty,types,array,null,or,will,be,expanded,to,all,types,available,for,the,given,indices,only,fields,that,match,the,provided,field,filter,will,be,returned,default,is,a,predicate,that,always,returns,true,which,can,be,overridden,via,plugins,see,mapper,plugin,get,field,filter;public,immutable,open,map,string,immutable,open,map,string,mapping,meta,data,find,mappings,string,concrete,indices,final,string,types,function,string,predicate,string,field,filter,throws,ioexception,assert,types,null,assert,concrete,indices,null,if,concrete,indices,length,0,return,immutable,open,map,of,boolean,is,all,types,is,all,types,types,immutable,open,map,builder,string,immutable,open,map,string,mapping,meta,data,index,map,builder,immutable,open,map,builder,iterable,string,intersection,hppc,maps,intersection,object,hash,set,from,concrete,indices,indices,keys,for,string,index,intersection,index,meta,data,index,meta,data,indices,get,index,predicate,string,field,predicate,field,filter,apply,index,if,is,all,types,index,map,builder,put,index,filter,fields,index,meta,data,get,mappings,field,predicate,else,immutable,open,map,builder,string,mapping,meta,data,filtered,mappings,immutable,open,map,builder,for,object,object,cursor,string,mapping,meta,data,cursor,index,meta,data,get,mappings,if,regex,simple,match,types,cursor,key,filtered,mappings,put,cursor,key,filter,fields,cursor,value,field,predicate,if,filtered,mappings,is,empty,index,map,builder,put,index,filtered,mappings,build,return,index,map,builder,build
MetaData -> public ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> findMappings(String[] concreteIndices,                                                                                             final String[] types,                                                                                             Function<String, Predicate<String>> fieldFilter)             throws IOException;1532028790;Finds all mappings for types and concrete indices. Types are expanded to include all types that match the glob_patterns in the types array. Empty types array, null or {"_all"} will be expanded to all types available for_the given indices. Only fields that match the provided field filter will be returned (default is a predicate_that always returns true, which can be overridden via plugins)__@see MapperPlugin#getFieldFilter();public ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> findMappings(String[] concreteIndices,_                                                                                            final String[] types,_                                                                                            Function<String, Predicate<String>> fieldFilter)_            throws IOException {_        assert types != null__        assert concreteIndices != null__        if (concreteIndices.length == 0) {_            return ImmutableOpenMap.of()__        }__        boolean isAllTypes = isAllTypes(types)__        ImmutableOpenMap.Builder<String, ImmutableOpenMap<String, MappingMetaData>> indexMapBuilder = ImmutableOpenMap.builder()__        Iterable<String> intersection = HppcMaps.intersection(ObjectHashSet.from(concreteIndices), indices.keys())__        for (String index : intersection) {_            IndexMetaData indexMetaData = indices.get(index)__            Predicate<String> fieldPredicate = fieldFilter.apply(index)__            if (isAllTypes) {_                indexMapBuilder.put(index, filterFields(indexMetaData.getMappings(), fieldPredicate))__            } else {_                ImmutableOpenMap.Builder<String, MappingMetaData> filteredMappings = ImmutableOpenMap.builder()__                for (ObjectObjectCursor<String, MappingMetaData> cursor : indexMetaData.getMappings()) {_                    if (Regex.simpleMatch(types, cursor.key)) {_                        filteredMappings.put(cursor.key, filterFields(cursor.value, fieldPredicate))__                    }_                }_                if (!filteredMappings.isEmpty()) {_                    indexMapBuilder.put(index, filteredMappings.build())__                }_            }_        }_        return indexMapBuilder.build()__    };finds,all,mappings,for,types,and,concrete,indices,types,are,expanded,to,include,all,types,that,match,the,glob,patterns,in,the,types,array,empty,types,array,null,or,will,be,expanded,to,all,types,available,for,the,given,indices,only,fields,that,match,the,provided,field,filter,will,be,returned,default,is,a,predicate,that,always,returns,true,which,can,be,overridden,via,plugins,see,mapper,plugin,get,field,filter;public,immutable,open,map,string,immutable,open,map,string,mapping,meta,data,find,mappings,string,concrete,indices,final,string,types,function,string,predicate,string,field,filter,throws,ioexception,assert,types,null,assert,concrete,indices,null,if,concrete,indices,length,0,return,immutable,open,map,of,boolean,is,all,types,is,all,types,types,immutable,open,map,builder,string,immutable,open,map,string,mapping,meta,data,index,map,builder,immutable,open,map,builder,iterable,string,intersection,hppc,maps,intersection,object,hash,set,from,concrete,indices,indices,keys,for,string,index,intersection,index,meta,data,index,meta,data,indices,get,index,predicate,string,field,predicate,field,filter,apply,index,if,is,all,types,index,map,builder,put,index,filter,fields,index,meta,data,get,mappings,field,predicate,else,immutable,open,map,builder,string,mapping,meta,data,filtered,mappings,immutable,open,map,builder,for,object,object,cursor,string,mapping,meta,data,cursor,index,meta,data,get,mappings,if,regex,simple,match,types,cursor,key,filtered,mappings,put,cursor,key,filter,fields,cursor,value,field,predicate,if,filtered,mappings,is,empty,index,map,builder,put,index,filtered,mappings,build,return,index,map,builder,build
MetaData -> public ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> findMappings(String[] concreteIndices,                                                                                             final String[] types,                                                                                             Function<String, Predicate<String>> fieldFilter)             throws IOException;1532353780;Finds all mappings for types and concrete indices. Types are expanded to include all types that match the glob_patterns in the types array. Empty types array, null or {"_all"} will be expanded to all types available for_the given indices. Only fields that match the provided field filter will be returned (default is a predicate_that always returns true, which can be overridden via plugins)__@see MapperPlugin#getFieldFilter();public ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> findMappings(String[] concreteIndices,_                                                                                            final String[] types,_                                                                                            Function<String, Predicate<String>> fieldFilter)_            throws IOException {_        assert types != null__        assert concreteIndices != null__        if (concreteIndices.length == 0) {_            return ImmutableOpenMap.of()__        }__        boolean isAllTypes = isAllTypes(types)__        ImmutableOpenMap.Builder<String, ImmutableOpenMap<String, MappingMetaData>> indexMapBuilder = ImmutableOpenMap.builder()__        Iterable<String> intersection = HppcMaps.intersection(ObjectHashSet.from(concreteIndices), indices.keys())__        for (String index : intersection) {_            IndexMetaData indexMetaData = indices.get(index)__            Predicate<String> fieldPredicate = fieldFilter.apply(index)__            if (isAllTypes) {_                indexMapBuilder.put(index, filterFields(indexMetaData.getMappings(), fieldPredicate))__            } else {_                ImmutableOpenMap.Builder<String, MappingMetaData> filteredMappings = ImmutableOpenMap.builder()__                for (ObjectObjectCursor<String, MappingMetaData> cursor : indexMetaData.getMappings()) {_                    if (Regex.simpleMatch(types, cursor.key)) {_                        filteredMappings.put(cursor.key, filterFields(cursor.value, fieldPredicate))__                    }_                }_                if (!filteredMappings.isEmpty()) {_                    indexMapBuilder.put(index, filteredMappings.build())__                }_            }_        }_        return indexMapBuilder.build()__    };finds,all,mappings,for,types,and,concrete,indices,types,are,expanded,to,include,all,types,that,match,the,glob,patterns,in,the,types,array,empty,types,array,null,or,will,be,expanded,to,all,types,available,for,the,given,indices,only,fields,that,match,the,provided,field,filter,will,be,returned,default,is,a,predicate,that,always,returns,true,which,can,be,overridden,via,plugins,see,mapper,plugin,get,field,filter;public,immutable,open,map,string,immutable,open,map,string,mapping,meta,data,find,mappings,string,concrete,indices,final,string,types,function,string,predicate,string,field,filter,throws,ioexception,assert,types,null,assert,concrete,indices,null,if,concrete,indices,length,0,return,immutable,open,map,of,boolean,is,all,types,is,all,types,types,immutable,open,map,builder,string,immutable,open,map,string,mapping,meta,data,index,map,builder,immutable,open,map,builder,iterable,string,intersection,hppc,maps,intersection,object,hash,set,from,concrete,indices,indices,keys,for,string,index,intersection,index,meta,data,index,meta,data,indices,get,index,predicate,string,field,predicate,field,filter,apply,index,if,is,all,types,index,map,builder,put,index,filter,fields,index,meta,data,get,mappings,field,predicate,else,immutable,open,map,builder,string,mapping,meta,data,filtered,mappings,immutable,open,map,builder,for,object,object,cursor,string,mapping,meta,data,cursor,index,meta,data,get,mappings,if,regex,simple,match,types,cursor,key,filtered,mappings,put,cursor,key,filter,fields,cursor,value,field,predicate,if,filtered,mappings,is,empty,index,map,builder,put,index,filtered,mappings,build,return,index,map,builder,build
MetaData -> public ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> findMappings(String[] concreteIndices,                                                                                             final String[] types,                                                                                             Function<String, Predicate<String>> fieldFilter)             throws IOException;1536611444;Finds all mappings for types and concrete indices. Types are expanded to include all types that match the glob_patterns in the types array. Empty types array, null or {"_all"} will be expanded to all types available for_the given indices. Only fields that match the provided field filter will be returned (default is a predicate_that always returns true, which can be overridden via plugins)__@see MapperPlugin#getFieldFilter();public ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> findMappings(String[] concreteIndices,_                                                                                            final String[] types,_                                                                                            Function<String, Predicate<String>> fieldFilter)_            throws IOException {_        assert types != null__        assert concreteIndices != null__        if (concreteIndices.length == 0) {_            return ImmutableOpenMap.of()__        }__        boolean isAllTypes = isAllTypes(types)__        ImmutableOpenMap.Builder<String, ImmutableOpenMap<String, MappingMetaData>> indexMapBuilder = ImmutableOpenMap.builder()__        Iterable<String> intersection = HppcMaps.intersection(ObjectHashSet.from(concreteIndices), indices.keys())__        for (String index : intersection) {_            IndexMetaData indexMetaData = indices.get(index)__            Predicate<String> fieldPredicate = fieldFilter.apply(index)__            if (isAllTypes) {_                indexMapBuilder.put(index, filterFields(indexMetaData.getMappings(), fieldPredicate))__            } else {_                ImmutableOpenMap.Builder<String, MappingMetaData> filteredMappings = ImmutableOpenMap.builder()__                for (ObjectObjectCursor<String, MappingMetaData> cursor : indexMetaData.getMappings()) {_                    if (Regex.simpleMatch(types, cursor.key)) {_                        filteredMappings.put(cursor.key, filterFields(cursor.value, fieldPredicate))__                    }_                }_                if (!filteredMappings.isEmpty()) {_                    indexMapBuilder.put(index, filteredMappings.build())__                }_            }_        }_        return indexMapBuilder.build()__    };finds,all,mappings,for,types,and,concrete,indices,types,are,expanded,to,include,all,types,that,match,the,glob,patterns,in,the,types,array,empty,types,array,null,or,will,be,expanded,to,all,types,available,for,the,given,indices,only,fields,that,match,the,provided,field,filter,will,be,returned,default,is,a,predicate,that,always,returns,true,which,can,be,overridden,via,plugins,see,mapper,plugin,get,field,filter;public,immutable,open,map,string,immutable,open,map,string,mapping,meta,data,find,mappings,string,concrete,indices,final,string,types,function,string,predicate,string,field,filter,throws,ioexception,assert,types,null,assert,concrete,indices,null,if,concrete,indices,length,0,return,immutable,open,map,of,boolean,is,all,types,is,all,types,types,immutable,open,map,builder,string,immutable,open,map,string,mapping,meta,data,index,map,builder,immutable,open,map,builder,iterable,string,intersection,hppc,maps,intersection,object,hash,set,from,concrete,indices,indices,keys,for,string,index,intersection,index,meta,data,index,meta,data,indices,get,index,predicate,string,field,predicate,field,filter,apply,index,if,is,all,types,index,map,builder,put,index,filter,fields,index,meta,data,get,mappings,field,predicate,else,immutable,open,map,builder,string,mapping,meta,data,filtered,mappings,immutable,open,map,builder,for,object,object,cursor,string,mapping,meta,data,cursor,index,meta,data,get,mappings,if,regex,simple,match,types,cursor,key,filtered,mappings,put,cursor,key,filter,fields,cursor,value,field,predicate,if,filtered,mappings,is,empty,index,map,builder,put,index,filtered,mappings,build,return,index,map,builder,build
MetaData -> public ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> findMappings(String[] concreteIndices,                                                                                             final String[] types,                                                                                             Function<String, Predicate<String>> fieldFilter)             throws IOException;1539723533;Finds all mappings for types and concrete indices. Types are expanded to include all types that match the glob_patterns in the types array. Empty types array, null or {"_all"} will be expanded to all types available for_the given indices. Only fields that match the provided field filter will be returned (default is a predicate_that always returns true, which can be overridden via plugins)__@see MapperPlugin#getFieldFilter();public ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> findMappings(String[] concreteIndices,_                                                                                            final String[] types,_                                                                                            Function<String, Predicate<String>> fieldFilter)_            throws IOException {_        assert types != null__        assert concreteIndices != null__        if (concreteIndices.length == 0) {_            return ImmutableOpenMap.of()__        }__        boolean isAllTypes = isAllTypes(types)__        ImmutableOpenMap.Builder<String, ImmutableOpenMap<String, MappingMetaData>> indexMapBuilder = ImmutableOpenMap.builder()__        Iterable<String> intersection = HppcMaps.intersection(ObjectHashSet.from(concreteIndices), indices.keys())__        for (String index : intersection) {_            IndexMetaData indexMetaData = indices.get(index)__            Predicate<String> fieldPredicate = fieldFilter.apply(index)__            if (isAllTypes) {_                indexMapBuilder.put(index, filterFields(indexMetaData.getMappings(), fieldPredicate))__            } else {_                ImmutableOpenMap.Builder<String, MappingMetaData> filteredMappings = ImmutableOpenMap.builder()__                for (ObjectObjectCursor<String, MappingMetaData> cursor : indexMetaData.getMappings()) {_                    if (Regex.simpleMatch(types, cursor.key)) {_                        filteredMappings.put(cursor.key, filterFields(cursor.value, fieldPredicate))__                    }_                }_                if (!filteredMappings.isEmpty()) {_                    indexMapBuilder.put(index, filteredMappings.build())__                }_            }_        }_        return indexMapBuilder.build()__    };finds,all,mappings,for,types,and,concrete,indices,types,are,expanded,to,include,all,types,that,match,the,glob,patterns,in,the,types,array,empty,types,array,null,or,will,be,expanded,to,all,types,available,for,the,given,indices,only,fields,that,match,the,provided,field,filter,will,be,returned,default,is,a,predicate,that,always,returns,true,which,can,be,overridden,via,plugins,see,mapper,plugin,get,field,filter;public,immutable,open,map,string,immutable,open,map,string,mapping,meta,data,find,mappings,string,concrete,indices,final,string,types,function,string,predicate,string,field,filter,throws,ioexception,assert,types,null,assert,concrete,indices,null,if,concrete,indices,length,0,return,immutable,open,map,of,boolean,is,all,types,is,all,types,types,immutable,open,map,builder,string,immutable,open,map,string,mapping,meta,data,index,map,builder,immutable,open,map,builder,iterable,string,intersection,hppc,maps,intersection,object,hash,set,from,concrete,indices,indices,keys,for,string,index,intersection,index,meta,data,index,meta,data,indices,get,index,predicate,string,field,predicate,field,filter,apply,index,if,is,all,types,index,map,builder,put,index,filter,fields,index,meta,data,get,mappings,field,predicate,else,immutable,open,map,builder,string,mapping,meta,data,filtered,mappings,immutable,open,map,builder,for,object,object,cursor,string,mapping,meta,data,cursor,index,meta,data,get,mappings,if,regex,simple,match,types,cursor,key,filtered,mappings,put,cursor,key,filter,fields,cursor,value,field,predicate,if,filtered,mappings,is,empty,index,map,builder,put,index,filtered,mappings,build,return,index,map,builder,build
MetaData -> public ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> findMappings(String[] concreteIndices,                                                                                             final String[] types,                                                                                             Function<String, Predicate<String>> fieldFilter)             throws IOException;1540313026;Finds all mappings for types and concrete indices. Types are expanded to include all types that match the glob_patterns in the types array. Empty types array, null or {"_all"} will be expanded to all types available for_the given indices. Only fields that match the provided field filter will be returned (default is a predicate_that always returns true, which can be overridden via plugins)__@see MapperPlugin#getFieldFilter();public ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> findMappings(String[] concreteIndices,_                                                                                            final String[] types,_                                                                                            Function<String, Predicate<String>> fieldFilter)_            throws IOException {_        assert types != null__        assert concreteIndices != null__        if (concreteIndices.length == 0) {_            return ImmutableOpenMap.of()__        }__        boolean isAllTypes = isAllTypes(types)__        ImmutableOpenMap.Builder<String, ImmutableOpenMap<String, MappingMetaData>> indexMapBuilder = ImmutableOpenMap.builder()__        Iterable<String> intersection = HppcMaps.intersection(ObjectHashSet.from(concreteIndices), indices.keys())__        for (String index : intersection) {_            IndexMetaData indexMetaData = indices.get(index)__            Predicate<String> fieldPredicate = fieldFilter.apply(index)__            if (isAllTypes) {_                indexMapBuilder.put(index, filterFields(indexMetaData.getMappings(), fieldPredicate))__            } else {_                ImmutableOpenMap.Builder<String, MappingMetaData> filteredMappings = ImmutableOpenMap.builder()__                for (ObjectObjectCursor<String, MappingMetaData> cursor : indexMetaData.getMappings()) {_                    if (Regex.simpleMatch(types, cursor.key)) {_                        filteredMappings.put(cursor.key, filterFields(cursor.value, fieldPredicate))__                    }_                }_                if (!filteredMappings.isEmpty()) {_                    indexMapBuilder.put(index, filteredMappings.build())__                }_            }_        }_        return indexMapBuilder.build()__    };finds,all,mappings,for,types,and,concrete,indices,types,are,expanded,to,include,all,types,that,match,the,glob,patterns,in,the,types,array,empty,types,array,null,or,will,be,expanded,to,all,types,available,for,the,given,indices,only,fields,that,match,the,provided,field,filter,will,be,returned,default,is,a,predicate,that,always,returns,true,which,can,be,overridden,via,plugins,see,mapper,plugin,get,field,filter;public,immutable,open,map,string,immutable,open,map,string,mapping,meta,data,find,mappings,string,concrete,indices,final,string,types,function,string,predicate,string,field,filter,throws,ioexception,assert,types,null,assert,concrete,indices,null,if,concrete,indices,length,0,return,immutable,open,map,of,boolean,is,all,types,is,all,types,types,immutable,open,map,builder,string,immutable,open,map,string,mapping,meta,data,index,map,builder,immutable,open,map,builder,iterable,string,intersection,hppc,maps,intersection,object,hash,set,from,concrete,indices,indices,keys,for,string,index,intersection,index,meta,data,index,meta,data,indices,get,index,predicate,string,field,predicate,field,filter,apply,index,if,is,all,types,index,map,builder,put,index,filter,fields,index,meta,data,get,mappings,field,predicate,else,immutable,open,map,builder,string,mapping,meta,data,filtered,mappings,immutable,open,map,builder,for,object,object,cursor,string,mapping,meta,data,cursor,index,meta,data,get,mappings,if,regex,simple,match,types,cursor,key,filtered,mappings,put,cursor,key,filter,fields,cursor,value,field,predicate,if,filtered,mappings,is,empty,index,map,builder,put,index,filtered,mappings,build,return,index,map,builder,build
MetaData -> public ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> findMappings(String[] concreteIndices,                                                                                             final String[] types,                                                                                             Function<String, Predicate<String>> fieldFilter)             throws IOException;1540486836;Finds all mappings for types and concrete indices. Types are expanded to include all types that match the glob_patterns in the types array. Empty types array, null or {"_all"} will be expanded to all types available for_the given indices. Only fields that match the provided field filter will be returned (default is a predicate_that always returns true, which can be overridden via plugins)__@see MapperPlugin#getFieldFilter();public ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> findMappings(String[] concreteIndices,_                                                                                            final String[] types,_                                                                                            Function<String, Predicate<String>> fieldFilter)_            throws IOException {_        assert types != null__        assert concreteIndices != null__        if (concreteIndices.length == 0) {_            return ImmutableOpenMap.of()__        }__        boolean isAllTypes = isAllTypes(types)__        ImmutableOpenMap.Builder<String, ImmutableOpenMap<String, MappingMetaData>> indexMapBuilder = ImmutableOpenMap.builder()__        Iterable<String> intersection = HppcMaps.intersection(ObjectHashSet.from(concreteIndices), indices.keys())__        for (String index : intersection) {_            IndexMetaData indexMetaData = indices.get(index)__            Predicate<String> fieldPredicate = fieldFilter.apply(index)__            if (isAllTypes) {_                indexMapBuilder.put(index, filterFields(indexMetaData.getMappings(), fieldPredicate))__            } else {_                ImmutableOpenMap.Builder<String, MappingMetaData> filteredMappings = ImmutableOpenMap.builder()__                for (ObjectObjectCursor<String, MappingMetaData> cursor : indexMetaData.getMappings()) {_                    if (Regex.simpleMatch(types, cursor.key)) {_                        filteredMappings.put(cursor.key, filterFields(cursor.value, fieldPredicate))__                    }_                }_                if (!filteredMappings.isEmpty()) {_                    indexMapBuilder.put(index, filteredMappings.build())__                }_            }_        }_        return indexMapBuilder.build()__    };finds,all,mappings,for,types,and,concrete,indices,types,are,expanded,to,include,all,types,that,match,the,glob,patterns,in,the,types,array,empty,types,array,null,or,will,be,expanded,to,all,types,available,for,the,given,indices,only,fields,that,match,the,provided,field,filter,will,be,returned,default,is,a,predicate,that,always,returns,true,which,can,be,overridden,via,plugins,see,mapper,plugin,get,field,filter;public,immutable,open,map,string,immutable,open,map,string,mapping,meta,data,find,mappings,string,concrete,indices,final,string,types,function,string,predicate,string,field,filter,throws,ioexception,assert,types,null,assert,concrete,indices,null,if,concrete,indices,length,0,return,immutable,open,map,of,boolean,is,all,types,is,all,types,types,immutable,open,map,builder,string,immutable,open,map,string,mapping,meta,data,index,map,builder,immutable,open,map,builder,iterable,string,intersection,hppc,maps,intersection,object,hash,set,from,concrete,indices,indices,keys,for,string,index,intersection,index,meta,data,index,meta,data,indices,get,index,predicate,string,field,predicate,field,filter,apply,index,if,is,all,types,index,map,builder,put,index,filter,fields,index,meta,data,get,mappings,field,predicate,else,immutable,open,map,builder,string,mapping,meta,data,filtered,mappings,immutable,open,map,builder,for,object,object,cursor,string,mapping,meta,data,cursor,index,meta,data,get,mappings,if,regex,simple,match,types,cursor,key,filtered,mappings,put,cursor,key,filter,fields,cursor,value,field,predicate,if,filtered,mappings,is,empty,index,map,builder,put,index,filtered,mappings,build,return,index,map,builder,build
MetaData -> public ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> findMappings(String[] concreteIndices,                                                                                             final String[] types,                                                                                             Function<String, Predicate<String>> fieldFilter)             throws IOException;1540847035;Finds all mappings for types and concrete indices. Types are expanded to include all types that match the glob_patterns in the types array. Empty types array, null or {"_all"} will be expanded to all types available for_the given indices. Only fields that match the provided field filter will be returned (default is a predicate_that always returns true, which can be overridden via plugins)__@see MapperPlugin#getFieldFilter();public ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> findMappings(String[] concreteIndices,_                                                                                            final String[] types,_                                                                                            Function<String, Predicate<String>> fieldFilter)_            throws IOException {_        assert types != null__        assert concreteIndices != null__        if (concreteIndices.length == 0) {_            return ImmutableOpenMap.of()__        }__        boolean isAllTypes = isAllTypes(types)__        ImmutableOpenMap.Builder<String, ImmutableOpenMap<String, MappingMetaData>> indexMapBuilder = ImmutableOpenMap.builder()__        Iterable<String> intersection = HppcMaps.intersection(ObjectHashSet.from(concreteIndices), indices.keys())__        for (String index : intersection) {_            IndexMetaData indexMetaData = indices.get(index)__            Predicate<String> fieldPredicate = fieldFilter.apply(index)__            if (isAllTypes) {_                indexMapBuilder.put(index, filterFields(indexMetaData.getMappings(), fieldPredicate))__            } else {_                ImmutableOpenMap.Builder<String, MappingMetaData> filteredMappings = ImmutableOpenMap.builder()__                for (ObjectObjectCursor<String, MappingMetaData> cursor : indexMetaData.getMappings()) {_                    if (Regex.simpleMatch(types, cursor.key)) {_                        filteredMappings.put(cursor.key, filterFields(cursor.value, fieldPredicate))__                    }_                }_                if (!filteredMappings.isEmpty()) {_                    indexMapBuilder.put(index, filteredMappings.build())__                }_            }_        }_        return indexMapBuilder.build()__    };finds,all,mappings,for,types,and,concrete,indices,types,are,expanded,to,include,all,types,that,match,the,glob,patterns,in,the,types,array,empty,types,array,null,or,will,be,expanded,to,all,types,available,for,the,given,indices,only,fields,that,match,the,provided,field,filter,will,be,returned,default,is,a,predicate,that,always,returns,true,which,can,be,overridden,via,plugins,see,mapper,plugin,get,field,filter;public,immutable,open,map,string,immutable,open,map,string,mapping,meta,data,find,mappings,string,concrete,indices,final,string,types,function,string,predicate,string,field,filter,throws,ioexception,assert,types,null,assert,concrete,indices,null,if,concrete,indices,length,0,return,immutable,open,map,of,boolean,is,all,types,is,all,types,types,immutable,open,map,builder,string,immutable,open,map,string,mapping,meta,data,index,map,builder,immutable,open,map,builder,iterable,string,intersection,hppc,maps,intersection,object,hash,set,from,concrete,indices,indices,keys,for,string,index,intersection,index,meta,data,index,meta,data,indices,get,index,predicate,string,field,predicate,field,filter,apply,index,if,is,all,types,index,map,builder,put,index,filter,fields,index,meta,data,get,mappings,field,predicate,else,immutable,open,map,builder,string,mapping,meta,data,filtered,mappings,immutable,open,map,builder,for,object,object,cursor,string,mapping,meta,data,cursor,index,meta,data,get,mappings,if,regex,simple,match,types,cursor,key,filtered,mappings,put,cursor,key,filter,fields,cursor,value,field,predicate,if,filtered,mappings,is,empty,index,map,builder,put,index,filtered,mappings,build,return,index,map,builder,build
MetaData -> public ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> findMappings(String[] concreteIndices,                                                                                             final String[] types,                                                                                             Function<String, Predicate<String>> fieldFilter)             throws IOException;1543947737;Finds all mappings for types and concrete indices. Types are expanded to include all types that match the glob_patterns in the types array. Empty types array, null or {"_all"} will be expanded to all types available for_the given indices. Only fields that match the provided field filter will be returned (default is a predicate_that always returns true, which can be overridden via plugins)__@see MapperPlugin#getFieldFilter();public ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> findMappings(String[] concreteIndices,_                                                                                            final String[] types,_                                                                                            Function<String, Predicate<String>> fieldFilter)_            throws IOException {_        assert types != null__        assert concreteIndices != null__        if (concreteIndices.length == 0) {_            return ImmutableOpenMap.of()__        }__        boolean isAllTypes = isAllTypes(types)__        ImmutableOpenMap.Builder<String, ImmutableOpenMap<String, MappingMetaData>> indexMapBuilder = ImmutableOpenMap.builder()__        Iterable<String> intersection = HppcMaps.intersection(ObjectHashSet.from(concreteIndices), indices.keys())__        for (String index : intersection) {_            IndexMetaData indexMetaData = indices.get(index)__            Predicate<String> fieldPredicate = fieldFilter.apply(index)__            if (isAllTypes) {_                indexMapBuilder.put(index, filterFields(indexMetaData.getMappings(), fieldPredicate))__            } else {_                ImmutableOpenMap.Builder<String, MappingMetaData> filteredMappings = ImmutableOpenMap.builder()__                for (ObjectObjectCursor<String, MappingMetaData> cursor : indexMetaData.getMappings()) {_                    if (Regex.simpleMatch(types, cursor.key)) {_                        filteredMappings.put(cursor.key, filterFields(cursor.value, fieldPredicate))__                    }_                }_                if (!filteredMappings.isEmpty()) {_                    indexMapBuilder.put(index, filteredMappings.build())__                }_            }_        }_        return indexMapBuilder.build()__    };finds,all,mappings,for,types,and,concrete,indices,types,are,expanded,to,include,all,types,that,match,the,glob,patterns,in,the,types,array,empty,types,array,null,or,will,be,expanded,to,all,types,available,for,the,given,indices,only,fields,that,match,the,provided,field,filter,will,be,returned,default,is,a,predicate,that,always,returns,true,which,can,be,overridden,via,plugins,see,mapper,plugin,get,field,filter;public,immutable,open,map,string,immutable,open,map,string,mapping,meta,data,find,mappings,string,concrete,indices,final,string,types,function,string,predicate,string,field,filter,throws,ioexception,assert,types,null,assert,concrete,indices,null,if,concrete,indices,length,0,return,immutable,open,map,of,boolean,is,all,types,is,all,types,types,immutable,open,map,builder,string,immutable,open,map,string,mapping,meta,data,index,map,builder,immutable,open,map,builder,iterable,string,intersection,hppc,maps,intersection,object,hash,set,from,concrete,indices,indices,keys,for,string,index,intersection,index,meta,data,index,meta,data,indices,get,index,predicate,string,field,predicate,field,filter,apply,index,if,is,all,types,index,map,builder,put,index,filter,fields,index,meta,data,get,mappings,field,predicate,else,immutable,open,map,builder,string,mapping,meta,data,filtered,mappings,immutable,open,map,builder,for,object,object,cursor,string,mapping,meta,data,cursor,index,meta,data,get,mappings,if,regex,simple,match,types,cursor,key,filtered,mappings,put,cursor,key,filter,fields,cursor,value,field,predicate,if,filtered,mappings,is,empty,index,map,builder,put,index,filtered,mappings,build,return,index,map,builder,build
MetaData -> public ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> findMappings(String[] concreteIndices,                                                                                             final String[] types,                                                                                             Function<String, Predicate<String>> fieldFilter)             throws IOException;1544081506;Finds all mappings for types and concrete indices. Types are expanded to include all types that match the glob_patterns in the types array. Empty types array, null or {"_all"} will be expanded to all types available for_the given indices. Only fields that match the provided field filter will be returned (default is a predicate_that always returns true, which can be overridden via plugins)__@see MapperPlugin#getFieldFilter();public ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> findMappings(String[] concreteIndices,_                                                                                            final String[] types,_                                                                                            Function<String, Predicate<String>> fieldFilter)_            throws IOException {_        assert types != null__        assert concreteIndices != null__        if (concreteIndices.length == 0) {_            return ImmutableOpenMap.of()__        }__        boolean isAllTypes = isAllTypes(types)__        ImmutableOpenMap.Builder<String, ImmutableOpenMap<String, MappingMetaData>> indexMapBuilder = ImmutableOpenMap.builder()__        Iterable<String> intersection = HppcMaps.intersection(ObjectHashSet.from(concreteIndices), indices.keys())__        for (String index : intersection) {_            IndexMetaData indexMetaData = indices.get(index)__            Predicate<String> fieldPredicate = fieldFilter.apply(index)__            if (isAllTypes) {_                indexMapBuilder.put(index, filterFields(indexMetaData.getMappings(), fieldPredicate))__            } else {_                ImmutableOpenMap.Builder<String, MappingMetaData> filteredMappings = ImmutableOpenMap.builder()__                for (ObjectObjectCursor<String, MappingMetaData> cursor : indexMetaData.getMappings()) {_                    if (Regex.simpleMatch(types, cursor.key)) {_                        filteredMappings.put(cursor.key, filterFields(cursor.value, fieldPredicate))__                    }_                }_                if (!filteredMappings.isEmpty()) {_                    indexMapBuilder.put(index, filteredMappings.build())__                }_            }_        }_        return indexMapBuilder.build()__    };finds,all,mappings,for,types,and,concrete,indices,types,are,expanded,to,include,all,types,that,match,the,glob,patterns,in,the,types,array,empty,types,array,null,or,will,be,expanded,to,all,types,available,for,the,given,indices,only,fields,that,match,the,provided,field,filter,will,be,returned,default,is,a,predicate,that,always,returns,true,which,can,be,overridden,via,plugins,see,mapper,plugin,get,field,filter;public,immutable,open,map,string,immutable,open,map,string,mapping,meta,data,find,mappings,string,concrete,indices,final,string,types,function,string,predicate,string,field,filter,throws,ioexception,assert,types,null,assert,concrete,indices,null,if,concrete,indices,length,0,return,immutable,open,map,of,boolean,is,all,types,is,all,types,types,immutable,open,map,builder,string,immutable,open,map,string,mapping,meta,data,index,map,builder,immutable,open,map,builder,iterable,string,intersection,hppc,maps,intersection,object,hash,set,from,concrete,indices,indices,keys,for,string,index,intersection,index,meta,data,index,meta,data,indices,get,index,predicate,string,field,predicate,field,filter,apply,index,if,is,all,types,index,map,builder,put,index,filter,fields,index,meta,data,get,mappings,field,predicate,else,immutable,open,map,builder,string,mapping,meta,data,filtered,mappings,immutable,open,map,builder,for,object,object,cursor,string,mapping,meta,data,cursor,index,meta,data,get,mappings,if,regex,simple,match,types,cursor,key,filtered,mappings,put,cursor,key,filter,fields,cursor,value,field,predicate,if,filtered,mappings,is,empty,index,map,builder,put,index,filtered,mappings,build,return,index,map,builder,build
MetaData -> public ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> findMappings(String[] concreteIndices,                                                                                             final String[] types,                                                                                             Function<String, Predicate<String>> fieldFilter)             throws IOException;1544702062;Finds all mappings for types and concrete indices. Types are expanded to include all types that match the glob_patterns in the types array. Empty types array, null or {"_all"} will be expanded to all types available for_the given indices. Only fields that match the provided field filter will be returned (default is a predicate_that always returns true, which can be overridden via plugins)__@see MapperPlugin#getFieldFilter();public ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> findMappings(String[] concreteIndices,_                                                                                            final String[] types,_                                                                                            Function<String, Predicate<String>> fieldFilter)_            throws IOException {_        assert types != null__        assert concreteIndices != null__        if (concreteIndices.length == 0) {_            return ImmutableOpenMap.of()__        }__        boolean isAllTypes = isAllTypes(types)__        ImmutableOpenMap.Builder<String, ImmutableOpenMap<String, MappingMetaData>> indexMapBuilder = ImmutableOpenMap.builder()__        Iterable<String> intersection = HppcMaps.intersection(ObjectHashSet.from(concreteIndices), indices.keys())__        for (String index : intersection) {_            IndexMetaData indexMetaData = indices.get(index)__            Predicate<String> fieldPredicate = fieldFilter.apply(index)__            if (isAllTypes) {_                indexMapBuilder.put(index, filterFields(indexMetaData.getMappings(), fieldPredicate))__            } else {_                ImmutableOpenMap.Builder<String, MappingMetaData> filteredMappings = ImmutableOpenMap.builder()__                for (ObjectObjectCursor<String, MappingMetaData> cursor : indexMetaData.getMappings()) {_                    if (Regex.simpleMatch(types, cursor.key)) {_                        filteredMappings.put(cursor.key, filterFields(cursor.value, fieldPredicate))__                    }_                }_                if (!filteredMappings.isEmpty()) {_                    indexMapBuilder.put(index, filteredMappings.build())__                }_            }_        }_        return indexMapBuilder.build()__    };finds,all,mappings,for,types,and,concrete,indices,types,are,expanded,to,include,all,types,that,match,the,glob,patterns,in,the,types,array,empty,types,array,null,or,will,be,expanded,to,all,types,available,for,the,given,indices,only,fields,that,match,the,provided,field,filter,will,be,returned,default,is,a,predicate,that,always,returns,true,which,can,be,overridden,via,plugins,see,mapper,plugin,get,field,filter;public,immutable,open,map,string,immutable,open,map,string,mapping,meta,data,find,mappings,string,concrete,indices,final,string,types,function,string,predicate,string,field,filter,throws,ioexception,assert,types,null,assert,concrete,indices,null,if,concrete,indices,length,0,return,immutable,open,map,of,boolean,is,all,types,is,all,types,types,immutable,open,map,builder,string,immutable,open,map,string,mapping,meta,data,index,map,builder,immutable,open,map,builder,iterable,string,intersection,hppc,maps,intersection,object,hash,set,from,concrete,indices,indices,keys,for,string,index,intersection,index,meta,data,index,meta,data,indices,get,index,predicate,string,field,predicate,field,filter,apply,index,if,is,all,types,index,map,builder,put,index,filter,fields,index,meta,data,get,mappings,field,predicate,else,immutable,open,map,builder,string,mapping,meta,data,filtered,mappings,immutable,open,map,builder,for,object,object,cursor,string,mapping,meta,data,cursor,index,meta,data,get,mappings,if,regex,simple,match,types,cursor,key,filtered,mappings,put,cursor,key,filter,fields,cursor,value,field,predicate,if,filtered,mappings,is,empty,index,map,builder,put,index,filtered,mappings,build,return,index,map,builder,build
MetaData -> public ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> findMappings(String[] concreteIndices,                                                                                             final String[] types,                                                                                             Function<String, Predicate<String>> fieldFilter)             throws IOException;1547500081;Finds all mappings for types and concrete indices. Types are expanded to include all types that match the glob_patterns in the types array. Empty types array, null or {"_all"} will be expanded to all types available for_the given indices. Only fields that match the provided field filter will be returned (default is a predicate_that always returns true, which can be overridden via plugins)__@see MapperPlugin#getFieldFilter();public ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> findMappings(String[] concreteIndices,_                                                                                            final String[] types,_                                                                                            Function<String, Predicate<String>> fieldFilter)_            throws IOException {_        assert types != null__        assert concreteIndices != null__        if (concreteIndices.length == 0) {_            return ImmutableOpenMap.of()__        }__        boolean isAllTypes = isAllTypes(types)__        ImmutableOpenMap.Builder<String, ImmutableOpenMap<String, MappingMetaData>> indexMapBuilder = ImmutableOpenMap.builder()__        Iterable<String> intersection = HppcMaps.intersection(ObjectHashSet.from(concreteIndices), indices.keys())__        for (String index : intersection) {_            IndexMetaData indexMetaData = indices.get(index)__            Predicate<String> fieldPredicate = fieldFilter.apply(index)__            if (isAllTypes) {_                indexMapBuilder.put(index, filterFields(indexMetaData.getMappings(), fieldPredicate))__            } else {_                ImmutableOpenMap.Builder<String, MappingMetaData> filteredMappings = ImmutableOpenMap.builder()__                for (ObjectObjectCursor<String, MappingMetaData> cursor : indexMetaData.getMappings()) {_                    if (Regex.simpleMatch(types, cursor.key)) {_                        filteredMappings.put(cursor.key, filterFields(cursor.value, fieldPredicate))__                    }_                }_                if (!filteredMappings.isEmpty()) {_                    indexMapBuilder.put(index, filteredMappings.build())__                }_            }_        }_        return indexMapBuilder.build()__    };finds,all,mappings,for,types,and,concrete,indices,types,are,expanded,to,include,all,types,that,match,the,glob,patterns,in,the,types,array,empty,types,array,null,or,will,be,expanded,to,all,types,available,for,the,given,indices,only,fields,that,match,the,provided,field,filter,will,be,returned,default,is,a,predicate,that,always,returns,true,which,can,be,overridden,via,plugins,see,mapper,plugin,get,field,filter;public,immutable,open,map,string,immutable,open,map,string,mapping,meta,data,find,mappings,string,concrete,indices,final,string,types,function,string,predicate,string,field,filter,throws,ioexception,assert,types,null,assert,concrete,indices,null,if,concrete,indices,length,0,return,immutable,open,map,of,boolean,is,all,types,is,all,types,types,immutable,open,map,builder,string,immutable,open,map,string,mapping,meta,data,index,map,builder,immutable,open,map,builder,iterable,string,intersection,hppc,maps,intersection,object,hash,set,from,concrete,indices,indices,keys,for,string,index,intersection,index,meta,data,index,meta,data,indices,get,index,predicate,string,field,predicate,field,filter,apply,index,if,is,all,types,index,map,builder,put,index,filter,fields,index,meta,data,get,mappings,field,predicate,else,immutable,open,map,builder,string,mapping,meta,data,filtered,mappings,immutable,open,map,builder,for,object,object,cursor,string,mapping,meta,data,cursor,index,meta,data,get,mappings,if,regex,simple,match,types,cursor,key,filtered,mappings,put,cursor,key,filter,fields,cursor,value,field,predicate,if,filtered,mappings,is,empty,index,map,builder,put,index,filtered,mappings,build,return,index,map,builder,build
MetaData -> public ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> findMappings(String[] concreteIndices,                                                                                             final String[] types,                                                                                             Function<String, Predicate<String>> fieldFilter)             throws IOException;1548772865;Finds all mappings for types and concrete indices. Types are expanded to include all types that match the glob_patterns in the types array. Empty types array, null or {"_all"} will be expanded to all types available for_the given indices. Only fields that match the provided field filter will be returned (default is a predicate_that always returns true, which can be overridden via plugins)__@see MapperPlugin#getFieldFilter();public ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> findMappings(String[] concreteIndices,_                                                                                            final String[] types,_                                                                                            Function<String, Predicate<String>> fieldFilter)_            throws IOException {_        assert types != null__        assert concreteIndices != null__        if (concreteIndices.length == 0) {_            return ImmutableOpenMap.of()__        }__        boolean isAllTypes = isAllTypes(types)__        ImmutableOpenMap.Builder<String, ImmutableOpenMap<String, MappingMetaData>> indexMapBuilder = ImmutableOpenMap.builder()__        Iterable<String> intersection = HppcMaps.intersection(ObjectHashSet.from(concreteIndices), indices.keys())__        for (String index : intersection) {_            IndexMetaData indexMetaData = indices.get(index)__            Predicate<String> fieldPredicate = fieldFilter.apply(index)__            if (isAllTypes) {_                indexMapBuilder.put(index, filterFields(indexMetaData.getMappings(), fieldPredicate))__            } else {_                ImmutableOpenMap.Builder<String, MappingMetaData> filteredMappings = ImmutableOpenMap.builder()__                for (ObjectObjectCursor<String, MappingMetaData> cursor : indexMetaData.getMappings()) {_                    if (Regex.simpleMatch(types, cursor.key)) {_                        filteredMappings.put(cursor.key, filterFields(cursor.value, fieldPredicate))__                    }_                }_                if (!filteredMappings.isEmpty()) {_                    indexMapBuilder.put(index, filteredMappings.build())__                }_            }_        }_        return indexMapBuilder.build()__    };finds,all,mappings,for,types,and,concrete,indices,types,are,expanded,to,include,all,types,that,match,the,glob,patterns,in,the,types,array,empty,types,array,null,or,will,be,expanded,to,all,types,available,for,the,given,indices,only,fields,that,match,the,provided,field,filter,will,be,returned,default,is,a,predicate,that,always,returns,true,which,can,be,overridden,via,plugins,see,mapper,plugin,get,field,filter;public,immutable,open,map,string,immutable,open,map,string,mapping,meta,data,find,mappings,string,concrete,indices,final,string,types,function,string,predicate,string,field,filter,throws,ioexception,assert,types,null,assert,concrete,indices,null,if,concrete,indices,length,0,return,immutable,open,map,of,boolean,is,all,types,is,all,types,types,immutable,open,map,builder,string,immutable,open,map,string,mapping,meta,data,index,map,builder,immutable,open,map,builder,iterable,string,intersection,hppc,maps,intersection,object,hash,set,from,concrete,indices,indices,keys,for,string,index,intersection,index,meta,data,index,meta,data,indices,get,index,predicate,string,field,predicate,field,filter,apply,index,if,is,all,types,index,map,builder,put,index,filter,fields,index,meta,data,get,mappings,field,predicate,else,immutable,open,map,builder,string,mapping,meta,data,filtered,mappings,immutable,open,map,builder,for,object,object,cursor,string,mapping,meta,data,cursor,index,meta,data,get,mappings,if,regex,simple,match,types,cursor,key,filtered,mappings,put,cursor,key,filter,fields,cursor,value,field,predicate,if,filtered,mappings,is,empty,index,map,builder,put,index,filtered,mappings,build,return,index,map,builder,build
MetaData -> public String[] getConcreteAllIndices();1524684173;Returns all the concrete indices.;public String[] getConcreteAllIndices() {_        return allIndices__    };returns,all,the,concrete,indices;public,string,get,concrete,all,indices,return,all,indices
MetaData -> public String[] getConcreteAllIndices();1527878678;Returns all the concrete indices.;public String[] getConcreteAllIndices() {_        return allIndices__    };returns,all,the,concrete,indices;public,string,get,concrete,all,indices,return,all,indices
MetaData -> public String[] getConcreteAllIndices();1528103657;Returns all the concrete indices.;public String[] getConcreteAllIndices() {_        return allIndices__    };returns,all,the,concrete,indices;public,string,get,concrete,all,indices,return,all,indices
MetaData -> public String[] getConcreteAllIndices();1529082965;Returns all the concrete indices.;public String[] getConcreteAllIndices() {_        return allIndices__    };returns,all,the,concrete,indices;public,string,get,concrete,all,indices,return,all,indices
MetaData -> public String[] getConcreteAllIndices();1531179852;Returns all the concrete indices.;public String[] getConcreteAllIndices() {_        return allIndices__    };returns,all,the,concrete,indices;public,string,get,concrete,all,indices,return,all,indices
MetaData -> public String[] getConcreteAllIndices();1532028790;Returns all the concrete indices.;public String[] getConcreteAllIndices() {_        return allIndices__    };returns,all,the,concrete,indices;public,string,get,concrete,all,indices,return,all,indices
MetaData -> public String[] getConcreteAllIndices();1532353780;Returns all the concrete indices.;public String[] getConcreteAllIndices() {_        return allIndices__    };returns,all,the,concrete,indices;public,string,get,concrete,all,indices,return,all,indices
MetaData -> public String[] getConcreteAllIndices();1536611444;Returns all the concrete indices.;public String[] getConcreteAllIndices() {_        return allIndices__    };returns,all,the,concrete,indices;public,string,get,concrete,all,indices,return,all,indices
MetaData -> public String[] getConcreteAllIndices();1539723533;Returns all the concrete indices.;public String[] getConcreteAllIndices() {_        return allIndices__    };returns,all,the,concrete,indices;public,string,get,concrete,all,indices,return,all,indices
MetaData -> public String[] getConcreteAllIndices();1540313026;Returns all the concrete indices.;public String[] getConcreteAllIndices() {_        return allIndices__    };returns,all,the,concrete,indices;public,string,get,concrete,all,indices,return,all,indices
MetaData -> public String[] getConcreteAllIndices();1540486836;Returns all the concrete indices.;public String[] getConcreteAllIndices() {_        return allIndices__    };returns,all,the,concrete,indices;public,string,get,concrete,all,indices,return,all,indices
MetaData -> public String[] getConcreteAllIndices();1540847035;Returns all the concrete indices.;public String[] getConcreteAllIndices() {_        return allIndices__    };returns,all,the,concrete,indices;public,string,get,concrete,all,indices,return,all,indices
MetaData -> public String[] getConcreteAllIndices();1543947737;Returns all the concrete indices.;public String[] getConcreteAllIndices() {_        return allIndices__    };returns,all,the,concrete,indices;public,string,get,concrete,all,indices,return,all,indices
MetaData -> public String[] getConcreteAllIndices();1544081506;Returns all the concrete indices.;public String[] getConcreteAllIndices() {_        return allIndices__    };returns,all,the,concrete,indices;public,string,get,concrete,all,indices,return,all,indices
MetaData -> public String[] getConcreteAllIndices();1544702062;Returns all the concrete indices.;public String[] getConcreteAllIndices() {_        return allIndices__    };returns,all,the,concrete,indices;public,string,get,concrete,all,indices,return,all,indices
MetaData -> public String[] getConcreteAllIndices();1547500081;Returns all the concrete indices.;public String[] getConcreteAllIndices() {_        return allIndices__    };returns,all,the,concrete,indices;public,string,get,concrete,all,indices,return,all,indices
MetaData -> public String[] getConcreteAllIndices();1548772865;Returns all the concrete indices.;public String[] getConcreteAllIndices() {_        return allIndices__    };returns,all,the,concrete,indices;public,string,get,concrete,all,indices,return,all,indices
MetaData -> private ImmutableOpenMap<String, List<AliasMetaData>> findAliases(String[] originalAliases, String[] aliases,                                                                       String[] concreteIndices);1532353780;Finds the specific index aliases that match with the specified aliases directly or partially via wildcards and_that point to the specified concrete indices or match partially with the indices via wildcards.__@param aliases The aliases to look for_@param originalAliases The original aliases that the user originally requested_@param concreteIndices The concrete indexes the index aliases must point to order to be returned._@return a map of index to a list of alias metadata, the list corresponding to a concrete index will be empty if no aliases are_present for that index;private ImmutableOpenMap<String, List<AliasMetaData>> findAliases(String[] originalAliases, String[] aliases,_                                                                      String[] concreteIndices) {_        assert aliases != null__        assert originalAliases != null__        assert concreteIndices != null__        if (concreteIndices.length == 0) {_            return ImmutableOpenMap.of()__        }__        _        if (originalAliases.length > 0 && aliases.length == 0) {_            return ImmutableOpenMap.of()__        }__        boolean matchAllAliases = matchAllAliases(aliases)__        ImmutableOpenMap.Builder<String, List<AliasMetaData>> mapBuilder = ImmutableOpenMap.builder()__        for (String index : concreteIndices) {_            IndexMetaData indexMetaData = indices.get(index)__            List<AliasMetaData> filteredValues = new ArrayList<>()__            for (ObjectCursor<AliasMetaData> cursor : indexMetaData.getAliases().values()) {_                AliasMetaData value = cursor.value__                if (matchAllAliases || Regex.simpleMatch(aliases, value.alias())) {_                    filteredValues.add(value)__                }_            }__            if (filteredValues.isEmpty() == false) {_                _                CollectionUtil.timSort(filteredValues, Comparator.comparing(AliasMetaData::alias))__                mapBuilder.put(index, Collections.unmodifiableList(filteredValues))__            }_        }_        return mapBuilder.build()__    };finds,the,specific,index,aliases,that,match,with,the,specified,aliases,directly,or,partially,via,wildcards,and,that,point,to,the,specified,concrete,indices,or,match,partially,with,the,indices,via,wildcards,param,aliases,the,aliases,to,look,for,param,original,aliases,the,original,aliases,that,the,user,originally,requested,param,concrete,indices,the,concrete,indexes,the,index,aliases,must,point,to,order,to,be,returned,return,a,map,of,index,to,a,list,of,alias,metadata,the,list,corresponding,to,a,concrete,index,will,be,empty,if,no,aliases,are,present,for,that,index;private,immutable,open,map,string,list,alias,meta,data,find,aliases,string,original,aliases,string,aliases,string,concrete,indices,assert,aliases,null,assert,original,aliases,null,assert,concrete,indices,null,if,concrete,indices,length,0,return,immutable,open,map,of,if,original,aliases,length,0,aliases,length,0,return,immutable,open,map,of,boolean,match,all,aliases,match,all,aliases,aliases,immutable,open,map,builder,string,list,alias,meta,data,map,builder,immutable,open,map,builder,for,string,index,concrete,indices,index,meta,data,index,meta,data,indices,get,index,list,alias,meta,data,filtered,values,new,array,list,for,object,cursor,alias,meta,data,cursor,index,meta,data,get,aliases,values,alias,meta,data,value,cursor,value,if,match,all,aliases,regex,simple,match,aliases,value,alias,filtered,values,add,value,if,filtered,values,is,empty,false,collection,util,tim,sort,filtered,values,comparator,comparing,alias,meta,data,alias,map,builder,put,index,collections,unmodifiable,list,filtered,values,return,map,builder,build
MetaData -> private ImmutableOpenMap<String, List<AliasMetaData>> findAliases(String[] originalAliases, String[] aliases,                                                                       String[] concreteIndices);1536611444;Finds the specific index aliases that match with the specified aliases directly or partially via wildcards and_that point to the specified concrete indices or match partially with the indices via wildcards.__@param aliases The aliases to look for_@param originalAliases The original aliases that the user originally requested_@param concreteIndices The concrete indexes the index aliases must point to order to be returned._@return a map of index to a list of alias metadata, the list corresponding to a concrete index will be empty if no aliases are_present for that index;private ImmutableOpenMap<String, List<AliasMetaData>> findAliases(String[] originalAliases, String[] aliases,_                                                                      String[] concreteIndices) {_        assert aliases != null__        assert originalAliases != null__        assert concreteIndices != null__        if (concreteIndices.length == 0) {_            return ImmutableOpenMap.of()__        }__        _        if (originalAliases.length > 0 && aliases.length == 0) {_            return ImmutableOpenMap.of()__        }__        String[] patterns = new String[aliases.length]__        boolean[] include = new boolean[aliases.length]__        for (int i = 0_ i < aliases.length_ i++) {_            String alias = aliases[i]__            if (alias.charAt(0) == '-') {_                patterns[i] = alias.substring(1)__                include[i] = false__            } else {_                patterns[i] = alias__                include[i] = true__            }_        }_        boolean matchAllAliases = patterns.length == 0__        ImmutableOpenMap.Builder<String, List<AliasMetaData>> mapBuilder = ImmutableOpenMap.builder()__        for (String index : concreteIndices) {_            IndexMetaData indexMetaData = indices.get(index)__            List<AliasMetaData> filteredValues = new ArrayList<>()__            for (ObjectCursor<AliasMetaData> cursor : indexMetaData.getAliases().values()) {_                AliasMetaData value = cursor.value__                boolean matched = matchAllAliases__                String alias = value.alias()__                for (int i = 0_ i < patterns.length_ i++) {_                    if (include[i]) {_                        if (matched == false) {_                            String pattern = patterns[i]__                            matched = ALL.equals(pattern) || Regex.simpleMatch(pattern, alias)__                        }_                    } else if (matched) {_                        matched = Regex.simpleMatch(patterns[i], alias) == false__                    }_                }_                if (matched) {_                    filteredValues.add(value)__                }_            }__            if (filteredValues.isEmpty() == false) {_                _                CollectionUtil.timSort(filteredValues, Comparator.comparing(AliasMetaData::alias))__                mapBuilder.put(index, Collections.unmodifiableList(filteredValues))__            }_        }_        return mapBuilder.build()__    };finds,the,specific,index,aliases,that,match,with,the,specified,aliases,directly,or,partially,via,wildcards,and,that,point,to,the,specified,concrete,indices,or,match,partially,with,the,indices,via,wildcards,param,aliases,the,aliases,to,look,for,param,original,aliases,the,original,aliases,that,the,user,originally,requested,param,concrete,indices,the,concrete,indexes,the,index,aliases,must,point,to,order,to,be,returned,return,a,map,of,index,to,a,list,of,alias,metadata,the,list,corresponding,to,a,concrete,index,will,be,empty,if,no,aliases,are,present,for,that,index;private,immutable,open,map,string,list,alias,meta,data,find,aliases,string,original,aliases,string,aliases,string,concrete,indices,assert,aliases,null,assert,original,aliases,null,assert,concrete,indices,null,if,concrete,indices,length,0,return,immutable,open,map,of,if,original,aliases,length,0,aliases,length,0,return,immutable,open,map,of,string,patterns,new,string,aliases,length,boolean,include,new,boolean,aliases,length,for,int,i,0,i,aliases,length,i,string,alias,aliases,i,if,alias,char,at,0,patterns,i,alias,substring,1,include,i,false,else,patterns,i,alias,include,i,true,boolean,match,all,aliases,patterns,length,0,immutable,open,map,builder,string,list,alias,meta,data,map,builder,immutable,open,map,builder,for,string,index,concrete,indices,index,meta,data,index,meta,data,indices,get,index,list,alias,meta,data,filtered,values,new,array,list,for,object,cursor,alias,meta,data,cursor,index,meta,data,get,aliases,values,alias,meta,data,value,cursor,value,boolean,matched,match,all,aliases,string,alias,value,alias,for,int,i,0,i,patterns,length,i,if,include,i,if,matched,false,string,pattern,patterns,i,matched,all,equals,pattern,regex,simple,match,pattern,alias,else,if,matched,matched,regex,simple,match,patterns,i,alias,false,if,matched,filtered,values,add,value,if,filtered,values,is,empty,false,collection,util,tim,sort,filtered,values,comparator,comparing,alias,meta,data,alias,map,builder,put,index,collections,unmodifiable,list,filtered,values,return,map,builder,build
MetaData -> private ImmutableOpenMap<String, List<AliasMetaData>> findAliases(String[] originalAliases, String[] aliases,                                                                       String[] concreteIndices);1539723533;Finds the specific index aliases that match with the specified aliases directly or partially via wildcards and_that point to the specified concrete indices or match partially with the indices via wildcards.__@param aliases The aliases to look for_@param originalAliases The original aliases that the user originally requested_@param concreteIndices The concrete indexes the index aliases must point to order to be returned._@return a map of index to a list of alias metadata, the list corresponding to a concrete index will be empty if no aliases are_present for that index;private ImmutableOpenMap<String, List<AliasMetaData>> findAliases(String[] originalAliases, String[] aliases,_                                                                      String[] concreteIndices) {_        assert aliases != null__        assert originalAliases != null__        assert concreteIndices != null__        if (concreteIndices.length == 0) {_            return ImmutableOpenMap.of()__        }__        _        if (originalAliases.length > 0 && aliases.length == 0) {_            return ImmutableOpenMap.of()__        }__        String[] patterns = new String[aliases.length]__        boolean[] include = new boolean[aliases.length]__        for (int i = 0_ i < aliases.length_ i++) {_            String alias = aliases[i]__            if (alias.charAt(0) == '-') {_                patterns[i] = alias.substring(1)__                include[i] = false__            } else {_                patterns[i] = alias__                include[i] = true__            }_        }_        boolean matchAllAliases = patterns.length == 0__        ImmutableOpenMap.Builder<String, List<AliasMetaData>> mapBuilder = ImmutableOpenMap.builder()__        for (String index : concreteIndices) {_            IndexMetaData indexMetaData = indices.get(index)__            List<AliasMetaData> filteredValues = new ArrayList<>()__            for (ObjectCursor<AliasMetaData> cursor : indexMetaData.getAliases().values()) {_                AliasMetaData value = cursor.value__                boolean matched = matchAllAliases__                String alias = value.alias()__                for (int i = 0_ i < patterns.length_ i++) {_                    if (include[i]) {_                        if (matched == false) {_                            String pattern = patterns[i]__                            matched = ALL.equals(pattern) || Regex.simpleMatch(pattern, alias)__                        }_                    } else if (matched) {_                        matched = Regex.simpleMatch(patterns[i], alias) == false__                    }_                }_                if (matched) {_                    filteredValues.add(value)__                }_            }__            if (filteredValues.isEmpty() == false) {_                _                CollectionUtil.timSort(filteredValues, Comparator.comparing(AliasMetaData::alias))__                mapBuilder.put(index, Collections.unmodifiableList(filteredValues))__            }_        }_        return mapBuilder.build()__    };finds,the,specific,index,aliases,that,match,with,the,specified,aliases,directly,or,partially,via,wildcards,and,that,point,to,the,specified,concrete,indices,or,match,partially,with,the,indices,via,wildcards,param,aliases,the,aliases,to,look,for,param,original,aliases,the,original,aliases,that,the,user,originally,requested,param,concrete,indices,the,concrete,indexes,the,index,aliases,must,point,to,order,to,be,returned,return,a,map,of,index,to,a,list,of,alias,metadata,the,list,corresponding,to,a,concrete,index,will,be,empty,if,no,aliases,are,present,for,that,index;private,immutable,open,map,string,list,alias,meta,data,find,aliases,string,original,aliases,string,aliases,string,concrete,indices,assert,aliases,null,assert,original,aliases,null,assert,concrete,indices,null,if,concrete,indices,length,0,return,immutable,open,map,of,if,original,aliases,length,0,aliases,length,0,return,immutable,open,map,of,string,patterns,new,string,aliases,length,boolean,include,new,boolean,aliases,length,for,int,i,0,i,aliases,length,i,string,alias,aliases,i,if,alias,char,at,0,patterns,i,alias,substring,1,include,i,false,else,patterns,i,alias,include,i,true,boolean,match,all,aliases,patterns,length,0,immutable,open,map,builder,string,list,alias,meta,data,map,builder,immutable,open,map,builder,for,string,index,concrete,indices,index,meta,data,index,meta,data,indices,get,index,list,alias,meta,data,filtered,values,new,array,list,for,object,cursor,alias,meta,data,cursor,index,meta,data,get,aliases,values,alias,meta,data,value,cursor,value,boolean,matched,match,all,aliases,string,alias,value,alias,for,int,i,0,i,patterns,length,i,if,include,i,if,matched,false,string,pattern,patterns,i,matched,all,equals,pattern,regex,simple,match,pattern,alias,else,if,matched,matched,regex,simple,match,patterns,i,alias,false,if,matched,filtered,values,add,value,if,filtered,values,is,empty,false,collection,util,tim,sort,filtered,values,comparator,comparing,alias,meta,data,alias,map,builder,put,index,collections,unmodifiable,list,filtered,values,return,map,builder,build
MetaData -> public boolean routingRequired(String concreteIndex, String type);1524684173;@param concreteIndex The concrete index to check if routing is required_@param type          The type to check if routing is required_@return Whether routing is required according to the mapping for the specified index and type;public boolean routingRequired(String concreteIndex, String type) {_        IndexMetaData indexMetaData = indices.get(concreteIndex)__        if (indexMetaData != null) {_            MappingMetaData mappingMetaData = indexMetaData.getMappings().get(type)__            if (mappingMetaData != null) {_                return mappingMetaData.routing().required()__            }_        }_        return false__    };param,concrete,index,the,concrete,index,to,check,if,routing,is,required,param,type,the,type,to,check,if,routing,is,required,return,whether,routing,is,required,according,to,the,mapping,for,the,specified,index,and,type;public,boolean,routing,required,string,concrete,index,string,type,index,meta,data,index,meta,data,indices,get,concrete,index,if,index,meta,data,null,mapping,meta,data,mapping,meta,data,index,meta,data,get,mappings,get,type,if,mapping,meta,data,null,return,mapping,meta,data,routing,required,return,false
MetaData -> public boolean routingRequired(String concreteIndex, String type);1527878678;@param concreteIndex The concrete index to check if routing is required_@param type          The type to check if routing is required_@return Whether routing is required according to the mapping for the specified index and type;public boolean routingRequired(String concreteIndex, String type) {_        IndexMetaData indexMetaData = indices.get(concreteIndex)__        if (indexMetaData != null) {_            MappingMetaData mappingMetaData = indexMetaData.getMappings().get(type)__            if (mappingMetaData != null) {_                return mappingMetaData.routing().required()__            }_        }_        return false__    };param,concrete,index,the,concrete,index,to,check,if,routing,is,required,param,type,the,type,to,check,if,routing,is,required,return,whether,routing,is,required,according,to,the,mapping,for,the,specified,index,and,type;public,boolean,routing,required,string,concrete,index,string,type,index,meta,data,index,meta,data,indices,get,concrete,index,if,index,meta,data,null,mapping,meta,data,mapping,meta,data,index,meta,data,get,mappings,get,type,if,mapping,meta,data,null,return,mapping,meta,data,routing,required,return,false
MetaData -> public boolean routingRequired(String concreteIndex, String type);1528103657;@param concreteIndex The concrete index to check if routing is required_@param type          The type to check if routing is required_@return Whether routing is required according to the mapping for the specified index and type;public boolean routingRequired(String concreteIndex, String type) {_        IndexMetaData indexMetaData = indices.get(concreteIndex)__        if (indexMetaData != null) {_            MappingMetaData mappingMetaData = indexMetaData.getMappings().get(type)__            if (mappingMetaData != null) {_                return mappingMetaData.routing().required()__            }_        }_        return false__    };param,concrete,index,the,concrete,index,to,check,if,routing,is,required,param,type,the,type,to,check,if,routing,is,required,return,whether,routing,is,required,according,to,the,mapping,for,the,specified,index,and,type;public,boolean,routing,required,string,concrete,index,string,type,index,meta,data,index,meta,data,indices,get,concrete,index,if,index,meta,data,null,mapping,meta,data,mapping,meta,data,index,meta,data,get,mappings,get,type,if,mapping,meta,data,null,return,mapping,meta,data,routing,required,return,false
MetaData -> public boolean routingRequired(String concreteIndex, String type);1529082965;@param concreteIndex The concrete index to check if routing is required_@param type          The type to check if routing is required_@return Whether routing is required according to the mapping for the specified index and type;public boolean routingRequired(String concreteIndex, String type) {_        IndexMetaData indexMetaData = indices.get(concreteIndex)__        if (indexMetaData != null) {_            MappingMetaData mappingMetaData = indexMetaData.getMappings().get(type)__            if (mappingMetaData != null) {_                return mappingMetaData.routing().required()__            }_        }_        return false__    };param,concrete,index,the,concrete,index,to,check,if,routing,is,required,param,type,the,type,to,check,if,routing,is,required,return,whether,routing,is,required,according,to,the,mapping,for,the,specified,index,and,type;public,boolean,routing,required,string,concrete,index,string,type,index,meta,data,index,meta,data,indices,get,concrete,index,if,index,meta,data,null,mapping,meta,data,mapping,meta,data,index,meta,data,get,mappings,get,type,if,mapping,meta,data,null,return,mapping,meta,data,routing,required,return,false
MetaData -> public boolean routingRequired(String concreteIndex, String type);1531179852;@param concreteIndex The concrete index to check if routing is required_@param type          The type to check if routing is required_@return Whether routing is required according to the mapping for the specified index and type;public boolean routingRequired(String concreteIndex, String type) {_        IndexMetaData indexMetaData = indices.get(concreteIndex)__        if (indexMetaData != null) {_            MappingMetaData mappingMetaData = indexMetaData.getMappings().get(type)__            if (mappingMetaData != null) {_                return mappingMetaData.routing().required()__            }_        }_        return false__    };param,concrete,index,the,concrete,index,to,check,if,routing,is,required,param,type,the,type,to,check,if,routing,is,required,return,whether,routing,is,required,according,to,the,mapping,for,the,specified,index,and,type;public,boolean,routing,required,string,concrete,index,string,type,index,meta,data,index,meta,data,indices,get,concrete,index,if,index,meta,data,null,mapping,meta,data,mapping,meta,data,index,meta,data,get,mappings,get,type,if,mapping,meta,data,null,return,mapping,meta,data,routing,required,return,false
MetaData -> public boolean routingRequired(String concreteIndex, String type);1532028790;@param concreteIndex The concrete index to check if routing is required_@param type          The type to check if routing is required_@return Whether routing is required according to the mapping for the specified index and type;public boolean routingRequired(String concreteIndex, String type) {_        IndexMetaData indexMetaData = indices.get(concreteIndex)__        if (indexMetaData != null) {_            MappingMetaData mappingMetaData = indexMetaData.getMappings().get(type)__            if (mappingMetaData != null) {_                return mappingMetaData.routing().required()__            }_        }_        return false__    };param,concrete,index,the,concrete,index,to,check,if,routing,is,required,param,type,the,type,to,check,if,routing,is,required,return,whether,routing,is,required,according,to,the,mapping,for,the,specified,index,and,type;public,boolean,routing,required,string,concrete,index,string,type,index,meta,data,index,meta,data,indices,get,concrete,index,if,index,meta,data,null,mapping,meta,data,mapping,meta,data,index,meta,data,get,mappings,get,type,if,mapping,meta,data,null,return,mapping,meta,data,routing,required,return,false
MetaData -> public boolean routingRequired(String concreteIndex, String type);1532353780;@param concreteIndex The concrete index to check if routing is required_@param type          The type to check if routing is required_@return Whether routing is required according to the mapping for the specified index and type;public boolean routingRequired(String concreteIndex, String type) {_        IndexMetaData indexMetaData = indices.get(concreteIndex)__        if (indexMetaData != null) {_            MappingMetaData mappingMetaData = indexMetaData.getMappings().get(type)__            if (mappingMetaData != null) {_                return mappingMetaData.routing().required()__            }_        }_        return false__    };param,concrete,index,the,concrete,index,to,check,if,routing,is,required,param,type,the,type,to,check,if,routing,is,required,return,whether,routing,is,required,according,to,the,mapping,for,the,specified,index,and,type;public,boolean,routing,required,string,concrete,index,string,type,index,meta,data,index,meta,data,indices,get,concrete,index,if,index,meta,data,null,mapping,meta,data,mapping,meta,data,index,meta,data,get,mappings,get,type,if,mapping,meta,data,null,return,mapping,meta,data,routing,required,return,false
MetaData -> public boolean routingRequired(String concreteIndex, String type);1536611444;@param concreteIndex The concrete index to check if routing is required_@param type          The type to check if routing is required_@return Whether routing is required according to the mapping for the specified index and type;public boolean routingRequired(String concreteIndex, String type) {_        IndexMetaData indexMetaData = indices.get(concreteIndex)__        if (indexMetaData != null) {_            MappingMetaData mappingMetaData = indexMetaData.getMappings().get(type)__            if (mappingMetaData != null) {_                return mappingMetaData.routing().required()__            }_        }_        return false__    };param,concrete,index,the,concrete,index,to,check,if,routing,is,required,param,type,the,type,to,check,if,routing,is,required,return,whether,routing,is,required,according,to,the,mapping,for,the,specified,index,and,type;public,boolean,routing,required,string,concrete,index,string,type,index,meta,data,index,meta,data,indices,get,concrete,index,if,index,meta,data,null,mapping,meta,data,mapping,meta,data,index,meta,data,get,mappings,get,type,if,mapping,meta,data,null,return,mapping,meta,data,routing,required,return,false
MetaData -> public boolean routingRequired(String concreteIndex, String type);1539723533;@param concreteIndex The concrete index to check if routing is required_@param type          The type to check if routing is required_@return Whether routing is required according to the mapping for the specified index and type;public boolean routingRequired(String concreteIndex, String type) {_        IndexMetaData indexMetaData = indices.get(concreteIndex)__        if (indexMetaData != null) {_            MappingMetaData mappingMetaData = indexMetaData.getMappings().get(type)__            if (mappingMetaData != null) {_                return mappingMetaData.routing().required()__            }_        }_        return false__    };param,concrete,index,the,concrete,index,to,check,if,routing,is,required,param,type,the,type,to,check,if,routing,is,required,return,whether,routing,is,required,according,to,the,mapping,for,the,specified,index,and,type;public,boolean,routing,required,string,concrete,index,string,type,index,meta,data,index,meta,data,indices,get,concrete,index,if,index,meta,data,null,mapping,meta,data,mapping,meta,data,index,meta,data,get,mappings,get,type,if,mapping,meta,data,null,return,mapping,meta,data,routing,required,return,false
MetaData -> public boolean routingRequired(String concreteIndex, String type);1540313026;@param concreteIndex The concrete index to check if routing is required_@param type          The type to check if routing is required_@return Whether routing is required according to the mapping for the specified index and type;public boolean routingRequired(String concreteIndex, String type) {_        IndexMetaData indexMetaData = indices.get(concreteIndex)__        if (indexMetaData != null) {_            MappingMetaData mappingMetaData = indexMetaData.getMappings().get(type)__            if (mappingMetaData != null) {_                return mappingMetaData.routing().required()__            }_        }_        return false__    };param,concrete,index,the,concrete,index,to,check,if,routing,is,required,param,type,the,type,to,check,if,routing,is,required,return,whether,routing,is,required,according,to,the,mapping,for,the,specified,index,and,type;public,boolean,routing,required,string,concrete,index,string,type,index,meta,data,index,meta,data,indices,get,concrete,index,if,index,meta,data,null,mapping,meta,data,mapping,meta,data,index,meta,data,get,mappings,get,type,if,mapping,meta,data,null,return,mapping,meta,data,routing,required,return,false
MetaData -> public boolean routingRequired(String concreteIndex, String type);1540486836;@param concreteIndex The concrete index to check if routing is required_@param type          The type to check if routing is required_@return Whether routing is required according to the mapping for the specified index and type;public boolean routingRequired(String concreteIndex, String type) {_        IndexMetaData indexMetaData = indices.get(concreteIndex)__        if (indexMetaData != null) {_            MappingMetaData mappingMetaData = indexMetaData.getMappings().get(type)__            if (mappingMetaData != null) {_                return mappingMetaData.routing().required()__            }_        }_        return false__    };param,concrete,index,the,concrete,index,to,check,if,routing,is,required,param,type,the,type,to,check,if,routing,is,required,return,whether,routing,is,required,according,to,the,mapping,for,the,specified,index,and,type;public,boolean,routing,required,string,concrete,index,string,type,index,meta,data,index,meta,data,indices,get,concrete,index,if,index,meta,data,null,mapping,meta,data,mapping,meta,data,index,meta,data,get,mappings,get,type,if,mapping,meta,data,null,return,mapping,meta,data,routing,required,return,false
MetaData -> public boolean routingRequired(String concreteIndex, String type);1540847035;@param concreteIndex The concrete index to check if routing is required_@param type          The type to check if routing is required_@return Whether routing is required according to the mapping for the specified index and type;public boolean routingRequired(String concreteIndex, String type) {_        IndexMetaData indexMetaData = indices.get(concreteIndex)__        if (indexMetaData != null) {_            MappingMetaData mappingMetaData = indexMetaData.getMappings().get(type)__            if (mappingMetaData != null) {_                return mappingMetaData.routing().required()__            }_        }_        return false__    };param,concrete,index,the,concrete,index,to,check,if,routing,is,required,param,type,the,type,to,check,if,routing,is,required,return,whether,routing,is,required,according,to,the,mapping,for,the,specified,index,and,type;public,boolean,routing,required,string,concrete,index,string,type,index,meta,data,index,meta,data,indices,get,concrete,index,if,index,meta,data,null,mapping,meta,data,mapping,meta,data,index,meta,data,get,mappings,get,type,if,mapping,meta,data,null,return,mapping,meta,data,routing,required,return,false
MetaData -> public boolean hasAliases(final String[] aliases, String[] concreteIndices);1524684173;Checks if at least one of the specified aliases exists in the specified concrete indices. Wildcards are supported in the_alias names for partial matches.__@param aliases         The names of the index aliases to find_@param concreteIndices The concrete indexes the index aliases must point to order to be returned._@return whether at least one of the specified aliases exists in one of the specified concrete indices.;public boolean hasAliases(final String[] aliases, String[] concreteIndices) {_        assert aliases != null__        assert concreteIndices != null__        if (concreteIndices.length == 0) {_            return false__        }__        Iterable<String> intersection = HppcMaps.intersection(ObjectHashSet.from(concreteIndices), indices.keys())__        for (String index : intersection) {_            IndexMetaData indexMetaData = indices.get(index)__            List<AliasMetaData> filteredValues = new ArrayList<>()__            for (ObjectCursor<AliasMetaData> cursor : indexMetaData.getAliases().values()) {_                AliasMetaData value = cursor.value__                if (Regex.simpleMatch(aliases, value.alias())) {_                    filteredValues.add(value)__                }_            }_            if (!filteredValues.isEmpty()) {_                return true__            }_        }_        return false__    };checks,if,at,least,one,of,the,specified,aliases,exists,in,the,specified,concrete,indices,wildcards,are,supported,in,the,alias,names,for,partial,matches,param,aliases,the,names,of,the,index,aliases,to,find,param,concrete,indices,the,concrete,indexes,the,index,aliases,must,point,to,order,to,be,returned,return,whether,at,least,one,of,the,specified,aliases,exists,in,one,of,the,specified,concrete,indices;public,boolean,has,aliases,final,string,aliases,string,concrete,indices,assert,aliases,null,assert,concrete,indices,null,if,concrete,indices,length,0,return,false,iterable,string,intersection,hppc,maps,intersection,object,hash,set,from,concrete,indices,indices,keys,for,string,index,intersection,index,meta,data,index,meta,data,indices,get,index,list,alias,meta,data,filtered,values,new,array,list,for,object,cursor,alias,meta,data,cursor,index,meta,data,get,aliases,values,alias,meta,data,value,cursor,value,if,regex,simple,match,aliases,value,alias,filtered,values,add,value,if,filtered,values,is,empty,return,true,return,false
MetaData -> public boolean hasAliases(final String[] aliases, String[] concreteIndices);1527878678;Checks if at least one of the specified aliases exists in the specified concrete indices. Wildcards are supported in the_alias names for partial matches.__@param aliases         The names of the index aliases to find_@param concreteIndices The concrete indexes the index aliases must point to order to be returned._@return whether at least one of the specified aliases exists in one of the specified concrete indices.;public boolean hasAliases(final String[] aliases, String[] concreteIndices) {_        assert aliases != null__        assert concreteIndices != null__        if (concreteIndices.length == 0) {_            return false__        }__        Iterable<String> intersection = HppcMaps.intersection(ObjectHashSet.from(concreteIndices), indices.keys())__        for (String index : intersection) {_            IndexMetaData indexMetaData = indices.get(index)__            List<AliasMetaData> filteredValues = new ArrayList<>()__            for (ObjectCursor<AliasMetaData> cursor : indexMetaData.getAliases().values()) {_                AliasMetaData value = cursor.value__                if (Regex.simpleMatch(aliases, value.alias())) {_                    filteredValues.add(value)__                }_            }_            if (!filteredValues.isEmpty()) {_                return true__            }_        }_        return false__    };checks,if,at,least,one,of,the,specified,aliases,exists,in,the,specified,concrete,indices,wildcards,are,supported,in,the,alias,names,for,partial,matches,param,aliases,the,names,of,the,index,aliases,to,find,param,concrete,indices,the,concrete,indexes,the,index,aliases,must,point,to,order,to,be,returned,return,whether,at,least,one,of,the,specified,aliases,exists,in,one,of,the,specified,concrete,indices;public,boolean,has,aliases,final,string,aliases,string,concrete,indices,assert,aliases,null,assert,concrete,indices,null,if,concrete,indices,length,0,return,false,iterable,string,intersection,hppc,maps,intersection,object,hash,set,from,concrete,indices,indices,keys,for,string,index,intersection,index,meta,data,index,meta,data,indices,get,index,list,alias,meta,data,filtered,values,new,array,list,for,object,cursor,alias,meta,data,cursor,index,meta,data,get,aliases,values,alias,meta,data,value,cursor,value,if,regex,simple,match,aliases,value,alias,filtered,values,add,value,if,filtered,values,is,empty,return,true,return,false
MetaData -> public boolean hasAliases(final String[] aliases, String[] concreteIndices);1528103657;Checks if at least one of the specified aliases exists in the specified concrete indices. Wildcards are supported in the_alias names for partial matches.__@param aliases         The names of the index aliases to find_@param concreteIndices The concrete indexes the index aliases must point to order to be returned._@return whether at least one of the specified aliases exists in one of the specified concrete indices.;public boolean hasAliases(final String[] aliases, String[] concreteIndices) {_        assert aliases != null__        assert concreteIndices != null__        if (concreteIndices.length == 0) {_            return false__        }__        Iterable<String> intersection = HppcMaps.intersection(ObjectHashSet.from(concreteIndices), indices.keys())__        for (String index : intersection) {_            IndexMetaData indexMetaData = indices.get(index)__            List<AliasMetaData> filteredValues = new ArrayList<>()__            for (ObjectCursor<AliasMetaData> cursor : indexMetaData.getAliases().values()) {_                AliasMetaData value = cursor.value__                if (Regex.simpleMatch(aliases, value.alias())) {_                    filteredValues.add(value)__                }_            }_            if (!filteredValues.isEmpty()) {_                return true__            }_        }_        return false__    };checks,if,at,least,one,of,the,specified,aliases,exists,in,the,specified,concrete,indices,wildcards,are,supported,in,the,alias,names,for,partial,matches,param,aliases,the,names,of,the,index,aliases,to,find,param,concrete,indices,the,concrete,indexes,the,index,aliases,must,point,to,order,to,be,returned,return,whether,at,least,one,of,the,specified,aliases,exists,in,one,of,the,specified,concrete,indices;public,boolean,has,aliases,final,string,aliases,string,concrete,indices,assert,aliases,null,assert,concrete,indices,null,if,concrete,indices,length,0,return,false,iterable,string,intersection,hppc,maps,intersection,object,hash,set,from,concrete,indices,indices,keys,for,string,index,intersection,index,meta,data,index,meta,data,indices,get,index,list,alias,meta,data,filtered,values,new,array,list,for,object,cursor,alias,meta,data,cursor,index,meta,data,get,aliases,values,alias,meta,data,value,cursor,value,if,regex,simple,match,aliases,value,alias,filtered,values,add,value,if,filtered,values,is,empty,return,true,return,false
MetaData -> public boolean hasAliases(final String[] aliases, String[] concreteIndices);1529082965;Checks if at least one of the specified aliases exists in the specified concrete indices. Wildcards are supported in the_alias names for partial matches.__@param aliases         The names of the index aliases to find_@param concreteIndices The concrete indexes the index aliases must point to order to be returned._@return whether at least one of the specified aliases exists in one of the specified concrete indices.;public boolean hasAliases(final String[] aliases, String[] concreteIndices) {_        assert aliases != null__        assert concreteIndices != null__        if (concreteIndices.length == 0) {_            return false__        }__        Iterable<String> intersection = HppcMaps.intersection(ObjectHashSet.from(concreteIndices), indices.keys())__        for (String index : intersection) {_            IndexMetaData indexMetaData = indices.get(index)__            List<AliasMetaData> filteredValues = new ArrayList<>()__            for (ObjectCursor<AliasMetaData> cursor : indexMetaData.getAliases().values()) {_                AliasMetaData value = cursor.value__                if (Regex.simpleMatch(aliases, value.alias())) {_                    filteredValues.add(value)__                }_            }_            if (!filteredValues.isEmpty()) {_                return true__            }_        }_        return false__    };checks,if,at,least,one,of,the,specified,aliases,exists,in,the,specified,concrete,indices,wildcards,are,supported,in,the,alias,names,for,partial,matches,param,aliases,the,names,of,the,index,aliases,to,find,param,concrete,indices,the,concrete,indexes,the,index,aliases,must,point,to,order,to,be,returned,return,whether,at,least,one,of,the,specified,aliases,exists,in,one,of,the,specified,concrete,indices;public,boolean,has,aliases,final,string,aliases,string,concrete,indices,assert,aliases,null,assert,concrete,indices,null,if,concrete,indices,length,0,return,false,iterable,string,intersection,hppc,maps,intersection,object,hash,set,from,concrete,indices,indices,keys,for,string,index,intersection,index,meta,data,index,meta,data,indices,get,index,list,alias,meta,data,filtered,values,new,array,list,for,object,cursor,alias,meta,data,cursor,index,meta,data,get,aliases,values,alias,meta,data,value,cursor,value,if,regex,simple,match,aliases,value,alias,filtered,values,add,value,if,filtered,values,is,empty,return,true,return,false
MetaData -> public boolean hasAliases(final String[] aliases, String[] concreteIndices);1531179852;Checks if at least one of the specified aliases exists in the specified concrete indices. Wildcards are supported in the_alias names for partial matches.__@param aliases         The names of the index aliases to find_@param concreteIndices The concrete indexes the index aliases must point to order to be returned._@return whether at least one of the specified aliases exists in one of the specified concrete indices.;public boolean hasAliases(final String[] aliases, String[] concreteIndices) {_        assert aliases != null__        assert concreteIndices != null__        if (concreteIndices.length == 0) {_            return false__        }__        Iterable<String> intersection = HppcMaps.intersection(ObjectHashSet.from(concreteIndices), indices.keys())__        for (String index : intersection) {_            IndexMetaData indexMetaData = indices.get(index)__            List<AliasMetaData> filteredValues = new ArrayList<>()__            for (ObjectCursor<AliasMetaData> cursor : indexMetaData.getAliases().values()) {_                AliasMetaData value = cursor.value__                if (Regex.simpleMatch(aliases, value.alias())) {_                    filteredValues.add(value)__                }_            }_            if (!filteredValues.isEmpty()) {_                return true__            }_        }_        return false__    };checks,if,at,least,one,of,the,specified,aliases,exists,in,the,specified,concrete,indices,wildcards,are,supported,in,the,alias,names,for,partial,matches,param,aliases,the,names,of,the,index,aliases,to,find,param,concrete,indices,the,concrete,indexes,the,index,aliases,must,point,to,order,to,be,returned,return,whether,at,least,one,of,the,specified,aliases,exists,in,one,of,the,specified,concrete,indices;public,boolean,has,aliases,final,string,aliases,string,concrete,indices,assert,aliases,null,assert,concrete,indices,null,if,concrete,indices,length,0,return,false,iterable,string,intersection,hppc,maps,intersection,object,hash,set,from,concrete,indices,indices,keys,for,string,index,intersection,index,meta,data,index,meta,data,indices,get,index,list,alias,meta,data,filtered,values,new,array,list,for,object,cursor,alias,meta,data,cursor,index,meta,data,get,aliases,values,alias,meta,data,value,cursor,value,if,regex,simple,match,aliases,value,alias,filtered,values,add,value,if,filtered,values,is,empty,return,true,return,false
MetaData -> public boolean hasAliases(final String[] aliases, String[] concreteIndices);1532028790;Checks if at least one of the specified aliases exists in the specified concrete indices. Wildcards are supported in the_alias names for partial matches.__@param aliases         The names of the index aliases to find_@param concreteIndices The concrete indexes the index aliases must point to order to be returned._@return whether at least one of the specified aliases exists in one of the specified concrete indices.;public boolean hasAliases(final String[] aliases, String[] concreteIndices) {_        assert aliases != null__        assert concreteIndices != null__        if (concreteIndices.length == 0) {_            return false__        }__        Iterable<String> intersection = HppcMaps.intersection(ObjectHashSet.from(concreteIndices), indices.keys())__        for (String index : intersection) {_            IndexMetaData indexMetaData = indices.get(index)__            List<AliasMetaData> filteredValues = new ArrayList<>()__            for (ObjectCursor<AliasMetaData> cursor : indexMetaData.getAliases().values()) {_                AliasMetaData value = cursor.value__                if (Regex.simpleMatch(aliases, value.alias())) {_                    filteredValues.add(value)__                }_            }_            if (!filteredValues.isEmpty()) {_                return true__            }_        }_        return false__    };checks,if,at,least,one,of,the,specified,aliases,exists,in,the,specified,concrete,indices,wildcards,are,supported,in,the,alias,names,for,partial,matches,param,aliases,the,names,of,the,index,aliases,to,find,param,concrete,indices,the,concrete,indexes,the,index,aliases,must,point,to,order,to,be,returned,return,whether,at,least,one,of,the,specified,aliases,exists,in,one,of,the,specified,concrete,indices;public,boolean,has,aliases,final,string,aliases,string,concrete,indices,assert,aliases,null,assert,concrete,indices,null,if,concrete,indices,length,0,return,false,iterable,string,intersection,hppc,maps,intersection,object,hash,set,from,concrete,indices,indices,keys,for,string,index,intersection,index,meta,data,index,meta,data,indices,get,index,list,alias,meta,data,filtered,values,new,array,list,for,object,cursor,alias,meta,data,cursor,index,meta,data,get,aliases,values,alias,meta,data,value,cursor,value,if,regex,simple,match,aliases,value,alias,filtered,values,add,value,if,filtered,values,is,empty,return,true,return,false
MetaData -> public boolean hasAliases(final String[] aliases, String[] concreteIndices);1532353780;Checks if at least one of the specified aliases exists in the specified concrete indices. Wildcards are supported in the_alias names for partial matches.__@param aliases         The names of the index aliases to find_@param concreteIndices The concrete indexes the index aliases must point to order to be returned._@return whether at least one of the specified aliases exists in one of the specified concrete indices.;public boolean hasAliases(final String[] aliases, String[] concreteIndices) {_        assert aliases != null__        assert concreteIndices != null__        if (concreteIndices.length == 0) {_            return false__        }__        Iterable<String> intersection = HppcMaps.intersection(ObjectHashSet.from(concreteIndices), indices.keys())__        for (String index : intersection) {_            IndexMetaData indexMetaData = indices.get(index)__            List<AliasMetaData> filteredValues = new ArrayList<>()__            for (ObjectCursor<AliasMetaData> cursor : indexMetaData.getAliases().values()) {_                AliasMetaData value = cursor.value__                if (Regex.simpleMatch(aliases, value.alias())) {_                    filteredValues.add(value)__                }_            }_            if (!filteredValues.isEmpty()) {_                return true__            }_        }_        return false__    };checks,if,at,least,one,of,the,specified,aliases,exists,in,the,specified,concrete,indices,wildcards,are,supported,in,the,alias,names,for,partial,matches,param,aliases,the,names,of,the,index,aliases,to,find,param,concrete,indices,the,concrete,indexes,the,index,aliases,must,point,to,order,to,be,returned,return,whether,at,least,one,of,the,specified,aliases,exists,in,one,of,the,specified,concrete,indices;public,boolean,has,aliases,final,string,aliases,string,concrete,indices,assert,aliases,null,assert,concrete,indices,null,if,concrete,indices,length,0,return,false,iterable,string,intersection,hppc,maps,intersection,object,hash,set,from,concrete,indices,indices,keys,for,string,index,intersection,index,meta,data,index,meta,data,indices,get,index,list,alias,meta,data,filtered,values,new,array,list,for,object,cursor,alias,meta,data,cursor,index,meta,data,get,aliases,values,alias,meta,data,value,cursor,value,if,regex,simple,match,aliases,value,alias,filtered,values,add,value,if,filtered,values,is,empty,return,true,return,false
MetaData -> public boolean hasAliases(final String[] aliases, String[] concreteIndices);1536611444;Checks if at least one of the specified aliases exists in the specified concrete indices. Wildcards are supported in the_alias names for partial matches.__@param aliases         The names of the index aliases to find_@param concreteIndices The concrete indexes the index aliases must point to order to be returned._@return whether at least one of the specified aliases exists in one of the specified concrete indices.;public boolean hasAliases(final String[] aliases, String[] concreteIndices) {_        assert aliases != null__        assert concreteIndices != null__        if (concreteIndices.length == 0) {_            return false__        }__        Iterable<String> intersection = HppcMaps.intersection(ObjectHashSet.from(concreteIndices), indices.keys())__        for (String index : intersection) {_            IndexMetaData indexMetaData = indices.get(index)__            List<AliasMetaData> filteredValues = new ArrayList<>()__            for (ObjectCursor<AliasMetaData> cursor : indexMetaData.getAliases().values()) {_                AliasMetaData value = cursor.value__                if (Regex.simpleMatch(aliases, value.alias())) {_                    filteredValues.add(value)__                }_            }_            if (!filteredValues.isEmpty()) {_                return true__            }_        }_        return false__    };checks,if,at,least,one,of,the,specified,aliases,exists,in,the,specified,concrete,indices,wildcards,are,supported,in,the,alias,names,for,partial,matches,param,aliases,the,names,of,the,index,aliases,to,find,param,concrete,indices,the,concrete,indexes,the,index,aliases,must,point,to,order,to,be,returned,return,whether,at,least,one,of,the,specified,aliases,exists,in,one,of,the,specified,concrete,indices;public,boolean,has,aliases,final,string,aliases,string,concrete,indices,assert,aliases,null,assert,concrete,indices,null,if,concrete,indices,length,0,return,false,iterable,string,intersection,hppc,maps,intersection,object,hash,set,from,concrete,indices,indices,keys,for,string,index,intersection,index,meta,data,index,meta,data,indices,get,index,list,alias,meta,data,filtered,values,new,array,list,for,object,cursor,alias,meta,data,cursor,index,meta,data,get,aliases,values,alias,meta,data,value,cursor,value,if,regex,simple,match,aliases,value,alias,filtered,values,add,value,if,filtered,values,is,empty,return,true,return,false
MetaData -> public boolean hasAliases(final String[] aliases, String[] concreteIndices);1539723533;Checks if at least one of the specified aliases exists in the specified concrete indices. Wildcards are supported in the_alias names for partial matches.__@param aliases         The names of the index aliases to find_@param concreteIndices The concrete indexes the index aliases must point to order to be returned._@return whether at least one of the specified aliases exists in one of the specified concrete indices.;public boolean hasAliases(final String[] aliases, String[] concreteIndices) {_        assert aliases != null__        assert concreteIndices != null__        if (concreteIndices.length == 0) {_            return false__        }__        Iterable<String> intersection = HppcMaps.intersection(ObjectHashSet.from(concreteIndices), indices.keys())__        for (String index : intersection) {_            IndexMetaData indexMetaData = indices.get(index)__            List<AliasMetaData> filteredValues = new ArrayList<>()__            for (ObjectCursor<AliasMetaData> cursor : indexMetaData.getAliases().values()) {_                AliasMetaData value = cursor.value__                if (Regex.simpleMatch(aliases, value.alias())) {_                    filteredValues.add(value)__                }_            }_            if (!filteredValues.isEmpty()) {_                return true__            }_        }_        return false__    };checks,if,at,least,one,of,the,specified,aliases,exists,in,the,specified,concrete,indices,wildcards,are,supported,in,the,alias,names,for,partial,matches,param,aliases,the,names,of,the,index,aliases,to,find,param,concrete,indices,the,concrete,indexes,the,index,aliases,must,point,to,order,to,be,returned,return,whether,at,least,one,of,the,specified,aliases,exists,in,one,of,the,specified,concrete,indices;public,boolean,has,aliases,final,string,aliases,string,concrete,indices,assert,aliases,null,assert,concrete,indices,null,if,concrete,indices,length,0,return,false,iterable,string,intersection,hppc,maps,intersection,object,hash,set,from,concrete,indices,indices,keys,for,string,index,intersection,index,meta,data,index,meta,data,indices,get,index,list,alias,meta,data,filtered,values,new,array,list,for,object,cursor,alias,meta,data,cursor,index,meta,data,get,aliases,values,alias,meta,data,value,cursor,value,if,regex,simple,match,aliases,value,alias,filtered,values,add,value,if,filtered,values,is,empty,return,true,return,false
MetaData -> public boolean hasAliases(final String[] aliases, String[] concreteIndices);1540313026;Checks if at least one of the specified aliases exists in the specified concrete indices. Wildcards are supported in the_alias names for partial matches.__@param aliases         The names of the index aliases to find_@param concreteIndices The concrete indexes the index aliases must point to order to be returned._@return whether at least one of the specified aliases exists in one of the specified concrete indices.;public boolean hasAliases(final String[] aliases, String[] concreteIndices) {_        assert aliases != null__        assert concreteIndices != null__        if (concreteIndices.length == 0) {_            return false__        }__        Iterable<String> intersection = HppcMaps.intersection(ObjectHashSet.from(concreteIndices), indices.keys())__        for (String index : intersection) {_            IndexMetaData indexMetaData = indices.get(index)__            List<AliasMetaData> filteredValues = new ArrayList<>()__            for (ObjectCursor<AliasMetaData> cursor : indexMetaData.getAliases().values()) {_                AliasMetaData value = cursor.value__                if (Regex.simpleMatch(aliases, value.alias())) {_                    filteredValues.add(value)__                }_            }_            if (!filteredValues.isEmpty()) {_                return true__            }_        }_        return false__    };checks,if,at,least,one,of,the,specified,aliases,exists,in,the,specified,concrete,indices,wildcards,are,supported,in,the,alias,names,for,partial,matches,param,aliases,the,names,of,the,index,aliases,to,find,param,concrete,indices,the,concrete,indexes,the,index,aliases,must,point,to,order,to,be,returned,return,whether,at,least,one,of,the,specified,aliases,exists,in,one,of,the,specified,concrete,indices;public,boolean,has,aliases,final,string,aliases,string,concrete,indices,assert,aliases,null,assert,concrete,indices,null,if,concrete,indices,length,0,return,false,iterable,string,intersection,hppc,maps,intersection,object,hash,set,from,concrete,indices,indices,keys,for,string,index,intersection,index,meta,data,index,meta,data,indices,get,index,list,alias,meta,data,filtered,values,new,array,list,for,object,cursor,alias,meta,data,cursor,index,meta,data,get,aliases,values,alias,meta,data,value,cursor,value,if,regex,simple,match,aliases,value,alias,filtered,values,add,value,if,filtered,values,is,empty,return,true,return,false
MetaData -> public boolean hasAliases(final String[] aliases, String[] concreteIndices);1540486836;Checks if at least one of the specified aliases exists in the specified concrete indices. Wildcards are supported in the_alias names for partial matches.__@param aliases         The names of the index aliases to find_@param concreteIndices The concrete indexes the index aliases must point to order to be returned._@return whether at least one of the specified aliases exists in one of the specified concrete indices.;public boolean hasAliases(final String[] aliases, String[] concreteIndices) {_        assert aliases != null__        assert concreteIndices != null__        if (concreteIndices.length == 0) {_            return false__        }__        Iterable<String> intersection = HppcMaps.intersection(ObjectHashSet.from(concreteIndices), indices.keys())__        for (String index : intersection) {_            IndexMetaData indexMetaData = indices.get(index)__            List<AliasMetaData> filteredValues = new ArrayList<>()__            for (ObjectCursor<AliasMetaData> cursor : indexMetaData.getAliases().values()) {_                AliasMetaData value = cursor.value__                if (Regex.simpleMatch(aliases, value.alias())) {_                    filteredValues.add(value)__                }_            }_            if (!filteredValues.isEmpty()) {_                return true__            }_        }_        return false__    };checks,if,at,least,one,of,the,specified,aliases,exists,in,the,specified,concrete,indices,wildcards,are,supported,in,the,alias,names,for,partial,matches,param,aliases,the,names,of,the,index,aliases,to,find,param,concrete,indices,the,concrete,indexes,the,index,aliases,must,point,to,order,to,be,returned,return,whether,at,least,one,of,the,specified,aliases,exists,in,one,of,the,specified,concrete,indices;public,boolean,has,aliases,final,string,aliases,string,concrete,indices,assert,aliases,null,assert,concrete,indices,null,if,concrete,indices,length,0,return,false,iterable,string,intersection,hppc,maps,intersection,object,hash,set,from,concrete,indices,indices,keys,for,string,index,intersection,index,meta,data,index,meta,data,indices,get,index,list,alias,meta,data,filtered,values,new,array,list,for,object,cursor,alias,meta,data,cursor,index,meta,data,get,aliases,values,alias,meta,data,value,cursor,value,if,regex,simple,match,aliases,value,alias,filtered,values,add,value,if,filtered,values,is,empty,return,true,return,false
MetaData -> public boolean hasAliases(final String[] aliases, String[] concreteIndices);1540847035;Checks if at least one of the specified aliases exists in the specified concrete indices. Wildcards are supported in the_alias names for partial matches.__@param aliases         The names of the index aliases to find_@param concreteIndices The concrete indexes the index aliases must point to order to be returned._@return whether at least one of the specified aliases exists in one of the specified concrete indices.;public boolean hasAliases(final String[] aliases, String[] concreteIndices) {_        assert aliases != null__        assert concreteIndices != null__        if (concreteIndices.length == 0) {_            return false__        }__        Iterable<String> intersection = HppcMaps.intersection(ObjectHashSet.from(concreteIndices), indices.keys())__        for (String index : intersection) {_            IndexMetaData indexMetaData = indices.get(index)__            List<AliasMetaData> filteredValues = new ArrayList<>()__            for (ObjectCursor<AliasMetaData> cursor : indexMetaData.getAliases().values()) {_                AliasMetaData value = cursor.value__                if (Regex.simpleMatch(aliases, value.alias())) {_                    filteredValues.add(value)__                }_            }_            if (!filteredValues.isEmpty()) {_                return true__            }_        }_        return false__    };checks,if,at,least,one,of,the,specified,aliases,exists,in,the,specified,concrete,indices,wildcards,are,supported,in,the,alias,names,for,partial,matches,param,aliases,the,names,of,the,index,aliases,to,find,param,concrete,indices,the,concrete,indexes,the,index,aliases,must,point,to,order,to,be,returned,return,whether,at,least,one,of,the,specified,aliases,exists,in,one,of,the,specified,concrete,indices;public,boolean,has,aliases,final,string,aliases,string,concrete,indices,assert,aliases,null,assert,concrete,indices,null,if,concrete,indices,length,0,return,false,iterable,string,intersection,hppc,maps,intersection,object,hash,set,from,concrete,indices,indices,keys,for,string,index,intersection,index,meta,data,index,meta,data,indices,get,index,list,alias,meta,data,filtered,values,new,array,list,for,object,cursor,alias,meta,data,cursor,index,meta,data,get,aliases,values,alias,meta,data,value,cursor,value,if,regex,simple,match,aliases,value,alias,filtered,values,add,value,if,filtered,values,is,empty,return,true,return,false
MetaData -> public boolean hasAliases(final String[] aliases, String[] concreteIndices);1543947737;Checks if at least one of the specified aliases exists in the specified concrete indices. Wildcards are supported in the_alias names for partial matches.__@param aliases         The names of the index aliases to find_@param concreteIndices The concrete indexes the index aliases must point to order to be returned._@return whether at least one of the specified aliases exists in one of the specified concrete indices.;public boolean hasAliases(final String[] aliases, String[] concreteIndices) {_        assert aliases != null__        assert concreteIndices != null__        if (concreteIndices.length == 0) {_            return false__        }__        Iterable<String> intersection = HppcMaps.intersection(ObjectHashSet.from(concreteIndices), indices.keys())__        for (String index : intersection) {_            IndexMetaData indexMetaData = indices.get(index)__            List<AliasMetaData> filteredValues = new ArrayList<>()__            for (ObjectCursor<AliasMetaData> cursor : indexMetaData.getAliases().values()) {_                AliasMetaData value = cursor.value__                if (Regex.simpleMatch(aliases, value.alias())) {_                    filteredValues.add(value)__                }_            }_            if (!filteredValues.isEmpty()) {_                return true__            }_        }_        return false__    };checks,if,at,least,one,of,the,specified,aliases,exists,in,the,specified,concrete,indices,wildcards,are,supported,in,the,alias,names,for,partial,matches,param,aliases,the,names,of,the,index,aliases,to,find,param,concrete,indices,the,concrete,indexes,the,index,aliases,must,point,to,order,to,be,returned,return,whether,at,least,one,of,the,specified,aliases,exists,in,one,of,the,specified,concrete,indices;public,boolean,has,aliases,final,string,aliases,string,concrete,indices,assert,aliases,null,assert,concrete,indices,null,if,concrete,indices,length,0,return,false,iterable,string,intersection,hppc,maps,intersection,object,hash,set,from,concrete,indices,indices,keys,for,string,index,intersection,index,meta,data,index,meta,data,indices,get,index,list,alias,meta,data,filtered,values,new,array,list,for,object,cursor,alias,meta,data,cursor,index,meta,data,get,aliases,values,alias,meta,data,value,cursor,value,if,regex,simple,match,aliases,value,alias,filtered,values,add,value,if,filtered,values,is,empty,return,true,return,false
MetaData -> public boolean hasAliases(final String[] aliases, String[] concreteIndices);1544081506;Checks if at least one of the specified aliases exists in the specified concrete indices. Wildcards are supported in the_alias names for partial matches.__@param aliases         The names of the index aliases to find_@param concreteIndices The concrete indexes the index aliases must point to order to be returned._@return whether at least one of the specified aliases exists in one of the specified concrete indices.;public boolean hasAliases(final String[] aliases, String[] concreteIndices) {_        assert aliases != null__        assert concreteIndices != null__        if (concreteIndices.length == 0) {_            return false__        }__        Iterable<String> intersection = HppcMaps.intersection(ObjectHashSet.from(concreteIndices), indices.keys())__        for (String index : intersection) {_            IndexMetaData indexMetaData = indices.get(index)__            List<AliasMetaData> filteredValues = new ArrayList<>()__            for (ObjectCursor<AliasMetaData> cursor : indexMetaData.getAliases().values()) {_                AliasMetaData value = cursor.value__                if (Regex.simpleMatch(aliases, value.alias())) {_                    filteredValues.add(value)__                }_            }_            if (!filteredValues.isEmpty()) {_                return true__            }_        }_        return false__    };checks,if,at,least,one,of,the,specified,aliases,exists,in,the,specified,concrete,indices,wildcards,are,supported,in,the,alias,names,for,partial,matches,param,aliases,the,names,of,the,index,aliases,to,find,param,concrete,indices,the,concrete,indexes,the,index,aliases,must,point,to,order,to,be,returned,return,whether,at,least,one,of,the,specified,aliases,exists,in,one,of,the,specified,concrete,indices;public,boolean,has,aliases,final,string,aliases,string,concrete,indices,assert,aliases,null,assert,concrete,indices,null,if,concrete,indices,length,0,return,false,iterable,string,intersection,hppc,maps,intersection,object,hash,set,from,concrete,indices,indices,keys,for,string,index,intersection,index,meta,data,index,meta,data,indices,get,index,list,alias,meta,data,filtered,values,new,array,list,for,object,cursor,alias,meta,data,cursor,index,meta,data,get,aliases,values,alias,meta,data,value,cursor,value,if,regex,simple,match,aliases,value,alias,filtered,values,add,value,if,filtered,values,is,empty,return,true,return,false
MetaData -> public boolean hasAliases(final String[] aliases, String[] concreteIndices);1544702062;Checks if at least one of the specified aliases exists in the specified concrete indices. Wildcards are supported in the_alias names for partial matches.__@param aliases         The names of the index aliases to find_@param concreteIndices The concrete indexes the index aliases must point to order to be returned._@return whether at least one of the specified aliases exists in one of the specified concrete indices.;public boolean hasAliases(final String[] aliases, String[] concreteIndices) {_        assert aliases != null__        assert concreteIndices != null__        if (concreteIndices.length == 0) {_            return false__        }__        Iterable<String> intersection = HppcMaps.intersection(ObjectHashSet.from(concreteIndices), indices.keys())__        for (String index : intersection) {_            IndexMetaData indexMetaData = indices.get(index)__            List<AliasMetaData> filteredValues = new ArrayList<>()__            for (ObjectCursor<AliasMetaData> cursor : indexMetaData.getAliases().values()) {_                AliasMetaData value = cursor.value__                if (Regex.simpleMatch(aliases, value.alias())) {_                    filteredValues.add(value)__                }_            }_            if (!filteredValues.isEmpty()) {_                return true__            }_        }_        return false__    };checks,if,at,least,one,of,the,specified,aliases,exists,in,the,specified,concrete,indices,wildcards,are,supported,in,the,alias,names,for,partial,matches,param,aliases,the,names,of,the,index,aliases,to,find,param,concrete,indices,the,concrete,indexes,the,index,aliases,must,point,to,order,to,be,returned,return,whether,at,least,one,of,the,specified,aliases,exists,in,one,of,the,specified,concrete,indices;public,boolean,has,aliases,final,string,aliases,string,concrete,indices,assert,aliases,null,assert,concrete,indices,null,if,concrete,indices,length,0,return,false,iterable,string,intersection,hppc,maps,intersection,object,hash,set,from,concrete,indices,indices,keys,for,string,index,intersection,index,meta,data,index,meta,data,indices,get,index,list,alias,meta,data,filtered,values,new,array,list,for,object,cursor,alias,meta,data,cursor,index,meta,data,get,aliases,values,alias,meta,data,value,cursor,value,if,regex,simple,match,aliases,value,alias,filtered,values,add,value,if,filtered,values,is,empty,return,true,return,false
MetaData -> public boolean hasAliases(final String[] aliases, String[] concreteIndices);1547500081;Checks if at least one of the specified aliases exists in the specified concrete indices. Wildcards are supported in the_alias names for partial matches.__@param aliases         The names of the index aliases to find_@param concreteIndices The concrete indexes the index aliases must point to order to be returned._@return whether at least one of the specified aliases exists in one of the specified concrete indices.;public boolean hasAliases(final String[] aliases, String[] concreteIndices) {_        assert aliases != null__        assert concreteIndices != null__        if (concreteIndices.length == 0) {_            return false__        }__        Iterable<String> intersection = HppcMaps.intersection(ObjectHashSet.from(concreteIndices), indices.keys())__        for (String index : intersection) {_            IndexMetaData indexMetaData = indices.get(index)__            List<AliasMetaData> filteredValues = new ArrayList<>()__            for (ObjectCursor<AliasMetaData> cursor : indexMetaData.getAliases().values()) {_                AliasMetaData value = cursor.value__                if (Regex.simpleMatch(aliases, value.alias())) {_                    filteredValues.add(value)__                }_            }_            if (!filteredValues.isEmpty()) {_                return true__            }_        }_        return false__    };checks,if,at,least,one,of,the,specified,aliases,exists,in,the,specified,concrete,indices,wildcards,are,supported,in,the,alias,names,for,partial,matches,param,aliases,the,names,of,the,index,aliases,to,find,param,concrete,indices,the,concrete,indexes,the,index,aliases,must,point,to,order,to,be,returned,return,whether,at,least,one,of,the,specified,aliases,exists,in,one,of,the,specified,concrete,indices;public,boolean,has,aliases,final,string,aliases,string,concrete,indices,assert,aliases,null,assert,concrete,indices,null,if,concrete,indices,length,0,return,false,iterable,string,intersection,hppc,maps,intersection,object,hash,set,from,concrete,indices,indices,keys,for,string,index,intersection,index,meta,data,index,meta,data,indices,get,index,list,alias,meta,data,filtered,values,new,array,list,for,object,cursor,alias,meta,data,cursor,index,meta,data,get,aliases,values,alias,meta,data,value,cursor,value,if,regex,simple,match,aliases,value,alias,filtered,values,add,value,if,filtered,values,is,empty,return,true,return,false
MetaData -> public boolean hasAliases(final String[] aliases, String[] concreteIndices);1548772865;Checks if at least one of the specified aliases exists in the specified concrete indices. Wildcards are supported in the_alias names for partial matches.__@param aliases         The names of the index aliases to find_@param concreteIndices The concrete indexes the index aliases must point to order to be returned._@return whether at least one of the specified aliases exists in one of the specified concrete indices.;public boolean hasAliases(final String[] aliases, String[] concreteIndices) {_        assert aliases != null__        assert concreteIndices != null__        if (concreteIndices.length == 0) {_            return false__        }__        Iterable<String> intersection = HppcMaps.intersection(ObjectHashSet.from(concreteIndices), indices.keys())__        for (String index : intersection) {_            IndexMetaData indexMetaData = indices.get(index)__            List<AliasMetaData> filteredValues = new ArrayList<>()__            for (ObjectCursor<AliasMetaData> cursor : indexMetaData.getAliases().values()) {_                AliasMetaData value = cursor.value__                if (Regex.simpleMatch(aliases, value.alias())) {_                    filteredValues.add(value)__                }_            }_            if (!filteredValues.isEmpty()) {_                return true__            }_        }_        return false__    };checks,if,at,least,one,of,the,specified,aliases,exists,in,the,specified,concrete,indices,wildcards,are,supported,in,the,alias,names,for,partial,matches,param,aliases,the,names,of,the,index,aliases,to,find,param,concrete,indices,the,concrete,indexes,the,index,aliases,must,point,to,order,to,be,returned,return,whether,at,least,one,of,the,specified,aliases,exists,in,one,of,the,specified,concrete,indices;public,boolean,has,aliases,final,string,aliases,string,concrete,indices,assert,aliases,null,assert,concrete,indices,null,if,concrete,indices,length,0,return,false,iterable,string,intersection,hppc,maps,intersection,object,hash,set,from,concrete,indices,indices,keys,for,string,index,intersection,index,meta,data,index,meta,data,indices,get,index,list,alias,meta,data,filtered,values,new,array,list,for,object,cursor,alias,meta,data,cursor,index,meta,data,get,aliases,values,alias,meta,data,value,cursor,value,if,regex,simple,match,aliases,value,alias,filtered,values,add,value,if,filtered,values,is,empty,return,true,return,false
