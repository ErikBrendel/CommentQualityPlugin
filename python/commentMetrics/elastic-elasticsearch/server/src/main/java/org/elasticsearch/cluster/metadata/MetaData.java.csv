commented;modifiers;parameterAmount;loc;comment;code
false;;0;1;;EnumSet<XContentContext> context().
false;public;0;3;;public long version() {     return this.version. }
false;public;0;3;;public String clusterUUID() {     return this.clusterUUID. }
true;public;0;3;/**  * Whether the current node with the given cluster state is locked into the cluster with the UUID returned by {@link #clusterUUID()},  * meaning that it will not accept any cluster state with a different clusterUUID.  */ ;/**  * Whether the current node with the given cluster state is locked into the cluster with the UUID returned by {@link #clusterUUID()},  * meaning that it will not accept any cluster state with a different clusterUUID.  */ public boolean clusterUUIDCommitted() {     return this.clusterUUIDCommitted. }
true;public;0;3;/**  * Returns the merged transient and persistent settings.  */ ;/**  * Returns the merged transient and persistent settings.  */ public Settings settings() {     return this.settings. }
false;public;0;3;;public Settings transientSettings() {     return this.transientSettings. }
false;public;0;3;;public Settings persistentSettings() {     return this.persistentSettings. }
false;public;0;3;;public CoordinationMetaData coordinationMetaData() {     return this.coordinationMetaData. }
false;public;1;8;;public boolean hasAlias(String alias) {     AliasOrIndex aliasOrIndex = getAliasAndIndexLookup().get(alias).     if (aliasOrIndex != null) {         return aliasOrIndex.isAlias().     } else {         return false.     } }
false;public;1;14;;public boolean equalsAliases(MetaData other) {     for (ObjectCursor<IndexMetaData> cursor : other.indices().values()) {         IndexMetaData otherIndex = cursor.value.         IndexMetaData thisIndex = index(otherIndex.getIndex()).         if (thisIndex == null) {             return false.         }         if (otherIndex.getAliases().equals(thisIndex.getAliases()) == false) {             return false.         }     }     return true. }
false;public;0;3;;public SortedMap<String, AliasOrIndex> getAliasAndIndexLookup() {     return aliasAndIndexLookup. }
true;public;1;3;/**  * Finds the specific index aliases that point to the requested concrete indices directly  * or that match with the indices via wildcards.  *  * @param concreteIndices The concrete indices that the aliases must point to in order to be returned.  * @return A map of index name to the list of aliases metadata. If a concrete index does not have matching  * aliases then the result will <b>not</b> include the index's key.  */ ;/**  * Finds the specific index aliases that point to the requested concrete indices directly  * or that match with the indices via wildcards.  *  * @param concreteIndices The concrete indices that the aliases must point to in order to be returned.  * @return A map of index name to the list of aliases metadata. If a concrete index does not have matching  * aliases then the result will <b>not</b> include the index's key.  */ public ImmutableOpenMap<String, List<AliasMetaData>> findAllAliases(final String[] concreteIndices) {     return findAliases(Strings.EMPTY_ARRAY, concreteIndices). }
true;public;2;3;/**  * Finds the specific index aliases that match with the specified aliases directly or partially via wildcards, and  * that point to the specified concrete indices (directly or matching indices via wildcards).  *  * @param aliasesRequest The request to find aliases for  * @param concreteIndices The concrete indices that the aliases must point to in order to be returned.  * @return A map of index name to the list of aliases metadata. If a concrete index does not have matching  * aliases then the result will <b>not</b> include the index's key.  */ ;/**  * Finds the specific index aliases that match with the specified aliases directly or partially via wildcards, and  * that point to the specified concrete indices (directly or matching indices via wildcards).  *  * @param aliasesRequest The request to find aliases for  * @param concreteIndices The concrete indices that the aliases must point to in order to be returned.  * @return A map of index name to the list of aliases metadata. If a concrete index does not have matching  * aliases then the result will <b>not</b> include the index's key.  */ public ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final AliasesRequest aliasesRequest, final String[] concreteIndices) {     return findAliases(aliasesRequest.aliases(), concreteIndices). }
true;private;2;49;/**  * Finds the specific index aliases that match with the specified aliases directly or partially via wildcards, and  * that point to the specified concrete indices (directly or matching indices via wildcards).  *  * @param aliases The aliases to look for. Might contain include or exclude wildcards.  * @param concreteIndices The concrete indices that the aliases must point to in order to be returned  * @return A map of index name to the list of aliases metadata. If a concrete index does not have matching  * aliases then the result will <b>not</b> include the index's key.  */ ;/**  * Finds the specific index aliases that match with the specified aliases directly or partially via wildcards, and  * that point to the specified concrete indices (directly or matching indices via wildcards).  *  * @param aliases The aliases to look for. Might contain include or exclude wildcards.  * @param concreteIndices The concrete indices that the aliases must point to in order to be returned  * @return A map of index name to the list of aliases metadata. If a concrete index does not have matching  * aliases then the result will <b>not</b> include the index's key.  */ private ImmutableOpenMap<String, List<AliasMetaData>> findAliases(final String[] aliases, final String[] concreteIndices) {     assert aliases != null.     assert concreteIndices != null.     if (concreteIndices.length == 0) {         return ImmutableOpenMap.of().     }     String[] patterns = new String[aliases.length].     boolean[] include = new boolean[aliases.length].     for (int i = 0. i < aliases.length. i++) {         String alias = aliases[i].         if (alias.charAt(0) == '-') {             patterns[i] = alias.substring(1).             include[i] = false.         } else {             patterns[i] = alias.             include[i] = true.         }     }     boolean matchAllAliases = patterns.length == 0.     ImmutableOpenMap.Builder<String, List<AliasMetaData>> mapBuilder = ImmutableOpenMap.builder().     for (String index : concreteIndices) {         IndexMetaData indexMetaData = indices.get(index).         List<AliasMetaData> filteredValues = new ArrayList<>().         for (ObjectCursor<AliasMetaData> cursor : indexMetaData.getAliases().values()) {             AliasMetaData value = cursor.value.             boolean matched = matchAllAliases.             String alias = value.alias().             for (int i = 0. i < patterns.length. i++) {                 if (include[i]) {                     if (matched == false) {                         String pattern = patterns[i].                         matched = ALL.equals(pattern) || Regex.simpleMatch(pattern, alias).                     }                 } else if (matched) {                     matched = Regex.simpleMatch(patterns[i], alias) == false.                 }             }             if (matched) {                 filteredValues.add(value).             }         }         if (filteredValues.isEmpty() == false) {             // Make the list order deterministic             CollectionUtil.timSort(filteredValues, Comparator.comparing(AliasMetaData::alias)).             mapBuilder.put(index, Collections.unmodifiableList(filteredValues)).         }     }     return mapBuilder.build(). }
true;public;2;23;/**  * Checks if at least one of the specified aliases exists in the specified concrete indices. Wildcards are supported in the  * alias names for partial matches.  *  * @param aliases         The names of the index aliases to find  * @param concreteIndices The concrete indexes the index aliases must point to order to be returned.  * @return whether at least one of the specified aliases exists in one of the specified concrete indices.  */ ;/**  * Checks if at least one of the specified aliases exists in the specified concrete indices. Wildcards are supported in the  * alias names for partial matches.  *  * @param aliases         The names of the index aliases to find  * @param concreteIndices The concrete indexes the index aliases must point to order to be returned.  * @return whether at least one of the specified aliases exists in one of the specified concrete indices.  */ public boolean hasAliases(final String[] aliases, String[] concreteIndices) {     assert aliases != null.     assert concreteIndices != null.     if (concreteIndices.length == 0) {         return false.     }     Iterable<String> intersection = HppcMaps.intersection(ObjectHashSet.from(concreteIndices), indices.keys()).     for (String index : intersection) {         IndexMetaData indexMetaData = indices.get(index).         List<AliasMetaData> filteredValues = new ArrayList<>().         for (ObjectCursor<AliasMetaData> cursor : indexMetaData.getAliases().values()) {             AliasMetaData value = cursor.value.             if (Regex.simpleMatch(aliases, value.alias())) {                 filteredValues.add(value).             }         }         if (!filteredValues.isEmpty()) {             return true.         }     }     return false. }
true;public;3;32;/**  * Finds all mappings for types and concrete indices. Types are expanded to include all types that match the glob  * patterns in the types array. Empty types array, null or {"_all"} will be expanded to all types available for  * the given indices. Only fields that match the provided field filter will be returned (default is a predicate  * that always returns true, which can be overridden via plugins)  *  * @see MapperPlugin#getFieldFilter()  */ ;/**  * Finds all mappings for types and concrete indices. Types are expanded to include all types that match the glob  * patterns in the types array. Empty types array, null or {"_all"} will be expanded to all types available for  * the given indices. Only fields that match the provided field filter will be returned (default is a predicate  * that always returns true, which can be overridden via plugins)  *  * @see MapperPlugin#getFieldFilter()  */ public ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> findMappings(String[] concreteIndices, final String[] types, Function<String, Predicate<String>> fieldFilter) throws IOException {     assert types != null.     assert concreteIndices != null.     if (concreteIndices.length == 0) {         return ImmutableOpenMap.of().     }     boolean isAllTypes = isAllTypes(types).     ImmutableOpenMap.Builder<String, ImmutableOpenMap<String, MappingMetaData>> indexMapBuilder = ImmutableOpenMap.builder().     Iterable<String> intersection = HppcMaps.intersection(ObjectHashSet.from(concreteIndices), indices.keys()).     for (String index : intersection) {         IndexMetaData indexMetaData = indices.get(index).         Predicate<String> fieldPredicate = fieldFilter.apply(index).         if (isAllTypes) {             indexMapBuilder.put(index, filterFields(indexMetaData.getMappings(), fieldPredicate)).         } else {             ImmutableOpenMap.Builder<String, MappingMetaData> filteredMappings = ImmutableOpenMap.builder().             for (ObjectObjectCursor<String, MappingMetaData> cursor : indexMetaData.getMappings()) {                 if (Regex.simpleMatch(types, cursor.key)) {                     filteredMappings.put(cursor.key, filterFields(cursor.value, fieldPredicate)).                 }             }             if (!filteredMappings.isEmpty()) {                 indexMapBuilder.put(index, filteredMappings.build()).             }         }     }     return indexMapBuilder.build(). }
false;private,static;2;11;;private static ImmutableOpenMap<String, MappingMetaData> filterFields(ImmutableOpenMap<String, MappingMetaData> mappings, Predicate<String> fieldPredicate) throws IOException {     if (fieldPredicate == MapperPlugin.NOOP_FIELD_PREDICATE) {         return mappings.     }     ImmutableOpenMap.Builder<String, MappingMetaData> builder = ImmutableOpenMap.builder(mappings.size()).     for (ObjectObjectCursor<String, MappingMetaData> cursor : mappings) {         builder.put(cursor.key, filterFields(cursor.value, fieldPredicate)).     }     // No types specified means return them all     return builder.build(). }
false;private,static;2;22;;@SuppressWarnings("unchecked") private static MappingMetaData filterFields(MappingMetaData mappingMetaData, Predicate<String> fieldPredicate) throws IOException {     if (fieldPredicate == MapperPlugin.NOOP_FIELD_PREDICATE) {         return mappingMetaData.     }     Map<String, Object> sourceAsMap = XContentHelper.convertToMap(mappingMetaData.source().compressedReference(), true).v2().     Map<String, Object> mapping.     if (sourceAsMap.size() == 1 && sourceAsMap.containsKey(mappingMetaData.type())) {         mapping = (Map<String, Object>) sourceAsMap.get(mappingMetaData.type()).     } else {         mapping = sourceAsMap.     }     Map<String, Object> properties = (Map<String, Object>) mapping.get("properties").     if (properties == null || properties.isEmpty()) {         return mappingMetaData.     }     filterFields("", properties, fieldPredicate).     return new MappingMetaData(mappingMetaData.type(), sourceAsMap). }
false;private,static;3;46;;@SuppressWarnings("unchecked") private static boolean filterFields(String currentPath, Map<String, Object> fields, Predicate<String> fieldPredicate) {     assert fieldPredicate != MapperPlugin.NOOP_FIELD_PREDICATE.     Iterator<Map.Entry<String, Object>> entryIterator = fields.entrySet().iterator().     while (entryIterator.hasNext()) {         Map.Entry<String, Object> entry = entryIterator.next().         String newPath = mergePaths(currentPath, entry.getKey()).         Object value = entry.getValue().         boolean mayRemove = true.         boolean isMultiField = false.         if (value instanceof Map) {             Map<String, Object> map = (Map<String, Object>) value.             Map<String, Object> properties = (Map<String, Object>) map.get("properties").             if (properties != null) {                 mayRemove = filterFields(newPath, properties, fieldPredicate).             } else {                 Map<String, Object> subFields = (Map<String, Object>) map.get("fields").                 if (subFields != null) {                     isMultiField = true.                     if (mayRemove = filterFields(newPath, subFields, fieldPredicate)) {                         map.remove("fields").                     }                 }             }         } else {             throw new IllegalStateException("cannot filter mappings, found unknown element of type [" + value.getClass() + "]").         }         // only remove a field if it has no sub-fields left and it has to be excluded         if (fieldPredicate.test(newPath) == false) {             if (mayRemove) {                 entryIterator.remove().             } else if (isMultiField) {                 // multi fields that should be excluded but hold subfields that don't have to be excluded are converted to objects                 Map<String, Object> map = (Map<String, Object>) value.                 Map<String, Object> subFields = (Map<String, Object>) map.get("fields").                 assert subFields.size() > 0.                 map.put("properties", subFields).                 map.remove("fields").                 map.remove("type").             }         }     }     // return true if the ancestor may be removed, as it has no sub-fields left     return fields.size() == 0. }
false;private,static;2;6;;private static String mergePaths(String path, String field) {     if (path.length() == 0) {         return field.     }     return path + "." + field. }
true;public;0;3;/**  * Returns all the concrete indices.  */ ;/**  * Returns all the concrete indices.  */ public String[] getConcreteAllIndices() {     return allIndices. }
false;public;0;3;;public String[] getConcreteAllOpenIndices() {     return allOpenIndices. }
false;public;0;3;;public String[] getConcreteAllClosedIndices() {     return allClosedIndices. }
true;public;2;31;/**  * Returns indexing routing for the given <code>aliasOrIndex</code>. Resolves routing from the alias metadata used  * in the write index.  */ ;/**  * Returns indexing routing for the given <code>aliasOrIndex</code>. Resolves routing from the alias metadata used  * in the write index.  */ public String resolveWriteIndexRouting(@Nullable String routing, String aliasOrIndex) {     if (aliasOrIndex == null) {         return routing.     }     AliasOrIndex result = getAliasAndIndexLookup().get(aliasOrIndex).     if (result == null || result.isAlias() == false) {         return routing.     }     AliasOrIndex.Alias alias = (AliasOrIndex.Alias) result.     IndexMetaData writeIndex = alias.getWriteIndex().     if (writeIndex == null) {         throw new IllegalArgumentException("alias [" + aliasOrIndex + "] does not have a write index").     }     AliasMetaData aliasMd = writeIndex.getAliases().get(alias.getAliasName()).     if (aliasMd.indexRouting() != null) {         if (aliasMd.indexRouting().indexOf(',') != -1) {             throw new IllegalArgumentException("index/alias [" + aliasOrIndex + "] provided with routing value [" + aliasMd.getIndexRouting() + "] that resolved to several routing values, rejecting operation").         }         if (routing != null) {             if (!routing.equals(aliasMd.indexRouting())) {                 throw new IllegalArgumentException("Alias [" + aliasOrIndex + "] has index routing associated with it [" + aliasMd.indexRouting() + "], and was provided with routing value [" + routing + "], rejecting operation").             }         }         // Alias routing overrides the parent routing (if any).         return aliasMd.indexRouting().     }     return routing. }
true;public;2;30;// in the index,bulk,update and delete apis. ;/**  * Returns indexing routing for the given index.  */ // TODO: This can be moved to IndexNameExpressionResolver too, but this means that we will support wildcards and other expressions // in the index,bulk,update and delete apis. public String resolveIndexRouting(@Nullable String routing, String aliasOrIndex) {     if (aliasOrIndex == null) {         return routing.     }     AliasOrIndex result = getAliasAndIndexLookup().get(aliasOrIndex).     if (result == null || result.isAlias() == false) {         return routing.     }     AliasOrIndex.Alias alias = (AliasOrIndex.Alias) result.     if (result.getIndices().size() > 1) {         rejectSingleIndexOperation(aliasOrIndex, result).     }     AliasMetaData aliasMd = alias.getFirstAliasMetaData().     if (aliasMd.indexRouting() != null) {         if (aliasMd.indexRouting().indexOf(',') != -1) {             throw new IllegalArgumentException("index/alias [" + aliasOrIndex + "] provided with routing value [" + aliasMd.getIndexRouting() + "] that resolved to several routing values, rejecting operation").         }         if (routing != null) {             if (!routing.equals(aliasMd.indexRouting())) {                 throw new IllegalArgumentException("Alias [" + aliasOrIndex + "] has index routing associated with it [" + aliasMd.indexRouting() + "], and was provided with routing value [" + routing + "], rejecting operation").             }         }         // Alias routing overrides the parent routing (if any).         return aliasMd.indexRouting().     }     return routing. }
false;private;2;9;;private void rejectSingleIndexOperation(String aliasOrIndex, AliasOrIndex result) {     String[] indexNames = new String[result.getIndices().size()].     int i = 0.     for (IndexMetaData indexMetaData : result.getIndices()) {         indexNames[i++] = indexMetaData.getIndex().getName().     }     throw new IllegalArgumentException("Alias [" + aliasOrIndex + "] has more than one index associated with it [" + Arrays.toString(indexNames) + "], can't execute a single index op"). }
false;public;1;3;;public boolean hasIndex(String index) {     return indices.containsKey(index). }
false;public;1;3;;public boolean hasConcreteIndex(String index) {     return getAliasAndIndexLookup().containsKey(index). }
false;public;1;3;;public IndexMetaData index(String index) {     return indices.get(index). }
false;public;1;7;;public IndexMetaData index(Index index) {     IndexMetaData metaData = index(index.getName()).     if (metaData != null && metaData.getIndexUUID().equals(index.getUUID())) {         return metaData.     }     return null. }
true;public;1;3;/**  * Returns true iff existing index has the same {@link IndexMetaData} instance  */ ;/**  * Returns true iff existing index has the same {@link IndexMetaData} instance  */ public boolean hasIndexMetaData(final IndexMetaData indexMetaData) {     return indices.get(indexMetaData.getIndex().getName()) == indexMetaData. }
true;public;1;12;/**  * Returns the {@link IndexMetaData} for this index.  * @throws IndexNotFoundException if no metadata for this index is found  */ ;/**  * Returns the {@link IndexMetaData} for this index.  * @throws IndexNotFoundException if no metadata for this index is found  */ public IndexMetaData getIndexSafe(Index index) {     IndexMetaData metaData = index(index.getName()).     if (metaData != null) {         if (metaData.getIndexUUID().equals(index.getUUID())) {             return metaData.         }         throw new IndexNotFoundException(index, new IllegalStateException("index uuid doesn't match expected: [" + index.getUUID() + "] but got: [" + metaData.getIndexUUID() + "]")).     }     throw new IndexNotFoundException(index). }
false;public;0;3;;public ImmutableOpenMap<String, IndexMetaData> indices() {     return this.indices. }
false;public;0;3;;public ImmutableOpenMap<String, IndexMetaData> getIndices() {     return indices(). }
false;public;0;3;;public ImmutableOpenMap<String, IndexTemplateMetaData> templates() {     return this.templates. }
false;public;0;3;;public ImmutableOpenMap<String, IndexTemplateMetaData> getTemplates() {     return this.templates. }
false;public;0;3;;public ImmutableOpenMap<String, Custom> customs() {     return this.customs. }
false;public;0;3;;public ImmutableOpenMap<String, Custom> getCustoms() {     return this.customs. }
true;public;0;3;/**  * The collection of index deletions in the cluster.  */ ;/**  * The collection of index deletions in the cluster.  */ public IndexGraveyard indexGraveyard() {     return custom(IndexGraveyard.TYPE). }
false;public;1;3;;public <T extends Custom> T custom(String type) {     return (T) customs.get(type). }
true;public;0;3;/**  * Gets the total number of shards from all indices, including replicas and  * closed indices.  * @return The total number shards from all indices.  */ ;/**  * Gets the total number of shards from all indices, including replicas and  * closed indices.  * @return The total number shards from all indices.  */ public int getTotalNumberOfShards() {     return this.totalNumberOfShards. }
true;public;0;3;/**  * Gets the total number of open shards from all indices. Includes  * replicas, but does not include shards that are part of closed indices.  * @return The total number of open shards from all indices.  */ ;/**  * Gets the total number of open shards from all indices. Includes  * replicas, but does not include shards that are part of closed indices.  * @return The total number of open shards from all indices.  */ public int getTotalOpenIndexShards() {     return this.totalOpenIndexShards. }
true;public,static;1;3;/**  * Identifies whether the array containing type names given as argument refers to all types  * The empty or null array identifies all types  *  * @param types the array containing types  * @return true if the provided array maps to all types, false otherwise  */ ;/**  * Identifies whether the array containing type names given as argument refers to all types  * The empty or null array identifies all types  *  * @param types the array containing types  * @return true if the provided array maps to all types, false otherwise  */ public static boolean isAllTypes(String[] types) {     return types == null || types.length == 0 || isExplicitAllType(types). }
true;public,static;1;3;/**  * Identifies whether the array containing type names given as argument explicitly refers to all types  * The empty or null array doesn't explicitly map to all types  *  * @param types the array containing index names  * @return true if the provided array explicitly maps to all types, false otherwise  */ ;/**  * Identifies whether the array containing type names given as argument explicitly refers to all types  * The empty or null array doesn't explicitly map to all types  *  * @param types the array containing index names  * @return true if the provided array explicitly maps to all types, false otherwise  */ public static boolean isExplicitAllType(String[] types) {     return types != null && types.length == 1 && ALL.equals(types[0]). }
true;public;1;10;/**  * @param concreteIndex The concrete index to check if routing is required  * @return Whether routing is required according to the mapping for the specified index and type  */ ;/**  * @param concreteIndex The concrete index to check if routing is required  * @return Whether routing is required according to the mapping for the specified index and type  */ public boolean routingRequired(String concreteIndex) {     IndexMetaData indexMetaData = indices.get(concreteIndex).     if (indexMetaData != null) {         MappingMetaData mappingMetaData = indexMetaData.mapping().         if (mappingMetaData != null) {             return mappingMetaData.routing().required().         }     }     return false. }
false;public;0;4;;@Override public Iterator<IndexMetaData> iterator() {     return indices.valuesIt(). }
false;public,static;2;33;;public static boolean isGlobalStateEquals(MetaData metaData1, MetaData metaData2) {     if (!metaData1.coordinationMetaData.equals(metaData2.coordinationMetaData)) {         return false.     }     if (!metaData1.persistentSettings.equals(metaData2.persistentSettings)) {         return false.     }     if (!metaData1.templates.equals(metaData2.templates())) {         return false.     }     if (!metaData1.clusterUUID.equals(metaData2.clusterUUID)) {         return false.     }     if (metaData1.clusterUUIDCommitted != metaData2.clusterUUIDCommitted) {         return false.     }     // Check if any persistent metadata needs to be saved     int customCount1 = 0.     for (ObjectObjectCursor<String, Custom> cursor : metaData1.customs) {         if (cursor.value.context().contains(XContentContext.GATEWAY)) {             if (!cursor.value.equals(metaData2.custom(cursor.key)))                 return false.             customCount1++.         }     }     int customCount2 = 0.     for (ObjectCursor<Custom> cursor : metaData2.customs.values()) {         if (cursor.value.context().contains(XContentContext.GATEWAY)) {             customCount2++.         }     }     if (customCount1 != customCount2)         return false.     return true. }
false;public;1;4;;@Override public Diff<MetaData> diff(MetaData previousState) {     return new MetaDataDiff(previousState, this). }
false;public,static;1;3;;public static Diff<MetaData> readDiffFrom(StreamInput in) throws IOException {     return new MetaDataDiff(in). }
false;public,static;1;3;;public static MetaData fromXContent(XContentParser parser) throws IOException {     return Builder.fromXContent(parser). }
false;public;2;5;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     Builder.toXContent(this, builder, params).     return builder. }
false;public;1;16;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeString(clusterUUID).     if (out.getVersion().onOrAfter(Version.V_7_0_0)) {         out.writeBoolean(clusterUUIDCommitted).     }     out.writeLong(version).     if (out.getVersion().onOrAfter(Version.V_7_0_0)) {         coordinationMetaData.writeTo(out).     }     Settings.writeSettingsToStream(transientSettings, out).     Settings.writeSettingsToStream(persistentSettings, out).     indices.writeTo(out).     templates.writeTo(out).     customs.writeTo(out). }
false;public;1;14;;@Override public MetaData apply(MetaData part) {     Builder builder = builder().     builder.clusterUUID(clusterUUID).     builder.clusterUUIDCommitted(clusterUUIDCommitted).     builder.version(version).     builder.coordinationMetaData(coordinationMetaData).     builder.transientSettings(transientSettings).     builder.persistentSettings(persistentSettings).     builder.indices(indices.apply(part.indices)).     builder.templates(templates.apply(part.templates)).     builder.customs(customs.apply(part.customs)).     return builder.build(). }
false;public,static;1;27;;public static MetaData readFrom(StreamInput in) throws IOException {     Builder builder = new Builder().     builder.version = in.readLong().     builder.clusterUUID = in.readString().     if (in.getVersion().onOrAfter(Version.V_7_0_0)) {         builder.clusterUUIDCommitted = in.readBoolean().     }     if (in.getVersion().onOrAfter(Version.V_7_0_0)) {         builder.coordinationMetaData(new CoordinationMetaData(in)).     }     builder.transientSettings(readSettingsFromStream(in)).     builder.persistentSettings(readSettingsFromStream(in)).     int size = in.readVInt().     for (int i = 0. i < size. i++) {         builder.put(IndexMetaData.readFrom(in), false).     }     size = in.readVInt().     for (int i = 0. i < size. i++) {         builder.put(IndexTemplateMetaData.readFrom(in)).     }     int customSize = in.readVInt().     for (int i = 0. i < customSize. i++) {         Custom customIndexMetaData = in.readNamedWriteable(Custom.class).         builder.putCustom(customIndexMetaData.getWriteableName(), customIndexMetaData).     }     return builder.build(). }
false;public;1;34;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeLong(version).     out.writeString(clusterUUID).     if (out.getVersion().onOrAfter(Version.V_7_0_0)) {         out.writeBoolean(clusterUUIDCommitted).     }     if (out.getVersion().onOrAfter(Version.V_7_0_0)) {         coordinationMetaData.writeTo(out).     }     writeSettingsToStream(transientSettings, out).     writeSettingsToStream(persistentSettings, out).     out.writeVInt(indices.size()).     for (IndexMetaData indexMetaData : this) {         indexMetaData.writeTo(out).     }     out.writeVInt(templates.size()).     for (ObjectCursor<IndexTemplateMetaData> cursor : templates.values()) {         cursor.value.writeTo(out).     }     // filter out custom states not supported by the other node     int numberOfCustoms = 0.     for (final ObjectCursor<Custom> cursor : customs.values()) {         if (FeatureAware.shouldSerialize(out, cursor.value)) {             numberOfCustoms++.         }     }     out.writeVInt(numberOfCustoms).     for (final ObjectCursor<Custom> cursor : customs.values()) {         if (FeatureAware.shouldSerialize(out, cursor.value)) {             out.writeNamedWriteable(cursor.value).         }     } }
false;public,static;0;3;;public static Builder builder() {     return new Builder(). }
false;public,static;1;3;;public static Builder builder(MetaData metaData) {     return new Builder(metaData). }
false;public;1;7;;public Builder put(IndexMetaData.Builder indexMetaDataBuilder) {     // we know its a new one, increment the version and store     indexMetaDataBuilder.version(indexMetaDataBuilder.version() + 1).     IndexMetaData indexMetaData = indexMetaDataBuilder.build().     indices.put(indexMetaData.getIndex().getName(), indexMetaData).     return this. }
false;public;2;11;;public Builder put(IndexMetaData indexMetaData, boolean incrementVersion) {     if (indices.get(indexMetaData.getIndex().getName()) == indexMetaData) {         return this.     }     // if we put a new index metadata, increment its version     if (incrementVersion) {         indexMetaData = IndexMetaData.builder(indexMetaData).version(indexMetaData.getVersion() + 1).build().     }     indices.put(indexMetaData.getIndex().getName(), indexMetaData).     return this. }
false;public;1;3;;public IndexMetaData get(String index) {     return indices.get(index). }
false;public;1;12;;public IndexMetaData getSafe(Index index) {     IndexMetaData indexMetaData = get(index.getName()).     if (indexMetaData != null) {         if (indexMetaData.getIndexUUID().equals(index.getUUID())) {             return indexMetaData.         }         throw new IndexNotFoundException(index, new IllegalStateException("index uuid doesn't match expected: [" + index.getUUID() + "] but got: [" + indexMetaData.getIndexUUID() + "]")).     }     throw new IndexNotFoundException(index). }
false;public;1;4;;public Builder remove(String index) {     indices.remove(index).     return this. }
false;public;0;4;;public Builder removeAllIndices() {     indices.clear().     return this. }
false;public;1;4;;public Builder indices(ImmutableOpenMap<String, IndexMetaData> indices) {     this.indices.putAll(indices).     return this. }
false;public;1;3;;public Builder put(IndexTemplateMetaData.Builder template) {     return put(template.build()). }
false;public;1;4;;public Builder put(IndexTemplateMetaData template) {     templates.put(template.name(), template).     return this. }
false;public;1;4;;public Builder removeTemplate(String templateName) {     templates.remove(templateName).     return this. }
false;public;1;4;;public Builder templates(ImmutableOpenMap<String, IndexTemplateMetaData> templates) {     this.templates.putAll(templates).     return this. }
false;public;1;3;;public Custom getCustom(String type) {     return customs.get(type). }
false;public;2;4;;public Builder putCustom(String type, Custom custom) {     customs.put(type, custom).     return this. }
false;public;1;4;;public Builder removeCustom(String type) {     customs.remove(type).     return this. }
false;public;1;4;;public Builder customs(ImmutableOpenMap<String, Custom> customs) {     this.customs.putAll(customs).     return this. }
false;public;1;4;;public Builder indexGraveyard(final IndexGraveyard indexGraveyard) {     putCustom(IndexGraveyard.TYPE, indexGraveyard).     return this. }
false;public;0;4;;public IndexGraveyard indexGraveyard() {     IndexGraveyard graveyard = (IndexGraveyard) getCustom(IndexGraveyard.TYPE).     return graveyard. }
false;public;2;14;;public Builder updateSettings(Settings settings, String... indices) {     if (indices == null || indices.length == 0) {         indices = this.indices.keys().toArray(String.class).     }     for (String index : indices) {         IndexMetaData indexMetaData = this.indices.get(index).         if (indexMetaData == null) {             throw new IndexNotFoundException(index).         }         put(IndexMetaData.builder(indexMetaData).settings(Settings.builder().put(indexMetaData.getSettings()).put(settings))).     }     return this. }
true;public;2;10;/**  * Update the number of replicas for the specified indices.  *  * @param numberOfReplicas the number of replicas  * @param indices          the indices to update the number of replicas for  * @return the builder  */ ;/**  * Update the number of replicas for the specified indices.  *  * @param numberOfReplicas the number of replicas  * @param indices          the indices to update the number of replicas for  * @return the builder  */ public Builder updateNumberOfReplicas(final int numberOfReplicas, final String[] indices) {     for (String index : indices) {         IndexMetaData indexMetaData = this.indices.get(index).         if (indexMetaData == null) {             throw new IndexNotFoundException(index).         }         put(IndexMetaData.builder(indexMetaData).numberOfReplicas(numberOfReplicas)).     }     return this. }
false;public;1;4;;public Builder coordinationMetaData(CoordinationMetaData coordinationMetaData) {     this.coordinationMetaData = coordinationMetaData.     return this. }
false;public;0;3;;public Settings transientSettings() {     return this.transientSettings. }
false;public;1;4;;public Builder transientSettings(Settings settings) {     this.transientSettings = settings.     return this. }
false;public;0;3;;public Settings persistentSettings() {     return this.persistentSettings. }
false;public;1;4;;public Builder persistentSettings(Settings settings) {     this.persistentSettings = settings.     return this. }
false;public;1;4;;public Builder version(long version) {     this.version = version.     return this. }
false;public;1;4;;public Builder clusterUUID(String clusterUUID) {     this.clusterUUID = clusterUUID.     return this. }
false;public;1;4;;public Builder clusterUUIDCommitted(boolean clusterUUIDCommitted) {     this.clusterUUIDCommitted = clusterUUIDCommitted.     return this. }
false;public;0;6;;public Builder generateClusterUuidIfNeeded() {     if (clusterUUID.equals(UNKNOWN_CLUSTER_UUID)) {         clusterUUID = UUIDs.randomBase64UUID().     }     return this. }
false;public;0;54;;public MetaData build() {     // TODO: We should move these datastructures to IndexNameExpressionResolver, this will give the following benefits:     // 1) The datastructures will only be rebuilded when needed. Now during serializing we rebuild these datastructures     // while these datastructures aren't even used.     // 2) The aliasAndIndexLookup can be updated instead of rebuilding it all the time.     final Set<String> allIndices = new HashSet<>(indices.size()).     final List<String> allOpenIndices = new ArrayList<>().     final List<String> allClosedIndices = new ArrayList<>().     final Set<String> duplicateAliasesIndices = new HashSet<>().     for (ObjectCursor<IndexMetaData> cursor : indices.values()) {         final IndexMetaData indexMetaData = cursor.value.         final String name = indexMetaData.getIndex().getName().         boolean added = allIndices.add(name).         assert added : "double index named [" + name + "]".         if (indexMetaData.getState() == IndexMetaData.State.OPEN) {             allOpenIndices.add(indexMetaData.getIndex().getName()).         } else if (indexMetaData.getState() == IndexMetaData.State.CLOSE) {             allClosedIndices.add(indexMetaData.getIndex().getName()).         }         indexMetaData.getAliases().keysIt().forEachRemaining(duplicateAliasesIndices::add).     }     duplicateAliasesIndices.retainAll(allIndices).     if (duplicateAliasesIndices.isEmpty() == false) {         // iterate again and constructs a helpful message         ArrayList<String> duplicates = new ArrayList<>().         for (ObjectCursor<IndexMetaData> cursor : indices.values()) {             for (String alias : duplicateAliasesIndices) {                 if (cursor.value.getAliases().containsKey(alias)) {                     duplicates.add(alias + " (alias of " + cursor.value.getIndex() + ")").                 }             }         }         assert duplicates.size() > 0.         throw new IllegalStateException("index and alias names need to be unique, but the following duplicates were found [" + Strings.collectionToCommaDelimitedString(duplicates) + "]").     }     SortedMap<String, AliasOrIndex> aliasAndIndexLookup = Collections.unmodifiableSortedMap(buildAliasAndIndexLookup()).     // build all concrete indices arrays:     // TODO: I think we can remove these arrays. it isn't worth the effort, for operations on all indices.     // When doing an operation across all indices, most of the time is spent on actually going to all shards and     // do the required operations, the bottleneck isn't resolving expressions into concrete indices.     String[] allIndicesArray = allIndices.toArray(new String[allIndices.size()]).     String[] allOpenIndicesArray = allOpenIndices.toArray(new String[allOpenIndices.size()]).     String[] allClosedIndicesArray = allClosedIndices.toArray(new String[allClosedIndices.size()]).     return new MetaData(clusterUUID, clusterUUIDCommitted, version, coordinationMetaData, transientSettings, persistentSettings, indices.build(), templates.build(), customs.build(), allIndicesArray, allOpenIndicesArray, allClosedIndicesArray, aliasAndIndexLookup). }
false;private;0;24;;private SortedMap<String, AliasOrIndex> buildAliasAndIndexLookup() {     SortedMap<String, AliasOrIndex> aliasAndIndexLookup = new TreeMap<>().     for (ObjectCursor<IndexMetaData> cursor : indices.values()) {         IndexMetaData indexMetaData = cursor.value.         AliasOrIndex existing = aliasAndIndexLookup.put(indexMetaData.getIndex().getName(), new AliasOrIndex.Index(indexMetaData)).         assert existing == null : "duplicate for " + indexMetaData.getIndex().         for (ObjectObjectCursor<String, AliasMetaData> aliasCursor : indexMetaData.getAliases()) {             AliasMetaData aliasMetaData = aliasCursor.value.             aliasAndIndexLookup.compute(aliasMetaData.getAlias(), (aliasName, alias) -> {                 if (alias == null) {                     return new AliasOrIndex.Alias(aliasMetaData, indexMetaData).                 } else {                     assert alias instanceof AliasOrIndex.Alias : alias.getClass().getName().                     ((AliasOrIndex.Alias) alias).addIndex(indexMetaData).                     return alias.                 }             }).         }     }     aliasAndIndexLookup.values().stream().filter(AliasOrIndex::isAlias).forEach(alias -> ((AliasOrIndex.Alias) alias).computeAndValidateWriteIndex()).     return aliasAndIndexLookup. }
false;public,static;1;7;;public static String toXContent(MetaData metaData) throws IOException {     XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON).     builder.startObject().     toXContent(metaData, builder, ToXContent.EMPTY_PARAMS).     builder.endObject().     return Strings.toString(builder). }
false;public,static;3;48;;public static void toXContent(MetaData metaData, XContentBuilder builder, ToXContent.Params params) throws IOException {     XContentContext context = XContentContext.valueOf(params.param(CONTEXT_MODE_PARAM, "API")).     builder.startObject("meta-data").     builder.field("version", metaData.version()).     builder.field("cluster_uuid", metaData.clusterUUID).     builder.field("cluster_uuid_committed", metaData.clusterUUIDCommitted).     builder.startObject("cluster_coordination").     metaData.coordinationMetaData().toXContent(builder, params).     builder.endObject().     if (!metaData.persistentSettings().isEmpty()) {         builder.startObject("settings").         metaData.persistentSettings().toXContent(builder, new MapParams(Collections.singletonMap("flat_settings", "true"))).         builder.endObject().     }     if (context == XContentContext.API && !metaData.transientSettings().isEmpty()) {         builder.startObject("transient_settings").         metaData.transientSettings().toXContent(builder, new MapParams(Collections.singletonMap("flat_settings", "true"))).         builder.endObject().     }     builder.startObject("templates").     for (ObjectCursor<IndexTemplateMetaData> cursor : metaData.templates().values()) {         IndexTemplateMetaData.Builder.toXContentWithTypes(cursor.value, builder, params).     }     builder.endObject().     if (context == XContentContext.API && !metaData.indices().isEmpty()) {         builder.startObject("indices").         for (IndexMetaData indexMetaData : metaData) {             IndexMetaData.Builder.toXContent(indexMetaData, builder, params).         }         builder.endObject().     }     for (ObjectObjectCursor<String, Custom> cursor : metaData.customs()) {         if (cursor.value.context().contains(context)) {             builder.startObject(cursor.key).             cursor.value.toXContent(builder, params).             builder.endObject().         }     }     builder.endObject(). }
false;public,static;1;68;;public static MetaData fromXContent(XContentParser parser) throws IOException {     Builder builder = new Builder().     // we might get here after the meta-data element, or on a fresh parser     XContentParser.Token token = parser.currentToken().     String currentFieldName = parser.currentName().     if (!"meta-data".equals(currentFieldName)) {         token = parser.nextToken().         if (token == XContentParser.Token.START_OBJECT) {             // move to the field name (meta-data)             token = parser.nextToken().             if (token != XContentParser.Token.FIELD_NAME) {                 throw new IllegalArgumentException("Expected a field name but got " + token).             }             // move to the next object             token = parser.nextToken().         }         currentFieldName = parser.currentName().     }     if (!"meta-data".equals(parser.currentName())) {         throw new IllegalArgumentException("Expected [meta-data] as a field name but got " + currentFieldName).     }     if (token != XContentParser.Token.START_OBJECT) {         throw new IllegalArgumentException("Expected a START_OBJECT but got " + token).     }     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token == XContentParser.Token.START_OBJECT) {             if ("cluster_coordination".equals(currentFieldName)) {                 builder.coordinationMetaData(CoordinationMetaData.fromXContent(parser)).             } else if ("settings".equals(currentFieldName)) {                 builder.persistentSettings(Settings.fromXContent(parser)).             } else if ("indices".equals(currentFieldName)) {                 while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {                     builder.put(IndexMetaData.Builder.fromXContent(parser), false).                 }             } else if ("templates".equals(currentFieldName)) {                 while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {                     builder.put(IndexTemplateMetaData.Builder.fromXContent(parser, parser.currentName())).                 }             } else {                 try {                     Custom custom = parser.namedObject(Custom.class, currentFieldName, null).                     builder.putCustom(custom.getWriteableName(), custom).                 } catch (NamedObjectNotFoundException ex) {                     logger.warn("Skipping unknown custom object with type {}", currentFieldName).                     parser.skipChildren().                 }             }         } else if (token.isValue()) {             if ("version".equals(currentFieldName)) {                 builder.version = parser.longValue().             } else if ("cluster_uuid".equals(currentFieldName) || "uuid".equals(currentFieldName)) {                 builder.clusterUUID = parser.text().             } else if ("cluster_uuid_committed".equals(currentFieldName)) {                 builder.clusterUUIDCommitted = parser.booleanValue().             } else {                 throw new IllegalArgumentException("Unexpected field [" + currentFieldName + "]").             }         } else {             throw new IllegalArgumentException("Unexpected token " + token).         }     }     return builder.build(). }
false;public;2;4;;@Override public void toXContent(XContentBuilder builder, MetaData state) throws IOException {     Builder.toXContent(state, builder, FORMAT_PARAMS). }
false;public;1;4;;@Override public MetaData fromXContent(XContentParser parser) throws IOException {     return Builder.fromXContent(parser). }
