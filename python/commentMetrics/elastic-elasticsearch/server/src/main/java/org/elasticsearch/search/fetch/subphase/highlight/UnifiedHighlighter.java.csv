commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public boolean canHighlight(MappedFieldType fieldType) {     return true. }
false;public;1;84;;@Override public HighlightField highlight(HighlighterContext highlighterContext) {     MappedFieldType fieldType = highlighterContext.fieldType.     SearchContextHighlight.Field field = highlighterContext.field.     SearchContext context = highlighterContext.context.     FetchSubPhase.HitContext hitContext = highlighterContext.hitContext.     Encoder encoder = field.fieldOptions().encoder().equals("html") ? HighlightUtils.Encoders.HTML : HighlightUtils.Encoders.DEFAULT.     final int maxAnalyzedOffset = context.indexShard().indexSettings().getHighlightMaxAnalyzedOffset().     List<Snippet> snippets = new ArrayList<>().     int numberOfFragments.     try {         final Analyzer analyzer = getAnalyzer(context.mapperService().documentMapper(hitContext.hit().getType()), fieldType).         List<Object> fieldValues = loadFieldValues(fieldType, field, context, hitContext).         if (fieldValues.size() == 0) {             return null.         }         final PassageFormatter passageFormatter = getPassageFormatter(field, encoder).         final IndexSearcher searcher = new IndexSearcher(hitContext.reader()).         final CustomUnifiedHighlighter highlighter.         final String fieldValue = mergeFieldValues(fieldValues, MULTIVAL_SEP_CHAR).         final OffsetSource offsetSource = getOffsetSource(fieldType).         if ((offsetSource == OffsetSource.ANALYSIS) && (fieldValue.length() > maxAnalyzedOffset)) {             throw new IllegalArgumentException("The length of [" + highlighterContext.fieldName + "] field of [" + hitContext.hit().getId() + "] doc of [" + context.indexShard().shardId().getIndexName() + "] index " + "has exceeded [" + maxAnalyzedOffset + "] - maximum allowed to be analyzed for highlighting. " + "This maximum can be set by changing the [" + IndexSettings.MAX_ANALYZED_OFFSET_SETTING.getKey() + "] index level setting. " + "For large texts, indexing with offsets or term vectors is recommended!").         }         if (field.fieldOptions().numberOfFragments() == 0) {             // we use a control char to separate values, which is the only char that the custom break iterator             // breaks the text on, so we don't lose the distinction between the different values of a field and we             // get back a snippet per value             CustomSeparatorBreakIterator breakIterator = new CustomSeparatorBreakIterator(MULTIVAL_SEP_CHAR).             highlighter = new CustomUnifiedHighlighter(searcher, analyzer, offsetSource, passageFormatter, field.fieldOptions().boundaryScannerLocale(), breakIterator, fieldValue, field.fieldOptions().noMatchSize()).             // we are highlighting the whole content, one snippet per value             numberOfFragments = fieldValues.size().         } else {             // using paragraph separator we make sure that each field value holds a discrete passage for highlighting             BreakIterator bi = getBreakIterator(field).             highlighter = new CustomUnifiedHighlighter(searcher, analyzer, offsetSource, passageFormatter, field.fieldOptions().boundaryScannerLocale(), bi, fieldValue, field.fieldOptions().noMatchSize()).             numberOfFragments = field.fieldOptions().numberOfFragments().         }         if (field.fieldOptions().requireFieldMatch()) {             final String fieldName = highlighterContext.fieldName.             highlighter.setFieldMatcher((name) -> fieldName.equals(name)).         } else {             highlighter.setFieldMatcher((name) -> true).         }         Snippet[] fieldSnippets = highlighter.highlightField(highlighterContext.fieldName, highlighterContext.query, hitContext.docId(), numberOfFragments).         for (Snippet fieldSnippet : fieldSnippets) {             if (Strings.hasText(fieldSnippet.getText())) {                 snippets.add(fieldSnippet).             }         }     } catch (IOException e) {         throw new FetchPhaseExecutionException(context, "Failed to highlight field [" + highlighterContext.fieldName + "]", e).     }     snippets = filterSnippets(snippets, field.fieldOptions().numberOfFragments()).     if (field.fieldOptions().scoreOrdered()) {         // let's sort the snippets by score if needed         CollectionUtil.introSort(snippets, (o1, o2) -> Double.compare(o2.getScore(), o1.getScore())).     }     String[] fragments = new String[snippets.size()].     for (int i = 0. i < fragments.length. i++) {         fragments[i] = snippets.get(i).getText().     }     if (fragments.length > 0) {         return new HighlightField(highlighterContext.fieldName, Text.convertFromStringArray(fragments)).     }     return null. }
false;protected;2;5;;protected PassageFormatter getPassageFormatter(SearchContextHighlight.Field field, Encoder encoder) {     CustomPassageFormatter passageFormatter = new CustomPassageFormatter(field.fieldOptions().preTags()[0], field.fieldOptions().postTags()[0], encoder).     return passageFormatter. }
false;protected;2;3;;protected Analyzer getAnalyzer(DocumentMapper docMapper, MappedFieldType type) {     return HighlightUtils.getAnalyzer(docMapper, type). }
false;protected;4;8;;protected List<Object> loadFieldValues(MappedFieldType fieldType, SearchContextHighlight.Field field, SearchContext context, FetchSubPhase.HitContext hitContext) throws IOException {     List<Object> fieldValues = HighlightUtils.loadFieldValues(field, fieldType, context, hitContext).     fieldValues = fieldValues.stream().map((s) -> convertFieldValue(fieldType, s)).collect(Collectors.toList()).     return fieldValues. }
false;protected;1;22;;protected BreakIterator getBreakIterator(SearchContextHighlight.Field field) {     final SearchContextHighlight.FieldOptions fieldOptions = field.fieldOptions().     final Locale locale = fieldOptions.boundaryScannerLocale() != null ? fieldOptions.boundaryScannerLocale() : Locale.ROOT.     final HighlightBuilder.BoundaryScannerType type = fieldOptions.boundaryScannerType() != null ? fieldOptions.boundaryScannerType() : HighlightBuilder.BoundaryScannerType.SENTENCE.     int maxLen = fieldOptions.fragmentCharSize().     switch(type) {         case SENTENCE:             if (maxLen > 0) {                 return BoundedBreakIteratorScanner.getSentence(locale, maxLen).             }             return BreakIterator.getSentenceInstance(locale).         case WORD:             // ignore maxLen             return BreakIterator.getWordInstance(locale).         default:             throw new IllegalArgumentException("Invalid boundary scanner type: " + type.toString()).     } }
false;protected,static;2;34;;protected static List<Snippet> filterSnippets(List<Snippet> snippets, int numberOfFragments) {     // We need to filter the snippets as due to no_match_size we could have     // either highlighted snippets or non highlighted ones and we don't want to mix those up     List<Snippet> filteredSnippets = new ArrayList<>(snippets.size()).     for (Snippet snippet : snippets) {         if (snippet.isHighlighted()) {             filteredSnippets.add(snippet).         }     }     // otherwise we return the first non highlighted one if available     if (filteredSnippets.size() == 0) {         if (snippets.size() > 0) {             Snippet snippet = snippets.get(0).             // we need to return the first sentence of the content rather than the whole content             if (numberOfFragments == 0) {                 BreakIterator bi = BreakIterator.getSentenceInstance(Locale.ROOT).                 String text = snippet.getText().                 bi.setText(text).                 int next = bi.next().                 if (next != BreakIterator.DONE) {                     String newText = text.substring(0, next).trim().                     snippet = new Snippet(newText, snippet.getScore(), snippet.isHighlighted()).                 }             }             filteredSnippets.add(snippet).         }     }     return filteredSnippets. }
false;protected,static;2;7;;protected static String convertFieldValue(MappedFieldType type, Object value) {     if (value instanceof BytesRef) {         return type.valueForDisplay(value).toString().     } else {         return value.toString().     } }
false;protected,static;2;6;;protected static String mergeFieldValues(List<Object> fieldValues, char valuesSeparator) {     // postings highlighter accepts all values in a single string, as offsets etc. need to match with content     // loaded from stored fields, we merge all values using a proper separator     String rawValue = Strings.collectionToDelimitedString(fieldValues, String.valueOf(valuesSeparator)).     return rawValue.substring(0, Math.min(rawValue.length(), Integer.MAX_VALUE - 1)). }
false;protected;1;9;;protected OffsetSource getOffsetSource(MappedFieldType fieldType) {     if (fieldType.indexOptions() == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) {         return fieldType.storeTermVectors() ? OffsetSource.POSTINGS_WITH_TERM_VECTORS : OffsetSource.POSTINGS.     }     if (fieldType.storeTermVectorOffsets()) {         return OffsetSource.TERM_VECTORS.     }     return OffsetSource.ANALYSIS. }
