commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public String getTaskName() {     return taskName. }
true;public;2;8;/**  * Returns the node id where the params has to be executed,  * <p>  * The default implementation returns the least loaded data node  */ ;/**  * Returns the node id where the params has to be executed,  * <p>  * The default implementation returns the least loaded data node  */ public Assignment getAssignment(Params params, ClusterState clusterState) {     DiscoveryNode discoveryNode = selectLeastLoadedNode(clusterState, DiscoveryNode::isDataNode).     if (discoveryNode == null) {         return NO_NODE_FOUND.     } else {         return new Assignment(discoveryNode.getId(), "").     } }
true;protected;2;19;/**  * Finds the least loaded node that satisfies the selector criteria  */ ;/**  * Finds the least loaded node that satisfies the selector criteria  */ protected DiscoveryNode selectLeastLoadedNode(ClusterState clusterState, Predicate<DiscoveryNode> selector) {     long minLoad = Long.MAX_VALUE.     DiscoveryNode minLoadedNode = null.     PersistentTasksCustomMetaData persistentTasks = clusterState.getMetaData().custom(PersistentTasksCustomMetaData.TYPE).     for (DiscoveryNode node : clusterState.getNodes()) {         if (selector.test(node)) {             if (persistentTasks == null) {                 // We don't have any task running yet, pick the first available node                 return node.             }             long numberOfTasks = persistentTasks.getNumberOfTasksOnNode(node.getId(), taskName).             if (minLoad > numberOfTasks) {                 minLoad = numberOfTasks.                 minLoadedNode = node.             }         }     }     return minLoadedNode. }
true;public;2;1;/**  * Checks the current cluster state for compatibility with the params  * <p>  * Throws an exception if the supplied params cannot be executed on the cluster in the current state.  */ ;/**  * Checks the current cluster state for compatibility with the params  * <p>  * Throws an exception if the supplied params cannot be executed on the cluster in the current state.  */ public void validate(Params params, ClusterState clusterState) { }
true;protected;6;4;/**  * Creates a AllocatedPersistentTask for communicating with task manager  */ ;/**  * Creates a AllocatedPersistentTask for communicating with task manager  */ protected AllocatedPersistentTask createTask(long id, String type, String action, TaskId parentTaskId, PersistentTask<Params> taskInProgress, Map<String, String> headers) {     return new AllocatedPersistentTask(id, type, action, getDescription(taskInProgress), parentTaskId, headers). }
true;protected;1;3;/**  * Returns task description that will be available via task manager  */ ;/**  * Returns task description that will be available via task manager  */ protected String getDescription(PersistentTask<Params> taskInProgress) {     return "id=" + taskInProgress.getId(). }
true;protected,abstract;3;1;/**  * This operation will be executed on the executor node.  * <p>  * NOTE: The nodeOperation has to throw an exception, trigger task.markAsCompleted() or task.completeAndNotifyIfNeeded() methods to  * indicate that the persistent task has finished.  */ ;/**  * This operation will be executed on the executor node.  * <p>  * NOTE: The nodeOperation has to throw an exception, trigger task.markAsCompleted() or task.completeAndNotifyIfNeeded() methods to  * indicate that the persistent task has finished.  */ protected abstract void nodeOperation(AllocatedPersistentTask task, Params params, @Nullable PersistentTaskState state).
false;public;0;3;;public String getExecutor() {     return executor. }
