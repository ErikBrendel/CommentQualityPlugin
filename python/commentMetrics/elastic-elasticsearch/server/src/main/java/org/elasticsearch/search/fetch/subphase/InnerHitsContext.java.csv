commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public Map<String, InnerHitSubContext> getInnerHits() {     return innerHits. }
false;public;1;8;;public void addInnerHitDefinition(InnerHitSubContext innerHit) {     if (innerHits.containsKey(innerHit.getName())) {         throw new IllegalArgumentException("inner_hit definition with the name [" + innerHit.getName() + "] already exists. Use a different inner_hit name or define one explicitly").     }     innerHits.put(innerHit.getName(), innerHit). }
false;public,abstract;1;1;;public abstract TopDocsAndMaxScore[] topDocs(SearchHit[] hits) throws IOException.
false;public;0;3;;public String getName() {     return name. }
false;public;0;4;;@Override public InnerHitsContext innerHits() {     return childInnerHits. }
false;public;1;3;;public void setChildInnerHits(Map<String, InnerHitSubContext> childInnerHits) {     this.childInnerHits = new InnerHitsContext(childInnerHits). }
false;protected;0;5;;protected Weight createInnerHitQueryWeight() throws IOException {     final boolean needsScores = size() != 0 && (sort() == null || sort().sort.needsScores()).     return context.searcher().createWeight(context.searcher().rewrite(query()), needsScores ? ScoreMode.COMPLETE : ScoreMode.COMPLETE_NO_SCORES, 1f). }
false;public;0;3;;public SearchContext parentSearchContext() {     return context. }
false;public;0;3;;public Uid getUid() {     return uid. }
false;public;1;3;;public void setUid(Uid uid) {     this.uid = uid. }
false;public,static;4;37;;public static void intersect(Weight weight, Weight innerHitQueryWeight, Collector collector, LeafReaderContext ctx) throws IOException {     ScorerSupplier scorerSupplier = weight.scorerSupplier(ctx).     if (scorerSupplier == null) {         return.     }     // use low leadCost since this scorer will be consumed on a minority of documents     Scorer scorer = scorerSupplier.get(0).     ScorerSupplier innerHitQueryScorerSupplier = innerHitQueryWeight.scorerSupplier(ctx).     if (innerHitQueryScorerSupplier == null) {         return.     }     // use low loadCost since this scorer will be consumed on a minority of documents     Scorer innerHitQueryScorer = innerHitQueryScorerSupplier.get(0).     final LeafCollector leafCollector.     try {         leafCollector = collector.getLeafCollector(ctx).         // Just setting the innerHitQueryScorer is ok, because that is the actual scoring part of the query         leafCollector.setScorer(innerHitQueryScorer).     } catch (CollectionTerminatedException e) {         return.     }     try {         Bits acceptDocs = ctx.reader().getLiveDocs().         DocIdSetIterator iterator = ConjunctionDISI.intersectIterators(Arrays.asList(innerHitQueryScorer.iterator(), scorer.iterator())).         for (int docId = iterator.nextDoc(). docId < DocIdSetIterator.NO_MORE_DOCS. docId = iterator.nextDoc()) {             if (acceptDocs == null || acceptDocs.get(docId)) {                 leafCollector.collect(docId).             }         }     } catch (CollectionTerminatedException e) {     // ignore and continue     } }
