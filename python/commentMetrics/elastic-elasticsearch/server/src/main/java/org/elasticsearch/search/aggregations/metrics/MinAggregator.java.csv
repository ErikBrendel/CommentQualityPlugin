commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public ScoreMode scoreMode() {     return valuesSource != null && valuesSource.needsScores() ? ScoreMode.COMPLETE : ScoreMode.COMPLETE_NO_SCORES. }
false;public;2;14;;@Override public void collect(int doc, long bucket) throws IOException {     if (bucket >= mins.size()) {         long from = mins.size().         mins = bigArrays.grow(mins, bucket + 1).         mins.fill(from, mins.size(), Double.POSITIVE_INFINITY).     }     if (values.advanceExact(doc)) {         final double value = values.doubleValue().         double min = mins.get(bucket).         min = Math.min(min, value).         mins.set(bucket, min).     } }
false;public;2;47;;@Override public LeafBucketCollector getLeafCollector(LeafReaderContext ctx, final LeafBucketCollector sub) throws IOException {     if (valuesSource == null) {         if (parent == null) {             return LeafBucketCollector.NO_OP_COLLECTOR.         } else {             // we have no parent and the values source is empty so we can skip collecting hits.             throw new CollectionTerminatedException().         }     }     if (pointConverter != null) {         Number segMin = findLeafMinValue(ctx.reader(), pointField, pointConverter).         if (segMin != null) {             /**              * There is no parent aggregator (see {@link MinAggregator#getPointReaderOrNull}              * so the ordinal for the bucket is always 0.              */             double min = mins.get(0).             min = Math.min(min, segMin.doubleValue()).             mins.set(0, min).             // the minimum value has been extracted, we don't need to collect hits on this segment.             throw new CollectionTerminatedException().         }     }     final BigArrays bigArrays = context.bigArrays().     final SortedNumericDoubleValues allValues = valuesSource.doubleValues(ctx).     final NumericDoubleValues values = MultiValueMode.MIN.select(allValues).     return new LeafBucketCollectorBase(sub, allValues) {          @Override         public void collect(int doc, long bucket) throws IOException {             if (bucket >= mins.size()) {                 long from = mins.size().                 mins = bigArrays.grow(mins, bucket + 1).                 mins.fill(from, mins.size(), Double.POSITIVE_INFINITY).             }             if (values.advanceExact(doc)) {                 final double value = values.doubleValue().                 double min = mins.get(bucket).                 min = Math.min(min, value).                 mins.set(bucket, min).             }         }     }. }
false;public;1;7;;@Override public double metric(long owningBucketOrd) {     if (valuesSource == null || owningBucketOrd >= mins.size()) {         return Double.POSITIVE_INFINITY.     }     return mins.get(owningBucketOrd). }
false;public;1;7;;@Override public InternalAggregation buildAggregation(long bucket) {     if (valuesSource == null || bucket >= mins.size()) {         return buildEmptyAggregation().     }     return new InternalMin(name, mins.get(bucket), format, pipelineAggregators(), metaData()). }
false;public;0;4;;@Override public InternalAggregation buildEmptyAggregation() {     return new InternalMin(name, Double.POSITIVE_INFINITY, format, pipelineAggregators(), metaData()). }
false;public;0;4;;@Override public void doClose() {     Releasables.close(mins). }
true;static;3;24;/**  * Returns a converter for point values if early termination is applicable to  * the context or <code>null</code> otherwise.  *  * @param context The {@link SearchContext} of the aggregation.  * @param parent The parent aggregator.  * @param config The config for the values source metric.  */ ;/**  * Returns a converter for point values if early termination is applicable to  * the context or <code>null</code> otherwise.  *  * @param context The {@link SearchContext} of the aggregation.  * @param parent The parent aggregator.  * @param config The config for the values source metric.  */ static Function<byte[], Number> getPointReaderOrNull(SearchContext context, Aggregator parent, ValuesSourceConfig<ValuesSource.Numeric> config) {     if (context.query() != null && context.query().getClass() != MatchAllDocsQuery.class) {         return null.     }     if (parent != null) {         return null.     }     if (config.fieldContext() != null && config.script() == null) {         MappedFieldType fieldType = config.fieldContext().fieldType().         if (fieldType == null || fieldType.indexOptions() == IndexOptions.NONE) {             return null.         }         Function<byte[], Number> converter = null.         if (fieldType instanceof NumberFieldMapper.NumberFieldType) {             converter = ((NumberFieldMapper.NumberFieldType) fieldType)::parsePoint.         } else if (fieldType.getClass() == DateFieldMapper.DateFieldType.class) {             converter = (in) -> LongPoint.decodeDimension(in, 0).         }         return converter.     }     return null. }
false;public;1;4;;@Override public void visit(int docID) {     throw new UnsupportedOperationException(). }
false;public;2;8;;@Override public void visit(int docID, byte[] packedValue) {     if (liveDocs.get(docID)) {         result[0] = converter.apply(packedValue).         // this is the first leaf with a live doc so the value is the minimum for this segment.         throw new CollectionTerminatedException().     } }
false;public;2;4;;@Override public PointValues.Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {     return PointValues.Relation.CELL_CROSSES_QUERY. }
true;static;3;34;/**  * Returns the minimum value indexed in the <code>fieldName</code> field or <code>null</code>  * if the value cannot be inferred from the indexed {@link PointValues}.  */ ;/**  * Returns the minimum value indexed in the <code>fieldName</code> field or <code>null</code>  * if the value cannot be inferred from the indexed {@link PointValues}.  */ static Number findLeafMinValue(LeafReader reader, String fieldName, Function<byte[], Number> converter) throws IOException {     final PointValues pointValues = reader.getPointValues(fieldName).     if (pointValues == null) {         return null.     }     final Bits liveDocs = reader.getLiveDocs().     if (liveDocs == null) {         return converter.apply(pointValues.getMinPackedValue()).     }     final Number[] result = new Number[1].     try {         pointValues.intersect(new PointValues.IntersectVisitor() {              @Override             public void visit(int docID) {                 throw new UnsupportedOperationException().             }              @Override             public void visit(int docID, byte[] packedValue) {                 if (liveDocs.get(docID)) {                     result[0] = converter.apply(packedValue).                     // this is the first leaf with a live doc so the value is the minimum for this segment.                     throw new CollectionTerminatedException().                 }             }              @Override             public PointValues.Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {                 return PointValues.Relation.CELL_CROSSES_QUERY.             }         }).     } catch (CollectionTerminatedException e) {     }     return result[0]. }
