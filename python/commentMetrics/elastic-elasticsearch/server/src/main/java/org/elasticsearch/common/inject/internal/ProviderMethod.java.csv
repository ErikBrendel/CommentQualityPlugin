commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public Key<T> getKey() {     return key. }
false;public;0;3;;public Method getMethod() {     return method. }
true;public;0;3;// exposed for GIN ;// exposed for GIN public Object getInstance() {     return instance. }
false;public;1;15;;public void configure(Binder binder) {     binder = binder.withSource(method).     if (scopeAnnotation != null) {         binder.bind(key).toProvider(this).in(scopeAnnotation).     } else {         binder.bind(key).toProvider(this).     }     if (exposed) {         // the cast is safe 'cause the only binder we have implements PrivateBinder. If there's a         // misplaced @Exposed, calling this will add an error to the binder's error queue         ((PrivateBinder) binder).expose(key).     } }
false;public;0;18;;@Override public T get() {     Object[] parameters = new Object[parameterProviders.size()].     for (int i = 0. i < parameters.length. i++) {         parameters[i] = parameterProviders.get(i).get().     }     try {         // We know this cast is safe because T is the method's return type.         @SuppressWarnings({ "unchecked" })         T result = (T) method.invoke(instance, parameters).         return result.     } catch (IllegalAccessException e) {         throw new AssertionError(e).     } catch (InvocationTargetException e) {         throw new RuntimeException(e).     } }
false;public;0;4;;@Override public Set<Dependency<?>> getDependencies() {     return dependencies. }
