commented;modifiers;parameterAmount;loc;comment;code
true;public;0;8;/**  * Clears any state with the FileWatcher, making all files show up as new  */ ;/**  * Clears any state with the FileWatcher, making all files show up as new  */ public void clearState() {     rootFileObserver = new FileObserver(file).     try {         rootFileObserver.init(false).     } catch (IOException e) {     // ignore IOException     } }
false;protected;0;4;;@Override protected void doInit() throws IOException {     rootFileObserver.init(true). }
false;protected;0;4;;@Override protected void doCheckAndNotify() throws IOException {     rootFileObserver.checkAndNotify(). }
false;public;0;68;;public void checkAndNotify() throws IOException {     boolean prevExists = exists.     boolean prevIsDirectory = isDirectory.     long prevLength = length.     long prevLastModified = lastModified.     exists = Files.exists(file).     // TODO we might use the new NIO2 API to get real notification?     if (exists) {         BasicFileAttributes attributes = Files.readAttributes(file, BasicFileAttributes.class).         isDirectory = attributes.isDirectory().         if (isDirectory) {             length = 0.             lastModified = 0.         } else {             length = attributes.size().             lastModified = attributes.lastModifiedTime().toMillis().         }     } else {         isDirectory = false.         length = 0.         lastModified = 0.     }     // Perform notifications and update children for the current file     if (prevExists) {         if (exists) {             if (isDirectory) {                 if (prevIsDirectory) {                     // Remained a directory                     updateChildren().                 } else {                     // File replaced by directory                     onFileDeleted().                     onDirectoryCreated(false).                 }             } else {                 if (prevIsDirectory) {                     // Directory replaced by file                     onDirectoryDeleted().                     onFileCreated(false).                 } else {                     // Remained file                     if (prevLastModified != lastModified || prevLength != length) {                         onFileChanged().                     }                 }             }         } else {             // Deleted             if (prevIsDirectory) {                 onDirectoryDeleted().             } else {                 onFileDeleted().             }         }     } else {         // Created         if (exists) {             if (isDirectory) {                 onDirectoryCreated(false).             } else {                 onFileCreated(false).             }         }     } }
false;private;1;14;;private void init(boolean initial) throws IOException {     exists = Files.exists(file).     if (exists) {         BasicFileAttributes attributes = Files.readAttributes(file, BasicFileAttributes.class).         isDirectory = attributes.isDirectory().         if (isDirectory) {             onDirectoryCreated(initial).         } else {             length = attributes.size().             lastModified = attributes.lastModifiedTime().toMillis().             onFileCreated(initial).         }     } }
false;private;2;5;;private FileObserver createChild(Path file, boolean initial) throws IOException {     FileObserver child = new FileObserver(file).     child.init(initial).     return child. }
false;private;0;5;;private Path[] listFiles() throws IOException {     final Path[] files = FileSystemUtils.files(file).     Arrays.sort(files).     return files. }
false;private;1;12;;private FileObserver[] listChildren(boolean initial) throws IOException {     Path[] files = listFiles().     if (files != null && files.length > 0) {         FileObserver[] children = new FileObserver[files.length].         for (int i = 0. i < files.length. i++) {             children[i] = createChild(files[i], initial).         }         return children.     } else {         return EMPTY_DIRECTORY.     } }
false;private;0;45;;private void updateChildren() throws IOException {     Path[] files = listFiles().     if (files != null && files.length > 0) {         FileObserver[] newChildren = new FileObserver[files.length].         int child = 0.         int file = 0.         while (file < files.length || child < children.length) {             int compare.             if (file >= files.length) {                 compare = -1.             } else if (child >= children.length) {                 compare = 1.             } else {                 compare = children[child].file.compareTo(files[file]).             }             if (compare == 0) {                 // Same file copy it and update                 children[child].checkAndNotify().                 newChildren[file] = children[child].                 file++.                 child++.             } else {                 if (compare > 0) {                     // This child doesn't appear in the old list - init it                     newChildren[file] = createChild(files[file], false).                     file++.                 } else {                     // The child from the old list is missing in the new list                     // Delete it                     deleteChild(child).                     child++.                 }             }         }         children = newChildren.     } else {         // No files - delete all children         for (int child = 0. child < children.length. child++) {             deleteChild(child).         }         children = EMPTY_DIRECTORY.     } }
false;private;1;9;;private void deleteChild(int child) {     if (children[child].exists) {         if (children[child].isDirectory) {             children[child].onDirectoryDeleted().         } else {             children[child].onFileDeleted().         }     } }
false;private;1;13;;private void onFileCreated(boolean initial) {     for (FileChangesListener listener : listeners()) {         try {             if (initial) {                 listener.onFileInit(file).             } else {                 listener.onFileCreated(file).             }         } catch (Exception e) {             logger.warn("cannot notify file changes listener", e).         }     } }
false;private;0;9;;private void onFileDeleted() {     for (FileChangesListener listener : listeners()) {         try {             listener.onFileDeleted(file).         } catch (Exception e) {             logger.warn("cannot notify file changes listener", e).         }     } }
false;private;0;10;;private void onFileChanged() {     for (FileChangesListener listener : listeners()) {         try {             listener.onFileChanged(file).         } catch (Exception e) {             logger.warn("cannot notify file changes listener", e).         }     } }
false;private;1;14;;private void onDirectoryCreated(boolean initial) throws IOException {     for (FileChangesListener listener : listeners()) {         try {             if (initial) {                 listener.onDirectoryInit(file).             } else {                 listener.onDirectoryCreated(file).             }         } catch (Exception e) {             logger.warn("cannot notify file changes listener", e).         }     }     children = listChildren(initial). }
false;private;0;13;;private void onDirectoryDeleted() {     // First delete all children     for (int child = 0. child < children.length. child++) {         deleteChild(child).     }     for (FileChangesListener listener : listeners()) {         try {             listener.onDirectoryDeleted(file).         } catch (Exception e) {             logger.warn("cannot notify file changes listener", e).         }     } }
