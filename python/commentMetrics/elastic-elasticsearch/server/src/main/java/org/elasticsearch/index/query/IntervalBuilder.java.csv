commented;modifiers;parameterAmount;loc;comment;code
false;public;3;6;;public IntervalsSource analyzeText(String query, int maxGaps, boolean ordered) throws IOException {     try (TokenStream ts = analyzer.tokenStream(field, query).         CachingTokenFilter stream = new CachingTokenFilter(ts)) {         return analyzeText(stream, maxGaps, ordered).     } }
false;protected;3;53;;protected IntervalsSource analyzeText(CachingTokenFilter stream, int maxGaps, boolean ordered) throws IOException {     TermToBytesRefAttribute termAtt = stream.getAttribute(TermToBytesRefAttribute.class).     PositionIncrementAttribute posIncAtt = stream.addAttribute(PositionIncrementAttribute.class).     PositionLengthAttribute posLenAtt = stream.addAttribute(PositionLengthAttribute.class).     if (termAtt == null) {         return NO_INTERVALS.     }     // phase 1: read through the stream and assess the situation:     // counting the number of tokens/positions and marking if we have any synonyms.     int numTokens = 0.     boolean hasSynonyms = false.     boolean isGraph = false.     stream.reset().     while (stream.incrementToken()) {         numTokens++.         int positionIncrement = posIncAtt.getPositionIncrement().         if (positionIncrement == 0) {             hasSynonyms = true.         }         int positionLength = posLenAtt.getPositionLength().         if (positionLength > 1) {             isGraph = true.         }     }     if (numTokens == 0) {         return null.     } else if (numTokens == 1) {         // single term         return analyzeTerm(stream).     } else if (isGraph) {         // graph         return combineSources(analyzeGraph(stream), maxGaps, ordered).     } else {         // phrase         if (hasSynonyms) {             // phrase with single-term synonyms             return analyzeSynonyms(stream, maxGaps, ordered).         } else {             // simple phrase             return combineSources(analyzeTerms(stream), maxGaps, ordered).         }     } }
false;protected;1;6;;protected IntervalsSource analyzeTerm(TokenStream ts) throws IOException {     TermToBytesRefAttribute bytesAtt = ts.addAttribute(TermToBytesRefAttribute.class).     ts.reset().     ts.incrementToken().     return Intervals.term(BytesRef.deepCopyOf(bytesAtt.getBytesRef())). }
false;protected,static;3;17;;protected static IntervalsSource combineSources(List<IntervalsSource> sources, int maxGaps, boolean ordered) {     if (sources.size() == 0) {         return NO_INTERVALS.     }     if (sources.size() == 1) {         return sources.get(0).     }     IntervalsSource[] sourcesArray = sources.toArray(new IntervalsSource[0]).     if (maxGaps == 0 && ordered) {         return Intervals.phrase(sourcesArray).     }     IntervalsSource inner = ordered ? Intervals.ordered(sourcesArray) : Intervals.unordered(sourcesArray).     if (maxGaps == -1) {         return inner.     }     return Intervals.maxgaps(maxGaps, inner). }
false;protected;1;11;;protected List<IntervalsSource> analyzeTerms(TokenStream ts) throws IOException {     List<IntervalsSource> terms = new ArrayList<>().     TermToBytesRefAttribute bytesAtt = ts.addAttribute(TermToBytesRefAttribute.class).     ts.reset().     while (ts.incrementToken()) {         BytesRef term = bytesAtt.getBytesRef().         terms.add(Intervals.term(BytesRef.deepCopyOf(term))).     }     ts.end().     return terms. }
false;protected;3;26;;protected IntervalsSource analyzeSynonyms(TokenStream ts, int maxGaps, boolean ordered) throws IOException {     List<IntervalsSource> terms = new ArrayList<>().     List<IntervalsSource> synonyms = new ArrayList<>().     TermToBytesRefAttribute bytesAtt = ts.addAttribute(TermToBytesRefAttribute.class).     PositionIncrementAttribute posAtt = ts.addAttribute(PositionIncrementAttribute.class).     ts.reset().     while (ts.incrementToken()) {         if (posAtt.getPositionIncrement() == 1) {             if (synonyms.size() == 1) {                 terms.add(synonyms.get(0)).             } else if (synonyms.size() > 1) {                 terms.add(Intervals.or(synonyms.toArray(new IntervalsSource[0]))).             }             synonyms.clear().         }         synonyms.add(Intervals.term(BytesRef.deepCopyOf(bytesAtt.getBytesRef()))).     }     if (synonyms.size() == 1) {         terms.add(synonyms.get(0)).     } else {         terms.add(Intervals.or(synonyms.toArray(new IntervalsSource[0]))).     }     return combineSources(terms, maxGaps, ordered). }
false;protected;1;38;;protected List<IntervalsSource> analyzeGraph(TokenStream source) throws IOException {     source.reset().     GraphTokenStreamFiniteStrings graph = new GraphTokenStreamFiniteStrings(source).     List<IntervalsSource> clauses = new ArrayList<>().     int[] articulationPoints = graph.articulationPoints().     int lastState = 0.     int maxClauseCount = BooleanQuery.getMaxClauseCount().     for (int i = 0. i <= articulationPoints.length. i++) {         int start = lastState.         int end = -1.         if (i < articulationPoints.length) {             end = articulationPoints[i].         }         lastState = end.         if (graph.hasSidePath(start)) {             List<IntervalsSource> paths = new ArrayList<>().             Iterator<TokenStream> it = graph.getFiniteStrings(start, end).             while (it.hasNext()) {                 TokenStream ts = it.next().                 IntervalsSource phrase = combineSources(analyzeTerms(ts), 0, true).                 if (paths.size() >= maxClauseCount) {                     throw new BooleanQuery.TooManyClauses().                 }                 paths.add(phrase).             }             if (paths.size() > 0) {                 clauses.add(Intervals.or(paths.toArray(new IntervalsSource[0]))).             }         } else {             Iterator<TokenStream> it = graph.getFiniteStrings(start, end).             TokenStream ts = it.next().             clauses.addAll(analyzeTerms(ts)).             assert it.hasNext() == false.         }     }     return clauses. }
false;public;0;4;;@Override public int start() {     return NO_MORE_INTERVALS. }
false;public;0;4;;@Override public int end() {     return NO_MORE_INTERVALS. }
false;public;0;4;;@Override public int gaps() {     throw new UnsupportedOperationException(). }
false;public;0;4;;@Override public int nextInterval() {     return NO_MORE_INTERVALS. }
false;public;0;4;;@Override public float matchCost() {     return 0. }
false;public;0;4;;@Override public int docID() {     return NO_MORE_DOCS. }
false;public;0;4;;@Override public int nextDoc() {     return NO_MORE_DOCS. }
false;public;1;4;;@Override public int advance(int target) {     return NO_MORE_DOCS. }
false;public;0;4;;@Override public long cost() {     return 0. }
false;public;2;49;;@Override public IntervalIterator intervals(String field, LeafReaderContext ctx) {     return new IntervalIterator() {          @Override         public int start() {             return NO_MORE_INTERVALS.         }          @Override         public int end() {             return NO_MORE_INTERVALS.         }          @Override         public int gaps() {             throw new UnsupportedOperationException().         }          @Override         public int nextInterval() {             return NO_MORE_INTERVALS.         }          @Override         public float matchCost() {             return 0.         }          @Override         public int docID() {             return NO_MORE_DOCS.         }          @Override         public int nextDoc() {             return NO_MORE_DOCS.         }          @Override         public int advance(int target) {             return NO_MORE_DOCS.         }          @Override         public long cost() {             return 0.         }     }. }
false;public;3;4;;@Override public MatchesIterator matches(String field, LeafReaderContext ctx, int doc) {     return null. }
false;public;0;4;;@Override public int minExtent() {     return 0. }
false;public;2;4;;@Override public void extractTerms(String field, Set<Term> terms) { }
false;public;0;4;;@Override public int hashCode() {     return 0. }
false;public;1;4;;@Override public boolean equals(Object other) {     return other == this. }
false;public;0;4;;@Override public String toString() {     return "no_match". }
