commented;modifiers;parameterAmount;loc;comment;code
true;public,static;0;3;/**  * Return a {@link SortedBinaryDocValues} that doesn't contain any value.  */ ;/**  * Return a {@link SortedBinaryDocValues} that doesn't contain any value.  */ public static SortedBinaryDocValues emptySortedBinary() {     return singleton(DocValues.emptyBinary()). }
false;public;1;4;;@Override public boolean advanceExact(int doc) throws IOException {     return false. }
false;public;0;4;;@Override public double doubleValue() throws IOException {     throw new UnsupportedOperationException(). }
true;public,static;0;14;/**  * Return a {@link NumericDoubleValues} that doesn't contain any value.  */ ;/**  * Return a {@link NumericDoubleValues} that doesn't contain any value.  */ public static NumericDoubleValues emptyNumericDouble() {     return new NumericDoubleValues() {          @Override         public boolean advanceExact(int doc) throws IOException {             return false.         }          @Override         public double doubleValue() throws IOException {             throw new UnsupportedOperationException().         }     }. }
true;public,static;0;3;/**  * Return a {@link SortedNumericDoubleValues} that doesn't contain any value.  */ ;/**  * Return a {@link SortedNumericDoubleValues} that doesn't contain any value.  */ public static SortedNumericDoubleValues emptySortedNumericDoubles() {     return singleton(emptyNumericDouble()). }
false;public;1;4;;@Override public boolean advanceExact(int doc) throws IOException {     return false. }
false;public;0;4;;@Override public GeoPoint geoPointValue() {     throw new UnsupportedOperationException(). }
false;public,static;0;13;;public static GeoPointValues emptyGeoPoint() {     return new GeoPointValues() {          @Override         public boolean advanceExact(int doc) throws IOException {             return false.         }          @Override         public GeoPoint geoPointValue() {             throw new UnsupportedOperationException().         }     }. }
true;public,static;0;3;/**  * Return a {@link SortedNumericDoubleValues} that doesn't contain any value.  */ ;/**  * Return a {@link SortedNumericDoubleValues} that doesn't contain any value.  */ public static MultiGeoPointValues emptyMultiGeoPoints() {     return singleton(emptyGeoPoint()). }
false;public;1;4;;@Override public boolean advanceExact(int doc) throws IOException {     return values.advanceExact(doc). }
true;public,static;1;8;/**  * Returns a {@link DocValueBits} representing all documents from <code>values</code> that have a value.  */ ;/**  * Returns a {@link DocValueBits} representing all documents from <code>values</code> that have a value.  */ public static DocValueBits docsWithValue(final SortedBinaryDocValues values) {     return new DocValueBits() {          @Override         public boolean advanceExact(int doc) throws IOException {             return values.advanceExact(doc).         }     }. }
false;public;1;4;;@Override public boolean advanceExact(int doc) throws IOException {     return docValues.advanceExact(doc). }
true;public,static;1;8;/**  * Returns a {@link DocValueBits} representing all documents from <code>docValues</code>  * that have a value.  */ ;/**  * Returns a {@link DocValueBits} representing all documents from <code>docValues</code>  * that have a value.  */ public static DocValueBits docsWithValue(final SortedSetDocValues docValues) {     return new DocValueBits() {          @Override         public boolean advanceExact(int doc) throws IOException {             return docValues.advanceExact(doc).         }     }. }
false;public;1;4;;@Override public boolean advanceExact(int doc) throws IOException {     return pointValues.advanceExact(doc). }
true;public,static;1;8;/**  * Returns a {@link DocValueBits} representing all documents from <code>pointValues</code> that have  * a value.  */ ;/**  * Returns a {@link DocValueBits} representing all documents from <code>pointValues</code> that have  * a value.  */ public static DocValueBits docsWithValue(final MultiGeoPointValues pointValues) {     return new DocValueBits() {          @Override         public boolean advanceExact(int doc) throws IOException {             return pointValues.advanceExact(doc).         }     }. }
false;public;1;4;;@Override public boolean advanceExact(int doc) throws IOException {     return doubleValues.advanceExact(doc). }
true;public,static;1;8;/**  * Returns a {@link DocValueBits} representing all documents from <code>doubleValues</code> that have a value.  */ ;/**  * Returns a {@link DocValueBits} representing all documents from <code>doubleValues</code> that have a value.  */ public static DocValueBits docsWithValue(final SortedNumericDoubleValues doubleValues) {     return new DocValueBits() {          @Override         public boolean advanceExact(int doc) throws IOException {             return doubleValues.advanceExact(doc).         }     }. }
false;public;1;4;;@Override public boolean advanceExact(int doc) throws IOException {     return docValues.advanceExact(doc). }
true;public,static;1;8;/**  * Returns a {@link DocValueBits} representing all documents from <code>docValues</code> that have  * a value.  */ ;/**  * Returns a {@link DocValueBits} representing all documents from <code>docValues</code> that have  * a value.  */ public static DocValueBits docsWithValue(final SortedNumericDocValues docValues) {     return new DocValueBits() {          @Override         public boolean advanceExact(int doc) throws IOException {             return docValues.advanceExact(doc).         }     }. }
true;public,static;1;18;/**  * Given a {@link SortedNumericDoubleValues}, return a  * {@link SortedNumericDocValues} instance that will translate double values  * to sortable long bits using  * {@link org.apache.lucene.util.NumericUtils#doubleToSortableLong(double)}.  */ ;/**  * Given a {@link SortedNumericDoubleValues}, return a  * {@link SortedNumericDocValues} instance that will translate double values  * to sortable long bits using  * {@link org.apache.lucene.util.NumericUtils#doubleToSortableLong(double)}.  */ public static SortedNumericDocValues toSortableLongBits(SortedNumericDoubleValues values) {     final NumericDoubleValues singleton = unwrapSingleton(values).     if (singleton != null) {         final NumericDocValues longBits.         if (singleton instanceof SortableLongBitsToNumericDoubleValues) {             longBits = ((SortableLongBitsToNumericDoubleValues) singleton).getLongValues().         } else {             longBits = new SortableLongBitsNumericDocValues(singleton).         }         return DocValues.singleton(longBits).     } else {         if (values instanceof SortableLongBitsToSortedNumericDoubleValues) {             return ((SortableLongBitsToSortedNumericDoubleValues) values).getLongValues().         } else {             return new SortableLongBitsSortedNumericDocValues(values).         }     } }
true;public,static;1;18;/**  * Given a {@link SortedNumericDocValues}, return a {@link SortedNumericDoubleValues}  * instance that will translate long values to doubles using  * {@link org.apache.lucene.util.NumericUtils#sortableLongToDouble(long)}.  */ ;/**  * Given a {@link SortedNumericDocValues}, return a {@link SortedNumericDoubleValues}  * instance that will translate long values to doubles using  * {@link org.apache.lucene.util.NumericUtils#sortableLongToDouble(long)}.  */ public static SortedNumericDoubleValues sortableLongBitsToDoubles(SortedNumericDocValues values) {     final NumericDocValues singleton = DocValues.unwrapSingleton(values).     if (singleton != null) {         final NumericDoubleValues doubles.         if (singleton instanceof SortableLongBitsNumericDocValues) {             doubles = ((SortableLongBitsNumericDocValues) singleton).getDoubleValues().         } else {             doubles = new SortableLongBitsToNumericDoubleValues(singleton).         }         return singleton(doubles).     } else {         if (values instanceof SortableLongBitsSortedNumericDocValues) {             return ((SortableLongBitsSortedNumericDocValues) values).getDoubleValues().         } else {             return new SortableLongBitsToSortedNumericDoubleValues(values).         }     } }
true;public,static;1;8;/**  * Wrap the provided {@link SortedNumericDocValues} instance to cast all values to doubles.  */ ;/**  * Wrap the provided {@link SortedNumericDocValues} instance to cast all values to doubles.  */ public static SortedNumericDoubleValues castToDouble(final SortedNumericDocValues values) {     final NumericDocValues singleton = DocValues.unwrapSingleton(values).     if (singleton != null) {         return singleton(new DoubleCastedValues(singleton)).     } else {         return new SortedDoubleCastedValues(values).     } }
true;public,static;1;8;/**  * Wrap the provided {@link SortedNumericDoubleValues} instance to cast all values to longs.  */ ;/**  * Wrap the provided {@link SortedNumericDoubleValues} instance to cast all values to longs.  */ public static SortedNumericDocValues castToLong(final SortedNumericDoubleValues values) {     final NumericDoubleValues singleton = unwrapSingleton(values).     if (singleton != null) {         return DocValues.singleton(new LongCastedValues(singleton)).     } else {         return new SortedLongCastedValues(values).     } }
true;public,static;1;3;/**  * Returns a multi-valued view over the provided {@link NumericDoubleValues}.  */ ;/**  * Returns a multi-valued view over the provided {@link NumericDoubleValues}.  */ public static SortedNumericDoubleValues singleton(NumericDoubleValues values) {     return new SingletonSortedNumericDoubleValues(values). }
true;public,static;1;6;/**  * Returns a single-valued view of the {@link SortedNumericDoubleValues},  * if it was previously wrapped with {@link DocValues#singleton(NumericDocValues)},  * or null.  */ ;/**  * Returns a single-valued view of the {@link SortedNumericDoubleValues},  * if it was previously wrapped with {@link DocValues#singleton(NumericDocValues)},  * or null.  */ public static NumericDoubleValues unwrapSingleton(SortedNumericDoubleValues values) {     if (values instanceof SingletonSortedNumericDoubleValues) {         return ((SingletonSortedNumericDoubleValues) values).getNumericDoubleValues().     }     return null. }
true;public,static;1;3;/**  * Returns a multi-valued view over the provided {@link GeoPointValues}.  */ ;/**  * Returns a multi-valued view over the provided {@link GeoPointValues}.  */ public static MultiGeoPointValues singleton(GeoPointValues values) {     return new SingletonMultiGeoPointValues(values). }
true;public,static;1;6;/**  * Returns a single-valued view of the {@link MultiGeoPointValues},  * if it was previously wrapped with {@link #singleton(GeoPointValues)},  * or null.  */ ;/**  * Returns a single-valued view of the {@link MultiGeoPointValues},  * if it was previously wrapped with {@link #singleton(GeoPointValues)},  * or null.  */ public static GeoPointValues unwrapSingleton(MultiGeoPointValues values) {     if (values instanceof SingletonMultiGeoPointValues) {         return ((SingletonMultiGeoPointValues) values).getGeoPointValues().     }     return null. }
true;public,static;1;3;/**  * Returns a multi-valued view over the provided {@link BinaryDocValues}.  */ ;/**  * Returns a multi-valued view over the provided {@link BinaryDocValues}.  */ public static SortedBinaryDocValues singleton(BinaryDocValues values) {     return new SingletonSortedBinaryDocValues(values). }
true;public,static;1;6;/**  * Returns a single-valued view of the {@link SortedBinaryDocValues},  * if it was previously wrapped with {@link #singleton(BinaryDocValues)},  * or null.  */ ;/**  * Returns a single-valued view of the {@link SortedBinaryDocValues},  * if it was previously wrapped with {@link #singleton(BinaryDocValues)},  * or null.  */ public static BinaryDocValues unwrapSingleton(SortedBinaryDocValues values) {     if (values instanceof SingletonSortedBinaryDocValues) {         return ((SingletonSortedBinaryDocValues) values).getBinaryDocValues().     }     return null. }
true;public,static;1;3;/**  * Returns whether the provided values *might* be multi-valued. There is no  * guarantee that this method will return {@code false} in the single-valued case.  */ ;/**  * Returns whether the provided values *might* be multi-valued. There is no  * guarantee that this method will return {@code false} in the single-valued case.  */ public static boolean isMultiValued(SortedSetDocValues values) {     return DocValues.unwrapSingleton(values) == null. }
false;public;1;4;;@Override public boolean advanceExact(int doc) throws IOException {     return values.advanceExact(doc). }
false;public;1;6;;@Override public void get(List<CharSequence> list) throws IOException {     for (int i = 0, count = values.docValueCount(). i < count. ++i) {         list.add(Long.toString(values.nextValue())).     } }
true;public,static;1;14;/**  * Return a {@link String} representation of the provided values. That is  * typically used for scripts or for the `map` execution mode of terms aggs.  * NOTE: this is very slow!  */ ;/**  * Return a {@link String} representation of the provided values. That is  * typically used for scripts or for the `map` execution mode of terms aggs.  * NOTE: this is very slow!  */ public static SortedBinaryDocValues toString(final SortedNumericDocValues values) {     return toString(new ToStringValues() {          @Override         public boolean advanceExact(int doc) throws IOException {             return values.advanceExact(doc).         }          @Override         public void get(List<CharSequence> list) throws IOException {             for (int i = 0, count = values.docValueCount(). i < count. ++i) {                 list.add(Long.toString(values.nextValue())).             }         }     }). }
false;public;1;4;;@Override public boolean advanceExact(int doc) throws IOException {     return values.advanceExact(doc). }
false;public;1;6;;@Override public void get(List<CharSequence> list) throws IOException {     for (int i = 0, count = values.docValueCount(). i < count. ++i) {         list.add(Double.toString(values.nextValue())).     } }
true;public,static;1;14;/**  * Return a {@link String} representation of the provided values. That is  * typically used for scripts or for the `map` execution mode of terms aggs.  * NOTE: this is very slow!  */ ;/**  * Return a {@link String} representation of the provided values. That is  * typically used for scripts or for the `map` execution mode of terms aggs.  * NOTE: this is very slow!  */ public static SortedBinaryDocValues toString(final SortedNumericDoubleValues values) {     return toString(new ToStringValues() {          @Override         public boolean advanceExact(int doc) throws IOException {             return values.advanceExact(doc).         }          @Override         public void get(List<CharSequence> list) throws IOException {             for (int i = 0, count = values.docValueCount(). i < count. ++i) {                 list.add(Double.toString(values.nextValue())).             }         }     }). }
false;public;1;16;;@Override public boolean advanceExact(int doc) throws IOException {     if (values.advanceExact(doc) == false) {         return false.     }     for (int i = 0. . ++i) {         if (values.nextOrd() == SortedSetDocValues.NO_MORE_ORDS) {             count = i.             break.         }     }     // reset the iterator on the current doc     boolean advanced = values.advanceExact(doc).     assert advanced.     return true. }
false;public;0;4;;@Override public int docValueCount() {     return count. }
false;public;0;4;;@Override public BytesRef nextValue() throws IOException {     return values.lookupOrd(values.nextOrd()). }
true;public,static;1;33;/**  * Return a {@link String} representation of the provided values. That is  * typically used for scripts or for the `map` execution mode of terms aggs.  * NOTE: this is slow!  */ ;/**  * Return a {@link String} representation of the provided values. That is  * typically used for scripts or for the `map` execution mode of terms aggs.  * NOTE: this is slow!  */ public static SortedBinaryDocValues toString(final SortedSetDocValues values) {     return new SortedBinaryDocValues() {          private int count = 0.          @Override         public boolean advanceExact(int doc) throws IOException {             if (values.advanceExact(doc) == false) {                 return false.             }             for (int i = 0. . ++i) {                 if (values.nextOrd() == SortedSetDocValues.NO_MORE_ORDS) {                     count = i.                     break.                 }             }             // reset the iterator on the current doc             boolean advanced = values.advanceExact(doc).             assert advanced.             return true.         }          @Override         public int docValueCount() {             return count.         }          @Override         public BytesRef nextValue() throws IOException {             return values.lookupOrd(values.nextOrd()).         }     }. }
false;public;1;4;;@Override public boolean advanceExact(int doc) throws IOException {     return values.advanceExact(doc). }
false;public;1;6;;@Override public void get(List<CharSequence> list) throws IOException {     for (int i = 0, count = values.docValueCount(). i < count. ++i) {         list.add(values.nextValue().toString()).     } }
true;public,static;1;14;/**  * Return a {@link String} representation of the provided values. That is  * typically used for scripts or for the `map` execution mode of terms aggs.  * NOTE: this is very slow!  */ ;/**  * Return a {@link String} representation of the provided values. That is  * typically used for scripts or for the `map` execution mode of terms aggs.  * NOTE: this is very slow!  */ public static SortedBinaryDocValues toString(final MultiGeoPointValues values) {     return toString(new ToStringValues() {          @Override         public boolean advanceExact(int doc) throws IOException {             return values.advanceExact(doc).         }          @Override         public void get(List<CharSequence> list) throws IOException {             for (int i = 0, count = values.docValueCount(). i < count. ++i) {                 list.add(values.nextValue().toString()).             }         }     }). }
false;public;1;16;;@Override public boolean advanceExact(int docID) throws IOException {     if (toStringValues.advanceExact(docID) == false) {         return false.     }     list.clear().     toStringValues.get(list).     count = list.size().     grow().     for (int i = 0. i < count. ++i) {         final CharSequence s = list.get(i).         values[i].copyChars(s).     }     sort().     return true. }
false;private,static;1;24;;private static SortedBinaryDocValues toString(final ToStringValues toStringValues) {     return new SortingBinaryDocValues() {          final List<CharSequence> list = new ArrayList<>().          @Override         public boolean advanceExact(int docID) throws IOException {             if (toStringValues.advanceExact(docID) == false) {                 return false.             }             list.clear().             toStringValues.get(list).             count = list.size().             grow().             for (int i = 0. i < count. ++i) {                 final CharSequence s = list.get(i).                 values[i].copyChars(s).             }             sort().             return true.         }     }. }
true;;1;1;/**  * Advance this instance to the given document id  * @return true if there is a value for this document  */ ;/**  * Advance this instance to the given document id  * @return true if there is a value for this document  */ boolean advanceExact(int doc) throws IOException.
true;;1;1;/**  * Fill the list of charsquences with the list of values for the current document.  */ ;/**  * Fill the list of charsquences with the list of values for the current document.  */ void get(List<CharSequence> values) throws IOException.
false;public;0;4;;@Override public double doubleValue() throws IOException {     return values.longValue(). }
false;public;1;4;;@Override public boolean advanceExact(int doc) throws IOException {     return values.advanceExact(doc). }
false;public;1;4;;@Override public boolean advanceExact(int target) throws IOException {     return values.advanceExact(target). }
false;public;0;4;;@Override public double nextValue() throws IOException {     return values.nextValue(). }
false;public;0;4;;@Override public int docValueCount() {     return values.docValueCount(). }
false;public;1;5;;@Override public boolean advanceExact(int target) throws IOException {     docID = target.     return values.advanceExact(target). }
false;public;0;4;;@Override public long longValue() throws IOException {     return (long) values.doubleValue(). }
false;public;0;4;;@Override public int docID() {     return docID. }
false;public;1;4;;@Override public boolean advanceExact(int target) throws IOException {     return values.advanceExact(target). }
false;public;0;4;;@Override public int docValueCount() {     return values.docValueCount(). }
false;public;0;4;;@Override public long nextValue() throws IOException {     return (long) values.nextValue(). }
false;public;0;4;;@Override public int docID() {     return values.docID(). }
false;public;1;9;;@Override public boolean advanceExact(int target) throws IOException {     if (values.advanceExact(target)) {         value = values.longValue().     } else {         value = missing.     }     return true. }
false;public;0;4;;@Override public long longValue() throws IOException {     return value. }
true;public,static;2;26;/**  * Return a {@link NumericDocValues} instance that has a value for every  * document, returns the same value as {@code values} if there is a value  * for the current document and {@code missing} otherwise.  */ ;/**  * Return a {@link NumericDocValues} instance that has a value for every  * document, returns the same value as {@code values} if there is a value  * for the current document and {@code missing} otherwise.  */ public static NumericDocValues replaceMissing(NumericDocValues values, long missing) {     return new AbstractNumericDocValues() {          private long value.          @Override         public int docID() {             return values.docID().         }          @Override         public boolean advanceExact(int target) throws IOException {             if (values.advanceExact(target)) {                 value = values.longValue().             } else {                 value = missing.             }             return true.         }          @Override         public long longValue() throws IOException {             return value.         }     }. }
false;public;1;9;;@Override public boolean advanceExact(int target) throws IOException {     if (values.advanceExact(target)) {         value = values.doubleValue().     } else {         value = missing.     }     return true. }
false;public;0;4;;@Override public double doubleValue() throws IOException {     return value. }
true;public,static;2;21;/**  * Return a {@link NumericDoubleValues} instance that has a value for every  * document, returns the same value as {@code values} if there is a value  * for the current document and {@code missing} otherwise.  */ ;/**  * Return a {@link NumericDoubleValues} instance that has a value for every  * document, returns the same value as {@code values} if there is a value  * for the current document and {@code missing} otherwise.  */ public static NumericDoubleValues replaceMissing(NumericDoubleValues values, double missing) {     return new NumericDoubleValues() {          private double value.          @Override         public boolean advanceExact(int target) throws IOException {             if (values.advanceExact(target)) {                 value = values.doubleValue().             } else {                 value = missing.             }             return true.         }          @Override         public double doubleValue() throws IOException {             return value.         }     }. }
