commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected BytesStreamOutput newBytesOutput() {     return new ReleasableBytesStreamOutput(bigArrays). }
false;public;1;55;;@Override public void sendResponse(RestResponse restResponse) {     HttpResponse httpResponse.     if (RestRequest.Method.HEAD == request.method()) {         httpResponse = httpRequest.createResponse(restResponse.status(), BytesArray.EMPTY).     } else {         httpResponse = httpRequest.createResponse(restResponse.status(), restResponse.content()).     }     // TODO: Ideally we should move the setting of Cors headers into :server     // NioCorsHandler.setCorsResponseHeaders(nettyRequest, resp, corsConfig).     String opaque = request.header(X_OPAQUE_ID).     if (opaque != null) {         setHeaderField(httpResponse, X_OPAQUE_ID, opaque).     }     // Add all custom headers     addCustomHeaders(httpResponse, restResponse.getHeaders()).     addCustomHeaders(httpResponse, threadContext.getResponseHeaders()).     ArrayList<Releasable> toClose = new ArrayList<>(3).     boolean success = false.     try {         // If our response doesn't specify a content-type header, set one         setHeaderField(httpResponse, CONTENT_TYPE, restResponse.contentType(), false).         // If our response has no content-length, calculate and set one         setHeaderField(httpResponse, CONTENT_LENGTH, String.valueOf(restResponse.content().length()), false).         addCookies(httpResponse).         BytesReference content = restResponse.content().         if (content instanceof Releasable) {             toClose.add((Releasable) content).         }         BytesStreamOutput bytesStreamOutput = bytesOutputOrNull().         if (bytesStreamOutput instanceof ReleasableBytesStreamOutput) {             toClose.add((Releasable) bytesStreamOutput).         }         if (isCloseConnection()) {             toClose.add(() -> CloseableChannel.closeChannel(httpChannel)).         }         ActionListener<Void> listener = ActionListener.wrap(() -> Releasables.close(toClose)).         httpChannel.sendResponse(httpResponse, listener).         success = true.     } finally {         if (success == false) {             Releasables.close(toClose).         }     } }
false;private;3;3;;private void setHeaderField(HttpResponse response, String headerField, String value) {     setHeaderField(response, headerField, value, true). }
false;private;4;5;;private void setHeaderField(HttpResponse response, String headerField, String value, boolean override) {     if (override || !response.containsHeader(headerField)) {         response.addHeader(headerField, value).     } }
false;private;2;9;;private void addCustomHeaders(HttpResponse response, Map<String, List<String>> customHeaders) {     if (customHeaders != null) {         for (Map.Entry<String, List<String>> headerEntry : customHeaders.entrySet()) {             for (String headerValue : headerEntry.getValue()) {                 setHeaderField(response, headerEntry.getKey(), headerValue).             }         }     } }
false;private;1;10;;private void addCookies(HttpResponse response) {     if (settings.isResetCookies()) {         List<String> cookies = request.getHttpRequest().strictCookies().         if (cookies.isEmpty() == false) {             for (String cookie : cookies) {                 response.addHeader(SET_COOKIE, cookie).             }         }     } }
true;private;0;4;// Determine if the request connection should be closed on completion. ;// Determine if the request connection should be closed on completion. private boolean isCloseConnection() {     final boolean http10 = isHttp10().     return CLOSE.equalsIgnoreCase(request.header(CONNECTION)) || (http10 && !KEEP_ALIVE.equalsIgnoreCase(request.header(CONNECTION))). }
true;private;0;3;// Determine if the request protocol version is HTTP 1.0 ;// Determine if the request protocol version is HTTP 1.0 private boolean isHttp10() {     return request.getHttpRequest().protocolVersion() == HttpRequest.HttpVersion.HTTP_1_0. }
