# id;timestamp;commentText;codeText;commentWords;codeWords
IndexNameExpressionResolver -> public Index[] concreteIndices(ClusterState state, IndicesOptions options, String... indexExpressions);1524684173;Translates the provided index expression into actual concrete indices, properly deduplicated.__@param state             the cluster state containing all the data to resolve to expressions to concrete indices_@param options           defines how the aliases or indices need to be resolved to concrete indices_@param indexExpressions  expressions that can be resolved to alias or index names._@return the resolved concrete indices based on the cluster state, indices options and index expressions_@throws IndexNotFoundException if one of the index expressions is pointing to a missing index or alias and the_provided indices options in the context don't allow such a case, or if the final result of the indices resolution_contains no indices and the indices options in the context don't allow such a case._@throws IllegalArgumentException if one of the aliases resolve to multiple indices and the provided_indices options in the context don't allow such a case.;public Index[] concreteIndices(ClusterState state, IndicesOptions options, String... indexExpressions) {_        Context context = new Context(state, options)__        return concreteIndices(context, indexExpressions)__    };translates,the,provided,index,expression,into,actual,concrete,indices,properly,deduplicated,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expressions,to,concrete,indices,param,options,defines,how,the,aliases,or,indices,need,to,be,resolved,to,concrete,indices,param,index,expressions,expressions,that,can,be,resolved,to,alias,or,index,names,return,the,resolved,concrete,indices,based,on,the,cluster,state,indices,options,and,index,expressions,throws,index,not,found,exception,if,one,of,the,index,expressions,is,pointing,to,a,missing,index,or,alias,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case,or,if,the,final,result,of,the,indices,resolution,contains,no,indices,and,the,indices,options,in,the,context,don,t,allow,such,a,case,throws,illegal,argument,exception,if,one,of,the,aliases,resolve,to,multiple,indices,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case;public,index,concrete,indices,cluster,state,state,indices,options,options,string,index,expressions,context,context,new,context,state,options,return,concrete,indices,context,index,expressions
IndexNameExpressionResolver -> public Index[] concreteIndices(ClusterState state, IndicesOptions options, String... indexExpressions);1525334055;Translates the provided index expression into actual concrete indices, properly deduplicated.__@param state             the cluster state containing all the data to resolve to expressions to concrete indices_@param options           defines how the aliases or indices need to be resolved to concrete indices_@param indexExpressions  expressions that can be resolved to alias or index names._@return the resolved concrete indices based on the cluster state, indices options and index expressions_@throws IndexNotFoundException if one of the index expressions is pointing to a missing index or alias and the_provided indices options in the context don't allow such a case, or if the final result of the indices resolution_contains no indices and the indices options in the context don't allow such a case._@throws IllegalArgumentException if one of the aliases resolve to multiple indices and the provided_indices options in the context don't allow such a case.;public Index[] concreteIndices(ClusterState state, IndicesOptions options, String... indexExpressions) {_        Context context = new Context(state, options)__        return concreteIndices(context, indexExpressions)__    };translates,the,provided,index,expression,into,actual,concrete,indices,properly,deduplicated,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expressions,to,concrete,indices,param,options,defines,how,the,aliases,or,indices,need,to,be,resolved,to,concrete,indices,param,index,expressions,expressions,that,can,be,resolved,to,alias,or,index,names,return,the,resolved,concrete,indices,based,on,the,cluster,state,indices,options,and,index,expressions,throws,index,not,found,exception,if,one,of,the,index,expressions,is,pointing,to,a,missing,index,or,alias,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case,or,if,the,final,result,of,the,indices,resolution,contains,no,indices,and,the,indices,options,in,the,context,don,t,allow,such,a,case,throws,illegal,argument,exception,if,one,of,the,aliases,resolve,to,multiple,indices,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case;public,index,concrete,indices,cluster,state,state,indices,options,options,string,index,expressions,context,context,new,context,state,options,return,concrete,indices,context,index,expressions
IndexNameExpressionResolver -> public Index[] concreteIndices(ClusterState state, IndicesOptions options, String... indexExpressions);1532028790;Translates the provided index expression into actual concrete indices, properly deduplicated.__@param state             the cluster state containing all the data to resolve to expressions to concrete indices_@param options           defines how the aliases or indices need to be resolved to concrete indices_@param indexExpressions  expressions that can be resolved to alias or index names._@return the resolved concrete indices based on the cluster state, indices options and index expressions_@throws IndexNotFoundException if one of the index expressions is pointing to a missing index or alias and the_provided indices options in the context don't allow such a case, or if the final result of the indices resolution_contains no indices and the indices options in the context don't allow such a case._@throws IllegalArgumentException if one of the aliases resolve to multiple indices and the provided_indices options in the context don't allow such a case.;public Index[] concreteIndices(ClusterState state, IndicesOptions options, String... indexExpressions) {_        Context context = new Context(state, options, false, false)__        return concreteIndices(context, indexExpressions)__    };translates,the,provided,index,expression,into,actual,concrete,indices,properly,deduplicated,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expressions,to,concrete,indices,param,options,defines,how,the,aliases,or,indices,need,to,be,resolved,to,concrete,indices,param,index,expressions,expressions,that,can,be,resolved,to,alias,or,index,names,return,the,resolved,concrete,indices,based,on,the,cluster,state,indices,options,and,index,expressions,throws,index,not,found,exception,if,one,of,the,index,expressions,is,pointing,to,a,missing,index,or,alias,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case,or,if,the,final,result,of,the,indices,resolution,contains,no,indices,and,the,indices,options,in,the,context,don,t,allow,such,a,case,throws,illegal,argument,exception,if,one,of,the,aliases,resolve,to,multiple,indices,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case;public,index,concrete,indices,cluster,state,state,indices,options,options,string,index,expressions,context,context,new,context,state,options,false,false,return,concrete,indices,context,index,expressions
IndexNameExpressionResolver -> public Index[] concreteIndices(ClusterState state, IndicesOptions options, String... indexExpressions);1538067637;Translates the provided index expression into actual concrete indices, properly deduplicated.__@param state             the cluster state containing all the data to resolve to expressions to concrete indices_@param options           defines how the aliases or indices need to be resolved to concrete indices_@param indexExpressions  expressions that can be resolved to alias or index names._@return the resolved concrete indices based on the cluster state, indices options and index expressions_@throws IndexNotFoundException if one of the index expressions is pointing to a missing index or alias and the_provided indices options in the context don't allow such a case, or if the final result of the indices resolution_contains no indices and the indices options in the context don't allow such a case._@throws IllegalArgumentException if one of the aliases resolve to multiple indices and the provided_indices options in the context don't allow such a case.;public Index[] concreteIndices(ClusterState state, IndicesOptions options, String... indexExpressions) {_        Context context = new Context(state, options, false, false)__        return concreteIndices(context, indexExpressions)__    };translates,the,provided,index,expression,into,actual,concrete,indices,properly,deduplicated,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expressions,to,concrete,indices,param,options,defines,how,the,aliases,or,indices,need,to,be,resolved,to,concrete,indices,param,index,expressions,expressions,that,can,be,resolved,to,alias,or,index,names,return,the,resolved,concrete,indices,based,on,the,cluster,state,indices,options,and,index,expressions,throws,index,not,found,exception,if,one,of,the,index,expressions,is,pointing,to,a,missing,index,or,alias,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case,or,if,the,final,result,of,the,indices,resolution,contains,no,indices,and,the,indices,options,in,the,context,don,t,allow,such,a,case,throws,illegal,argument,exception,if,one,of,the,aliases,resolve,to,multiple,indices,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case;public,index,concrete,indices,cluster,state,state,indices,options,options,string,index,expressions,context,context,new,context,state,options,false,false,return,concrete,indices,context,index,expressions
IndexNameExpressionResolver -> public Index[] concreteIndices(ClusterState state, IndicesOptions options, String... indexExpressions);1539615817;Translates the provided index expression into actual concrete indices, properly deduplicated.__@param state             the cluster state containing all the data to resolve to expressions to concrete indices_@param options           defines how the aliases or indices need to be resolved to concrete indices_@param indexExpressions  expressions that can be resolved to alias or index names._@return the resolved concrete indices based on the cluster state, indices options and index expressions_@throws IndexNotFoundException if one of the index expressions is pointing to a missing index or alias and the_provided indices options in the context don't allow such a case, or if the final result of the indices resolution_contains no indices and the indices options in the context don't allow such a case._@throws IllegalArgumentException if one of the aliases resolve to multiple indices and the provided_indices options in the context don't allow such a case.;public Index[] concreteIndices(ClusterState state, IndicesOptions options, String... indexExpressions) {_        Context context = new Context(state, options, false, false)__        return concreteIndices(context, indexExpressions)__    };translates,the,provided,index,expression,into,actual,concrete,indices,properly,deduplicated,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expressions,to,concrete,indices,param,options,defines,how,the,aliases,or,indices,need,to,be,resolved,to,concrete,indices,param,index,expressions,expressions,that,can,be,resolved,to,alias,or,index,names,return,the,resolved,concrete,indices,based,on,the,cluster,state,indices,options,and,index,expressions,throws,index,not,found,exception,if,one,of,the,index,expressions,is,pointing,to,a,missing,index,or,alias,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case,or,if,the,final,result,of,the,indices,resolution,contains,no,indices,and,the,indices,options,in,the,context,don,t,allow,such,a,case,throws,illegal,argument,exception,if,one,of,the,aliases,resolve,to,multiple,indices,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case;public,index,concrete,indices,cluster,state,state,indices,options,options,string,index,expressions,context,context,new,context,state,options,false,false,return,concrete,indices,context,index,expressions
IndexNameExpressionResolver -> public Index[] concreteIndices(ClusterState state, IndicesOptions options, String... indexExpressions);1540313026;Translates the provided index expression into actual concrete indices, properly deduplicated.__@param state             the cluster state containing all the data to resolve to expressions to concrete indices_@param options           defines how the aliases or indices need to be resolved to concrete indices_@param indexExpressions  expressions that can be resolved to alias or index names._@return the resolved concrete indices based on the cluster state, indices options and index expressions_@throws IndexNotFoundException if one of the index expressions is pointing to a missing index or alias and the_provided indices options in the context don't allow such a case, or if the final result of the indices resolution_contains no indices and the indices options in the context don't allow such a case._@throws IllegalArgumentException if one of the aliases resolve to multiple indices and the provided_indices options in the context don't allow such a case.;public Index[] concreteIndices(ClusterState state, IndicesOptions options, String... indexExpressions) {_        Context context = new Context(state, options, false, false)__        return concreteIndices(context, indexExpressions)__    };translates,the,provided,index,expression,into,actual,concrete,indices,properly,deduplicated,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expressions,to,concrete,indices,param,options,defines,how,the,aliases,or,indices,need,to,be,resolved,to,concrete,indices,param,index,expressions,expressions,that,can,be,resolved,to,alias,or,index,names,return,the,resolved,concrete,indices,based,on,the,cluster,state,indices,options,and,index,expressions,throws,index,not,found,exception,if,one,of,the,index,expressions,is,pointing,to,a,missing,index,or,alias,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case,or,if,the,final,result,of,the,indices,resolution,contains,no,indices,and,the,indices,options,in,the,context,don,t,allow,such,a,case,throws,illegal,argument,exception,if,one,of,the,aliases,resolve,to,multiple,indices,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case;public,index,concrete,indices,cluster,state,state,indices,options,options,string,index,expressions,context,context,new,context,state,options,false,false,return,concrete,indices,context,index,expressions
IndexNameExpressionResolver -> public Index[] concreteIndices(ClusterState state, IndicesOptions options, String... indexExpressions);1540847035;Translates the provided index expression into actual concrete indices, properly deduplicated.__@param state             the cluster state containing all the data to resolve to expressions to concrete indices_@param options           defines how the aliases or indices need to be resolved to concrete indices_@param indexExpressions  expressions that can be resolved to alias or index names._@return the resolved concrete indices based on the cluster state, indices options and index expressions_@throws IndexNotFoundException if one of the index expressions is pointing to a missing index or alias and the_provided indices options in the context don't allow such a case, or if the final result of the indices resolution_contains no indices and the indices options in the context don't allow such a case._@throws IllegalArgumentException if one of the aliases resolve to multiple indices and the provided_indices options in the context don't allow such a case.;public Index[] concreteIndices(ClusterState state, IndicesOptions options, String... indexExpressions) {_        Context context = new Context(state, options, false, false)__        return concreteIndices(context, indexExpressions)__    };translates,the,provided,index,expression,into,actual,concrete,indices,properly,deduplicated,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expressions,to,concrete,indices,param,options,defines,how,the,aliases,or,indices,need,to,be,resolved,to,concrete,indices,param,index,expressions,expressions,that,can,be,resolved,to,alias,or,index,names,return,the,resolved,concrete,indices,based,on,the,cluster,state,indices,options,and,index,expressions,throws,index,not,found,exception,if,one,of,the,index,expressions,is,pointing,to,a,missing,index,or,alias,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case,or,if,the,final,result,of,the,indices,resolution,contains,no,indices,and,the,indices,options,in,the,context,don,t,allow,such,a,case,throws,illegal,argument,exception,if,one,of,the,aliases,resolve,to,multiple,indices,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case;public,index,concrete,indices,cluster,state,state,indices,options,options,string,index,expressions,context,context,new,context,state,options,false,false,return,concrete,indices,context,index,expressions
IndexNameExpressionResolver -> public Index[] concreteIndices(ClusterState state, IndicesOptions options, String... indexExpressions);1541092382;Translates the provided index expression into actual concrete indices, properly deduplicated.__@param state             the cluster state containing all the data to resolve to expressions to concrete indices_@param options           defines how the aliases or indices need to be resolved to concrete indices_@param indexExpressions  expressions that can be resolved to alias or index names._@return the resolved concrete indices based on the cluster state, indices options and index expressions_@throws IndexNotFoundException if one of the index expressions is pointing to a missing index or alias and the_provided indices options in the context don't allow such a case, or if the final result of the indices resolution_contains no indices and the indices options in the context don't allow such a case._@throws IllegalArgumentException if one of the aliases resolve to multiple indices and the provided_indices options in the context don't allow such a case.;public Index[] concreteIndices(ClusterState state, IndicesOptions options, String... indexExpressions) {_        Context context = new Context(state, options, false, false)__        return concreteIndices(context, indexExpressions)__    };translates,the,provided,index,expression,into,actual,concrete,indices,properly,deduplicated,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expressions,to,concrete,indices,param,options,defines,how,the,aliases,or,indices,need,to,be,resolved,to,concrete,indices,param,index,expressions,expressions,that,can,be,resolved,to,alias,or,index,names,return,the,resolved,concrete,indices,based,on,the,cluster,state,indices,options,and,index,expressions,throws,index,not,found,exception,if,one,of,the,index,expressions,is,pointing,to,a,missing,index,or,alias,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case,or,if,the,final,result,of,the,indices,resolution,contains,no,indices,and,the,indices,options,in,the,context,don,t,allow,such,a,case,throws,illegal,argument,exception,if,one,of,the,aliases,resolve,to,multiple,indices,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case;public,index,concrete,indices,cluster,state,state,indices,options,options,string,index,expressions,context,context,new,context,state,options,false,false,return,concrete,indices,context,index,expressions
IndexNameExpressionResolver -> public Index[] concreteIndices(ClusterState state, IndicesOptions options, String... indexExpressions);1541493930;Translates the provided index expression into actual concrete indices, properly deduplicated.__@param state             the cluster state containing all the data to resolve to expressions to concrete indices_@param options           defines how the aliases or indices need to be resolved to concrete indices_@param indexExpressions  expressions that can be resolved to alias or index names._@return the resolved concrete indices based on the cluster state, indices options and index expressions_@throws IndexNotFoundException if one of the index expressions is pointing to a missing index or alias and the_provided indices options in the context don't allow such a case, or if the final result of the indices resolution_contains no indices and the indices options in the context don't allow such a case._@throws IllegalArgumentException if one of the aliases resolve to multiple indices and the provided_indices options in the context don't allow such a case.;public Index[] concreteIndices(ClusterState state, IndicesOptions options, String... indexExpressions) {_        Context context = new Context(state, options, false, false)__        return concreteIndices(context, indexExpressions)__    };translates,the,provided,index,expression,into,actual,concrete,indices,properly,deduplicated,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expressions,to,concrete,indices,param,options,defines,how,the,aliases,or,indices,need,to,be,resolved,to,concrete,indices,param,index,expressions,expressions,that,can,be,resolved,to,alias,or,index,names,return,the,resolved,concrete,indices,based,on,the,cluster,state,indices,options,and,index,expressions,throws,index,not,found,exception,if,one,of,the,index,expressions,is,pointing,to,a,missing,index,or,alias,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case,or,if,the,final,result,of,the,indices,resolution,contains,no,indices,and,the,indices,options,in,the,context,don,t,allow,such,a,case,throws,illegal,argument,exception,if,one,of,the,aliases,resolve,to,multiple,indices,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case;public,index,concrete,indices,cluster,state,state,indices,options,options,string,index,expressions,context,context,new,context,state,options,false,false,return,concrete,indices,context,index,expressions
IndexNameExpressionResolver -> public Index[] concreteIndices(ClusterState state, IndicesOptions options, String... indexExpressions);1541612607;Translates the provided index expression into actual concrete indices, properly deduplicated.__@param state             the cluster state containing all the data to resolve to expressions to concrete indices_@param options           defines how the aliases or indices need to be resolved to concrete indices_@param indexExpressions  expressions that can be resolved to alias or index names._@return the resolved concrete indices based on the cluster state, indices options and index expressions_@throws IndexNotFoundException if one of the index expressions is pointing to a missing index or alias and the_provided indices options in the context don't allow such a case, or if the final result of the indices resolution_contains no indices and the indices options in the context don't allow such a case._@throws IllegalArgumentException if one of the aliases resolve to multiple indices and the provided_indices options in the context don't allow such a case.;public Index[] concreteIndices(ClusterState state, IndicesOptions options, String... indexExpressions) {_        Context context = new Context(state, options, false, false)__        return concreteIndices(context, indexExpressions)__    };translates,the,provided,index,expression,into,actual,concrete,indices,properly,deduplicated,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expressions,to,concrete,indices,param,options,defines,how,the,aliases,or,indices,need,to,be,resolved,to,concrete,indices,param,index,expressions,expressions,that,can,be,resolved,to,alias,or,index,names,return,the,resolved,concrete,indices,based,on,the,cluster,state,indices,options,and,index,expressions,throws,index,not,found,exception,if,one,of,the,index,expressions,is,pointing,to,a,missing,index,or,alias,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case,or,if,the,final,result,of,the,indices,resolution,contains,no,indices,and,the,indices,options,in,the,context,don,t,allow,such,a,case,throws,illegal,argument,exception,if,one,of,the,aliases,resolve,to,multiple,indices,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case;public,index,concrete,indices,cluster,state,state,indices,options,options,string,index,expressions,context,context,new,context,state,options,false,false,return,concrete,indices,context,index,expressions
IndexNameExpressionResolver -> public Index[] concreteIndices(ClusterState state, IndicesOptions options, String... indexExpressions);1544215214;Translates the provided index expression into actual concrete indices, properly deduplicated.__@param state             the cluster state containing all the data to resolve to expressions to concrete indices_@param options           defines how the aliases or indices need to be resolved to concrete indices_@param indexExpressions  expressions that can be resolved to alias or index names._@return the resolved concrete indices based on the cluster state, indices options and index expressions_@throws IndexNotFoundException if one of the index expressions is pointing to a missing index or alias and the_provided indices options in the context don't allow such a case, or if the final result of the indices resolution_contains no indices and the indices options in the context don't allow such a case._@throws IllegalArgumentException if one of the aliases resolve to multiple indices and the provided_indices options in the context don't allow such a case.;public Index[] concreteIndices(ClusterState state, IndicesOptions options, String... indexExpressions) {_        Context context = new Context(state, options, false, false)__        return concreteIndices(context, indexExpressions)__    };translates,the,provided,index,expression,into,actual,concrete,indices,properly,deduplicated,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expressions,to,concrete,indices,param,options,defines,how,the,aliases,or,indices,need,to,be,resolved,to,concrete,indices,param,index,expressions,expressions,that,can,be,resolved,to,alias,or,index,names,return,the,resolved,concrete,indices,based,on,the,cluster,state,indices,options,and,index,expressions,throws,index,not,found,exception,if,one,of,the,index,expressions,is,pointing,to,a,missing,index,or,alias,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case,or,if,the,final,result,of,the,indices,resolution,contains,no,indices,and,the,indices,options,in,the,context,don,t,allow,such,a,case,throws,illegal,argument,exception,if,one,of,the,aliases,resolve,to,multiple,indices,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case;public,index,concrete,indices,cluster,state,state,indices,options,options,string,index,expressions,context,context,new,context,state,options,false,false,return,concrete,indices,context,index,expressions
IndexNameExpressionResolver -> public Index[] concreteIndices(ClusterState state, IndicesOptions options, String... indexExpressions);1548236405;Translates the provided index expression into actual concrete indices, properly deduplicated.__@param state             the cluster state containing all the data to resolve to expressions to concrete indices_@param options           defines how the aliases or indices need to be resolved to concrete indices_@param indexExpressions  expressions that can be resolved to alias or index names._@return the resolved concrete indices based on the cluster state, indices options and index expressions_@throws IndexNotFoundException if one of the index expressions is pointing to a missing index or alias and the_provided indices options in the context don't allow such a case, or if the final result of the indices resolution_contains no indices and the indices options in the context don't allow such a case._@throws IllegalArgumentException if one of the aliases resolve to multiple indices and the provided_indices options in the context don't allow such a case.;public Index[] concreteIndices(ClusterState state, IndicesOptions options, String... indexExpressions) {_        Context context = new Context(state, options, false, false)__        return concreteIndices(context, indexExpressions)__    };translates,the,provided,index,expression,into,actual,concrete,indices,properly,deduplicated,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expressions,to,concrete,indices,param,options,defines,how,the,aliases,or,indices,need,to,be,resolved,to,concrete,indices,param,index,expressions,expressions,that,can,be,resolved,to,alias,or,index,names,return,the,resolved,concrete,indices,based,on,the,cluster,state,indices,options,and,index,expressions,throws,index,not,found,exception,if,one,of,the,index,expressions,is,pointing,to,a,missing,index,or,alias,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case,or,if,the,final,result,of,the,indices,resolution,contains,no,indices,and,the,indices,options,in,the,context,don,t,allow,such,a,case,throws,illegal,argument,exception,if,one,of,the,aliases,resolve,to,multiple,indices,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case;public,index,concrete,indices,cluster,state,state,indices,options,options,string,index,expressions,context,context,new,context,state,options,false,false,return,concrete,indices,context,index,expressions
IndexNameExpressionResolver -> boolean isPatternMatchingAllIndices(MetaData metaData, String[] indicesOrAliases, String[] concreteIndices);1524684173;Identifies whether the first argument (an array containing index names) is a pattern that matches all indices__@param indicesOrAliases the array containing index names_@param concreteIndices  array containing the concrete indices that the first argument refers to_@return true if the first argument is a pattern that maps to all available indices, false otherwise;boolean isPatternMatchingAllIndices(MetaData metaData, String[] indicesOrAliases, String[] concreteIndices) {_        _        if (concreteIndices.length == metaData.getConcreteAllIndices().length && indicesOrAliases.length > 0) {__            _            _            if (indicesOrAliases[0].charAt(0) == '-') {_                return true__            }__            _            for (String indexOrAlias : indicesOrAliases) {_                if (Regex.isSimpleMatchPattern(indexOrAlias)) {_                    return true__                }_            }_        }_        return false__    };identifies,whether,the,first,argument,an,array,containing,index,names,is,a,pattern,that,matches,all,indices,param,indices,or,aliases,the,array,containing,index,names,param,concrete,indices,array,containing,the,concrete,indices,that,the,first,argument,refers,to,return,true,if,the,first,argument,is,a,pattern,that,maps,to,all,available,indices,false,otherwise;boolean,is,pattern,matching,all,indices,meta,data,meta,data,string,indices,or,aliases,string,concrete,indices,if,concrete,indices,length,meta,data,get,concrete,all,indices,length,indices,or,aliases,length,0,if,indices,or,aliases,0,char,at,0,return,true,for,string,index,or,alias,indices,or,aliases,if,regex,is,simple,match,pattern,index,or,alias,return,true,return,false
IndexNameExpressionResolver -> boolean isPatternMatchingAllIndices(MetaData metaData, String[] indicesOrAliases, String[] concreteIndices);1525334055;Identifies whether the first argument (an array containing index names) is a pattern that matches all indices__@param indicesOrAliases the array containing index names_@param concreteIndices  array containing the concrete indices that the first argument refers to_@return true if the first argument is a pattern that maps to all available indices, false otherwise;boolean isPatternMatchingAllIndices(MetaData metaData, String[] indicesOrAliases, String[] concreteIndices) {_        _        if (concreteIndices.length == metaData.getConcreteAllIndices().length && indicesOrAliases.length > 0) {__            _            _            if (indicesOrAliases[0].charAt(0) == '-') {_                return true__            }__            _            for (String indexOrAlias : indicesOrAliases) {_                if (Regex.isSimpleMatchPattern(indexOrAlias)) {_                    return true__                }_            }_        }_        return false__    };identifies,whether,the,first,argument,an,array,containing,index,names,is,a,pattern,that,matches,all,indices,param,indices,or,aliases,the,array,containing,index,names,param,concrete,indices,array,containing,the,concrete,indices,that,the,first,argument,refers,to,return,true,if,the,first,argument,is,a,pattern,that,maps,to,all,available,indices,false,otherwise;boolean,is,pattern,matching,all,indices,meta,data,meta,data,string,indices,or,aliases,string,concrete,indices,if,concrete,indices,length,meta,data,get,concrete,all,indices,length,indices,or,aliases,length,0,if,indices,or,aliases,0,char,at,0,return,true,for,string,index,or,alias,indices,or,aliases,if,regex,is,simple,match,pattern,index,or,alias,return,true,return,false
IndexNameExpressionResolver -> boolean isPatternMatchingAllIndices(MetaData metaData, String[] indicesOrAliases, String[] concreteIndices);1532028790;Identifies whether the first argument (an array containing index names) is a pattern that matches all indices__@param indicesOrAliases the array containing index names_@param concreteIndices  array containing the concrete indices that the first argument refers to_@return true if the first argument is a pattern that maps to all available indices, false otherwise;boolean isPatternMatchingAllIndices(MetaData metaData, String[] indicesOrAliases, String[] concreteIndices) {_        _        if (concreteIndices.length == metaData.getConcreteAllIndices().length && indicesOrAliases.length > 0) {__            _            _            if (indicesOrAliases[0].charAt(0) == '-') {_                return true__            }__            _            for (String indexOrAlias : indicesOrAliases) {_                if (Regex.isSimpleMatchPattern(indexOrAlias)) {_                    return true__                }_            }_        }_        return false__    };identifies,whether,the,first,argument,an,array,containing,index,names,is,a,pattern,that,matches,all,indices,param,indices,or,aliases,the,array,containing,index,names,param,concrete,indices,array,containing,the,concrete,indices,that,the,first,argument,refers,to,return,true,if,the,first,argument,is,a,pattern,that,maps,to,all,available,indices,false,otherwise;boolean,is,pattern,matching,all,indices,meta,data,meta,data,string,indices,or,aliases,string,concrete,indices,if,concrete,indices,length,meta,data,get,concrete,all,indices,length,indices,or,aliases,length,0,if,indices,or,aliases,0,char,at,0,return,true,for,string,index,or,alias,indices,or,aliases,if,regex,is,simple,match,pattern,index,or,alias,return,true,return,false
IndexNameExpressionResolver -> boolean isPatternMatchingAllIndices(MetaData metaData, String[] indicesOrAliases, String[] concreteIndices);1538067637;Identifies whether the first argument (an array containing index names) is a pattern that matches all indices__@param indicesOrAliases the array containing index names_@param concreteIndices  array containing the concrete indices that the first argument refers to_@return true if the first argument is a pattern that maps to all available indices, false otherwise;boolean isPatternMatchingAllIndices(MetaData metaData, String[] indicesOrAliases, String[] concreteIndices) {_        _        if (concreteIndices.length == metaData.getConcreteAllIndices().length && indicesOrAliases.length > 0) {__            _            _            if (indicesOrAliases[0].charAt(0) == '-') {_                return true__            }__            _            for (String indexOrAlias : indicesOrAliases) {_                if (Regex.isSimpleMatchPattern(indexOrAlias)) {_                    return true__                }_            }_        }_        return false__    };identifies,whether,the,first,argument,an,array,containing,index,names,is,a,pattern,that,matches,all,indices,param,indices,or,aliases,the,array,containing,index,names,param,concrete,indices,array,containing,the,concrete,indices,that,the,first,argument,refers,to,return,true,if,the,first,argument,is,a,pattern,that,maps,to,all,available,indices,false,otherwise;boolean,is,pattern,matching,all,indices,meta,data,meta,data,string,indices,or,aliases,string,concrete,indices,if,concrete,indices,length,meta,data,get,concrete,all,indices,length,indices,or,aliases,length,0,if,indices,or,aliases,0,char,at,0,return,true,for,string,index,or,alias,indices,or,aliases,if,regex,is,simple,match,pattern,index,or,alias,return,true,return,false
IndexNameExpressionResolver -> boolean isPatternMatchingAllIndices(MetaData metaData, String[] indicesOrAliases, String[] concreteIndices);1539615817;Identifies whether the first argument (an array containing index names) is a pattern that matches all indices__@param indicesOrAliases the array containing index names_@param concreteIndices  array containing the concrete indices that the first argument refers to_@return true if the first argument is a pattern that maps to all available indices, false otherwise;boolean isPatternMatchingAllIndices(MetaData metaData, String[] indicesOrAliases, String[] concreteIndices) {_        _        if (concreteIndices.length == metaData.getConcreteAllIndices().length && indicesOrAliases.length > 0) {__            _            _            if (indicesOrAliases[0].charAt(0) == '-') {_                return true__            }__            _            for (String indexOrAlias : indicesOrAliases) {_                if (Regex.isSimpleMatchPattern(indexOrAlias)) {_                    return true__                }_            }_        }_        return false__    };identifies,whether,the,first,argument,an,array,containing,index,names,is,a,pattern,that,matches,all,indices,param,indices,or,aliases,the,array,containing,index,names,param,concrete,indices,array,containing,the,concrete,indices,that,the,first,argument,refers,to,return,true,if,the,first,argument,is,a,pattern,that,maps,to,all,available,indices,false,otherwise;boolean,is,pattern,matching,all,indices,meta,data,meta,data,string,indices,or,aliases,string,concrete,indices,if,concrete,indices,length,meta,data,get,concrete,all,indices,length,indices,or,aliases,length,0,if,indices,or,aliases,0,char,at,0,return,true,for,string,index,or,alias,indices,or,aliases,if,regex,is,simple,match,pattern,index,or,alias,return,true,return,false
IndexNameExpressionResolver -> boolean isPatternMatchingAllIndices(MetaData metaData, String[] indicesOrAliases, String[] concreteIndices);1540313026;Identifies whether the first argument (an array containing index names) is a pattern that matches all indices__@param indicesOrAliases the array containing index names_@param concreteIndices  array containing the concrete indices that the first argument refers to_@return true if the first argument is a pattern that maps to all available indices, false otherwise;boolean isPatternMatchingAllIndices(MetaData metaData, String[] indicesOrAliases, String[] concreteIndices) {_        _        if (concreteIndices.length == metaData.getConcreteAllIndices().length && indicesOrAliases.length > 0) {__            _            _            if (indicesOrAliases[0].charAt(0) == '-') {_                return true__            }__            _            for (String indexOrAlias : indicesOrAliases) {_                if (Regex.isSimpleMatchPattern(indexOrAlias)) {_                    return true__                }_            }_        }_        return false__    };identifies,whether,the,first,argument,an,array,containing,index,names,is,a,pattern,that,matches,all,indices,param,indices,or,aliases,the,array,containing,index,names,param,concrete,indices,array,containing,the,concrete,indices,that,the,first,argument,refers,to,return,true,if,the,first,argument,is,a,pattern,that,maps,to,all,available,indices,false,otherwise;boolean,is,pattern,matching,all,indices,meta,data,meta,data,string,indices,or,aliases,string,concrete,indices,if,concrete,indices,length,meta,data,get,concrete,all,indices,length,indices,or,aliases,length,0,if,indices,or,aliases,0,char,at,0,return,true,for,string,index,or,alias,indices,or,aliases,if,regex,is,simple,match,pattern,index,or,alias,return,true,return,false
IndexNameExpressionResolver -> boolean isPatternMatchingAllIndices(MetaData metaData, String[] indicesOrAliases, String[] concreteIndices);1540847035;Identifies whether the first argument (an array containing index names) is a pattern that matches all indices__@param indicesOrAliases the array containing index names_@param concreteIndices  array containing the concrete indices that the first argument refers to_@return true if the first argument is a pattern that maps to all available indices, false otherwise;boolean isPatternMatchingAllIndices(MetaData metaData, String[] indicesOrAliases, String[] concreteIndices) {_        _        if (concreteIndices.length == metaData.getConcreteAllIndices().length && indicesOrAliases.length > 0) {__            _            _            if (indicesOrAliases[0].charAt(0) == '-') {_                return true__            }__            _            for (String indexOrAlias : indicesOrAliases) {_                if (Regex.isSimpleMatchPattern(indexOrAlias)) {_                    return true__                }_            }_        }_        return false__    };identifies,whether,the,first,argument,an,array,containing,index,names,is,a,pattern,that,matches,all,indices,param,indices,or,aliases,the,array,containing,index,names,param,concrete,indices,array,containing,the,concrete,indices,that,the,first,argument,refers,to,return,true,if,the,first,argument,is,a,pattern,that,maps,to,all,available,indices,false,otherwise;boolean,is,pattern,matching,all,indices,meta,data,meta,data,string,indices,or,aliases,string,concrete,indices,if,concrete,indices,length,meta,data,get,concrete,all,indices,length,indices,or,aliases,length,0,if,indices,or,aliases,0,char,at,0,return,true,for,string,index,or,alias,indices,or,aliases,if,regex,is,simple,match,pattern,index,or,alias,return,true,return,false
IndexNameExpressionResolver -> boolean isPatternMatchingAllIndices(MetaData metaData, String[] indicesOrAliases, String[] concreteIndices);1541092382;Identifies whether the first argument (an array containing index names) is a pattern that matches all indices__@param indicesOrAliases the array containing index names_@param concreteIndices  array containing the concrete indices that the first argument refers to_@return true if the first argument is a pattern that maps to all available indices, false otherwise;boolean isPatternMatchingAllIndices(MetaData metaData, String[] indicesOrAliases, String[] concreteIndices) {_        _        if (concreteIndices.length == metaData.getConcreteAllIndices().length && indicesOrAliases.length > 0) {__            _            _            if (indicesOrAliases[0].charAt(0) == '-') {_                return true__            }__            _            for (String indexOrAlias : indicesOrAliases) {_                if (Regex.isSimpleMatchPattern(indexOrAlias)) {_                    return true__                }_            }_        }_        return false__    };identifies,whether,the,first,argument,an,array,containing,index,names,is,a,pattern,that,matches,all,indices,param,indices,or,aliases,the,array,containing,index,names,param,concrete,indices,array,containing,the,concrete,indices,that,the,first,argument,refers,to,return,true,if,the,first,argument,is,a,pattern,that,maps,to,all,available,indices,false,otherwise;boolean,is,pattern,matching,all,indices,meta,data,meta,data,string,indices,or,aliases,string,concrete,indices,if,concrete,indices,length,meta,data,get,concrete,all,indices,length,indices,or,aliases,length,0,if,indices,or,aliases,0,char,at,0,return,true,for,string,index,or,alias,indices,or,aliases,if,regex,is,simple,match,pattern,index,or,alias,return,true,return,false
IndexNameExpressionResolver -> boolean isPatternMatchingAllIndices(MetaData metaData, String[] indicesOrAliases, String[] concreteIndices);1541493930;Identifies whether the first argument (an array containing index names) is a pattern that matches all indices__@param indicesOrAliases the array containing index names_@param concreteIndices  array containing the concrete indices that the first argument refers to_@return true if the first argument is a pattern that maps to all available indices, false otherwise;boolean isPatternMatchingAllIndices(MetaData metaData, String[] indicesOrAliases, String[] concreteIndices) {_        _        if (concreteIndices.length == metaData.getConcreteAllIndices().length && indicesOrAliases.length > 0) {__            _            _            if (indicesOrAliases[0].charAt(0) == '-') {_                return true__            }__            _            for (String indexOrAlias : indicesOrAliases) {_                if (Regex.isSimpleMatchPattern(indexOrAlias)) {_                    return true__                }_            }_        }_        return false__    };identifies,whether,the,first,argument,an,array,containing,index,names,is,a,pattern,that,matches,all,indices,param,indices,or,aliases,the,array,containing,index,names,param,concrete,indices,array,containing,the,concrete,indices,that,the,first,argument,refers,to,return,true,if,the,first,argument,is,a,pattern,that,maps,to,all,available,indices,false,otherwise;boolean,is,pattern,matching,all,indices,meta,data,meta,data,string,indices,or,aliases,string,concrete,indices,if,concrete,indices,length,meta,data,get,concrete,all,indices,length,indices,or,aliases,length,0,if,indices,or,aliases,0,char,at,0,return,true,for,string,index,or,alias,indices,or,aliases,if,regex,is,simple,match,pattern,index,or,alias,return,true,return,false
IndexNameExpressionResolver -> boolean isPatternMatchingAllIndices(MetaData metaData, String[] indicesOrAliases, String[] concreteIndices);1541612607;Identifies whether the first argument (an array containing index names) is a pattern that matches all indices__@param indicesOrAliases the array containing index names_@param concreteIndices  array containing the concrete indices that the first argument refers to_@return true if the first argument is a pattern that maps to all available indices, false otherwise;boolean isPatternMatchingAllIndices(MetaData metaData, String[] indicesOrAliases, String[] concreteIndices) {_        _        if (concreteIndices.length == metaData.getConcreteAllIndices().length && indicesOrAliases.length > 0) {__            _            _            if (indicesOrAliases[0].charAt(0) == '-') {_                return true__            }__            _            for (String indexOrAlias : indicesOrAliases) {_                if (Regex.isSimpleMatchPattern(indexOrAlias)) {_                    return true__                }_            }_        }_        return false__    };identifies,whether,the,first,argument,an,array,containing,index,names,is,a,pattern,that,matches,all,indices,param,indices,or,aliases,the,array,containing,index,names,param,concrete,indices,array,containing,the,concrete,indices,that,the,first,argument,refers,to,return,true,if,the,first,argument,is,a,pattern,that,maps,to,all,available,indices,false,otherwise;boolean,is,pattern,matching,all,indices,meta,data,meta,data,string,indices,or,aliases,string,concrete,indices,if,concrete,indices,length,meta,data,get,concrete,all,indices,length,indices,or,aliases,length,0,if,indices,or,aliases,0,char,at,0,return,true,for,string,index,or,alias,indices,or,aliases,if,regex,is,simple,match,pattern,index,or,alias,return,true,return,false
IndexNameExpressionResolver -> boolean isPatternMatchingAllIndices(MetaData metaData, String[] indicesOrAliases, String[] concreteIndices);1544215214;Identifies whether the first argument (an array containing index names) is a pattern that matches all indices__@param indicesOrAliases the array containing index names_@param concreteIndices  array containing the concrete indices that the first argument refers to_@return true if the first argument is a pattern that maps to all available indices, false otherwise;boolean isPatternMatchingAllIndices(MetaData metaData, String[] indicesOrAliases, String[] concreteIndices) {_        _        if (concreteIndices.length == metaData.getConcreteAllIndices().length && indicesOrAliases.length > 0) {__            _            _            if (indicesOrAliases[0].charAt(0) == '-') {_                return true__            }__            _            for (String indexOrAlias : indicesOrAliases) {_                if (Regex.isSimpleMatchPattern(indexOrAlias)) {_                    return true__                }_            }_        }_        return false__    };identifies,whether,the,first,argument,an,array,containing,index,names,is,a,pattern,that,matches,all,indices,param,indices,or,aliases,the,array,containing,index,names,param,concrete,indices,array,containing,the,concrete,indices,that,the,first,argument,refers,to,return,true,if,the,first,argument,is,a,pattern,that,maps,to,all,available,indices,false,otherwise;boolean,is,pattern,matching,all,indices,meta,data,meta,data,string,indices,or,aliases,string,concrete,indices,if,concrete,indices,length,meta,data,get,concrete,all,indices,length,indices,or,aliases,length,0,if,indices,or,aliases,0,char,at,0,return,true,for,string,index,or,alias,indices,or,aliases,if,regex,is,simple,match,pattern,index,or,alias,return,true,return,false
IndexNameExpressionResolver -> boolean isPatternMatchingAllIndices(MetaData metaData, String[] indicesOrAliases, String[] concreteIndices);1548236405;Identifies whether the first argument (an array containing index names) is a pattern that matches all indices__@param indicesOrAliases the array containing index names_@param concreteIndices  array containing the concrete indices that the first argument refers to_@return true if the first argument is a pattern that maps to all available indices, false otherwise;boolean isPatternMatchingAllIndices(MetaData metaData, String[] indicesOrAliases, String[] concreteIndices) {_        _        if (concreteIndices.length == metaData.getConcreteAllIndices().length && indicesOrAliases.length > 0) {__            _            _            if (indicesOrAliases[0].charAt(0) == '-') {_                return true__            }__            _            for (String indexOrAlias : indicesOrAliases) {_                if (Regex.isSimpleMatchPattern(indexOrAlias)) {_                    return true__                }_            }_        }_        return false__    };identifies,whether,the,first,argument,an,array,containing,index,names,is,a,pattern,that,matches,all,indices,param,indices,or,aliases,the,array,containing,index,names,param,concrete,indices,array,containing,the,concrete,indices,that,the,first,argument,refers,to,return,true,if,the,first,argument,is,a,pattern,that,maps,to,all,available,indices,false,otherwise;boolean,is,pattern,matching,all,indices,meta,data,meta,data,string,indices,or,aliases,string,concrete,indices,if,concrete,indices,length,meta,data,get,concrete,all,indices,length,indices,or,aliases,length,0,if,indices,or,aliases,0,char,at,0,return,true,for,string,index,or,alias,indices,or,aliases,if,regex,is,simple,match,pattern,index,or,alias,return,true,return,false
IndexNameExpressionResolver -> public String[] concreteIndexNames(ClusterState state, IndicesOptions options, String... indexExpressions);1524684173;Translates the provided index expression into actual concrete indices, properly deduplicated.__@param state             the cluster state containing all the data to resolve to expressions to concrete indices_@param options           defines how the aliases or indices need to be resolved to concrete indices_@param indexExpressions  expressions that can be resolved to alias or index names._@return the resolved concrete indices based on the cluster state, indices options and index expressions_@throws IndexNotFoundException if one of the index expressions is pointing to a missing index or alias and the_provided indices options in the context don't allow such a case, or if the final result of the indices resolution_contains no indices and the indices options in the context don't allow such a case._@throws IllegalArgumentException if one of the aliases resolve to multiple indices and the provided_indices options in the context don't allow such a case.;public String[] concreteIndexNames(ClusterState state, IndicesOptions options, String... indexExpressions) {_        Context context = new Context(state, options)__        return concreteIndexNames(context, indexExpressions)__    };translates,the,provided,index,expression,into,actual,concrete,indices,properly,deduplicated,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expressions,to,concrete,indices,param,options,defines,how,the,aliases,or,indices,need,to,be,resolved,to,concrete,indices,param,index,expressions,expressions,that,can,be,resolved,to,alias,or,index,names,return,the,resolved,concrete,indices,based,on,the,cluster,state,indices,options,and,index,expressions,throws,index,not,found,exception,if,one,of,the,index,expressions,is,pointing,to,a,missing,index,or,alias,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case,or,if,the,final,result,of,the,indices,resolution,contains,no,indices,and,the,indices,options,in,the,context,don,t,allow,such,a,case,throws,illegal,argument,exception,if,one,of,the,aliases,resolve,to,multiple,indices,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case;public,string,concrete,index,names,cluster,state,state,indices,options,options,string,index,expressions,context,context,new,context,state,options,return,concrete,index,names,context,index,expressions
IndexNameExpressionResolver -> public String[] concreteIndexNames(ClusterState state, IndicesOptions options, String... indexExpressions);1525334055;Translates the provided index expression into actual concrete indices, properly deduplicated.__@param state             the cluster state containing all the data to resolve to expressions to concrete indices_@param options           defines how the aliases or indices need to be resolved to concrete indices_@param indexExpressions  expressions that can be resolved to alias or index names._@return the resolved concrete indices based on the cluster state, indices options and index expressions_@throws IndexNotFoundException if one of the index expressions is pointing to a missing index or alias and the_provided indices options in the context don't allow such a case, or if the final result of the indices resolution_contains no indices and the indices options in the context don't allow such a case._@throws IllegalArgumentException if one of the aliases resolve to multiple indices and the provided_indices options in the context don't allow such a case.;public String[] concreteIndexNames(ClusterState state, IndicesOptions options, String... indexExpressions) {_        Context context = new Context(state, options)__        return concreteIndexNames(context, indexExpressions)__    };translates,the,provided,index,expression,into,actual,concrete,indices,properly,deduplicated,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expressions,to,concrete,indices,param,options,defines,how,the,aliases,or,indices,need,to,be,resolved,to,concrete,indices,param,index,expressions,expressions,that,can,be,resolved,to,alias,or,index,names,return,the,resolved,concrete,indices,based,on,the,cluster,state,indices,options,and,index,expressions,throws,index,not,found,exception,if,one,of,the,index,expressions,is,pointing,to,a,missing,index,or,alias,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case,or,if,the,final,result,of,the,indices,resolution,contains,no,indices,and,the,indices,options,in,the,context,don,t,allow,such,a,case,throws,illegal,argument,exception,if,one,of,the,aliases,resolve,to,multiple,indices,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case;public,string,concrete,index,names,cluster,state,state,indices,options,options,string,index,expressions,context,context,new,context,state,options,return,concrete,index,names,context,index,expressions
IndexNameExpressionResolver -> public String[] concreteIndexNames(ClusterState state, IndicesOptions options, String... indexExpressions);1532028790;Translates the provided index expression into actual concrete indices, properly deduplicated.__@param state             the cluster state containing all the data to resolve to expressions to concrete indices_@param options           defines how the aliases or indices need to be resolved to concrete indices_@param indexExpressions  expressions that can be resolved to alias or index names._@return the resolved concrete indices based on the cluster state, indices options and index expressions_@throws IndexNotFoundException if one of the index expressions is pointing to a missing index or alias and the_provided indices options in the context don't allow such a case, or if the final result of the indices resolution_contains no indices and the indices options in the context don't allow such a case._@throws IllegalArgumentException if one of the aliases resolve to multiple indices and the provided_indices options in the context don't allow such a case.;public String[] concreteIndexNames(ClusterState state, IndicesOptions options, String... indexExpressions) {_        Context context = new Context(state, options)__        return concreteIndexNames(context, indexExpressions)__    };translates,the,provided,index,expression,into,actual,concrete,indices,properly,deduplicated,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expressions,to,concrete,indices,param,options,defines,how,the,aliases,or,indices,need,to,be,resolved,to,concrete,indices,param,index,expressions,expressions,that,can,be,resolved,to,alias,or,index,names,return,the,resolved,concrete,indices,based,on,the,cluster,state,indices,options,and,index,expressions,throws,index,not,found,exception,if,one,of,the,index,expressions,is,pointing,to,a,missing,index,or,alias,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case,or,if,the,final,result,of,the,indices,resolution,contains,no,indices,and,the,indices,options,in,the,context,don,t,allow,such,a,case,throws,illegal,argument,exception,if,one,of,the,aliases,resolve,to,multiple,indices,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case;public,string,concrete,index,names,cluster,state,state,indices,options,options,string,index,expressions,context,context,new,context,state,options,return,concrete,index,names,context,index,expressions
IndexNameExpressionResolver -> public String[] concreteIndexNames(ClusterState state, IndicesOptions options, String... indexExpressions);1538067637;Translates the provided index expression into actual concrete indices, properly deduplicated.__@param state             the cluster state containing all the data to resolve to expressions to concrete indices_@param options           defines how the aliases or indices need to be resolved to concrete indices_@param indexExpressions  expressions that can be resolved to alias or index names._@return the resolved concrete indices based on the cluster state, indices options and index expressions_@throws IndexNotFoundException if one of the index expressions is pointing to a missing index or alias and the_provided indices options in the context don't allow such a case, or if the final result of the indices resolution_contains no indices and the indices options in the context don't allow such a case._@throws IllegalArgumentException if one of the aliases resolve to multiple indices and the provided_indices options in the context don't allow such a case.;public String[] concreteIndexNames(ClusterState state, IndicesOptions options, String... indexExpressions) {_        Context context = new Context(state, options)__        return concreteIndexNames(context, indexExpressions)__    };translates,the,provided,index,expression,into,actual,concrete,indices,properly,deduplicated,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expressions,to,concrete,indices,param,options,defines,how,the,aliases,or,indices,need,to,be,resolved,to,concrete,indices,param,index,expressions,expressions,that,can,be,resolved,to,alias,or,index,names,return,the,resolved,concrete,indices,based,on,the,cluster,state,indices,options,and,index,expressions,throws,index,not,found,exception,if,one,of,the,index,expressions,is,pointing,to,a,missing,index,or,alias,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case,or,if,the,final,result,of,the,indices,resolution,contains,no,indices,and,the,indices,options,in,the,context,don,t,allow,such,a,case,throws,illegal,argument,exception,if,one,of,the,aliases,resolve,to,multiple,indices,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case;public,string,concrete,index,names,cluster,state,state,indices,options,options,string,index,expressions,context,context,new,context,state,options,return,concrete,index,names,context,index,expressions
IndexNameExpressionResolver -> public String[] concreteIndexNames(ClusterState state, IndicesOptions options, String... indexExpressions);1539615817;Translates the provided index expression into actual concrete indices, properly deduplicated.__@param state             the cluster state containing all the data to resolve to expressions to concrete indices_@param options           defines how the aliases or indices need to be resolved to concrete indices_@param indexExpressions  expressions that can be resolved to alias or index names._@return the resolved concrete indices based on the cluster state, indices options and index expressions_@throws IndexNotFoundException if one of the index expressions is pointing to a missing index or alias and the_provided indices options in the context don't allow such a case, or if the final result of the indices resolution_contains no indices and the indices options in the context don't allow such a case._@throws IllegalArgumentException if one of the aliases resolve to multiple indices and the provided_indices options in the context don't allow such a case.;public String[] concreteIndexNames(ClusterState state, IndicesOptions options, String... indexExpressions) {_        Context context = new Context(state, options)__        return concreteIndexNames(context, indexExpressions)__    };translates,the,provided,index,expression,into,actual,concrete,indices,properly,deduplicated,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expressions,to,concrete,indices,param,options,defines,how,the,aliases,or,indices,need,to,be,resolved,to,concrete,indices,param,index,expressions,expressions,that,can,be,resolved,to,alias,or,index,names,return,the,resolved,concrete,indices,based,on,the,cluster,state,indices,options,and,index,expressions,throws,index,not,found,exception,if,one,of,the,index,expressions,is,pointing,to,a,missing,index,or,alias,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case,or,if,the,final,result,of,the,indices,resolution,contains,no,indices,and,the,indices,options,in,the,context,don,t,allow,such,a,case,throws,illegal,argument,exception,if,one,of,the,aliases,resolve,to,multiple,indices,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case;public,string,concrete,index,names,cluster,state,state,indices,options,options,string,index,expressions,context,context,new,context,state,options,return,concrete,index,names,context,index,expressions
IndexNameExpressionResolver -> public String[] concreteIndexNames(ClusterState state, IndicesOptions options, String... indexExpressions);1540313026;Translates the provided index expression into actual concrete indices, properly deduplicated.__@param state             the cluster state containing all the data to resolve to expressions to concrete indices_@param options           defines how the aliases or indices need to be resolved to concrete indices_@param indexExpressions  expressions that can be resolved to alias or index names._@return the resolved concrete indices based on the cluster state, indices options and index expressions_@throws IndexNotFoundException if one of the index expressions is pointing to a missing index or alias and the_provided indices options in the context don't allow such a case, or if the final result of the indices resolution_contains no indices and the indices options in the context don't allow such a case._@throws IllegalArgumentException if one of the aliases resolve to multiple indices and the provided_indices options in the context don't allow such a case.;public String[] concreteIndexNames(ClusterState state, IndicesOptions options, String... indexExpressions) {_        Context context = new Context(state, options)__        return concreteIndexNames(context, indexExpressions)__    };translates,the,provided,index,expression,into,actual,concrete,indices,properly,deduplicated,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expressions,to,concrete,indices,param,options,defines,how,the,aliases,or,indices,need,to,be,resolved,to,concrete,indices,param,index,expressions,expressions,that,can,be,resolved,to,alias,or,index,names,return,the,resolved,concrete,indices,based,on,the,cluster,state,indices,options,and,index,expressions,throws,index,not,found,exception,if,one,of,the,index,expressions,is,pointing,to,a,missing,index,or,alias,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case,or,if,the,final,result,of,the,indices,resolution,contains,no,indices,and,the,indices,options,in,the,context,don,t,allow,such,a,case,throws,illegal,argument,exception,if,one,of,the,aliases,resolve,to,multiple,indices,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case;public,string,concrete,index,names,cluster,state,state,indices,options,options,string,index,expressions,context,context,new,context,state,options,return,concrete,index,names,context,index,expressions
IndexNameExpressionResolver -> public String[] concreteIndexNames(ClusterState state, IndicesOptions options, String... indexExpressions);1540847035;Translates the provided index expression into actual concrete indices, properly deduplicated.__@param state             the cluster state containing all the data to resolve to expressions to concrete indices_@param options           defines how the aliases or indices need to be resolved to concrete indices_@param indexExpressions  expressions that can be resolved to alias or index names._@return the resolved concrete indices based on the cluster state, indices options and index expressions_@throws IndexNotFoundException if one of the index expressions is pointing to a missing index or alias and the_provided indices options in the context don't allow such a case, or if the final result of the indices resolution_contains no indices and the indices options in the context don't allow such a case._@throws IllegalArgumentException if one of the aliases resolve to multiple indices and the provided_indices options in the context don't allow such a case.;public String[] concreteIndexNames(ClusterState state, IndicesOptions options, String... indexExpressions) {_        Context context = new Context(state, options)__        return concreteIndexNames(context, indexExpressions)__    };translates,the,provided,index,expression,into,actual,concrete,indices,properly,deduplicated,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expressions,to,concrete,indices,param,options,defines,how,the,aliases,or,indices,need,to,be,resolved,to,concrete,indices,param,index,expressions,expressions,that,can,be,resolved,to,alias,or,index,names,return,the,resolved,concrete,indices,based,on,the,cluster,state,indices,options,and,index,expressions,throws,index,not,found,exception,if,one,of,the,index,expressions,is,pointing,to,a,missing,index,or,alias,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case,or,if,the,final,result,of,the,indices,resolution,contains,no,indices,and,the,indices,options,in,the,context,don,t,allow,such,a,case,throws,illegal,argument,exception,if,one,of,the,aliases,resolve,to,multiple,indices,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case;public,string,concrete,index,names,cluster,state,state,indices,options,options,string,index,expressions,context,context,new,context,state,options,return,concrete,index,names,context,index,expressions
IndexNameExpressionResolver -> public String[] concreteIndexNames(ClusterState state, IndicesOptions options, String... indexExpressions);1541092382;Translates the provided index expression into actual concrete indices, properly deduplicated.__@param state             the cluster state containing all the data to resolve to expressions to concrete indices_@param options           defines how the aliases or indices need to be resolved to concrete indices_@param indexExpressions  expressions that can be resolved to alias or index names._@return the resolved concrete indices based on the cluster state, indices options and index expressions_@throws IndexNotFoundException if one of the index expressions is pointing to a missing index or alias and the_provided indices options in the context don't allow such a case, or if the final result of the indices resolution_contains no indices and the indices options in the context don't allow such a case._@throws IllegalArgumentException if one of the aliases resolve to multiple indices and the provided_indices options in the context don't allow such a case.;public String[] concreteIndexNames(ClusterState state, IndicesOptions options, String... indexExpressions) {_        Context context = new Context(state, options)__        return concreteIndexNames(context, indexExpressions)__    };translates,the,provided,index,expression,into,actual,concrete,indices,properly,deduplicated,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expressions,to,concrete,indices,param,options,defines,how,the,aliases,or,indices,need,to,be,resolved,to,concrete,indices,param,index,expressions,expressions,that,can,be,resolved,to,alias,or,index,names,return,the,resolved,concrete,indices,based,on,the,cluster,state,indices,options,and,index,expressions,throws,index,not,found,exception,if,one,of,the,index,expressions,is,pointing,to,a,missing,index,or,alias,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case,or,if,the,final,result,of,the,indices,resolution,contains,no,indices,and,the,indices,options,in,the,context,don,t,allow,such,a,case,throws,illegal,argument,exception,if,one,of,the,aliases,resolve,to,multiple,indices,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case;public,string,concrete,index,names,cluster,state,state,indices,options,options,string,index,expressions,context,context,new,context,state,options,return,concrete,index,names,context,index,expressions
IndexNameExpressionResolver -> public String[] concreteIndexNames(ClusterState state, IndicesOptions options, String... indexExpressions);1541493930;Translates the provided index expression into actual concrete indices, properly deduplicated.__@param state             the cluster state containing all the data to resolve to expressions to concrete indices_@param options           defines how the aliases or indices need to be resolved to concrete indices_@param indexExpressions  expressions that can be resolved to alias or index names._@return the resolved concrete indices based on the cluster state, indices options and index expressions_@throws IndexNotFoundException if one of the index expressions is pointing to a missing index or alias and the_provided indices options in the context don't allow such a case, or if the final result of the indices resolution_contains no indices and the indices options in the context don't allow such a case._@throws IllegalArgumentException if one of the aliases resolve to multiple indices and the provided_indices options in the context don't allow such a case.;public String[] concreteIndexNames(ClusterState state, IndicesOptions options, String... indexExpressions) {_        Context context = new Context(state, options)__        return concreteIndexNames(context, indexExpressions)__    };translates,the,provided,index,expression,into,actual,concrete,indices,properly,deduplicated,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expressions,to,concrete,indices,param,options,defines,how,the,aliases,or,indices,need,to,be,resolved,to,concrete,indices,param,index,expressions,expressions,that,can,be,resolved,to,alias,or,index,names,return,the,resolved,concrete,indices,based,on,the,cluster,state,indices,options,and,index,expressions,throws,index,not,found,exception,if,one,of,the,index,expressions,is,pointing,to,a,missing,index,or,alias,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case,or,if,the,final,result,of,the,indices,resolution,contains,no,indices,and,the,indices,options,in,the,context,don,t,allow,such,a,case,throws,illegal,argument,exception,if,one,of,the,aliases,resolve,to,multiple,indices,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case;public,string,concrete,index,names,cluster,state,state,indices,options,options,string,index,expressions,context,context,new,context,state,options,return,concrete,index,names,context,index,expressions
IndexNameExpressionResolver -> public String[] concreteIndexNames(ClusterState state, IndicesOptions options, String... indexExpressions);1541612607;Translates the provided index expression into actual concrete indices, properly deduplicated.__@param state             the cluster state containing all the data to resolve to expressions to concrete indices_@param options           defines how the aliases or indices need to be resolved to concrete indices_@param indexExpressions  expressions that can be resolved to alias or index names._@return the resolved concrete indices based on the cluster state, indices options and index expressions_@throws IndexNotFoundException if one of the index expressions is pointing to a missing index or alias and the_provided indices options in the context don't allow such a case, or if the final result of the indices resolution_contains no indices and the indices options in the context don't allow such a case._@throws IllegalArgumentException if one of the aliases resolve to multiple indices and the provided_indices options in the context don't allow such a case.;public String[] concreteIndexNames(ClusterState state, IndicesOptions options, String... indexExpressions) {_        Context context = new Context(state, options)__        return concreteIndexNames(context, indexExpressions)__    };translates,the,provided,index,expression,into,actual,concrete,indices,properly,deduplicated,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expressions,to,concrete,indices,param,options,defines,how,the,aliases,or,indices,need,to,be,resolved,to,concrete,indices,param,index,expressions,expressions,that,can,be,resolved,to,alias,or,index,names,return,the,resolved,concrete,indices,based,on,the,cluster,state,indices,options,and,index,expressions,throws,index,not,found,exception,if,one,of,the,index,expressions,is,pointing,to,a,missing,index,or,alias,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case,or,if,the,final,result,of,the,indices,resolution,contains,no,indices,and,the,indices,options,in,the,context,don,t,allow,such,a,case,throws,illegal,argument,exception,if,one,of,the,aliases,resolve,to,multiple,indices,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case;public,string,concrete,index,names,cluster,state,state,indices,options,options,string,index,expressions,context,context,new,context,state,options,return,concrete,index,names,context,index,expressions
IndexNameExpressionResolver -> public String[] concreteIndexNames(ClusterState state, IndicesOptions options, String... indexExpressions);1544215214;Translates the provided index expression into actual concrete indices, properly deduplicated.__@param state             the cluster state containing all the data to resolve to expressions to concrete indices_@param options           defines how the aliases or indices need to be resolved to concrete indices_@param indexExpressions  expressions that can be resolved to alias or index names._@return the resolved concrete indices based on the cluster state, indices options and index expressions_@throws IndexNotFoundException if one of the index expressions is pointing to a missing index or alias and the_provided indices options in the context don't allow such a case, or if the final result of the indices resolution_contains no indices and the indices options in the context don't allow such a case._@throws IllegalArgumentException if one of the aliases resolve to multiple indices and the provided_indices options in the context don't allow such a case.;public String[] concreteIndexNames(ClusterState state, IndicesOptions options, String... indexExpressions) {_        Context context = new Context(state, options)__        return concreteIndexNames(context, indexExpressions)__    };translates,the,provided,index,expression,into,actual,concrete,indices,properly,deduplicated,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expressions,to,concrete,indices,param,options,defines,how,the,aliases,or,indices,need,to,be,resolved,to,concrete,indices,param,index,expressions,expressions,that,can,be,resolved,to,alias,or,index,names,return,the,resolved,concrete,indices,based,on,the,cluster,state,indices,options,and,index,expressions,throws,index,not,found,exception,if,one,of,the,index,expressions,is,pointing,to,a,missing,index,or,alias,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case,or,if,the,final,result,of,the,indices,resolution,contains,no,indices,and,the,indices,options,in,the,context,don,t,allow,such,a,case,throws,illegal,argument,exception,if,one,of,the,aliases,resolve,to,multiple,indices,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case;public,string,concrete,index,names,cluster,state,state,indices,options,options,string,index,expressions,context,context,new,context,state,options,return,concrete,index,names,context,index,expressions
IndexNameExpressionResolver -> public String[] concreteIndexNames(ClusterState state, IndicesOptions options, String... indexExpressions);1548236405;Translates the provided index expression into actual concrete indices, properly deduplicated.__@param state             the cluster state containing all the data to resolve to expressions to concrete indices_@param options           defines how the aliases or indices need to be resolved to concrete indices_@param indexExpressions  expressions that can be resolved to alias or index names._@return the resolved concrete indices based on the cluster state, indices options and index expressions_@throws IndexNotFoundException if one of the index expressions is pointing to a missing index or alias and the_provided indices options in the context don't allow such a case, or if the final result of the indices resolution_contains no indices and the indices options in the context don't allow such a case._@throws IllegalArgumentException if one of the aliases resolve to multiple indices and the provided_indices options in the context don't allow such a case.;public String[] concreteIndexNames(ClusterState state, IndicesOptions options, String... indexExpressions) {_        Context context = new Context(state, options)__        return concreteIndexNames(context, indexExpressions)__    };translates,the,provided,index,expression,into,actual,concrete,indices,properly,deduplicated,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expressions,to,concrete,indices,param,options,defines,how,the,aliases,or,indices,need,to,be,resolved,to,concrete,indices,param,index,expressions,expressions,that,can,be,resolved,to,alias,or,index,names,return,the,resolved,concrete,indices,based,on,the,cluster,state,indices,options,and,index,expressions,throws,index,not,found,exception,if,one,of,the,index,expressions,is,pointing,to,a,missing,index,or,alias,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case,or,if,the,final,result,of,the,indices,resolution,contains,no,indices,and,the,indices,options,in,the,context,don,t,allow,such,a,case,throws,illegal,argument,exception,if,one,of,the,aliases,resolve,to,multiple,indices,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case;public,string,concrete,index,names,cluster,state,state,indices,options,options,string,index,expressions,context,context,new,context,state,options,return,concrete,index,names,context,index,expressions
IndexNameExpressionResolver -> public final boolean matchesIndex(String indexName, String expression, ClusterState state);1524684173;Returns <code>true</code> iff the given expression resolves to the given index name otherwise <code>false</code>;public final boolean matchesIndex(String indexName, String expression, ClusterState state) {_        final String[] concreteIndices = concreteIndexNames(state, IndicesOptions.lenientExpandOpen(), expression)__        for (String index : concreteIndices) {_            if (Regex.simpleMatch(index, indexName)) {_                return true__            }_        }_        return indexName.equals(expression)__    };returns,code,true,code,iff,the,given,expression,resolves,to,the,given,index,name,otherwise,code,false,code;public,final,boolean,matches,index,string,index,name,string,expression,cluster,state,state,final,string,concrete,indices,concrete,index,names,state,indices,options,lenient,expand,open,expression,for,string,index,concrete,indices,if,regex,simple,match,index,index,name,return,true,return,index,name,equals,expression
IndexNameExpressionResolver -> public final boolean matchesIndex(String indexName, String expression, ClusterState state);1525334055;Returns <code>true</code> iff the given expression resolves to the given index name otherwise <code>false</code>;public final boolean matchesIndex(String indexName, String expression, ClusterState state) {_        final String[] concreteIndices = concreteIndexNames(state, IndicesOptions.lenientExpandOpen(), expression)__        for (String index : concreteIndices) {_            if (Regex.simpleMatch(index, indexName)) {_                return true__            }_        }_        return indexName.equals(expression)__    };returns,code,true,code,iff,the,given,expression,resolves,to,the,given,index,name,otherwise,code,false,code;public,final,boolean,matches,index,string,index,name,string,expression,cluster,state,state,final,string,concrete,indices,concrete,index,names,state,indices,options,lenient,expand,open,expression,for,string,index,concrete,indices,if,regex,simple,match,index,index,name,return,true,return,index,name,equals,expression
IndexNameExpressionResolver -> public final boolean matchesIndex(String indexName, String expression, ClusterState state);1532028790;Returns <code>true</code> iff the given expression resolves to the given index name otherwise <code>false</code>;public final boolean matchesIndex(String indexName, String expression, ClusterState state) {_        final String[] concreteIndices = concreteIndexNames(state, IndicesOptions.lenientExpandOpen(), expression)__        for (String index : concreteIndices) {_            if (Regex.simpleMatch(index, indexName)) {_                return true__            }_        }_        return indexName.equals(expression)__    };returns,code,true,code,iff,the,given,expression,resolves,to,the,given,index,name,otherwise,code,false,code;public,final,boolean,matches,index,string,index,name,string,expression,cluster,state,state,final,string,concrete,indices,concrete,index,names,state,indices,options,lenient,expand,open,expression,for,string,index,concrete,indices,if,regex,simple,match,index,index,name,return,true,return,index,name,equals,expression
IndexNameExpressionResolver -> public final boolean matchesIndex(String indexName, String expression, ClusterState state);1538067637;Returns <code>true</code> iff the given expression resolves to the given index name otherwise <code>false</code>;public final boolean matchesIndex(String indexName, String expression, ClusterState state) {_        final String[] concreteIndices = concreteIndexNames(state, IndicesOptions.lenientExpandOpen(), expression)__        for (String index : concreteIndices) {_            if (Regex.simpleMatch(index, indexName)) {_                return true__            }_        }_        return indexName.equals(expression)__    };returns,code,true,code,iff,the,given,expression,resolves,to,the,given,index,name,otherwise,code,false,code;public,final,boolean,matches,index,string,index,name,string,expression,cluster,state,state,final,string,concrete,indices,concrete,index,names,state,indices,options,lenient,expand,open,expression,for,string,index,concrete,indices,if,regex,simple,match,index,index,name,return,true,return,index,name,equals,expression
IndexNameExpressionResolver -> public final boolean matchesIndex(String indexName, String expression, ClusterState state);1539615817;Returns <code>true</code> iff the given expression resolves to the given index name otherwise <code>false</code>;public final boolean matchesIndex(String indexName, String expression, ClusterState state) {_        final String[] concreteIndices = concreteIndexNames(state, IndicesOptions.lenientExpandOpen(), expression)__        for (String index : concreteIndices) {_            if (Regex.simpleMatch(index, indexName)) {_                return true__            }_        }_        return indexName.equals(expression)__    };returns,code,true,code,iff,the,given,expression,resolves,to,the,given,index,name,otherwise,code,false,code;public,final,boolean,matches,index,string,index,name,string,expression,cluster,state,state,final,string,concrete,indices,concrete,index,names,state,indices,options,lenient,expand,open,expression,for,string,index,concrete,indices,if,regex,simple,match,index,index,name,return,true,return,index,name,equals,expression
IndexNameExpressionResolver -> Context -> boolean isResolveToWriteIndex();1532028790;This is used to require that aliases resolve to their write-index. It is currently not used in conjunction_with <code>preserveAliases</code>.;boolean isResolveToWriteIndex() {_            return resolveToWriteIndex__        };this,is,used,to,require,that,aliases,resolve,to,their,write,index,it,is,currently,not,used,in,conjunction,with,code,preserve,aliases,code;boolean,is,resolve,to,write,index,return,resolve,to,write,index
IndexNameExpressionResolver -> Context -> boolean isResolveToWriteIndex();1538067637;This is used to require that aliases resolve to their write-index. It is currently not used in conjunction_with <code>preserveAliases</code>.;boolean isResolveToWriteIndex() {_            return resolveToWriteIndex__        };this,is,used,to,require,that,aliases,resolve,to,their,write,index,it,is,currently,not,used,in,conjunction,with,code,preserve,aliases,code;boolean,is,resolve,to,write,index,return,resolve,to,write,index
IndexNameExpressionResolver -> Context -> boolean isResolveToWriteIndex();1539615817;This is used to require that aliases resolve to their write-index. It is currently not used in conjunction_with <code>preserveAliases</code>.;boolean isResolveToWriteIndex() {_            return resolveToWriteIndex__        };this,is,used,to,require,that,aliases,resolve,to,their,write,index,it,is,currently,not,used,in,conjunction,with,code,preserve,aliases,code;boolean,is,resolve,to,write,index,return,resolve,to,write,index
IndexNameExpressionResolver -> Context -> boolean isResolveToWriteIndex();1540313026;This is used to require that aliases resolve to their write-index. It is currently not used in conjunction_with <code>preserveAliases</code>.;boolean isResolveToWriteIndex() {_            return resolveToWriteIndex__        };this,is,used,to,require,that,aliases,resolve,to,their,write,index,it,is,currently,not,used,in,conjunction,with,code,preserve,aliases,code;boolean,is,resolve,to,write,index,return,resolve,to,write,index
IndexNameExpressionResolver -> Context -> boolean isResolveToWriteIndex();1540847035;This is used to require that aliases resolve to their write-index. It is currently not used in conjunction_with <code>preserveAliases</code>.;boolean isResolveToWriteIndex() {_            return resolveToWriteIndex__        };this,is,used,to,require,that,aliases,resolve,to,their,write,index,it,is,currently,not,used,in,conjunction,with,code,preserve,aliases,code;boolean,is,resolve,to,write,index,return,resolve,to,write,index
IndexNameExpressionResolver -> Context -> boolean isResolveToWriteIndex();1541092382;This is used to require that aliases resolve to their write-index. It is currently not used in conjunction_with <code>preserveAliases</code>.;boolean isResolveToWriteIndex() {_            return resolveToWriteIndex__        };this,is,used,to,require,that,aliases,resolve,to,their,write,index,it,is,currently,not,used,in,conjunction,with,code,preserve,aliases,code;boolean,is,resolve,to,write,index,return,resolve,to,write,index
IndexNameExpressionResolver -> Context -> boolean isResolveToWriteIndex();1541493930;This is used to require that aliases resolve to their write-index. It is currently not used in conjunction_with <code>preserveAliases</code>.;boolean isResolveToWriteIndex() {_            return resolveToWriteIndex__        };this,is,used,to,require,that,aliases,resolve,to,their,write,index,it,is,currently,not,used,in,conjunction,with,code,preserve,aliases,code;boolean,is,resolve,to,write,index,return,resolve,to,write,index
IndexNameExpressionResolver -> Context -> boolean isResolveToWriteIndex();1541612607;This is used to require that aliases resolve to their write-index. It is currently not used in conjunction_with <code>preserveAliases</code>.;boolean isResolveToWriteIndex() {_            return resolveToWriteIndex__        };this,is,used,to,require,that,aliases,resolve,to,their,write,index,it,is,currently,not,used,in,conjunction,with,code,preserve,aliases,code;boolean,is,resolve,to,write,index,return,resolve,to,write,index
IndexNameExpressionResolver -> Context -> boolean isResolveToWriteIndex();1544215214;This is used to require that aliases resolve to their write-index. It is currently not used in conjunction_with <code>preserveAliases</code>.;boolean isResolveToWriteIndex() {_            return resolveToWriteIndex__        };this,is,used,to,require,that,aliases,resolve,to,their,write,index,it,is,currently,not,used,in,conjunction,with,code,preserve,aliases,code;boolean,is,resolve,to,write,index,return,resolve,to,write,index
IndexNameExpressionResolver -> Context -> boolean isResolveToWriteIndex();1548236405;This is used to require that aliases resolve to their write-index. It is currently not used in conjunction_with <code>preserveAliases</code>.;boolean isResolveToWriteIndex() {_            return resolveToWriteIndex__        };this,is,used,to,require,that,aliases,resolve,to,their,write,index,it,is,currently,not,used,in,conjunction,with,code,preserve,aliases,code;boolean,is,resolve,to,write,index,return,resolve,to,write,index
IndexNameExpressionResolver -> public String[] concreteIndexNames(ClusterState state, IndicesRequest request);1524684173;Same as {@link #concreteIndexNames(ClusterState, IndicesOptions, String...)}, but the index expressions and options_are encapsulated in the specified request.;public String[] concreteIndexNames(ClusterState state, IndicesRequest request) {_        Context context = new Context(state, request.indicesOptions())__        return concreteIndexNames(context, request.indices())__    };same,as,link,concrete,index,names,cluster,state,indices,options,string,but,the,index,expressions,and,options,are,encapsulated,in,the,specified,request;public,string,concrete,index,names,cluster,state,state,indices,request,request,context,context,new,context,state,request,indices,options,return,concrete,index,names,context,request,indices
IndexNameExpressionResolver -> public String[] concreteIndexNames(ClusterState state, IndicesRequest request);1525334055;Same as {@link #concreteIndexNames(ClusterState, IndicesOptions, String...)}, but the index expressions and options_are encapsulated in the specified request.;public String[] concreteIndexNames(ClusterState state, IndicesRequest request) {_        Context context = new Context(state, request.indicesOptions())__        return concreteIndexNames(context, request.indices())__    };same,as,link,concrete,index,names,cluster,state,indices,options,string,but,the,index,expressions,and,options,are,encapsulated,in,the,specified,request;public,string,concrete,index,names,cluster,state,state,indices,request,request,context,context,new,context,state,request,indices,options,return,concrete,index,names,context,request,indices
IndexNameExpressionResolver -> public String[] concreteIndexNames(ClusterState state, IndicesRequest request);1532028790;Same as {@link #concreteIndexNames(ClusterState, IndicesOptions, String...)}, but the index expressions and options_are encapsulated in the specified request.;public String[] concreteIndexNames(ClusterState state, IndicesRequest request) {_        Context context = new Context(state, request.indicesOptions())__        return concreteIndexNames(context, request.indices())__    };same,as,link,concrete,index,names,cluster,state,indices,options,string,but,the,index,expressions,and,options,are,encapsulated,in,the,specified,request;public,string,concrete,index,names,cluster,state,state,indices,request,request,context,context,new,context,state,request,indices,options,return,concrete,index,names,context,request,indices
IndexNameExpressionResolver -> public String[] concreteIndexNames(ClusterState state, IndicesRequest request);1538067637;Same as {@link #concreteIndexNames(ClusterState, IndicesOptions, String...)}, but the index expressions and options_are encapsulated in the specified request.;public String[] concreteIndexNames(ClusterState state, IndicesRequest request) {_        Context context = new Context(state, request.indicesOptions())__        return concreteIndexNames(context, request.indices())__    };same,as,link,concrete,index,names,cluster,state,indices,options,string,but,the,index,expressions,and,options,are,encapsulated,in,the,specified,request;public,string,concrete,index,names,cluster,state,state,indices,request,request,context,context,new,context,state,request,indices,options,return,concrete,index,names,context,request,indices
IndexNameExpressionResolver -> public String[] concreteIndexNames(ClusterState state, IndicesRequest request);1539615817;Same as {@link #concreteIndexNames(ClusterState, IndicesOptions, String...)}, but the index expressions and options_are encapsulated in the specified request.;public String[] concreteIndexNames(ClusterState state, IndicesRequest request) {_        Context context = new Context(state, request.indicesOptions())__        return concreteIndexNames(context, request.indices())__    };same,as,link,concrete,index,names,cluster,state,indices,options,string,but,the,index,expressions,and,options,are,encapsulated,in,the,specified,request;public,string,concrete,index,names,cluster,state,state,indices,request,request,context,context,new,context,state,request,indices,options,return,concrete,index,names,context,request,indices
IndexNameExpressionResolver -> public String[] concreteIndexNames(ClusterState state, IndicesRequest request);1540313026;Same as {@link #concreteIndexNames(ClusterState, IndicesOptions, String...)}, but the index expressions and options_are encapsulated in the specified request.;public String[] concreteIndexNames(ClusterState state, IndicesRequest request) {_        Context context = new Context(state, request.indicesOptions())__        return concreteIndexNames(context, request.indices())__    };same,as,link,concrete,index,names,cluster,state,indices,options,string,but,the,index,expressions,and,options,are,encapsulated,in,the,specified,request;public,string,concrete,index,names,cluster,state,state,indices,request,request,context,context,new,context,state,request,indices,options,return,concrete,index,names,context,request,indices
IndexNameExpressionResolver -> public String[] concreteIndexNames(ClusterState state, IndicesRequest request);1540847035;Same as {@link #concreteIndexNames(ClusterState, IndicesOptions, String...)}, but the index expressions and options_are encapsulated in the specified request.;public String[] concreteIndexNames(ClusterState state, IndicesRequest request) {_        Context context = new Context(state, request.indicesOptions())__        return concreteIndexNames(context, request.indices())__    };same,as,link,concrete,index,names,cluster,state,indices,options,string,but,the,index,expressions,and,options,are,encapsulated,in,the,specified,request;public,string,concrete,index,names,cluster,state,state,indices,request,request,context,context,new,context,state,request,indices,options,return,concrete,index,names,context,request,indices
IndexNameExpressionResolver -> public String[] concreteIndexNames(ClusterState state, IndicesRequest request);1541092382;Same as {@link #concreteIndexNames(ClusterState, IndicesOptions, String...)}, but the index expressions and options_are encapsulated in the specified request.;public String[] concreteIndexNames(ClusterState state, IndicesRequest request) {_        Context context = new Context(state, request.indicesOptions())__        return concreteIndexNames(context, request.indices())__    };same,as,link,concrete,index,names,cluster,state,indices,options,string,but,the,index,expressions,and,options,are,encapsulated,in,the,specified,request;public,string,concrete,index,names,cluster,state,state,indices,request,request,context,context,new,context,state,request,indices,options,return,concrete,index,names,context,request,indices
IndexNameExpressionResolver -> public String[] concreteIndexNames(ClusterState state, IndicesRequest request);1541493930;Same as {@link #concreteIndexNames(ClusterState, IndicesOptions, String...)}, but the index expressions and options_are encapsulated in the specified request.;public String[] concreteIndexNames(ClusterState state, IndicesRequest request) {_        Context context = new Context(state, request.indicesOptions())__        return concreteIndexNames(context, request.indices())__    };same,as,link,concrete,index,names,cluster,state,indices,options,string,but,the,index,expressions,and,options,are,encapsulated,in,the,specified,request;public,string,concrete,index,names,cluster,state,state,indices,request,request,context,context,new,context,state,request,indices,options,return,concrete,index,names,context,request,indices
IndexNameExpressionResolver -> public String[] concreteIndexNames(ClusterState state, IndicesRequest request);1541612607;Same as {@link #concreteIndexNames(ClusterState, IndicesOptions, String...)}, but the index expressions and options_are encapsulated in the specified request.;public String[] concreteIndexNames(ClusterState state, IndicesRequest request) {_        Context context = new Context(state, request.indicesOptions())__        return concreteIndexNames(context, request.indices())__    };same,as,link,concrete,index,names,cluster,state,indices,options,string,but,the,index,expressions,and,options,are,encapsulated,in,the,specified,request;public,string,concrete,index,names,cluster,state,state,indices,request,request,context,context,new,context,state,request,indices,options,return,concrete,index,names,context,request,indices
IndexNameExpressionResolver -> public String[] concreteIndexNames(ClusterState state, IndicesRequest request);1544215214;Same as {@link #concreteIndexNames(ClusterState, IndicesOptions, String...)}, but the index expressions and options_are encapsulated in the specified request.;public String[] concreteIndexNames(ClusterState state, IndicesRequest request) {_        Context context = new Context(state, request.indicesOptions())__        return concreteIndexNames(context, request.indices())__    };same,as,link,concrete,index,names,cluster,state,indices,options,string,but,the,index,expressions,and,options,are,encapsulated,in,the,specified,request;public,string,concrete,index,names,cluster,state,state,indices,request,request,context,context,new,context,state,request,indices,options,return,concrete,index,names,context,request,indices
IndexNameExpressionResolver -> public String[] concreteIndexNames(ClusterState state, IndicesRequest request);1548236405;Same as {@link #concreteIndexNames(ClusterState, IndicesOptions, String...)}, but the index expressions and options_are encapsulated in the specified request.;public String[] concreteIndexNames(ClusterState state, IndicesRequest request) {_        Context context = new Context(state, request.indicesOptions())__        return concreteIndexNames(context, request.indices())__    };same,as,link,concrete,index,names,cluster,state,indices,options,string,but,the,index,expressions,and,options,are,encapsulated,in,the,specified,request;public,string,concrete,index,names,cluster,state,state,indices,request,request,context,context,new,context,state,request,indices,options,return,concrete,index,names,context,request,indices
IndexNameExpressionResolver -> public String[] indexAliases(ClusterState state, String index, Predicate<AliasMetaData> requiredAlias, boolean skipIdentity,                                  String... expressions);1524684173;Iterates through the list of indices and selects the effective list of required aliases for the given index._<p>Only aliases where the given predicate tests successfully are returned. If the indices list contains a non-required reference to_the index itself - null is returned. Returns <tt>null</tt> if no filtering is required.;public String[] indexAliases(ClusterState state, String index, Predicate<AliasMetaData> requiredAlias, boolean skipIdentity,_                                 String... expressions) {_        _        List<String> resolvedExpressions = expressions != null ? Arrays.asList(expressions) : Collections.emptyList()__        Context context = new Context(state, IndicesOptions.lenientExpandOpen(), true)__        for (ExpressionResolver expressionResolver : expressionResolvers) {_            resolvedExpressions = expressionResolver.resolve(context, resolvedExpressions)__        }__        if (isAllIndices(resolvedExpressions)) {_            return null__        }_        final IndexMetaData indexMetaData = state.metaData().getIndices().get(index)__        if (indexMetaData == null) {_            _            throw new IndexNotFoundException(index)__        }_        _        if (resolvedExpressions.size() == 1) {_            String alias = resolvedExpressions.get(0)___            AliasMetaData aliasMetaData = indexMetaData.getAliases().get(alias)__            if (aliasMetaData == null || requiredAlias.test(aliasMetaData) == false) {_                return null__            }_            return new String[]{alias}__        }_        List<String> aliases = null__        for (String alias : resolvedExpressions) {_            if (alias.equals(index)) {_                if (skipIdentity) {_                    continue__                } else {_                    return null__                }_            }_            AliasMetaData aliasMetaData = indexMetaData.getAliases().get(alias)__            _            _            if (aliasMetaData != null) {_                if (requiredAlias.test(aliasMetaData)) {_                    _                    if (aliases == null) {_                        aliases = new ArrayList<>()__                    }_                    aliases.add(alias)__                } else {_                    _                    return null__                }_            }_        }_        if (aliases == null) {_            return null__        }_        return aliases.toArray(new String[aliases.size()])__    };iterates,through,the,list,of,indices,and,selects,the,effective,list,of,required,aliases,for,the,given,index,p,only,aliases,where,the,given,predicate,tests,successfully,are,returned,if,the,indices,list,contains,a,non,required,reference,to,the,index,itself,null,is,returned,returns,tt,null,tt,if,no,filtering,is,required;public,string,index,aliases,cluster,state,state,string,index,predicate,alias,meta,data,required,alias,boolean,skip,identity,string,expressions,list,string,resolved,expressions,expressions,null,arrays,as,list,expressions,collections,empty,list,context,context,new,context,state,indices,options,lenient,expand,open,true,for,expression,resolver,expression,resolver,expression,resolvers,resolved,expressions,expression,resolver,resolve,context,resolved,expressions,if,is,all,indices,resolved,expressions,return,null,final,index,meta,data,index,meta,data,state,meta,data,get,indices,get,index,if,index,meta,data,null,throw,new,index,not,found,exception,index,if,resolved,expressions,size,1,string,alias,resolved,expressions,get,0,alias,meta,data,alias,meta,data,index,meta,data,get,aliases,get,alias,if,alias,meta,data,null,required,alias,test,alias,meta,data,false,return,null,return,new,string,alias,list,string,aliases,null,for,string,alias,resolved,expressions,if,alias,equals,index,if,skip,identity,continue,else,return,null,alias,meta,data,alias,meta,data,index,meta,data,get,aliases,get,alias,if,alias,meta,data,null,if,required,alias,test,alias,meta,data,if,aliases,null,aliases,new,array,list,aliases,add,alias,else,return,null,if,aliases,null,return,null,return,aliases,to,array,new,string,aliases,size
IndexNameExpressionResolver -> public String[] indexAliases(ClusterState state, String index, Predicate<AliasMetaData> requiredAlias, boolean skipIdentity,                                  String... expressions);1525334055;Iterates through the list of indices and selects the effective list of required aliases for the given index._<p>Only aliases where the given predicate tests successfully are returned. If the indices list contains a non-required reference to_the index itself - null is returned. Returns {@code null} if no filtering is required.;public String[] indexAliases(ClusterState state, String index, Predicate<AliasMetaData> requiredAlias, boolean skipIdentity,_                                 String... expressions) {_        _        List<String> resolvedExpressions = expressions != null ? Arrays.asList(expressions) : Collections.emptyList()__        Context context = new Context(state, IndicesOptions.lenientExpandOpen(), true)__        for (ExpressionResolver expressionResolver : expressionResolvers) {_            resolvedExpressions = expressionResolver.resolve(context, resolvedExpressions)__        }__        if (isAllIndices(resolvedExpressions)) {_            return null__        }_        final IndexMetaData indexMetaData = state.metaData().getIndices().get(index)__        if (indexMetaData == null) {_            _            throw new IndexNotFoundException(index)__        }_        _        if (resolvedExpressions.size() == 1) {_            String alias = resolvedExpressions.get(0)___            AliasMetaData aliasMetaData = indexMetaData.getAliases().get(alias)__            if (aliasMetaData == null || requiredAlias.test(aliasMetaData) == false) {_                return null__            }_            return new String[]{alias}__        }_        List<String> aliases = null__        for (String alias : resolvedExpressions) {_            if (alias.equals(index)) {_                if (skipIdentity) {_                    continue__                } else {_                    return null__                }_            }_            AliasMetaData aliasMetaData = indexMetaData.getAliases().get(alias)__            _            _            if (aliasMetaData != null) {_                if (requiredAlias.test(aliasMetaData)) {_                    _                    if (aliases == null) {_                        aliases = new ArrayList<>()__                    }_                    aliases.add(alias)__                } else {_                    _                    return null__                }_            }_        }_        if (aliases == null) {_            return null__        }_        return aliases.toArray(new String[aliases.size()])__    };iterates,through,the,list,of,indices,and,selects,the,effective,list,of,required,aliases,for,the,given,index,p,only,aliases,where,the,given,predicate,tests,successfully,are,returned,if,the,indices,list,contains,a,non,required,reference,to,the,index,itself,null,is,returned,returns,code,null,if,no,filtering,is,required;public,string,index,aliases,cluster,state,state,string,index,predicate,alias,meta,data,required,alias,boolean,skip,identity,string,expressions,list,string,resolved,expressions,expressions,null,arrays,as,list,expressions,collections,empty,list,context,context,new,context,state,indices,options,lenient,expand,open,true,for,expression,resolver,expression,resolver,expression,resolvers,resolved,expressions,expression,resolver,resolve,context,resolved,expressions,if,is,all,indices,resolved,expressions,return,null,final,index,meta,data,index,meta,data,state,meta,data,get,indices,get,index,if,index,meta,data,null,throw,new,index,not,found,exception,index,if,resolved,expressions,size,1,string,alias,resolved,expressions,get,0,alias,meta,data,alias,meta,data,index,meta,data,get,aliases,get,alias,if,alias,meta,data,null,required,alias,test,alias,meta,data,false,return,null,return,new,string,alias,list,string,aliases,null,for,string,alias,resolved,expressions,if,alias,equals,index,if,skip,identity,continue,else,return,null,alias,meta,data,alias,meta,data,index,meta,data,get,aliases,get,alias,if,alias,meta,data,null,if,required,alias,test,alias,meta,data,if,aliases,null,aliases,new,array,list,aliases,add,alias,else,return,null,if,aliases,null,return,null,return,aliases,to,array,new,string,aliases,size
IndexNameExpressionResolver -> public String[] indexAliases(ClusterState state, String index, Predicate<AliasMetaData> requiredAlias, boolean skipIdentity,                                  String... expressions);1532028790;Iterates through the list of indices and selects the effective list of required aliases for the given index._<p>Only aliases where the given predicate tests successfully are returned. If the indices list contains a non-required reference to_the index itself - null is returned. Returns {@code null} if no filtering is required.;public String[] indexAliases(ClusterState state, String index, Predicate<AliasMetaData> requiredAlias, boolean skipIdentity,_                                 String... expressions) {_        _        List<String> resolvedExpressions = expressions != null ? Arrays.asList(expressions) : Collections.emptyList()__        Context context = new Context(state, IndicesOptions.lenientExpandOpen(), true, false)__        for (ExpressionResolver expressionResolver : expressionResolvers) {_            resolvedExpressions = expressionResolver.resolve(context, resolvedExpressions)__        }__        if (isAllIndices(resolvedExpressions)) {_            return null__        }_        final IndexMetaData indexMetaData = state.metaData().getIndices().get(index)__        if (indexMetaData == null) {_            _            throw new IndexNotFoundException(index)__        }_        _        if (resolvedExpressions.size() == 1) {_            String alias = resolvedExpressions.get(0)___            AliasMetaData aliasMetaData = indexMetaData.getAliases().get(alias)__            if (aliasMetaData == null || requiredAlias.test(aliasMetaData) == false) {_                return null__            }_            return new String[]{alias}__        }_        List<String> aliases = null__        for (String alias : resolvedExpressions) {_            if (alias.equals(index)) {_                if (skipIdentity) {_                    continue__                } else {_                    return null__                }_            }_            AliasMetaData aliasMetaData = indexMetaData.getAliases().get(alias)__            _            _            if (aliasMetaData != null) {_                if (requiredAlias.test(aliasMetaData)) {_                    _                    if (aliases == null) {_                        aliases = new ArrayList<>()__                    }_                    aliases.add(alias)__                } else {_                    _                    return null__                }_            }_        }_        if (aliases == null) {_            return null__        }_        return aliases.toArray(new String[aliases.size()])__    };iterates,through,the,list,of,indices,and,selects,the,effective,list,of,required,aliases,for,the,given,index,p,only,aliases,where,the,given,predicate,tests,successfully,are,returned,if,the,indices,list,contains,a,non,required,reference,to,the,index,itself,null,is,returned,returns,code,null,if,no,filtering,is,required;public,string,index,aliases,cluster,state,state,string,index,predicate,alias,meta,data,required,alias,boolean,skip,identity,string,expressions,list,string,resolved,expressions,expressions,null,arrays,as,list,expressions,collections,empty,list,context,context,new,context,state,indices,options,lenient,expand,open,true,false,for,expression,resolver,expression,resolver,expression,resolvers,resolved,expressions,expression,resolver,resolve,context,resolved,expressions,if,is,all,indices,resolved,expressions,return,null,final,index,meta,data,index,meta,data,state,meta,data,get,indices,get,index,if,index,meta,data,null,throw,new,index,not,found,exception,index,if,resolved,expressions,size,1,string,alias,resolved,expressions,get,0,alias,meta,data,alias,meta,data,index,meta,data,get,aliases,get,alias,if,alias,meta,data,null,required,alias,test,alias,meta,data,false,return,null,return,new,string,alias,list,string,aliases,null,for,string,alias,resolved,expressions,if,alias,equals,index,if,skip,identity,continue,else,return,null,alias,meta,data,alias,meta,data,index,meta,data,get,aliases,get,alias,if,alias,meta,data,null,if,required,alias,test,alias,meta,data,if,aliases,null,aliases,new,array,list,aliases,add,alias,else,return,null,if,aliases,null,return,null,return,aliases,to,array,new,string,aliases,size
IndexNameExpressionResolver -> public String[] indexAliases(ClusterState state, String index, Predicate<AliasMetaData> requiredAlias, boolean skipIdentity,                                  String... expressions);1538067637;Iterates through the list of indices and selects the effective list of required aliases for the given index._<p>Only aliases where the given predicate tests successfully are returned. If the indices list contains a non-required reference to_the index itself - null is returned. Returns {@code null} if no filtering is required.;public String[] indexAliases(ClusterState state, String index, Predicate<AliasMetaData> requiredAlias, boolean skipIdentity,_                                 String... expressions) {_        _        List<String> resolvedExpressions = expressions != null ? Arrays.asList(expressions) : Collections.emptyList()__        Context context = new Context(state, IndicesOptions.lenientExpandOpen(), true, false)__        for (ExpressionResolver expressionResolver : expressionResolvers) {_            resolvedExpressions = expressionResolver.resolve(context, resolvedExpressions)__        }__        if (isAllIndices(resolvedExpressions)) {_            return null__        }_        final IndexMetaData indexMetaData = state.metaData().getIndices().get(index)__        if (indexMetaData == null) {_            _            throw new IndexNotFoundException(index)__        }_        _        if (resolvedExpressions.size() == 1) {_            String alias = resolvedExpressions.get(0)___            AliasMetaData aliasMetaData = indexMetaData.getAliases().get(alias)__            if (aliasMetaData == null || requiredAlias.test(aliasMetaData) == false) {_                return null__            }_            return new String[]{alias}__        }_        List<String> aliases = null__        for (String alias : resolvedExpressions) {_            if (alias.equals(index)) {_                if (skipIdentity) {_                    continue__                } else {_                    return null__                }_            }_            AliasMetaData aliasMetaData = indexMetaData.getAliases().get(alias)__            _            _            if (aliasMetaData != null) {_                if (requiredAlias.test(aliasMetaData)) {_                    _                    if (aliases == null) {_                        aliases = new ArrayList<>()__                    }_                    aliases.add(alias)__                } else {_                    _                    return null__                }_            }_        }_        if (aliases == null) {_            return null__        }_        return aliases.toArray(new String[aliases.size()])__    };iterates,through,the,list,of,indices,and,selects,the,effective,list,of,required,aliases,for,the,given,index,p,only,aliases,where,the,given,predicate,tests,successfully,are,returned,if,the,indices,list,contains,a,non,required,reference,to,the,index,itself,null,is,returned,returns,code,null,if,no,filtering,is,required;public,string,index,aliases,cluster,state,state,string,index,predicate,alias,meta,data,required,alias,boolean,skip,identity,string,expressions,list,string,resolved,expressions,expressions,null,arrays,as,list,expressions,collections,empty,list,context,context,new,context,state,indices,options,lenient,expand,open,true,false,for,expression,resolver,expression,resolver,expression,resolvers,resolved,expressions,expression,resolver,resolve,context,resolved,expressions,if,is,all,indices,resolved,expressions,return,null,final,index,meta,data,index,meta,data,state,meta,data,get,indices,get,index,if,index,meta,data,null,throw,new,index,not,found,exception,index,if,resolved,expressions,size,1,string,alias,resolved,expressions,get,0,alias,meta,data,alias,meta,data,index,meta,data,get,aliases,get,alias,if,alias,meta,data,null,required,alias,test,alias,meta,data,false,return,null,return,new,string,alias,list,string,aliases,null,for,string,alias,resolved,expressions,if,alias,equals,index,if,skip,identity,continue,else,return,null,alias,meta,data,alias,meta,data,index,meta,data,get,aliases,get,alias,if,alias,meta,data,null,if,required,alias,test,alias,meta,data,if,aliases,null,aliases,new,array,list,aliases,add,alias,else,return,null,if,aliases,null,return,null,return,aliases,to,array,new,string,aliases,size
IndexNameExpressionResolver -> public String[] indexAliases(ClusterState state, String index, Predicate<AliasMetaData> requiredAlias, boolean skipIdentity,                                  String... expressions);1539615817;Iterates through the list of indices and selects the effective list of required aliases for the given index._<p>Only aliases where the given predicate tests successfully are returned. If the indices list contains a non-required reference to_the index itself - null is returned. Returns {@code null} if no filtering is required.;public String[] indexAliases(ClusterState state, String index, Predicate<AliasMetaData> requiredAlias, boolean skipIdentity,_                                 String... expressions) {_        _        List<String> resolvedExpressions = expressions != null ? Arrays.asList(expressions) : Collections.emptyList()__        Context context = new Context(state, IndicesOptions.lenientExpandOpen(), true, false)__        for (ExpressionResolver expressionResolver : expressionResolvers) {_            resolvedExpressions = expressionResolver.resolve(context, resolvedExpressions)__        }__        if (isAllIndices(resolvedExpressions)) {_            return null__        }_        final IndexMetaData indexMetaData = state.metaData().getIndices().get(index)__        if (indexMetaData == null) {_            _            throw new IndexNotFoundException(index)__        }_        _        if (resolvedExpressions.size() == 1) {_            String alias = resolvedExpressions.get(0)___            AliasMetaData aliasMetaData = indexMetaData.getAliases().get(alias)__            if (aliasMetaData == null || requiredAlias.test(aliasMetaData) == false) {_                return null__            }_            return new String[]{alias}__        }_        List<String> aliases = null__        for (String alias : resolvedExpressions) {_            if (alias.equals(index)) {_                if (skipIdentity) {_                    continue__                } else {_                    return null__                }_            }_            AliasMetaData aliasMetaData = indexMetaData.getAliases().get(alias)__            _            _            if (aliasMetaData != null) {_                if (requiredAlias.test(aliasMetaData)) {_                    _                    if (aliases == null) {_                        aliases = new ArrayList<>()__                    }_                    aliases.add(alias)__                } else {_                    _                    return null__                }_            }_        }_        if (aliases == null) {_            return null__        }_        return aliases.toArray(new String[aliases.size()])__    };iterates,through,the,list,of,indices,and,selects,the,effective,list,of,required,aliases,for,the,given,index,p,only,aliases,where,the,given,predicate,tests,successfully,are,returned,if,the,indices,list,contains,a,non,required,reference,to,the,index,itself,null,is,returned,returns,code,null,if,no,filtering,is,required;public,string,index,aliases,cluster,state,state,string,index,predicate,alias,meta,data,required,alias,boolean,skip,identity,string,expressions,list,string,resolved,expressions,expressions,null,arrays,as,list,expressions,collections,empty,list,context,context,new,context,state,indices,options,lenient,expand,open,true,false,for,expression,resolver,expression,resolver,expression,resolvers,resolved,expressions,expression,resolver,resolve,context,resolved,expressions,if,is,all,indices,resolved,expressions,return,null,final,index,meta,data,index,meta,data,state,meta,data,get,indices,get,index,if,index,meta,data,null,throw,new,index,not,found,exception,index,if,resolved,expressions,size,1,string,alias,resolved,expressions,get,0,alias,meta,data,alias,meta,data,index,meta,data,get,aliases,get,alias,if,alias,meta,data,null,required,alias,test,alias,meta,data,false,return,null,return,new,string,alias,list,string,aliases,null,for,string,alias,resolved,expressions,if,alias,equals,index,if,skip,identity,continue,else,return,null,alias,meta,data,alias,meta,data,index,meta,data,get,aliases,get,alias,if,alias,meta,data,null,if,required,alias,test,alias,meta,data,if,aliases,null,aliases,new,array,list,aliases,add,alias,else,return,null,if,aliases,null,return,null,return,aliases,to,array,new,string,aliases,size
IndexNameExpressionResolver -> public String[] indexAliases(ClusterState state, String index, Predicate<AliasMetaData> requiredAlias, boolean skipIdentity,                                  String... expressions);1540313026;Iterates through the list of indices and selects the effective list of required aliases for the given index._<p>Only aliases where the given predicate tests successfully are returned. If the indices list contains a non-required reference to_the index itself - null is returned. Returns {@code null} if no filtering is required.;public String[] indexAliases(ClusterState state, String index, Predicate<AliasMetaData> requiredAlias, boolean skipIdentity,_                                 String... expressions) {_        _        List<String> resolvedExpressions = expressions != null ? Arrays.asList(expressions) : Collections.emptyList()__        Context context = new Context(state, IndicesOptions.lenientExpandOpen(), true, false)__        for (ExpressionResolver expressionResolver : expressionResolvers) {_            resolvedExpressions = expressionResolver.resolve(context, resolvedExpressions)__        }__        if (isAllIndices(resolvedExpressions)) {_            return null__        }_        final IndexMetaData indexMetaData = state.metaData().getIndices().get(index)__        if (indexMetaData == null) {_            _            throw new IndexNotFoundException(index)__        }_        _        if (resolvedExpressions.size() == 1) {_            String alias = resolvedExpressions.get(0)___            AliasMetaData aliasMetaData = indexMetaData.getAliases().get(alias)__            if (aliasMetaData == null || requiredAlias.test(aliasMetaData) == false) {_                return null__            }_            return new String[]{alias}__        }_        List<String> aliases = null__        for (String alias : resolvedExpressions) {_            if (alias.equals(index)) {_                if (skipIdentity) {_                    continue__                } else {_                    return null__                }_            }_            AliasMetaData aliasMetaData = indexMetaData.getAliases().get(alias)__            _            _            if (aliasMetaData != null) {_                if (requiredAlias.test(aliasMetaData)) {_                    _                    if (aliases == null) {_                        aliases = new ArrayList<>()__                    }_                    aliases.add(alias)__                } else {_                    _                    return null__                }_            }_        }_        if (aliases == null) {_            return null__        }_        return aliases.toArray(new String[aliases.size()])__    };iterates,through,the,list,of,indices,and,selects,the,effective,list,of,required,aliases,for,the,given,index,p,only,aliases,where,the,given,predicate,tests,successfully,are,returned,if,the,indices,list,contains,a,non,required,reference,to,the,index,itself,null,is,returned,returns,code,null,if,no,filtering,is,required;public,string,index,aliases,cluster,state,state,string,index,predicate,alias,meta,data,required,alias,boolean,skip,identity,string,expressions,list,string,resolved,expressions,expressions,null,arrays,as,list,expressions,collections,empty,list,context,context,new,context,state,indices,options,lenient,expand,open,true,false,for,expression,resolver,expression,resolver,expression,resolvers,resolved,expressions,expression,resolver,resolve,context,resolved,expressions,if,is,all,indices,resolved,expressions,return,null,final,index,meta,data,index,meta,data,state,meta,data,get,indices,get,index,if,index,meta,data,null,throw,new,index,not,found,exception,index,if,resolved,expressions,size,1,string,alias,resolved,expressions,get,0,alias,meta,data,alias,meta,data,index,meta,data,get,aliases,get,alias,if,alias,meta,data,null,required,alias,test,alias,meta,data,false,return,null,return,new,string,alias,list,string,aliases,null,for,string,alias,resolved,expressions,if,alias,equals,index,if,skip,identity,continue,else,return,null,alias,meta,data,alias,meta,data,index,meta,data,get,aliases,get,alias,if,alias,meta,data,null,if,required,alias,test,alias,meta,data,if,aliases,null,aliases,new,array,list,aliases,add,alias,else,return,null,if,aliases,null,return,null,return,aliases,to,array,new,string,aliases,size
IndexNameExpressionResolver -> public String[] indexAliases(ClusterState state, String index, Predicate<AliasMetaData> requiredAlias, boolean skipIdentity,                                  String... expressions);1540847035;Iterates through the list of indices and selects the effective list of required aliases for the given index._<p>Only aliases where the given predicate tests successfully are returned. If the indices list contains a non-required reference to_the index itself - null is returned. Returns {@code null} if no filtering is required.;public String[] indexAliases(ClusterState state, String index, Predicate<AliasMetaData> requiredAlias, boolean skipIdentity,_                                 String... expressions) {_        _        List<String> resolvedExpressions = expressions != null ? Arrays.asList(expressions) : Collections.emptyList()__        Context context = new Context(state, IndicesOptions.lenientExpandOpen(), true, false)__        for (ExpressionResolver expressionResolver : expressionResolvers) {_            resolvedExpressions = expressionResolver.resolve(context, resolvedExpressions)__        }__        if (isAllIndices(resolvedExpressions)) {_            return null__        }_        final IndexMetaData indexMetaData = state.metaData().getIndices().get(index)__        if (indexMetaData == null) {_            _            throw new IndexNotFoundException(index)__        }_        _        if (resolvedExpressions.size() == 1) {_            String alias = resolvedExpressions.get(0)___            AliasMetaData aliasMetaData = indexMetaData.getAliases().get(alias)__            if (aliasMetaData == null || requiredAlias.test(aliasMetaData) == false) {_                return null__            }_            return new String[]{alias}__        }_        List<String> aliases = null__        for (String alias : resolvedExpressions) {_            if (alias.equals(index)) {_                if (skipIdentity) {_                    continue__                } else {_                    return null__                }_            }_            AliasMetaData aliasMetaData = indexMetaData.getAliases().get(alias)__            _            _            if (aliasMetaData != null) {_                if (requiredAlias.test(aliasMetaData)) {_                    _                    if (aliases == null) {_                        aliases = new ArrayList<>()__                    }_                    aliases.add(alias)__                } else {_                    _                    return null__                }_            }_        }_        if (aliases == null) {_            return null__        }_        return aliases.toArray(new String[aliases.size()])__    };iterates,through,the,list,of,indices,and,selects,the,effective,list,of,required,aliases,for,the,given,index,p,only,aliases,where,the,given,predicate,tests,successfully,are,returned,if,the,indices,list,contains,a,non,required,reference,to,the,index,itself,null,is,returned,returns,code,null,if,no,filtering,is,required;public,string,index,aliases,cluster,state,state,string,index,predicate,alias,meta,data,required,alias,boolean,skip,identity,string,expressions,list,string,resolved,expressions,expressions,null,arrays,as,list,expressions,collections,empty,list,context,context,new,context,state,indices,options,lenient,expand,open,true,false,for,expression,resolver,expression,resolver,expression,resolvers,resolved,expressions,expression,resolver,resolve,context,resolved,expressions,if,is,all,indices,resolved,expressions,return,null,final,index,meta,data,index,meta,data,state,meta,data,get,indices,get,index,if,index,meta,data,null,throw,new,index,not,found,exception,index,if,resolved,expressions,size,1,string,alias,resolved,expressions,get,0,alias,meta,data,alias,meta,data,index,meta,data,get,aliases,get,alias,if,alias,meta,data,null,required,alias,test,alias,meta,data,false,return,null,return,new,string,alias,list,string,aliases,null,for,string,alias,resolved,expressions,if,alias,equals,index,if,skip,identity,continue,else,return,null,alias,meta,data,alias,meta,data,index,meta,data,get,aliases,get,alias,if,alias,meta,data,null,if,required,alias,test,alias,meta,data,if,aliases,null,aliases,new,array,list,aliases,add,alias,else,return,null,if,aliases,null,return,null,return,aliases,to,array,new,string,aliases,size
IndexNameExpressionResolver -> public String[] indexAliases(ClusterState state, String index, Predicate<AliasMetaData> requiredAlias, boolean skipIdentity,                                  String... expressions);1541092382;Iterates through the list of indices and selects the effective list of required aliases for the given index._<p>Only aliases where the given predicate tests successfully are returned. If the indices list contains a non-required reference to_the index itself - null is returned. Returns {@code null} if no filtering is required.;public String[] indexAliases(ClusterState state, String index, Predicate<AliasMetaData> requiredAlias, boolean skipIdentity,_                                 String... expressions) {_        _        List<String> resolvedExpressions = expressions != null ? Arrays.asList(expressions) : Collections.emptyList()__        Context context = new Context(state, IndicesOptions.lenientExpandOpen(), true, false)__        for (ExpressionResolver expressionResolver : expressionResolvers) {_            resolvedExpressions = expressionResolver.resolve(context, resolvedExpressions)__        }__        if (isAllIndices(resolvedExpressions)) {_            return null__        }_        final IndexMetaData indexMetaData = state.metaData().getIndices().get(index)__        if (indexMetaData == null) {_            _            throw new IndexNotFoundException(index)__        }_        _        if (resolvedExpressions.size() == 1) {_            String alias = resolvedExpressions.get(0)___            AliasMetaData aliasMetaData = indexMetaData.getAliases().get(alias)__            if (aliasMetaData == null || requiredAlias.test(aliasMetaData) == false) {_                return null__            }_            return new String[]{alias}__        }_        List<String> aliases = null__        for (String alias : resolvedExpressions) {_            if (alias.equals(index)) {_                if (skipIdentity) {_                    continue__                } else {_                    return null__                }_            }_            AliasMetaData aliasMetaData = indexMetaData.getAliases().get(alias)__            _            _            if (aliasMetaData != null) {_                if (requiredAlias.test(aliasMetaData)) {_                    _                    if (aliases == null) {_                        aliases = new ArrayList<>()__                    }_                    aliases.add(alias)__                } else {_                    _                    return null__                }_            }_        }_        if (aliases == null) {_            return null__        }_        return aliases.toArray(new String[aliases.size()])__    };iterates,through,the,list,of,indices,and,selects,the,effective,list,of,required,aliases,for,the,given,index,p,only,aliases,where,the,given,predicate,tests,successfully,are,returned,if,the,indices,list,contains,a,non,required,reference,to,the,index,itself,null,is,returned,returns,code,null,if,no,filtering,is,required;public,string,index,aliases,cluster,state,state,string,index,predicate,alias,meta,data,required,alias,boolean,skip,identity,string,expressions,list,string,resolved,expressions,expressions,null,arrays,as,list,expressions,collections,empty,list,context,context,new,context,state,indices,options,lenient,expand,open,true,false,for,expression,resolver,expression,resolver,expression,resolvers,resolved,expressions,expression,resolver,resolve,context,resolved,expressions,if,is,all,indices,resolved,expressions,return,null,final,index,meta,data,index,meta,data,state,meta,data,get,indices,get,index,if,index,meta,data,null,throw,new,index,not,found,exception,index,if,resolved,expressions,size,1,string,alias,resolved,expressions,get,0,alias,meta,data,alias,meta,data,index,meta,data,get,aliases,get,alias,if,alias,meta,data,null,required,alias,test,alias,meta,data,false,return,null,return,new,string,alias,list,string,aliases,null,for,string,alias,resolved,expressions,if,alias,equals,index,if,skip,identity,continue,else,return,null,alias,meta,data,alias,meta,data,index,meta,data,get,aliases,get,alias,if,alias,meta,data,null,if,required,alias,test,alias,meta,data,if,aliases,null,aliases,new,array,list,aliases,add,alias,else,return,null,if,aliases,null,return,null,return,aliases,to,array,new,string,aliases,size
IndexNameExpressionResolver -> public String[] indexAliases(ClusterState state, String index, Predicate<AliasMetaData> requiredAlias, boolean skipIdentity,                                  String... expressions);1541493930;Iterates through the list of indices and selects the effective list of required aliases for the given index._<p>Only aliases where the given predicate tests successfully are returned. If the indices list contains a non-required reference to_the index itself - null is returned. Returns {@code null} if no filtering is required.;public String[] indexAliases(ClusterState state, String index, Predicate<AliasMetaData> requiredAlias, boolean skipIdentity,_                                 String... expressions) {_        _        List<String> resolvedExpressions = expressions != null ? Arrays.asList(expressions) : Collections.emptyList()__        Context context = new Context(state, IndicesOptions.lenientExpandOpen(), true, false)__        for (ExpressionResolver expressionResolver : expressionResolvers) {_            resolvedExpressions = expressionResolver.resolve(context, resolvedExpressions)__        }__        if (isAllIndices(resolvedExpressions)) {_            return null__        }_        final IndexMetaData indexMetaData = state.metaData().getIndices().get(index)__        if (indexMetaData == null) {_            _            throw new IndexNotFoundException(index)__        }_        _        if (resolvedExpressions.size() == 1) {_            String alias = resolvedExpressions.get(0)___            AliasMetaData aliasMetaData = indexMetaData.getAliases().get(alias)__            if (aliasMetaData == null || requiredAlias.test(aliasMetaData) == false) {_                return null__            }_            return new String[]{alias}__        }_        List<String> aliases = null__        for (String alias : resolvedExpressions) {_            if (alias.equals(index)) {_                if (skipIdentity) {_                    continue__                } else {_                    return null__                }_            }_            AliasMetaData aliasMetaData = indexMetaData.getAliases().get(alias)__            _            _            if (aliasMetaData != null) {_                if (requiredAlias.test(aliasMetaData)) {_                    _                    if (aliases == null) {_                        aliases = new ArrayList<>()__                    }_                    aliases.add(alias)__                } else {_                    _                    return null__                }_            }_        }_        if (aliases == null) {_            return null__        }_        return aliases.toArray(new String[aliases.size()])__    };iterates,through,the,list,of,indices,and,selects,the,effective,list,of,required,aliases,for,the,given,index,p,only,aliases,where,the,given,predicate,tests,successfully,are,returned,if,the,indices,list,contains,a,non,required,reference,to,the,index,itself,null,is,returned,returns,code,null,if,no,filtering,is,required;public,string,index,aliases,cluster,state,state,string,index,predicate,alias,meta,data,required,alias,boolean,skip,identity,string,expressions,list,string,resolved,expressions,expressions,null,arrays,as,list,expressions,collections,empty,list,context,context,new,context,state,indices,options,lenient,expand,open,true,false,for,expression,resolver,expression,resolver,expression,resolvers,resolved,expressions,expression,resolver,resolve,context,resolved,expressions,if,is,all,indices,resolved,expressions,return,null,final,index,meta,data,index,meta,data,state,meta,data,get,indices,get,index,if,index,meta,data,null,throw,new,index,not,found,exception,index,if,resolved,expressions,size,1,string,alias,resolved,expressions,get,0,alias,meta,data,alias,meta,data,index,meta,data,get,aliases,get,alias,if,alias,meta,data,null,required,alias,test,alias,meta,data,false,return,null,return,new,string,alias,list,string,aliases,null,for,string,alias,resolved,expressions,if,alias,equals,index,if,skip,identity,continue,else,return,null,alias,meta,data,alias,meta,data,index,meta,data,get,aliases,get,alias,if,alias,meta,data,null,if,required,alias,test,alias,meta,data,if,aliases,null,aliases,new,array,list,aliases,add,alias,else,return,null,if,aliases,null,return,null,return,aliases,to,array,new,string,aliases,size
IndexNameExpressionResolver -> public String[] indexAliases(ClusterState state, String index, Predicate<AliasMetaData> requiredAlias, boolean skipIdentity,                                  String... expressions);1541612607;Iterates through the list of indices and selects the effective list of required aliases for the given index._<p>Only aliases where the given predicate tests successfully are returned. If the indices list contains a non-required reference to_the index itself - null is returned. Returns {@code null} if no filtering is required.;public String[] indexAliases(ClusterState state, String index, Predicate<AliasMetaData> requiredAlias, boolean skipIdentity,_                                 String... expressions) {_        _        List<String> resolvedExpressions = expressions != null ? Arrays.asList(expressions) : Collections.emptyList()__        Context context = new Context(state, IndicesOptions.lenientExpandOpen(), true, false)__        for (ExpressionResolver expressionResolver : expressionResolvers) {_            resolvedExpressions = expressionResolver.resolve(context, resolvedExpressions)__        }__        if (isAllIndices(resolvedExpressions)) {_            return null__        }_        final IndexMetaData indexMetaData = state.metaData().getIndices().get(index)__        if (indexMetaData == null) {_            _            throw new IndexNotFoundException(index)__        }_        _        if (resolvedExpressions.size() == 1) {_            String alias = resolvedExpressions.get(0)___            AliasMetaData aliasMetaData = indexMetaData.getAliases().get(alias)__            if (aliasMetaData == null || requiredAlias.test(aliasMetaData) == false) {_                return null__            }_            return new String[]{alias}__        }_        List<String> aliases = null__        for (String alias : resolvedExpressions) {_            if (alias.equals(index)) {_                if (skipIdentity) {_                    continue__                } else {_                    return null__                }_            }_            AliasMetaData aliasMetaData = indexMetaData.getAliases().get(alias)__            _            _            if (aliasMetaData != null) {_                if (requiredAlias.test(aliasMetaData)) {_                    _                    if (aliases == null) {_                        aliases = new ArrayList<>()__                    }_                    aliases.add(alias)__                } else {_                    _                    return null__                }_            }_        }_        if (aliases == null) {_            return null__        }_        return aliases.toArray(new String[aliases.size()])__    };iterates,through,the,list,of,indices,and,selects,the,effective,list,of,required,aliases,for,the,given,index,p,only,aliases,where,the,given,predicate,tests,successfully,are,returned,if,the,indices,list,contains,a,non,required,reference,to,the,index,itself,null,is,returned,returns,code,null,if,no,filtering,is,required;public,string,index,aliases,cluster,state,state,string,index,predicate,alias,meta,data,required,alias,boolean,skip,identity,string,expressions,list,string,resolved,expressions,expressions,null,arrays,as,list,expressions,collections,empty,list,context,context,new,context,state,indices,options,lenient,expand,open,true,false,for,expression,resolver,expression,resolver,expression,resolvers,resolved,expressions,expression,resolver,resolve,context,resolved,expressions,if,is,all,indices,resolved,expressions,return,null,final,index,meta,data,index,meta,data,state,meta,data,get,indices,get,index,if,index,meta,data,null,throw,new,index,not,found,exception,index,if,resolved,expressions,size,1,string,alias,resolved,expressions,get,0,alias,meta,data,alias,meta,data,index,meta,data,get,aliases,get,alias,if,alias,meta,data,null,required,alias,test,alias,meta,data,false,return,null,return,new,string,alias,list,string,aliases,null,for,string,alias,resolved,expressions,if,alias,equals,index,if,skip,identity,continue,else,return,null,alias,meta,data,alias,meta,data,index,meta,data,get,aliases,get,alias,if,alias,meta,data,null,if,required,alias,test,alias,meta,data,if,aliases,null,aliases,new,array,list,aliases,add,alias,else,return,null,if,aliases,null,return,null,return,aliases,to,array,new,string,aliases,size
IndexNameExpressionResolver -> public String[] indexAliases(ClusterState state, String index, Predicate<AliasMetaData> requiredAlias, boolean skipIdentity,                                  String... expressions);1544215214;Iterates through the list of indices and selects the effective list of required aliases for the given index._<p>Only aliases where the given predicate tests successfully are returned. If the indices list contains a non-required reference to_the index itself - null is returned. Returns {@code null} if no filtering is required.;public String[] indexAliases(ClusterState state, String index, Predicate<AliasMetaData> requiredAlias, boolean skipIdentity,_                                 String... expressions) {_        _        List<String> resolvedExpressions = expressions != null ? Arrays.asList(expressions) : Collections.emptyList()__        Context context = new Context(state, IndicesOptions.lenientExpandOpen(), true, false)__        for (ExpressionResolver expressionResolver : expressionResolvers) {_            resolvedExpressions = expressionResolver.resolve(context, resolvedExpressions)__        }__        if (isAllIndices(resolvedExpressions)) {_            return null__        }_        final IndexMetaData indexMetaData = state.metaData().getIndices().get(index)__        if (indexMetaData == null) {_            _            throw new IndexNotFoundException(index)__        }_        _        if (resolvedExpressions.size() == 1) {_            String alias = resolvedExpressions.get(0)___            AliasMetaData aliasMetaData = indexMetaData.getAliases().get(alias)__            if (aliasMetaData == null || requiredAlias.test(aliasMetaData) == false) {_                return null__            }_            return new String[]{alias}__        }_        List<String> aliases = null__        for (String alias : resolvedExpressions) {_            if (alias.equals(index)) {_                if (skipIdentity) {_                    continue__                } else {_                    return null__                }_            }_            AliasMetaData aliasMetaData = indexMetaData.getAliases().get(alias)__            _            _            if (aliasMetaData != null) {_                if (requiredAlias.test(aliasMetaData)) {_                    _                    if (aliases == null) {_                        aliases = new ArrayList<>()__                    }_                    aliases.add(alias)__                } else {_                    _                    return null__                }_            }_        }_        if (aliases == null) {_            return null__        }_        return aliases.toArray(new String[aliases.size()])__    };iterates,through,the,list,of,indices,and,selects,the,effective,list,of,required,aliases,for,the,given,index,p,only,aliases,where,the,given,predicate,tests,successfully,are,returned,if,the,indices,list,contains,a,non,required,reference,to,the,index,itself,null,is,returned,returns,code,null,if,no,filtering,is,required;public,string,index,aliases,cluster,state,state,string,index,predicate,alias,meta,data,required,alias,boolean,skip,identity,string,expressions,list,string,resolved,expressions,expressions,null,arrays,as,list,expressions,collections,empty,list,context,context,new,context,state,indices,options,lenient,expand,open,true,false,for,expression,resolver,expression,resolver,expression,resolvers,resolved,expressions,expression,resolver,resolve,context,resolved,expressions,if,is,all,indices,resolved,expressions,return,null,final,index,meta,data,index,meta,data,state,meta,data,get,indices,get,index,if,index,meta,data,null,throw,new,index,not,found,exception,index,if,resolved,expressions,size,1,string,alias,resolved,expressions,get,0,alias,meta,data,alias,meta,data,index,meta,data,get,aliases,get,alias,if,alias,meta,data,null,required,alias,test,alias,meta,data,false,return,null,return,new,string,alias,list,string,aliases,null,for,string,alias,resolved,expressions,if,alias,equals,index,if,skip,identity,continue,else,return,null,alias,meta,data,alias,meta,data,index,meta,data,get,aliases,get,alias,if,alias,meta,data,null,if,required,alias,test,alias,meta,data,if,aliases,null,aliases,new,array,list,aliases,add,alias,else,return,null,if,aliases,null,return,null,return,aliases,to,array,new,string,aliases,size
IndexNameExpressionResolver -> public String[] indexAliases(ClusterState state, String index, Predicate<AliasMetaData> requiredAlias, boolean skipIdentity,                                  String... expressions);1548236405;Iterates through the list of indices and selects the effective list of required aliases for the given index._<p>Only aliases where the given predicate tests successfully are returned. If the indices list contains a non-required reference to_the index itself - null is returned. Returns {@code null} if no filtering is required.;public String[] indexAliases(ClusterState state, String index, Predicate<AliasMetaData> requiredAlias, boolean skipIdentity,_                                 String... expressions) {_        _        List<String> resolvedExpressions = expressions != null ? Arrays.asList(expressions) : Collections.emptyList()__        Context context = new Context(state, IndicesOptions.lenientExpandOpen(), true, false)__        for (ExpressionResolver expressionResolver : expressionResolvers) {_            resolvedExpressions = expressionResolver.resolve(context, resolvedExpressions)__        }__        if (isAllIndices(resolvedExpressions)) {_            return null__        }_        final IndexMetaData indexMetaData = state.metaData().getIndices().get(index)__        if (indexMetaData == null) {_            _            throw new IndexNotFoundException(index)__        }_        _        if (resolvedExpressions.size() == 1) {_            String alias = resolvedExpressions.get(0)___            AliasMetaData aliasMetaData = indexMetaData.getAliases().get(alias)__            if (aliasMetaData == null || requiredAlias.test(aliasMetaData) == false) {_                return null__            }_            return new String[]{alias}__        }_        List<String> aliases = null__        for (String alias : resolvedExpressions) {_            if (alias.equals(index)) {_                if (skipIdentity) {_                    continue__                } else {_                    return null__                }_            }_            AliasMetaData aliasMetaData = indexMetaData.getAliases().get(alias)__            _            _            if (aliasMetaData != null) {_                if (requiredAlias.test(aliasMetaData)) {_                    _                    if (aliases == null) {_                        aliases = new ArrayList<>()__                    }_                    aliases.add(alias)__                } else {_                    _                    return null__                }_            }_        }_        if (aliases == null) {_            return null__        }_        return aliases.toArray(new String[aliases.size()])__    };iterates,through,the,list,of,indices,and,selects,the,effective,list,of,required,aliases,for,the,given,index,p,only,aliases,where,the,given,predicate,tests,successfully,are,returned,if,the,indices,list,contains,a,non,required,reference,to,the,index,itself,null,is,returned,returns,code,null,if,no,filtering,is,required;public,string,index,aliases,cluster,state,state,string,index,predicate,alias,meta,data,required,alias,boolean,skip,identity,string,expressions,list,string,resolved,expressions,expressions,null,arrays,as,list,expressions,collections,empty,list,context,context,new,context,state,indices,options,lenient,expand,open,true,false,for,expression,resolver,expression,resolver,expression,resolvers,resolved,expressions,expression,resolver,resolve,context,resolved,expressions,if,is,all,indices,resolved,expressions,return,null,final,index,meta,data,index,meta,data,state,meta,data,get,indices,get,index,if,index,meta,data,null,throw,new,index,not,found,exception,index,if,resolved,expressions,size,1,string,alias,resolved,expressions,get,0,alias,meta,data,alias,meta,data,index,meta,data,get,aliases,get,alias,if,alias,meta,data,null,required,alias,test,alias,meta,data,false,return,null,return,new,string,alias,list,string,aliases,null,for,string,alias,resolved,expressions,if,alias,equals,index,if,skip,identity,continue,else,return,null,alias,meta,data,alias,meta,data,index,meta,data,get,aliases,get,alias,if,alias,meta,data,null,if,required,alias,test,alias,meta,data,if,aliases,null,aliases,new,array,list,aliases,add,alias,else,return,null,if,aliases,null,return,null,return,aliases,to,array,new,string,aliases,size
IndexNameExpressionResolver -> public Map<String, Set<String>> resolveSearchRouting(ClusterState state, @Nullable String routing, String... expressions);1524684173;Resolves the search routing if in the expression aliases are used. If expressions point to concrete indices_or aliases with no routing defined the specified routing is used.__@return routing values grouped by concrete index;public Map<String, Set<String>> resolveSearchRouting(ClusterState state, @Nullable String routing, String... expressions) {_        List<String> resolvedExpressions = expressions != null ? Arrays.asList(expressions) : Collections.<String>emptyList()__        Context context = new Context(state, IndicesOptions.lenientExpandOpen())__        for (ExpressionResolver expressionResolver : expressionResolvers) {_            resolvedExpressions = expressionResolver.resolve(context, resolvedExpressions)__        }__        _        if (isAllIndices(resolvedExpressions)) {_            return resolveSearchRoutingAllIndices(state.metaData(), routing)__        }__        Map<String, Set<String>> routings = null__        Set<String> paramRouting = null__        _        Set<String> norouting = new HashSet<>()__        if (routing != null) {_            paramRouting = Sets.newHashSet(Strings.splitStringByCommaToArray(routing))__        }__        for (String expression : resolvedExpressions) {_            AliasOrIndex aliasOrIndex = state.metaData().getAliasAndIndexLookup().get(expression)__            if (aliasOrIndex != null && aliasOrIndex.isAlias()) {_                AliasOrIndex.Alias alias = (AliasOrIndex.Alias) aliasOrIndex__                for (Tuple<String, AliasMetaData> item : alias.getConcreteIndexAndAliasMetaDatas()) {_                    String concreteIndex = item.v1()__                    AliasMetaData aliasMetaData = item.v2()__                    if (!norouting.contains(concreteIndex)) {_                        if (!aliasMetaData.searchRoutingValues().isEmpty()) {_                            _                            if (routings == null) {_                                routings = new HashMap<>()__                            }_                            Set<String> r = routings.get(concreteIndex)__                            if (r == null) {_                                r = new HashSet<>()__                                routings.put(concreteIndex, r)__                            }_                            r.addAll(aliasMetaData.searchRoutingValues())__                            if (paramRouting != null) {_                                r.retainAll(paramRouting)__                            }_                            if (r.isEmpty()) {_                                routings.remove(concreteIndex)__                            }_                        } else {_                            _                            if (!norouting.contains(concreteIndex)) {_                                norouting.add(concreteIndex)__                                if (paramRouting != null) {_                                    Set<String> r = new HashSet<>(paramRouting)__                                    if (routings == null) {_                                        routings = new HashMap<>()__                                    }_                                    routings.put(concreteIndex, r)__                                } else {_                                    if (routings != null) {_                                        routings.remove(concreteIndex)__                                    }_                                }_                            }_                        }_                    }_                }_            } else {_                _                if (!norouting.contains(expression)) {_                    norouting.add(expression)__                    if (paramRouting != null) {_                        Set<String> r = new HashSet<>(paramRouting)__                        if (routings == null) {_                            routings = new HashMap<>()__                        }_                        routings.put(expression, r)__                    } else {_                        if (routings != null) {_                            routings.remove(expression)__                        }_                    }_                }_            }__        }_        if (routings == null || routings.isEmpty()) {_            return null__        }_        return routings__    };resolves,the,search,routing,if,in,the,expression,aliases,are,used,if,expressions,point,to,concrete,indices,or,aliases,with,no,routing,defined,the,specified,routing,is,used,return,routing,values,grouped,by,concrete,index;public,map,string,set,string,resolve,search,routing,cluster,state,state,nullable,string,routing,string,expressions,list,string,resolved,expressions,expressions,null,arrays,as,list,expressions,collections,string,empty,list,context,context,new,context,state,indices,options,lenient,expand,open,for,expression,resolver,expression,resolver,expression,resolvers,resolved,expressions,expression,resolver,resolve,context,resolved,expressions,if,is,all,indices,resolved,expressions,return,resolve,search,routing,all,indices,state,meta,data,routing,map,string,set,string,routings,null,set,string,param,routing,null,set,string,norouting,new,hash,set,if,routing,null,param,routing,sets,new,hash,set,strings,split,string,by,comma,to,array,routing,for,string,expression,resolved,expressions,alias,or,index,alias,or,index,state,meta,data,get,alias,and,index,lookup,get,expression,if,alias,or,index,null,alias,or,index,is,alias,alias,or,index,alias,alias,alias,or,index,alias,alias,or,index,for,tuple,string,alias,meta,data,item,alias,get,concrete,index,and,alias,meta,datas,string,concrete,index,item,v1,alias,meta,data,alias,meta,data,item,v2,if,norouting,contains,concrete,index,if,alias,meta,data,search,routing,values,is,empty,if,routings,null,routings,new,hash,map,set,string,r,routings,get,concrete,index,if,r,null,r,new,hash,set,routings,put,concrete,index,r,r,add,all,alias,meta,data,search,routing,values,if,param,routing,null,r,retain,all,param,routing,if,r,is,empty,routings,remove,concrete,index,else,if,norouting,contains,concrete,index,norouting,add,concrete,index,if,param,routing,null,set,string,r,new,hash,set,param,routing,if,routings,null,routings,new,hash,map,routings,put,concrete,index,r,else,if,routings,null,routings,remove,concrete,index,else,if,norouting,contains,expression,norouting,add,expression,if,param,routing,null,set,string,r,new,hash,set,param,routing,if,routings,null,routings,new,hash,map,routings,put,expression,r,else,if,routings,null,routings,remove,expression,if,routings,null,routings,is,empty,return,null,return,routings
IndexNameExpressionResolver -> public Map<String, Set<String>> resolveSearchRouting(ClusterState state, @Nullable String routing, String... expressions);1525334055;Resolves the search routing if in the expression aliases are used. If expressions point to concrete indices_or aliases with no routing defined the specified routing is used.__@return routing values grouped by concrete index;public Map<String, Set<String>> resolveSearchRouting(ClusterState state, @Nullable String routing, String... expressions) {_        List<String> resolvedExpressions = expressions != null ? Arrays.asList(expressions) : Collections.<String>emptyList()__        Context context = new Context(state, IndicesOptions.lenientExpandOpen())__        for (ExpressionResolver expressionResolver : expressionResolvers) {_            resolvedExpressions = expressionResolver.resolve(context, resolvedExpressions)__        }__        _        if (isAllIndices(resolvedExpressions)) {_            return resolveSearchRoutingAllIndices(state.metaData(), routing)__        }__        Map<String, Set<String>> routings = null__        Set<String> paramRouting = null__        _        Set<String> norouting = new HashSet<>()__        if (routing != null) {_            paramRouting = Sets.newHashSet(Strings.splitStringByCommaToArray(routing))__        }__        for (String expression : resolvedExpressions) {_            AliasOrIndex aliasOrIndex = state.metaData().getAliasAndIndexLookup().get(expression)__            if (aliasOrIndex != null && aliasOrIndex.isAlias()) {_                AliasOrIndex.Alias alias = (AliasOrIndex.Alias) aliasOrIndex__                for (Tuple<String, AliasMetaData> item : alias.getConcreteIndexAndAliasMetaDatas()) {_                    String concreteIndex = item.v1()__                    AliasMetaData aliasMetaData = item.v2()__                    if (!norouting.contains(concreteIndex)) {_                        if (!aliasMetaData.searchRoutingValues().isEmpty()) {_                            _                            if (routings == null) {_                                routings = new HashMap<>()__                            }_                            Set<String> r = routings.get(concreteIndex)__                            if (r == null) {_                                r = new HashSet<>()__                                routings.put(concreteIndex, r)__                            }_                            r.addAll(aliasMetaData.searchRoutingValues())__                            if (paramRouting != null) {_                                r.retainAll(paramRouting)__                            }_                            if (r.isEmpty()) {_                                routings.remove(concreteIndex)__                            }_                        } else {_                            _                            if (!norouting.contains(concreteIndex)) {_                                norouting.add(concreteIndex)__                                if (paramRouting != null) {_                                    Set<String> r = new HashSet<>(paramRouting)__                                    if (routings == null) {_                                        routings = new HashMap<>()__                                    }_                                    routings.put(concreteIndex, r)__                                } else {_                                    if (routings != null) {_                                        routings.remove(concreteIndex)__                                    }_                                }_                            }_                        }_                    }_                }_            } else {_                _                if (!norouting.contains(expression)) {_                    norouting.add(expression)__                    if (paramRouting != null) {_                        Set<String> r = new HashSet<>(paramRouting)__                        if (routings == null) {_                            routings = new HashMap<>()__                        }_                        routings.put(expression, r)__                    } else {_                        if (routings != null) {_                            routings.remove(expression)__                        }_                    }_                }_            }__        }_        if (routings == null || routings.isEmpty()) {_            return null__        }_        return routings__    };resolves,the,search,routing,if,in,the,expression,aliases,are,used,if,expressions,point,to,concrete,indices,or,aliases,with,no,routing,defined,the,specified,routing,is,used,return,routing,values,grouped,by,concrete,index;public,map,string,set,string,resolve,search,routing,cluster,state,state,nullable,string,routing,string,expressions,list,string,resolved,expressions,expressions,null,arrays,as,list,expressions,collections,string,empty,list,context,context,new,context,state,indices,options,lenient,expand,open,for,expression,resolver,expression,resolver,expression,resolvers,resolved,expressions,expression,resolver,resolve,context,resolved,expressions,if,is,all,indices,resolved,expressions,return,resolve,search,routing,all,indices,state,meta,data,routing,map,string,set,string,routings,null,set,string,param,routing,null,set,string,norouting,new,hash,set,if,routing,null,param,routing,sets,new,hash,set,strings,split,string,by,comma,to,array,routing,for,string,expression,resolved,expressions,alias,or,index,alias,or,index,state,meta,data,get,alias,and,index,lookup,get,expression,if,alias,or,index,null,alias,or,index,is,alias,alias,or,index,alias,alias,alias,or,index,alias,alias,or,index,for,tuple,string,alias,meta,data,item,alias,get,concrete,index,and,alias,meta,datas,string,concrete,index,item,v1,alias,meta,data,alias,meta,data,item,v2,if,norouting,contains,concrete,index,if,alias,meta,data,search,routing,values,is,empty,if,routings,null,routings,new,hash,map,set,string,r,routings,get,concrete,index,if,r,null,r,new,hash,set,routings,put,concrete,index,r,r,add,all,alias,meta,data,search,routing,values,if,param,routing,null,r,retain,all,param,routing,if,r,is,empty,routings,remove,concrete,index,else,if,norouting,contains,concrete,index,norouting,add,concrete,index,if,param,routing,null,set,string,r,new,hash,set,param,routing,if,routings,null,routings,new,hash,map,routings,put,concrete,index,r,else,if,routings,null,routings,remove,concrete,index,else,if,norouting,contains,expression,norouting,add,expression,if,param,routing,null,set,string,r,new,hash,set,param,routing,if,routings,null,routings,new,hash,map,routings,put,expression,r,else,if,routings,null,routings,remove,expression,if,routings,null,routings,is,empty,return,null,return,routings
IndexNameExpressionResolver -> public Map<String, Set<String>> resolveSearchRouting(ClusterState state, @Nullable String routing, String... expressions);1532028790;Resolves the search routing if in the expression aliases are used. If expressions point to concrete indices_or aliases with no routing defined the specified routing is used.__@return routing values grouped by concrete index;public Map<String, Set<String>> resolveSearchRouting(ClusterState state, @Nullable String routing, String... expressions) {_        List<String> resolvedExpressions = expressions != null ? Arrays.asList(expressions) : Collections.<String>emptyList()__        Context context = new Context(state, IndicesOptions.lenientExpandOpen())__        for (ExpressionResolver expressionResolver : expressionResolvers) {_            resolvedExpressions = expressionResolver.resolve(context, resolvedExpressions)__        }__        _        if (isAllIndices(resolvedExpressions)) {_            return resolveSearchRoutingAllIndices(state.metaData(), routing)__        }__        Map<String, Set<String>> routings = null__        Set<String> paramRouting = null__        _        Set<String> norouting = new HashSet<>()__        if (routing != null) {_            paramRouting = Sets.newHashSet(Strings.splitStringByCommaToArray(routing))__        }__        for (String expression : resolvedExpressions) {_            AliasOrIndex aliasOrIndex = state.metaData().getAliasAndIndexLookup().get(expression)__            if (aliasOrIndex != null && aliasOrIndex.isAlias()) {_                AliasOrIndex.Alias alias = (AliasOrIndex.Alias) aliasOrIndex__                for (Tuple<String, AliasMetaData> item : alias.getConcreteIndexAndAliasMetaDatas()) {_                    String concreteIndex = item.v1()__                    AliasMetaData aliasMetaData = item.v2()__                    if (!norouting.contains(concreteIndex)) {_                        if (!aliasMetaData.searchRoutingValues().isEmpty()) {_                            _                            if (routings == null) {_                                routings = new HashMap<>()__                            }_                            Set<String> r = routings.get(concreteIndex)__                            if (r == null) {_                                r = new HashSet<>()__                                routings.put(concreteIndex, r)__                            }_                            r.addAll(aliasMetaData.searchRoutingValues())__                            if (paramRouting != null) {_                                r.retainAll(paramRouting)__                            }_                            if (r.isEmpty()) {_                                routings.remove(concreteIndex)__                            }_                        } else {_                            _                            if (!norouting.contains(concreteIndex)) {_                                norouting.add(concreteIndex)__                                if (paramRouting != null) {_                                    Set<String> r = new HashSet<>(paramRouting)__                                    if (routings == null) {_                                        routings = new HashMap<>()__                                    }_                                    routings.put(concreteIndex, r)__                                } else {_                                    if (routings != null) {_                                        routings.remove(concreteIndex)__                                    }_                                }_                            }_                        }_                    }_                }_            } else {_                _                if (!norouting.contains(expression)) {_                    norouting.add(expression)__                    if (paramRouting != null) {_                        Set<String> r = new HashSet<>(paramRouting)__                        if (routings == null) {_                            routings = new HashMap<>()__                        }_                        routings.put(expression, r)__                    } else {_                        if (routings != null) {_                            routings.remove(expression)__                        }_                    }_                }_            }__        }_        if (routings == null || routings.isEmpty()) {_            return null__        }_        return routings__    };resolves,the,search,routing,if,in,the,expression,aliases,are,used,if,expressions,point,to,concrete,indices,or,aliases,with,no,routing,defined,the,specified,routing,is,used,return,routing,values,grouped,by,concrete,index;public,map,string,set,string,resolve,search,routing,cluster,state,state,nullable,string,routing,string,expressions,list,string,resolved,expressions,expressions,null,arrays,as,list,expressions,collections,string,empty,list,context,context,new,context,state,indices,options,lenient,expand,open,for,expression,resolver,expression,resolver,expression,resolvers,resolved,expressions,expression,resolver,resolve,context,resolved,expressions,if,is,all,indices,resolved,expressions,return,resolve,search,routing,all,indices,state,meta,data,routing,map,string,set,string,routings,null,set,string,param,routing,null,set,string,norouting,new,hash,set,if,routing,null,param,routing,sets,new,hash,set,strings,split,string,by,comma,to,array,routing,for,string,expression,resolved,expressions,alias,or,index,alias,or,index,state,meta,data,get,alias,and,index,lookup,get,expression,if,alias,or,index,null,alias,or,index,is,alias,alias,or,index,alias,alias,alias,or,index,alias,alias,or,index,for,tuple,string,alias,meta,data,item,alias,get,concrete,index,and,alias,meta,datas,string,concrete,index,item,v1,alias,meta,data,alias,meta,data,item,v2,if,norouting,contains,concrete,index,if,alias,meta,data,search,routing,values,is,empty,if,routings,null,routings,new,hash,map,set,string,r,routings,get,concrete,index,if,r,null,r,new,hash,set,routings,put,concrete,index,r,r,add,all,alias,meta,data,search,routing,values,if,param,routing,null,r,retain,all,param,routing,if,r,is,empty,routings,remove,concrete,index,else,if,norouting,contains,concrete,index,norouting,add,concrete,index,if,param,routing,null,set,string,r,new,hash,set,param,routing,if,routings,null,routings,new,hash,map,routings,put,concrete,index,r,else,if,routings,null,routings,remove,concrete,index,else,if,norouting,contains,expression,norouting,add,expression,if,param,routing,null,set,string,r,new,hash,set,param,routing,if,routings,null,routings,new,hash,map,routings,put,expression,r,else,if,routings,null,routings,remove,expression,if,routings,null,routings,is,empty,return,null,return,routings
IndexNameExpressionResolver -> public Map<String, Set<String>> resolveSearchRouting(ClusterState state, @Nullable String routing, String... expressions);1538067637;Resolves the search routing if in the expression aliases are used. If expressions point to concrete indices_or aliases with no routing defined the specified routing is used.__@return routing values grouped by concrete index;public Map<String, Set<String>> resolveSearchRouting(ClusterState state, @Nullable String routing, String... expressions) {_        List<String> resolvedExpressions = expressions != null ? Arrays.asList(expressions) : Collections.<String>emptyList()__        Context context = new Context(state, IndicesOptions.lenientExpandOpen())__        for (ExpressionResolver expressionResolver : expressionResolvers) {_            resolvedExpressions = expressionResolver.resolve(context, resolvedExpressions)__        }__        _        if (isAllIndices(resolvedExpressions)) {_            return resolveSearchRoutingAllIndices(state.metaData(), routing)__        }__        Map<String, Set<String>> routings = null__        Set<String> paramRouting = null__        _        Set<String> norouting = new HashSet<>()__        if (routing != null) {_            paramRouting = Sets.newHashSet(Strings.splitStringByCommaToArray(routing))__        }__        for (String expression : resolvedExpressions) {_            AliasOrIndex aliasOrIndex = state.metaData().getAliasAndIndexLookup().get(expression)__            if (aliasOrIndex != null && aliasOrIndex.isAlias()) {_                AliasOrIndex.Alias alias = (AliasOrIndex.Alias) aliasOrIndex__                for (Tuple<String, AliasMetaData> item : alias.getConcreteIndexAndAliasMetaDatas()) {_                    String concreteIndex = item.v1()__                    AliasMetaData aliasMetaData = item.v2()__                    if (!norouting.contains(concreteIndex)) {_                        if (!aliasMetaData.searchRoutingValues().isEmpty()) {_                            _                            if (routings == null) {_                                routings = new HashMap<>()__                            }_                            Set<String> r = routings.get(concreteIndex)__                            if (r == null) {_                                r = new HashSet<>()__                                routings.put(concreteIndex, r)__                            }_                            r.addAll(aliasMetaData.searchRoutingValues())__                            if (paramRouting != null) {_                                r.retainAll(paramRouting)__                            }_                            if (r.isEmpty()) {_                                routings.remove(concreteIndex)__                            }_                        } else {_                            _                            if (!norouting.contains(concreteIndex)) {_                                norouting.add(concreteIndex)__                                if (paramRouting != null) {_                                    Set<String> r = new HashSet<>(paramRouting)__                                    if (routings == null) {_                                        routings = new HashMap<>()__                                    }_                                    routings.put(concreteIndex, r)__                                } else {_                                    if (routings != null) {_                                        routings.remove(concreteIndex)__                                    }_                                }_                            }_                        }_                    }_                }_            } else {_                _                if (!norouting.contains(expression)) {_                    norouting.add(expression)__                    if (paramRouting != null) {_                        Set<String> r = new HashSet<>(paramRouting)__                        if (routings == null) {_                            routings = new HashMap<>()__                        }_                        routings.put(expression, r)__                    } else {_                        if (routings != null) {_                            routings.remove(expression)__                        }_                    }_                }_            }__        }_        if (routings == null || routings.isEmpty()) {_            return null__        }_        return routings__    };resolves,the,search,routing,if,in,the,expression,aliases,are,used,if,expressions,point,to,concrete,indices,or,aliases,with,no,routing,defined,the,specified,routing,is,used,return,routing,values,grouped,by,concrete,index;public,map,string,set,string,resolve,search,routing,cluster,state,state,nullable,string,routing,string,expressions,list,string,resolved,expressions,expressions,null,arrays,as,list,expressions,collections,string,empty,list,context,context,new,context,state,indices,options,lenient,expand,open,for,expression,resolver,expression,resolver,expression,resolvers,resolved,expressions,expression,resolver,resolve,context,resolved,expressions,if,is,all,indices,resolved,expressions,return,resolve,search,routing,all,indices,state,meta,data,routing,map,string,set,string,routings,null,set,string,param,routing,null,set,string,norouting,new,hash,set,if,routing,null,param,routing,sets,new,hash,set,strings,split,string,by,comma,to,array,routing,for,string,expression,resolved,expressions,alias,or,index,alias,or,index,state,meta,data,get,alias,and,index,lookup,get,expression,if,alias,or,index,null,alias,or,index,is,alias,alias,or,index,alias,alias,alias,or,index,alias,alias,or,index,for,tuple,string,alias,meta,data,item,alias,get,concrete,index,and,alias,meta,datas,string,concrete,index,item,v1,alias,meta,data,alias,meta,data,item,v2,if,norouting,contains,concrete,index,if,alias,meta,data,search,routing,values,is,empty,if,routings,null,routings,new,hash,map,set,string,r,routings,get,concrete,index,if,r,null,r,new,hash,set,routings,put,concrete,index,r,r,add,all,alias,meta,data,search,routing,values,if,param,routing,null,r,retain,all,param,routing,if,r,is,empty,routings,remove,concrete,index,else,if,norouting,contains,concrete,index,norouting,add,concrete,index,if,param,routing,null,set,string,r,new,hash,set,param,routing,if,routings,null,routings,new,hash,map,routings,put,concrete,index,r,else,if,routings,null,routings,remove,concrete,index,else,if,norouting,contains,expression,norouting,add,expression,if,param,routing,null,set,string,r,new,hash,set,param,routing,if,routings,null,routings,new,hash,map,routings,put,expression,r,else,if,routings,null,routings,remove,expression,if,routings,null,routings,is,empty,return,null,return,routings
IndexNameExpressionResolver -> public Map<String, Set<String>> resolveSearchRouting(ClusterState state, @Nullable String routing, String... expressions);1539615817;Resolves the search routing if in the expression aliases are used. If expressions point to concrete indices_or aliases with no routing defined the specified routing is used.__@return routing values grouped by concrete index;public Map<String, Set<String>> resolveSearchRouting(ClusterState state, @Nullable String routing, String... expressions) {_        List<String> resolvedExpressions = expressions != null ? Arrays.asList(expressions) : Collections.<String>emptyList()__        Context context = new Context(state, IndicesOptions.lenientExpandOpen())__        for (ExpressionResolver expressionResolver : expressionResolvers) {_            resolvedExpressions = expressionResolver.resolve(context, resolvedExpressions)__        }__        _        if (isAllIndices(resolvedExpressions)) {_            return resolveSearchRoutingAllIndices(state.metaData(), routing)__        }__        Map<String, Set<String>> routings = null__        Set<String> paramRouting = null__        _        Set<String> norouting = new HashSet<>()__        if (routing != null) {_            paramRouting = Sets.newHashSet(Strings.splitStringByCommaToArray(routing))__        }__        for (String expression : resolvedExpressions) {_            AliasOrIndex aliasOrIndex = state.metaData().getAliasAndIndexLookup().get(expression)__            if (aliasOrIndex != null && aliasOrIndex.isAlias()) {_                AliasOrIndex.Alias alias = (AliasOrIndex.Alias) aliasOrIndex__                for (Tuple<String, AliasMetaData> item : alias.getConcreteIndexAndAliasMetaDatas()) {_                    String concreteIndex = item.v1()__                    AliasMetaData aliasMetaData = item.v2()__                    if (!norouting.contains(concreteIndex)) {_                        if (!aliasMetaData.searchRoutingValues().isEmpty()) {_                            _                            if (routings == null) {_                                routings = new HashMap<>()__                            }_                            Set<String> r = routings.get(concreteIndex)__                            if (r == null) {_                                r = new HashSet<>()__                                routings.put(concreteIndex, r)__                            }_                            r.addAll(aliasMetaData.searchRoutingValues())__                            if (paramRouting != null) {_                                r.retainAll(paramRouting)__                            }_                            if (r.isEmpty()) {_                                routings.remove(concreteIndex)__                            }_                        } else {_                            _                            if (!norouting.contains(concreteIndex)) {_                                norouting.add(concreteIndex)__                                if (paramRouting != null) {_                                    Set<String> r = new HashSet<>(paramRouting)__                                    if (routings == null) {_                                        routings = new HashMap<>()__                                    }_                                    routings.put(concreteIndex, r)__                                } else {_                                    if (routings != null) {_                                        routings.remove(concreteIndex)__                                    }_                                }_                            }_                        }_                    }_                }_            } else {_                _                if (!norouting.contains(expression)) {_                    norouting.add(expression)__                    if (paramRouting != null) {_                        Set<String> r = new HashSet<>(paramRouting)__                        if (routings == null) {_                            routings = new HashMap<>()__                        }_                        routings.put(expression, r)__                    } else {_                        if (routings != null) {_                            routings.remove(expression)__                        }_                    }_                }_            }__        }_        if (routings == null || routings.isEmpty()) {_            return null__        }_        return routings__    };resolves,the,search,routing,if,in,the,expression,aliases,are,used,if,expressions,point,to,concrete,indices,or,aliases,with,no,routing,defined,the,specified,routing,is,used,return,routing,values,grouped,by,concrete,index;public,map,string,set,string,resolve,search,routing,cluster,state,state,nullable,string,routing,string,expressions,list,string,resolved,expressions,expressions,null,arrays,as,list,expressions,collections,string,empty,list,context,context,new,context,state,indices,options,lenient,expand,open,for,expression,resolver,expression,resolver,expression,resolvers,resolved,expressions,expression,resolver,resolve,context,resolved,expressions,if,is,all,indices,resolved,expressions,return,resolve,search,routing,all,indices,state,meta,data,routing,map,string,set,string,routings,null,set,string,param,routing,null,set,string,norouting,new,hash,set,if,routing,null,param,routing,sets,new,hash,set,strings,split,string,by,comma,to,array,routing,for,string,expression,resolved,expressions,alias,or,index,alias,or,index,state,meta,data,get,alias,and,index,lookup,get,expression,if,alias,or,index,null,alias,or,index,is,alias,alias,or,index,alias,alias,alias,or,index,alias,alias,or,index,for,tuple,string,alias,meta,data,item,alias,get,concrete,index,and,alias,meta,datas,string,concrete,index,item,v1,alias,meta,data,alias,meta,data,item,v2,if,norouting,contains,concrete,index,if,alias,meta,data,search,routing,values,is,empty,if,routings,null,routings,new,hash,map,set,string,r,routings,get,concrete,index,if,r,null,r,new,hash,set,routings,put,concrete,index,r,r,add,all,alias,meta,data,search,routing,values,if,param,routing,null,r,retain,all,param,routing,if,r,is,empty,routings,remove,concrete,index,else,if,norouting,contains,concrete,index,norouting,add,concrete,index,if,param,routing,null,set,string,r,new,hash,set,param,routing,if,routings,null,routings,new,hash,map,routings,put,concrete,index,r,else,if,routings,null,routings,remove,concrete,index,else,if,norouting,contains,expression,norouting,add,expression,if,param,routing,null,set,string,r,new,hash,set,param,routing,if,routings,null,routings,new,hash,map,routings,put,expression,r,else,if,routings,null,routings,remove,expression,if,routings,null,routings,is,empty,return,null,return,routings
IndexNameExpressionResolver -> public Map<String, Set<String>> resolveSearchRouting(ClusterState state, @Nullable String routing, String... expressions);1540313026;Resolves the search routing if in the expression aliases are used. If expressions point to concrete indices_or aliases with no routing defined the specified routing is used.__@return routing values grouped by concrete index;public Map<String, Set<String>> resolveSearchRouting(ClusterState state, @Nullable String routing, String... expressions) {_        List<String> resolvedExpressions = expressions != null ? Arrays.asList(expressions) : Collections.<String>emptyList()__        Context context = new Context(state, IndicesOptions.lenientExpandOpen())__        for (ExpressionResolver expressionResolver : expressionResolvers) {_            resolvedExpressions = expressionResolver.resolve(context, resolvedExpressions)__        }__        _        if (isAllIndices(resolvedExpressions)) {_            return resolveSearchRoutingAllIndices(state.metaData(), routing)__        }__        Map<String, Set<String>> routings = null__        Set<String> paramRouting = null__        _        Set<String> norouting = new HashSet<>()__        if (routing != null) {_            paramRouting = Sets.newHashSet(Strings.splitStringByCommaToArray(routing))__        }__        for (String expression : resolvedExpressions) {_            AliasOrIndex aliasOrIndex = state.metaData().getAliasAndIndexLookup().get(expression)__            if (aliasOrIndex != null && aliasOrIndex.isAlias()) {_                AliasOrIndex.Alias alias = (AliasOrIndex.Alias) aliasOrIndex__                for (Tuple<String, AliasMetaData> item : alias.getConcreteIndexAndAliasMetaDatas()) {_                    String concreteIndex = item.v1()__                    AliasMetaData aliasMetaData = item.v2()__                    if (!norouting.contains(concreteIndex)) {_                        if (!aliasMetaData.searchRoutingValues().isEmpty()) {_                            _                            if (routings == null) {_                                routings = new HashMap<>()__                            }_                            Set<String> r = routings.get(concreteIndex)__                            if (r == null) {_                                r = new HashSet<>()__                                routings.put(concreteIndex, r)__                            }_                            r.addAll(aliasMetaData.searchRoutingValues())__                            if (paramRouting != null) {_                                r.retainAll(paramRouting)__                            }_                            if (r.isEmpty()) {_                                routings.remove(concreteIndex)__                            }_                        } else {_                            _                            if (!norouting.contains(concreteIndex)) {_                                norouting.add(concreteIndex)__                                if (paramRouting != null) {_                                    Set<String> r = new HashSet<>(paramRouting)__                                    if (routings == null) {_                                        routings = new HashMap<>()__                                    }_                                    routings.put(concreteIndex, r)__                                } else {_                                    if (routings != null) {_                                        routings.remove(concreteIndex)__                                    }_                                }_                            }_                        }_                    }_                }_            } else {_                _                if (!norouting.contains(expression)) {_                    norouting.add(expression)__                    if (paramRouting != null) {_                        Set<String> r = new HashSet<>(paramRouting)__                        if (routings == null) {_                            routings = new HashMap<>()__                        }_                        routings.put(expression, r)__                    } else {_                        if (routings != null) {_                            routings.remove(expression)__                        }_                    }_                }_            }__        }_        if (routings == null || routings.isEmpty()) {_            return null__        }_        return routings__    };resolves,the,search,routing,if,in,the,expression,aliases,are,used,if,expressions,point,to,concrete,indices,or,aliases,with,no,routing,defined,the,specified,routing,is,used,return,routing,values,grouped,by,concrete,index;public,map,string,set,string,resolve,search,routing,cluster,state,state,nullable,string,routing,string,expressions,list,string,resolved,expressions,expressions,null,arrays,as,list,expressions,collections,string,empty,list,context,context,new,context,state,indices,options,lenient,expand,open,for,expression,resolver,expression,resolver,expression,resolvers,resolved,expressions,expression,resolver,resolve,context,resolved,expressions,if,is,all,indices,resolved,expressions,return,resolve,search,routing,all,indices,state,meta,data,routing,map,string,set,string,routings,null,set,string,param,routing,null,set,string,norouting,new,hash,set,if,routing,null,param,routing,sets,new,hash,set,strings,split,string,by,comma,to,array,routing,for,string,expression,resolved,expressions,alias,or,index,alias,or,index,state,meta,data,get,alias,and,index,lookup,get,expression,if,alias,or,index,null,alias,or,index,is,alias,alias,or,index,alias,alias,alias,or,index,alias,alias,or,index,for,tuple,string,alias,meta,data,item,alias,get,concrete,index,and,alias,meta,datas,string,concrete,index,item,v1,alias,meta,data,alias,meta,data,item,v2,if,norouting,contains,concrete,index,if,alias,meta,data,search,routing,values,is,empty,if,routings,null,routings,new,hash,map,set,string,r,routings,get,concrete,index,if,r,null,r,new,hash,set,routings,put,concrete,index,r,r,add,all,alias,meta,data,search,routing,values,if,param,routing,null,r,retain,all,param,routing,if,r,is,empty,routings,remove,concrete,index,else,if,norouting,contains,concrete,index,norouting,add,concrete,index,if,param,routing,null,set,string,r,new,hash,set,param,routing,if,routings,null,routings,new,hash,map,routings,put,concrete,index,r,else,if,routings,null,routings,remove,concrete,index,else,if,norouting,contains,expression,norouting,add,expression,if,param,routing,null,set,string,r,new,hash,set,param,routing,if,routings,null,routings,new,hash,map,routings,put,expression,r,else,if,routings,null,routings,remove,expression,if,routings,null,routings,is,empty,return,null,return,routings
IndexNameExpressionResolver -> public Map<String, Set<String>> resolveSearchRouting(ClusterState state, @Nullable String routing, String... expressions);1540847035;Resolves the search routing if in the expression aliases are used. If expressions point to concrete indices_or aliases with no routing defined the specified routing is used.__@return routing values grouped by concrete index;public Map<String, Set<String>> resolveSearchRouting(ClusterState state, @Nullable String routing, String... expressions) {_        List<String> resolvedExpressions = expressions != null ? Arrays.asList(expressions) : Collections.<String>emptyList()__        Context context = new Context(state, IndicesOptions.lenientExpandOpen())__        for (ExpressionResolver expressionResolver : expressionResolvers) {_            resolvedExpressions = expressionResolver.resolve(context, resolvedExpressions)__        }__        _        if (isAllIndices(resolvedExpressions)) {_            return resolveSearchRoutingAllIndices(state.metaData(), routing)__        }__        Map<String, Set<String>> routings = null__        Set<String> paramRouting = null__        _        Set<String> norouting = new HashSet<>()__        if (routing != null) {_            paramRouting = Sets.newHashSet(Strings.splitStringByCommaToArray(routing))__        }__        for (String expression : resolvedExpressions) {_            AliasOrIndex aliasOrIndex = state.metaData().getAliasAndIndexLookup().get(expression)__            if (aliasOrIndex != null && aliasOrIndex.isAlias()) {_                AliasOrIndex.Alias alias = (AliasOrIndex.Alias) aliasOrIndex__                for (Tuple<String, AliasMetaData> item : alias.getConcreteIndexAndAliasMetaDatas()) {_                    String concreteIndex = item.v1()__                    AliasMetaData aliasMetaData = item.v2()__                    if (!norouting.contains(concreteIndex)) {_                        if (!aliasMetaData.searchRoutingValues().isEmpty()) {_                            _                            if (routings == null) {_                                routings = new HashMap<>()__                            }_                            Set<String> r = routings.get(concreteIndex)__                            if (r == null) {_                                r = new HashSet<>()__                                routings.put(concreteIndex, r)__                            }_                            r.addAll(aliasMetaData.searchRoutingValues())__                            if (paramRouting != null) {_                                r.retainAll(paramRouting)__                            }_                            if (r.isEmpty()) {_                                routings.remove(concreteIndex)__                            }_                        } else {_                            _                            if (!norouting.contains(concreteIndex)) {_                                norouting.add(concreteIndex)__                                if (paramRouting != null) {_                                    Set<String> r = new HashSet<>(paramRouting)__                                    if (routings == null) {_                                        routings = new HashMap<>()__                                    }_                                    routings.put(concreteIndex, r)__                                } else {_                                    if (routings != null) {_                                        routings.remove(concreteIndex)__                                    }_                                }_                            }_                        }_                    }_                }_            } else {_                _                if (!norouting.contains(expression)) {_                    norouting.add(expression)__                    if (paramRouting != null) {_                        Set<String> r = new HashSet<>(paramRouting)__                        if (routings == null) {_                            routings = new HashMap<>()__                        }_                        routings.put(expression, r)__                    } else {_                        if (routings != null) {_                            routings.remove(expression)__                        }_                    }_                }_            }__        }_        if (routings == null || routings.isEmpty()) {_            return null__        }_        return routings__    };resolves,the,search,routing,if,in,the,expression,aliases,are,used,if,expressions,point,to,concrete,indices,or,aliases,with,no,routing,defined,the,specified,routing,is,used,return,routing,values,grouped,by,concrete,index;public,map,string,set,string,resolve,search,routing,cluster,state,state,nullable,string,routing,string,expressions,list,string,resolved,expressions,expressions,null,arrays,as,list,expressions,collections,string,empty,list,context,context,new,context,state,indices,options,lenient,expand,open,for,expression,resolver,expression,resolver,expression,resolvers,resolved,expressions,expression,resolver,resolve,context,resolved,expressions,if,is,all,indices,resolved,expressions,return,resolve,search,routing,all,indices,state,meta,data,routing,map,string,set,string,routings,null,set,string,param,routing,null,set,string,norouting,new,hash,set,if,routing,null,param,routing,sets,new,hash,set,strings,split,string,by,comma,to,array,routing,for,string,expression,resolved,expressions,alias,or,index,alias,or,index,state,meta,data,get,alias,and,index,lookup,get,expression,if,alias,or,index,null,alias,or,index,is,alias,alias,or,index,alias,alias,alias,or,index,alias,alias,or,index,for,tuple,string,alias,meta,data,item,alias,get,concrete,index,and,alias,meta,datas,string,concrete,index,item,v1,alias,meta,data,alias,meta,data,item,v2,if,norouting,contains,concrete,index,if,alias,meta,data,search,routing,values,is,empty,if,routings,null,routings,new,hash,map,set,string,r,routings,get,concrete,index,if,r,null,r,new,hash,set,routings,put,concrete,index,r,r,add,all,alias,meta,data,search,routing,values,if,param,routing,null,r,retain,all,param,routing,if,r,is,empty,routings,remove,concrete,index,else,if,norouting,contains,concrete,index,norouting,add,concrete,index,if,param,routing,null,set,string,r,new,hash,set,param,routing,if,routings,null,routings,new,hash,map,routings,put,concrete,index,r,else,if,routings,null,routings,remove,concrete,index,else,if,norouting,contains,expression,norouting,add,expression,if,param,routing,null,set,string,r,new,hash,set,param,routing,if,routings,null,routings,new,hash,map,routings,put,expression,r,else,if,routings,null,routings,remove,expression,if,routings,null,routings,is,empty,return,null,return,routings
IndexNameExpressionResolver -> public Map<String, Set<String>> resolveSearchRouting(ClusterState state, @Nullable String routing, String... expressions);1541092382;Resolves the search routing if in the expression aliases are used. If expressions point to concrete indices_or aliases with no routing defined the specified routing is used.__@return routing values grouped by concrete index;public Map<String, Set<String>> resolveSearchRouting(ClusterState state, @Nullable String routing, String... expressions) {_        List<String> resolvedExpressions = expressions != null ? Arrays.asList(expressions) : Collections.<String>emptyList()__        Context context = new Context(state, IndicesOptions.lenientExpandOpen())__        for (ExpressionResolver expressionResolver : expressionResolvers) {_            resolvedExpressions = expressionResolver.resolve(context, resolvedExpressions)__        }__        _        if (isAllIndices(resolvedExpressions)) {_            return resolveSearchRoutingAllIndices(state.metaData(), routing)__        }__        Map<String, Set<String>> routings = null__        Set<String> paramRouting = null__        _        Set<String> norouting = new HashSet<>()__        if (routing != null) {_            paramRouting = Sets.newHashSet(Strings.splitStringByCommaToArray(routing))__        }__        for (String expression : resolvedExpressions) {_            AliasOrIndex aliasOrIndex = state.metaData().getAliasAndIndexLookup().get(expression)__            if (aliasOrIndex != null && aliasOrIndex.isAlias()) {_                AliasOrIndex.Alias alias = (AliasOrIndex.Alias) aliasOrIndex__                for (Tuple<String, AliasMetaData> item : alias.getConcreteIndexAndAliasMetaDatas()) {_                    String concreteIndex = item.v1()__                    AliasMetaData aliasMetaData = item.v2()__                    if (!norouting.contains(concreteIndex)) {_                        if (!aliasMetaData.searchRoutingValues().isEmpty()) {_                            _                            if (routings == null) {_                                routings = new HashMap<>()__                            }_                            Set<String> r = routings.get(concreteIndex)__                            if (r == null) {_                                r = new HashSet<>()__                                routings.put(concreteIndex, r)__                            }_                            r.addAll(aliasMetaData.searchRoutingValues())__                            if (paramRouting != null) {_                                r.retainAll(paramRouting)__                            }_                            if (r.isEmpty()) {_                                routings.remove(concreteIndex)__                            }_                        } else {_                            _                            if (!norouting.contains(concreteIndex)) {_                                norouting.add(concreteIndex)__                                if (paramRouting != null) {_                                    Set<String> r = new HashSet<>(paramRouting)__                                    if (routings == null) {_                                        routings = new HashMap<>()__                                    }_                                    routings.put(concreteIndex, r)__                                } else {_                                    if (routings != null) {_                                        routings.remove(concreteIndex)__                                    }_                                }_                            }_                        }_                    }_                }_            } else {_                _                if (!norouting.contains(expression)) {_                    norouting.add(expression)__                    if (paramRouting != null) {_                        Set<String> r = new HashSet<>(paramRouting)__                        if (routings == null) {_                            routings = new HashMap<>()__                        }_                        routings.put(expression, r)__                    } else {_                        if (routings != null) {_                            routings.remove(expression)__                        }_                    }_                }_            }__        }_        if (routings == null || routings.isEmpty()) {_            return null__        }_        return routings__    };resolves,the,search,routing,if,in,the,expression,aliases,are,used,if,expressions,point,to,concrete,indices,or,aliases,with,no,routing,defined,the,specified,routing,is,used,return,routing,values,grouped,by,concrete,index;public,map,string,set,string,resolve,search,routing,cluster,state,state,nullable,string,routing,string,expressions,list,string,resolved,expressions,expressions,null,arrays,as,list,expressions,collections,string,empty,list,context,context,new,context,state,indices,options,lenient,expand,open,for,expression,resolver,expression,resolver,expression,resolvers,resolved,expressions,expression,resolver,resolve,context,resolved,expressions,if,is,all,indices,resolved,expressions,return,resolve,search,routing,all,indices,state,meta,data,routing,map,string,set,string,routings,null,set,string,param,routing,null,set,string,norouting,new,hash,set,if,routing,null,param,routing,sets,new,hash,set,strings,split,string,by,comma,to,array,routing,for,string,expression,resolved,expressions,alias,or,index,alias,or,index,state,meta,data,get,alias,and,index,lookup,get,expression,if,alias,or,index,null,alias,or,index,is,alias,alias,or,index,alias,alias,alias,or,index,alias,alias,or,index,for,tuple,string,alias,meta,data,item,alias,get,concrete,index,and,alias,meta,datas,string,concrete,index,item,v1,alias,meta,data,alias,meta,data,item,v2,if,norouting,contains,concrete,index,if,alias,meta,data,search,routing,values,is,empty,if,routings,null,routings,new,hash,map,set,string,r,routings,get,concrete,index,if,r,null,r,new,hash,set,routings,put,concrete,index,r,r,add,all,alias,meta,data,search,routing,values,if,param,routing,null,r,retain,all,param,routing,if,r,is,empty,routings,remove,concrete,index,else,if,norouting,contains,concrete,index,norouting,add,concrete,index,if,param,routing,null,set,string,r,new,hash,set,param,routing,if,routings,null,routings,new,hash,map,routings,put,concrete,index,r,else,if,routings,null,routings,remove,concrete,index,else,if,norouting,contains,expression,norouting,add,expression,if,param,routing,null,set,string,r,new,hash,set,param,routing,if,routings,null,routings,new,hash,map,routings,put,expression,r,else,if,routings,null,routings,remove,expression,if,routings,null,routings,is,empty,return,null,return,routings
IndexNameExpressionResolver -> public Map<String, Set<String>> resolveSearchRouting(ClusterState state, @Nullable String routing, String... expressions);1541493930;Resolves the search routing if in the expression aliases are used. If expressions point to concrete indices_or aliases with no routing defined the specified routing is used.__@return routing values grouped by concrete index;public Map<String, Set<String>> resolveSearchRouting(ClusterState state, @Nullable String routing, String... expressions) {_        List<String> resolvedExpressions = expressions != null ? Arrays.asList(expressions) : Collections.<String>emptyList()__        Context context = new Context(state, IndicesOptions.lenientExpandOpen())__        for (ExpressionResolver expressionResolver : expressionResolvers) {_            resolvedExpressions = expressionResolver.resolve(context, resolvedExpressions)__        }__        _        if (isAllIndices(resolvedExpressions)) {_            return resolveSearchRoutingAllIndices(state.metaData(), routing)__        }__        Map<String, Set<String>> routings = null__        Set<String> paramRouting = null__        _        Set<String> norouting = new HashSet<>()__        if (routing != null) {_            paramRouting = Sets.newHashSet(Strings.splitStringByCommaToArray(routing))__        }__        for (String expression : resolvedExpressions) {_            AliasOrIndex aliasOrIndex = state.metaData().getAliasAndIndexLookup().get(expression)__            if (aliasOrIndex != null && aliasOrIndex.isAlias()) {_                AliasOrIndex.Alias alias = (AliasOrIndex.Alias) aliasOrIndex__                for (Tuple<String, AliasMetaData> item : alias.getConcreteIndexAndAliasMetaDatas()) {_                    String concreteIndex = item.v1()__                    AliasMetaData aliasMetaData = item.v2()__                    if (!norouting.contains(concreteIndex)) {_                        if (!aliasMetaData.searchRoutingValues().isEmpty()) {_                            _                            if (routings == null) {_                                routings = new HashMap<>()__                            }_                            Set<String> r = routings.get(concreteIndex)__                            if (r == null) {_                                r = new HashSet<>()__                                routings.put(concreteIndex, r)__                            }_                            r.addAll(aliasMetaData.searchRoutingValues())__                            if (paramRouting != null) {_                                r.retainAll(paramRouting)__                            }_                            if (r.isEmpty()) {_                                routings.remove(concreteIndex)__                            }_                        } else {_                            _                            if (!norouting.contains(concreteIndex)) {_                                norouting.add(concreteIndex)__                                if (paramRouting != null) {_                                    Set<String> r = new HashSet<>(paramRouting)__                                    if (routings == null) {_                                        routings = new HashMap<>()__                                    }_                                    routings.put(concreteIndex, r)__                                } else {_                                    if (routings != null) {_                                        routings.remove(concreteIndex)__                                    }_                                }_                            }_                        }_                    }_                }_            } else {_                _                if (!norouting.contains(expression)) {_                    norouting.add(expression)__                    if (paramRouting != null) {_                        Set<String> r = new HashSet<>(paramRouting)__                        if (routings == null) {_                            routings = new HashMap<>()__                        }_                        routings.put(expression, r)__                    } else {_                        if (routings != null) {_                            routings.remove(expression)__                        }_                    }_                }_            }__        }_        if (routings == null || routings.isEmpty()) {_            return null__        }_        return routings__    };resolves,the,search,routing,if,in,the,expression,aliases,are,used,if,expressions,point,to,concrete,indices,or,aliases,with,no,routing,defined,the,specified,routing,is,used,return,routing,values,grouped,by,concrete,index;public,map,string,set,string,resolve,search,routing,cluster,state,state,nullable,string,routing,string,expressions,list,string,resolved,expressions,expressions,null,arrays,as,list,expressions,collections,string,empty,list,context,context,new,context,state,indices,options,lenient,expand,open,for,expression,resolver,expression,resolver,expression,resolvers,resolved,expressions,expression,resolver,resolve,context,resolved,expressions,if,is,all,indices,resolved,expressions,return,resolve,search,routing,all,indices,state,meta,data,routing,map,string,set,string,routings,null,set,string,param,routing,null,set,string,norouting,new,hash,set,if,routing,null,param,routing,sets,new,hash,set,strings,split,string,by,comma,to,array,routing,for,string,expression,resolved,expressions,alias,or,index,alias,or,index,state,meta,data,get,alias,and,index,lookup,get,expression,if,alias,or,index,null,alias,or,index,is,alias,alias,or,index,alias,alias,alias,or,index,alias,alias,or,index,for,tuple,string,alias,meta,data,item,alias,get,concrete,index,and,alias,meta,datas,string,concrete,index,item,v1,alias,meta,data,alias,meta,data,item,v2,if,norouting,contains,concrete,index,if,alias,meta,data,search,routing,values,is,empty,if,routings,null,routings,new,hash,map,set,string,r,routings,get,concrete,index,if,r,null,r,new,hash,set,routings,put,concrete,index,r,r,add,all,alias,meta,data,search,routing,values,if,param,routing,null,r,retain,all,param,routing,if,r,is,empty,routings,remove,concrete,index,else,if,norouting,contains,concrete,index,norouting,add,concrete,index,if,param,routing,null,set,string,r,new,hash,set,param,routing,if,routings,null,routings,new,hash,map,routings,put,concrete,index,r,else,if,routings,null,routings,remove,concrete,index,else,if,norouting,contains,expression,norouting,add,expression,if,param,routing,null,set,string,r,new,hash,set,param,routing,if,routings,null,routings,new,hash,map,routings,put,expression,r,else,if,routings,null,routings,remove,expression,if,routings,null,routings,is,empty,return,null,return,routings
IndexNameExpressionResolver -> public Map<String, Set<String>> resolveSearchRouting(ClusterState state, @Nullable String routing, String... expressions);1541612607;Resolves the search routing if in the expression aliases are used. If expressions point to concrete indices_or aliases with no routing defined the specified routing is used.__@return routing values grouped by concrete index;public Map<String, Set<String>> resolveSearchRouting(ClusterState state, @Nullable String routing, String... expressions) {_        List<String> resolvedExpressions = expressions != null ? Arrays.asList(expressions) : Collections.<String>emptyList()__        Context context = new Context(state, IndicesOptions.lenientExpandOpen())__        for (ExpressionResolver expressionResolver : expressionResolvers) {_            resolvedExpressions = expressionResolver.resolve(context, resolvedExpressions)__        }__        _        if (isAllIndices(resolvedExpressions)) {_            return resolveSearchRoutingAllIndices(state.metaData(), routing)__        }__        Map<String, Set<String>> routings = null__        Set<String> paramRouting = null__        _        Set<String> norouting = new HashSet<>()__        if (routing != null) {_            paramRouting = Sets.newHashSet(Strings.splitStringByCommaToArray(routing))__        }__        for (String expression : resolvedExpressions) {_            AliasOrIndex aliasOrIndex = state.metaData().getAliasAndIndexLookup().get(expression)__            if (aliasOrIndex != null && aliasOrIndex.isAlias()) {_                AliasOrIndex.Alias alias = (AliasOrIndex.Alias) aliasOrIndex__                for (Tuple<String, AliasMetaData> item : alias.getConcreteIndexAndAliasMetaDatas()) {_                    String concreteIndex = item.v1()__                    AliasMetaData aliasMetaData = item.v2()__                    if (!norouting.contains(concreteIndex)) {_                        if (!aliasMetaData.searchRoutingValues().isEmpty()) {_                            _                            if (routings == null) {_                                routings = new HashMap<>()__                            }_                            Set<String> r = routings.get(concreteIndex)__                            if (r == null) {_                                r = new HashSet<>()__                                routings.put(concreteIndex, r)__                            }_                            r.addAll(aliasMetaData.searchRoutingValues())__                            if (paramRouting != null) {_                                r.retainAll(paramRouting)__                            }_                            if (r.isEmpty()) {_                                routings.remove(concreteIndex)__                            }_                        } else {_                            _                            if (!norouting.contains(concreteIndex)) {_                                norouting.add(concreteIndex)__                                if (paramRouting != null) {_                                    Set<String> r = new HashSet<>(paramRouting)__                                    if (routings == null) {_                                        routings = new HashMap<>()__                                    }_                                    routings.put(concreteIndex, r)__                                } else {_                                    if (routings != null) {_                                        routings.remove(concreteIndex)__                                    }_                                }_                            }_                        }_                    }_                }_            } else {_                _                if (!norouting.contains(expression)) {_                    norouting.add(expression)__                    if (paramRouting != null) {_                        Set<String> r = new HashSet<>(paramRouting)__                        if (routings == null) {_                            routings = new HashMap<>()__                        }_                        routings.put(expression, r)__                    } else {_                        if (routings != null) {_                            routings.remove(expression)__                        }_                    }_                }_            }__        }_        if (routings == null || routings.isEmpty()) {_            return null__        }_        return routings__    };resolves,the,search,routing,if,in,the,expression,aliases,are,used,if,expressions,point,to,concrete,indices,or,aliases,with,no,routing,defined,the,specified,routing,is,used,return,routing,values,grouped,by,concrete,index;public,map,string,set,string,resolve,search,routing,cluster,state,state,nullable,string,routing,string,expressions,list,string,resolved,expressions,expressions,null,arrays,as,list,expressions,collections,string,empty,list,context,context,new,context,state,indices,options,lenient,expand,open,for,expression,resolver,expression,resolver,expression,resolvers,resolved,expressions,expression,resolver,resolve,context,resolved,expressions,if,is,all,indices,resolved,expressions,return,resolve,search,routing,all,indices,state,meta,data,routing,map,string,set,string,routings,null,set,string,param,routing,null,set,string,norouting,new,hash,set,if,routing,null,param,routing,sets,new,hash,set,strings,split,string,by,comma,to,array,routing,for,string,expression,resolved,expressions,alias,or,index,alias,or,index,state,meta,data,get,alias,and,index,lookup,get,expression,if,alias,or,index,null,alias,or,index,is,alias,alias,or,index,alias,alias,alias,or,index,alias,alias,or,index,for,tuple,string,alias,meta,data,item,alias,get,concrete,index,and,alias,meta,datas,string,concrete,index,item,v1,alias,meta,data,alias,meta,data,item,v2,if,norouting,contains,concrete,index,if,alias,meta,data,search,routing,values,is,empty,if,routings,null,routings,new,hash,map,set,string,r,routings,get,concrete,index,if,r,null,r,new,hash,set,routings,put,concrete,index,r,r,add,all,alias,meta,data,search,routing,values,if,param,routing,null,r,retain,all,param,routing,if,r,is,empty,routings,remove,concrete,index,else,if,norouting,contains,concrete,index,norouting,add,concrete,index,if,param,routing,null,set,string,r,new,hash,set,param,routing,if,routings,null,routings,new,hash,map,routings,put,concrete,index,r,else,if,routings,null,routings,remove,concrete,index,else,if,norouting,contains,expression,norouting,add,expression,if,param,routing,null,set,string,r,new,hash,set,param,routing,if,routings,null,routings,new,hash,map,routings,put,expression,r,else,if,routings,null,routings,remove,expression,if,routings,null,routings,is,empty,return,null,return,routings
IndexNameExpressionResolver -> public Map<String, Set<String>> resolveSearchRouting(ClusterState state, @Nullable String routing, String... expressions);1544215214;Resolves the search routing if in the expression aliases are used. If expressions point to concrete indices_or aliases with no routing defined the specified routing is used.__@return routing values grouped by concrete index;public Map<String, Set<String>> resolveSearchRouting(ClusterState state, @Nullable String routing, String... expressions) {_        List<String> resolvedExpressions = expressions != null ? Arrays.asList(expressions) : Collections.<String>emptyList()__        Context context = new Context(state, IndicesOptions.lenientExpandOpen())__        for (ExpressionResolver expressionResolver : expressionResolvers) {_            resolvedExpressions = expressionResolver.resolve(context, resolvedExpressions)__        }__        _        if (isAllIndices(resolvedExpressions)) {_            return resolveSearchRoutingAllIndices(state.metaData(), routing)__        }__        Map<String, Set<String>> routings = null__        Set<String> paramRouting = null__        _        Set<String> norouting = new HashSet<>()__        if (routing != null) {_            paramRouting = Sets.newHashSet(Strings.splitStringByCommaToArray(routing))__        }__        for (String expression : resolvedExpressions) {_            AliasOrIndex aliasOrIndex = state.metaData().getAliasAndIndexLookup().get(expression)__            if (aliasOrIndex != null && aliasOrIndex.isAlias()) {_                AliasOrIndex.Alias alias = (AliasOrIndex.Alias) aliasOrIndex__                for (Tuple<String, AliasMetaData> item : alias.getConcreteIndexAndAliasMetaDatas()) {_                    String concreteIndex = item.v1()__                    AliasMetaData aliasMetaData = item.v2()__                    if (!norouting.contains(concreteIndex)) {_                        if (!aliasMetaData.searchRoutingValues().isEmpty()) {_                            _                            if (routings == null) {_                                routings = new HashMap<>()__                            }_                            Set<String> r = routings.get(concreteIndex)__                            if (r == null) {_                                r = new HashSet<>()__                                routings.put(concreteIndex, r)__                            }_                            r.addAll(aliasMetaData.searchRoutingValues())__                            if (paramRouting != null) {_                                r.retainAll(paramRouting)__                            }_                            if (r.isEmpty()) {_                                routings.remove(concreteIndex)__                            }_                        } else {_                            _                            if (!norouting.contains(concreteIndex)) {_                                norouting.add(concreteIndex)__                                if (paramRouting != null) {_                                    Set<String> r = new HashSet<>(paramRouting)__                                    if (routings == null) {_                                        routings = new HashMap<>()__                                    }_                                    routings.put(concreteIndex, r)__                                } else {_                                    if (routings != null) {_                                        routings.remove(concreteIndex)__                                    }_                                }_                            }_                        }_                    }_                }_            } else {_                _                if (!norouting.contains(expression)) {_                    norouting.add(expression)__                    if (paramRouting != null) {_                        Set<String> r = new HashSet<>(paramRouting)__                        if (routings == null) {_                            routings = new HashMap<>()__                        }_                        routings.put(expression, r)__                    } else {_                        if (routings != null) {_                            routings.remove(expression)__                        }_                    }_                }_            }__        }_        if (routings == null || routings.isEmpty()) {_            return null__        }_        return routings__    };resolves,the,search,routing,if,in,the,expression,aliases,are,used,if,expressions,point,to,concrete,indices,or,aliases,with,no,routing,defined,the,specified,routing,is,used,return,routing,values,grouped,by,concrete,index;public,map,string,set,string,resolve,search,routing,cluster,state,state,nullable,string,routing,string,expressions,list,string,resolved,expressions,expressions,null,arrays,as,list,expressions,collections,string,empty,list,context,context,new,context,state,indices,options,lenient,expand,open,for,expression,resolver,expression,resolver,expression,resolvers,resolved,expressions,expression,resolver,resolve,context,resolved,expressions,if,is,all,indices,resolved,expressions,return,resolve,search,routing,all,indices,state,meta,data,routing,map,string,set,string,routings,null,set,string,param,routing,null,set,string,norouting,new,hash,set,if,routing,null,param,routing,sets,new,hash,set,strings,split,string,by,comma,to,array,routing,for,string,expression,resolved,expressions,alias,or,index,alias,or,index,state,meta,data,get,alias,and,index,lookup,get,expression,if,alias,or,index,null,alias,or,index,is,alias,alias,or,index,alias,alias,alias,or,index,alias,alias,or,index,for,tuple,string,alias,meta,data,item,alias,get,concrete,index,and,alias,meta,datas,string,concrete,index,item,v1,alias,meta,data,alias,meta,data,item,v2,if,norouting,contains,concrete,index,if,alias,meta,data,search,routing,values,is,empty,if,routings,null,routings,new,hash,map,set,string,r,routings,get,concrete,index,if,r,null,r,new,hash,set,routings,put,concrete,index,r,r,add,all,alias,meta,data,search,routing,values,if,param,routing,null,r,retain,all,param,routing,if,r,is,empty,routings,remove,concrete,index,else,if,norouting,contains,concrete,index,norouting,add,concrete,index,if,param,routing,null,set,string,r,new,hash,set,param,routing,if,routings,null,routings,new,hash,map,routings,put,concrete,index,r,else,if,routings,null,routings,remove,concrete,index,else,if,norouting,contains,expression,norouting,add,expression,if,param,routing,null,set,string,r,new,hash,set,param,routing,if,routings,null,routings,new,hash,map,routings,put,expression,r,else,if,routings,null,routings,remove,expression,if,routings,null,routings,is,empty,return,null,return,routings
IndexNameExpressionResolver -> public Map<String, Set<String>> resolveSearchRouting(ClusterState state, @Nullable String routing, String... expressions);1548236405;Resolves the search routing if in the expression aliases are used. If expressions point to concrete indices_or aliases with no routing defined the specified routing is used.__@return routing values grouped by concrete index;public Map<String, Set<String>> resolveSearchRouting(ClusterState state, @Nullable String routing, String... expressions) {_        List<String> resolvedExpressions = expressions != null ? Arrays.asList(expressions) : Collections.<String>emptyList()__        Context context = new Context(state, IndicesOptions.lenientExpandOpen())__        for (ExpressionResolver expressionResolver : expressionResolvers) {_            resolvedExpressions = expressionResolver.resolve(context, resolvedExpressions)__        }__        _        if (isAllIndices(resolvedExpressions)) {_            return resolveSearchRoutingAllIndices(state.metaData(), routing)__        }__        Map<String, Set<String>> routings = null__        Set<String> paramRouting = null__        _        Set<String> norouting = new HashSet<>()__        if (routing != null) {_            paramRouting = Sets.newHashSet(Strings.splitStringByCommaToArray(routing))__        }__        for (String expression : resolvedExpressions) {_            AliasOrIndex aliasOrIndex = state.metaData().getAliasAndIndexLookup().get(expression)__            if (aliasOrIndex != null && aliasOrIndex.isAlias()) {_                AliasOrIndex.Alias alias = (AliasOrIndex.Alias) aliasOrIndex__                for (Tuple<String, AliasMetaData> item : alias.getConcreteIndexAndAliasMetaDatas()) {_                    String concreteIndex = item.v1()__                    AliasMetaData aliasMetaData = item.v2()__                    if (!norouting.contains(concreteIndex)) {_                        if (!aliasMetaData.searchRoutingValues().isEmpty()) {_                            _                            if (routings == null) {_                                routings = new HashMap<>()__                            }_                            Set<String> r = routings.get(concreteIndex)__                            if (r == null) {_                                r = new HashSet<>()__                                routings.put(concreteIndex, r)__                            }_                            r.addAll(aliasMetaData.searchRoutingValues())__                            if (paramRouting != null) {_                                r.retainAll(paramRouting)__                            }_                            if (r.isEmpty()) {_                                routings.remove(concreteIndex)__                            }_                        } else {_                            _                            if (!norouting.contains(concreteIndex)) {_                                norouting.add(concreteIndex)__                                if (paramRouting != null) {_                                    Set<String> r = new HashSet<>(paramRouting)__                                    if (routings == null) {_                                        routings = new HashMap<>()__                                    }_                                    routings.put(concreteIndex, r)__                                } else {_                                    if (routings != null) {_                                        routings.remove(concreteIndex)__                                    }_                                }_                            }_                        }_                    }_                }_            } else {_                _                if (!norouting.contains(expression)) {_                    norouting.add(expression)__                    if (paramRouting != null) {_                        Set<String> r = new HashSet<>(paramRouting)__                        if (routings == null) {_                            routings = new HashMap<>()__                        }_                        routings.put(expression, r)__                    } else {_                        if (routings != null) {_                            routings.remove(expression)__                        }_                    }_                }_            }__        }_        if (routings == null || routings.isEmpty()) {_            return null__        }_        return routings__    };resolves,the,search,routing,if,in,the,expression,aliases,are,used,if,expressions,point,to,concrete,indices,or,aliases,with,no,routing,defined,the,specified,routing,is,used,return,routing,values,grouped,by,concrete,index;public,map,string,set,string,resolve,search,routing,cluster,state,state,nullable,string,routing,string,expressions,list,string,resolved,expressions,expressions,null,arrays,as,list,expressions,collections,string,empty,list,context,context,new,context,state,indices,options,lenient,expand,open,for,expression,resolver,expression,resolver,expression,resolvers,resolved,expressions,expression,resolver,resolve,context,resolved,expressions,if,is,all,indices,resolved,expressions,return,resolve,search,routing,all,indices,state,meta,data,routing,map,string,set,string,routings,null,set,string,param,routing,null,set,string,norouting,new,hash,set,if,routing,null,param,routing,sets,new,hash,set,strings,split,string,by,comma,to,array,routing,for,string,expression,resolved,expressions,alias,or,index,alias,or,index,state,meta,data,get,alias,and,index,lookup,get,expression,if,alias,or,index,null,alias,or,index,is,alias,alias,or,index,alias,alias,alias,or,index,alias,alias,or,index,for,tuple,string,alias,meta,data,item,alias,get,concrete,index,and,alias,meta,datas,string,concrete,index,item,v1,alias,meta,data,alias,meta,data,item,v2,if,norouting,contains,concrete,index,if,alias,meta,data,search,routing,values,is,empty,if,routings,null,routings,new,hash,map,set,string,r,routings,get,concrete,index,if,r,null,r,new,hash,set,routings,put,concrete,index,r,r,add,all,alias,meta,data,search,routing,values,if,param,routing,null,r,retain,all,param,routing,if,r,is,empty,routings,remove,concrete,index,else,if,norouting,contains,concrete,index,norouting,add,concrete,index,if,param,routing,null,set,string,r,new,hash,set,param,routing,if,routings,null,routings,new,hash,map,routings,put,concrete,index,r,else,if,routings,null,routings,remove,concrete,index,else,if,norouting,contains,expression,norouting,add,expression,if,param,routing,null,set,string,r,new,hash,set,param,routing,if,routings,null,routings,new,hash,map,routings,put,expression,r,else,if,routings,null,routings,remove,expression,if,routings,null,routings,is,empty,return,null,return,routings
IndexNameExpressionResolver -> public Map<String, Set<String>> resolveSearchRoutingAllIndices(MetaData metaData, String routing);1524684173;Sets the same routing for all indices;public Map<String, Set<String>> resolveSearchRoutingAllIndices(MetaData metaData, String routing) {_        if (routing != null) {_            Set<String> r = Sets.newHashSet(Strings.splitStringByCommaToArray(routing))__            Map<String, Set<String>> routings = new HashMap<>()__            String[] concreteIndices = metaData.getConcreteAllIndices()__            for (String index : concreteIndices) {_                routings.put(index, r)__            }_            return routings__        }_        return null__    };sets,the,same,routing,for,all,indices;public,map,string,set,string,resolve,search,routing,all,indices,meta,data,meta,data,string,routing,if,routing,null,set,string,r,sets,new,hash,set,strings,split,string,by,comma,to,array,routing,map,string,set,string,routings,new,hash,map,string,concrete,indices,meta,data,get,concrete,all,indices,for,string,index,concrete,indices,routings,put,index,r,return,routings,return,null
IndexNameExpressionResolver -> public Map<String, Set<String>> resolveSearchRoutingAllIndices(MetaData metaData, String routing);1525334055;Sets the same routing for all indices;public Map<String, Set<String>> resolveSearchRoutingAllIndices(MetaData metaData, String routing) {_        if (routing != null) {_            Set<String> r = Sets.newHashSet(Strings.splitStringByCommaToArray(routing))__            Map<String, Set<String>> routings = new HashMap<>()__            String[] concreteIndices = metaData.getConcreteAllIndices()__            for (String index : concreteIndices) {_                routings.put(index, r)__            }_            return routings__        }_        return null__    };sets,the,same,routing,for,all,indices;public,map,string,set,string,resolve,search,routing,all,indices,meta,data,meta,data,string,routing,if,routing,null,set,string,r,sets,new,hash,set,strings,split,string,by,comma,to,array,routing,map,string,set,string,routings,new,hash,map,string,concrete,indices,meta,data,get,concrete,all,indices,for,string,index,concrete,indices,routings,put,index,r,return,routings,return,null
IndexNameExpressionResolver -> public Map<String, Set<String>> resolveSearchRoutingAllIndices(MetaData metaData, String routing);1532028790;Sets the same routing for all indices;public Map<String, Set<String>> resolveSearchRoutingAllIndices(MetaData metaData, String routing) {_        if (routing != null) {_            Set<String> r = Sets.newHashSet(Strings.splitStringByCommaToArray(routing))__            Map<String, Set<String>> routings = new HashMap<>()__            String[] concreteIndices = metaData.getConcreteAllIndices()__            for (String index : concreteIndices) {_                routings.put(index, r)__            }_            return routings__        }_        return null__    };sets,the,same,routing,for,all,indices;public,map,string,set,string,resolve,search,routing,all,indices,meta,data,meta,data,string,routing,if,routing,null,set,string,r,sets,new,hash,set,strings,split,string,by,comma,to,array,routing,map,string,set,string,routings,new,hash,map,string,concrete,indices,meta,data,get,concrete,all,indices,for,string,index,concrete,indices,routings,put,index,r,return,routings,return,null
IndexNameExpressionResolver -> public Map<String, Set<String>> resolveSearchRoutingAllIndices(MetaData metaData, String routing);1538067637;Sets the same routing for all indices;public Map<String, Set<String>> resolveSearchRoutingAllIndices(MetaData metaData, String routing) {_        if (routing != null) {_            Set<String> r = Sets.newHashSet(Strings.splitStringByCommaToArray(routing))__            Map<String, Set<String>> routings = new HashMap<>()__            String[] concreteIndices = metaData.getConcreteAllIndices()__            for (String index : concreteIndices) {_                routings.put(index, r)__            }_            return routings__        }_        return null__    };sets,the,same,routing,for,all,indices;public,map,string,set,string,resolve,search,routing,all,indices,meta,data,meta,data,string,routing,if,routing,null,set,string,r,sets,new,hash,set,strings,split,string,by,comma,to,array,routing,map,string,set,string,routings,new,hash,map,string,concrete,indices,meta,data,get,concrete,all,indices,for,string,index,concrete,indices,routings,put,index,r,return,routings,return,null
IndexNameExpressionResolver -> public Map<String, Set<String>> resolveSearchRoutingAllIndices(MetaData metaData, String routing);1539615817;Sets the same routing for all indices;public Map<String, Set<String>> resolveSearchRoutingAllIndices(MetaData metaData, String routing) {_        if (routing != null) {_            Set<String> r = Sets.newHashSet(Strings.splitStringByCommaToArray(routing))__            Map<String, Set<String>> routings = new HashMap<>()__            String[] concreteIndices = metaData.getConcreteAllIndices()__            for (String index : concreteIndices) {_                routings.put(index, r)__            }_            return routings__        }_        return null__    };sets,the,same,routing,for,all,indices;public,map,string,set,string,resolve,search,routing,all,indices,meta,data,meta,data,string,routing,if,routing,null,set,string,r,sets,new,hash,set,strings,split,string,by,comma,to,array,routing,map,string,set,string,routings,new,hash,map,string,concrete,indices,meta,data,get,concrete,all,indices,for,string,index,concrete,indices,routings,put,index,r,return,routings,return,null
IndexNameExpressionResolver -> public Map<String, Set<String>> resolveSearchRoutingAllIndices(MetaData metaData, String routing);1540313026;Sets the same routing for all indices;public Map<String, Set<String>> resolveSearchRoutingAllIndices(MetaData metaData, String routing) {_        if (routing != null) {_            Set<String> r = Sets.newHashSet(Strings.splitStringByCommaToArray(routing))__            Map<String, Set<String>> routings = new HashMap<>()__            String[] concreteIndices = metaData.getConcreteAllIndices()__            for (String index : concreteIndices) {_                routings.put(index, r)__            }_            return routings__        }_        return null__    };sets,the,same,routing,for,all,indices;public,map,string,set,string,resolve,search,routing,all,indices,meta,data,meta,data,string,routing,if,routing,null,set,string,r,sets,new,hash,set,strings,split,string,by,comma,to,array,routing,map,string,set,string,routings,new,hash,map,string,concrete,indices,meta,data,get,concrete,all,indices,for,string,index,concrete,indices,routings,put,index,r,return,routings,return,null
IndexNameExpressionResolver -> public Map<String, Set<String>> resolveSearchRoutingAllIndices(MetaData metaData, String routing);1540847035;Sets the same routing for all indices;public Map<String, Set<String>> resolveSearchRoutingAllIndices(MetaData metaData, String routing) {_        if (routing != null) {_            Set<String> r = Sets.newHashSet(Strings.splitStringByCommaToArray(routing))__            Map<String, Set<String>> routings = new HashMap<>()__            String[] concreteIndices = metaData.getConcreteAllIndices()__            for (String index : concreteIndices) {_                routings.put(index, r)__            }_            return routings__        }_        return null__    };sets,the,same,routing,for,all,indices;public,map,string,set,string,resolve,search,routing,all,indices,meta,data,meta,data,string,routing,if,routing,null,set,string,r,sets,new,hash,set,strings,split,string,by,comma,to,array,routing,map,string,set,string,routings,new,hash,map,string,concrete,indices,meta,data,get,concrete,all,indices,for,string,index,concrete,indices,routings,put,index,r,return,routings,return,null
IndexNameExpressionResolver -> public Map<String, Set<String>> resolveSearchRoutingAllIndices(MetaData metaData, String routing);1541092382;Sets the same routing for all indices;public Map<String, Set<String>> resolveSearchRoutingAllIndices(MetaData metaData, String routing) {_        if (routing != null) {_            Set<String> r = Sets.newHashSet(Strings.splitStringByCommaToArray(routing))__            Map<String, Set<String>> routings = new HashMap<>()__            String[] concreteIndices = metaData.getConcreteAllIndices()__            for (String index : concreteIndices) {_                routings.put(index, r)__            }_            return routings__        }_        return null__    };sets,the,same,routing,for,all,indices;public,map,string,set,string,resolve,search,routing,all,indices,meta,data,meta,data,string,routing,if,routing,null,set,string,r,sets,new,hash,set,strings,split,string,by,comma,to,array,routing,map,string,set,string,routings,new,hash,map,string,concrete,indices,meta,data,get,concrete,all,indices,for,string,index,concrete,indices,routings,put,index,r,return,routings,return,null
IndexNameExpressionResolver -> public Map<String, Set<String>> resolveSearchRoutingAllIndices(MetaData metaData, String routing);1541493930;Sets the same routing for all indices;public Map<String, Set<String>> resolveSearchRoutingAllIndices(MetaData metaData, String routing) {_        if (routing != null) {_            Set<String> r = Sets.newHashSet(Strings.splitStringByCommaToArray(routing))__            Map<String, Set<String>> routings = new HashMap<>()__            String[] concreteIndices = metaData.getConcreteAllIndices()__            for (String index : concreteIndices) {_                routings.put(index, r)__            }_            return routings__        }_        return null__    };sets,the,same,routing,for,all,indices;public,map,string,set,string,resolve,search,routing,all,indices,meta,data,meta,data,string,routing,if,routing,null,set,string,r,sets,new,hash,set,strings,split,string,by,comma,to,array,routing,map,string,set,string,routings,new,hash,map,string,concrete,indices,meta,data,get,concrete,all,indices,for,string,index,concrete,indices,routings,put,index,r,return,routings,return,null
IndexNameExpressionResolver -> public Map<String, Set<String>> resolveSearchRoutingAllIndices(MetaData metaData, String routing);1541612607;Sets the same routing for all indices;public Map<String, Set<String>> resolveSearchRoutingAllIndices(MetaData metaData, String routing) {_        if (routing != null) {_            Set<String> r = Sets.newHashSet(Strings.splitStringByCommaToArray(routing))__            Map<String, Set<String>> routings = new HashMap<>()__            String[] concreteIndices = metaData.getConcreteAllIndices()__            for (String index : concreteIndices) {_                routings.put(index, r)__            }_            return routings__        }_        return null__    };sets,the,same,routing,for,all,indices;public,map,string,set,string,resolve,search,routing,all,indices,meta,data,meta,data,string,routing,if,routing,null,set,string,r,sets,new,hash,set,strings,split,string,by,comma,to,array,routing,map,string,set,string,routings,new,hash,map,string,concrete,indices,meta,data,get,concrete,all,indices,for,string,index,concrete,indices,routings,put,index,r,return,routings,return,null
IndexNameExpressionResolver -> public Map<String, Set<String>> resolveSearchRoutingAllIndices(MetaData metaData, String routing);1544215214;Sets the same routing for all indices;public Map<String, Set<String>> resolveSearchRoutingAllIndices(MetaData metaData, String routing) {_        if (routing != null) {_            Set<String> r = Sets.newHashSet(Strings.splitStringByCommaToArray(routing))__            Map<String, Set<String>> routings = new HashMap<>()__            String[] concreteIndices = metaData.getConcreteAllIndices()__            for (String index : concreteIndices) {_                routings.put(index, r)__            }_            return routings__        }_        return null__    };sets,the,same,routing,for,all,indices;public,map,string,set,string,resolve,search,routing,all,indices,meta,data,meta,data,string,routing,if,routing,null,set,string,r,sets,new,hash,set,strings,split,string,by,comma,to,array,routing,map,string,set,string,routings,new,hash,map,string,concrete,indices,meta,data,get,concrete,all,indices,for,string,index,concrete,indices,routings,put,index,r,return,routings,return,null
IndexNameExpressionResolver -> public Map<String, Set<String>> resolveSearchRoutingAllIndices(MetaData metaData, String routing);1548236405;Sets the same routing for all indices;public Map<String, Set<String>> resolveSearchRoutingAllIndices(MetaData metaData, String routing) {_        if (routing != null) {_            Set<String> r = Sets.newHashSet(Strings.splitStringByCommaToArray(routing))__            Map<String, Set<String>> routings = new HashMap<>()__            String[] concreteIndices = metaData.getConcreteAllIndices()__            for (String index : concreteIndices) {_                routings.put(index, r)__            }_            return routings__        }_        return null__    };sets,the,same,routing,for,all,indices;public,map,string,set,string,resolve,search,routing,all,indices,meta,data,meta,data,string,routing,if,routing,null,set,string,r,sets,new,hash,set,strings,split,string,by,comma,to,array,routing,map,string,set,string,routings,new,hash,map,string,concrete,indices,meta,data,get,concrete,all,indices,for,string,index,concrete,indices,routings,put,index,r,return,routings,return,null
IndexNameExpressionResolver -> public static boolean isAllIndices(List<String> aliasesOrIndices);1524684173;Identifies whether the array containing index names given as argument refers to all indices_The empty or null array identifies all indices__@param aliasesOrIndices the array containing index names_@return true if the provided array maps to all indices, false otherwise;public static boolean isAllIndices(List<String> aliasesOrIndices) {_        return aliasesOrIndices == null || aliasesOrIndices.isEmpty() || isExplicitAllPattern(aliasesOrIndices)__    };identifies,whether,the,array,containing,index,names,given,as,argument,refers,to,all,indices,the,empty,or,null,array,identifies,all,indices,param,aliases,or,indices,the,array,containing,index,names,return,true,if,the,provided,array,maps,to,all,indices,false,otherwise;public,static,boolean,is,all,indices,list,string,aliases,or,indices,return,aliases,or,indices,null,aliases,or,indices,is,empty,is,explicit,all,pattern,aliases,or,indices
IndexNameExpressionResolver -> public static boolean isAllIndices(List<String> aliasesOrIndices);1525334055;Identifies whether the array containing index names given as argument refers to all indices_The empty or null array identifies all indices__@param aliasesOrIndices the array containing index names_@return true if the provided array maps to all indices, false otherwise;public static boolean isAllIndices(List<String> aliasesOrIndices) {_        return aliasesOrIndices == null || aliasesOrIndices.isEmpty() || isExplicitAllPattern(aliasesOrIndices)__    };identifies,whether,the,array,containing,index,names,given,as,argument,refers,to,all,indices,the,empty,or,null,array,identifies,all,indices,param,aliases,or,indices,the,array,containing,index,names,return,true,if,the,provided,array,maps,to,all,indices,false,otherwise;public,static,boolean,is,all,indices,list,string,aliases,or,indices,return,aliases,or,indices,null,aliases,or,indices,is,empty,is,explicit,all,pattern,aliases,or,indices
IndexNameExpressionResolver -> public static boolean isAllIndices(List<String> aliasesOrIndices);1532028790;Identifies whether the array containing index names given as argument refers to all indices_The empty or null array identifies all indices__@param aliasesOrIndices the array containing index names_@return true if the provided array maps to all indices, false otherwise;public static boolean isAllIndices(List<String> aliasesOrIndices) {_        return aliasesOrIndices == null || aliasesOrIndices.isEmpty() || isExplicitAllPattern(aliasesOrIndices)__    };identifies,whether,the,array,containing,index,names,given,as,argument,refers,to,all,indices,the,empty,or,null,array,identifies,all,indices,param,aliases,or,indices,the,array,containing,index,names,return,true,if,the,provided,array,maps,to,all,indices,false,otherwise;public,static,boolean,is,all,indices,list,string,aliases,or,indices,return,aliases,or,indices,null,aliases,or,indices,is,empty,is,explicit,all,pattern,aliases,or,indices
IndexNameExpressionResolver -> public static boolean isAllIndices(List<String> aliasesOrIndices);1538067637;Identifies whether the array containing index names given as argument refers to all indices_The empty or null array identifies all indices__@param aliasesOrIndices the array containing index names_@return true if the provided array maps to all indices, false otherwise;public static boolean isAllIndices(List<String> aliasesOrIndices) {_        return aliasesOrIndices == null || aliasesOrIndices.isEmpty() || isExplicitAllPattern(aliasesOrIndices)__    };identifies,whether,the,array,containing,index,names,given,as,argument,refers,to,all,indices,the,empty,or,null,array,identifies,all,indices,param,aliases,or,indices,the,array,containing,index,names,return,true,if,the,provided,array,maps,to,all,indices,false,otherwise;public,static,boolean,is,all,indices,list,string,aliases,or,indices,return,aliases,or,indices,null,aliases,or,indices,is,empty,is,explicit,all,pattern,aliases,or,indices
IndexNameExpressionResolver -> public static boolean isAllIndices(List<String> aliasesOrIndices);1539615817;Identifies whether the array containing index names given as argument refers to all indices_The empty or null array identifies all indices__@param aliasesOrIndices the array containing index names_@return true if the provided array maps to all indices, false otherwise;public static boolean isAllIndices(List<String> aliasesOrIndices) {_        return aliasesOrIndices == null || aliasesOrIndices.isEmpty() || isExplicitAllPattern(aliasesOrIndices)__    };identifies,whether,the,array,containing,index,names,given,as,argument,refers,to,all,indices,the,empty,or,null,array,identifies,all,indices,param,aliases,or,indices,the,array,containing,index,names,return,true,if,the,provided,array,maps,to,all,indices,false,otherwise;public,static,boolean,is,all,indices,list,string,aliases,or,indices,return,aliases,or,indices,null,aliases,or,indices,is,empty,is,explicit,all,pattern,aliases,or,indices
IndexNameExpressionResolver -> public static boolean isAllIndices(List<String> aliasesOrIndices);1540313026;Identifies whether the array containing index names given as argument refers to all indices_The empty or null array identifies all indices__@param aliasesOrIndices the array containing index names_@return true if the provided array maps to all indices, false otherwise;public static boolean isAllIndices(List<String> aliasesOrIndices) {_        return aliasesOrIndices == null || aliasesOrIndices.isEmpty() || isExplicitAllPattern(aliasesOrIndices)__    };identifies,whether,the,array,containing,index,names,given,as,argument,refers,to,all,indices,the,empty,or,null,array,identifies,all,indices,param,aliases,or,indices,the,array,containing,index,names,return,true,if,the,provided,array,maps,to,all,indices,false,otherwise;public,static,boolean,is,all,indices,list,string,aliases,or,indices,return,aliases,or,indices,null,aliases,or,indices,is,empty,is,explicit,all,pattern,aliases,or,indices
IndexNameExpressionResolver -> public static boolean isAllIndices(List<String> aliasesOrIndices);1540847035;Identifies whether the array containing index names given as argument refers to all indices_The empty or null array identifies all indices__@param aliasesOrIndices the array containing index names_@return true if the provided array maps to all indices, false otherwise;public static boolean isAllIndices(List<String> aliasesOrIndices) {_        return aliasesOrIndices == null || aliasesOrIndices.isEmpty() || isExplicitAllPattern(aliasesOrIndices)__    };identifies,whether,the,array,containing,index,names,given,as,argument,refers,to,all,indices,the,empty,or,null,array,identifies,all,indices,param,aliases,or,indices,the,array,containing,index,names,return,true,if,the,provided,array,maps,to,all,indices,false,otherwise;public,static,boolean,is,all,indices,list,string,aliases,or,indices,return,aliases,or,indices,null,aliases,or,indices,is,empty,is,explicit,all,pattern,aliases,or,indices
IndexNameExpressionResolver -> public static boolean isAllIndices(List<String> aliasesOrIndices);1541092382;Identifies whether the array containing index names given as argument refers to all indices_The empty or null array identifies all indices__@param aliasesOrIndices the array containing index names_@return true if the provided array maps to all indices, false otherwise;public static boolean isAllIndices(List<String> aliasesOrIndices) {_        return aliasesOrIndices == null || aliasesOrIndices.isEmpty() || isExplicitAllPattern(aliasesOrIndices)__    };identifies,whether,the,array,containing,index,names,given,as,argument,refers,to,all,indices,the,empty,or,null,array,identifies,all,indices,param,aliases,or,indices,the,array,containing,index,names,return,true,if,the,provided,array,maps,to,all,indices,false,otherwise;public,static,boolean,is,all,indices,list,string,aliases,or,indices,return,aliases,or,indices,null,aliases,or,indices,is,empty,is,explicit,all,pattern,aliases,or,indices
IndexNameExpressionResolver -> public static boolean isAllIndices(List<String> aliasesOrIndices);1541493930;Identifies whether the array containing index names given as argument refers to all indices_The empty or null array identifies all indices__@param aliasesOrIndices the array containing index names_@return true if the provided array maps to all indices, false otherwise;public static boolean isAllIndices(List<String> aliasesOrIndices) {_        return aliasesOrIndices == null || aliasesOrIndices.isEmpty() || isExplicitAllPattern(aliasesOrIndices)__    };identifies,whether,the,array,containing,index,names,given,as,argument,refers,to,all,indices,the,empty,or,null,array,identifies,all,indices,param,aliases,or,indices,the,array,containing,index,names,return,true,if,the,provided,array,maps,to,all,indices,false,otherwise;public,static,boolean,is,all,indices,list,string,aliases,or,indices,return,aliases,or,indices,null,aliases,or,indices,is,empty,is,explicit,all,pattern,aliases,or,indices
IndexNameExpressionResolver -> public static boolean isAllIndices(List<String> aliasesOrIndices);1541612607;Identifies whether the array containing index names given as argument refers to all indices_The empty or null array identifies all indices__@param aliasesOrIndices the array containing index names_@return true if the provided array maps to all indices, false otherwise;public static boolean isAllIndices(List<String> aliasesOrIndices) {_        return aliasesOrIndices == null || aliasesOrIndices.isEmpty() || isExplicitAllPattern(aliasesOrIndices)__    };identifies,whether,the,array,containing,index,names,given,as,argument,refers,to,all,indices,the,empty,or,null,array,identifies,all,indices,param,aliases,or,indices,the,array,containing,index,names,return,true,if,the,provided,array,maps,to,all,indices,false,otherwise;public,static,boolean,is,all,indices,list,string,aliases,or,indices,return,aliases,or,indices,null,aliases,or,indices,is,empty,is,explicit,all,pattern,aliases,or,indices
IndexNameExpressionResolver -> public static boolean isAllIndices(List<String> aliasesOrIndices);1544215214;Identifies whether the array containing index names given as argument refers to all indices_The empty or null array identifies all indices__@param aliasesOrIndices the array containing index names_@return true if the provided array maps to all indices, false otherwise;public static boolean isAllIndices(List<String> aliasesOrIndices) {_        return aliasesOrIndices == null || aliasesOrIndices.isEmpty() || isExplicitAllPattern(aliasesOrIndices)__    };identifies,whether,the,array,containing,index,names,given,as,argument,refers,to,all,indices,the,empty,or,null,array,identifies,all,indices,param,aliases,or,indices,the,array,containing,index,names,return,true,if,the,provided,array,maps,to,all,indices,false,otherwise;public,static,boolean,is,all,indices,list,string,aliases,or,indices,return,aliases,or,indices,null,aliases,or,indices,is,empty,is,explicit,all,pattern,aliases,or,indices
IndexNameExpressionResolver -> public static boolean isAllIndices(List<String> aliasesOrIndices);1548236405;Identifies whether the array containing index names given as argument refers to all indices_The empty or null array identifies all indices__@param aliasesOrIndices the array containing index names_@return true if the provided array maps to all indices, false otherwise;public static boolean isAllIndices(List<String> aliasesOrIndices) {_        return aliasesOrIndices == null || aliasesOrIndices.isEmpty() || isExplicitAllPattern(aliasesOrIndices)__    };identifies,whether,the,array,containing,index,names,given,as,argument,refers,to,all,indices,the,empty,or,null,array,identifies,all,indices,param,aliases,or,indices,the,array,containing,index,names,return,true,if,the,provided,array,maps,to,all,indices,false,otherwise;public,static,boolean,is,all,indices,list,string,aliases,or,indices,return,aliases,or,indices,null,aliases,or,indices,is,empty,is,explicit,all,pattern,aliases,or,indices
IndexNameExpressionResolver -> public Index concreteSingleIndex(ClusterState state, IndicesRequest request);1524684173;Utility method that allows to resolve an index expression to its corresponding single concrete index._Callers should make sure they provide proper {@link org.elasticsearch.action.support.IndicesOptions}_that require a single index as a result. The indices resolution must in fact return a single index when_using this method, an {@link IllegalArgumentException} gets thrown otherwise.__@param state             the cluster state containing all the data to resolve to expression to a concrete index_@param request           The request that defines how the an alias or an index need to be resolved to a concrete index_and the expression that can be resolved to an alias or an index name._@throws IllegalArgumentException if the index resolution lead to more than one index_@return the concrete index obtained as a result of the index resolution;public Index concreteSingleIndex(ClusterState state, IndicesRequest request) {_        String indexExpression = request.indices() != null && request.indices().length > 0 ? request.indices()[0] : null__        Index[] indices = concreteIndices(state, request.indicesOptions(), indexExpression)__        if (indices.length != 1) {_            throw new IllegalArgumentException("unable to return a single index as the index and options provided got resolved to multiple indices")__        }_        return indices[0]__    };utility,method,that,allows,to,resolve,an,index,expression,to,its,corresponding,single,concrete,index,callers,should,make,sure,they,provide,proper,link,org,elasticsearch,action,support,indices,options,that,require,a,single,index,as,a,result,the,indices,resolution,must,in,fact,return,a,single,index,when,using,this,method,an,link,illegal,argument,exception,gets,thrown,otherwise,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expression,to,a,concrete,index,param,request,the,request,that,defines,how,the,an,alias,or,an,index,need,to,be,resolved,to,a,concrete,index,and,the,expression,that,can,be,resolved,to,an,alias,or,an,index,name,throws,illegal,argument,exception,if,the,index,resolution,lead,to,more,than,one,index,return,the,concrete,index,obtained,as,a,result,of,the,index,resolution;public,index,concrete,single,index,cluster,state,state,indices,request,request,string,index,expression,request,indices,null,request,indices,length,0,request,indices,0,null,index,indices,concrete,indices,state,request,indices,options,index,expression,if,indices,length,1,throw,new,illegal,argument,exception,unable,to,return,a,single,index,as,the,index,and,options,provided,got,resolved,to,multiple,indices,return,indices,0
IndexNameExpressionResolver -> public Index concreteSingleIndex(ClusterState state, IndicesRequest request);1525334055;Utility method that allows to resolve an index expression to its corresponding single concrete index._Callers should make sure they provide proper {@link org.elasticsearch.action.support.IndicesOptions}_that require a single index as a result. The indices resolution must in fact return a single index when_using this method, an {@link IllegalArgumentException} gets thrown otherwise.__@param state             the cluster state containing all the data to resolve to expression to a concrete index_@param request           The request that defines how the an alias or an index need to be resolved to a concrete index_and the expression that can be resolved to an alias or an index name._@throws IllegalArgumentException if the index resolution lead to more than one index_@return the concrete index obtained as a result of the index resolution;public Index concreteSingleIndex(ClusterState state, IndicesRequest request) {_        String indexExpression = request.indices() != null && request.indices().length > 0 ? request.indices()[0] : null__        Index[] indices = concreteIndices(state, request.indicesOptions(), indexExpression)__        if (indices.length != 1) {_            throw new IllegalArgumentException("unable to return a single index as the index and options provided got resolved to multiple indices")__        }_        return indices[0]__    };utility,method,that,allows,to,resolve,an,index,expression,to,its,corresponding,single,concrete,index,callers,should,make,sure,they,provide,proper,link,org,elasticsearch,action,support,indices,options,that,require,a,single,index,as,a,result,the,indices,resolution,must,in,fact,return,a,single,index,when,using,this,method,an,link,illegal,argument,exception,gets,thrown,otherwise,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expression,to,a,concrete,index,param,request,the,request,that,defines,how,the,an,alias,or,an,index,need,to,be,resolved,to,a,concrete,index,and,the,expression,that,can,be,resolved,to,an,alias,or,an,index,name,throws,illegal,argument,exception,if,the,index,resolution,lead,to,more,than,one,index,return,the,concrete,index,obtained,as,a,result,of,the,index,resolution;public,index,concrete,single,index,cluster,state,state,indices,request,request,string,index,expression,request,indices,null,request,indices,length,0,request,indices,0,null,index,indices,concrete,indices,state,request,indices,options,index,expression,if,indices,length,1,throw,new,illegal,argument,exception,unable,to,return,a,single,index,as,the,index,and,options,provided,got,resolved,to,multiple,indices,return,indices,0
IndexNameExpressionResolver -> public Index concreteSingleIndex(ClusterState state, IndicesRequest request);1532028790;Utility method that allows to resolve an index expression to its corresponding single concrete index._Callers should make sure they provide proper {@link org.elasticsearch.action.support.IndicesOptions}_that require a single index as a result. The indices resolution must in fact return a single index when_using this method, an {@link IllegalArgumentException} gets thrown otherwise.__@param state             the cluster state containing all the data to resolve to expression to a concrete index_@param request           The request that defines how the an alias or an index need to be resolved to a concrete index_and the expression that can be resolved to an alias or an index name._@throws IllegalArgumentException if the index resolution lead to more than one index_@return the concrete index obtained as a result of the index resolution;public Index concreteSingleIndex(ClusterState state, IndicesRequest request) {_        String indexExpression = request.indices() != null && request.indices().length > 0 ? request.indices()[0] : null__        Index[] indices = concreteIndices(state, request.indicesOptions(), indexExpression)__        if (indices.length != 1) {_            throw new IllegalArgumentException("unable to return a single index as the index and options provided got resolved to multiple indices")__        }_        return indices[0]__    };utility,method,that,allows,to,resolve,an,index,expression,to,its,corresponding,single,concrete,index,callers,should,make,sure,they,provide,proper,link,org,elasticsearch,action,support,indices,options,that,require,a,single,index,as,a,result,the,indices,resolution,must,in,fact,return,a,single,index,when,using,this,method,an,link,illegal,argument,exception,gets,thrown,otherwise,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expression,to,a,concrete,index,param,request,the,request,that,defines,how,the,an,alias,or,an,index,need,to,be,resolved,to,a,concrete,index,and,the,expression,that,can,be,resolved,to,an,alias,or,an,index,name,throws,illegal,argument,exception,if,the,index,resolution,lead,to,more,than,one,index,return,the,concrete,index,obtained,as,a,result,of,the,index,resolution;public,index,concrete,single,index,cluster,state,state,indices,request,request,string,index,expression,request,indices,null,request,indices,length,0,request,indices,0,null,index,indices,concrete,indices,state,request,indices,options,index,expression,if,indices,length,1,throw,new,illegal,argument,exception,unable,to,return,a,single,index,as,the,index,and,options,provided,got,resolved,to,multiple,indices,return,indices,0
IndexNameExpressionResolver -> public Index concreteSingleIndex(ClusterState state, IndicesRequest request);1538067637;Utility method that allows to resolve an index expression to its corresponding single concrete index._Callers should make sure they provide proper {@link org.elasticsearch.action.support.IndicesOptions}_that require a single index as a result. The indices resolution must in fact return a single index when_using this method, an {@link IllegalArgumentException} gets thrown otherwise.__@param state             the cluster state containing all the data to resolve to expression to a concrete index_@param request           The request that defines how the an alias or an index need to be resolved to a concrete index_and the expression that can be resolved to an alias or an index name._@throws IllegalArgumentException if the index resolution lead to more than one index_@return the concrete index obtained as a result of the index resolution;public Index concreteSingleIndex(ClusterState state, IndicesRequest request) {_        String indexExpression = request.indices() != null && request.indices().length > 0 ? request.indices()[0] : null__        Index[] indices = concreteIndices(state, request.indicesOptions(), indexExpression)__        if (indices.length != 1) {_            throw new IllegalArgumentException("unable to return a single index as the index and options provided got resolved to multiple indices")__        }_        return indices[0]__    };utility,method,that,allows,to,resolve,an,index,expression,to,its,corresponding,single,concrete,index,callers,should,make,sure,they,provide,proper,link,org,elasticsearch,action,support,indices,options,that,require,a,single,index,as,a,result,the,indices,resolution,must,in,fact,return,a,single,index,when,using,this,method,an,link,illegal,argument,exception,gets,thrown,otherwise,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expression,to,a,concrete,index,param,request,the,request,that,defines,how,the,an,alias,or,an,index,need,to,be,resolved,to,a,concrete,index,and,the,expression,that,can,be,resolved,to,an,alias,or,an,index,name,throws,illegal,argument,exception,if,the,index,resolution,lead,to,more,than,one,index,return,the,concrete,index,obtained,as,a,result,of,the,index,resolution;public,index,concrete,single,index,cluster,state,state,indices,request,request,string,index,expression,request,indices,null,request,indices,length,0,request,indices,0,null,index,indices,concrete,indices,state,request,indices,options,index,expression,if,indices,length,1,throw,new,illegal,argument,exception,unable,to,return,a,single,index,as,the,index,and,options,provided,got,resolved,to,multiple,indices,return,indices,0
IndexNameExpressionResolver -> public Index concreteSingleIndex(ClusterState state, IndicesRequest request);1539615817;Utility method that allows to resolve an index expression to its corresponding single concrete index._Callers should make sure they provide proper {@link org.elasticsearch.action.support.IndicesOptions}_that require a single index as a result. The indices resolution must in fact return a single index when_using this method, an {@link IllegalArgumentException} gets thrown otherwise.__@param state             the cluster state containing all the data to resolve to expression to a concrete index_@param request           The request that defines how the an alias or an index need to be resolved to a concrete index_and the expression that can be resolved to an alias or an index name._@throws IllegalArgumentException if the index resolution lead to more than one index_@return the concrete index obtained as a result of the index resolution;public Index concreteSingleIndex(ClusterState state, IndicesRequest request) {_        String indexExpression = request.indices() != null && request.indices().length > 0 ? request.indices()[0] : null__        Index[] indices = concreteIndices(state, request.indicesOptions(), indexExpression)__        if (indices.length != 1) {_            throw new IllegalArgumentException("unable to return a single index as the index and options provided got resolved to multiple indices")__        }_        return indices[0]__    };utility,method,that,allows,to,resolve,an,index,expression,to,its,corresponding,single,concrete,index,callers,should,make,sure,they,provide,proper,link,org,elasticsearch,action,support,indices,options,that,require,a,single,index,as,a,result,the,indices,resolution,must,in,fact,return,a,single,index,when,using,this,method,an,link,illegal,argument,exception,gets,thrown,otherwise,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expression,to,a,concrete,index,param,request,the,request,that,defines,how,the,an,alias,or,an,index,need,to,be,resolved,to,a,concrete,index,and,the,expression,that,can,be,resolved,to,an,alias,or,an,index,name,throws,illegal,argument,exception,if,the,index,resolution,lead,to,more,than,one,index,return,the,concrete,index,obtained,as,a,result,of,the,index,resolution;public,index,concrete,single,index,cluster,state,state,indices,request,request,string,index,expression,request,indices,null,request,indices,length,0,request,indices,0,null,index,indices,concrete,indices,state,request,indices,options,index,expression,if,indices,length,1,throw,new,illegal,argument,exception,unable,to,return,a,single,index,as,the,index,and,options,provided,got,resolved,to,multiple,indices,return,indices,0
IndexNameExpressionResolver -> public Index concreteSingleIndex(ClusterState state, IndicesRequest request);1540313026;Utility method that allows to resolve an index expression to its corresponding single concrete index._Callers should make sure they provide proper {@link org.elasticsearch.action.support.IndicesOptions}_that require a single index as a result. The indices resolution must in fact return a single index when_using this method, an {@link IllegalArgumentException} gets thrown otherwise.__@param state             the cluster state containing all the data to resolve to expression to a concrete index_@param request           The request that defines how the an alias or an index need to be resolved to a concrete index_and the expression that can be resolved to an alias or an index name._@throws IllegalArgumentException if the index resolution lead to more than one index_@return the concrete index obtained as a result of the index resolution;public Index concreteSingleIndex(ClusterState state, IndicesRequest request) {_        String indexExpression = request.indices() != null && request.indices().length > 0 ? request.indices()[0] : null__        Index[] indices = concreteIndices(state, request.indicesOptions(), indexExpression)__        if (indices.length != 1) {_            throw new IllegalArgumentException("unable to return a single index as the index and options provided got resolved to multiple indices")__        }_        return indices[0]__    };utility,method,that,allows,to,resolve,an,index,expression,to,its,corresponding,single,concrete,index,callers,should,make,sure,they,provide,proper,link,org,elasticsearch,action,support,indices,options,that,require,a,single,index,as,a,result,the,indices,resolution,must,in,fact,return,a,single,index,when,using,this,method,an,link,illegal,argument,exception,gets,thrown,otherwise,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expression,to,a,concrete,index,param,request,the,request,that,defines,how,the,an,alias,or,an,index,need,to,be,resolved,to,a,concrete,index,and,the,expression,that,can,be,resolved,to,an,alias,or,an,index,name,throws,illegal,argument,exception,if,the,index,resolution,lead,to,more,than,one,index,return,the,concrete,index,obtained,as,a,result,of,the,index,resolution;public,index,concrete,single,index,cluster,state,state,indices,request,request,string,index,expression,request,indices,null,request,indices,length,0,request,indices,0,null,index,indices,concrete,indices,state,request,indices,options,index,expression,if,indices,length,1,throw,new,illegal,argument,exception,unable,to,return,a,single,index,as,the,index,and,options,provided,got,resolved,to,multiple,indices,return,indices,0
IndexNameExpressionResolver -> public Index concreteSingleIndex(ClusterState state, IndicesRequest request);1540847035;Utility method that allows to resolve an index expression to its corresponding single concrete index._Callers should make sure they provide proper {@link org.elasticsearch.action.support.IndicesOptions}_that require a single index as a result. The indices resolution must in fact return a single index when_using this method, an {@link IllegalArgumentException} gets thrown otherwise.__@param state             the cluster state containing all the data to resolve to expression to a concrete index_@param request           The request that defines how the an alias or an index need to be resolved to a concrete index_and the expression that can be resolved to an alias or an index name._@throws IllegalArgumentException if the index resolution lead to more than one index_@return the concrete index obtained as a result of the index resolution;public Index concreteSingleIndex(ClusterState state, IndicesRequest request) {_        String indexExpression = request.indices() != null && request.indices().length > 0 ? request.indices()[0] : null__        Index[] indices = concreteIndices(state, request.indicesOptions(), indexExpression)__        if (indices.length != 1) {_            throw new IllegalArgumentException("unable to return a single index as the index and options" +_                " provided got resolved to multiple indices")__        }_        return indices[0]__    };utility,method,that,allows,to,resolve,an,index,expression,to,its,corresponding,single,concrete,index,callers,should,make,sure,they,provide,proper,link,org,elasticsearch,action,support,indices,options,that,require,a,single,index,as,a,result,the,indices,resolution,must,in,fact,return,a,single,index,when,using,this,method,an,link,illegal,argument,exception,gets,thrown,otherwise,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expression,to,a,concrete,index,param,request,the,request,that,defines,how,the,an,alias,or,an,index,need,to,be,resolved,to,a,concrete,index,and,the,expression,that,can,be,resolved,to,an,alias,or,an,index,name,throws,illegal,argument,exception,if,the,index,resolution,lead,to,more,than,one,index,return,the,concrete,index,obtained,as,a,result,of,the,index,resolution;public,index,concrete,single,index,cluster,state,state,indices,request,request,string,index,expression,request,indices,null,request,indices,length,0,request,indices,0,null,index,indices,concrete,indices,state,request,indices,options,index,expression,if,indices,length,1,throw,new,illegal,argument,exception,unable,to,return,a,single,index,as,the,index,and,options,provided,got,resolved,to,multiple,indices,return,indices,0
IndexNameExpressionResolver -> public Index concreteSingleIndex(ClusterState state, IndicesRequest request);1541092382;Utility method that allows to resolve an index expression to its corresponding single concrete index._Callers should make sure they provide proper {@link org.elasticsearch.action.support.IndicesOptions}_that require a single index as a result. The indices resolution must in fact return a single index when_using this method, an {@link IllegalArgumentException} gets thrown otherwise.__@param state             the cluster state containing all the data to resolve to expression to a concrete index_@param request           The request that defines how the an alias or an index need to be resolved to a concrete index_and the expression that can be resolved to an alias or an index name._@throws IllegalArgumentException if the index resolution lead to more than one index_@return the concrete index obtained as a result of the index resolution;public Index concreteSingleIndex(ClusterState state, IndicesRequest request) {_        String indexExpression = request.indices() != null && request.indices().length > 0 ? request.indices()[0] : null__        Index[] indices = concreteIndices(state, request.indicesOptions(), indexExpression)__        if (indices.length != 1) {_            throw new IllegalArgumentException("unable to return a single index as the index and options" +_                " provided got resolved to multiple indices")__        }_        return indices[0]__    };utility,method,that,allows,to,resolve,an,index,expression,to,its,corresponding,single,concrete,index,callers,should,make,sure,they,provide,proper,link,org,elasticsearch,action,support,indices,options,that,require,a,single,index,as,a,result,the,indices,resolution,must,in,fact,return,a,single,index,when,using,this,method,an,link,illegal,argument,exception,gets,thrown,otherwise,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expression,to,a,concrete,index,param,request,the,request,that,defines,how,the,an,alias,or,an,index,need,to,be,resolved,to,a,concrete,index,and,the,expression,that,can,be,resolved,to,an,alias,or,an,index,name,throws,illegal,argument,exception,if,the,index,resolution,lead,to,more,than,one,index,return,the,concrete,index,obtained,as,a,result,of,the,index,resolution;public,index,concrete,single,index,cluster,state,state,indices,request,request,string,index,expression,request,indices,null,request,indices,length,0,request,indices,0,null,index,indices,concrete,indices,state,request,indices,options,index,expression,if,indices,length,1,throw,new,illegal,argument,exception,unable,to,return,a,single,index,as,the,index,and,options,provided,got,resolved,to,multiple,indices,return,indices,0
IndexNameExpressionResolver -> public Index concreteSingleIndex(ClusterState state, IndicesRequest request);1541493930;Utility method that allows to resolve an index expression to its corresponding single concrete index._Callers should make sure they provide proper {@link org.elasticsearch.action.support.IndicesOptions}_that require a single index as a result. The indices resolution must in fact return a single index when_using this method, an {@link IllegalArgumentException} gets thrown otherwise.__@param state             the cluster state containing all the data to resolve to expression to a concrete index_@param request           The request that defines how the an alias or an index need to be resolved to a concrete index_and the expression that can be resolved to an alias or an index name._@throws IllegalArgumentException if the index resolution lead to more than one index_@return the concrete index obtained as a result of the index resolution;public Index concreteSingleIndex(ClusterState state, IndicesRequest request) {_        String indexExpression = request.indices() != null && request.indices().length > 0 ? request.indices()[0] : null__        Index[] indices = concreteIndices(state, request.indicesOptions(), indexExpression)__        if (indices.length != 1) {_            throw new IllegalArgumentException("unable to return a single index as the index and options" +_                " provided got resolved to multiple indices")__        }_        return indices[0]__    };utility,method,that,allows,to,resolve,an,index,expression,to,its,corresponding,single,concrete,index,callers,should,make,sure,they,provide,proper,link,org,elasticsearch,action,support,indices,options,that,require,a,single,index,as,a,result,the,indices,resolution,must,in,fact,return,a,single,index,when,using,this,method,an,link,illegal,argument,exception,gets,thrown,otherwise,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expression,to,a,concrete,index,param,request,the,request,that,defines,how,the,an,alias,or,an,index,need,to,be,resolved,to,a,concrete,index,and,the,expression,that,can,be,resolved,to,an,alias,or,an,index,name,throws,illegal,argument,exception,if,the,index,resolution,lead,to,more,than,one,index,return,the,concrete,index,obtained,as,a,result,of,the,index,resolution;public,index,concrete,single,index,cluster,state,state,indices,request,request,string,index,expression,request,indices,null,request,indices,length,0,request,indices,0,null,index,indices,concrete,indices,state,request,indices,options,index,expression,if,indices,length,1,throw,new,illegal,argument,exception,unable,to,return,a,single,index,as,the,index,and,options,provided,got,resolved,to,multiple,indices,return,indices,0
IndexNameExpressionResolver -> public Index concreteSingleIndex(ClusterState state, IndicesRequest request);1541612607;Utility method that allows to resolve an index expression to its corresponding single concrete index._Callers should make sure they provide proper {@link org.elasticsearch.action.support.IndicesOptions}_that require a single index as a result. The indices resolution must in fact return a single index when_using this method, an {@link IllegalArgumentException} gets thrown otherwise.__@param state             the cluster state containing all the data to resolve to expression to a concrete index_@param request           The request that defines how the an alias or an index need to be resolved to a concrete index_and the expression that can be resolved to an alias or an index name._@throws IllegalArgumentException if the index resolution lead to more than one index_@return the concrete index obtained as a result of the index resolution;public Index concreteSingleIndex(ClusterState state, IndicesRequest request) {_        String indexExpression = request.indices() != null && request.indices().length > 0 ? request.indices()[0] : null__        Index[] indices = concreteIndices(state, request.indicesOptions(), indexExpression)__        if (indices.length != 1) {_            throw new IllegalArgumentException("unable to return a single index as the index and options" +_                " provided got resolved to multiple indices")__        }_        return indices[0]__    };utility,method,that,allows,to,resolve,an,index,expression,to,its,corresponding,single,concrete,index,callers,should,make,sure,they,provide,proper,link,org,elasticsearch,action,support,indices,options,that,require,a,single,index,as,a,result,the,indices,resolution,must,in,fact,return,a,single,index,when,using,this,method,an,link,illegal,argument,exception,gets,thrown,otherwise,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expression,to,a,concrete,index,param,request,the,request,that,defines,how,the,an,alias,or,an,index,need,to,be,resolved,to,a,concrete,index,and,the,expression,that,can,be,resolved,to,an,alias,or,an,index,name,throws,illegal,argument,exception,if,the,index,resolution,lead,to,more,than,one,index,return,the,concrete,index,obtained,as,a,result,of,the,index,resolution;public,index,concrete,single,index,cluster,state,state,indices,request,request,string,index,expression,request,indices,null,request,indices,length,0,request,indices,0,null,index,indices,concrete,indices,state,request,indices,options,index,expression,if,indices,length,1,throw,new,illegal,argument,exception,unable,to,return,a,single,index,as,the,index,and,options,provided,got,resolved,to,multiple,indices,return,indices,0
IndexNameExpressionResolver -> public Index concreteSingleIndex(ClusterState state, IndicesRequest request);1544215214;Utility method that allows to resolve an index expression to its corresponding single concrete index._Callers should make sure they provide proper {@link org.elasticsearch.action.support.IndicesOptions}_that require a single index as a result. The indices resolution must in fact return a single index when_using this method, an {@link IllegalArgumentException} gets thrown otherwise.__@param state             the cluster state containing all the data to resolve to expression to a concrete index_@param request           The request that defines how the an alias or an index need to be resolved to a concrete index_and the expression that can be resolved to an alias or an index name._@throws IllegalArgumentException if the index resolution lead to more than one index_@return the concrete index obtained as a result of the index resolution;public Index concreteSingleIndex(ClusterState state, IndicesRequest request) {_        String indexExpression = request.indices() != null && request.indices().length > 0 ? request.indices()[0] : null__        Index[] indices = concreteIndices(state, request.indicesOptions(), indexExpression)__        if (indices.length != 1) {_            throw new IllegalArgumentException("unable to return a single index as the index and options" +_                " provided got resolved to multiple indices")__        }_        return indices[0]__    };utility,method,that,allows,to,resolve,an,index,expression,to,its,corresponding,single,concrete,index,callers,should,make,sure,they,provide,proper,link,org,elasticsearch,action,support,indices,options,that,require,a,single,index,as,a,result,the,indices,resolution,must,in,fact,return,a,single,index,when,using,this,method,an,link,illegal,argument,exception,gets,thrown,otherwise,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expression,to,a,concrete,index,param,request,the,request,that,defines,how,the,an,alias,or,an,index,need,to,be,resolved,to,a,concrete,index,and,the,expression,that,can,be,resolved,to,an,alias,or,an,index,name,throws,illegal,argument,exception,if,the,index,resolution,lead,to,more,than,one,index,return,the,concrete,index,obtained,as,a,result,of,the,index,resolution;public,index,concrete,single,index,cluster,state,state,indices,request,request,string,index,expression,request,indices,null,request,indices,length,0,request,indices,0,null,index,indices,concrete,indices,state,request,indices,options,index,expression,if,indices,length,1,throw,new,illegal,argument,exception,unable,to,return,a,single,index,as,the,index,and,options,provided,got,resolved,to,multiple,indices,return,indices,0
IndexNameExpressionResolver -> public Index concreteSingleIndex(ClusterState state, IndicesRequest request);1548236405;Utility method that allows to resolve an index expression to its corresponding single concrete index._Callers should make sure they provide proper {@link org.elasticsearch.action.support.IndicesOptions}_that require a single index as a result. The indices resolution must in fact return a single index when_using this method, an {@link IllegalArgumentException} gets thrown otherwise.__@param state             the cluster state containing all the data to resolve to expression to a concrete index_@param request           The request that defines how the an alias or an index need to be resolved to a concrete index_and the expression that can be resolved to an alias or an index name._@throws IllegalArgumentException if the index resolution lead to more than one index_@return the concrete index obtained as a result of the index resolution;public Index concreteSingleIndex(ClusterState state, IndicesRequest request) {_        String indexExpression = request.indices() != null && request.indices().length > 0 ? request.indices()[0] : null__        Index[] indices = concreteIndices(state, request.indicesOptions(), indexExpression)__        if (indices.length != 1) {_            throw new IllegalArgumentException("unable to return a single index as the index and options" +_                " provided got resolved to multiple indices")__        }_        return indices[0]__    };utility,method,that,allows,to,resolve,an,index,expression,to,its,corresponding,single,concrete,index,callers,should,make,sure,they,provide,proper,link,org,elasticsearch,action,support,indices,options,that,require,a,single,index,as,a,result,the,indices,resolution,must,in,fact,return,a,single,index,when,using,this,method,an,link,illegal,argument,exception,gets,thrown,otherwise,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expression,to,a,concrete,index,param,request,the,request,that,defines,how,the,an,alias,or,an,index,need,to,be,resolved,to,a,concrete,index,and,the,expression,that,can,be,resolved,to,an,alias,or,an,index,name,throws,illegal,argument,exception,if,the,index,resolution,lead,to,more,than,one,index,return,the,concrete,index,obtained,as,a,result,of,the,index,resolution;public,index,concrete,single,index,cluster,state,state,indices,request,request,string,index,expression,request,indices,null,request,indices,length,0,request,indices,0,null,index,indices,concrete,indices,state,request,indices,options,index,expression,if,indices,length,1,throw,new,illegal,argument,exception,unable,to,return,a,single,index,as,the,index,and,options,provided,got,resolved,to,multiple,indices,return,indices,0
IndexNameExpressionResolver -> static boolean isExplicitAllPattern(List<String> aliasesOrIndices);1524684173;Identifies whether the array containing index names given as argument explicitly refers to all indices_The empty or null array doesn't explicitly map to all indices__@param aliasesOrIndices the array containing index names_@return true if the provided array explicitly maps to all indices, false otherwise;static boolean isExplicitAllPattern(List<String> aliasesOrIndices) {_        return aliasesOrIndices != null && aliasesOrIndices.size() == 1 && MetaData.ALL.equals(aliasesOrIndices.get(0))__    };identifies,whether,the,array,containing,index,names,given,as,argument,explicitly,refers,to,all,indices,the,empty,or,null,array,doesn,t,explicitly,map,to,all,indices,param,aliases,or,indices,the,array,containing,index,names,return,true,if,the,provided,array,explicitly,maps,to,all,indices,false,otherwise;static,boolean,is,explicit,all,pattern,list,string,aliases,or,indices,return,aliases,or,indices,null,aliases,or,indices,size,1,meta,data,all,equals,aliases,or,indices,get,0
IndexNameExpressionResolver -> static boolean isExplicitAllPattern(List<String> aliasesOrIndices);1525334055;Identifies whether the array containing index names given as argument explicitly refers to all indices_The empty or null array doesn't explicitly map to all indices__@param aliasesOrIndices the array containing index names_@return true if the provided array explicitly maps to all indices, false otherwise;static boolean isExplicitAllPattern(List<String> aliasesOrIndices) {_        return aliasesOrIndices != null && aliasesOrIndices.size() == 1 && MetaData.ALL.equals(aliasesOrIndices.get(0))__    };identifies,whether,the,array,containing,index,names,given,as,argument,explicitly,refers,to,all,indices,the,empty,or,null,array,doesn,t,explicitly,map,to,all,indices,param,aliases,or,indices,the,array,containing,index,names,return,true,if,the,provided,array,explicitly,maps,to,all,indices,false,otherwise;static,boolean,is,explicit,all,pattern,list,string,aliases,or,indices,return,aliases,or,indices,null,aliases,or,indices,size,1,meta,data,all,equals,aliases,or,indices,get,0
IndexNameExpressionResolver -> static boolean isExplicitAllPattern(List<String> aliasesOrIndices);1532028790;Identifies whether the array containing index names given as argument explicitly refers to all indices_The empty or null array doesn't explicitly map to all indices__@param aliasesOrIndices the array containing index names_@return true if the provided array explicitly maps to all indices, false otherwise;static boolean isExplicitAllPattern(List<String> aliasesOrIndices) {_        return aliasesOrIndices != null && aliasesOrIndices.size() == 1 && MetaData.ALL.equals(aliasesOrIndices.get(0))__    };identifies,whether,the,array,containing,index,names,given,as,argument,explicitly,refers,to,all,indices,the,empty,or,null,array,doesn,t,explicitly,map,to,all,indices,param,aliases,or,indices,the,array,containing,index,names,return,true,if,the,provided,array,explicitly,maps,to,all,indices,false,otherwise;static,boolean,is,explicit,all,pattern,list,string,aliases,or,indices,return,aliases,or,indices,null,aliases,or,indices,size,1,meta,data,all,equals,aliases,or,indices,get,0
IndexNameExpressionResolver -> static boolean isExplicitAllPattern(List<String> aliasesOrIndices);1538067637;Identifies whether the array containing index names given as argument explicitly refers to all indices_The empty or null array doesn't explicitly map to all indices__@param aliasesOrIndices the array containing index names_@return true if the provided array explicitly maps to all indices, false otherwise;static boolean isExplicitAllPattern(List<String> aliasesOrIndices) {_        return aliasesOrIndices != null && aliasesOrIndices.size() == 1 && MetaData.ALL.equals(aliasesOrIndices.get(0))__    };identifies,whether,the,array,containing,index,names,given,as,argument,explicitly,refers,to,all,indices,the,empty,or,null,array,doesn,t,explicitly,map,to,all,indices,param,aliases,or,indices,the,array,containing,index,names,return,true,if,the,provided,array,explicitly,maps,to,all,indices,false,otherwise;static,boolean,is,explicit,all,pattern,list,string,aliases,or,indices,return,aliases,or,indices,null,aliases,or,indices,size,1,meta,data,all,equals,aliases,or,indices,get,0
IndexNameExpressionResolver -> static boolean isExplicitAllPattern(List<String> aliasesOrIndices);1539615817;Identifies whether the array containing index names given as argument explicitly refers to all indices_The empty or null array doesn't explicitly map to all indices__@param aliasesOrIndices the array containing index names_@return true if the provided array explicitly maps to all indices, false otherwise;static boolean isExplicitAllPattern(List<String> aliasesOrIndices) {_        return aliasesOrIndices != null && aliasesOrIndices.size() == 1 && MetaData.ALL.equals(aliasesOrIndices.get(0))__    };identifies,whether,the,array,containing,index,names,given,as,argument,explicitly,refers,to,all,indices,the,empty,or,null,array,doesn,t,explicitly,map,to,all,indices,param,aliases,or,indices,the,array,containing,index,names,return,true,if,the,provided,array,explicitly,maps,to,all,indices,false,otherwise;static,boolean,is,explicit,all,pattern,list,string,aliases,or,indices,return,aliases,or,indices,null,aliases,or,indices,size,1,meta,data,all,equals,aliases,or,indices,get,0
IndexNameExpressionResolver -> static boolean isExplicitAllPattern(List<String> aliasesOrIndices);1540313026;Identifies whether the array containing index names given as argument explicitly refers to all indices_The empty or null array doesn't explicitly map to all indices__@param aliasesOrIndices the array containing index names_@return true if the provided array explicitly maps to all indices, false otherwise;static boolean isExplicitAllPattern(List<String> aliasesOrIndices) {_        return aliasesOrIndices != null && aliasesOrIndices.size() == 1 && MetaData.ALL.equals(aliasesOrIndices.get(0))__    };identifies,whether,the,array,containing,index,names,given,as,argument,explicitly,refers,to,all,indices,the,empty,or,null,array,doesn,t,explicitly,map,to,all,indices,param,aliases,or,indices,the,array,containing,index,names,return,true,if,the,provided,array,explicitly,maps,to,all,indices,false,otherwise;static,boolean,is,explicit,all,pattern,list,string,aliases,or,indices,return,aliases,or,indices,null,aliases,or,indices,size,1,meta,data,all,equals,aliases,or,indices,get,0
IndexNameExpressionResolver -> static boolean isExplicitAllPattern(List<String> aliasesOrIndices);1540847035;Identifies whether the array containing index names given as argument explicitly refers to all indices_The empty or null array doesn't explicitly map to all indices__@param aliasesOrIndices the array containing index names_@return true if the provided array explicitly maps to all indices, false otherwise;static boolean isExplicitAllPattern(List<String> aliasesOrIndices) {_        return aliasesOrIndices != null && aliasesOrIndices.size() == 1 && MetaData.ALL.equals(aliasesOrIndices.get(0))__    };identifies,whether,the,array,containing,index,names,given,as,argument,explicitly,refers,to,all,indices,the,empty,or,null,array,doesn,t,explicitly,map,to,all,indices,param,aliases,or,indices,the,array,containing,index,names,return,true,if,the,provided,array,explicitly,maps,to,all,indices,false,otherwise;static,boolean,is,explicit,all,pattern,list,string,aliases,or,indices,return,aliases,or,indices,null,aliases,or,indices,size,1,meta,data,all,equals,aliases,or,indices,get,0
IndexNameExpressionResolver -> static boolean isExplicitAllPattern(List<String> aliasesOrIndices);1541092382;Identifies whether the array containing index names given as argument explicitly refers to all indices_The empty or null array doesn't explicitly map to all indices__@param aliasesOrIndices the array containing index names_@return true if the provided array explicitly maps to all indices, false otherwise;static boolean isExplicitAllPattern(List<String> aliasesOrIndices) {_        return aliasesOrIndices != null && aliasesOrIndices.size() == 1 && MetaData.ALL.equals(aliasesOrIndices.get(0))__    };identifies,whether,the,array,containing,index,names,given,as,argument,explicitly,refers,to,all,indices,the,empty,or,null,array,doesn,t,explicitly,map,to,all,indices,param,aliases,or,indices,the,array,containing,index,names,return,true,if,the,provided,array,explicitly,maps,to,all,indices,false,otherwise;static,boolean,is,explicit,all,pattern,list,string,aliases,or,indices,return,aliases,or,indices,null,aliases,or,indices,size,1,meta,data,all,equals,aliases,or,indices,get,0
IndexNameExpressionResolver -> static boolean isExplicitAllPattern(List<String> aliasesOrIndices);1541493930;Identifies whether the array containing index names given as argument explicitly refers to all indices_The empty or null array doesn't explicitly map to all indices__@param aliasesOrIndices the array containing index names_@return true if the provided array explicitly maps to all indices, false otherwise;static boolean isExplicitAllPattern(List<String> aliasesOrIndices) {_        return aliasesOrIndices != null && aliasesOrIndices.size() == 1 && MetaData.ALL.equals(aliasesOrIndices.get(0))__    };identifies,whether,the,array,containing,index,names,given,as,argument,explicitly,refers,to,all,indices,the,empty,or,null,array,doesn,t,explicitly,map,to,all,indices,param,aliases,or,indices,the,array,containing,index,names,return,true,if,the,provided,array,explicitly,maps,to,all,indices,false,otherwise;static,boolean,is,explicit,all,pattern,list,string,aliases,or,indices,return,aliases,or,indices,null,aliases,or,indices,size,1,meta,data,all,equals,aliases,or,indices,get,0
IndexNameExpressionResolver -> static boolean isExplicitAllPattern(List<String> aliasesOrIndices);1541612607;Identifies whether the array containing index names given as argument explicitly refers to all indices_The empty or null array doesn't explicitly map to all indices__@param aliasesOrIndices the array containing index names_@return true if the provided array explicitly maps to all indices, false otherwise;static boolean isExplicitAllPattern(List<String> aliasesOrIndices) {_        return aliasesOrIndices != null && aliasesOrIndices.size() == 1 && MetaData.ALL.equals(aliasesOrIndices.get(0))__    };identifies,whether,the,array,containing,index,names,given,as,argument,explicitly,refers,to,all,indices,the,empty,or,null,array,doesn,t,explicitly,map,to,all,indices,param,aliases,or,indices,the,array,containing,index,names,return,true,if,the,provided,array,explicitly,maps,to,all,indices,false,otherwise;static,boolean,is,explicit,all,pattern,list,string,aliases,or,indices,return,aliases,or,indices,null,aliases,or,indices,size,1,meta,data,all,equals,aliases,or,indices,get,0
IndexNameExpressionResolver -> static boolean isExplicitAllPattern(List<String> aliasesOrIndices);1544215214;Identifies whether the array containing index names given as argument explicitly refers to all indices_The empty or null array doesn't explicitly map to all indices__@param aliasesOrIndices the array containing index names_@return true if the provided array explicitly maps to all indices, false otherwise;static boolean isExplicitAllPattern(List<String> aliasesOrIndices) {_        return aliasesOrIndices != null && aliasesOrIndices.size() == 1 && MetaData.ALL.equals(aliasesOrIndices.get(0))__    };identifies,whether,the,array,containing,index,names,given,as,argument,explicitly,refers,to,all,indices,the,empty,or,null,array,doesn,t,explicitly,map,to,all,indices,param,aliases,or,indices,the,array,containing,index,names,return,true,if,the,provided,array,explicitly,maps,to,all,indices,false,otherwise;static,boolean,is,explicit,all,pattern,list,string,aliases,or,indices,return,aliases,or,indices,null,aliases,or,indices,size,1,meta,data,all,equals,aliases,or,indices,get,0
IndexNameExpressionResolver -> static boolean isExplicitAllPattern(List<String> aliasesOrIndices);1548236405;Identifies whether the array containing index names given as argument explicitly refers to all indices_The empty or null array doesn't explicitly map to all indices__@param aliasesOrIndices the array containing index names_@return true if the provided array explicitly maps to all indices, false otherwise;static boolean isExplicitAllPattern(List<String> aliasesOrIndices) {_        return aliasesOrIndices != null && aliasesOrIndices.size() == 1 && MetaData.ALL.equals(aliasesOrIndices.get(0))__    };identifies,whether,the,array,containing,index,names,given,as,argument,explicitly,refers,to,all,indices,the,empty,or,null,array,doesn,t,explicitly,map,to,all,indices,param,aliases,or,indices,the,array,containing,index,names,return,true,if,the,provided,array,explicitly,maps,to,all,indices,false,otherwise;static,boolean,is,explicit,all,pattern,list,string,aliases,or,indices,return,aliases,or,indices,null,aliases,or,indices,size,1,meta,data,all,equals,aliases,or,indices,get,0
IndexNameExpressionResolver -> Context -> boolean isPreserveAliases();1524684173;This is used to prevent resolving aliases to concrete indices but this also means_that we might return aliases that point to a closed index. This is currently only used_by {@link #filteringAliases(ClusterState, String, String...)} since it's the only one that needs aliases;boolean isPreserveAliases() {_            return preserveAliases__        };this,is,used,to,prevent,resolving,aliases,to,concrete,indices,but,this,also,means,that,we,might,return,aliases,that,point,to,a,closed,index,this,is,currently,only,used,by,link,filtering,aliases,cluster,state,string,string,since,it,s,the,only,one,that,needs,aliases;boolean,is,preserve,aliases,return,preserve,aliases
IndexNameExpressionResolver -> Context -> boolean isPreserveAliases();1525334055;This is used to prevent resolving aliases to concrete indices but this also means_that we might return aliases that point to a closed index. This is currently only used_by {@link #filteringAliases(ClusterState, String, String...)} since it's the only one that needs aliases;boolean isPreserveAliases() {_            return preserveAliases__        };this,is,used,to,prevent,resolving,aliases,to,concrete,indices,but,this,also,means,that,we,might,return,aliases,that,point,to,a,closed,index,this,is,currently,only,used,by,link,filtering,aliases,cluster,state,string,string,since,it,s,the,only,one,that,needs,aliases;boolean,is,preserve,aliases,return,preserve,aliases
IndexNameExpressionResolver -> Context -> boolean isPreserveAliases();1532028790;This is used to prevent resolving aliases to concrete indices but this also means_that we might return aliases that point to a closed index. This is currently only used_by {@link #filteringAliases(ClusterState, String, String...)} since it's the only one that needs aliases;boolean isPreserveAliases() {_            return preserveAliases__        };this,is,used,to,prevent,resolving,aliases,to,concrete,indices,but,this,also,means,that,we,might,return,aliases,that,point,to,a,closed,index,this,is,currently,only,used,by,link,filtering,aliases,cluster,state,string,string,since,it,s,the,only,one,that,needs,aliases;boolean,is,preserve,aliases,return,preserve,aliases
IndexNameExpressionResolver -> Context -> boolean isPreserveAliases();1538067637;This is used to prevent resolving aliases to concrete indices but this also means_that we might return aliases that point to a closed index. This is currently only used_by {@link #filteringAliases(ClusterState, String, String...)} since it's the only one that needs aliases;boolean isPreserveAliases() {_            return preserveAliases__        };this,is,used,to,prevent,resolving,aliases,to,concrete,indices,but,this,also,means,that,we,might,return,aliases,that,point,to,a,closed,index,this,is,currently,only,used,by,link,filtering,aliases,cluster,state,string,string,since,it,s,the,only,one,that,needs,aliases;boolean,is,preserve,aliases,return,preserve,aliases
IndexNameExpressionResolver -> Context -> boolean isPreserveAliases();1539615817;This is used to prevent resolving aliases to concrete indices but this also means_that we might return aliases that point to a closed index. This is currently only used_by {@link #filteringAliases(ClusterState, String, String...)} since it's the only one that needs aliases;boolean isPreserveAliases() {_            return preserveAliases__        };this,is,used,to,prevent,resolving,aliases,to,concrete,indices,but,this,also,means,that,we,might,return,aliases,that,point,to,a,closed,index,this,is,currently,only,used,by,link,filtering,aliases,cluster,state,string,string,since,it,s,the,only,one,that,needs,aliases;boolean,is,preserve,aliases,return,preserve,aliases
IndexNameExpressionResolver -> Context -> boolean isPreserveAliases();1540313026;This is used to prevent resolving aliases to concrete indices but this also means_that we might return aliases that point to a closed index. This is currently only used_by {@link #filteringAliases(ClusterState, String, String...)} since it's the only one that needs aliases;boolean isPreserveAliases() {_            return preserveAliases__        };this,is,used,to,prevent,resolving,aliases,to,concrete,indices,but,this,also,means,that,we,might,return,aliases,that,point,to,a,closed,index,this,is,currently,only,used,by,link,filtering,aliases,cluster,state,string,string,since,it,s,the,only,one,that,needs,aliases;boolean,is,preserve,aliases,return,preserve,aliases
IndexNameExpressionResolver -> Context -> boolean isPreserveAliases();1540847035;This is used to prevent resolving aliases to concrete indices but this also means_that we might return aliases that point to a closed index. This is currently only used_by {@link #filteringAliases(ClusterState, String, String...)} since it's the only one that needs aliases;boolean isPreserveAliases() {_            return preserveAliases__        };this,is,used,to,prevent,resolving,aliases,to,concrete,indices,but,this,also,means,that,we,might,return,aliases,that,point,to,a,closed,index,this,is,currently,only,used,by,link,filtering,aliases,cluster,state,string,string,since,it,s,the,only,one,that,needs,aliases;boolean,is,preserve,aliases,return,preserve,aliases
IndexNameExpressionResolver -> Context -> boolean isPreserveAliases();1541092382;This is used to prevent resolving aliases to concrete indices but this also means_that we might return aliases that point to a closed index. This is currently only used_by {@link #filteringAliases(ClusterState, String, String...)} since it's the only one that needs aliases;boolean isPreserveAliases() {_            return preserveAliases__        };this,is,used,to,prevent,resolving,aliases,to,concrete,indices,but,this,also,means,that,we,might,return,aliases,that,point,to,a,closed,index,this,is,currently,only,used,by,link,filtering,aliases,cluster,state,string,string,since,it,s,the,only,one,that,needs,aliases;boolean,is,preserve,aliases,return,preserve,aliases
IndexNameExpressionResolver -> Context -> boolean isPreserveAliases();1541493930;This is used to prevent resolving aliases to concrete indices but this also means_that we might return aliases that point to a closed index. This is currently only used_by {@link #filteringAliases(ClusterState, String, String...)} since it's the only one that needs aliases;boolean isPreserveAliases() {_            return preserveAliases__        };this,is,used,to,prevent,resolving,aliases,to,concrete,indices,but,this,also,means,that,we,might,return,aliases,that,point,to,a,closed,index,this,is,currently,only,used,by,link,filtering,aliases,cluster,state,string,string,since,it,s,the,only,one,that,needs,aliases;boolean,is,preserve,aliases,return,preserve,aliases
IndexNameExpressionResolver -> Context -> boolean isPreserveAliases();1541612607;This is used to prevent resolving aliases to concrete indices but this also means_that we might return aliases that point to a closed index. This is currently only used_by {@link #filteringAliases(ClusterState, String, String...)} since it's the only one that needs aliases;boolean isPreserveAliases() {_            return preserveAliases__        };this,is,used,to,prevent,resolving,aliases,to,concrete,indices,but,this,also,means,that,we,might,return,aliases,that,point,to,a,closed,index,this,is,currently,only,used,by,link,filtering,aliases,cluster,state,string,string,since,it,s,the,only,one,that,needs,aliases;boolean,is,preserve,aliases,return,preserve,aliases
IndexNameExpressionResolver -> Context -> boolean isPreserveAliases();1544215214;This is used to prevent resolving aliases to concrete indices but this also means_that we might return aliases that point to a closed index. This is currently only used_by {@link #filteringAliases(ClusterState, String, String...)} since it's the only one that needs aliases;boolean isPreserveAliases() {_            return preserveAliases__        };this,is,used,to,prevent,resolving,aliases,to,concrete,indices,but,this,also,means,that,we,might,return,aliases,that,point,to,a,closed,index,this,is,currently,only,used,by,link,filtering,aliases,cluster,state,string,string,since,it,s,the,only,one,that,needs,aliases;boolean,is,preserve,aliases,return,preserve,aliases
IndexNameExpressionResolver -> Context -> boolean isPreserveAliases();1548236405;This is used to prevent resolving aliases to concrete indices but this also means_that we might return aliases that point to a closed index. This is currently only used_by {@link #filteringAliases(ClusterState, String, String...)} since it's the only one that needs aliases;boolean isPreserveAliases() {_            return preserveAliases__        };this,is,used,to,prevent,resolving,aliases,to,concrete,indices,but,this,also,means,that,we,might,return,aliases,that,point,to,a,closed,index,this,is,currently,only,used,by,link,filtering,aliases,cluster,state,string,string,since,it,s,the,only,one,that,needs,aliases;boolean,is,preserve,aliases,return,preserve,aliases
IndexNameExpressionResolver -> public Index concreteWriteIndex(ClusterState state, IndicesRequest request);1532028790;Utility method that allows to resolve an index expression to its corresponding single write index.__@param state             the cluster state containing all the data to resolve to expression to a concrete index_@param request           The request that defines how the an alias or an index need to be resolved to a concrete index_and the expression that can be resolved to an alias or an index name._@throws IllegalArgumentException if the index resolution does not lead to an index, or leads to more than one index_@return the write index obtained as a result of the index resolution;public Index concreteWriteIndex(ClusterState state, IndicesRequest request) {_        if (request.indices() == null || (request.indices() != null && request.indices().length != 1)) {_            throw new IllegalArgumentException("indices request must specify a single index expression")__        }_        Context context = new Context(state, request.indicesOptions(), false, true)__        Index[] indices = concreteIndices(context, request.indices()[0])__        if (indices.length != 1) {_            throw new IllegalArgumentException("The index expression [" + request.indices()[0] +_                "] and options provided did not point to a single write-index")__        }_        return indices[0]__    };utility,method,that,allows,to,resolve,an,index,expression,to,its,corresponding,single,write,index,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expression,to,a,concrete,index,param,request,the,request,that,defines,how,the,an,alias,or,an,index,need,to,be,resolved,to,a,concrete,index,and,the,expression,that,can,be,resolved,to,an,alias,or,an,index,name,throws,illegal,argument,exception,if,the,index,resolution,does,not,lead,to,an,index,or,leads,to,more,than,one,index,return,the,write,index,obtained,as,a,result,of,the,index,resolution;public,index,concrete,write,index,cluster,state,state,indices,request,request,if,request,indices,null,request,indices,null,request,indices,length,1,throw,new,illegal,argument,exception,indices,request,must,specify,a,single,index,expression,context,context,new,context,state,request,indices,options,false,true,index,indices,concrete,indices,context,request,indices,0,if,indices,length,1,throw,new,illegal,argument,exception,the,index,expression,request,indices,0,and,options,provided,did,not,point,to,a,single,write,index,return,indices,0
IndexNameExpressionResolver -> public Index concreteWriteIndex(ClusterState state, IndicesRequest request);1538067637;Utility method that allows to resolve an index expression to its corresponding single write index.__@param state             the cluster state containing all the data to resolve to expression to a concrete index_@param request           The request that defines how the an alias or an index need to be resolved to a concrete index_and the expression that can be resolved to an alias or an index name._@throws IllegalArgumentException if the index resolution does not lead to an index, or leads to more than one index_@return the write index obtained as a result of the index resolution;public Index concreteWriteIndex(ClusterState state, IndicesRequest request) {_        if (request.indices() == null || (request.indices() != null && request.indices().length != 1)) {_            throw new IllegalArgumentException("indices request must specify a single index expression")__        }_        Context context = new Context(state, request.indicesOptions(), false, true)__        Index[] indices = concreteIndices(context, request.indices()[0])__        if (indices.length != 1) {_            throw new IllegalArgumentException("The index expression [" + request.indices()[0] +_                "] and options provided did not point to a single write-index")__        }_        return indices[0]__    };utility,method,that,allows,to,resolve,an,index,expression,to,its,corresponding,single,write,index,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expression,to,a,concrete,index,param,request,the,request,that,defines,how,the,an,alias,or,an,index,need,to,be,resolved,to,a,concrete,index,and,the,expression,that,can,be,resolved,to,an,alias,or,an,index,name,throws,illegal,argument,exception,if,the,index,resolution,does,not,lead,to,an,index,or,leads,to,more,than,one,index,return,the,write,index,obtained,as,a,result,of,the,index,resolution;public,index,concrete,write,index,cluster,state,state,indices,request,request,if,request,indices,null,request,indices,null,request,indices,length,1,throw,new,illegal,argument,exception,indices,request,must,specify,a,single,index,expression,context,context,new,context,state,request,indices,options,false,true,index,indices,concrete,indices,context,request,indices,0,if,indices,length,1,throw,new,illegal,argument,exception,the,index,expression,request,indices,0,and,options,provided,did,not,point,to,a,single,write,index,return,indices,0
IndexNameExpressionResolver -> public Index concreteWriteIndex(ClusterState state, IndicesRequest request);1539615817;Utility method that allows to resolve an index expression to its corresponding single write index.__@param state             the cluster state containing all the data to resolve to expression to a concrete index_@param request           The request that defines how the an alias or an index need to be resolved to a concrete index_and the expression that can be resolved to an alias or an index name._@throws IllegalArgumentException if the index resolution does not lead to an index, or leads to more than one index_@return the write index obtained as a result of the index resolution;public Index concreteWriteIndex(ClusterState state, IndicesRequest request) {_        if (request.indices() == null || (request.indices() != null && request.indices().length != 1)) {_            throw new IllegalArgumentException("indices request must specify a single index expression")__        }_        Context context = new Context(state, request.indicesOptions(), false, true)__        Index[] indices = concreteIndices(context, request.indices()[0])__        if (indices.length != 1) {_            throw new IllegalArgumentException("The index expression [" + request.indices()[0] +_                "] and options provided did not point to a single write-index")__        }_        return indices[0]__    };utility,method,that,allows,to,resolve,an,index,expression,to,its,corresponding,single,write,index,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expression,to,a,concrete,index,param,request,the,request,that,defines,how,the,an,alias,or,an,index,need,to,be,resolved,to,a,concrete,index,and,the,expression,that,can,be,resolved,to,an,alias,or,an,index,name,throws,illegal,argument,exception,if,the,index,resolution,does,not,lead,to,an,index,or,leads,to,more,than,one,index,return,the,write,index,obtained,as,a,result,of,the,index,resolution;public,index,concrete,write,index,cluster,state,state,indices,request,request,if,request,indices,null,request,indices,null,request,indices,length,1,throw,new,illegal,argument,exception,indices,request,must,specify,a,single,index,expression,context,context,new,context,state,request,indices,options,false,true,index,indices,concrete,indices,context,request,indices,0,if,indices,length,1,throw,new,illegal,argument,exception,the,index,expression,request,indices,0,and,options,provided,did,not,point,to,a,single,write,index,return,indices,0
IndexNameExpressionResolver -> public Index concreteWriteIndex(ClusterState state, IndicesRequest request);1540313026;Utility method that allows to resolve an index expression to its corresponding single write index.__@param state             the cluster state containing all the data to resolve to expression to a concrete index_@param request           The request that defines how the an alias or an index need to be resolved to a concrete index_and the expression that can be resolved to an alias or an index name._@throws IllegalArgumentException if the index resolution does not lead to an index, or leads to more than one index_@return the write index obtained as a result of the index resolution;public Index concreteWriteIndex(ClusterState state, IndicesRequest request) {_        if (request.indices() == null || (request.indices() != null && request.indices().length != 1)) {_            throw new IllegalArgumentException("indices request must specify a single index expression")__        }_        Context context = new Context(state, request.indicesOptions(), false, true)__        Index[] indices = concreteIndices(context, request.indices()[0])__        if (indices.length != 1) {_            throw new IllegalArgumentException("The index expression [" + request.indices()[0] +_                "] and options provided did not point to a single write-index")__        }_        return indices[0]__    };utility,method,that,allows,to,resolve,an,index,expression,to,its,corresponding,single,write,index,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expression,to,a,concrete,index,param,request,the,request,that,defines,how,the,an,alias,or,an,index,need,to,be,resolved,to,a,concrete,index,and,the,expression,that,can,be,resolved,to,an,alias,or,an,index,name,throws,illegal,argument,exception,if,the,index,resolution,does,not,lead,to,an,index,or,leads,to,more,than,one,index,return,the,write,index,obtained,as,a,result,of,the,index,resolution;public,index,concrete,write,index,cluster,state,state,indices,request,request,if,request,indices,null,request,indices,null,request,indices,length,1,throw,new,illegal,argument,exception,indices,request,must,specify,a,single,index,expression,context,context,new,context,state,request,indices,options,false,true,index,indices,concrete,indices,context,request,indices,0,if,indices,length,1,throw,new,illegal,argument,exception,the,index,expression,request,indices,0,and,options,provided,did,not,point,to,a,single,write,index,return,indices,0
IndexNameExpressionResolver -> public Index concreteWriteIndex(ClusterState state, IndicesRequest request);1540847035;Utility method that allows to resolve an index expression to its corresponding single write index.__@param state             the cluster state containing all the data to resolve to expression to a concrete index_@param request           The request that defines how the an alias or an index need to be resolved to a concrete index_and the expression that can be resolved to an alias or an index name._@throws IllegalArgumentException if the index resolution does not lead to an index, or leads to more than one index_@return the write index obtained as a result of the index resolution;public Index concreteWriteIndex(ClusterState state, IndicesRequest request) {_        if (request.indices() == null || (request.indices() != null && request.indices().length != 1)) {_            throw new IllegalArgumentException("indices request must specify a single index expression")__        }_        Context context = new Context(state, request.indicesOptions(), false, true)__        Index[] indices = concreteIndices(context, request.indices()[0])__        if (indices.length != 1) {_            throw new IllegalArgumentException("The index expression [" + request.indices()[0] +_                "] and options provided did not point to a single write-index")__        }_        return indices[0]__    };utility,method,that,allows,to,resolve,an,index,expression,to,its,corresponding,single,write,index,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expression,to,a,concrete,index,param,request,the,request,that,defines,how,the,an,alias,or,an,index,need,to,be,resolved,to,a,concrete,index,and,the,expression,that,can,be,resolved,to,an,alias,or,an,index,name,throws,illegal,argument,exception,if,the,index,resolution,does,not,lead,to,an,index,or,leads,to,more,than,one,index,return,the,write,index,obtained,as,a,result,of,the,index,resolution;public,index,concrete,write,index,cluster,state,state,indices,request,request,if,request,indices,null,request,indices,null,request,indices,length,1,throw,new,illegal,argument,exception,indices,request,must,specify,a,single,index,expression,context,context,new,context,state,request,indices,options,false,true,index,indices,concrete,indices,context,request,indices,0,if,indices,length,1,throw,new,illegal,argument,exception,the,index,expression,request,indices,0,and,options,provided,did,not,point,to,a,single,write,index,return,indices,0
IndexNameExpressionResolver -> public Index concreteWriteIndex(ClusterState state, IndicesRequest request);1541092382;Utility method that allows to resolve an index expression to its corresponding single write index.__@param state             the cluster state containing all the data to resolve to expression to a concrete index_@param request           The request that defines how the an alias or an index need to be resolved to a concrete index_and the expression that can be resolved to an alias or an index name._@throws IllegalArgumentException if the index resolution does not lead to an index, or leads to more than one index_@return the write index obtained as a result of the index resolution;public Index concreteWriteIndex(ClusterState state, IndicesRequest request) {_        if (request.indices() == null || (request.indices() != null && request.indices().length != 1)) {_            throw new IllegalArgumentException("indices request must specify a single index expression")__        }_        Context context = new Context(state, request.indicesOptions(), false, true)__        Index[] indices = concreteIndices(context, request.indices()[0])__        if (indices.length != 1) {_            throw new IllegalArgumentException("The index expression [" + request.indices()[0] +_                "] and options provided did not point to a single write-index")__        }_        return indices[0]__    };utility,method,that,allows,to,resolve,an,index,expression,to,its,corresponding,single,write,index,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expression,to,a,concrete,index,param,request,the,request,that,defines,how,the,an,alias,or,an,index,need,to,be,resolved,to,a,concrete,index,and,the,expression,that,can,be,resolved,to,an,alias,or,an,index,name,throws,illegal,argument,exception,if,the,index,resolution,does,not,lead,to,an,index,or,leads,to,more,than,one,index,return,the,write,index,obtained,as,a,result,of,the,index,resolution;public,index,concrete,write,index,cluster,state,state,indices,request,request,if,request,indices,null,request,indices,null,request,indices,length,1,throw,new,illegal,argument,exception,indices,request,must,specify,a,single,index,expression,context,context,new,context,state,request,indices,options,false,true,index,indices,concrete,indices,context,request,indices,0,if,indices,length,1,throw,new,illegal,argument,exception,the,index,expression,request,indices,0,and,options,provided,did,not,point,to,a,single,write,index,return,indices,0
IndexNameExpressionResolver -> public Index concreteWriteIndex(ClusterState state, IndicesRequest request);1541493930;Utility method that allows to resolve an index expression to its corresponding single write index.__@param state             the cluster state containing all the data to resolve to expression to a concrete index_@param request           The request that defines how the an alias or an index need to be resolved to a concrete index_and the expression that can be resolved to an alias or an index name._@throws IllegalArgumentException if the index resolution does not lead to an index, or leads to more than one index_@return the write index obtained as a result of the index resolution;public Index concreteWriteIndex(ClusterState state, IndicesRequest request) {_        if (request.indices() == null || (request.indices() != null && request.indices().length != 1)) {_            throw new IllegalArgumentException("indices request must specify a single index expression")__        }_        Context context = new Context(state, request.indicesOptions(), false, true)__        Index[] indices = concreteIndices(context, request.indices()[0])__        if (indices.length != 1) {_            throw new IllegalArgumentException("The index expression [" + request.indices()[0] +_                "] and options provided did not point to a single write-index")__        }_        return indices[0]__    };utility,method,that,allows,to,resolve,an,index,expression,to,its,corresponding,single,write,index,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expression,to,a,concrete,index,param,request,the,request,that,defines,how,the,an,alias,or,an,index,need,to,be,resolved,to,a,concrete,index,and,the,expression,that,can,be,resolved,to,an,alias,or,an,index,name,throws,illegal,argument,exception,if,the,index,resolution,does,not,lead,to,an,index,or,leads,to,more,than,one,index,return,the,write,index,obtained,as,a,result,of,the,index,resolution;public,index,concrete,write,index,cluster,state,state,indices,request,request,if,request,indices,null,request,indices,null,request,indices,length,1,throw,new,illegal,argument,exception,indices,request,must,specify,a,single,index,expression,context,context,new,context,state,request,indices,options,false,true,index,indices,concrete,indices,context,request,indices,0,if,indices,length,1,throw,new,illegal,argument,exception,the,index,expression,request,indices,0,and,options,provided,did,not,point,to,a,single,write,index,return,indices,0
IndexNameExpressionResolver -> public Index concreteWriteIndex(ClusterState state, IndicesRequest request);1541612607;Utility method that allows to resolve an index expression to its corresponding single write index.__@param state             the cluster state containing all the data to resolve to expression to a concrete index_@param request           The request that defines how the an alias or an index need to be resolved to a concrete index_and the expression that can be resolved to an alias or an index name._@throws IllegalArgumentException if the index resolution does not lead to an index, or leads to more than one index_@return the write index obtained as a result of the index resolution;public Index concreteWriteIndex(ClusterState state, IndicesRequest request) {_        if (request.indices() == null || (request.indices() != null && request.indices().length != 1)) {_            throw new IllegalArgumentException("indices request must specify a single index expression")__        }_        Context context = new Context(state, request.indicesOptions(), false, true)__        Index[] indices = concreteIndices(context, request.indices()[0])__        if (indices.length != 1) {_            throw new IllegalArgumentException("The index expression [" + request.indices()[0] +_                "] and options provided did not point to a single write-index")__        }_        return indices[0]__    };utility,method,that,allows,to,resolve,an,index,expression,to,its,corresponding,single,write,index,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expression,to,a,concrete,index,param,request,the,request,that,defines,how,the,an,alias,or,an,index,need,to,be,resolved,to,a,concrete,index,and,the,expression,that,can,be,resolved,to,an,alias,or,an,index,name,throws,illegal,argument,exception,if,the,index,resolution,does,not,lead,to,an,index,or,leads,to,more,than,one,index,return,the,write,index,obtained,as,a,result,of,the,index,resolution;public,index,concrete,write,index,cluster,state,state,indices,request,request,if,request,indices,null,request,indices,null,request,indices,length,1,throw,new,illegal,argument,exception,indices,request,must,specify,a,single,index,expression,context,context,new,context,state,request,indices,options,false,true,index,indices,concrete,indices,context,request,indices,0,if,indices,length,1,throw,new,illegal,argument,exception,the,index,expression,request,indices,0,and,options,provided,did,not,point,to,a,single,write,index,return,indices,0
IndexNameExpressionResolver -> public Index concreteWriteIndex(ClusterState state, IndicesRequest request);1544215214;Utility method that allows to resolve an index expression to its corresponding single write index.__@param state             the cluster state containing all the data to resolve to expression to a concrete index_@param request           The request that defines how the an alias or an index need to be resolved to a concrete index_and the expression that can be resolved to an alias or an index name._@throws IllegalArgumentException if the index resolution does not lead to an index, or leads to more than one index_@return the write index obtained as a result of the index resolution;public Index concreteWriteIndex(ClusterState state, IndicesRequest request) {_        if (request.indices() == null || (request.indices() != null && request.indices().length != 1)) {_            throw new IllegalArgumentException("indices request must specify a single index expression")__        }_        Context context = new Context(state, request.indicesOptions(), false, true)__        Index[] indices = concreteIndices(context, request.indices()[0])__        if (indices.length != 1) {_            throw new IllegalArgumentException("The index expression [" + request.indices()[0] +_                "] and options provided did not point to a single write-index")__        }_        return indices[0]__    };utility,method,that,allows,to,resolve,an,index,expression,to,its,corresponding,single,write,index,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expression,to,a,concrete,index,param,request,the,request,that,defines,how,the,an,alias,or,an,index,need,to,be,resolved,to,a,concrete,index,and,the,expression,that,can,be,resolved,to,an,alias,or,an,index,name,throws,illegal,argument,exception,if,the,index,resolution,does,not,lead,to,an,index,or,leads,to,more,than,one,index,return,the,write,index,obtained,as,a,result,of,the,index,resolution;public,index,concrete,write,index,cluster,state,state,indices,request,request,if,request,indices,null,request,indices,null,request,indices,length,1,throw,new,illegal,argument,exception,indices,request,must,specify,a,single,index,expression,context,context,new,context,state,request,indices,options,false,true,index,indices,concrete,indices,context,request,indices,0,if,indices,length,1,throw,new,illegal,argument,exception,the,index,expression,request,indices,0,and,options,provided,did,not,point,to,a,single,write,index,return,indices,0
IndexNameExpressionResolver -> public Index concreteWriteIndex(ClusterState state, IndicesRequest request);1548236405;Utility method that allows to resolve an index expression to its corresponding single write index.__@param state             the cluster state containing all the data to resolve to expression to a concrete index_@param request           The request that defines how the an alias or an index need to be resolved to a concrete index_and the expression that can be resolved to an alias or an index name._@throws IllegalArgumentException if the index resolution does not lead to an index, or leads to more than one index_@return the write index obtained as a result of the index resolution;public Index concreteWriteIndex(ClusterState state, IndicesRequest request) {_        if (request.indices() == null || (request.indices() != null && request.indices().length != 1)) {_            throw new IllegalArgumentException("indices request must specify a single index expression")__        }_        Context context = new Context(state, request.indicesOptions(), false, true)__        Index[] indices = concreteIndices(context, request.indices()[0])__        if (indices.length != 1) {_            throw new IllegalArgumentException("The index expression [" + request.indices()[0] +_                "] and options provided did not point to a single write-index")__        }_        return indices[0]__    };utility,method,that,allows,to,resolve,an,index,expression,to,its,corresponding,single,write,index,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expression,to,a,concrete,index,param,request,the,request,that,defines,how,the,an,alias,or,an,index,need,to,be,resolved,to,a,concrete,index,and,the,expression,that,can,be,resolved,to,an,alias,or,an,index,name,throws,illegal,argument,exception,if,the,index,resolution,does,not,lead,to,an,index,or,leads,to,more,than,one,index,return,the,write,index,obtained,as,a,result,of,the,index,resolution;public,index,concrete,write,index,cluster,state,state,indices,request,request,if,request,indices,null,request,indices,null,request,indices,length,1,throw,new,illegal,argument,exception,indices,request,must,specify,a,single,index,expression,context,context,new,context,state,request,indices,options,false,true,index,indices,concrete,indices,context,request,indices,0,if,indices,length,1,throw,new,illegal,argument,exception,the,index,expression,request,indices,0,and,options,provided,did,not,point,to,a,single,write,index,return,indices,0
IndexNameExpressionResolver -> public Index[] concreteIndices(ClusterState state, IndicesRequest request);1524684173;Same as {@link #concreteIndices(ClusterState, IndicesOptions, String...)}, but the index expressions and options_are encapsulated in the specified request.;public Index[] concreteIndices(ClusterState state, IndicesRequest request) {_        Context context = new Context(state, request.indicesOptions())__        return concreteIndices(context, request.indices())__    };same,as,link,concrete,indices,cluster,state,indices,options,string,but,the,index,expressions,and,options,are,encapsulated,in,the,specified,request;public,index,concrete,indices,cluster,state,state,indices,request,request,context,context,new,context,state,request,indices,options,return,concrete,indices,context,request,indices
IndexNameExpressionResolver -> public Index[] concreteIndices(ClusterState state, IndicesRequest request);1525334055;Same as {@link #concreteIndices(ClusterState, IndicesOptions, String...)}, but the index expressions and options_are encapsulated in the specified request.;public Index[] concreteIndices(ClusterState state, IndicesRequest request) {_        Context context = new Context(state, request.indicesOptions())__        return concreteIndices(context, request.indices())__    };same,as,link,concrete,indices,cluster,state,indices,options,string,but,the,index,expressions,and,options,are,encapsulated,in,the,specified,request;public,index,concrete,indices,cluster,state,state,indices,request,request,context,context,new,context,state,request,indices,options,return,concrete,indices,context,request,indices
IndexNameExpressionResolver -> public Index[] concreteIndices(ClusterState state, IndicesRequest request);1532028790;Same as {@link #concreteIndices(ClusterState, IndicesOptions, String...)}, but the index expressions and options_are encapsulated in the specified request.;public Index[] concreteIndices(ClusterState state, IndicesRequest request) {_        Context context = new Context(state, request.indicesOptions())__        return concreteIndices(context, request.indices())__    };same,as,link,concrete,indices,cluster,state,indices,options,string,but,the,index,expressions,and,options,are,encapsulated,in,the,specified,request;public,index,concrete,indices,cluster,state,state,indices,request,request,context,context,new,context,state,request,indices,options,return,concrete,indices,context,request,indices
IndexNameExpressionResolver -> public Index[] concreteIndices(ClusterState state, IndicesRequest request);1538067637;Same as {@link #concreteIndices(ClusterState, IndicesOptions, String...)}, but the index expressions and options_are encapsulated in the specified request.;public Index[] concreteIndices(ClusterState state, IndicesRequest request) {_        Context context = new Context(state, request.indicesOptions())__        return concreteIndices(context, request.indices())__    };same,as,link,concrete,indices,cluster,state,indices,options,string,but,the,index,expressions,and,options,are,encapsulated,in,the,specified,request;public,index,concrete,indices,cluster,state,state,indices,request,request,context,context,new,context,state,request,indices,options,return,concrete,indices,context,request,indices
IndexNameExpressionResolver -> public Index[] concreteIndices(ClusterState state, IndicesRequest request);1539615817;Same as {@link #concreteIndices(ClusterState, IndicesOptions, String...)}, but the index expressions and options_are encapsulated in the specified request.;public Index[] concreteIndices(ClusterState state, IndicesRequest request) {_        Context context = new Context(state, request.indicesOptions())__        return concreteIndices(context, request.indices())__    };same,as,link,concrete,indices,cluster,state,indices,options,string,but,the,index,expressions,and,options,are,encapsulated,in,the,specified,request;public,index,concrete,indices,cluster,state,state,indices,request,request,context,context,new,context,state,request,indices,options,return,concrete,indices,context,request,indices
IndexNameExpressionResolver -> public Index[] concreteIndices(ClusterState state, IndicesRequest request);1540313026;Same as {@link #concreteIndices(ClusterState, IndicesOptions, String...)}, but the index expressions and options_are encapsulated in the specified request.;public Index[] concreteIndices(ClusterState state, IndicesRequest request) {_        Context context = new Context(state, request.indicesOptions())__        return concreteIndices(context, request.indices())__    };same,as,link,concrete,indices,cluster,state,indices,options,string,but,the,index,expressions,and,options,are,encapsulated,in,the,specified,request;public,index,concrete,indices,cluster,state,state,indices,request,request,context,context,new,context,state,request,indices,options,return,concrete,indices,context,request,indices
IndexNameExpressionResolver -> public Index[] concreteIndices(ClusterState state, IndicesRequest request);1540847035;Same as {@link #concreteIndices(ClusterState, IndicesOptions, String...)}, but the index expressions and options_are encapsulated in the specified request.;public Index[] concreteIndices(ClusterState state, IndicesRequest request) {_        Context context = new Context(state, request.indicesOptions())__        return concreteIndices(context, request.indices())__    };same,as,link,concrete,indices,cluster,state,indices,options,string,but,the,index,expressions,and,options,are,encapsulated,in,the,specified,request;public,index,concrete,indices,cluster,state,state,indices,request,request,context,context,new,context,state,request,indices,options,return,concrete,indices,context,request,indices
IndexNameExpressionResolver -> public Index[] concreteIndices(ClusterState state, IndicesRequest request);1541092382;Same as {@link #concreteIndices(ClusterState, IndicesOptions, String...)}, but the index expressions and options_are encapsulated in the specified request.;public Index[] concreteIndices(ClusterState state, IndicesRequest request) {_        Context context = new Context(state, request.indicesOptions())__        return concreteIndices(context, request.indices())__    };same,as,link,concrete,indices,cluster,state,indices,options,string,but,the,index,expressions,and,options,are,encapsulated,in,the,specified,request;public,index,concrete,indices,cluster,state,state,indices,request,request,context,context,new,context,state,request,indices,options,return,concrete,indices,context,request,indices
IndexNameExpressionResolver -> public Index[] concreteIndices(ClusterState state, IndicesRequest request);1541493930;Same as {@link #concreteIndices(ClusterState, IndicesOptions, String...)}, but the index expressions and options_are encapsulated in the specified request.;public Index[] concreteIndices(ClusterState state, IndicesRequest request) {_        Context context = new Context(state, request.indicesOptions())__        return concreteIndices(context, request.indices())__    };same,as,link,concrete,indices,cluster,state,indices,options,string,but,the,index,expressions,and,options,are,encapsulated,in,the,specified,request;public,index,concrete,indices,cluster,state,state,indices,request,request,context,context,new,context,state,request,indices,options,return,concrete,indices,context,request,indices
IndexNameExpressionResolver -> public Index[] concreteIndices(ClusterState state, IndicesRequest request);1541612607;Same as {@link #concreteIndices(ClusterState, IndicesOptions, String...)}, but the index expressions and options_are encapsulated in the specified request.;public Index[] concreteIndices(ClusterState state, IndicesRequest request) {_        Context context = new Context(state, request.indicesOptions())__        return concreteIndices(context, request.indices())__    };same,as,link,concrete,indices,cluster,state,indices,options,string,but,the,index,expressions,and,options,are,encapsulated,in,the,specified,request;public,index,concrete,indices,cluster,state,state,indices,request,request,context,context,new,context,state,request,indices,options,return,concrete,indices,context,request,indices
IndexNameExpressionResolver -> public Index[] concreteIndices(ClusterState state, IndicesRequest request);1544215214;Same as {@link #concreteIndices(ClusterState, IndicesOptions, String...)}, but the index expressions and options_are encapsulated in the specified request.;public Index[] concreteIndices(ClusterState state, IndicesRequest request) {_        Context context = new Context(state, request.indicesOptions())__        return concreteIndices(context, request.indices())__    };same,as,link,concrete,indices,cluster,state,indices,options,string,but,the,index,expressions,and,options,are,encapsulated,in,the,specified,request;public,index,concrete,indices,cluster,state,state,indices,request,request,context,context,new,context,state,request,indices,options,return,concrete,indices,context,request,indices
IndexNameExpressionResolver -> public Index[] concreteIndices(ClusterState state, IndicesRequest request);1548236405;Same as {@link #concreteIndices(ClusterState, IndicesOptions, String...)}, but the index expressions and options_are encapsulated in the specified request.;public Index[] concreteIndices(ClusterState state, IndicesRequest request) {_        Context context = new Context(state, request.indicesOptions())__        return concreteIndices(context, request.indices())__    };same,as,link,concrete,indices,cluster,state,indices,options,string,but,the,index,expressions,and,options,are,encapsulated,in,the,specified,request;public,index,concrete,indices,cluster,state,state,indices,request,request,context,context,new,context,state,request,indices,options,return,concrete,indices,context,request,indices
IndexNameExpressionResolver -> public String resolveDateMathExpression(String dateExpression);1524684173;@return If the specified string is data math expression then this method returns the resolved expression.;public String resolveDateMathExpression(String dateExpression) {_        _        _        return dateMathExpressionResolver.resolveExpression(dateExpression, new Context(null, null))__    };return,if,the,specified,string,is,data,math,expression,then,this,method,returns,the,resolved,expression;public,string,resolve,date,math,expression,string,date,expression,return,date,math,expression,resolver,resolve,expression,date,expression,new,context,null,null
IndexNameExpressionResolver -> public String resolveDateMathExpression(String dateExpression);1525334055;@return If the specified string is data math expression then this method returns the resolved expression.;public String resolveDateMathExpression(String dateExpression) {_        _        _        return dateMathExpressionResolver.resolveExpression(dateExpression, new Context(null, null))__    };return,if,the,specified,string,is,data,math,expression,then,this,method,returns,the,resolved,expression;public,string,resolve,date,math,expression,string,date,expression,return,date,math,expression,resolver,resolve,expression,date,expression,new,context,null,null
IndexNameExpressionResolver -> public String resolveDateMathExpression(String dateExpression);1532028790;@return If the specified string is data math expression then this method returns the resolved expression.;public String resolveDateMathExpression(String dateExpression) {_        _        _        return dateMathExpressionResolver.resolveExpression(dateExpression, new Context(null, null))__    };return,if,the,specified,string,is,data,math,expression,then,this,method,returns,the,resolved,expression;public,string,resolve,date,math,expression,string,date,expression,return,date,math,expression,resolver,resolve,expression,date,expression,new,context,null,null
IndexNameExpressionResolver -> public String resolveDateMathExpression(String dateExpression);1538067637;@return If the specified string is data math expression then this method returns the resolved expression.;public String resolveDateMathExpression(String dateExpression) {_        _        _        return dateMathExpressionResolver.resolveExpression(dateExpression, new Context(null, null))__    };return,if,the,specified,string,is,data,math,expression,then,this,method,returns,the,resolved,expression;public,string,resolve,date,math,expression,string,date,expression,return,date,math,expression,resolver,resolve,expression,date,expression,new,context,null,null
IndexNameExpressionResolver -> public String resolveDateMathExpression(String dateExpression);1539615817;@return If the specified string is data math expression then this method returns the resolved expression.;public String resolveDateMathExpression(String dateExpression) {_        _        _        return dateMathExpressionResolver.resolveExpression(dateExpression, new Context(null, null))__    };return,if,the,specified,string,is,data,math,expression,then,this,method,returns,the,resolved,expression;public,string,resolve,date,math,expression,string,date,expression,return,date,math,expression,resolver,resolve,expression,date,expression,new,context,null,null
IndexNameExpressionResolver -> public String resolveDateMathExpression(String dateExpression);1540313026;@return If the specified string is data math expression then this method returns the resolved expression.;public String resolveDateMathExpression(String dateExpression) {_        _        _        return dateMathExpressionResolver.resolveExpression(dateExpression, new Context(null, null))__    };return,if,the,specified,string,is,data,math,expression,then,this,method,returns,the,resolved,expression;public,string,resolve,date,math,expression,string,date,expression,return,date,math,expression,resolver,resolve,expression,date,expression,new,context,null,null
IndexNameExpressionResolver -> public String resolveDateMathExpression(String dateExpression);1540847035;@return If the specified string is data math expression then this method returns the resolved expression.;public String resolveDateMathExpression(String dateExpression) {_        _        _        return dateMathExpressionResolver.resolveExpression(dateExpression, new Context(null, null))__    };return,if,the,specified,string,is,data,math,expression,then,this,method,returns,the,resolved,expression;public,string,resolve,date,math,expression,string,date,expression,return,date,math,expression,resolver,resolve,expression,date,expression,new,context,null,null
IndexNameExpressionResolver -> public String resolveDateMathExpression(String dateExpression);1541092382;@return If the specified string is data math expression then this method returns the resolved expression.;public String resolveDateMathExpression(String dateExpression) {_        _        _        return dateMathExpressionResolver.resolveExpression(dateExpression, new Context(null, null))__    };return,if,the,specified,string,is,data,math,expression,then,this,method,returns,the,resolved,expression;public,string,resolve,date,math,expression,string,date,expression,return,date,math,expression,resolver,resolve,expression,date,expression,new,context,null,null
IndexNameExpressionResolver -> public String resolveDateMathExpression(String dateExpression);1541493930;@return If the specified string is data math expression then this method returns the resolved expression.;public String resolveDateMathExpression(String dateExpression) {_        _        _        return dateMathExpressionResolver.resolveExpression(dateExpression, new Context(null, null))__    };return,if,the,specified,string,is,data,math,expression,then,this,method,returns,the,resolved,expression;public,string,resolve,date,math,expression,string,date,expression,return,date,math,expression,resolver,resolve,expression,date,expression,new,context,null,null
IndexNameExpressionResolver -> public String resolveDateMathExpression(String dateExpression);1541612607;@return If the specified string is data math expression then this method returns the resolved expression.;public String resolveDateMathExpression(String dateExpression) {_        _        _        return dateMathExpressionResolver.resolveExpression(dateExpression, new Context(null, null))__    };return,if,the,specified,string,is,data,math,expression,then,this,method,returns,the,resolved,expression;public,string,resolve,date,math,expression,string,date,expression,return,date,math,expression,resolver,resolve,expression,date,expression,new,context,null,null
IndexNameExpressionResolver -> public String resolveDateMathExpression(String dateExpression);1544215214;@return If the specified string is data math expression then this method returns the resolved expression.;public String resolveDateMathExpression(String dateExpression) {_        _        _        return dateMathExpressionResolver.resolveExpression(dateExpression, new Context(null, null))__    };return,if,the,specified,string,is,data,math,expression,then,this,method,returns,the,resolved,expression;public,string,resolve,date,math,expression,string,date,expression,return,date,math,expression,resolver,resolve,expression,date,expression,new,context,null,null
IndexNameExpressionResolver -> public String resolveDateMathExpression(String dateExpression);1548236405;@return If the specified string is data math expression then this method returns the resolved expression.;public String resolveDateMathExpression(String dateExpression) {_        _        _        return dateMathExpressionResolver.resolveExpression(dateExpression, new Context(null, null))__    };return,if,the,specified,string,is,data,math,expression,then,this,method,returns,the,resolved,expression;public,string,resolve,date,math,expression,string,date,expression,return,date,math,expression,resolver,resolve,expression,date,expression,new,context,null,null
IndexNameExpressionResolver -> public String[] filteringAliases(ClusterState state, String index, String... expressions);1524684173;Iterates through the list of indices and selects the effective list of filtering aliases for the_given index._<p>Only aliases with filters are returned. If the indices list contains a non-filtering reference to_the index itself - null is returned. Returns <tt>null</tt> if no filtering is required.;public String[] filteringAliases(ClusterState state, String index, String... expressions) {_        return indexAliases(state, index, AliasMetaData::filteringRequired, false, expressions)__    };iterates,through,the,list,of,indices,and,selects,the,effective,list,of,filtering,aliases,for,the,given,index,p,only,aliases,with,filters,are,returned,if,the,indices,list,contains,a,non,filtering,reference,to,the,index,itself,null,is,returned,returns,tt,null,tt,if,no,filtering,is,required;public,string,filtering,aliases,cluster,state,state,string,index,string,expressions,return,index,aliases,state,index,alias,meta,data,filtering,required,false,expressions
IndexNameExpressionResolver -> public String[] filteringAliases(ClusterState state, String index, String... expressions);1525334055;Iterates through the list of indices and selects the effective list of filtering aliases for the_given index._<p>Only aliases with filters are returned. If the indices list contains a non-filtering reference to_the index itself - null is returned. Returns {@code null} if no filtering is required.;public String[] filteringAliases(ClusterState state, String index, String... expressions) {_        return indexAliases(state, index, AliasMetaData::filteringRequired, false, expressions)__    };iterates,through,the,list,of,indices,and,selects,the,effective,list,of,filtering,aliases,for,the,given,index,p,only,aliases,with,filters,are,returned,if,the,indices,list,contains,a,non,filtering,reference,to,the,index,itself,null,is,returned,returns,code,null,if,no,filtering,is,required;public,string,filtering,aliases,cluster,state,state,string,index,string,expressions,return,index,aliases,state,index,alias,meta,data,filtering,required,false,expressions
IndexNameExpressionResolver -> public String[] filteringAliases(ClusterState state, String index, String... expressions);1532028790;Iterates through the list of indices and selects the effective list of filtering aliases for the_given index._<p>Only aliases with filters are returned. If the indices list contains a non-filtering reference to_the index itself - null is returned. Returns {@code null} if no filtering is required.;public String[] filteringAliases(ClusterState state, String index, String... expressions) {_        return indexAliases(state, index, AliasMetaData::filteringRequired, false, expressions)__    };iterates,through,the,list,of,indices,and,selects,the,effective,list,of,filtering,aliases,for,the,given,index,p,only,aliases,with,filters,are,returned,if,the,indices,list,contains,a,non,filtering,reference,to,the,index,itself,null,is,returned,returns,code,null,if,no,filtering,is,required;public,string,filtering,aliases,cluster,state,state,string,index,string,expressions,return,index,aliases,state,index,alias,meta,data,filtering,required,false,expressions
IndexNameExpressionResolver -> public String[] filteringAliases(ClusterState state, String index, String... expressions);1538067637;Iterates through the list of indices and selects the effective list of filtering aliases for the_given index._<p>Only aliases with filters are returned. If the indices list contains a non-filtering reference to_the index itself - null is returned. Returns {@code null} if no filtering is required.;public String[] filteringAliases(ClusterState state, String index, String... expressions) {_        return indexAliases(state, index, AliasMetaData::filteringRequired, false, expressions)__    };iterates,through,the,list,of,indices,and,selects,the,effective,list,of,filtering,aliases,for,the,given,index,p,only,aliases,with,filters,are,returned,if,the,indices,list,contains,a,non,filtering,reference,to,the,index,itself,null,is,returned,returns,code,null,if,no,filtering,is,required;public,string,filtering,aliases,cluster,state,state,string,index,string,expressions,return,index,aliases,state,index,alias,meta,data,filtering,required,false,expressions
IndexNameExpressionResolver -> public String[] filteringAliases(ClusterState state, String index, String... expressions);1539615817;Iterates through the list of indices and selects the effective list of filtering aliases for the_given index._<p>Only aliases with filters are returned. If the indices list contains a non-filtering reference to_the index itself - null is returned. Returns {@code null} if no filtering is required.;public String[] filteringAliases(ClusterState state, String index, String... expressions) {_        return indexAliases(state, index, AliasMetaData::filteringRequired, false, expressions)__    };iterates,through,the,list,of,indices,and,selects,the,effective,list,of,filtering,aliases,for,the,given,index,p,only,aliases,with,filters,are,returned,if,the,indices,list,contains,a,non,filtering,reference,to,the,index,itself,null,is,returned,returns,code,null,if,no,filtering,is,required;public,string,filtering,aliases,cluster,state,state,string,index,string,expressions,return,index,aliases,state,index,alias,meta,data,filtering,required,false,expressions
IndexNameExpressionResolver -> public String[] filteringAliases(ClusterState state, String index, String... expressions);1540313026;Iterates through the list of indices and selects the effective list of filtering aliases for the_given index._<p>Only aliases with filters are returned. If the indices list contains a non-filtering reference to_the index itself - null is returned. Returns {@code null} if no filtering is required.;public String[] filteringAliases(ClusterState state, String index, String... expressions) {_        return indexAliases(state, index, AliasMetaData::filteringRequired, false, expressions)__    };iterates,through,the,list,of,indices,and,selects,the,effective,list,of,filtering,aliases,for,the,given,index,p,only,aliases,with,filters,are,returned,if,the,indices,list,contains,a,non,filtering,reference,to,the,index,itself,null,is,returned,returns,code,null,if,no,filtering,is,required;public,string,filtering,aliases,cluster,state,state,string,index,string,expressions,return,index,aliases,state,index,alias,meta,data,filtering,required,false,expressions
IndexNameExpressionResolver -> public String[] filteringAliases(ClusterState state, String index, String... expressions);1540847035;Iterates through the list of indices and selects the effective list of filtering aliases for the_given index._<p>Only aliases with filters are returned. If the indices list contains a non-filtering reference to_the index itself - null is returned. Returns {@code null} if no filtering is required.;public String[] filteringAliases(ClusterState state, String index, String... expressions) {_        return indexAliases(state, index, AliasMetaData::filteringRequired, false, expressions)__    };iterates,through,the,list,of,indices,and,selects,the,effective,list,of,filtering,aliases,for,the,given,index,p,only,aliases,with,filters,are,returned,if,the,indices,list,contains,a,non,filtering,reference,to,the,index,itself,null,is,returned,returns,code,null,if,no,filtering,is,required;public,string,filtering,aliases,cluster,state,state,string,index,string,expressions,return,index,aliases,state,index,alias,meta,data,filtering,required,false,expressions
IndexNameExpressionResolver -> public String[] filteringAliases(ClusterState state, String index, String... expressions);1541092382;Iterates through the list of indices and selects the effective list of filtering aliases for the_given index._<p>Only aliases with filters are returned. If the indices list contains a non-filtering reference to_the index itself - null is returned. Returns {@code null} if no filtering is required.;public String[] filteringAliases(ClusterState state, String index, String... expressions) {_        return indexAliases(state, index, AliasMetaData::filteringRequired, false, expressions)__    };iterates,through,the,list,of,indices,and,selects,the,effective,list,of,filtering,aliases,for,the,given,index,p,only,aliases,with,filters,are,returned,if,the,indices,list,contains,a,non,filtering,reference,to,the,index,itself,null,is,returned,returns,code,null,if,no,filtering,is,required;public,string,filtering,aliases,cluster,state,state,string,index,string,expressions,return,index,aliases,state,index,alias,meta,data,filtering,required,false,expressions
IndexNameExpressionResolver -> public String[] filteringAliases(ClusterState state, String index, String... expressions);1541493930;Iterates through the list of indices and selects the effective list of filtering aliases for the_given index._<p>Only aliases with filters are returned. If the indices list contains a non-filtering reference to_the index itself - null is returned. Returns {@code null} if no filtering is required.;public String[] filteringAliases(ClusterState state, String index, String... expressions) {_        return indexAliases(state, index, AliasMetaData::filteringRequired, false, expressions)__    };iterates,through,the,list,of,indices,and,selects,the,effective,list,of,filtering,aliases,for,the,given,index,p,only,aliases,with,filters,are,returned,if,the,indices,list,contains,a,non,filtering,reference,to,the,index,itself,null,is,returned,returns,code,null,if,no,filtering,is,required;public,string,filtering,aliases,cluster,state,state,string,index,string,expressions,return,index,aliases,state,index,alias,meta,data,filtering,required,false,expressions
IndexNameExpressionResolver -> public String[] filteringAliases(ClusterState state, String index, String... expressions);1541612607;Iterates through the list of indices and selects the effective list of filtering aliases for the_given index._<p>Only aliases with filters are returned. If the indices list contains a non-filtering reference to_the index itself - null is returned. Returns {@code null} if no filtering is required.;public String[] filteringAliases(ClusterState state, String index, String... expressions) {_        return indexAliases(state, index, AliasMetaData::filteringRequired, false, expressions)__    };iterates,through,the,list,of,indices,and,selects,the,effective,list,of,filtering,aliases,for,the,given,index,p,only,aliases,with,filters,are,returned,if,the,indices,list,contains,a,non,filtering,reference,to,the,index,itself,null,is,returned,returns,code,null,if,no,filtering,is,required;public,string,filtering,aliases,cluster,state,state,string,index,string,expressions,return,index,aliases,state,index,alias,meta,data,filtering,required,false,expressions
IndexNameExpressionResolver -> public String[] filteringAliases(ClusterState state, String index, String... expressions);1544215214;Iterates through the list of indices and selects the effective list of filtering aliases for the_given index._<p>Only aliases with filters are returned. If the indices list contains a non-filtering reference to_the index itself - null is returned. Returns {@code null} if no filtering is required.;public String[] filteringAliases(ClusterState state, String index, String... expressions) {_        return indexAliases(state, index, AliasMetaData::filteringRequired, false, expressions)__    };iterates,through,the,list,of,indices,and,selects,the,effective,list,of,filtering,aliases,for,the,given,index,p,only,aliases,with,filters,are,returned,if,the,indices,list,contains,a,non,filtering,reference,to,the,index,itself,null,is,returned,returns,code,null,if,no,filtering,is,required;public,string,filtering,aliases,cluster,state,state,string,index,string,expressions,return,index,aliases,state,index,alias,meta,data,filtering,required,false,expressions
IndexNameExpressionResolver -> public String[] filteringAliases(ClusterState state, String index, String... expressions);1548236405;Iterates through the list of indices and selects the effective list of filtering aliases for the_given index._<p>Only aliases with filters are returned. If the indices list contains a non-filtering reference to_the index itself - null is returned. Returns {@code null} if no filtering is required.;public String[] filteringAliases(ClusterState state, String index, String... expressions) {_        return indexAliases(state, index, AliasMetaData::filteringRequired, false, expressions)__    };iterates,through,the,list,of,indices,and,selects,the,effective,list,of,filtering,aliases,for,the,given,index,p,only,aliases,with,filters,are,returned,if,the,indices,list,contains,a,non,filtering,reference,to,the,index,itself,null,is,returned,returns,code,null,if,no,filtering,is,required;public,string,filtering,aliases,cluster,state,state,string,index,string,expressions,return,index,aliases,state,index,alias,meta,data,filtering,required,false,expressions
IndexNameExpressionResolver -> ExpressionResolver -> List<String> resolve(Context context, List<String> expressions)_;1524684173;Resolves the list of expressions into other expressions if possible (possible concrete indices and aliases, but_that isn't required). The provided implementations can also be left untouched.__@return a new list with expressions based on the provided expressions;List<String> resolve(Context context, List<String> expressions)_;resolves,the,list,of,expressions,into,other,expressions,if,possible,possible,concrete,indices,and,aliases,but,that,isn,t,required,the,provided,implementations,can,also,be,left,untouched,return,a,new,list,with,expressions,based,on,the,provided,expressions;list,string,resolve,context,context,list,string,expressions
IndexNameExpressionResolver -> ExpressionResolver -> List<String> resolve(Context context, List<String> expressions)_;1525334055;Resolves the list of expressions into other expressions if possible (possible concrete indices and aliases, but_that isn't required). The provided implementations can also be left untouched.__@return a new list with expressions based on the provided expressions;List<String> resolve(Context context, List<String> expressions)_;resolves,the,list,of,expressions,into,other,expressions,if,possible,possible,concrete,indices,and,aliases,but,that,isn,t,required,the,provided,implementations,can,also,be,left,untouched,return,a,new,list,with,expressions,based,on,the,provided,expressions;list,string,resolve,context,context,list,string,expressions
IndexNameExpressionResolver -> ExpressionResolver -> List<String> resolve(Context context, List<String> expressions)_;1532028790;Resolves the list of expressions into other expressions if possible (possible concrete indices and aliases, but_that isn't required). The provided implementations can also be left untouched.__@return a new list with expressions based on the provided expressions;List<String> resolve(Context context, List<String> expressions)_;resolves,the,list,of,expressions,into,other,expressions,if,possible,possible,concrete,indices,and,aliases,but,that,isn,t,required,the,provided,implementations,can,also,be,left,untouched,return,a,new,list,with,expressions,based,on,the,provided,expressions;list,string,resolve,context,context,list,string,expressions
IndexNameExpressionResolver -> ExpressionResolver -> List<String> resolve(Context context, List<String> expressions)_;1538067637;Resolves the list of expressions into other expressions if possible (possible concrete indices and aliases, but_that isn't required). The provided implementations can also be left untouched.__@return a new list with expressions based on the provided expressions;List<String> resolve(Context context, List<String> expressions)_;resolves,the,list,of,expressions,into,other,expressions,if,possible,possible,concrete,indices,and,aliases,but,that,isn,t,required,the,provided,implementations,can,also,be,left,untouched,return,a,new,list,with,expressions,based,on,the,provided,expressions;list,string,resolve,context,context,list,string,expressions
IndexNameExpressionResolver -> ExpressionResolver -> List<String> resolve(Context context, List<String> expressions)_;1539615817;Resolves the list of expressions into other expressions if possible (possible concrete indices and aliases, but_that isn't required). The provided implementations can also be left untouched.__@return a new list with expressions based on the provided expressions;List<String> resolve(Context context, List<String> expressions)_;resolves,the,list,of,expressions,into,other,expressions,if,possible,possible,concrete,indices,and,aliases,but,that,isn,t,required,the,provided,implementations,can,also,be,left,untouched,return,a,new,list,with,expressions,based,on,the,provided,expressions;list,string,resolve,context,context,list,string,expressions
IndexNameExpressionResolver -> ExpressionResolver -> List<String> resolve(Context context, List<String> expressions)_;1540313026;Resolves the list of expressions into other expressions if possible (possible concrete indices and aliases, but_that isn't required). The provided implementations can also be left untouched.__@return a new list with expressions based on the provided expressions;List<String> resolve(Context context, List<String> expressions)_;resolves,the,list,of,expressions,into,other,expressions,if,possible,possible,concrete,indices,and,aliases,but,that,isn,t,required,the,provided,implementations,can,also,be,left,untouched,return,a,new,list,with,expressions,based,on,the,provided,expressions;list,string,resolve,context,context,list,string,expressions
IndexNameExpressionResolver -> ExpressionResolver -> List<String> resolve(Context context, List<String> expressions)_;1540847035;Resolves the list of expressions into other expressions if possible (possible concrete indices and aliases, but_that isn't required). The provided implementations can also be left untouched.__@return a new list with expressions based on the provided expressions;List<String> resolve(Context context, List<String> expressions)_;resolves,the,list,of,expressions,into,other,expressions,if,possible,possible,concrete,indices,and,aliases,but,that,isn,t,required,the,provided,implementations,can,also,be,left,untouched,return,a,new,list,with,expressions,based,on,the,provided,expressions;list,string,resolve,context,context,list,string,expressions
IndexNameExpressionResolver -> ExpressionResolver -> List<String> resolve(Context context, List<String> expressions)_;1541092382;Resolves the list of expressions into other expressions if possible (possible concrete indices and aliases, but_that isn't required). The provided implementations can also be left untouched.__@return a new list with expressions based on the provided expressions;List<String> resolve(Context context, List<String> expressions)_;resolves,the,list,of,expressions,into,other,expressions,if,possible,possible,concrete,indices,and,aliases,but,that,isn,t,required,the,provided,implementations,can,also,be,left,untouched,return,a,new,list,with,expressions,based,on,the,provided,expressions;list,string,resolve,context,context,list,string,expressions
IndexNameExpressionResolver -> ExpressionResolver -> List<String> resolve(Context context, List<String> expressions)_;1541493930;Resolves the list of expressions into other expressions if possible (possible concrete indices and aliases, but_that isn't required). The provided implementations can also be left untouched.__@return a new list with expressions based on the provided expressions;List<String> resolve(Context context, List<String> expressions)_;resolves,the,list,of,expressions,into,other,expressions,if,possible,possible,concrete,indices,and,aliases,but,that,isn,t,required,the,provided,implementations,can,also,be,left,untouched,return,a,new,list,with,expressions,based,on,the,provided,expressions;list,string,resolve,context,context,list,string,expressions
IndexNameExpressionResolver -> ExpressionResolver -> List<String> resolve(Context context, List<String> expressions)_;1541612607;Resolves the list of expressions into other expressions if possible (possible concrete indices and aliases, but_that isn't required). The provided implementations can also be left untouched.__@return a new list with expressions based on the provided expressions;List<String> resolve(Context context, List<String> expressions)_;resolves,the,list,of,expressions,into,other,expressions,if,possible,possible,concrete,indices,and,aliases,but,that,isn,t,required,the,provided,implementations,can,also,be,left,untouched,return,a,new,list,with,expressions,based,on,the,provided,expressions;list,string,resolve,context,context,list,string,expressions
IndexNameExpressionResolver -> ExpressionResolver -> List<String> resolve(Context context, List<String> expressions)_;1544215214;Resolves the list of expressions into other expressions if possible (possible concrete indices and aliases, but_that isn't required). The provided implementations can also be left untouched.__@return a new list with expressions based on the provided expressions;List<String> resolve(Context context, List<String> expressions)_;resolves,the,list,of,expressions,into,other,expressions,if,possible,possible,concrete,indices,and,aliases,but,that,isn,t,required,the,provided,implementations,can,also,be,left,untouched,return,a,new,list,with,expressions,based,on,the,provided,expressions;list,string,resolve,context,context,list,string,expressions
IndexNameExpressionResolver -> ExpressionResolver -> List<String> resolve(Context context, List<String> expressions)_;1548236405;Resolves the list of expressions into other expressions if possible (possible concrete indices and aliases, but_that isn't required). The provided implementations can also be left untouched.__@return a new list with expressions based on the provided expressions;List<String> resolve(Context context, List<String> expressions)_;resolves,the,list,of,expressions,into,other,expressions,if,possible,possible,concrete,indices,and,aliases,but,that,isn,t,required,the,provided,implementations,can,also,be,left,untouched,return,a,new,list,with,expressions,based,on,the,provided,expressions;list,string,resolve,context,context,list,string,expressions
IndexNameExpressionResolver -> public boolean hasIndexOrAlias(String aliasOrIndex, ClusterState state);1524684173;@return whether the specified alias or index exists. If the alias or index contains datemath then that is resolved too.;public boolean hasIndexOrAlias(String aliasOrIndex, ClusterState state) {_        Context context = new Context(state, IndicesOptions.lenientExpandOpen())__        String resolvedAliasOrIndex = dateMathExpressionResolver.resolveExpression(aliasOrIndex, context)__        return state.metaData().getAliasAndIndexLookup().containsKey(resolvedAliasOrIndex)__    };return,whether,the,specified,alias,or,index,exists,if,the,alias,or,index,contains,datemath,then,that,is,resolved,too;public,boolean,has,index,or,alias,string,alias,or,index,cluster,state,state,context,context,new,context,state,indices,options,lenient,expand,open,string,resolved,alias,or,index,date,math,expression,resolver,resolve,expression,alias,or,index,context,return,state,meta,data,get,alias,and,index,lookup,contains,key,resolved,alias,or,index
IndexNameExpressionResolver -> public boolean hasIndexOrAlias(String aliasOrIndex, ClusterState state);1525334055;@return whether the specified alias or index exists. If the alias or index contains datemath then that is resolved too.;public boolean hasIndexOrAlias(String aliasOrIndex, ClusterState state) {_        Context context = new Context(state, IndicesOptions.lenientExpandOpen())__        String resolvedAliasOrIndex = dateMathExpressionResolver.resolveExpression(aliasOrIndex, context)__        return state.metaData().getAliasAndIndexLookup().containsKey(resolvedAliasOrIndex)__    };return,whether,the,specified,alias,or,index,exists,if,the,alias,or,index,contains,datemath,then,that,is,resolved,too;public,boolean,has,index,or,alias,string,alias,or,index,cluster,state,state,context,context,new,context,state,indices,options,lenient,expand,open,string,resolved,alias,or,index,date,math,expression,resolver,resolve,expression,alias,or,index,context,return,state,meta,data,get,alias,and,index,lookup,contains,key,resolved,alias,or,index
IndexNameExpressionResolver -> public boolean hasIndexOrAlias(String aliasOrIndex, ClusterState state);1532028790;@return whether the specified alias or index exists. If the alias or index contains datemath then that is resolved too.;public boolean hasIndexOrAlias(String aliasOrIndex, ClusterState state) {_        Context context = new Context(state, IndicesOptions.lenientExpandOpen())__        String resolvedAliasOrIndex = dateMathExpressionResolver.resolveExpression(aliasOrIndex, context)__        return state.metaData().getAliasAndIndexLookup().containsKey(resolvedAliasOrIndex)__    };return,whether,the,specified,alias,or,index,exists,if,the,alias,or,index,contains,datemath,then,that,is,resolved,too;public,boolean,has,index,or,alias,string,alias,or,index,cluster,state,state,context,context,new,context,state,indices,options,lenient,expand,open,string,resolved,alias,or,index,date,math,expression,resolver,resolve,expression,alias,or,index,context,return,state,meta,data,get,alias,and,index,lookup,contains,key,resolved,alias,or,index
IndexNameExpressionResolver -> public boolean hasIndexOrAlias(String aliasOrIndex, ClusterState state);1538067637;@return whether the specified alias or index exists. If the alias or index contains datemath then that is resolved too.;public boolean hasIndexOrAlias(String aliasOrIndex, ClusterState state) {_        Context context = new Context(state, IndicesOptions.lenientExpandOpen())__        String resolvedAliasOrIndex = dateMathExpressionResolver.resolveExpression(aliasOrIndex, context)__        return state.metaData().getAliasAndIndexLookup().containsKey(resolvedAliasOrIndex)__    };return,whether,the,specified,alias,or,index,exists,if,the,alias,or,index,contains,datemath,then,that,is,resolved,too;public,boolean,has,index,or,alias,string,alias,or,index,cluster,state,state,context,context,new,context,state,indices,options,lenient,expand,open,string,resolved,alias,or,index,date,math,expression,resolver,resolve,expression,alias,or,index,context,return,state,meta,data,get,alias,and,index,lookup,contains,key,resolved,alias,or,index
IndexNameExpressionResolver -> public boolean hasIndexOrAlias(String aliasOrIndex, ClusterState state);1539615817;@return whether the specified alias or index exists. If the alias or index contains datemath then that is resolved too.;public boolean hasIndexOrAlias(String aliasOrIndex, ClusterState state) {_        Context context = new Context(state, IndicesOptions.lenientExpandOpen())__        String resolvedAliasOrIndex = dateMathExpressionResolver.resolveExpression(aliasOrIndex, context)__        return state.metaData().getAliasAndIndexLookup().containsKey(resolvedAliasOrIndex)__    };return,whether,the,specified,alias,or,index,exists,if,the,alias,or,index,contains,datemath,then,that,is,resolved,too;public,boolean,has,index,or,alias,string,alias,or,index,cluster,state,state,context,context,new,context,state,indices,options,lenient,expand,open,string,resolved,alias,or,index,date,math,expression,resolver,resolve,expression,alias,or,index,context,return,state,meta,data,get,alias,and,index,lookup,contains,key,resolved,alias,or,index
IndexNameExpressionResolver -> public boolean hasIndexOrAlias(String aliasOrIndex, ClusterState state);1540313026;@return whether the specified alias or index exists. If the alias or index contains datemath then that is resolved too.;public boolean hasIndexOrAlias(String aliasOrIndex, ClusterState state) {_        Context context = new Context(state, IndicesOptions.lenientExpandOpen())__        String resolvedAliasOrIndex = dateMathExpressionResolver.resolveExpression(aliasOrIndex, context)__        return state.metaData().getAliasAndIndexLookup().containsKey(resolvedAliasOrIndex)__    };return,whether,the,specified,alias,or,index,exists,if,the,alias,or,index,contains,datemath,then,that,is,resolved,too;public,boolean,has,index,or,alias,string,alias,or,index,cluster,state,state,context,context,new,context,state,indices,options,lenient,expand,open,string,resolved,alias,or,index,date,math,expression,resolver,resolve,expression,alias,or,index,context,return,state,meta,data,get,alias,and,index,lookup,contains,key,resolved,alias,or,index
IndexNameExpressionResolver -> public boolean hasIndexOrAlias(String aliasOrIndex, ClusterState state);1540847035;@return whether the specified alias or index exists. If the alias or index contains datemath then that is resolved too.;public boolean hasIndexOrAlias(String aliasOrIndex, ClusterState state) {_        Context context = new Context(state, IndicesOptions.lenientExpandOpen())__        String resolvedAliasOrIndex = dateMathExpressionResolver.resolveExpression(aliasOrIndex, context)__        return state.metaData().getAliasAndIndexLookup().containsKey(resolvedAliasOrIndex)__    };return,whether,the,specified,alias,or,index,exists,if,the,alias,or,index,contains,datemath,then,that,is,resolved,too;public,boolean,has,index,or,alias,string,alias,or,index,cluster,state,state,context,context,new,context,state,indices,options,lenient,expand,open,string,resolved,alias,or,index,date,math,expression,resolver,resolve,expression,alias,or,index,context,return,state,meta,data,get,alias,and,index,lookup,contains,key,resolved,alias,or,index
IndexNameExpressionResolver -> public boolean hasIndexOrAlias(String aliasOrIndex, ClusterState state);1541092382;@return whether the specified alias or index exists. If the alias or index contains datemath then that is resolved too.;public boolean hasIndexOrAlias(String aliasOrIndex, ClusterState state) {_        Context context = new Context(state, IndicesOptions.lenientExpandOpen())__        String resolvedAliasOrIndex = dateMathExpressionResolver.resolveExpression(aliasOrIndex, context)__        return state.metaData().getAliasAndIndexLookup().containsKey(resolvedAliasOrIndex)__    };return,whether,the,specified,alias,or,index,exists,if,the,alias,or,index,contains,datemath,then,that,is,resolved,too;public,boolean,has,index,or,alias,string,alias,or,index,cluster,state,state,context,context,new,context,state,indices,options,lenient,expand,open,string,resolved,alias,or,index,date,math,expression,resolver,resolve,expression,alias,or,index,context,return,state,meta,data,get,alias,and,index,lookup,contains,key,resolved,alias,or,index
IndexNameExpressionResolver -> public boolean hasIndexOrAlias(String aliasOrIndex, ClusterState state);1541493930;@return whether the specified alias or index exists. If the alias or index contains datemath then that is resolved too.;public boolean hasIndexOrAlias(String aliasOrIndex, ClusterState state) {_        Context context = new Context(state, IndicesOptions.lenientExpandOpen())__        String resolvedAliasOrIndex = dateMathExpressionResolver.resolveExpression(aliasOrIndex, context)__        return state.metaData().getAliasAndIndexLookup().containsKey(resolvedAliasOrIndex)__    };return,whether,the,specified,alias,or,index,exists,if,the,alias,or,index,contains,datemath,then,that,is,resolved,too;public,boolean,has,index,or,alias,string,alias,or,index,cluster,state,state,context,context,new,context,state,indices,options,lenient,expand,open,string,resolved,alias,or,index,date,math,expression,resolver,resolve,expression,alias,or,index,context,return,state,meta,data,get,alias,and,index,lookup,contains,key,resolved,alias,or,index
IndexNameExpressionResolver -> public boolean hasIndexOrAlias(String aliasOrIndex, ClusterState state);1541612607;@return whether the specified alias or index exists. If the alias or index contains datemath then that is resolved too.;public boolean hasIndexOrAlias(String aliasOrIndex, ClusterState state) {_        Context context = new Context(state, IndicesOptions.lenientExpandOpen())__        String resolvedAliasOrIndex = dateMathExpressionResolver.resolveExpression(aliasOrIndex, context)__        return state.metaData().getAliasAndIndexLookup().containsKey(resolvedAliasOrIndex)__    };return,whether,the,specified,alias,or,index,exists,if,the,alias,or,index,contains,datemath,then,that,is,resolved,too;public,boolean,has,index,or,alias,string,alias,or,index,cluster,state,state,context,context,new,context,state,indices,options,lenient,expand,open,string,resolved,alias,or,index,date,math,expression,resolver,resolve,expression,alias,or,index,context,return,state,meta,data,get,alias,and,index,lookup,contains,key,resolved,alias,or,index
IndexNameExpressionResolver -> public boolean hasIndexOrAlias(String aliasOrIndex, ClusterState state);1544215214;@return whether the specified alias or index exists. If the alias or index contains datemath then that is resolved too.;public boolean hasIndexOrAlias(String aliasOrIndex, ClusterState state) {_        Context context = new Context(state, IndicesOptions.lenientExpandOpen())__        String resolvedAliasOrIndex = dateMathExpressionResolver.resolveExpression(aliasOrIndex, context)__        return state.metaData().getAliasAndIndexLookup().containsKey(resolvedAliasOrIndex)__    };return,whether,the,specified,alias,or,index,exists,if,the,alias,or,index,contains,datemath,then,that,is,resolved,too;public,boolean,has,index,or,alias,string,alias,or,index,cluster,state,state,context,context,new,context,state,indices,options,lenient,expand,open,string,resolved,alias,or,index,date,math,expression,resolver,resolve,expression,alias,or,index,context,return,state,meta,data,get,alias,and,index,lookup,contains,key,resolved,alias,or,index
IndexNameExpressionResolver -> public boolean hasIndexOrAlias(String aliasOrIndex, ClusterState state);1548236405;@return whether the specified alias or index exists. If the alias or index contains datemath then that is resolved too.;public boolean hasIndexOrAlias(String aliasOrIndex, ClusterState state) {_        Context context = new Context(state, IndicesOptions.lenientExpandOpen())__        String resolvedAliasOrIndex = dateMathExpressionResolver.resolveExpression(aliasOrIndex, context)__        return state.metaData().getAliasAndIndexLookup().containsKey(resolvedAliasOrIndex)__    };return,whether,the,specified,alias,or,index,exists,if,the,alias,or,index,contains,datemath,then,that,is,resolved,too;public,boolean,has,index,or,alias,string,alias,or,index,cluster,state,state,context,context,new,context,state,indices,options,lenient,expand,open,string,resolved,alias,or,index,date,math,expression,resolver,resolve,expression,alias,or,index,context,return,state,meta,data,get,alias,and,index,lookup,contains,key,resolved,alias,or,index
IndexNameExpressionResolver -> public Index[] concreteIndices(ClusterState state, IndicesOptions options, long startTime, String... indexExpressions);1524684173;Translates the provided index expression into actual concrete indices, properly deduplicated.__@param state             the cluster state containing all the data to resolve to expressions to concrete indices_@param options           defines how the aliases or indices need to be resolved to concrete indices_@param startTime         The start of the request where concrete indices is being invoked for_@param indexExpressions  expressions that can be resolved to alias or index names._@return the resolved concrete indices based on the cluster state, indices options and index expressions_provided indices options in the context don't allow such a case, or if the final result of the indices resolution_contains no indices and the indices options in the context don't allow such a case._@throws IllegalArgumentException if one of the aliases resolve to multiple indices and the provided_indices options in the context don't allow such a case.;public Index[] concreteIndices(ClusterState state, IndicesOptions options, long startTime, String... indexExpressions) {_        Context context = new Context(state, options, startTime)__        return concreteIndices(context, indexExpressions)__    };translates,the,provided,index,expression,into,actual,concrete,indices,properly,deduplicated,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expressions,to,concrete,indices,param,options,defines,how,the,aliases,or,indices,need,to,be,resolved,to,concrete,indices,param,start,time,the,start,of,the,request,where,concrete,indices,is,being,invoked,for,param,index,expressions,expressions,that,can,be,resolved,to,alias,or,index,names,return,the,resolved,concrete,indices,based,on,the,cluster,state,indices,options,and,index,expressions,provided,indices,options,in,the,context,don,t,allow,such,a,case,or,if,the,final,result,of,the,indices,resolution,contains,no,indices,and,the,indices,options,in,the,context,don,t,allow,such,a,case,throws,illegal,argument,exception,if,one,of,the,aliases,resolve,to,multiple,indices,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case;public,index,concrete,indices,cluster,state,state,indices,options,options,long,start,time,string,index,expressions,context,context,new,context,state,options,start,time,return,concrete,indices,context,index,expressions
IndexNameExpressionResolver -> public Index[] concreteIndices(ClusterState state, IndicesOptions options, long startTime, String... indexExpressions);1525334055;Translates the provided index expression into actual concrete indices, properly deduplicated.__@param state             the cluster state containing all the data to resolve to expressions to concrete indices_@param options           defines how the aliases or indices need to be resolved to concrete indices_@param startTime         The start of the request where concrete indices is being invoked for_@param indexExpressions  expressions that can be resolved to alias or index names._@return the resolved concrete indices based on the cluster state, indices options and index expressions_provided indices options in the context don't allow such a case, or if the final result of the indices resolution_contains no indices and the indices options in the context don't allow such a case._@throws IllegalArgumentException if one of the aliases resolve to multiple indices and the provided_indices options in the context don't allow such a case.;public Index[] concreteIndices(ClusterState state, IndicesOptions options, long startTime, String... indexExpressions) {_        Context context = new Context(state, options, startTime)__        return concreteIndices(context, indexExpressions)__    };translates,the,provided,index,expression,into,actual,concrete,indices,properly,deduplicated,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expressions,to,concrete,indices,param,options,defines,how,the,aliases,or,indices,need,to,be,resolved,to,concrete,indices,param,start,time,the,start,of,the,request,where,concrete,indices,is,being,invoked,for,param,index,expressions,expressions,that,can,be,resolved,to,alias,or,index,names,return,the,resolved,concrete,indices,based,on,the,cluster,state,indices,options,and,index,expressions,provided,indices,options,in,the,context,don,t,allow,such,a,case,or,if,the,final,result,of,the,indices,resolution,contains,no,indices,and,the,indices,options,in,the,context,don,t,allow,such,a,case,throws,illegal,argument,exception,if,one,of,the,aliases,resolve,to,multiple,indices,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case;public,index,concrete,indices,cluster,state,state,indices,options,options,long,start,time,string,index,expressions,context,context,new,context,state,options,start,time,return,concrete,indices,context,index,expressions
IndexNameExpressionResolver -> public Index[] concreteIndices(ClusterState state, IndicesOptions options, long startTime, String... indexExpressions);1532028790;Translates the provided index expression into actual concrete indices, properly deduplicated.__@param state             the cluster state containing all the data to resolve to expressions to concrete indices_@param options           defines how the aliases or indices need to be resolved to concrete indices_@param startTime         The start of the request where concrete indices is being invoked for_@param indexExpressions  expressions that can be resolved to alias or index names._@return the resolved concrete indices based on the cluster state, indices options and index expressions_provided indices options in the context don't allow such a case, or if the final result of the indices resolution_contains no indices and the indices options in the context don't allow such a case._@throws IllegalArgumentException if one of the aliases resolve to multiple indices and the provided_indices options in the context don't allow such a case.;public Index[] concreteIndices(ClusterState state, IndicesOptions options, long startTime, String... indexExpressions) {_        Context context = new Context(state, options, startTime)__        return concreteIndices(context, indexExpressions)__    };translates,the,provided,index,expression,into,actual,concrete,indices,properly,deduplicated,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expressions,to,concrete,indices,param,options,defines,how,the,aliases,or,indices,need,to,be,resolved,to,concrete,indices,param,start,time,the,start,of,the,request,where,concrete,indices,is,being,invoked,for,param,index,expressions,expressions,that,can,be,resolved,to,alias,or,index,names,return,the,resolved,concrete,indices,based,on,the,cluster,state,indices,options,and,index,expressions,provided,indices,options,in,the,context,don,t,allow,such,a,case,or,if,the,final,result,of,the,indices,resolution,contains,no,indices,and,the,indices,options,in,the,context,don,t,allow,such,a,case,throws,illegal,argument,exception,if,one,of,the,aliases,resolve,to,multiple,indices,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case;public,index,concrete,indices,cluster,state,state,indices,options,options,long,start,time,string,index,expressions,context,context,new,context,state,options,start,time,return,concrete,indices,context,index,expressions
IndexNameExpressionResolver -> public Index[] concreteIndices(ClusterState state, IndicesOptions options, long startTime, String... indexExpressions);1538067637;Translates the provided index expression into actual concrete indices, properly deduplicated.__@param state             the cluster state containing all the data to resolve to expressions to concrete indices_@param options           defines how the aliases or indices need to be resolved to concrete indices_@param startTime         The start of the request where concrete indices is being invoked for_@param indexExpressions  expressions that can be resolved to alias or index names._@return the resolved concrete indices based on the cluster state, indices options and index expressions_provided indices options in the context don't allow such a case, or if the final result of the indices resolution_contains no indices and the indices options in the context don't allow such a case._@throws IllegalArgumentException if one of the aliases resolve to multiple indices and the provided_indices options in the context don't allow such a case.;public Index[] concreteIndices(ClusterState state, IndicesOptions options, long startTime, String... indexExpressions) {_        Context context = new Context(state, options, startTime)__        return concreteIndices(context, indexExpressions)__    };translates,the,provided,index,expression,into,actual,concrete,indices,properly,deduplicated,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expressions,to,concrete,indices,param,options,defines,how,the,aliases,or,indices,need,to,be,resolved,to,concrete,indices,param,start,time,the,start,of,the,request,where,concrete,indices,is,being,invoked,for,param,index,expressions,expressions,that,can,be,resolved,to,alias,or,index,names,return,the,resolved,concrete,indices,based,on,the,cluster,state,indices,options,and,index,expressions,provided,indices,options,in,the,context,don,t,allow,such,a,case,or,if,the,final,result,of,the,indices,resolution,contains,no,indices,and,the,indices,options,in,the,context,don,t,allow,such,a,case,throws,illegal,argument,exception,if,one,of,the,aliases,resolve,to,multiple,indices,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case;public,index,concrete,indices,cluster,state,state,indices,options,options,long,start,time,string,index,expressions,context,context,new,context,state,options,start,time,return,concrete,indices,context,index,expressions
IndexNameExpressionResolver -> public Index[] concreteIndices(ClusterState state, IndicesOptions options, long startTime, String... indexExpressions);1539615817;Translates the provided index expression into actual concrete indices, properly deduplicated.__@param state             the cluster state containing all the data to resolve to expressions to concrete indices_@param options           defines how the aliases or indices need to be resolved to concrete indices_@param startTime         The start of the request where concrete indices is being invoked for_@param indexExpressions  expressions that can be resolved to alias or index names._@return the resolved concrete indices based on the cluster state, indices options and index expressions_provided indices options in the context don't allow such a case, or if the final result of the indices resolution_contains no indices and the indices options in the context don't allow such a case._@throws IllegalArgumentException if one of the aliases resolve to multiple indices and the provided_indices options in the context don't allow such a case.;public Index[] concreteIndices(ClusterState state, IndicesOptions options, long startTime, String... indexExpressions) {_        Context context = new Context(state, options, startTime)__        return concreteIndices(context, indexExpressions)__    };translates,the,provided,index,expression,into,actual,concrete,indices,properly,deduplicated,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expressions,to,concrete,indices,param,options,defines,how,the,aliases,or,indices,need,to,be,resolved,to,concrete,indices,param,start,time,the,start,of,the,request,where,concrete,indices,is,being,invoked,for,param,index,expressions,expressions,that,can,be,resolved,to,alias,or,index,names,return,the,resolved,concrete,indices,based,on,the,cluster,state,indices,options,and,index,expressions,provided,indices,options,in,the,context,don,t,allow,such,a,case,or,if,the,final,result,of,the,indices,resolution,contains,no,indices,and,the,indices,options,in,the,context,don,t,allow,such,a,case,throws,illegal,argument,exception,if,one,of,the,aliases,resolve,to,multiple,indices,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case;public,index,concrete,indices,cluster,state,state,indices,options,options,long,start,time,string,index,expressions,context,context,new,context,state,options,start,time,return,concrete,indices,context,index,expressions
IndexNameExpressionResolver -> public Index[] concreteIndices(ClusterState state, IndicesOptions options, long startTime, String... indexExpressions);1540313026;Translates the provided index expression into actual concrete indices, properly deduplicated.__@param state             the cluster state containing all the data to resolve to expressions to concrete indices_@param options           defines how the aliases or indices need to be resolved to concrete indices_@param startTime         The start of the request where concrete indices is being invoked for_@param indexExpressions  expressions that can be resolved to alias or index names._@return the resolved concrete indices based on the cluster state, indices options and index expressions_provided indices options in the context don't allow such a case, or if the final result of the indices resolution_contains no indices and the indices options in the context don't allow such a case._@throws IllegalArgumentException if one of the aliases resolve to multiple indices and the provided_indices options in the context don't allow such a case.;public Index[] concreteIndices(ClusterState state, IndicesOptions options, long startTime, String... indexExpressions) {_        Context context = new Context(state, options, startTime)__        return concreteIndices(context, indexExpressions)__    };translates,the,provided,index,expression,into,actual,concrete,indices,properly,deduplicated,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expressions,to,concrete,indices,param,options,defines,how,the,aliases,or,indices,need,to,be,resolved,to,concrete,indices,param,start,time,the,start,of,the,request,where,concrete,indices,is,being,invoked,for,param,index,expressions,expressions,that,can,be,resolved,to,alias,or,index,names,return,the,resolved,concrete,indices,based,on,the,cluster,state,indices,options,and,index,expressions,provided,indices,options,in,the,context,don,t,allow,such,a,case,or,if,the,final,result,of,the,indices,resolution,contains,no,indices,and,the,indices,options,in,the,context,don,t,allow,such,a,case,throws,illegal,argument,exception,if,one,of,the,aliases,resolve,to,multiple,indices,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case;public,index,concrete,indices,cluster,state,state,indices,options,options,long,start,time,string,index,expressions,context,context,new,context,state,options,start,time,return,concrete,indices,context,index,expressions
IndexNameExpressionResolver -> public Index[] concreteIndices(ClusterState state, IndicesOptions options, long startTime, String... indexExpressions);1540847035;Translates the provided index expression into actual concrete indices, properly deduplicated.__@param state             the cluster state containing all the data to resolve to expressions to concrete indices_@param options           defines how the aliases or indices need to be resolved to concrete indices_@param startTime         The start of the request where concrete indices is being invoked for_@param indexExpressions  expressions that can be resolved to alias or index names._@return the resolved concrete indices based on the cluster state, indices options and index expressions_provided indices options in the context don't allow such a case, or if the final result of the indices resolution_contains no indices and the indices options in the context don't allow such a case._@throws IllegalArgumentException if one of the aliases resolve to multiple indices and the provided_indices options in the context don't allow such a case.;public Index[] concreteIndices(ClusterState state, IndicesOptions options, long startTime, String... indexExpressions) {_        Context context = new Context(state, options, startTime)__        return concreteIndices(context, indexExpressions)__    };translates,the,provided,index,expression,into,actual,concrete,indices,properly,deduplicated,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expressions,to,concrete,indices,param,options,defines,how,the,aliases,or,indices,need,to,be,resolved,to,concrete,indices,param,start,time,the,start,of,the,request,where,concrete,indices,is,being,invoked,for,param,index,expressions,expressions,that,can,be,resolved,to,alias,or,index,names,return,the,resolved,concrete,indices,based,on,the,cluster,state,indices,options,and,index,expressions,provided,indices,options,in,the,context,don,t,allow,such,a,case,or,if,the,final,result,of,the,indices,resolution,contains,no,indices,and,the,indices,options,in,the,context,don,t,allow,such,a,case,throws,illegal,argument,exception,if,one,of,the,aliases,resolve,to,multiple,indices,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case;public,index,concrete,indices,cluster,state,state,indices,options,options,long,start,time,string,index,expressions,context,context,new,context,state,options,start,time,return,concrete,indices,context,index,expressions
IndexNameExpressionResolver -> public Index[] concreteIndices(ClusterState state, IndicesOptions options, long startTime, String... indexExpressions);1541092382;Translates the provided index expression into actual concrete indices, properly deduplicated.__@param state             the cluster state containing all the data to resolve to expressions to concrete indices_@param options           defines how the aliases or indices need to be resolved to concrete indices_@param startTime         The start of the request where concrete indices is being invoked for_@param indexExpressions  expressions that can be resolved to alias or index names._@return the resolved concrete indices based on the cluster state, indices options and index expressions_provided indices options in the context don't allow such a case, or if the final result of the indices resolution_contains no indices and the indices options in the context don't allow such a case._@throws IllegalArgumentException if one of the aliases resolve to multiple indices and the provided_indices options in the context don't allow such a case.;public Index[] concreteIndices(ClusterState state, IndicesOptions options, long startTime, String... indexExpressions) {_        Context context = new Context(state, options, startTime)__        return concreteIndices(context, indexExpressions)__    };translates,the,provided,index,expression,into,actual,concrete,indices,properly,deduplicated,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expressions,to,concrete,indices,param,options,defines,how,the,aliases,or,indices,need,to,be,resolved,to,concrete,indices,param,start,time,the,start,of,the,request,where,concrete,indices,is,being,invoked,for,param,index,expressions,expressions,that,can,be,resolved,to,alias,or,index,names,return,the,resolved,concrete,indices,based,on,the,cluster,state,indices,options,and,index,expressions,provided,indices,options,in,the,context,don,t,allow,such,a,case,or,if,the,final,result,of,the,indices,resolution,contains,no,indices,and,the,indices,options,in,the,context,don,t,allow,such,a,case,throws,illegal,argument,exception,if,one,of,the,aliases,resolve,to,multiple,indices,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case;public,index,concrete,indices,cluster,state,state,indices,options,options,long,start,time,string,index,expressions,context,context,new,context,state,options,start,time,return,concrete,indices,context,index,expressions
IndexNameExpressionResolver -> public Index[] concreteIndices(ClusterState state, IndicesOptions options, long startTime, String... indexExpressions);1541493930;Translates the provided index expression into actual concrete indices, properly deduplicated.__@param state             the cluster state containing all the data to resolve to expressions to concrete indices_@param options           defines how the aliases or indices need to be resolved to concrete indices_@param startTime         The start of the request where concrete indices is being invoked for_@param indexExpressions  expressions that can be resolved to alias or index names._@return the resolved concrete indices based on the cluster state, indices options and index expressions_provided indices options in the context don't allow such a case, or if the final result of the indices resolution_contains no indices and the indices options in the context don't allow such a case._@throws IllegalArgumentException if one of the aliases resolve to multiple indices and the provided_indices options in the context don't allow such a case.;public Index[] concreteIndices(ClusterState state, IndicesOptions options, long startTime, String... indexExpressions) {_        Context context = new Context(state, options, startTime)__        return concreteIndices(context, indexExpressions)__    };translates,the,provided,index,expression,into,actual,concrete,indices,properly,deduplicated,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expressions,to,concrete,indices,param,options,defines,how,the,aliases,or,indices,need,to,be,resolved,to,concrete,indices,param,start,time,the,start,of,the,request,where,concrete,indices,is,being,invoked,for,param,index,expressions,expressions,that,can,be,resolved,to,alias,or,index,names,return,the,resolved,concrete,indices,based,on,the,cluster,state,indices,options,and,index,expressions,provided,indices,options,in,the,context,don,t,allow,such,a,case,or,if,the,final,result,of,the,indices,resolution,contains,no,indices,and,the,indices,options,in,the,context,don,t,allow,such,a,case,throws,illegal,argument,exception,if,one,of,the,aliases,resolve,to,multiple,indices,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case;public,index,concrete,indices,cluster,state,state,indices,options,options,long,start,time,string,index,expressions,context,context,new,context,state,options,start,time,return,concrete,indices,context,index,expressions
IndexNameExpressionResolver -> public Index[] concreteIndices(ClusterState state, IndicesOptions options, long startTime, String... indexExpressions);1541612607;Translates the provided index expression into actual concrete indices, properly deduplicated.__@param state             the cluster state containing all the data to resolve to expressions to concrete indices_@param options           defines how the aliases or indices need to be resolved to concrete indices_@param startTime         The start of the request where concrete indices is being invoked for_@param indexExpressions  expressions that can be resolved to alias or index names._@return the resolved concrete indices based on the cluster state, indices options and index expressions_provided indices options in the context don't allow such a case, or if the final result of the indices resolution_contains no indices and the indices options in the context don't allow such a case._@throws IllegalArgumentException if one of the aliases resolve to multiple indices and the provided_indices options in the context don't allow such a case.;public Index[] concreteIndices(ClusterState state, IndicesOptions options, long startTime, String... indexExpressions) {_        Context context = new Context(state, options, startTime)__        return concreteIndices(context, indexExpressions)__    };translates,the,provided,index,expression,into,actual,concrete,indices,properly,deduplicated,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expressions,to,concrete,indices,param,options,defines,how,the,aliases,or,indices,need,to,be,resolved,to,concrete,indices,param,start,time,the,start,of,the,request,where,concrete,indices,is,being,invoked,for,param,index,expressions,expressions,that,can,be,resolved,to,alias,or,index,names,return,the,resolved,concrete,indices,based,on,the,cluster,state,indices,options,and,index,expressions,provided,indices,options,in,the,context,don,t,allow,such,a,case,or,if,the,final,result,of,the,indices,resolution,contains,no,indices,and,the,indices,options,in,the,context,don,t,allow,such,a,case,throws,illegal,argument,exception,if,one,of,the,aliases,resolve,to,multiple,indices,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case;public,index,concrete,indices,cluster,state,state,indices,options,options,long,start,time,string,index,expressions,context,context,new,context,state,options,start,time,return,concrete,indices,context,index,expressions
IndexNameExpressionResolver -> public Index[] concreteIndices(ClusterState state, IndicesOptions options, long startTime, String... indexExpressions);1544215214;Translates the provided index expression into actual concrete indices, properly deduplicated.__@param state             the cluster state containing all the data to resolve to expressions to concrete indices_@param options           defines how the aliases or indices need to be resolved to concrete indices_@param startTime         The start of the request where concrete indices is being invoked for_@param indexExpressions  expressions that can be resolved to alias or index names._@return the resolved concrete indices based on the cluster state, indices options and index expressions_provided indices options in the context don't allow such a case, or if the final result of the indices resolution_contains no indices and the indices options in the context don't allow such a case._@throws IllegalArgumentException if one of the aliases resolve to multiple indices and the provided_indices options in the context don't allow such a case.;public Index[] concreteIndices(ClusterState state, IndicesOptions options, long startTime, String... indexExpressions) {_        Context context = new Context(state, options, startTime)__        return concreteIndices(context, indexExpressions)__    };translates,the,provided,index,expression,into,actual,concrete,indices,properly,deduplicated,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expressions,to,concrete,indices,param,options,defines,how,the,aliases,or,indices,need,to,be,resolved,to,concrete,indices,param,start,time,the,start,of,the,request,where,concrete,indices,is,being,invoked,for,param,index,expressions,expressions,that,can,be,resolved,to,alias,or,index,names,return,the,resolved,concrete,indices,based,on,the,cluster,state,indices,options,and,index,expressions,provided,indices,options,in,the,context,don,t,allow,such,a,case,or,if,the,final,result,of,the,indices,resolution,contains,no,indices,and,the,indices,options,in,the,context,don,t,allow,such,a,case,throws,illegal,argument,exception,if,one,of,the,aliases,resolve,to,multiple,indices,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case;public,index,concrete,indices,cluster,state,state,indices,options,options,long,start,time,string,index,expressions,context,context,new,context,state,options,start,time,return,concrete,indices,context,index,expressions
IndexNameExpressionResolver -> public Index[] concreteIndices(ClusterState state, IndicesOptions options, long startTime, String... indexExpressions);1548236405;Translates the provided index expression into actual concrete indices, properly deduplicated.__@param state             the cluster state containing all the data to resolve to expressions to concrete indices_@param options           defines how the aliases or indices need to be resolved to concrete indices_@param startTime         The start of the request where concrete indices is being invoked for_@param indexExpressions  expressions that can be resolved to alias or index names._@return the resolved concrete indices based on the cluster state, indices options and index expressions_provided indices options in the context don't allow such a case, or if the final result of the indices resolution_contains no indices and the indices options in the context don't allow such a case._@throws IllegalArgumentException if one of the aliases resolve to multiple indices and the provided_indices options in the context don't allow such a case.;public Index[] concreteIndices(ClusterState state, IndicesOptions options, long startTime, String... indexExpressions) {_        Context context = new Context(state, options, startTime)__        return concreteIndices(context, indexExpressions)__    };translates,the,provided,index,expression,into,actual,concrete,indices,properly,deduplicated,param,state,the,cluster,state,containing,all,the,data,to,resolve,to,expressions,to,concrete,indices,param,options,defines,how,the,aliases,or,indices,need,to,be,resolved,to,concrete,indices,param,start,time,the,start,of,the,request,where,concrete,indices,is,being,invoked,for,param,index,expressions,expressions,that,can,be,resolved,to,alias,or,index,names,return,the,resolved,concrete,indices,based,on,the,cluster,state,indices,options,and,index,expressions,provided,indices,options,in,the,context,don,t,allow,such,a,case,or,if,the,final,result,of,the,indices,resolution,contains,no,indices,and,the,indices,options,in,the,context,don,t,allow,such,a,case,throws,illegal,argument,exception,if,one,of,the,aliases,resolve,to,multiple,indices,and,the,provided,indices,options,in,the,context,don,t,allow,such,a,case;public,index,concrete,indices,cluster,state,state,indices,options,options,long,start,time,string,index,expressions,context,context,new,context,state,options,start,time,return,concrete,indices,context,index,expressions
