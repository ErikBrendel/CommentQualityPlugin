commented;modifiers;parameterAmount;loc;comment;code
true;public;1;6;/**  * Set the query for selective delete  */ ;/**  * Set the query for selective delete  */ public DeleteByQueryRequest setQuery(QueryBuilder query) {     if (query != null) {         getSearchRequest().source().query(query).     }     return this. }
true;public;1;7;/**  * Set the document types for the delete  * @deprecated Types are in the process of being removed. Instead of  * using a type, prefer to filter on a field of the document.  */ ;/**  * Set the document types for the delete  * @deprecated Types are in the process of being removed. Instead of  * using a type, prefer to filter on a field of the document.  */ @Deprecated public DeleteByQueryRequest setDocTypes(String... types) {     if (types != null) {         getSearchRequest().types(types).     }     return this. }
true;public;1;6;/**  * Set routing limiting the process to the shards that match that routing value  */ ;/**  * Set routing limiting the process to the shards that match that routing value  */ public DeleteByQueryRequest setRouting(String routing) {     if (routing != null) {         getSearchRequest().routing(routing).     }     return this. }
true;public;1;4;/**  * The scroll size to control number of documents processed per batch  */ ;/**  * The scroll size to control number of documents processed per batch  */ public DeleteByQueryRequest setBatchSize(int size) {     getSearchRequest().source().size(size).     return this. }
true;public;1;4;/**  * Set the IndicesOptions for controlling unavailable indices  */ ;/**  * Set the IndicesOptions for controlling unavailable indices  */ public DeleteByQueryRequest setIndicesOptions(IndicesOptions indicesOptions) {     getSearchRequest().indicesOptions(indicesOptions).     return this. }
true;public;0;3;/**  * Gets the batch size for this request  */ ;/**  * Gets the batch size for this request  */ public int getBatchSize() {     return getSearchRequest().source().size(). }
true;public;0;3;/**  * Gets the routing value used for this request  */ ;/**  * Gets the routing value used for this request  */ public String getRouting() {     return getSearchRequest().routing(). }
true;public;0;8;/**  * Gets the document types on which this request would be executed. Returns an empty array if all  * types are to be processed.  * @deprecated Types are in the process of being removed. Instead of  * using a type, prefer to filter on a field of the document.  */ ;/**  * Gets the document types on which this request would be executed. Returns an empty array if all  * types are to be processed.  * @deprecated Types are in the process of being removed. Instead of  * using a type, prefer to filter on a field of the document.  */ @Deprecated public String[] getDocTypes() {     if (getSearchRequest().types() != null) {         return getSearchRequest().types().     } else {         return new String[0].     } }
false;protected;0;4;;@Override protected DeleteByQueryRequest self() {     return this. }
false;public;0;13;;@Override public ActionRequestValidationException validate() {     ActionRequestValidationException e = super.validate().     if (getSearchRequest().indices() == null || getSearchRequest().indices().length == 0) {         e = addValidationError("use _all if you really want to delete from all existing indexes", e).     }     if (getSearchRequest() == null || getSearchRequest().source() == null) {         e = addValidationError("source is missing", e).     } else if (getSearchRequest().source().query() == null) {         e = addValidationError("query is missing", e).     }     return e. }
false;public;3;4;;@Override public DeleteByQueryRequest forSlice(TaskId slicingTask, SearchRequest slice, int totalSlices) {     return doForSlice(new DeleteByQueryRequest(slice, false), slicingTask, totalSlices). }
false;public;0;7;;@Override public String toString() {     StringBuilder b = new StringBuilder().     b.append("delete-by-query ").     searchToString(b).     return b.toString(). }
true;public;1;6;// indices are resolved depend entirely on the inner search request. That's why the following methods delegate to it. ;// delete by query deletes all documents that match a query. The indices and indices options that affect how // indices are resolved depend entirely on the inner search request. That's why the following methods delegate to it. @Override public IndicesRequest indices(String... indices) {     assert getSearchRequest() != null.     getSearchRequest().indices(indices).     return this. }
false;public;0;5;;@Override public String[] indices() {     assert getSearchRequest() != null.     return getSearchRequest().indices(). }
false;public;0;5;;@Override public IndicesOptions indicesOptions() {     assert getSearchRequest() != null.     return getSearchRequest().indicesOptions(). }
true;public;0;5;/**  * Gets the document types on which this request would be executed.  * @deprecated Types are in the process of being removed. Instead of  * using a type, prefer to filter on a field of the document.  */ ;/**  * Gets the document types on which this request would be executed.  * @deprecated Types are in the process of being removed. Instead of  * using a type, prefer to filter on a field of the document.  */ @Deprecated public String[] types() {     assert getSearchRequest() != null.     return getSearchRequest().types(). }
true;public;1;6;/**  * Set the document types for the delete  * @deprecated Types are in the process of being removed. Instead of  * using a type, prefer to filter on a field of the document.  */ ;/**  * Set the document types for the delete  * @deprecated Types are in the process of being removed. Instead of  * using a type, prefer to filter on a field of the document.  */ @Deprecated public DeleteByQueryRequest types(String... types) {     assert getSearchRequest() != null.     getSearchRequest().types(types).     return this. }
false;public;2;7;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     getSearchRequest().source().innerToXContent(builder, params).     builder.endObject().     return builder. }
