commented;modifiers;parameterAmount;loc;comment;code
false;public;1;41;;@Override public boolean advanceExact(int target) throws IOException {     script.setDocument(target).     final Object value = script.execute().     if (value == null) {         return false.     } else if (value.getClass().isArray()) {         int length = Array.getLength(value).         if (length == 0) {             return false.         }         resize(length).         for (int i = 0. i < length. ++i) {             values[i] = toLongValue(Array.get(value, i)).         }     } else if (value instanceof Collection) {         Collection<?> coll = (Collection<?>) value.         if (coll.isEmpty()) {             return false.         }         resize(coll.size()).         int i = 0.         for (Iterator<?> it = coll.iterator(). it.hasNext(). ++i) {             values[i] = toLongValue(it.next()).         }         assert i == docValueCount().     } else {         resize(1).         values[0] = toLongValue(value).     }     sort().     return true. }
false;private,static;1;20;;private static long toLongValue(Object o) {     if (o instanceof Number) {         return ((Number) o).longValue().     } else if (o instanceof ReadableInstant) {         // Dates are exposed in scripts as ReadableDateTimes but aggregations want them to be numeric         return ((ReadableInstant) o).getMillis().     } else if (o instanceof ZonedDateTime) {         return ((ZonedDateTime) o).toInstant().toEpochMilli().     } else if (o instanceof JodaCompatibleZonedDateTime) {         return ((JodaCompatibleZonedDateTime) o).toInstant().toEpochMilli().     } else if (o instanceof Boolean) {         // make sure of using true/false in the key_as_string field         return ((Boolean) o).booleanValue() ? 1L : 0L.     } else {         throw new AggregationExecutionException("Unsupported script value [" + o + "], expected a number, date, or boolean").     } }
false;public;1;4;;@Override public void setScorer(Scorable scorer) {     script.setScorer(scorer). }
