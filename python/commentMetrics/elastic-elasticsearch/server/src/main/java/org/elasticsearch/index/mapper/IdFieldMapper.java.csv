commented;modifiers;parameterAmount;loc;comment;code
false;public;3;5;;@Override public MetadataFieldMapper.Builder parse(String name, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {     throw new MapperParsingException(NAME + " is not configurable"). }
false;public;2;5;;@Override public MetadataFieldMapper getDefault(MappedFieldType fieldType, ParserContext context) {     final IndexSettings indexSettings = context.mapperService().getIndexSettings().     return new IdFieldMapper(indexSettings, fieldType). }
false;public;0;4;;@Override public MappedFieldType clone() {     return new IdFieldType(this). }
false;public;0;4;;@Override public String typeName() {     return CONTENT_TYPE. }
false;public;0;5;;@Override public boolean isSearchable() {     // The _id field is always searchable.     return true. }
false;public;2;4;;@Override public Query termQuery(Object value, QueryShardContext context) {     return termsQuery(Arrays.asList(value), context). }
false;public;1;4;;@Override public Query existsQuery(QueryShardContext context) {     return new MatchAllDocsQuery(). }
false;public;2;13;;@Override public Query termsQuery(List<?> values, QueryShardContext context) {     failIfNotIndexed().     BytesRef[] bytesRefs = new BytesRef[values.size()].     for (int i = 0. i < bytesRefs.length. i++) {         Object idObject = values.get(i).         if (idObject instanceof BytesRef) {             idObject = ((BytesRef) idObject).utf8ToString().         }         bytesRefs[i] = Uid.encodeId(idObject.toString()).     }     return new TermInSetQuery(name(), bytesRefs). }
false;public;0;4;;@Override public Index index() {     return fieldData.index(). }
false;public;0;4;;@Override public String getFieldName() {     return fieldData.getFieldName(). }
false;public;1;4;;@Override public AtomicFieldData load(LeafReaderContext context) {     return wrap(fieldData.load(context)). }
false;public;1;4;;@Override public AtomicFieldData loadDirect(LeafReaderContext context) throws Exception {     return wrap(fieldData.loadDirect(context)). }
false;public;4;6;;@Override public SortField sortField(Object missingValue, MultiValueMode sortMode, Nested nested, boolean reverse) {     XFieldComparatorSource source = new BytesRefFieldComparatorSource(this, missingValue, sortMode, nested).     return new SortField(getFieldName(), source, reverse). }
false;public;0;4;;@Override public void clear() {     fieldData.clear(). }
false;public;5;41;;@Override public IndexFieldData<?> build(IndexSettings indexSettings, MappedFieldType fieldType, IndexFieldDataCache cache, CircuitBreakerService breakerService, MapperService mapperService) {     final IndexFieldData<?> fieldData = fieldDataBuilder.build(indexSettings, fieldType, cache, breakerService, mapperService).     return new IndexFieldData<AtomicFieldData>() {          @Override         public Index index() {             return fieldData.index().         }          @Override         public String getFieldName() {             return fieldData.getFieldName().         }          @Override         public AtomicFieldData load(LeafReaderContext context) {             return wrap(fieldData.load(context)).         }          @Override         public AtomicFieldData loadDirect(LeafReaderContext context) throws Exception {             return wrap(fieldData.loadDirect(context)).         }          @Override         public SortField sortField(Object missingValue, MultiValueMode sortMode, Nested nested, boolean reverse) {             XFieldComparatorSource source = new BytesRefFieldComparatorSource(this, missingValue, sortMode, nested).             return new SortField(getFieldName(), source, reverse).         }          @Override         public void clear() {             fieldData.clear().         }     }. }
false;public;1;53;;@Override public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {     if (indexOptions() == IndexOptions.NONE) {         throw new IllegalArgumentException("Fielddata access on the _id field is disallowed").     }     final IndexFieldData.Builder fieldDataBuilder = new PagedBytesIndexFieldData.Builder(TextFieldMapper.Defaults.FIELDDATA_MIN_FREQUENCY, TextFieldMapper.Defaults.FIELDDATA_MAX_FREQUENCY, TextFieldMapper.Defaults.FIELDDATA_MIN_SEGMENT_SIZE).     return new IndexFieldData.Builder() {          @Override         public IndexFieldData<?> build(IndexSettings indexSettings, MappedFieldType fieldType, IndexFieldDataCache cache, CircuitBreakerService breakerService, MapperService mapperService) {             final IndexFieldData<?> fieldData = fieldDataBuilder.build(indexSettings, fieldType, cache, breakerService, mapperService).             return new IndexFieldData<AtomicFieldData>() {                  @Override                 public Index index() {                     return fieldData.index().                 }                  @Override                 public String getFieldName() {                     return fieldData.getFieldName().                 }                  @Override                 public AtomicFieldData load(LeafReaderContext context) {                     return wrap(fieldData.load(context)).                 }                  @Override                 public AtomicFieldData loadDirect(LeafReaderContext context) throws Exception {                     return wrap(fieldData.loadDirect(context)).                 }                  @Override                 public SortField sortField(Object missingValue, MultiValueMode sortMode, Nested nested, boolean reverse) {                     XFieldComparatorSource source = new BytesRefFieldComparatorSource(this, missingValue, sortMode, nested).                     return new SortField(getFieldName(), source, reverse).                 }                  @Override                 public void clear() {                     fieldData.clear().                 }             }.         }     }. }
false;public;0;4;;@Override public void close() {     in.close(). }
false;public;0;4;;@Override public long ramBytesUsed() {     return in.ramBytesUsed(). }
false;public;0;4;;@Override public ScriptDocValues<?> getScriptValues() {     return new ScriptDocValues.Strings(getBytesValues()). }
false;public;0;6;;@Override public BytesRef nextValue() throws IOException {     BytesRef encoded = inValues.nextValue().     return new BytesRef(Uid.decodeId(Arrays.copyOfRange(encoded.bytes, encoded.offset, encoded.offset + encoded.length))). }
false;public;0;8;;@Override public int docValueCount() {     final int count = inValues.docValueCount().     // does not preserve order. But id fields only have one value per doc so we are good.     assert count == 1.     return inValues.docValueCount(). }
false;public;1;4;;@Override public boolean advanceExact(int doc) throws IOException {     return inValues.advanceExact(doc). }
false;public;0;27;;@Override public SortedBinaryDocValues getBytesValues() {     SortedBinaryDocValues inValues = in.getBytesValues().     return new SortedBinaryDocValues() {          @Override         public BytesRef nextValue() throws IOException {             BytesRef encoded = inValues.nextValue().             return new BytesRef(Uid.decodeId(Arrays.copyOfRange(encoded.bytes, encoded.offset, encoded.offset + encoded.length))).         }          @Override         public int docValueCount() {             final int count = inValues.docValueCount().             // does not preserve order. But id fields only have one value per doc so we are good.             assert count == 1.             return inValues.docValueCount().         }          @Override         public boolean advanceExact(int doc) throws IOException {             return inValues.advanceExact(doc).         }     }. }
false;private,static;1;47;;private static AtomicFieldData wrap(AtomicFieldData in) {     return new AtomicFieldData() {          @Override         public void close() {             in.close().         }          @Override         public long ramBytesUsed() {             return in.ramBytesUsed().         }          @Override         public ScriptDocValues<?> getScriptValues() {             return new ScriptDocValues.Strings(getBytesValues()).         }          @Override         public SortedBinaryDocValues getBytesValues() {             SortedBinaryDocValues inValues = in.getBytesValues().             return new SortedBinaryDocValues() {                  @Override                 public BytesRef nextValue() throws IOException {                     BytesRef encoded = inValues.nextValue().                     return new BytesRef(Uid.decodeId(Arrays.copyOfRange(encoded.bytes, encoded.offset, encoded.offset + encoded.length))).                 }                  @Override                 public int docValueCount() {                     final int count = inValues.docValueCount().                     // does not preserve order. But id fields only have one value per doc so we are good.                     assert count == 1.                     return inValues.docValueCount().                 }                  @Override                 public boolean advanceExact(int doc) throws IOException {                     return inValues.advanceExact(doc).                 }             }.         }     }. }
false;static;1;6;;static MappedFieldType defaultFieldType(IndexSettings indexSettings) {     MappedFieldType defaultFieldType = Defaults.FIELD_TYPE.clone().     defaultFieldType.setIndexOptions(IndexOptions.DOCS).     defaultFieldType.setStored(true).     return defaultFieldType. }
false;public;1;4;;@Override public void preParse(ParseContext context) throws IOException {     super.parse(context). }
false;protected;2;7;;@Override protected void parseCreateField(ParseContext context, List<IndexableField> fields) throws IOException {     if (fieldType.indexOptions() != IndexOptions.NONE || fieldType.stored()) {         BytesRef id = Uid.encodeId(context.sourceToParse().id()).         fields.add(new Field(NAME, id, fieldType)).     } }
false;protected;0;4;;@Override protected String contentType() {     return CONTENT_TYPE. }
false;public;2;4;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     return builder. }
false;protected;1;4;;@Override protected void doMerge(Mapper mergeWith) { // do nothing here, no merging, but also no exception }
