commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String getType() {     return IpRangeAggregationBuilder.NAME. }
false;public;0;4;;@Override public List<? extends Range.Bucket> getBuckets() {     return buckets. }
false;public,static;2;5;;public static ParsedBinaryRange fromXContent(XContentParser parser, String name) throws IOException {     ParsedBinaryRange aggregation = PARSER.parse(parser, null).     aggregation.setName(name).     return aggregation. }
false;public;0;4;;@Override public Object getKey() {     return key. }
false;public;0;4;;@Override public String getKeyAsString() {     return key. }
false;public;0;4;;@Override public Object getFrom() {     return from. }
false;public;0;4;;@Override public String getFromAsString() {     return from. }
false;public;0;4;;@Override public Object getTo() {     return to. }
false;public;0;4;;@Override public String getToAsString() {     return to. }
false;public;2;19;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     if (isKeyed()) {         builder.startObject(key).     } else {         builder.startObject().         builder.field(CommonFields.KEY.getPreferredName(), key).     }     if (from != null) {         builder.field(CommonFields.FROM.getPreferredName(), from).     }     if (to != null) {         builder.field(CommonFields.TO.getPreferredName(), to).     }     builder.field(CommonFields.DOC_COUNT.getPreferredName(), getDocCount()).     getAggregations().toXContentInternal(builder, params).     builder.endObject().     return builder. }
false;static;2;34;;static ParsedBucket fromXContent(final XContentParser parser, final boolean keyed) throws IOException {     final ParsedBucket bucket = new ParsedBucket().     bucket.setKeyed(keyed).     XContentParser.Token token = parser.currentToken().     String currentFieldName = parser.currentName().     if (keyed) {         ensureExpectedToken(XContentParser.Token.FIELD_NAME, token, parser::getTokenLocation).         bucket.key = currentFieldName.         ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation).     }     List<Aggregation> aggregations = new ArrayList<>().     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token.isValue()) {             if (CommonFields.KEY.getPreferredName().equals(currentFieldName)) {                 bucket.key = parser.text().             } else if (CommonFields.DOC_COUNT.getPreferredName().equals(currentFieldName)) {                 bucket.setDocCount(parser.longValue()).             } else if (CommonFields.FROM.getPreferredName().equals(currentFieldName)) {                 bucket.from = parser.text().             } else if (CommonFields.TO.getPreferredName().equals(currentFieldName)) {                 bucket.to = parser.text().             }         } else if (token == XContentParser.Token.START_OBJECT) {             XContentParserUtils.parseTypedKeysObject(parser, Aggregation.TYPED_KEYS_DELIMITER, Aggregation.class, aggregations::add).         }     }     bucket.setAggregations(new Aggregations(aggregations)).     return bucket. }
