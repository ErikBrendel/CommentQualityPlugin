commented;modifiers;parameterAmount;loc;comment;code
false;;1;3;;void setUseAdaptiveReplicaSelection(boolean useAdaptiveReplicaSelection) {     this.useAdaptiveReplicaSelection = useAdaptiveReplicaSelection. }
false;private;1;3;;private void setAwarenessAttributes(List<String> awarenessAttributes) {     this.awarenessAttributes = awarenessAttributes. }
false;public;4;3;;public ShardIterator indexShards(ClusterState clusterState, String index, String id, @Nullable String routing) {     return shards(clusterState, index, id, routing).shardsIt(). }
false;public;5;5;;public ShardIterator getShards(ClusterState clusterState, String index, String id, @Nullable String routing, @Nullable String preference) {     return preferenceActiveShardIterator(shards(clusterState, index, id, routing), clusterState.nodes().getLocalNodeId(), clusterState.nodes(), preference, null, null). }
false;public;4;5;;public ShardIterator getShards(ClusterState clusterState, String index, int shardId, @Nullable String preference) {     final IndexShardRoutingTable indexShard = clusterState.getRoutingTable().shardRoutingTable(index, shardId).     return preferenceActiveShardIterator(indexShard, clusterState.nodes().getLocalNodeId(), clusterState.nodes(), preference, null, null). }
false;public;4;6;;public GroupShardsIterator<ShardIterator> searchShards(ClusterState clusterState, String[] concreteIndices, @Nullable Map<String, Set<String>> routing, @Nullable String preference) {     return searchShards(clusterState, concreteIndices, routing, preference, null, null). }
false;public;6;17;;public GroupShardsIterator<ShardIterator> searchShards(ClusterState clusterState, String[] concreteIndices, @Nullable Map<String, Set<String>> routing, @Nullable String preference, @Nullable ResponseCollectorService collectorService, @Nullable Map<String, Long> nodeCounts) {     final Set<IndexShardRoutingTable> shards = computeTargetedShards(clusterState, concreteIndices, routing).     final Set<ShardIterator> set = new HashSet<>(shards.size()).     for (IndexShardRoutingTable shard : shards) {         ShardIterator iterator = preferenceActiveShardIterator(shard, clusterState.nodes().getLocalNodeId(), clusterState.nodes(), preference, collectorService, nodeCounts).         if (iterator != null) {             set.add(iterator).         }     }     return new GroupShardsIterator<>(new ArrayList<>(set)). }
false;private;3;24;;private Set<IndexShardRoutingTable> computeTargetedShards(ClusterState clusterState, String[] concreteIndices, @Nullable Map<String, Set<String>> routing) {     // just use an empty map     routing = routing == null ? EMPTY_ROUTING : routing.     final Set<IndexShardRoutingTable> set = new HashSet<>().     // we use set here and not list since we might get duplicates     for (String index : concreteIndices) {         final IndexRoutingTable indexRouting = indexRoutingTable(clusterState, index).         final IndexMetaData indexMetaData = indexMetaData(clusterState, index).         final Set<String> effectiveRouting = routing.get(index).         if (effectiveRouting != null) {             for (String r : effectiveRouting) {                 final int routingPartitionSize = indexMetaData.getRoutingPartitionSize().                 for (int partitionOffset = 0. partitionOffset < routingPartitionSize. partitionOffset++) {                     set.add(RoutingTable.shardRoutingTable(indexRouting, calculateScaledShardId(indexMetaData, r, partitionOffset))).                 }             }         } else {             for (IndexShardRoutingTable indexShard : indexRouting) {                 set.add(indexShard).             }         }     }     return set. }
false;private;6;74;;private ShardIterator preferenceActiveShardIterator(IndexShardRoutingTable indexShard, String localNodeId, DiscoveryNodes nodes, @Nullable String preference, @Nullable ResponseCollectorService collectorService, @Nullable Map<String, Long> nodeCounts) {     if (preference == null || preference.isEmpty()) {         return shardRoutings(indexShard, nodes, collectorService, nodeCounts).     }     if (preference.charAt(0) == '_') {         Preference preferenceType = Preference.parse(preference).         if (preferenceType == Preference.SHARDS) {             // starts with _shards, so execute on specific ones             int index = preference.indexOf('|').             String shards.             if (index == -1) {                 shards = preference.substring(Preference.SHARDS.type().length() + 1).             } else {                 shards = preference.substring(Preference.SHARDS.type().length() + 1, index).             }             String[] ids = Strings.splitStringByCommaToArray(shards).             boolean found = false.             for (String id : ids) {                 if (Integer.parseInt(id) == indexShard.shardId().id()) {                     found = true.                     break.                 }             }             if (!found) {                 return null.             }             // no more preference             if (index == -1 || index == preference.length() - 1) {                 return shardRoutings(indexShard, nodes, collectorService, nodeCounts).             } else {                 // update the preference and continue                 preference = preference.substring(index + 1).             }         }         preferenceType = Preference.parse(preference).         switch(preferenceType) {             case PREFER_NODES:                 final Set<String> nodesIds = Arrays.stream(preference.substring(Preference.PREFER_NODES.type().length() + 1).split(",")).collect(Collectors.toSet()).                 return indexShard.preferNodeActiveInitializingShardsIt(nodesIds).             case LOCAL:                 return indexShard.preferNodeActiveInitializingShardsIt(Collections.singleton(localNodeId)).             case ONLY_LOCAL:                 return indexShard.onlyNodeActiveInitializingShardsIt(localNodeId).             case ONLY_NODES:                 String nodeAttributes = preference.substring(Preference.ONLY_NODES.type().length() + 1).                 return indexShard.onlyNodeSelectorActiveInitializingShardsIt(nodeAttributes.split(","), nodes).             default:                 throw new IllegalArgumentException("unknown preference [" + preferenceType + "]").         }     }     // if not, then use it as the index     int routingHash = Murmur3HashFunction.hash(preference).     if (nodes.getMinNodeVersion().onOrAfter(Version.V_6_0_0_alpha1)) {         // The AllocationService lists shards in a fixed order based on nodes         // so earlier versions of this class would have a tendency to         // select the same node across different shardIds.         // Better overall balancing can be achieved if each shardId opts         // for a different element in the list by also incorporating the         // shard ID into the hash of the user-supplied preference key.         routingHash = 31 * routingHash + indexShard.shardId.hashCode().     }     if (awarenessAttributes.isEmpty()) {         return indexShard.activeInitializingShardsIt(routingHash).     } else {         return indexShard.preferAttributesActiveInitializingShardsIt(awarenessAttributes, nodes, routingHash).     } }
false;private;4;12;;private ShardIterator shardRoutings(IndexShardRoutingTable indexShard, DiscoveryNodes nodes, @Nullable ResponseCollectorService collectorService, @Nullable Map<String, Long> nodeCounts) {     if (awarenessAttributes.isEmpty()) {         if (useAdaptiveReplicaSelection) {             return indexShard.activeInitializingShardsRankedIt(collectorService, nodeCounts).         } else {             return indexShard.activeInitializingShardsRandomIt().         }     } else {         return indexShard.preferAttributesActiveInitializingShardsIt(awarenessAttributes, nodes).     } }
false;protected;2;7;;protected IndexRoutingTable indexRoutingTable(ClusterState clusterState, String index) {     IndexRoutingTable indexRouting = clusterState.routingTable().index(index).     if (indexRouting == null) {         throw new IndexNotFoundException(index).     }     return indexRouting. }
false;protected;2;7;;protected IndexMetaData indexMetaData(ClusterState clusterState, String index) {     IndexMetaData indexMetaData = clusterState.metaData().index(index).     if (indexMetaData == null) {         throw new IndexNotFoundException(index).     }     return indexMetaData. }
false;protected;4;4;;protected IndexShardRoutingTable shards(ClusterState clusterState, String index, String id, String routing) {     int shardId = generateShardId(indexMetaData(clusterState, index), id, routing).     return clusterState.getRoutingTable().shardRoutingTable(index, shardId). }
false;public;4;4;;public ShardId shardId(ClusterState clusterState, String index, String id, @Nullable String routing) {     IndexMetaData indexMetaData = indexMetaData(clusterState, index).     return new ShardId(indexMetaData.getIndex(), generateShardId(indexMetaData, id, routing)). }
false;public,static;3;20;;public static int generateShardId(IndexMetaData indexMetaData, @Nullable String id, @Nullable String routing) {     final String effectiveRouting.     final int partitionOffset.     if (routing == null) {         assert (indexMetaData.isRoutingPartitionedIndex() == false) : "A routing value is required for gets from a partitioned index".         effectiveRouting = id.     } else {         effectiveRouting = routing.     }     if (indexMetaData.isRoutingPartitionedIndex()) {         partitionOffset = Math.floorMod(Murmur3HashFunction.hash(id), indexMetaData.getRoutingPartitionSize()).     } else {         // we would have still got 0 above but this check just saves us an unnecessary hash calculation         partitionOffset = 0.     }     return calculateScaledShardId(indexMetaData, effectiveRouting, partitionOffset). }
false;private,static;3;7;;private static int calculateScaledShardId(IndexMetaData indexMetaData, String effectiveRouting, int partitionOffset) {     final int hash = Murmur3HashFunction.hash(effectiveRouting) + partitionOffset.     // of original index to hash documents     return Math.floorMod(hash, indexMetaData.getRoutingNumShards()) / indexMetaData.getRoutingFactor(). }
