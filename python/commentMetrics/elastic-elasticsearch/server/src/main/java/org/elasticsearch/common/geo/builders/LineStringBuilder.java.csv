# id;timestamp;commentText;codeText;commentWords;codeWords
LineStringBuilder -> public LineStringBuilder(StreamInput in) throws IOException;1524684173;Read from a stream.;public LineStringBuilder(StreamInput in) throws IOException {_        super(in)__    };read,from,a,stream;public,line,string,builder,stream,input,in,throws,ioexception,super,in
LineStringBuilder -> public LineStringBuilder(StreamInput in) throws IOException;1542820501;Read from a stream.;public LineStringBuilder(StreamInput in) throws IOException {_        super(in)__    };read,from,a,stream;public,line,string,builder,stream,input,in,throws,ioexception,super,in
LineStringBuilder -> public LineStringBuilder(StreamInput in) throws IOException;1548434247;Read from a stream.;public LineStringBuilder(StreamInput in) throws IOException {_        super(in)__    };read,from,a,stream;public,line,string,builder,stream,input,in,throws,ioexception,super,in
LineStringBuilder -> public LineStringBuilder(List<Coordinate> coordinates);1524684173;Construct a new LineString._Per GeoJSON spec (http://geojson.org/geojson-spec.html#linestring)_a LineString must contain two or more coordinates_@param coordinates the initial list of coordinates_@throws IllegalArgumentException if there are less then two coordinates defined;public LineStringBuilder(List<Coordinate> coordinates) {_        super(coordinates)__        if (coordinates.size() < 2) {_            throw new IllegalArgumentException("invalid number of points in LineString (found [" + coordinates.size()+ "] - must be >= 2)")__        }_    };construct,a,new,line,string,per,geo,json,spec,http,geojson,org,geojson,spec,html,linestring,a,line,string,must,contain,two,or,more,coordinates,param,coordinates,the,initial,list,of,coordinates,throws,illegal,argument,exception,if,there,are,less,then,two,coordinates,defined;public,line,string,builder,list,coordinate,coordinates,super,coordinates,if,coordinates,size,2,throw,new,illegal,argument,exception,invalid,number,of,points,in,line,string,found,coordinates,size,must,be,2
LineStringBuilder -> public LineStringBuilder(List<Coordinate> coordinates);1542820501;Construct a new LineString._Per GeoJSON spec (http://geojson.org/geojson-spec.html#linestring)_a LineString must contain two or more coordinates_@param coordinates the initial list of coordinates_@throws IllegalArgumentException if there are less then two coordinates defined;public LineStringBuilder(List<Coordinate> coordinates) {_        super(coordinates)__        if (coordinates.size() < 2) {_            throw new IllegalArgumentException("invalid number of points in LineString (found [" + coordinates.size()+ "] - must be >= 2)")__        }_    };construct,a,new,line,string,per,geo,json,spec,http,geojson,org,geojson,spec,html,linestring,a,line,string,must,contain,two,or,more,coordinates,param,coordinates,the,initial,list,of,coordinates,throws,illegal,argument,exception,if,there,are,less,then,two,coordinates,defined;public,line,string,builder,list,coordinate,coordinates,super,coordinates,if,coordinates,size,2,throw,new,illegal,argument,exception,invalid,number,of,points,in,line,string,found,coordinates,size,must,be,2
LineStringBuilder -> public LineStringBuilder(List<Coordinate> coordinates);1548434247;Construct a new LineString._Per GeoJSON spec (http://geojson.org/geojson-spec.html#linestring)_a LineString must contain two or more coordinates_@param coordinates the initial list of coordinates_@throws IllegalArgumentException if there are less then two coordinates defined;public LineStringBuilder(List<Coordinate> coordinates) {_        super(coordinates)__        if (coordinates.size() < 2) {_            throw new IllegalArgumentException("invalid number of points in LineString (found [" + coordinates.size()+ "] - must be >= 2)")__        }_    };construct,a,new,line,string,per,geo,json,spec,http,geojson,org,geojson,spec,html,linestring,a,line,string,must,contain,two,or,more,coordinates,param,coordinates,the,initial,list,of,coordinates,throws,illegal,argument,exception,if,there,are,less,then,two,coordinates,defined;public,line,string,builder,list,coordinate,coordinates,super,coordinates,if,coordinates,size,2,throw,new,illegal,argument,exception,invalid,number,of,points,in,line,string,found,coordinates,size,must,be,2
LineStringBuilder -> public LineStringBuilder close();1524684173;Closes the current lineString by adding the starting point as the end point._This will have no effect if starting and end point are already the same.;public LineStringBuilder close() {_        Coordinate start = coordinates.get(0)__        Coordinate end = coordinates.get(coordinates.size() - 1)__        if(start.x != end.x || start.y != end.y) {_            coordinates.add(start)__        }_        return this__    };closes,the,current,line,string,by,adding,the,starting,point,as,the,end,point,this,will,have,no,effect,if,starting,and,end,point,are,already,the,same;public,line,string,builder,close,coordinate,start,coordinates,get,0,coordinate,end,coordinates,get,coordinates,size,1,if,start,x,end,x,start,y,end,y,coordinates,add,start,return,this
LineStringBuilder -> public LineStringBuilder close();1542820501;Closes the current lineString by adding the starting point as the end point._This will have no effect if starting and end point are already the same.;public LineStringBuilder close() {_        Coordinate start = coordinates.get(0)__        Coordinate end = coordinates.get(coordinates.size() - 1)__        if(start.x != end.x || start.y != end.y) {_            coordinates.add(start)__        }_        return this__    };closes,the,current,line,string,by,adding,the,starting,point,as,the,end,point,this,will,have,no,effect,if,starting,and,end,point,are,already,the,same;public,line,string,builder,close,coordinate,start,coordinates,get,0,coordinate,end,coordinates,get,coordinates,size,1,if,start,x,end,x,start,y,end,y,coordinates,add,start,return,this
LineStringBuilder -> public LineStringBuilder close();1548434247;Closes the current lineString by adding the starting point as the end point._This will have no effect if starting and end point are already the same.;public LineStringBuilder close() {_        Coordinate start = coordinates.get(0)__        Coordinate end = coordinates.get(coordinates.size() - 1)__        if(start.x != end.x || start.y != end.y) {_            coordinates.add(start)__        }_        return this__    };closes,the,current,line,string,by,adding,the,starting,point,as,the,end,point,this,will,have,no,effect,if,starting,and,end,point,are,already,the,same;public,line,string,builder,close,coordinate,start,coordinates,get,0,coordinate,end,coordinates,get,coordinates,size,1,if,start,x,end,x,start,y,end,y,coordinates,add,start,return,this
LineStringBuilder -> private static Coordinate[][] decompose(double dateline, Coordinate[] coordinates);1524684173;Decompose a linestring given as array of coordinates at a vertical line.__@param dateline x-axis intercept of the vertical line_@param coordinates coordinates forming the linestring_@return array of linestrings given as coordinate arrays;private static Coordinate[][] decompose(double dateline, Coordinate[] coordinates) {_        int offset = 0__        ArrayList<Coordinate[]> parts = new ArrayList<>()___        double shift = coordinates[0].x > DATELINE ? DATELINE : (coordinates[0].x < -DATELINE ? -DATELINE : 0)___        for (int i = 1_ i < coordinates.length_ i++) {_            double t = intersection(coordinates[i-1], coordinates[i], dateline)__            if(!Double.isNaN(t)) {_                Coordinate[] part__                if(t<1) {_                    part = Arrays.copyOfRange(coordinates, offset, i+1)__                    part[part.length-1] = Edge.position(coordinates[i-1], coordinates[i], t)__                    coordinates[offset+i-1] = Edge.position(coordinates[i-1], coordinates[i], t)__                    shift(shift, part)__                    offset = i-1__                    shift = coordinates[i].x > DATELINE ? DATELINE : (coordinates[i].x < -DATELINE ? -DATELINE : 0)__                } else {_                    part = shift(shift, Arrays.copyOfRange(coordinates, offset, i+1))__                    offset = i__                }_                parts.add(part)__            }_        }__        if(offset == 0) {_            parts.add(shift(shift, coordinates))__        } else if(offset < coordinates.length-1) {_            Coordinate[] part = Arrays.copyOfRange(coordinates, offset, coordinates.length)__            parts.add(shift(shift, part))__        }_        return parts.toArray(new Coordinate[parts.size()][])__    };decompose,a,linestring,given,as,array,of,coordinates,at,a,vertical,line,param,dateline,x,axis,intercept,of,the,vertical,line,param,coordinates,coordinates,forming,the,linestring,return,array,of,linestrings,given,as,coordinate,arrays;private,static,coordinate,decompose,double,dateline,coordinate,coordinates,int,offset,0,array,list,coordinate,parts,new,array,list,double,shift,coordinates,0,x,dateline,dateline,coordinates,0,x,dateline,dateline,0,for,int,i,1,i,coordinates,length,i,double,t,intersection,coordinates,i,1,coordinates,i,dateline,if,double,is,na,n,t,coordinate,part,if,t,1,part,arrays,copy,of,range,coordinates,offset,i,1,part,part,length,1,edge,position,coordinates,i,1,coordinates,i,t,coordinates,offset,i,1,edge,position,coordinates,i,1,coordinates,i,t,shift,shift,part,offset,i,1,shift,coordinates,i,x,dateline,dateline,coordinates,i,x,dateline,dateline,0,else,part,shift,shift,arrays,copy,of,range,coordinates,offset,i,1,offset,i,parts,add,part,if,offset,0,parts,add,shift,shift,coordinates,else,if,offset,coordinates,length,1,coordinate,part,arrays,copy,of,range,coordinates,offset,coordinates,length,parts,add,shift,shift,part,return,parts,to,array,new,coordinate,parts,size
LineStringBuilder -> private static Coordinate[][] decompose(double dateline, Coordinate[] coordinates);1542820501;Decompose a linestring given as array of coordinates at a vertical line.__@param dateline x-axis intercept of the vertical line_@param coordinates coordinates forming the linestring_@return array of linestrings given as coordinate arrays;private static Coordinate[][] decompose(double dateline, Coordinate[] coordinates) {_        int offset = 0__        ArrayList<Coordinate[]> parts = new ArrayList<>()___        double shift = coordinates[0].x > DATELINE ? DATELINE : (coordinates[0].x < -DATELINE ? -DATELINE : 0)___        for (int i = 1_ i < coordinates.length_ i++) {_            double t = intersection(coordinates[i-1], coordinates[i], dateline)__            if(!Double.isNaN(t)) {_                Coordinate[] part__                if(t<1) {_                    part = Arrays.copyOfRange(coordinates, offset, i+1)__                    part[part.length-1] = Edge.position(coordinates[i-1], coordinates[i], t)__                    coordinates[offset+i-1] = Edge.position(coordinates[i-1], coordinates[i], t)__                    shift(shift, part)__                    offset = i-1__                    shift = coordinates[i].x > DATELINE ? DATELINE : (coordinates[i].x < -DATELINE ? -DATELINE : 0)__                } else {_                    part = shift(shift, Arrays.copyOfRange(coordinates, offset, i+1))__                    offset = i__                }_                parts.add(part)__            }_        }__        if(offset == 0) {_            parts.add(shift(shift, coordinates))__        } else if(offset < coordinates.length-1) {_            Coordinate[] part = Arrays.copyOfRange(coordinates, offset, coordinates.length)__            parts.add(shift(shift, part))__        }_        return parts.toArray(new Coordinate[parts.size()][])__    };decompose,a,linestring,given,as,array,of,coordinates,at,a,vertical,line,param,dateline,x,axis,intercept,of,the,vertical,line,param,coordinates,coordinates,forming,the,linestring,return,array,of,linestrings,given,as,coordinate,arrays;private,static,coordinate,decompose,double,dateline,coordinate,coordinates,int,offset,0,array,list,coordinate,parts,new,array,list,double,shift,coordinates,0,x,dateline,dateline,coordinates,0,x,dateline,dateline,0,for,int,i,1,i,coordinates,length,i,double,t,intersection,coordinates,i,1,coordinates,i,dateline,if,double,is,na,n,t,coordinate,part,if,t,1,part,arrays,copy,of,range,coordinates,offset,i,1,part,part,length,1,edge,position,coordinates,i,1,coordinates,i,t,coordinates,offset,i,1,edge,position,coordinates,i,1,coordinates,i,t,shift,shift,part,offset,i,1,shift,coordinates,i,x,dateline,dateline,coordinates,i,x,dateline,dateline,0,else,part,shift,shift,arrays,copy,of,range,coordinates,offset,i,1,offset,i,parts,add,part,if,offset,0,parts,add,shift,shift,coordinates,else,if,offset,coordinates,length,1,coordinate,part,arrays,copy,of,range,coordinates,offset,coordinates,length,parts,add,shift,shift,part,return,parts,to,array,new,coordinate,parts,size
LineStringBuilder -> private static Coordinate[][] decompose(double dateline, Coordinate[] coordinates);1548434247;Decompose a linestring given as array of coordinates at a vertical line.__@param dateline x-axis intercept of the vertical line_@param coordinates coordinates forming the linestring_@return array of linestrings given as coordinate arrays;private static Coordinate[][] decompose(double dateline, Coordinate[] coordinates) {_        int offset = 0__        ArrayList<Coordinate[]> parts = new ArrayList<>()___        double shift = coordinates[0].x > DATELINE ? DATELINE : (coordinates[0].x < -DATELINE ? -DATELINE : 0)___        for (int i = 1_ i < coordinates.length_ i++) {_            double t = intersection(coordinates[i-1], coordinates[i], dateline)__            if(!Double.isNaN(t)) {_                Coordinate[] part__                if(t<1) {_                    part = Arrays.copyOfRange(coordinates, offset, i+1)__                    part[part.length-1] = Edge.position(coordinates[i-1], coordinates[i], t)__                    coordinates[offset+i-1] = Edge.position(coordinates[i-1], coordinates[i], t)__                    shift(shift, part)__                    offset = i-1__                    shift = coordinates[i].x > DATELINE ? DATELINE : (coordinates[i].x < -DATELINE ? -DATELINE : 0)__                } else {_                    part = shift(shift, Arrays.copyOfRange(coordinates, offset, i+1))__                    offset = i__                }_                parts.add(part)__            }_        }__        if(offset == 0) {_            parts.add(shift(shift, coordinates))__        } else if(offset < coordinates.length-1) {_            Coordinate[] part = Arrays.copyOfRange(coordinates, offset, coordinates.length)__            parts.add(shift(shift, part))__        }_        return parts.toArray(new Coordinate[parts.size()][])__    };decompose,a,linestring,given,as,array,of,coordinates,at,a,vertical,line,param,dateline,x,axis,intercept,of,the,vertical,line,param,coordinates,coordinates,forming,the,linestring,return,array,of,linestrings,given,as,coordinate,arrays;private,static,coordinate,decompose,double,dateline,coordinate,coordinates,int,offset,0,array,list,coordinate,parts,new,array,list,double,shift,coordinates,0,x,dateline,dateline,coordinates,0,x,dateline,dateline,0,for,int,i,1,i,coordinates,length,i,double,t,intersection,coordinates,i,1,coordinates,i,dateline,if,double,is,na,n,t,coordinate,part,if,t,1,part,arrays,copy,of,range,coordinates,offset,i,1,part,part,length,1,edge,position,coordinates,i,1,coordinates,i,t,coordinates,offset,i,1,edge,position,coordinates,i,1,coordinates,i,t,shift,shift,part,offset,i,1,shift,coordinates,i,x,dateline,dateline,coordinates,i,x,dateline,dateline,0,else,part,shift,shift,arrays,copy,of,range,coordinates,offset,i,1,offset,i,parts,add,part,if,offset,0,parts,add,shift,shift,coordinates,else,if,offset,coordinates,length,1,coordinate,part,arrays,copy,of,range,coordinates,offset,coordinates,length,parts,add,shift,shift,part,return,parts,to,array,new,coordinate,parts,size
