commented;modifiers;parameterAmount;loc;comment;code
false;public;2;9;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.field(ShapeParser.FIELD_TYPE.getPreferredName(), TYPE.shapeName()).     builder.field(ShapeParser.FIELD_COORDINATES.getPreferredName()).     coordinatesToXcontent(builder, false).     builder.endObject().     return builder. }
true;public;0;8;/**  * Closes the current lineString by adding the starting point as the end point.  * This will have no effect if starting and end point are already the same.  */ ;/**  * Closes the current lineString by adding the starting point as the end point.  * This will have no effect if starting and end point are already the same.  */ public LineStringBuilder close() {     Coordinate start = coordinates.get(0).     Coordinate end = coordinates.get(coordinates.size() - 1).     if (start.x != end.x || start.y != end.y) {         coordinates.add(start).     }     return this. }
false;public;0;4;;@Override public GeoShapeType type() {     return TYPE. }
false;public;0;8;;@Override public int numDimensions() {     if (coordinates == null || coordinates.isEmpty()) {         throw new IllegalStateException("unable to get number of dimensions, " + "LineString has not yet been initialized").     }     return Double.isNaN(coordinates.get(0).z) ? 2 : 3. }
false;public;0;19;;@Override public JtsGeometry buildS4J() {     Coordinate[] coordinates = this.coordinates.toArray(new Coordinate[this.coordinates.size()]).     Geometry geometry.     if (wrapdateline) {         ArrayList<LineString> strings = decomposeS4J(FACTORY, coordinates, new ArrayList<LineString>()).         if (strings.size() == 1) {             geometry = strings.get(0).         } else {             LineString[] linestrings = strings.toArray(new LineString[strings.size()]).             geometry = FACTORY.createMultiLineString(linestrings).         }     } else {         geometry = FACTORY.createLineString(coordinates).     }     return jtsGeometry(geometry). }
false;public;0;15;;@Override public org.elasticsearch.geo.geometry.Geometry buildGeometry() {     // decompose linestrings crossing dateline into array of Lines     Coordinate[] coordinates = this.coordinates.toArray(new Coordinate[this.coordinates.size()]).     if (wrapdateline) {         List<Line> linestrings = decomposeGeometry(coordinates, new ArrayList<>()).         if (linestrings.size() == 1) {             return linestrings.get(0).         } else {             return new MultiLine(linestrings).         }     }     return new Line(Arrays.stream(coordinates).mapToDouble(i -> normalizeLat(i.y)).toArray(), Arrays.stream(coordinates).mapToDouble(i -> normalizeLon(i.x)).toArray()). }
false;static;3;8;;static ArrayList<LineString> decomposeS4J(GeometryFactory factory, Coordinate[] coordinates, ArrayList<LineString> strings) {     for (Coordinate[] part : decompose(+DATELINE, coordinates)) {         for (Coordinate[] line : decompose(-DATELINE, part)) {             strings.add(factory.createLineString(line)).         }     }     return strings. }
false;static;2;9;;static List<Line> decomposeGeometry(Coordinate[] coordinates, List<Line> lines) {     for (Coordinate[] part : decompose(+DATELINE, coordinates)) {         for (Coordinate[] line : decompose(-DATELINE, part)) {             lines.add(new Line(Arrays.stream(line).mapToDouble(i -> normalizeLat(i.y)).toArray(), Arrays.stream(line).mapToDouble(i -> normalizeLon(i.x)).toArray())).         }     }     return lines. }
true;private,static;2;33;/**  * Decompose a linestring given as array of coordinates at a vertical line.  *  * @param dateline x-axis intercept of the vertical line  * @param coordinates coordinates forming the linestring  * @return array of linestrings given as coordinate arrays  */ ;/**  * Decompose a linestring given as array of coordinates at a vertical line.  *  * @param dateline x-axis intercept of the vertical line  * @param coordinates coordinates forming the linestring  * @return array of linestrings given as coordinate arrays  */ private static Coordinate[][] decompose(double dateline, Coordinate[] coordinates) {     int offset = 0.     ArrayList<Coordinate[]> parts = new ArrayList<>().     double shift = coordinates[0].x > DATELINE ? DATELINE : (coordinates[0].x < -DATELINE ? -DATELINE : 0).     for (int i = 1. i < coordinates.length. i++) {         double t = intersection(coordinates[i - 1], coordinates[i], dateline).         if (!Double.isNaN(t)) {             Coordinate[] part.             if (t < 1) {                 part = Arrays.copyOfRange(coordinates, offset, i + 1).                 part[part.length - 1] = Edge.position(coordinates[i - 1], coordinates[i], t).                 coordinates[offset + i - 1] = Edge.position(coordinates[i - 1], coordinates[i], t).                 shift(shift, part).                 offset = i - 1.                 shift = coordinates[i].x > DATELINE ? DATELINE : (coordinates[i].x < -DATELINE ? -DATELINE : 0).             } else {                 part = shift(shift, Arrays.copyOfRange(coordinates, offset, i + 1)).                 offset = i.             }             parts.add(part).         }     }     if (offset == 0) {         parts.add(shift(shift, coordinates)).     } else if (offset < coordinates.length - 1) {         Coordinate[] part = Arrays.copyOfRange(coordinates, offset, coordinates.length).         parts.add(shift(shift, part)).     }     return parts.toArray(new Coordinate[parts.size()][]). }
false;private,static;2;8;;private static Coordinate[] shift(double shift, Coordinate... coordinates) {     if (shift != 0) {         for (int j = 0. j < coordinates.length. j++) {             coordinates[j] = new Coordinate(coordinates[j].x - 2 * shift, coordinates[j].y).         }     }     return coordinates. }
