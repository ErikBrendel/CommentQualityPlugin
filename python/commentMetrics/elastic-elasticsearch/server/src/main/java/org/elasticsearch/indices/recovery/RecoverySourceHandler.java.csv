# id;timestamp;commentText;codeText;commentWords;codeWords
RecoverySourceHandler -> public SendFileResult phase1(final IndexCommit snapshot, final Supplier<Integer> translogOps);1546981938;Perform phase1 of the recovery operations. Once this {@link IndexCommit}_snapshot has been performed no commit operations (files being fsync'd)_are effectively allowed on this index until all recovery phases are done_<p>_Phase1 examines the segment files on the target node and copies over the_segments that are missing. Only segments that have the same size and_checksum can be reused;public SendFileResult phase1(final IndexCommit snapshot, final Supplier<Integer> translogOps) {_        cancellableThreads.checkForCancel()__        _        long totalSize = 0__        _        long existingTotalSize = 0__        final List<String> phase1FileNames = new ArrayList<>()__        final List<Long> phase1FileSizes = new ArrayList<>()__        final List<String> phase1ExistingFileNames = new ArrayList<>()__        final List<Long> phase1ExistingFileSizes = new ArrayList<>()__        final Store store = shard.store()__        store.incRef()__        try {_            StopWatch stopWatch = new StopWatch().start()__            final Store.MetadataSnapshot recoverySourceMetadata__            try {_                recoverySourceMetadata = store.getMetadata(snapshot)__            } catch (CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {_                shard.failShard("recovery", ex)__                throw ex__            }_            for (String name : snapshot.getFileNames()) {_                final StoreFileMetaData md = recoverySourceMetadata.get(name)__                if (md == null) {_                    logger.info("Snapshot differs from actual index for file: {} meta: {}", name, recoverySourceMetadata.asMap())__                    throw new CorruptIndexException("Snapshot differs from actual index - maybe index was removed metadata has " +_                            recoverySourceMetadata.asMap().size() + " files", name)__                }_            }_            _            _            _            String recoverySourceSyncId = recoverySourceMetadata.getSyncId()__            String recoveryTargetSyncId = request.metadataSnapshot().getSyncId()__            final boolean recoverWithSyncId = recoverySourceSyncId != null &&_                    recoverySourceSyncId.equals(recoveryTargetSyncId)__            if (recoverWithSyncId) {_                final long numDocsTarget = request.metadataSnapshot().getNumDocs()__                final long numDocsSource = recoverySourceMetadata.getNumDocs()__                if (numDocsTarget != numDocsSource) {_                    throw new IllegalStateException("try to recover " + request.shardId() + " from primary shard with sync id but number " +_                            "of docs differ: " + numDocsSource + " (" + request.sourceNode().getName() + ", primary) vs " + numDocsTarget_                            + "(" + request.targetNode().getName() + ")")__                }_                _                _                logger.trace("skipping [phase1]- identical sync id [{}] found on both source and target", recoverySourceSyncId)__            } else {_                final Store.RecoveryDiff diff = recoverySourceMetadata.recoveryDiff(request.metadataSnapshot())__                for (StoreFileMetaData md : diff.identical) {_                    phase1ExistingFileNames.add(md.name())__                    phase1ExistingFileSizes.add(md.length())__                    existingTotalSize += md.length()__                    if (logger.isTraceEnabled()) {_                        logger.trace("recovery [phase1]: not recovering [{}], exist in local store and has checksum [{}]," +_                                        " size [{}]", md.name(), md.checksum(), md.length())__                    }_                    totalSize += md.length()__                }_                List<StoreFileMetaData> phase1Files = new ArrayList<>(diff.different.size() + diff.missing.size())__                phase1Files.addAll(diff.different)__                phase1Files.addAll(diff.missing)__                for (StoreFileMetaData md : phase1Files) {_                    if (request.metadataSnapshot().asMap().containsKey(md.name())) {_                        logger.trace("recovery [phase1]: recovering [{}], exists in local store, but is different: remote [{}], local [{}]",_                            md.name(), request.metadataSnapshot().asMap().get(md.name()), md)__                    } else {_                        logger.trace("recovery [phase1]: recovering [{}], does not exist in remote", md.name())__                    }_                    phase1FileNames.add(md.name())__                    phase1FileSizes.add(md.length())__                    totalSize += md.length()__                }__                logger.trace("recovery [phase1]: recovering_files [{}] with total_size [{}], reusing_files [{}] with total_size [{}]",_                    phase1FileNames.size(), new ByteSizeValue(totalSize),_                    phase1ExistingFileNames.size(), new ByteSizeValue(existingTotalSize))__                cancellableThreads.execute(() -> recoveryTarget.receiveFileInfo(_                    phase1FileNames, phase1FileSizes, phase1ExistingFileNames, phase1ExistingFileSizes, translogOps.get()))__                _                final Function<StoreFileMetaData, OutputStream> outputStreamFactories =_                        md -> new BufferedOutputStream(new RecoveryOutputStream(md, translogOps), chunkSizeInBytes)__                sendFiles(store, phase1Files.toArray(new StoreFileMetaData[phase1Files.size()]), outputStreamFactories)__                _                _                _                _                _                _                _                _                try {_                    cancellableThreads.executeIO(() ->_                        recoveryTarget.cleanFiles(translogOps.get(), recoverySourceMetadata))__                } catch (RemoteTransportException | IOException targetException) {_                    final IOException corruptIndexException__                    _                    _                    _                    _                    if ((corruptIndexException = ExceptionsHelper.unwrapCorruption(targetException)) != null) {_                        try {_                            final Store.MetadataSnapshot recoverySourceMetadata1 = store.getMetadata(snapshot)__                            StoreFileMetaData[] metadata =_                                    StreamSupport.stream(recoverySourceMetadata1.spliterator(), false).toArray(StoreFileMetaData[]::new)__                            ArrayUtil.timSort(metadata, Comparator.comparingLong(StoreFileMetaData::length))_ _                            for (StoreFileMetaData md : metadata) {_                                cancellableThreads.checkForCancel()__                                logger.debug("checking integrity for file {} after remove corruption exception", md)__                                if (store.checkIntegrityNoException(md) == false) { _                                    shard.failShard("recovery", corruptIndexException)__                                    logger.warn("Corrupted file detected {} checksum mismatch", md)__                                    throw corruptIndexException__                                }_                            }_                        } catch (IOException ex) {_                            targetException.addSuppressed(ex)__                            throw targetException__                        }_                        _                        RemoteTransportException exception = new RemoteTransportException("File corruption occurred on recovery but " +_                                "checksums are ok", null)__                        exception.addSuppressed(targetException)__                        logger.warn(() -> new ParameterizedMessage(_                                "{} Remote file corruption during finalization of recovery on node {}. local checksum OK",_                                shard.shardId(), request.targetNode()), corruptIndexException)__                        throw exception__                    } else {_                        throw targetException__                    }_                }_            }_            final TimeValue took = stopWatch.totalTime()__            logger.trace("recovery [phase1]: took [{}]", took)__            return new SendFileResult(phase1FileNames, phase1FileSizes, totalSize, phase1ExistingFileNames,_                phase1ExistingFileSizes, existingTotalSize, took)__        } catch (Exception e) {_            throw new RecoverFilesRecoveryException(request.shardId(), phase1FileNames.size(), new ByteSizeValue(totalSize), e)__        } finally {_            store.decRef()__        }_    };perform,phase1,of,the,recovery,operations,once,this,link,index,commit,snapshot,has,been,performed,no,commit,operations,files,being,fsync,d,are,effectively,allowed,on,this,index,until,all,recovery,phases,are,done,p,phase1,examines,the,segment,files,on,the,target,node,and,copies,over,the,segments,that,are,missing,only,segments,that,have,the,same,size,and,checksum,can,be,reused;public,send,file,result,phase1,final,index,commit,snapshot,final,supplier,integer,translog,ops,cancellable,threads,check,for,cancel,long,total,size,0,long,existing,total,size,0,final,list,string,phase1file,names,new,array,list,final,list,long,phase1file,sizes,new,array,list,final,list,string,phase1existing,file,names,new,array,list,final,list,long,phase1existing,file,sizes,new,array,list,final,store,store,shard,store,store,inc,ref,try,stop,watch,stop,watch,new,stop,watch,start,final,store,metadata,snapshot,recovery,source,metadata,try,recovery,source,metadata,store,get,metadata,snapshot,catch,corrupt,index,exception,index,format,too,old,exception,index,format,too,new,exception,ex,shard,fail,shard,recovery,ex,throw,ex,for,string,name,snapshot,get,file,names,final,store,file,meta,data,md,recovery,source,metadata,get,name,if,md,null,logger,info,snapshot,differs,from,actual,index,for,file,meta,name,recovery,source,metadata,as,map,throw,new,corrupt,index,exception,snapshot,differs,from,actual,index,maybe,index,was,removed,metadata,has,recovery,source,metadata,as,map,size,files,name,string,recovery,source,sync,id,recovery,source,metadata,get,sync,id,string,recovery,target,sync,id,request,metadata,snapshot,get,sync,id,final,boolean,recover,with,sync,id,recovery,source,sync,id,null,recovery,source,sync,id,equals,recovery,target,sync,id,if,recover,with,sync,id,final,long,num,docs,target,request,metadata,snapshot,get,num,docs,final,long,num,docs,source,recovery,source,metadata,get,num,docs,if,num,docs,target,num,docs,source,throw,new,illegal,state,exception,try,to,recover,request,shard,id,from,primary,shard,with,sync,id,but,number,of,docs,differ,num,docs,source,request,source,node,get,name,primary,vs,num,docs,target,request,target,node,get,name,logger,trace,skipping,phase1,identical,sync,id,found,on,both,source,and,target,recovery,source,sync,id,else,final,store,recovery,diff,diff,recovery,source,metadata,recovery,diff,request,metadata,snapshot,for,store,file,meta,data,md,diff,identical,phase1existing,file,names,add,md,name,phase1existing,file,sizes,add,md,length,existing,total,size,md,length,if,logger,is,trace,enabled,logger,trace,recovery,phase1,not,recovering,exist,in,local,store,and,has,checksum,size,md,name,md,checksum,md,length,total,size,md,length,list,store,file,meta,data,phase1files,new,array,list,diff,different,size,diff,missing,size,phase1files,add,all,diff,different,phase1files,add,all,diff,missing,for,store,file,meta,data,md,phase1files,if,request,metadata,snapshot,as,map,contains,key,md,name,logger,trace,recovery,phase1,recovering,exists,in,local,store,but,is,different,remote,local,md,name,request,metadata,snapshot,as,map,get,md,name,md,else,logger,trace,recovery,phase1,recovering,does,not,exist,in,remote,md,name,phase1file,names,add,md,name,phase1file,sizes,add,md,length,total,size,md,length,logger,trace,recovery,phase1,with,with,phase1file,names,size,new,byte,size,value,total,size,phase1existing,file,names,size,new,byte,size,value,existing,total,size,cancellable,threads,execute,recovery,target,receive,file,info,phase1file,names,phase1file,sizes,phase1existing,file,names,phase1existing,file,sizes,translog,ops,get,final,function,store,file,meta,data,output,stream,output,stream,factories,md,new,buffered,output,stream,new,recovery,output,stream,md,translog,ops,chunk,size,in,bytes,send,files,store,phase1files,to,array,new,store,file,meta,data,phase1files,size,output,stream,factories,try,cancellable,threads,execute,io,recovery,target,clean,files,translog,ops,get,recovery,source,metadata,catch,remote,transport,exception,ioexception,target,exception,final,ioexception,corrupt,index,exception,if,corrupt,index,exception,exceptions,helper,unwrap,corruption,target,exception,null,try,final,store,metadata,snapshot,recovery,source,metadata1,store,get,metadata,snapshot,store,file,meta,data,metadata,stream,support,stream,recovery,source,metadata1,spliterator,false,to,array,store,file,meta,data,new,array,util,tim,sort,metadata,comparator,comparing,long,store,file,meta,data,length,for,store,file,meta,data,md,metadata,cancellable,threads,check,for,cancel,logger,debug,checking,integrity,for,file,after,remove,corruption,exception,md,if,store,check,integrity,no,exception,md,false,shard,fail,shard,recovery,corrupt,index,exception,logger,warn,corrupted,file,detected,checksum,mismatch,md,throw,corrupt,index,exception,catch,ioexception,ex,target,exception,add,suppressed,ex,throw,target,exception,remote,transport,exception,exception,new,remote,transport,exception,file,corruption,occurred,on,recovery,but,checksums,are,ok,null,exception,add,suppressed,target,exception,logger,warn,new,parameterized,message,remote,file,corruption,during,finalization,of,recovery,on,node,local,checksum,ok,shard,shard,id,request,target,node,corrupt,index,exception,throw,exception,else,throw,target,exception,final,time,value,took,stop,watch,total,time,logger,trace,recovery,phase1,took,took,return,new,send,file,result,phase1file,names,phase1file,sizes,total,size,phase1existing,file,names,phase1existing,file,sizes,existing,total,size,took,catch,exception,e,throw,new,recover,files,recovery,exception,request,shard,id,phase1file,names,size,new,byte,size,value,total,size,e,finally,store,dec,ref
RecoverySourceHandler -> public SendFileResult phase1(final IndexCommit snapshot, final Supplier<Integer> translogOps);1547315388;Perform phase1 of the recovery operations. Once this {@link IndexCommit}_snapshot has been performed no commit operations (files being fsync'd)_are effectively allowed on this index until all recovery phases are done_<p>_Phase1 examines the segment files on the target node and copies over the_segments that are missing. Only segments that have the same size and_checksum can be reused;public SendFileResult phase1(final IndexCommit snapshot, final Supplier<Integer> translogOps) {_        cancellableThreads.checkForCancel()__        _        long totalSize = 0__        _        long existingTotalSize = 0__        final List<String> phase1FileNames = new ArrayList<>()__        final List<Long> phase1FileSizes = new ArrayList<>()__        final List<String> phase1ExistingFileNames = new ArrayList<>()__        final List<Long> phase1ExistingFileSizes = new ArrayList<>()__        final Store store = shard.store()__        store.incRef()__        try {_            StopWatch stopWatch = new StopWatch().start()__            final Store.MetadataSnapshot recoverySourceMetadata__            try {_                recoverySourceMetadata = store.getMetadata(snapshot)__            } catch (CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {_                shard.failShard("recovery", ex)__                throw ex__            }_            for (String name : snapshot.getFileNames()) {_                final StoreFileMetaData md = recoverySourceMetadata.get(name)__                if (md == null) {_                    logger.info("Snapshot differs from actual index for file: {} meta: {}", name, recoverySourceMetadata.asMap())__                    throw new CorruptIndexException("Snapshot differs from actual index - maybe index was removed metadata has " +_                            recoverySourceMetadata.asMap().size() + " files", name)__                }_            }_            _            _            _            String recoverySourceSyncId = recoverySourceMetadata.getSyncId()__            String recoveryTargetSyncId = request.metadataSnapshot().getSyncId()__            final boolean recoverWithSyncId = recoverySourceSyncId != null &&_                    recoverySourceSyncId.equals(recoveryTargetSyncId)__            if (recoverWithSyncId) {_                final long numDocsTarget = request.metadataSnapshot().getNumDocs()__                final long numDocsSource = recoverySourceMetadata.getNumDocs()__                if (numDocsTarget != numDocsSource) {_                    throw new IllegalStateException("try to recover " + request.shardId() + " from primary shard with sync id but number " +_                            "of docs differ: " + numDocsSource + " (" + request.sourceNode().getName() + ", primary) vs " + numDocsTarget_                            + "(" + request.targetNode().getName() + ")")__                }_                _                _                logger.trace("skipping [phase1]- identical sync id [{}] found on both source and target", recoverySourceSyncId)__            } else {_                final Store.RecoveryDiff diff = recoverySourceMetadata.recoveryDiff(request.metadataSnapshot())__                for (StoreFileMetaData md : diff.identical) {_                    phase1ExistingFileNames.add(md.name())__                    phase1ExistingFileSizes.add(md.length())__                    existingTotalSize += md.length()__                    if (logger.isTraceEnabled()) {_                        logger.trace("recovery [phase1]: not recovering [{}], exist in local store and has checksum [{}]," +_                                        " size [{}]", md.name(), md.checksum(), md.length())__                    }_                    totalSize += md.length()__                }_                List<StoreFileMetaData> phase1Files = new ArrayList<>(diff.different.size() + diff.missing.size())__                phase1Files.addAll(diff.different)__                phase1Files.addAll(diff.missing)__                for (StoreFileMetaData md : phase1Files) {_                    if (request.metadataSnapshot().asMap().containsKey(md.name())) {_                        logger.trace("recovery [phase1]: recovering [{}], exists in local store, but is different: remote [{}], local [{}]",_                            md.name(), request.metadataSnapshot().asMap().get(md.name()), md)__                    } else {_                        logger.trace("recovery [phase1]: recovering [{}], does not exist in remote", md.name())__                    }_                    phase1FileNames.add(md.name())__                    phase1FileSizes.add(md.length())__                    totalSize += md.length()__                }__                logger.trace("recovery [phase1]: recovering_files [{}] with total_size [{}], reusing_files [{}] with total_size [{}]",_                    phase1FileNames.size(), new ByteSizeValue(totalSize),_                    phase1ExistingFileNames.size(), new ByteSizeValue(existingTotalSize))__                cancellableThreads.execute(() -> recoveryTarget.receiveFileInfo(_                    phase1FileNames, phase1FileSizes, phase1ExistingFileNames, phase1ExistingFileSizes, translogOps.get()))__                _                final Function<StoreFileMetaData, OutputStream> outputStreamFactories =_                        md -> new BufferedOutputStream(new RecoveryOutputStream(md, translogOps), chunkSizeInBytes)__                sendFiles(store, phase1Files.toArray(new StoreFileMetaData[phase1Files.size()]), outputStreamFactories)__                _                _                _                _                _                _                _                _                try {_                    cancellableThreads.executeIO(() ->_                        recoveryTarget.cleanFiles(translogOps.get(), recoverySourceMetadata))__                } catch (RemoteTransportException | IOException targetException) {_                    final IOException corruptIndexException__                    _                    _                    _                    _                    if ((corruptIndexException = ExceptionsHelper.unwrapCorruption(targetException)) != null) {_                        try {_                            final Store.MetadataSnapshot recoverySourceMetadata1 = store.getMetadata(snapshot)__                            StoreFileMetaData[] metadata =_                                    StreamSupport.stream(recoverySourceMetadata1.spliterator(), false).toArray(StoreFileMetaData[]::new)__                            ArrayUtil.timSort(metadata, Comparator.comparingLong(StoreFileMetaData::length))_ _                            for (StoreFileMetaData md : metadata) {_                                cancellableThreads.checkForCancel()__                                logger.debug("checking integrity for file {} after remove corruption exception", md)__                                if (store.checkIntegrityNoException(md) == false) { _                                    shard.failShard("recovery", corruptIndexException)__                                    logger.warn("Corrupted file detected {} checksum mismatch", md)__                                    throw corruptIndexException__                                }_                            }_                        } catch (IOException ex) {_                            targetException.addSuppressed(ex)__                            throw targetException__                        }_                        _                        RemoteTransportException exception = new RemoteTransportException("File corruption occurred on recovery but " +_                                "checksums are ok", null)__                        exception.addSuppressed(targetException)__                        logger.warn(() -> new ParameterizedMessage(_                                "{} Remote file corruption during finalization of recovery on node {}. local checksum OK",_                                shard.shardId(), request.targetNode()), corruptIndexException)__                        throw exception__                    } else {_                        throw targetException__                    }_                }_            }_            final TimeValue took = stopWatch.totalTime()__            logger.trace("recovery [phase1]: took [{}]", took)__            return new SendFileResult(phase1FileNames, phase1FileSizes, totalSize, phase1ExistingFileNames,_                phase1ExistingFileSizes, existingTotalSize, took)__        } catch (Exception e) {_            throw new RecoverFilesRecoveryException(request.shardId(), phase1FileNames.size(), new ByteSizeValue(totalSize), e)__        } finally {_            store.decRef()__        }_    };perform,phase1,of,the,recovery,operations,once,this,link,index,commit,snapshot,has,been,performed,no,commit,operations,files,being,fsync,d,are,effectively,allowed,on,this,index,until,all,recovery,phases,are,done,p,phase1,examines,the,segment,files,on,the,target,node,and,copies,over,the,segments,that,are,missing,only,segments,that,have,the,same,size,and,checksum,can,be,reused;public,send,file,result,phase1,final,index,commit,snapshot,final,supplier,integer,translog,ops,cancellable,threads,check,for,cancel,long,total,size,0,long,existing,total,size,0,final,list,string,phase1file,names,new,array,list,final,list,long,phase1file,sizes,new,array,list,final,list,string,phase1existing,file,names,new,array,list,final,list,long,phase1existing,file,sizes,new,array,list,final,store,store,shard,store,store,inc,ref,try,stop,watch,stop,watch,new,stop,watch,start,final,store,metadata,snapshot,recovery,source,metadata,try,recovery,source,metadata,store,get,metadata,snapshot,catch,corrupt,index,exception,index,format,too,old,exception,index,format,too,new,exception,ex,shard,fail,shard,recovery,ex,throw,ex,for,string,name,snapshot,get,file,names,final,store,file,meta,data,md,recovery,source,metadata,get,name,if,md,null,logger,info,snapshot,differs,from,actual,index,for,file,meta,name,recovery,source,metadata,as,map,throw,new,corrupt,index,exception,snapshot,differs,from,actual,index,maybe,index,was,removed,metadata,has,recovery,source,metadata,as,map,size,files,name,string,recovery,source,sync,id,recovery,source,metadata,get,sync,id,string,recovery,target,sync,id,request,metadata,snapshot,get,sync,id,final,boolean,recover,with,sync,id,recovery,source,sync,id,null,recovery,source,sync,id,equals,recovery,target,sync,id,if,recover,with,sync,id,final,long,num,docs,target,request,metadata,snapshot,get,num,docs,final,long,num,docs,source,recovery,source,metadata,get,num,docs,if,num,docs,target,num,docs,source,throw,new,illegal,state,exception,try,to,recover,request,shard,id,from,primary,shard,with,sync,id,but,number,of,docs,differ,num,docs,source,request,source,node,get,name,primary,vs,num,docs,target,request,target,node,get,name,logger,trace,skipping,phase1,identical,sync,id,found,on,both,source,and,target,recovery,source,sync,id,else,final,store,recovery,diff,diff,recovery,source,metadata,recovery,diff,request,metadata,snapshot,for,store,file,meta,data,md,diff,identical,phase1existing,file,names,add,md,name,phase1existing,file,sizes,add,md,length,existing,total,size,md,length,if,logger,is,trace,enabled,logger,trace,recovery,phase1,not,recovering,exist,in,local,store,and,has,checksum,size,md,name,md,checksum,md,length,total,size,md,length,list,store,file,meta,data,phase1files,new,array,list,diff,different,size,diff,missing,size,phase1files,add,all,diff,different,phase1files,add,all,diff,missing,for,store,file,meta,data,md,phase1files,if,request,metadata,snapshot,as,map,contains,key,md,name,logger,trace,recovery,phase1,recovering,exists,in,local,store,but,is,different,remote,local,md,name,request,metadata,snapshot,as,map,get,md,name,md,else,logger,trace,recovery,phase1,recovering,does,not,exist,in,remote,md,name,phase1file,names,add,md,name,phase1file,sizes,add,md,length,total,size,md,length,logger,trace,recovery,phase1,with,with,phase1file,names,size,new,byte,size,value,total,size,phase1existing,file,names,size,new,byte,size,value,existing,total,size,cancellable,threads,execute,recovery,target,receive,file,info,phase1file,names,phase1file,sizes,phase1existing,file,names,phase1existing,file,sizes,translog,ops,get,final,function,store,file,meta,data,output,stream,output,stream,factories,md,new,buffered,output,stream,new,recovery,output,stream,md,translog,ops,chunk,size,in,bytes,send,files,store,phase1files,to,array,new,store,file,meta,data,phase1files,size,output,stream,factories,try,cancellable,threads,execute,io,recovery,target,clean,files,translog,ops,get,recovery,source,metadata,catch,remote,transport,exception,ioexception,target,exception,final,ioexception,corrupt,index,exception,if,corrupt,index,exception,exceptions,helper,unwrap,corruption,target,exception,null,try,final,store,metadata,snapshot,recovery,source,metadata1,store,get,metadata,snapshot,store,file,meta,data,metadata,stream,support,stream,recovery,source,metadata1,spliterator,false,to,array,store,file,meta,data,new,array,util,tim,sort,metadata,comparator,comparing,long,store,file,meta,data,length,for,store,file,meta,data,md,metadata,cancellable,threads,check,for,cancel,logger,debug,checking,integrity,for,file,after,remove,corruption,exception,md,if,store,check,integrity,no,exception,md,false,shard,fail,shard,recovery,corrupt,index,exception,logger,warn,corrupted,file,detected,checksum,mismatch,md,throw,corrupt,index,exception,catch,ioexception,ex,target,exception,add,suppressed,ex,throw,target,exception,remote,transport,exception,exception,new,remote,transport,exception,file,corruption,occurred,on,recovery,but,checksums,are,ok,null,exception,add,suppressed,target,exception,logger,warn,new,parameterized,message,remote,file,corruption,during,finalization,of,recovery,on,node,local,checksum,ok,shard,shard,id,request,target,node,corrupt,index,exception,throw,exception,else,throw,target,exception,final,time,value,took,stop,watch,total,time,logger,trace,recovery,phase1,took,took,return,new,send,file,result,phase1file,names,phase1file,sizes,total,size,phase1existing,file,names,phase1existing,file,sizes,existing,total,size,took,catch,exception,e,throw,new,recover,files,recovery,exception,request,shard,id,phase1file,names,size,new,byte,size,value,total,size,e,finally,store,dec,ref
RecoverySourceHandler -> public SendFileResult phase1(final IndexCommit snapshot, final Supplier<Integer> translogOps);1547496886;Perform phase1 of the recovery operations. Once this {@link IndexCommit}_snapshot has been performed no commit operations (files being fsync'd)_are effectively allowed on this index until all recovery phases are done_<p>_Phase1 examines the segment files on the target node and copies over the_segments that are missing. Only segments that have the same size and_checksum can be reused;public SendFileResult phase1(final IndexCommit snapshot, final Supplier<Integer> translogOps) {_        cancellableThreads.checkForCancel()__        _        long totalSize = 0__        _        long existingTotalSize = 0__        final List<String> phase1FileNames = new ArrayList<>()__        final List<Long> phase1FileSizes = new ArrayList<>()__        final List<String> phase1ExistingFileNames = new ArrayList<>()__        final List<Long> phase1ExistingFileSizes = new ArrayList<>()__        final Store store = shard.store()__        store.incRef()__        try {_            StopWatch stopWatch = new StopWatch().start()__            final Store.MetadataSnapshot recoverySourceMetadata__            try {_                recoverySourceMetadata = store.getMetadata(snapshot)__            } catch (CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {_                shard.failShard("recovery", ex)__                throw ex__            }_            for (String name : snapshot.getFileNames()) {_                final StoreFileMetaData md = recoverySourceMetadata.get(name)__                if (md == null) {_                    logger.info("Snapshot differs from actual index for file: {} meta: {}", name, recoverySourceMetadata.asMap())__                    throw new CorruptIndexException("Snapshot differs from actual index - maybe index was removed metadata has " +_                            recoverySourceMetadata.asMap().size() + " files", name)__                }_            }_            _            _            _            String recoverySourceSyncId = recoverySourceMetadata.getSyncId()__            String recoveryTargetSyncId = request.metadataSnapshot().getSyncId()__            final boolean recoverWithSyncId = recoverySourceSyncId != null &&_                    recoverySourceSyncId.equals(recoveryTargetSyncId)__            if (recoverWithSyncId) {_                final long numDocsTarget = request.metadataSnapshot().getNumDocs()__                final long numDocsSource = recoverySourceMetadata.getNumDocs()__                if (numDocsTarget != numDocsSource) {_                    throw new IllegalStateException("try to recover " + request.shardId() + " from primary shard with sync id but number " +_                            "of docs differ: " + numDocsSource + " (" + request.sourceNode().getName() + ", primary) vs " + numDocsTarget_                            + "(" + request.targetNode().getName() + ")")__                }_                _                _                logger.trace("skipping [phase1]- identical sync id [{}] found on both source and target", recoverySourceSyncId)__            } else {_                final Store.RecoveryDiff diff = recoverySourceMetadata.recoveryDiff(request.metadataSnapshot())__                for (StoreFileMetaData md : diff.identical) {_                    phase1ExistingFileNames.add(md.name())__                    phase1ExistingFileSizes.add(md.length())__                    existingTotalSize += md.length()__                    if (logger.isTraceEnabled()) {_                        logger.trace("recovery [phase1]: not recovering [{}], exist in local store and has checksum [{}]," +_                                        " size [{}]", md.name(), md.checksum(), md.length())__                    }_                    totalSize += md.length()__                }_                List<StoreFileMetaData> phase1Files = new ArrayList<>(diff.different.size() + diff.missing.size())__                phase1Files.addAll(diff.different)__                phase1Files.addAll(diff.missing)__                for (StoreFileMetaData md : phase1Files) {_                    if (request.metadataSnapshot().asMap().containsKey(md.name())) {_                        logger.trace("recovery [phase1]: recovering [{}], exists in local store, but is different: remote [{}], local [{}]",_                            md.name(), request.metadataSnapshot().asMap().get(md.name()), md)__                    } else {_                        logger.trace("recovery [phase1]: recovering [{}], does not exist in remote", md.name())__                    }_                    phase1FileNames.add(md.name())__                    phase1FileSizes.add(md.length())__                    totalSize += md.length()__                }__                logger.trace("recovery [phase1]: recovering_files [{}] with total_size [{}], reusing_files [{}] with total_size [{}]",_                    phase1FileNames.size(), new ByteSizeValue(totalSize),_                    phase1ExistingFileNames.size(), new ByteSizeValue(existingTotalSize))__                cancellableThreads.execute(() -> recoveryTarget.receiveFileInfo(_                    phase1FileNames, phase1FileSizes, phase1ExistingFileNames, phase1ExistingFileSizes, translogOps.get()))__                sendFiles(store, phase1Files.toArray(new StoreFileMetaData[0]), translogOps)__                _                _                _                _                _                _                _                _                try {_                    cancellableThreads.executeIO(() ->_                        recoveryTarget.cleanFiles(translogOps.get(), recoverySourceMetadata))__                } catch (RemoteTransportException | IOException targetException) {_                    final IOException corruptIndexException__                    _                    _                    _                    _                    if ((corruptIndexException = ExceptionsHelper.unwrapCorruption(targetException)) != null) {_                        try {_                            final Store.MetadataSnapshot recoverySourceMetadata1 = store.getMetadata(snapshot)__                            StoreFileMetaData[] metadata =_                                    StreamSupport.stream(recoverySourceMetadata1.spliterator(), false).toArray(StoreFileMetaData[]::new)__                            ArrayUtil.timSort(metadata, Comparator.comparingLong(StoreFileMetaData::length))_ _                            for (StoreFileMetaData md : metadata) {_                                cancellableThreads.checkForCancel()__                                logger.debug("checking integrity for file {} after remove corruption exception", md)__                                if (store.checkIntegrityNoException(md) == false) { _                                    shard.failShard("recovery", corruptIndexException)__                                    logger.warn("Corrupted file detected {} checksum mismatch", md)__                                    throw corruptIndexException__                                }_                            }_                        } catch (IOException ex) {_                            targetException.addSuppressed(ex)__                            throw targetException__                        }_                        _                        RemoteTransportException exception = new RemoteTransportException("File corruption occurred on recovery but " +_                                "checksums are ok", null)__                        exception.addSuppressed(targetException)__                        logger.warn(() -> new ParameterizedMessage(_                                "{} Remote file corruption during finalization of recovery on node {}. local checksum OK",_                                shard.shardId(), request.targetNode()), corruptIndexException)__                        throw exception__                    } else {_                        throw targetException__                    }_                }_            }_            final TimeValue took = stopWatch.totalTime()__            logger.trace("recovery [phase1]: took [{}]", took)__            return new SendFileResult(phase1FileNames, phase1FileSizes, totalSize, phase1ExistingFileNames,_                phase1ExistingFileSizes, existingTotalSize, took)__        } catch (Exception e) {_            throw new RecoverFilesRecoveryException(request.shardId(), phase1FileNames.size(), new ByteSizeValue(totalSize), e)__        } finally {_            store.decRef()__        }_    };perform,phase1,of,the,recovery,operations,once,this,link,index,commit,snapshot,has,been,performed,no,commit,operations,files,being,fsync,d,are,effectively,allowed,on,this,index,until,all,recovery,phases,are,done,p,phase1,examines,the,segment,files,on,the,target,node,and,copies,over,the,segments,that,are,missing,only,segments,that,have,the,same,size,and,checksum,can,be,reused;public,send,file,result,phase1,final,index,commit,snapshot,final,supplier,integer,translog,ops,cancellable,threads,check,for,cancel,long,total,size,0,long,existing,total,size,0,final,list,string,phase1file,names,new,array,list,final,list,long,phase1file,sizes,new,array,list,final,list,string,phase1existing,file,names,new,array,list,final,list,long,phase1existing,file,sizes,new,array,list,final,store,store,shard,store,store,inc,ref,try,stop,watch,stop,watch,new,stop,watch,start,final,store,metadata,snapshot,recovery,source,metadata,try,recovery,source,metadata,store,get,metadata,snapshot,catch,corrupt,index,exception,index,format,too,old,exception,index,format,too,new,exception,ex,shard,fail,shard,recovery,ex,throw,ex,for,string,name,snapshot,get,file,names,final,store,file,meta,data,md,recovery,source,metadata,get,name,if,md,null,logger,info,snapshot,differs,from,actual,index,for,file,meta,name,recovery,source,metadata,as,map,throw,new,corrupt,index,exception,snapshot,differs,from,actual,index,maybe,index,was,removed,metadata,has,recovery,source,metadata,as,map,size,files,name,string,recovery,source,sync,id,recovery,source,metadata,get,sync,id,string,recovery,target,sync,id,request,metadata,snapshot,get,sync,id,final,boolean,recover,with,sync,id,recovery,source,sync,id,null,recovery,source,sync,id,equals,recovery,target,sync,id,if,recover,with,sync,id,final,long,num,docs,target,request,metadata,snapshot,get,num,docs,final,long,num,docs,source,recovery,source,metadata,get,num,docs,if,num,docs,target,num,docs,source,throw,new,illegal,state,exception,try,to,recover,request,shard,id,from,primary,shard,with,sync,id,but,number,of,docs,differ,num,docs,source,request,source,node,get,name,primary,vs,num,docs,target,request,target,node,get,name,logger,trace,skipping,phase1,identical,sync,id,found,on,both,source,and,target,recovery,source,sync,id,else,final,store,recovery,diff,diff,recovery,source,metadata,recovery,diff,request,metadata,snapshot,for,store,file,meta,data,md,diff,identical,phase1existing,file,names,add,md,name,phase1existing,file,sizes,add,md,length,existing,total,size,md,length,if,logger,is,trace,enabled,logger,trace,recovery,phase1,not,recovering,exist,in,local,store,and,has,checksum,size,md,name,md,checksum,md,length,total,size,md,length,list,store,file,meta,data,phase1files,new,array,list,diff,different,size,diff,missing,size,phase1files,add,all,diff,different,phase1files,add,all,diff,missing,for,store,file,meta,data,md,phase1files,if,request,metadata,snapshot,as,map,contains,key,md,name,logger,trace,recovery,phase1,recovering,exists,in,local,store,but,is,different,remote,local,md,name,request,metadata,snapshot,as,map,get,md,name,md,else,logger,trace,recovery,phase1,recovering,does,not,exist,in,remote,md,name,phase1file,names,add,md,name,phase1file,sizes,add,md,length,total,size,md,length,logger,trace,recovery,phase1,with,with,phase1file,names,size,new,byte,size,value,total,size,phase1existing,file,names,size,new,byte,size,value,existing,total,size,cancellable,threads,execute,recovery,target,receive,file,info,phase1file,names,phase1file,sizes,phase1existing,file,names,phase1existing,file,sizes,translog,ops,get,send,files,store,phase1files,to,array,new,store,file,meta,data,0,translog,ops,try,cancellable,threads,execute,io,recovery,target,clean,files,translog,ops,get,recovery,source,metadata,catch,remote,transport,exception,ioexception,target,exception,final,ioexception,corrupt,index,exception,if,corrupt,index,exception,exceptions,helper,unwrap,corruption,target,exception,null,try,final,store,metadata,snapshot,recovery,source,metadata1,store,get,metadata,snapshot,store,file,meta,data,metadata,stream,support,stream,recovery,source,metadata1,spliterator,false,to,array,store,file,meta,data,new,array,util,tim,sort,metadata,comparator,comparing,long,store,file,meta,data,length,for,store,file,meta,data,md,metadata,cancellable,threads,check,for,cancel,logger,debug,checking,integrity,for,file,after,remove,corruption,exception,md,if,store,check,integrity,no,exception,md,false,shard,fail,shard,recovery,corrupt,index,exception,logger,warn,corrupted,file,detected,checksum,mismatch,md,throw,corrupt,index,exception,catch,ioexception,ex,target,exception,add,suppressed,ex,throw,target,exception,remote,transport,exception,exception,new,remote,transport,exception,file,corruption,occurred,on,recovery,but,checksums,are,ok,null,exception,add,suppressed,target,exception,logger,warn,new,parameterized,message,remote,file,corruption,during,finalization,of,recovery,on,node,local,checksum,ok,shard,shard,id,request,target,node,corrupt,index,exception,throw,exception,else,throw,target,exception,final,time,value,took,stop,watch,total,time,logger,trace,recovery,phase1,took,took,return,new,send,file,result,phase1file,names,phase1file,sizes,total,size,phase1existing,file,names,phase1existing,file,sizes,existing,total,size,took,catch,exception,e,throw,new,recover,files,recovery,exception,request,shard,id,phase1file,names,size,new,byte,size,value,total,size,e,finally,store,dec,ref
RecoverySourceHandler -> public SendFileResult phase1(final IndexCommit snapshot, final Supplier<Integer> translogOps);1547508054;Perform phase1 of the recovery operations. Once this {@link IndexCommit}_snapshot has been performed no commit operations (files being fsync'd)_are effectively allowed on this index until all recovery phases are done_<p>_Phase1 examines the segment files on the target node and copies over the_segments that are missing. Only segments that have the same size and_checksum can be reused;public SendFileResult phase1(final IndexCommit snapshot, final Supplier<Integer> translogOps) {_        cancellableThreads.checkForCancel()__        _        long totalSize = 0__        _        long existingTotalSize = 0__        final List<String> phase1FileNames = new ArrayList<>()__        final List<Long> phase1FileSizes = new ArrayList<>()__        final List<String> phase1ExistingFileNames = new ArrayList<>()__        final List<Long> phase1ExistingFileSizes = new ArrayList<>()__        final Store store = shard.store()__        store.incRef()__        try {_            StopWatch stopWatch = new StopWatch().start()__            final Store.MetadataSnapshot recoverySourceMetadata__            try {_                recoverySourceMetadata = store.getMetadata(snapshot)__            } catch (CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {_                shard.failShard("recovery", ex)__                throw ex__            }_            for (String name : snapshot.getFileNames()) {_                final StoreFileMetaData md = recoverySourceMetadata.get(name)__                if (md == null) {_                    logger.info("Snapshot differs from actual index for file: {} meta: {}", name, recoverySourceMetadata.asMap())__                    throw new CorruptIndexException("Snapshot differs from actual index - maybe index was removed metadata has " +_                            recoverySourceMetadata.asMap().size() + " files", name)__                }_            }_            _            _            _            String recoverySourceSyncId = recoverySourceMetadata.getSyncId()__            String recoveryTargetSyncId = request.metadataSnapshot().getSyncId()__            final boolean recoverWithSyncId = recoverySourceSyncId != null &&_                    recoverySourceSyncId.equals(recoveryTargetSyncId)__            if (recoverWithSyncId) {_                final long numDocsTarget = request.metadataSnapshot().getNumDocs()__                final long numDocsSource = recoverySourceMetadata.getNumDocs()__                if (numDocsTarget != numDocsSource) {_                    throw new IllegalStateException("try to recover " + request.shardId() + " from primary shard with sync id but number " +_                            "of docs differ: " + numDocsSource + " (" + request.sourceNode().getName() + ", primary) vs " + numDocsTarget_                            + "(" + request.targetNode().getName() + ")")__                }_                _                _                logger.trace("skipping [phase1]- identical sync id [{}] found on both source and target", recoverySourceSyncId)__            } else {_                final Store.RecoveryDiff diff = recoverySourceMetadata.recoveryDiff(request.metadataSnapshot())__                for (StoreFileMetaData md : diff.identical) {_                    phase1ExistingFileNames.add(md.name())__                    phase1ExistingFileSizes.add(md.length())__                    existingTotalSize += md.length()__                    if (logger.isTraceEnabled()) {_                        logger.trace("recovery [phase1]: not recovering [{}], exist in local store and has checksum [{}]," +_                                        " size [{}]", md.name(), md.checksum(), md.length())__                    }_                    totalSize += md.length()__                }_                List<StoreFileMetaData> phase1Files = new ArrayList<>(diff.different.size() + diff.missing.size())__                phase1Files.addAll(diff.different)__                phase1Files.addAll(diff.missing)__                for (StoreFileMetaData md : phase1Files) {_                    if (request.metadataSnapshot().asMap().containsKey(md.name())) {_                        logger.trace("recovery [phase1]: recovering [{}], exists in local store, but is different: remote [{}], local [{}]",_                            md.name(), request.metadataSnapshot().asMap().get(md.name()), md)__                    } else {_                        logger.trace("recovery [phase1]: recovering [{}], does not exist in remote", md.name())__                    }_                    phase1FileNames.add(md.name())__                    phase1FileSizes.add(md.length())__                    totalSize += md.length()__                }__                logger.trace("recovery [phase1]: recovering_files [{}] with total_size [{}], reusing_files [{}] with total_size [{}]",_                    phase1FileNames.size(), new ByteSizeValue(totalSize),_                    phase1ExistingFileNames.size(), new ByteSizeValue(existingTotalSize))__                cancellableThreads.execute(() -> recoveryTarget.receiveFileInfo(_                    phase1FileNames, phase1FileSizes, phase1ExistingFileNames, phase1ExistingFileSizes, translogOps.get()))__                sendFiles(store, phase1Files.toArray(new StoreFileMetaData[0]), translogOps)__                _                _                _                _                _                _                _                _                try {_                    cancellableThreads.executeIO(() ->_                        recoveryTarget.cleanFiles(translogOps.get(), recoverySourceMetadata))__                } catch (RemoteTransportException | IOException targetException) {_                    final IOException corruptIndexException__                    _                    _                    _                    _                    if ((corruptIndexException = ExceptionsHelper.unwrapCorruption(targetException)) != null) {_                        try {_                            final Store.MetadataSnapshot recoverySourceMetadata1 = store.getMetadata(snapshot)__                            StoreFileMetaData[] metadata =_                                    StreamSupport.stream(recoverySourceMetadata1.spliterator(), false).toArray(StoreFileMetaData[]::new)__                            ArrayUtil.timSort(metadata, Comparator.comparingLong(StoreFileMetaData::length))_ _                            for (StoreFileMetaData md : metadata) {_                                cancellableThreads.checkForCancel()__                                logger.debug("checking integrity for file {} after remove corruption exception", md)__                                if (store.checkIntegrityNoException(md) == false) { _                                    shard.failShard("recovery", corruptIndexException)__                                    logger.warn("Corrupted file detected {} checksum mismatch", md)__                                    throw corruptIndexException__                                }_                            }_                        } catch (IOException ex) {_                            targetException.addSuppressed(ex)__                            throw targetException__                        }_                        _                        RemoteTransportException exception = new RemoteTransportException("File corruption occurred on recovery but " +_                                "checksums are ok", null)__                        exception.addSuppressed(targetException)__                        logger.warn(() -> new ParameterizedMessage(_                                "{} Remote file corruption during finalization of recovery on node {}. local checksum OK",_                                shard.shardId(), request.targetNode()), corruptIndexException)__                        throw exception__                    } else {_                        throw targetException__                    }_                }_            }_            final TimeValue took = stopWatch.totalTime()__            logger.trace("recovery [phase1]: took [{}]", took)__            return new SendFileResult(phase1FileNames, phase1FileSizes, totalSize, phase1ExistingFileNames,_                phase1ExistingFileSizes, existingTotalSize, took)__        } catch (Exception e) {_            throw new RecoverFilesRecoveryException(request.shardId(), phase1FileNames.size(), new ByteSizeValue(totalSize), e)__        } finally {_            store.decRef()__        }_    };perform,phase1,of,the,recovery,operations,once,this,link,index,commit,snapshot,has,been,performed,no,commit,operations,files,being,fsync,d,are,effectively,allowed,on,this,index,until,all,recovery,phases,are,done,p,phase1,examines,the,segment,files,on,the,target,node,and,copies,over,the,segments,that,are,missing,only,segments,that,have,the,same,size,and,checksum,can,be,reused;public,send,file,result,phase1,final,index,commit,snapshot,final,supplier,integer,translog,ops,cancellable,threads,check,for,cancel,long,total,size,0,long,existing,total,size,0,final,list,string,phase1file,names,new,array,list,final,list,long,phase1file,sizes,new,array,list,final,list,string,phase1existing,file,names,new,array,list,final,list,long,phase1existing,file,sizes,new,array,list,final,store,store,shard,store,store,inc,ref,try,stop,watch,stop,watch,new,stop,watch,start,final,store,metadata,snapshot,recovery,source,metadata,try,recovery,source,metadata,store,get,metadata,snapshot,catch,corrupt,index,exception,index,format,too,old,exception,index,format,too,new,exception,ex,shard,fail,shard,recovery,ex,throw,ex,for,string,name,snapshot,get,file,names,final,store,file,meta,data,md,recovery,source,metadata,get,name,if,md,null,logger,info,snapshot,differs,from,actual,index,for,file,meta,name,recovery,source,metadata,as,map,throw,new,corrupt,index,exception,snapshot,differs,from,actual,index,maybe,index,was,removed,metadata,has,recovery,source,metadata,as,map,size,files,name,string,recovery,source,sync,id,recovery,source,metadata,get,sync,id,string,recovery,target,sync,id,request,metadata,snapshot,get,sync,id,final,boolean,recover,with,sync,id,recovery,source,sync,id,null,recovery,source,sync,id,equals,recovery,target,sync,id,if,recover,with,sync,id,final,long,num,docs,target,request,metadata,snapshot,get,num,docs,final,long,num,docs,source,recovery,source,metadata,get,num,docs,if,num,docs,target,num,docs,source,throw,new,illegal,state,exception,try,to,recover,request,shard,id,from,primary,shard,with,sync,id,but,number,of,docs,differ,num,docs,source,request,source,node,get,name,primary,vs,num,docs,target,request,target,node,get,name,logger,trace,skipping,phase1,identical,sync,id,found,on,both,source,and,target,recovery,source,sync,id,else,final,store,recovery,diff,diff,recovery,source,metadata,recovery,diff,request,metadata,snapshot,for,store,file,meta,data,md,diff,identical,phase1existing,file,names,add,md,name,phase1existing,file,sizes,add,md,length,existing,total,size,md,length,if,logger,is,trace,enabled,logger,trace,recovery,phase1,not,recovering,exist,in,local,store,and,has,checksum,size,md,name,md,checksum,md,length,total,size,md,length,list,store,file,meta,data,phase1files,new,array,list,diff,different,size,diff,missing,size,phase1files,add,all,diff,different,phase1files,add,all,diff,missing,for,store,file,meta,data,md,phase1files,if,request,metadata,snapshot,as,map,contains,key,md,name,logger,trace,recovery,phase1,recovering,exists,in,local,store,but,is,different,remote,local,md,name,request,metadata,snapshot,as,map,get,md,name,md,else,logger,trace,recovery,phase1,recovering,does,not,exist,in,remote,md,name,phase1file,names,add,md,name,phase1file,sizes,add,md,length,total,size,md,length,logger,trace,recovery,phase1,with,with,phase1file,names,size,new,byte,size,value,total,size,phase1existing,file,names,size,new,byte,size,value,existing,total,size,cancellable,threads,execute,recovery,target,receive,file,info,phase1file,names,phase1file,sizes,phase1existing,file,names,phase1existing,file,sizes,translog,ops,get,send,files,store,phase1files,to,array,new,store,file,meta,data,0,translog,ops,try,cancellable,threads,execute,io,recovery,target,clean,files,translog,ops,get,recovery,source,metadata,catch,remote,transport,exception,ioexception,target,exception,final,ioexception,corrupt,index,exception,if,corrupt,index,exception,exceptions,helper,unwrap,corruption,target,exception,null,try,final,store,metadata,snapshot,recovery,source,metadata1,store,get,metadata,snapshot,store,file,meta,data,metadata,stream,support,stream,recovery,source,metadata1,spliterator,false,to,array,store,file,meta,data,new,array,util,tim,sort,metadata,comparator,comparing,long,store,file,meta,data,length,for,store,file,meta,data,md,metadata,cancellable,threads,check,for,cancel,logger,debug,checking,integrity,for,file,after,remove,corruption,exception,md,if,store,check,integrity,no,exception,md,false,shard,fail,shard,recovery,corrupt,index,exception,logger,warn,corrupted,file,detected,checksum,mismatch,md,throw,corrupt,index,exception,catch,ioexception,ex,target,exception,add,suppressed,ex,throw,target,exception,remote,transport,exception,exception,new,remote,transport,exception,file,corruption,occurred,on,recovery,but,checksums,are,ok,null,exception,add,suppressed,target,exception,logger,warn,new,parameterized,message,remote,file,corruption,during,finalization,of,recovery,on,node,local,checksum,ok,shard,shard,id,request,target,node,corrupt,index,exception,throw,exception,else,throw,target,exception,final,time,value,took,stop,watch,total,time,logger,trace,recovery,phase1,took,took,return,new,send,file,result,phase1file,names,phase1file,sizes,total,size,phase1existing,file,names,phase1existing,file,sizes,existing,total,size,took,catch,exception,e,throw,new,recover,files,recovery,exception,request,shard,id,phase1file,names,size,new,byte,size,value,total,size,e,finally,store,dec,ref
RecoverySourceHandler -> public SendFileResult phase1(final IndexCommit snapshot, final Supplier<Integer> translogOps);1547569135;Perform phase1 of the recovery operations. Once this {@link IndexCommit}_snapshot has been performed no commit operations (files being fsync'd)_are effectively allowed on this index until all recovery phases are done_<p>_Phase1 examines the segment files on the target node and copies over the_segments that are missing. Only segments that have the same size and_checksum can be reused;public SendFileResult phase1(final IndexCommit snapshot, final Supplier<Integer> translogOps) {_        cancellableThreads.checkForCancel()__        _        long totalSize = 0__        _        long existingTotalSize = 0__        final List<String> phase1FileNames = new ArrayList<>()__        final List<Long> phase1FileSizes = new ArrayList<>()__        final List<String> phase1ExistingFileNames = new ArrayList<>()__        final List<Long> phase1ExistingFileSizes = new ArrayList<>()__        final Store store = shard.store()__        store.incRef()__        try {_            StopWatch stopWatch = new StopWatch().start()__            final Store.MetadataSnapshot recoverySourceMetadata__            try {_                recoverySourceMetadata = store.getMetadata(snapshot)__            } catch (CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {_                shard.failShard("recovery", ex)__                throw ex__            }_            for (String name : snapshot.getFileNames()) {_                final StoreFileMetaData md = recoverySourceMetadata.get(name)__                if (md == null) {_                    logger.info("Snapshot differs from actual index for file: {} meta: {}", name, recoverySourceMetadata.asMap())__                    throw new CorruptIndexException("Snapshot differs from actual index - maybe index was removed metadata has " +_                            recoverySourceMetadata.asMap().size() + " files", name)__                }_            }_            _            _            _            String recoverySourceSyncId = recoverySourceMetadata.getSyncId()__            String recoveryTargetSyncId = request.metadataSnapshot().getSyncId()__            final boolean recoverWithSyncId = recoverySourceSyncId != null &&_                    recoverySourceSyncId.equals(recoveryTargetSyncId)__            if (recoverWithSyncId) {_                final long numDocsTarget = request.metadataSnapshot().getNumDocs()__                final long numDocsSource = recoverySourceMetadata.getNumDocs()__                if (numDocsTarget != numDocsSource) {_                    throw new IllegalStateException("try to recover " + request.shardId() + " from primary shard with sync id but number " +_                            "of docs differ: " + numDocsSource + " (" + request.sourceNode().getName() + ", primary) vs " + numDocsTarget_                            + "(" + request.targetNode().getName() + ")")__                }_                _                _                logger.trace("skipping [phase1]- identical sync id [{}] found on both source and target", recoverySourceSyncId)__            } else {_                final Store.RecoveryDiff diff = recoverySourceMetadata.recoveryDiff(request.metadataSnapshot())__                for (StoreFileMetaData md : diff.identical) {_                    phase1ExistingFileNames.add(md.name())__                    phase1ExistingFileSizes.add(md.length())__                    existingTotalSize += md.length()__                    if (logger.isTraceEnabled()) {_                        logger.trace("recovery [phase1]: not recovering [{}], exist in local store and has checksum [{}]," +_                                        " size [{}]", md.name(), md.checksum(), md.length())__                    }_                    totalSize += md.length()__                }_                List<StoreFileMetaData> phase1Files = new ArrayList<>(diff.different.size() + diff.missing.size())__                phase1Files.addAll(diff.different)__                phase1Files.addAll(diff.missing)__                for (StoreFileMetaData md : phase1Files) {_                    if (request.metadataSnapshot().asMap().containsKey(md.name())) {_                        logger.trace("recovery [phase1]: recovering [{}], exists in local store, but is different: remote [{}], local [{}]",_                            md.name(), request.metadataSnapshot().asMap().get(md.name()), md)__                    } else {_                        logger.trace("recovery [phase1]: recovering [{}], does not exist in remote", md.name())__                    }_                    phase1FileNames.add(md.name())__                    phase1FileSizes.add(md.length())__                    totalSize += md.length()__                }__                logger.trace("recovery [phase1]: recovering_files [{}] with total_size [{}], reusing_files [{}] with total_size [{}]",_                    phase1FileNames.size(), new ByteSizeValue(totalSize),_                    phase1ExistingFileNames.size(), new ByteSizeValue(existingTotalSize))__                cancellableThreads.execute(() -> recoveryTarget.receiveFileInfo(_                    phase1FileNames, phase1FileSizes, phase1ExistingFileNames, phase1ExistingFileSizes, translogOps.get()))__                sendFiles(store, phase1Files.toArray(new StoreFileMetaData[0]), translogOps)__                _                _                _                _                _                _                _                _                try {_                    cancellableThreads.executeIO(() ->_                        recoveryTarget.cleanFiles(translogOps.get(), recoverySourceMetadata))__                } catch (RemoteTransportException | IOException targetException) {_                    final IOException corruptIndexException__                    _                    _                    _                    _                    if ((corruptIndexException = ExceptionsHelper.unwrapCorruption(targetException)) != null) {_                        try {_                            final Store.MetadataSnapshot recoverySourceMetadata1 = store.getMetadata(snapshot)__                            StoreFileMetaData[] metadata =_                                    StreamSupport.stream(recoverySourceMetadata1.spliterator(), false).toArray(StoreFileMetaData[]::new)__                            ArrayUtil.timSort(metadata, Comparator.comparingLong(StoreFileMetaData::length))_ _                            for (StoreFileMetaData md : metadata) {_                                cancellableThreads.checkForCancel()__                                logger.debug("checking integrity for file {} after remove corruption exception", md)__                                if (store.checkIntegrityNoException(md) == false) { _                                    shard.failShard("recovery", corruptIndexException)__                                    logger.warn("Corrupted file detected {} checksum mismatch", md)__                                    throw corruptIndexException__                                }_                            }_                        } catch (IOException ex) {_                            targetException.addSuppressed(ex)__                            throw targetException__                        }_                        _                        RemoteTransportException exception = new RemoteTransportException("File corruption occurred on recovery but " +_                                "checksums are ok", null)__                        exception.addSuppressed(targetException)__                        logger.warn(() -> new ParameterizedMessage(_                                "{} Remote file corruption during finalization of recovery on node {}. local checksum OK",_                                shard.shardId(), request.targetNode()), corruptIndexException)__                        throw exception__                    } else {_                        throw targetException__                    }_                }_            }_            final TimeValue took = stopWatch.totalTime()__            logger.trace("recovery [phase1]: took [{}]", took)__            return new SendFileResult(phase1FileNames, phase1FileSizes, totalSize, phase1ExistingFileNames,_                phase1ExistingFileSizes, existingTotalSize, took)__        } catch (Exception e) {_            throw new RecoverFilesRecoveryException(request.shardId(), phase1FileNames.size(), new ByteSizeValue(totalSize), e)__        } finally {_            store.decRef()__        }_    };perform,phase1,of,the,recovery,operations,once,this,link,index,commit,snapshot,has,been,performed,no,commit,operations,files,being,fsync,d,are,effectively,allowed,on,this,index,until,all,recovery,phases,are,done,p,phase1,examines,the,segment,files,on,the,target,node,and,copies,over,the,segments,that,are,missing,only,segments,that,have,the,same,size,and,checksum,can,be,reused;public,send,file,result,phase1,final,index,commit,snapshot,final,supplier,integer,translog,ops,cancellable,threads,check,for,cancel,long,total,size,0,long,existing,total,size,0,final,list,string,phase1file,names,new,array,list,final,list,long,phase1file,sizes,new,array,list,final,list,string,phase1existing,file,names,new,array,list,final,list,long,phase1existing,file,sizes,new,array,list,final,store,store,shard,store,store,inc,ref,try,stop,watch,stop,watch,new,stop,watch,start,final,store,metadata,snapshot,recovery,source,metadata,try,recovery,source,metadata,store,get,metadata,snapshot,catch,corrupt,index,exception,index,format,too,old,exception,index,format,too,new,exception,ex,shard,fail,shard,recovery,ex,throw,ex,for,string,name,snapshot,get,file,names,final,store,file,meta,data,md,recovery,source,metadata,get,name,if,md,null,logger,info,snapshot,differs,from,actual,index,for,file,meta,name,recovery,source,metadata,as,map,throw,new,corrupt,index,exception,snapshot,differs,from,actual,index,maybe,index,was,removed,metadata,has,recovery,source,metadata,as,map,size,files,name,string,recovery,source,sync,id,recovery,source,metadata,get,sync,id,string,recovery,target,sync,id,request,metadata,snapshot,get,sync,id,final,boolean,recover,with,sync,id,recovery,source,sync,id,null,recovery,source,sync,id,equals,recovery,target,sync,id,if,recover,with,sync,id,final,long,num,docs,target,request,metadata,snapshot,get,num,docs,final,long,num,docs,source,recovery,source,metadata,get,num,docs,if,num,docs,target,num,docs,source,throw,new,illegal,state,exception,try,to,recover,request,shard,id,from,primary,shard,with,sync,id,but,number,of,docs,differ,num,docs,source,request,source,node,get,name,primary,vs,num,docs,target,request,target,node,get,name,logger,trace,skipping,phase1,identical,sync,id,found,on,both,source,and,target,recovery,source,sync,id,else,final,store,recovery,diff,diff,recovery,source,metadata,recovery,diff,request,metadata,snapshot,for,store,file,meta,data,md,diff,identical,phase1existing,file,names,add,md,name,phase1existing,file,sizes,add,md,length,existing,total,size,md,length,if,logger,is,trace,enabled,logger,trace,recovery,phase1,not,recovering,exist,in,local,store,and,has,checksum,size,md,name,md,checksum,md,length,total,size,md,length,list,store,file,meta,data,phase1files,new,array,list,diff,different,size,diff,missing,size,phase1files,add,all,diff,different,phase1files,add,all,diff,missing,for,store,file,meta,data,md,phase1files,if,request,metadata,snapshot,as,map,contains,key,md,name,logger,trace,recovery,phase1,recovering,exists,in,local,store,but,is,different,remote,local,md,name,request,metadata,snapshot,as,map,get,md,name,md,else,logger,trace,recovery,phase1,recovering,does,not,exist,in,remote,md,name,phase1file,names,add,md,name,phase1file,sizes,add,md,length,total,size,md,length,logger,trace,recovery,phase1,with,with,phase1file,names,size,new,byte,size,value,total,size,phase1existing,file,names,size,new,byte,size,value,existing,total,size,cancellable,threads,execute,recovery,target,receive,file,info,phase1file,names,phase1file,sizes,phase1existing,file,names,phase1existing,file,sizes,translog,ops,get,send,files,store,phase1files,to,array,new,store,file,meta,data,0,translog,ops,try,cancellable,threads,execute,io,recovery,target,clean,files,translog,ops,get,recovery,source,metadata,catch,remote,transport,exception,ioexception,target,exception,final,ioexception,corrupt,index,exception,if,corrupt,index,exception,exceptions,helper,unwrap,corruption,target,exception,null,try,final,store,metadata,snapshot,recovery,source,metadata1,store,get,metadata,snapshot,store,file,meta,data,metadata,stream,support,stream,recovery,source,metadata1,spliterator,false,to,array,store,file,meta,data,new,array,util,tim,sort,metadata,comparator,comparing,long,store,file,meta,data,length,for,store,file,meta,data,md,metadata,cancellable,threads,check,for,cancel,logger,debug,checking,integrity,for,file,after,remove,corruption,exception,md,if,store,check,integrity,no,exception,md,false,shard,fail,shard,recovery,corrupt,index,exception,logger,warn,corrupted,file,detected,checksum,mismatch,md,throw,corrupt,index,exception,catch,ioexception,ex,target,exception,add,suppressed,ex,throw,target,exception,remote,transport,exception,exception,new,remote,transport,exception,file,corruption,occurred,on,recovery,but,checksums,are,ok,null,exception,add,suppressed,target,exception,logger,warn,new,parameterized,message,remote,file,corruption,during,finalization,of,recovery,on,node,local,checksum,ok,shard,shard,id,request,target,node,corrupt,index,exception,throw,exception,else,throw,target,exception,final,time,value,took,stop,watch,total,time,logger,trace,recovery,phase1,took,took,return,new,send,file,result,phase1file,names,phase1file,sizes,total,size,phase1existing,file,names,phase1existing,file,sizes,existing,total,size,took,catch,exception,e,throw,new,recover,files,recovery,exception,request,shard,id,phase1file,names,size,new,byte,size,value,total,size,e,finally,store,dec,ref
RecoverySourceHandler -> public SendFileResult phase1(final IndexCommit snapshot, final Supplier<Integer> translogOps);1547576245;Perform phase1 of the recovery operations. Once this {@link IndexCommit}_snapshot has been performed no commit operations (files being fsync'd)_are effectively allowed on this index until all recovery phases are done_<p>_Phase1 examines the segment files on the target node and copies over the_segments that are missing. Only segments that have the same size and_checksum can be reused;public SendFileResult phase1(final IndexCommit snapshot, final Supplier<Integer> translogOps) {_        cancellableThreads.checkForCancel()__        _        long totalSize = 0__        _        long existingTotalSize = 0__        final List<String> phase1FileNames = new ArrayList<>()__        final List<Long> phase1FileSizes = new ArrayList<>()__        final List<String> phase1ExistingFileNames = new ArrayList<>()__        final List<Long> phase1ExistingFileSizes = new ArrayList<>()__        final Store store = shard.store()__        store.incRef()__        try {_            StopWatch stopWatch = new StopWatch().start()__            final Store.MetadataSnapshot recoverySourceMetadata__            try {_                recoverySourceMetadata = store.getMetadata(snapshot)__            } catch (CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {_                shard.failShard("recovery", ex)__                throw ex__            }_            for (String name : snapshot.getFileNames()) {_                final StoreFileMetaData md = recoverySourceMetadata.get(name)__                if (md == null) {_                    logger.info("Snapshot differs from actual index for file: {} meta: {}", name, recoverySourceMetadata.asMap())__                    throw new CorruptIndexException("Snapshot differs from actual index - maybe index was removed metadata has " +_                            recoverySourceMetadata.asMap().size() + " files", name)__                }_            }_            _            _            _            String recoverySourceSyncId = recoverySourceMetadata.getSyncId()__            String recoveryTargetSyncId = request.metadataSnapshot().getSyncId()__            final boolean recoverWithSyncId = recoverySourceSyncId != null &&_                    recoverySourceSyncId.equals(recoveryTargetSyncId)__            if (recoverWithSyncId) {_                final long numDocsTarget = request.metadataSnapshot().getNumDocs()__                final long numDocsSource = recoverySourceMetadata.getNumDocs()__                if (numDocsTarget != numDocsSource) {_                    throw new IllegalStateException("try to recover " + request.shardId() + " from primary shard with sync id but number " +_                            "of docs differ: " + numDocsSource + " (" + request.sourceNode().getName() + ", primary) vs " + numDocsTarget_                            + "(" + request.targetNode().getName() + ")")__                }_                _                _                logger.trace("skipping [phase1]- identical sync id [{}] found on both source and target", recoverySourceSyncId)__            } else {_                final Store.RecoveryDiff diff = recoverySourceMetadata.recoveryDiff(request.metadataSnapshot())__                for (StoreFileMetaData md : diff.identical) {_                    phase1ExistingFileNames.add(md.name())__                    phase1ExistingFileSizes.add(md.length())__                    existingTotalSize += md.length()__                    if (logger.isTraceEnabled()) {_                        logger.trace("recovery [phase1]: not recovering [{}], exist in local store and has checksum [{}]," +_                                        " size [{}]", md.name(), md.checksum(), md.length())__                    }_                    totalSize += md.length()__                }_                List<StoreFileMetaData> phase1Files = new ArrayList<>(diff.different.size() + diff.missing.size())__                phase1Files.addAll(diff.different)__                phase1Files.addAll(diff.missing)__                for (StoreFileMetaData md : phase1Files) {_                    if (request.metadataSnapshot().asMap().containsKey(md.name())) {_                        logger.trace("recovery [phase1]: recovering [{}], exists in local store, but is different: remote [{}], local [{}]",_                            md.name(), request.metadataSnapshot().asMap().get(md.name()), md)__                    } else {_                        logger.trace("recovery [phase1]: recovering [{}], does not exist in remote", md.name())__                    }_                    phase1FileNames.add(md.name())__                    phase1FileSizes.add(md.length())__                    totalSize += md.length()__                }__                logger.trace("recovery [phase1]: recovering_files [{}] with total_size [{}], reusing_files [{}] with total_size [{}]",_                    phase1FileNames.size(), new ByteSizeValue(totalSize),_                    phase1ExistingFileNames.size(), new ByteSizeValue(existingTotalSize))__                cancellableThreads.execute(() -> recoveryTarget.receiveFileInfo(_                    phase1FileNames, phase1FileSizes, phase1ExistingFileNames, phase1ExistingFileSizes, translogOps.get()))__                sendFiles(store, phase1Files.toArray(new StoreFileMetaData[0]), translogOps)__                _                _                _                _                _                _                _                _                try {_                    cancellableThreads.executeIO(() ->_                        recoveryTarget.cleanFiles(translogOps.get(), recoverySourceMetadata))__                } catch (RemoteTransportException | IOException targetException) {_                    final IOException corruptIndexException__                    _                    _                    _                    _                    if ((corruptIndexException = ExceptionsHelper.unwrapCorruption(targetException)) != null) {_                        try {_                            final Store.MetadataSnapshot recoverySourceMetadata1 = store.getMetadata(snapshot)__                            StoreFileMetaData[] metadata =_                                    StreamSupport.stream(recoverySourceMetadata1.spliterator(), false).toArray(StoreFileMetaData[]::new)__                            ArrayUtil.timSort(metadata, Comparator.comparingLong(StoreFileMetaData::length))_ _                            for (StoreFileMetaData md : metadata) {_                                cancellableThreads.checkForCancel()__                                logger.debug("checking integrity for file {} after remove corruption exception", md)__                                if (store.checkIntegrityNoException(md) == false) { _                                    shard.failShard("recovery", corruptIndexException)__                                    logger.warn("Corrupted file detected {} checksum mismatch", md)__                                    throw corruptIndexException__                                }_                            }_                        } catch (IOException ex) {_                            targetException.addSuppressed(ex)__                            throw targetException__                        }_                        _                        RemoteTransportException exception = new RemoteTransportException("File corruption occurred on recovery but " +_                                "checksums are ok", null)__                        exception.addSuppressed(targetException)__                        logger.warn(() -> new ParameterizedMessage(_                                "{} Remote file corruption during finalization of recovery on node {}. local checksum OK",_                                shard.shardId(), request.targetNode()), corruptIndexException)__                        throw exception__                    } else {_                        throw targetException__                    }_                }_            }_            final TimeValue took = stopWatch.totalTime()__            logger.trace("recovery [phase1]: took [{}]", took)__            return new SendFileResult(phase1FileNames, phase1FileSizes, totalSize, phase1ExistingFileNames,_                phase1ExistingFileSizes, existingTotalSize, took)__        } catch (Exception e) {_            throw new RecoverFilesRecoveryException(request.shardId(), phase1FileNames.size(), new ByteSizeValue(totalSize), e)__        } finally {_            store.decRef()__        }_    };perform,phase1,of,the,recovery,operations,once,this,link,index,commit,snapshot,has,been,performed,no,commit,operations,files,being,fsync,d,are,effectively,allowed,on,this,index,until,all,recovery,phases,are,done,p,phase1,examines,the,segment,files,on,the,target,node,and,copies,over,the,segments,that,are,missing,only,segments,that,have,the,same,size,and,checksum,can,be,reused;public,send,file,result,phase1,final,index,commit,snapshot,final,supplier,integer,translog,ops,cancellable,threads,check,for,cancel,long,total,size,0,long,existing,total,size,0,final,list,string,phase1file,names,new,array,list,final,list,long,phase1file,sizes,new,array,list,final,list,string,phase1existing,file,names,new,array,list,final,list,long,phase1existing,file,sizes,new,array,list,final,store,store,shard,store,store,inc,ref,try,stop,watch,stop,watch,new,stop,watch,start,final,store,metadata,snapshot,recovery,source,metadata,try,recovery,source,metadata,store,get,metadata,snapshot,catch,corrupt,index,exception,index,format,too,old,exception,index,format,too,new,exception,ex,shard,fail,shard,recovery,ex,throw,ex,for,string,name,snapshot,get,file,names,final,store,file,meta,data,md,recovery,source,metadata,get,name,if,md,null,logger,info,snapshot,differs,from,actual,index,for,file,meta,name,recovery,source,metadata,as,map,throw,new,corrupt,index,exception,snapshot,differs,from,actual,index,maybe,index,was,removed,metadata,has,recovery,source,metadata,as,map,size,files,name,string,recovery,source,sync,id,recovery,source,metadata,get,sync,id,string,recovery,target,sync,id,request,metadata,snapshot,get,sync,id,final,boolean,recover,with,sync,id,recovery,source,sync,id,null,recovery,source,sync,id,equals,recovery,target,sync,id,if,recover,with,sync,id,final,long,num,docs,target,request,metadata,snapshot,get,num,docs,final,long,num,docs,source,recovery,source,metadata,get,num,docs,if,num,docs,target,num,docs,source,throw,new,illegal,state,exception,try,to,recover,request,shard,id,from,primary,shard,with,sync,id,but,number,of,docs,differ,num,docs,source,request,source,node,get,name,primary,vs,num,docs,target,request,target,node,get,name,logger,trace,skipping,phase1,identical,sync,id,found,on,both,source,and,target,recovery,source,sync,id,else,final,store,recovery,diff,diff,recovery,source,metadata,recovery,diff,request,metadata,snapshot,for,store,file,meta,data,md,diff,identical,phase1existing,file,names,add,md,name,phase1existing,file,sizes,add,md,length,existing,total,size,md,length,if,logger,is,trace,enabled,logger,trace,recovery,phase1,not,recovering,exist,in,local,store,and,has,checksum,size,md,name,md,checksum,md,length,total,size,md,length,list,store,file,meta,data,phase1files,new,array,list,diff,different,size,diff,missing,size,phase1files,add,all,diff,different,phase1files,add,all,diff,missing,for,store,file,meta,data,md,phase1files,if,request,metadata,snapshot,as,map,contains,key,md,name,logger,trace,recovery,phase1,recovering,exists,in,local,store,but,is,different,remote,local,md,name,request,metadata,snapshot,as,map,get,md,name,md,else,logger,trace,recovery,phase1,recovering,does,not,exist,in,remote,md,name,phase1file,names,add,md,name,phase1file,sizes,add,md,length,total,size,md,length,logger,trace,recovery,phase1,with,with,phase1file,names,size,new,byte,size,value,total,size,phase1existing,file,names,size,new,byte,size,value,existing,total,size,cancellable,threads,execute,recovery,target,receive,file,info,phase1file,names,phase1file,sizes,phase1existing,file,names,phase1existing,file,sizes,translog,ops,get,send,files,store,phase1files,to,array,new,store,file,meta,data,0,translog,ops,try,cancellable,threads,execute,io,recovery,target,clean,files,translog,ops,get,recovery,source,metadata,catch,remote,transport,exception,ioexception,target,exception,final,ioexception,corrupt,index,exception,if,corrupt,index,exception,exceptions,helper,unwrap,corruption,target,exception,null,try,final,store,metadata,snapshot,recovery,source,metadata1,store,get,metadata,snapshot,store,file,meta,data,metadata,stream,support,stream,recovery,source,metadata1,spliterator,false,to,array,store,file,meta,data,new,array,util,tim,sort,metadata,comparator,comparing,long,store,file,meta,data,length,for,store,file,meta,data,md,metadata,cancellable,threads,check,for,cancel,logger,debug,checking,integrity,for,file,after,remove,corruption,exception,md,if,store,check,integrity,no,exception,md,false,shard,fail,shard,recovery,corrupt,index,exception,logger,warn,corrupted,file,detected,checksum,mismatch,md,throw,corrupt,index,exception,catch,ioexception,ex,target,exception,add,suppressed,ex,throw,target,exception,remote,transport,exception,exception,new,remote,transport,exception,file,corruption,occurred,on,recovery,but,checksums,are,ok,null,exception,add,suppressed,target,exception,logger,warn,new,parameterized,message,remote,file,corruption,during,finalization,of,recovery,on,node,local,checksum,ok,shard,shard,id,request,target,node,corrupt,index,exception,throw,exception,else,throw,target,exception,final,time,value,took,stop,watch,total,time,logger,trace,recovery,phase1,took,took,return,new,send,file,result,phase1file,names,phase1file,sizes,total,size,phase1existing,file,names,phase1existing,file,sizes,existing,total,size,took,catch,exception,e,throw,new,recover,files,recovery,exception,request,shard,id,phase1file,names,size,new,byte,size,value,total,size,e,finally,store,dec,ref
RecoverySourceHandler -> public SendFileResult phase1(final IndexCommit snapshot, final Supplier<Integer> translogOps);1547737145;Perform phase1 of the recovery operations. Once this {@link IndexCommit}_snapshot has been performed no commit operations (files being fsync'd)_are effectively allowed on this index until all recovery phases are done_<p>_Phase1 examines the segment files on the target node and copies over the_segments that are missing. Only segments that have the same size and_checksum can be reused;public SendFileResult phase1(final IndexCommit snapshot, final Supplier<Integer> translogOps) {_        cancellableThreads.checkForCancel()__        _        long totalSize = 0__        _        long existingTotalSize = 0__        final List<String> phase1FileNames = new ArrayList<>()__        final List<Long> phase1FileSizes = new ArrayList<>()__        final List<String> phase1ExistingFileNames = new ArrayList<>()__        final List<Long> phase1ExistingFileSizes = new ArrayList<>()__        final Store store = shard.store()__        store.incRef()__        try {_            StopWatch stopWatch = new StopWatch().start()__            final Store.MetadataSnapshot recoverySourceMetadata__            try {_                recoverySourceMetadata = store.getMetadata(snapshot)__            } catch (CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {_                shard.failShard("recovery", ex)__                throw ex__            }_            for (String name : snapshot.getFileNames()) {_                final StoreFileMetaData md = recoverySourceMetadata.get(name)__                if (md == null) {_                    logger.info("Snapshot differs from actual index for file: {} meta: {}", name, recoverySourceMetadata.asMap())__                    throw new CorruptIndexException("Snapshot differs from actual index - maybe index was removed metadata has " +_                            recoverySourceMetadata.asMap().size() + " files", name)__                }_            }_            _            _            _            String recoverySourceSyncId = recoverySourceMetadata.getSyncId()__            String recoveryTargetSyncId = request.metadataSnapshot().getSyncId()__            final boolean recoverWithSyncId = recoverySourceSyncId != null &&_                    recoverySourceSyncId.equals(recoveryTargetSyncId)__            if (recoverWithSyncId) {_                final long numDocsTarget = request.metadataSnapshot().getNumDocs()__                final long numDocsSource = recoverySourceMetadata.getNumDocs()__                if (numDocsTarget != numDocsSource) {_                    throw new IllegalStateException("try to recover " + request.shardId() + " from primary shard with sync id but number " +_                            "of docs differ: " + numDocsSource + " (" + request.sourceNode().getName() + ", primary) vs " + numDocsTarget_                            + "(" + request.targetNode().getName() + ")")__                }_                _                _                logger.trace("skipping [phase1]- identical sync id [{}] found on both source and target", recoverySourceSyncId)__            } else {_                final Store.RecoveryDiff diff = recoverySourceMetadata.recoveryDiff(request.metadataSnapshot())__                for (StoreFileMetaData md : diff.identical) {_                    phase1ExistingFileNames.add(md.name())__                    phase1ExistingFileSizes.add(md.length())__                    existingTotalSize += md.length()__                    if (logger.isTraceEnabled()) {_                        logger.trace("recovery [phase1]: not recovering [{}], exist in local store and has checksum [{}]," +_                                        " size [{}]", md.name(), md.checksum(), md.length())__                    }_                    totalSize += md.length()__                }_                List<StoreFileMetaData> phase1Files = new ArrayList<>(diff.different.size() + diff.missing.size())__                phase1Files.addAll(diff.different)__                phase1Files.addAll(diff.missing)__                for (StoreFileMetaData md : phase1Files) {_                    if (request.metadataSnapshot().asMap().containsKey(md.name())) {_                        logger.trace("recovery [phase1]: recovering [{}], exists in local store, but is different: remote [{}], local [{}]",_                            md.name(), request.metadataSnapshot().asMap().get(md.name()), md)__                    } else {_                        logger.trace("recovery [phase1]: recovering [{}], does not exist in remote", md.name())__                    }_                    phase1FileNames.add(md.name())__                    phase1FileSizes.add(md.length())__                    totalSize += md.length()__                }__                logger.trace("recovery [phase1]: recovering_files [{}] with total_size [{}], reusing_files [{}] with total_size [{}]",_                    phase1FileNames.size(), new ByteSizeValue(totalSize),_                    phase1ExistingFileNames.size(), new ByteSizeValue(existingTotalSize))__                cancellableThreads.execute(() -> recoveryTarget.receiveFileInfo(_                    phase1FileNames, phase1FileSizes, phase1ExistingFileNames, phase1ExistingFileSizes, translogOps.get()))__                sendFiles(store, phase1Files.toArray(new StoreFileMetaData[0]), translogOps)__                _                _                _                _                _                _                _                _                try {_                    cancellableThreads.executeIO(() ->_                        recoveryTarget.cleanFiles(translogOps.get(), recoverySourceMetadata))__                } catch (RemoteTransportException | IOException targetException) {_                    final IOException corruptIndexException__                    _                    _                    _                    _                    if ((corruptIndexException = ExceptionsHelper.unwrapCorruption(targetException)) != null) {_                        try {_                            final Store.MetadataSnapshot recoverySourceMetadata1 = store.getMetadata(snapshot)__                            StoreFileMetaData[] metadata =_                                    StreamSupport.stream(recoverySourceMetadata1.spliterator(), false).toArray(StoreFileMetaData[]::new)__                            ArrayUtil.timSort(metadata, Comparator.comparingLong(StoreFileMetaData::length))_ _                            for (StoreFileMetaData md : metadata) {_                                cancellableThreads.checkForCancel()__                                logger.debug("checking integrity for file {} after remove corruption exception", md)__                                if (store.checkIntegrityNoException(md) == false) { _                                    shard.failShard("recovery", corruptIndexException)__                                    logger.warn("Corrupted file detected {} checksum mismatch", md)__                                    throw corruptIndexException__                                }_                            }_                        } catch (IOException ex) {_                            targetException.addSuppressed(ex)__                            throw targetException__                        }_                        _                        RemoteTransportException exception = new RemoteTransportException("File corruption occurred on recovery but " +_                                "checksums are ok", null)__                        exception.addSuppressed(targetException)__                        logger.warn(() -> new ParameterizedMessage(_                                "{} Remote file corruption during finalization of recovery on node {}. local checksum OK",_                                shard.shardId(), request.targetNode()), corruptIndexException)__                        throw exception__                    } else {_                        throw targetException__                    }_                }_            }_            final TimeValue took = stopWatch.totalTime()__            logger.trace("recovery [phase1]: took [{}]", took)__            return new SendFileResult(phase1FileNames, phase1FileSizes, totalSize, phase1ExistingFileNames,_                phase1ExistingFileSizes, existingTotalSize, took)__        } catch (Exception e) {_            throw new RecoverFilesRecoveryException(request.shardId(), phase1FileNames.size(), new ByteSizeValue(totalSize), e)__        } finally {_            store.decRef()__        }_    };perform,phase1,of,the,recovery,operations,once,this,link,index,commit,snapshot,has,been,performed,no,commit,operations,files,being,fsync,d,are,effectively,allowed,on,this,index,until,all,recovery,phases,are,done,p,phase1,examines,the,segment,files,on,the,target,node,and,copies,over,the,segments,that,are,missing,only,segments,that,have,the,same,size,and,checksum,can,be,reused;public,send,file,result,phase1,final,index,commit,snapshot,final,supplier,integer,translog,ops,cancellable,threads,check,for,cancel,long,total,size,0,long,existing,total,size,0,final,list,string,phase1file,names,new,array,list,final,list,long,phase1file,sizes,new,array,list,final,list,string,phase1existing,file,names,new,array,list,final,list,long,phase1existing,file,sizes,new,array,list,final,store,store,shard,store,store,inc,ref,try,stop,watch,stop,watch,new,stop,watch,start,final,store,metadata,snapshot,recovery,source,metadata,try,recovery,source,metadata,store,get,metadata,snapshot,catch,corrupt,index,exception,index,format,too,old,exception,index,format,too,new,exception,ex,shard,fail,shard,recovery,ex,throw,ex,for,string,name,snapshot,get,file,names,final,store,file,meta,data,md,recovery,source,metadata,get,name,if,md,null,logger,info,snapshot,differs,from,actual,index,for,file,meta,name,recovery,source,metadata,as,map,throw,new,corrupt,index,exception,snapshot,differs,from,actual,index,maybe,index,was,removed,metadata,has,recovery,source,metadata,as,map,size,files,name,string,recovery,source,sync,id,recovery,source,metadata,get,sync,id,string,recovery,target,sync,id,request,metadata,snapshot,get,sync,id,final,boolean,recover,with,sync,id,recovery,source,sync,id,null,recovery,source,sync,id,equals,recovery,target,sync,id,if,recover,with,sync,id,final,long,num,docs,target,request,metadata,snapshot,get,num,docs,final,long,num,docs,source,recovery,source,metadata,get,num,docs,if,num,docs,target,num,docs,source,throw,new,illegal,state,exception,try,to,recover,request,shard,id,from,primary,shard,with,sync,id,but,number,of,docs,differ,num,docs,source,request,source,node,get,name,primary,vs,num,docs,target,request,target,node,get,name,logger,trace,skipping,phase1,identical,sync,id,found,on,both,source,and,target,recovery,source,sync,id,else,final,store,recovery,diff,diff,recovery,source,metadata,recovery,diff,request,metadata,snapshot,for,store,file,meta,data,md,diff,identical,phase1existing,file,names,add,md,name,phase1existing,file,sizes,add,md,length,existing,total,size,md,length,if,logger,is,trace,enabled,logger,trace,recovery,phase1,not,recovering,exist,in,local,store,and,has,checksum,size,md,name,md,checksum,md,length,total,size,md,length,list,store,file,meta,data,phase1files,new,array,list,diff,different,size,diff,missing,size,phase1files,add,all,diff,different,phase1files,add,all,diff,missing,for,store,file,meta,data,md,phase1files,if,request,metadata,snapshot,as,map,contains,key,md,name,logger,trace,recovery,phase1,recovering,exists,in,local,store,but,is,different,remote,local,md,name,request,metadata,snapshot,as,map,get,md,name,md,else,logger,trace,recovery,phase1,recovering,does,not,exist,in,remote,md,name,phase1file,names,add,md,name,phase1file,sizes,add,md,length,total,size,md,length,logger,trace,recovery,phase1,with,with,phase1file,names,size,new,byte,size,value,total,size,phase1existing,file,names,size,new,byte,size,value,existing,total,size,cancellable,threads,execute,recovery,target,receive,file,info,phase1file,names,phase1file,sizes,phase1existing,file,names,phase1existing,file,sizes,translog,ops,get,send,files,store,phase1files,to,array,new,store,file,meta,data,0,translog,ops,try,cancellable,threads,execute,io,recovery,target,clean,files,translog,ops,get,recovery,source,metadata,catch,remote,transport,exception,ioexception,target,exception,final,ioexception,corrupt,index,exception,if,corrupt,index,exception,exceptions,helper,unwrap,corruption,target,exception,null,try,final,store,metadata,snapshot,recovery,source,metadata1,store,get,metadata,snapshot,store,file,meta,data,metadata,stream,support,stream,recovery,source,metadata1,spliterator,false,to,array,store,file,meta,data,new,array,util,tim,sort,metadata,comparator,comparing,long,store,file,meta,data,length,for,store,file,meta,data,md,metadata,cancellable,threads,check,for,cancel,logger,debug,checking,integrity,for,file,after,remove,corruption,exception,md,if,store,check,integrity,no,exception,md,false,shard,fail,shard,recovery,corrupt,index,exception,logger,warn,corrupted,file,detected,checksum,mismatch,md,throw,corrupt,index,exception,catch,ioexception,ex,target,exception,add,suppressed,ex,throw,target,exception,remote,transport,exception,exception,new,remote,transport,exception,file,corruption,occurred,on,recovery,but,checksums,are,ok,null,exception,add,suppressed,target,exception,logger,warn,new,parameterized,message,remote,file,corruption,during,finalization,of,recovery,on,node,local,checksum,ok,shard,shard,id,request,target,node,corrupt,index,exception,throw,exception,else,throw,target,exception,final,time,value,took,stop,watch,total,time,logger,trace,recovery,phase1,took,took,return,new,send,file,result,phase1file,names,phase1file,sizes,total,size,phase1existing,file,names,phase1existing,file,sizes,existing,total,size,took,catch,exception,e,throw,new,recover,files,recovery,exception,request,shard,id,phase1file,names,size,new,byte,size,value,total,size,e,finally,store,dec,ref
RecoverySourceHandler -> public SendFileResult phase1(final IndexCommit snapshot, final Supplier<Integer> translogOps);1548124510;Perform phase1 of the recovery operations. Once this {@link IndexCommit}_snapshot has been performed no commit operations (files being fsync'd)_are effectively allowed on this index until all recovery phases are done_<p>_Phase1 examines the segment files on the target node and copies over the_segments that are missing. Only segments that have the same size and_checksum can be reused;public SendFileResult phase1(final IndexCommit snapshot, final Supplier<Integer> translogOps) {_        cancellableThreads.checkForCancel()__        _        long totalSize = 0__        _        long existingTotalSize = 0__        final List<String> phase1FileNames = new ArrayList<>()__        final List<Long> phase1FileSizes = new ArrayList<>()__        final List<String> phase1ExistingFileNames = new ArrayList<>()__        final List<Long> phase1ExistingFileSizes = new ArrayList<>()__        final Store store = shard.store()__        store.incRef()__        try {_            StopWatch stopWatch = new StopWatch().start()__            final Store.MetadataSnapshot recoverySourceMetadata__            try {_                recoverySourceMetadata = store.getMetadata(snapshot)__            } catch (CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {_                shard.failShard("recovery", ex)__                throw ex__            }_            for (String name : snapshot.getFileNames()) {_                final StoreFileMetaData md = recoverySourceMetadata.get(name)__                if (md == null) {_                    logger.info("Snapshot differs from actual index for file: {} meta: {}", name, recoverySourceMetadata.asMap())__                    throw new CorruptIndexException("Snapshot differs from actual index - maybe index was removed metadata has " +_                            recoverySourceMetadata.asMap().size() + " files", name)__                }_            }_            _            _            _            String recoverySourceSyncId = recoverySourceMetadata.getSyncId()__            String recoveryTargetSyncId = request.metadataSnapshot().getSyncId()__            final boolean recoverWithSyncId = recoverySourceSyncId != null &&_                    recoverySourceSyncId.equals(recoveryTargetSyncId)__            if (recoverWithSyncId) {_                final long numDocsTarget = request.metadataSnapshot().getNumDocs()__                final long numDocsSource = recoverySourceMetadata.getNumDocs()__                if (numDocsTarget != numDocsSource) {_                    throw new IllegalStateException("try to recover " + request.shardId() + " from primary shard with sync id but number " +_                            "of docs differ: " + numDocsSource + " (" + request.sourceNode().getName() + ", primary) vs " + numDocsTarget_                            + "(" + request.targetNode().getName() + ")")__                }_                _                _                logger.trace("skipping [phase1]- identical sync id [{}] found on both source and target", recoverySourceSyncId)__            } else {_                final Store.RecoveryDiff diff = recoverySourceMetadata.recoveryDiff(request.metadataSnapshot())__                for (StoreFileMetaData md : diff.identical) {_                    phase1ExistingFileNames.add(md.name())__                    phase1ExistingFileSizes.add(md.length())__                    existingTotalSize += md.length()__                    if (logger.isTraceEnabled()) {_                        logger.trace("recovery [phase1]: not recovering [{}], exist in local store and has checksum [{}]," +_                                        " size [{}]", md.name(), md.checksum(), md.length())__                    }_                    totalSize += md.length()__                }_                List<StoreFileMetaData> phase1Files = new ArrayList<>(diff.different.size() + diff.missing.size())__                phase1Files.addAll(diff.different)__                phase1Files.addAll(diff.missing)__                for (StoreFileMetaData md : phase1Files) {_                    if (request.metadataSnapshot().asMap().containsKey(md.name())) {_                        logger.trace("recovery [phase1]: recovering [{}], exists in local store, but is different: remote [{}], local [{}]",_                            md.name(), request.metadataSnapshot().asMap().get(md.name()), md)__                    } else {_                        logger.trace("recovery [phase1]: recovering [{}], does not exist in remote", md.name())__                    }_                    phase1FileNames.add(md.name())__                    phase1FileSizes.add(md.length())__                    totalSize += md.length()__                }__                logger.trace("recovery [phase1]: recovering_files [{}] with total_size [{}], reusing_files [{}] with total_size [{}]",_                    phase1FileNames.size(), new ByteSizeValue(totalSize),_                    phase1ExistingFileNames.size(), new ByteSizeValue(existingTotalSize))__                cancellableThreads.execute(() -> recoveryTarget.receiveFileInfo(_                    phase1FileNames, phase1FileSizes, phase1ExistingFileNames, phase1ExistingFileSizes, translogOps.get()))__                sendFiles(store, phase1Files.toArray(new StoreFileMetaData[0]), translogOps)__                _                _                _                _                _                _                _                _                try {_                    cancellableThreads.executeIO(() ->_                        recoveryTarget.cleanFiles(translogOps.get(), recoverySourceMetadata))__                } catch (RemoteTransportException | IOException targetException) {_                    final IOException corruptIndexException__                    _                    _                    _                    _                    if ((corruptIndexException = ExceptionsHelper.unwrapCorruption(targetException)) != null) {_                        try {_                            final Store.MetadataSnapshot recoverySourceMetadata1 = store.getMetadata(snapshot)__                            StoreFileMetaData[] metadata =_                                    StreamSupport.stream(recoverySourceMetadata1.spliterator(), false).toArray(StoreFileMetaData[]::new)__                            ArrayUtil.timSort(metadata, Comparator.comparingLong(StoreFileMetaData::length))_ _                            for (StoreFileMetaData md : metadata) {_                                cancellableThreads.checkForCancel()__                                logger.debug("checking integrity for file {} after remove corruption exception", md)__                                if (store.checkIntegrityNoException(md) == false) { _                                    shard.failShard("recovery", corruptIndexException)__                                    logger.warn("Corrupted file detected {} checksum mismatch", md)__                                    throw corruptIndexException__                                }_                            }_                        } catch (IOException ex) {_                            targetException.addSuppressed(ex)__                            throw targetException__                        }_                        _                        RemoteTransportException exception = new RemoteTransportException("File corruption occurred on recovery but " +_                                "checksums are ok", null)__                        exception.addSuppressed(targetException)__                        logger.warn(() -> new ParameterizedMessage(_                                "{} Remote file corruption during finalization of recovery on node {}. local checksum OK",_                                shard.shardId(), request.targetNode()), corruptIndexException)__                        throw exception__                    } else {_                        throw targetException__                    }_                }_            }_            final TimeValue took = stopWatch.totalTime()__            logger.trace("recovery [phase1]: took [{}]", took)__            return new SendFileResult(phase1FileNames, phase1FileSizes, totalSize, phase1ExistingFileNames,_                phase1ExistingFileSizes, existingTotalSize, took)__        } catch (Exception e) {_            throw new RecoverFilesRecoveryException(request.shardId(), phase1FileNames.size(), new ByteSizeValue(totalSize), e)__        } finally {_            store.decRef()__        }_    };perform,phase1,of,the,recovery,operations,once,this,link,index,commit,snapshot,has,been,performed,no,commit,operations,files,being,fsync,d,are,effectively,allowed,on,this,index,until,all,recovery,phases,are,done,p,phase1,examines,the,segment,files,on,the,target,node,and,copies,over,the,segments,that,are,missing,only,segments,that,have,the,same,size,and,checksum,can,be,reused;public,send,file,result,phase1,final,index,commit,snapshot,final,supplier,integer,translog,ops,cancellable,threads,check,for,cancel,long,total,size,0,long,existing,total,size,0,final,list,string,phase1file,names,new,array,list,final,list,long,phase1file,sizes,new,array,list,final,list,string,phase1existing,file,names,new,array,list,final,list,long,phase1existing,file,sizes,new,array,list,final,store,store,shard,store,store,inc,ref,try,stop,watch,stop,watch,new,stop,watch,start,final,store,metadata,snapshot,recovery,source,metadata,try,recovery,source,metadata,store,get,metadata,snapshot,catch,corrupt,index,exception,index,format,too,old,exception,index,format,too,new,exception,ex,shard,fail,shard,recovery,ex,throw,ex,for,string,name,snapshot,get,file,names,final,store,file,meta,data,md,recovery,source,metadata,get,name,if,md,null,logger,info,snapshot,differs,from,actual,index,for,file,meta,name,recovery,source,metadata,as,map,throw,new,corrupt,index,exception,snapshot,differs,from,actual,index,maybe,index,was,removed,metadata,has,recovery,source,metadata,as,map,size,files,name,string,recovery,source,sync,id,recovery,source,metadata,get,sync,id,string,recovery,target,sync,id,request,metadata,snapshot,get,sync,id,final,boolean,recover,with,sync,id,recovery,source,sync,id,null,recovery,source,sync,id,equals,recovery,target,sync,id,if,recover,with,sync,id,final,long,num,docs,target,request,metadata,snapshot,get,num,docs,final,long,num,docs,source,recovery,source,metadata,get,num,docs,if,num,docs,target,num,docs,source,throw,new,illegal,state,exception,try,to,recover,request,shard,id,from,primary,shard,with,sync,id,but,number,of,docs,differ,num,docs,source,request,source,node,get,name,primary,vs,num,docs,target,request,target,node,get,name,logger,trace,skipping,phase1,identical,sync,id,found,on,both,source,and,target,recovery,source,sync,id,else,final,store,recovery,diff,diff,recovery,source,metadata,recovery,diff,request,metadata,snapshot,for,store,file,meta,data,md,diff,identical,phase1existing,file,names,add,md,name,phase1existing,file,sizes,add,md,length,existing,total,size,md,length,if,logger,is,trace,enabled,logger,trace,recovery,phase1,not,recovering,exist,in,local,store,and,has,checksum,size,md,name,md,checksum,md,length,total,size,md,length,list,store,file,meta,data,phase1files,new,array,list,diff,different,size,diff,missing,size,phase1files,add,all,diff,different,phase1files,add,all,diff,missing,for,store,file,meta,data,md,phase1files,if,request,metadata,snapshot,as,map,contains,key,md,name,logger,trace,recovery,phase1,recovering,exists,in,local,store,but,is,different,remote,local,md,name,request,metadata,snapshot,as,map,get,md,name,md,else,logger,trace,recovery,phase1,recovering,does,not,exist,in,remote,md,name,phase1file,names,add,md,name,phase1file,sizes,add,md,length,total,size,md,length,logger,trace,recovery,phase1,with,with,phase1file,names,size,new,byte,size,value,total,size,phase1existing,file,names,size,new,byte,size,value,existing,total,size,cancellable,threads,execute,recovery,target,receive,file,info,phase1file,names,phase1file,sizes,phase1existing,file,names,phase1existing,file,sizes,translog,ops,get,send,files,store,phase1files,to,array,new,store,file,meta,data,0,translog,ops,try,cancellable,threads,execute,io,recovery,target,clean,files,translog,ops,get,recovery,source,metadata,catch,remote,transport,exception,ioexception,target,exception,final,ioexception,corrupt,index,exception,if,corrupt,index,exception,exceptions,helper,unwrap,corruption,target,exception,null,try,final,store,metadata,snapshot,recovery,source,metadata1,store,get,metadata,snapshot,store,file,meta,data,metadata,stream,support,stream,recovery,source,metadata1,spliterator,false,to,array,store,file,meta,data,new,array,util,tim,sort,metadata,comparator,comparing,long,store,file,meta,data,length,for,store,file,meta,data,md,metadata,cancellable,threads,check,for,cancel,logger,debug,checking,integrity,for,file,after,remove,corruption,exception,md,if,store,check,integrity,no,exception,md,false,shard,fail,shard,recovery,corrupt,index,exception,logger,warn,corrupted,file,detected,checksum,mismatch,md,throw,corrupt,index,exception,catch,ioexception,ex,target,exception,add,suppressed,ex,throw,target,exception,remote,transport,exception,exception,new,remote,transport,exception,file,corruption,occurred,on,recovery,but,checksums,are,ok,null,exception,add,suppressed,target,exception,logger,warn,new,parameterized,message,remote,file,corruption,during,finalization,of,recovery,on,node,local,checksum,ok,shard,shard,id,request,target,node,corrupt,index,exception,throw,exception,else,throw,target,exception,final,time,value,took,stop,watch,total,time,logger,trace,recovery,phase1,took,took,return,new,send,file,result,phase1file,names,phase1file,sizes,total,size,phase1existing,file,names,phase1existing,file,sizes,existing,total,size,took,catch,exception,e,throw,new,recover,files,recovery,exception,request,shard,id,phase1file,names,size,new,byte,size,value,total,size,e,finally,store,dec,ref
RecoverySourceHandler -> public SendFileResult phase1(final IndexCommit snapshot, final Supplier<Integer> translogOps);1549406621;Perform phase1 of the recovery operations. Once this {@link IndexCommit}_snapshot has been performed no commit operations (files being fsync'd)_are effectively allowed on this index until all recovery phases are done_<p>_Phase1 examines the segment files on the target node and copies over the_segments that are missing. Only segments that have the same size and_checksum can be reused;public SendFileResult phase1(final IndexCommit snapshot, final Supplier<Integer> translogOps) {_        cancellableThreads.checkForCancel()__        _        long totalSize = 0__        _        long existingTotalSize = 0__        final List<String> phase1FileNames = new ArrayList<>()__        final List<Long> phase1FileSizes = new ArrayList<>()__        final List<String> phase1ExistingFileNames = new ArrayList<>()__        final List<Long> phase1ExistingFileSizes = new ArrayList<>()__        final Store store = shard.store()__        store.incRef()__        try {_            StopWatch stopWatch = new StopWatch().start()__            final Store.MetadataSnapshot recoverySourceMetadata__            try {_                recoverySourceMetadata = store.getMetadata(snapshot)__            } catch (CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {_                shard.failShard("recovery", ex)__                throw ex__            }_            for (String name : snapshot.getFileNames()) {_                final StoreFileMetaData md = recoverySourceMetadata.get(name)__                if (md == null) {_                    logger.info("Snapshot differs from actual index for file: {} meta: {}", name, recoverySourceMetadata.asMap())__                    throw new CorruptIndexException("Snapshot differs from actual index - maybe index was removed metadata has " +_                            recoverySourceMetadata.asMap().size() + " files", name)__                }_            }_            _            _            _            String recoverySourceSyncId = recoverySourceMetadata.getSyncId()__            String recoveryTargetSyncId = request.metadataSnapshot().getSyncId()__            final boolean recoverWithSyncId = recoverySourceSyncId != null &&_                    recoverySourceSyncId.equals(recoveryTargetSyncId)__            if (recoverWithSyncId) {_                final long numDocsTarget = request.metadataSnapshot().getNumDocs()__                final long numDocsSource = recoverySourceMetadata.getNumDocs()__                if (numDocsTarget != numDocsSource) {_                    throw new IllegalStateException("try to recover " + request.shardId() + " from primary shard with sync id but number " +_                            "of docs differ: " + numDocsSource + " (" + request.sourceNode().getName() + ", primary) vs " + numDocsTarget_                            + "(" + request.targetNode().getName() + ")")__                }_                _                _                logger.trace("skipping [phase1]- identical sync id [{}] found on both source and target", recoverySourceSyncId)__            } else {_                final Store.RecoveryDiff diff = recoverySourceMetadata.recoveryDiff(request.metadataSnapshot())__                for (StoreFileMetaData md : diff.identical) {_                    phase1ExistingFileNames.add(md.name())__                    phase1ExistingFileSizes.add(md.length())__                    existingTotalSize += md.length()__                    if (logger.isTraceEnabled()) {_                        logger.trace("recovery [phase1]: not recovering [{}], exist in local store and has checksum [{}]," +_                                        " size [{}]", md.name(), md.checksum(), md.length())__                    }_                    totalSize += md.length()__                }_                List<StoreFileMetaData> phase1Files = new ArrayList<>(diff.different.size() + diff.missing.size())__                phase1Files.addAll(diff.different)__                phase1Files.addAll(diff.missing)__                for (StoreFileMetaData md : phase1Files) {_                    if (request.metadataSnapshot().asMap().containsKey(md.name())) {_                        logger.trace("recovery [phase1]: recovering [{}], exists in local store, but is different: remote [{}], local [{}]",_                            md.name(), request.metadataSnapshot().asMap().get(md.name()), md)__                    } else {_                        logger.trace("recovery [phase1]: recovering [{}], does not exist in remote", md.name())__                    }_                    phase1FileNames.add(md.name())__                    phase1FileSizes.add(md.length())__                    totalSize += md.length()__                }__                logger.trace("recovery [phase1]: recovering_files [{}] with total_size [{}], reusing_files [{}] with total_size [{}]",_                    phase1FileNames.size(), new ByteSizeValue(totalSize),_                    phase1ExistingFileNames.size(), new ByteSizeValue(existingTotalSize))__                cancellableThreads.execute(() -> recoveryTarget.receiveFileInfo(_                    phase1FileNames, phase1FileSizes, phase1ExistingFileNames, phase1ExistingFileSizes, translogOps.get()))__                sendFiles(store, phase1Files.toArray(new StoreFileMetaData[0]), translogOps)__                _                _                _                _                _                _                _                _                try {_                    cancellableThreads.executeIO(() ->_                        recoveryTarget.cleanFiles(translogOps.get(), recoverySourceMetadata))__                } catch (RemoteTransportException | IOException targetException) {_                    final IOException corruptIndexException__                    _                    _                    _                    _                    if ((corruptIndexException = ExceptionsHelper.unwrapCorruption(targetException)) != null) {_                        try {_                            final Store.MetadataSnapshot recoverySourceMetadata1 = store.getMetadata(snapshot)__                            StoreFileMetaData[] metadata =_                                    StreamSupport.stream(recoverySourceMetadata1.spliterator(), false).toArray(StoreFileMetaData[]::new)__                            ArrayUtil.timSort(metadata, Comparator.comparingLong(StoreFileMetaData::length))_ _                            for (StoreFileMetaData md : metadata) {_                                cancellableThreads.checkForCancel()__                                logger.debug("checking integrity for file {} after remove corruption exception", md)__                                if (store.checkIntegrityNoException(md) == false) { _                                    shard.failShard("recovery", corruptIndexException)__                                    logger.warn("Corrupted file detected {} checksum mismatch", md)__                                    throw corruptIndexException__                                }_                            }_                        } catch (IOException ex) {_                            targetException.addSuppressed(ex)__                            throw targetException__                        }_                        _                        RemoteTransportException exception = new RemoteTransportException("File corruption occurred on recovery but " +_                                "checksums are ok", null)__                        exception.addSuppressed(targetException)__                        logger.warn(() -> new ParameterizedMessage(_                                "{} Remote file corruption during finalization of recovery on node {}. local checksum OK",_                                shard.shardId(), request.targetNode()), corruptIndexException)__                        throw exception__                    } else {_                        throw targetException__                    }_                }_            }_            final TimeValue took = stopWatch.totalTime()__            logger.trace("recovery [phase1]: took [{}]", took)__            return new SendFileResult(phase1FileNames, phase1FileSizes, totalSize, phase1ExistingFileNames,_                phase1ExistingFileSizes, existingTotalSize, took)__        } catch (Exception e) {_            throw new RecoverFilesRecoveryException(request.shardId(), phase1FileNames.size(), new ByteSizeValue(totalSize), e)__        } finally {_            store.decRef()__        }_    };perform,phase1,of,the,recovery,operations,once,this,link,index,commit,snapshot,has,been,performed,no,commit,operations,files,being,fsync,d,are,effectively,allowed,on,this,index,until,all,recovery,phases,are,done,p,phase1,examines,the,segment,files,on,the,target,node,and,copies,over,the,segments,that,are,missing,only,segments,that,have,the,same,size,and,checksum,can,be,reused;public,send,file,result,phase1,final,index,commit,snapshot,final,supplier,integer,translog,ops,cancellable,threads,check,for,cancel,long,total,size,0,long,existing,total,size,0,final,list,string,phase1file,names,new,array,list,final,list,long,phase1file,sizes,new,array,list,final,list,string,phase1existing,file,names,new,array,list,final,list,long,phase1existing,file,sizes,new,array,list,final,store,store,shard,store,store,inc,ref,try,stop,watch,stop,watch,new,stop,watch,start,final,store,metadata,snapshot,recovery,source,metadata,try,recovery,source,metadata,store,get,metadata,snapshot,catch,corrupt,index,exception,index,format,too,old,exception,index,format,too,new,exception,ex,shard,fail,shard,recovery,ex,throw,ex,for,string,name,snapshot,get,file,names,final,store,file,meta,data,md,recovery,source,metadata,get,name,if,md,null,logger,info,snapshot,differs,from,actual,index,for,file,meta,name,recovery,source,metadata,as,map,throw,new,corrupt,index,exception,snapshot,differs,from,actual,index,maybe,index,was,removed,metadata,has,recovery,source,metadata,as,map,size,files,name,string,recovery,source,sync,id,recovery,source,metadata,get,sync,id,string,recovery,target,sync,id,request,metadata,snapshot,get,sync,id,final,boolean,recover,with,sync,id,recovery,source,sync,id,null,recovery,source,sync,id,equals,recovery,target,sync,id,if,recover,with,sync,id,final,long,num,docs,target,request,metadata,snapshot,get,num,docs,final,long,num,docs,source,recovery,source,metadata,get,num,docs,if,num,docs,target,num,docs,source,throw,new,illegal,state,exception,try,to,recover,request,shard,id,from,primary,shard,with,sync,id,but,number,of,docs,differ,num,docs,source,request,source,node,get,name,primary,vs,num,docs,target,request,target,node,get,name,logger,trace,skipping,phase1,identical,sync,id,found,on,both,source,and,target,recovery,source,sync,id,else,final,store,recovery,diff,diff,recovery,source,metadata,recovery,diff,request,metadata,snapshot,for,store,file,meta,data,md,diff,identical,phase1existing,file,names,add,md,name,phase1existing,file,sizes,add,md,length,existing,total,size,md,length,if,logger,is,trace,enabled,logger,trace,recovery,phase1,not,recovering,exist,in,local,store,and,has,checksum,size,md,name,md,checksum,md,length,total,size,md,length,list,store,file,meta,data,phase1files,new,array,list,diff,different,size,diff,missing,size,phase1files,add,all,diff,different,phase1files,add,all,diff,missing,for,store,file,meta,data,md,phase1files,if,request,metadata,snapshot,as,map,contains,key,md,name,logger,trace,recovery,phase1,recovering,exists,in,local,store,but,is,different,remote,local,md,name,request,metadata,snapshot,as,map,get,md,name,md,else,logger,trace,recovery,phase1,recovering,does,not,exist,in,remote,md,name,phase1file,names,add,md,name,phase1file,sizes,add,md,length,total,size,md,length,logger,trace,recovery,phase1,with,with,phase1file,names,size,new,byte,size,value,total,size,phase1existing,file,names,size,new,byte,size,value,existing,total,size,cancellable,threads,execute,recovery,target,receive,file,info,phase1file,names,phase1file,sizes,phase1existing,file,names,phase1existing,file,sizes,translog,ops,get,send,files,store,phase1files,to,array,new,store,file,meta,data,0,translog,ops,try,cancellable,threads,execute,io,recovery,target,clean,files,translog,ops,get,recovery,source,metadata,catch,remote,transport,exception,ioexception,target,exception,final,ioexception,corrupt,index,exception,if,corrupt,index,exception,exceptions,helper,unwrap,corruption,target,exception,null,try,final,store,metadata,snapshot,recovery,source,metadata1,store,get,metadata,snapshot,store,file,meta,data,metadata,stream,support,stream,recovery,source,metadata1,spliterator,false,to,array,store,file,meta,data,new,array,util,tim,sort,metadata,comparator,comparing,long,store,file,meta,data,length,for,store,file,meta,data,md,metadata,cancellable,threads,check,for,cancel,logger,debug,checking,integrity,for,file,after,remove,corruption,exception,md,if,store,check,integrity,no,exception,md,false,shard,fail,shard,recovery,corrupt,index,exception,logger,warn,corrupted,file,detected,checksum,mismatch,md,throw,corrupt,index,exception,catch,ioexception,ex,target,exception,add,suppressed,ex,throw,target,exception,remote,transport,exception,exception,new,remote,transport,exception,file,corruption,occurred,on,recovery,but,checksums,are,ok,null,exception,add,suppressed,target,exception,logger,warn,new,parameterized,message,remote,file,corruption,during,finalization,of,recovery,on,node,local,checksum,ok,shard,shard,id,request,target,node,corrupt,index,exception,throw,exception,else,throw,target,exception,final,time,value,took,stop,watch,total,time,logger,trace,recovery,phase1,took,took,return,new,send,file,result,phase1file,names,phase1file,sizes,total,size,phase1existing,file,names,phase1existing,file,sizes,existing,total,size,took,catch,exception,e,throw,new,recover,files,recovery,exception,request,shard,id,phase1file,names,size,new,byte,size,value,total,size,e,finally,store,dec,ref
RecoverySourceHandler -> public SendFileResult phase1(final IndexCommit snapshot, final Supplier<Integer> translogOps);1549975032;Perform phase1 of the recovery operations. Once this {@link IndexCommit}_snapshot has been performed no commit operations (files being fsync'd)_are effectively allowed on this index until all recovery phases are done_<p>_Phase1 examines the segment files on the target node and copies over the_segments that are missing. Only segments that have the same size and_checksum can be reused;public SendFileResult phase1(final IndexCommit snapshot, final Supplier<Integer> translogOps) {_        cancellableThreads.checkForCancel()__        _        long totalSize = 0__        _        long existingTotalSize = 0__        final List<String> phase1FileNames = new ArrayList<>()__        final List<Long> phase1FileSizes = new ArrayList<>()__        final List<String> phase1ExistingFileNames = new ArrayList<>()__        final List<Long> phase1ExistingFileSizes = new ArrayList<>()__        final Store store = shard.store()__        store.incRef()__        try {_            StopWatch stopWatch = new StopWatch().start()__            final Store.MetadataSnapshot recoverySourceMetadata__            try {_                recoverySourceMetadata = store.getMetadata(snapshot)__            } catch (CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {_                shard.failShard("recovery", ex)__                throw ex__            }_            for (String name : snapshot.getFileNames()) {_                final StoreFileMetaData md = recoverySourceMetadata.get(name)__                if (md == null) {_                    logger.info("Snapshot differs from actual index for file: {} meta: {}", name, recoverySourceMetadata.asMap())__                    throw new CorruptIndexException("Snapshot differs from actual index - maybe index was removed metadata has " +_                            recoverySourceMetadata.asMap().size() + " files", name)__                }_            }_            _            _            _            String recoverySourceSyncId = recoverySourceMetadata.getSyncId()__            String recoveryTargetSyncId = request.metadataSnapshot().getSyncId()__            final boolean recoverWithSyncId = recoverySourceSyncId != null &&_                    recoverySourceSyncId.equals(recoveryTargetSyncId)__            if (recoverWithSyncId) {_                final long numDocsTarget = request.metadataSnapshot().getNumDocs()__                final long numDocsSource = recoverySourceMetadata.getNumDocs()__                if (numDocsTarget != numDocsSource) {_                    throw new IllegalStateException("try to recover " + request.shardId() + " from primary shard with sync id but number " +_                            "of docs differ: " + numDocsSource + " (" + request.sourceNode().getName() + ", primary) vs " + numDocsTarget_                            + "(" + request.targetNode().getName() + ")")__                }_                _                _                logger.trace("skipping [phase1]- identical sync id [{}] found on both source and target", recoverySourceSyncId)__            } else {_                final Store.RecoveryDiff diff = recoverySourceMetadata.recoveryDiff(request.metadataSnapshot())__                for (StoreFileMetaData md : diff.identical) {_                    phase1ExistingFileNames.add(md.name())__                    phase1ExistingFileSizes.add(md.length())__                    existingTotalSize += md.length()__                    if (logger.isTraceEnabled()) {_                        logger.trace("recovery [phase1]: not recovering [{}], exist in local store and has checksum [{}]," +_                                        " size [{}]", md.name(), md.checksum(), md.length())__                    }_                    totalSize += md.length()__                }_                List<StoreFileMetaData> phase1Files = new ArrayList<>(diff.different.size() + diff.missing.size())__                phase1Files.addAll(diff.different)__                phase1Files.addAll(diff.missing)__                for (StoreFileMetaData md : phase1Files) {_                    if (request.metadataSnapshot().asMap().containsKey(md.name())) {_                        logger.trace("recovery [phase1]: recovering [{}], exists in local store, but is different: remote [{}], local [{}]",_                            md.name(), request.metadataSnapshot().asMap().get(md.name()), md)__                    } else {_                        logger.trace("recovery [phase1]: recovering [{}], does not exist in remote", md.name())__                    }_                    phase1FileNames.add(md.name())__                    phase1FileSizes.add(md.length())__                    totalSize += md.length()__                }__                logger.trace("recovery [phase1]: recovering_files [{}] with total_size [{}], reusing_files [{}] with total_size [{}]",_                    phase1FileNames.size(), new ByteSizeValue(totalSize),_                    phase1ExistingFileNames.size(), new ByteSizeValue(existingTotalSize))__                cancellableThreads.execute(() -> recoveryTarget.receiveFileInfo(_                    phase1FileNames, phase1FileSizes, phase1ExistingFileNames, phase1ExistingFileSizes, translogOps.get()))__                sendFiles(store, phase1Files.toArray(new StoreFileMetaData[0]), translogOps)__                _                _                _                _                _                _                _                _                try {_                    cancellableThreads.executeIO(() ->_                        recoveryTarget.cleanFiles(translogOps.get(), recoverySourceMetadata))__                } catch (RemoteTransportException | IOException targetException) {_                    final IOException corruptIndexException__                    _                    _                    _                    _                    if ((corruptIndexException = ExceptionsHelper.unwrapCorruption(targetException)) != null) {_                        try {_                            final Store.MetadataSnapshot recoverySourceMetadata1 = store.getMetadata(snapshot)__                            StoreFileMetaData[] metadata =_                                    StreamSupport.stream(recoverySourceMetadata1.spliterator(), false).toArray(StoreFileMetaData[]::new)__                            ArrayUtil.timSort(metadata, Comparator.comparingLong(StoreFileMetaData::length))_ _                            for (StoreFileMetaData md : metadata) {_                                cancellableThreads.checkForCancel()__                                logger.debug("checking integrity for file {} after remove corruption exception", md)__                                if (store.checkIntegrityNoException(md) == false) { _                                    shard.failShard("recovery", corruptIndexException)__                                    logger.warn("Corrupted file detected {} checksum mismatch", md)__                                    throw corruptIndexException__                                }_                            }_                        } catch (IOException ex) {_                            targetException.addSuppressed(ex)__                            throw targetException__                        }_                        _                        RemoteTransportException exception = new RemoteTransportException("File corruption occurred on recovery but " +_                                "checksums are ok", null)__                        exception.addSuppressed(targetException)__                        logger.warn(() -> new ParameterizedMessage(_                                "{} Remote file corruption during finalization of recovery on node {}. local checksum OK",_                                shard.shardId(), request.targetNode()), corruptIndexException)__                        throw exception__                    } else {_                        throw targetException__                    }_                }_            }_            final TimeValue took = stopWatch.totalTime()__            logger.trace("recovery [phase1]: took [{}]", took)__            return new SendFileResult(phase1FileNames, phase1FileSizes, totalSize, phase1ExistingFileNames,_                phase1ExistingFileSizes, existingTotalSize, took)__        } catch (Exception e) {_            throw new RecoverFilesRecoveryException(request.shardId(), phase1FileNames.size(), new ByteSizeValue(totalSize), e)__        } finally {_            store.decRef()__        }_    };perform,phase1,of,the,recovery,operations,once,this,link,index,commit,snapshot,has,been,performed,no,commit,operations,files,being,fsync,d,are,effectively,allowed,on,this,index,until,all,recovery,phases,are,done,p,phase1,examines,the,segment,files,on,the,target,node,and,copies,over,the,segments,that,are,missing,only,segments,that,have,the,same,size,and,checksum,can,be,reused;public,send,file,result,phase1,final,index,commit,snapshot,final,supplier,integer,translog,ops,cancellable,threads,check,for,cancel,long,total,size,0,long,existing,total,size,0,final,list,string,phase1file,names,new,array,list,final,list,long,phase1file,sizes,new,array,list,final,list,string,phase1existing,file,names,new,array,list,final,list,long,phase1existing,file,sizes,new,array,list,final,store,store,shard,store,store,inc,ref,try,stop,watch,stop,watch,new,stop,watch,start,final,store,metadata,snapshot,recovery,source,metadata,try,recovery,source,metadata,store,get,metadata,snapshot,catch,corrupt,index,exception,index,format,too,old,exception,index,format,too,new,exception,ex,shard,fail,shard,recovery,ex,throw,ex,for,string,name,snapshot,get,file,names,final,store,file,meta,data,md,recovery,source,metadata,get,name,if,md,null,logger,info,snapshot,differs,from,actual,index,for,file,meta,name,recovery,source,metadata,as,map,throw,new,corrupt,index,exception,snapshot,differs,from,actual,index,maybe,index,was,removed,metadata,has,recovery,source,metadata,as,map,size,files,name,string,recovery,source,sync,id,recovery,source,metadata,get,sync,id,string,recovery,target,sync,id,request,metadata,snapshot,get,sync,id,final,boolean,recover,with,sync,id,recovery,source,sync,id,null,recovery,source,sync,id,equals,recovery,target,sync,id,if,recover,with,sync,id,final,long,num,docs,target,request,metadata,snapshot,get,num,docs,final,long,num,docs,source,recovery,source,metadata,get,num,docs,if,num,docs,target,num,docs,source,throw,new,illegal,state,exception,try,to,recover,request,shard,id,from,primary,shard,with,sync,id,but,number,of,docs,differ,num,docs,source,request,source,node,get,name,primary,vs,num,docs,target,request,target,node,get,name,logger,trace,skipping,phase1,identical,sync,id,found,on,both,source,and,target,recovery,source,sync,id,else,final,store,recovery,diff,diff,recovery,source,metadata,recovery,diff,request,metadata,snapshot,for,store,file,meta,data,md,diff,identical,phase1existing,file,names,add,md,name,phase1existing,file,sizes,add,md,length,existing,total,size,md,length,if,logger,is,trace,enabled,logger,trace,recovery,phase1,not,recovering,exist,in,local,store,and,has,checksum,size,md,name,md,checksum,md,length,total,size,md,length,list,store,file,meta,data,phase1files,new,array,list,diff,different,size,diff,missing,size,phase1files,add,all,diff,different,phase1files,add,all,diff,missing,for,store,file,meta,data,md,phase1files,if,request,metadata,snapshot,as,map,contains,key,md,name,logger,trace,recovery,phase1,recovering,exists,in,local,store,but,is,different,remote,local,md,name,request,metadata,snapshot,as,map,get,md,name,md,else,logger,trace,recovery,phase1,recovering,does,not,exist,in,remote,md,name,phase1file,names,add,md,name,phase1file,sizes,add,md,length,total,size,md,length,logger,trace,recovery,phase1,with,with,phase1file,names,size,new,byte,size,value,total,size,phase1existing,file,names,size,new,byte,size,value,existing,total,size,cancellable,threads,execute,recovery,target,receive,file,info,phase1file,names,phase1file,sizes,phase1existing,file,names,phase1existing,file,sizes,translog,ops,get,send,files,store,phase1files,to,array,new,store,file,meta,data,0,translog,ops,try,cancellable,threads,execute,io,recovery,target,clean,files,translog,ops,get,recovery,source,metadata,catch,remote,transport,exception,ioexception,target,exception,final,ioexception,corrupt,index,exception,if,corrupt,index,exception,exceptions,helper,unwrap,corruption,target,exception,null,try,final,store,metadata,snapshot,recovery,source,metadata1,store,get,metadata,snapshot,store,file,meta,data,metadata,stream,support,stream,recovery,source,metadata1,spliterator,false,to,array,store,file,meta,data,new,array,util,tim,sort,metadata,comparator,comparing,long,store,file,meta,data,length,for,store,file,meta,data,md,metadata,cancellable,threads,check,for,cancel,logger,debug,checking,integrity,for,file,after,remove,corruption,exception,md,if,store,check,integrity,no,exception,md,false,shard,fail,shard,recovery,corrupt,index,exception,logger,warn,corrupted,file,detected,checksum,mismatch,md,throw,corrupt,index,exception,catch,ioexception,ex,target,exception,add,suppressed,ex,throw,target,exception,remote,transport,exception,exception,new,remote,transport,exception,file,corruption,occurred,on,recovery,but,checksums,are,ok,null,exception,add,suppressed,target,exception,logger,warn,new,parameterized,message,remote,file,corruption,during,finalization,of,recovery,on,node,local,checksum,ok,shard,shard,id,request,target,node,corrupt,index,exception,throw,exception,else,throw,target,exception,final,time,value,took,stop,watch,total,time,logger,trace,recovery,phase1,took,took,return,new,send,file,result,phase1file,names,phase1file,sizes,total,size,phase1existing,file,names,phase1existing,file,sizes,existing,total,size,took,catch,exception,e,throw,new,recover,files,recovery,exception,request,shard,id,phase1file,names,size,new,byte,size,value,total,size,e,finally,store,dec,ref
RecoverySourceHandler -> public SendFileResult phase1(final IndexCommit snapshot, final Supplier<Integer> translogOps);1550220204;Perform phase1 of the recovery operations. Once this {@link IndexCommit}_snapshot has been performed no commit operations (files being fsync'd)_are effectively allowed on this index until all recovery phases are done_<p>_Phase1 examines the segment files on the target node and copies over the_segments that are missing. Only segments that have the same size and_checksum can be reused;public SendFileResult phase1(final IndexCommit snapshot, final Supplier<Integer> translogOps) {_        cancellableThreads.checkForCancel()__        _        long totalSize = 0__        _        long existingTotalSize = 0__        final List<String> phase1FileNames = new ArrayList<>()__        final List<Long> phase1FileSizes = new ArrayList<>()__        final List<String> phase1ExistingFileNames = new ArrayList<>()__        final List<Long> phase1ExistingFileSizes = new ArrayList<>()__        final Store store = shard.store()__        store.incRef()__        try {_            StopWatch stopWatch = new StopWatch().start()__            final Store.MetadataSnapshot recoverySourceMetadata__            try {_                recoverySourceMetadata = store.getMetadata(snapshot)__            } catch (CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {_                shard.failShard("recovery", ex)__                throw ex__            }_            for (String name : snapshot.getFileNames()) {_                final StoreFileMetaData md = recoverySourceMetadata.get(name)__                if (md == null) {_                    logger.info("Snapshot differs from actual index for file: {} meta: {}", name, recoverySourceMetadata.asMap())__                    throw new CorruptIndexException("Snapshot differs from actual index - maybe index was removed metadata has " +_                            recoverySourceMetadata.asMap().size() + " files", name)__                }_            }_            _            _            _            String recoverySourceSyncId = recoverySourceMetadata.getSyncId()__            String recoveryTargetSyncId = request.metadataSnapshot().getSyncId()__            final boolean recoverWithSyncId = recoverySourceSyncId != null &&_                    recoverySourceSyncId.equals(recoveryTargetSyncId)__            if (recoverWithSyncId) {_                final long numDocsTarget = request.metadataSnapshot().getNumDocs()__                final long numDocsSource = recoverySourceMetadata.getNumDocs()__                if (numDocsTarget != numDocsSource) {_                    throw new IllegalStateException("try to recover " + request.shardId() + " from primary shard with sync id but number " +_                            "of docs differ: " + numDocsSource + " (" + request.sourceNode().getName() + ", primary) vs " + numDocsTarget_                            + "(" + request.targetNode().getName() + ")")__                }_                _                _                logger.trace("skipping [phase1]- identical sync id [{}] found on both source and target", recoverySourceSyncId)__            } else {_                final Store.RecoveryDiff diff = recoverySourceMetadata.recoveryDiff(request.metadataSnapshot())__                for (StoreFileMetaData md : diff.identical) {_                    phase1ExistingFileNames.add(md.name())__                    phase1ExistingFileSizes.add(md.length())__                    existingTotalSize += md.length()__                    if (logger.isTraceEnabled()) {_                        logger.trace("recovery [phase1]: not recovering [{}], exist in local store and has checksum [{}]," +_                                        " size [{}]", md.name(), md.checksum(), md.length())__                    }_                    totalSize += md.length()__                }_                List<StoreFileMetaData> phase1Files = new ArrayList<>(diff.different.size() + diff.missing.size())__                phase1Files.addAll(diff.different)__                phase1Files.addAll(diff.missing)__                for (StoreFileMetaData md : phase1Files) {_                    if (request.metadataSnapshot().asMap().containsKey(md.name())) {_                        logger.trace("recovery [phase1]: recovering [{}], exists in local store, but is different: remote [{}], local [{}]",_                            md.name(), request.metadataSnapshot().asMap().get(md.name()), md)__                    } else {_                        logger.trace("recovery [phase1]: recovering [{}], does not exist in remote", md.name())__                    }_                    phase1FileNames.add(md.name())__                    phase1FileSizes.add(md.length())__                    totalSize += md.length()__                }__                logger.trace("recovery [phase1]: recovering_files [{}] with total_size [{}], reusing_files [{}] with total_size [{}]",_                    phase1FileNames.size(), new ByteSizeValue(totalSize),_                    phase1ExistingFileNames.size(), new ByteSizeValue(existingTotalSize))__                cancellableThreads.execute(() -> recoveryTarget.receiveFileInfo(_                    phase1FileNames, phase1FileSizes, phase1ExistingFileNames, phase1ExistingFileSizes, translogOps.get()))__                sendFiles(store, phase1Files.toArray(new StoreFileMetaData[0]), translogOps)__                _                _                _                _                _                _                _                _                try {_                    cancellableThreads.executeIO(() ->_                        recoveryTarget.cleanFiles(translogOps.get(), recoverySourceMetadata))__                } catch (RemoteTransportException | IOException targetException) {_                    final IOException corruptIndexException__                    _                    _                    _                    _                    if ((corruptIndexException = ExceptionsHelper.unwrapCorruption(targetException)) != null) {_                        try {_                            final Store.MetadataSnapshot recoverySourceMetadata1 = store.getMetadata(snapshot)__                            StoreFileMetaData[] metadata =_                                    StreamSupport.stream(recoverySourceMetadata1.spliterator(), false).toArray(StoreFileMetaData[]::new)__                            ArrayUtil.timSort(metadata, Comparator.comparingLong(StoreFileMetaData::length))_ _                            for (StoreFileMetaData md : metadata) {_                                cancellableThreads.checkForCancel()__                                logger.debug("checking integrity for file {} after remove corruption exception", md)__                                if (store.checkIntegrityNoException(md) == false) { _                                    shard.failShard("recovery", corruptIndexException)__                                    logger.warn("Corrupted file detected {} checksum mismatch", md)__                                    throw corruptIndexException__                                }_                            }_                        } catch (IOException ex) {_                            targetException.addSuppressed(ex)__                            throw targetException__                        }_                        _                        RemoteTransportException exception = new RemoteTransportException("File corruption occurred on recovery but " +_                                "checksums are ok", null)__                        exception.addSuppressed(targetException)__                        logger.warn(() -> new ParameterizedMessage(_                                "{} Remote file corruption during finalization of recovery on node {}. local checksum OK",_                                shard.shardId(), request.targetNode()), corruptIndexException)__                        throw exception__                    } else {_                        throw targetException__                    }_                }_            }_            final TimeValue took = stopWatch.totalTime()__            logger.trace("recovery [phase1]: took [{}]", took)__            return new SendFileResult(phase1FileNames, phase1FileSizes, totalSize, phase1ExistingFileNames,_                phase1ExistingFileSizes, existingTotalSize, took)__        } catch (Exception e) {_            throw new RecoverFilesRecoveryException(request.shardId(), phase1FileNames.size(), new ByteSizeValue(totalSize), e)__        } finally {_            store.decRef()__        }_    };perform,phase1,of,the,recovery,operations,once,this,link,index,commit,snapshot,has,been,performed,no,commit,operations,files,being,fsync,d,are,effectively,allowed,on,this,index,until,all,recovery,phases,are,done,p,phase1,examines,the,segment,files,on,the,target,node,and,copies,over,the,segments,that,are,missing,only,segments,that,have,the,same,size,and,checksum,can,be,reused;public,send,file,result,phase1,final,index,commit,snapshot,final,supplier,integer,translog,ops,cancellable,threads,check,for,cancel,long,total,size,0,long,existing,total,size,0,final,list,string,phase1file,names,new,array,list,final,list,long,phase1file,sizes,new,array,list,final,list,string,phase1existing,file,names,new,array,list,final,list,long,phase1existing,file,sizes,new,array,list,final,store,store,shard,store,store,inc,ref,try,stop,watch,stop,watch,new,stop,watch,start,final,store,metadata,snapshot,recovery,source,metadata,try,recovery,source,metadata,store,get,metadata,snapshot,catch,corrupt,index,exception,index,format,too,old,exception,index,format,too,new,exception,ex,shard,fail,shard,recovery,ex,throw,ex,for,string,name,snapshot,get,file,names,final,store,file,meta,data,md,recovery,source,metadata,get,name,if,md,null,logger,info,snapshot,differs,from,actual,index,for,file,meta,name,recovery,source,metadata,as,map,throw,new,corrupt,index,exception,snapshot,differs,from,actual,index,maybe,index,was,removed,metadata,has,recovery,source,metadata,as,map,size,files,name,string,recovery,source,sync,id,recovery,source,metadata,get,sync,id,string,recovery,target,sync,id,request,metadata,snapshot,get,sync,id,final,boolean,recover,with,sync,id,recovery,source,sync,id,null,recovery,source,sync,id,equals,recovery,target,sync,id,if,recover,with,sync,id,final,long,num,docs,target,request,metadata,snapshot,get,num,docs,final,long,num,docs,source,recovery,source,metadata,get,num,docs,if,num,docs,target,num,docs,source,throw,new,illegal,state,exception,try,to,recover,request,shard,id,from,primary,shard,with,sync,id,but,number,of,docs,differ,num,docs,source,request,source,node,get,name,primary,vs,num,docs,target,request,target,node,get,name,logger,trace,skipping,phase1,identical,sync,id,found,on,both,source,and,target,recovery,source,sync,id,else,final,store,recovery,diff,diff,recovery,source,metadata,recovery,diff,request,metadata,snapshot,for,store,file,meta,data,md,diff,identical,phase1existing,file,names,add,md,name,phase1existing,file,sizes,add,md,length,existing,total,size,md,length,if,logger,is,trace,enabled,logger,trace,recovery,phase1,not,recovering,exist,in,local,store,and,has,checksum,size,md,name,md,checksum,md,length,total,size,md,length,list,store,file,meta,data,phase1files,new,array,list,diff,different,size,diff,missing,size,phase1files,add,all,diff,different,phase1files,add,all,diff,missing,for,store,file,meta,data,md,phase1files,if,request,metadata,snapshot,as,map,contains,key,md,name,logger,trace,recovery,phase1,recovering,exists,in,local,store,but,is,different,remote,local,md,name,request,metadata,snapshot,as,map,get,md,name,md,else,logger,trace,recovery,phase1,recovering,does,not,exist,in,remote,md,name,phase1file,names,add,md,name,phase1file,sizes,add,md,length,total,size,md,length,logger,trace,recovery,phase1,with,with,phase1file,names,size,new,byte,size,value,total,size,phase1existing,file,names,size,new,byte,size,value,existing,total,size,cancellable,threads,execute,recovery,target,receive,file,info,phase1file,names,phase1file,sizes,phase1existing,file,names,phase1existing,file,sizes,translog,ops,get,send,files,store,phase1files,to,array,new,store,file,meta,data,0,translog,ops,try,cancellable,threads,execute,io,recovery,target,clean,files,translog,ops,get,recovery,source,metadata,catch,remote,transport,exception,ioexception,target,exception,final,ioexception,corrupt,index,exception,if,corrupt,index,exception,exceptions,helper,unwrap,corruption,target,exception,null,try,final,store,metadata,snapshot,recovery,source,metadata1,store,get,metadata,snapshot,store,file,meta,data,metadata,stream,support,stream,recovery,source,metadata1,spliterator,false,to,array,store,file,meta,data,new,array,util,tim,sort,metadata,comparator,comparing,long,store,file,meta,data,length,for,store,file,meta,data,md,metadata,cancellable,threads,check,for,cancel,logger,debug,checking,integrity,for,file,after,remove,corruption,exception,md,if,store,check,integrity,no,exception,md,false,shard,fail,shard,recovery,corrupt,index,exception,logger,warn,corrupted,file,detected,checksum,mismatch,md,throw,corrupt,index,exception,catch,ioexception,ex,target,exception,add,suppressed,ex,throw,target,exception,remote,transport,exception,exception,new,remote,transport,exception,file,corruption,occurred,on,recovery,but,checksums,are,ok,null,exception,add,suppressed,target,exception,logger,warn,new,parameterized,message,remote,file,corruption,during,finalization,of,recovery,on,node,local,checksum,ok,shard,shard,id,request,target,node,corrupt,index,exception,throw,exception,else,throw,target,exception,final,time,value,took,stop,watch,total,time,logger,trace,recovery,phase1,took,took,return,new,send,file,result,phase1file,names,phase1file,sizes,total,size,phase1existing,file,names,phase1existing,file,sizes,existing,total,size,took,catch,exception,e,throw,new,recover,files,recovery,exception,request,shard,id,phase1file,names,size,new,byte,size,value,total,size,e,finally,store,dec,ref
RecoverySourceHandler -> public SendFileResult phase1(final IndexCommit snapshot, final Supplier<Integer> translogOps);1551110274;Perform phase1 of the recovery operations. Once this {@link IndexCommit}_snapshot has been performed no commit operations (files being fsync'd)_are effectively allowed on this index until all recovery phases are done_<p>_Phase1 examines the segment files on the target node and copies over the_segments that are missing. Only segments that have the same size and_checksum can be reused;public SendFileResult phase1(final IndexCommit snapshot, final Supplier<Integer> translogOps) {_        cancellableThreads.checkForCancel()__        _        long totalSize = 0__        _        long existingTotalSize = 0__        final List<String> phase1FileNames = new ArrayList<>()__        final List<Long> phase1FileSizes = new ArrayList<>()__        final List<String> phase1ExistingFileNames = new ArrayList<>()__        final List<Long> phase1ExistingFileSizes = new ArrayList<>()__        final Store store = shard.store()__        store.incRef()__        try {_            StopWatch stopWatch = new StopWatch().start()__            final Store.MetadataSnapshot recoverySourceMetadata__            try {_                recoverySourceMetadata = store.getMetadata(snapshot)__            } catch (CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {_                shard.failShard("recovery", ex)__                throw ex__            }_            for (String name : snapshot.getFileNames()) {_                final StoreFileMetaData md = recoverySourceMetadata.get(name)__                if (md == null) {_                    logger.info("Snapshot differs from actual index for file: {} meta: {}", name, recoverySourceMetadata.asMap())__                    throw new CorruptIndexException("Snapshot differs from actual index - maybe index was removed metadata has " +_                            recoverySourceMetadata.asMap().size() + " files", name)__                }_            }_            _            _            _            String recoverySourceSyncId = recoverySourceMetadata.getSyncId()__            String recoveryTargetSyncId = request.metadataSnapshot().getSyncId()__            final boolean recoverWithSyncId = recoverySourceSyncId != null &&_                    recoverySourceSyncId.equals(recoveryTargetSyncId)__            if (recoverWithSyncId) {_                final long numDocsTarget = request.metadataSnapshot().getNumDocs()__                final long numDocsSource = recoverySourceMetadata.getNumDocs()__                if (numDocsTarget != numDocsSource) {_                    throw new IllegalStateException("try to recover " + request.shardId() + " from primary shard with sync id but number " +_                            "of docs differ: " + numDocsSource + " (" + request.sourceNode().getName() + ", primary) vs " + numDocsTarget_                            + "(" + request.targetNode().getName() + ")")__                }_                _                _                logger.trace("skipping [phase1]- identical sync id [{}] found on both source and target", recoverySourceSyncId)__            } else {_                final Store.RecoveryDiff diff = recoverySourceMetadata.recoveryDiff(request.metadataSnapshot())__                for (StoreFileMetaData md : diff.identical) {_                    phase1ExistingFileNames.add(md.name())__                    phase1ExistingFileSizes.add(md.length())__                    existingTotalSize += md.length()__                    if (logger.isTraceEnabled()) {_                        logger.trace("recovery [phase1]: not recovering [{}], exist in local store and has checksum [{}]," +_                                        " size [{}]", md.name(), md.checksum(), md.length())__                    }_                    totalSize += md.length()__                }_                List<StoreFileMetaData> phase1Files = new ArrayList<>(diff.different.size() + diff.missing.size())__                phase1Files.addAll(diff.different)__                phase1Files.addAll(diff.missing)__                for (StoreFileMetaData md : phase1Files) {_                    if (request.metadataSnapshot().asMap().containsKey(md.name())) {_                        logger.trace("recovery [phase1]: recovering [{}], exists in local store, but is different: remote [{}], local [{}]",_                            md.name(), request.metadataSnapshot().asMap().get(md.name()), md)__                    } else {_                        logger.trace("recovery [phase1]: recovering [{}], does not exist in remote", md.name())__                    }_                    phase1FileNames.add(md.name())__                    phase1FileSizes.add(md.length())__                    totalSize += md.length()__                }__                logger.trace("recovery [phase1]: recovering_files [{}] with total_size [{}], reusing_files [{}] with total_size [{}]",_                    phase1FileNames.size(), new ByteSizeValue(totalSize),_                    phase1ExistingFileNames.size(), new ByteSizeValue(existingTotalSize))__                cancellableThreads.execute(() -> recoveryTarget.receiveFileInfo(_                    phase1FileNames, phase1FileSizes, phase1ExistingFileNames, phase1ExistingFileSizes, translogOps.get()))__                sendFiles(store, phase1Files.toArray(new StoreFileMetaData[0]), translogOps)__                _                _                _                _                _                _                _                _                try {_                    cancellableThreads.executeIO(() ->_                        recoveryTarget.cleanFiles(translogOps.get(), recoverySourceMetadata))__                } catch (RemoteTransportException | IOException targetException) {_                    final IOException corruptIndexException__                    _                    _                    _                    _                    if ((corruptIndexException = ExceptionsHelper.unwrapCorruption(targetException)) != null) {_                        try {_                            final Store.MetadataSnapshot recoverySourceMetadata1 = store.getMetadata(snapshot)__                            StoreFileMetaData[] metadata =_                                    StreamSupport.stream(recoverySourceMetadata1.spliterator(), false).toArray(StoreFileMetaData[]::new)__                            ArrayUtil.timSort(metadata, Comparator.comparingLong(StoreFileMetaData::length))_ _                            for (StoreFileMetaData md : metadata) {_                                cancellableThreads.checkForCancel()__                                logger.debug("checking integrity for file {} after remove corruption exception", md)__                                if (store.checkIntegrityNoException(md) == false) { _                                    shard.failShard("recovery", corruptIndexException)__                                    logger.warn("Corrupted file detected {} checksum mismatch", md)__                                    throw corruptIndexException__                                }_                            }_                        } catch (IOException ex) {_                            targetException.addSuppressed(ex)__                            throw targetException__                        }_                        _                        RemoteTransportException exception = new RemoteTransportException("File corruption occurred on recovery but " +_                                "checksums are ok", null)__                        exception.addSuppressed(targetException)__                        logger.warn(() -> new ParameterizedMessage(_                                "{} Remote file corruption during finalization of recovery on node {}. local checksum OK",_                                shard.shardId(), request.targetNode()), corruptIndexException)__                        throw exception__                    } else {_                        throw targetException__                    }_                }_            }_            final TimeValue took = stopWatch.totalTime()__            logger.trace("recovery [phase1]: took [{}]", took)__            return new SendFileResult(phase1FileNames, phase1FileSizes, totalSize, phase1ExistingFileNames,_                phase1ExistingFileSizes, existingTotalSize, took)__        } catch (Exception e) {_            throw new RecoverFilesRecoveryException(request.shardId(), phase1FileNames.size(), new ByteSizeValue(totalSize), e)__        } finally {_            store.decRef()__        }_    };perform,phase1,of,the,recovery,operations,once,this,link,index,commit,snapshot,has,been,performed,no,commit,operations,files,being,fsync,d,are,effectively,allowed,on,this,index,until,all,recovery,phases,are,done,p,phase1,examines,the,segment,files,on,the,target,node,and,copies,over,the,segments,that,are,missing,only,segments,that,have,the,same,size,and,checksum,can,be,reused;public,send,file,result,phase1,final,index,commit,snapshot,final,supplier,integer,translog,ops,cancellable,threads,check,for,cancel,long,total,size,0,long,existing,total,size,0,final,list,string,phase1file,names,new,array,list,final,list,long,phase1file,sizes,new,array,list,final,list,string,phase1existing,file,names,new,array,list,final,list,long,phase1existing,file,sizes,new,array,list,final,store,store,shard,store,store,inc,ref,try,stop,watch,stop,watch,new,stop,watch,start,final,store,metadata,snapshot,recovery,source,metadata,try,recovery,source,metadata,store,get,metadata,snapshot,catch,corrupt,index,exception,index,format,too,old,exception,index,format,too,new,exception,ex,shard,fail,shard,recovery,ex,throw,ex,for,string,name,snapshot,get,file,names,final,store,file,meta,data,md,recovery,source,metadata,get,name,if,md,null,logger,info,snapshot,differs,from,actual,index,for,file,meta,name,recovery,source,metadata,as,map,throw,new,corrupt,index,exception,snapshot,differs,from,actual,index,maybe,index,was,removed,metadata,has,recovery,source,metadata,as,map,size,files,name,string,recovery,source,sync,id,recovery,source,metadata,get,sync,id,string,recovery,target,sync,id,request,metadata,snapshot,get,sync,id,final,boolean,recover,with,sync,id,recovery,source,sync,id,null,recovery,source,sync,id,equals,recovery,target,sync,id,if,recover,with,sync,id,final,long,num,docs,target,request,metadata,snapshot,get,num,docs,final,long,num,docs,source,recovery,source,metadata,get,num,docs,if,num,docs,target,num,docs,source,throw,new,illegal,state,exception,try,to,recover,request,shard,id,from,primary,shard,with,sync,id,but,number,of,docs,differ,num,docs,source,request,source,node,get,name,primary,vs,num,docs,target,request,target,node,get,name,logger,trace,skipping,phase1,identical,sync,id,found,on,both,source,and,target,recovery,source,sync,id,else,final,store,recovery,diff,diff,recovery,source,metadata,recovery,diff,request,metadata,snapshot,for,store,file,meta,data,md,diff,identical,phase1existing,file,names,add,md,name,phase1existing,file,sizes,add,md,length,existing,total,size,md,length,if,logger,is,trace,enabled,logger,trace,recovery,phase1,not,recovering,exist,in,local,store,and,has,checksum,size,md,name,md,checksum,md,length,total,size,md,length,list,store,file,meta,data,phase1files,new,array,list,diff,different,size,diff,missing,size,phase1files,add,all,diff,different,phase1files,add,all,diff,missing,for,store,file,meta,data,md,phase1files,if,request,metadata,snapshot,as,map,contains,key,md,name,logger,trace,recovery,phase1,recovering,exists,in,local,store,but,is,different,remote,local,md,name,request,metadata,snapshot,as,map,get,md,name,md,else,logger,trace,recovery,phase1,recovering,does,not,exist,in,remote,md,name,phase1file,names,add,md,name,phase1file,sizes,add,md,length,total,size,md,length,logger,trace,recovery,phase1,with,with,phase1file,names,size,new,byte,size,value,total,size,phase1existing,file,names,size,new,byte,size,value,existing,total,size,cancellable,threads,execute,recovery,target,receive,file,info,phase1file,names,phase1file,sizes,phase1existing,file,names,phase1existing,file,sizes,translog,ops,get,send,files,store,phase1files,to,array,new,store,file,meta,data,0,translog,ops,try,cancellable,threads,execute,io,recovery,target,clean,files,translog,ops,get,recovery,source,metadata,catch,remote,transport,exception,ioexception,target,exception,final,ioexception,corrupt,index,exception,if,corrupt,index,exception,exceptions,helper,unwrap,corruption,target,exception,null,try,final,store,metadata,snapshot,recovery,source,metadata1,store,get,metadata,snapshot,store,file,meta,data,metadata,stream,support,stream,recovery,source,metadata1,spliterator,false,to,array,store,file,meta,data,new,array,util,tim,sort,metadata,comparator,comparing,long,store,file,meta,data,length,for,store,file,meta,data,md,metadata,cancellable,threads,check,for,cancel,logger,debug,checking,integrity,for,file,after,remove,corruption,exception,md,if,store,check,integrity,no,exception,md,false,shard,fail,shard,recovery,corrupt,index,exception,logger,warn,corrupted,file,detected,checksum,mismatch,md,throw,corrupt,index,exception,catch,ioexception,ex,target,exception,add,suppressed,ex,throw,target,exception,remote,transport,exception,exception,new,remote,transport,exception,file,corruption,occurred,on,recovery,but,checksums,are,ok,null,exception,add,suppressed,target,exception,logger,warn,new,parameterized,message,remote,file,corruption,during,finalization,of,recovery,on,node,local,checksum,ok,shard,shard,id,request,target,node,corrupt,index,exception,throw,exception,else,throw,target,exception,final,time,value,took,stop,watch,total,time,logger,trace,recovery,phase1,took,took,return,new,send,file,result,phase1file,names,phase1file,sizes,total,size,phase1existing,file,names,phase1existing,file,sizes,existing,total,size,took,catch,exception,e,throw,new,recover,files,recovery,exception,request,shard,id,phase1file,names,size,new,byte,size,value,total,size,e,finally,store,dec,ref
RecoverySourceHandler -> void phase2(long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo, Translog.Snapshot snapshot, long maxSeenAutoIdTimestamp,                 long maxSeqNoOfUpdatesOrDeletes, ActionListener<SendSnapshotResult> listener) throws IOException;1547576245;Perform phase two of the recovery process._<p>_Phase two uses a snapshot of the current translog *without* acquiring the write lock (however, the translog snapshot is_point-in-time view of the translog). It then sends each translog operation to the target node so it can be replayed into the new_shard.__@param startingSeqNo              the sequence number to start recovery from, or {@link SequenceNumbers#UNASSIGNED_SEQ_NO} if all_ops should be sent_@param requiredSeqNoRangeStart    the lower sequence number of the required range (ending with endingSeqNo)_@param endingSeqNo                the highest sequence number that should be sent_@param snapshot                   a snapshot of the translog_@param maxSeenAutoIdTimestamp     the max auto_id_timestamp of append-only requests on the primary_@param maxSeqNoOfUpdatesOrDeletes the max seq_no of updates or deletes on the primary after these operations were executed on it._@param listener                   a listener which will be notified with the local checkpoint on the target.;void phase2(long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo, Translog.Snapshot snapshot, long maxSeenAutoIdTimestamp,_                long maxSeqNoOfUpdatesOrDeletes, ActionListener<SendSnapshotResult> listener) throws IOException {_        ActionListener.completeWith(listener, () -> sendSnapshotBlockingly(_            startingSeqNo, requiredSeqNoRangeStart, endingSeqNo, snapshot, maxSeenAutoIdTimestamp, maxSeqNoOfUpdatesOrDeletes))__    };perform,phase,two,of,the,recovery,process,p,phase,two,uses,a,snapshot,of,the,current,translog,without,acquiring,the,write,lock,however,the,translog,snapshot,is,point,in,time,view,of,the,translog,it,then,sends,each,translog,operation,to,the,target,node,so,it,can,be,replayed,into,the,new,shard,param,starting,seq,no,the,sequence,number,to,start,recovery,from,or,link,sequence,numbers,if,all,ops,should,be,sent,param,required,seq,no,range,start,the,lower,sequence,number,of,the,required,range,ending,with,ending,seq,no,param,ending,seq,no,the,highest,sequence,number,that,should,be,sent,param,snapshot,a,snapshot,of,the,translog,param,max,seen,auto,id,timestamp,the,max,of,append,only,requests,on,the,primary,param,max,seq,no,of,updates,or,deletes,the,max,of,updates,or,deletes,on,the,primary,after,these,operations,were,executed,on,it,param,listener,a,listener,which,will,be,notified,with,the,local,checkpoint,on,the,target;void,phase2,long,starting,seq,no,long,required,seq,no,range,start,long,ending,seq,no,translog,snapshot,snapshot,long,max,seen,auto,id,timestamp,long,max,seq,no,of,updates,or,deletes,action,listener,send,snapshot,result,listener,throws,ioexception,action,listener,complete,with,listener,send,snapshot,blockingly,starting,seq,no,required,seq,no,range,start,ending,seq,no,snapshot,max,seen,auto,id,timestamp,max,seq,no,of,updates,or,deletes
RecoverySourceHandler -> void phase2(long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo, Translog.Snapshot snapshot, long maxSeenAutoIdTimestamp,                 long maxSeqNoOfUpdatesOrDeletes, ActionListener<SendSnapshotResult> listener) throws IOException;1547737145;Perform phase two of the recovery process._<p>_Phase two uses a snapshot of the current translog *without* acquiring the write lock (however, the translog snapshot is_point-in-time view of the translog). It then sends each translog operation to the target node so it can be replayed into the new_shard.__@param startingSeqNo              the sequence number to start recovery from, or {@link SequenceNumbers#UNASSIGNED_SEQ_NO} if all_ops should be sent_@param requiredSeqNoRangeStart    the lower sequence number of the required range (ending with endingSeqNo)_@param endingSeqNo                the highest sequence number that should be sent_@param snapshot                   a snapshot of the translog_@param maxSeenAutoIdTimestamp     the max auto_id_timestamp of append-only requests on the primary_@param maxSeqNoOfUpdatesOrDeletes the max seq_no of updates or deletes on the primary after these operations were executed on it._@param listener                   a listener which will be notified with the local checkpoint on the target.;void phase2(long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo, Translog.Snapshot snapshot, long maxSeenAutoIdTimestamp,_                long maxSeqNoOfUpdatesOrDeletes, ActionListener<SendSnapshotResult> listener) throws IOException {_        assert requiredSeqNoRangeStart <= endingSeqNo + 1:_            "requiredSeqNoRangeStart " + requiredSeqNoRangeStart + " is larger than endingSeqNo " + endingSeqNo__        assert startingSeqNo <= requiredSeqNoRangeStart :_            "startingSeqNo " + startingSeqNo + " is larger than requiredSeqNoRangeStart " + requiredSeqNoRangeStart__        if (shard.state() == IndexShardState.CLOSED) {_            throw new IndexShardClosedException(request.shardId())__        }_        logger.trace("recovery [phase2]: sending transaction log operations (seq# from [" +  startingSeqNo  + "], " +_            "required [" + requiredSeqNoRangeStart + ":" + endingSeqNo + "]")___        final AtomicInteger skippedOps = new AtomicInteger()__        final AtomicInteger totalSentOps = new AtomicInteger()__        final LocalCheckpointTracker requiredOpsTracker = new LocalCheckpointTracker(endingSeqNo, requiredSeqNoRangeStart - 1)__        final AtomicInteger lastBatchCount = new AtomicInteger()_ _        final CheckedSupplier<List<Translog.Operation>, IOException> readNextBatch = () -> {_            _            _            synchronized (snapshot) {_                final List<Translog.Operation> ops = lastBatchCount.get() > 0 ? new ArrayList<>(lastBatchCount.get()) : new ArrayList<>()__                long batchSizeInBytes = 0L__                Translog.Operation operation__                while ((operation = snapshot.next()) != null) {_                    if (shard.state() == IndexShardState.CLOSED) {_                        throw new IndexShardClosedException(request.shardId())__                    }_                    cancellableThreads.checkForCancel()__                    final long seqNo = operation.seqNo()__                    if (seqNo < startingSeqNo || seqNo > endingSeqNo) {_                        skippedOps.incrementAndGet()__                        continue__                    }_                    ops.add(operation)__                    batchSizeInBytes += operation.estimateSize()__                    totalSentOps.incrementAndGet()__                    requiredOpsTracker.markSeqNoAsCompleted(seqNo)___                    _                    if (batchSizeInBytes >= chunkSizeInBytes) {_                        break__                    }_                }_                lastBatchCount.set(ops.size())__                return ops__            }_        }___        final StopWatch stopWatch = new StopWatch().start()__        final ActionListener<Long> batchedListener = ActionListener.wrap(_            targetLocalCheckpoint -> {_                assert snapshot.totalOperations() == snapshot.skippedOperations() + skippedOps.get() + totalSentOps.get()_                    : String.format(Locale.ROOT, "expected total [%d], overridden [%d], skipped [%d], total sent [%d]",_                    snapshot.totalOperations(), snapshot.skippedOperations(), skippedOps.get(), totalSentOps.get())__                if (requiredOpsTracker.getCheckpoint() < endingSeqNo) {_                    throw new IllegalStateException("translog replay failed to cover required sequence numbers" +_                        " (required range [" + requiredSeqNoRangeStart + ":" + endingSeqNo + "). first missing op is ["_                        + (requiredOpsTracker.getCheckpoint() + 1) + "]")__                }_                stopWatch.stop()__                final TimeValue tookTime = stopWatch.totalTime()__                logger.trace("recovery [phase2]: took [{}]", tookTime)__                listener.onResponse(new SendSnapshotResult(targetLocalCheckpoint, totalSentOps.get(), tookTime))__            },_            listener::onFailure_        )___        sendBatch(readNextBatch, true, SequenceNumbers.UNASSIGNED_SEQ_NO, snapshot.totalOperations(),_            maxSeenAutoIdTimestamp, maxSeqNoOfUpdatesOrDeletes, batchedListener)__    };perform,phase,two,of,the,recovery,process,p,phase,two,uses,a,snapshot,of,the,current,translog,without,acquiring,the,write,lock,however,the,translog,snapshot,is,point,in,time,view,of,the,translog,it,then,sends,each,translog,operation,to,the,target,node,so,it,can,be,replayed,into,the,new,shard,param,starting,seq,no,the,sequence,number,to,start,recovery,from,or,link,sequence,numbers,if,all,ops,should,be,sent,param,required,seq,no,range,start,the,lower,sequence,number,of,the,required,range,ending,with,ending,seq,no,param,ending,seq,no,the,highest,sequence,number,that,should,be,sent,param,snapshot,a,snapshot,of,the,translog,param,max,seen,auto,id,timestamp,the,max,of,append,only,requests,on,the,primary,param,max,seq,no,of,updates,or,deletes,the,max,of,updates,or,deletes,on,the,primary,after,these,operations,were,executed,on,it,param,listener,a,listener,which,will,be,notified,with,the,local,checkpoint,on,the,target;void,phase2,long,starting,seq,no,long,required,seq,no,range,start,long,ending,seq,no,translog,snapshot,snapshot,long,max,seen,auto,id,timestamp,long,max,seq,no,of,updates,or,deletes,action,listener,send,snapshot,result,listener,throws,ioexception,assert,required,seq,no,range,start,ending,seq,no,1,required,seq,no,range,start,required,seq,no,range,start,is,larger,than,ending,seq,no,ending,seq,no,assert,starting,seq,no,required,seq,no,range,start,starting,seq,no,starting,seq,no,is,larger,than,required,seq,no,range,start,required,seq,no,range,start,if,shard,state,index,shard,state,closed,throw,new,index,shard,closed,exception,request,shard,id,logger,trace,recovery,phase2,sending,transaction,log,operations,seq,from,starting,seq,no,required,required,seq,no,range,start,ending,seq,no,final,atomic,integer,skipped,ops,new,atomic,integer,final,atomic,integer,total,sent,ops,new,atomic,integer,final,local,checkpoint,tracker,required,ops,tracker,new,local,checkpoint,tracker,ending,seq,no,required,seq,no,range,start,1,final,atomic,integer,last,batch,count,new,atomic,integer,final,checked,supplier,list,translog,operation,ioexception,read,next,batch,synchronized,snapshot,final,list,translog,operation,ops,last,batch,count,get,0,new,array,list,last,batch,count,get,new,array,list,long,batch,size,in,bytes,0l,translog,operation,operation,while,operation,snapshot,next,null,if,shard,state,index,shard,state,closed,throw,new,index,shard,closed,exception,request,shard,id,cancellable,threads,check,for,cancel,final,long,seq,no,operation,seq,no,if,seq,no,starting,seq,no,seq,no,ending,seq,no,skipped,ops,increment,and,get,continue,ops,add,operation,batch,size,in,bytes,operation,estimate,size,total,sent,ops,increment,and,get,required,ops,tracker,mark,seq,no,as,completed,seq,no,if,batch,size,in,bytes,chunk,size,in,bytes,break,last,batch,count,set,ops,size,return,ops,final,stop,watch,stop,watch,new,stop,watch,start,final,action,listener,long,batched,listener,action,listener,wrap,target,local,checkpoint,assert,snapshot,total,operations,snapshot,skipped,operations,skipped,ops,get,total,sent,ops,get,string,format,locale,root,expected,total,d,overridden,d,skipped,d,total,sent,d,snapshot,total,operations,snapshot,skipped,operations,skipped,ops,get,total,sent,ops,get,if,required,ops,tracker,get,checkpoint,ending,seq,no,throw,new,illegal,state,exception,translog,replay,failed,to,cover,required,sequence,numbers,required,range,required,seq,no,range,start,ending,seq,no,first,missing,op,is,required,ops,tracker,get,checkpoint,1,stop,watch,stop,final,time,value,took,time,stop,watch,total,time,logger,trace,recovery,phase2,took,took,time,listener,on,response,new,send,snapshot,result,target,local,checkpoint,total,sent,ops,get,took,time,listener,on,failure,send,batch,read,next,batch,true,sequence,numbers,snapshot,total,operations,max,seen,auto,id,timestamp,max,seq,no,of,updates,or,deletes,batched,listener
RecoverySourceHandler -> void phase2(long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo, Translog.Snapshot snapshot, long maxSeenAutoIdTimestamp,                 long maxSeqNoOfUpdatesOrDeletes, ActionListener<SendSnapshotResult> listener) throws IOException;1548124510;Perform phase two of the recovery process._<p>_Phase two uses a snapshot of the current translog *without* acquiring the write lock (however, the translog snapshot is_point-in-time view of the translog). It then sends each translog operation to the target node so it can be replayed into the new_shard.__@param startingSeqNo              the sequence number to start recovery from, or {@link SequenceNumbers#UNASSIGNED_SEQ_NO} if all_ops should be sent_@param requiredSeqNoRangeStart    the lower sequence number of the required range (ending with endingSeqNo)_@param endingSeqNo                the highest sequence number that should be sent_@param snapshot                   a snapshot of the translog_@param maxSeenAutoIdTimestamp     the max auto_id_timestamp of append-only requests on the primary_@param maxSeqNoOfUpdatesOrDeletes the max seq_no of updates or deletes on the primary after these operations were executed on it._@param listener                   a listener which will be notified with the local checkpoint on the target.;void phase2(long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo, Translog.Snapshot snapshot, long maxSeenAutoIdTimestamp,_                long maxSeqNoOfUpdatesOrDeletes, ActionListener<SendSnapshotResult> listener) throws IOException {_        assert requiredSeqNoRangeStart <= endingSeqNo + 1:_            "requiredSeqNoRangeStart " + requiredSeqNoRangeStart + " is larger than endingSeqNo " + endingSeqNo__        assert startingSeqNo <= requiredSeqNoRangeStart :_            "startingSeqNo " + startingSeqNo + " is larger than requiredSeqNoRangeStart " + requiredSeqNoRangeStart__        if (shard.state() == IndexShardState.CLOSED) {_            throw new IndexShardClosedException(request.shardId())__        }_        logger.trace("recovery [phase2]: sending transaction log operations (seq# from [" +  startingSeqNo  + "], " +_            "required [" + requiredSeqNoRangeStart + ":" + endingSeqNo + "]")___        final AtomicInteger skippedOps = new AtomicInteger()__        final AtomicInteger totalSentOps = new AtomicInteger()__        final LocalCheckpointTracker requiredOpsTracker = new LocalCheckpointTracker(endingSeqNo, requiredSeqNoRangeStart - 1)__        final AtomicInteger lastBatchCount = new AtomicInteger()_ _        final CheckedSupplier<List<Translog.Operation>, IOException> readNextBatch = () -> {_            _            _            synchronized (snapshot) {_                final List<Translog.Operation> ops = lastBatchCount.get() > 0 ? new ArrayList<>(lastBatchCount.get()) : new ArrayList<>()__                long batchSizeInBytes = 0L__                Translog.Operation operation__                while ((operation = snapshot.next()) != null) {_                    if (shard.state() == IndexShardState.CLOSED) {_                        throw new IndexShardClosedException(request.shardId())__                    }_                    cancellableThreads.checkForCancel()__                    final long seqNo = operation.seqNo()__                    if (seqNo < startingSeqNo || seqNo > endingSeqNo) {_                        skippedOps.incrementAndGet()__                        continue__                    }_                    ops.add(operation)__                    batchSizeInBytes += operation.estimateSize()__                    totalSentOps.incrementAndGet()__                    requiredOpsTracker.markSeqNoAsCompleted(seqNo)___                    _                    if (batchSizeInBytes >= chunkSizeInBytes) {_                        break__                    }_                }_                lastBatchCount.set(ops.size())__                return ops__            }_        }___        final StopWatch stopWatch = new StopWatch().start()__        final ActionListener<Long> batchedListener = ActionListener.wrap(_            targetLocalCheckpoint -> {_                assert snapshot.totalOperations() == snapshot.skippedOperations() + skippedOps.get() + totalSentOps.get()_                    : String.format(Locale.ROOT, "expected total [%d], overridden [%d], skipped [%d], total sent [%d]",_                    snapshot.totalOperations(), snapshot.skippedOperations(), skippedOps.get(), totalSentOps.get())__                if (requiredOpsTracker.getCheckpoint() < endingSeqNo) {_                    throw new IllegalStateException("translog replay failed to cover required sequence numbers" +_                        " (required range [" + requiredSeqNoRangeStart + ":" + endingSeqNo + "). first missing op is ["_                        + (requiredOpsTracker.getCheckpoint() + 1) + "]")__                }_                stopWatch.stop()__                final TimeValue tookTime = stopWatch.totalTime()__                logger.trace("recovery [phase2]: took [{}]", tookTime)__                listener.onResponse(new SendSnapshotResult(targetLocalCheckpoint, totalSentOps.get(), tookTime))__            },_            listener::onFailure_        )___        sendBatch(readNextBatch, true, SequenceNumbers.UNASSIGNED_SEQ_NO, snapshot.totalOperations(),_            maxSeenAutoIdTimestamp, maxSeqNoOfUpdatesOrDeletes, batchedListener)__    };perform,phase,two,of,the,recovery,process,p,phase,two,uses,a,snapshot,of,the,current,translog,without,acquiring,the,write,lock,however,the,translog,snapshot,is,point,in,time,view,of,the,translog,it,then,sends,each,translog,operation,to,the,target,node,so,it,can,be,replayed,into,the,new,shard,param,starting,seq,no,the,sequence,number,to,start,recovery,from,or,link,sequence,numbers,if,all,ops,should,be,sent,param,required,seq,no,range,start,the,lower,sequence,number,of,the,required,range,ending,with,ending,seq,no,param,ending,seq,no,the,highest,sequence,number,that,should,be,sent,param,snapshot,a,snapshot,of,the,translog,param,max,seen,auto,id,timestamp,the,max,of,append,only,requests,on,the,primary,param,max,seq,no,of,updates,or,deletes,the,max,of,updates,or,deletes,on,the,primary,after,these,operations,were,executed,on,it,param,listener,a,listener,which,will,be,notified,with,the,local,checkpoint,on,the,target;void,phase2,long,starting,seq,no,long,required,seq,no,range,start,long,ending,seq,no,translog,snapshot,snapshot,long,max,seen,auto,id,timestamp,long,max,seq,no,of,updates,or,deletes,action,listener,send,snapshot,result,listener,throws,ioexception,assert,required,seq,no,range,start,ending,seq,no,1,required,seq,no,range,start,required,seq,no,range,start,is,larger,than,ending,seq,no,ending,seq,no,assert,starting,seq,no,required,seq,no,range,start,starting,seq,no,starting,seq,no,is,larger,than,required,seq,no,range,start,required,seq,no,range,start,if,shard,state,index,shard,state,closed,throw,new,index,shard,closed,exception,request,shard,id,logger,trace,recovery,phase2,sending,transaction,log,operations,seq,from,starting,seq,no,required,required,seq,no,range,start,ending,seq,no,final,atomic,integer,skipped,ops,new,atomic,integer,final,atomic,integer,total,sent,ops,new,atomic,integer,final,local,checkpoint,tracker,required,ops,tracker,new,local,checkpoint,tracker,ending,seq,no,required,seq,no,range,start,1,final,atomic,integer,last,batch,count,new,atomic,integer,final,checked,supplier,list,translog,operation,ioexception,read,next,batch,synchronized,snapshot,final,list,translog,operation,ops,last,batch,count,get,0,new,array,list,last,batch,count,get,new,array,list,long,batch,size,in,bytes,0l,translog,operation,operation,while,operation,snapshot,next,null,if,shard,state,index,shard,state,closed,throw,new,index,shard,closed,exception,request,shard,id,cancellable,threads,check,for,cancel,final,long,seq,no,operation,seq,no,if,seq,no,starting,seq,no,seq,no,ending,seq,no,skipped,ops,increment,and,get,continue,ops,add,operation,batch,size,in,bytes,operation,estimate,size,total,sent,ops,increment,and,get,required,ops,tracker,mark,seq,no,as,completed,seq,no,if,batch,size,in,bytes,chunk,size,in,bytes,break,last,batch,count,set,ops,size,return,ops,final,stop,watch,stop,watch,new,stop,watch,start,final,action,listener,long,batched,listener,action,listener,wrap,target,local,checkpoint,assert,snapshot,total,operations,snapshot,skipped,operations,skipped,ops,get,total,sent,ops,get,string,format,locale,root,expected,total,d,overridden,d,skipped,d,total,sent,d,snapshot,total,operations,snapshot,skipped,operations,skipped,ops,get,total,sent,ops,get,if,required,ops,tracker,get,checkpoint,ending,seq,no,throw,new,illegal,state,exception,translog,replay,failed,to,cover,required,sequence,numbers,required,range,required,seq,no,range,start,ending,seq,no,first,missing,op,is,required,ops,tracker,get,checkpoint,1,stop,watch,stop,final,time,value,took,time,stop,watch,total,time,logger,trace,recovery,phase2,took,took,time,listener,on,response,new,send,snapshot,result,target,local,checkpoint,total,sent,ops,get,took,time,listener,on,failure,send,batch,read,next,batch,true,sequence,numbers,snapshot,total,operations,max,seen,auto,id,timestamp,max,seq,no,of,updates,or,deletes,batched,listener
RecoverySourceHandler -> boolean isTranslogReadyForSequenceNumberBasedRecovery() throws IOException;1524684173;Determines if the source translog is ready for a sequence-number-based peer recovery. The main condition here is that the source_translog contains all operations above the local checkpoint on the target. We already know the that translog contains or will contain_all ops above the source local checkpoint, so we can stop check there.__@return {@code true} if the source is ready for a sequence-number-based recovery_@throws IOException if an I/O exception occurred reading the translog snapshot;boolean isTranslogReadyForSequenceNumberBasedRecovery() throws IOException {_        final long startingSeqNo = request.startingSeqNo()__        assert startingSeqNo >= 0__        final long localCheckpoint = shard.getLocalCheckpoint()__        logger.trace("testing sequence numbers in range: [{}, {}]", startingSeqNo, localCheckpoint)__        _        if (startingSeqNo - 1 <= localCheckpoint) {_            final LocalCheckpointTracker tracker = new LocalCheckpointTracker(startingSeqNo, startingSeqNo - 1)__            try (Translog.Snapshot snapshot = shard.newTranslogSnapshotFromMinSeqNo(startingSeqNo)) {_                Translog.Operation operation__                while ((operation = snapshot.next()) != null) {_                    if (operation.seqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO) {_                        tracker.markSeqNoAsCompleted(operation.seqNo())__                    }_                }_            }_            return tracker.getCheckpoint() >= localCheckpoint__        } else {_            return false__        }_    };determines,if,the,source,translog,is,ready,for,a,sequence,number,based,peer,recovery,the,main,condition,here,is,that,the,source,translog,contains,all,operations,above,the,local,checkpoint,on,the,target,we,already,know,the,that,translog,contains,or,will,contain,all,ops,above,the,source,local,checkpoint,so,we,can,stop,check,there,return,code,true,if,the,source,is,ready,for,a,sequence,number,based,recovery,throws,ioexception,if,an,i,o,exception,occurred,reading,the,translog,snapshot;boolean,is,translog,ready,for,sequence,number,based,recovery,throws,ioexception,final,long,starting,seq,no,request,starting,seq,no,assert,starting,seq,no,0,final,long,local,checkpoint,shard,get,local,checkpoint,logger,trace,testing,sequence,numbers,in,range,starting,seq,no,local,checkpoint,if,starting,seq,no,1,local,checkpoint,final,local,checkpoint,tracker,tracker,new,local,checkpoint,tracker,starting,seq,no,starting,seq,no,1,try,translog,snapshot,snapshot,shard,new,translog,snapshot,from,min,seq,no,starting,seq,no,translog,operation,operation,while,operation,snapshot,next,null,if,operation,seq,no,sequence,numbers,tracker,mark,seq,no,as,completed,operation,seq,no,return,tracker,get,checkpoint,local,checkpoint,else,return,false
RecoverySourceHandler -> boolean isTranslogReadyForSequenceNumberBasedRecovery() throws IOException;1525334055;Determines if the source translog is ready for a sequence-number-based peer recovery. The main condition here is that the source_translog contains all operations above the local checkpoint on the target. We already know the that translog contains or will contain_all ops above the source local checkpoint, so we can stop check there.__@return {@code true} if the source is ready for a sequence-number-based recovery_@throws IOException if an I/O exception occurred reading the translog snapshot;boolean isTranslogReadyForSequenceNumberBasedRecovery() throws IOException {_        final long startingSeqNo = request.startingSeqNo()__        assert startingSeqNo >= 0__        final long localCheckpoint = shard.getLocalCheckpoint()__        logger.trace("testing sequence numbers in range: [{}, {}]", startingSeqNo, localCheckpoint)__        _        if (startingSeqNo - 1 <= localCheckpoint) {_            final LocalCheckpointTracker tracker = new LocalCheckpointTracker(startingSeqNo, startingSeqNo - 1)__            try (Translog.Snapshot snapshot = shard.newTranslogSnapshotFromMinSeqNo(startingSeqNo)) {_                Translog.Operation operation__                while ((operation = snapshot.next()) != null) {_                    if (operation.seqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO) {_                        tracker.markSeqNoAsCompleted(operation.seqNo())__                    }_                }_            }_            return tracker.getCheckpoint() >= localCheckpoint__        } else {_            return false__        }_    };determines,if,the,source,translog,is,ready,for,a,sequence,number,based,peer,recovery,the,main,condition,here,is,that,the,source,translog,contains,all,operations,above,the,local,checkpoint,on,the,target,we,already,know,the,that,translog,contains,or,will,contain,all,ops,above,the,source,local,checkpoint,so,we,can,stop,check,there,return,code,true,if,the,source,is,ready,for,a,sequence,number,based,recovery,throws,ioexception,if,an,i,o,exception,occurred,reading,the,translog,snapshot;boolean,is,translog,ready,for,sequence,number,based,recovery,throws,ioexception,final,long,starting,seq,no,request,starting,seq,no,assert,starting,seq,no,0,final,long,local,checkpoint,shard,get,local,checkpoint,logger,trace,testing,sequence,numbers,in,range,starting,seq,no,local,checkpoint,if,starting,seq,no,1,local,checkpoint,final,local,checkpoint,tracker,tracker,new,local,checkpoint,tracker,starting,seq,no,starting,seq,no,1,try,translog,snapshot,snapshot,shard,new,translog,snapshot,from,min,seq,no,starting,seq,no,translog,operation,operation,while,operation,snapshot,next,null,if,operation,seq,no,sequence,numbers,tracker,mark,seq,no,as,completed,operation,seq,no,return,tracker,get,checkpoint,local,checkpoint,else,return,false
RecoverySourceHandler -> boolean isTranslogReadyForSequenceNumberBasedRecovery() throws IOException;1528706846;Determines if the source translog is ready for a sequence-number-based peer recovery. The main condition here is that the source_translog contains all operations above the local checkpoint on the target. We already know the that translog contains or will contain_all ops above the source local checkpoint, so we can stop check there.__@return {@code true} if the source is ready for a sequence-number-based recovery_@throws IOException if an I/O exception occurred reading the translog snapshot;boolean isTranslogReadyForSequenceNumberBasedRecovery() throws IOException {_        final long startingSeqNo = request.startingSeqNo()__        assert startingSeqNo >= 0__        final long localCheckpoint = shard.getLocalCheckpoint()__        logger.trace("testing sequence numbers in range: [{}, {}]", startingSeqNo, localCheckpoint)__        _        if (startingSeqNo - 1 <= localCheckpoint) {_            final LocalCheckpointTracker tracker = new LocalCheckpointTracker(startingSeqNo, startingSeqNo - 1)__            try (Translog.Snapshot snapshot = shard.newTranslogSnapshotFromMinSeqNo(startingSeqNo)) {_                Translog.Operation operation__                while ((operation = snapshot.next()) != null) {_                    if (operation.seqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO) {_                        tracker.markSeqNoAsCompleted(operation.seqNo())__                    }_                }_            }_            return tracker.getCheckpoint() >= localCheckpoint__        } else {_            return false__        }_    };determines,if,the,source,translog,is,ready,for,a,sequence,number,based,peer,recovery,the,main,condition,here,is,that,the,source,translog,contains,all,operations,above,the,local,checkpoint,on,the,target,we,already,know,the,that,translog,contains,or,will,contain,all,ops,above,the,source,local,checkpoint,so,we,can,stop,check,there,return,code,true,if,the,source,is,ready,for,a,sequence,number,based,recovery,throws,ioexception,if,an,i,o,exception,occurred,reading,the,translog,snapshot;boolean,is,translog,ready,for,sequence,number,based,recovery,throws,ioexception,final,long,starting,seq,no,request,starting,seq,no,assert,starting,seq,no,0,final,long,local,checkpoint,shard,get,local,checkpoint,logger,trace,testing,sequence,numbers,in,range,starting,seq,no,local,checkpoint,if,starting,seq,no,1,local,checkpoint,final,local,checkpoint,tracker,tracker,new,local,checkpoint,tracker,starting,seq,no,starting,seq,no,1,try,translog,snapshot,snapshot,shard,new,translog,snapshot,from,min,seq,no,starting,seq,no,translog,operation,operation,while,operation,snapshot,next,null,if,operation,seq,no,sequence,numbers,tracker,mark,seq,no,as,completed,operation,seq,no,return,tracker,get,checkpoint,local,checkpoint,else,return,false
RecoverySourceHandler -> boolean isTranslogReadyForSequenceNumberBasedRecovery() throws IOException;1529658035;Determines if the source translog is ready for a sequence-number-based peer recovery. The main condition here is that the source_translog contains all operations above the local checkpoint on the target. We already know the that translog contains or will contain_all ops above the source local checkpoint, so we can stop check there.__@return {@code true} if the source is ready for a sequence-number-based recovery_@throws IOException if an I/O exception occurred reading the translog snapshot;boolean isTranslogReadyForSequenceNumberBasedRecovery() throws IOException {_        final long startingSeqNo = request.startingSeqNo()__        assert startingSeqNo >= 0__        final long localCheckpoint = shard.getLocalCheckpoint()__        logger.trace("testing sequence numbers in range: [{}, {}]", startingSeqNo, localCheckpoint)__        _        if (startingSeqNo - 1 <= localCheckpoint) {_            final LocalCheckpointTracker tracker = new LocalCheckpointTracker(startingSeqNo, startingSeqNo - 1)__            try (Translog.Snapshot snapshot = shard.newTranslogSnapshotFromMinSeqNo(startingSeqNo)) {_                Translog.Operation operation__                while ((operation = snapshot.next()) != null) {_                    if (operation.seqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO) {_                        tracker.markSeqNoAsCompleted(operation.seqNo())__                    }_                }_            }_            return tracker.getCheckpoint() >= localCheckpoint__        } else {_            return false__        }_    };determines,if,the,source,translog,is,ready,for,a,sequence,number,based,peer,recovery,the,main,condition,here,is,that,the,source,translog,contains,all,operations,above,the,local,checkpoint,on,the,target,we,already,know,the,that,translog,contains,or,will,contain,all,ops,above,the,source,local,checkpoint,so,we,can,stop,check,there,return,code,true,if,the,source,is,ready,for,a,sequence,number,based,recovery,throws,ioexception,if,an,i,o,exception,occurred,reading,the,translog,snapshot;boolean,is,translog,ready,for,sequence,number,based,recovery,throws,ioexception,final,long,starting,seq,no,request,starting,seq,no,assert,starting,seq,no,0,final,long,local,checkpoint,shard,get,local,checkpoint,logger,trace,testing,sequence,numbers,in,range,starting,seq,no,local,checkpoint,if,starting,seq,no,1,local,checkpoint,final,local,checkpoint,tracker,tracker,new,local,checkpoint,tracker,starting,seq,no,starting,seq,no,1,try,translog,snapshot,snapshot,shard,new,translog,snapshot,from,min,seq,no,starting,seq,no,translog,operation,operation,while,operation,snapshot,next,null,if,operation,seq,no,sequence,numbers,tracker,mark,seq,no,as,completed,operation,seq,no,return,tracker,get,checkpoint,local,checkpoint,else,return,false
RecoverySourceHandler -> boolean isTranslogReadyForSequenceNumberBasedRecovery() throws IOException;1533295538;Determines if the source translog is ready for a sequence-number-based peer recovery. The main condition here is that the source_translog contains all operations above the local checkpoint on the target. We already know the that translog contains or will contain_all ops above the source local checkpoint, so we can stop check there.__@return {@code true} if the source is ready for a sequence-number-based recovery_@throws IOException if an I/O exception occurred reading the translog snapshot;boolean isTranslogReadyForSequenceNumberBasedRecovery() throws IOException {_        final long startingSeqNo = request.startingSeqNo()__        assert startingSeqNo >= 0__        final long localCheckpoint = shard.getLocalCheckpoint()__        logger.trace("testing sequence numbers in range: [{}, {}]", startingSeqNo, localCheckpoint)__        _        if (startingSeqNo - 1 <= localCheckpoint) {_            final LocalCheckpointTracker tracker = new LocalCheckpointTracker(startingSeqNo, startingSeqNo - 1)__            try (Translog.Snapshot snapshot = shard.newTranslogSnapshotFromMinSeqNo(startingSeqNo)) {_                Translog.Operation operation__                while ((operation = snapshot.next()) != null) {_                    if (operation.seqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO) {_                        tracker.markSeqNoAsCompleted(operation.seqNo())__                    }_                }_            }_            return tracker.getCheckpoint() >= localCheckpoint__        } else {_            return false__        }_    };determines,if,the,source,translog,is,ready,for,a,sequence,number,based,peer,recovery,the,main,condition,here,is,that,the,source,translog,contains,all,operations,above,the,local,checkpoint,on,the,target,we,already,know,the,that,translog,contains,or,will,contain,all,ops,above,the,source,local,checkpoint,so,we,can,stop,check,there,return,code,true,if,the,source,is,ready,for,a,sequence,number,based,recovery,throws,ioexception,if,an,i,o,exception,occurred,reading,the,translog,snapshot;boolean,is,translog,ready,for,sequence,number,based,recovery,throws,ioexception,final,long,starting,seq,no,request,starting,seq,no,assert,starting,seq,no,0,final,long,local,checkpoint,shard,get,local,checkpoint,logger,trace,testing,sequence,numbers,in,range,starting,seq,no,local,checkpoint,if,starting,seq,no,1,local,checkpoint,final,local,checkpoint,tracker,tracker,new,local,checkpoint,tracker,starting,seq,no,starting,seq,no,1,try,translog,snapshot,snapshot,shard,new,translog,snapshot,from,min,seq,no,starting,seq,no,translog,operation,operation,while,operation,snapshot,next,null,if,operation,seq,no,sequence,numbers,tracker,mark,seq,no,as,completed,operation,seq,no,return,tracker,get,checkpoint,local,checkpoint,else,return,false
RecoverySourceHandler -> protected SendSnapshotResult sendSnapshot(final long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo,                                               final Translog.Snapshot snapshot) throws IOException;1524684173;Send the given snapshot's operations with a sequence number greater than the specified staring sequence number to this handler's_target node._<p>_Operations are bulked into a single request depending on an operation count limit or size-in-bytes limit.__@param startingSeqNo           the sequence number for which only operations with a sequence number greater than this will be sent_@param requiredSeqNoRangeStart the lower sequence number of the required range_@param endingSeqNo             the upper bound of the sequence number range to be sent (inclusive)_@param snapshot                the translog snapshot to replay operations from  @return the local checkpoint on the target and the_total number of operations sent_@throws IOException if an I/O exception occurred reading the translog snapshot;protected SendSnapshotResult sendSnapshot(final long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo,_                                              final Translog.Snapshot snapshot) throws IOException {_        assert requiredSeqNoRangeStart <= endingSeqNo + 1:_            "requiredSeqNoRangeStart " + requiredSeqNoRangeStart + " is larger than endingSeqNo " + endingSeqNo__        assert startingSeqNo <= requiredSeqNoRangeStart :_            "startingSeqNo " + startingSeqNo + " is larger than requiredSeqNoRangeStart " + requiredSeqNoRangeStart__        int ops = 0__        long size = 0__        int skippedOps = 0__        int totalSentOps = 0__        final AtomicLong targetLocalCheckpoint = new AtomicLong(SequenceNumbers.UNASSIGNED_SEQ_NO)__        final List<Translog.Operation> operations = new ArrayList<>()__        final LocalCheckpointTracker requiredOpsTracker = new LocalCheckpointTracker(endingSeqNo, requiredSeqNoRangeStart - 1)___        final int expectedTotalOps = snapshot.totalOperations()__        if (expectedTotalOps == 0) {_            logger.trace("no translog operations to send")__        }__        final CancellableThreads.IOInterruptable sendBatch =_                () -> targetLocalCheckpoint.set(recoveryTarget.indexTranslogOperations(operations, expectedTotalOps))___        _        Translog.Operation operation__        while ((operation = snapshot.next()) != null) {_            if (shard.state() == IndexShardState.CLOSED) {_                throw new IndexShardClosedException(request.shardId())__            }_            cancellableThreads.checkForCancel()___            final long seqNo = operation.seqNo()__            if (seqNo < startingSeqNo || seqNo > endingSeqNo) {_                skippedOps++__                continue__            }_            operations.add(operation)__            ops++__            size += operation.estimateSize()__            totalSentOps++__            requiredOpsTracker.markSeqNoAsCompleted(seqNo)___            _            if (size >= chunkSizeInBytes) {_                cancellableThreads.executeIO(sendBatch)__                logger.trace("sent batch of [{}][{}] (total: [{}]) translog operations", ops, new ByteSizeValue(size), expectedTotalOps)__                ops = 0__                size = 0__                operations.clear()__            }_        }__        if (!operations.isEmpty() || totalSentOps == 0) {_            _            cancellableThreads.executeIO(sendBatch)__        }__        assert expectedTotalOps == snapshot.overriddenOperations() + skippedOps + totalSentOps_            : String.format(Locale.ROOT, "expected total [%d], overridden [%d], skipped [%d], total sent [%d]",_            expectedTotalOps, snapshot.overriddenOperations(), skippedOps, totalSentOps)___        if (requiredOpsTracker.getCheckpoint() < endingSeqNo) {_            throw new IllegalStateException("translog replay failed to cover required sequence numbers" +_                " (required range [" + requiredSeqNoRangeStart + ":" + endingSeqNo + "). first missing op is ["_                + (requiredOpsTracker.getCheckpoint() + 1) + "]")__        }__        logger.trace("sent final batch of [{}][{}] (total: [{}]) translog operations", ops, new ByteSizeValue(size), expectedTotalOps)___        return new SendSnapshotResult(targetLocalCheckpoint.get(), totalSentOps)__    };send,the,given,snapshot,s,operations,with,a,sequence,number,greater,than,the,specified,staring,sequence,number,to,this,handler,s,target,node,p,operations,are,bulked,into,a,single,request,depending,on,an,operation,count,limit,or,size,in,bytes,limit,param,starting,seq,no,the,sequence,number,for,which,only,operations,with,a,sequence,number,greater,than,this,will,be,sent,param,required,seq,no,range,start,the,lower,sequence,number,of,the,required,range,param,ending,seq,no,the,upper,bound,of,the,sequence,number,range,to,be,sent,inclusive,param,snapshot,the,translog,snapshot,to,replay,operations,from,return,the,local,checkpoint,on,the,target,and,the,total,number,of,operations,sent,throws,ioexception,if,an,i,o,exception,occurred,reading,the,translog,snapshot;protected,send,snapshot,result,send,snapshot,final,long,starting,seq,no,long,required,seq,no,range,start,long,ending,seq,no,final,translog,snapshot,snapshot,throws,ioexception,assert,required,seq,no,range,start,ending,seq,no,1,required,seq,no,range,start,required,seq,no,range,start,is,larger,than,ending,seq,no,ending,seq,no,assert,starting,seq,no,required,seq,no,range,start,starting,seq,no,starting,seq,no,is,larger,than,required,seq,no,range,start,required,seq,no,range,start,int,ops,0,long,size,0,int,skipped,ops,0,int,total,sent,ops,0,final,atomic,long,target,local,checkpoint,new,atomic,long,sequence,numbers,final,list,translog,operation,operations,new,array,list,final,local,checkpoint,tracker,required,ops,tracker,new,local,checkpoint,tracker,ending,seq,no,required,seq,no,range,start,1,final,int,expected,total,ops,snapshot,total,operations,if,expected,total,ops,0,logger,trace,no,translog,operations,to,send,final,cancellable,threads,iointerruptable,send,batch,target,local,checkpoint,set,recovery,target,index,translog,operations,operations,expected,total,ops,translog,operation,operation,while,operation,snapshot,next,null,if,shard,state,index,shard,state,closed,throw,new,index,shard,closed,exception,request,shard,id,cancellable,threads,check,for,cancel,final,long,seq,no,operation,seq,no,if,seq,no,starting,seq,no,seq,no,ending,seq,no,skipped,ops,continue,operations,add,operation,ops,size,operation,estimate,size,total,sent,ops,required,ops,tracker,mark,seq,no,as,completed,seq,no,if,size,chunk,size,in,bytes,cancellable,threads,execute,io,send,batch,logger,trace,sent,batch,of,total,translog,operations,ops,new,byte,size,value,size,expected,total,ops,ops,0,size,0,operations,clear,if,operations,is,empty,total,sent,ops,0,cancellable,threads,execute,io,send,batch,assert,expected,total,ops,snapshot,overridden,operations,skipped,ops,total,sent,ops,string,format,locale,root,expected,total,d,overridden,d,skipped,d,total,sent,d,expected,total,ops,snapshot,overridden,operations,skipped,ops,total,sent,ops,if,required,ops,tracker,get,checkpoint,ending,seq,no,throw,new,illegal,state,exception,translog,replay,failed,to,cover,required,sequence,numbers,required,range,required,seq,no,range,start,ending,seq,no,first,missing,op,is,required,ops,tracker,get,checkpoint,1,logger,trace,sent,final,batch,of,total,translog,operations,ops,new,byte,size,value,size,expected,total,ops,return,new,send,snapshot,result,target,local,checkpoint,get,total,sent,ops
RecoverySourceHandler -> protected SendSnapshotResult sendSnapshot(final long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo,                                               final Translog.Snapshot snapshot) throws IOException;1525334055;Send the given snapshot's operations with a sequence number greater than the specified staring sequence number to this handler's_target node._<p>_Operations are bulked into a single request depending on an operation count limit or size-in-bytes limit.__@param startingSeqNo           the sequence number for which only operations with a sequence number greater than this will be sent_@param requiredSeqNoRangeStart the lower sequence number of the required range_@param endingSeqNo             the upper bound of the sequence number range to be sent (inclusive)_@param snapshot                the translog snapshot to replay operations from  @return the local checkpoint on the target and the_total number of operations sent_@throws IOException if an I/O exception occurred reading the translog snapshot;protected SendSnapshotResult sendSnapshot(final long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo,_                                              final Translog.Snapshot snapshot) throws IOException {_        assert requiredSeqNoRangeStart <= endingSeqNo + 1:_            "requiredSeqNoRangeStart " + requiredSeqNoRangeStart + " is larger than endingSeqNo " + endingSeqNo__        assert startingSeqNo <= requiredSeqNoRangeStart :_            "startingSeqNo " + startingSeqNo + " is larger than requiredSeqNoRangeStart " + requiredSeqNoRangeStart__        int ops = 0__        long size = 0__        int skippedOps = 0__        int totalSentOps = 0__        final AtomicLong targetLocalCheckpoint = new AtomicLong(SequenceNumbers.UNASSIGNED_SEQ_NO)__        final List<Translog.Operation> operations = new ArrayList<>()__        final LocalCheckpointTracker requiredOpsTracker = new LocalCheckpointTracker(endingSeqNo, requiredSeqNoRangeStart - 1)___        final int expectedTotalOps = snapshot.totalOperations()__        if (expectedTotalOps == 0) {_            logger.trace("no translog operations to send")__        }__        final CancellableThreads.IOInterruptable sendBatch =_                () -> targetLocalCheckpoint.set(recoveryTarget.indexTranslogOperations(operations, expectedTotalOps))___        _        Translog.Operation operation__        while ((operation = snapshot.next()) != null) {_            if (shard.state() == IndexShardState.CLOSED) {_                throw new IndexShardClosedException(request.shardId())__            }_            cancellableThreads.checkForCancel()___            final long seqNo = operation.seqNo()__            if (seqNo < startingSeqNo || seqNo > endingSeqNo) {_                skippedOps++__                continue__            }_            operations.add(operation)__            ops++__            size += operation.estimateSize()__            totalSentOps++__            requiredOpsTracker.markSeqNoAsCompleted(seqNo)___            _            if (size >= chunkSizeInBytes) {_                cancellableThreads.executeIO(sendBatch)__                logger.trace("sent batch of [{}][{}] (total: [{}]) translog operations", ops, new ByteSizeValue(size), expectedTotalOps)__                ops = 0__                size = 0__                operations.clear()__            }_        }__        if (!operations.isEmpty() || totalSentOps == 0) {_            _            cancellableThreads.executeIO(sendBatch)__        }__        assert expectedTotalOps == snapshot.overriddenOperations() + skippedOps + totalSentOps_            : String.format(Locale.ROOT, "expected total [%d], overridden [%d], skipped [%d], total sent [%d]",_            expectedTotalOps, snapshot.overriddenOperations(), skippedOps, totalSentOps)___        if (requiredOpsTracker.getCheckpoint() < endingSeqNo) {_            throw new IllegalStateException("translog replay failed to cover required sequence numbers" +_                " (required range [" + requiredSeqNoRangeStart + ":" + endingSeqNo + "). first missing op is ["_                + (requiredOpsTracker.getCheckpoint() + 1) + "]")__        }__        logger.trace("sent final batch of [{}][{}] (total: [{}]) translog operations", ops, new ByteSizeValue(size), expectedTotalOps)___        return new SendSnapshotResult(targetLocalCheckpoint.get(), totalSentOps)__    };send,the,given,snapshot,s,operations,with,a,sequence,number,greater,than,the,specified,staring,sequence,number,to,this,handler,s,target,node,p,operations,are,bulked,into,a,single,request,depending,on,an,operation,count,limit,or,size,in,bytes,limit,param,starting,seq,no,the,sequence,number,for,which,only,operations,with,a,sequence,number,greater,than,this,will,be,sent,param,required,seq,no,range,start,the,lower,sequence,number,of,the,required,range,param,ending,seq,no,the,upper,bound,of,the,sequence,number,range,to,be,sent,inclusive,param,snapshot,the,translog,snapshot,to,replay,operations,from,return,the,local,checkpoint,on,the,target,and,the,total,number,of,operations,sent,throws,ioexception,if,an,i,o,exception,occurred,reading,the,translog,snapshot;protected,send,snapshot,result,send,snapshot,final,long,starting,seq,no,long,required,seq,no,range,start,long,ending,seq,no,final,translog,snapshot,snapshot,throws,ioexception,assert,required,seq,no,range,start,ending,seq,no,1,required,seq,no,range,start,required,seq,no,range,start,is,larger,than,ending,seq,no,ending,seq,no,assert,starting,seq,no,required,seq,no,range,start,starting,seq,no,starting,seq,no,is,larger,than,required,seq,no,range,start,required,seq,no,range,start,int,ops,0,long,size,0,int,skipped,ops,0,int,total,sent,ops,0,final,atomic,long,target,local,checkpoint,new,atomic,long,sequence,numbers,final,list,translog,operation,operations,new,array,list,final,local,checkpoint,tracker,required,ops,tracker,new,local,checkpoint,tracker,ending,seq,no,required,seq,no,range,start,1,final,int,expected,total,ops,snapshot,total,operations,if,expected,total,ops,0,logger,trace,no,translog,operations,to,send,final,cancellable,threads,iointerruptable,send,batch,target,local,checkpoint,set,recovery,target,index,translog,operations,operations,expected,total,ops,translog,operation,operation,while,operation,snapshot,next,null,if,shard,state,index,shard,state,closed,throw,new,index,shard,closed,exception,request,shard,id,cancellable,threads,check,for,cancel,final,long,seq,no,operation,seq,no,if,seq,no,starting,seq,no,seq,no,ending,seq,no,skipped,ops,continue,operations,add,operation,ops,size,operation,estimate,size,total,sent,ops,required,ops,tracker,mark,seq,no,as,completed,seq,no,if,size,chunk,size,in,bytes,cancellable,threads,execute,io,send,batch,logger,trace,sent,batch,of,total,translog,operations,ops,new,byte,size,value,size,expected,total,ops,ops,0,size,0,operations,clear,if,operations,is,empty,total,sent,ops,0,cancellable,threads,execute,io,send,batch,assert,expected,total,ops,snapshot,overridden,operations,skipped,ops,total,sent,ops,string,format,locale,root,expected,total,d,overridden,d,skipped,d,total,sent,d,expected,total,ops,snapshot,overridden,operations,skipped,ops,total,sent,ops,if,required,ops,tracker,get,checkpoint,ending,seq,no,throw,new,illegal,state,exception,translog,replay,failed,to,cover,required,sequence,numbers,required,range,required,seq,no,range,start,ending,seq,no,first,missing,op,is,required,ops,tracker,get,checkpoint,1,logger,trace,sent,final,batch,of,total,translog,operations,ops,new,byte,size,value,size,expected,total,ops,return,new,send,snapshot,result,target,local,checkpoint,get,total,sent,ops
RecoverySourceHandler -> protected SendSnapshotResult sendSnapshot(final long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo,                                               final Translog.Snapshot snapshot) throws IOException;1528706846;Send the given snapshot's operations with a sequence number greater than the specified staring sequence number to this handler's_target node._<p>_Operations are bulked into a single request depending on an operation count limit or size-in-bytes limit.__@param startingSeqNo           the sequence number for which only operations with a sequence number greater than this will be sent_@param requiredSeqNoRangeStart the lower sequence number of the required range_@param endingSeqNo             the upper bound of the sequence number range to be sent (inclusive)_@param snapshot                the translog snapshot to replay operations from  @return the local checkpoint on the target and the_total number of operations sent_@throws IOException if an I/O exception occurred reading the translog snapshot;protected SendSnapshotResult sendSnapshot(final long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo,_                                              final Translog.Snapshot snapshot) throws IOException {_        assert requiredSeqNoRangeStart <= endingSeqNo + 1:_            "requiredSeqNoRangeStart " + requiredSeqNoRangeStart + " is larger than endingSeqNo " + endingSeqNo__        assert startingSeqNo <= requiredSeqNoRangeStart :_            "startingSeqNo " + startingSeqNo + " is larger than requiredSeqNoRangeStart " + requiredSeqNoRangeStart__        int ops = 0__        long size = 0__        int skippedOps = 0__        int totalSentOps = 0__        final AtomicLong targetLocalCheckpoint = new AtomicLong(SequenceNumbers.UNASSIGNED_SEQ_NO)__        final List<Translog.Operation> operations = new ArrayList<>()__        final LocalCheckpointTracker requiredOpsTracker = new LocalCheckpointTracker(endingSeqNo, requiredSeqNoRangeStart - 1)___        final int expectedTotalOps = snapshot.totalOperations()__        if (expectedTotalOps == 0) {_            logger.trace("no translog operations to send")__        }__        final CancellableThreads.IOInterruptable sendBatch =_                () -> targetLocalCheckpoint.set(recoveryTarget.indexTranslogOperations(operations, expectedTotalOps))___        _        Translog.Operation operation__        while ((operation = snapshot.next()) != null) {_            if (shard.state() == IndexShardState.CLOSED) {_                throw new IndexShardClosedException(request.shardId())__            }_            cancellableThreads.checkForCancel()___            final long seqNo = operation.seqNo()__            if (seqNo < startingSeqNo || seqNo > endingSeqNo) {_                skippedOps++__                continue__            }_            operations.add(operation)__            ops++__            size += operation.estimateSize()__            totalSentOps++__            requiredOpsTracker.markSeqNoAsCompleted(seqNo)___            _            if (size >= chunkSizeInBytes) {_                cancellableThreads.executeIO(sendBatch)__                logger.trace("sent batch of [{}][{}] (total: [{}]) translog operations", ops, new ByteSizeValue(size), expectedTotalOps)__                ops = 0__                size = 0__                operations.clear()__            }_        }__        if (!operations.isEmpty() || totalSentOps == 0) {_            _            cancellableThreads.executeIO(sendBatch)__        }__        assert expectedTotalOps == snapshot.skippedOperations() + skippedOps + totalSentOps_            : String.format(Locale.ROOT, "expected total [%d], overridden [%d], skipped [%d], total sent [%d]",_            expectedTotalOps, snapshot.skippedOperations(), skippedOps, totalSentOps)___        if (requiredOpsTracker.getCheckpoint() < endingSeqNo) {_            throw new IllegalStateException("translog replay failed to cover required sequence numbers" +_                " (required range [" + requiredSeqNoRangeStart + ":" + endingSeqNo + "). first missing op is ["_                + (requiredOpsTracker.getCheckpoint() + 1) + "]")__        }__        logger.trace("sent final batch of [{}][{}] (total: [{}]) translog operations", ops, new ByteSizeValue(size), expectedTotalOps)___        return new SendSnapshotResult(targetLocalCheckpoint.get(), totalSentOps)__    };send,the,given,snapshot,s,operations,with,a,sequence,number,greater,than,the,specified,staring,sequence,number,to,this,handler,s,target,node,p,operations,are,bulked,into,a,single,request,depending,on,an,operation,count,limit,or,size,in,bytes,limit,param,starting,seq,no,the,sequence,number,for,which,only,operations,with,a,sequence,number,greater,than,this,will,be,sent,param,required,seq,no,range,start,the,lower,sequence,number,of,the,required,range,param,ending,seq,no,the,upper,bound,of,the,sequence,number,range,to,be,sent,inclusive,param,snapshot,the,translog,snapshot,to,replay,operations,from,return,the,local,checkpoint,on,the,target,and,the,total,number,of,operations,sent,throws,ioexception,if,an,i,o,exception,occurred,reading,the,translog,snapshot;protected,send,snapshot,result,send,snapshot,final,long,starting,seq,no,long,required,seq,no,range,start,long,ending,seq,no,final,translog,snapshot,snapshot,throws,ioexception,assert,required,seq,no,range,start,ending,seq,no,1,required,seq,no,range,start,required,seq,no,range,start,is,larger,than,ending,seq,no,ending,seq,no,assert,starting,seq,no,required,seq,no,range,start,starting,seq,no,starting,seq,no,is,larger,than,required,seq,no,range,start,required,seq,no,range,start,int,ops,0,long,size,0,int,skipped,ops,0,int,total,sent,ops,0,final,atomic,long,target,local,checkpoint,new,atomic,long,sequence,numbers,final,list,translog,operation,operations,new,array,list,final,local,checkpoint,tracker,required,ops,tracker,new,local,checkpoint,tracker,ending,seq,no,required,seq,no,range,start,1,final,int,expected,total,ops,snapshot,total,operations,if,expected,total,ops,0,logger,trace,no,translog,operations,to,send,final,cancellable,threads,iointerruptable,send,batch,target,local,checkpoint,set,recovery,target,index,translog,operations,operations,expected,total,ops,translog,operation,operation,while,operation,snapshot,next,null,if,shard,state,index,shard,state,closed,throw,new,index,shard,closed,exception,request,shard,id,cancellable,threads,check,for,cancel,final,long,seq,no,operation,seq,no,if,seq,no,starting,seq,no,seq,no,ending,seq,no,skipped,ops,continue,operations,add,operation,ops,size,operation,estimate,size,total,sent,ops,required,ops,tracker,mark,seq,no,as,completed,seq,no,if,size,chunk,size,in,bytes,cancellable,threads,execute,io,send,batch,logger,trace,sent,batch,of,total,translog,operations,ops,new,byte,size,value,size,expected,total,ops,ops,0,size,0,operations,clear,if,operations,is,empty,total,sent,ops,0,cancellable,threads,execute,io,send,batch,assert,expected,total,ops,snapshot,skipped,operations,skipped,ops,total,sent,ops,string,format,locale,root,expected,total,d,overridden,d,skipped,d,total,sent,d,expected,total,ops,snapshot,skipped,operations,skipped,ops,total,sent,ops,if,required,ops,tracker,get,checkpoint,ending,seq,no,throw,new,illegal,state,exception,translog,replay,failed,to,cover,required,sequence,numbers,required,range,required,seq,no,range,start,ending,seq,no,first,missing,op,is,required,ops,tracker,get,checkpoint,1,logger,trace,sent,final,batch,of,total,translog,operations,ops,new,byte,size,value,size,expected,total,ops,return,new,send,snapshot,result,target,local,checkpoint,get,total,sent,ops
RecoverySourceHandler -> protected SendSnapshotResult sendSnapshot(final long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo,                                               final Translog.Snapshot snapshot) throws IOException;1529658035;Send the given snapshot's operations with a sequence number greater than the specified staring sequence number to this handler's_target node._<p>_Operations are bulked into a single request depending on an operation count limit or size-in-bytes limit.__@param startingSeqNo           the sequence number for which only operations with a sequence number greater than this will be sent_@param requiredSeqNoRangeStart the lower sequence number of the required range_@param endingSeqNo             the upper bound of the sequence number range to be sent (inclusive)_@param snapshot                the translog snapshot to replay operations from  @return the local checkpoint on the target and the_total number of operations sent_@throws IOException if an I/O exception occurred reading the translog snapshot;protected SendSnapshotResult sendSnapshot(final long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo,_                                              final Translog.Snapshot snapshot) throws IOException {_        assert requiredSeqNoRangeStart <= endingSeqNo + 1:_            "requiredSeqNoRangeStart " + requiredSeqNoRangeStart + " is larger than endingSeqNo " + endingSeqNo__        assert startingSeqNo <= requiredSeqNoRangeStart :_            "startingSeqNo " + startingSeqNo + " is larger than requiredSeqNoRangeStart " + requiredSeqNoRangeStart__        int ops = 0__        long size = 0__        int skippedOps = 0__        int totalSentOps = 0__        final AtomicLong targetLocalCheckpoint = new AtomicLong(SequenceNumbers.UNASSIGNED_SEQ_NO)__        final List<Translog.Operation> operations = new ArrayList<>()__        final LocalCheckpointTracker requiredOpsTracker = new LocalCheckpointTracker(endingSeqNo, requiredSeqNoRangeStart - 1)___        final int expectedTotalOps = snapshot.totalOperations()__        if (expectedTotalOps == 0) {_            logger.trace("no translog operations to send")__        }__        final CancellableThreads.IOInterruptable sendBatch =_                () -> targetLocalCheckpoint.set(recoveryTarget.indexTranslogOperations(operations, expectedTotalOps))___        _        Translog.Operation operation__        while ((operation = snapshot.next()) != null) {_            if (shard.state() == IndexShardState.CLOSED) {_                throw new IndexShardClosedException(request.shardId())__            }_            cancellableThreads.checkForCancel()___            final long seqNo = operation.seqNo()__            if (seqNo < startingSeqNo || seqNo > endingSeqNo) {_                skippedOps++__                continue__            }_            operations.add(operation)__            ops++__            size += operation.estimateSize()__            totalSentOps++__            requiredOpsTracker.markSeqNoAsCompleted(seqNo)___            _            if (size >= chunkSizeInBytes) {_                cancellableThreads.executeIO(sendBatch)__                logger.trace("sent batch of [{}][{}] (total: [{}]) translog operations", ops, new ByteSizeValue(size), expectedTotalOps)__                ops = 0__                size = 0__                operations.clear()__            }_        }__        if (!operations.isEmpty() || totalSentOps == 0) {_            _            cancellableThreads.executeIO(sendBatch)__        }__        assert expectedTotalOps == snapshot.skippedOperations() + skippedOps + totalSentOps_            : String.format(Locale.ROOT, "expected total [%d], overridden [%d], skipped [%d], total sent [%d]",_            expectedTotalOps, snapshot.skippedOperations(), skippedOps, totalSentOps)___        if (requiredOpsTracker.getCheckpoint() < endingSeqNo) {_            throw new IllegalStateException("translog replay failed to cover required sequence numbers" +_                " (required range [" + requiredSeqNoRangeStart + ":" + endingSeqNo + "). first missing op is ["_                + (requiredOpsTracker.getCheckpoint() + 1) + "]")__        }__        logger.trace("sent final batch of [{}][{}] (total: [{}]) translog operations", ops, new ByteSizeValue(size), expectedTotalOps)___        return new SendSnapshotResult(targetLocalCheckpoint.get(), totalSentOps)__    };send,the,given,snapshot,s,operations,with,a,sequence,number,greater,than,the,specified,staring,sequence,number,to,this,handler,s,target,node,p,operations,are,bulked,into,a,single,request,depending,on,an,operation,count,limit,or,size,in,bytes,limit,param,starting,seq,no,the,sequence,number,for,which,only,operations,with,a,sequence,number,greater,than,this,will,be,sent,param,required,seq,no,range,start,the,lower,sequence,number,of,the,required,range,param,ending,seq,no,the,upper,bound,of,the,sequence,number,range,to,be,sent,inclusive,param,snapshot,the,translog,snapshot,to,replay,operations,from,return,the,local,checkpoint,on,the,target,and,the,total,number,of,operations,sent,throws,ioexception,if,an,i,o,exception,occurred,reading,the,translog,snapshot;protected,send,snapshot,result,send,snapshot,final,long,starting,seq,no,long,required,seq,no,range,start,long,ending,seq,no,final,translog,snapshot,snapshot,throws,ioexception,assert,required,seq,no,range,start,ending,seq,no,1,required,seq,no,range,start,required,seq,no,range,start,is,larger,than,ending,seq,no,ending,seq,no,assert,starting,seq,no,required,seq,no,range,start,starting,seq,no,starting,seq,no,is,larger,than,required,seq,no,range,start,required,seq,no,range,start,int,ops,0,long,size,0,int,skipped,ops,0,int,total,sent,ops,0,final,atomic,long,target,local,checkpoint,new,atomic,long,sequence,numbers,final,list,translog,operation,operations,new,array,list,final,local,checkpoint,tracker,required,ops,tracker,new,local,checkpoint,tracker,ending,seq,no,required,seq,no,range,start,1,final,int,expected,total,ops,snapshot,total,operations,if,expected,total,ops,0,logger,trace,no,translog,operations,to,send,final,cancellable,threads,iointerruptable,send,batch,target,local,checkpoint,set,recovery,target,index,translog,operations,operations,expected,total,ops,translog,operation,operation,while,operation,snapshot,next,null,if,shard,state,index,shard,state,closed,throw,new,index,shard,closed,exception,request,shard,id,cancellable,threads,check,for,cancel,final,long,seq,no,operation,seq,no,if,seq,no,starting,seq,no,seq,no,ending,seq,no,skipped,ops,continue,operations,add,operation,ops,size,operation,estimate,size,total,sent,ops,required,ops,tracker,mark,seq,no,as,completed,seq,no,if,size,chunk,size,in,bytes,cancellable,threads,execute,io,send,batch,logger,trace,sent,batch,of,total,translog,operations,ops,new,byte,size,value,size,expected,total,ops,ops,0,size,0,operations,clear,if,operations,is,empty,total,sent,ops,0,cancellable,threads,execute,io,send,batch,assert,expected,total,ops,snapshot,skipped,operations,skipped,ops,total,sent,ops,string,format,locale,root,expected,total,d,overridden,d,skipped,d,total,sent,d,expected,total,ops,snapshot,skipped,operations,skipped,ops,total,sent,ops,if,required,ops,tracker,get,checkpoint,ending,seq,no,throw,new,illegal,state,exception,translog,replay,failed,to,cover,required,sequence,numbers,required,range,required,seq,no,range,start,ending,seq,no,first,missing,op,is,required,ops,tracker,get,checkpoint,1,logger,trace,sent,final,batch,of,total,translog,operations,ops,new,byte,size,value,size,expected,total,ops,return,new,send,snapshot,result,target,local,checkpoint,get,total,sent,ops
RecoverySourceHandler -> protected SendSnapshotResult sendSnapshot(final long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo,                                               final Translog.Snapshot snapshot) throws IOException;1533295538;Send the given snapshot's operations with a sequence number greater than the specified staring sequence number to this handler's_target node._<p>_Operations are bulked into a single request depending on an operation count limit or size-in-bytes limit.__@param startingSeqNo           the sequence number for which only operations with a sequence number greater than this will be sent_@param requiredSeqNoRangeStart the lower sequence number of the required range_@param endingSeqNo             the upper bound of the sequence number range to be sent (inclusive)_@param snapshot                the translog snapshot to replay operations from  @return the local checkpoint on the target and the_total number of operations sent_@throws IOException if an I/O exception occurred reading the translog snapshot;protected SendSnapshotResult sendSnapshot(final long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo,_                                              final Translog.Snapshot snapshot) throws IOException {_        assert requiredSeqNoRangeStart <= endingSeqNo + 1:_            "requiredSeqNoRangeStart " + requiredSeqNoRangeStart + " is larger than endingSeqNo " + endingSeqNo__        assert startingSeqNo <= requiredSeqNoRangeStart :_            "startingSeqNo " + startingSeqNo + " is larger than requiredSeqNoRangeStart " + requiredSeqNoRangeStart__        int ops = 0__        long size = 0__        int skippedOps = 0__        int totalSentOps = 0__        final AtomicLong targetLocalCheckpoint = new AtomicLong(SequenceNumbers.UNASSIGNED_SEQ_NO)__        final List<Translog.Operation> operations = new ArrayList<>()__        final LocalCheckpointTracker requiredOpsTracker = new LocalCheckpointTracker(endingSeqNo, requiredSeqNoRangeStart - 1)___        final int expectedTotalOps = snapshot.totalOperations()__        if (expectedTotalOps == 0) {_            logger.trace("no translog operations to send")__        }__        final CancellableThreads.IOInterruptable sendBatch =_                () -> targetLocalCheckpoint.set(recoveryTarget.indexTranslogOperations(operations, expectedTotalOps))___        _        Translog.Operation operation__        while ((operation = snapshot.next()) != null) {_            if (shard.state() == IndexShardState.CLOSED) {_                throw new IndexShardClosedException(request.shardId())__            }_            cancellableThreads.checkForCancel()___            final long seqNo = operation.seqNo()__            if (seqNo < startingSeqNo || seqNo > endingSeqNo) {_                skippedOps++__                continue__            }_            operations.add(operation)__            ops++__            size += operation.estimateSize()__            totalSentOps++__            requiredOpsTracker.markSeqNoAsCompleted(seqNo)___            _            if (size >= chunkSizeInBytes) {_                cancellableThreads.executeIO(sendBatch)__                logger.trace("sent batch of [{}][{}] (total: [{}]) translog operations", ops, new ByteSizeValue(size), expectedTotalOps)__                ops = 0__                size = 0__                operations.clear()__            }_        }__        if (!operations.isEmpty() || totalSentOps == 0) {_            _            cancellableThreads.executeIO(sendBatch)__        }__        assert expectedTotalOps == snapshot.skippedOperations() + skippedOps + totalSentOps_            : String.format(Locale.ROOT, "expected total [%d], overridden [%d], skipped [%d], total sent [%d]",_            expectedTotalOps, snapshot.skippedOperations(), skippedOps, totalSentOps)___        if (requiredOpsTracker.getCheckpoint() < endingSeqNo) {_            throw new IllegalStateException("translog replay failed to cover required sequence numbers" +_                " (required range [" + requiredSeqNoRangeStart + ":" + endingSeqNo + "). first missing op is ["_                + (requiredOpsTracker.getCheckpoint() + 1) + "]")__        }__        logger.trace("sent final batch of [{}][{}] (total: [{}]) translog operations", ops, new ByteSizeValue(size), expectedTotalOps)___        return new SendSnapshotResult(targetLocalCheckpoint.get(), totalSentOps)__    };send,the,given,snapshot,s,operations,with,a,sequence,number,greater,than,the,specified,staring,sequence,number,to,this,handler,s,target,node,p,operations,are,bulked,into,a,single,request,depending,on,an,operation,count,limit,or,size,in,bytes,limit,param,starting,seq,no,the,sequence,number,for,which,only,operations,with,a,sequence,number,greater,than,this,will,be,sent,param,required,seq,no,range,start,the,lower,sequence,number,of,the,required,range,param,ending,seq,no,the,upper,bound,of,the,sequence,number,range,to,be,sent,inclusive,param,snapshot,the,translog,snapshot,to,replay,operations,from,return,the,local,checkpoint,on,the,target,and,the,total,number,of,operations,sent,throws,ioexception,if,an,i,o,exception,occurred,reading,the,translog,snapshot;protected,send,snapshot,result,send,snapshot,final,long,starting,seq,no,long,required,seq,no,range,start,long,ending,seq,no,final,translog,snapshot,snapshot,throws,ioexception,assert,required,seq,no,range,start,ending,seq,no,1,required,seq,no,range,start,required,seq,no,range,start,is,larger,than,ending,seq,no,ending,seq,no,assert,starting,seq,no,required,seq,no,range,start,starting,seq,no,starting,seq,no,is,larger,than,required,seq,no,range,start,required,seq,no,range,start,int,ops,0,long,size,0,int,skipped,ops,0,int,total,sent,ops,0,final,atomic,long,target,local,checkpoint,new,atomic,long,sequence,numbers,final,list,translog,operation,operations,new,array,list,final,local,checkpoint,tracker,required,ops,tracker,new,local,checkpoint,tracker,ending,seq,no,required,seq,no,range,start,1,final,int,expected,total,ops,snapshot,total,operations,if,expected,total,ops,0,logger,trace,no,translog,operations,to,send,final,cancellable,threads,iointerruptable,send,batch,target,local,checkpoint,set,recovery,target,index,translog,operations,operations,expected,total,ops,translog,operation,operation,while,operation,snapshot,next,null,if,shard,state,index,shard,state,closed,throw,new,index,shard,closed,exception,request,shard,id,cancellable,threads,check,for,cancel,final,long,seq,no,operation,seq,no,if,seq,no,starting,seq,no,seq,no,ending,seq,no,skipped,ops,continue,operations,add,operation,ops,size,operation,estimate,size,total,sent,ops,required,ops,tracker,mark,seq,no,as,completed,seq,no,if,size,chunk,size,in,bytes,cancellable,threads,execute,io,send,batch,logger,trace,sent,batch,of,total,translog,operations,ops,new,byte,size,value,size,expected,total,ops,ops,0,size,0,operations,clear,if,operations,is,empty,total,sent,ops,0,cancellable,threads,execute,io,send,batch,assert,expected,total,ops,snapshot,skipped,operations,skipped,ops,total,sent,ops,string,format,locale,root,expected,total,d,overridden,d,skipped,d,total,sent,d,expected,total,ops,snapshot,skipped,operations,skipped,ops,total,sent,ops,if,required,ops,tracker,get,checkpoint,ending,seq,no,throw,new,illegal,state,exception,translog,replay,failed,to,cover,required,sequence,numbers,required,range,required,seq,no,range,start,ending,seq,no,first,missing,op,is,required,ops,tracker,get,checkpoint,1,logger,trace,sent,final,batch,of,total,translog,operations,ops,new,byte,size,value,size,expected,total,ops,return,new,send,snapshot,result,target,local,checkpoint,get,total,sent,ops
RecoverySourceHandler -> protected SendSnapshotResult sendSnapshot(final long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo,                                               final Translog.Snapshot snapshot) throws IOException;1535723122;Send the given snapshot's operations with a sequence number greater than the specified staring sequence number to this handler's_target node._<p>_Operations are bulked into a single request depending on an operation count limit or size-in-bytes limit.__@param startingSeqNo           the sequence number for which only operations with a sequence number greater than this will be sent_@param requiredSeqNoRangeStart the lower sequence number of the required range_@param endingSeqNo             the upper bound of the sequence number range to be sent (inclusive)_@param snapshot                the translog snapshot to replay operations from  @return the local checkpoint on the target and the_total number of operations sent_@throws IOException if an I/O exception occurred reading the translog snapshot;protected SendSnapshotResult sendSnapshot(final long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo,_                                              final Translog.Snapshot snapshot) throws IOException {_        assert requiredSeqNoRangeStart <= endingSeqNo + 1:_            "requiredSeqNoRangeStart " + requiredSeqNoRangeStart + " is larger than endingSeqNo " + endingSeqNo__        assert startingSeqNo <= requiredSeqNoRangeStart :_            "startingSeqNo " + startingSeqNo + " is larger than requiredSeqNoRangeStart " + requiredSeqNoRangeStart__        int ops = 0__        long size = 0__        int skippedOps = 0__        int totalSentOps = 0__        final AtomicLong targetLocalCheckpoint = new AtomicLong(SequenceNumbers.UNASSIGNED_SEQ_NO)__        final List<Translog.Operation> operations = new ArrayList<>()__        final LocalCheckpointTracker requiredOpsTracker = new LocalCheckpointTracker(endingSeqNo, requiredSeqNoRangeStart - 1)___        final int expectedTotalOps = snapshot.totalOperations()__        if (expectedTotalOps == 0) {_            logger.trace("no translog operations to send")__        }__        final CancellableThreads.IOInterruptable sendBatch =_                () -> targetLocalCheckpoint.set(recoveryTarget.indexTranslogOperations(operations, expectedTotalOps))___        _        Translog.Operation operation__        while ((operation = snapshot.next()) != null) {_            if (shard.state() == IndexShardState.CLOSED) {_                throw new IndexShardClosedException(request.shardId())__            }_            cancellableThreads.checkForCancel()___            final long seqNo = operation.seqNo()__            if (seqNo < startingSeqNo || seqNo > endingSeqNo) {_                skippedOps++__                continue__            }_            operations.add(operation)__            ops++__            size += operation.estimateSize()__            totalSentOps++__            requiredOpsTracker.markSeqNoAsCompleted(seqNo)___            _            if (size >= chunkSizeInBytes) {_                cancellableThreads.executeIO(sendBatch)__                logger.trace("sent batch of [{}][{}] (total: [{}]) translog operations", ops, new ByteSizeValue(size), expectedTotalOps)__                ops = 0__                size = 0__                operations.clear()__            }_        }__        if (!operations.isEmpty() || totalSentOps == 0) {_            _            cancellableThreads.executeIO(sendBatch)__        }__        assert expectedTotalOps == snapshot.skippedOperations() + skippedOps + totalSentOps_            : String.format(Locale.ROOT, "expected total [%d], overridden [%d], skipped [%d], total sent [%d]",_            expectedTotalOps, snapshot.skippedOperations(), skippedOps, totalSentOps)___        if (requiredOpsTracker.getCheckpoint() < endingSeqNo) {_            throw new IllegalStateException("translog replay failed to cover required sequence numbers" +_                " (required range [" + requiredSeqNoRangeStart + ":" + endingSeqNo + "). first missing op is ["_                + (requiredOpsTracker.getCheckpoint() + 1) + "]")__        }__        logger.trace("sent final batch of [{}][{}] (total: [{}]) translog operations", ops, new ByteSizeValue(size), expectedTotalOps)___        return new SendSnapshotResult(targetLocalCheckpoint.get(), totalSentOps)__    };send,the,given,snapshot,s,operations,with,a,sequence,number,greater,than,the,specified,staring,sequence,number,to,this,handler,s,target,node,p,operations,are,bulked,into,a,single,request,depending,on,an,operation,count,limit,or,size,in,bytes,limit,param,starting,seq,no,the,sequence,number,for,which,only,operations,with,a,sequence,number,greater,than,this,will,be,sent,param,required,seq,no,range,start,the,lower,sequence,number,of,the,required,range,param,ending,seq,no,the,upper,bound,of,the,sequence,number,range,to,be,sent,inclusive,param,snapshot,the,translog,snapshot,to,replay,operations,from,return,the,local,checkpoint,on,the,target,and,the,total,number,of,operations,sent,throws,ioexception,if,an,i,o,exception,occurred,reading,the,translog,snapshot;protected,send,snapshot,result,send,snapshot,final,long,starting,seq,no,long,required,seq,no,range,start,long,ending,seq,no,final,translog,snapshot,snapshot,throws,ioexception,assert,required,seq,no,range,start,ending,seq,no,1,required,seq,no,range,start,required,seq,no,range,start,is,larger,than,ending,seq,no,ending,seq,no,assert,starting,seq,no,required,seq,no,range,start,starting,seq,no,starting,seq,no,is,larger,than,required,seq,no,range,start,required,seq,no,range,start,int,ops,0,long,size,0,int,skipped,ops,0,int,total,sent,ops,0,final,atomic,long,target,local,checkpoint,new,atomic,long,sequence,numbers,final,list,translog,operation,operations,new,array,list,final,local,checkpoint,tracker,required,ops,tracker,new,local,checkpoint,tracker,ending,seq,no,required,seq,no,range,start,1,final,int,expected,total,ops,snapshot,total,operations,if,expected,total,ops,0,logger,trace,no,translog,operations,to,send,final,cancellable,threads,iointerruptable,send,batch,target,local,checkpoint,set,recovery,target,index,translog,operations,operations,expected,total,ops,translog,operation,operation,while,operation,snapshot,next,null,if,shard,state,index,shard,state,closed,throw,new,index,shard,closed,exception,request,shard,id,cancellable,threads,check,for,cancel,final,long,seq,no,operation,seq,no,if,seq,no,starting,seq,no,seq,no,ending,seq,no,skipped,ops,continue,operations,add,operation,ops,size,operation,estimate,size,total,sent,ops,required,ops,tracker,mark,seq,no,as,completed,seq,no,if,size,chunk,size,in,bytes,cancellable,threads,execute,io,send,batch,logger,trace,sent,batch,of,total,translog,operations,ops,new,byte,size,value,size,expected,total,ops,ops,0,size,0,operations,clear,if,operations,is,empty,total,sent,ops,0,cancellable,threads,execute,io,send,batch,assert,expected,total,ops,snapshot,skipped,operations,skipped,ops,total,sent,ops,string,format,locale,root,expected,total,d,overridden,d,skipped,d,total,sent,d,expected,total,ops,snapshot,skipped,operations,skipped,ops,total,sent,ops,if,required,ops,tracker,get,checkpoint,ending,seq,no,throw,new,illegal,state,exception,translog,replay,failed,to,cover,required,sequence,numbers,required,range,required,seq,no,range,start,ending,seq,no,first,missing,op,is,required,ops,tracker,get,checkpoint,1,logger,trace,sent,final,batch,of,total,translog,operations,ops,new,byte,size,value,size,expected,total,ops,return,new,send,snapshot,result,target,local,checkpoint,get,total,sent,ops
RecoverySourceHandler -> protected SendSnapshotResult sendSnapshot(final long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo,                                               final Translog.Snapshot snapshot) throws IOException;1535965276;Send the given snapshot's operations with a sequence number greater than the specified staring sequence number to this handler's_target node._<p>_Operations are bulked into a single request depending on an operation count limit or size-in-bytes limit.__@param startingSeqNo           the sequence number for which only operations with a sequence number greater than this will be sent_@param requiredSeqNoRangeStart the lower sequence number of the required range_@param endingSeqNo             the upper bound of the sequence number range to be sent (inclusive)_@param snapshot                the translog snapshot to replay operations from  @return the local checkpoint on the target and the_total number of operations sent_@throws IOException if an I/O exception occurred reading the translog snapshot;protected SendSnapshotResult sendSnapshot(final long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo,_                                              final Translog.Snapshot snapshot) throws IOException {_        assert requiredSeqNoRangeStart <= endingSeqNo + 1:_            "requiredSeqNoRangeStart " + requiredSeqNoRangeStart + " is larger than endingSeqNo " + endingSeqNo__        assert startingSeqNo <= requiredSeqNoRangeStart :_            "startingSeqNo " + startingSeqNo + " is larger than requiredSeqNoRangeStart " + requiredSeqNoRangeStart__        int ops = 0__        long size = 0__        int skippedOps = 0__        int totalSentOps = 0__        final AtomicLong targetLocalCheckpoint = new AtomicLong(SequenceNumbers.UNASSIGNED_SEQ_NO)__        final List<Translog.Operation> operations = new ArrayList<>()__        final LocalCheckpointTracker requiredOpsTracker = new LocalCheckpointTracker(endingSeqNo, requiredSeqNoRangeStart - 1)___        final int expectedTotalOps = snapshot.totalOperations()__        if (expectedTotalOps == 0) {_            logger.trace("no translog operations to send")__        }__        final CancellableThreads.IOInterruptable sendBatch =_                () -> targetLocalCheckpoint.set(recoveryTarget.indexTranslogOperations(operations, expectedTotalOps))___        _        Translog.Operation operation__        while ((operation = snapshot.next()) != null) {_            if (shard.state() == IndexShardState.CLOSED) {_                throw new IndexShardClosedException(request.shardId())__            }_            cancellableThreads.checkForCancel()___            final long seqNo = operation.seqNo()__            if (seqNo < startingSeqNo || seqNo > endingSeqNo) {_                skippedOps++__                continue__            }_            operations.add(operation)__            ops++__            size += operation.estimateSize()__            totalSentOps++__            requiredOpsTracker.markSeqNoAsCompleted(seqNo)___            _            if (size >= chunkSizeInBytes) {_                cancellableThreads.executeIO(sendBatch)__                logger.trace("sent batch of [{}][{}] (total: [{}]) translog operations", ops, new ByteSizeValue(size), expectedTotalOps)__                ops = 0__                size = 0__                operations.clear()__            }_        }__        if (!operations.isEmpty() || totalSentOps == 0) {_            _            cancellableThreads.executeIO(sendBatch)__        }__        assert expectedTotalOps == snapshot.skippedOperations() + skippedOps + totalSentOps_            : String.format(Locale.ROOT, "expected total [%d], overridden [%d], skipped [%d], total sent [%d]",_            expectedTotalOps, snapshot.skippedOperations(), skippedOps, totalSentOps)___        if (requiredOpsTracker.getCheckpoint() < endingSeqNo) {_            throw new IllegalStateException("translog replay failed to cover required sequence numbers" +_                " (required range [" + requiredSeqNoRangeStart + ":" + endingSeqNo + "). first missing op is ["_                + (requiredOpsTracker.getCheckpoint() + 1) + "]")__        }__        logger.trace("sent final batch of [{}][{}] (total: [{}]) translog operations", ops, new ByteSizeValue(size), expectedTotalOps)___        return new SendSnapshotResult(targetLocalCheckpoint.get(), totalSentOps)__    };send,the,given,snapshot,s,operations,with,a,sequence,number,greater,than,the,specified,staring,sequence,number,to,this,handler,s,target,node,p,operations,are,bulked,into,a,single,request,depending,on,an,operation,count,limit,or,size,in,bytes,limit,param,starting,seq,no,the,sequence,number,for,which,only,operations,with,a,sequence,number,greater,than,this,will,be,sent,param,required,seq,no,range,start,the,lower,sequence,number,of,the,required,range,param,ending,seq,no,the,upper,bound,of,the,sequence,number,range,to,be,sent,inclusive,param,snapshot,the,translog,snapshot,to,replay,operations,from,return,the,local,checkpoint,on,the,target,and,the,total,number,of,operations,sent,throws,ioexception,if,an,i,o,exception,occurred,reading,the,translog,snapshot;protected,send,snapshot,result,send,snapshot,final,long,starting,seq,no,long,required,seq,no,range,start,long,ending,seq,no,final,translog,snapshot,snapshot,throws,ioexception,assert,required,seq,no,range,start,ending,seq,no,1,required,seq,no,range,start,required,seq,no,range,start,is,larger,than,ending,seq,no,ending,seq,no,assert,starting,seq,no,required,seq,no,range,start,starting,seq,no,starting,seq,no,is,larger,than,required,seq,no,range,start,required,seq,no,range,start,int,ops,0,long,size,0,int,skipped,ops,0,int,total,sent,ops,0,final,atomic,long,target,local,checkpoint,new,atomic,long,sequence,numbers,final,list,translog,operation,operations,new,array,list,final,local,checkpoint,tracker,required,ops,tracker,new,local,checkpoint,tracker,ending,seq,no,required,seq,no,range,start,1,final,int,expected,total,ops,snapshot,total,operations,if,expected,total,ops,0,logger,trace,no,translog,operations,to,send,final,cancellable,threads,iointerruptable,send,batch,target,local,checkpoint,set,recovery,target,index,translog,operations,operations,expected,total,ops,translog,operation,operation,while,operation,snapshot,next,null,if,shard,state,index,shard,state,closed,throw,new,index,shard,closed,exception,request,shard,id,cancellable,threads,check,for,cancel,final,long,seq,no,operation,seq,no,if,seq,no,starting,seq,no,seq,no,ending,seq,no,skipped,ops,continue,operations,add,operation,ops,size,operation,estimate,size,total,sent,ops,required,ops,tracker,mark,seq,no,as,completed,seq,no,if,size,chunk,size,in,bytes,cancellable,threads,execute,io,send,batch,logger,trace,sent,batch,of,total,translog,operations,ops,new,byte,size,value,size,expected,total,ops,ops,0,size,0,operations,clear,if,operations,is,empty,total,sent,ops,0,cancellable,threads,execute,io,send,batch,assert,expected,total,ops,snapshot,skipped,operations,skipped,ops,total,sent,ops,string,format,locale,root,expected,total,d,overridden,d,skipped,d,total,sent,d,expected,total,ops,snapshot,skipped,operations,skipped,ops,total,sent,ops,if,required,ops,tracker,get,checkpoint,ending,seq,no,throw,new,illegal,state,exception,translog,replay,failed,to,cover,required,sequence,numbers,required,range,required,seq,no,range,start,ending,seq,no,first,missing,op,is,required,ops,tracker,get,checkpoint,1,logger,trace,sent,final,batch,of,total,translog,operations,ops,new,byte,size,value,size,expected,total,ops,return,new,send,snapshot,result,target,local,checkpoint,get,total,sent,ops
RecoverySourceHandler -> SendSnapshotResult phase2(long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo, Translog.Snapshot snapshot,                               long maxSeenAutoIdTimestamp, long maxSeqNoOfUpdatesOrDeletes) throws IOException;1546981938;Perform phase two of the recovery process._<p>_Phase two uses a snapshot of the current translog *without* acquiring the write lock (however, the translog snapshot is_point-in-time view of the translog). It then sends each translog operation to the target node so it can be replayed into the new_shard.__@param startingSeqNo              the sequence number to start recovery from, or {@link SequenceNumbers#UNASSIGNED_SEQ_NO} if all_ops should be sent_@param requiredSeqNoRangeStart    the lower sequence number of the required range (ending with endingSeqNo)_@param endingSeqNo                the highest sequence number that should be sent_@param snapshot                   a snapshot of the translog_@param maxSeenAutoIdTimestamp     the max auto_id_timestamp of append-only requests on the primary_@param maxSeqNoOfUpdatesOrDeletes the max seq_no of updates or deletes on the primary after these operations were executed on it._@return the send snapshot result;SendSnapshotResult phase2(long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo, Translog.Snapshot snapshot,_                              long maxSeenAutoIdTimestamp, long maxSeqNoOfUpdatesOrDeletes) throws IOException {_        assert requiredSeqNoRangeStart <= endingSeqNo + 1:_            "requiredSeqNoRangeStart " + requiredSeqNoRangeStart + " is larger than endingSeqNo " + endingSeqNo__        assert startingSeqNo <= requiredSeqNoRangeStart :_            "startingSeqNo " + startingSeqNo + " is larger than requiredSeqNoRangeStart " + requiredSeqNoRangeStart__        if (shard.state() == IndexShardState.CLOSED) {_            throw new IndexShardClosedException(request.shardId())__        }__        final StopWatch stopWatch = new StopWatch().start()___        logger.trace("recovery [phase2]: sending transaction log operations (seq# from [" +  startingSeqNo  + "], " +_            "required [" + requiredSeqNoRangeStart + ":" + endingSeqNo + "]")___        int ops = 0__        long size = 0__        int skippedOps = 0__        int totalSentOps = 0__        final AtomicLong targetLocalCheckpoint = new AtomicLong(SequenceNumbers.UNASSIGNED_SEQ_NO)__        final List<Translog.Operation> operations = new ArrayList<>()__        final LocalCheckpointTracker requiredOpsTracker = new LocalCheckpointTracker(endingSeqNo, requiredSeqNoRangeStart - 1)___        final int expectedTotalOps = snapshot.totalOperations()__        if (expectedTotalOps == 0) {_            logger.trace("no translog operations to send")__        }__        final CancellableThreads.IOInterruptible sendBatch = () -> {_            final long targetCheckpoint = recoveryTarget.indexTranslogOperations(_                operations, expectedTotalOps, maxSeenAutoIdTimestamp, maxSeqNoOfUpdatesOrDeletes)__            targetLocalCheckpoint.set(targetCheckpoint)__        }___        _        Translog.Operation operation__        while ((operation = snapshot.next()) != null) {_            if (shard.state() == IndexShardState.CLOSED) {_                throw new IndexShardClosedException(request.shardId())__            }_            cancellableThreads.checkForCancel()___            final long seqNo = operation.seqNo()__            if (seqNo < startingSeqNo || seqNo > endingSeqNo) {_                skippedOps++__                continue__            }_            operations.add(operation)__            ops++__            size += operation.estimateSize()__            totalSentOps++__            requiredOpsTracker.markSeqNoAsCompleted(seqNo)___            _            if (size >= chunkSizeInBytes) {_                cancellableThreads.executeIO(sendBatch)__                logger.trace("sent batch of [{}][{}] (total: [{}]) translog operations", ops, new ByteSizeValue(size), expectedTotalOps)__                ops = 0__                size = 0__                operations.clear()__            }_        }__        if (!operations.isEmpty() || totalSentOps == 0) {_            _            cancellableThreads.executeIO(sendBatch)__        }__        assert expectedTotalOps == snapshot.skippedOperations() + skippedOps + totalSentOps_            : String.format(Locale.ROOT, "expected total [%d], overridden [%d], skipped [%d], total sent [%d]",_            expectedTotalOps, snapshot.skippedOperations(), skippedOps, totalSentOps)___        if (requiredOpsTracker.getCheckpoint() < endingSeqNo) {_            throw new IllegalStateException("translog replay failed to cover required sequence numbers" +_                " (required range [" + requiredSeqNoRangeStart + ":" + endingSeqNo + "). first missing op is ["_                + (requiredOpsTracker.getCheckpoint() + 1) + "]")__        }__        logger.trace("sent final batch of [{}][{}] (total: [{}]) translog operations", ops, new ByteSizeValue(size), expectedTotalOps)___        stopWatch.stop()__        final TimeValue tookTime = stopWatch.totalTime()__        logger.trace("recovery [phase2]: took [{}]", tookTime)__        return new SendSnapshotResult(targetLocalCheckpoint.get(), totalSentOps, tookTime)__    };perform,phase,two,of,the,recovery,process,p,phase,two,uses,a,snapshot,of,the,current,translog,without,acquiring,the,write,lock,however,the,translog,snapshot,is,point,in,time,view,of,the,translog,it,then,sends,each,translog,operation,to,the,target,node,so,it,can,be,replayed,into,the,new,shard,param,starting,seq,no,the,sequence,number,to,start,recovery,from,or,link,sequence,numbers,if,all,ops,should,be,sent,param,required,seq,no,range,start,the,lower,sequence,number,of,the,required,range,ending,with,ending,seq,no,param,ending,seq,no,the,highest,sequence,number,that,should,be,sent,param,snapshot,a,snapshot,of,the,translog,param,max,seen,auto,id,timestamp,the,max,of,append,only,requests,on,the,primary,param,max,seq,no,of,updates,or,deletes,the,max,of,updates,or,deletes,on,the,primary,after,these,operations,were,executed,on,it,return,the,send,snapshot,result;send,snapshot,result,phase2,long,starting,seq,no,long,required,seq,no,range,start,long,ending,seq,no,translog,snapshot,snapshot,long,max,seen,auto,id,timestamp,long,max,seq,no,of,updates,or,deletes,throws,ioexception,assert,required,seq,no,range,start,ending,seq,no,1,required,seq,no,range,start,required,seq,no,range,start,is,larger,than,ending,seq,no,ending,seq,no,assert,starting,seq,no,required,seq,no,range,start,starting,seq,no,starting,seq,no,is,larger,than,required,seq,no,range,start,required,seq,no,range,start,if,shard,state,index,shard,state,closed,throw,new,index,shard,closed,exception,request,shard,id,final,stop,watch,stop,watch,new,stop,watch,start,logger,trace,recovery,phase2,sending,transaction,log,operations,seq,from,starting,seq,no,required,required,seq,no,range,start,ending,seq,no,int,ops,0,long,size,0,int,skipped,ops,0,int,total,sent,ops,0,final,atomic,long,target,local,checkpoint,new,atomic,long,sequence,numbers,final,list,translog,operation,operations,new,array,list,final,local,checkpoint,tracker,required,ops,tracker,new,local,checkpoint,tracker,ending,seq,no,required,seq,no,range,start,1,final,int,expected,total,ops,snapshot,total,operations,if,expected,total,ops,0,logger,trace,no,translog,operations,to,send,final,cancellable,threads,iointerruptible,send,batch,final,long,target,checkpoint,recovery,target,index,translog,operations,operations,expected,total,ops,max,seen,auto,id,timestamp,max,seq,no,of,updates,or,deletes,target,local,checkpoint,set,target,checkpoint,translog,operation,operation,while,operation,snapshot,next,null,if,shard,state,index,shard,state,closed,throw,new,index,shard,closed,exception,request,shard,id,cancellable,threads,check,for,cancel,final,long,seq,no,operation,seq,no,if,seq,no,starting,seq,no,seq,no,ending,seq,no,skipped,ops,continue,operations,add,operation,ops,size,operation,estimate,size,total,sent,ops,required,ops,tracker,mark,seq,no,as,completed,seq,no,if,size,chunk,size,in,bytes,cancellable,threads,execute,io,send,batch,logger,trace,sent,batch,of,total,translog,operations,ops,new,byte,size,value,size,expected,total,ops,ops,0,size,0,operations,clear,if,operations,is,empty,total,sent,ops,0,cancellable,threads,execute,io,send,batch,assert,expected,total,ops,snapshot,skipped,operations,skipped,ops,total,sent,ops,string,format,locale,root,expected,total,d,overridden,d,skipped,d,total,sent,d,expected,total,ops,snapshot,skipped,operations,skipped,ops,total,sent,ops,if,required,ops,tracker,get,checkpoint,ending,seq,no,throw,new,illegal,state,exception,translog,replay,failed,to,cover,required,sequence,numbers,required,range,required,seq,no,range,start,ending,seq,no,first,missing,op,is,required,ops,tracker,get,checkpoint,1,logger,trace,sent,final,batch,of,total,translog,operations,ops,new,byte,size,value,size,expected,total,ops,stop,watch,stop,final,time,value,took,time,stop,watch,total,time,logger,trace,recovery,phase2,took,took,time,return,new,send,snapshot,result,target,local,checkpoint,get,total,sent,ops,took,time
RecoverySourceHandler -> SendSnapshotResult phase2(long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo, Translog.Snapshot snapshot,                               long maxSeenAutoIdTimestamp, long maxSeqNoOfUpdatesOrDeletes) throws IOException;1547315388;Perform phase two of the recovery process._<p>_Phase two uses a snapshot of the current translog *without* acquiring the write lock (however, the translog snapshot is_point-in-time view of the translog). It then sends each translog operation to the target node so it can be replayed into the new_shard.__@param startingSeqNo              the sequence number to start recovery from, or {@link SequenceNumbers#UNASSIGNED_SEQ_NO} if all_ops should be sent_@param requiredSeqNoRangeStart    the lower sequence number of the required range (ending with endingSeqNo)_@param endingSeqNo                the highest sequence number that should be sent_@param snapshot                   a snapshot of the translog_@param maxSeenAutoIdTimestamp     the max auto_id_timestamp of append-only requests on the primary_@param maxSeqNoOfUpdatesOrDeletes the max seq_no of updates or deletes on the primary after these operations were executed on it._@return the send snapshot result;SendSnapshotResult phase2(long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo, Translog.Snapshot snapshot,_                              long maxSeenAutoIdTimestamp, long maxSeqNoOfUpdatesOrDeletes) throws IOException {_        assert requiredSeqNoRangeStart <= endingSeqNo + 1:_            "requiredSeqNoRangeStart " + requiredSeqNoRangeStart + " is larger than endingSeqNo " + endingSeqNo__        assert startingSeqNo <= requiredSeqNoRangeStart :_            "startingSeqNo " + startingSeqNo + " is larger than requiredSeqNoRangeStart " + requiredSeqNoRangeStart__        if (shard.state() == IndexShardState.CLOSED) {_            throw new IndexShardClosedException(request.shardId())__        }__        final StopWatch stopWatch = new StopWatch().start()___        logger.trace("recovery [phase2]: sending transaction log operations (seq# from [" +  startingSeqNo  + "], " +_            "required [" + requiredSeqNoRangeStart + ":" + endingSeqNo + "]")___        int ops = 0__        long size = 0__        int skippedOps = 0__        int totalSentOps = 0__        final AtomicLong targetLocalCheckpoint = new AtomicLong(SequenceNumbers.UNASSIGNED_SEQ_NO)__        final List<Translog.Operation> operations = new ArrayList<>()__        final LocalCheckpointTracker requiredOpsTracker = new LocalCheckpointTracker(endingSeqNo, requiredSeqNoRangeStart - 1)___        final int expectedTotalOps = snapshot.totalOperations()__        if (expectedTotalOps == 0) {_            logger.trace("no translog operations to send")__        }__        final CancellableThreads.IOInterruptible sendBatch = () -> {_            final long targetCheckpoint = recoveryTarget.indexTranslogOperations(_                operations, expectedTotalOps, maxSeenAutoIdTimestamp, maxSeqNoOfUpdatesOrDeletes)__            targetLocalCheckpoint.set(targetCheckpoint)__        }___        _        Translog.Operation operation__        while ((operation = snapshot.next()) != null) {_            if (shard.state() == IndexShardState.CLOSED) {_                throw new IndexShardClosedException(request.shardId())__            }_            cancellableThreads.checkForCancel()___            final long seqNo = operation.seqNo()__            if (seqNo < startingSeqNo || seqNo > endingSeqNo) {_                skippedOps++__                continue__            }_            operations.add(operation)__            ops++__            size += operation.estimateSize()__            totalSentOps++__            requiredOpsTracker.markSeqNoAsCompleted(seqNo)___            _            if (size >= chunkSizeInBytes) {_                cancellableThreads.executeIO(sendBatch)__                logger.trace("sent batch of [{}][{}] (total: [{}]) translog operations", ops, new ByteSizeValue(size), expectedTotalOps)__                ops = 0__                size = 0__                operations.clear()__            }_        }__        if (!operations.isEmpty() || totalSentOps == 0) {_            _            cancellableThreads.executeIO(sendBatch)__        }__        assert expectedTotalOps == snapshot.skippedOperations() + skippedOps + totalSentOps_            : String.format(Locale.ROOT, "expected total [%d], overridden [%d], skipped [%d], total sent [%d]",_            expectedTotalOps, snapshot.skippedOperations(), skippedOps, totalSentOps)___        if (requiredOpsTracker.getCheckpoint() < endingSeqNo) {_            throw new IllegalStateException("translog replay failed to cover required sequence numbers" +_                " (required range [" + requiredSeqNoRangeStart + ":" + endingSeqNo + "). first missing op is ["_                + (requiredOpsTracker.getCheckpoint() + 1) + "]")__        }__        logger.trace("sent final batch of [{}][{}] (total: [{}]) translog operations", ops, new ByteSizeValue(size), expectedTotalOps)___        stopWatch.stop()__        final TimeValue tookTime = stopWatch.totalTime()__        logger.trace("recovery [phase2]: took [{}]", tookTime)__        return new SendSnapshotResult(targetLocalCheckpoint.get(), totalSentOps, tookTime)__    };perform,phase,two,of,the,recovery,process,p,phase,two,uses,a,snapshot,of,the,current,translog,without,acquiring,the,write,lock,however,the,translog,snapshot,is,point,in,time,view,of,the,translog,it,then,sends,each,translog,operation,to,the,target,node,so,it,can,be,replayed,into,the,new,shard,param,starting,seq,no,the,sequence,number,to,start,recovery,from,or,link,sequence,numbers,if,all,ops,should,be,sent,param,required,seq,no,range,start,the,lower,sequence,number,of,the,required,range,ending,with,ending,seq,no,param,ending,seq,no,the,highest,sequence,number,that,should,be,sent,param,snapshot,a,snapshot,of,the,translog,param,max,seen,auto,id,timestamp,the,max,of,append,only,requests,on,the,primary,param,max,seq,no,of,updates,or,deletes,the,max,of,updates,or,deletes,on,the,primary,after,these,operations,were,executed,on,it,return,the,send,snapshot,result;send,snapshot,result,phase2,long,starting,seq,no,long,required,seq,no,range,start,long,ending,seq,no,translog,snapshot,snapshot,long,max,seen,auto,id,timestamp,long,max,seq,no,of,updates,or,deletes,throws,ioexception,assert,required,seq,no,range,start,ending,seq,no,1,required,seq,no,range,start,required,seq,no,range,start,is,larger,than,ending,seq,no,ending,seq,no,assert,starting,seq,no,required,seq,no,range,start,starting,seq,no,starting,seq,no,is,larger,than,required,seq,no,range,start,required,seq,no,range,start,if,shard,state,index,shard,state,closed,throw,new,index,shard,closed,exception,request,shard,id,final,stop,watch,stop,watch,new,stop,watch,start,logger,trace,recovery,phase2,sending,transaction,log,operations,seq,from,starting,seq,no,required,required,seq,no,range,start,ending,seq,no,int,ops,0,long,size,0,int,skipped,ops,0,int,total,sent,ops,0,final,atomic,long,target,local,checkpoint,new,atomic,long,sequence,numbers,final,list,translog,operation,operations,new,array,list,final,local,checkpoint,tracker,required,ops,tracker,new,local,checkpoint,tracker,ending,seq,no,required,seq,no,range,start,1,final,int,expected,total,ops,snapshot,total,operations,if,expected,total,ops,0,logger,trace,no,translog,operations,to,send,final,cancellable,threads,iointerruptible,send,batch,final,long,target,checkpoint,recovery,target,index,translog,operations,operations,expected,total,ops,max,seen,auto,id,timestamp,max,seq,no,of,updates,or,deletes,target,local,checkpoint,set,target,checkpoint,translog,operation,operation,while,operation,snapshot,next,null,if,shard,state,index,shard,state,closed,throw,new,index,shard,closed,exception,request,shard,id,cancellable,threads,check,for,cancel,final,long,seq,no,operation,seq,no,if,seq,no,starting,seq,no,seq,no,ending,seq,no,skipped,ops,continue,operations,add,operation,ops,size,operation,estimate,size,total,sent,ops,required,ops,tracker,mark,seq,no,as,completed,seq,no,if,size,chunk,size,in,bytes,cancellable,threads,execute,io,send,batch,logger,trace,sent,batch,of,total,translog,operations,ops,new,byte,size,value,size,expected,total,ops,ops,0,size,0,operations,clear,if,operations,is,empty,total,sent,ops,0,cancellable,threads,execute,io,send,batch,assert,expected,total,ops,snapshot,skipped,operations,skipped,ops,total,sent,ops,string,format,locale,root,expected,total,d,overridden,d,skipped,d,total,sent,d,expected,total,ops,snapshot,skipped,operations,skipped,ops,total,sent,ops,if,required,ops,tracker,get,checkpoint,ending,seq,no,throw,new,illegal,state,exception,translog,replay,failed,to,cover,required,sequence,numbers,required,range,required,seq,no,range,start,ending,seq,no,first,missing,op,is,required,ops,tracker,get,checkpoint,1,logger,trace,sent,final,batch,of,total,translog,operations,ops,new,byte,size,value,size,expected,total,ops,stop,watch,stop,final,time,value,took,time,stop,watch,total,time,logger,trace,recovery,phase2,took,took,time,return,new,send,snapshot,result,target,local,checkpoint,get,total,sent,ops,took,time
RecoverySourceHandler -> SendSnapshotResult phase2(long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo, Translog.Snapshot snapshot,                               long maxSeenAutoIdTimestamp, long maxSeqNoOfUpdatesOrDeletes) throws IOException;1547496886;Perform phase two of the recovery process._<p>_Phase two uses a snapshot of the current translog *without* acquiring the write lock (however, the translog snapshot is_point-in-time view of the translog). It then sends each translog operation to the target node so it can be replayed into the new_shard.__@param startingSeqNo              the sequence number to start recovery from, or {@link SequenceNumbers#UNASSIGNED_SEQ_NO} if all_ops should be sent_@param requiredSeqNoRangeStart    the lower sequence number of the required range (ending with endingSeqNo)_@param endingSeqNo                the highest sequence number that should be sent_@param snapshot                   a snapshot of the translog_@param maxSeenAutoIdTimestamp     the max auto_id_timestamp of append-only requests on the primary_@param maxSeqNoOfUpdatesOrDeletes the max seq_no of updates or deletes on the primary after these operations were executed on it._@return the send snapshot result;SendSnapshotResult phase2(long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo, Translog.Snapshot snapshot,_                              long maxSeenAutoIdTimestamp, long maxSeqNoOfUpdatesOrDeletes) throws IOException {_        assert requiredSeqNoRangeStart <= endingSeqNo + 1:_            "requiredSeqNoRangeStart " + requiredSeqNoRangeStart + " is larger than endingSeqNo " + endingSeqNo__        assert startingSeqNo <= requiredSeqNoRangeStart :_            "startingSeqNo " + startingSeqNo + " is larger than requiredSeqNoRangeStart " + requiredSeqNoRangeStart__        if (shard.state() == IndexShardState.CLOSED) {_            throw new IndexShardClosedException(request.shardId())__        }__        final StopWatch stopWatch = new StopWatch().start()___        logger.trace("recovery [phase2]: sending transaction log operations (seq# from [" +  startingSeqNo  + "], " +_            "required [" + requiredSeqNoRangeStart + ":" + endingSeqNo + "]")___        int ops = 0__        long size = 0__        int skippedOps = 0__        int totalSentOps = 0__        final AtomicLong targetLocalCheckpoint = new AtomicLong(SequenceNumbers.UNASSIGNED_SEQ_NO)__        final List<Translog.Operation> operations = new ArrayList<>()__        final LocalCheckpointTracker requiredOpsTracker = new LocalCheckpointTracker(endingSeqNo, requiredSeqNoRangeStart - 1)___        final int expectedTotalOps = snapshot.totalOperations()__        if (expectedTotalOps == 0) {_            logger.trace("no translog operations to send")__        }__        final CancellableThreads.IOInterruptible sendBatch = () -> {_            final long targetCheckpoint = recoveryTarget.indexTranslogOperations(_                operations, expectedTotalOps, maxSeenAutoIdTimestamp, maxSeqNoOfUpdatesOrDeletes)__            targetLocalCheckpoint.set(targetCheckpoint)__        }___        _        Translog.Operation operation__        while ((operation = snapshot.next()) != null) {_            if (shard.state() == IndexShardState.CLOSED) {_                throw new IndexShardClosedException(request.shardId())__            }_            cancellableThreads.checkForCancel()___            final long seqNo = operation.seqNo()__            if (seqNo < startingSeqNo || seqNo > endingSeqNo) {_                skippedOps++__                continue__            }_            operations.add(operation)__            ops++__            size += operation.estimateSize()__            totalSentOps++__            requiredOpsTracker.markSeqNoAsCompleted(seqNo)___            _            if (size >= chunkSizeInBytes) {_                cancellableThreads.executeIO(sendBatch)__                logger.trace("sent batch of [{}][{}] (total: [{}]) translog operations", ops, new ByteSizeValue(size), expectedTotalOps)__                ops = 0__                size = 0__                operations.clear()__            }_        }__        if (!operations.isEmpty() || totalSentOps == 0) {_            _            cancellableThreads.executeIO(sendBatch)__        }__        assert expectedTotalOps == snapshot.skippedOperations() + skippedOps + totalSentOps_            : String.format(Locale.ROOT, "expected total [%d], overridden [%d], skipped [%d], total sent [%d]",_            expectedTotalOps, snapshot.skippedOperations(), skippedOps, totalSentOps)___        if (requiredOpsTracker.getCheckpoint() < endingSeqNo) {_            throw new IllegalStateException("translog replay failed to cover required sequence numbers" +_                " (required range [" + requiredSeqNoRangeStart + ":" + endingSeqNo + "). first missing op is ["_                + (requiredOpsTracker.getCheckpoint() + 1) + "]")__        }__        logger.trace("sent final batch of [{}][{}] (total: [{}]) translog operations", ops, new ByteSizeValue(size), expectedTotalOps)___        stopWatch.stop()__        final TimeValue tookTime = stopWatch.totalTime()__        logger.trace("recovery [phase2]: took [{}]", tookTime)__        return new SendSnapshotResult(targetLocalCheckpoint.get(), totalSentOps, tookTime)__    };perform,phase,two,of,the,recovery,process,p,phase,two,uses,a,snapshot,of,the,current,translog,without,acquiring,the,write,lock,however,the,translog,snapshot,is,point,in,time,view,of,the,translog,it,then,sends,each,translog,operation,to,the,target,node,so,it,can,be,replayed,into,the,new,shard,param,starting,seq,no,the,sequence,number,to,start,recovery,from,or,link,sequence,numbers,if,all,ops,should,be,sent,param,required,seq,no,range,start,the,lower,sequence,number,of,the,required,range,ending,with,ending,seq,no,param,ending,seq,no,the,highest,sequence,number,that,should,be,sent,param,snapshot,a,snapshot,of,the,translog,param,max,seen,auto,id,timestamp,the,max,of,append,only,requests,on,the,primary,param,max,seq,no,of,updates,or,deletes,the,max,of,updates,or,deletes,on,the,primary,after,these,operations,were,executed,on,it,return,the,send,snapshot,result;send,snapshot,result,phase2,long,starting,seq,no,long,required,seq,no,range,start,long,ending,seq,no,translog,snapshot,snapshot,long,max,seen,auto,id,timestamp,long,max,seq,no,of,updates,or,deletes,throws,ioexception,assert,required,seq,no,range,start,ending,seq,no,1,required,seq,no,range,start,required,seq,no,range,start,is,larger,than,ending,seq,no,ending,seq,no,assert,starting,seq,no,required,seq,no,range,start,starting,seq,no,starting,seq,no,is,larger,than,required,seq,no,range,start,required,seq,no,range,start,if,shard,state,index,shard,state,closed,throw,new,index,shard,closed,exception,request,shard,id,final,stop,watch,stop,watch,new,stop,watch,start,logger,trace,recovery,phase2,sending,transaction,log,operations,seq,from,starting,seq,no,required,required,seq,no,range,start,ending,seq,no,int,ops,0,long,size,0,int,skipped,ops,0,int,total,sent,ops,0,final,atomic,long,target,local,checkpoint,new,atomic,long,sequence,numbers,final,list,translog,operation,operations,new,array,list,final,local,checkpoint,tracker,required,ops,tracker,new,local,checkpoint,tracker,ending,seq,no,required,seq,no,range,start,1,final,int,expected,total,ops,snapshot,total,operations,if,expected,total,ops,0,logger,trace,no,translog,operations,to,send,final,cancellable,threads,iointerruptible,send,batch,final,long,target,checkpoint,recovery,target,index,translog,operations,operations,expected,total,ops,max,seen,auto,id,timestamp,max,seq,no,of,updates,or,deletes,target,local,checkpoint,set,target,checkpoint,translog,operation,operation,while,operation,snapshot,next,null,if,shard,state,index,shard,state,closed,throw,new,index,shard,closed,exception,request,shard,id,cancellable,threads,check,for,cancel,final,long,seq,no,operation,seq,no,if,seq,no,starting,seq,no,seq,no,ending,seq,no,skipped,ops,continue,operations,add,operation,ops,size,operation,estimate,size,total,sent,ops,required,ops,tracker,mark,seq,no,as,completed,seq,no,if,size,chunk,size,in,bytes,cancellable,threads,execute,io,send,batch,logger,trace,sent,batch,of,total,translog,operations,ops,new,byte,size,value,size,expected,total,ops,ops,0,size,0,operations,clear,if,operations,is,empty,total,sent,ops,0,cancellable,threads,execute,io,send,batch,assert,expected,total,ops,snapshot,skipped,operations,skipped,ops,total,sent,ops,string,format,locale,root,expected,total,d,overridden,d,skipped,d,total,sent,d,expected,total,ops,snapshot,skipped,operations,skipped,ops,total,sent,ops,if,required,ops,tracker,get,checkpoint,ending,seq,no,throw,new,illegal,state,exception,translog,replay,failed,to,cover,required,sequence,numbers,required,range,required,seq,no,range,start,ending,seq,no,first,missing,op,is,required,ops,tracker,get,checkpoint,1,logger,trace,sent,final,batch,of,total,translog,operations,ops,new,byte,size,value,size,expected,total,ops,stop,watch,stop,final,time,value,took,time,stop,watch,total,time,logger,trace,recovery,phase2,took,took,time,return,new,send,snapshot,result,target,local,checkpoint,get,total,sent,ops,took,time
RecoverySourceHandler -> SendSnapshotResult phase2(long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo, Translog.Snapshot snapshot,                               long maxSeenAutoIdTimestamp, long maxSeqNoOfUpdatesOrDeletes) throws IOException;1547508054;Perform phase two of the recovery process._<p>_Phase two uses a snapshot of the current translog *without* acquiring the write lock (however, the translog snapshot is_point-in-time view of the translog). It then sends each translog operation to the target node so it can be replayed into the new_shard.__@param startingSeqNo              the sequence number to start recovery from, or {@link SequenceNumbers#UNASSIGNED_SEQ_NO} if all_ops should be sent_@param requiredSeqNoRangeStart    the lower sequence number of the required range (ending with endingSeqNo)_@param endingSeqNo                the highest sequence number that should be sent_@param snapshot                   a snapshot of the translog_@param maxSeenAutoIdTimestamp     the max auto_id_timestamp of append-only requests on the primary_@param maxSeqNoOfUpdatesOrDeletes the max seq_no of updates or deletes on the primary after these operations were executed on it._@return the send snapshot result;SendSnapshotResult phase2(long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo, Translog.Snapshot snapshot,_                              long maxSeenAutoIdTimestamp, long maxSeqNoOfUpdatesOrDeletes) throws IOException {_        assert requiredSeqNoRangeStart <= endingSeqNo + 1:_            "requiredSeqNoRangeStart " + requiredSeqNoRangeStart + " is larger than endingSeqNo " + endingSeqNo__        assert startingSeqNo <= requiredSeqNoRangeStart :_            "startingSeqNo " + startingSeqNo + " is larger than requiredSeqNoRangeStart " + requiredSeqNoRangeStart__        if (shard.state() == IndexShardState.CLOSED) {_            throw new IndexShardClosedException(request.shardId())__        }__        final StopWatch stopWatch = new StopWatch().start()___        logger.trace("recovery [phase2]: sending transaction log operations (seq# from [" +  startingSeqNo  + "], " +_            "required [" + requiredSeqNoRangeStart + ":" + endingSeqNo + "]")___        int ops = 0__        long size = 0__        int skippedOps = 0__        int totalSentOps = 0__        final AtomicLong targetLocalCheckpoint = new AtomicLong(SequenceNumbers.UNASSIGNED_SEQ_NO)__        final List<Translog.Operation> operations = new ArrayList<>()__        final LocalCheckpointTracker requiredOpsTracker = new LocalCheckpointTracker(endingSeqNo, requiredSeqNoRangeStart - 1)___        final int expectedTotalOps = snapshot.totalOperations()__        if (expectedTotalOps == 0) {_            logger.trace("no translog operations to send")__        }__        final CancellableThreads.IOInterruptible sendBatch = () -> {_            final long targetCheckpoint = recoveryTarget.indexTranslogOperations(_                operations, expectedTotalOps, maxSeenAutoIdTimestamp, maxSeqNoOfUpdatesOrDeletes)__            targetLocalCheckpoint.set(targetCheckpoint)__        }___        _        Translog.Operation operation__        while ((operation = snapshot.next()) != null) {_            if (shard.state() == IndexShardState.CLOSED) {_                throw new IndexShardClosedException(request.shardId())__            }_            cancellableThreads.checkForCancel()___            final long seqNo = operation.seqNo()__            if (seqNo < startingSeqNo || seqNo > endingSeqNo) {_                skippedOps++__                continue__            }_            operations.add(operation)__            ops++__            size += operation.estimateSize()__            totalSentOps++__            requiredOpsTracker.markSeqNoAsCompleted(seqNo)___            _            if (size >= chunkSizeInBytes) {_                cancellableThreads.executeIO(sendBatch)__                logger.trace("sent batch of [{}][{}] (total: [{}]) translog operations", ops, new ByteSizeValue(size), expectedTotalOps)__                ops = 0__                size = 0__                operations.clear()__            }_        }__        if (!operations.isEmpty() || totalSentOps == 0) {_            _            cancellableThreads.executeIO(sendBatch)__        }__        assert expectedTotalOps == snapshot.skippedOperations() + skippedOps + totalSentOps_            : String.format(Locale.ROOT, "expected total [%d], overridden [%d], skipped [%d], total sent [%d]",_            expectedTotalOps, snapshot.skippedOperations(), skippedOps, totalSentOps)___        if (requiredOpsTracker.getCheckpoint() < endingSeqNo) {_            throw new IllegalStateException("translog replay failed to cover required sequence numbers" +_                " (required range [" + requiredSeqNoRangeStart + ":" + endingSeqNo + "). first missing op is ["_                + (requiredOpsTracker.getCheckpoint() + 1) + "]")__        }__        logger.trace("sent final batch of [{}][{}] (total: [{}]) translog operations", ops, new ByteSizeValue(size), expectedTotalOps)___        stopWatch.stop()__        final TimeValue tookTime = stopWatch.totalTime()__        logger.trace("recovery [phase2]: took [{}]", tookTime)__        return new SendSnapshotResult(targetLocalCheckpoint.get(), totalSentOps, tookTime)__    };perform,phase,two,of,the,recovery,process,p,phase,two,uses,a,snapshot,of,the,current,translog,without,acquiring,the,write,lock,however,the,translog,snapshot,is,point,in,time,view,of,the,translog,it,then,sends,each,translog,operation,to,the,target,node,so,it,can,be,replayed,into,the,new,shard,param,starting,seq,no,the,sequence,number,to,start,recovery,from,or,link,sequence,numbers,if,all,ops,should,be,sent,param,required,seq,no,range,start,the,lower,sequence,number,of,the,required,range,ending,with,ending,seq,no,param,ending,seq,no,the,highest,sequence,number,that,should,be,sent,param,snapshot,a,snapshot,of,the,translog,param,max,seen,auto,id,timestamp,the,max,of,append,only,requests,on,the,primary,param,max,seq,no,of,updates,or,deletes,the,max,of,updates,or,deletes,on,the,primary,after,these,operations,were,executed,on,it,return,the,send,snapshot,result;send,snapshot,result,phase2,long,starting,seq,no,long,required,seq,no,range,start,long,ending,seq,no,translog,snapshot,snapshot,long,max,seen,auto,id,timestamp,long,max,seq,no,of,updates,or,deletes,throws,ioexception,assert,required,seq,no,range,start,ending,seq,no,1,required,seq,no,range,start,required,seq,no,range,start,is,larger,than,ending,seq,no,ending,seq,no,assert,starting,seq,no,required,seq,no,range,start,starting,seq,no,starting,seq,no,is,larger,than,required,seq,no,range,start,required,seq,no,range,start,if,shard,state,index,shard,state,closed,throw,new,index,shard,closed,exception,request,shard,id,final,stop,watch,stop,watch,new,stop,watch,start,logger,trace,recovery,phase2,sending,transaction,log,operations,seq,from,starting,seq,no,required,required,seq,no,range,start,ending,seq,no,int,ops,0,long,size,0,int,skipped,ops,0,int,total,sent,ops,0,final,atomic,long,target,local,checkpoint,new,atomic,long,sequence,numbers,final,list,translog,operation,operations,new,array,list,final,local,checkpoint,tracker,required,ops,tracker,new,local,checkpoint,tracker,ending,seq,no,required,seq,no,range,start,1,final,int,expected,total,ops,snapshot,total,operations,if,expected,total,ops,0,logger,trace,no,translog,operations,to,send,final,cancellable,threads,iointerruptible,send,batch,final,long,target,checkpoint,recovery,target,index,translog,operations,operations,expected,total,ops,max,seen,auto,id,timestamp,max,seq,no,of,updates,or,deletes,target,local,checkpoint,set,target,checkpoint,translog,operation,operation,while,operation,snapshot,next,null,if,shard,state,index,shard,state,closed,throw,new,index,shard,closed,exception,request,shard,id,cancellable,threads,check,for,cancel,final,long,seq,no,operation,seq,no,if,seq,no,starting,seq,no,seq,no,ending,seq,no,skipped,ops,continue,operations,add,operation,ops,size,operation,estimate,size,total,sent,ops,required,ops,tracker,mark,seq,no,as,completed,seq,no,if,size,chunk,size,in,bytes,cancellable,threads,execute,io,send,batch,logger,trace,sent,batch,of,total,translog,operations,ops,new,byte,size,value,size,expected,total,ops,ops,0,size,0,operations,clear,if,operations,is,empty,total,sent,ops,0,cancellable,threads,execute,io,send,batch,assert,expected,total,ops,snapshot,skipped,operations,skipped,ops,total,sent,ops,string,format,locale,root,expected,total,d,overridden,d,skipped,d,total,sent,d,expected,total,ops,snapshot,skipped,operations,skipped,ops,total,sent,ops,if,required,ops,tracker,get,checkpoint,ending,seq,no,throw,new,illegal,state,exception,translog,replay,failed,to,cover,required,sequence,numbers,required,range,required,seq,no,range,start,ending,seq,no,first,missing,op,is,required,ops,tracker,get,checkpoint,1,logger,trace,sent,final,batch,of,total,translog,operations,ops,new,byte,size,value,size,expected,total,ops,stop,watch,stop,final,time,value,took,time,stop,watch,total,time,logger,trace,recovery,phase2,took,took,time,return,new,send,snapshot,result,target,local,checkpoint,get,total,sent,ops,took,time
RecoverySourceHandler -> SendSnapshotResult phase2(long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo, Translog.Snapshot snapshot,                               long maxSeenAutoIdTimestamp, long maxSeqNoOfUpdatesOrDeletes) throws IOException;1547569135;Perform phase two of the recovery process._<p>_Phase two uses a snapshot of the current translog *without* acquiring the write lock (however, the translog snapshot is_point-in-time view of the translog). It then sends each translog operation to the target node so it can be replayed into the new_shard.__@param startingSeqNo              the sequence number to start recovery from, or {@link SequenceNumbers#UNASSIGNED_SEQ_NO} if all_ops should be sent_@param requiredSeqNoRangeStart    the lower sequence number of the required range (ending with endingSeqNo)_@param endingSeqNo                the highest sequence number that should be sent_@param snapshot                   a snapshot of the translog_@param maxSeenAutoIdTimestamp     the max auto_id_timestamp of append-only requests on the primary_@param maxSeqNoOfUpdatesOrDeletes the max seq_no of updates or deletes on the primary after these operations were executed on it._@return the send snapshot result;SendSnapshotResult phase2(long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo, Translog.Snapshot snapshot,_                              long maxSeenAutoIdTimestamp, long maxSeqNoOfUpdatesOrDeletes) throws IOException {_        assert requiredSeqNoRangeStart <= endingSeqNo + 1:_            "requiredSeqNoRangeStart " + requiredSeqNoRangeStart + " is larger than endingSeqNo " + endingSeqNo__        assert startingSeqNo <= requiredSeqNoRangeStart :_            "startingSeqNo " + startingSeqNo + " is larger than requiredSeqNoRangeStart " + requiredSeqNoRangeStart__        if (shard.state() == IndexShardState.CLOSED) {_            throw new IndexShardClosedException(request.shardId())__        }__        final StopWatch stopWatch = new StopWatch().start()___        logger.trace("recovery [phase2]: sending transaction log operations (seq# from [" +  startingSeqNo  + "], " +_            "required [" + requiredSeqNoRangeStart + ":" + endingSeqNo + "]")___        int ops = 0__        long size = 0__        int skippedOps = 0__        int totalSentOps = 0__        final AtomicLong targetLocalCheckpoint = new AtomicLong(SequenceNumbers.UNASSIGNED_SEQ_NO)__        final List<Translog.Operation> operations = new ArrayList<>()__        final LocalCheckpointTracker requiredOpsTracker = new LocalCheckpointTracker(endingSeqNo, requiredSeqNoRangeStart - 1)___        final int expectedTotalOps = snapshot.totalOperations()__        if (expectedTotalOps == 0) {_            logger.trace("no translog operations to send")__        }__        final CancellableThreads.IOInterruptible sendBatch = () -> {_            final long targetCheckpoint = recoveryTarget.indexTranslogOperations(_                operations, expectedTotalOps, maxSeenAutoIdTimestamp, maxSeqNoOfUpdatesOrDeletes)__            targetLocalCheckpoint.set(targetCheckpoint)__        }___        _        Translog.Operation operation__        while ((operation = snapshot.next()) != null) {_            if (shard.state() == IndexShardState.CLOSED) {_                throw new IndexShardClosedException(request.shardId())__            }_            cancellableThreads.checkForCancel()___            final long seqNo = operation.seqNo()__            if (seqNo < startingSeqNo || seqNo > endingSeqNo) {_                skippedOps++__                continue__            }_            operations.add(operation)__            ops++__            size += operation.estimateSize()__            totalSentOps++__            requiredOpsTracker.markSeqNoAsCompleted(seqNo)___            _            if (size >= chunkSizeInBytes) {_                cancellableThreads.executeIO(sendBatch)__                logger.trace("sent batch of [{}][{}] (total: [{}]) translog operations", ops, new ByteSizeValue(size), expectedTotalOps)__                ops = 0__                size = 0__                operations.clear()__            }_        }__        if (!operations.isEmpty() || totalSentOps == 0) {_            _            cancellableThreads.executeIO(sendBatch)__        }__        assert expectedTotalOps == snapshot.skippedOperations() + skippedOps + totalSentOps_            : String.format(Locale.ROOT, "expected total [%d], overridden [%d], skipped [%d], total sent [%d]",_            expectedTotalOps, snapshot.skippedOperations(), skippedOps, totalSentOps)___        if (requiredOpsTracker.getCheckpoint() < endingSeqNo) {_            throw new IllegalStateException("translog replay failed to cover required sequence numbers" +_                " (required range [" + requiredSeqNoRangeStart + ":" + endingSeqNo + "). first missing op is ["_                + (requiredOpsTracker.getCheckpoint() + 1) + "]")__        }__        logger.trace("sent final batch of [{}][{}] (total: [{}]) translog operations", ops, new ByteSizeValue(size), expectedTotalOps)___        stopWatch.stop()__        final TimeValue tookTime = stopWatch.totalTime()__        logger.trace("recovery [phase2]: took [{}]", tookTime)__        return new SendSnapshotResult(targetLocalCheckpoint.get(), totalSentOps, tookTime)__    };perform,phase,two,of,the,recovery,process,p,phase,two,uses,a,snapshot,of,the,current,translog,without,acquiring,the,write,lock,however,the,translog,snapshot,is,point,in,time,view,of,the,translog,it,then,sends,each,translog,operation,to,the,target,node,so,it,can,be,replayed,into,the,new,shard,param,starting,seq,no,the,sequence,number,to,start,recovery,from,or,link,sequence,numbers,if,all,ops,should,be,sent,param,required,seq,no,range,start,the,lower,sequence,number,of,the,required,range,ending,with,ending,seq,no,param,ending,seq,no,the,highest,sequence,number,that,should,be,sent,param,snapshot,a,snapshot,of,the,translog,param,max,seen,auto,id,timestamp,the,max,of,append,only,requests,on,the,primary,param,max,seq,no,of,updates,or,deletes,the,max,of,updates,or,deletes,on,the,primary,after,these,operations,were,executed,on,it,return,the,send,snapshot,result;send,snapshot,result,phase2,long,starting,seq,no,long,required,seq,no,range,start,long,ending,seq,no,translog,snapshot,snapshot,long,max,seen,auto,id,timestamp,long,max,seq,no,of,updates,or,deletes,throws,ioexception,assert,required,seq,no,range,start,ending,seq,no,1,required,seq,no,range,start,required,seq,no,range,start,is,larger,than,ending,seq,no,ending,seq,no,assert,starting,seq,no,required,seq,no,range,start,starting,seq,no,starting,seq,no,is,larger,than,required,seq,no,range,start,required,seq,no,range,start,if,shard,state,index,shard,state,closed,throw,new,index,shard,closed,exception,request,shard,id,final,stop,watch,stop,watch,new,stop,watch,start,logger,trace,recovery,phase2,sending,transaction,log,operations,seq,from,starting,seq,no,required,required,seq,no,range,start,ending,seq,no,int,ops,0,long,size,0,int,skipped,ops,0,int,total,sent,ops,0,final,atomic,long,target,local,checkpoint,new,atomic,long,sequence,numbers,final,list,translog,operation,operations,new,array,list,final,local,checkpoint,tracker,required,ops,tracker,new,local,checkpoint,tracker,ending,seq,no,required,seq,no,range,start,1,final,int,expected,total,ops,snapshot,total,operations,if,expected,total,ops,0,logger,trace,no,translog,operations,to,send,final,cancellable,threads,iointerruptible,send,batch,final,long,target,checkpoint,recovery,target,index,translog,operations,operations,expected,total,ops,max,seen,auto,id,timestamp,max,seq,no,of,updates,or,deletes,target,local,checkpoint,set,target,checkpoint,translog,operation,operation,while,operation,snapshot,next,null,if,shard,state,index,shard,state,closed,throw,new,index,shard,closed,exception,request,shard,id,cancellable,threads,check,for,cancel,final,long,seq,no,operation,seq,no,if,seq,no,starting,seq,no,seq,no,ending,seq,no,skipped,ops,continue,operations,add,operation,ops,size,operation,estimate,size,total,sent,ops,required,ops,tracker,mark,seq,no,as,completed,seq,no,if,size,chunk,size,in,bytes,cancellable,threads,execute,io,send,batch,logger,trace,sent,batch,of,total,translog,operations,ops,new,byte,size,value,size,expected,total,ops,ops,0,size,0,operations,clear,if,operations,is,empty,total,sent,ops,0,cancellable,threads,execute,io,send,batch,assert,expected,total,ops,snapshot,skipped,operations,skipped,ops,total,sent,ops,string,format,locale,root,expected,total,d,overridden,d,skipped,d,total,sent,d,expected,total,ops,snapshot,skipped,operations,skipped,ops,total,sent,ops,if,required,ops,tracker,get,checkpoint,ending,seq,no,throw,new,illegal,state,exception,translog,replay,failed,to,cover,required,sequence,numbers,required,range,required,seq,no,range,start,ending,seq,no,first,missing,op,is,required,ops,tracker,get,checkpoint,1,logger,trace,sent,final,batch,of,total,translog,operations,ops,new,byte,size,value,size,expected,total,ops,stop,watch,stop,final,time,value,took,time,stop,watch,total,time,logger,trace,recovery,phase2,took,took,time,return,new,send,snapshot,result,target,local,checkpoint,get,total,sent,ops,took,time
RecoverySourceHandler -> public void phase1(final IndexCommit snapshot, final Supplier<Integer> translogOps);1524684173;Perform phase1 of the recovery operations. Once this {@link IndexCommit}_snapshot has been performed no commit operations (files being fsync'd)_are effectively allowed on this index until all recovery phases are done_<p>_Phase1 examines the segment files on the target node and copies over the_segments that are missing. Only segments that have the same size and_checksum can be reused;public void phase1(final IndexCommit snapshot, final Supplier<Integer> translogOps) {_        cancellableThreads.checkForCancel()__        _        long totalSize = 0__        _        long existingTotalSize = 0__        final Store store = shard.store()__        store.incRef()__        try {_            StopWatch stopWatch = new StopWatch().start()__            final Store.MetadataSnapshot recoverySourceMetadata__            try {_                recoverySourceMetadata = store.getMetadata(snapshot)__            } catch (CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {_                shard.failShard("recovery", ex)__                throw ex__            }_            for (String name : snapshot.getFileNames()) {_                final StoreFileMetaData md = recoverySourceMetadata.get(name)__                if (md == null) {_                    logger.info("Snapshot differs from actual index for file: {} meta: {}", name, recoverySourceMetadata.asMap())__                    throw new CorruptIndexException("Snapshot differs from actual index - maybe index was removed metadata has " +_                            recoverySourceMetadata.asMap().size() + " files", name)__                }_            }_            _            _            _            String recoverySourceSyncId = recoverySourceMetadata.getSyncId()__            String recoveryTargetSyncId = request.metadataSnapshot().getSyncId()__            final boolean recoverWithSyncId = recoverySourceSyncId != null &&_                    recoverySourceSyncId.equals(recoveryTargetSyncId)__            if (recoverWithSyncId) {_                final long numDocsTarget = request.metadataSnapshot().getNumDocs()__                final long numDocsSource = recoverySourceMetadata.getNumDocs()__                if (numDocsTarget != numDocsSource) {_                    throw new IllegalStateException("try to recover " + request.shardId() + " from primary shard with sync id but number " +_                            "of docs differ: " + numDocsSource + " (" + request.sourceNode().getName() + ", primary) vs " + numDocsTarget_                            + "(" + request.targetNode().getName() + ")")__                }_                _                _                logger.trace("skipping [phase1]- identical sync id [{}] found on both source and target", recoverySourceSyncId)__            } else {_                final Store.RecoveryDiff diff = recoverySourceMetadata.recoveryDiff(request.metadataSnapshot())__                for (StoreFileMetaData md : diff.identical) {_                    response.phase1ExistingFileNames.add(md.name())__                    response.phase1ExistingFileSizes.add(md.length())__                    existingTotalSize += md.length()__                    if (logger.isTraceEnabled()) {_                        logger.trace("recovery [phase1]: not recovering [{}], exist in local store and has checksum [{}]," +_                                        " size [{}]", md.name(), md.checksum(), md.length())__                    }_                    totalSize += md.length()__                }_                List<StoreFileMetaData> phase1Files = new ArrayList<>(diff.different.size() + diff.missing.size())__                phase1Files.addAll(diff.different)__                phase1Files.addAll(diff.missing)__                for (StoreFileMetaData md : phase1Files) {_                    if (request.metadataSnapshot().asMap().containsKey(md.name())) {_                        logger.trace("recovery [phase1]: recovering [{}], exists in local store, but is different: remote [{}], local [{}]",_                            md.name(), request.metadataSnapshot().asMap().get(md.name()), md)__                    } else {_                        logger.trace("recovery [phase1]: recovering [{}], does not exist in remote", md.name())__                    }_                    response.phase1FileNames.add(md.name())__                    response.phase1FileSizes.add(md.length())__                    totalSize += md.length()__                }__                response.phase1TotalSize = totalSize__                response.phase1ExistingTotalSize = existingTotalSize___                logger.trace("recovery [phase1]: recovering_files [{}] with total_size [{}], reusing_files [{}] with total_size [{}]",_                        response.phase1FileNames.size(),_                        new ByteSizeValue(totalSize), response.phase1ExistingFileNames.size(), new ByteSizeValue(existingTotalSize))__                cancellableThreads.execute(() ->_                        recoveryTarget.receiveFileInfo(response.phase1FileNames, response.phase1FileSizes, response.phase1ExistingFileNames,_                                response.phase1ExistingFileSizes, translogOps.get()))__                _                final Function<StoreFileMetaData, OutputStream> outputStreamFactories =_                        md -> new BufferedOutputStream(new RecoveryOutputStream(md, translogOps), chunkSizeInBytes)__                sendFiles(store, phase1Files.toArray(new StoreFileMetaData[phase1Files.size()]), outputStreamFactories)__                _                _                _                _                _                _                _                _                try {_                    cancellableThreads.executeIO(() ->_                        recoveryTarget.cleanFiles(translogOps.get(), recoverySourceMetadata))__                } catch (RemoteTransportException | IOException targetException) {_                    final IOException corruptIndexException__                    _                    _                    _                    _                    if ((corruptIndexException = ExceptionsHelper.unwrapCorruption(targetException)) != null) {_                        try {_                            final Store.MetadataSnapshot recoverySourceMetadata1 = store.getMetadata(snapshot)__                            StoreFileMetaData[] metadata =_                                    StreamSupport.stream(recoverySourceMetadata1.spliterator(), false).toArray(StoreFileMetaData[]::new)__                            ArrayUtil.timSort(metadata, Comparator.comparingLong(StoreFileMetaData::length))_ _                            for (StoreFileMetaData md : metadata) {_                                cancellableThreads.checkForCancel()__                                logger.debug("checking integrity for file {} after remove corruption exception", md)__                                if (store.checkIntegrityNoException(md) == false) { _                                    shard.failShard("recovery", corruptIndexException)__                                    logger.warn("Corrupted file detected {} checksum mismatch", md)__                                    throw corruptIndexException__                                }_                            }_                        } catch (IOException ex) {_                            targetException.addSuppressed(ex)__                            throw targetException__                        }_                        _                        RemoteTransportException exception = new RemoteTransportException("File corruption occurred on recovery but " +_                                "checksums are ok", null)__                        exception.addSuppressed(targetException)__                        logger.warn(() -> new ParameterizedMessage(_                                "{} Remote file corruption during finalization of recovery on node {}. local checksum OK",_                                shard.shardId(), request.targetNode()), corruptIndexException)__                        throw exception__                    } else {_                        throw targetException__                    }_                }_            }__            logger.trace("recovery [phase1]: took [{}]", stopWatch.totalTime())__            response.phase1Time = stopWatch.totalTime().millis()__        } catch (Exception e) {_            throw new RecoverFilesRecoveryException(request.shardId(), response.phase1FileNames.size(), new ByteSizeValue(totalSize), e)__        } finally {_            store.decRef()__        }_    };perform,phase1,of,the,recovery,operations,once,this,link,index,commit,snapshot,has,been,performed,no,commit,operations,files,being,fsync,d,are,effectively,allowed,on,this,index,until,all,recovery,phases,are,done,p,phase1,examines,the,segment,files,on,the,target,node,and,copies,over,the,segments,that,are,missing,only,segments,that,have,the,same,size,and,checksum,can,be,reused;public,void,phase1,final,index,commit,snapshot,final,supplier,integer,translog,ops,cancellable,threads,check,for,cancel,long,total,size,0,long,existing,total,size,0,final,store,store,shard,store,store,inc,ref,try,stop,watch,stop,watch,new,stop,watch,start,final,store,metadata,snapshot,recovery,source,metadata,try,recovery,source,metadata,store,get,metadata,snapshot,catch,corrupt,index,exception,index,format,too,old,exception,index,format,too,new,exception,ex,shard,fail,shard,recovery,ex,throw,ex,for,string,name,snapshot,get,file,names,final,store,file,meta,data,md,recovery,source,metadata,get,name,if,md,null,logger,info,snapshot,differs,from,actual,index,for,file,meta,name,recovery,source,metadata,as,map,throw,new,corrupt,index,exception,snapshot,differs,from,actual,index,maybe,index,was,removed,metadata,has,recovery,source,metadata,as,map,size,files,name,string,recovery,source,sync,id,recovery,source,metadata,get,sync,id,string,recovery,target,sync,id,request,metadata,snapshot,get,sync,id,final,boolean,recover,with,sync,id,recovery,source,sync,id,null,recovery,source,sync,id,equals,recovery,target,sync,id,if,recover,with,sync,id,final,long,num,docs,target,request,metadata,snapshot,get,num,docs,final,long,num,docs,source,recovery,source,metadata,get,num,docs,if,num,docs,target,num,docs,source,throw,new,illegal,state,exception,try,to,recover,request,shard,id,from,primary,shard,with,sync,id,but,number,of,docs,differ,num,docs,source,request,source,node,get,name,primary,vs,num,docs,target,request,target,node,get,name,logger,trace,skipping,phase1,identical,sync,id,found,on,both,source,and,target,recovery,source,sync,id,else,final,store,recovery,diff,diff,recovery,source,metadata,recovery,diff,request,metadata,snapshot,for,store,file,meta,data,md,diff,identical,response,phase1existing,file,names,add,md,name,response,phase1existing,file,sizes,add,md,length,existing,total,size,md,length,if,logger,is,trace,enabled,logger,trace,recovery,phase1,not,recovering,exist,in,local,store,and,has,checksum,size,md,name,md,checksum,md,length,total,size,md,length,list,store,file,meta,data,phase1files,new,array,list,diff,different,size,diff,missing,size,phase1files,add,all,diff,different,phase1files,add,all,diff,missing,for,store,file,meta,data,md,phase1files,if,request,metadata,snapshot,as,map,contains,key,md,name,logger,trace,recovery,phase1,recovering,exists,in,local,store,but,is,different,remote,local,md,name,request,metadata,snapshot,as,map,get,md,name,md,else,logger,trace,recovery,phase1,recovering,does,not,exist,in,remote,md,name,response,phase1file,names,add,md,name,response,phase1file,sizes,add,md,length,total,size,md,length,response,phase1total,size,total,size,response,phase1existing,total,size,existing,total,size,logger,trace,recovery,phase1,with,with,response,phase1file,names,size,new,byte,size,value,total,size,response,phase1existing,file,names,size,new,byte,size,value,existing,total,size,cancellable,threads,execute,recovery,target,receive,file,info,response,phase1file,names,response,phase1file,sizes,response,phase1existing,file,names,response,phase1existing,file,sizes,translog,ops,get,final,function,store,file,meta,data,output,stream,output,stream,factories,md,new,buffered,output,stream,new,recovery,output,stream,md,translog,ops,chunk,size,in,bytes,send,files,store,phase1files,to,array,new,store,file,meta,data,phase1files,size,output,stream,factories,try,cancellable,threads,execute,io,recovery,target,clean,files,translog,ops,get,recovery,source,metadata,catch,remote,transport,exception,ioexception,target,exception,final,ioexception,corrupt,index,exception,if,corrupt,index,exception,exceptions,helper,unwrap,corruption,target,exception,null,try,final,store,metadata,snapshot,recovery,source,metadata1,store,get,metadata,snapshot,store,file,meta,data,metadata,stream,support,stream,recovery,source,metadata1,spliterator,false,to,array,store,file,meta,data,new,array,util,tim,sort,metadata,comparator,comparing,long,store,file,meta,data,length,for,store,file,meta,data,md,metadata,cancellable,threads,check,for,cancel,logger,debug,checking,integrity,for,file,after,remove,corruption,exception,md,if,store,check,integrity,no,exception,md,false,shard,fail,shard,recovery,corrupt,index,exception,logger,warn,corrupted,file,detected,checksum,mismatch,md,throw,corrupt,index,exception,catch,ioexception,ex,target,exception,add,suppressed,ex,throw,target,exception,remote,transport,exception,exception,new,remote,transport,exception,file,corruption,occurred,on,recovery,but,checksums,are,ok,null,exception,add,suppressed,target,exception,logger,warn,new,parameterized,message,remote,file,corruption,during,finalization,of,recovery,on,node,local,checksum,ok,shard,shard,id,request,target,node,corrupt,index,exception,throw,exception,else,throw,target,exception,logger,trace,recovery,phase1,took,stop,watch,total,time,response,phase1time,stop,watch,total,time,millis,catch,exception,e,throw,new,recover,files,recovery,exception,request,shard,id,response,phase1file,names,size,new,byte,size,value,total,size,e,finally,store,dec,ref
RecoverySourceHandler -> public void phase1(final IndexCommit snapshot, final Supplier<Integer> translogOps);1525334055;Perform phase1 of the recovery operations. Once this {@link IndexCommit}_snapshot has been performed no commit operations (files being fsync'd)_are effectively allowed on this index until all recovery phases are done_<p>_Phase1 examines the segment files on the target node and copies over the_segments that are missing. Only segments that have the same size and_checksum can be reused;public void phase1(final IndexCommit snapshot, final Supplier<Integer> translogOps) {_        cancellableThreads.checkForCancel()__        _        long totalSize = 0__        _        long existingTotalSize = 0__        final Store store = shard.store()__        store.incRef()__        try {_            StopWatch stopWatch = new StopWatch().start()__            final Store.MetadataSnapshot recoverySourceMetadata__            try {_                recoverySourceMetadata = store.getMetadata(snapshot)__            } catch (CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {_                shard.failShard("recovery", ex)__                throw ex__            }_            for (String name : snapshot.getFileNames()) {_                final StoreFileMetaData md = recoverySourceMetadata.get(name)__                if (md == null) {_                    logger.info("Snapshot differs from actual index for file: {} meta: {}", name, recoverySourceMetadata.asMap())__                    throw new CorruptIndexException("Snapshot differs from actual index - maybe index was removed metadata has " +_                            recoverySourceMetadata.asMap().size() + " files", name)__                }_            }_            _            _            _            String recoverySourceSyncId = recoverySourceMetadata.getSyncId()__            String recoveryTargetSyncId = request.metadataSnapshot().getSyncId()__            final boolean recoverWithSyncId = recoverySourceSyncId != null &&_                    recoverySourceSyncId.equals(recoveryTargetSyncId)__            if (recoverWithSyncId) {_                final long numDocsTarget = request.metadataSnapshot().getNumDocs()__                final long numDocsSource = recoverySourceMetadata.getNumDocs()__                if (numDocsTarget != numDocsSource) {_                    throw new IllegalStateException("try to recover " + request.shardId() + " from primary shard with sync id but number " +_                            "of docs differ: " + numDocsSource + " (" + request.sourceNode().getName() + ", primary) vs " + numDocsTarget_                            + "(" + request.targetNode().getName() + ")")__                }_                _                _                logger.trace("skipping [phase1]- identical sync id [{}] found on both source and target", recoverySourceSyncId)__            } else {_                final Store.RecoveryDiff diff = recoverySourceMetadata.recoveryDiff(request.metadataSnapshot())__                for (StoreFileMetaData md : diff.identical) {_                    response.phase1ExistingFileNames.add(md.name())__                    response.phase1ExistingFileSizes.add(md.length())__                    existingTotalSize += md.length()__                    if (logger.isTraceEnabled()) {_                        logger.trace("recovery [phase1]: not recovering [{}], exist in local store and has checksum [{}]," +_                                        " size [{}]", md.name(), md.checksum(), md.length())__                    }_                    totalSize += md.length()__                }_                List<StoreFileMetaData> phase1Files = new ArrayList<>(diff.different.size() + diff.missing.size())__                phase1Files.addAll(diff.different)__                phase1Files.addAll(diff.missing)__                for (StoreFileMetaData md : phase1Files) {_                    if (request.metadataSnapshot().asMap().containsKey(md.name())) {_                        logger.trace("recovery [phase1]: recovering [{}], exists in local store, but is different: remote [{}], local [{}]",_                            md.name(), request.metadataSnapshot().asMap().get(md.name()), md)__                    } else {_                        logger.trace("recovery [phase1]: recovering [{}], does not exist in remote", md.name())__                    }_                    response.phase1FileNames.add(md.name())__                    response.phase1FileSizes.add(md.length())__                    totalSize += md.length()__                }__                response.phase1TotalSize = totalSize__                response.phase1ExistingTotalSize = existingTotalSize___                logger.trace("recovery [phase1]: recovering_files [{}] with total_size [{}], reusing_files [{}] with total_size [{}]",_                        response.phase1FileNames.size(),_                        new ByteSizeValue(totalSize), response.phase1ExistingFileNames.size(), new ByteSizeValue(existingTotalSize))__                cancellableThreads.execute(() ->_                        recoveryTarget.receiveFileInfo(response.phase1FileNames, response.phase1FileSizes, response.phase1ExistingFileNames,_                                response.phase1ExistingFileSizes, translogOps.get()))__                _                final Function<StoreFileMetaData, OutputStream> outputStreamFactories =_                        md -> new BufferedOutputStream(new RecoveryOutputStream(md, translogOps), chunkSizeInBytes)__                sendFiles(store, phase1Files.toArray(new StoreFileMetaData[phase1Files.size()]), outputStreamFactories)__                _                _                _                _                _                _                _                _                try {_                    cancellableThreads.executeIO(() ->_                        recoveryTarget.cleanFiles(translogOps.get(), recoverySourceMetadata))__                } catch (RemoteTransportException | IOException targetException) {_                    final IOException corruptIndexException__                    _                    _                    _                    _                    if ((corruptIndexException = ExceptionsHelper.unwrapCorruption(targetException)) != null) {_                        try {_                            final Store.MetadataSnapshot recoverySourceMetadata1 = store.getMetadata(snapshot)__                            StoreFileMetaData[] metadata =_                                    StreamSupport.stream(recoverySourceMetadata1.spliterator(), false).toArray(StoreFileMetaData[]::new)__                            ArrayUtil.timSort(metadata, Comparator.comparingLong(StoreFileMetaData::length))_ _                            for (StoreFileMetaData md : metadata) {_                                cancellableThreads.checkForCancel()__                                logger.debug("checking integrity for file {} after remove corruption exception", md)__                                if (store.checkIntegrityNoException(md) == false) { _                                    shard.failShard("recovery", corruptIndexException)__                                    logger.warn("Corrupted file detected {} checksum mismatch", md)__                                    throw corruptIndexException__                                }_                            }_                        } catch (IOException ex) {_                            targetException.addSuppressed(ex)__                            throw targetException__                        }_                        _                        RemoteTransportException exception = new RemoteTransportException("File corruption occurred on recovery but " +_                                "checksums are ok", null)__                        exception.addSuppressed(targetException)__                        logger.warn(() -> new ParameterizedMessage(_                                "{} Remote file corruption during finalization of recovery on node {}. local checksum OK",_                                shard.shardId(), request.targetNode()), corruptIndexException)__                        throw exception__                    } else {_                        throw targetException__                    }_                }_            }__            logger.trace("recovery [phase1]: took [{}]", stopWatch.totalTime())__            response.phase1Time = stopWatch.totalTime().millis()__        } catch (Exception e) {_            throw new RecoverFilesRecoveryException(request.shardId(), response.phase1FileNames.size(), new ByteSizeValue(totalSize), e)__        } finally {_            store.decRef()__        }_    };perform,phase1,of,the,recovery,operations,once,this,link,index,commit,snapshot,has,been,performed,no,commit,operations,files,being,fsync,d,are,effectively,allowed,on,this,index,until,all,recovery,phases,are,done,p,phase1,examines,the,segment,files,on,the,target,node,and,copies,over,the,segments,that,are,missing,only,segments,that,have,the,same,size,and,checksum,can,be,reused;public,void,phase1,final,index,commit,snapshot,final,supplier,integer,translog,ops,cancellable,threads,check,for,cancel,long,total,size,0,long,existing,total,size,0,final,store,store,shard,store,store,inc,ref,try,stop,watch,stop,watch,new,stop,watch,start,final,store,metadata,snapshot,recovery,source,metadata,try,recovery,source,metadata,store,get,metadata,snapshot,catch,corrupt,index,exception,index,format,too,old,exception,index,format,too,new,exception,ex,shard,fail,shard,recovery,ex,throw,ex,for,string,name,snapshot,get,file,names,final,store,file,meta,data,md,recovery,source,metadata,get,name,if,md,null,logger,info,snapshot,differs,from,actual,index,for,file,meta,name,recovery,source,metadata,as,map,throw,new,corrupt,index,exception,snapshot,differs,from,actual,index,maybe,index,was,removed,metadata,has,recovery,source,metadata,as,map,size,files,name,string,recovery,source,sync,id,recovery,source,metadata,get,sync,id,string,recovery,target,sync,id,request,metadata,snapshot,get,sync,id,final,boolean,recover,with,sync,id,recovery,source,sync,id,null,recovery,source,sync,id,equals,recovery,target,sync,id,if,recover,with,sync,id,final,long,num,docs,target,request,metadata,snapshot,get,num,docs,final,long,num,docs,source,recovery,source,metadata,get,num,docs,if,num,docs,target,num,docs,source,throw,new,illegal,state,exception,try,to,recover,request,shard,id,from,primary,shard,with,sync,id,but,number,of,docs,differ,num,docs,source,request,source,node,get,name,primary,vs,num,docs,target,request,target,node,get,name,logger,trace,skipping,phase1,identical,sync,id,found,on,both,source,and,target,recovery,source,sync,id,else,final,store,recovery,diff,diff,recovery,source,metadata,recovery,diff,request,metadata,snapshot,for,store,file,meta,data,md,diff,identical,response,phase1existing,file,names,add,md,name,response,phase1existing,file,sizes,add,md,length,existing,total,size,md,length,if,logger,is,trace,enabled,logger,trace,recovery,phase1,not,recovering,exist,in,local,store,and,has,checksum,size,md,name,md,checksum,md,length,total,size,md,length,list,store,file,meta,data,phase1files,new,array,list,diff,different,size,diff,missing,size,phase1files,add,all,diff,different,phase1files,add,all,diff,missing,for,store,file,meta,data,md,phase1files,if,request,metadata,snapshot,as,map,contains,key,md,name,logger,trace,recovery,phase1,recovering,exists,in,local,store,but,is,different,remote,local,md,name,request,metadata,snapshot,as,map,get,md,name,md,else,logger,trace,recovery,phase1,recovering,does,not,exist,in,remote,md,name,response,phase1file,names,add,md,name,response,phase1file,sizes,add,md,length,total,size,md,length,response,phase1total,size,total,size,response,phase1existing,total,size,existing,total,size,logger,trace,recovery,phase1,with,with,response,phase1file,names,size,new,byte,size,value,total,size,response,phase1existing,file,names,size,new,byte,size,value,existing,total,size,cancellable,threads,execute,recovery,target,receive,file,info,response,phase1file,names,response,phase1file,sizes,response,phase1existing,file,names,response,phase1existing,file,sizes,translog,ops,get,final,function,store,file,meta,data,output,stream,output,stream,factories,md,new,buffered,output,stream,new,recovery,output,stream,md,translog,ops,chunk,size,in,bytes,send,files,store,phase1files,to,array,new,store,file,meta,data,phase1files,size,output,stream,factories,try,cancellable,threads,execute,io,recovery,target,clean,files,translog,ops,get,recovery,source,metadata,catch,remote,transport,exception,ioexception,target,exception,final,ioexception,corrupt,index,exception,if,corrupt,index,exception,exceptions,helper,unwrap,corruption,target,exception,null,try,final,store,metadata,snapshot,recovery,source,metadata1,store,get,metadata,snapshot,store,file,meta,data,metadata,stream,support,stream,recovery,source,metadata1,spliterator,false,to,array,store,file,meta,data,new,array,util,tim,sort,metadata,comparator,comparing,long,store,file,meta,data,length,for,store,file,meta,data,md,metadata,cancellable,threads,check,for,cancel,logger,debug,checking,integrity,for,file,after,remove,corruption,exception,md,if,store,check,integrity,no,exception,md,false,shard,fail,shard,recovery,corrupt,index,exception,logger,warn,corrupted,file,detected,checksum,mismatch,md,throw,corrupt,index,exception,catch,ioexception,ex,target,exception,add,suppressed,ex,throw,target,exception,remote,transport,exception,exception,new,remote,transport,exception,file,corruption,occurred,on,recovery,but,checksums,are,ok,null,exception,add,suppressed,target,exception,logger,warn,new,parameterized,message,remote,file,corruption,during,finalization,of,recovery,on,node,local,checksum,ok,shard,shard,id,request,target,node,corrupt,index,exception,throw,exception,else,throw,target,exception,logger,trace,recovery,phase1,took,stop,watch,total,time,response,phase1time,stop,watch,total,time,millis,catch,exception,e,throw,new,recover,files,recovery,exception,request,shard,id,response,phase1file,names,size,new,byte,size,value,total,size,e,finally,store,dec,ref
RecoverySourceHandler -> public void phase1(final IndexCommit snapshot, final Supplier<Integer> translogOps);1528706846;Perform phase1 of the recovery operations. Once this {@link IndexCommit}_snapshot has been performed no commit operations (files being fsync'd)_are effectively allowed on this index until all recovery phases are done_<p>_Phase1 examines the segment files on the target node and copies over the_segments that are missing. Only segments that have the same size and_checksum can be reused;public void phase1(final IndexCommit snapshot, final Supplier<Integer> translogOps) {_        cancellableThreads.checkForCancel()__        _        long totalSize = 0__        _        long existingTotalSize = 0__        final Store store = shard.store()__        store.incRef()__        try {_            StopWatch stopWatch = new StopWatch().start()__            final Store.MetadataSnapshot recoverySourceMetadata__            try {_                recoverySourceMetadata = store.getMetadata(snapshot)__            } catch (CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {_                shard.failShard("recovery", ex)__                throw ex__            }_            for (String name : snapshot.getFileNames()) {_                final StoreFileMetaData md = recoverySourceMetadata.get(name)__                if (md == null) {_                    logger.info("Snapshot differs from actual index for file: {} meta: {}", name, recoverySourceMetadata.asMap())__                    throw new CorruptIndexException("Snapshot differs from actual index - maybe index was removed metadata has " +_                            recoverySourceMetadata.asMap().size() + " files", name)__                }_            }_            _            _            _            String recoverySourceSyncId = recoverySourceMetadata.getSyncId()__            String recoveryTargetSyncId = request.metadataSnapshot().getSyncId()__            final boolean recoverWithSyncId = recoverySourceSyncId != null &&_                    recoverySourceSyncId.equals(recoveryTargetSyncId)__            if (recoverWithSyncId) {_                final long numDocsTarget = request.metadataSnapshot().getNumDocs()__                final long numDocsSource = recoverySourceMetadata.getNumDocs()__                if (numDocsTarget != numDocsSource) {_                    throw new IllegalStateException("try to recover " + request.shardId() + " from primary shard with sync id but number " +_                            "of docs differ: " + numDocsSource + " (" + request.sourceNode().getName() + ", primary) vs " + numDocsTarget_                            + "(" + request.targetNode().getName() + ")")__                }_                _                _                logger.trace("skipping [phase1]- identical sync id [{}] found on both source and target", recoverySourceSyncId)__            } else {_                final Store.RecoveryDiff diff = recoverySourceMetadata.recoveryDiff(request.metadataSnapshot())__                for (StoreFileMetaData md : diff.identical) {_                    response.phase1ExistingFileNames.add(md.name())__                    response.phase1ExistingFileSizes.add(md.length())__                    existingTotalSize += md.length()__                    if (logger.isTraceEnabled()) {_                        logger.trace("recovery [phase1]: not recovering [{}], exist in local store and has checksum [{}]," +_                                        " size [{}]", md.name(), md.checksum(), md.length())__                    }_                    totalSize += md.length()__                }_                List<StoreFileMetaData> phase1Files = new ArrayList<>(diff.different.size() + diff.missing.size())__                phase1Files.addAll(diff.different)__                phase1Files.addAll(diff.missing)__                for (StoreFileMetaData md : phase1Files) {_                    if (request.metadataSnapshot().asMap().containsKey(md.name())) {_                        logger.trace("recovery [phase1]: recovering [{}], exists in local store, but is different: remote [{}], local [{}]",_                            md.name(), request.metadataSnapshot().asMap().get(md.name()), md)__                    } else {_                        logger.trace("recovery [phase1]: recovering [{}], does not exist in remote", md.name())__                    }_                    response.phase1FileNames.add(md.name())__                    response.phase1FileSizes.add(md.length())__                    totalSize += md.length()__                }__                response.phase1TotalSize = totalSize__                response.phase1ExistingTotalSize = existingTotalSize___                logger.trace("recovery [phase1]: recovering_files [{}] with total_size [{}], reusing_files [{}] with total_size [{}]",_                        response.phase1FileNames.size(),_                        new ByteSizeValue(totalSize), response.phase1ExistingFileNames.size(), new ByteSizeValue(existingTotalSize))__                cancellableThreads.execute(() ->_                        recoveryTarget.receiveFileInfo(response.phase1FileNames, response.phase1FileSizes, response.phase1ExistingFileNames,_                                response.phase1ExistingFileSizes, translogOps.get()))__                _                final Function<StoreFileMetaData, OutputStream> outputStreamFactories =_                        md -> new BufferedOutputStream(new RecoveryOutputStream(md, translogOps), chunkSizeInBytes)__                sendFiles(store, phase1Files.toArray(new StoreFileMetaData[phase1Files.size()]), outputStreamFactories)__                _                _                _                _                _                _                _                _                try {_                    cancellableThreads.executeIO(() ->_                        recoveryTarget.cleanFiles(translogOps.get(), recoverySourceMetadata))__                } catch (RemoteTransportException | IOException targetException) {_                    final IOException corruptIndexException__                    _                    _                    _                    _                    if ((corruptIndexException = ExceptionsHelper.unwrapCorruption(targetException)) != null) {_                        try {_                            final Store.MetadataSnapshot recoverySourceMetadata1 = store.getMetadata(snapshot)__                            StoreFileMetaData[] metadata =_                                    StreamSupport.stream(recoverySourceMetadata1.spliterator(), false).toArray(StoreFileMetaData[]::new)__                            ArrayUtil.timSort(metadata, Comparator.comparingLong(StoreFileMetaData::length))_ _                            for (StoreFileMetaData md : metadata) {_                                cancellableThreads.checkForCancel()__                                logger.debug("checking integrity for file {} after remove corruption exception", md)__                                if (store.checkIntegrityNoException(md) == false) { _                                    shard.failShard("recovery", corruptIndexException)__                                    logger.warn("Corrupted file detected {} checksum mismatch", md)__                                    throw corruptIndexException__                                }_                            }_                        } catch (IOException ex) {_                            targetException.addSuppressed(ex)__                            throw targetException__                        }_                        _                        RemoteTransportException exception = new RemoteTransportException("File corruption occurred on recovery but " +_                                "checksums are ok", null)__                        exception.addSuppressed(targetException)__                        logger.warn(() -> new ParameterizedMessage(_                                "{} Remote file corruption during finalization of recovery on node {}. local checksum OK",_                                shard.shardId(), request.targetNode()), corruptIndexException)__                        throw exception__                    } else {_                        throw targetException__                    }_                }_            }__            logger.trace("recovery [phase1]: took [{}]", stopWatch.totalTime())__            response.phase1Time = stopWatch.totalTime().millis()__        } catch (Exception e) {_            throw new RecoverFilesRecoveryException(request.shardId(), response.phase1FileNames.size(), new ByteSizeValue(totalSize), e)__        } finally {_            store.decRef()__        }_    };perform,phase1,of,the,recovery,operations,once,this,link,index,commit,snapshot,has,been,performed,no,commit,operations,files,being,fsync,d,are,effectively,allowed,on,this,index,until,all,recovery,phases,are,done,p,phase1,examines,the,segment,files,on,the,target,node,and,copies,over,the,segments,that,are,missing,only,segments,that,have,the,same,size,and,checksum,can,be,reused;public,void,phase1,final,index,commit,snapshot,final,supplier,integer,translog,ops,cancellable,threads,check,for,cancel,long,total,size,0,long,existing,total,size,0,final,store,store,shard,store,store,inc,ref,try,stop,watch,stop,watch,new,stop,watch,start,final,store,metadata,snapshot,recovery,source,metadata,try,recovery,source,metadata,store,get,metadata,snapshot,catch,corrupt,index,exception,index,format,too,old,exception,index,format,too,new,exception,ex,shard,fail,shard,recovery,ex,throw,ex,for,string,name,snapshot,get,file,names,final,store,file,meta,data,md,recovery,source,metadata,get,name,if,md,null,logger,info,snapshot,differs,from,actual,index,for,file,meta,name,recovery,source,metadata,as,map,throw,new,corrupt,index,exception,snapshot,differs,from,actual,index,maybe,index,was,removed,metadata,has,recovery,source,metadata,as,map,size,files,name,string,recovery,source,sync,id,recovery,source,metadata,get,sync,id,string,recovery,target,sync,id,request,metadata,snapshot,get,sync,id,final,boolean,recover,with,sync,id,recovery,source,sync,id,null,recovery,source,sync,id,equals,recovery,target,sync,id,if,recover,with,sync,id,final,long,num,docs,target,request,metadata,snapshot,get,num,docs,final,long,num,docs,source,recovery,source,metadata,get,num,docs,if,num,docs,target,num,docs,source,throw,new,illegal,state,exception,try,to,recover,request,shard,id,from,primary,shard,with,sync,id,but,number,of,docs,differ,num,docs,source,request,source,node,get,name,primary,vs,num,docs,target,request,target,node,get,name,logger,trace,skipping,phase1,identical,sync,id,found,on,both,source,and,target,recovery,source,sync,id,else,final,store,recovery,diff,diff,recovery,source,metadata,recovery,diff,request,metadata,snapshot,for,store,file,meta,data,md,diff,identical,response,phase1existing,file,names,add,md,name,response,phase1existing,file,sizes,add,md,length,existing,total,size,md,length,if,logger,is,trace,enabled,logger,trace,recovery,phase1,not,recovering,exist,in,local,store,and,has,checksum,size,md,name,md,checksum,md,length,total,size,md,length,list,store,file,meta,data,phase1files,new,array,list,diff,different,size,diff,missing,size,phase1files,add,all,diff,different,phase1files,add,all,diff,missing,for,store,file,meta,data,md,phase1files,if,request,metadata,snapshot,as,map,contains,key,md,name,logger,trace,recovery,phase1,recovering,exists,in,local,store,but,is,different,remote,local,md,name,request,metadata,snapshot,as,map,get,md,name,md,else,logger,trace,recovery,phase1,recovering,does,not,exist,in,remote,md,name,response,phase1file,names,add,md,name,response,phase1file,sizes,add,md,length,total,size,md,length,response,phase1total,size,total,size,response,phase1existing,total,size,existing,total,size,logger,trace,recovery,phase1,with,with,response,phase1file,names,size,new,byte,size,value,total,size,response,phase1existing,file,names,size,new,byte,size,value,existing,total,size,cancellable,threads,execute,recovery,target,receive,file,info,response,phase1file,names,response,phase1file,sizes,response,phase1existing,file,names,response,phase1existing,file,sizes,translog,ops,get,final,function,store,file,meta,data,output,stream,output,stream,factories,md,new,buffered,output,stream,new,recovery,output,stream,md,translog,ops,chunk,size,in,bytes,send,files,store,phase1files,to,array,new,store,file,meta,data,phase1files,size,output,stream,factories,try,cancellable,threads,execute,io,recovery,target,clean,files,translog,ops,get,recovery,source,metadata,catch,remote,transport,exception,ioexception,target,exception,final,ioexception,corrupt,index,exception,if,corrupt,index,exception,exceptions,helper,unwrap,corruption,target,exception,null,try,final,store,metadata,snapshot,recovery,source,metadata1,store,get,metadata,snapshot,store,file,meta,data,metadata,stream,support,stream,recovery,source,metadata1,spliterator,false,to,array,store,file,meta,data,new,array,util,tim,sort,metadata,comparator,comparing,long,store,file,meta,data,length,for,store,file,meta,data,md,metadata,cancellable,threads,check,for,cancel,logger,debug,checking,integrity,for,file,after,remove,corruption,exception,md,if,store,check,integrity,no,exception,md,false,shard,fail,shard,recovery,corrupt,index,exception,logger,warn,corrupted,file,detected,checksum,mismatch,md,throw,corrupt,index,exception,catch,ioexception,ex,target,exception,add,suppressed,ex,throw,target,exception,remote,transport,exception,exception,new,remote,transport,exception,file,corruption,occurred,on,recovery,but,checksums,are,ok,null,exception,add,suppressed,target,exception,logger,warn,new,parameterized,message,remote,file,corruption,during,finalization,of,recovery,on,node,local,checksum,ok,shard,shard,id,request,target,node,corrupt,index,exception,throw,exception,else,throw,target,exception,logger,trace,recovery,phase1,took,stop,watch,total,time,response,phase1time,stop,watch,total,time,millis,catch,exception,e,throw,new,recover,files,recovery,exception,request,shard,id,response,phase1file,names,size,new,byte,size,value,total,size,e,finally,store,dec,ref
RecoverySourceHandler -> public void phase1(final IndexCommit snapshot, final Supplier<Integer> translogOps);1529658035;Perform phase1 of the recovery operations. Once this {@link IndexCommit}_snapshot has been performed no commit operations (files being fsync'd)_are effectively allowed on this index until all recovery phases are done_<p>_Phase1 examines the segment files on the target node and copies over the_segments that are missing. Only segments that have the same size and_checksum can be reused;public void phase1(final IndexCommit snapshot, final Supplier<Integer> translogOps) {_        cancellableThreads.checkForCancel()__        _        long totalSize = 0__        _        long existingTotalSize = 0__        final Store store = shard.store()__        store.incRef()__        try {_            StopWatch stopWatch = new StopWatch().start()__            final Store.MetadataSnapshot recoverySourceMetadata__            try {_                recoverySourceMetadata = store.getMetadata(snapshot)__            } catch (CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {_                shard.failShard("recovery", ex)__                throw ex__            }_            for (String name : snapshot.getFileNames()) {_                final StoreFileMetaData md = recoverySourceMetadata.get(name)__                if (md == null) {_                    logger.info("Snapshot differs from actual index for file: {} meta: {}", name, recoverySourceMetadata.asMap())__                    throw new CorruptIndexException("Snapshot differs from actual index - maybe index was removed metadata has " +_                            recoverySourceMetadata.asMap().size() + " files", name)__                }_            }_            _            _            _            String recoverySourceSyncId = recoverySourceMetadata.getSyncId()__            String recoveryTargetSyncId = request.metadataSnapshot().getSyncId()__            final boolean recoverWithSyncId = recoverySourceSyncId != null &&_                    recoverySourceSyncId.equals(recoveryTargetSyncId)__            if (recoverWithSyncId) {_                final long numDocsTarget = request.metadataSnapshot().getNumDocs()__                final long numDocsSource = recoverySourceMetadata.getNumDocs()__                if (numDocsTarget != numDocsSource) {_                    throw new IllegalStateException("try to recover " + request.shardId() + " from primary shard with sync id but number " +_                            "of docs differ: " + numDocsSource + " (" + request.sourceNode().getName() + ", primary) vs " + numDocsTarget_                            + "(" + request.targetNode().getName() + ")")__                }_                _                _                logger.trace("skipping [phase1]- identical sync id [{}] found on both source and target", recoverySourceSyncId)__            } else {_                final Store.RecoveryDiff diff = recoverySourceMetadata.recoveryDiff(request.metadataSnapshot())__                for (StoreFileMetaData md : diff.identical) {_                    response.phase1ExistingFileNames.add(md.name())__                    response.phase1ExistingFileSizes.add(md.length())__                    existingTotalSize += md.length()__                    if (logger.isTraceEnabled()) {_                        logger.trace("recovery [phase1]: not recovering [{}], exist in local store and has checksum [{}]," +_                                        " size [{}]", md.name(), md.checksum(), md.length())__                    }_                    totalSize += md.length()__                }_                List<StoreFileMetaData> phase1Files = new ArrayList<>(diff.different.size() + diff.missing.size())__                phase1Files.addAll(diff.different)__                phase1Files.addAll(diff.missing)__                for (StoreFileMetaData md : phase1Files) {_                    if (request.metadataSnapshot().asMap().containsKey(md.name())) {_                        logger.trace("recovery [phase1]: recovering [{}], exists in local store, but is different: remote [{}], local [{}]",_                            md.name(), request.metadataSnapshot().asMap().get(md.name()), md)__                    } else {_                        logger.trace("recovery [phase1]: recovering [{}], does not exist in remote", md.name())__                    }_                    response.phase1FileNames.add(md.name())__                    response.phase1FileSizes.add(md.length())__                    totalSize += md.length()__                }__                response.phase1TotalSize = totalSize__                response.phase1ExistingTotalSize = existingTotalSize___                logger.trace("recovery [phase1]: recovering_files [{}] with total_size [{}], reusing_files [{}] with total_size [{}]",_                        response.phase1FileNames.size(),_                        new ByteSizeValue(totalSize), response.phase1ExistingFileNames.size(), new ByteSizeValue(existingTotalSize))__                cancellableThreads.execute(() ->_                        recoveryTarget.receiveFileInfo(response.phase1FileNames, response.phase1FileSizes, response.phase1ExistingFileNames,_                                response.phase1ExistingFileSizes, translogOps.get()))__                _                final Function<StoreFileMetaData, OutputStream> outputStreamFactories =_                        md -> new BufferedOutputStream(new RecoveryOutputStream(md, translogOps), chunkSizeInBytes)__                sendFiles(store, phase1Files.toArray(new StoreFileMetaData[phase1Files.size()]), outputStreamFactories)__                _                _                _                _                _                _                _                _                try {_                    cancellableThreads.executeIO(() ->_                        recoveryTarget.cleanFiles(translogOps.get(), recoverySourceMetadata))__                } catch (RemoteTransportException | IOException targetException) {_                    final IOException corruptIndexException__                    _                    _                    _                    _                    if ((corruptIndexException = ExceptionsHelper.unwrapCorruption(targetException)) != null) {_                        try {_                            final Store.MetadataSnapshot recoverySourceMetadata1 = store.getMetadata(snapshot)__                            StoreFileMetaData[] metadata =_                                    StreamSupport.stream(recoverySourceMetadata1.spliterator(), false).toArray(StoreFileMetaData[]::new)__                            ArrayUtil.timSort(metadata, Comparator.comparingLong(StoreFileMetaData::length))_ _                            for (StoreFileMetaData md : metadata) {_                                cancellableThreads.checkForCancel()__                                logger.debug("checking integrity for file {} after remove corruption exception", md)__                                if (store.checkIntegrityNoException(md) == false) { _                                    shard.failShard("recovery", corruptIndexException)__                                    logger.warn("Corrupted file detected {} checksum mismatch", md)__                                    throw corruptIndexException__                                }_                            }_                        } catch (IOException ex) {_                            targetException.addSuppressed(ex)__                            throw targetException__                        }_                        _                        RemoteTransportException exception = new RemoteTransportException("File corruption occurred on recovery but " +_                                "checksums are ok", null)__                        exception.addSuppressed(targetException)__                        logger.warn(() -> new ParameterizedMessage(_                                "{} Remote file corruption during finalization of recovery on node {}. local checksum OK",_                                shard.shardId(), request.targetNode()), corruptIndexException)__                        throw exception__                    } else {_                        throw targetException__                    }_                }_            }__            logger.trace("recovery [phase1]: took [{}]", stopWatch.totalTime())__            response.phase1Time = stopWatch.totalTime().millis()__        } catch (Exception e) {_            throw new RecoverFilesRecoveryException(request.shardId(), response.phase1FileNames.size(), new ByteSizeValue(totalSize), e)__        } finally {_            store.decRef()__        }_    };perform,phase1,of,the,recovery,operations,once,this,link,index,commit,snapshot,has,been,performed,no,commit,operations,files,being,fsync,d,are,effectively,allowed,on,this,index,until,all,recovery,phases,are,done,p,phase1,examines,the,segment,files,on,the,target,node,and,copies,over,the,segments,that,are,missing,only,segments,that,have,the,same,size,and,checksum,can,be,reused;public,void,phase1,final,index,commit,snapshot,final,supplier,integer,translog,ops,cancellable,threads,check,for,cancel,long,total,size,0,long,existing,total,size,0,final,store,store,shard,store,store,inc,ref,try,stop,watch,stop,watch,new,stop,watch,start,final,store,metadata,snapshot,recovery,source,metadata,try,recovery,source,metadata,store,get,metadata,snapshot,catch,corrupt,index,exception,index,format,too,old,exception,index,format,too,new,exception,ex,shard,fail,shard,recovery,ex,throw,ex,for,string,name,snapshot,get,file,names,final,store,file,meta,data,md,recovery,source,metadata,get,name,if,md,null,logger,info,snapshot,differs,from,actual,index,for,file,meta,name,recovery,source,metadata,as,map,throw,new,corrupt,index,exception,snapshot,differs,from,actual,index,maybe,index,was,removed,metadata,has,recovery,source,metadata,as,map,size,files,name,string,recovery,source,sync,id,recovery,source,metadata,get,sync,id,string,recovery,target,sync,id,request,metadata,snapshot,get,sync,id,final,boolean,recover,with,sync,id,recovery,source,sync,id,null,recovery,source,sync,id,equals,recovery,target,sync,id,if,recover,with,sync,id,final,long,num,docs,target,request,metadata,snapshot,get,num,docs,final,long,num,docs,source,recovery,source,metadata,get,num,docs,if,num,docs,target,num,docs,source,throw,new,illegal,state,exception,try,to,recover,request,shard,id,from,primary,shard,with,sync,id,but,number,of,docs,differ,num,docs,source,request,source,node,get,name,primary,vs,num,docs,target,request,target,node,get,name,logger,trace,skipping,phase1,identical,sync,id,found,on,both,source,and,target,recovery,source,sync,id,else,final,store,recovery,diff,diff,recovery,source,metadata,recovery,diff,request,metadata,snapshot,for,store,file,meta,data,md,diff,identical,response,phase1existing,file,names,add,md,name,response,phase1existing,file,sizes,add,md,length,existing,total,size,md,length,if,logger,is,trace,enabled,logger,trace,recovery,phase1,not,recovering,exist,in,local,store,and,has,checksum,size,md,name,md,checksum,md,length,total,size,md,length,list,store,file,meta,data,phase1files,new,array,list,diff,different,size,diff,missing,size,phase1files,add,all,diff,different,phase1files,add,all,diff,missing,for,store,file,meta,data,md,phase1files,if,request,metadata,snapshot,as,map,contains,key,md,name,logger,trace,recovery,phase1,recovering,exists,in,local,store,but,is,different,remote,local,md,name,request,metadata,snapshot,as,map,get,md,name,md,else,logger,trace,recovery,phase1,recovering,does,not,exist,in,remote,md,name,response,phase1file,names,add,md,name,response,phase1file,sizes,add,md,length,total,size,md,length,response,phase1total,size,total,size,response,phase1existing,total,size,existing,total,size,logger,trace,recovery,phase1,with,with,response,phase1file,names,size,new,byte,size,value,total,size,response,phase1existing,file,names,size,new,byte,size,value,existing,total,size,cancellable,threads,execute,recovery,target,receive,file,info,response,phase1file,names,response,phase1file,sizes,response,phase1existing,file,names,response,phase1existing,file,sizes,translog,ops,get,final,function,store,file,meta,data,output,stream,output,stream,factories,md,new,buffered,output,stream,new,recovery,output,stream,md,translog,ops,chunk,size,in,bytes,send,files,store,phase1files,to,array,new,store,file,meta,data,phase1files,size,output,stream,factories,try,cancellable,threads,execute,io,recovery,target,clean,files,translog,ops,get,recovery,source,metadata,catch,remote,transport,exception,ioexception,target,exception,final,ioexception,corrupt,index,exception,if,corrupt,index,exception,exceptions,helper,unwrap,corruption,target,exception,null,try,final,store,metadata,snapshot,recovery,source,metadata1,store,get,metadata,snapshot,store,file,meta,data,metadata,stream,support,stream,recovery,source,metadata1,spliterator,false,to,array,store,file,meta,data,new,array,util,tim,sort,metadata,comparator,comparing,long,store,file,meta,data,length,for,store,file,meta,data,md,metadata,cancellable,threads,check,for,cancel,logger,debug,checking,integrity,for,file,after,remove,corruption,exception,md,if,store,check,integrity,no,exception,md,false,shard,fail,shard,recovery,corrupt,index,exception,logger,warn,corrupted,file,detected,checksum,mismatch,md,throw,corrupt,index,exception,catch,ioexception,ex,target,exception,add,suppressed,ex,throw,target,exception,remote,transport,exception,exception,new,remote,transport,exception,file,corruption,occurred,on,recovery,but,checksums,are,ok,null,exception,add,suppressed,target,exception,logger,warn,new,parameterized,message,remote,file,corruption,during,finalization,of,recovery,on,node,local,checksum,ok,shard,shard,id,request,target,node,corrupt,index,exception,throw,exception,else,throw,target,exception,logger,trace,recovery,phase1,took,stop,watch,total,time,response,phase1time,stop,watch,total,time,millis,catch,exception,e,throw,new,recover,files,recovery,exception,request,shard,id,response,phase1file,names,size,new,byte,size,value,total,size,e,finally,store,dec,ref
RecoverySourceHandler -> public void phase1(final IndexCommit snapshot, final Supplier<Integer> translogOps);1533295538;Perform phase1 of the recovery operations. Once this {@link IndexCommit}_snapshot has been performed no commit operations (files being fsync'd)_are effectively allowed on this index until all recovery phases are done_<p>_Phase1 examines the segment files on the target node and copies over the_segments that are missing. Only segments that have the same size and_checksum can be reused;public void phase1(final IndexCommit snapshot, final Supplier<Integer> translogOps) {_        cancellableThreads.checkForCancel()__        _        long totalSize = 0__        _        long existingTotalSize = 0__        final Store store = shard.store()__        store.incRef()__        try {_            StopWatch stopWatch = new StopWatch().start()__            final Store.MetadataSnapshot recoverySourceMetadata__            try {_                recoverySourceMetadata = store.getMetadata(snapshot)__            } catch (CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {_                shard.failShard("recovery", ex)__                throw ex__            }_            for (String name : snapshot.getFileNames()) {_                final StoreFileMetaData md = recoverySourceMetadata.get(name)__                if (md == null) {_                    logger.info("Snapshot differs from actual index for file: {} meta: {}", name, recoverySourceMetadata.asMap())__                    throw new CorruptIndexException("Snapshot differs from actual index - maybe index was removed metadata has " +_                            recoverySourceMetadata.asMap().size() + " files", name)__                }_            }_            _            _            _            String recoverySourceSyncId = recoverySourceMetadata.getSyncId()__            String recoveryTargetSyncId = request.metadataSnapshot().getSyncId()__            final boolean recoverWithSyncId = recoverySourceSyncId != null &&_                    recoverySourceSyncId.equals(recoveryTargetSyncId)__            if (recoverWithSyncId) {_                final long numDocsTarget = request.metadataSnapshot().getNumDocs()__                final long numDocsSource = recoverySourceMetadata.getNumDocs()__                if (numDocsTarget != numDocsSource) {_                    throw new IllegalStateException("try to recover " + request.shardId() + " from primary shard with sync id but number " +_                            "of docs differ: " + numDocsSource + " (" + request.sourceNode().getName() + ", primary) vs " + numDocsTarget_                            + "(" + request.targetNode().getName() + ")")__                }_                _                _                logger.trace("skipping [phase1]- identical sync id [{}] found on both source and target", recoverySourceSyncId)__            } else {_                final Store.RecoveryDiff diff = recoverySourceMetadata.recoveryDiff(request.metadataSnapshot())__                for (StoreFileMetaData md : diff.identical) {_                    response.phase1ExistingFileNames.add(md.name())__                    response.phase1ExistingFileSizes.add(md.length())__                    existingTotalSize += md.length()__                    if (logger.isTraceEnabled()) {_                        logger.trace("recovery [phase1]: not recovering [{}], exist in local store and has checksum [{}]," +_                                        " size [{}]", md.name(), md.checksum(), md.length())__                    }_                    totalSize += md.length()__                }_                List<StoreFileMetaData> phase1Files = new ArrayList<>(diff.different.size() + diff.missing.size())__                phase1Files.addAll(diff.different)__                phase1Files.addAll(diff.missing)__                for (StoreFileMetaData md : phase1Files) {_                    if (request.metadataSnapshot().asMap().containsKey(md.name())) {_                        logger.trace("recovery [phase1]: recovering [{}], exists in local store, but is different: remote [{}], local [{}]",_                            md.name(), request.metadataSnapshot().asMap().get(md.name()), md)__                    } else {_                        logger.trace("recovery [phase1]: recovering [{}], does not exist in remote", md.name())__                    }_                    response.phase1FileNames.add(md.name())__                    response.phase1FileSizes.add(md.length())__                    totalSize += md.length()__                }__                response.phase1TotalSize = totalSize__                response.phase1ExistingTotalSize = existingTotalSize___                logger.trace("recovery [phase1]: recovering_files [{}] with total_size [{}], reusing_files [{}] with total_size [{}]",_                        response.phase1FileNames.size(),_                        new ByteSizeValue(totalSize), response.phase1ExistingFileNames.size(), new ByteSizeValue(existingTotalSize))__                cancellableThreads.execute(() ->_                        recoveryTarget.receiveFileInfo(response.phase1FileNames, response.phase1FileSizes, response.phase1ExistingFileNames,_                                response.phase1ExistingFileSizes, translogOps.get()))__                _                final Function<StoreFileMetaData, OutputStream> outputStreamFactories =_                        md -> new BufferedOutputStream(new RecoveryOutputStream(md, translogOps), chunkSizeInBytes)__                sendFiles(store, phase1Files.toArray(new StoreFileMetaData[phase1Files.size()]), outputStreamFactories)__                _                _                _                _                _                _                _                _                try {_                    cancellableThreads.executeIO(() ->_                        recoveryTarget.cleanFiles(translogOps.get(), recoverySourceMetadata))__                } catch (RemoteTransportException | IOException targetException) {_                    final IOException corruptIndexException__                    _                    _                    _                    _                    if ((corruptIndexException = ExceptionsHelper.unwrapCorruption(targetException)) != null) {_                        try {_                            final Store.MetadataSnapshot recoverySourceMetadata1 = store.getMetadata(snapshot)__                            StoreFileMetaData[] metadata =_                                    StreamSupport.stream(recoverySourceMetadata1.spliterator(), false).toArray(StoreFileMetaData[]::new)__                            ArrayUtil.timSort(metadata, Comparator.comparingLong(StoreFileMetaData::length))_ _                            for (StoreFileMetaData md : metadata) {_                                cancellableThreads.checkForCancel()__                                logger.debug("checking integrity for file {} after remove corruption exception", md)__                                if (store.checkIntegrityNoException(md) == false) { _                                    shard.failShard("recovery", corruptIndexException)__                                    logger.warn("Corrupted file detected {} checksum mismatch", md)__                                    throw corruptIndexException__                                }_                            }_                        } catch (IOException ex) {_                            targetException.addSuppressed(ex)__                            throw targetException__                        }_                        _                        RemoteTransportException exception = new RemoteTransportException("File corruption occurred on recovery but " +_                                "checksums are ok", null)__                        exception.addSuppressed(targetException)__                        logger.warn(() -> new ParameterizedMessage(_                                "{} Remote file corruption during finalization of recovery on node {}. local checksum OK",_                                shard.shardId(), request.targetNode()), corruptIndexException)__                        throw exception__                    } else {_                        throw targetException__                    }_                }_            }__            logger.trace("recovery [phase1]: took [{}]", stopWatch.totalTime())__            response.phase1Time = stopWatch.totalTime().millis()__        } catch (Exception e) {_            throw new RecoverFilesRecoveryException(request.shardId(), response.phase1FileNames.size(), new ByteSizeValue(totalSize), e)__        } finally {_            store.decRef()__        }_    };perform,phase1,of,the,recovery,operations,once,this,link,index,commit,snapshot,has,been,performed,no,commit,operations,files,being,fsync,d,are,effectively,allowed,on,this,index,until,all,recovery,phases,are,done,p,phase1,examines,the,segment,files,on,the,target,node,and,copies,over,the,segments,that,are,missing,only,segments,that,have,the,same,size,and,checksum,can,be,reused;public,void,phase1,final,index,commit,snapshot,final,supplier,integer,translog,ops,cancellable,threads,check,for,cancel,long,total,size,0,long,existing,total,size,0,final,store,store,shard,store,store,inc,ref,try,stop,watch,stop,watch,new,stop,watch,start,final,store,metadata,snapshot,recovery,source,metadata,try,recovery,source,metadata,store,get,metadata,snapshot,catch,corrupt,index,exception,index,format,too,old,exception,index,format,too,new,exception,ex,shard,fail,shard,recovery,ex,throw,ex,for,string,name,snapshot,get,file,names,final,store,file,meta,data,md,recovery,source,metadata,get,name,if,md,null,logger,info,snapshot,differs,from,actual,index,for,file,meta,name,recovery,source,metadata,as,map,throw,new,corrupt,index,exception,snapshot,differs,from,actual,index,maybe,index,was,removed,metadata,has,recovery,source,metadata,as,map,size,files,name,string,recovery,source,sync,id,recovery,source,metadata,get,sync,id,string,recovery,target,sync,id,request,metadata,snapshot,get,sync,id,final,boolean,recover,with,sync,id,recovery,source,sync,id,null,recovery,source,sync,id,equals,recovery,target,sync,id,if,recover,with,sync,id,final,long,num,docs,target,request,metadata,snapshot,get,num,docs,final,long,num,docs,source,recovery,source,metadata,get,num,docs,if,num,docs,target,num,docs,source,throw,new,illegal,state,exception,try,to,recover,request,shard,id,from,primary,shard,with,sync,id,but,number,of,docs,differ,num,docs,source,request,source,node,get,name,primary,vs,num,docs,target,request,target,node,get,name,logger,trace,skipping,phase1,identical,sync,id,found,on,both,source,and,target,recovery,source,sync,id,else,final,store,recovery,diff,diff,recovery,source,metadata,recovery,diff,request,metadata,snapshot,for,store,file,meta,data,md,diff,identical,response,phase1existing,file,names,add,md,name,response,phase1existing,file,sizes,add,md,length,existing,total,size,md,length,if,logger,is,trace,enabled,logger,trace,recovery,phase1,not,recovering,exist,in,local,store,and,has,checksum,size,md,name,md,checksum,md,length,total,size,md,length,list,store,file,meta,data,phase1files,new,array,list,diff,different,size,diff,missing,size,phase1files,add,all,diff,different,phase1files,add,all,diff,missing,for,store,file,meta,data,md,phase1files,if,request,metadata,snapshot,as,map,contains,key,md,name,logger,trace,recovery,phase1,recovering,exists,in,local,store,but,is,different,remote,local,md,name,request,metadata,snapshot,as,map,get,md,name,md,else,logger,trace,recovery,phase1,recovering,does,not,exist,in,remote,md,name,response,phase1file,names,add,md,name,response,phase1file,sizes,add,md,length,total,size,md,length,response,phase1total,size,total,size,response,phase1existing,total,size,existing,total,size,logger,trace,recovery,phase1,with,with,response,phase1file,names,size,new,byte,size,value,total,size,response,phase1existing,file,names,size,new,byte,size,value,existing,total,size,cancellable,threads,execute,recovery,target,receive,file,info,response,phase1file,names,response,phase1file,sizes,response,phase1existing,file,names,response,phase1existing,file,sizes,translog,ops,get,final,function,store,file,meta,data,output,stream,output,stream,factories,md,new,buffered,output,stream,new,recovery,output,stream,md,translog,ops,chunk,size,in,bytes,send,files,store,phase1files,to,array,new,store,file,meta,data,phase1files,size,output,stream,factories,try,cancellable,threads,execute,io,recovery,target,clean,files,translog,ops,get,recovery,source,metadata,catch,remote,transport,exception,ioexception,target,exception,final,ioexception,corrupt,index,exception,if,corrupt,index,exception,exceptions,helper,unwrap,corruption,target,exception,null,try,final,store,metadata,snapshot,recovery,source,metadata1,store,get,metadata,snapshot,store,file,meta,data,metadata,stream,support,stream,recovery,source,metadata1,spliterator,false,to,array,store,file,meta,data,new,array,util,tim,sort,metadata,comparator,comparing,long,store,file,meta,data,length,for,store,file,meta,data,md,metadata,cancellable,threads,check,for,cancel,logger,debug,checking,integrity,for,file,after,remove,corruption,exception,md,if,store,check,integrity,no,exception,md,false,shard,fail,shard,recovery,corrupt,index,exception,logger,warn,corrupted,file,detected,checksum,mismatch,md,throw,corrupt,index,exception,catch,ioexception,ex,target,exception,add,suppressed,ex,throw,target,exception,remote,transport,exception,exception,new,remote,transport,exception,file,corruption,occurred,on,recovery,but,checksums,are,ok,null,exception,add,suppressed,target,exception,logger,warn,new,parameterized,message,remote,file,corruption,during,finalization,of,recovery,on,node,local,checksum,ok,shard,shard,id,request,target,node,corrupt,index,exception,throw,exception,else,throw,target,exception,logger,trace,recovery,phase1,took,stop,watch,total,time,response,phase1time,stop,watch,total,time,millis,catch,exception,e,throw,new,recover,files,recovery,exception,request,shard,id,response,phase1file,names,size,new,byte,size,value,total,size,e,finally,store,dec,ref
RecoverySourceHandler -> public void phase1(final IndexCommit snapshot, final Supplier<Integer> translogOps);1535723122;Perform phase1 of the recovery operations. Once this {@link IndexCommit}_snapshot has been performed no commit operations (files being fsync'd)_are effectively allowed on this index until all recovery phases are done_<p>_Phase1 examines the segment files on the target node and copies over the_segments that are missing. Only segments that have the same size and_checksum can be reused;public void phase1(final IndexCommit snapshot, final Supplier<Integer> translogOps) {_        cancellableThreads.checkForCancel()__        _        long totalSize = 0__        _        long existingTotalSize = 0__        final Store store = shard.store()__        store.incRef()__        try {_            StopWatch stopWatch = new StopWatch().start()__            final Store.MetadataSnapshot recoverySourceMetadata__            try {_                recoverySourceMetadata = store.getMetadata(snapshot)__            } catch (CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {_                shard.failShard("recovery", ex)__                throw ex__            }_            for (String name : snapshot.getFileNames()) {_                final StoreFileMetaData md = recoverySourceMetadata.get(name)__                if (md == null) {_                    logger.info("Snapshot differs from actual index for file: {} meta: {}", name, recoverySourceMetadata.asMap())__                    throw new CorruptIndexException("Snapshot differs from actual index - maybe index was removed metadata has " +_                            recoverySourceMetadata.asMap().size() + " files", name)__                }_            }_            _            _            _            String recoverySourceSyncId = recoverySourceMetadata.getSyncId()__            String recoveryTargetSyncId = request.metadataSnapshot().getSyncId()__            final boolean recoverWithSyncId = recoverySourceSyncId != null &&_                    recoverySourceSyncId.equals(recoveryTargetSyncId)__            if (recoverWithSyncId) {_                final long numDocsTarget = request.metadataSnapshot().getNumDocs()__                final long numDocsSource = recoverySourceMetadata.getNumDocs()__                if (numDocsTarget != numDocsSource) {_                    throw new IllegalStateException("try to recover " + request.shardId() + " from primary shard with sync id but number " +_                            "of docs differ: " + numDocsSource + " (" + request.sourceNode().getName() + ", primary) vs " + numDocsTarget_                            + "(" + request.targetNode().getName() + ")")__                }_                _                _                logger.trace("skipping [phase1]- identical sync id [{}] found on both source and target", recoverySourceSyncId)__            } else {_                final Store.RecoveryDiff diff = recoverySourceMetadata.recoveryDiff(request.metadataSnapshot())__                for (StoreFileMetaData md : diff.identical) {_                    response.phase1ExistingFileNames.add(md.name())__                    response.phase1ExistingFileSizes.add(md.length())__                    existingTotalSize += md.length()__                    if (logger.isTraceEnabled()) {_                        logger.trace("recovery [phase1]: not recovering [{}], exist in local store and has checksum [{}]," +_                                        " size [{}]", md.name(), md.checksum(), md.length())__                    }_                    totalSize += md.length()__                }_                List<StoreFileMetaData> phase1Files = new ArrayList<>(diff.different.size() + diff.missing.size())__                phase1Files.addAll(diff.different)__                phase1Files.addAll(diff.missing)__                for (StoreFileMetaData md : phase1Files) {_                    if (request.metadataSnapshot().asMap().containsKey(md.name())) {_                        logger.trace("recovery [phase1]: recovering [{}], exists in local store, but is different: remote [{}], local [{}]",_                            md.name(), request.metadataSnapshot().asMap().get(md.name()), md)__                    } else {_                        logger.trace("recovery [phase1]: recovering [{}], does not exist in remote", md.name())__                    }_                    response.phase1FileNames.add(md.name())__                    response.phase1FileSizes.add(md.length())__                    totalSize += md.length()__                }__                response.phase1TotalSize = totalSize__                response.phase1ExistingTotalSize = existingTotalSize___                logger.trace("recovery [phase1]: recovering_files [{}] with total_size [{}], reusing_files [{}] with total_size [{}]",_                        response.phase1FileNames.size(),_                        new ByteSizeValue(totalSize), response.phase1ExistingFileNames.size(), new ByteSizeValue(existingTotalSize))__                cancellableThreads.execute(() ->_                        recoveryTarget.receiveFileInfo(response.phase1FileNames, response.phase1FileSizes, response.phase1ExistingFileNames,_                                response.phase1ExistingFileSizes, translogOps.get()))__                _                final Function<StoreFileMetaData, OutputStream> outputStreamFactories =_                        md -> new BufferedOutputStream(new RecoveryOutputStream(md, translogOps), chunkSizeInBytes)__                sendFiles(store, phase1Files.toArray(new StoreFileMetaData[phase1Files.size()]), outputStreamFactories)__                _                _                _                _                _                _                _                _                try {_                    cancellableThreads.executeIO(() ->_                        recoveryTarget.cleanFiles(translogOps.get(), recoverySourceMetadata))__                } catch (RemoteTransportException | IOException targetException) {_                    final IOException corruptIndexException__                    _                    _                    _                    _                    if ((corruptIndexException = ExceptionsHelper.unwrapCorruption(targetException)) != null) {_                        try {_                            final Store.MetadataSnapshot recoverySourceMetadata1 = store.getMetadata(snapshot)__                            StoreFileMetaData[] metadata =_                                    StreamSupport.stream(recoverySourceMetadata1.spliterator(), false).toArray(StoreFileMetaData[]::new)__                            ArrayUtil.timSort(metadata, Comparator.comparingLong(StoreFileMetaData::length))_ _                            for (StoreFileMetaData md : metadata) {_                                cancellableThreads.checkForCancel()__                                logger.debug("checking integrity for file {} after remove corruption exception", md)__                                if (store.checkIntegrityNoException(md) == false) { _                                    shard.failShard("recovery", corruptIndexException)__                                    logger.warn("Corrupted file detected {} checksum mismatch", md)__                                    throw corruptIndexException__                                }_                            }_                        } catch (IOException ex) {_                            targetException.addSuppressed(ex)__                            throw targetException__                        }_                        _                        RemoteTransportException exception = new RemoteTransportException("File corruption occurred on recovery but " +_                                "checksums are ok", null)__                        exception.addSuppressed(targetException)__                        logger.warn(() -> new ParameterizedMessage(_                                "{} Remote file corruption during finalization of recovery on node {}. local checksum OK",_                                shard.shardId(), request.targetNode()), corruptIndexException)__                        throw exception__                    } else {_                        throw targetException__                    }_                }_            }__            logger.trace("recovery [phase1]: took [{}]", stopWatch.totalTime())__            response.phase1Time = stopWatch.totalTime().millis()__        } catch (Exception e) {_            throw new RecoverFilesRecoveryException(request.shardId(), response.phase1FileNames.size(), new ByteSizeValue(totalSize), e)__        } finally {_            store.decRef()__        }_    };perform,phase1,of,the,recovery,operations,once,this,link,index,commit,snapshot,has,been,performed,no,commit,operations,files,being,fsync,d,are,effectively,allowed,on,this,index,until,all,recovery,phases,are,done,p,phase1,examines,the,segment,files,on,the,target,node,and,copies,over,the,segments,that,are,missing,only,segments,that,have,the,same,size,and,checksum,can,be,reused;public,void,phase1,final,index,commit,snapshot,final,supplier,integer,translog,ops,cancellable,threads,check,for,cancel,long,total,size,0,long,existing,total,size,0,final,store,store,shard,store,store,inc,ref,try,stop,watch,stop,watch,new,stop,watch,start,final,store,metadata,snapshot,recovery,source,metadata,try,recovery,source,metadata,store,get,metadata,snapshot,catch,corrupt,index,exception,index,format,too,old,exception,index,format,too,new,exception,ex,shard,fail,shard,recovery,ex,throw,ex,for,string,name,snapshot,get,file,names,final,store,file,meta,data,md,recovery,source,metadata,get,name,if,md,null,logger,info,snapshot,differs,from,actual,index,for,file,meta,name,recovery,source,metadata,as,map,throw,new,corrupt,index,exception,snapshot,differs,from,actual,index,maybe,index,was,removed,metadata,has,recovery,source,metadata,as,map,size,files,name,string,recovery,source,sync,id,recovery,source,metadata,get,sync,id,string,recovery,target,sync,id,request,metadata,snapshot,get,sync,id,final,boolean,recover,with,sync,id,recovery,source,sync,id,null,recovery,source,sync,id,equals,recovery,target,sync,id,if,recover,with,sync,id,final,long,num,docs,target,request,metadata,snapshot,get,num,docs,final,long,num,docs,source,recovery,source,metadata,get,num,docs,if,num,docs,target,num,docs,source,throw,new,illegal,state,exception,try,to,recover,request,shard,id,from,primary,shard,with,sync,id,but,number,of,docs,differ,num,docs,source,request,source,node,get,name,primary,vs,num,docs,target,request,target,node,get,name,logger,trace,skipping,phase1,identical,sync,id,found,on,both,source,and,target,recovery,source,sync,id,else,final,store,recovery,diff,diff,recovery,source,metadata,recovery,diff,request,metadata,snapshot,for,store,file,meta,data,md,diff,identical,response,phase1existing,file,names,add,md,name,response,phase1existing,file,sizes,add,md,length,existing,total,size,md,length,if,logger,is,trace,enabled,logger,trace,recovery,phase1,not,recovering,exist,in,local,store,and,has,checksum,size,md,name,md,checksum,md,length,total,size,md,length,list,store,file,meta,data,phase1files,new,array,list,diff,different,size,diff,missing,size,phase1files,add,all,diff,different,phase1files,add,all,diff,missing,for,store,file,meta,data,md,phase1files,if,request,metadata,snapshot,as,map,contains,key,md,name,logger,trace,recovery,phase1,recovering,exists,in,local,store,but,is,different,remote,local,md,name,request,metadata,snapshot,as,map,get,md,name,md,else,logger,trace,recovery,phase1,recovering,does,not,exist,in,remote,md,name,response,phase1file,names,add,md,name,response,phase1file,sizes,add,md,length,total,size,md,length,response,phase1total,size,total,size,response,phase1existing,total,size,existing,total,size,logger,trace,recovery,phase1,with,with,response,phase1file,names,size,new,byte,size,value,total,size,response,phase1existing,file,names,size,new,byte,size,value,existing,total,size,cancellable,threads,execute,recovery,target,receive,file,info,response,phase1file,names,response,phase1file,sizes,response,phase1existing,file,names,response,phase1existing,file,sizes,translog,ops,get,final,function,store,file,meta,data,output,stream,output,stream,factories,md,new,buffered,output,stream,new,recovery,output,stream,md,translog,ops,chunk,size,in,bytes,send,files,store,phase1files,to,array,new,store,file,meta,data,phase1files,size,output,stream,factories,try,cancellable,threads,execute,io,recovery,target,clean,files,translog,ops,get,recovery,source,metadata,catch,remote,transport,exception,ioexception,target,exception,final,ioexception,corrupt,index,exception,if,corrupt,index,exception,exceptions,helper,unwrap,corruption,target,exception,null,try,final,store,metadata,snapshot,recovery,source,metadata1,store,get,metadata,snapshot,store,file,meta,data,metadata,stream,support,stream,recovery,source,metadata1,spliterator,false,to,array,store,file,meta,data,new,array,util,tim,sort,metadata,comparator,comparing,long,store,file,meta,data,length,for,store,file,meta,data,md,metadata,cancellable,threads,check,for,cancel,logger,debug,checking,integrity,for,file,after,remove,corruption,exception,md,if,store,check,integrity,no,exception,md,false,shard,fail,shard,recovery,corrupt,index,exception,logger,warn,corrupted,file,detected,checksum,mismatch,md,throw,corrupt,index,exception,catch,ioexception,ex,target,exception,add,suppressed,ex,throw,target,exception,remote,transport,exception,exception,new,remote,transport,exception,file,corruption,occurred,on,recovery,but,checksums,are,ok,null,exception,add,suppressed,target,exception,logger,warn,new,parameterized,message,remote,file,corruption,during,finalization,of,recovery,on,node,local,checksum,ok,shard,shard,id,request,target,node,corrupt,index,exception,throw,exception,else,throw,target,exception,logger,trace,recovery,phase1,took,stop,watch,total,time,response,phase1time,stop,watch,total,time,millis,catch,exception,e,throw,new,recover,files,recovery,exception,request,shard,id,response,phase1file,names,size,new,byte,size,value,total,size,e,finally,store,dec,ref
RecoverySourceHandler -> public void phase1(final IndexCommit snapshot, final Supplier<Integer> translogOps);1535965276;Perform phase1 of the recovery operations. Once this {@link IndexCommit}_snapshot has been performed no commit operations (files being fsync'd)_are effectively allowed on this index until all recovery phases are done_<p>_Phase1 examines the segment files on the target node and copies over the_segments that are missing. Only segments that have the same size and_checksum can be reused;public void phase1(final IndexCommit snapshot, final Supplier<Integer> translogOps) {_        cancellableThreads.checkForCancel()__        _        long totalSize = 0__        _        long existingTotalSize = 0__        final Store store = shard.store()__        store.incRef()__        try {_            StopWatch stopWatch = new StopWatch().start()__            final Store.MetadataSnapshot recoverySourceMetadata__            try {_                recoverySourceMetadata = store.getMetadata(snapshot)__            } catch (CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {_                shard.failShard("recovery", ex)__                throw ex__            }_            for (String name : snapshot.getFileNames()) {_                final StoreFileMetaData md = recoverySourceMetadata.get(name)__                if (md == null) {_                    logger.info("Snapshot differs from actual index for file: {} meta: {}", name, recoverySourceMetadata.asMap())__                    throw new CorruptIndexException("Snapshot differs from actual index - maybe index was removed metadata has " +_                            recoverySourceMetadata.asMap().size() + " files", name)__                }_            }_            _            _            _            String recoverySourceSyncId = recoverySourceMetadata.getSyncId()__            String recoveryTargetSyncId = request.metadataSnapshot().getSyncId()__            final boolean recoverWithSyncId = recoverySourceSyncId != null &&_                    recoverySourceSyncId.equals(recoveryTargetSyncId)__            if (recoverWithSyncId) {_                final long numDocsTarget = request.metadataSnapshot().getNumDocs()__                final long numDocsSource = recoverySourceMetadata.getNumDocs()__                if (numDocsTarget != numDocsSource) {_                    throw new IllegalStateException("try to recover " + request.shardId() + " from primary shard with sync id but number " +_                            "of docs differ: " + numDocsSource + " (" + request.sourceNode().getName() + ", primary) vs " + numDocsTarget_                            + "(" + request.targetNode().getName() + ")")__                }_                _                _                logger.trace("skipping [phase1]- identical sync id [{}] found on both source and target", recoverySourceSyncId)__            } else {_                final Store.RecoveryDiff diff = recoverySourceMetadata.recoveryDiff(request.metadataSnapshot())__                for (StoreFileMetaData md : diff.identical) {_                    response.phase1ExistingFileNames.add(md.name())__                    response.phase1ExistingFileSizes.add(md.length())__                    existingTotalSize += md.length()__                    if (logger.isTraceEnabled()) {_                        logger.trace("recovery [phase1]: not recovering [{}], exist in local store and has checksum [{}]," +_                                        " size [{}]", md.name(), md.checksum(), md.length())__                    }_                    totalSize += md.length()__                }_                List<StoreFileMetaData> phase1Files = new ArrayList<>(diff.different.size() + diff.missing.size())__                phase1Files.addAll(diff.different)__                phase1Files.addAll(diff.missing)__                for (StoreFileMetaData md : phase1Files) {_                    if (request.metadataSnapshot().asMap().containsKey(md.name())) {_                        logger.trace("recovery [phase1]: recovering [{}], exists in local store, but is different: remote [{}], local [{}]",_                            md.name(), request.metadataSnapshot().asMap().get(md.name()), md)__                    } else {_                        logger.trace("recovery [phase1]: recovering [{}], does not exist in remote", md.name())__                    }_                    response.phase1FileNames.add(md.name())__                    response.phase1FileSizes.add(md.length())__                    totalSize += md.length()__                }__                response.phase1TotalSize = totalSize__                response.phase1ExistingTotalSize = existingTotalSize___                logger.trace("recovery [phase1]: recovering_files [{}] with total_size [{}], reusing_files [{}] with total_size [{}]",_                        response.phase1FileNames.size(),_                        new ByteSizeValue(totalSize), response.phase1ExistingFileNames.size(), new ByteSizeValue(existingTotalSize))__                cancellableThreads.execute(() ->_                        recoveryTarget.receiveFileInfo(response.phase1FileNames, response.phase1FileSizes, response.phase1ExistingFileNames,_                                response.phase1ExistingFileSizes, translogOps.get()))__                _                final Function<StoreFileMetaData, OutputStream> outputStreamFactories =_                        md -> new BufferedOutputStream(new RecoveryOutputStream(md, translogOps), chunkSizeInBytes)__                sendFiles(store, phase1Files.toArray(new StoreFileMetaData[phase1Files.size()]), outputStreamFactories)__                _                _                _                _                _                _                _                _                try {_                    cancellableThreads.executeIO(() ->_                        recoveryTarget.cleanFiles(translogOps.get(), recoverySourceMetadata))__                } catch (RemoteTransportException | IOException targetException) {_                    final IOException corruptIndexException__                    _                    _                    _                    _                    if ((corruptIndexException = ExceptionsHelper.unwrapCorruption(targetException)) != null) {_                        try {_                            final Store.MetadataSnapshot recoverySourceMetadata1 = store.getMetadata(snapshot)__                            StoreFileMetaData[] metadata =_                                    StreamSupport.stream(recoverySourceMetadata1.spliterator(), false).toArray(StoreFileMetaData[]::new)__                            ArrayUtil.timSort(metadata, Comparator.comparingLong(StoreFileMetaData::length))_ _                            for (StoreFileMetaData md : metadata) {_                                cancellableThreads.checkForCancel()__                                logger.debug("checking integrity for file {} after remove corruption exception", md)__                                if (store.checkIntegrityNoException(md) == false) { _                                    shard.failShard("recovery", corruptIndexException)__                                    logger.warn("Corrupted file detected {} checksum mismatch", md)__                                    throw corruptIndexException__                                }_                            }_                        } catch (IOException ex) {_                            targetException.addSuppressed(ex)__                            throw targetException__                        }_                        _                        RemoteTransportException exception = new RemoteTransportException("File corruption occurred on recovery but " +_                                "checksums are ok", null)__                        exception.addSuppressed(targetException)__                        logger.warn(() -> new ParameterizedMessage(_                                "{} Remote file corruption during finalization of recovery on node {}. local checksum OK",_                                shard.shardId(), request.targetNode()), corruptIndexException)__                        throw exception__                    } else {_                        throw targetException__                    }_                }_            }__            logger.trace("recovery [phase1]: took [{}]", stopWatch.totalTime())__            response.phase1Time = stopWatch.totalTime().millis()__        } catch (Exception e) {_            throw new RecoverFilesRecoveryException(request.shardId(), response.phase1FileNames.size(), new ByteSizeValue(totalSize), e)__        } finally {_            store.decRef()__        }_    };perform,phase1,of,the,recovery,operations,once,this,link,index,commit,snapshot,has,been,performed,no,commit,operations,files,being,fsync,d,are,effectively,allowed,on,this,index,until,all,recovery,phases,are,done,p,phase1,examines,the,segment,files,on,the,target,node,and,copies,over,the,segments,that,are,missing,only,segments,that,have,the,same,size,and,checksum,can,be,reused;public,void,phase1,final,index,commit,snapshot,final,supplier,integer,translog,ops,cancellable,threads,check,for,cancel,long,total,size,0,long,existing,total,size,0,final,store,store,shard,store,store,inc,ref,try,stop,watch,stop,watch,new,stop,watch,start,final,store,metadata,snapshot,recovery,source,metadata,try,recovery,source,metadata,store,get,metadata,snapshot,catch,corrupt,index,exception,index,format,too,old,exception,index,format,too,new,exception,ex,shard,fail,shard,recovery,ex,throw,ex,for,string,name,snapshot,get,file,names,final,store,file,meta,data,md,recovery,source,metadata,get,name,if,md,null,logger,info,snapshot,differs,from,actual,index,for,file,meta,name,recovery,source,metadata,as,map,throw,new,corrupt,index,exception,snapshot,differs,from,actual,index,maybe,index,was,removed,metadata,has,recovery,source,metadata,as,map,size,files,name,string,recovery,source,sync,id,recovery,source,metadata,get,sync,id,string,recovery,target,sync,id,request,metadata,snapshot,get,sync,id,final,boolean,recover,with,sync,id,recovery,source,sync,id,null,recovery,source,sync,id,equals,recovery,target,sync,id,if,recover,with,sync,id,final,long,num,docs,target,request,metadata,snapshot,get,num,docs,final,long,num,docs,source,recovery,source,metadata,get,num,docs,if,num,docs,target,num,docs,source,throw,new,illegal,state,exception,try,to,recover,request,shard,id,from,primary,shard,with,sync,id,but,number,of,docs,differ,num,docs,source,request,source,node,get,name,primary,vs,num,docs,target,request,target,node,get,name,logger,trace,skipping,phase1,identical,sync,id,found,on,both,source,and,target,recovery,source,sync,id,else,final,store,recovery,diff,diff,recovery,source,metadata,recovery,diff,request,metadata,snapshot,for,store,file,meta,data,md,diff,identical,response,phase1existing,file,names,add,md,name,response,phase1existing,file,sizes,add,md,length,existing,total,size,md,length,if,logger,is,trace,enabled,logger,trace,recovery,phase1,not,recovering,exist,in,local,store,and,has,checksum,size,md,name,md,checksum,md,length,total,size,md,length,list,store,file,meta,data,phase1files,new,array,list,diff,different,size,diff,missing,size,phase1files,add,all,diff,different,phase1files,add,all,diff,missing,for,store,file,meta,data,md,phase1files,if,request,metadata,snapshot,as,map,contains,key,md,name,logger,trace,recovery,phase1,recovering,exists,in,local,store,but,is,different,remote,local,md,name,request,metadata,snapshot,as,map,get,md,name,md,else,logger,trace,recovery,phase1,recovering,does,not,exist,in,remote,md,name,response,phase1file,names,add,md,name,response,phase1file,sizes,add,md,length,total,size,md,length,response,phase1total,size,total,size,response,phase1existing,total,size,existing,total,size,logger,trace,recovery,phase1,with,with,response,phase1file,names,size,new,byte,size,value,total,size,response,phase1existing,file,names,size,new,byte,size,value,existing,total,size,cancellable,threads,execute,recovery,target,receive,file,info,response,phase1file,names,response,phase1file,sizes,response,phase1existing,file,names,response,phase1existing,file,sizes,translog,ops,get,final,function,store,file,meta,data,output,stream,output,stream,factories,md,new,buffered,output,stream,new,recovery,output,stream,md,translog,ops,chunk,size,in,bytes,send,files,store,phase1files,to,array,new,store,file,meta,data,phase1files,size,output,stream,factories,try,cancellable,threads,execute,io,recovery,target,clean,files,translog,ops,get,recovery,source,metadata,catch,remote,transport,exception,ioexception,target,exception,final,ioexception,corrupt,index,exception,if,corrupt,index,exception,exceptions,helper,unwrap,corruption,target,exception,null,try,final,store,metadata,snapshot,recovery,source,metadata1,store,get,metadata,snapshot,store,file,meta,data,metadata,stream,support,stream,recovery,source,metadata1,spliterator,false,to,array,store,file,meta,data,new,array,util,tim,sort,metadata,comparator,comparing,long,store,file,meta,data,length,for,store,file,meta,data,md,metadata,cancellable,threads,check,for,cancel,logger,debug,checking,integrity,for,file,after,remove,corruption,exception,md,if,store,check,integrity,no,exception,md,false,shard,fail,shard,recovery,corrupt,index,exception,logger,warn,corrupted,file,detected,checksum,mismatch,md,throw,corrupt,index,exception,catch,ioexception,ex,target,exception,add,suppressed,ex,throw,target,exception,remote,transport,exception,exception,new,remote,transport,exception,file,corruption,occurred,on,recovery,but,checksums,are,ok,null,exception,add,suppressed,target,exception,logger,warn,new,parameterized,message,remote,file,corruption,during,finalization,of,recovery,on,node,local,checksum,ok,shard,shard,id,request,target,node,corrupt,index,exception,throw,exception,else,throw,target,exception,logger,trace,recovery,phase1,took,stop,watch,total,time,response,phase1time,stop,watch,total,time,millis,catch,exception,e,throw,new,recover,files,recovery,exception,request,shard,id,response,phase1file,names,size,new,byte,size,value,total,size,e,finally,store,dec,ref
RecoverySourceHandler -> public void phase1(final IndexCommit snapshot, final Supplier<Integer> translogOps);1537806831;Perform phase1 of the recovery operations. Once this {@link IndexCommit}_snapshot has been performed no commit operations (files being fsync'd)_are effectively allowed on this index until all recovery phases are done_<p>_Phase1 examines the segment files on the target node and copies over the_segments that are missing. Only segments that have the same size and_checksum can be reused;public void phase1(final IndexCommit snapshot, final Supplier<Integer> translogOps) {_        cancellableThreads.checkForCancel()__        _        long totalSize = 0__        _        long existingTotalSize = 0__        final Store store = shard.store()__        store.incRef()__        try {_            StopWatch stopWatch = new StopWatch().start()__            final Store.MetadataSnapshot recoverySourceMetadata__            try {_                recoverySourceMetadata = store.getMetadata(snapshot)__            } catch (CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {_                shard.failShard("recovery", ex)__                throw ex__            }_            for (String name : snapshot.getFileNames()) {_                final StoreFileMetaData md = recoverySourceMetadata.get(name)__                if (md == null) {_                    logger.info("Snapshot differs from actual index for file: {} meta: {}", name, recoverySourceMetadata.asMap())__                    throw new CorruptIndexException("Snapshot differs from actual index - maybe index was removed metadata has " +_                            recoverySourceMetadata.asMap().size() + " files", name)__                }_            }_            _            _            _            String recoverySourceSyncId = recoverySourceMetadata.getSyncId()__            String recoveryTargetSyncId = request.metadataSnapshot().getSyncId()__            final boolean recoverWithSyncId = recoverySourceSyncId != null &&_                    recoverySourceSyncId.equals(recoveryTargetSyncId)__            if (recoverWithSyncId) {_                final long numDocsTarget = request.metadataSnapshot().getNumDocs()__                final long numDocsSource = recoverySourceMetadata.getNumDocs()__                if (numDocsTarget != numDocsSource) {_                    throw new IllegalStateException("try to recover " + request.shardId() + " from primary shard with sync id but number " +_                            "of docs differ: " + numDocsSource + " (" + request.sourceNode().getName() + ", primary) vs " + numDocsTarget_                            + "(" + request.targetNode().getName() + ")")__                }_                _                _                logger.trace("skipping [phase1]- identical sync id [{}] found on both source and target", recoverySourceSyncId)__            } else {_                final Store.RecoveryDiff diff = recoverySourceMetadata.recoveryDiff(request.metadataSnapshot())__                for (StoreFileMetaData md : diff.identical) {_                    response.phase1ExistingFileNames.add(md.name())__                    response.phase1ExistingFileSizes.add(md.length())__                    existingTotalSize += md.length()__                    if (logger.isTraceEnabled()) {_                        logger.trace("recovery [phase1]: not recovering [{}], exist in local store and has checksum [{}]," +_                                        " size [{}]", md.name(), md.checksum(), md.length())__                    }_                    totalSize += md.length()__                }_                List<StoreFileMetaData> phase1Files = new ArrayList<>(diff.different.size() + diff.missing.size())__                phase1Files.addAll(diff.different)__                phase1Files.addAll(diff.missing)__                for (StoreFileMetaData md : phase1Files) {_                    if (request.metadataSnapshot().asMap().containsKey(md.name())) {_                        logger.trace("recovery [phase1]: recovering [{}], exists in local store, but is different: remote [{}], local [{}]",_                            md.name(), request.metadataSnapshot().asMap().get(md.name()), md)__                    } else {_                        logger.trace("recovery [phase1]: recovering [{}], does not exist in remote", md.name())__                    }_                    response.phase1FileNames.add(md.name())__                    response.phase1FileSizes.add(md.length())__                    totalSize += md.length()__                }__                response.phase1TotalSize = totalSize__                response.phase1ExistingTotalSize = existingTotalSize___                logger.trace("recovery [phase1]: recovering_files [{}] with total_size [{}], reusing_files [{}] with total_size [{}]",_                        response.phase1FileNames.size(),_                        new ByteSizeValue(totalSize), response.phase1ExistingFileNames.size(), new ByteSizeValue(existingTotalSize))__                cancellableThreads.execute(() ->_                        recoveryTarget.receiveFileInfo(response.phase1FileNames, response.phase1FileSizes, response.phase1ExistingFileNames,_                                response.phase1ExistingFileSizes, translogOps.get()))__                _                final Function<StoreFileMetaData, OutputStream> outputStreamFactories =_                        md -> new BufferedOutputStream(new RecoveryOutputStream(md, translogOps), chunkSizeInBytes)__                sendFiles(store, phase1Files.toArray(new StoreFileMetaData[phase1Files.size()]), outputStreamFactories)__                _                _                _                _                _                _                _                _                try {_                    cancellableThreads.executeIO(() ->_                        recoveryTarget.cleanFiles(translogOps.get(), recoverySourceMetadata))__                } catch (RemoteTransportException | IOException targetException) {_                    final IOException corruptIndexException__                    _                    _                    _                    _                    if ((corruptIndexException = ExceptionsHelper.unwrapCorruption(targetException)) != null) {_                        try {_                            final Store.MetadataSnapshot recoverySourceMetadata1 = store.getMetadata(snapshot)__                            StoreFileMetaData[] metadata =_                                    StreamSupport.stream(recoverySourceMetadata1.spliterator(), false).toArray(StoreFileMetaData[]::new)__                            ArrayUtil.timSort(metadata, Comparator.comparingLong(StoreFileMetaData::length))_ _                            for (StoreFileMetaData md : metadata) {_                                cancellableThreads.checkForCancel()__                                logger.debug("checking integrity for file {} after remove corruption exception", md)__                                if (store.checkIntegrityNoException(md) == false) { _                                    shard.failShard("recovery", corruptIndexException)__                                    logger.warn("Corrupted file detected {} checksum mismatch", md)__                                    throw corruptIndexException__                                }_                            }_                        } catch (IOException ex) {_                            targetException.addSuppressed(ex)__                            throw targetException__                        }_                        _                        RemoteTransportException exception = new RemoteTransportException("File corruption occurred on recovery but " +_                                "checksums are ok", null)__                        exception.addSuppressed(targetException)__                        logger.warn(() -> new ParameterizedMessage(_                                "{} Remote file corruption during finalization of recovery on node {}. local checksum OK",_                                shard.shardId(), request.targetNode()), corruptIndexException)__                        throw exception__                    } else {_                        throw targetException__                    }_                }_            }__            logger.trace("recovery [phase1]: took [{}]", stopWatch.totalTime())__            response.phase1Time = stopWatch.totalTime().millis()__        } catch (Exception e) {_            throw new RecoverFilesRecoveryException(request.shardId(), response.phase1FileNames.size(), new ByteSizeValue(totalSize), e)__        } finally {_            store.decRef()__        }_    };perform,phase1,of,the,recovery,operations,once,this,link,index,commit,snapshot,has,been,performed,no,commit,operations,files,being,fsync,d,are,effectively,allowed,on,this,index,until,all,recovery,phases,are,done,p,phase1,examines,the,segment,files,on,the,target,node,and,copies,over,the,segments,that,are,missing,only,segments,that,have,the,same,size,and,checksum,can,be,reused;public,void,phase1,final,index,commit,snapshot,final,supplier,integer,translog,ops,cancellable,threads,check,for,cancel,long,total,size,0,long,existing,total,size,0,final,store,store,shard,store,store,inc,ref,try,stop,watch,stop,watch,new,stop,watch,start,final,store,metadata,snapshot,recovery,source,metadata,try,recovery,source,metadata,store,get,metadata,snapshot,catch,corrupt,index,exception,index,format,too,old,exception,index,format,too,new,exception,ex,shard,fail,shard,recovery,ex,throw,ex,for,string,name,snapshot,get,file,names,final,store,file,meta,data,md,recovery,source,metadata,get,name,if,md,null,logger,info,snapshot,differs,from,actual,index,for,file,meta,name,recovery,source,metadata,as,map,throw,new,corrupt,index,exception,snapshot,differs,from,actual,index,maybe,index,was,removed,metadata,has,recovery,source,metadata,as,map,size,files,name,string,recovery,source,sync,id,recovery,source,metadata,get,sync,id,string,recovery,target,sync,id,request,metadata,snapshot,get,sync,id,final,boolean,recover,with,sync,id,recovery,source,sync,id,null,recovery,source,sync,id,equals,recovery,target,sync,id,if,recover,with,sync,id,final,long,num,docs,target,request,metadata,snapshot,get,num,docs,final,long,num,docs,source,recovery,source,metadata,get,num,docs,if,num,docs,target,num,docs,source,throw,new,illegal,state,exception,try,to,recover,request,shard,id,from,primary,shard,with,sync,id,but,number,of,docs,differ,num,docs,source,request,source,node,get,name,primary,vs,num,docs,target,request,target,node,get,name,logger,trace,skipping,phase1,identical,sync,id,found,on,both,source,and,target,recovery,source,sync,id,else,final,store,recovery,diff,diff,recovery,source,metadata,recovery,diff,request,metadata,snapshot,for,store,file,meta,data,md,diff,identical,response,phase1existing,file,names,add,md,name,response,phase1existing,file,sizes,add,md,length,existing,total,size,md,length,if,logger,is,trace,enabled,logger,trace,recovery,phase1,not,recovering,exist,in,local,store,and,has,checksum,size,md,name,md,checksum,md,length,total,size,md,length,list,store,file,meta,data,phase1files,new,array,list,diff,different,size,diff,missing,size,phase1files,add,all,diff,different,phase1files,add,all,diff,missing,for,store,file,meta,data,md,phase1files,if,request,metadata,snapshot,as,map,contains,key,md,name,logger,trace,recovery,phase1,recovering,exists,in,local,store,but,is,different,remote,local,md,name,request,metadata,snapshot,as,map,get,md,name,md,else,logger,trace,recovery,phase1,recovering,does,not,exist,in,remote,md,name,response,phase1file,names,add,md,name,response,phase1file,sizes,add,md,length,total,size,md,length,response,phase1total,size,total,size,response,phase1existing,total,size,existing,total,size,logger,trace,recovery,phase1,with,with,response,phase1file,names,size,new,byte,size,value,total,size,response,phase1existing,file,names,size,new,byte,size,value,existing,total,size,cancellable,threads,execute,recovery,target,receive,file,info,response,phase1file,names,response,phase1file,sizes,response,phase1existing,file,names,response,phase1existing,file,sizes,translog,ops,get,final,function,store,file,meta,data,output,stream,output,stream,factories,md,new,buffered,output,stream,new,recovery,output,stream,md,translog,ops,chunk,size,in,bytes,send,files,store,phase1files,to,array,new,store,file,meta,data,phase1files,size,output,stream,factories,try,cancellable,threads,execute,io,recovery,target,clean,files,translog,ops,get,recovery,source,metadata,catch,remote,transport,exception,ioexception,target,exception,final,ioexception,corrupt,index,exception,if,corrupt,index,exception,exceptions,helper,unwrap,corruption,target,exception,null,try,final,store,metadata,snapshot,recovery,source,metadata1,store,get,metadata,snapshot,store,file,meta,data,metadata,stream,support,stream,recovery,source,metadata1,spliterator,false,to,array,store,file,meta,data,new,array,util,tim,sort,metadata,comparator,comparing,long,store,file,meta,data,length,for,store,file,meta,data,md,metadata,cancellable,threads,check,for,cancel,logger,debug,checking,integrity,for,file,after,remove,corruption,exception,md,if,store,check,integrity,no,exception,md,false,shard,fail,shard,recovery,corrupt,index,exception,logger,warn,corrupted,file,detected,checksum,mismatch,md,throw,corrupt,index,exception,catch,ioexception,ex,target,exception,add,suppressed,ex,throw,target,exception,remote,transport,exception,exception,new,remote,transport,exception,file,corruption,occurred,on,recovery,but,checksums,are,ok,null,exception,add,suppressed,target,exception,logger,warn,new,parameterized,message,remote,file,corruption,during,finalization,of,recovery,on,node,local,checksum,ok,shard,shard,id,request,target,node,corrupt,index,exception,throw,exception,else,throw,target,exception,logger,trace,recovery,phase1,took,stop,watch,total,time,response,phase1time,stop,watch,total,time,millis,catch,exception,e,throw,new,recover,files,recovery,exception,request,shard,id,response,phase1file,names,size,new,byte,size,value,total,size,e,finally,store,dec,ref
RecoverySourceHandler -> public void phase1(final IndexCommit snapshot, final Supplier<Integer> translogOps);1538067637;Perform phase1 of the recovery operations. Once this {@link IndexCommit}_snapshot has been performed no commit operations (files being fsync'd)_are effectively allowed on this index until all recovery phases are done_<p>_Phase1 examines the segment files on the target node and copies over the_segments that are missing. Only segments that have the same size and_checksum can be reused;public void phase1(final IndexCommit snapshot, final Supplier<Integer> translogOps) {_        cancellableThreads.checkForCancel()__        _        long totalSize = 0__        _        long existingTotalSize = 0__        final Store store = shard.store()__        store.incRef()__        try {_            StopWatch stopWatch = new StopWatch().start()__            final Store.MetadataSnapshot recoverySourceMetadata__            try {_                recoverySourceMetadata = store.getMetadata(snapshot)__            } catch (CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {_                shard.failShard("recovery", ex)__                throw ex__            }_            for (String name : snapshot.getFileNames()) {_                final StoreFileMetaData md = recoverySourceMetadata.get(name)__                if (md == null) {_                    logger.info("Snapshot differs from actual index for file: {} meta: {}", name, recoverySourceMetadata.asMap())__                    throw new CorruptIndexException("Snapshot differs from actual index - maybe index was removed metadata has " +_                            recoverySourceMetadata.asMap().size() + " files", name)__                }_            }_            _            _            _            String recoverySourceSyncId = recoverySourceMetadata.getSyncId()__            String recoveryTargetSyncId = request.metadataSnapshot().getSyncId()__            final boolean recoverWithSyncId = recoverySourceSyncId != null &&_                    recoverySourceSyncId.equals(recoveryTargetSyncId)__            if (recoverWithSyncId) {_                final long numDocsTarget = request.metadataSnapshot().getNumDocs()__                final long numDocsSource = recoverySourceMetadata.getNumDocs()__                if (numDocsTarget != numDocsSource) {_                    throw new IllegalStateException("try to recover " + request.shardId() + " from primary shard with sync id but number " +_                            "of docs differ: " + numDocsSource + " (" + request.sourceNode().getName() + ", primary) vs " + numDocsTarget_                            + "(" + request.targetNode().getName() + ")")__                }_                _                _                logger.trace("skipping [phase1]- identical sync id [{}] found on both source and target", recoverySourceSyncId)__            } else {_                final Store.RecoveryDiff diff = recoverySourceMetadata.recoveryDiff(request.metadataSnapshot())__                for (StoreFileMetaData md : diff.identical) {_                    response.phase1ExistingFileNames.add(md.name())__                    response.phase1ExistingFileSizes.add(md.length())__                    existingTotalSize += md.length()__                    if (logger.isTraceEnabled()) {_                        logger.trace("recovery [phase1]: not recovering [{}], exist in local store and has checksum [{}]," +_                                        " size [{}]", md.name(), md.checksum(), md.length())__                    }_                    totalSize += md.length()__                }_                List<StoreFileMetaData> phase1Files = new ArrayList<>(diff.different.size() + diff.missing.size())__                phase1Files.addAll(diff.different)__                phase1Files.addAll(diff.missing)__                for (StoreFileMetaData md : phase1Files) {_                    if (request.metadataSnapshot().asMap().containsKey(md.name())) {_                        logger.trace("recovery [phase1]: recovering [{}], exists in local store, but is different: remote [{}], local [{}]",_                            md.name(), request.metadataSnapshot().asMap().get(md.name()), md)__                    } else {_                        logger.trace("recovery [phase1]: recovering [{}], does not exist in remote", md.name())__                    }_                    response.phase1FileNames.add(md.name())__                    response.phase1FileSizes.add(md.length())__                    totalSize += md.length()__                }__                response.phase1TotalSize = totalSize__                response.phase1ExistingTotalSize = existingTotalSize___                logger.trace("recovery [phase1]: recovering_files [{}] with total_size [{}], reusing_files [{}] with total_size [{}]",_                        response.phase1FileNames.size(),_                        new ByteSizeValue(totalSize), response.phase1ExistingFileNames.size(), new ByteSizeValue(existingTotalSize))__                cancellableThreads.execute(() ->_                        recoveryTarget.receiveFileInfo(response.phase1FileNames, response.phase1FileSizes, response.phase1ExistingFileNames,_                                response.phase1ExistingFileSizes, translogOps.get()))__                _                final Function<StoreFileMetaData, OutputStream> outputStreamFactories =_                        md -> new BufferedOutputStream(new RecoveryOutputStream(md, translogOps), chunkSizeInBytes)__                sendFiles(store, phase1Files.toArray(new StoreFileMetaData[phase1Files.size()]), outputStreamFactories)__                _                _                _                _                _                _                _                _                try {_                    cancellableThreads.executeIO(() ->_                        recoveryTarget.cleanFiles(translogOps.get(), recoverySourceMetadata))__                } catch (RemoteTransportException | IOException targetException) {_                    final IOException corruptIndexException__                    _                    _                    _                    _                    if ((corruptIndexException = ExceptionsHelper.unwrapCorruption(targetException)) != null) {_                        try {_                            final Store.MetadataSnapshot recoverySourceMetadata1 = store.getMetadata(snapshot)__                            StoreFileMetaData[] metadata =_                                    StreamSupport.stream(recoverySourceMetadata1.spliterator(), false).toArray(StoreFileMetaData[]::new)__                            ArrayUtil.timSort(metadata, Comparator.comparingLong(StoreFileMetaData::length))_ _                            for (StoreFileMetaData md : metadata) {_                                cancellableThreads.checkForCancel()__                                logger.debug("checking integrity for file {} after remove corruption exception", md)__                                if (store.checkIntegrityNoException(md) == false) { _                                    shard.failShard("recovery", corruptIndexException)__                                    logger.warn("Corrupted file detected {} checksum mismatch", md)__                                    throw corruptIndexException__                                }_                            }_                        } catch (IOException ex) {_                            targetException.addSuppressed(ex)__                            throw targetException__                        }_                        _                        RemoteTransportException exception = new RemoteTransportException("File corruption occurred on recovery but " +_                                "checksums are ok", null)__                        exception.addSuppressed(targetException)__                        logger.warn(() -> new ParameterizedMessage(_                                "{} Remote file corruption during finalization of recovery on node {}. local checksum OK",_                                shard.shardId(), request.targetNode()), corruptIndexException)__                        throw exception__                    } else {_                        throw targetException__                    }_                }_            }__            logger.trace("recovery [phase1]: took [{}]", stopWatch.totalTime())__            response.phase1Time = stopWatch.totalTime().millis()__        } catch (Exception e) {_            throw new RecoverFilesRecoveryException(request.shardId(), response.phase1FileNames.size(), new ByteSizeValue(totalSize), e)__        } finally {_            store.decRef()__        }_    };perform,phase1,of,the,recovery,operations,once,this,link,index,commit,snapshot,has,been,performed,no,commit,operations,files,being,fsync,d,are,effectively,allowed,on,this,index,until,all,recovery,phases,are,done,p,phase1,examines,the,segment,files,on,the,target,node,and,copies,over,the,segments,that,are,missing,only,segments,that,have,the,same,size,and,checksum,can,be,reused;public,void,phase1,final,index,commit,snapshot,final,supplier,integer,translog,ops,cancellable,threads,check,for,cancel,long,total,size,0,long,existing,total,size,0,final,store,store,shard,store,store,inc,ref,try,stop,watch,stop,watch,new,stop,watch,start,final,store,metadata,snapshot,recovery,source,metadata,try,recovery,source,metadata,store,get,metadata,snapshot,catch,corrupt,index,exception,index,format,too,old,exception,index,format,too,new,exception,ex,shard,fail,shard,recovery,ex,throw,ex,for,string,name,snapshot,get,file,names,final,store,file,meta,data,md,recovery,source,metadata,get,name,if,md,null,logger,info,snapshot,differs,from,actual,index,for,file,meta,name,recovery,source,metadata,as,map,throw,new,corrupt,index,exception,snapshot,differs,from,actual,index,maybe,index,was,removed,metadata,has,recovery,source,metadata,as,map,size,files,name,string,recovery,source,sync,id,recovery,source,metadata,get,sync,id,string,recovery,target,sync,id,request,metadata,snapshot,get,sync,id,final,boolean,recover,with,sync,id,recovery,source,sync,id,null,recovery,source,sync,id,equals,recovery,target,sync,id,if,recover,with,sync,id,final,long,num,docs,target,request,metadata,snapshot,get,num,docs,final,long,num,docs,source,recovery,source,metadata,get,num,docs,if,num,docs,target,num,docs,source,throw,new,illegal,state,exception,try,to,recover,request,shard,id,from,primary,shard,with,sync,id,but,number,of,docs,differ,num,docs,source,request,source,node,get,name,primary,vs,num,docs,target,request,target,node,get,name,logger,trace,skipping,phase1,identical,sync,id,found,on,both,source,and,target,recovery,source,sync,id,else,final,store,recovery,diff,diff,recovery,source,metadata,recovery,diff,request,metadata,snapshot,for,store,file,meta,data,md,diff,identical,response,phase1existing,file,names,add,md,name,response,phase1existing,file,sizes,add,md,length,existing,total,size,md,length,if,logger,is,trace,enabled,logger,trace,recovery,phase1,not,recovering,exist,in,local,store,and,has,checksum,size,md,name,md,checksum,md,length,total,size,md,length,list,store,file,meta,data,phase1files,new,array,list,diff,different,size,diff,missing,size,phase1files,add,all,diff,different,phase1files,add,all,diff,missing,for,store,file,meta,data,md,phase1files,if,request,metadata,snapshot,as,map,contains,key,md,name,logger,trace,recovery,phase1,recovering,exists,in,local,store,but,is,different,remote,local,md,name,request,metadata,snapshot,as,map,get,md,name,md,else,logger,trace,recovery,phase1,recovering,does,not,exist,in,remote,md,name,response,phase1file,names,add,md,name,response,phase1file,sizes,add,md,length,total,size,md,length,response,phase1total,size,total,size,response,phase1existing,total,size,existing,total,size,logger,trace,recovery,phase1,with,with,response,phase1file,names,size,new,byte,size,value,total,size,response,phase1existing,file,names,size,new,byte,size,value,existing,total,size,cancellable,threads,execute,recovery,target,receive,file,info,response,phase1file,names,response,phase1file,sizes,response,phase1existing,file,names,response,phase1existing,file,sizes,translog,ops,get,final,function,store,file,meta,data,output,stream,output,stream,factories,md,new,buffered,output,stream,new,recovery,output,stream,md,translog,ops,chunk,size,in,bytes,send,files,store,phase1files,to,array,new,store,file,meta,data,phase1files,size,output,stream,factories,try,cancellable,threads,execute,io,recovery,target,clean,files,translog,ops,get,recovery,source,metadata,catch,remote,transport,exception,ioexception,target,exception,final,ioexception,corrupt,index,exception,if,corrupt,index,exception,exceptions,helper,unwrap,corruption,target,exception,null,try,final,store,metadata,snapshot,recovery,source,metadata1,store,get,metadata,snapshot,store,file,meta,data,metadata,stream,support,stream,recovery,source,metadata1,spliterator,false,to,array,store,file,meta,data,new,array,util,tim,sort,metadata,comparator,comparing,long,store,file,meta,data,length,for,store,file,meta,data,md,metadata,cancellable,threads,check,for,cancel,logger,debug,checking,integrity,for,file,after,remove,corruption,exception,md,if,store,check,integrity,no,exception,md,false,shard,fail,shard,recovery,corrupt,index,exception,logger,warn,corrupted,file,detected,checksum,mismatch,md,throw,corrupt,index,exception,catch,ioexception,ex,target,exception,add,suppressed,ex,throw,target,exception,remote,transport,exception,exception,new,remote,transport,exception,file,corruption,occurred,on,recovery,but,checksums,are,ok,null,exception,add,suppressed,target,exception,logger,warn,new,parameterized,message,remote,file,corruption,during,finalization,of,recovery,on,node,local,checksum,ok,shard,shard,id,request,target,node,corrupt,index,exception,throw,exception,else,throw,target,exception,logger,trace,recovery,phase1,took,stop,watch,total,time,response,phase1time,stop,watch,total,time,millis,catch,exception,e,throw,new,recover,files,recovery,exception,request,shard,id,response,phase1file,names,size,new,byte,size,value,total,size,e,finally,store,dec,ref
RecoverySourceHandler -> public void phase1(final IndexCommit snapshot, final Supplier<Integer> translogOps);1546446953;Perform phase1 of the recovery operations. Once this {@link IndexCommit}_snapshot has been performed no commit operations (files being fsync'd)_are effectively allowed on this index until all recovery phases are done_<p>_Phase1 examines the segment files on the target node and copies over the_segments that are missing. Only segments that have the same size and_checksum can be reused;public void phase1(final IndexCommit snapshot, final Supplier<Integer> translogOps) {_        cancellableThreads.checkForCancel()__        _        long totalSize = 0__        _        long existingTotalSize = 0__        final Store store = shard.store()__        store.incRef()__        try {_            StopWatch stopWatch = new StopWatch().start()__            final Store.MetadataSnapshot recoverySourceMetadata__            try {_                recoverySourceMetadata = store.getMetadata(snapshot)__            } catch (CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {_                shard.failShard("recovery", ex)__                throw ex__            }_            for (String name : snapshot.getFileNames()) {_                final StoreFileMetaData md = recoverySourceMetadata.get(name)__                if (md == null) {_                    logger.info("Snapshot differs from actual index for file: {} meta: {}", name, recoverySourceMetadata.asMap())__                    throw new CorruptIndexException("Snapshot differs from actual index - maybe index was removed metadata has " +_                            recoverySourceMetadata.asMap().size() + " files", name)__                }_            }_            _            _            _            String recoverySourceSyncId = recoverySourceMetadata.getSyncId()__            String recoveryTargetSyncId = request.metadataSnapshot().getSyncId()__            final boolean recoverWithSyncId = recoverySourceSyncId != null &&_                    recoverySourceSyncId.equals(recoveryTargetSyncId)__            if (recoverWithSyncId) {_                final long numDocsTarget = request.metadataSnapshot().getNumDocs()__                final long numDocsSource = recoverySourceMetadata.getNumDocs()__                if (numDocsTarget != numDocsSource) {_                    throw new IllegalStateException("try to recover " + request.shardId() + " from primary shard with sync id but number " +_                            "of docs differ: " + numDocsSource + " (" + request.sourceNode().getName() + ", primary) vs " + numDocsTarget_                            + "(" + request.targetNode().getName() + ")")__                }_                _                _                logger.trace("skipping [phase1]- identical sync id [{}] found on both source and target", recoverySourceSyncId)__            } else {_                final Store.RecoveryDiff diff = recoverySourceMetadata.recoveryDiff(request.metadataSnapshot())__                for (StoreFileMetaData md : diff.identical) {_                    response.phase1ExistingFileNames.add(md.name())__                    response.phase1ExistingFileSizes.add(md.length())__                    existingTotalSize += md.length()__                    if (logger.isTraceEnabled()) {_                        logger.trace("recovery [phase1]: not recovering [{}], exist in local store and has checksum [{}]," +_                                        " size [{}]", md.name(), md.checksum(), md.length())__                    }_                    totalSize += md.length()__                }_                List<StoreFileMetaData> phase1Files = new ArrayList<>(diff.different.size() + diff.missing.size())__                phase1Files.addAll(diff.different)__                phase1Files.addAll(diff.missing)__                for (StoreFileMetaData md : phase1Files) {_                    if (request.metadataSnapshot().asMap().containsKey(md.name())) {_                        logger.trace("recovery [phase1]: recovering [{}], exists in local store, but is different: remote [{}], local [{}]",_                            md.name(), request.metadataSnapshot().asMap().get(md.name()), md)__                    } else {_                        logger.trace("recovery [phase1]: recovering [{}], does not exist in remote", md.name())__                    }_                    response.phase1FileNames.add(md.name())__                    response.phase1FileSizes.add(md.length())__                    totalSize += md.length()__                }__                response.phase1TotalSize = totalSize__                response.phase1ExistingTotalSize = existingTotalSize___                logger.trace("recovery [phase1]: recovering_files [{}] with total_size [{}], reusing_files [{}] with total_size [{}]",_                        response.phase1FileNames.size(),_                        new ByteSizeValue(totalSize), response.phase1ExistingFileNames.size(), new ByteSizeValue(existingTotalSize))__                cancellableThreads.execute(() ->_                        recoveryTarget.receiveFileInfo(response.phase1FileNames, response.phase1FileSizes, response.phase1ExistingFileNames,_                                response.phase1ExistingFileSizes, translogOps.get()))__                _                final Function<StoreFileMetaData, OutputStream> outputStreamFactories =_                        md -> new BufferedOutputStream(new RecoveryOutputStream(md, translogOps), chunkSizeInBytes)__                sendFiles(store, phase1Files.toArray(new StoreFileMetaData[phase1Files.size()]), outputStreamFactories)__                _                _                _                _                _                _                _                _                try {_                    cancellableThreads.executeIO(() ->_                        recoveryTarget.cleanFiles(translogOps.get(), recoverySourceMetadata))__                } catch (RemoteTransportException | IOException targetException) {_                    final IOException corruptIndexException__                    _                    _                    _                    _                    if ((corruptIndexException = ExceptionsHelper.unwrapCorruption(targetException)) != null) {_                        try {_                            final Store.MetadataSnapshot recoverySourceMetadata1 = store.getMetadata(snapshot)__                            StoreFileMetaData[] metadata =_                                    StreamSupport.stream(recoverySourceMetadata1.spliterator(), false).toArray(StoreFileMetaData[]::new)__                            ArrayUtil.timSort(metadata, Comparator.comparingLong(StoreFileMetaData::length))_ _                            for (StoreFileMetaData md : metadata) {_                                cancellableThreads.checkForCancel()__                                logger.debug("checking integrity for file {} after remove corruption exception", md)__                                if (store.checkIntegrityNoException(md) == false) { _                                    shard.failShard("recovery", corruptIndexException)__                                    logger.warn("Corrupted file detected {} checksum mismatch", md)__                                    throw corruptIndexException__                                }_                            }_                        } catch (IOException ex) {_                            targetException.addSuppressed(ex)__                            throw targetException__                        }_                        _                        RemoteTransportException exception = new RemoteTransportException("File corruption occurred on recovery but " +_                                "checksums are ok", null)__                        exception.addSuppressed(targetException)__                        logger.warn(() -> new ParameterizedMessage(_                                "{} Remote file corruption during finalization of recovery on node {}. local checksum OK",_                                shard.shardId(), request.targetNode()), corruptIndexException)__                        throw exception__                    } else {_                        throw targetException__                    }_                }_            }__            logger.trace("recovery [phase1]: took [{}]", stopWatch.totalTime())__            response.phase1Time = stopWatch.totalTime().millis()__        } catch (Exception e) {_            throw new RecoverFilesRecoveryException(request.shardId(), response.phase1FileNames.size(), new ByteSizeValue(totalSize), e)__        } finally {_            store.decRef()__        }_    };perform,phase1,of,the,recovery,operations,once,this,link,index,commit,snapshot,has,been,performed,no,commit,operations,files,being,fsync,d,are,effectively,allowed,on,this,index,until,all,recovery,phases,are,done,p,phase1,examines,the,segment,files,on,the,target,node,and,copies,over,the,segments,that,are,missing,only,segments,that,have,the,same,size,and,checksum,can,be,reused;public,void,phase1,final,index,commit,snapshot,final,supplier,integer,translog,ops,cancellable,threads,check,for,cancel,long,total,size,0,long,existing,total,size,0,final,store,store,shard,store,store,inc,ref,try,stop,watch,stop,watch,new,stop,watch,start,final,store,metadata,snapshot,recovery,source,metadata,try,recovery,source,metadata,store,get,metadata,snapshot,catch,corrupt,index,exception,index,format,too,old,exception,index,format,too,new,exception,ex,shard,fail,shard,recovery,ex,throw,ex,for,string,name,snapshot,get,file,names,final,store,file,meta,data,md,recovery,source,metadata,get,name,if,md,null,logger,info,snapshot,differs,from,actual,index,for,file,meta,name,recovery,source,metadata,as,map,throw,new,corrupt,index,exception,snapshot,differs,from,actual,index,maybe,index,was,removed,metadata,has,recovery,source,metadata,as,map,size,files,name,string,recovery,source,sync,id,recovery,source,metadata,get,sync,id,string,recovery,target,sync,id,request,metadata,snapshot,get,sync,id,final,boolean,recover,with,sync,id,recovery,source,sync,id,null,recovery,source,sync,id,equals,recovery,target,sync,id,if,recover,with,sync,id,final,long,num,docs,target,request,metadata,snapshot,get,num,docs,final,long,num,docs,source,recovery,source,metadata,get,num,docs,if,num,docs,target,num,docs,source,throw,new,illegal,state,exception,try,to,recover,request,shard,id,from,primary,shard,with,sync,id,but,number,of,docs,differ,num,docs,source,request,source,node,get,name,primary,vs,num,docs,target,request,target,node,get,name,logger,trace,skipping,phase1,identical,sync,id,found,on,both,source,and,target,recovery,source,sync,id,else,final,store,recovery,diff,diff,recovery,source,metadata,recovery,diff,request,metadata,snapshot,for,store,file,meta,data,md,diff,identical,response,phase1existing,file,names,add,md,name,response,phase1existing,file,sizes,add,md,length,existing,total,size,md,length,if,logger,is,trace,enabled,logger,trace,recovery,phase1,not,recovering,exist,in,local,store,and,has,checksum,size,md,name,md,checksum,md,length,total,size,md,length,list,store,file,meta,data,phase1files,new,array,list,diff,different,size,diff,missing,size,phase1files,add,all,diff,different,phase1files,add,all,diff,missing,for,store,file,meta,data,md,phase1files,if,request,metadata,snapshot,as,map,contains,key,md,name,logger,trace,recovery,phase1,recovering,exists,in,local,store,but,is,different,remote,local,md,name,request,metadata,snapshot,as,map,get,md,name,md,else,logger,trace,recovery,phase1,recovering,does,not,exist,in,remote,md,name,response,phase1file,names,add,md,name,response,phase1file,sizes,add,md,length,total,size,md,length,response,phase1total,size,total,size,response,phase1existing,total,size,existing,total,size,logger,trace,recovery,phase1,with,with,response,phase1file,names,size,new,byte,size,value,total,size,response,phase1existing,file,names,size,new,byte,size,value,existing,total,size,cancellable,threads,execute,recovery,target,receive,file,info,response,phase1file,names,response,phase1file,sizes,response,phase1existing,file,names,response,phase1existing,file,sizes,translog,ops,get,final,function,store,file,meta,data,output,stream,output,stream,factories,md,new,buffered,output,stream,new,recovery,output,stream,md,translog,ops,chunk,size,in,bytes,send,files,store,phase1files,to,array,new,store,file,meta,data,phase1files,size,output,stream,factories,try,cancellable,threads,execute,io,recovery,target,clean,files,translog,ops,get,recovery,source,metadata,catch,remote,transport,exception,ioexception,target,exception,final,ioexception,corrupt,index,exception,if,corrupt,index,exception,exceptions,helper,unwrap,corruption,target,exception,null,try,final,store,metadata,snapshot,recovery,source,metadata1,store,get,metadata,snapshot,store,file,meta,data,metadata,stream,support,stream,recovery,source,metadata1,spliterator,false,to,array,store,file,meta,data,new,array,util,tim,sort,metadata,comparator,comparing,long,store,file,meta,data,length,for,store,file,meta,data,md,metadata,cancellable,threads,check,for,cancel,logger,debug,checking,integrity,for,file,after,remove,corruption,exception,md,if,store,check,integrity,no,exception,md,false,shard,fail,shard,recovery,corrupt,index,exception,logger,warn,corrupted,file,detected,checksum,mismatch,md,throw,corrupt,index,exception,catch,ioexception,ex,target,exception,add,suppressed,ex,throw,target,exception,remote,transport,exception,exception,new,remote,transport,exception,file,corruption,occurred,on,recovery,but,checksums,are,ok,null,exception,add,suppressed,target,exception,logger,warn,new,parameterized,message,remote,file,corruption,during,finalization,of,recovery,on,node,local,checksum,ok,shard,shard,id,request,target,node,corrupt,index,exception,throw,exception,else,throw,target,exception,logger,trace,recovery,phase1,took,stop,watch,total,time,response,phase1time,stop,watch,total,time,millis,catch,exception,e,throw,new,recover,files,recovery,exception,request,shard,id,response,phase1file,names,size,new,byte,size,value,total,size,e,finally,store,dec,ref
RecoverySourceHandler -> long phase2(final long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo, final Translog.Snapshot snapshot)         throws IOException;1524684173;Perform phase two of the recovery process._<p>_Phase two uses a snapshot of the current translog *without* acquiring the write lock (however, the translog snapshot is_point-in-time view of the translog). It then sends each translog operation to the target node so it can be replayed into the new_shard.__@param startingSeqNo           the sequence number to start recovery from, or {@link SequenceNumbers#UNASSIGNED_SEQ_NO} if all_ops should be sent_@param requiredSeqNoRangeStart the lower sequence number of the required range (ending with endingSeqNo)_@param endingSeqNo             the highest sequence number that should be sent_@param snapshot                a snapshot of the translog_@return the local checkpoint on the target;long phase2(final long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo, final Translog.Snapshot snapshot)_        throws IOException {_        if (shard.state() == IndexShardState.CLOSED) {_            throw new IndexShardClosedException(request.shardId())__        }_        cancellableThreads.checkForCancel()___        final StopWatch stopWatch = new StopWatch().start()___        logger.trace("recovery [phase2]: sending transaction log operations (seq# from [" +  startingSeqNo  + "], " +_            "required [" + requiredSeqNoRangeStart + ":" + endingSeqNo + "]")___        _        final SendSnapshotResult result = sendSnapshot(startingSeqNo, requiredSeqNoRangeStart, endingSeqNo, snapshot)___        stopWatch.stop()__        logger.trace("recovery [phase2]: took [{}]", stopWatch.totalTime())__        response.phase2Time = stopWatch.totalTime().millis()__        response.phase2Operations = result.totalOperations__        return result.targetLocalCheckpoint__    };perform,phase,two,of,the,recovery,process,p,phase,two,uses,a,snapshot,of,the,current,translog,without,acquiring,the,write,lock,however,the,translog,snapshot,is,point,in,time,view,of,the,translog,it,then,sends,each,translog,operation,to,the,target,node,so,it,can,be,replayed,into,the,new,shard,param,starting,seq,no,the,sequence,number,to,start,recovery,from,or,link,sequence,numbers,if,all,ops,should,be,sent,param,required,seq,no,range,start,the,lower,sequence,number,of,the,required,range,ending,with,ending,seq,no,param,ending,seq,no,the,highest,sequence,number,that,should,be,sent,param,snapshot,a,snapshot,of,the,translog,return,the,local,checkpoint,on,the,target;long,phase2,final,long,starting,seq,no,long,required,seq,no,range,start,long,ending,seq,no,final,translog,snapshot,snapshot,throws,ioexception,if,shard,state,index,shard,state,closed,throw,new,index,shard,closed,exception,request,shard,id,cancellable,threads,check,for,cancel,final,stop,watch,stop,watch,new,stop,watch,start,logger,trace,recovery,phase2,sending,transaction,log,operations,seq,from,starting,seq,no,required,required,seq,no,range,start,ending,seq,no,final,send,snapshot,result,result,send,snapshot,starting,seq,no,required,seq,no,range,start,ending,seq,no,snapshot,stop,watch,stop,logger,trace,recovery,phase2,took,stop,watch,total,time,response,phase2time,stop,watch,total,time,millis,response,phase2operations,result,total,operations,return,result,target,local,checkpoint
RecoverySourceHandler -> long phase2(final long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo, final Translog.Snapshot snapshot)         throws IOException;1525334055;Perform phase two of the recovery process._<p>_Phase two uses a snapshot of the current translog *without* acquiring the write lock (however, the translog snapshot is_point-in-time view of the translog). It then sends each translog operation to the target node so it can be replayed into the new_shard.__@param startingSeqNo           the sequence number to start recovery from, or {@link SequenceNumbers#UNASSIGNED_SEQ_NO} if all_ops should be sent_@param requiredSeqNoRangeStart the lower sequence number of the required range (ending with endingSeqNo)_@param endingSeqNo             the highest sequence number that should be sent_@param snapshot                a snapshot of the translog_@return the local checkpoint on the target;long phase2(final long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo, final Translog.Snapshot snapshot)_        throws IOException {_        if (shard.state() == IndexShardState.CLOSED) {_            throw new IndexShardClosedException(request.shardId())__        }_        cancellableThreads.checkForCancel()___        final StopWatch stopWatch = new StopWatch().start()___        logger.trace("recovery [phase2]: sending transaction log operations (seq# from [" +  startingSeqNo  + "], " +_            "required [" + requiredSeqNoRangeStart + ":" + endingSeqNo + "]")___        _        final SendSnapshotResult result = sendSnapshot(startingSeqNo, requiredSeqNoRangeStart, endingSeqNo, snapshot)___        stopWatch.stop()__        logger.trace("recovery [phase2]: took [{}]", stopWatch.totalTime())__        response.phase2Time = stopWatch.totalTime().millis()__        response.phase2Operations = result.totalOperations__        return result.targetLocalCheckpoint__    };perform,phase,two,of,the,recovery,process,p,phase,two,uses,a,snapshot,of,the,current,translog,without,acquiring,the,write,lock,however,the,translog,snapshot,is,point,in,time,view,of,the,translog,it,then,sends,each,translog,operation,to,the,target,node,so,it,can,be,replayed,into,the,new,shard,param,starting,seq,no,the,sequence,number,to,start,recovery,from,or,link,sequence,numbers,if,all,ops,should,be,sent,param,required,seq,no,range,start,the,lower,sequence,number,of,the,required,range,ending,with,ending,seq,no,param,ending,seq,no,the,highest,sequence,number,that,should,be,sent,param,snapshot,a,snapshot,of,the,translog,return,the,local,checkpoint,on,the,target;long,phase2,final,long,starting,seq,no,long,required,seq,no,range,start,long,ending,seq,no,final,translog,snapshot,snapshot,throws,ioexception,if,shard,state,index,shard,state,closed,throw,new,index,shard,closed,exception,request,shard,id,cancellable,threads,check,for,cancel,final,stop,watch,stop,watch,new,stop,watch,start,logger,trace,recovery,phase2,sending,transaction,log,operations,seq,from,starting,seq,no,required,required,seq,no,range,start,ending,seq,no,final,send,snapshot,result,result,send,snapshot,starting,seq,no,required,seq,no,range,start,ending,seq,no,snapshot,stop,watch,stop,logger,trace,recovery,phase2,took,stop,watch,total,time,response,phase2time,stop,watch,total,time,millis,response,phase2operations,result,total,operations,return,result,target,local,checkpoint
RecoverySourceHandler -> long phase2(final long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo, final Translog.Snapshot snapshot)         throws IOException;1528706846;Perform phase two of the recovery process._<p>_Phase two uses a snapshot of the current translog *without* acquiring the write lock (however, the translog snapshot is_point-in-time view of the translog). It then sends each translog operation to the target node so it can be replayed into the new_shard.__@param startingSeqNo           the sequence number to start recovery from, or {@link SequenceNumbers#UNASSIGNED_SEQ_NO} if all_ops should be sent_@param requiredSeqNoRangeStart the lower sequence number of the required range (ending with endingSeqNo)_@param endingSeqNo             the highest sequence number that should be sent_@param snapshot                a snapshot of the translog_@return the local checkpoint on the target;long phase2(final long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo, final Translog.Snapshot snapshot)_        throws IOException {_        if (shard.state() == IndexShardState.CLOSED) {_            throw new IndexShardClosedException(request.shardId())__        }_        cancellableThreads.checkForCancel()___        final StopWatch stopWatch = new StopWatch().start()___        logger.trace("recovery [phase2]: sending transaction log operations (seq# from [" +  startingSeqNo  + "], " +_            "required [" + requiredSeqNoRangeStart + ":" + endingSeqNo + "]")___        _        final SendSnapshotResult result = sendSnapshot(startingSeqNo, requiredSeqNoRangeStart, endingSeqNo, snapshot)___        stopWatch.stop()__        logger.trace("recovery [phase2]: took [{}]", stopWatch.totalTime())__        response.phase2Time = stopWatch.totalTime().millis()__        response.phase2Operations = result.totalOperations__        return result.targetLocalCheckpoint__    };perform,phase,two,of,the,recovery,process,p,phase,two,uses,a,snapshot,of,the,current,translog,without,acquiring,the,write,lock,however,the,translog,snapshot,is,point,in,time,view,of,the,translog,it,then,sends,each,translog,operation,to,the,target,node,so,it,can,be,replayed,into,the,new,shard,param,starting,seq,no,the,sequence,number,to,start,recovery,from,or,link,sequence,numbers,if,all,ops,should,be,sent,param,required,seq,no,range,start,the,lower,sequence,number,of,the,required,range,ending,with,ending,seq,no,param,ending,seq,no,the,highest,sequence,number,that,should,be,sent,param,snapshot,a,snapshot,of,the,translog,return,the,local,checkpoint,on,the,target;long,phase2,final,long,starting,seq,no,long,required,seq,no,range,start,long,ending,seq,no,final,translog,snapshot,snapshot,throws,ioexception,if,shard,state,index,shard,state,closed,throw,new,index,shard,closed,exception,request,shard,id,cancellable,threads,check,for,cancel,final,stop,watch,stop,watch,new,stop,watch,start,logger,trace,recovery,phase2,sending,transaction,log,operations,seq,from,starting,seq,no,required,required,seq,no,range,start,ending,seq,no,final,send,snapshot,result,result,send,snapshot,starting,seq,no,required,seq,no,range,start,ending,seq,no,snapshot,stop,watch,stop,logger,trace,recovery,phase2,took,stop,watch,total,time,response,phase2time,stop,watch,total,time,millis,response,phase2operations,result,total,operations,return,result,target,local,checkpoint
RecoverySourceHandler -> long phase2(final long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo, final Translog.Snapshot snapshot)         throws IOException;1529658035;Perform phase two of the recovery process._<p>_Phase two uses a snapshot of the current translog *without* acquiring the write lock (however, the translog snapshot is_point-in-time view of the translog). It then sends each translog operation to the target node so it can be replayed into the new_shard.__@param startingSeqNo           the sequence number to start recovery from, or {@link SequenceNumbers#UNASSIGNED_SEQ_NO} if all_ops should be sent_@param requiredSeqNoRangeStart the lower sequence number of the required range (ending with endingSeqNo)_@param endingSeqNo             the highest sequence number that should be sent_@param snapshot                a snapshot of the translog_@return the local checkpoint on the target;long phase2(final long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo, final Translog.Snapshot snapshot)_        throws IOException {_        if (shard.state() == IndexShardState.CLOSED) {_            throw new IndexShardClosedException(request.shardId())__        }_        cancellableThreads.checkForCancel()___        final StopWatch stopWatch = new StopWatch().start()___        logger.trace("recovery [phase2]: sending transaction log operations (seq# from [" +  startingSeqNo  + "], " +_            "required [" + requiredSeqNoRangeStart + ":" + endingSeqNo + "]")___        _        final SendSnapshotResult result = sendSnapshot(startingSeqNo, requiredSeqNoRangeStart, endingSeqNo, snapshot)___        stopWatch.stop()__        logger.trace("recovery [phase2]: took [{}]", stopWatch.totalTime())__        response.phase2Time = stopWatch.totalTime().millis()__        response.phase2Operations = result.totalOperations__        return result.targetLocalCheckpoint__    };perform,phase,two,of,the,recovery,process,p,phase,two,uses,a,snapshot,of,the,current,translog,without,acquiring,the,write,lock,however,the,translog,snapshot,is,point,in,time,view,of,the,translog,it,then,sends,each,translog,operation,to,the,target,node,so,it,can,be,replayed,into,the,new,shard,param,starting,seq,no,the,sequence,number,to,start,recovery,from,or,link,sequence,numbers,if,all,ops,should,be,sent,param,required,seq,no,range,start,the,lower,sequence,number,of,the,required,range,ending,with,ending,seq,no,param,ending,seq,no,the,highest,sequence,number,that,should,be,sent,param,snapshot,a,snapshot,of,the,translog,return,the,local,checkpoint,on,the,target;long,phase2,final,long,starting,seq,no,long,required,seq,no,range,start,long,ending,seq,no,final,translog,snapshot,snapshot,throws,ioexception,if,shard,state,index,shard,state,closed,throw,new,index,shard,closed,exception,request,shard,id,cancellable,threads,check,for,cancel,final,stop,watch,stop,watch,new,stop,watch,start,logger,trace,recovery,phase2,sending,transaction,log,operations,seq,from,starting,seq,no,required,required,seq,no,range,start,ending,seq,no,final,send,snapshot,result,result,send,snapshot,starting,seq,no,required,seq,no,range,start,ending,seq,no,snapshot,stop,watch,stop,logger,trace,recovery,phase2,took,stop,watch,total,time,response,phase2time,stop,watch,total,time,millis,response,phase2operations,result,total,operations,return,result,target,local,checkpoint
RecoverySourceHandler -> long phase2(final long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo, final Translog.Snapshot snapshot)         throws IOException;1533295538;Perform phase two of the recovery process._<p>_Phase two uses a snapshot of the current translog *without* acquiring the write lock (however, the translog snapshot is_point-in-time view of the translog). It then sends each translog operation to the target node so it can be replayed into the new_shard.__@param startingSeqNo           the sequence number to start recovery from, or {@link SequenceNumbers#UNASSIGNED_SEQ_NO} if all_ops should be sent_@param requiredSeqNoRangeStart the lower sequence number of the required range (ending with endingSeqNo)_@param endingSeqNo             the highest sequence number that should be sent_@param snapshot                a snapshot of the translog_@return the local checkpoint on the target;long phase2(final long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo, final Translog.Snapshot snapshot)_        throws IOException {_        if (shard.state() == IndexShardState.CLOSED) {_            throw new IndexShardClosedException(request.shardId())__        }_        cancellableThreads.checkForCancel()___        final StopWatch stopWatch = new StopWatch().start()___        logger.trace("recovery [phase2]: sending transaction log operations (seq# from [" +  startingSeqNo  + "], " +_            "required [" + requiredSeqNoRangeStart + ":" + endingSeqNo + "]")___        _        final SendSnapshotResult result = sendSnapshot(startingSeqNo, requiredSeqNoRangeStart, endingSeqNo, snapshot)___        stopWatch.stop()__        logger.trace("recovery [phase2]: took [{}]", stopWatch.totalTime())__        response.phase2Time = stopWatch.totalTime().millis()__        response.phase2Operations = result.totalOperations__        return result.targetLocalCheckpoint__    };perform,phase,two,of,the,recovery,process,p,phase,two,uses,a,snapshot,of,the,current,translog,without,acquiring,the,write,lock,however,the,translog,snapshot,is,point,in,time,view,of,the,translog,it,then,sends,each,translog,operation,to,the,target,node,so,it,can,be,replayed,into,the,new,shard,param,starting,seq,no,the,sequence,number,to,start,recovery,from,or,link,sequence,numbers,if,all,ops,should,be,sent,param,required,seq,no,range,start,the,lower,sequence,number,of,the,required,range,ending,with,ending,seq,no,param,ending,seq,no,the,highest,sequence,number,that,should,be,sent,param,snapshot,a,snapshot,of,the,translog,return,the,local,checkpoint,on,the,target;long,phase2,final,long,starting,seq,no,long,required,seq,no,range,start,long,ending,seq,no,final,translog,snapshot,snapshot,throws,ioexception,if,shard,state,index,shard,state,closed,throw,new,index,shard,closed,exception,request,shard,id,cancellable,threads,check,for,cancel,final,stop,watch,stop,watch,new,stop,watch,start,logger,trace,recovery,phase2,sending,transaction,log,operations,seq,from,starting,seq,no,required,required,seq,no,range,start,ending,seq,no,final,send,snapshot,result,result,send,snapshot,starting,seq,no,required,seq,no,range,start,ending,seq,no,snapshot,stop,watch,stop,logger,trace,recovery,phase2,took,stop,watch,total,time,response,phase2time,stop,watch,total,time,millis,response,phase2operations,result,total,operations,return,result,target,local,checkpoint
RecoverySourceHandler -> long phase2(final long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo, final Translog.Snapshot snapshot)         throws IOException;1535723122;Perform phase two of the recovery process._<p>_Phase two uses a snapshot of the current translog *without* acquiring the write lock (however, the translog snapshot is_point-in-time view of the translog). It then sends each translog operation to the target node so it can be replayed into the new_shard.__@param startingSeqNo           the sequence number to start recovery from, or {@link SequenceNumbers#UNASSIGNED_SEQ_NO} if all_ops should be sent_@param requiredSeqNoRangeStart the lower sequence number of the required range (ending with endingSeqNo)_@param endingSeqNo             the highest sequence number that should be sent_@param snapshot                a snapshot of the translog_@return the local checkpoint on the target;long phase2(final long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo, final Translog.Snapshot snapshot)_        throws IOException {_        if (shard.state() == IndexShardState.CLOSED) {_            throw new IndexShardClosedException(request.shardId())__        }_        cancellableThreads.checkForCancel()___        final StopWatch stopWatch = new StopWatch().start()___        logger.trace("recovery [phase2]: sending transaction log operations (seq# from [" +  startingSeqNo  + "], " +_            "required [" + requiredSeqNoRangeStart + ":" + endingSeqNo + "]")___        _        final SendSnapshotResult result = sendSnapshot(startingSeqNo, requiredSeqNoRangeStart, endingSeqNo, snapshot)___        stopWatch.stop()__        logger.trace("recovery [phase2]: took [{}]", stopWatch.totalTime())__        response.phase2Time = stopWatch.totalTime().millis()__        response.phase2Operations = result.totalOperations__        return result.targetLocalCheckpoint__    };perform,phase,two,of,the,recovery,process,p,phase,two,uses,a,snapshot,of,the,current,translog,without,acquiring,the,write,lock,however,the,translog,snapshot,is,point,in,time,view,of,the,translog,it,then,sends,each,translog,operation,to,the,target,node,so,it,can,be,replayed,into,the,new,shard,param,starting,seq,no,the,sequence,number,to,start,recovery,from,or,link,sequence,numbers,if,all,ops,should,be,sent,param,required,seq,no,range,start,the,lower,sequence,number,of,the,required,range,ending,with,ending,seq,no,param,ending,seq,no,the,highest,sequence,number,that,should,be,sent,param,snapshot,a,snapshot,of,the,translog,return,the,local,checkpoint,on,the,target;long,phase2,final,long,starting,seq,no,long,required,seq,no,range,start,long,ending,seq,no,final,translog,snapshot,snapshot,throws,ioexception,if,shard,state,index,shard,state,closed,throw,new,index,shard,closed,exception,request,shard,id,cancellable,threads,check,for,cancel,final,stop,watch,stop,watch,new,stop,watch,start,logger,trace,recovery,phase2,sending,transaction,log,operations,seq,from,starting,seq,no,required,required,seq,no,range,start,ending,seq,no,final,send,snapshot,result,result,send,snapshot,starting,seq,no,required,seq,no,range,start,ending,seq,no,snapshot,stop,watch,stop,logger,trace,recovery,phase2,took,stop,watch,total,time,response,phase2time,stop,watch,total,time,millis,response,phase2operations,result,total,operations,return,result,target,local,checkpoint
RecoverySourceHandler -> long phase2(final long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo, final Translog.Snapshot snapshot)         throws IOException;1535965276;Perform phase two of the recovery process._<p>_Phase two uses a snapshot of the current translog *without* acquiring the write lock (however, the translog snapshot is_point-in-time view of the translog). It then sends each translog operation to the target node so it can be replayed into the new_shard.__@param startingSeqNo           the sequence number to start recovery from, or {@link SequenceNumbers#UNASSIGNED_SEQ_NO} if all_ops should be sent_@param requiredSeqNoRangeStart the lower sequence number of the required range (ending with endingSeqNo)_@param endingSeqNo             the highest sequence number that should be sent_@param snapshot                a snapshot of the translog_@return the local checkpoint on the target;long phase2(final long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo, final Translog.Snapshot snapshot)_        throws IOException {_        if (shard.state() == IndexShardState.CLOSED) {_            throw new IndexShardClosedException(request.shardId())__        }_        cancellableThreads.checkForCancel()___        final StopWatch stopWatch = new StopWatch().start()___        logger.trace("recovery [phase2]: sending transaction log operations (seq# from [" +  startingSeqNo  + "], " +_            "required [" + requiredSeqNoRangeStart + ":" + endingSeqNo + "]")___        _        final SendSnapshotResult result = sendSnapshot(startingSeqNo, requiredSeqNoRangeStart, endingSeqNo, snapshot)___        stopWatch.stop()__        logger.trace("recovery [phase2]: took [{}]", stopWatch.totalTime())__        response.phase2Time = stopWatch.totalTime().millis()__        response.phase2Operations = result.totalOperations__        return result.targetLocalCheckpoint__    };perform,phase,two,of,the,recovery,process,p,phase,two,uses,a,snapshot,of,the,current,translog,without,acquiring,the,write,lock,however,the,translog,snapshot,is,point,in,time,view,of,the,translog,it,then,sends,each,translog,operation,to,the,target,node,so,it,can,be,replayed,into,the,new,shard,param,starting,seq,no,the,sequence,number,to,start,recovery,from,or,link,sequence,numbers,if,all,ops,should,be,sent,param,required,seq,no,range,start,the,lower,sequence,number,of,the,required,range,ending,with,ending,seq,no,param,ending,seq,no,the,highest,sequence,number,that,should,be,sent,param,snapshot,a,snapshot,of,the,translog,return,the,local,checkpoint,on,the,target;long,phase2,final,long,starting,seq,no,long,required,seq,no,range,start,long,ending,seq,no,final,translog,snapshot,snapshot,throws,ioexception,if,shard,state,index,shard,state,closed,throw,new,index,shard,closed,exception,request,shard,id,cancellable,threads,check,for,cancel,final,stop,watch,stop,watch,new,stop,watch,start,logger,trace,recovery,phase2,sending,transaction,log,operations,seq,from,starting,seq,no,required,required,seq,no,range,start,ending,seq,no,final,send,snapshot,result,result,send,snapshot,starting,seq,no,required,seq,no,range,start,ending,seq,no,snapshot,stop,watch,stop,logger,trace,recovery,phase2,took,stop,watch,total,time,response,phase2time,stop,watch,total,time,millis,response,phase2operations,result,total,operations,return,result,target,local,checkpoint
RecoverySourceHandler -> public RecoveryResponse recoverToTarget() throws IOException;1524684173;performs the recovery from the local engine to the target;public RecoveryResponse recoverToTarget() throws IOException {_        runUnderPrimaryPermit(() -> {_            final IndexShardRoutingTable routingTable = shard.getReplicationGroup().getRoutingTable()__            ShardRouting targetShardRouting = routingTable.getByAllocationId(request.targetAllocationId())__            if (targetShardRouting == null) {_                logger.debug("delaying recovery of {} as it is not listed as assigned to target node {}", request.shardId(),_                    request.targetNode())__                throw new DelayRecoveryException("source node does not have the shard listed in its state as allocated on the node")__            }_            assert targetShardRouting.initializing() : "expected recovery target to be initializing but was " + targetShardRouting__        }, shardId + " validating recovery target ["+ request.targetAllocationId() + "] registered ")___        try (Closeable ignored = shard.acquireTranslogRetentionLock()) {_            final long startingSeqNo__            final long requiredSeqNoRangeStart__            final boolean isSequenceNumberBasedRecovery = request.startingSeqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                isTargetSameHistory() && isTranslogReadyForSequenceNumberBasedRecovery()__            if (isSequenceNumberBasedRecovery) {_                logger.trace("performing sequence numbers based recovery. starting at [{}]", request.startingSeqNo())__                startingSeqNo = request.startingSeqNo()__                requiredSeqNoRangeStart = startingSeqNo__            } else {_                final Engine.IndexCommitRef phase1Snapshot__                try {_                    phase1Snapshot = shard.acquireSafeIndexCommit()__                } catch (final Exception e) {_                    throw new RecoveryEngineException(shard.shardId(), 1, "snapshot failed", e)__                }_                _                _                startingSeqNo = 0__                _                requiredSeqNoRangeStart =_                    Long.parseLong(phase1Snapshot.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) + 1__                try {_                    phase1(phase1Snapshot.getIndexCommit(), () -> shard.estimateTranslogOperationsFromMinSeq(startingSeqNo))__                } catch (final Exception e) {_                    throw new RecoveryEngineException(shard.shardId(), 1, "phase1 failed", e)__                } finally {_                    try {_                        IOUtils.close(phase1Snapshot)__                    } catch (final IOException ex) {_                        logger.warn("releasing snapshot caused exception", ex)__                    }_                }_            }_            assert startingSeqNo >= 0 : "startingSeqNo must be non negative. got: " + startingSeqNo__            assert requiredSeqNoRangeStart >= startingSeqNo : "requiredSeqNoRangeStart [" + requiredSeqNoRangeStart + "] is lower than ["_                + startingSeqNo + "]"___            try {_                _                prepareTargetForTranslog(isSequenceNumberBasedRecovery == false, shard.estimateTranslogOperationsFromMinSeq(startingSeqNo))__            } catch (final Exception e) {_                throw new RecoveryEngineException(shard.shardId(), 1, "prepare target for translog failed", e)__            }__            _            runUnderPrimaryPermit(() -> shard.initiateTracking(request.targetAllocationId()),_                shardId + " initiating tracking of " + request.targetAllocationId())___            final long endingSeqNo = shard.seqNoStats().getMaxSeqNo()__            _            cancellableThreads.execute(() -> shard.waitForOpsToComplete(endingSeqNo))___            logger.trace("all operations up to [{}] completed, which will be used as an ending sequence number", endingSeqNo)___            logger.trace("snapshot translog for recovery_ current size is [{}]", shard.estimateTranslogOperationsFromMinSeq(startingSeqNo))__            final long targetLocalCheckpoint__            try(Translog.Snapshot snapshot = shard.newTranslogSnapshotFromMinSeqNo(startingSeqNo)) {_                targetLocalCheckpoint = phase2(startingSeqNo, requiredSeqNoRangeStart, endingSeqNo, snapshot)__            } catch (Exception e) {_                throw new RecoveryEngineException(shard.shardId(), 2, "phase2 failed", e)__            }__            finalizeRecovery(targetLocalCheckpoint)__        }_        return response__    };performs,the,recovery,from,the,local,engine,to,the,target;public,recovery,response,recover,to,target,throws,ioexception,run,under,primary,permit,final,index,shard,routing,table,routing,table,shard,get,replication,group,get,routing,table,shard,routing,target,shard,routing,routing,table,get,by,allocation,id,request,target,allocation,id,if,target,shard,routing,null,logger,debug,delaying,recovery,of,as,it,is,not,listed,as,assigned,to,target,node,request,shard,id,request,target,node,throw,new,delay,recovery,exception,source,node,does,not,have,the,shard,listed,in,its,state,as,allocated,on,the,node,assert,target,shard,routing,initializing,expected,recovery,target,to,be,initializing,but,was,target,shard,routing,shard,id,validating,recovery,target,request,target,allocation,id,registered,try,closeable,ignored,shard,acquire,translog,retention,lock,final,long,starting,seq,no,final,long,required,seq,no,range,start,final,boolean,is,sequence,number,based,recovery,request,starting,seq,no,sequence,numbers,is,target,same,history,is,translog,ready,for,sequence,number,based,recovery,if,is,sequence,number,based,recovery,logger,trace,performing,sequence,numbers,based,recovery,starting,at,request,starting,seq,no,starting,seq,no,request,starting,seq,no,required,seq,no,range,start,starting,seq,no,else,final,engine,index,commit,ref,phase1snapshot,try,phase1snapshot,shard,acquire,safe,index,commit,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,snapshot,failed,e,starting,seq,no,0,required,seq,no,range,start,long,parse,long,phase1snapshot,get,index,commit,get,user,data,get,sequence,numbers,1,try,phase1,phase1snapshot,get,index,commit,shard,estimate,translog,operations,from,min,seq,starting,seq,no,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,phase1,failed,e,finally,try,ioutils,close,phase1snapshot,catch,final,ioexception,ex,logger,warn,releasing,snapshot,caused,exception,ex,assert,starting,seq,no,0,starting,seq,no,must,be,non,negative,got,starting,seq,no,assert,required,seq,no,range,start,starting,seq,no,required,seq,no,range,start,required,seq,no,range,start,is,lower,than,starting,seq,no,try,prepare,target,for,translog,is,sequence,number,based,recovery,false,shard,estimate,translog,operations,from,min,seq,starting,seq,no,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,prepare,target,for,translog,failed,e,run,under,primary,permit,shard,initiate,tracking,request,target,allocation,id,shard,id,initiating,tracking,of,request,target,allocation,id,final,long,ending,seq,no,shard,seq,no,stats,get,max,seq,no,cancellable,threads,execute,shard,wait,for,ops,to,complete,ending,seq,no,logger,trace,all,operations,up,to,completed,which,will,be,used,as,an,ending,sequence,number,ending,seq,no,logger,trace,snapshot,translog,for,recovery,current,size,is,shard,estimate,translog,operations,from,min,seq,starting,seq,no,final,long,target,local,checkpoint,try,translog,snapshot,snapshot,shard,new,translog,snapshot,from,min,seq,no,starting,seq,no,target,local,checkpoint,phase2,starting,seq,no,required,seq,no,range,start,ending,seq,no,snapshot,catch,exception,e,throw,new,recovery,engine,exception,shard,shard,id,2,phase2,failed,e,finalize,recovery,target,local,checkpoint,return,response
RecoverySourceHandler -> public RecoveryResponse recoverToTarget() throws IOException;1525334055;performs the recovery from the local engine to the target;public RecoveryResponse recoverToTarget() throws IOException {_        runUnderPrimaryPermit(() -> {_            final IndexShardRoutingTable routingTable = shard.getReplicationGroup().getRoutingTable()__            ShardRouting targetShardRouting = routingTable.getByAllocationId(request.targetAllocationId())__            if (targetShardRouting == null) {_                logger.debug("delaying recovery of {} as it is not listed as assigned to target node {}", request.shardId(),_                    request.targetNode())__                throw new DelayRecoveryException("source node does not have the shard listed in its state as allocated on the node")__            }_            assert targetShardRouting.initializing() : "expected recovery target to be initializing but was " + targetShardRouting__        }, shardId + " validating recovery target ["+ request.targetAllocationId() + "] registered ", shard, cancellableThreads, logger)___        try (Closeable ignored = shard.acquireTranslogRetentionLock()) {_            final long startingSeqNo__            final long requiredSeqNoRangeStart__            final boolean isSequenceNumberBasedRecovery = request.startingSeqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                isTargetSameHistory() && isTranslogReadyForSequenceNumberBasedRecovery()__            if (isSequenceNumberBasedRecovery) {_                logger.trace("performing sequence numbers based recovery. starting at [{}]", request.startingSeqNo())__                startingSeqNo = request.startingSeqNo()__                requiredSeqNoRangeStart = startingSeqNo__            } else {_                final Engine.IndexCommitRef phase1Snapshot__                try {_                    phase1Snapshot = shard.acquireSafeIndexCommit()__                } catch (final Exception e) {_                    throw new RecoveryEngineException(shard.shardId(), 1, "snapshot failed", e)__                }_                _                _                startingSeqNo = 0__                _                requiredSeqNoRangeStart =_                    Long.parseLong(phase1Snapshot.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) + 1__                try {_                    phase1(phase1Snapshot.getIndexCommit(), () -> shard.estimateTranslogOperationsFromMinSeq(startingSeqNo))__                } catch (final Exception e) {_                    throw new RecoveryEngineException(shard.shardId(), 1, "phase1 failed", e)__                } finally {_                    try {_                        IOUtils.close(phase1Snapshot)__                    } catch (final IOException ex) {_                        logger.warn("releasing snapshot caused exception", ex)__                    }_                }_            }_            assert startingSeqNo >= 0 : "startingSeqNo must be non negative. got: " + startingSeqNo__            assert requiredSeqNoRangeStart >= startingSeqNo : "requiredSeqNoRangeStart [" + requiredSeqNoRangeStart + "] is lower than ["_                + startingSeqNo + "]"___            try {_                _                prepareTargetForTranslog(isSequenceNumberBasedRecovery == false, shard.estimateTranslogOperationsFromMinSeq(startingSeqNo))__            } catch (final Exception e) {_                throw new RecoveryEngineException(shard.shardId(), 1, "prepare target for translog failed", e)__            }__            _            runUnderPrimaryPermit(() -> shard.initiateTracking(request.targetAllocationId()),_                shardId + " initiating tracking of " + request.targetAllocationId(), shard, cancellableThreads, logger)___            final long endingSeqNo = shard.seqNoStats().getMaxSeqNo()__            _            cancellableThreads.execute(() -> shard.waitForOpsToComplete(endingSeqNo))___            logger.trace("all operations up to [{}] completed, which will be used as an ending sequence number", endingSeqNo)___            logger.trace("snapshot translog for recovery_ current size is [{}]", shard.estimateTranslogOperationsFromMinSeq(startingSeqNo))__            final long targetLocalCheckpoint__            try(Translog.Snapshot snapshot = shard.newTranslogSnapshotFromMinSeqNo(startingSeqNo)) {_                targetLocalCheckpoint = phase2(startingSeqNo, requiredSeqNoRangeStart, endingSeqNo, snapshot)__            } catch (Exception e) {_                throw new RecoveryEngineException(shard.shardId(), 2, "phase2 failed", e)__            }__            finalizeRecovery(targetLocalCheckpoint)__        }_        return response__    };performs,the,recovery,from,the,local,engine,to,the,target;public,recovery,response,recover,to,target,throws,ioexception,run,under,primary,permit,final,index,shard,routing,table,routing,table,shard,get,replication,group,get,routing,table,shard,routing,target,shard,routing,routing,table,get,by,allocation,id,request,target,allocation,id,if,target,shard,routing,null,logger,debug,delaying,recovery,of,as,it,is,not,listed,as,assigned,to,target,node,request,shard,id,request,target,node,throw,new,delay,recovery,exception,source,node,does,not,have,the,shard,listed,in,its,state,as,allocated,on,the,node,assert,target,shard,routing,initializing,expected,recovery,target,to,be,initializing,but,was,target,shard,routing,shard,id,validating,recovery,target,request,target,allocation,id,registered,shard,cancellable,threads,logger,try,closeable,ignored,shard,acquire,translog,retention,lock,final,long,starting,seq,no,final,long,required,seq,no,range,start,final,boolean,is,sequence,number,based,recovery,request,starting,seq,no,sequence,numbers,is,target,same,history,is,translog,ready,for,sequence,number,based,recovery,if,is,sequence,number,based,recovery,logger,trace,performing,sequence,numbers,based,recovery,starting,at,request,starting,seq,no,starting,seq,no,request,starting,seq,no,required,seq,no,range,start,starting,seq,no,else,final,engine,index,commit,ref,phase1snapshot,try,phase1snapshot,shard,acquire,safe,index,commit,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,snapshot,failed,e,starting,seq,no,0,required,seq,no,range,start,long,parse,long,phase1snapshot,get,index,commit,get,user,data,get,sequence,numbers,1,try,phase1,phase1snapshot,get,index,commit,shard,estimate,translog,operations,from,min,seq,starting,seq,no,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,phase1,failed,e,finally,try,ioutils,close,phase1snapshot,catch,final,ioexception,ex,logger,warn,releasing,snapshot,caused,exception,ex,assert,starting,seq,no,0,starting,seq,no,must,be,non,negative,got,starting,seq,no,assert,required,seq,no,range,start,starting,seq,no,required,seq,no,range,start,required,seq,no,range,start,is,lower,than,starting,seq,no,try,prepare,target,for,translog,is,sequence,number,based,recovery,false,shard,estimate,translog,operations,from,min,seq,starting,seq,no,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,prepare,target,for,translog,failed,e,run,under,primary,permit,shard,initiate,tracking,request,target,allocation,id,shard,id,initiating,tracking,of,request,target,allocation,id,shard,cancellable,threads,logger,final,long,ending,seq,no,shard,seq,no,stats,get,max,seq,no,cancellable,threads,execute,shard,wait,for,ops,to,complete,ending,seq,no,logger,trace,all,operations,up,to,completed,which,will,be,used,as,an,ending,sequence,number,ending,seq,no,logger,trace,snapshot,translog,for,recovery,current,size,is,shard,estimate,translog,operations,from,min,seq,starting,seq,no,final,long,target,local,checkpoint,try,translog,snapshot,snapshot,shard,new,translog,snapshot,from,min,seq,no,starting,seq,no,target,local,checkpoint,phase2,starting,seq,no,required,seq,no,range,start,ending,seq,no,snapshot,catch,exception,e,throw,new,recovery,engine,exception,shard,shard,id,2,phase2,failed,e,finalize,recovery,target,local,checkpoint,return,response
RecoverySourceHandler -> public RecoveryResponse recoverToTarget() throws IOException;1528706846;performs the recovery from the local engine to the target;public RecoveryResponse recoverToTarget() throws IOException {_        runUnderPrimaryPermit(() -> {_            final IndexShardRoutingTable routingTable = shard.getReplicationGroup().getRoutingTable()__            ShardRouting targetShardRouting = routingTable.getByAllocationId(request.targetAllocationId())__            if (targetShardRouting == null) {_                logger.debug("delaying recovery of {} as it is not listed as assigned to target node {}", request.shardId(),_                    request.targetNode())__                throw new DelayRecoveryException("source node does not have the shard listed in its state as allocated on the node")__            }_            assert targetShardRouting.initializing() : "expected recovery target to be initializing but was " + targetShardRouting__        }, shardId + " validating recovery target ["+ request.targetAllocationId() + "] registered ", shard, cancellableThreads, logger)___        try (Closeable ignored = shard.acquireTranslogRetentionLock()) {_            final long startingSeqNo__            final long requiredSeqNoRangeStart__            final boolean isSequenceNumberBasedRecovery = request.startingSeqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                isTargetSameHistory() && isTranslogReadyForSequenceNumberBasedRecovery()__            if (isSequenceNumberBasedRecovery) {_                logger.trace("performing sequence numbers based recovery. starting at [{}]", request.startingSeqNo())__                startingSeqNo = request.startingSeqNo()__                requiredSeqNoRangeStart = startingSeqNo__            } else {_                final Engine.IndexCommitRef phase1Snapshot__                try {_                    phase1Snapshot = shard.acquireSafeIndexCommit()__                } catch (final Exception e) {_                    throw new RecoveryEngineException(shard.shardId(), 1, "snapshot failed", e)__                }_                _                _                startingSeqNo = 0__                _                requiredSeqNoRangeStart =_                    Long.parseLong(phase1Snapshot.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) + 1__                try {_                    phase1(phase1Snapshot.getIndexCommit(), () -> shard.estimateTranslogOperationsFromMinSeq(startingSeqNo))__                } catch (final Exception e) {_                    throw new RecoveryEngineException(shard.shardId(), 1, "phase1 failed", e)__                } finally {_                    try {_                        IOUtils.close(phase1Snapshot)__                    } catch (final IOException ex) {_                        logger.warn("releasing snapshot caused exception", ex)__                    }_                }_            }_            assert startingSeqNo >= 0 : "startingSeqNo must be non negative. got: " + startingSeqNo__            assert requiredSeqNoRangeStart >= startingSeqNo : "requiredSeqNoRangeStart [" + requiredSeqNoRangeStart + "] is lower than ["_                + startingSeqNo + "]"___            try {_                _                prepareTargetForTranslog(isSequenceNumberBasedRecovery == false, shard.estimateTranslogOperationsFromMinSeq(startingSeqNo))__            } catch (final Exception e) {_                throw new RecoveryEngineException(shard.shardId(), 1, "prepare target for translog failed", e)__            }__            _            runUnderPrimaryPermit(() -> shard.initiateTracking(request.targetAllocationId()),_                shardId + " initiating tracking of " + request.targetAllocationId(), shard, cancellableThreads, logger)___            final long endingSeqNo = shard.seqNoStats().getMaxSeqNo()__            _            cancellableThreads.execute(() -> shard.waitForOpsToComplete(endingSeqNo))___            logger.trace("all operations up to [{}] completed, which will be used as an ending sequence number", endingSeqNo)___            logger.trace("snapshot translog for recovery_ current size is [{}]", shard.estimateTranslogOperationsFromMinSeq(startingSeqNo))__            final long targetLocalCheckpoint__            try(Translog.Snapshot snapshot = shard.newTranslogSnapshotFromMinSeqNo(startingSeqNo)) {_                targetLocalCheckpoint = phase2(startingSeqNo, requiredSeqNoRangeStart, endingSeqNo, snapshot)__            } catch (Exception e) {_                throw new RecoveryEngineException(shard.shardId(), 2, "phase2 failed", e)__            }__            finalizeRecovery(targetLocalCheckpoint)__        }_        return response__    };performs,the,recovery,from,the,local,engine,to,the,target;public,recovery,response,recover,to,target,throws,ioexception,run,under,primary,permit,final,index,shard,routing,table,routing,table,shard,get,replication,group,get,routing,table,shard,routing,target,shard,routing,routing,table,get,by,allocation,id,request,target,allocation,id,if,target,shard,routing,null,logger,debug,delaying,recovery,of,as,it,is,not,listed,as,assigned,to,target,node,request,shard,id,request,target,node,throw,new,delay,recovery,exception,source,node,does,not,have,the,shard,listed,in,its,state,as,allocated,on,the,node,assert,target,shard,routing,initializing,expected,recovery,target,to,be,initializing,but,was,target,shard,routing,shard,id,validating,recovery,target,request,target,allocation,id,registered,shard,cancellable,threads,logger,try,closeable,ignored,shard,acquire,translog,retention,lock,final,long,starting,seq,no,final,long,required,seq,no,range,start,final,boolean,is,sequence,number,based,recovery,request,starting,seq,no,sequence,numbers,is,target,same,history,is,translog,ready,for,sequence,number,based,recovery,if,is,sequence,number,based,recovery,logger,trace,performing,sequence,numbers,based,recovery,starting,at,request,starting,seq,no,starting,seq,no,request,starting,seq,no,required,seq,no,range,start,starting,seq,no,else,final,engine,index,commit,ref,phase1snapshot,try,phase1snapshot,shard,acquire,safe,index,commit,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,snapshot,failed,e,starting,seq,no,0,required,seq,no,range,start,long,parse,long,phase1snapshot,get,index,commit,get,user,data,get,sequence,numbers,1,try,phase1,phase1snapshot,get,index,commit,shard,estimate,translog,operations,from,min,seq,starting,seq,no,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,phase1,failed,e,finally,try,ioutils,close,phase1snapshot,catch,final,ioexception,ex,logger,warn,releasing,snapshot,caused,exception,ex,assert,starting,seq,no,0,starting,seq,no,must,be,non,negative,got,starting,seq,no,assert,required,seq,no,range,start,starting,seq,no,required,seq,no,range,start,required,seq,no,range,start,is,lower,than,starting,seq,no,try,prepare,target,for,translog,is,sequence,number,based,recovery,false,shard,estimate,translog,operations,from,min,seq,starting,seq,no,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,prepare,target,for,translog,failed,e,run,under,primary,permit,shard,initiate,tracking,request,target,allocation,id,shard,id,initiating,tracking,of,request,target,allocation,id,shard,cancellable,threads,logger,final,long,ending,seq,no,shard,seq,no,stats,get,max,seq,no,cancellable,threads,execute,shard,wait,for,ops,to,complete,ending,seq,no,logger,trace,all,operations,up,to,completed,which,will,be,used,as,an,ending,sequence,number,ending,seq,no,logger,trace,snapshot,translog,for,recovery,current,size,is,shard,estimate,translog,operations,from,min,seq,starting,seq,no,final,long,target,local,checkpoint,try,translog,snapshot,snapshot,shard,new,translog,snapshot,from,min,seq,no,starting,seq,no,target,local,checkpoint,phase2,starting,seq,no,required,seq,no,range,start,ending,seq,no,snapshot,catch,exception,e,throw,new,recovery,engine,exception,shard,shard,id,2,phase2,failed,e,finalize,recovery,target,local,checkpoint,return,response
RecoverySourceHandler -> public RecoveryResponse recoverToTarget() throws IOException;1529658035;performs the recovery from the local engine to the target;public RecoveryResponse recoverToTarget() throws IOException {_        runUnderPrimaryPermit(() -> {_            final IndexShardRoutingTable routingTable = shard.getReplicationGroup().getRoutingTable()__            ShardRouting targetShardRouting = routingTable.getByAllocationId(request.targetAllocationId())__            if (targetShardRouting == null) {_                logger.debug("delaying recovery of {} as it is not listed as assigned to target node {}", request.shardId(),_                    request.targetNode())__                throw new DelayRecoveryException("source node does not have the shard listed in its state as allocated on the node")__            }_            assert targetShardRouting.initializing() : "expected recovery target to be initializing but was " + targetShardRouting__        }, shardId + " validating recovery target ["+ request.targetAllocationId() + "] registered ", shard, cancellableThreads, logger)___        try (Closeable ignored = shard.acquireTranslogRetentionLock()) {_            final long startingSeqNo__            final long requiredSeqNoRangeStart__            final boolean isSequenceNumberBasedRecovery = request.startingSeqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                isTargetSameHistory() && isTranslogReadyForSequenceNumberBasedRecovery()__            if (isSequenceNumberBasedRecovery) {_                logger.trace("performing sequence numbers based recovery. starting at [{}]", request.startingSeqNo())__                startingSeqNo = request.startingSeqNo()__                requiredSeqNoRangeStart = startingSeqNo__            } else {_                final Engine.IndexCommitRef phase1Snapshot__                try {_                    phase1Snapshot = shard.acquireSafeIndexCommit()__                } catch (final Exception e) {_                    throw new RecoveryEngineException(shard.shardId(), 1, "snapshot failed", e)__                }_                _                _                startingSeqNo = 0__                _                requiredSeqNoRangeStart =_                    Long.parseLong(phase1Snapshot.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) + 1__                try {_                    phase1(phase1Snapshot.getIndexCommit(), () -> shard.estimateTranslogOperationsFromMinSeq(startingSeqNo))__                } catch (final Exception e) {_                    throw new RecoveryEngineException(shard.shardId(), 1, "phase1 failed", e)__                } finally {_                    try {_                        IOUtils.close(phase1Snapshot)__                    } catch (final IOException ex) {_                        logger.warn("releasing snapshot caused exception", ex)__                    }_                }_            }_            assert startingSeqNo >= 0 : "startingSeqNo must be non negative. got: " + startingSeqNo__            assert requiredSeqNoRangeStart >= startingSeqNo : "requiredSeqNoRangeStart [" + requiredSeqNoRangeStart + "] is lower than ["_                + startingSeqNo + "]"___            try {_                _                prepareTargetForTranslog(isSequenceNumberBasedRecovery == false, shard.estimateTranslogOperationsFromMinSeq(startingSeqNo))__            } catch (final Exception e) {_                throw new RecoveryEngineException(shard.shardId(), 1, "prepare target for translog failed", e)__            }__            _            runUnderPrimaryPermit(() -> shard.initiateTracking(request.targetAllocationId()),_                shardId + " initiating tracking of " + request.targetAllocationId(), shard, cancellableThreads, logger)___            final long endingSeqNo = shard.seqNoStats().getMaxSeqNo()__            _            cancellableThreads.execute(() -> shard.waitForOpsToComplete(endingSeqNo))___            logger.trace("all operations up to [{}] completed, which will be used as an ending sequence number", endingSeqNo)___            logger.trace("snapshot translog for recovery_ current size is [{}]", shard.estimateTranslogOperationsFromMinSeq(startingSeqNo))__            final long targetLocalCheckpoint__            try(Translog.Snapshot snapshot = shard.newTranslogSnapshotFromMinSeqNo(startingSeqNo)) {_                targetLocalCheckpoint = phase2(startingSeqNo, requiredSeqNoRangeStart, endingSeqNo, snapshot)__            } catch (Exception e) {_                throw new RecoveryEngineException(shard.shardId(), 2, "phase2 failed", e)__            }__            finalizeRecovery(targetLocalCheckpoint)__        }_        return response__    };performs,the,recovery,from,the,local,engine,to,the,target;public,recovery,response,recover,to,target,throws,ioexception,run,under,primary,permit,final,index,shard,routing,table,routing,table,shard,get,replication,group,get,routing,table,shard,routing,target,shard,routing,routing,table,get,by,allocation,id,request,target,allocation,id,if,target,shard,routing,null,logger,debug,delaying,recovery,of,as,it,is,not,listed,as,assigned,to,target,node,request,shard,id,request,target,node,throw,new,delay,recovery,exception,source,node,does,not,have,the,shard,listed,in,its,state,as,allocated,on,the,node,assert,target,shard,routing,initializing,expected,recovery,target,to,be,initializing,but,was,target,shard,routing,shard,id,validating,recovery,target,request,target,allocation,id,registered,shard,cancellable,threads,logger,try,closeable,ignored,shard,acquire,translog,retention,lock,final,long,starting,seq,no,final,long,required,seq,no,range,start,final,boolean,is,sequence,number,based,recovery,request,starting,seq,no,sequence,numbers,is,target,same,history,is,translog,ready,for,sequence,number,based,recovery,if,is,sequence,number,based,recovery,logger,trace,performing,sequence,numbers,based,recovery,starting,at,request,starting,seq,no,starting,seq,no,request,starting,seq,no,required,seq,no,range,start,starting,seq,no,else,final,engine,index,commit,ref,phase1snapshot,try,phase1snapshot,shard,acquire,safe,index,commit,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,snapshot,failed,e,starting,seq,no,0,required,seq,no,range,start,long,parse,long,phase1snapshot,get,index,commit,get,user,data,get,sequence,numbers,1,try,phase1,phase1snapshot,get,index,commit,shard,estimate,translog,operations,from,min,seq,starting,seq,no,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,phase1,failed,e,finally,try,ioutils,close,phase1snapshot,catch,final,ioexception,ex,logger,warn,releasing,snapshot,caused,exception,ex,assert,starting,seq,no,0,starting,seq,no,must,be,non,negative,got,starting,seq,no,assert,required,seq,no,range,start,starting,seq,no,required,seq,no,range,start,required,seq,no,range,start,is,lower,than,starting,seq,no,try,prepare,target,for,translog,is,sequence,number,based,recovery,false,shard,estimate,translog,operations,from,min,seq,starting,seq,no,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,prepare,target,for,translog,failed,e,run,under,primary,permit,shard,initiate,tracking,request,target,allocation,id,shard,id,initiating,tracking,of,request,target,allocation,id,shard,cancellable,threads,logger,final,long,ending,seq,no,shard,seq,no,stats,get,max,seq,no,cancellable,threads,execute,shard,wait,for,ops,to,complete,ending,seq,no,logger,trace,all,operations,up,to,completed,which,will,be,used,as,an,ending,sequence,number,ending,seq,no,logger,trace,snapshot,translog,for,recovery,current,size,is,shard,estimate,translog,operations,from,min,seq,starting,seq,no,final,long,target,local,checkpoint,try,translog,snapshot,snapshot,shard,new,translog,snapshot,from,min,seq,no,starting,seq,no,target,local,checkpoint,phase2,starting,seq,no,required,seq,no,range,start,ending,seq,no,snapshot,catch,exception,e,throw,new,recovery,engine,exception,shard,shard,id,2,phase2,failed,e,finalize,recovery,target,local,checkpoint,return,response
RecoverySourceHandler -> public RecoveryResponse recoverToTarget() throws IOException;1533295538;performs the recovery from the local engine to the target;public RecoveryResponse recoverToTarget() throws IOException {_        runUnderPrimaryPermit(() -> {_            final IndexShardRoutingTable routingTable = shard.getReplicationGroup().getRoutingTable()__            ShardRouting targetShardRouting = routingTable.getByAllocationId(request.targetAllocationId())__            if (targetShardRouting == null) {_                logger.debug("delaying recovery of {} as it is not listed as assigned to target node {}", request.shardId(),_                    request.targetNode())__                throw new DelayRecoveryException("source node does not have the shard listed in its state as allocated on the node")__            }_            assert targetShardRouting.initializing() : "expected recovery target to be initializing but was " + targetShardRouting__        }, shardId + " validating recovery target ["+ request.targetAllocationId() + "] registered ", shard, cancellableThreads, logger)___        try (Closeable ignored = shard.acquireTranslogRetentionLock()) {_            final long startingSeqNo__            final long requiredSeqNoRangeStart__            final boolean isSequenceNumberBasedRecovery = request.startingSeqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                isTargetSameHistory() && isTranslogReadyForSequenceNumberBasedRecovery()__            if (isSequenceNumberBasedRecovery) {_                logger.trace("performing sequence numbers based recovery. starting at [{}]", request.startingSeqNo())__                startingSeqNo = request.startingSeqNo()__                requiredSeqNoRangeStart = startingSeqNo__            } else {_                final Engine.IndexCommitRef phase1Snapshot__                try {_                    phase1Snapshot = shard.acquireSafeIndexCommit()__                } catch (final Exception e) {_                    throw new RecoveryEngineException(shard.shardId(), 1, "snapshot failed", e)__                }_                _                _                startingSeqNo = 0__                _                requiredSeqNoRangeStart =_                    Long.parseLong(phase1Snapshot.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) + 1__                try {_                    phase1(phase1Snapshot.getIndexCommit(), () -> shard.estimateTranslogOperationsFromMinSeq(startingSeqNo))__                } catch (final Exception e) {_                    throw new RecoveryEngineException(shard.shardId(), 1, "phase1 failed", e)__                } finally {_                    try {_                        IOUtils.close(phase1Snapshot)__                    } catch (final IOException ex) {_                        logger.warn("releasing snapshot caused exception", ex)__                    }_                }_            }_            assert startingSeqNo >= 0 : "startingSeqNo must be non negative. got: " + startingSeqNo__            assert requiredSeqNoRangeStart >= startingSeqNo : "requiredSeqNoRangeStart [" + requiredSeqNoRangeStart + "] is lower than ["_                + startingSeqNo + "]"___            try {_                _                prepareTargetForTranslog(isSequenceNumberBasedRecovery == false, shard.estimateTranslogOperationsFromMinSeq(startingSeqNo))__            } catch (final Exception e) {_                throw new RecoveryEngineException(shard.shardId(), 1, "prepare target for translog failed", e)__            }__            _            runUnderPrimaryPermit(() -> shard.initiateTracking(request.targetAllocationId()),_                shardId + " initiating tracking of " + request.targetAllocationId(), shard, cancellableThreads, logger)___            final long endingSeqNo = shard.seqNoStats().getMaxSeqNo()__            _            cancellableThreads.execute(() -> shard.waitForOpsToComplete(endingSeqNo))___            logger.trace("all operations up to [{}] completed, which will be used as an ending sequence number", endingSeqNo)___            logger.trace("snapshot translog for recovery_ current size is [{}]", shard.estimateTranslogOperationsFromMinSeq(startingSeqNo))__            final long targetLocalCheckpoint__            try(Translog.Snapshot snapshot = shard.newTranslogSnapshotFromMinSeqNo(startingSeqNo)) {_                targetLocalCheckpoint = phase2(startingSeqNo, requiredSeqNoRangeStart, endingSeqNo, snapshot)__            } catch (Exception e) {_                throw new RecoveryEngineException(shard.shardId(), 2, "phase2 failed", e)__            }__            finalizeRecovery(targetLocalCheckpoint)__        }_        return response__    };performs,the,recovery,from,the,local,engine,to,the,target;public,recovery,response,recover,to,target,throws,ioexception,run,under,primary,permit,final,index,shard,routing,table,routing,table,shard,get,replication,group,get,routing,table,shard,routing,target,shard,routing,routing,table,get,by,allocation,id,request,target,allocation,id,if,target,shard,routing,null,logger,debug,delaying,recovery,of,as,it,is,not,listed,as,assigned,to,target,node,request,shard,id,request,target,node,throw,new,delay,recovery,exception,source,node,does,not,have,the,shard,listed,in,its,state,as,allocated,on,the,node,assert,target,shard,routing,initializing,expected,recovery,target,to,be,initializing,but,was,target,shard,routing,shard,id,validating,recovery,target,request,target,allocation,id,registered,shard,cancellable,threads,logger,try,closeable,ignored,shard,acquire,translog,retention,lock,final,long,starting,seq,no,final,long,required,seq,no,range,start,final,boolean,is,sequence,number,based,recovery,request,starting,seq,no,sequence,numbers,is,target,same,history,is,translog,ready,for,sequence,number,based,recovery,if,is,sequence,number,based,recovery,logger,trace,performing,sequence,numbers,based,recovery,starting,at,request,starting,seq,no,starting,seq,no,request,starting,seq,no,required,seq,no,range,start,starting,seq,no,else,final,engine,index,commit,ref,phase1snapshot,try,phase1snapshot,shard,acquire,safe,index,commit,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,snapshot,failed,e,starting,seq,no,0,required,seq,no,range,start,long,parse,long,phase1snapshot,get,index,commit,get,user,data,get,sequence,numbers,1,try,phase1,phase1snapshot,get,index,commit,shard,estimate,translog,operations,from,min,seq,starting,seq,no,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,phase1,failed,e,finally,try,ioutils,close,phase1snapshot,catch,final,ioexception,ex,logger,warn,releasing,snapshot,caused,exception,ex,assert,starting,seq,no,0,starting,seq,no,must,be,non,negative,got,starting,seq,no,assert,required,seq,no,range,start,starting,seq,no,required,seq,no,range,start,required,seq,no,range,start,is,lower,than,starting,seq,no,try,prepare,target,for,translog,is,sequence,number,based,recovery,false,shard,estimate,translog,operations,from,min,seq,starting,seq,no,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,prepare,target,for,translog,failed,e,run,under,primary,permit,shard,initiate,tracking,request,target,allocation,id,shard,id,initiating,tracking,of,request,target,allocation,id,shard,cancellable,threads,logger,final,long,ending,seq,no,shard,seq,no,stats,get,max,seq,no,cancellable,threads,execute,shard,wait,for,ops,to,complete,ending,seq,no,logger,trace,all,operations,up,to,completed,which,will,be,used,as,an,ending,sequence,number,ending,seq,no,logger,trace,snapshot,translog,for,recovery,current,size,is,shard,estimate,translog,operations,from,min,seq,starting,seq,no,final,long,target,local,checkpoint,try,translog,snapshot,snapshot,shard,new,translog,snapshot,from,min,seq,no,starting,seq,no,target,local,checkpoint,phase2,starting,seq,no,required,seq,no,range,start,ending,seq,no,snapshot,catch,exception,e,throw,new,recovery,engine,exception,shard,shard,id,2,phase2,failed,e,finalize,recovery,target,local,checkpoint,return,response
RecoverySourceHandler -> public RecoveryResponse recoverToTarget() throws IOException;1535723122;performs the recovery from the local engine to the target;public RecoveryResponse recoverToTarget() throws IOException {_        runUnderPrimaryPermit(() -> {_            final IndexShardRoutingTable routingTable = shard.getReplicationGroup().getRoutingTable()__            ShardRouting targetShardRouting = routingTable.getByAllocationId(request.targetAllocationId())__            if (targetShardRouting == null) {_                logger.debug("delaying recovery of {} as it is not listed as assigned to target node {}", request.shardId(),_                    request.targetNode())__                throw new DelayRecoveryException("source node does not have the shard listed in its state as allocated on the node")__            }_            assert targetShardRouting.initializing() : "expected recovery target to be initializing but was " + targetShardRouting__        }, shardId + " validating recovery target ["+ request.targetAllocationId() + "] registered ", shard, cancellableThreads, logger)___        try (Closeable ignored = shard.acquireRetentionLockForPeerRecovery()) {_            final long startingSeqNo__            final long requiredSeqNoRangeStart__            final boolean isSequenceNumberBasedRecovery = request.startingSeqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                isTargetSameHistory() && shard.hasCompleteHistoryOperations("peer-recovery", request.startingSeqNo())__            if (isSequenceNumberBasedRecovery) {_                logger.trace("performing sequence numbers based recovery. starting at [{}]", request.startingSeqNo())__                startingSeqNo = request.startingSeqNo()__                requiredSeqNoRangeStart = startingSeqNo__            } else {_                final Engine.IndexCommitRef phase1Snapshot__                try {_                    phase1Snapshot = shard.acquireSafeIndexCommit()__                } catch (final Exception e) {_                    throw new RecoveryEngineException(shard.shardId(), 1, "snapshot failed", e)__                }_                _                requiredSeqNoRangeStart =_                    Long.parseLong(phase1Snapshot.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) + 1__                _                _                _                startingSeqNo = shard.indexSettings().isSoftDeleteEnabled() ? requiredSeqNoRangeStart : 0__                try {_                    final int estimateNumOps = shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo)__                    phase1(phase1Snapshot.getIndexCommit(), () -> estimateNumOps)__                } catch (final Exception e) {_                    throw new RecoveryEngineException(shard.shardId(), 1, "phase1 failed", e)__                } finally {_                    try {_                        IOUtils.close(phase1Snapshot)__                    } catch (final IOException ex) {_                        logger.warn("releasing snapshot caused exception", ex)__                    }_                }_            }_            assert startingSeqNo >= 0 : "startingSeqNo must be non negative. got: " + startingSeqNo__            assert requiredSeqNoRangeStart >= startingSeqNo : "requiredSeqNoRangeStart [" + requiredSeqNoRangeStart + "] is lower than ["_                + startingSeqNo + "]"___            try {_                _                prepareTargetForTranslog(isSequenceNumberBasedRecovery == false,_                    shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo))__            } catch (final Exception e) {_                throw new RecoveryEngineException(shard.shardId(), 1, "prepare target for translog failed", e)__            }__            _            runUnderPrimaryPermit(() -> shard.initiateTracking(request.targetAllocationId()),_                shardId + " initiating tracking of " + request.targetAllocationId(), shard, cancellableThreads, logger)___            final long endingSeqNo = shard.seqNoStats().getMaxSeqNo()__            _            cancellableThreads.execute(() -> shard.waitForOpsToComplete(endingSeqNo))___            if (logger.isTraceEnabled()) {_                logger.trace("all operations up to [{}] completed, which will be used as an ending sequence number", endingSeqNo)__                logger.trace("snapshot translog for recovery_ current size is [{}]",_                    shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo))__            }_            final long targetLocalCheckpoint__            try (Translog.Snapshot snapshot = shard.getHistoryOperations("peer-recovery", startingSeqNo)) {_                targetLocalCheckpoint = phase2(startingSeqNo, requiredSeqNoRangeStart, endingSeqNo, snapshot)__            } catch (Exception e) {_                throw new RecoveryEngineException(shard.shardId(), 2, "phase2 failed", e)__            }__            finalizeRecovery(targetLocalCheckpoint)__        }_        return response__    };performs,the,recovery,from,the,local,engine,to,the,target;public,recovery,response,recover,to,target,throws,ioexception,run,under,primary,permit,final,index,shard,routing,table,routing,table,shard,get,replication,group,get,routing,table,shard,routing,target,shard,routing,routing,table,get,by,allocation,id,request,target,allocation,id,if,target,shard,routing,null,logger,debug,delaying,recovery,of,as,it,is,not,listed,as,assigned,to,target,node,request,shard,id,request,target,node,throw,new,delay,recovery,exception,source,node,does,not,have,the,shard,listed,in,its,state,as,allocated,on,the,node,assert,target,shard,routing,initializing,expected,recovery,target,to,be,initializing,but,was,target,shard,routing,shard,id,validating,recovery,target,request,target,allocation,id,registered,shard,cancellable,threads,logger,try,closeable,ignored,shard,acquire,retention,lock,for,peer,recovery,final,long,starting,seq,no,final,long,required,seq,no,range,start,final,boolean,is,sequence,number,based,recovery,request,starting,seq,no,sequence,numbers,is,target,same,history,shard,has,complete,history,operations,peer,recovery,request,starting,seq,no,if,is,sequence,number,based,recovery,logger,trace,performing,sequence,numbers,based,recovery,starting,at,request,starting,seq,no,starting,seq,no,request,starting,seq,no,required,seq,no,range,start,starting,seq,no,else,final,engine,index,commit,ref,phase1snapshot,try,phase1snapshot,shard,acquire,safe,index,commit,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,snapshot,failed,e,required,seq,no,range,start,long,parse,long,phase1snapshot,get,index,commit,get,user,data,get,sequence,numbers,1,starting,seq,no,shard,index,settings,is,soft,delete,enabled,required,seq,no,range,start,0,try,final,int,estimate,num,ops,shard,estimate,number,of,history,operations,peer,recovery,starting,seq,no,phase1,phase1snapshot,get,index,commit,estimate,num,ops,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,phase1,failed,e,finally,try,ioutils,close,phase1snapshot,catch,final,ioexception,ex,logger,warn,releasing,snapshot,caused,exception,ex,assert,starting,seq,no,0,starting,seq,no,must,be,non,negative,got,starting,seq,no,assert,required,seq,no,range,start,starting,seq,no,required,seq,no,range,start,required,seq,no,range,start,is,lower,than,starting,seq,no,try,prepare,target,for,translog,is,sequence,number,based,recovery,false,shard,estimate,number,of,history,operations,peer,recovery,starting,seq,no,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,prepare,target,for,translog,failed,e,run,under,primary,permit,shard,initiate,tracking,request,target,allocation,id,shard,id,initiating,tracking,of,request,target,allocation,id,shard,cancellable,threads,logger,final,long,ending,seq,no,shard,seq,no,stats,get,max,seq,no,cancellable,threads,execute,shard,wait,for,ops,to,complete,ending,seq,no,if,logger,is,trace,enabled,logger,trace,all,operations,up,to,completed,which,will,be,used,as,an,ending,sequence,number,ending,seq,no,logger,trace,snapshot,translog,for,recovery,current,size,is,shard,estimate,number,of,history,operations,peer,recovery,starting,seq,no,final,long,target,local,checkpoint,try,translog,snapshot,snapshot,shard,get,history,operations,peer,recovery,starting,seq,no,target,local,checkpoint,phase2,starting,seq,no,required,seq,no,range,start,ending,seq,no,snapshot,catch,exception,e,throw,new,recovery,engine,exception,shard,shard,id,2,phase2,failed,e,finalize,recovery,target,local,checkpoint,return,response
RecoverySourceHandler -> public RecoveryResponse recoverToTarget() throws IOException;1535965276;performs the recovery from the local engine to the target;public RecoveryResponse recoverToTarget() throws IOException {_        runUnderPrimaryPermit(() -> {_            final IndexShardRoutingTable routingTable = shard.getReplicationGroup().getRoutingTable()__            ShardRouting targetShardRouting = routingTable.getByAllocationId(request.targetAllocationId())__            if (targetShardRouting == null) {_                logger.debug("delaying recovery of {} as it is not listed as assigned to target node {}", request.shardId(),_                    request.targetNode())__                throw new DelayRecoveryException("source node does not have the shard listed in its state as allocated on the node")__            }_            assert targetShardRouting.initializing() : "expected recovery target to be initializing but was " + targetShardRouting__        }, shardId + " validating recovery target ["+ request.targetAllocationId() + "] registered ", shard, cancellableThreads, logger)___        try (Closeable ignored = shard.acquireRetentionLockForPeerRecovery()) {_            final long startingSeqNo__            final long requiredSeqNoRangeStart__            final boolean isSequenceNumberBasedRecovery = request.startingSeqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                isTargetSameHistory() && shard.hasCompleteHistoryOperations("peer-recovery", request.startingSeqNo())__            if (isSequenceNumberBasedRecovery) {_                logger.trace("performing sequence numbers based recovery. starting at [{}]", request.startingSeqNo())__                startingSeqNo = request.startingSeqNo()__                requiredSeqNoRangeStart = startingSeqNo__            } else {_                final Engine.IndexCommitRef phase1Snapshot__                try {_                    phase1Snapshot = shard.acquireSafeIndexCommit()__                } catch (final Exception e) {_                    throw new RecoveryEngineException(shard.shardId(), 1, "snapshot failed", e)__                }_                _                requiredSeqNoRangeStart =_                    Long.parseLong(phase1Snapshot.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) + 1__                _                _                _                startingSeqNo = shard.indexSettings().isSoftDeleteEnabled() ? requiredSeqNoRangeStart : 0__                try {_                    final int estimateNumOps = shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo)__                    phase1(phase1Snapshot.getIndexCommit(), () -> estimateNumOps)__                } catch (final Exception e) {_                    throw new RecoveryEngineException(shard.shardId(), 1, "phase1 failed", e)__                } finally {_                    try {_                        IOUtils.close(phase1Snapshot)__                    } catch (final IOException ex) {_                        logger.warn("releasing snapshot caused exception", ex)__                    }_                }_            }_            assert startingSeqNo >= 0 : "startingSeqNo must be non negative. got: " + startingSeqNo__            assert requiredSeqNoRangeStart >= startingSeqNo : "requiredSeqNoRangeStart [" + requiredSeqNoRangeStart + "] is lower than ["_                + startingSeqNo + "]"___            try {_                _                prepareTargetForTranslog(isSequenceNumberBasedRecovery == false,_                    shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo))__            } catch (final Exception e) {_                throw new RecoveryEngineException(shard.shardId(), 1, "prepare target for translog failed", e)__            }__            _            runUnderPrimaryPermit(() -> shard.initiateTracking(request.targetAllocationId()),_                shardId + " initiating tracking of " + request.targetAllocationId(), shard, cancellableThreads, logger)___            final long endingSeqNo = shard.seqNoStats().getMaxSeqNo()__            _            cancellableThreads.execute(() -> shard.waitForOpsToComplete(endingSeqNo))___            if (logger.isTraceEnabled()) {_                logger.trace("all operations up to [{}] completed, which will be used as an ending sequence number", endingSeqNo)__                logger.trace("snapshot translog for recovery_ current size is [{}]",_                    shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo))__            }_            final long targetLocalCheckpoint__            try (Translog.Snapshot snapshot = shard.getHistoryOperations("peer-recovery", startingSeqNo)) {_                targetLocalCheckpoint = phase2(startingSeqNo, requiredSeqNoRangeStart, endingSeqNo, snapshot)__            } catch (Exception e) {_                throw new RecoveryEngineException(shard.shardId(), 2, "phase2 failed", e)__            }__            finalizeRecovery(targetLocalCheckpoint)__        }_        return response__    };performs,the,recovery,from,the,local,engine,to,the,target;public,recovery,response,recover,to,target,throws,ioexception,run,under,primary,permit,final,index,shard,routing,table,routing,table,shard,get,replication,group,get,routing,table,shard,routing,target,shard,routing,routing,table,get,by,allocation,id,request,target,allocation,id,if,target,shard,routing,null,logger,debug,delaying,recovery,of,as,it,is,not,listed,as,assigned,to,target,node,request,shard,id,request,target,node,throw,new,delay,recovery,exception,source,node,does,not,have,the,shard,listed,in,its,state,as,allocated,on,the,node,assert,target,shard,routing,initializing,expected,recovery,target,to,be,initializing,but,was,target,shard,routing,shard,id,validating,recovery,target,request,target,allocation,id,registered,shard,cancellable,threads,logger,try,closeable,ignored,shard,acquire,retention,lock,for,peer,recovery,final,long,starting,seq,no,final,long,required,seq,no,range,start,final,boolean,is,sequence,number,based,recovery,request,starting,seq,no,sequence,numbers,is,target,same,history,shard,has,complete,history,operations,peer,recovery,request,starting,seq,no,if,is,sequence,number,based,recovery,logger,trace,performing,sequence,numbers,based,recovery,starting,at,request,starting,seq,no,starting,seq,no,request,starting,seq,no,required,seq,no,range,start,starting,seq,no,else,final,engine,index,commit,ref,phase1snapshot,try,phase1snapshot,shard,acquire,safe,index,commit,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,snapshot,failed,e,required,seq,no,range,start,long,parse,long,phase1snapshot,get,index,commit,get,user,data,get,sequence,numbers,1,starting,seq,no,shard,index,settings,is,soft,delete,enabled,required,seq,no,range,start,0,try,final,int,estimate,num,ops,shard,estimate,number,of,history,operations,peer,recovery,starting,seq,no,phase1,phase1snapshot,get,index,commit,estimate,num,ops,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,phase1,failed,e,finally,try,ioutils,close,phase1snapshot,catch,final,ioexception,ex,logger,warn,releasing,snapshot,caused,exception,ex,assert,starting,seq,no,0,starting,seq,no,must,be,non,negative,got,starting,seq,no,assert,required,seq,no,range,start,starting,seq,no,required,seq,no,range,start,required,seq,no,range,start,is,lower,than,starting,seq,no,try,prepare,target,for,translog,is,sequence,number,based,recovery,false,shard,estimate,number,of,history,operations,peer,recovery,starting,seq,no,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,prepare,target,for,translog,failed,e,run,under,primary,permit,shard,initiate,tracking,request,target,allocation,id,shard,id,initiating,tracking,of,request,target,allocation,id,shard,cancellable,threads,logger,final,long,ending,seq,no,shard,seq,no,stats,get,max,seq,no,cancellable,threads,execute,shard,wait,for,ops,to,complete,ending,seq,no,if,logger,is,trace,enabled,logger,trace,all,operations,up,to,completed,which,will,be,used,as,an,ending,sequence,number,ending,seq,no,logger,trace,snapshot,translog,for,recovery,current,size,is,shard,estimate,number,of,history,operations,peer,recovery,starting,seq,no,final,long,target,local,checkpoint,try,translog,snapshot,snapshot,shard,get,history,operations,peer,recovery,starting,seq,no,target,local,checkpoint,phase2,starting,seq,no,required,seq,no,range,start,ending,seq,no,snapshot,catch,exception,e,throw,new,recovery,engine,exception,shard,shard,id,2,phase2,failed,e,finalize,recovery,target,local,checkpoint,return,response
RecoverySourceHandler -> public RecoveryResponse recoverToTarget() throws IOException;1537806831;performs the recovery from the local engine to the target;public RecoveryResponse recoverToTarget() throws IOException {_        runUnderPrimaryPermit(() -> {_            final IndexShardRoutingTable routingTable = shard.getReplicationGroup().getRoutingTable()__            ShardRouting targetShardRouting = routingTable.getByAllocationId(request.targetAllocationId())__            if (targetShardRouting == null) {_                logger.debug("delaying recovery of {} as it is not listed as assigned to target node {}", request.shardId(),_                    request.targetNode())__                throw new DelayRecoveryException("source node does not have the shard listed in its state as allocated on the node")__            }_            assert targetShardRouting.initializing() : "expected recovery target to be initializing but was " + targetShardRouting__        }, shardId + " validating recovery target ["+ request.targetAllocationId() + "] registered ", shard, cancellableThreads, logger)___        try (Closeable ignored = shard.acquireRetentionLockForPeerRecovery()) {_            final long startingSeqNo__            final long requiredSeqNoRangeStart__            final boolean isSequenceNumberBasedRecovery = request.startingSeqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                isTargetSameHistory() && shard.hasCompleteHistoryOperations("peer-recovery", request.startingSeqNo())__            if (isSequenceNumberBasedRecovery) {_                logger.trace("performing sequence numbers based recovery. starting at [{}]", request.startingSeqNo())__                startingSeqNo = request.startingSeqNo()__                requiredSeqNoRangeStart = startingSeqNo__            } else {_                final Engine.IndexCommitRef phase1Snapshot__                try {_                    phase1Snapshot = shard.acquireSafeIndexCommit()__                } catch (final Exception e) {_                    throw new RecoveryEngineException(shard.shardId(), 1, "snapshot failed", e)__                }_                _                requiredSeqNoRangeStart =_                    Long.parseLong(phase1Snapshot.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) + 1__                _                _                _                startingSeqNo = shard.indexSettings().isSoftDeleteEnabled() ? requiredSeqNoRangeStart : 0__                try {_                    final int estimateNumOps = shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo)__                    phase1(phase1Snapshot.getIndexCommit(), () -> estimateNumOps)__                } catch (final Exception e) {_                    throw new RecoveryEngineException(shard.shardId(), 1, "phase1 failed", e)__                } finally {_                    try {_                        IOUtils.close(phase1Snapshot)__                    } catch (final IOException ex) {_                        logger.warn("releasing snapshot caused exception", ex)__                    }_                }_            }_            assert startingSeqNo >= 0 : "startingSeqNo must be non negative. got: " + startingSeqNo__            assert requiredSeqNoRangeStart >= startingSeqNo : "requiredSeqNoRangeStart [" + requiredSeqNoRangeStart + "] is lower than ["_                + startingSeqNo + "]"___            try {_                _                prepareTargetForTranslog(isSequenceNumberBasedRecovery == false,_                    shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo))__            } catch (final Exception e) {_                throw new RecoveryEngineException(shard.shardId(), 1, "prepare target for translog failed", e)__            }__            _            runUnderPrimaryPermit(() -> shard.initiateTracking(request.targetAllocationId()),_                shardId + " initiating tracking of " + request.targetAllocationId(), shard, cancellableThreads, logger)___            final long endingSeqNo = shard.seqNoStats().getMaxSeqNo()__            _            cancellableThreads.execute(() -> shard.waitForOpsToComplete(endingSeqNo))___            if (logger.isTraceEnabled()) {_                logger.trace("all operations up to [{}] completed, which will be used as an ending sequence number", endingSeqNo)__                logger.trace("snapshot translog for recovery_ current size is [{}]",_                    shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo))__            }_            final long targetLocalCheckpoint__            try (Translog.Snapshot snapshot = shard.getHistoryOperations("peer-recovery", startingSeqNo)) {_                _                _                final long maxSeenAutoIdTimestamp = shard.getMaxSeenAutoIdTimestamp()__                targetLocalCheckpoint = phase2(startingSeqNo, requiredSeqNoRangeStart, endingSeqNo, snapshot, maxSeenAutoIdTimestamp)__            } catch (Exception e) {_                throw new RecoveryEngineException(shard.shardId(), 2, "phase2 failed", e)__            }__            finalizeRecovery(targetLocalCheckpoint)__        }_        return response__    };performs,the,recovery,from,the,local,engine,to,the,target;public,recovery,response,recover,to,target,throws,ioexception,run,under,primary,permit,final,index,shard,routing,table,routing,table,shard,get,replication,group,get,routing,table,shard,routing,target,shard,routing,routing,table,get,by,allocation,id,request,target,allocation,id,if,target,shard,routing,null,logger,debug,delaying,recovery,of,as,it,is,not,listed,as,assigned,to,target,node,request,shard,id,request,target,node,throw,new,delay,recovery,exception,source,node,does,not,have,the,shard,listed,in,its,state,as,allocated,on,the,node,assert,target,shard,routing,initializing,expected,recovery,target,to,be,initializing,but,was,target,shard,routing,shard,id,validating,recovery,target,request,target,allocation,id,registered,shard,cancellable,threads,logger,try,closeable,ignored,shard,acquire,retention,lock,for,peer,recovery,final,long,starting,seq,no,final,long,required,seq,no,range,start,final,boolean,is,sequence,number,based,recovery,request,starting,seq,no,sequence,numbers,is,target,same,history,shard,has,complete,history,operations,peer,recovery,request,starting,seq,no,if,is,sequence,number,based,recovery,logger,trace,performing,sequence,numbers,based,recovery,starting,at,request,starting,seq,no,starting,seq,no,request,starting,seq,no,required,seq,no,range,start,starting,seq,no,else,final,engine,index,commit,ref,phase1snapshot,try,phase1snapshot,shard,acquire,safe,index,commit,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,snapshot,failed,e,required,seq,no,range,start,long,parse,long,phase1snapshot,get,index,commit,get,user,data,get,sequence,numbers,1,starting,seq,no,shard,index,settings,is,soft,delete,enabled,required,seq,no,range,start,0,try,final,int,estimate,num,ops,shard,estimate,number,of,history,operations,peer,recovery,starting,seq,no,phase1,phase1snapshot,get,index,commit,estimate,num,ops,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,phase1,failed,e,finally,try,ioutils,close,phase1snapshot,catch,final,ioexception,ex,logger,warn,releasing,snapshot,caused,exception,ex,assert,starting,seq,no,0,starting,seq,no,must,be,non,negative,got,starting,seq,no,assert,required,seq,no,range,start,starting,seq,no,required,seq,no,range,start,required,seq,no,range,start,is,lower,than,starting,seq,no,try,prepare,target,for,translog,is,sequence,number,based,recovery,false,shard,estimate,number,of,history,operations,peer,recovery,starting,seq,no,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,prepare,target,for,translog,failed,e,run,under,primary,permit,shard,initiate,tracking,request,target,allocation,id,shard,id,initiating,tracking,of,request,target,allocation,id,shard,cancellable,threads,logger,final,long,ending,seq,no,shard,seq,no,stats,get,max,seq,no,cancellable,threads,execute,shard,wait,for,ops,to,complete,ending,seq,no,if,logger,is,trace,enabled,logger,trace,all,operations,up,to,completed,which,will,be,used,as,an,ending,sequence,number,ending,seq,no,logger,trace,snapshot,translog,for,recovery,current,size,is,shard,estimate,number,of,history,operations,peer,recovery,starting,seq,no,final,long,target,local,checkpoint,try,translog,snapshot,snapshot,shard,get,history,operations,peer,recovery,starting,seq,no,final,long,max,seen,auto,id,timestamp,shard,get,max,seen,auto,id,timestamp,target,local,checkpoint,phase2,starting,seq,no,required,seq,no,range,start,ending,seq,no,snapshot,max,seen,auto,id,timestamp,catch,exception,e,throw,new,recovery,engine,exception,shard,shard,id,2,phase2,failed,e,finalize,recovery,target,local,checkpoint,return,response
RecoverySourceHandler -> public RecoveryResponse recoverToTarget() throws IOException;1538067637;performs the recovery from the local engine to the target;public RecoveryResponse recoverToTarget() throws IOException {_        runUnderPrimaryPermit(() -> {_            final IndexShardRoutingTable routingTable = shard.getReplicationGroup().getRoutingTable()__            ShardRouting targetShardRouting = routingTable.getByAllocationId(request.targetAllocationId())__            if (targetShardRouting == null) {_                logger.debug("delaying recovery of {} as it is not listed as assigned to target node {}", request.shardId(),_                    request.targetNode())__                throw new DelayRecoveryException("source node does not have the shard listed in its state as allocated on the node")__            }_            assert targetShardRouting.initializing() : "expected recovery target to be initializing but was " + targetShardRouting__        }, shardId + " validating recovery target ["+ request.targetAllocationId() + "] registered ", shard, cancellableThreads, logger)___        try (Closeable ignored = shard.acquireRetentionLockForPeerRecovery()) {_            final long startingSeqNo__            final long requiredSeqNoRangeStart__            final boolean isSequenceNumberBasedRecovery = request.startingSeqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                isTargetSameHistory() && shard.hasCompleteHistoryOperations("peer-recovery", request.startingSeqNo())__            if (isSequenceNumberBasedRecovery) {_                logger.trace("performing sequence numbers based recovery. starting at [{}]", request.startingSeqNo())__                startingSeqNo = request.startingSeqNo()__                requiredSeqNoRangeStart = startingSeqNo__            } else {_                final Engine.IndexCommitRef phase1Snapshot__                try {_                    phase1Snapshot = shard.acquireSafeIndexCommit()__                } catch (final Exception e) {_                    throw new RecoveryEngineException(shard.shardId(), 1, "snapshot failed", e)__                }_                _                requiredSeqNoRangeStart =_                    Long.parseLong(phase1Snapshot.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) + 1__                _                _                _                startingSeqNo = shard.indexSettings().isSoftDeleteEnabled() ? requiredSeqNoRangeStart : 0__                try {_                    final int estimateNumOps = shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo)__                    phase1(phase1Snapshot.getIndexCommit(), () -> estimateNumOps)__                } catch (final Exception e) {_                    throw new RecoveryEngineException(shard.shardId(), 1, "phase1 failed", e)__                } finally {_                    try {_                        IOUtils.close(phase1Snapshot)__                    } catch (final IOException ex) {_                        logger.warn("releasing snapshot caused exception", ex)__                    }_                }_            }_            assert startingSeqNo >= 0 : "startingSeqNo must be non negative. got: " + startingSeqNo__            assert requiredSeqNoRangeStart >= startingSeqNo : "requiredSeqNoRangeStart [" + requiredSeqNoRangeStart + "] is lower than ["_                + startingSeqNo + "]"___            try {_                _                prepareTargetForTranslog(isSequenceNumberBasedRecovery == false,_                    shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo))__            } catch (final Exception e) {_                throw new RecoveryEngineException(shard.shardId(), 1, "prepare target for translog failed", e)__            }__            _            runUnderPrimaryPermit(() -> shard.initiateTracking(request.targetAllocationId()),_                shardId + " initiating tracking of " + request.targetAllocationId(), shard, cancellableThreads, logger)___            final long endingSeqNo = shard.seqNoStats().getMaxSeqNo()__            _            cancellableThreads.execute(() -> shard.waitForOpsToComplete(endingSeqNo))___            if (logger.isTraceEnabled()) {_                logger.trace("all operations up to [{}] completed, which will be used as an ending sequence number", endingSeqNo)__                logger.trace("snapshot translog for recovery_ current size is [{}]",_                    shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo))__            }_            final long targetLocalCheckpoint__            try (Translog.Snapshot snapshot = shard.getHistoryOperations("peer-recovery", startingSeqNo)) {_                _                _                final long maxSeenAutoIdTimestamp = shard.getMaxSeenAutoIdTimestamp()__                final long maxSeqNoOfUpdatesOrDeletes = shard.getMaxSeqNoOfUpdatesOrDeletes()__                targetLocalCheckpoint = phase2(startingSeqNo, requiredSeqNoRangeStart, endingSeqNo, snapshot,_                    maxSeenAutoIdTimestamp, maxSeqNoOfUpdatesOrDeletes)__            } catch (Exception e) {_                throw new RecoveryEngineException(shard.shardId(), 2, "phase2 failed", e)__            }__            finalizeRecovery(targetLocalCheckpoint)__        }_        return response__    };performs,the,recovery,from,the,local,engine,to,the,target;public,recovery,response,recover,to,target,throws,ioexception,run,under,primary,permit,final,index,shard,routing,table,routing,table,shard,get,replication,group,get,routing,table,shard,routing,target,shard,routing,routing,table,get,by,allocation,id,request,target,allocation,id,if,target,shard,routing,null,logger,debug,delaying,recovery,of,as,it,is,not,listed,as,assigned,to,target,node,request,shard,id,request,target,node,throw,new,delay,recovery,exception,source,node,does,not,have,the,shard,listed,in,its,state,as,allocated,on,the,node,assert,target,shard,routing,initializing,expected,recovery,target,to,be,initializing,but,was,target,shard,routing,shard,id,validating,recovery,target,request,target,allocation,id,registered,shard,cancellable,threads,logger,try,closeable,ignored,shard,acquire,retention,lock,for,peer,recovery,final,long,starting,seq,no,final,long,required,seq,no,range,start,final,boolean,is,sequence,number,based,recovery,request,starting,seq,no,sequence,numbers,is,target,same,history,shard,has,complete,history,operations,peer,recovery,request,starting,seq,no,if,is,sequence,number,based,recovery,logger,trace,performing,sequence,numbers,based,recovery,starting,at,request,starting,seq,no,starting,seq,no,request,starting,seq,no,required,seq,no,range,start,starting,seq,no,else,final,engine,index,commit,ref,phase1snapshot,try,phase1snapshot,shard,acquire,safe,index,commit,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,snapshot,failed,e,required,seq,no,range,start,long,parse,long,phase1snapshot,get,index,commit,get,user,data,get,sequence,numbers,1,starting,seq,no,shard,index,settings,is,soft,delete,enabled,required,seq,no,range,start,0,try,final,int,estimate,num,ops,shard,estimate,number,of,history,operations,peer,recovery,starting,seq,no,phase1,phase1snapshot,get,index,commit,estimate,num,ops,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,phase1,failed,e,finally,try,ioutils,close,phase1snapshot,catch,final,ioexception,ex,logger,warn,releasing,snapshot,caused,exception,ex,assert,starting,seq,no,0,starting,seq,no,must,be,non,negative,got,starting,seq,no,assert,required,seq,no,range,start,starting,seq,no,required,seq,no,range,start,required,seq,no,range,start,is,lower,than,starting,seq,no,try,prepare,target,for,translog,is,sequence,number,based,recovery,false,shard,estimate,number,of,history,operations,peer,recovery,starting,seq,no,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,prepare,target,for,translog,failed,e,run,under,primary,permit,shard,initiate,tracking,request,target,allocation,id,shard,id,initiating,tracking,of,request,target,allocation,id,shard,cancellable,threads,logger,final,long,ending,seq,no,shard,seq,no,stats,get,max,seq,no,cancellable,threads,execute,shard,wait,for,ops,to,complete,ending,seq,no,if,logger,is,trace,enabled,logger,trace,all,operations,up,to,completed,which,will,be,used,as,an,ending,sequence,number,ending,seq,no,logger,trace,snapshot,translog,for,recovery,current,size,is,shard,estimate,number,of,history,operations,peer,recovery,starting,seq,no,final,long,target,local,checkpoint,try,translog,snapshot,snapshot,shard,get,history,operations,peer,recovery,starting,seq,no,final,long,max,seen,auto,id,timestamp,shard,get,max,seen,auto,id,timestamp,final,long,max,seq,no,of,updates,or,deletes,shard,get,max,seq,no,of,updates,or,deletes,target,local,checkpoint,phase2,starting,seq,no,required,seq,no,range,start,ending,seq,no,snapshot,max,seen,auto,id,timestamp,max,seq,no,of,updates,or,deletes,catch,exception,e,throw,new,recovery,engine,exception,shard,shard,id,2,phase2,failed,e,finalize,recovery,target,local,checkpoint,return,response
RecoverySourceHandler -> public RecoveryResponse recoverToTarget() throws IOException;1546446953;performs the recovery from the local engine to the target;public RecoveryResponse recoverToTarget() throws IOException {_        runUnderPrimaryPermit(() -> {_            final IndexShardRoutingTable routingTable = shard.getReplicationGroup().getRoutingTable()__            ShardRouting targetShardRouting = routingTable.getByAllocationId(request.targetAllocationId())__            if (targetShardRouting == null) {_                logger.debug("delaying recovery of {} as it is not listed as assigned to target node {}", request.shardId(),_                    request.targetNode())__                throw new DelayRecoveryException("source node does not have the shard listed in its state as allocated on the node")__            }_            assert targetShardRouting.initializing() : "expected recovery target to be initializing but was " + targetShardRouting__        }, shardId + " validating recovery target ["+ request.targetAllocationId() + "] registered ", shard, cancellableThreads, logger)___        try (Closeable ignored = shard.acquireRetentionLockForPeerRecovery()) {_            final long startingSeqNo__            final long requiredSeqNoRangeStart__            final boolean isSequenceNumberBasedRecovery = request.startingSeqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                isTargetSameHistory() && shard.hasCompleteHistoryOperations("peer-recovery", request.startingSeqNo())__            if (isSequenceNumberBasedRecovery) {_                logger.trace("performing sequence numbers based recovery. starting at [{}]", request.startingSeqNo())__                startingSeqNo = request.startingSeqNo()__                requiredSeqNoRangeStart = startingSeqNo__            } else {_                final Engine.IndexCommitRef phase1Snapshot__                try {_                    phase1Snapshot = shard.acquireSafeIndexCommit()__                } catch (final Exception e) {_                    throw new RecoveryEngineException(shard.shardId(), 1, "snapshot failed", e)__                }_                _                requiredSeqNoRangeStart =_                    Long.parseLong(phase1Snapshot.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) + 1__                _                _                _                startingSeqNo = shard.indexSettings().isSoftDeleteEnabled() ? requiredSeqNoRangeStart : 0__                try {_                    final int estimateNumOps = shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo)__                    phase1(phase1Snapshot.getIndexCommit(), () -> estimateNumOps)__                } catch (final Exception e) {_                    throw new RecoveryEngineException(shard.shardId(), 1, "phase1 failed", e)__                } finally {_                    try {_                        IOUtils.close(phase1Snapshot)__                    } catch (final IOException ex) {_                        logger.warn("releasing snapshot caused exception", ex)__                    }_                }_            }_            assert startingSeqNo >= 0 : "startingSeqNo must be non negative. got: " + startingSeqNo__            assert requiredSeqNoRangeStart >= startingSeqNo : "requiredSeqNoRangeStart [" + requiredSeqNoRangeStart + "] is lower than ["_                + startingSeqNo + "]"___            try {_                _                prepareTargetForTranslog(isSequenceNumberBasedRecovery == false,_                    shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo))__            } catch (final Exception e) {_                throw new RecoveryEngineException(shard.shardId(), 1, "prepare target for translog failed", e)__            }__            _            runUnderPrimaryPermit(() -> shard.initiateTracking(request.targetAllocationId()),_                shardId + " initiating tracking of " + request.targetAllocationId(), shard, cancellableThreads, logger)___            final long endingSeqNo = shard.seqNoStats().getMaxSeqNo()__            _            cancellableThreads.execute(() -> shard.waitForOpsToComplete(endingSeqNo))___            if (logger.isTraceEnabled()) {_                logger.trace("all operations up to [{}] completed, which will be used as an ending sequence number", endingSeqNo)__                logger.trace("snapshot translog for recovery_ current size is [{}]",_                    shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo))__            }_            final long targetLocalCheckpoint__            try (Translog.Snapshot snapshot = shard.getHistoryOperations("peer-recovery", startingSeqNo)) {_                _                _                final long maxSeenAutoIdTimestamp = shard.getMaxSeenAutoIdTimestamp()__                final long maxSeqNoOfUpdatesOrDeletes = shard.getMaxSeqNoOfUpdatesOrDeletes()__                targetLocalCheckpoint = phase2(startingSeqNo, requiredSeqNoRangeStart, endingSeqNo, snapshot,_                    maxSeenAutoIdTimestamp, maxSeqNoOfUpdatesOrDeletes)__            } catch (Exception e) {_                throw new RecoveryEngineException(shard.shardId(), 2, "phase2 failed", e)__            }__            finalizeRecovery(targetLocalCheckpoint)__        }_        return response__    };performs,the,recovery,from,the,local,engine,to,the,target;public,recovery,response,recover,to,target,throws,ioexception,run,under,primary,permit,final,index,shard,routing,table,routing,table,shard,get,replication,group,get,routing,table,shard,routing,target,shard,routing,routing,table,get,by,allocation,id,request,target,allocation,id,if,target,shard,routing,null,logger,debug,delaying,recovery,of,as,it,is,not,listed,as,assigned,to,target,node,request,shard,id,request,target,node,throw,new,delay,recovery,exception,source,node,does,not,have,the,shard,listed,in,its,state,as,allocated,on,the,node,assert,target,shard,routing,initializing,expected,recovery,target,to,be,initializing,but,was,target,shard,routing,shard,id,validating,recovery,target,request,target,allocation,id,registered,shard,cancellable,threads,logger,try,closeable,ignored,shard,acquire,retention,lock,for,peer,recovery,final,long,starting,seq,no,final,long,required,seq,no,range,start,final,boolean,is,sequence,number,based,recovery,request,starting,seq,no,sequence,numbers,is,target,same,history,shard,has,complete,history,operations,peer,recovery,request,starting,seq,no,if,is,sequence,number,based,recovery,logger,trace,performing,sequence,numbers,based,recovery,starting,at,request,starting,seq,no,starting,seq,no,request,starting,seq,no,required,seq,no,range,start,starting,seq,no,else,final,engine,index,commit,ref,phase1snapshot,try,phase1snapshot,shard,acquire,safe,index,commit,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,snapshot,failed,e,required,seq,no,range,start,long,parse,long,phase1snapshot,get,index,commit,get,user,data,get,sequence,numbers,1,starting,seq,no,shard,index,settings,is,soft,delete,enabled,required,seq,no,range,start,0,try,final,int,estimate,num,ops,shard,estimate,number,of,history,operations,peer,recovery,starting,seq,no,phase1,phase1snapshot,get,index,commit,estimate,num,ops,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,phase1,failed,e,finally,try,ioutils,close,phase1snapshot,catch,final,ioexception,ex,logger,warn,releasing,snapshot,caused,exception,ex,assert,starting,seq,no,0,starting,seq,no,must,be,non,negative,got,starting,seq,no,assert,required,seq,no,range,start,starting,seq,no,required,seq,no,range,start,required,seq,no,range,start,is,lower,than,starting,seq,no,try,prepare,target,for,translog,is,sequence,number,based,recovery,false,shard,estimate,number,of,history,operations,peer,recovery,starting,seq,no,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,prepare,target,for,translog,failed,e,run,under,primary,permit,shard,initiate,tracking,request,target,allocation,id,shard,id,initiating,tracking,of,request,target,allocation,id,shard,cancellable,threads,logger,final,long,ending,seq,no,shard,seq,no,stats,get,max,seq,no,cancellable,threads,execute,shard,wait,for,ops,to,complete,ending,seq,no,if,logger,is,trace,enabled,logger,trace,all,operations,up,to,completed,which,will,be,used,as,an,ending,sequence,number,ending,seq,no,logger,trace,snapshot,translog,for,recovery,current,size,is,shard,estimate,number,of,history,operations,peer,recovery,starting,seq,no,final,long,target,local,checkpoint,try,translog,snapshot,snapshot,shard,get,history,operations,peer,recovery,starting,seq,no,final,long,max,seen,auto,id,timestamp,shard,get,max,seen,auto,id,timestamp,final,long,max,seq,no,of,updates,or,deletes,shard,get,max,seq,no,of,updates,or,deletes,target,local,checkpoint,phase2,starting,seq,no,required,seq,no,range,start,ending,seq,no,snapshot,max,seen,auto,id,timestamp,max,seq,no,of,updates,or,deletes,catch,exception,e,throw,new,recovery,engine,exception,shard,shard,id,2,phase2,failed,e,finalize,recovery,target,local,checkpoint,return,response
RecoverySourceHandler -> public RecoveryResponse recoverToTarget() throws IOException;1546981938;performs the recovery from the local engine to the target;public RecoveryResponse recoverToTarget() throws IOException {_        runUnderPrimaryPermit(() -> {_            final IndexShardRoutingTable routingTable = shard.getReplicationGroup().getRoutingTable()__            ShardRouting targetShardRouting = routingTable.getByAllocationId(request.targetAllocationId())__            if (targetShardRouting == null) {_                logger.debug("delaying recovery of {} as it is not listed as assigned to target node {}", request.shardId(),_                    request.targetNode())__                throw new DelayRecoveryException("source node does not have the shard listed in its state as allocated on the node")__            }_            assert targetShardRouting.initializing() : "expected recovery target to be initializing but was " + targetShardRouting__        }, shardId + " validating recovery target ["+ request.targetAllocationId() + "] registered ", shard, cancellableThreads, logger)___        try (Closeable ignored = shard.acquireRetentionLockForPeerRecovery()) {_            final long startingSeqNo__            final long requiredSeqNoRangeStart__            final boolean isSequenceNumberBasedRecovery = request.startingSeqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                isTargetSameHistory() && shard.hasCompleteHistoryOperations("peer-recovery", request.startingSeqNo())__            final SendFileResult sendFileResult__            if (isSequenceNumberBasedRecovery) {_                logger.trace("performing sequence numbers based recovery. starting at [{}]", request.startingSeqNo())__                startingSeqNo = request.startingSeqNo()__                requiredSeqNoRangeStart = startingSeqNo__                sendFileResult = SendFileResult.EMPTY__            } else {_                final Engine.IndexCommitRef phase1Snapshot__                try {_                    phase1Snapshot = shard.acquireSafeIndexCommit()__                } catch (final Exception e) {_                    throw new RecoveryEngineException(shard.shardId(), 1, "snapshot failed", e)__                }_                _                requiredSeqNoRangeStart =_                    Long.parseLong(phase1Snapshot.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) + 1__                _                _                _                startingSeqNo = shard.indexSettings().isSoftDeleteEnabled() ? requiredSeqNoRangeStart : 0__                try {_                    final int estimateNumOps = shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo)__                    sendFileResult = phase1(phase1Snapshot.getIndexCommit(), () -> estimateNumOps)__                } catch (final Exception e) {_                    throw new RecoveryEngineException(shard.shardId(), 1, "phase1 failed", e)__                } finally {_                    try {_                        IOUtils.close(phase1Snapshot)__                    } catch (final IOException ex) {_                        logger.warn("releasing snapshot caused exception", ex)__                    }_                }_            }_            assert startingSeqNo >= 0 : "startingSeqNo must be non negative. got: " + startingSeqNo__            assert requiredSeqNoRangeStart >= startingSeqNo : "requiredSeqNoRangeStart [" + requiredSeqNoRangeStart + "] is lower than ["_                + startingSeqNo + "]"___            final TimeValue prepareEngineTime__            try {_                _                prepareEngineTime = prepareTargetForTranslog(isSequenceNumberBasedRecovery == false,_                    shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo))__            } catch (final Exception e) {_                throw new RecoveryEngineException(shard.shardId(), 1, "prepare target for translog failed", e)__            }__            _            runUnderPrimaryPermit(() -> shard.initiateTracking(request.targetAllocationId()),_                shardId + " initiating tracking of " + request.targetAllocationId(), shard, cancellableThreads, logger)___            final long endingSeqNo = shard.seqNoStats().getMaxSeqNo()__            _            cancellableThreads.execute(() -> shard.waitForOpsToComplete(endingSeqNo))___            if (logger.isTraceEnabled()) {_                logger.trace("all operations up to [{}] completed, which will be used as an ending sequence number", endingSeqNo)__                logger.trace("snapshot translog for recovery_ current size is [{}]",_                    shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo))__            }_            final SendSnapshotResult sendSnapshotResult__            try (Translog.Snapshot snapshot = shard.getHistoryOperations("peer-recovery", startingSeqNo)) {_                _                _                final long maxSeenAutoIdTimestamp = shard.getMaxSeenAutoIdTimestamp()__                final long maxSeqNoOfUpdatesOrDeletes = shard.getMaxSeqNoOfUpdatesOrDeletes()__                sendSnapshotResult = phase2(startingSeqNo, requiredSeqNoRangeStart, endingSeqNo, snapshot,_                    maxSeenAutoIdTimestamp, maxSeqNoOfUpdatesOrDeletes)__            } catch (Exception e) {_                throw new RecoveryEngineException(shard.shardId(), 2, "phase2 failed", e)__            }__            finalizeRecovery(sendSnapshotResult.targetLocalCheckpoint)__            final long phase1ThrottlingWaitTime = 0L_ _            return new RecoveryResponse(sendFileResult.phase1FileNames, sendFileResult.phase1FileSizes,_                sendFileResult.phase1ExistingFileNames, sendFileResult.phase1ExistingFileSizes, sendFileResult.totalSize,_                sendFileResult.existingTotalSize, sendFileResult.took.millis(), phase1ThrottlingWaitTime, prepareEngineTime.millis(),_                sendSnapshotResult.totalOperations, sendSnapshotResult.tookTime.millis())__        }_    };performs,the,recovery,from,the,local,engine,to,the,target;public,recovery,response,recover,to,target,throws,ioexception,run,under,primary,permit,final,index,shard,routing,table,routing,table,shard,get,replication,group,get,routing,table,shard,routing,target,shard,routing,routing,table,get,by,allocation,id,request,target,allocation,id,if,target,shard,routing,null,logger,debug,delaying,recovery,of,as,it,is,not,listed,as,assigned,to,target,node,request,shard,id,request,target,node,throw,new,delay,recovery,exception,source,node,does,not,have,the,shard,listed,in,its,state,as,allocated,on,the,node,assert,target,shard,routing,initializing,expected,recovery,target,to,be,initializing,but,was,target,shard,routing,shard,id,validating,recovery,target,request,target,allocation,id,registered,shard,cancellable,threads,logger,try,closeable,ignored,shard,acquire,retention,lock,for,peer,recovery,final,long,starting,seq,no,final,long,required,seq,no,range,start,final,boolean,is,sequence,number,based,recovery,request,starting,seq,no,sequence,numbers,is,target,same,history,shard,has,complete,history,operations,peer,recovery,request,starting,seq,no,final,send,file,result,send,file,result,if,is,sequence,number,based,recovery,logger,trace,performing,sequence,numbers,based,recovery,starting,at,request,starting,seq,no,starting,seq,no,request,starting,seq,no,required,seq,no,range,start,starting,seq,no,send,file,result,send,file,result,empty,else,final,engine,index,commit,ref,phase1snapshot,try,phase1snapshot,shard,acquire,safe,index,commit,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,snapshot,failed,e,required,seq,no,range,start,long,parse,long,phase1snapshot,get,index,commit,get,user,data,get,sequence,numbers,1,starting,seq,no,shard,index,settings,is,soft,delete,enabled,required,seq,no,range,start,0,try,final,int,estimate,num,ops,shard,estimate,number,of,history,operations,peer,recovery,starting,seq,no,send,file,result,phase1,phase1snapshot,get,index,commit,estimate,num,ops,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,phase1,failed,e,finally,try,ioutils,close,phase1snapshot,catch,final,ioexception,ex,logger,warn,releasing,snapshot,caused,exception,ex,assert,starting,seq,no,0,starting,seq,no,must,be,non,negative,got,starting,seq,no,assert,required,seq,no,range,start,starting,seq,no,required,seq,no,range,start,required,seq,no,range,start,is,lower,than,starting,seq,no,final,time,value,prepare,engine,time,try,prepare,engine,time,prepare,target,for,translog,is,sequence,number,based,recovery,false,shard,estimate,number,of,history,operations,peer,recovery,starting,seq,no,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,prepare,target,for,translog,failed,e,run,under,primary,permit,shard,initiate,tracking,request,target,allocation,id,shard,id,initiating,tracking,of,request,target,allocation,id,shard,cancellable,threads,logger,final,long,ending,seq,no,shard,seq,no,stats,get,max,seq,no,cancellable,threads,execute,shard,wait,for,ops,to,complete,ending,seq,no,if,logger,is,trace,enabled,logger,trace,all,operations,up,to,completed,which,will,be,used,as,an,ending,sequence,number,ending,seq,no,logger,trace,snapshot,translog,for,recovery,current,size,is,shard,estimate,number,of,history,operations,peer,recovery,starting,seq,no,final,send,snapshot,result,send,snapshot,result,try,translog,snapshot,snapshot,shard,get,history,operations,peer,recovery,starting,seq,no,final,long,max,seen,auto,id,timestamp,shard,get,max,seen,auto,id,timestamp,final,long,max,seq,no,of,updates,or,deletes,shard,get,max,seq,no,of,updates,or,deletes,send,snapshot,result,phase2,starting,seq,no,required,seq,no,range,start,ending,seq,no,snapshot,max,seen,auto,id,timestamp,max,seq,no,of,updates,or,deletes,catch,exception,e,throw,new,recovery,engine,exception,shard,shard,id,2,phase2,failed,e,finalize,recovery,send,snapshot,result,target,local,checkpoint,final,long,phase1throttling,wait,time,0l,return,new,recovery,response,send,file,result,phase1file,names,send,file,result,phase1file,sizes,send,file,result,phase1existing,file,names,send,file,result,phase1existing,file,sizes,send,file,result,total,size,send,file,result,existing,total,size,send,file,result,took,millis,phase1throttling,wait,time,prepare,engine,time,millis,send,snapshot,result,total,operations,send,snapshot,result,took,time,millis
RecoverySourceHandler -> protected SendSnapshotResult sendSnapshot(final long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo,                                               final Translog.Snapshot snapshot, final long maxSeenAutoIdTimestamp,                                               final long maxSeqNoOfUpdatesOrDeletes) throws IOException;1538067637;Send the given snapshot's operations with a sequence number greater than the specified staring sequence number to this handler's_target node._<p>_Operations are bulked into a single request depending on an operation count limit or size-in-bytes limit.__@param startingSeqNo              the sequence number for which only operations with a sequence number greater than this will be sent_@param requiredSeqNoRangeStart    the lower sequence number of the required range_@param endingSeqNo                the upper bound of the sequence number range to be sent (inclusive)_@param snapshot                   the translog snapshot to replay operations from  @return the local checkpoint on the target and the_total number of operations sent_@param maxSeenAutoIdTimestamp     the max auto_id_timestamp of append-only requests on the primary_@param maxSeqNoOfUpdatesOrDeletes the max seq_no of updates or deletes on the primary after these operations were executed on it._@throws IOException if an I/O exception occurred reading the translog snapshot;protected SendSnapshotResult sendSnapshot(final long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo,_                                              final Translog.Snapshot snapshot, final long maxSeenAutoIdTimestamp,_                                              final long maxSeqNoOfUpdatesOrDeletes) throws IOException {_        assert requiredSeqNoRangeStart <= endingSeqNo + 1:_            "requiredSeqNoRangeStart " + requiredSeqNoRangeStart + " is larger than endingSeqNo " + endingSeqNo__        assert startingSeqNo <= requiredSeqNoRangeStart :_            "startingSeqNo " + startingSeqNo + " is larger than requiredSeqNoRangeStart " + requiredSeqNoRangeStart__        int ops = 0__        long size = 0__        int skippedOps = 0__        int totalSentOps = 0__        final AtomicLong targetLocalCheckpoint = new AtomicLong(SequenceNumbers.UNASSIGNED_SEQ_NO)__        final List<Translog.Operation> operations = new ArrayList<>()__        final LocalCheckpointTracker requiredOpsTracker = new LocalCheckpointTracker(endingSeqNo, requiredSeqNoRangeStart - 1)___        final int expectedTotalOps = snapshot.totalOperations()__        if (expectedTotalOps == 0) {_            logger.trace("no translog operations to send")__        }__        final CancellableThreads.IOInterruptable sendBatch = () -> {_            final long targetCheckpoint = recoveryTarget.indexTranslogOperations(_                operations, expectedTotalOps, maxSeenAutoIdTimestamp, maxSeqNoOfUpdatesOrDeletes)__            targetLocalCheckpoint.set(targetCheckpoint)__        }___        _        Translog.Operation operation__        while ((operation = snapshot.next()) != null) {_            if (shard.state() == IndexShardState.CLOSED) {_                throw new IndexShardClosedException(request.shardId())__            }_            cancellableThreads.checkForCancel()___            final long seqNo = operation.seqNo()__            if (seqNo < startingSeqNo || seqNo > endingSeqNo) {_                skippedOps++__                continue__            }_            operations.add(operation)__            ops++__            size += operation.estimateSize()__            totalSentOps++__            requiredOpsTracker.markSeqNoAsCompleted(seqNo)___            _            if (size >= chunkSizeInBytes) {_                cancellableThreads.executeIO(sendBatch)__                logger.trace("sent batch of [{}][{}] (total: [{}]) translog operations", ops, new ByteSizeValue(size), expectedTotalOps)__                ops = 0__                size = 0__                operations.clear()__            }_        }__        if (!operations.isEmpty() || totalSentOps == 0) {_            _            cancellableThreads.executeIO(sendBatch)__        }__        assert expectedTotalOps == snapshot.skippedOperations() + skippedOps + totalSentOps_            : String.format(Locale.ROOT, "expected total [%d], overridden [%d], skipped [%d], total sent [%d]",_            expectedTotalOps, snapshot.skippedOperations(), skippedOps, totalSentOps)___        if (requiredOpsTracker.getCheckpoint() < endingSeqNo) {_            throw new IllegalStateException("translog replay failed to cover required sequence numbers" +_                " (required range [" + requiredSeqNoRangeStart + ":" + endingSeqNo + "). first missing op is ["_                + (requiredOpsTracker.getCheckpoint() + 1) + "]")__        }__        logger.trace("sent final batch of [{}][{}] (total: [{}]) translog operations", ops, new ByteSizeValue(size), expectedTotalOps)___        return new SendSnapshotResult(targetLocalCheckpoint.get(), totalSentOps)__    };send,the,given,snapshot,s,operations,with,a,sequence,number,greater,than,the,specified,staring,sequence,number,to,this,handler,s,target,node,p,operations,are,bulked,into,a,single,request,depending,on,an,operation,count,limit,or,size,in,bytes,limit,param,starting,seq,no,the,sequence,number,for,which,only,operations,with,a,sequence,number,greater,than,this,will,be,sent,param,required,seq,no,range,start,the,lower,sequence,number,of,the,required,range,param,ending,seq,no,the,upper,bound,of,the,sequence,number,range,to,be,sent,inclusive,param,snapshot,the,translog,snapshot,to,replay,operations,from,return,the,local,checkpoint,on,the,target,and,the,total,number,of,operations,sent,param,max,seen,auto,id,timestamp,the,max,of,append,only,requests,on,the,primary,param,max,seq,no,of,updates,or,deletes,the,max,of,updates,or,deletes,on,the,primary,after,these,operations,were,executed,on,it,throws,ioexception,if,an,i,o,exception,occurred,reading,the,translog,snapshot;protected,send,snapshot,result,send,snapshot,final,long,starting,seq,no,long,required,seq,no,range,start,long,ending,seq,no,final,translog,snapshot,snapshot,final,long,max,seen,auto,id,timestamp,final,long,max,seq,no,of,updates,or,deletes,throws,ioexception,assert,required,seq,no,range,start,ending,seq,no,1,required,seq,no,range,start,required,seq,no,range,start,is,larger,than,ending,seq,no,ending,seq,no,assert,starting,seq,no,required,seq,no,range,start,starting,seq,no,starting,seq,no,is,larger,than,required,seq,no,range,start,required,seq,no,range,start,int,ops,0,long,size,0,int,skipped,ops,0,int,total,sent,ops,0,final,atomic,long,target,local,checkpoint,new,atomic,long,sequence,numbers,final,list,translog,operation,operations,new,array,list,final,local,checkpoint,tracker,required,ops,tracker,new,local,checkpoint,tracker,ending,seq,no,required,seq,no,range,start,1,final,int,expected,total,ops,snapshot,total,operations,if,expected,total,ops,0,logger,trace,no,translog,operations,to,send,final,cancellable,threads,iointerruptable,send,batch,final,long,target,checkpoint,recovery,target,index,translog,operations,operations,expected,total,ops,max,seen,auto,id,timestamp,max,seq,no,of,updates,or,deletes,target,local,checkpoint,set,target,checkpoint,translog,operation,operation,while,operation,snapshot,next,null,if,shard,state,index,shard,state,closed,throw,new,index,shard,closed,exception,request,shard,id,cancellable,threads,check,for,cancel,final,long,seq,no,operation,seq,no,if,seq,no,starting,seq,no,seq,no,ending,seq,no,skipped,ops,continue,operations,add,operation,ops,size,operation,estimate,size,total,sent,ops,required,ops,tracker,mark,seq,no,as,completed,seq,no,if,size,chunk,size,in,bytes,cancellable,threads,execute,io,send,batch,logger,trace,sent,batch,of,total,translog,operations,ops,new,byte,size,value,size,expected,total,ops,ops,0,size,0,operations,clear,if,operations,is,empty,total,sent,ops,0,cancellable,threads,execute,io,send,batch,assert,expected,total,ops,snapshot,skipped,operations,skipped,ops,total,sent,ops,string,format,locale,root,expected,total,d,overridden,d,skipped,d,total,sent,d,expected,total,ops,snapshot,skipped,operations,skipped,ops,total,sent,ops,if,required,ops,tracker,get,checkpoint,ending,seq,no,throw,new,illegal,state,exception,translog,replay,failed,to,cover,required,sequence,numbers,required,range,required,seq,no,range,start,ending,seq,no,first,missing,op,is,required,ops,tracker,get,checkpoint,1,logger,trace,sent,final,batch,of,total,translog,operations,ops,new,byte,size,value,size,expected,total,ops,return,new,send,snapshot,result,target,local,checkpoint,get,total,sent,ops
RecoverySourceHandler -> protected SendSnapshotResult sendSnapshot(final long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo,                                               final Translog.Snapshot snapshot, final long maxSeenAutoIdTimestamp,                                               final long maxSeqNoOfUpdatesOrDeletes) throws IOException;1546446953;Send the given snapshot's operations with a sequence number greater than the specified staring sequence number to this handler's_target node._<p>_Operations are bulked into a single request depending on an operation count limit or size-in-bytes limit.__@param startingSeqNo              the sequence number for which only operations with a sequence number greater than this will be sent_@param requiredSeqNoRangeStart    the lower sequence number of the required range_@param endingSeqNo                the upper bound of the sequence number range to be sent (inclusive)_@param snapshot                   the translog snapshot to replay operations from  @return the local checkpoint on the target and the_total number of operations sent_@param maxSeenAutoIdTimestamp     the max auto_id_timestamp of append-only requests on the primary_@param maxSeqNoOfUpdatesOrDeletes the max seq_no of updates or deletes on the primary after these operations were executed on it._@throws IOException if an I/O exception occurred reading the translog snapshot;protected SendSnapshotResult sendSnapshot(final long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo,_                                              final Translog.Snapshot snapshot, final long maxSeenAutoIdTimestamp,_                                              final long maxSeqNoOfUpdatesOrDeletes) throws IOException {_        assert requiredSeqNoRangeStart <= endingSeqNo + 1:_            "requiredSeqNoRangeStart " + requiredSeqNoRangeStart + " is larger than endingSeqNo " + endingSeqNo__        assert startingSeqNo <= requiredSeqNoRangeStart :_            "startingSeqNo " + startingSeqNo + " is larger than requiredSeqNoRangeStart " + requiredSeqNoRangeStart__        int ops = 0__        long size = 0__        int skippedOps = 0__        int totalSentOps = 0__        final AtomicLong targetLocalCheckpoint = new AtomicLong(SequenceNumbers.UNASSIGNED_SEQ_NO)__        final List<Translog.Operation> operations = new ArrayList<>()__        final LocalCheckpointTracker requiredOpsTracker = new LocalCheckpointTracker(endingSeqNo, requiredSeqNoRangeStart - 1)___        final int expectedTotalOps = snapshot.totalOperations()__        if (expectedTotalOps == 0) {_            logger.trace("no translog operations to send")__        }__        final CancellableThreads.IOInterruptible sendBatch = () -> {_            final long targetCheckpoint = recoveryTarget.indexTranslogOperations(_                operations, expectedTotalOps, maxSeenAutoIdTimestamp, maxSeqNoOfUpdatesOrDeletes)__            targetLocalCheckpoint.set(targetCheckpoint)__        }___        _        Translog.Operation operation__        while ((operation = snapshot.next()) != null) {_            if (shard.state() == IndexShardState.CLOSED) {_                throw new IndexShardClosedException(request.shardId())__            }_            cancellableThreads.checkForCancel()___            final long seqNo = operation.seqNo()__            if (seqNo < startingSeqNo || seqNo > endingSeqNo) {_                skippedOps++__                continue__            }_            operations.add(operation)__            ops++__            size += operation.estimateSize()__            totalSentOps++__            requiredOpsTracker.markSeqNoAsCompleted(seqNo)___            _            if (size >= chunkSizeInBytes) {_                cancellableThreads.executeIO(sendBatch)__                logger.trace("sent batch of [{}][{}] (total: [{}]) translog operations", ops, new ByteSizeValue(size), expectedTotalOps)__                ops = 0__                size = 0__                operations.clear()__            }_        }__        if (!operations.isEmpty() || totalSentOps == 0) {_            _            cancellableThreads.executeIO(sendBatch)__        }__        assert expectedTotalOps == snapshot.skippedOperations() + skippedOps + totalSentOps_            : String.format(Locale.ROOT, "expected total [%d], overridden [%d], skipped [%d], total sent [%d]",_            expectedTotalOps, snapshot.skippedOperations(), skippedOps, totalSentOps)___        if (requiredOpsTracker.getCheckpoint() < endingSeqNo) {_            throw new IllegalStateException("translog replay failed to cover required sequence numbers" +_                " (required range [" + requiredSeqNoRangeStart + ":" + endingSeqNo + "). first missing op is ["_                + (requiredOpsTracker.getCheckpoint() + 1) + "]")__        }__        logger.trace("sent final batch of [{}][{}] (total: [{}]) translog operations", ops, new ByteSizeValue(size), expectedTotalOps)___        return new SendSnapshotResult(targetLocalCheckpoint.get(), totalSentOps)__    };send,the,given,snapshot,s,operations,with,a,sequence,number,greater,than,the,specified,staring,sequence,number,to,this,handler,s,target,node,p,operations,are,bulked,into,a,single,request,depending,on,an,operation,count,limit,or,size,in,bytes,limit,param,starting,seq,no,the,sequence,number,for,which,only,operations,with,a,sequence,number,greater,than,this,will,be,sent,param,required,seq,no,range,start,the,lower,sequence,number,of,the,required,range,param,ending,seq,no,the,upper,bound,of,the,sequence,number,range,to,be,sent,inclusive,param,snapshot,the,translog,snapshot,to,replay,operations,from,return,the,local,checkpoint,on,the,target,and,the,total,number,of,operations,sent,param,max,seen,auto,id,timestamp,the,max,of,append,only,requests,on,the,primary,param,max,seq,no,of,updates,or,deletes,the,max,of,updates,or,deletes,on,the,primary,after,these,operations,were,executed,on,it,throws,ioexception,if,an,i,o,exception,occurred,reading,the,translog,snapshot;protected,send,snapshot,result,send,snapshot,final,long,starting,seq,no,long,required,seq,no,range,start,long,ending,seq,no,final,translog,snapshot,snapshot,final,long,max,seen,auto,id,timestamp,final,long,max,seq,no,of,updates,or,deletes,throws,ioexception,assert,required,seq,no,range,start,ending,seq,no,1,required,seq,no,range,start,required,seq,no,range,start,is,larger,than,ending,seq,no,ending,seq,no,assert,starting,seq,no,required,seq,no,range,start,starting,seq,no,starting,seq,no,is,larger,than,required,seq,no,range,start,required,seq,no,range,start,int,ops,0,long,size,0,int,skipped,ops,0,int,total,sent,ops,0,final,atomic,long,target,local,checkpoint,new,atomic,long,sequence,numbers,final,list,translog,operation,operations,new,array,list,final,local,checkpoint,tracker,required,ops,tracker,new,local,checkpoint,tracker,ending,seq,no,required,seq,no,range,start,1,final,int,expected,total,ops,snapshot,total,operations,if,expected,total,ops,0,logger,trace,no,translog,operations,to,send,final,cancellable,threads,iointerruptible,send,batch,final,long,target,checkpoint,recovery,target,index,translog,operations,operations,expected,total,ops,max,seen,auto,id,timestamp,max,seq,no,of,updates,or,deletes,target,local,checkpoint,set,target,checkpoint,translog,operation,operation,while,operation,snapshot,next,null,if,shard,state,index,shard,state,closed,throw,new,index,shard,closed,exception,request,shard,id,cancellable,threads,check,for,cancel,final,long,seq,no,operation,seq,no,if,seq,no,starting,seq,no,seq,no,ending,seq,no,skipped,ops,continue,operations,add,operation,ops,size,operation,estimate,size,total,sent,ops,required,ops,tracker,mark,seq,no,as,completed,seq,no,if,size,chunk,size,in,bytes,cancellable,threads,execute,io,send,batch,logger,trace,sent,batch,of,total,translog,operations,ops,new,byte,size,value,size,expected,total,ops,ops,0,size,0,operations,clear,if,operations,is,empty,total,sent,ops,0,cancellable,threads,execute,io,send,batch,assert,expected,total,ops,snapshot,skipped,operations,skipped,ops,total,sent,ops,string,format,locale,root,expected,total,d,overridden,d,skipped,d,total,sent,d,expected,total,ops,snapshot,skipped,operations,skipped,ops,total,sent,ops,if,required,ops,tracker,get,checkpoint,ending,seq,no,throw,new,illegal,state,exception,translog,replay,failed,to,cover,required,sequence,numbers,required,range,required,seq,no,range,start,ending,seq,no,first,missing,op,is,required,ops,tracker,get,checkpoint,1,logger,trace,sent,final,batch,of,total,translog,operations,ops,new,byte,size,value,size,expected,total,ops,return,new,send,snapshot,result,target,local,checkpoint,get,total,sent,ops
RecoverySourceHandler -> long phase2(final long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo, final Translog.Snapshot snapshot,                 final long maxSeenAutoIdTimestamp, final long maxSeqNoOfUpdatesOrDeletes)         throws IOException;1538067637;Perform phase two of the recovery process._<p>_Phase two uses a snapshot of the current translog *without* acquiring the write lock (however, the translog snapshot is_point-in-time view of the translog). It then sends each translog operation to the target node so it can be replayed into the new_shard.__@param startingSeqNo              the sequence number to start recovery from, or {@link SequenceNumbers#UNASSIGNED_SEQ_NO} if all_ops should be sent_@param requiredSeqNoRangeStart    the lower sequence number of the required range (ending with endingSeqNo)_@param endingSeqNo                the highest sequence number that should be sent_@param snapshot                   a snapshot of the translog_@param maxSeenAutoIdTimestamp     the max auto_id_timestamp of append-only requests on the primary_@param maxSeqNoOfUpdatesOrDeletes the max seq_no of updates or deletes on the primary after these operations were executed on it._@return the local checkpoint on the target;long phase2(final long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo, final Translog.Snapshot snapshot,_                final long maxSeenAutoIdTimestamp, final long maxSeqNoOfUpdatesOrDeletes)_        throws IOException {_        if (shard.state() == IndexShardState.CLOSED) {_            throw new IndexShardClosedException(request.shardId())__        }_        cancellableThreads.checkForCancel()___        final StopWatch stopWatch = new StopWatch().start()___        logger.trace("recovery [phase2]: sending transaction log operations (seq# from [" +  startingSeqNo  + "], " +_            "required [" + requiredSeqNoRangeStart + ":" + endingSeqNo + "]")___        _        final SendSnapshotResult result = sendSnapshot(_            startingSeqNo, requiredSeqNoRangeStart, endingSeqNo, snapshot, maxSeenAutoIdTimestamp, maxSeqNoOfUpdatesOrDeletes)___        stopWatch.stop()__        logger.trace("recovery [phase2]: took [{}]", stopWatch.totalTime())__        response.phase2Time = stopWatch.totalTime().millis()__        response.phase2Operations = result.totalOperations__        return result.targetLocalCheckpoint__    };perform,phase,two,of,the,recovery,process,p,phase,two,uses,a,snapshot,of,the,current,translog,without,acquiring,the,write,lock,however,the,translog,snapshot,is,point,in,time,view,of,the,translog,it,then,sends,each,translog,operation,to,the,target,node,so,it,can,be,replayed,into,the,new,shard,param,starting,seq,no,the,sequence,number,to,start,recovery,from,or,link,sequence,numbers,if,all,ops,should,be,sent,param,required,seq,no,range,start,the,lower,sequence,number,of,the,required,range,ending,with,ending,seq,no,param,ending,seq,no,the,highest,sequence,number,that,should,be,sent,param,snapshot,a,snapshot,of,the,translog,param,max,seen,auto,id,timestamp,the,max,of,append,only,requests,on,the,primary,param,max,seq,no,of,updates,or,deletes,the,max,of,updates,or,deletes,on,the,primary,after,these,operations,were,executed,on,it,return,the,local,checkpoint,on,the,target;long,phase2,final,long,starting,seq,no,long,required,seq,no,range,start,long,ending,seq,no,final,translog,snapshot,snapshot,final,long,max,seen,auto,id,timestamp,final,long,max,seq,no,of,updates,or,deletes,throws,ioexception,if,shard,state,index,shard,state,closed,throw,new,index,shard,closed,exception,request,shard,id,cancellable,threads,check,for,cancel,final,stop,watch,stop,watch,new,stop,watch,start,logger,trace,recovery,phase2,sending,transaction,log,operations,seq,from,starting,seq,no,required,required,seq,no,range,start,ending,seq,no,final,send,snapshot,result,result,send,snapshot,starting,seq,no,required,seq,no,range,start,ending,seq,no,snapshot,max,seen,auto,id,timestamp,max,seq,no,of,updates,or,deletes,stop,watch,stop,logger,trace,recovery,phase2,took,stop,watch,total,time,response,phase2time,stop,watch,total,time,millis,response,phase2operations,result,total,operations,return,result,target,local,checkpoint
RecoverySourceHandler -> long phase2(final long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo, final Translog.Snapshot snapshot,                 final long maxSeenAutoIdTimestamp, final long maxSeqNoOfUpdatesOrDeletes)         throws IOException;1546446953;Perform phase two of the recovery process._<p>_Phase two uses a snapshot of the current translog *without* acquiring the write lock (however, the translog snapshot is_point-in-time view of the translog). It then sends each translog operation to the target node so it can be replayed into the new_shard.__@param startingSeqNo              the sequence number to start recovery from, or {@link SequenceNumbers#UNASSIGNED_SEQ_NO} if all_ops should be sent_@param requiredSeqNoRangeStart    the lower sequence number of the required range (ending with endingSeqNo)_@param endingSeqNo                the highest sequence number that should be sent_@param snapshot                   a snapshot of the translog_@param maxSeenAutoIdTimestamp     the max auto_id_timestamp of append-only requests on the primary_@param maxSeqNoOfUpdatesOrDeletes the max seq_no of updates or deletes on the primary after these operations were executed on it._@return the local checkpoint on the target;long phase2(final long startingSeqNo, long requiredSeqNoRangeStart, long endingSeqNo, final Translog.Snapshot snapshot,_                final long maxSeenAutoIdTimestamp, final long maxSeqNoOfUpdatesOrDeletes)_        throws IOException {_        if (shard.state() == IndexShardState.CLOSED) {_            throw new IndexShardClosedException(request.shardId())__        }_        cancellableThreads.checkForCancel()___        final StopWatch stopWatch = new StopWatch().start()___        logger.trace("recovery [phase2]: sending transaction log operations (seq# from [" +  startingSeqNo  + "], " +_            "required [" + requiredSeqNoRangeStart + ":" + endingSeqNo + "]")___        _        final SendSnapshotResult result = sendSnapshot(_            startingSeqNo, requiredSeqNoRangeStart, endingSeqNo, snapshot, maxSeenAutoIdTimestamp, maxSeqNoOfUpdatesOrDeletes)___        stopWatch.stop()__        logger.trace("recovery [phase2]: took [{}]", stopWatch.totalTime())__        response.phase2Time = stopWatch.totalTime().millis()__        response.phase2Operations = result.totalOperations__        return result.targetLocalCheckpoint__    };perform,phase,two,of,the,recovery,process,p,phase,two,uses,a,snapshot,of,the,current,translog,without,acquiring,the,write,lock,however,the,translog,snapshot,is,point,in,time,view,of,the,translog,it,then,sends,each,translog,operation,to,the,target,node,so,it,can,be,replayed,into,the,new,shard,param,starting,seq,no,the,sequence,number,to,start,recovery,from,or,link,sequence,numbers,if,all,ops,should,be,sent,param,required,seq,no,range,start,the,lower,sequence,number,of,the,required,range,ending,with,ending,seq,no,param,ending,seq,no,the,highest,sequence,number,that,should,be,sent,param,snapshot,a,snapshot,of,the,translog,param,max,seen,auto,id,timestamp,the,max,of,append,only,requests,on,the,primary,param,max,seq,no,of,updates,or,deletes,the,max,of,updates,or,deletes,on,the,primary,after,these,operations,were,executed,on,it,return,the,local,checkpoint,on,the,target;long,phase2,final,long,starting,seq,no,long,required,seq,no,range,start,long,ending,seq,no,final,translog,snapshot,snapshot,final,long,max,seen,auto,id,timestamp,final,long,max,seq,no,of,updates,or,deletes,throws,ioexception,if,shard,state,index,shard,state,closed,throw,new,index,shard,closed,exception,request,shard,id,cancellable,threads,check,for,cancel,final,stop,watch,stop,watch,new,stop,watch,start,logger,trace,recovery,phase2,sending,transaction,log,operations,seq,from,starting,seq,no,required,required,seq,no,range,start,ending,seq,no,final,send,snapshot,result,result,send,snapshot,starting,seq,no,required,seq,no,range,start,ending,seq,no,snapshot,max,seen,auto,id,timestamp,max,seq,no,of,updates,or,deletes,stop,watch,stop,logger,trace,recovery,phase2,took,stop,watch,total,time,response,phase2time,stop,watch,total,time,millis,response,phase2operations,result,total,operations,return,result,target,local,checkpoint
RecoverySourceHandler -> public void recoverToTarget(ActionListener<RecoveryResponse> listener);1547315388;performs the recovery from the local engine to the target;public void recoverToTarget(ActionListener<RecoveryResponse> listener) {_        final List<Closeable> resources = new CopyOnWriteArrayList<>()__        final Closeable releaseResources = () -> IOUtils.close(resources)__        final ActionListener<RecoveryResponse> wrappedListener = ActionListener.notifyOnce(listener)__        try {_            cancellableThreads.setOnCancel((reason, beforeCancelEx) -> {_                final RuntimeException e__                if (shard.state() == IndexShardState.CLOSED) { _                    e = new IndexShardClosedException(shard.shardId(), "shard is closed and recovery was canceled reason [" + reason + "]")__                } else {_                    e = new CancellableThreads.ExecutionCancelledException("recovery was canceled reason [" + reason + "]")__                }_                if (beforeCancelEx != null) {_                    e.addSuppressed(beforeCancelEx)__                }_                IOUtils.closeWhileHandlingException(releaseResources, () -> wrappedListener.onFailure(e))__                throw e__            })__            runUnderPrimaryPermit(() -> {_                final IndexShardRoutingTable routingTable = shard.getReplicationGroup().getRoutingTable()__                ShardRouting targetShardRouting = routingTable.getByAllocationId(request.targetAllocationId())__                if (targetShardRouting == null) {_                    logger.debug("delaying recovery of {} as it is not listed as assigned to target node {}", request.shardId(),_                        request.targetNode())__                    throw new DelayRecoveryException("source node does not have the shard listed in its state as allocated on the node")__                }_                assert targetShardRouting.initializing() : "expected recovery target to be initializing but was " + targetShardRouting__            }, shardId + " validating recovery target ["+ request.targetAllocationId() + "] registered ",_                shard, cancellableThreads, logger)__            final Closeable retentionLock = shard.acquireRetentionLockForPeerRecovery()__            resources.add(retentionLock)__            final long startingSeqNo__            final long requiredSeqNoRangeStart__            final boolean isSequenceNumberBasedRecovery = request.startingSeqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                isTargetSameHistory() && shard.hasCompleteHistoryOperations("peer-recovery", request.startingSeqNo())__            final SendFileResult sendFileResult__            if (isSequenceNumberBasedRecovery) {_                logger.trace("performing sequence numbers based recovery. starting at [{}]", request.startingSeqNo())__                startingSeqNo = request.startingSeqNo()__                requiredSeqNoRangeStart = startingSeqNo__                sendFileResult = SendFileResult.EMPTY__            } else {_                final Engine.IndexCommitRef phase1Snapshot__                try {_                    phase1Snapshot = shard.acquireSafeIndexCommit()__                } catch (final Exception e) {_                    throw new RecoveryEngineException(shard.shardId(), 1, "snapshot failed", e)__                }_                _                requiredSeqNoRangeStart =_                    Long.parseLong(phase1Snapshot.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) + 1__                _                _                _                startingSeqNo = shard.indexSettings().isSoftDeleteEnabled() ? requiredSeqNoRangeStart : 0__                try {_                    final int estimateNumOps = shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo)__                    sendFileResult = phase1(phase1Snapshot.getIndexCommit(), () -> estimateNumOps)__                } catch (final Exception e) {_                    throw new RecoveryEngineException(shard.shardId(), 1, "phase1 failed", e)__                } finally {_                    try {_                        IOUtils.close(phase1Snapshot)__                    } catch (final IOException ex) {_                        logger.warn("releasing snapshot caused exception", ex)__                    }_                }_            }_            assert startingSeqNo >= 0 : "startingSeqNo must be non negative. got: " + startingSeqNo__            assert requiredSeqNoRangeStart >= startingSeqNo : "requiredSeqNoRangeStart [" + requiredSeqNoRangeStart + "] is lower than ["_                + startingSeqNo + "]"___            final TimeValue prepareEngineTime__            try {_                _                prepareEngineTime = prepareTargetForTranslog(isSequenceNumberBasedRecovery == false,_                    shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo))__            } catch (final Exception e) {_                throw new RecoveryEngineException(shard.shardId(), 1, "prepare target for translog failed", e)__            }__            _            runUnderPrimaryPermit(() -> shard.initiateTracking(request.targetAllocationId()),_                shardId + " initiating tracking of " + request.targetAllocationId(), shard, cancellableThreads, logger)___            final long endingSeqNo = shard.seqNoStats().getMaxSeqNo()__            _            cancellableThreads.execute(() -> shard.waitForOpsToComplete(endingSeqNo))___            if (logger.isTraceEnabled()) {_                logger.trace("all operations up to [{}] completed, which will be used as an ending sequence number", endingSeqNo)__                logger.trace("snapshot translog for recovery_ current size is [{}]",_                    shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo))__            }_            final SendSnapshotResult sendSnapshotResult__            try (Translog.Snapshot snapshot = shard.getHistoryOperations("peer-recovery", startingSeqNo)) {_                _                IOUtils.close(retentionLock, () -> resources.remove(retentionLock))__                _                _                final long maxSeenAutoIdTimestamp = shard.getMaxSeenAutoIdTimestamp()__                final long maxSeqNoOfUpdatesOrDeletes = shard.getMaxSeqNoOfUpdatesOrDeletes()__                sendSnapshotResult = phase2(startingSeqNo, requiredSeqNoRangeStart, endingSeqNo, snapshot,_                    maxSeenAutoIdTimestamp, maxSeqNoOfUpdatesOrDeletes)__            } catch (Exception e) {_                throw new RecoveryEngineException(shard.shardId(), 2, "phase2 failed", e)__            }__            finalizeRecovery(sendSnapshotResult.targetLocalCheckpoint)__            final long phase1ThrottlingWaitTime = 0L_ _            assert resources.isEmpty() : "not every resource is released [" + resources + "]"__            IOUtils.close(resources)__            wrappedListener.onResponse(_                new RecoveryResponse(sendFileResult.phase1FileNames, sendFileResult.phase1FileSizes,_                    sendFileResult.phase1ExistingFileNames, sendFileResult.phase1ExistingFileSizes, sendFileResult.totalSize,_                    sendFileResult.existingTotalSize, sendFileResult.took.millis(), phase1ThrottlingWaitTime, prepareEngineTime.millis(),_                    sendSnapshotResult.totalOperations, sendSnapshotResult.tookTime.millis())_            )__        } catch (Exception e) {_            IOUtils.closeWhileHandlingException(releaseResources, () -> wrappedListener.onFailure(e))__        }_    };performs,the,recovery,from,the,local,engine,to,the,target;public,void,recover,to,target,action,listener,recovery,response,listener,final,list,closeable,resources,new,copy,on,write,array,list,final,closeable,release,resources,ioutils,close,resources,final,action,listener,recovery,response,wrapped,listener,action,listener,notify,once,listener,try,cancellable,threads,set,on,cancel,reason,before,cancel,ex,final,runtime,exception,e,if,shard,state,index,shard,state,closed,e,new,index,shard,closed,exception,shard,shard,id,shard,is,closed,and,recovery,was,canceled,reason,reason,else,e,new,cancellable,threads,execution,cancelled,exception,recovery,was,canceled,reason,reason,if,before,cancel,ex,null,e,add,suppressed,before,cancel,ex,ioutils,close,while,handling,exception,release,resources,wrapped,listener,on,failure,e,throw,e,run,under,primary,permit,final,index,shard,routing,table,routing,table,shard,get,replication,group,get,routing,table,shard,routing,target,shard,routing,routing,table,get,by,allocation,id,request,target,allocation,id,if,target,shard,routing,null,logger,debug,delaying,recovery,of,as,it,is,not,listed,as,assigned,to,target,node,request,shard,id,request,target,node,throw,new,delay,recovery,exception,source,node,does,not,have,the,shard,listed,in,its,state,as,allocated,on,the,node,assert,target,shard,routing,initializing,expected,recovery,target,to,be,initializing,but,was,target,shard,routing,shard,id,validating,recovery,target,request,target,allocation,id,registered,shard,cancellable,threads,logger,final,closeable,retention,lock,shard,acquire,retention,lock,for,peer,recovery,resources,add,retention,lock,final,long,starting,seq,no,final,long,required,seq,no,range,start,final,boolean,is,sequence,number,based,recovery,request,starting,seq,no,sequence,numbers,is,target,same,history,shard,has,complete,history,operations,peer,recovery,request,starting,seq,no,final,send,file,result,send,file,result,if,is,sequence,number,based,recovery,logger,trace,performing,sequence,numbers,based,recovery,starting,at,request,starting,seq,no,starting,seq,no,request,starting,seq,no,required,seq,no,range,start,starting,seq,no,send,file,result,send,file,result,empty,else,final,engine,index,commit,ref,phase1snapshot,try,phase1snapshot,shard,acquire,safe,index,commit,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,snapshot,failed,e,required,seq,no,range,start,long,parse,long,phase1snapshot,get,index,commit,get,user,data,get,sequence,numbers,1,starting,seq,no,shard,index,settings,is,soft,delete,enabled,required,seq,no,range,start,0,try,final,int,estimate,num,ops,shard,estimate,number,of,history,operations,peer,recovery,starting,seq,no,send,file,result,phase1,phase1snapshot,get,index,commit,estimate,num,ops,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,phase1,failed,e,finally,try,ioutils,close,phase1snapshot,catch,final,ioexception,ex,logger,warn,releasing,snapshot,caused,exception,ex,assert,starting,seq,no,0,starting,seq,no,must,be,non,negative,got,starting,seq,no,assert,required,seq,no,range,start,starting,seq,no,required,seq,no,range,start,required,seq,no,range,start,is,lower,than,starting,seq,no,final,time,value,prepare,engine,time,try,prepare,engine,time,prepare,target,for,translog,is,sequence,number,based,recovery,false,shard,estimate,number,of,history,operations,peer,recovery,starting,seq,no,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,prepare,target,for,translog,failed,e,run,under,primary,permit,shard,initiate,tracking,request,target,allocation,id,shard,id,initiating,tracking,of,request,target,allocation,id,shard,cancellable,threads,logger,final,long,ending,seq,no,shard,seq,no,stats,get,max,seq,no,cancellable,threads,execute,shard,wait,for,ops,to,complete,ending,seq,no,if,logger,is,trace,enabled,logger,trace,all,operations,up,to,completed,which,will,be,used,as,an,ending,sequence,number,ending,seq,no,logger,trace,snapshot,translog,for,recovery,current,size,is,shard,estimate,number,of,history,operations,peer,recovery,starting,seq,no,final,send,snapshot,result,send,snapshot,result,try,translog,snapshot,snapshot,shard,get,history,operations,peer,recovery,starting,seq,no,ioutils,close,retention,lock,resources,remove,retention,lock,final,long,max,seen,auto,id,timestamp,shard,get,max,seen,auto,id,timestamp,final,long,max,seq,no,of,updates,or,deletes,shard,get,max,seq,no,of,updates,or,deletes,send,snapshot,result,phase2,starting,seq,no,required,seq,no,range,start,ending,seq,no,snapshot,max,seen,auto,id,timestamp,max,seq,no,of,updates,or,deletes,catch,exception,e,throw,new,recovery,engine,exception,shard,shard,id,2,phase2,failed,e,finalize,recovery,send,snapshot,result,target,local,checkpoint,final,long,phase1throttling,wait,time,0l,assert,resources,is,empty,not,every,resource,is,released,resources,ioutils,close,resources,wrapped,listener,on,response,new,recovery,response,send,file,result,phase1file,names,send,file,result,phase1file,sizes,send,file,result,phase1existing,file,names,send,file,result,phase1existing,file,sizes,send,file,result,total,size,send,file,result,existing,total,size,send,file,result,took,millis,phase1throttling,wait,time,prepare,engine,time,millis,send,snapshot,result,total,operations,send,snapshot,result,took,time,millis,catch,exception,e,ioutils,close,while,handling,exception,release,resources,wrapped,listener,on,failure,e
RecoverySourceHandler -> public void recoverToTarget(ActionListener<RecoveryResponse> listener);1547496886;performs the recovery from the local engine to the target;public void recoverToTarget(ActionListener<RecoveryResponse> listener) {_        final List<Closeable> resources = new CopyOnWriteArrayList<>()__        final Closeable releaseResources = () -> IOUtils.close(resources)__        final ActionListener<RecoveryResponse> wrappedListener = ActionListener.notifyOnce(listener)__        try {_            cancellableThreads.setOnCancel((reason, beforeCancelEx) -> {_                final RuntimeException e__                if (shard.state() == IndexShardState.CLOSED) { _                    e = new IndexShardClosedException(shard.shardId(), "shard is closed and recovery was canceled reason [" + reason + "]")__                } else {_                    e = new CancellableThreads.ExecutionCancelledException("recovery was canceled reason [" + reason + "]")__                }_                if (beforeCancelEx != null) {_                    e.addSuppressed(beforeCancelEx)__                }_                IOUtils.closeWhileHandlingException(releaseResources, () -> wrappedListener.onFailure(e))__                throw e__            })__            runUnderPrimaryPermit(() -> {_                final IndexShardRoutingTable routingTable = shard.getReplicationGroup().getRoutingTable()__                ShardRouting targetShardRouting = routingTable.getByAllocationId(request.targetAllocationId())__                if (targetShardRouting == null) {_                    logger.debug("delaying recovery of {} as it is not listed as assigned to target node {}", request.shardId(),_                        request.targetNode())__                    throw new DelayRecoveryException("source node does not have the shard listed in its state as allocated on the node")__                }_                assert targetShardRouting.initializing() : "expected recovery target to be initializing but was " + targetShardRouting__            }, shardId + " validating recovery target ["+ request.targetAllocationId() + "] registered ",_                shard, cancellableThreads, logger)__            final Closeable retentionLock = shard.acquireRetentionLockForPeerRecovery()__            resources.add(retentionLock)__            final long startingSeqNo__            final long requiredSeqNoRangeStart__            final boolean isSequenceNumberBasedRecovery = request.startingSeqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                isTargetSameHistory() && shard.hasCompleteHistoryOperations("peer-recovery", request.startingSeqNo())__            final SendFileResult sendFileResult__            if (isSequenceNumberBasedRecovery) {_                logger.trace("performing sequence numbers based recovery. starting at [{}]", request.startingSeqNo())__                startingSeqNo = request.startingSeqNo()__                requiredSeqNoRangeStart = startingSeqNo__                sendFileResult = SendFileResult.EMPTY__            } else {_                final Engine.IndexCommitRef phase1Snapshot__                try {_                    phase1Snapshot = shard.acquireSafeIndexCommit()__                } catch (final Exception e) {_                    throw new RecoveryEngineException(shard.shardId(), 1, "snapshot failed", e)__                }_                _                requiredSeqNoRangeStart =_                    Long.parseLong(phase1Snapshot.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) + 1__                _                _                _                startingSeqNo = shard.indexSettings().isSoftDeleteEnabled() ? requiredSeqNoRangeStart : 0__                try {_                    final int estimateNumOps = shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo)__                    sendFileResult = phase1(phase1Snapshot.getIndexCommit(), () -> estimateNumOps)__                } catch (final Exception e) {_                    throw new RecoveryEngineException(shard.shardId(), 1, "phase1 failed", e)__                } finally {_                    try {_                        IOUtils.close(phase1Snapshot)__                    } catch (final IOException ex) {_                        logger.warn("releasing snapshot caused exception", ex)__                    }_                }_            }_            assert startingSeqNo >= 0 : "startingSeqNo must be non negative. got: " + startingSeqNo__            assert requiredSeqNoRangeStart >= startingSeqNo : "requiredSeqNoRangeStart [" + requiredSeqNoRangeStart + "] is lower than ["_                + startingSeqNo + "]"___            final TimeValue prepareEngineTime__            try {_                _                prepareEngineTime = prepareTargetForTranslog(isSequenceNumberBasedRecovery == false,_                    shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo))__            } catch (final Exception e) {_                throw new RecoveryEngineException(shard.shardId(), 1, "prepare target for translog failed", e)__            }__            _            runUnderPrimaryPermit(() -> shard.initiateTracking(request.targetAllocationId()),_                shardId + " initiating tracking of " + request.targetAllocationId(), shard, cancellableThreads, logger)___            final long endingSeqNo = shard.seqNoStats().getMaxSeqNo()__            _            cancellableThreads.execute(() -> shard.waitForOpsToComplete(endingSeqNo))___            if (logger.isTraceEnabled()) {_                logger.trace("all operations up to [{}] completed, which will be used as an ending sequence number", endingSeqNo)__                logger.trace("snapshot translog for recovery_ current size is [{}]",_                    shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo))__            }_            final SendSnapshotResult sendSnapshotResult__            try (Translog.Snapshot snapshot = shard.getHistoryOperations("peer-recovery", startingSeqNo)) {_                _                IOUtils.close(retentionLock, () -> resources.remove(retentionLock))__                _                _                final long maxSeenAutoIdTimestamp = shard.getMaxSeenAutoIdTimestamp()__                final long maxSeqNoOfUpdatesOrDeletes = shard.getMaxSeqNoOfUpdatesOrDeletes()__                sendSnapshotResult = phase2(startingSeqNo, requiredSeqNoRangeStart, endingSeqNo, snapshot,_                    maxSeenAutoIdTimestamp, maxSeqNoOfUpdatesOrDeletes)__            } catch (Exception e) {_                throw new RecoveryEngineException(shard.shardId(), 2, "phase2 failed", e)__            }__            finalizeRecovery(sendSnapshotResult.targetLocalCheckpoint)__            final long phase1ThrottlingWaitTime = 0L_ _            assert resources.isEmpty() : "not every resource is released [" + resources + "]"__            IOUtils.close(resources)__            wrappedListener.onResponse(_                new RecoveryResponse(sendFileResult.phase1FileNames, sendFileResult.phase1FileSizes,_                    sendFileResult.phase1ExistingFileNames, sendFileResult.phase1ExistingFileSizes, sendFileResult.totalSize,_                    sendFileResult.existingTotalSize, sendFileResult.took.millis(), phase1ThrottlingWaitTime, prepareEngineTime.millis(),_                    sendSnapshotResult.totalOperations, sendSnapshotResult.tookTime.millis())_            )__        } catch (Exception e) {_            IOUtils.closeWhileHandlingException(releaseResources, () -> wrappedListener.onFailure(e))__        }_    };performs,the,recovery,from,the,local,engine,to,the,target;public,void,recover,to,target,action,listener,recovery,response,listener,final,list,closeable,resources,new,copy,on,write,array,list,final,closeable,release,resources,ioutils,close,resources,final,action,listener,recovery,response,wrapped,listener,action,listener,notify,once,listener,try,cancellable,threads,set,on,cancel,reason,before,cancel,ex,final,runtime,exception,e,if,shard,state,index,shard,state,closed,e,new,index,shard,closed,exception,shard,shard,id,shard,is,closed,and,recovery,was,canceled,reason,reason,else,e,new,cancellable,threads,execution,cancelled,exception,recovery,was,canceled,reason,reason,if,before,cancel,ex,null,e,add,suppressed,before,cancel,ex,ioutils,close,while,handling,exception,release,resources,wrapped,listener,on,failure,e,throw,e,run,under,primary,permit,final,index,shard,routing,table,routing,table,shard,get,replication,group,get,routing,table,shard,routing,target,shard,routing,routing,table,get,by,allocation,id,request,target,allocation,id,if,target,shard,routing,null,logger,debug,delaying,recovery,of,as,it,is,not,listed,as,assigned,to,target,node,request,shard,id,request,target,node,throw,new,delay,recovery,exception,source,node,does,not,have,the,shard,listed,in,its,state,as,allocated,on,the,node,assert,target,shard,routing,initializing,expected,recovery,target,to,be,initializing,but,was,target,shard,routing,shard,id,validating,recovery,target,request,target,allocation,id,registered,shard,cancellable,threads,logger,final,closeable,retention,lock,shard,acquire,retention,lock,for,peer,recovery,resources,add,retention,lock,final,long,starting,seq,no,final,long,required,seq,no,range,start,final,boolean,is,sequence,number,based,recovery,request,starting,seq,no,sequence,numbers,is,target,same,history,shard,has,complete,history,operations,peer,recovery,request,starting,seq,no,final,send,file,result,send,file,result,if,is,sequence,number,based,recovery,logger,trace,performing,sequence,numbers,based,recovery,starting,at,request,starting,seq,no,starting,seq,no,request,starting,seq,no,required,seq,no,range,start,starting,seq,no,send,file,result,send,file,result,empty,else,final,engine,index,commit,ref,phase1snapshot,try,phase1snapshot,shard,acquire,safe,index,commit,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,snapshot,failed,e,required,seq,no,range,start,long,parse,long,phase1snapshot,get,index,commit,get,user,data,get,sequence,numbers,1,starting,seq,no,shard,index,settings,is,soft,delete,enabled,required,seq,no,range,start,0,try,final,int,estimate,num,ops,shard,estimate,number,of,history,operations,peer,recovery,starting,seq,no,send,file,result,phase1,phase1snapshot,get,index,commit,estimate,num,ops,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,phase1,failed,e,finally,try,ioutils,close,phase1snapshot,catch,final,ioexception,ex,logger,warn,releasing,snapshot,caused,exception,ex,assert,starting,seq,no,0,starting,seq,no,must,be,non,negative,got,starting,seq,no,assert,required,seq,no,range,start,starting,seq,no,required,seq,no,range,start,required,seq,no,range,start,is,lower,than,starting,seq,no,final,time,value,prepare,engine,time,try,prepare,engine,time,prepare,target,for,translog,is,sequence,number,based,recovery,false,shard,estimate,number,of,history,operations,peer,recovery,starting,seq,no,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,prepare,target,for,translog,failed,e,run,under,primary,permit,shard,initiate,tracking,request,target,allocation,id,shard,id,initiating,tracking,of,request,target,allocation,id,shard,cancellable,threads,logger,final,long,ending,seq,no,shard,seq,no,stats,get,max,seq,no,cancellable,threads,execute,shard,wait,for,ops,to,complete,ending,seq,no,if,logger,is,trace,enabled,logger,trace,all,operations,up,to,completed,which,will,be,used,as,an,ending,sequence,number,ending,seq,no,logger,trace,snapshot,translog,for,recovery,current,size,is,shard,estimate,number,of,history,operations,peer,recovery,starting,seq,no,final,send,snapshot,result,send,snapshot,result,try,translog,snapshot,snapshot,shard,get,history,operations,peer,recovery,starting,seq,no,ioutils,close,retention,lock,resources,remove,retention,lock,final,long,max,seen,auto,id,timestamp,shard,get,max,seen,auto,id,timestamp,final,long,max,seq,no,of,updates,or,deletes,shard,get,max,seq,no,of,updates,or,deletes,send,snapshot,result,phase2,starting,seq,no,required,seq,no,range,start,ending,seq,no,snapshot,max,seen,auto,id,timestamp,max,seq,no,of,updates,or,deletes,catch,exception,e,throw,new,recovery,engine,exception,shard,shard,id,2,phase2,failed,e,finalize,recovery,send,snapshot,result,target,local,checkpoint,final,long,phase1throttling,wait,time,0l,assert,resources,is,empty,not,every,resource,is,released,resources,ioutils,close,resources,wrapped,listener,on,response,new,recovery,response,send,file,result,phase1file,names,send,file,result,phase1file,sizes,send,file,result,phase1existing,file,names,send,file,result,phase1existing,file,sizes,send,file,result,total,size,send,file,result,existing,total,size,send,file,result,took,millis,phase1throttling,wait,time,prepare,engine,time,millis,send,snapshot,result,total,operations,send,snapshot,result,took,time,millis,catch,exception,e,ioutils,close,while,handling,exception,release,resources,wrapped,listener,on,failure,e
RecoverySourceHandler -> public void recoverToTarget(ActionListener<RecoveryResponse> listener);1547508054;performs the recovery from the local engine to the target;public void recoverToTarget(ActionListener<RecoveryResponse> listener) {_        final List<Closeable> resources = new CopyOnWriteArrayList<>()__        final Closeable releaseResources = () -> IOUtils.close(resources)__        final ActionListener<RecoveryResponse> wrappedListener = ActionListener.notifyOnce(listener)__        try {_            cancellableThreads.setOnCancel((reason, beforeCancelEx) -> {_                final RuntimeException e__                if (shard.state() == IndexShardState.CLOSED) { _                    e = new IndexShardClosedException(shard.shardId(), "shard is closed and recovery was canceled reason [" + reason + "]")__                } else {_                    e = new CancellableThreads.ExecutionCancelledException("recovery was canceled reason [" + reason + "]")__                }_                if (beforeCancelEx != null) {_                    e.addSuppressed(beforeCancelEx)__                }_                IOUtils.closeWhileHandlingException(releaseResources, () -> wrappedListener.onFailure(e))__                throw e__            })__            final Consumer<Exception> onFailure = e ->_                IOUtils.closeWhileHandlingException(releaseResources, () -> wrappedListener.onFailure(e))___            runUnderPrimaryPermit(() -> {_                final IndexShardRoutingTable routingTable = shard.getReplicationGroup().getRoutingTable()__                ShardRouting targetShardRouting = routingTable.getByAllocationId(request.targetAllocationId())__                if (targetShardRouting == null) {_                    logger.debug("delaying recovery of {} as it is not listed as assigned to target node {}", request.shardId(),_                        request.targetNode())__                    throw new DelayRecoveryException("source node does not have the shard listed in its state as allocated on the node")__                }_                assert targetShardRouting.initializing() : "expected recovery target to be initializing but was " + targetShardRouting__            }, shardId + " validating recovery target ["+ request.targetAllocationId() + "] registered ",_                shard, cancellableThreads, logger)__            final Closeable retentionLock = shard.acquireRetentionLockForPeerRecovery()__            resources.add(retentionLock)__            final long startingSeqNo__            final long requiredSeqNoRangeStart__            final boolean isSequenceNumberBasedRecovery = request.startingSeqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                isTargetSameHistory() && shard.hasCompleteHistoryOperations("peer-recovery", request.startingSeqNo())__            final SendFileResult sendFileResult__            if (isSequenceNumberBasedRecovery) {_                logger.trace("performing sequence numbers based recovery. starting at [{}]", request.startingSeqNo())__                startingSeqNo = request.startingSeqNo()__                requiredSeqNoRangeStart = startingSeqNo__                sendFileResult = SendFileResult.EMPTY__            } else {_                final Engine.IndexCommitRef phase1Snapshot__                try {_                    phase1Snapshot = shard.acquireSafeIndexCommit()__                } catch (final Exception e) {_                    throw new RecoveryEngineException(shard.shardId(), 1, "snapshot failed", e)__                }_                _                requiredSeqNoRangeStart =_                    Long.parseLong(phase1Snapshot.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) + 1__                _                _                _                startingSeqNo = shard.indexSettings().isSoftDeleteEnabled() ? requiredSeqNoRangeStart : 0__                try {_                    final int estimateNumOps = shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo)__                    sendFileResult = phase1(phase1Snapshot.getIndexCommit(), () -> estimateNumOps)__                } catch (final Exception e) {_                    throw new RecoveryEngineException(shard.shardId(), 1, "phase1 failed", e)__                } finally {_                    try {_                        IOUtils.close(phase1Snapshot)__                    } catch (final IOException ex) {_                        logger.warn("releasing snapshot caused exception", ex)__                    }_                }_            }_            assert startingSeqNo >= 0 : "startingSeqNo must be non negative. got: " + startingSeqNo__            assert requiredSeqNoRangeStart >= startingSeqNo : "requiredSeqNoRangeStart [" + requiredSeqNoRangeStart + "] is lower than ["_                + startingSeqNo + "]"___            final TimeValue prepareEngineTime__            try {_                _                prepareEngineTime = prepareTargetForTranslog(isSequenceNumberBasedRecovery == false,_                    shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo))__            } catch (final Exception e) {_                throw new RecoveryEngineException(shard.shardId(), 1, "prepare target for translog failed", e)__            }__            _            runUnderPrimaryPermit(() -> shard.initiateTracking(request.targetAllocationId()),_                shardId + " initiating tracking of " + request.targetAllocationId(), shard, cancellableThreads, logger)___            final long endingSeqNo = shard.seqNoStats().getMaxSeqNo()__            _            cancellableThreads.execute(() -> shard.waitForOpsToComplete(endingSeqNo))___            if (logger.isTraceEnabled()) {_                logger.trace("all operations up to [{}] completed, which will be used as an ending sequence number", endingSeqNo)__                logger.trace("snapshot translog for recovery_ current size is [{}]",_                    shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo))__            }_            final SendSnapshotResult sendSnapshotResult__            try (Translog.Snapshot snapshot = shard.getHistoryOperations("peer-recovery", startingSeqNo)) {_                _                IOUtils.close(retentionLock, () -> resources.remove(retentionLock))__                _                _                final long maxSeenAutoIdTimestamp = shard.getMaxSeenAutoIdTimestamp()__                final long maxSeqNoOfUpdatesOrDeletes = shard.getMaxSeqNoOfUpdatesOrDeletes()__                sendSnapshotResult = phase2(startingSeqNo, requiredSeqNoRangeStart, endingSeqNo, snapshot,_                    maxSeenAutoIdTimestamp, maxSeqNoOfUpdatesOrDeletes)__            } catch (Exception e) {_                throw new RecoveryEngineException(shard.shardId(), 2, "phase2 failed", e)__            }__            final StepListener<Void> finalizeStep = new StepListener<>()__            finalizeRecovery(sendSnapshotResult.targetLocalCheckpoint, finalizeStep)__            finalizeStep.whenComplete(r -> {_                assert resources.isEmpty() : "not every resource is released [" + resources + "]"__                final long phase1ThrottlingWaitTime = 0L_ _                final RecoveryResponse response = new RecoveryResponse(sendFileResult.phase1FileNames, sendFileResult.phase1FileSizes,_                    sendFileResult.phase1ExistingFileNames, sendFileResult.phase1ExistingFileSizes, sendFileResult.totalSize,_                    sendFileResult.existingTotalSize, sendFileResult.took.millis(), phase1ThrottlingWaitTime,_                    prepareEngineTime.millis(), sendSnapshotResult.totalOperations, sendSnapshotResult.tookTime.millis())__                try {_                    wrappedListener.onResponse(response)__                } finally {_                    IOUtils.close(resources)__                }_            }, onFailure)__        } catch (Exception e) {_            IOUtils.closeWhileHandlingException(releaseResources, () -> wrappedListener.onFailure(e))__        }_    };performs,the,recovery,from,the,local,engine,to,the,target;public,void,recover,to,target,action,listener,recovery,response,listener,final,list,closeable,resources,new,copy,on,write,array,list,final,closeable,release,resources,ioutils,close,resources,final,action,listener,recovery,response,wrapped,listener,action,listener,notify,once,listener,try,cancellable,threads,set,on,cancel,reason,before,cancel,ex,final,runtime,exception,e,if,shard,state,index,shard,state,closed,e,new,index,shard,closed,exception,shard,shard,id,shard,is,closed,and,recovery,was,canceled,reason,reason,else,e,new,cancellable,threads,execution,cancelled,exception,recovery,was,canceled,reason,reason,if,before,cancel,ex,null,e,add,suppressed,before,cancel,ex,ioutils,close,while,handling,exception,release,resources,wrapped,listener,on,failure,e,throw,e,final,consumer,exception,on,failure,e,ioutils,close,while,handling,exception,release,resources,wrapped,listener,on,failure,e,run,under,primary,permit,final,index,shard,routing,table,routing,table,shard,get,replication,group,get,routing,table,shard,routing,target,shard,routing,routing,table,get,by,allocation,id,request,target,allocation,id,if,target,shard,routing,null,logger,debug,delaying,recovery,of,as,it,is,not,listed,as,assigned,to,target,node,request,shard,id,request,target,node,throw,new,delay,recovery,exception,source,node,does,not,have,the,shard,listed,in,its,state,as,allocated,on,the,node,assert,target,shard,routing,initializing,expected,recovery,target,to,be,initializing,but,was,target,shard,routing,shard,id,validating,recovery,target,request,target,allocation,id,registered,shard,cancellable,threads,logger,final,closeable,retention,lock,shard,acquire,retention,lock,for,peer,recovery,resources,add,retention,lock,final,long,starting,seq,no,final,long,required,seq,no,range,start,final,boolean,is,sequence,number,based,recovery,request,starting,seq,no,sequence,numbers,is,target,same,history,shard,has,complete,history,operations,peer,recovery,request,starting,seq,no,final,send,file,result,send,file,result,if,is,sequence,number,based,recovery,logger,trace,performing,sequence,numbers,based,recovery,starting,at,request,starting,seq,no,starting,seq,no,request,starting,seq,no,required,seq,no,range,start,starting,seq,no,send,file,result,send,file,result,empty,else,final,engine,index,commit,ref,phase1snapshot,try,phase1snapshot,shard,acquire,safe,index,commit,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,snapshot,failed,e,required,seq,no,range,start,long,parse,long,phase1snapshot,get,index,commit,get,user,data,get,sequence,numbers,1,starting,seq,no,shard,index,settings,is,soft,delete,enabled,required,seq,no,range,start,0,try,final,int,estimate,num,ops,shard,estimate,number,of,history,operations,peer,recovery,starting,seq,no,send,file,result,phase1,phase1snapshot,get,index,commit,estimate,num,ops,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,phase1,failed,e,finally,try,ioutils,close,phase1snapshot,catch,final,ioexception,ex,logger,warn,releasing,snapshot,caused,exception,ex,assert,starting,seq,no,0,starting,seq,no,must,be,non,negative,got,starting,seq,no,assert,required,seq,no,range,start,starting,seq,no,required,seq,no,range,start,required,seq,no,range,start,is,lower,than,starting,seq,no,final,time,value,prepare,engine,time,try,prepare,engine,time,prepare,target,for,translog,is,sequence,number,based,recovery,false,shard,estimate,number,of,history,operations,peer,recovery,starting,seq,no,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,prepare,target,for,translog,failed,e,run,under,primary,permit,shard,initiate,tracking,request,target,allocation,id,shard,id,initiating,tracking,of,request,target,allocation,id,shard,cancellable,threads,logger,final,long,ending,seq,no,shard,seq,no,stats,get,max,seq,no,cancellable,threads,execute,shard,wait,for,ops,to,complete,ending,seq,no,if,logger,is,trace,enabled,logger,trace,all,operations,up,to,completed,which,will,be,used,as,an,ending,sequence,number,ending,seq,no,logger,trace,snapshot,translog,for,recovery,current,size,is,shard,estimate,number,of,history,operations,peer,recovery,starting,seq,no,final,send,snapshot,result,send,snapshot,result,try,translog,snapshot,snapshot,shard,get,history,operations,peer,recovery,starting,seq,no,ioutils,close,retention,lock,resources,remove,retention,lock,final,long,max,seen,auto,id,timestamp,shard,get,max,seen,auto,id,timestamp,final,long,max,seq,no,of,updates,or,deletes,shard,get,max,seq,no,of,updates,or,deletes,send,snapshot,result,phase2,starting,seq,no,required,seq,no,range,start,ending,seq,no,snapshot,max,seen,auto,id,timestamp,max,seq,no,of,updates,or,deletes,catch,exception,e,throw,new,recovery,engine,exception,shard,shard,id,2,phase2,failed,e,final,step,listener,void,finalize,step,new,step,listener,finalize,recovery,send,snapshot,result,target,local,checkpoint,finalize,step,finalize,step,when,complete,r,assert,resources,is,empty,not,every,resource,is,released,resources,final,long,phase1throttling,wait,time,0l,final,recovery,response,response,new,recovery,response,send,file,result,phase1file,names,send,file,result,phase1file,sizes,send,file,result,phase1existing,file,names,send,file,result,phase1existing,file,sizes,send,file,result,total,size,send,file,result,existing,total,size,send,file,result,took,millis,phase1throttling,wait,time,prepare,engine,time,millis,send,snapshot,result,total,operations,send,snapshot,result,took,time,millis,try,wrapped,listener,on,response,response,finally,ioutils,close,resources,on,failure,catch,exception,e,ioutils,close,while,handling,exception,release,resources,wrapped,listener,on,failure,e
RecoverySourceHandler -> public void recoverToTarget(ActionListener<RecoveryResponse> listener);1547569135;performs the recovery from the local engine to the target;public void recoverToTarget(ActionListener<RecoveryResponse> listener) {_        final List<Closeable> resources = new CopyOnWriteArrayList<>()__        final Closeable releaseResources = () -> IOUtils.close(resources)__        final ActionListener<RecoveryResponse> wrappedListener = ActionListener.notifyOnce(listener)__        try {_            cancellableThreads.setOnCancel((reason, beforeCancelEx) -> {_                final RuntimeException e__                if (shard.state() == IndexShardState.CLOSED) { _                    e = new IndexShardClosedException(shard.shardId(), "shard is closed and recovery was canceled reason [" + reason + "]")__                } else {_                    e = new CancellableThreads.ExecutionCancelledException("recovery was canceled reason [" + reason + "]")__                }_                if (beforeCancelEx != null) {_                    e.addSuppressed(beforeCancelEx)__                }_                IOUtils.closeWhileHandlingException(releaseResources, () -> wrappedListener.onFailure(e))__                throw e__            })__            final Consumer<Exception> onFailure = e ->_                IOUtils.closeWhileHandlingException(releaseResources, () -> wrappedListener.onFailure(e))___            runUnderPrimaryPermit(() -> {_                final IndexShardRoutingTable routingTable = shard.getReplicationGroup().getRoutingTable()__                ShardRouting targetShardRouting = routingTable.getByAllocationId(request.targetAllocationId())__                if (targetShardRouting == null) {_                    logger.debug("delaying recovery of {} as it is not listed as assigned to target node {}", request.shardId(),_                        request.targetNode())__                    throw new DelayRecoveryException("source node does not have the shard listed in its state as allocated on the node")__                }_                assert targetShardRouting.initializing() : "expected recovery target to be initializing but was " + targetShardRouting__            }, shardId + " validating recovery target ["+ request.targetAllocationId() + "] registered ",_                shard, cancellableThreads, logger)__            final Closeable retentionLock = shard.acquireRetentionLockForPeerRecovery()__            resources.add(retentionLock)__            final long startingSeqNo__            final long requiredSeqNoRangeStart__            final boolean isSequenceNumberBasedRecovery = request.startingSeqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                isTargetSameHistory() && shard.hasCompleteHistoryOperations("peer-recovery", request.startingSeqNo())__            final SendFileResult sendFileResult__            if (isSequenceNumberBasedRecovery) {_                logger.trace("performing sequence numbers based recovery. starting at [{}]", request.startingSeqNo())__                startingSeqNo = request.startingSeqNo()__                requiredSeqNoRangeStart = startingSeqNo__                sendFileResult = SendFileResult.EMPTY__            } else {_                final Engine.IndexCommitRef phase1Snapshot__                try {_                    phase1Snapshot = shard.acquireSafeIndexCommit()__                } catch (final Exception e) {_                    throw new RecoveryEngineException(shard.shardId(), 1, "snapshot failed", e)__                }_                _                requiredSeqNoRangeStart =_                    Long.parseLong(phase1Snapshot.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) + 1__                _                _                _                startingSeqNo = shard.indexSettings().isSoftDeleteEnabled() ? requiredSeqNoRangeStart : 0__                try {_                    final int estimateNumOps = shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo)__                    sendFileResult = phase1(phase1Snapshot.getIndexCommit(), () -> estimateNumOps)__                } catch (final Exception e) {_                    throw new RecoveryEngineException(shard.shardId(), 1, "phase1 failed", e)__                } finally {_                    try {_                        IOUtils.close(phase1Snapshot)__                    } catch (final IOException ex) {_                        logger.warn("releasing snapshot caused exception", ex)__                    }_                }_            }_            assert startingSeqNo >= 0 : "startingSeqNo must be non negative. got: " + startingSeqNo__            assert requiredSeqNoRangeStart >= startingSeqNo : "requiredSeqNoRangeStart [" + requiredSeqNoRangeStart + "] is lower than ["_                + startingSeqNo + "]"___            final TimeValue prepareEngineTime__            try {_                _                prepareEngineTime = prepareTargetForTranslog(isSequenceNumberBasedRecovery == false,_                    shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo))__            } catch (final Exception e) {_                throw new RecoveryEngineException(shard.shardId(), 1, "prepare target for translog failed", e)__            }__            _            runUnderPrimaryPermit(() -> shard.initiateTracking(request.targetAllocationId()),_                shardId + " initiating tracking of " + request.targetAllocationId(), shard, cancellableThreads, logger)___            final long endingSeqNo = shard.seqNoStats().getMaxSeqNo()__            _            cancellableThreads.execute(() -> shard.waitForOpsToComplete(endingSeqNo))___            if (logger.isTraceEnabled()) {_                logger.trace("all operations up to [{}] completed, which will be used as an ending sequence number", endingSeqNo)__                logger.trace("snapshot translog for recovery_ current size is [{}]",_                    shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo))__            }_            final SendSnapshotResult sendSnapshotResult__            try (Translog.Snapshot snapshot = shard.getHistoryOperations("peer-recovery", startingSeqNo)) {_                _                IOUtils.close(retentionLock, () -> resources.remove(retentionLock))__                _                _                final long maxSeenAutoIdTimestamp = shard.getMaxSeenAutoIdTimestamp()__                final long maxSeqNoOfUpdatesOrDeletes = shard.getMaxSeqNoOfUpdatesOrDeletes()__                sendSnapshotResult = phase2(startingSeqNo, requiredSeqNoRangeStart, endingSeqNo, snapshot,_                    maxSeenAutoIdTimestamp, maxSeqNoOfUpdatesOrDeletes)__            } catch (Exception e) {_                throw new RecoveryEngineException(shard.shardId(), 2, "phase2 failed", e)__            }__            final StepListener<Void> finalizeStep = new StepListener<>()__            finalizeRecovery(sendSnapshotResult.targetLocalCheckpoint, finalizeStep)__            finalizeStep.whenComplete(r -> {_                assert resources.isEmpty() : "not every resource is released [" + resources + "]"__                final long phase1ThrottlingWaitTime = 0L_ _                final RecoveryResponse response = new RecoveryResponse(sendFileResult.phase1FileNames, sendFileResult.phase1FileSizes,_                    sendFileResult.phase1ExistingFileNames, sendFileResult.phase1ExistingFileSizes, sendFileResult.totalSize,_                    sendFileResult.existingTotalSize, sendFileResult.took.millis(), phase1ThrottlingWaitTime,_                    prepareEngineTime.millis(), sendSnapshotResult.totalOperations, sendSnapshotResult.tookTime.millis())__                try {_                    wrappedListener.onResponse(response)__                } finally {_                    IOUtils.close(resources)__                }_            }, onFailure)__        } catch (Exception e) {_            IOUtils.closeWhileHandlingException(releaseResources, () -> wrappedListener.onFailure(e))__        }_    };performs,the,recovery,from,the,local,engine,to,the,target;public,void,recover,to,target,action,listener,recovery,response,listener,final,list,closeable,resources,new,copy,on,write,array,list,final,closeable,release,resources,ioutils,close,resources,final,action,listener,recovery,response,wrapped,listener,action,listener,notify,once,listener,try,cancellable,threads,set,on,cancel,reason,before,cancel,ex,final,runtime,exception,e,if,shard,state,index,shard,state,closed,e,new,index,shard,closed,exception,shard,shard,id,shard,is,closed,and,recovery,was,canceled,reason,reason,else,e,new,cancellable,threads,execution,cancelled,exception,recovery,was,canceled,reason,reason,if,before,cancel,ex,null,e,add,suppressed,before,cancel,ex,ioutils,close,while,handling,exception,release,resources,wrapped,listener,on,failure,e,throw,e,final,consumer,exception,on,failure,e,ioutils,close,while,handling,exception,release,resources,wrapped,listener,on,failure,e,run,under,primary,permit,final,index,shard,routing,table,routing,table,shard,get,replication,group,get,routing,table,shard,routing,target,shard,routing,routing,table,get,by,allocation,id,request,target,allocation,id,if,target,shard,routing,null,logger,debug,delaying,recovery,of,as,it,is,not,listed,as,assigned,to,target,node,request,shard,id,request,target,node,throw,new,delay,recovery,exception,source,node,does,not,have,the,shard,listed,in,its,state,as,allocated,on,the,node,assert,target,shard,routing,initializing,expected,recovery,target,to,be,initializing,but,was,target,shard,routing,shard,id,validating,recovery,target,request,target,allocation,id,registered,shard,cancellable,threads,logger,final,closeable,retention,lock,shard,acquire,retention,lock,for,peer,recovery,resources,add,retention,lock,final,long,starting,seq,no,final,long,required,seq,no,range,start,final,boolean,is,sequence,number,based,recovery,request,starting,seq,no,sequence,numbers,is,target,same,history,shard,has,complete,history,operations,peer,recovery,request,starting,seq,no,final,send,file,result,send,file,result,if,is,sequence,number,based,recovery,logger,trace,performing,sequence,numbers,based,recovery,starting,at,request,starting,seq,no,starting,seq,no,request,starting,seq,no,required,seq,no,range,start,starting,seq,no,send,file,result,send,file,result,empty,else,final,engine,index,commit,ref,phase1snapshot,try,phase1snapshot,shard,acquire,safe,index,commit,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,snapshot,failed,e,required,seq,no,range,start,long,parse,long,phase1snapshot,get,index,commit,get,user,data,get,sequence,numbers,1,starting,seq,no,shard,index,settings,is,soft,delete,enabled,required,seq,no,range,start,0,try,final,int,estimate,num,ops,shard,estimate,number,of,history,operations,peer,recovery,starting,seq,no,send,file,result,phase1,phase1snapshot,get,index,commit,estimate,num,ops,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,phase1,failed,e,finally,try,ioutils,close,phase1snapshot,catch,final,ioexception,ex,logger,warn,releasing,snapshot,caused,exception,ex,assert,starting,seq,no,0,starting,seq,no,must,be,non,negative,got,starting,seq,no,assert,required,seq,no,range,start,starting,seq,no,required,seq,no,range,start,required,seq,no,range,start,is,lower,than,starting,seq,no,final,time,value,prepare,engine,time,try,prepare,engine,time,prepare,target,for,translog,is,sequence,number,based,recovery,false,shard,estimate,number,of,history,operations,peer,recovery,starting,seq,no,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,prepare,target,for,translog,failed,e,run,under,primary,permit,shard,initiate,tracking,request,target,allocation,id,shard,id,initiating,tracking,of,request,target,allocation,id,shard,cancellable,threads,logger,final,long,ending,seq,no,shard,seq,no,stats,get,max,seq,no,cancellable,threads,execute,shard,wait,for,ops,to,complete,ending,seq,no,if,logger,is,trace,enabled,logger,trace,all,operations,up,to,completed,which,will,be,used,as,an,ending,sequence,number,ending,seq,no,logger,trace,snapshot,translog,for,recovery,current,size,is,shard,estimate,number,of,history,operations,peer,recovery,starting,seq,no,final,send,snapshot,result,send,snapshot,result,try,translog,snapshot,snapshot,shard,get,history,operations,peer,recovery,starting,seq,no,ioutils,close,retention,lock,resources,remove,retention,lock,final,long,max,seen,auto,id,timestamp,shard,get,max,seen,auto,id,timestamp,final,long,max,seq,no,of,updates,or,deletes,shard,get,max,seq,no,of,updates,or,deletes,send,snapshot,result,phase2,starting,seq,no,required,seq,no,range,start,ending,seq,no,snapshot,max,seen,auto,id,timestamp,max,seq,no,of,updates,or,deletes,catch,exception,e,throw,new,recovery,engine,exception,shard,shard,id,2,phase2,failed,e,final,step,listener,void,finalize,step,new,step,listener,finalize,recovery,send,snapshot,result,target,local,checkpoint,finalize,step,finalize,step,when,complete,r,assert,resources,is,empty,not,every,resource,is,released,resources,final,long,phase1throttling,wait,time,0l,final,recovery,response,response,new,recovery,response,send,file,result,phase1file,names,send,file,result,phase1file,sizes,send,file,result,phase1existing,file,names,send,file,result,phase1existing,file,sizes,send,file,result,total,size,send,file,result,existing,total,size,send,file,result,took,millis,phase1throttling,wait,time,prepare,engine,time,millis,send,snapshot,result,total,operations,send,snapshot,result,took,time,millis,try,wrapped,listener,on,response,response,finally,ioutils,close,resources,on,failure,catch,exception,e,ioutils,close,while,handling,exception,release,resources,wrapped,listener,on,failure,e
RecoverySourceHandler -> public void recoverToTarget(ActionListener<RecoveryResponse> listener);1547576245;performs the recovery from the local engine to the target;public void recoverToTarget(ActionListener<RecoveryResponse> listener) {_        final List<Closeable> resources = new CopyOnWriteArrayList<>()__        final Closeable releaseResources = () -> IOUtils.close(resources)__        final ActionListener<RecoveryResponse> wrappedListener = ActionListener.notifyOnce(listener)__        try {_            cancellableThreads.setOnCancel((reason, beforeCancelEx) -> {_                final RuntimeException e__                if (shard.state() == IndexShardState.CLOSED) { _                    e = new IndexShardClosedException(shard.shardId(), "shard is closed and recovery was canceled reason [" + reason + "]")__                } else {_                    e = new CancellableThreads.ExecutionCancelledException("recovery was canceled reason [" + reason + "]")__                }_                if (beforeCancelEx != null) {_                    e.addSuppressed(beforeCancelEx)__                }_                IOUtils.closeWhileHandlingException(releaseResources, () -> wrappedListener.onFailure(e))__                throw e__            })__            final Consumer<Exception> onFailure = e ->_                IOUtils.closeWhileHandlingException(releaseResources, () -> wrappedListener.onFailure(e))___            runUnderPrimaryPermit(() -> {_                final IndexShardRoutingTable routingTable = shard.getReplicationGroup().getRoutingTable()__                ShardRouting targetShardRouting = routingTable.getByAllocationId(request.targetAllocationId())__                if (targetShardRouting == null) {_                    logger.debug("delaying recovery of {} as it is not listed as assigned to target node {}", request.shardId(),_                        request.targetNode())__                    throw new DelayRecoveryException("source node does not have the shard listed in its state as allocated on the node")__                }_                assert targetShardRouting.initializing() : "expected recovery target to be initializing but was " + targetShardRouting__            }, shardId + " validating recovery target ["+ request.targetAllocationId() + "] registered ",_                shard, cancellableThreads, logger)__            final Closeable retentionLock = shard.acquireRetentionLockForPeerRecovery()__            resources.add(retentionLock)__            final long startingSeqNo__            final long requiredSeqNoRangeStart__            final boolean isSequenceNumberBasedRecovery = request.startingSeqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                isTargetSameHistory() && shard.hasCompleteHistoryOperations("peer-recovery", request.startingSeqNo())__            final SendFileResult sendFileResult__            if (isSequenceNumberBasedRecovery) {_                logger.trace("performing sequence numbers based recovery. starting at [{}]", request.startingSeqNo())__                startingSeqNo = request.startingSeqNo()__                requiredSeqNoRangeStart = startingSeqNo__                sendFileResult = SendFileResult.EMPTY__            } else {_                final Engine.IndexCommitRef phase1Snapshot__                try {_                    phase1Snapshot = shard.acquireSafeIndexCommit()__                } catch (final Exception e) {_                    throw new RecoveryEngineException(shard.shardId(), 1, "snapshot failed", e)__                }_                _                requiredSeqNoRangeStart =_                    Long.parseLong(phase1Snapshot.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) + 1__                _                _                _                startingSeqNo = shard.indexSettings().isSoftDeleteEnabled() ? requiredSeqNoRangeStart : 0__                try {_                    final int estimateNumOps = shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo)__                    sendFileResult = phase1(phase1Snapshot.getIndexCommit(), () -> estimateNumOps)__                } catch (final Exception e) {_                    throw new RecoveryEngineException(shard.shardId(), 1, "phase1 failed", e)__                } finally {_                    try {_                        IOUtils.close(phase1Snapshot)__                    } catch (final IOException ex) {_                        logger.warn("releasing snapshot caused exception", ex)__                    }_                }_            }_            assert startingSeqNo >= 0 : "startingSeqNo must be non negative. got: " + startingSeqNo__            assert requiredSeqNoRangeStart >= startingSeqNo : "requiredSeqNoRangeStart [" + requiredSeqNoRangeStart + "] is lower than ["_                + startingSeqNo + "]"___            final TimeValue prepareEngineTime__            try {_                _                prepareEngineTime = prepareTargetForTranslog(isSequenceNumberBasedRecovery == false,_                    shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo))__            } catch (final Exception e) {_                throw new RecoveryEngineException(shard.shardId(), 1, "prepare target for translog failed", e)__            }__            _            runUnderPrimaryPermit(() -> shard.initiateTracking(request.targetAllocationId()),_                shardId + " initiating tracking of " + request.targetAllocationId(), shard, cancellableThreads, logger)___            final long endingSeqNo = shard.seqNoStats().getMaxSeqNo()__            _            cancellableThreads.execute(() -> shard.waitForOpsToComplete(endingSeqNo))___            if (logger.isTraceEnabled()) {_                logger.trace("all operations up to [{}] completed, which will be used as an ending sequence number", endingSeqNo)__                logger.trace("snapshot translog for recovery_ current size is [{}]",_                    shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo))__            }__            final Translog.Snapshot phase2Snapshot = shard.getHistoryOperations("peer-recovery", startingSeqNo)__            resources.add(phase2Snapshot)__            _            IOUtils.close(retentionLock)__            _            _            final long maxSeenAutoIdTimestamp = shard.getMaxSeenAutoIdTimestamp()__            final long maxSeqNoOfUpdatesOrDeletes = shard.getMaxSeqNoOfUpdatesOrDeletes()__            final StepListener<SendSnapshotResult> sendSnapshotStep = new StepListener<>()__            phase2(startingSeqNo, requiredSeqNoRangeStart, endingSeqNo, phase2Snapshot, maxSeenAutoIdTimestamp,_                maxSeqNoOfUpdatesOrDeletes, sendSnapshotStep)__            sendSnapshotStep.whenComplete(_                r -> IOUtils.close(phase2Snapshot),_                e -> onFailure.accept(new RecoveryEngineException(shard.shardId(), 2, "phase2 failed", e)))__            final StepListener<Void> finalizeStep = new StepListener<>()__            sendSnapshotStep.whenComplete(r -> finalizeRecovery(r.targetLocalCheckpoint, finalizeStep), onFailure)___            finalizeStep.whenComplete(r -> {_                final long phase1ThrottlingWaitTime = 0L_ _                final SendSnapshotResult sendSnapshotResult = sendSnapshotStep.result()__                final RecoveryResponse response = new RecoveryResponse(sendFileResult.phase1FileNames, sendFileResult.phase1FileSizes,_                    sendFileResult.phase1ExistingFileNames, sendFileResult.phase1ExistingFileSizes, sendFileResult.totalSize,_                    sendFileResult.existingTotalSize, sendFileResult.took.millis(), phase1ThrottlingWaitTime,_                    prepareEngineTime.millis(), sendSnapshotResult.totalOperations, sendSnapshotResult.tookTime.millis())__                try {_                    wrappedListener.onResponse(response)__                } finally {_                    IOUtils.close(resources)__                }_            }, onFailure)__        } catch (Exception e) {_            IOUtils.closeWhileHandlingException(releaseResources, () -> wrappedListener.onFailure(e))__        }_    };performs,the,recovery,from,the,local,engine,to,the,target;public,void,recover,to,target,action,listener,recovery,response,listener,final,list,closeable,resources,new,copy,on,write,array,list,final,closeable,release,resources,ioutils,close,resources,final,action,listener,recovery,response,wrapped,listener,action,listener,notify,once,listener,try,cancellable,threads,set,on,cancel,reason,before,cancel,ex,final,runtime,exception,e,if,shard,state,index,shard,state,closed,e,new,index,shard,closed,exception,shard,shard,id,shard,is,closed,and,recovery,was,canceled,reason,reason,else,e,new,cancellable,threads,execution,cancelled,exception,recovery,was,canceled,reason,reason,if,before,cancel,ex,null,e,add,suppressed,before,cancel,ex,ioutils,close,while,handling,exception,release,resources,wrapped,listener,on,failure,e,throw,e,final,consumer,exception,on,failure,e,ioutils,close,while,handling,exception,release,resources,wrapped,listener,on,failure,e,run,under,primary,permit,final,index,shard,routing,table,routing,table,shard,get,replication,group,get,routing,table,shard,routing,target,shard,routing,routing,table,get,by,allocation,id,request,target,allocation,id,if,target,shard,routing,null,logger,debug,delaying,recovery,of,as,it,is,not,listed,as,assigned,to,target,node,request,shard,id,request,target,node,throw,new,delay,recovery,exception,source,node,does,not,have,the,shard,listed,in,its,state,as,allocated,on,the,node,assert,target,shard,routing,initializing,expected,recovery,target,to,be,initializing,but,was,target,shard,routing,shard,id,validating,recovery,target,request,target,allocation,id,registered,shard,cancellable,threads,logger,final,closeable,retention,lock,shard,acquire,retention,lock,for,peer,recovery,resources,add,retention,lock,final,long,starting,seq,no,final,long,required,seq,no,range,start,final,boolean,is,sequence,number,based,recovery,request,starting,seq,no,sequence,numbers,is,target,same,history,shard,has,complete,history,operations,peer,recovery,request,starting,seq,no,final,send,file,result,send,file,result,if,is,sequence,number,based,recovery,logger,trace,performing,sequence,numbers,based,recovery,starting,at,request,starting,seq,no,starting,seq,no,request,starting,seq,no,required,seq,no,range,start,starting,seq,no,send,file,result,send,file,result,empty,else,final,engine,index,commit,ref,phase1snapshot,try,phase1snapshot,shard,acquire,safe,index,commit,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,snapshot,failed,e,required,seq,no,range,start,long,parse,long,phase1snapshot,get,index,commit,get,user,data,get,sequence,numbers,1,starting,seq,no,shard,index,settings,is,soft,delete,enabled,required,seq,no,range,start,0,try,final,int,estimate,num,ops,shard,estimate,number,of,history,operations,peer,recovery,starting,seq,no,send,file,result,phase1,phase1snapshot,get,index,commit,estimate,num,ops,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,phase1,failed,e,finally,try,ioutils,close,phase1snapshot,catch,final,ioexception,ex,logger,warn,releasing,snapshot,caused,exception,ex,assert,starting,seq,no,0,starting,seq,no,must,be,non,negative,got,starting,seq,no,assert,required,seq,no,range,start,starting,seq,no,required,seq,no,range,start,required,seq,no,range,start,is,lower,than,starting,seq,no,final,time,value,prepare,engine,time,try,prepare,engine,time,prepare,target,for,translog,is,sequence,number,based,recovery,false,shard,estimate,number,of,history,operations,peer,recovery,starting,seq,no,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,prepare,target,for,translog,failed,e,run,under,primary,permit,shard,initiate,tracking,request,target,allocation,id,shard,id,initiating,tracking,of,request,target,allocation,id,shard,cancellable,threads,logger,final,long,ending,seq,no,shard,seq,no,stats,get,max,seq,no,cancellable,threads,execute,shard,wait,for,ops,to,complete,ending,seq,no,if,logger,is,trace,enabled,logger,trace,all,operations,up,to,completed,which,will,be,used,as,an,ending,sequence,number,ending,seq,no,logger,trace,snapshot,translog,for,recovery,current,size,is,shard,estimate,number,of,history,operations,peer,recovery,starting,seq,no,final,translog,snapshot,phase2snapshot,shard,get,history,operations,peer,recovery,starting,seq,no,resources,add,phase2snapshot,ioutils,close,retention,lock,final,long,max,seen,auto,id,timestamp,shard,get,max,seen,auto,id,timestamp,final,long,max,seq,no,of,updates,or,deletes,shard,get,max,seq,no,of,updates,or,deletes,final,step,listener,send,snapshot,result,send,snapshot,step,new,step,listener,phase2,starting,seq,no,required,seq,no,range,start,ending,seq,no,phase2snapshot,max,seen,auto,id,timestamp,max,seq,no,of,updates,or,deletes,send,snapshot,step,send,snapshot,step,when,complete,r,ioutils,close,phase2snapshot,e,on,failure,accept,new,recovery,engine,exception,shard,shard,id,2,phase2,failed,e,final,step,listener,void,finalize,step,new,step,listener,send,snapshot,step,when,complete,r,finalize,recovery,r,target,local,checkpoint,finalize,step,on,failure,finalize,step,when,complete,r,final,long,phase1throttling,wait,time,0l,final,send,snapshot,result,send,snapshot,result,send,snapshot,step,result,final,recovery,response,response,new,recovery,response,send,file,result,phase1file,names,send,file,result,phase1file,sizes,send,file,result,phase1existing,file,names,send,file,result,phase1existing,file,sizes,send,file,result,total,size,send,file,result,existing,total,size,send,file,result,took,millis,phase1throttling,wait,time,prepare,engine,time,millis,send,snapshot,result,total,operations,send,snapshot,result,took,time,millis,try,wrapped,listener,on,response,response,finally,ioutils,close,resources,on,failure,catch,exception,e,ioutils,close,while,handling,exception,release,resources,wrapped,listener,on,failure,e
RecoverySourceHandler -> public void recoverToTarget(ActionListener<RecoveryResponse> listener);1547737145;performs the recovery from the local engine to the target;public void recoverToTarget(ActionListener<RecoveryResponse> listener) {_        final List<Closeable> resources = new CopyOnWriteArrayList<>()__        final Closeable releaseResources = () -> IOUtils.close(resources)__        final ActionListener<RecoveryResponse> wrappedListener = ActionListener.notifyOnce(listener)__        try {_            cancellableThreads.setOnCancel((reason, beforeCancelEx) -> {_                final RuntimeException e__                if (shard.state() == IndexShardState.CLOSED) { _                    e = new IndexShardClosedException(shard.shardId(), "shard is closed and recovery was canceled reason [" + reason + "]")__                } else {_                    e = new CancellableThreads.ExecutionCancelledException("recovery was canceled reason [" + reason + "]")__                }_                if (beforeCancelEx != null) {_                    e.addSuppressed(beforeCancelEx)__                }_                IOUtils.closeWhileHandlingException(releaseResources, () -> wrappedListener.onFailure(e))__                throw e__            })__            final Consumer<Exception> onFailure = e ->_                IOUtils.closeWhileHandlingException(releaseResources, () -> wrappedListener.onFailure(e))___            runUnderPrimaryPermit(() -> {_                final IndexShardRoutingTable routingTable = shard.getReplicationGroup().getRoutingTable()__                ShardRouting targetShardRouting = routingTable.getByAllocationId(request.targetAllocationId())__                if (targetShardRouting == null) {_                    logger.debug("delaying recovery of {} as it is not listed as assigned to target node {}", request.shardId(),_                        request.targetNode())__                    throw new DelayRecoveryException("source node does not have the shard listed in its state as allocated on the node")__                }_                assert targetShardRouting.initializing() : "expected recovery target to be initializing but was " + targetShardRouting__            }, shardId + " validating recovery target ["+ request.targetAllocationId() + "] registered ",_                shard, cancellableThreads, logger)__            final Closeable retentionLock = shard.acquireRetentionLockForPeerRecovery()__            resources.add(retentionLock)__            final long startingSeqNo__            final long requiredSeqNoRangeStart__            final boolean isSequenceNumberBasedRecovery = request.startingSeqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                isTargetSameHistory() && shard.hasCompleteHistoryOperations("peer-recovery", request.startingSeqNo())__            final SendFileResult sendFileResult__            if (isSequenceNumberBasedRecovery) {_                logger.trace("performing sequence numbers based recovery. starting at [{}]", request.startingSeqNo())__                startingSeqNo = request.startingSeqNo()__                requiredSeqNoRangeStart = startingSeqNo__                sendFileResult = SendFileResult.EMPTY__            } else {_                final Engine.IndexCommitRef phase1Snapshot__                try {_                    phase1Snapshot = shard.acquireSafeIndexCommit()__                } catch (final Exception e) {_                    throw new RecoveryEngineException(shard.shardId(), 1, "snapshot failed", e)__                }_                _                requiredSeqNoRangeStart =_                    Long.parseLong(phase1Snapshot.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) + 1__                _                _                _                startingSeqNo = shard.indexSettings().isSoftDeleteEnabled() ? requiredSeqNoRangeStart : 0__                try {_                    final int estimateNumOps = shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo)__                    sendFileResult = phase1(phase1Snapshot.getIndexCommit(), () -> estimateNumOps)__                } catch (final Exception e) {_                    throw new RecoveryEngineException(shard.shardId(), 1, "phase1 failed", e)__                } finally {_                    try {_                        IOUtils.close(phase1Snapshot)__                    } catch (final IOException ex) {_                        logger.warn("releasing snapshot caused exception", ex)__                    }_                }_            }_            assert startingSeqNo >= 0 : "startingSeqNo must be non negative. got: " + startingSeqNo__            assert requiredSeqNoRangeStart >= startingSeqNo : "requiredSeqNoRangeStart [" + requiredSeqNoRangeStart + "] is lower than ["_                + startingSeqNo + "]"___            final TimeValue prepareEngineTime__            try {_                _                prepareEngineTime = prepareTargetForTranslog(isSequenceNumberBasedRecovery == false,_                    shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo))__            } catch (final Exception e) {_                throw new RecoveryEngineException(shard.shardId(), 1, "prepare target for translog failed", e)__            }__            _            runUnderPrimaryPermit(() -> shard.initiateTracking(request.targetAllocationId()),_                shardId + " initiating tracking of " + request.targetAllocationId(), shard, cancellableThreads, logger)___            final long endingSeqNo = shard.seqNoStats().getMaxSeqNo()__            _            cancellableThreads.execute(() -> shard.waitForOpsToComplete(endingSeqNo))___            if (logger.isTraceEnabled()) {_                logger.trace("all operations up to [{}] completed, which will be used as an ending sequence number", endingSeqNo)__                logger.trace("snapshot translog for recovery_ current size is [{}]",_                    shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo))__            }__            final Translog.Snapshot phase2Snapshot = shard.getHistoryOperations("peer-recovery", startingSeqNo)__            resources.add(phase2Snapshot)__            _            IOUtils.close(retentionLock)__            _            _            final long maxSeenAutoIdTimestamp = shard.getMaxSeenAutoIdTimestamp()__            final long maxSeqNoOfUpdatesOrDeletes = shard.getMaxSeqNoOfUpdatesOrDeletes()__            final StepListener<SendSnapshotResult> sendSnapshotStep = new StepListener<>()__            phase2(startingSeqNo, requiredSeqNoRangeStart, endingSeqNo, phase2Snapshot, maxSeenAutoIdTimestamp,_                maxSeqNoOfUpdatesOrDeletes, sendSnapshotStep)__            sendSnapshotStep.whenComplete(_                r -> IOUtils.close(phase2Snapshot),_                e -> onFailure.accept(new RecoveryEngineException(shard.shardId(), 2, "phase2 failed", e)))__            final StepListener<Void> finalizeStep = new StepListener<>()__            sendSnapshotStep.whenComplete(r -> finalizeRecovery(r.targetLocalCheckpoint, finalizeStep), onFailure)___            finalizeStep.whenComplete(r -> {_                final long phase1ThrottlingWaitTime = 0L_ _                final SendSnapshotResult sendSnapshotResult = sendSnapshotStep.result()__                final RecoveryResponse response = new RecoveryResponse(sendFileResult.phase1FileNames, sendFileResult.phase1FileSizes,_                    sendFileResult.phase1ExistingFileNames, sendFileResult.phase1ExistingFileSizes, sendFileResult.totalSize,_                    sendFileResult.existingTotalSize, sendFileResult.took.millis(), phase1ThrottlingWaitTime,_                    prepareEngineTime.millis(), sendSnapshotResult.totalOperations, sendSnapshotResult.tookTime.millis())__                try {_                    wrappedListener.onResponse(response)__                } finally {_                    IOUtils.close(resources)__                }_            }, onFailure)__        } catch (Exception e) {_            IOUtils.closeWhileHandlingException(releaseResources, () -> wrappedListener.onFailure(e))__        }_    };performs,the,recovery,from,the,local,engine,to,the,target;public,void,recover,to,target,action,listener,recovery,response,listener,final,list,closeable,resources,new,copy,on,write,array,list,final,closeable,release,resources,ioutils,close,resources,final,action,listener,recovery,response,wrapped,listener,action,listener,notify,once,listener,try,cancellable,threads,set,on,cancel,reason,before,cancel,ex,final,runtime,exception,e,if,shard,state,index,shard,state,closed,e,new,index,shard,closed,exception,shard,shard,id,shard,is,closed,and,recovery,was,canceled,reason,reason,else,e,new,cancellable,threads,execution,cancelled,exception,recovery,was,canceled,reason,reason,if,before,cancel,ex,null,e,add,suppressed,before,cancel,ex,ioutils,close,while,handling,exception,release,resources,wrapped,listener,on,failure,e,throw,e,final,consumer,exception,on,failure,e,ioutils,close,while,handling,exception,release,resources,wrapped,listener,on,failure,e,run,under,primary,permit,final,index,shard,routing,table,routing,table,shard,get,replication,group,get,routing,table,shard,routing,target,shard,routing,routing,table,get,by,allocation,id,request,target,allocation,id,if,target,shard,routing,null,logger,debug,delaying,recovery,of,as,it,is,not,listed,as,assigned,to,target,node,request,shard,id,request,target,node,throw,new,delay,recovery,exception,source,node,does,not,have,the,shard,listed,in,its,state,as,allocated,on,the,node,assert,target,shard,routing,initializing,expected,recovery,target,to,be,initializing,but,was,target,shard,routing,shard,id,validating,recovery,target,request,target,allocation,id,registered,shard,cancellable,threads,logger,final,closeable,retention,lock,shard,acquire,retention,lock,for,peer,recovery,resources,add,retention,lock,final,long,starting,seq,no,final,long,required,seq,no,range,start,final,boolean,is,sequence,number,based,recovery,request,starting,seq,no,sequence,numbers,is,target,same,history,shard,has,complete,history,operations,peer,recovery,request,starting,seq,no,final,send,file,result,send,file,result,if,is,sequence,number,based,recovery,logger,trace,performing,sequence,numbers,based,recovery,starting,at,request,starting,seq,no,starting,seq,no,request,starting,seq,no,required,seq,no,range,start,starting,seq,no,send,file,result,send,file,result,empty,else,final,engine,index,commit,ref,phase1snapshot,try,phase1snapshot,shard,acquire,safe,index,commit,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,snapshot,failed,e,required,seq,no,range,start,long,parse,long,phase1snapshot,get,index,commit,get,user,data,get,sequence,numbers,1,starting,seq,no,shard,index,settings,is,soft,delete,enabled,required,seq,no,range,start,0,try,final,int,estimate,num,ops,shard,estimate,number,of,history,operations,peer,recovery,starting,seq,no,send,file,result,phase1,phase1snapshot,get,index,commit,estimate,num,ops,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,phase1,failed,e,finally,try,ioutils,close,phase1snapshot,catch,final,ioexception,ex,logger,warn,releasing,snapshot,caused,exception,ex,assert,starting,seq,no,0,starting,seq,no,must,be,non,negative,got,starting,seq,no,assert,required,seq,no,range,start,starting,seq,no,required,seq,no,range,start,required,seq,no,range,start,is,lower,than,starting,seq,no,final,time,value,prepare,engine,time,try,prepare,engine,time,prepare,target,for,translog,is,sequence,number,based,recovery,false,shard,estimate,number,of,history,operations,peer,recovery,starting,seq,no,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,prepare,target,for,translog,failed,e,run,under,primary,permit,shard,initiate,tracking,request,target,allocation,id,shard,id,initiating,tracking,of,request,target,allocation,id,shard,cancellable,threads,logger,final,long,ending,seq,no,shard,seq,no,stats,get,max,seq,no,cancellable,threads,execute,shard,wait,for,ops,to,complete,ending,seq,no,if,logger,is,trace,enabled,logger,trace,all,operations,up,to,completed,which,will,be,used,as,an,ending,sequence,number,ending,seq,no,logger,trace,snapshot,translog,for,recovery,current,size,is,shard,estimate,number,of,history,operations,peer,recovery,starting,seq,no,final,translog,snapshot,phase2snapshot,shard,get,history,operations,peer,recovery,starting,seq,no,resources,add,phase2snapshot,ioutils,close,retention,lock,final,long,max,seen,auto,id,timestamp,shard,get,max,seen,auto,id,timestamp,final,long,max,seq,no,of,updates,or,deletes,shard,get,max,seq,no,of,updates,or,deletes,final,step,listener,send,snapshot,result,send,snapshot,step,new,step,listener,phase2,starting,seq,no,required,seq,no,range,start,ending,seq,no,phase2snapshot,max,seen,auto,id,timestamp,max,seq,no,of,updates,or,deletes,send,snapshot,step,send,snapshot,step,when,complete,r,ioutils,close,phase2snapshot,e,on,failure,accept,new,recovery,engine,exception,shard,shard,id,2,phase2,failed,e,final,step,listener,void,finalize,step,new,step,listener,send,snapshot,step,when,complete,r,finalize,recovery,r,target,local,checkpoint,finalize,step,on,failure,finalize,step,when,complete,r,final,long,phase1throttling,wait,time,0l,final,send,snapshot,result,send,snapshot,result,send,snapshot,step,result,final,recovery,response,response,new,recovery,response,send,file,result,phase1file,names,send,file,result,phase1file,sizes,send,file,result,phase1existing,file,names,send,file,result,phase1existing,file,sizes,send,file,result,total,size,send,file,result,existing,total,size,send,file,result,took,millis,phase1throttling,wait,time,prepare,engine,time,millis,send,snapshot,result,total,operations,send,snapshot,result,took,time,millis,try,wrapped,listener,on,response,response,finally,ioutils,close,resources,on,failure,catch,exception,e,ioutils,close,while,handling,exception,release,resources,wrapped,listener,on,failure,e
RecoverySourceHandler -> public void recoverToTarget(ActionListener<RecoveryResponse> listener);1548124510;performs the recovery from the local engine to the target;public void recoverToTarget(ActionListener<RecoveryResponse> listener) {_        final List<Closeable> resources = new CopyOnWriteArrayList<>()__        final Closeable releaseResources = () -> IOUtils.close(resources)__        final ActionListener<RecoveryResponse> wrappedListener = ActionListener.notifyOnce(listener)__        try {_            cancellableThreads.setOnCancel((reason, beforeCancelEx) -> {_                final RuntimeException e__                if (shard.state() == IndexShardState.CLOSED) { _                    e = new IndexShardClosedException(shard.shardId(), "shard is closed and recovery was canceled reason [" + reason + "]")__                } else {_                    e = new CancellableThreads.ExecutionCancelledException("recovery was canceled reason [" + reason + "]")__                }_                if (beforeCancelEx != null) {_                    e.addSuppressed(beforeCancelEx)__                }_                IOUtils.closeWhileHandlingException(releaseResources, () -> wrappedListener.onFailure(e))__                throw e__            })__            final Consumer<Exception> onFailure = e ->_                IOUtils.closeWhileHandlingException(releaseResources, () -> wrappedListener.onFailure(e))___            runUnderPrimaryPermit(() -> {_                final IndexShardRoutingTable routingTable = shard.getReplicationGroup().getRoutingTable()__                ShardRouting targetShardRouting = routingTable.getByAllocationId(request.targetAllocationId())__                if (targetShardRouting == null) {_                    logger.debug("delaying recovery of {} as it is not listed as assigned to target node {}", request.shardId(),_                        request.targetNode())__                    throw new DelayRecoveryException("source node does not have the shard listed in its state as allocated on the node")__                }_                assert targetShardRouting.initializing() : "expected recovery target to be initializing but was " + targetShardRouting__            }, shardId + " validating recovery target ["+ request.targetAllocationId() + "] registered ",_                shard, cancellableThreads, logger)__            final Closeable retentionLock = shard.acquireRetentionLockForPeerRecovery()__            resources.add(retentionLock)__            final long startingSeqNo__            final long requiredSeqNoRangeStart__            final boolean isSequenceNumberBasedRecovery = request.startingSeqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                isTargetSameHistory() && shard.hasCompleteHistoryOperations("peer-recovery", request.startingSeqNo())__            final SendFileResult sendFileResult__            if (isSequenceNumberBasedRecovery) {_                logger.trace("performing sequence numbers based recovery. starting at [{}]", request.startingSeqNo())__                startingSeqNo = request.startingSeqNo()__                requiredSeqNoRangeStart = startingSeqNo__                sendFileResult = SendFileResult.EMPTY__            } else {_                final Engine.IndexCommitRef phase1Snapshot__                try {_                    phase1Snapshot = shard.acquireSafeIndexCommit()__                } catch (final Exception e) {_                    throw new RecoveryEngineException(shard.shardId(), 1, "snapshot failed", e)__                }_                _                requiredSeqNoRangeStart =_                    Long.parseLong(phase1Snapshot.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) + 1__                _                _                _                startingSeqNo = shard.indexSettings().isSoftDeleteEnabled() ? requiredSeqNoRangeStart : 0__                try {_                    final int estimateNumOps = shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo)__                    sendFileResult = phase1(phase1Snapshot.getIndexCommit(), () -> estimateNumOps)__                } catch (final Exception e) {_                    throw new RecoveryEngineException(shard.shardId(), 1, "phase1 failed", e)__                } finally {_                    try {_                        IOUtils.close(phase1Snapshot)__                    } catch (final IOException ex) {_                        logger.warn("releasing snapshot caused exception", ex)__                    }_                }_            }_            assert startingSeqNo >= 0 : "startingSeqNo must be non negative. got: " + startingSeqNo__            assert requiredSeqNoRangeStart >= startingSeqNo : "requiredSeqNoRangeStart [" + requiredSeqNoRangeStart + "] is lower than ["_                + startingSeqNo + "]"___            final StepListener<TimeValue> prepareEngineStep = new StepListener<>()__            _            prepareTargetForTranslog(isSequenceNumberBasedRecovery == false,_                shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo), prepareEngineStep)__            final StepListener<SendSnapshotResult> sendSnapshotStep = new StepListener<>()__            prepareEngineStep.whenComplete(prepareEngineTime -> {_                _                runUnderPrimaryPermit(() -> shard.initiateTracking(request.targetAllocationId()),_                    shardId + " initiating tracking of " + request.targetAllocationId(), shard, cancellableThreads, logger)___                final long endingSeqNo = shard.seqNoStats().getMaxSeqNo()__                _                cancellableThreads.execute(() -> shard.waitForOpsToComplete(endingSeqNo))__                if (logger.isTraceEnabled()) {_                    logger.trace("all operations up to [{}] completed, which will be used as an ending sequence number", endingSeqNo)__                    logger.trace("snapshot translog for recovery_ current size is [{}]",_                        shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo))__                }_                final Translog.Snapshot phase2Snapshot = shard.getHistoryOperations("peer-recovery", startingSeqNo)__                resources.add(phase2Snapshot)__                _                retentionLock.close()__                _                _                final long maxSeenAutoIdTimestamp = shard.getMaxSeenAutoIdTimestamp()__                final long maxSeqNoOfUpdatesOrDeletes = shard.getMaxSeqNoOfUpdatesOrDeletes()__                phase2(startingSeqNo, requiredSeqNoRangeStart, endingSeqNo, phase2Snapshot, maxSeenAutoIdTimestamp,_                    maxSeqNoOfUpdatesOrDeletes, sendSnapshotStep)__                sendSnapshotStep.whenComplete(_                    r -> IOUtils.close(phase2Snapshot),_                    e -> {_                        IOUtils.closeWhileHandlingException(phase2Snapshot)__                        onFailure.accept(new RecoveryEngineException(shard.shardId(), 2, "phase2 failed", e))__                    })___            }, onFailure)___            final StepListener<Void> finalizeStep = new StepListener<>()__            sendSnapshotStep.whenComplete(r -> finalizeRecovery(r.targetLocalCheckpoint, finalizeStep), onFailure)___            finalizeStep.whenComplete(r -> {_                final long phase1ThrottlingWaitTime = 0L_ _                final SendSnapshotResult sendSnapshotResult = sendSnapshotStep.result()__                final RecoveryResponse response = new RecoveryResponse(sendFileResult.phase1FileNames, sendFileResult.phase1FileSizes,_                    sendFileResult.phase1ExistingFileNames, sendFileResult.phase1ExistingFileSizes, sendFileResult.totalSize,_                    sendFileResult.existingTotalSize, sendFileResult.took.millis(), phase1ThrottlingWaitTime,_                    prepareEngineStep.result().millis(), sendSnapshotResult.totalOperations, sendSnapshotResult.tookTime.millis())__                try {_                    wrappedListener.onResponse(response)__                } finally {_                    IOUtils.close(resources)__                }_            }, onFailure)__        } catch (Exception e) {_            IOUtils.closeWhileHandlingException(releaseResources, () -> wrappedListener.onFailure(e))__        }_    };performs,the,recovery,from,the,local,engine,to,the,target;public,void,recover,to,target,action,listener,recovery,response,listener,final,list,closeable,resources,new,copy,on,write,array,list,final,closeable,release,resources,ioutils,close,resources,final,action,listener,recovery,response,wrapped,listener,action,listener,notify,once,listener,try,cancellable,threads,set,on,cancel,reason,before,cancel,ex,final,runtime,exception,e,if,shard,state,index,shard,state,closed,e,new,index,shard,closed,exception,shard,shard,id,shard,is,closed,and,recovery,was,canceled,reason,reason,else,e,new,cancellable,threads,execution,cancelled,exception,recovery,was,canceled,reason,reason,if,before,cancel,ex,null,e,add,suppressed,before,cancel,ex,ioutils,close,while,handling,exception,release,resources,wrapped,listener,on,failure,e,throw,e,final,consumer,exception,on,failure,e,ioutils,close,while,handling,exception,release,resources,wrapped,listener,on,failure,e,run,under,primary,permit,final,index,shard,routing,table,routing,table,shard,get,replication,group,get,routing,table,shard,routing,target,shard,routing,routing,table,get,by,allocation,id,request,target,allocation,id,if,target,shard,routing,null,logger,debug,delaying,recovery,of,as,it,is,not,listed,as,assigned,to,target,node,request,shard,id,request,target,node,throw,new,delay,recovery,exception,source,node,does,not,have,the,shard,listed,in,its,state,as,allocated,on,the,node,assert,target,shard,routing,initializing,expected,recovery,target,to,be,initializing,but,was,target,shard,routing,shard,id,validating,recovery,target,request,target,allocation,id,registered,shard,cancellable,threads,logger,final,closeable,retention,lock,shard,acquire,retention,lock,for,peer,recovery,resources,add,retention,lock,final,long,starting,seq,no,final,long,required,seq,no,range,start,final,boolean,is,sequence,number,based,recovery,request,starting,seq,no,sequence,numbers,is,target,same,history,shard,has,complete,history,operations,peer,recovery,request,starting,seq,no,final,send,file,result,send,file,result,if,is,sequence,number,based,recovery,logger,trace,performing,sequence,numbers,based,recovery,starting,at,request,starting,seq,no,starting,seq,no,request,starting,seq,no,required,seq,no,range,start,starting,seq,no,send,file,result,send,file,result,empty,else,final,engine,index,commit,ref,phase1snapshot,try,phase1snapshot,shard,acquire,safe,index,commit,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,snapshot,failed,e,required,seq,no,range,start,long,parse,long,phase1snapshot,get,index,commit,get,user,data,get,sequence,numbers,1,starting,seq,no,shard,index,settings,is,soft,delete,enabled,required,seq,no,range,start,0,try,final,int,estimate,num,ops,shard,estimate,number,of,history,operations,peer,recovery,starting,seq,no,send,file,result,phase1,phase1snapshot,get,index,commit,estimate,num,ops,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,phase1,failed,e,finally,try,ioutils,close,phase1snapshot,catch,final,ioexception,ex,logger,warn,releasing,snapshot,caused,exception,ex,assert,starting,seq,no,0,starting,seq,no,must,be,non,negative,got,starting,seq,no,assert,required,seq,no,range,start,starting,seq,no,required,seq,no,range,start,required,seq,no,range,start,is,lower,than,starting,seq,no,final,step,listener,time,value,prepare,engine,step,new,step,listener,prepare,target,for,translog,is,sequence,number,based,recovery,false,shard,estimate,number,of,history,operations,peer,recovery,starting,seq,no,prepare,engine,step,final,step,listener,send,snapshot,result,send,snapshot,step,new,step,listener,prepare,engine,step,when,complete,prepare,engine,time,run,under,primary,permit,shard,initiate,tracking,request,target,allocation,id,shard,id,initiating,tracking,of,request,target,allocation,id,shard,cancellable,threads,logger,final,long,ending,seq,no,shard,seq,no,stats,get,max,seq,no,cancellable,threads,execute,shard,wait,for,ops,to,complete,ending,seq,no,if,logger,is,trace,enabled,logger,trace,all,operations,up,to,completed,which,will,be,used,as,an,ending,sequence,number,ending,seq,no,logger,trace,snapshot,translog,for,recovery,current,size,is,shard,estimate,number,of,history,operations,peer,recovery,starting,seq,no,final,translog,snapshot,phase2snapshot,shard,get,history,operations,peer,recovery,starting,seq,no,resources,add,phase2snapshot,retention,lock,close,final,long,max,seen,auto,id,timestamp,shard,get,max,seen,auto,id,timestamp,final,long,max,seq,no,of,updates,or,deletes,shard,get,max,seq,no,of,updates,or,deletes,phase2,starting,seq,no,required,seq,no,range,start,ending,seq,no,phase2snapshot,max,seen,auto,id,timestamp,max,seq,no,of,updates,or,deletes,send,snapshot,step,send,snapshot,step,when,complete,r,ioutils,close,phase2snapshot,e,ioutils,close,while,handling,exception,phase2snapshot,on,failure,accept,new,recovery,engine,exception,shard,shard,id,2,phase2,failed,e,on,failure,final,step,listener,void,finalize,step,new,step,listener,send,snapshot,step,when,complete,r,finalize,recovery,r,target,local,checkpoint,finalize,step,on,failure,finalize,step,when,complete,r,final,long,phase1throttling,wait,time,0l,final,send,snapshot,result,send,snapshot,result,send,snapshot,step,result,final,recovery,response,response,new,recovery,response,send,file,result,phase1file,names,send,file,result,phase1file,sizes,send,file,result,phase1existing,file,names,send,file,result,phase1existing,file,sizes,send,file,result,total,size,send,file,result,existing,total,size,send,file,result,took,millis,phase1throttling,wait,time,prepare,engine,step,result,millis,send,snapshot,result,total,operations,send,snapshot,result,took,time,millis,try,wrapped,listener,on,response,response,finally,ioutils,close,resources,on,failure,catch,exception,e,ioutils,close,while,handling,exception,release,resources,wrapped,listener,on,failure,e
RecoverySourceHandler -> public void recoverToTarget(ActionListener<RecoveryResponse> listener);1549406621;performs the recovery from the local engine to the target;public void recoverToTarget(ActionListener<RecoveryResponse> listener) {_        final List<Closeable> resources = new CopyOnWriteArrayList<>()__        final Closeable releaseResources = () -> IOUtils.close(resources)__        final ActionListener<RecoveryResponse> wrappedListener = ActionListener.notifyOnce(listener)__        try {_            cancellableThreads.setOnCancel((reason, beforeCancelEx) -> {_                final RuntimeException e__                if (shard.state() == IndexShardState.CLOSED) { _                    e = new IndexShardClosedException(shard.shardId(), "shard is closed and recovery was canceled reason [" + reason + "]")__                } else {_                    e = new CancellableThreads.ExecutionCancelledException("recovery was canceled reason [" + reason + "]")__                }_                if (beforeCancelEx != null) {_                    e.addSuppressed(beforeCancelEx)__                }_                IOUtils.closeWhileHandlingException(releaseResources, () -> wrappedListener.onFailure(e))__                throw e__            })__            final Consumer<Exception> onFailure = e ->_                IOUtils.closeWhileHandlingException(releaseResources, () -> wrappedListener.onFailure(e))___            runUnderPrimaryPermit(() -> {_                final IndexShardRoutingTable routingTable = shard.getReplicationGroup().getRoutingTable()__                ShardRouting targetShardRouting = routingTable.getByAllocationId(request.targetAllocationId())__                if (targetShardRouting == null) {_                    logger.debug("delaying recovery of {} as it is not listed as assigned to target node {}", request.shardId(),_                        request.targetNode())__                    throw new DelayRecoveryException("source node does not have the shard listed in its state as allocated on the node")__                }_                assert targetShardRouting.initializing() : "expected recovery target to be initializing but was " + targetShardRouting__            }, shardId + " validating recovery target ["+ request.targetAllocationId() + "] registered ",_                shard, cancellableThreads, logger)__            final Closeable retentionLock = shard.acquireRetentionLockForPeerRecovery()__            resources.add(retentionLock)__            final long startingSeqNo__            final long requiredSeqNoRangeStart__            final boolean isSequenceNumberBasedRecovery = request.startingSeqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                isTargetSameHistory() && shard.hasCompleteHistoryOperations("peer-recovery", request.startingSeqNo())__            final SendFileResult sendFileResult__            if (isSequenceNumberBasedRecovery) {_                logger.trace("performing sequence numbers based recovery. starting at [{}]", request.startingSeqNo())__                startingSeqNo = request.startingSeqNo()__                requiredSeqNoRangeStart = startingSeqNo__                sendFileResult = SendFileResult.EMPTY__            } else {_                final Engine.IndexCommitRef phase1Snapshot__                try {_                    phase1Snapshot = shard.acquireSafeIndexCommit()__                } catch (final Exception e) {_                    throw new RecoveryEngineException(shard.shardId(), 1, "snapshot failed", e)__                }_                _                requiredSeqNoRangeStart =_                    Long.parseLong(phase1Snapshot.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) + 1__                _                _                _                startingSeqNo = shard.indexSettings().isSoftDeleteEnabled() ? requiredSeqNoRangeStart : 0__                try {_                    final int estimateNumOps = shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo)__                    sendFileResult = phase1(phase1Snapshot.getIndexCommit(), () -> estimateNumOps)__                } catch (final Exception e) {_                    throw new RecoveryEngineException(shard.shardId(), 1, "phase1 failed", e)__                } finally {_                    try {_                        IOUtils.close(phase1Snapshot)__                    } catch (final IOException ex) {_                        logger.warn("releasing snapshot caused exception", ex)__                    }_                }_            }_            assert startingSeqNo >= 0 : "startingSeqNo must be non negative. got: " + startingSeqNo__            assert requiredSeqNoRangeStart >= startingSeqNo : "requiredSeqNoRangeStart [" + requiredSeqNoRangeStart + "] is lower than ["_                + startingSeqNo + "]"___            final StepListener<TimeValue> prepareEngineStep = new StepListener<>()__            _            prepareTargetForTranslog(isSequenceNumberBasedRecovery == false,_                shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo), prepareEngineStep)__            final StepListener<SendSnapshotResult> sendSnapshotStep = new StepListener<>()__            prepareEngineStep.whenComplete(prepareEngineTime -> {_                _                runUnderPrimaryPermit(() -> shard.initiateTracking(request.targetAllocationId()),_                    shardId + " initiating tracking of " + request.targetAllocationId(), shard, cancellableThreads, logger)___                final long endingSeqNo = shard.seqNoStats().getMaxSeqNo()__                _                cancellableThreads.execute(() -> shard.waitForOpsToComplete(endingSeqNo))__                if (logger.isTraceEnabled()) {_                    logger.trace("all operations up to [{}] completed, which will be used as an ending sequence number", endingSeqNo)__                    logger.trace("snapshot translog for recovery_ current size is [{}]",_                        shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo))__                }_                final Translog.Snapshot phase2Snapshot = shard.getHistoryOperations("peer-recovery", startingSeqNo)__                resources.add(phase2Snapshot)__                _                retentionLock.close()__                _                _                final long maxSeenAutoIdTimestamp = shard.getMaxSeenAutoIdTimestamp()__                final long maxSeqNoOfUpdatesOrDeletes = shard.getMaxSeqNoOfUpdatesOrDeletes()__                final RetentionLeases retentionLeases = shard.getRetentionLeases()__                phase2(_                        startingSeqNo,_                        requiredSeqNoRangeStart,_                        endingSeqNo,_                        phase2Snapshot,_                        maxSeenAutoIdTimestamp,_                        maxSeqNoOfUpdatesOrDeletes,_                        retentionLeases,_                        sendSnapshotStep)__                sendSnapshotStep.whenComplete(_                    r -> IOUtils.close(phase2Snapshot),_                    e -> {_                        IOUtils.closeWhileHandlingException(phase2Snapshot)__                        onFailure.accept(new RecoveryEngineException(shard.shardId(), 2, "phase2 failed", e))__                    })___            }, onFailure)___            final StepListener<Void> finalizeStep = new StepListener<>()__            sendSnapshotStep.whenComplete(r -> finalizeRecovery(r.targetLocalCheckpoint, finalizeStep), onFailure)___            finalizeStep.whenComplete(r -> {_                final long phase1ThrottlingWaitTime = 0L_ _                final SendSnapshotResult sendSnapshotResult = sendSnapshotStep.result()__                final RecoveryResponse response = new RecoveryResponse(sendFileResult.phase1FileNames, sendFileResult.phase1FileSizes,_                    sendFileResult.phase1ExistingFileNames, sendFileResult.phase1ExistingFileSizes, sendFileResult.totalSize,_                    sendFileResult.existingTotalSize, sendFileResult.took.millis(), phase1ThrottlingWaitTime,_                    prepareEngineStep.result().millis(), sendSnapshotResult.totalOperations, sendSnapshotResult.tookTime.millis())__                try {_                    wrappedListener.onResponse(response)__                } finally {_                    IOUtils.close(resources)__                }_            }, onFailure)__        } catch (Exception e) {_            IOUtils.closeWhileHandlingException(releaseResources, () -> wrappedListener.onFailure(e))__        }_    };performs,the,recovery,from,the,local,engine,to,the,target;public,void,recover,to,target,action,listener,recovery,response,listener,final,list,closeable,resources,new,copy,on,write,array,list,final,closeable,release,resources,ioutils,close,resources,final,action,listener,recovery,response,wrapped,listener,action,listener,notify,once,listener,try,cancellable,threads,set,on,cancel,reason,before,cancel,ex,final,runtime,exception,e,if,shard,state,index,shard,state,closed,e,new,index,shard,closed,exception,shard,shard,id,shard,is,closed,and,recovery,was,canceled,reason,reason,else,e,new,cancellable,threads,execution,cancelled,exception,recovery,was,canceled,reason,reason,if,before,cancel,ex,null,e,add,suppressed,before,cancel,ex,ioutils,close,while,handling,exception,release,resources,wrapped,listener,on,failure,e,throw,e,final,consumer,exception,on,failure,e,ioutils,close,while,handling,exception,release,resources,wrapped,listener,on,failure,e,run,under,primary,permit,final,index,shard,routing,table,routing,table,shard,get,replication,group,get,routing,table,shard,routing,target,shard,routing,routing,table,get,by,allocation,id,request,target,allocation,id,if,target,shard,routing,null,logger,debug,delaying,recovery,of,as,it,is,not,listed,as,assigned,to,target,node,request,shard,id,request,target,node,throw,new,delay,recovery,exception,source,node,does,not,have,the,shard,listed,in,its,state,as,allocated,on,the,node,assert,target,shard,routing,initializing,expected,recovery,target,to,be,initializing,but,was,target,shard,routing,shard,id,validating,recovery,target,request,target,allocation,id,registered,shard,cancellable,threads,logger,final,closeable,retention,lock,shard,acquire,retention,lock,for,peer,recovery,resources,add,retention,lock,final,long,starting,seq,no,final,long,required,seq,no,range,start,final,boolean,is,sequence,number,based,recovery,request,starting,seq,no,sequence,numbers,is,target,same,history,shard,has,complete,history,operations,peer,recovery,request,starting,seq,no,final,send,file,result,send,file,result,if,is,sequence,number,based,recovery,logger,trace,performing,sequence,numbers,based,recovery,starting,at,request,starting,seq,no,starting,seq,no,request,starting,seq,no,required,seq,no,range,start,starting,seq,no,send,file,result,send,file,result,empty,else,final,engine,index,commit,ref,phase1snapshot,try,phase1snapshot,shard,acquire,safe,index,commit,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,snapshot,failed,e,required,seq,no,range,start,long,parse,long,phase1snapshot,get,index,commit,get,user,data,get,sequence,numbers,1,starting,seq,no,shard,index,settings,is,soft,delete,enabled,required,seq,no,range,start,0,try,final,int,estimate,num,ops,shard,estimate,number,of,history,operations,peer,recovery,starting,seq,no,send,file,result,phase1,phase1snapshot,get,index,commit,estimate,num,ops,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,phase1,failed,e,finally,try,ioutils,close,phase1snapshot,catch,final,ioexception,ex,logger,warn,releasing,snapshot,caused,exception,ex,assert,starting,seq,no,0,starting,seq,no,must,be,non,negative,got,starting,seq,no,assert,required,seq,no,range,start,starting,seq,no,required,seq,no,range,start,required,seq,no,range,start,is,lower,than,starting,seq,no,final,step,listener,time,value,prepare,engine,step,new,step,listener,prepare,target,for,translog,is,sequence,number,based,recovery,false,shard,estimate,number,of,history,operations,peer,recovery,starting,seq,no,prepare,engine,step,final,step,listener,send,snapshot,result,send,snapshot,step,new,step,listener,prepare,engine,step,when,complete,prepare,engine,time,run,under,primary,permit,shard,initiate,tracking,request,target,allocation,id,shard,id,initiating,tracking,of,request,target,allocation,id,shard,cancellable,threads,logger,final,long,ending,seq,no,shard,seq,no,stats,get,max,seq,no,cancellable,threads,execute,shard,wait,for,ops,to,complete,ending,seq,no,if,logger,is,trace,enabled,logger,trace,all,operations,up,to,completed,which,will,be,used,as,an,ending,sequence,number,ending,seq,no,logger,trace,snapshot,translog,for,recovery,current,size,is,shard,estimate,number,of,history,operations,peer,recovery,starting,seq,no,final,translog,snapshot,phase2snapshot,shard,get,history,operations,peer,recovery,starting,seq,no,resources,add,phase2snapshot,retention,lock,close,final,long,max,seen,auto,id,timestamp,shard,get,max,seen,auto,id,timestamp,final,long,max,seq,no,of,updates,or,deletes,shard,get,max,seq,no,of,updates,or,deletes,final,retention,leases,retention,leases,shard,get,retention,leases,phase2,starting,seq,no,required,seq,no,range,start,ending,seq,no,phase2snapshot,max,seen,auto,id,timestamp,max,seq,no,of,updates,or,deletes,retention,leases,send,snapshot,step,send,snapshot,step,when,complete,r,ioutils,close,phase2snapshot,e,ioutils,close,while,handling,exception,phase2snapshot,on,failure,accept,new,recovery,engine,exception,shard,shard,id,2,phase2,failed,e,on,failure,final,step,listener,void,finalize,step,new,step,listener,send,snapshot,step,when,complete,r,finalize,recovery,r,target,local,checkpoint,finalize,step,on,failure,finalize,step,when,complete,r,final,long,phase1throttling,wait,time,0l,final,send,snapshot,result,send,snapshot,result,send,snapshot,step,result,final,recovery,response,response,new,recovery,response,send,file,result,phase1file,names,send,file,result,phase1file,sizes,send,file,result,phase1existing,file,names,send,file,result,phase1existing,file,sizes,send,file,result,total,size,send,file,result,existing,total,size,send,file,result,took,millis,phase1throttling,wait,time,prepare,engine,step,result,millis,send,snapshot,result,total,operations,send,snapshot,result,took,time,millis,try,wrapped,listener,on,response,response,finally,ioutils,close,resources,on,failure,catch,exception,e,ioutils,close,while,handling,exception,release,resources,wrapped,listener,on,failure,e
RecoverySourceHandler -> public void recoverToTarget(ActionListener<RecoveryResponse> listener);1549975032;performs the recovery from the local engine to the target;public void recoverToTarget(ActionListener<RecoveryResponse> listener) {_        final List<Closeable> resources = new CopyOnWriteArrayList<>()__        final Closeable releaseResources = () -> IOUtils.close(resources)__        final ActionListener<RecoveryResponse> wrappedListener = ActionListener.notifyOnce(listener)__        try {_            cancellableThreads.setOnCancel((reason, beforeCancelEx) -> {_                final RuntimeException e__                if (shard.state() == IndexShardState.CLOSED) { _                    e = new IndexShardClosedException(shard.shardId(), "shard is closed and recovery was canceled reason [" + reason + "]")__                } else {_                    e = new CancellableThreads.ExecutionCancelledException("recovery was canceled reason [" + reason + "]")__                }_                if (beforeCancelEx != null) {_                    e.addSuppressed(beforeCancelEx)__                }_                IOUtils.closeWhileHandlingException(releaseResources, () -> wrappedListener.onFailure(e))__                throw e__            })__            final Consumer<Exception> onFailure = e ->_                IOUtils.closeWhileHandlingException(releaseResources, () -> wrappedListener.onFailure(e))___            runUnderPrimaryPermit(() -> {_                final IndexShardRoutingTable routingTable = shard.getReplicationGroup().getRoutingTable()__                ShardRouting targetShardRouting = routingTable.getByAllocationId(request.targetAllocationId())__                if (targetShardRouting == null) {_                    logger.debug("delaying recovery of {} as it is not listed as assigned to target node {}", request.shardId(),_                        request.targetNode())__                    throw new DelayRecoveryException("source node does not have the shard listed in its state as allocated on the node")__                }_                assert targetShardRouting.initializing() : "expected recovery target to be initializing but was " + targetShardRouting__            }, shardId + " validating recovery target ["+ request.targetAllocationId() + "] registered ",_                shard, cancellableThreads, logger)__            final Closeable retentionLock = shard.acquireRetentionLock()__            resources.add(retentionLock)__            final long startingSeqNo__            final long requiredSeqNoRangeStart__            final boolean isSequenceNumberBasedRecovery = request.startingSeqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                isTargetSameHistory() && shard.hasCompleteHistoryOperations("peer-recovery", request.startingSeqNo())__            final SendFileResult sendFileResult__            if (isSequenceNumberBasedRecovery) {_                logger.trace("performing sequence numbers based recovery. starting at [{}]", request.startingSeqNo())__                startingSeqNo = request.startingSeqNo()__                requiredSeqNoRangeStart = startingSeqNo__                sendFileResult = SendFileResult.EMPTY__            } else {_                final Engine.IndexCommitRef phase1Snapshot__                try {_                    phase1Snapshot = shard.acquireSafeIndexCommit()__                } catch (final Exception e) {_                    throw new RecoveryEngineException(shard.shardId(), 1, "snapshot failed", e)__                }_                _                requiredSeqNoRangeStart =_                    Long.parseLong(phase1Snapshot.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) + 1__                _                _                _                startingSeqNo = shard.indexSettings().isSoftDeleteEnabled() ? requiredSeqNoRangeStart : 0__                try {_                    final int estimateNumOps = shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo)__                    sendFileResult = phase1(phase1Snapshot.getIndexCommit(), () -> estimateNumOps)__                } catch (final Exception e) {_                    throw new RecoveryEngineException(shard.shardId(), 1, "phase1 failed", e)__                } finally {_                    try {_                        IOUtils.close(phase1Snapshot)__                    } catch (final IOException ex) {_                        logger.warn("releasing snapshot caused exception", ex)__                    }_                }_            }_            assert startingSeqNo >= 0 : "startingSeqNo must be non negative. got: " + startingSeqNo__            assert requiredSeqNoRangeStart >= startingSeqNo : "requiredSeqNoRangeStart [" + requiredSeqNoRangeStart + "] is lower than ["_                + startingSeqNo + "]"___            final StepListener<TimeValue> prepareEngineStep = new StepListener<>()__            _            prepareTargetForTranslog(isSequenceNumberBasedRecovery == false,_                shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo), prepareEngineStep)__            final StepListener<SendSnapshotResult> sendSnapshotStep = new StepListener<>()__            prepareEngineStep.whenComplete(prepareEngineTime -> {_                _                runUnderPrimaryPermit(() -> shard.initiateTracking(request.targetAllocationId()),_                    shardId + " initiating tracking of " + request.targetAllocationId(), shard, cancellableThreads, logger)___                final long endingSeqNo = shard.seqNoStats().getMaxSeqNo()__                _                cancellableThreads.execute(() -> shard.waitForOpsToComplete(endingSeqNo))__                if (logger.isTraceEnabled()) {_                    logger.trace("all operations up to [{}] completed, which will be used as an ending sequence number", endingSeqNo)__                    logger.trace("snapshot translog for recovery_ current size is [{}]",_                        shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo))__                }_                final Translog.Snapshot phase2Snapshot = shard.getHistoryOperations("peer-recovery", startingSeqNo)__                resources.add(phase2Snapshot)__                _                retentionLock.close()__                _                _                final long maxSeenAutoIdTimestamp = shard.getMaxSeenAutoIdTimestamp()__                final long maxSeqNoOfUpdatesOrDeletes = shard.getMaxSeqNoOfUpdatesOrDeletes()__                final RetentionLeases retentionLeases = shard.getRetentionLeases()__                phase2(_                        startingSeqNo,_                        requiredSeqNoRangeStart,_                        endingSeqNo,_                        phase2Snapshot,_                        maxSeenAutoIdTimestamp,_                        maxSeqNoOfUpdatesOrDeletes,_                        retentionLeases,_                        sendSnapshotStep)__                sendSnapshotStep.whenComplete(_                    r -> IOUtils.close(phase2Snapshot),_                    e -> {_                        IOUtils.closeWhileHandlingException(phase2Snapshot)__                        onFailure.accept(new RecoveryEngineException(shard.shardId(), 2, "phase2 failed", e))__                    })___            }, onFailure)___            final StepListener<Void> finalizeStep = new StepListener<>()__            sendSnapshotStep.whenComplete(r -> finalizeRecovery(r.targetLocalCheckpoint, finalizeStep), onFailure)___            finalizeStep.whenComplete(r -> {_                final long phase1ThrottlingWaitTime = 0L_ _                final SendSnapshotResult sendSnapshotResult = sendSnapshotStep.result()__                final RecoveryResponse response = new RecoveryResponse(sendFileResult.phase1FileNames, sendFileResult.phase1FileSizes,_                    sendFileResult.phase1ExistingFileNames, sendFileResult.phase1ExistingFileSizes, sendFileResult.totalSize,_                    sendFileResult.existingTotalSize, sendFileResult.took.millis(), phase1ThrottlingWaitTime,_                    prepareEngineStep.result().millis(), sendSnapshotResult.totalOperations, sendSnapshotResult.tookTime.millis())__                try {_                    wrappedListener.onResponse(response)__                } finally {_                    IOUtils.close(resources)__                }_            }, onFailure)__        } catch (Exception e) {_            IOUtils.closeWhileHandlingException(releaseResources, () -> wrappedListener.onFailure(e))__        }_    };performs,the,recovery,from,the,local,engine,to,the,target;public,void,recover,to,target,action,listener,recovery,response,listener,final,list,closeable,resources,new,copy,on,write,array,list,final,closeable,release,resources,ioutils,close,resources,final,action,listener,recovery,response,wrapped,listener,action,listener,notify,once,listener,try,cancellable,threads,set,on,cancel,reason,before,cancel,ex,final,runtime,exception,e,if,shard,state,index,shard,state,closed,e,new,index,shard,closed,exception,shard,shard,id,shard,is,closed,and,recovery,was,canceled,reason,reason,else,e,new,cancellable,threads,execution,cancelled,exception,recovery,was,canceled,reason,reason,if,before,cancel,ex,null,e,add,suppressed,before,cancel,ex,ioutils,close,while,handling,exception,release,resources,wrapped,listener,on,failure,e,throw,e,final,consumer,exception,on,failure,e,ioutils,close,while,handling,exception,release,resources,wrapped,listener,on,failure,e,run,under,primary,permit,final,index,shard,routing,table,routing,table,shard,get,replication,group,get,routing,table,shard,routing,target,shard,routing,routing,table,get,by,allocation,id,request,target,allocation,id,if,target,shard,routing,null,logger,debug,delaying,recovery,of,as,it,is,not,listed,as,assigned,to,target,node,request,shard,id,request,target,node,throw,new,delay,recovery,exception,source,node,does,not,have,the,shard,listed,in,its,state,as,allocated,on,the,node,assert,target,shard,routing,initializing,expected,recovery,target,to,be,initializing,but,was,target,shard,routing,shard,id,validating,recovery,target,request,target,allocation,id,registered,shard,cancellable,threads,logger,final,closeable,retention,lock,shard,acquire,retention,lock,resources,add,retention,lock,final,long,starting,seq,no,final,long,required,seq,no,range,start,final,boolean,is,sequence,number,based,recovery,request,starting,seq,no,sequence,numbers,is,target,same,history,shard,has,complete,history,operations,peer,recovery,request,starting,seq,no,final,send,file,result,send,file,result,if,is,sequence,number,based,recovery,logger,trace,performing,sequence,numbers,based,recovery,starting,at,request,starting,seq,no,starting,seq,no,request,starting,seq,no,required,seq,no,range,start,starting,seq,no,send,file,result,send,file,result,empty,else,final,engine,index,commit,ref,phase1snapshot,try,phase1snapshot,shard,acquire,safe,index,commit,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,snapshot,failed,e,required,seq,no,range,start,long,parse,long,phase1snapshot,get,index,commit,get,user,data,get,sequence,numbers,1,starting,seq,no,shard,index,settings,is,soft,delete,enabled,required,seq,no,range,start,0,try,final,int,estimate,num,ops,shard,estimate,number,of,history,operations,peer,recovery,starting,seq,no,send,file,result,phase1,phase1snapshot,get,index,commit,estimate,num,ops,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,phase1,failed,e,finally,try,ioutils,close,phase1snapshot,catch,final,ioexception,ex,logger,warn,releasing,snapshot,caused,exception,ex,assert,starting,seq,no,0,starting,seq,no,must,be,non,negative,got,starting,seq,no,assert,required,seq,no,range,start,starting,seq,no,required,seq,no,range,start,required,seq,no,range,start,is,lower,than,starting,seq,no,final,step,listener,time,value,prepare,engine,step,new,step,listener,prepare,target,for,translog,is,sequence,number,based,recovery,false,shard,estimate,number,of,history,operations,peer,recovery,starting,seq,no,prepare,engine,step,final,step,listener,send,snapshot,result,send,snapshot,step,new,step,listener,prepare,engine,step,when,complete,prepare,engine,time,run,under,primary,permit,shard,initiate,tracking,request,target,allocation,id,shard,id,initiating,tracking,of,request,target,allocation,id,shard,cancellable,threads,logger,final,long,ending,seq,no,shard,seq,no,stats,get,max,seq,no,cancellable,threads,execute,shard,wait,for,ops,to,complete,ending,seq,no,if,logger,is,trace,enabled,logger,trace,all,operations,up,to,completed,which,will,be,used,as,an,ending,sequence,number,ending,seq,no,logger,trace,snapshot,translog,for,recovery,current,size,is,shard,estimate,number,of,history,operations,peer,recovery,starting,seq,no,final,translog,snapshot,phase2snapshot,shard,get,history,operations,peer,recovery,starting,seq,no,resources,add,phase2snapshot,retention,lock,close,final,long,max,seen,auto,id,timestamp,shard,get,max,seen,auto,id,timestamp,final,long,max,seq,no,of,updates,or,deletes,shard,get,max,seq,no,of,updates,or,deletes,final,retention,leases,retention,leases,shard,get,retention,leases,phase2,starting,seq,no,required,seq,no,range,start,ending,seq,no,phase2snapshot,max,seen,auto,id,timestamp,max,seq,no,of,updates,or,deletes,retention,leases,send,snapshot,step,send,snapshot,step,when,complete,r,ioutils,close,phase2snapshot,e,ioutils,close,while,handling,exception,phase2snapshot,on,failure,accept,new,recovery,engine,exception,shard,shard,id,2,phase2,failed,e,on,failure,final,step,listener,void,finalize,step,new,step,listener,send,snapshot,step,when,complete,r,finalize,recovery,r,target,local,checkpoint,finalize,step,on,failure,finalize,step,when,complete,r,final,long,phase1throttling,wait,time,0l,final,send,snapshot,result,send,snapshot,result,send,snapshot,step,result,final,recovery,response,response,new,recovery,response,send,file,result,phase1file,names,send,file,result,phase1file,sizes,send,file,result,phase1existing,file,names,send,file,result,phase1existing,file,sizes,send,file,result,total,size,send,file,result,existing,total,size,send,file,result,took,millis,phase1throttling,wait,time,prepare,engine,step,result,millis,send,snapshot,result,total,operations,send,snapshot,result,took,time,millis,try,wrapped,listener,on,response,response,finally,ioutils,close,resources,on,failure,catch,exception,e,ioutils,close,while,handling,exception,release,resources,wrapped,listener,on,failure,e
RecoverySourceHandler -> public void recoverToTarget(ActionListener<RecoveryResponse> listener);1550220204;performs the recovery from the local engine to the target;public void recoverToTarget(ActionListener<RecoveryResponse> listener) {_        final List<Closeable> resources = new CopyOnWriteArrayList<>()__        final Closeable releaseResources = () -> IOUtils.close(resources)__        final ActionListener<RecoveryResponse> wrappedListener = ActionListener.notifyOnce(listener)__        try {_            cancellableThreads.setOnCancel((reason, beforeCancelEx) -> {_                final RuntimeException e__                if (shard.state() == IndexShardState.CLOSED) { _                    e = new IndexShardClosedException(shard.shardId(), "shard is closed and recovery was canceled reason [" + reason + "]")__                } else {_                    e = new CancellableThreads.ExecutionCancelledException("recovery was canceled reason [" + reason + "]")__                }_                if (beforeCancelEx != null) {_                    e.addSuppressed(beforeCancelEx)__                }_                IOUtils.closeWhileHandlingException(releaseResources, () -> wrappedListener.onFailure(e))__                throw e__            })__            final Consumer<Exception> onFailure = e ->_                IOUtils.closeWhileHandlingException(releaseResources, () -> wrappedListener.onFailure(e))___            runUnderPrimaryPermit(() -> {_                final IndexShardRoutingTable routingTable = shard.getReplicationGroup().getRoutingTable()__                ShardRouting targetShardRouting = routingTable.getByAllocationId(request.targetAllocationId())__                if (targetShardRouting == null) {_                    logger.debug("delaying recovery of {} as it is not listed as assigned to target node {}", request.shardId(),_                        request.targetNode())__                    throw new DelayRecoveryException("source node does not have the shard listed in its state as allocated on the node")__                }_                assert targetShardRouting.initializing() : "expected recovery target to be initializing but was " + targetShardRouting__            }, shardId + " validating recovery target ["+ request.targetAllocationId() + "] registered ",_                shard, cancellableThreads, logger)__            final Closeable retentionLock = shard.acquireRetentionLock()__            resources.add(retentionLock)__            final long startingSeqNo__            final long requiredSeqNoRangeStart__            final boolean isSequenceNumberBasedRecovery = request.startingSeqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                isTargetSameHistory() && shard.hasCompleteHistoryOperations("peer-recovery", request.startingSeqNo())__            final SendFileResult sendFileResult__            if (isSequenceNumberBasedRecovery) {_                logger.trace("performing sequence numbers based recovery. starting at [{}]", request.startingSeqNo())__                startingSeqNo = request.startingSeqNo()__                requiredSeqNoRangeStart = startingSeqNo__                sendFileResult = SendFileResult.EMPTY__            } else {_                final Engine.IndexCommitRef phase1Snapshot__                try {_                    phase1Snapshot = shard.acquireSafeIndexCommit()__                } catch (final Exception e) {_                    throw new RecoveryEngineException(shard.shardId(), 1, "snapshot failed", e)__                }_                _                requiredSeqNoRangeStart =_                    Long.parseLong(phase1Snapshot.getIndexCommit().getUserData().get(SequenceNumbers.LOCAL_CHECKPOINT_KEY)) + 1__                _                _                startingSeqNo = 0__                try {_                    final int estimateNumOps = shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo)__                    sendFileResult = phase1(phase1Snapshot.getIndexCommit(), () -> estimateNumOps)__                } catch (final Exception e) {_                    throw new RecoveryEngineException(shard.shardId(), 1, "phase1 failed", e)__                } finally {_                    try {_                        IOUtils.close(phase1Snapshot)__                    } catch (final IOException ex) {_                        logger.warn("releasing snapshot caused exception", ex)__                    }_                }_            }_            assert startingSeqNo >= 0 : "startingSeqNo must be non negative. got: " + startingSeqNo__            assert requiredSeqNoRangeStart >= startingSeqNo : "requiredSeqNoRangeStart [" + requiredSeqNoRangeStart + "] is lower than ["_                + startingSeqNo + "]"___            final StepListener<TimeValue> prepareEngineStep = new StepListener<>()__            _            prepareTargetForTranslog(isSequenceNumberBasedRecovery == false,_                shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo), prepareEngineStep)__            final StepListener<SendSnapshotResult> sendSnapshotStep = new StepListener<>()__            prepareEngineStep.whenComplete(prepareEngineTime -> {_                _                runUnderPrimaryPermit(() -> shard.initiateTracking(request.targetAllocationId()),_                    shardId + " initiating tracking of " + request.targetAllocationId(), shard, cancellableThreads, logger)___                final long endingSeqNo = shard.seqNoStats().getMaxSeqNo()__                _                cancellableThreads.execute(() -> shard.waitForOpsToComplete(endingSeqNo))__                if (logger.isTraceEnabled()) {_                    logger.trace("all operations up to [{}] completed, which will be used as an ending sequence number", endingSeqNo)__                    logger.trace("snapshot translog for recovery_ current size is [{}]",_                        shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo))__                }_                final Translog.Snapshot phase2Snapshot = shard.getHistoryOperations("peer-recovery", startingSeqNo)__                resources.add(phase2Snapshot)__                _                retentionLock.close()__                _                _                final long maxSeenAutoIdTimestamp = shard.getMaxSeenAutoIdTimestamp()__                final long maxSeqNoOfUpdatesOrDeletes = shard.getMaxSeqNoOfUpdatesOrDeletes()__                final RetentionLeases retentionLeases = shard.getRetentionLeases()__                phase2(_                        startingSeqNo,_                        requiredSeqNoRangeStart,_                        endingSeqNo,_                        phase2Snapshot,_                        maxSeenAutoIdTimestamp,_                        maxSeqNoOfUpdatesOrDeletes,_                        retentionLeases,_                        sendSnapshotStep)__                sendSnapshotStep.whenComplete(_                    r -> IOUtils.close(phase2Snapshot),_                    e -> {_                        IOUtils.closeWhileHandlingException(phase2Snapshot)__                        onFailure.accept(new RecoveryEngineException(shard.shardId(), 2, "phase2 failed", e))__                    })___            }, onFailure)___            final StepListener<Void> finalizeStep = new StepListener<>()__            sendSnapshotStep.whenComplete(r -> finalizeRecovery(r.targetLocalCheckpoint, finalizeStep), onFailure)___            finalizeStep.whenComplete(r -> {_                final long phase1ThrottlingWaitTime = 0L_ _                final SendSnapshotResult sendSnapshotResult = sendSnapshotStep.result()__                final RecoveryResponse response = new RecoveryResponse(sendFileResult.phase1FileNames, sendFileResult.phase1FileSizes,_                    sendFileResult.phase1ExistingFileNames, sendFileResult.phase1ExistingFileSizes, sendFileResult.totalSize,_                    sendFileResult.existingTotalSize, sendFileResult.took.millis(), phase1ThrottlingWaitTime,_                    prepareEngineStep.result().millis(), sendSnapshotResult.totalOperations, sendSnapshotResult.tookTime.millis())__                try {_                    wrappedListener.onResponse(response)__                } finally {_                    IOUtils.close(resources)__                }_            }, onFailure)__        } catch (Exception e) {_            IOUtils.closeWhileHandlingException(releaseResources, () -> wrappedListener.onFailure(e))__        }_    };performs,the,recovery,from,the,local,engine,to,the,target;public,void,recover,to,target,action,listener,recovery,response,listener,final,list,closeable,resources,new,copy,on,write,array,list,final,closeable,release,resources,ioutils,close,resources,final,action,listener,recovery,response,wrapped,listener,action,listener,notify,once,listener,try,cancellable,threads,set,on,cancel,reason,before,cancel,ex,final,runtime,exception,e,if,shard,state,index,shard,state,closed,e,new,index,shard,closed,exception,shard,shard,id,shard,is,closed,and,recovery,was,canceled,reason,reason,else,e,new,cancellable,threads,execution,cancelled,exception,recovery,was,canceled,reason,reason,if,before,cancel,ex,null,e,add,suppressed,before,cancel,ex,ioutils,close,while,handling,exception,release,resources,wrapped,listener,on,failure,e,throw,e,final,consumer,exception,on,failure,e,ioutils,close,while,handling,exception,release,resources,wrapped,listener,on,failure,e,run,under,primary,permit,final,index,shard,routing,table,routing,table,shard,get,replication,group,get,routing,table,shard,routing,target,shard,routing,routing,table,get,by,allocation,id,request,target,allocation,id,if,target,shard,routing,null,logger,debug,delaying,recovery,of,as,it,is,not,listed,as,assigned,to,target,node,request,shard,id,request,target,node,throw,new,delay,recovery,exception,source,node,does,not,have,the,shard,listed,in,its,state,as,allocated,on,the,node,assert,target,shard,routing,initializing,expected,recovery,target,to,be,initializing,but,was,target,shard,routing,shard,id,validating,recovery,target,request,target,allocation,id,registered,shard,cancellable,threads,logger,final,closeable,retention,lock,shard,acquire,retention,lock,resources,add,retention,lock,final,long,starting,seq,no,final,long,required,seq,no,range,start,final,boolean,is,sequence,number,based,recovery,request,starting,seq,no,sequence,numbers,is,target,same,history,shard,has,complete,history,operations,peer,recovery,request,starting,seq,no,final,send,file,result,send,file,result,if,is,sequence,number,based,recovery,logger,trace,performing,sequence,numbers,based,recovery,starting,at,request,starting,seq,no,starting,seq,no,request,starting,seq,no,required,seq,no,range,start,starting,seq,no,send,file,result,send,file,result,empty,else,final,engine,index,commit,ref,phase1snapshot,try,phase1snapshot,shard,acquire,safe,index,commit,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,snapshot,failed,e,required,seq,no,range,start,long,parse,long,phase1snapshot,get,index,commit,get,user,data,get,sequence,numbers,1,starting,seq,no,0,try,final,int,estimate,num,ops,shard,estimate,number,of,history,operations,peer,recovery,starting,seq,no,send,file,result,phase1,phase1snapshot,get,index,commit,estimate,num,ops,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,phase1,failed,e,finally,try,ioutils,close,phase1snapshot,catch,final,ioexception,ex,logger,warn,releasing,snapshot,caused,exception,ex,assert,starting,seq,no,0,starting,seq,no,must,be,non,negative,got,starting,seq,no,assert,required,seq,no,range,start,starting,seq,no,required,seq,no,range,start,required,seq,no,range,start,is,lower,than,starting,seq,no,final,step,listener,time,value,prepare,engine,step,new,step,listener,prepare,target,for,translog,is,sequence,number,based,recovery,false,shard,estimate,number,of,history,operations,peer,recovery,starting,seq,no,prepare,engine,step,final,step,listener,send,snapshot,result,send,snapshot,step,new,step,listener,prepare,engine,step,when,complete,prepare,engine,time,run,under,primary,permit,shard,initiate,tracking,request,target,allocation,id,shard,id,initiating,tracking,of,request,target,allocation,id,shard,cancellable,threads,logger,final,long,ending,seq,no,shard,seq,no,stats,get,max,seq,no,cancellable,threads,execute,shard,wait,for,ops,to,complete,ending,seq,no,if,logger,is,trace,enabled,logger,trace,all,operations,up,to,completed,which,will,be,used,as,an,ending,sequence,number,ending,seq,no,logger,trace,snapshot,translog,for,recovery,current,size,is,shard,estimate,number,of,history,operations,peer,recovery,starting,seq,no,final,translog,snapshot,phase2snapshot,shard,get,history,operations,peer,recovery,starting,seq,no,resources,add,phase2snapshot,retention,lock,close,final,long,max,seen,auto,id,timestamp,shard,get,max,seen,auto,id,timestamp,final,long,max,seq,no,of,updates,or,deletes,shard,get,max,seq,no,of,updates,or,deletes,final,retention,leases,retention,leases,shard,get,retention,leases,phase2,starting,seq,no,required,seq,no,range,start,ending,seq,no,phase2snapshot,max,seen,auto,id,timestamp,max,seq,no,of,updates,or,deletes,retention,leases,send,snapshot,step,send,snapshot,step,when,complete,r,ioutils,close,phase2snapshot,e,ioutils,close,while,handling,exception,phase2snapshot,on,failure,accept,new,recovery,engine,exception,shard,shard,id,2,phase2,failed,e,on,failure,final,step,listener,void,finalize,step,new,step,listener,send,snapshot,step,when,complete,r,finalize,recovery,r,target,local,checkpoint,finalize,step,on,failure,finalize,step,when,complete,r,final,long,phase1throttling,wait,time,0l,final,send,snapshot,result,send,snapshot,result,send,snapshot,step,result,final,recovery,response,response,new,recovery,response,send,file,result,phase1file,names,send,file,result,phase1file,sizes,send,file,result,phase1existing,file,names,send,file,result,phase1existing,file,sizes,send,file,result,total,size,send,file,result,existing,total,size,send,file,result,took,millis,phase1throttling,wait,time,prepare,engine,step,result,millis,send,snapshot,result,total,operations,send,snapshot,result,took,time,millis,try,wrapped,listener,on,response,response,finally,ioutils,close,resources,on,failure,catch,exception,e,ioutils,close,while,handling,exception,release,resources,wrapped,listener,on,failure,e
RecoverySourceHandler -> public void recoverToTarget(ActionListener<RecoveryResponse> listener);1551110274;performs the recovery from the local engine to the target;public void recoverToTarget(ActionListener<RecoveryResponse> listener) {_        final List<Closeable> resources = new CopyOnWriteArrayList<>()__        final Closeable releaseResources = () -> IOUtils.close(resources)__        final ActionListener<RecoveryResponse> wrappedListener = ActionListener.notifyOnce(listener)__        try {_            cancellableThreads.setOnCancel((reason, beforeCancelEx) -> {_                final RuntimeException e__                if (shard.state() == IndexShardState.CLOSED) { _                    e = new IndexShardClosedException(shard.shardId(), "shard is closed and recovery was canceled reason [" + reason + "]")__                } else {_                    e = new CancellableThreads.ExecutionCancelledException("recovery was canceled reason [" + reason + "]")__                }_                if (beforeCancelEx != null) {_                    e.addSuppressed(beforeCancelEx)__                }_                IOUtils.closeWhileHandlingException(releaseResources, () -> wrappedListener.onFailure(e))__                throw e__            })__            final Consumer<Exception> onFailure = e ->_                IOUtils.closeWhileHandlingException(releaseResources, () -> wrappedListener.onFailure(e))___            runUnderPrimaryPermit(() -> {_                final IndexShardRoutingTable routingTable = shard.getReplicationGroup().getRoutingTable()__                ShardRouting targetShardRouting = routingTable.getByAllocationId(request.targetAllocationId())__                if (targetShardRouting == null) {_                    logger.debug("delaying recovery of {} as it is not listed as assigned to target node {}", request.shardId(),_                        request.targetNode())__                    throw new DelayRecoveryException("source node does not have the shard listed in its state as allocated on the node")__                }_                assert targetShardRouting.initializing() : "expected recovery target to be initializing but was " + targetShardRouting__            }, shardId + " validating recovery target ["+ request.targetAllocationId() + "] registered ",_                shard, cancellableThreads, logger)__            final Closeable retentionLock = shard.acquireRetentionLock()__            resources.add(retentionLock)__            final long startingSeqNo__            final boolean isSequenceNumberBasedRecovery = request.startingSeqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                isTargetSameHistory() && shard.hasCompleteHistoryOperations("peer-recovery", request.startingSeqNo())__            final SendFileResult sendFileResult__            if (isSequenceNumberBasedRecovery) {_                logger.trace("performing sequence numbers based recovery. starting at [{}]", request.startingSeqNo())__                startingSeqNo = request.startingSeqNo()__                sendFileResult = SendFileResult.EMPTY__            } else {_                final Engine.IndexCommitRef phase1Snapshot__                try {_                    phase1Snapshot = shard.acquireSafeIndexCommit()__                } catch (final Exception e) {_                    throw new RecoveryEngineException(shard.shardId(), 1, "snapshot failed", e)__                }_                _                _                startingSeqNo = 0__                try {_                    final int estimateNumOps = shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo)__                    sendFileResult = phase1(phase1Snapshot.getIndexCommit(), () -> estimateNumOps)__                } catch (final Exception e) {_                    throw new RecoveryEngineException(shard.shardId(), 1, "phase1 failed", e)__                } finally {_                    try {_                        IOUtils.close(phase1Snapshot)__                    } catch (final IOException ex) {_                        logger.warn("releasing snapshot caused exception", ex)__                    }_                }_            }_            assert startingSeqNo >= 0 : "startingSeqNo must be non negative. got: " + startingSeqNo___            final StepListener<TimeValue> prepareEngineStep = new StepListener<>()__            _            prepareTargetForTranslog(isSequenceNumberBasedRecovery == false,_                shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo), prepareEngineStep)__            final StepListener<SendSnapshotResult> sendSnapshotStep = new StepListener<>()__            prepareEngineStep.whenComplete(prepareEngineTime -> {_                _                runUnderPrimaryPermit(() -> shard.initiateTracking(request.targetAllocationId()),_                    shardId + " initiating tracking of " + request.targetAllocationId(), shard, cancellableThreads, logger)___                final long endingSeqNo = shard.seqNoStats().getMaxSeqNo()__                if (logger.isTraceEnabled()) {_                    logger.trace("snapshot translog for recovery_ current size is [{}]",_                        shard.estimateNumberOfHistoryOperations("peer-recovery", startingSeqNo))__                }_                final Translog.Snapshot phase2Snapshot = shard.getHistoryOperations("peer-recovery", startingSeqNo)__                resources.add(phase2Snapshot)__                _                retentionLock.close()__                _                _                final long maxSeenAutoIdTimestamp = shard.getMaxSeenAutoIdTimestamp()__                final long maxSeqNoOfUpdatesOrDeletes = shard.getMaxSeqNoOfUpdatesOrDeletes()__                final RetentionLeases retentionLeases = shard.getRetentionLeases()__                phase2(startingSeqNo, endingSeqNo, phase2Snapshot, maxSeenAutoIdTimestamp, maxSeqNoOfUpdatesOrDeletes,_                    retentionLeases, sendSnapshotStep)__                sendSnapshotStep.whenComplete(_                    r -> IOUtils.close(phase2Snapshot),_                    e -> {_                        IOUtils.closeWhileHandlingException(phase2Snapshot)__                        onFailure.accept(new RecoveryEngineException(shard.shardId(), 2, "phase2 failed", e))__                    })___            }, onFailure)___            final StepListener<Void> finalizeStep = new StepListener<>()__            sendSnapshotStep.whenComplete(r -> finalizeRecovery(r.targetLocalCheckpoint, finalizeStep), onFailure)___            finalizeStep.whenComplete(r -> {_                final long phase1ThrottlingWaitTime = 0L_ _                final SendSnapshotResult sendSnapshotResult = sendSnapshotStep.result()__                final RecoveryResponse response = new RecoveryResponse(sendFileResult.phase1FileNames, sendFileResult.phase1FileSizes,_                    sendFileResult.phase1ExistingFileNames, sendFileResult.phase1ExistingFileSizes, sendFileResult.totalSize,_                    sendFileResult.existingTotalSize, sendFileResult.took.millis(), phase1ThrottlingWaitTime,_                    prepareEngineStep.result().millis(), sendSnapshotResult.totalOperations, sendSnapshotResult.tookTime.millis())__                try {_                    wrappedListener.onResponse(response)__                } finally {_                    IOUtils.close(resources)__                }_            }, onFailure)__        } catch (Exception e) {_            IOUtils.closeWhileHandlingException(releaseResources, () -> wrappedListener.onFailure(e))__        }_    };performs,the,recovery,from,the,local,engine,to,the,target;public,void,recover,to,target,action,listener,recovery,response,listener,final,list,closeable,resources,new,copy,on,write,array,list,final,closeable,release,resources,ioutils,close,resources,final,action,listener,recovery,response,wrapped,listener,action,listener,notify,once,listener,try,cancellable,threads,set,on,cancel,reason,before,cancel,ex,final,runtime,exception,e,if,shard,state,index,shard,state,closed,e,new,index,shard,closed,exception,shard,shard,id,shard,is,closed,and,recovery,was,canceled,reason,reason,else,e,new,cancellable,threads,execution,cancelled,exception,recovery,was,canceled,reason,reason,if,before,cancel,ex,null,e,add,suppressed,before,cancel,ex,ioutils,close,while,handling,exception,release,resources,wrapped,listener,on,failure,e,throw,e,final,consumer,exception,on,failure,e,ioutils,close,while,handling,exception,release,resources,wrapped,listener,on,failure,e,run,under,primary,permit,final,index,shard,routing,table,routing,table,shard,get,replication,group,get,routing,table,shard,routing,target,shard,routing,routing,table,get,by,allocation,id,request,target,allocation,id,if,target,shard,routing,null,logger,debug,delaying,recovery,of,as,it,is,not,listed,as,assigned,to,target,node,request,shard,id,request,target,node,throw,new,delay,recovery,exception,source,node,does,not,have,the,shard,listed,in,its,state,as,allocated,on,the,node,assert,target,shard,routing,initializing,expected,recovery,target,to,be,initializing,but,was,target,shard,routing,shard,id,validating,recovery,target,request,target,allocation,id,registered,shard,cancellable,threads,logger,final,closeable,retention,lock,shard,acquire,retention,lock,resources,add,retention,lock,final,long,starting,seq,no,final,boolean,is,sequence,number,based,recovery,request,starting,seq,no,sequence,numbers,is,target,same,history,shard,has,complete,history,operations,peer,recovery,request,starting,seq,no,final,send,file,result,send,file,result,if,is,sequence,number,based,recovery,logger,trace,performing,sequence,numbers,based,recovery,starting,at,request,starting,seq,no,starting,seq,no,request,starting,seq,no,send,file,result,send,file,result,empty,else,final,engine,index,commit,ref,phase1snapshot,try,phase1snapshot,shard,acquire,safe,index,commit,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,snapshot,failed,e,starting,seq,no,0,try,final,int,estimate,num,ops,shard,estimate,number,of,history,operations,peer,recovery,starting,seq,no,send,file,result,phase1,phase1snapshot,get,index,commit,estimate,num,ops,catch,final,exception,e,throw,new,recovery,engine,exception,shard,shard,id,1,phase1,failed,e,finally,try,ioutils,close,phase1snapshot,catch,final,ioexception,ex,logger,warn,releasing,snapshot,caused,exception,ex,assert,starting,seq,no,0,starting,seq,no,must,be,non,negative,got,starting,seq,no,final,step,listener,time,value,prepare,engine,step,new,step,listener,prepare,target,for,translog,is,sequence,number,based,recovery,false,shard,estimate,number,of,history,operations,peer,recovery,starting,seq,no,prepare,engine,step,final,step,listener,send,snapshot,result,send,snapshot,step,new,step,listener,prepare,engine,step,when,complete,prepare,engine,time,run,under,primary,permit,shard,initiate,tracking,request,target,allocation,id,shard,id,initiating,tracking,of,request,target,allocation,id,shard,cancellable,threads,logger,final,long,ending,seq,no,shard,seq,no,stats,get,max,seq,no,if,logger,is,trace,enabled,logger,trace,snapshot,translog,for,recovery,current,size,is,shard,estimate,number,of,history,operations,peer,recovery,starting,seq,no,final,translog,snapshot,phase2snapshot,shard,get,history,operations,peer,recovery,starting,seq,no,resources,add,phase2snapshot,retention,lock,close,final,long,max,seen,auto,id,timestamp,shard,get,max,seen,auto,id,timestamp,final,long,max,seq,no,of,updates,or,deletes,shard,get,max,seq,no,of,updates,or,deletes,final,retention,leases,retention,leases,shard,get,retention,leases,phase2,starting,seq,no,ending,seq,no,phase2snapshot,max,seen,auto,id,timestamp,max,seq,no,of,updates,or,deletes,retention,leases,send,snapshot,step,send,snapshot,step,when,complete,r,ioutils,close,phase2snapshot,e,ioutils,close,while,handling,exception,phase2snapshot,on,failure,accept,new,recovery,engine,exception,shard,shard,id,2,phase2,failed,e,on,failure,final,step,listener,void,finalize,step,new,step,listener,send,snapshot,step,when,complete,r,finalize,recovery,r,target,local,checkpoint,finalize,step,on,failure,finalize,step,when,complete,r,final,long,phase1throttling,wait,time,0l,final,send,snapshot,result,send,snapshot,result,send,snapshot,step,result,final,recovery,response,response,new,recovery,response,send,file,result,phase1file,names,send,file,result,phase1file,sizes,send,file,result,phase1existing,file,names,send,file,result,phase1existing,file,sizes,send,file,result,total,size,send,file,result,existing,total,size,send,file,result,took,millis,phase1throttling,wait,time,prepare,engine,step,result,millis,send,snapshot,result,total,operations,send,snapshot,result,took,time,millis,try,wrapped,listener,on,response,response,finally,ioutils,close,resources,on,failure,catch,exception,e,ioutils,close,while,handling,exception,release,resources,wrapped,listener,on,failure,e
RecoverySourceHandler -> public void cancel(String reason);1524684173;Cancels the recovery and interrupts all eligible threads.;public void cancel(String reason) {_        cancellableThreads.cancel(reason)__    };cancels,the,recovery,and,interrupts,all,eligible,threads;public,void,cancel,string,reason,cancellable,threads,cancel,reason
RecoverySourceHandler -> public void cancel(String reason);1525334055;Cancels the recovery and interrupts all eligible threads.;public void cancel(String reason) {_        cancellableThreads.cancel(reason)__    };cancels,the,recovery,and,interrupts,all,eligible,threads;public,void,cancel,string,reason,cancellable,threads,cancel,reason
RecoverySourceHandler -> public void cancel(String reason);1528706846;Cancels the recovery and interrupts all eligible threads.;public void cancel(String reason) {_        cancellableThreads.cancel(reason)__    };cancels,the,recovery,and,interrupts,all,eligible,threads;public,void,cancel,string,reason,cancellable,threads,cancel,reason
RecoverySourceHandler -> public void cancel(String reason);1529658035;Cancels the recovery and interrupts all eligible threads.;public void cancel(String reason) {_        cancellableThreads.cancel(reason)__    };cancels,the,recovery,and,interrupts,all,eligible,threads;public,void,cancel,string,reason,cancellable,threads,cancel,reason
RecoverySourceHandler -> public void cancel(String reason);1533295538;Cancels the recovery and interrupts all eligible threads.;public void cancel(String reason) {_        cancellableThreads.cancel(reason)__    };cancels,the,recovery,and,interrupts,all,eligible,threads;public,void,cancel,string,reason,cancellable,threads,cancel,reason
RecoverySourceHandler -> public void cancel(String reason);1535723122;Cancels the recovery and interrupts all eligible threads.;public void cancel(String reason) {_        cancellableThreads.cancel(reason)__    };cancels,the,recovery,and,interrupts,all,eligible,threads;public,void,cancel,string,reason,cancellable,threads,cancel,reason
RecoverySourceHandler -> public void cancel(String reason);1535965276;Cancels the recovery and interrupts all eligible threads.;public void cancel(String reason) {_        cancellableThreads.cancel(reason)__    };cancels,the,recovery,and,interrupts,all,eligible,threads;public,void,cancel,string,reason,cancellable,threads,cancel,reason
RecoverySourceHandler -> public void cancel(String reason);1537806831;Cancels the recovery and interrupts all eligible threads.;public void cancel(String reason) {_        cancellableThreads.cancel(reason)__    };cancels,the,recovery,and,interrupts,all,eligible,threads;public,void,cancel,string,reason,cancellable,threads,cancel,reason
RecoverySourceHandler -> public void cancel(String reason);1538067637;Cancels the recovery and interrupts all eligible threads.;public void cancel(String reason) {_        cancellableThreads.cancel(reason)__    };cancels,the,recovery,and,interrupts,all,eligible,threads;public,void,cancel,string,reason,cancellable,threads,cancel,reason
RecoverySourceHandler -> public void cancel(String reason);1546446953;Cancels the recovery and interrupts all eligible threads.;public void cancel(String reason) {_        cancellableThreads.cancel(reason)__    };cancels,the,recovery,and,interrupts,all,eligible,threads;public,void,cancel,string,reason,cancellable,threads,cancel,reason
RecoverySourceHandler -> public void cancel(String reason);1546981938;Cancels the recovery and interrupts all eligible threads.;public void cancel(String reason) {_        cancellableThreads.cancel(reason)__    };cancels,the,recovery,and,interrupts,all,eligible,threads;public,void,cancel,string,reason,cancellable,threads,cancel,reason
RecoverySourceHandler -> public void cancel(String reason);1547315388;Cancels the recovery and interrupts all eligible threads.;public void cancel(String reason) {_        cancellableThreads.cancel(reason)__    };cancels,the,recovery,and,interrupts,all,eligible,threads;public,void,cancel,string,reason,cancellable,threads,cancel,reason
RecoverySourceHandler -> public void cancel(String reason);1547496886;Cancels the recovery and interrupts all eligible threads.;public void cancel(String reason) {_        cancellableThreads.cancel(reason)__    };cancels,the,recovery,and,interrupts,all,eligible,threads;public,void,cancel,string,reason,cancellable,threads,cancel,reason
RecoverySourceHandler -> public void cancel(String reason);1547508054;Cancels the recovery and interrupts all eligible threads.;public void cancel(String reason) {_        cancellableThreads.cancel(reason)__    };cancels,the,recovery,and,interrupts,all,eligible,threads;public,void,cancel,string,reason,cancellable,threads,cancel,reason
RecoverySourceHandler -> public void cancel(String reason);1547569135;Cancels the recovery and interrupts all eligible threads.;public void cancel(String reason) {_        cancellableThreads.cancel(reason)__    };cancels,the,recovery,and,interrupts,all,eligible,threads;public,void,cancel,string,reason,cancellable,threads,cancel,reason
RecoverySourceHandler -> public void cancel(String reason);1547576245;Cancels the recovery and interrupts all eligible threads.;public void cancel(String reason) {_        cancellableThreads.cancel(reason)__    };cancels,the,recovery,and,interrupts,all,eligible,threads;public,void,cancel,string,reason,cancellable,threads,cancel,reason
RecoverySourceHandler -> public void cancel(String reason);1547737145;Cancels the recovery and interrupts all eligible threads.;public void cancel(String reason) {_        cancellableThreads.cancel(reason)__    };cancels,the,recovery,and,interrupts,all,eligible,threads;public,void,cancel,string,reason,cancellable,threads,cancel,reason
RecoverySourceHandler -> public void cancel(String reason);1548124510;Cancels the recovery and interrupts all eligible threads.;public void cancel(String reason) {_        cancellableThreads.cancel(reason)__    };cancels,the,recovery,and,interrupts,all,eligible,threads;public,void,cancel,string,reason,cancellable,threads,cancel,reason
RecoverySourceHandler -> public void cancel(String reason);1549406621;Cancels the recovery and interrupts all eligible threads.;public void cancel(String reason) {_        cancellableThreads.cancel(reason)__    };cancels,the,recovery,and,interrupts,all,eligible,threads;public,void,cancel,string,reason,cancellable,threads,cancel,reason
RecoverySourceHandler -> public void cancel(String reason);1549975032;Cancels the recovery and interrupts all eligible threads.;public void cancel(String reason) {_        cancellableThreads.cancel(reason)__    };cancels,the,recovery,and,interrupts,all,eligible,threads;public,void,cancel,string,reason,cancellable,threads,cancel,reason
RecoverySourceHandler -> public void cancel(String reason);1550220204;Cancels the recovery and interrupts all eligible threads.;public void cancel(String reason) {_        cancellableThreads.cancel(reason)__    };cancels,the,recovery,and,interrupts,all,eligible,threads;public,void,cancel,string,reason,cancellable,threads,cancel,reason
RecoverySourceHandler -> public void cancel(String reason);1551110274;Cancels the recovery and interrupts all eligible threads.;public void cancel(String reason) {_        cancellableThreads.cancel(reason)__    };cancels,the,recovery,and,interrupts,all,eligible,threads;public,void,cancel,string,reason,cancellable,threads,cancel,reason
RecoverySourceHandler -> void phase2(             final long startingSeqNo,             final long requiredSeqNoRangeStart,             final long endingSeqNo,             final Translog.Snapshot snapshot,             final long maxSeenAutoIdTimestamp,             final long maxSeqNoOfUpdatesOrDeletes,             final RetentionLeases retentionLeases,             final ActionListener<SendSnapshotResult> listener) throws IOException;1549406621;Perform phase two of the recovery process._<p>_Phase two uses a snapshot of the current translog *without* acquiring the write lock (however, the translog snapshot is_point-in-time view of the translog). It then sends each translog operation to the target node so it can be replayed into the new_shard.__@param startingSeqNo              the sequence number to start recovery from, or {@link SequenceNumbers#UNASSIGNED_SEQ_NO} if all_ops should be sent_@param requiredSeqNoRangeStart    the lower sequence number of the required range (ending with endingSeqNo)_@param endingSeqNo                the highest sequence number that should be sent_@param snapshot                   a snapshot of the translog_@param maxSeenAutoIdTimestamp     the max auto_id_timestamp of append-only requests on the primary_@param maxSeqNoOfUpdatesOrDeletes the max seq_no of updates or deletes on the primary after these operations were executed on it._@param listener                   a listener which will be notified with the local checkpoint on the target.;void phase2(_            final long startingSeqNo,_            final long requiredSeqNoRangeStart,_            final long endingSeqNo,_            final Translog.Snapshot snapshot,_            final long maxSeenAutoIdTimestamp,_            final long maxSeqNoOfUpdatesOrDeletes,_            final RetentionLeases retentionLeases,_            final ActionListener<SendSnapshotResult> listener) throws IOException {_        assert requiredSeqNoRangeStart <= endingSeqNo + 1:_            "requiredSeqNoRangeStart " + requiredSeqNoRangeStart + " is larger than endingSeqNo " + endingSeqNo__        assert startingSeqNo <= requiredSeqNoRangeStart :_            "startingSeqNo " + startingSeqNo + " is larger than requiredSeqNoRangeStart " + requiredSeqNoRangeStart__        if (shard.state() == IndexShardState.CLOSED) {_            throw new IndexShardClosedException(request.shardId())__        }_        logger.trace("recovery [phase2]: sending transaction log operations (seq# from [" +  startingSeqNo  + "], " +_            "required [" + requiredSeqNoRangeStart + ":" + endingSeqNo + "]")___        final AtomicInteger skippedOps = new AtomicInteger()__        final AtomicInteger totalSentOps = new AtomicInteger()__        final LocalCheckpointTracker requiredOpsTracker = new LocalCheckpointTracker(endingSeqNo, requiredSeqNoRangeStart - 1)__        final AtomicInteger lastBatchCount = new AtomicInteger()_ _        final CheckedSupplier<List<Translog.Operation>, IOException> readNextBatch = () -> {_            _            _            synchronized (snapshot) {_                final List<Translog.Operation> ops = lastBatchCount.get() > 0 ? new ArrayList<>(lastBatchCount.get()) : new ArrayList<>()__                long batchSizeInBytes = 0L__                Translog.Operation operation__                while ((operation = snapshot.next()) != null) {_                    if (shard.state() == IndexShardState.CLOSED) {_                        throw new IndexShardClosedException(request.shardId())__                    }_                    cancellableThreads.checkForCancel()__                    final long seqNo = operation.seqNo()__                    if (seqNo < startingSeqNo || seqNo > endingSeqNo) {_                        skippedOps.incrementAndGet()__                        continue__                    }_                    ops.add(operation)__                    batchSizeInBytes += operation.estimateSize()__                    totalSentOps.incrementAndGet()__                    requiredOpsTracker.markSeqNoAsCompleted(seqNo)___                    _                    if (batchSizeInBytes >= chunkSizeInBytes) {_                        break__                    }_                }_                lastBatchCount.set(ops.size())__                return ops__            }_        }___        final StopWatch stopWatch = new StopWatch().start()__        final ActionListener<Long> batchedListener = ActionListener.wrap(_            targetLocalCheckpoint -> {_                assert snapshot.totalOperations() == snapshot.skippedOperations() + skippedOps.get() + totalSentOps.get()_                    : String.format(Locale.ROOT, "expected total [%d], overridden [%d], skipped [%d], total sent [%d]",_                    snapshot.totalOperations(), snapshot.skippedOperations(), skippedOps.get(), totalSentOps.get())__                if (requiredOpsTracker.getCheckpoint() < endingSeqNo) {_                    throw new IllegalStateException("translog replay failed to cover required sequence numbers" +_                        " (required range [" + requiredSeqNoRangeStart + ":" + endingSeqNo + "). first missing op is ["_                        + (requiredOpsTracker.getCheckpoint() + 1) + "]")__                }_                stopWatch.stop()__                final TimeValue tookTime = stopWatch.totalTime()__                logger.trace("recovery [phase2]: took [{}]", tookTime)__                listener.onResponse(new SendSnapshotResult(targetLocalCheckpoint, totalSentOps.get(), tookTime))__            },_            listener::onFailure_        )___        sendBatch(_                readNextBatch,_                true,_                SequenceNumbers.UNASSIGNED_SEQ_NO,_                snapshot.totalOperations(),_                maxSeenAutoIdTimestamp,_                maxSeqNoOfUpdatesOrDeletes,_                retentionLeases,_                batchedListener)__    };perform,phase,two,of,the,recovery,process,p,phase,two,uses,a,snapshot,of,the,current,translog,without,acquiring,the,write,lock,however,the,translog,snapshot,is,point,in,time,view,of,the,translog,it,then,sends,each,translog,operation,to,the,target,node,so,it,can,be,replayed,into,the,new,shard,param,starting,seq,no,the,sequence,number,to,start,recovery,from,or,link,sequence,numbers,if,all,ops,should,be,sent,param,required,seq,no,range,start,the,lower,sequence,number,of,the,required,range,ending,with,ending,seq,no,param,ending,seq,no,the,highest,sequence,number,that,should,be,sent,param,snapshot,a,snapshot,of,the,translog,param,max,seen,auto,id,timestamp,the,max,of,append,only,requests,on,the,primary,param,max,seq,no,of,updates,or,deletes,the,max,of,updates,or,deletes,on,the,primary,after,these,operations,were,executed,on,it,param,listener,a,listener,which,will,be,notified,with,the,local,checkpoint,on,the,target;void,phase2,final,long,starting,seq,no,final,long,required,seq,no,range,start,final,long,ending,seq,no,final,translog,snapshot,snapshot,final,long,max,seen,auto,id,timestamp,final,long,max,seq,no,of,updates,or,deletes,final,retention,leases,retention,leases,final,action,listener,send,snapshot,result,listener,throws,ioexception,assert,required,seq,no,range,start,ending,seq,no,1,required,seq,no,range,start,required,seq,no,range,start,is,larger,than,ending,seq,no,ending,seq,no,assert,starting,seq,no,required,seq,no,range,start,starting,seq,no,starting,seq,no,is,larger,than,required,seq,no,range,start,required,seq,no,range,start,if,shard,state,index,shard,state,closed,throw,new,index,shard,closed,exception,request,shard,id,logger,trace,recovery,phase2,sending,transaction,log,operations,seq,from,starting,seq,no,required,required,seq,no,range,start,ending,seq,no,final,atomic,integer,skipped,ops,new,atomic,integer,final,atomic,integer,total,sent,ops,new,atomic,integer,final,local,checkpoint,tracker,required,ops,tracker,new,local,checkpoint,tracker,ending,seq,no,required,seq,no,range,start,1,final,atomic,integer,last,batch,count,new,atomic,integer,final,checked,supplier,list,translog,operation,ioexception,read,next,batch,synchronized,snapshot,final,list,translog,operation,ops,last,batch,count,get,0,new,array,list,last,batch,count,get,new,array,list,long,batch,size,in,bytes,0l,translog,operation,operation,while,operation,snapshot,next,null,if,shard,state,index,shard,state,closed,throw,new,index,shard,closed,exception,request,shard,id,cancellable,threads,check,for,cancel,final,long,seq,no,operation,seq,no,if,seq,no,starting,seq,no,seq,no,ending,seq,no,skipped,ops,increment,and,get,continue,ops,add,operation,batch,size,in,bytes,operation,estimate,size,total,sent,ops,increment,and,get,required,ops,tracker,mark,seq,no,as,completed,seq,no,if,batch,size,in,bytes,chunk,size,in,bytes,break,last,batch,count,set,ops,size,return,ops,final,stop,watch,stop,watch,new,stop,watch,start,final,action,listener,long,batched,listener,action,listener,wrap,target,local,checkpoint,assert,snapshot,total,operations,snapshot,skipped,operations,skipped,ops,get,total,sent,ops,get,string,format,locale,root,expected,total,d,overridden,d,skipped,d,total,sent,d,snapshot,total,operations,snapshot,skipped,operations,skipped,ops,get,total,sent,ops,get,if,required,ops,tracker,get,checkpoint,ending,seq,no,throw,new,illegal,state,exception,translog,replay,failed,to,cover,required,sequence,numbers,required,range,required,seq,no,range,start,ending,seq,no,first,missing,op,is,required,ops,tracker,get,checkpoint,1,stop,watch,stop,final,time,value,took,time,stop,watch,total,time,logger,trace,recovery,phase2,took,took,time,listener,on,response,new,send,snapshot,result,target,local,checkpoint,total,sent,ops,get,took,time,listener,on,failure,send,batch,read,next,batch,true,sequence,numbers,snapshot,total,operations,max,seen,auto,id,timestamp,max,seq,no,of,updates,or,deletes,retention,leases,batched,listener
RecoverySourceHandler -> void phase2(             final long startingSeqNo,             final long requiredSeqNoRangeStart,             final long endingSeqNo,             final Translog.Snapshot snapshot,             final long maxSeenAutoIdTimestamp,             final long maxSeqNoOfUpdatesOrDeletes,             final RetentionLeases retentionLeases,             final ActionListener<SendSnapshotResult> listener) throws IOException;1549975032;Perform phase two of the recovery process._<p>_Phase two uses a snapshot of the current translog *without* acquiring the write lock (however, the translog snapshot is_point-in-time view of the translog). It then sends each translog operation to the target node so it can be replayed into the new_shard.__@param startingSeqNo              the sequence number to start recovery from, or {@link SequenceNumbers#UNASSIGNED_SEQ_NO} if all_ops should be sent_@param requiredSeqNoRangeStart    the lower sequence number of the required range (ending with endingSeqNo)_@param endingSeqNo                the highest sequence number that should be sent_@param snapshot                   a snapshot of the translog_@param maxSeenAutoIdTimestamp     the max auto_id_timestamp of append-only requests on the primary_@param maxSeqNoOfUpdatesOrDeletes the max seq_no of updates or deletes on the primary after these operations were executed on it._@param listener                   a listener which will be notified with the local checkpoint on the target.;void phase2(_            final long startingSeqNo,_            final long requiredSeqNoRangeStart,_            final long endingSeqNo,_            final Translog.Snapshot snapshot,_            final long maxSeenAutoIdTimestamp,_            final long maxSeqNoOfUpdatesOrDeletes,_            final RetentionLeases retentionLeases,_            final ActionListener<SendSnapshotResult> listener) throws IOException {_        assert requiredSeqNoRangeStart <= endingSeqNo + 1:_            "requiredSeqNoRangeStart " + requiredSeqNoRangeStart + " is larger than endingSeqNo " + endingSeqNo__        assert startingSeqNo <= requiredSeqNoRangeStart :_            "startingSeqNo " + startingSeqNo + " is larger than requiredSeqNoRangeStart " + requiredSeqNoRangeStart__        if (shard.state() == IndexShardState.CLOSED) {_            throw new IndexShardClosedException(request.shardId())__        }_        logger.trace("recovery [phase2]: sending transaction log operations (seq# from [" +  startingSeqNo  + "], " +_            "required [" + requiredSeqNoRangeStart + ":" + endingSeqNo + "]")___        final AtomicInteger skippedOps = new AtomicInteger()__        final AtomicInteger totalSentOps = new AtomicInteger()__        final LocalCheckpointTracker requiredOpsTracker = new LocalCheckpointTracker(endingSeqNo, requiredSeqNoRangeStart - 1)__        final AtomicInteger lastBatchCount = new AtomicInteger()_ _        final CheckedSupplier<List<Translog.Operation>, IOException> readNextBatch = () -> {_            _            _            synchronized (snapshot) {_                final List<Translog.Operation> ops = lastBatchCount.get() > 0 ? new ArrayList<>(lastBatchCount.get()) : new ArrayList<>()__                long batchSizeInBytes = 0L__                Translog.Operation operation__                while ((operation = snapshot.next()) != null) {_                    if (shard.state() == IndexShardState.CLOSED) {_                        throw new IndexShardClosedException(request.shardId())__                    }_                    cancellableThreads.checkForCancel()__                    final long seqNo = operation.seqNo()__                    if (seqNo < startingSeqNo || seqNo > endingSeqNo) {_                        skippedOps.incrementAndGet()__                        continue__                    }_                    ops.add(operation)__                    batchSizeInBytes += operation.estimateSize()__                    totalSentOps.incrementAndGet()__                    requiredOpsTracker.markSeqNoAsCompleted(seqNo)___                    _                    if (batchSizeInBytes >= chunkSizeInBytes) {_                        break__                    }_                }_                lastBatchCount.set(ops.size())__                return ops__            }_        }___        final StopWatch stopWatch = new StopWatch().start()__        final ActionListener<Long> batchedListener = ActionListener.wrap(_            targetLocalCheckpoint -> {_                assert snapshot.totalOperations() == snapshot.skippedOperations() + skippedOps.get() + totalSentOps.get()_                    : String.format(Locale.ROOT, "expected total [%d], overridden [%d], skipped [%d], total sent [%d]",_                    snapshot.totalOperations(), snapshot.skippedOperations(), skippedOps.get(), totalSentOps.get())__                if (requiredOpsTracker.getCheckpoint() < endingSeqNo) {_                    throw new IllegalStateException("translog replay failed to cover required sequence numbers" +_                        " (required range [" + requiredSeqNoRangeStart + ":" + endingSeqNo + "). first missing op is ["_                        + (requiredOpsTracker.getCheckpoint() + 1) + "]")__                }_                stopWatch.stop()__                final TimeValue tookTime = stopWatch.totalTime()__                logger.trace("recovery [phase2]: took [{}]", tookTime)__                listener.onResponse(new SendSnapshotResult(targetLocalCheckpoint, totalSentOps.get(), tookTime))__            },_            listener::onFailure_        )___        sendBatch(_                readNextBatch,_                true,_                SequenceNumbers.UNASSIGNED_SEQ_NO,_                snapshot.totalOperations(),_                maxSeenAutoIdTimestamp,_                maxSeqNoOfUpdatesOrDeletes,_                retentionLeases,_                batchedListener)__    };perform,phase,two,of,the,recovery,process,p,phase,two,uses,a,snapshot,of,the,current,translog,without,acquiring,the,write,lock,however,the,translog,snapshot,is,point,in,time,view,of,the,translog,it,then,sends,each,translog,operation,to,the,target,node,so,it,can,be,replayed,into,the,new,shard,param,starting,seq,no,the,sequence,number,to,start,recovery,from,or,link,sequence,numbers,if,all,ops,should,be,sent,param,required,seq,no,range,start,the,lower,sequence,number,of,the,required,range,ending,with,ending,seq,no,param,ending,seq,no,the,highest,sequence,number,that,should,be,sent,param,snapshot,a,snapshot,of,the,translog,param,max,seen,auto,id,timestamp,the,max,of,append,only,requests,on,the,primary,param,max,seq,no,of,updates,or,deletes,the,max,of,updates,or,deletes,on,the,primary,after,these,operations,were,executed,on,it,param,listener,a,listener,which,will,be,notified,with,the,local,checkpoint,on,the,target;void,phase2,final,long,starting,seq,no,final,long,required,seq,no,range,start,final,long,ending,seq,no,final,translog,snapshot,snapshot,final,long,max,seen,auto,id,timestamp,final,long,max,seq,no,of,updates,or,deletes,final,retention,leases,retention,leases,final,action,listener,send,snapshot,result,listener,throws,ioexception,assert,required,seq,no,range,start,ending,seq,no,1,required,seq,no,range,start,required,seq,no,range,start,is,larger,than,ending,seq,no,ending,seq,no,assert,starting,seq,no,required,seq,no,range,start,starting,seq,no,starting,seq,no,is,larger,than,required,seq,no,range,start,required,seq,no,range,start,if,shard,state,index,shard,state,closed,throw,new,index,shard,closed,exception,request,shard,id,logger,trace,recovery,phase2,sending,transaction,log,operations,seq,from,starting,seq,no,required,required,seq,no,range,start,ending,seq,no,final,atomic,integer,skipped,ops,new,atomic,integer,final,atomic,integer,total,sent,ops,new,atomic,integer,final,local,checkpoint,tracker,required,ops,tracker,new,local,checkpoint,tracker,ending,seq,no,required,seq,no,range,start,1,final,atomic,integer,last,batch,count,new,atomic,integer,final,checked,supplier,list,translog,operation,ioexception,read,next,batch,synchronized,snapshot,final,list,translog,operation,ops,last,batch,count,get,0,new,array,list,last,batch,count,get,new,array,list,long,batch,size,in,bytes,0l,translog,operation,operation,while,operation,snapshot,next,null,if,shard,state,index,shard,state,closed,throw,new,index,shard,closed,exception,request,shard,id,cancellable,threads,check,for,cancel,final,long,seq,no,operation,seq,no,if,seq,no,starting,seq,no,seq,no,ending,seq,no,skipped,ops,increment,and,get,continue,ops,add,operation,batch,size,in,bytes,operation,estimate,size,total,sent,ops,increment,and,get,required,ops,tracker,mark,seq,no,as,completed,seq,no,if,batch,size,in,bytes,chunk,size,in,bytes,break,last,batch,count,set,ops,size,return,ops,final,stop,watch,stop,watch,new,stop,watch,start,final,action,listener,long,batched,listener,action,listener,wrap,target,local,checkpoint,assert,snapshot,total,operations,snapshot,skipped,operations,skipped,ops,get,total,sent,ops,get,string,format,locale,root,expected,total,d,overridden,d,skipped,d,total,sent,d,snapshot,total,operations,snapshot,skipped,operations,skipped,ops,get,total,sent,ops,get,if,required,ops,tracker,get,checkpoint,ending,seq,no,throw,new,illegal,state,exception,translog,replay,failed,to,cover,required,sequence,numbers,required,range,required,seq,no,range,start,ending,seq,no,first,missing,op,is,required,ops,tracker,get,checkpoint,1,stop,watch,stop,final,time,value,took,time,stop,watch,total,time,logger,trace,recovery,phase2,took,took,time,listener,on,response,new,send,snapshot,result,target,local,checkpoint,total,sent,ops,get,took,time,listener,on,failure,send,batch,read,next,batch,true,sequence,numbers,snapshot,total,operations,max,seen,auto,id,timestamp,max,seq,no,of,updates,or,deletes,retention,leases,batched,listener
RecoverySourceHandler -> void phase2(             final long startingSeqNo,             final long requiredSeqNoRangeStart,             final long endingSeqNo,             final Translog.Snapshot snapshot,             final long maxSeenAutoIdTimestamp,             final long maxSeqNoOfUpdatesOrDeletes,             final RetentionLeases retentionLeases,             final ActionListener<SendSnapshotResult> listener) throws IOException;1550220204;Perform phase two of the recovery process._<p>_Phase two uses a snapshot of the current translog *without* acquiring the write lock (however, the translog snapshot is_point-in-time view of the translog). It then sends each translog operation to the target node so it can be replayed into the new_shard.__@param startingSeqNo              the sequence number to start recovery from, or {@link SequenceNumbers#UNASSIGNED_SEQ_NO} if all_ops should be sent_@param requiredSeqNoRangeStart    the lower sequence number of the required range (ending with endingSeqNo)_@param endingSeqNo                the highest sequence number that should be sent_@param snapshot                   a snapshot of the translog_@param maxSeenAutoIdTimestamp     the max auto_id_timestamp of append-only requests on the primary_@param maxSeqNoOfUpdatesOrDeletes the max seq_no of updates or deletes on the primary after these operations were executed on it._@param listener                   a listener which will be notified with the local checkpoint on the target.;void phase2(_            final long startingSeqNo,_            final long requiredSeqNoRangeStart,_            final long endingSeqNo,_            final Translog.Snapshot snapshot,_            final long maxSeenAutoIdTimestamp,_            final long maxSeqNoOfUpdatesOrDeletes,_            final RetentionLeases retentionLeases,_            final ActionListener<SendSnapshotResult> listener) throws IOException {_        assert requiredSeqNoRangeStart <= endingSeqNo + 1:_            "requiredSeqNoRangeStart " + requiredSeqNoRangeStart + " is larger than endingSeqNo " + endingSeqNo__        assert startingSeqNo <= requiredSeqNoRangeStart :_            "startingSeqNo " + startingSeqNo + " is larger than requiredSeqNoRangeStart " + requiredSeqNoRangeStart__        if (shard.state() == IndexShardState.CLOSED) {_            throw new IndexShardClosedException(request.shardId())__        }_        logger.trace("recovery [phase2]: sending transaction log operations (seq# from [" +  startingSeqNo  + "], " +_            "required [" + requiredSeqNoRangeStart + ":" + endingSeqNo + "]")___        final AtomicInteger skippedOps = new AtomicInteger()__        final AtomicInteger totalSentOps = new AtomicInteger()__        final LocalCheckpointTracker requiredOpsTracker = new LocalCheckpointTracker(endingSeqNo, requiredSeqNoRangeStart - 1)__        final AtomicInteger lastBatchCount = new AtomicInteger()_ _        final CheckedSupplier<List<Translog.Operation>, IOException> readNextBatch = () -> {_            _            _            synchronized (snapshot) {_                final List<Translog.Operation> ops = lastBatchCount.get() > 0 ? new ArrayList<>(lastBatchCount.get()) : new ArrayList<>()__                long batchSizeInBytes = 0L__                Translog.Operation operation__                while ((operation = snapshot.next()) != null) {_                    if (shard.state() == IndexShardState.CLOSED) {_                        throw new IndexShardClosedException(request.shardId())__                    }_                    cancellableThreads.checkForCancel()__                    final long seqNo = operation.seqNo()__                    if (seqNo < startingSeqNo || seqNo > endingSeqNo) {_                        skippedOps.incrementAndGet()__                        continue__                    }_                    ops.add(operation)__                    batchSizeInBytes += operation.estimateSize()__                    totalSentOps.incrementAndGet()__                    requiredOpsTracker.markSeqNoAsCompleted(seqNo)___                    _                    if (batchSizeInBytes >= chunkSizeInBytes) {_                        break__                    }_                }_                lastBatchCount.set(ops.size())__                return ops__            }_        }___        final StopWatch stopWatch = new StopWatch().start()__        final ActionListener<Long> batchedListener = ActionListener.wrap(_            targetLocalCheckpoint -> {_                assert snapshot.totalOperations() == snapshot.skippedOperations() + skippedOps.get() + totalSentOps.get()_                    : String.format(Locale.ROOT, "expected total [%d], overridden [%d], skipped [%d], total sent [%d]",_                    snapshot.totalOperations(), snapshot.skippedOperations(), skippedOps.get(), totalSentOps.get())__                if (requiredOpsTracker.getCheckpoint() < endingSeqNo) {_                    throw new IllegalStateException("translog replay failed to cover required sequence numbers" +_                        " (required range [" + requiredSeqNoRangeStart + ":" + endingSeqNo + "). first missing op is ["_                        + (requiredOpsTracker.getCheckpoint() + 1) + "]")__                }_                stopWatch.stop()__                final TimeValue tookTime = stopWatch.totalTime()__                logger.trace("recovery [phase2]: took [{}]", tookTime)__                listener.onResponse(new SendSnapshotResult(targetLocalCheckpoint, totalSentOps.get(), tookTime))__            },_            listener::onFailure_        )___        sendBatch(_                readNextBatch,_                true,_                SequenceNumbers.UNASSIGNED_SEQ_NO,_                snapshot.totalOperations(),_                maxSeenAutoIdTimestamp,_                maxSeqNoOfUpdatesOrDeletes,_                retentionLeases,_                batchedListener)__    };perform,phase,two,of,the,recovery,process,p,phase,two,uses,a,snapshot,of,the,current,translog,without,acquiring,the,write,lock,however,the,translog,snapshot,is,point,in,time,view,of,the,translog,it,then,sends,each,translog,operation,to,the,target,node,so,it,can,be,replayed,into,the,new,shard,param,starting,seq,no,the,sequence,number,to,start,recovery,from,or,link,sequence,numbers,if,all,ops,should,be,sent,param,required,seq,no,range,start,the,lower,sequence,number,of,the,required,range,ending,with,ending,seq,no,param,ending,seq,no,the,highest,sequence,number,that,should,be,sent,param,snapshot,a,snapshot,of,the,translog,param,max,seen,auto,id,timestamp,the,max,of,append,only,requests,on,the,primary,param,max,seq,no,of,updates,or,deletes,the,max,of,updates,or,deletes,on,the,primary,after,these,operations,were,executed,on,it,param,listener,a,listener,which,will,be,notified,with,the,local,checkpoint,on,the,target;void,phase2,final,long,starting,seq,no,final,long,required,seq,no,range,start,final,long,ending,seq,no,final,translog,snapshot,snapshot,final,long,max,seen,auto,id,timestamp,final,long,max,seq,no,of,updates,or,deletes,final,retention,leases,retention,leases,final,action,listener,send,snapshot,result,listener,throws,ioexception,assert,required,seq,no,range,start,ending,seq,no,1,required,seq,no,range,start,required,seq,no,range,start,is,larger,than,ending,seq,no,ending,seq,no,assert,starting,seq,no,required,seq,no,range,start,starting,seq,no,starting,seq,no,is,larger,than,required,seq,no,range,start,required,seq,no,range,start,if,shard,state,index,shard,state,closed,throw,new,index,shard,closed,exception,request,shard,id,logger,trace,recovery,phase2,sending,transaction,log,operations,seq,from,starting,seq,no,required,required,seq,no,range,start,ending,seq,no,final,atomic,integer,skipped,ops,new,atomic,integer,final,atomic,integer,total,sent,ops,new,atomic,integer,final,local,checkpoint,tracker,required,ops,tracker,new,local,checkpoint,tracker,ending,seq,no,required,seq,no,range,start,1,final,atomic,integer,last,batch,count,new,atomic,integer,final,checked,supplier,list,translog,operation,ioexception,read,next,batch,synchronized,snapshot,final,list,translog,operation,ops,last,batch,count,get,0,new,array,list,last,batch,count,get,new,array,list,long,batch,size,in,bytes,0l,translog,operation,operation,while,operation,snapshot,next,null,if,shard,state,index,shard,state,closed,throw,new,index,shard,closed,exception,request,shard,id,cancellable,threads,check,for,cancel,final,long,seq,no,operation,seq,no,if,seq,no,starting,seq,no,seq,no,ending,seq,no,skipped,ops,increment,and,get,continue,ops,add,operation,batch,size,in,bytes,operation,estimate,size,total,sent,ops,increment,and,get,required,ops,tracker,mark,seq,no,as,completed,seq,no,if,batch,size,in,bytes,chunk,size,in,bytes,break,last,batch,count,set,ops,size,return,ops,final,stop,watch,stop,watch,new,stop,watch,start,final,action,listener,long,batched,listener,action,listener,wrap,target,local,checkpoint,assert,snapshot,total,operations,snapshot,skipped,operations,skipped,ops,get,total,sent,ops,get,string,format,locale,root,expected,total,d,overridden,d,skipped,d,total,sent,d,snapshot,total,operations,snapshot,skipped,operations,skipped,ops,get,total,sent,ops,get,if,required,ops,tracker,get,checkpoint,ending,seq,no,throw,new,illegal,state,exception,translog,replay,failed,to,cover,required,sequence,numbers,required,range,required,seq,no,range,start,ending,seq,no,first,missing,op,is,required,ops,tracker,get,checkpoint,1,stop,watch,stop,final,time,value,took,time,stop,watch,total,time,logger,trace,recovery,phase2,took,took,time,listener,on,response,new,send,snapshot,result,target,local,checkpoint,total,sent,ops,get,took,time,listener,on,failure,send,batch,read,next,batch,true,sequence,numbers,snapshot,total,operations,max,seen,auto,id,timestamp,max,seq,no,of,updates,or,deletes,retention,leases,batched,listener
