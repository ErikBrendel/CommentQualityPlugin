commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;public Builder ignoreMalformed(boolean ignoreMalformed) {     this.ignoreMalformed = ignoreMalformed.     return builder. }
false;public;1;5;;@Override public Builder indexOptions(IndexOptions indexOptions) {     throw new MapperParsingException("index_options not allowed in field [" + name + "] of type [" + builder.fieldType().typeName() + "]"). }
false;protected;1;9;;protected Explicit<Boolean> ignoreMalformed(BuilderContext context) {     if (ignoreMalformed != null) {         return new Explicit<>(ignoreMalformed, true).     }     if (context.indexSettings() != null) {         return new Explicit<>(IGNORE_MALFORMED_SETTING.get(context.indexSettings()), false).     }     return Defaults.IGNORE_MALFORMED. }
false;public;1;4;;public Builder coerce(boolean coerce) {     this.coerce = coerce.     return builder. }
false;protected;1;9;;protected Explicit<Boolean> coerce(BuilderContext context) {     if (coerce != null) {         return new Explicit<>(coerce, true).     }     if (context.indexSettings() != null) {         return new Explicit<>(COERCE_SETTING.get(context.indexSettings()), false).     }     return Defaults.COERCE. }
false;protected;1;4;;@Override protected void setupFieldType(BuilderContext context) {     super.setupFieldType(context). }
false;public;1;6;;@Override public NumberFieldMapper build(BuilderContext context) {     setupFieldType(context).     return new NumberFieldMapper(name, fieldType, defaultFieldType, ignoreMalformed(context), coerce(context), context.indexSettings(), multiFieldsBuilder.build(this, context), copyTo). }
false;public;3;25;;@Override public Mapper.Builder<?, ?> parse(String name, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {     Builder builder = new Builder(name, type).     TypeParsers.parseField(builder, name, node, parserContext).     for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(). iterator.hasNext(). ) {         Map.Entry<String, Object> entry = iterator.next().         String propName = entry.getKey().         Object propNode = entry.getValue().         if (propName.equals("null_value")) {             if (propNode == null) {                 throw new MapperParsingException("Property [null_value] cannot be null.").             }             builder.nullValue(type.parse(propNode, false)).             iterator.remove().         } else if (propName.equals("ignore_malformed")) {             builder.ignoreMalformed(XContentMapValues.nodeBooleanValue(propNode, name + ".ignore_malformed")).             iterator.remove().         } else if (propName.equals("coerce")) {             builder.coerce(XContentMapValues.nodeBooleanValue(propNode, name + ".coerce")).             iterator.remove().         }     }     return builder. }
false;public;2;15;;@Override public Float parse(Object value, boolean coerce) {     final float result.     if (value instanceof Number) {         result = ((Number) value).floatValue().     } else {         if (value instanceof BytesRef) {             value = ((BytesRef) value).utf8ToString().         }         result = Float.parseFloat(value.toString()).     }     validateParsed(result).     return result. }
false;public;1;4;;@Override public Number parsePoint(byte[] value) {     return HalfFloatPoint.decodeDimension(value, 0). }
false;public;2;6;;@Override public Float parse(XContentParser parser, boolean coerce) throws IOException {     float parsed = parser.floatValue(coerce).     validateParsed(parsed).     return parsed. }
false;public;2;5;;@Override public Query termQuery(String field, Object value) {     float v = parse(value, false).     return HalfFloatPoint.newExactQuery(field, v). }
false;public;2;8;;@Override public Query termsQuery(String field, List<Object> values) {     float[] v = new float[values.size()].     for (int i = 0. i < values.size(). ++i) {         v[i] = parse(values.get(i), false).     }     return HalfFloatPoint.newSetQuery(field, v). }
false;public;6;29;;@Override public Query rangeQuery(String field, Object lowerTerm, Object upperTerm, boolean includeLower, boolean includeUpper, boolean hasDocValues) {     float l = Float.NEGATIVE_INFINITY.     float u = Float.POSITIVE_INFINITY.     if (lowerTerm != null) {         l = parse(lowerTerm, false).         if (includeLower) {             l = HalfFloatPoint.nextDown(l).         }         l = HalfFloatPoint.nextUp(l).     }     if (upperTerm != null) {         u = parse(upperTerm, false).         if (includeUpper) {             u = HalfFloatPoint.nextUp(u).         }         u = HalfFloatPoint.nextDown(u).     }     Query query = HalfFloatPoint.newRangeQuery(field, l, u).     if (hasDocValues) {         Query dvQuery = SortedNumericDocValuesField.newSlowRangeQuery(field, HalfFloatPoint.halfFloatToSortableShort(l), HalfFloatPoint.halfFloatToSortableShort(u)).         query = new IndexOrDocValuesQuery(query, dvQuery).     }     return query. }
false;public;5;16;;@Override public List<Field> createFields(String name, Number value, boolean indexed, boolean docValued, boolean stored) {     List<Field> fields = new ArrayList<>().     if (indexed) {         fields.add(new HalfFloatPoint(name, value.floatValue())).     }     if (docValued) {         fields.add(new SortedNumericDocValuesField(name, HalfFloatPoint.halfFloatToSortableShort(value.floatValue()))).     }     if (stored) {         fields.add(new StoredField(name, value.floatValue())).     }     return fields. }
false;private;1;5;;private void validateParsed(float value) {     if (!Float.isFinite(HalfFloatPoint.sortableShortToHalfFloat(HalfFloatPoint.halfFloatToSortableShort(value)))) {         throw new IllegalArgumentException("[half_float] supports only finite values, but got [" + value + "]").     } }
false;public;2;15;;@Override public Float parse(Object value, boolean coerce) {     final float result.     if (value instanceof Number) {         result = ((Number) value).floatValue().     } else {         if (value instanceof BytesRef) {             value = ((BytesRef) value).utf8ToString().         }         result = Float.parseFloat(value.toString()).     }     validateParsed(result).     return result. }
false;public;1;4;;@Override public Number parsePoint(byte[] value) {     return FloatPoint.decodeDimension(value, 0). }
false;public;2;6;;@Override public Float parse(XContentParser parser, boolean coerce) throws IOException {     float parsed = parser.floatValue(coerce).     validateParsed(parsed).     return parsed. }
false;public;2;5;;@Override public Query termQuery(String field, Object value) {     float v = parse(value, false).     return FloatPoint.newExactQuery(field, v). }
false;public;2;8;;@Override public Query termsQuery(String field, List<Object> values) {     float[] v = new float[values.size()].     for (int i = 0. i < values.size(). ++i) {         v[i] = parse(values.get(i), false).     }     return FloatPoint.newSetQuery(field, v). }
false;public;6;27;;@Override public Query rangeQuery(String field, Object lowerTerm, Object upperTerm, boolean includeLower, boolean includeUpper, boolean hasDocValues) {     float l = Float.NEGATIVE_INFINITY.     float u = Float.POSITIVE_INFINITY.     if (lowerTerm != null) {         l = parse(lowerTerm, false).         if (includeLower == false) {             l = FloatPoint.nextUp(l).         }     }     if (upperTerm != null) {         u = parse(upperTerm, false).         if (includeUpper == false) {             u = FloatPoint.nextDown(u).         }     }     Query query = FloatPoint.newRangeQuery(field, l, u).     if (hasDocValues) {         Query dvQuery = SortedNumericDocValuesField.newSlowRangeQuery(field, NumericUtils.floatToSortableInt(l), NumericUtils.floatToSortableInt(u)).         query = new IndexOrDocValuesQuery(query, dvQuery).     }     return query. }
false;public;5;16;;@Override public List<Field> createFields(String name, Number value, boolean indexed, boolean docValued, boolean stored) {     List<Field> fields = new ArrayList<>().     if (indexed) {         fields.add(new FloatPoint(name, value.floatValue())).     }     if (docValued) {         fields.add(new SortedNumericDocValuesField(name, NumericUtils.floatToSortableInt(value.floatValue()))).     }     if (stored) {         fields.add(new StoredField(name, value.floatValue())).     }     return fields. }
false;private;1;5;;private void validateParsed(float value) {     if (!Float.isFinite(value)) {         throw new IllegalArgumentException("[float] supports only finite values, but got [" + value + "]").     } }
false;public;2;6;;@Override public Double parse(Object value, boolean coerce) {     double parsed = objectToDouble(value).     validateParsed(parsed).     return parsed. }
false;public;1;4;;@Override public Number parsePoint(byte[] value) {     return DoublePoint.decodeDimension(value, 0). }
false;public;2;6;;@Override public Double parse(XContentParser parser, boolean coerce) throws IOException {     double parsed = parser.doubleValue(coerce).     validateParsed(parsed).     return parsed. }
false;public;2;5;;@Override public Query termQuery(String field, Object value) {     double v = parse(value, false).     return DoublePoint.newExactQuery(field, v). }
false;public;2;8;;@Override public Query termsQuery(String field, List<Object> values) {     double[] v = new double[values.size()].     for (int i = 0. i < values.size(). ++i) {         v[i] = parse(values.get(i), false).     }     return DoublePoint.newSetQuery(field, v). }
false;public;6;27;;@Override public Query rangeQuery(String field, Object lowerTerm, Object upperTerm, boolean includeLower, boolean includeUpper, boolean hasDocValues) {     double l = Double.NEGATIVE_INFINITY.     double u = Double.POSITIVE_INFINITY.     if (lowerTerm != null) {         l = parse(lowerTerm, false).         if (includeLower == false) {             l = DoublePoint.nextUp(l).         }     }     if (upperTerm != null) {         u = parse(upperTerm, false).         if (includeUpper == false) {             u = DoublePoint.nextDown(u).         }     }     Query query = DoublePoint.newRangeQuery(field, l, u).     if (hasDocValues) {         Query dvQuery = SortedNumericDocValuesField.newSlowRangeQuery(field, NumericUtils.doubleToSortableLong(l), NumericUtils.doubleToSortableLong(u)).         query = new IndexOrDocValuesQuery(query, dvQuery).     }     return query. }
false;public;5;16;;@Override public List<Field> createFields(String name, Number value, boolean indexed, boolean docValued, boolean stored) {     List<Field> fields = new ArrayList<>().     if (indexed) {         fields.add(new DoublePoint(name, value.doubleValue())).     }     if (docValued) {         fields.add(new SortedNumericDocValuesField(name, NumericUtils.doubleToSortableLong(value.doubleValue()))).     }     if (stored) {         fields.add(new StoredField(name, value.doubleValue())).     }     return fields. }
false;private;1;5;;private void validateParsed(double value) {     if (!Double.isFinite(value)) {         throw new IllegalArgumentException("[double] supports only finite values, but got [" + value + "]").     } }
false;public;2;17;;@Override public Byte parse(Object value, boolean coerce) {     double doubleValue = objectToDouble(value).     if (doubleValue < Byte.MIN_VALUE || doubleValue > Byte.MAX_VALUE) {         throw new IllegalArgumentException("Value [" + value + "] is out of range for a byte").     }     if (!coerce && doubleValue % 1 != 0) {         throw new IllegalArgumentException("Value [" + value + "] has a decimal part").     }     if (value instanceof Number) {         return ((Number) value).byteValue().     }     return (byte) doubleValue. }
false;public;1;4;;@Override public Number parsePoint(byte[] value) {     return INTEGER.parsePoint(value).byteValue(). }
false;public;2;8;;@Override public Short parse(XContentParser parser, boolean coerce) throws IOException {     int value = parser.intValue(coerce).     if (value < Byte.MIN_VALUE || value > Byte.MAX_VALUE) {         throw new IllegalArgumentException("Value [" + value + "] is out of range for a byte").     }     return (short) value. }
false;public;2;4;;@Override public Query termQuery(String field, Object value) {     return INTEGER.termQuery(field, value). }
false;public;2;4;;@Override public Query termsQuery(String field, List<Object> values) {     return INTEGER.termsQuery(field, values). }
false;public;6;6;;@Override public Query rangeQuery(String field, Object lowerTerm, Object upperTerm, boolean includeLower, boolean includeUpper, boolean hasDocValues) {     return INTEGER.rangeQuery(field, lowerTerm, upperTerm, includeLower, includeUpper, hasDocValues). }
false;public;5;5;;@Override public List<Field> createFields(String name, Number value, boolean indexed, boolean docValued, boolean stored) {     return INTEGER.createFields(name, value, indexed, docValued, stored). }
false;;1;4;;@Override Number valueForSearch(Number value) {     return value.byteValue(). }
false;public;2;17;;@Override public Short parse(Object value, boolean coerce) {     double doubleValue = objectToDouble(value).     if (doubleValue < Short.MIN_VALUE || doubleValue > Short.MAX_VALUE) {         throw new IllegalArgumentException("Value [" + value + "] is out of range for a short").     }     if (!coerce && doubleValue % 1 != 0) {         throw new IllegalArgumentException("Value [" + value + "] has a decimal part").     }     if (value instanceof Number) {         return ((Number) value).shortValue().     }     return (short) doubleValue. }
false;public;1;4;;@Override public Number parsePoint(byte[] value) {     return INTEGER.parsePoint(value).shortValue(). }
false;public;2;4;;@Override public Short parse(XContentParser parser, boolean coerce) throws IOException {     return parser.shortValue(coerce). }
false;public;2;4;;@Override public Query termQuery(String field, Object value) {     return INTEGER.termQuery(field, value). }
false;public;2;4;;@Override public Query termsQuery(String field, List<Object> values) {     return INTEGER.termsQuery(field, values). }
false;public;6;6;;@Override public Query rangeQuery(String field, Object lowerTerm, Object upperTerm, boolean includeLower, boolean includeUpper, boolean hasDocValues) {     return INTEGER.rangeQuery(field, lowerTerm, upperTerm, includeLower, includeUpper, hasDocValues). }
false;public;5;5;;@Override public List<Field> createFields(String name, Number value, boolean indexed, boolean docValued, boolean stored) {     return INTEGER.createFields(name, value, indexed, docValued, stored). }
false;;1;4;;@Override Number valueForSearch(Number value) {     return value.shortValue(). }
false;public;2;17;;@Override public Integer parse(Object value, boolean coerce) {     double doubleValue = objectToDouble(value).     if (doubleValue < Integer.MIN_VALUE || doubleValue > Integer.MAX_VALUE) {         throw new IllegalArgumentException("Value [" + value + "] is out of range for an integer").     }     if (!coerce && doubleValue % 1 != 0) {         throw new IllegalArgumentException("Value [" + value + "] has a decimal part").     }     if (value instanceof Number) {         return ((Number) value).intValue().     }     return (int) doubleValue. }
false;public;1;4;;@Override public Number parsePoint(byte[] value) {     return IntPoint.decodeDimension(value, 0). }
false;public;2;4;;@Override public Integer parse(XContentParser parser, boolean coerce) throws IOException {     return parser.intValue(coerce). }
false;public;2;8;;@Override public Query termQuery(String field, Object value) {     if (hasDecimalPart(value)) {         return Queries.newMatchNoDocsQuery("Value [" + value + "] has a decimal part").     }     int v = parse(value, true).     return IntPoint.newExactQuery(field, v). }
false;public;2;20;;@Override public Query termsQuery(String field, List<Object> values) {     int[] v = new int[values.size()].     int upTo = 0.     for (int i = 0. i < values.size(). i++) {         Object value = values.get(i).         if (!hasDecimalPart(value)) {             v[upTo++] = parse(value, true).         }     }     if (upTo == 0) {         return Queries.newMatchNoDocsQuery("All values have a decimal part").     }     if (upTo != v.length) {         v = Arrays.copyOf(v, upTo).     }     return IntPoint.newSetQuery(field, v). }
false;public;6;40;;@Override public Query rangeQuery(String field, Object lowerTerm, Object upperTerm, boolean includeLower, boolean includeUpper, boolean hasDocValues) {     int l = Integer.MIN_VALUE.     int u = Integer.MAX_VALUE.     if (lowerTerm != null) {         l = parse(lowerTerm, true).         // if the lower bound is decimal:         // - if the bound is positive then we increment it:         // if lowerTerm=1.5 then the (inclusive) bound becomes 2         // - if the bound is negative then we leave it as is:         // if lowerTerm=-1.5 then the (inclusive) bound becomes -1 due to the call to longValue         boolean lowerTermHasDecimalPart = hasDecimalPart(lowerTerm).         if ((lowerTermHasDecimalPart == false && includeLower == false) || (lowerTermHasDecimalPart && signum(lowerTerm) > 0)) {             if (l == Integer.MAX_VALUE) {                 return new MatchNoDocsQuery().             }             ++l.         }     }     if (upperTerm != null) {         u = parse(upperTerm, true).         boolean upperTermHasDecimalPart = hasDecimalPart(upperTerm).         if ((upperTermHasDecimalPart == false && includeUpper == false) || (upperTermHasDecimalPart && signum(upperTerm) < 0)) {             if (u == Integer.MIN_VALUE) {                 return new MatchNoDocsQuery().             }             --u.         }     }     Query query = IntPoint.newRangeQuery(field, l, u).     if (hasDocValues) {         Query dvQuery = SortedNumericDocValuesField.newSlowRangeQuery(field, l, u).         query = new IndexOrDocValuesQuery(query, dvQuery).     }     return query. }
false;public;5;15;;@Override public List<Field> createFields(String name, Number value, boolean indexed, boolean docValued, boolean stored) {     List<Field> fields = new ArrayList<>().     if (indexed) {         fields.add(new IntPoint(name, value.intValue())).     }     if (docValued) {         fields.add(new SortedNumericDocValuesField(name, value.intValue())).     }     if (stored) {         fields.add(new StoredField(name, value.intValue())).     }     return fields. }
false;public;2;20;;@Override public Long parse(Object value, boolean coerce) {     if (value instanceof Long) {         return (Long) value.     }     double doubleValue = objectToDouble(value).     // be equal to Long.MAX_VALUE after conversion to double. More checks ahead.     if (doubleValue < Long.MIN_VALUE || doubleValue > Long.MAX_VALUE) {         throw new IllegalArgumentException("Value [" + value + "] is out of range for a long").     }     if (!coerce && doubleValue % 1 != 0) {         throw new IllegalArgumentException("Value [" + value + "] has a decimal part").     }     // longs need special handling so we don't lose precision while parsing     String stringValue = (value instanceof BytesRef) ? ((BytesRef) value).utf8ToString() : value.toString().     return Numbers.toLong(stringValue, coerce). }
false;public;1;4;;@Override public Number parsePoint(byte[] value) {     return LongPoint.decodeDimension(value, 0). }
false;public;2;4;;@Override public Long parse(XContentParser parser, boolean coerce) throws IOException {     return parser.longValue(coerce). }
false;public;2;8;;@Override public Query termQuery(String field, Object value) {     if (hasDecimalPart(value)) {         return Queries.newMatchNoDocsQuery("Value [" + value + "] has a decimal part").     }     long v = parse(value, true).     return LongPoint.newExactQuery(field, v). }
false;public;2;20;;@Override public Query termsQuery(String field, List<Object> values) {     long[] v = new long[values.size()].     int upTo = 0.     for (int i = 0. i < values.size(). i++) {         Object value = values.get(i).         if (!hasDecimalPart(value)) {             v[upTo++] = parse(value, true).         }     }     if (upTo == 0) {         return Queries.newMatchNoDocsQuery("All values have a decimal part").     }     if (upTo != v.length) {         v = Arrays.copyOf(v, upTo).     }     return LongPoint.newSetQuery(field, v). }
false;public;6;40;;@Override public Query rangeQuery(String field, Object lowerTerm, Object upperTerm, boolean includeLower, boolean includeUpper, boolean hasDocValues) {     long l = Long.MIN_VALUE.     long u = Long.MAX_VALUE.     if (lowerTerm != null) {         l = parse(lowerTerm, true).         // if the lower bound is decimal:         // - if the bound is positive then we increment it:         // if lowerTerm=1.5 then the (inclusive) bound becomes 2         // - if the bound is negative then we leave it as is:         // if lowerTerm=-1.5 then the (inclusive) bound becomes -1 due to the call to longValue         boolean lowerTermHasDecimalPart = hasDecimalPart(lowerTerm).         if ((lowerTermHasDecimalPart == false && includeLower == false) || (lowerTermHasDecimalPart && signum(lowerTerm) > 0)) {             if (l == Long.MAX_VALUE) {                 return new MatchNoDocsQuery().             }             ++l.         }     }     if (upperTerm != null) {         u = parse(upperTerm, true).         boolean upperTermHasDecimalPart = hasDecimalPart(upperTerm).         if ((upperTermHasDecimalPart == false && includeUpper == false) || (upperTermHasDecimalPart && signum(upperTerm) < 0)) {             if (u == Long.MIN_VALUE) {                 return new MatchNoDocsQuery().             }             --u.         }     }     Query query = LongPoint.newRangeQuery(field, l, u).     if (hasDocValues) {         Query dvQuery = SortedNumericDocValuesField.newSlowRangeQuery(field, l, u).         query = new IndexOrDocValuesQuery(query, dvQuery).     }     return query. }
false;public;5;15;;@Override public List<Field> createFields(String name, Number value, boolean indexed, boolean docValued, boolean stored) {     List<Field> fields = new ArrayList<>().     if (indexed) {         fields.add(new LongPoint(name, value.longValue())).     }     if (docValued) {         fields.add(new SortedNumericDocValuesField(name, value.longValue())).     }     if (stored) {         fields.add(new StoredField(name, value.longValue())).     }     return fields. }
true;public,final;0;3;/**  * Get the associated type name.  */ ;/**  * Get the associated type name.  */ public final String typeName() {     return name. }
true;final;0;3;/**  * Get the associated numeric type  */ ;/**  * Get the associated numeric type  */ final NumericType numericType() {     return numericType. }
false;public,abstract;2;1;;public abstract Query termQuery(String field, Object value).
false;public,abstract;2;1;;public abstract Query termsQuery(String field, List<Object> values).
false;public,abstract;6;3;;public abstract Query rangeQuery(String field, Object lowerTerm, Object upperTerm, boolean includeLower, boolean includeUpper, boolean hasDocValues).
false;public,abstract;2;1;;public abstract Number parse(XContentParser parser, boolean coerce) throws IOException.
false;public,abstract;2;1;;public abstract Number parse(Object value, boolean coerce).
false;public,abstract;1;1;;public abstract Number parsePoint(byte[] value).
false;public,abstract;5;2;;public abstract List<Field> createFields(String name, Number value, boolean indexed, boolean docValued, boolean stored).
false;;1;3;;Number valueForSearch(Number value) {     return value. }
true;;1;13;/**  * Returns true if the object is a number and has a decimal part  */ ;/**  * Returns true if the object is a number and has a decimal part  */ boolean hasDecimalPart(Object number) {     if (number instanceof Number) {         double doubleValue = ((Number) number).doubleValue().         return doubleValue % 1 != 0.     }     if (number instanceof BytesRef) {         number = ((BytesRef) number).utf8ToString().     }     if (number instanceof String) {         return Double.parseDouble((String) number) % 1 != 0.     }     return false. }
true;;1;10;/**  * Returns -1, 0, or 1 if the value is lower than, equal to, or greater than 0  */ ;/**  * Returns -1, 0, or 1 if the value is lower than, equal to, or greater than 0  */ double signum(Object value) {     if (value instanceof Number) {         double doubleValue = ((Number) value).doubleValue().         return Math.signum(doubleValue).     }     if (value instanceof BytesRef) {         value = ((BytesRef) value).utf8ToString().     }     return Math.signum(Double.parseDouble(value.toString())). }
true;private,static;1;13;/**  * Converts an Object to a double by checking it against known types first  */ ;/**  * Converts an Object to a double by checking it against known types first  */ private static double objectToDouble(Object value) {     double doubleValue.     if (value instanceof Number) {         doubleValue = ((Number) value).doubleValue().     } else if (value instanceof BytesRef) {         doubleValue = Double.parseDouble(((BytesRef) value).utf8ToString()).     } else {         doubleValue = Double.parseDouble(value.toString()).     }     return doubleValue. }
false;public;0;4;;@Override public MappedFieldType clone() {     return new NumberFieldType(this). }
false;public;0;4;;@Override public String typeName() {     return type.name. }
false;public;1;8;;@Override public Query existsQuery(QueryShardContext context) {     if (hasDocValues()) {         return new DocValuesFieldExistsQuery(name()).     } else {         return new TermQuery(new Term(FieldNamesFieldMapper.NAME, name())).     } }
false;public;2;9;;@Override public Query termQuery(Object value, QueryShardContext context) {     failIfNotIndexed().     Query query = type.termQuery(name(), value).     if (boost() != 1f) {         query = new BoostQuery(query, boost()).     }     return query. }
false;public;2;9;;@Override public Query termsQuery(List values, QueryShardContext context) {     failIfNotIndexed().     Query query = type.termsQuery(name(), values).     if (boost() != 1f) {         query = new BoostQuery(query, boost()).     }     return query. }
false;public;5;9;;@Override public Query rangeQuery(Object lowerTerm, Object upperTerm, boolean includeLower, boolean includeUpper, QueryShardContext context) {     failIfNotIndexed().     Query query = type.rangeQuery(name(), lowerTerm, upperTerm, includeLower, includeUpper, hasDocValues()).     if (boost() != 1f) {         query = new BoostQuery(query, boost()).     }     return query. }
false;public;1;5;;@Override public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {     failIfNoDocValues().     return new DocValuesIndexFieldData.Builder().numericType(type.numericType()). }
false;public;1;7;;@Override public Object valueForDisplay(Object value) {     if (value == null) {         return null.     }     return type.valueForSearch((Number) value). }
false;public;2;12;;@Override public DocValueFormat docValueFormat(String format, ZoneId timeZone) {     if (timeZone != null) {         throw new IllegalArgumentException("Field [" + name() + "] of type [" + typeName() + "] does not support custom time zones").     }     if (format == null) {         return DocValueFormat.RAW.     } else {         return new DocValueFormat.Decimal(format).     } }
false;public;1;3;;public Number parsePoint(byte[] value) {     return type.parsePoint(value). }
false;public;1;8;;@Override public boolean equals(Object o) {     if (super.equals(o) == false) {         return false.     }     NumberFieldType that = (NumberFieldType) o.     return type == that.type. }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(super.hashCode(), type). }
false;public;0;4;;@Override public NumberFieldType fieldType() {     return (NumberFieldType) super.fieldType(). }
false;protected;0;4;;@Override protected String contentType() {     return fieldType.typeName(). }
false;protected;0;4;;@Override protected NumberFieldMapper clone() {     return (NumberFieldMapper) super.clone(). }
false;protected;2;48;;@Override protected void parseCreateField(ParseContext context, List<IndexableField> fields) throws IOException {     XContentParser parser = context.parser().     Object value.     Number numericValue = null.     if (context.externalValueSet()) {         value = context.externalValue().     } else if (parser.currentToken() == Token.VALUE_NULL) {         value = null.     } else if (coerce.value() && parser.currentToken() == Token.VALUE_STRING && parser.textLength() == 0) {         value = null.     } else {         try {             numericValue = fieldType().type.parse(parser, coerce.value()).         } catch (IllegalArgumentException e) {             if (ignoreMalformed.value()) {                 context.addIgnoredField(fieldType.name()).                 return.             } else {                 throw e.             }         }         value = numericValue.     }     if (value == null) {         value = fieldType().nullValue().     }     if (value == null) {         return.     }     if (numericValue == null) {         numericValue = fieldType().type.parse(value, coerce.value()).     }     boolean indexed = fieldType().indexOptions() != IndexOptions.NONE.     boolean docValued = fieldType().hasDocValues().     boolean stored = fieldType().stored().     fields.addAll(fieldType().type.createFields(fieldType().name(), numericValue, indexed, docValued, stored)).     if (docValued == false && (stored || indexed)) {         createFieldNamesField(context, fields).     } }
false;protected;1;11;;@Override protected void doMerge(Mapper mergeWith) {     super.doMerge(mergeWith).     NumberFieldMapper other = (NumberFieldMapper) mergeWith.     if (other.ignoreMalformed.explicit()) {         this.ignoreMalformed = other.ignoreMalformed.     }     if (other.coerce.explicit()) {         this.coerce = other.coerce.     } }
false;protected;3;15;;@Override protected void doXContentBody(XContentBuilder builder, boolean includeDefaults, Params params) throws IOException {     super.doXContentBody(builder, includeDefaults, params).     if (includeDefaults || ignoreMalformed.explicit()) {         builder.field("ignore_malformed", ignoreMalformed.value()).     }     if (includeDefaults || coerce.explicit()) {         builder.field("coerce", coerce.value()).     }     if (includeDefaults || fieldType().nullValue() != null) {         builder.field("null_value", fieldType().nullValue()).     } }
