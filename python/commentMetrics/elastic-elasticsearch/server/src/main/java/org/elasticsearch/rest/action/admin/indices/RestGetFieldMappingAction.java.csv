commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String getName() {     return "get_field_mapping_action". }
false;public;2;16;;@Override public RestResponse buildResponse(GetFieldMappingsResponse response, XContentBuilder builder) throws Exception {     Map<String, Map<String, Map<String, FieldMappingMetaData>>> mappingsByIndex = response.mappings().     boolean isPossibleSingleFieldRequest = indices.length == 1 && types.length == 1 && fields.length == 1.     if (isPossibleSingleFieldRequest && isFieldMappingMissingField(mappingsByIndex)) {         return new BytesRestResponse(OK, builder.startObject().endObject()).     }     RestStatus status = OK.     if (mappingsByIndex.isEmpty() && fields.length > 0) {         status = NOT_FOUND.     }     response.toXContent(builder, request).     return new BytesRestResponse(status, builder). }
false;public;2;39;;@Override public RestChannelConsumer prepareRequest(final RestRequest request, final NodeClient client) throws IOException {     final String[] indices = Strings.splitStringByCommaToArray(request.param("index")).     final String[] types = request.paramAsStringArrayOrEmptyIfAll("type").     final String[] fields = Strings.splitStringByCommaToArray(request.param("fields")).     boolean includeTypeName = request.paramAsBoolean(INCLUDE_TYPE_NAME_PARAMETER, DEFAULT_INCLUDE_TYPE_NAME_POLICY).     if (includeTypeName == false && types.length > 0) {         throw new IllegalArgumentException("Types cannot be specified unless include_type_name" + " is set to true.").     }     if (request.hasParam(INCLUDE_TYPE_NAME_PARAMETER)) {         deprecationLogger.deprecatedAndMaybeLog("get_field_mapping_with_types", TYPES_DEPRECATION_MESSAGE).     }     GetFieldMappingsRequest getMappingsRequest = new GetFieldMappingsRequest().     getMappingsRequest.indices(indices).types(types).fields(fields).includeDefaults(request.paramAsBoolean("include_defaults", false)).     getMappingsRequest.indicesOptions(IndicesOptions.fromRequest(request, getMappingsRequest.indicesOptions())).     getMappingsRequest.local(request.paramAsBoolean("local", getMappingsRequest.local())).     return channel -> client.admin().indices().getFieldMappings(getMappingsRequest, new RestBuilderListener<GetFieldMappingsResponse>(channel) {          @Override         public RestResponse buildResponse(GetFieldMappingsResponse response, XContentBuilder builder) throws Exception {             Map<String, Map<String, Map<String, FieldMappingMetaData>>> mappingsByIndex = response.mappings().             boolean isPossibleSingleFieldRequest = indices.length == 1 && types.length == 1 && fields.length == 1.             if (isPossibleSingleFieldRequest && isFieldMappingMissingField(mappingsByIndex)) {                 return new BytesRestResponse(OK, builder.startObject().endObject()).             }             RestStatus status = OK.             if (mappingsByIndex.isEmpty() && fields.length > 0) {                 status = NOT_FOUND.             }             response.toXContent(builder, request).             return new BytesRestResponse(status, builder).         }     }). }
true;private;1;16;/**  * Helper method to find out if the only included fieldmapping metadata is typed NULL, which means  * that type and index exist, but the field did not  */ ;/**  * Helper method to find out if the only included fieldmapping metadata is typed NULL, which means  * that type and index exist, but the field did not  */ private boolean isFieldMappingMissingField(Map<String, Map<String, Map<String, FieldMappingMetaData>>> mappingsByIndex) {     if (mappingsByIndex.size() != 1) {         return false.     }     for (Map<String, Map<String, FieldMappingMetaData>> value : mappingsByIndex.values()) {         for (Map<String, FieldMappingMetaData> fieldValue : value.values()) {             for (Map.Entry<String, FieldMappingMetaData> fieldMappingMetaDataEntry : fieldValue.entrySet()) {                 if (fieldMappingMetaDataEntry.getValue().isNull()) {                     return true.                 }             }         }     }     return false. }
