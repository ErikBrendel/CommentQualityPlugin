commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected String executor() {     return Names.SAME. }
false;protected;0;4;;@Override protected AddVotingConfigExclusionsResponse newResponse() {     throw new UnsupportedOperationException("usage of Streamable is to be replaced by Writeable"). }
false;protected;1;4;;@Override protected AddVotingConfigExclusionsResponse read(StreamInput in) throws IOException {     return new AddVotingConfigExclusionsResponse(in). }
false;public;1;13;;@Override public ClusterState execute(ClusterState currentState) {     assert resolvedExclusions == null : resolvedExclusions.     resolvedExclusions = resolveVotingConfigExclusionsAndCheckMaximum(request, currentState).     final CoordinationMetaData.Builder builder = CoordinationMetaData.builder(currentState.coordinationMetaData()).     resolvedExclusions.forEach(builder::addVotingConfigExclusion).     final MetaData newMetaData = MetaData.builder(currentState.metaData()).coordinationMetaData(builder.build()).build().     final ClusterState newState = ClusterState.builder(currentState).metaData(newMetaData).build().     assert newState.getVotingConfigExclusions().size() <= MAXIMUM_VOTING_CONFIG_EXCLUSIONS_SETTING.get(currentState.metaData().settings()).     return newState. }
false;public;2;4;;@Override public void onFailure(String source, Exception e) {     listener.onFailure(e). }
false;public;1;4;;@Override public void onNewClusterState(ClusterState state) {     listener.onResponse(new AddVotingConfigExclusionsResponse()). }
false;public;0;5;;@Override public void onClusterServiceClose() {     listener.onFailure(new ElasticsearchException("cluster service closed while waiting for voting config exclusions " + resolvedExclusions + " to take effect")). }
false;public;1;5;;@Override public void onTimeout(TimeValue timeout) {     listener.onFailure(new ElasticsearchTimeoutException("timed out waiting for voting config exclusions " + resolvedExclusions + " to take effect")). }
false;public;3;39;;@Override public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {     final ClusterStateObserver observer = new ClusterStateObserver(clusterService, request.getTimeout(), logger, threadPool.getThreadContext()).     final Set<String> excludedNodeIds = resolvedExclusions.stream().map(VotingConfigExclusion::getNodeId).collect(Collectors.toSet()).     final Predicate<ClusterState> allNodesRemoved = clusterState -> {         final Set<String> votingConfigNodeIds = clusterState.getLastCommittedConfiguration().getNodeIds().         return excludedNodeIds.stream().noneMatch(votingConfigNodeIds::contains).     }.     final Listener clusterStateListener = new Listener() {          @Override         public void onNewClusterState(ClusterState state) {             listener.onResponse(new AddVotingConfigExclusionsResponse()).         }          @Override         public void onClusterServiceClose() {             listener.onFailure(new ElasticsearchException("cluster service closed while waiting for voting config exclusions " + resolvedExclusions + " to take effect")).         }          @Override         public void onTimeout(TimeValue timeout) {             listener.onFailure(new ElasticsearchTimeoutException("timed out waiting for voting config exclusions " + resolvedExclusions + " to take effect")).         }     }.     if (allNodesRemoved.test(newState)) {         clusterStateListener.onNewClusterState(newState).     } else {         observer.waitForNextChange(clusterStateListener, allNodesRemoved).     } }
false;protected;3;70;;@Override protected void masterOperation(AddVotingConfigExclusionsRequest request, ClusterState state, ActionListener<AddVotingConfigExclusionsResponse> listener) throws Exception {     // throws IAE if no nodes matched or maximum exceeded     resolveVotingConfigExclusionsAndCheckMaximum(request, state).     clusterService.submitStateUpdateTask("add-voting-config-exclusions", new ClusterStateUpdateTask(Priority.URGENT) {          private Set<VotingConfigExclusion> resolvedExclusions.          @Override         public ClusterState execute(ClusterState currentState) {             assert resolvedExclusions == null : resolvedExclusions.             resolvedExclusions = resolveVotingConfigExclusionsAndCheckMaximum(request, currentState).             final CoordinationMetaData.Builder builder = CoordinationMetaData.builder(currentState.coordinationMetaData()).             resolvedExclusions.forEach(builder::addVotingConfigExclusion).             final MetaData newMetaData = MetaData.builder(currentState.metaData()).coordinationMetaData(builder.build()).build().             final ClusterState newState = ClusterState.builder(currentState).metaData(newMetaData).build().             assert newState.getVotingConfigExclusions().size() <= MAXIMUM_VOTING_CONFIG_EXCLUSIONS_SETTING.get(currentState.metaData().settings()).             return newState.         }          @Override         public void onFailure(String source, Exception e) {             listener.onFailure(e).         }          @Override         public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {             final ClusterStateObserver observer = new ClusterStateObserver(clusterService, request.getTimeout(), logger, threadPool.getThreadContext()).             final Set<String> excludedNodeIds = resolvedExclusions.stream().map(VotingConfigExclusion::getNodeId).collect(Collectors.toSet()).             final Predicate<ClusterState> allNodesRemoved = clusterState -> {                 final Set<String> votingConfigNodeIds = clusterState.getLastCommittedConfiguration().getNodeIds().                 return excludedNodeIds.stream().noneMatch(votingConfigNodeIds::contains).             }.             final Listener clusterStateListener = new Listener() {                  @Override                 public void onNewClusterState(ClusterState state) {                     listener.onResponse(new AddVotingConfigExclusionsResponse()).                 }                  @Override                 public void onClusterServiceClose() {                     listener.onFailure(new ElasticsearchException("cluster service closed while waiting for voting config exclusions " + resolvedExclusions + " to take effect")).                 }                  @Override                 public void onTimeout(TimeValue timeout) {                     listener.onFailure(new ElasticsearchTimeoutException("timed out waiting for voting config exclusions " + resolvedExclusions + " to take effect")).                 }             }.             if (allNodesRemoved.test(newState)) {                 clusterStateListener.onNewClusterState(newState).             } else {                 observer.waitForNextChange(clusterStateListener, allNodesRemoved).             }         }     }). }
false;private,static;2;5;;private static Set<VotingConfigExclusion> resolveVotingConfigExclusionsAndCheckMaximum(AddVotingConfigExclusionsRequest request, ClusterState state) {     return request.resolveVotingConfigExclusionsAndCheckMaximum(state, MAXIMUM_VOTING_CONFIG_EXCLUSIONS_SETTING.get(state.metaData().settings()), MAXIMUM_VOTING_CONFIG_EXCLUSIONS_SETTING.getKey()). }
false;protected;2;4;;@Override protected ClusterBlockException checkBlock(AddVotingConfigExclusionsRequest request, ClusterState state) {     return state.blocks().globalBlockedException(ClusterBlockLevel.METADATA_WRITE). }
