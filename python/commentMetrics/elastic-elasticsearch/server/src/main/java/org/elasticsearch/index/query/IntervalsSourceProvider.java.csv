commented;modifiers;parameterAmount;loc;comment;code
false;public,abstract;2;1;;public abstract IntervalsSource getSource(QueryShardContext context, MappedFieldType fieldType) throws IOException.
false;public,abstract;0;2;;@Override public abstract int hashCode().
false;public,abstract;1;2;;@Override public abstract boolean equals(Object other).
false;public,static;1;13;;public static IntervalsSourceProvider fromXContent(XContentParser parser) throws IOException {     assert parser.currentToken() == XContentParser.Token.FIELD_NAME.     switch(parser.currentName()) {         case "match":             return Match.fromXContent(parser).         case "any_of":             return Disjunction.fromXContent(parser).         case "all_of":             return Combine.fromXContent(parser).     }     throw new ParsingException(parser.getTokenLocation(), "Unknown interval type [" + parser.currentName() + "], expecting one of [match, any_of, all_of]"). }
false;private,static;1;10;;private static IntervalsSourceProvider parseInnerIntervals(XContentParser parser) throws IOException {     if (parser.nextToken() != XContentParser.Token.FIELD_NAME) {         throw new ParsingException(parser.getTokenLocation(), "Expected [FIELD_NAME] but got [" + parser.currentToken() + "]").     }     IntervalsSourceProvider isp = IntervalsSourceProvider.fromXContent(parser).     if (parser.nextToken() != XContentParser.Token.END_OBJECT) {         throw new ParsingException(parser.getTokenLocation(), "Expected [END_OBJECT] but got [" + parser.currentToken() + "]").     }     return isp. }
false;public;2;12;;@Override public IntervalsSource getSource(QueryShardContext context, MappedFieldType fieldType) throws IOException {     NamedAnalyzer analyzer = null.     if (this.analyzer != null) {         analyzer = context.getMapperService().getIndexAnalyzers().get(this.analyzer).     }     IntervalsSource source = fieldType.intervals(query, maxGaps, ordered, analyzer).     if (filter != null) {         return filter.filter(source, context, fieldType).     }     return source. }
false;public;1;11;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     Match match = (Match) o.     return maxGaps == match.maxGaps && ordered == match.ordered && Objects.equals(query, match.query) && Objects.equals(filter, match.filter) && Objects.equals(analyzer, match.analyzer). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(query, maxGaps, ordered, analyzer, filter). }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
false;public;1;8;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeString(query).     out.writeVInt(maxGaps).     out.writeBoolean(ordered).     out.writeOptionalString(analyzer).     out.writeOptionalWriteable(filter). }
false;public;2;15;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.field(NAME).     builder.startObject().     builder.field("query", query).     builder.field("max_gaps", maxGaps).     builder.field("ordered", ordered).     if (analyzer != null) {         builder.field("analyzer", analyzer).     }     if (filter != null) {         builder.field("filter", filter).     }     return builder.endObject(). }
false;public,static;1;3;;public static Match fromXContent(XContentParser parser) {     return PARSER.apply(parser, null). }
false;public;2;12;;@Override public IntervalsSource getSource(QueryShardContext ctx, MappedFieldType fieldType) throws IOException {     List<IntervalsSource> sources = new ArrayList<>().     for (IntervalsSourceProvider provider : subSources) {         sources.add(provider.getSource(ctx, fieldType)).     }     IntervalsSource source = Intervals.or(sources.toArray(new IntervalsSource[0])).     if (filter == null) {         return source.     }     return filter.filter(source, ctx, fieldType). }
false;public;1;7;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     Disjunction that = (Disjunction) o.     return Objects.equals(subSources, that.subSources). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(subSources). }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
false;public;1;5;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeNamedWriteableList(subSources).     out.writeOptionalWriteable(filter). }
false;public;2;15;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject(NAME).     builder.startArray("intervals").     for (IntervalsSourceProvider provider : subSources) {         builder.startObject().         provider.toXContent(builder, params).         builder.endObject().     }     builder.endArray().     if (filter != null) {         builder.field("filter", filter).     }     return builder.endObject(). }
false;public,static;1;3;;public static Disjunction fromXContent(XContentParser parser) throws IOException {     return PARSER.parse(parser, null). }
false;public;2;12;;@Override public IntervalsSource getSource(QueryShardContext ctx, MappedFieldType fieldType) throws IOException {     List<IntervalsSource> ss = new ArrayList<>().     for (IntervalsSourceProvider provider : subSources) {         ss.add(provider.getSource(ctx, fieldType)).     }     IntervalsSource source = IntervalBuilder.combineSources(ss, maxGaps, ordered).     if (filter != null) {         return filter.filter(source, ctx, fieldType).     }     return source. }
false;public;1;8;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     Combine combine = (Combine) o.     return Objects.equals(subSources, combine.subSources) && ordered == combine.ordered && maxGaps == combine.maxGaps. }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(subSources, ordered, maxGaps). }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
false;public;1;7;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeBoolean(ordered).     out.writeNamedWriteableList(subSources).     out.writeInt(maxGaps).     out.writeOptionalWriteable(filter). }
false;public;2;17;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject(NAME).     builder.field("ordered", ordered).     builder.field("max_gaps", maxGaps).     builder.startArray("intervals").     for (IntervalsSourceProvider provider : subSources) {         builder.startObject().         provider.toXContent(builder, params).         builder.endObject().     }     builder.endArray().     if (filter != null) {         builder.field("filter", filter).     }     return builder.endObject(). }
false;public,static;1;3;;public static Combine fromXContent(XContentParser parser) {     return PARSER.apply(parser, null). }
false;protected;1;5;;@Override protected boolean accept(IntervalIterator it) {     interval.setIterator(it).     return script.execute(interval). }
false;public;3;27;;public IntervalsSource filter(IntervalsSource input, QueryShardContext context, MappedFieldType fieldType) throws IOException {     if (script != null) {         IntervalFilterScript ifs = context.getScriptService().compile(script, IntervalFilterScript.CONTEXT).newInstance().         return new ScriptFilterSource(input, script.getIdOrCode(), ifs).     }     IntervalsSource filterSource = filter.getSource(context, fieldType).     switch(type) {         case "containing":             return Intervals.containing(input, filterSource).         case "contained_by":             return Intervals.containedBy(input, filterSource).         case "not_containing":             return Intervals.notContaining(input, filterSource).         case "not_contained_by":             return Intervals.notContainedBy(input, filterSource).         case "overlapping":             return Intervals.overlapping(input, filterSource).         case "not_overlapping":             return Intervals.nonOverlapping(input, filterSource).         case "before":             return Intervals.before(input, filterSource).         case "after":             return Intervals.after(input, filterSource).         default:             throw new IllegalArgumentException("Unknown filter type [" + type + "]").     } }
false;public;1;8;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     IntervalFilter that = (IntervalFilter) o.     return Objects.equals(type, that.type) && Objects.equals(filter, that.filter). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(type, filter). }
false;public;1;12;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeString(type).     out.writeOptionalNamedWriteable(filter).     if (script == null) {         out.writeBoolean(false).     } else {         out.writeBoolean(true).         script.writeTo(out).     } }
false;public;2;10;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.field(type).     builder.startObject().     filter.toXContent(builder, params).     builder.endObject().     builder.endObject().     return builder. }
false;public,static;1;27;;public static IntervalFilter fromXContent(XContentParser parser) throws IOException {     if (parser.nextToken() != XContentParser.Token.FIELD_NAME) {         throw new ParsingException(parser.getTokenLocation(), "Expected [FIELD_NAME] but got [" + parser.currentToken() + "]").     }     String type = parser.currentName().     if (Script.SCRIPT_PARSE_FIELD.match(type, parser.getDeprecationHandler())) {         Script script = Script.parse(parser).         if (parser.nextToken() != XContentParser.Token.END_OBJECT) {             throw new ParsingException(parser.getTokenLocation(), "Expected [END_OBJECT] but got [" + parser.currentToken() + "]").         }         return new IntervalFilter(script).     }     if (parser.nextToken() != XContentParser.Token.START_OBJECT) {         throw new ParsingException(parser.getTokenLocation(), "Expected [START_OBJECT] but got [" + parser.currentToken() + "]").     }     if (parser.nextToken() != XContentParser.Token.FIELD_NAME) {         throw new ParsingException(parser.getTokenLocation(), "Expected [FIELD_NAME] but got [" + parser.currentToken() + "]").     }     IntervalsSourceProvider intervals = IntervalsSourceProvider.fromXContent(parser).     if (parser.nextToken() != XContentParser.Token.END_OBJECT) {         throw new ParsingException(parser.getTokenLocation(), "Expected [END_OBJECT] but got [" + parser.currentToken() + "]").     }     if (parser.nextToken() != XContentParser.Token.END_OBJECT) {         throw new ParsingException(parser.getTokenLocation(), "Expected [END_OBJECT] but got [" + parser.currentToken() + "]").     }     return new IntervalFilter(intervals, type). }
