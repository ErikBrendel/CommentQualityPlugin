commented;modifiers;parameterAmount;loc;comment;code
true;default;1;3;/**  * Format a long value. This is used by terms and histogram aggregations  *  to format keys for fields that use longs as a doc value representation  *  such as the {@code long} and {@code date} fields.  */ ;/**  * Format a long value. This is used by terms and histogram aggregations  *  to format keys for fields that use longs as a doc value representation  *  such as the {@code long} and {@code date} fields.  */ default Object format(long value) {     throw new UnsupportedOperationException(). }
true;default;1;3;/**  * Format a double value. This is used by terms and stats aggregations  *  to format keys for fields that use numbers as a doc value representation  *  such as the {@code long}, {@code double} or {@code date} fields.  */ ;/**  * Format a double value. This is used by terms and stats aggregations  *  to format keys for fields that use numbers as a doc value representation  *  such as the {@code long}, {@code double} or {@code date} fields.  */ default Object format(double value) {     throw new UnsupportedOperationException(). }
true;default;1;3;/**  * Format a binary value. This is used by terms aggregations to format  *  keys for fields that use binary doc value representations such as the  *  {@code keyword} and {@code ip} fields.  */ ;/**  * Format a binary value. This is used by terms aggregations to format  *  keys for fields that use binary doc value representations such as the  *  {@code keyword} and {@code ip} fields.  */ default Object format(BytesRef value) {     throw new UnsupportedOperationException(). }
true;default;3;3;/**  * Parse a value that was formatted with {@link #format(long)} back to the  *  original long value.  */ ;/**  * Parse a value that was formatted with {@link #format(long)} back to the  *  original long value.  */ default long parseLong(String value, boolean roundUp, LongSupplier now) {     throw new UnsupportedOperationException(). }
true;default;3;3;/**  * Parse a value that was formatted with {@link #format(double)} back to  *  the original double value.  */ ;/**  * Parse a value that was formatted with {@link #format(double)} back to  *  the original double value.  */ default double parseDouble(String value, boolean roundUp, LongSupplier now) {     throw new UnsupportedOperationException(). }
true;default;1;3;/**  * Parse a value that was formatted with {@link #format(BytesRef)} back  *  to the original BytesRef.  */ ;/**  * Parse a value that was formatted with {@link #format(BytesRef)} back  *  to the original BytesRef.  */ default BytesRef parseBytesRef(String value) {     throw new UnsupportedOperationException(). }
false;public;0;4;;@Override public String getWriteableName() {     return "raw". }
false;public;1;3;;@Override public void writeTo(StreamOutput out) { }
false;public;1;4;;@Override public Long format(long value) {     return value. }
false;public;1;4;;@Override public Double format(double value) {     return value. }
false;public;1;4;;@Override public String format(BytesRef value) {     return value.utf8ToString(). }
false;public;3;10;;@Override public long parseLong(String value, boolean roundUp, LongSupplier now) {     double d = Double.parseDouble(value).     if (roundUp) {         d = Math.ceil(d).     } else {         d = Math.floor(d).     }     return Math.round(d). }
false;public;3;4;;@Override public double parseDouble(String value, boolean roundUp, LongSupplier now) {     return Double.parseDouble(value). }
false;public;1;4;;@Override public BytesRef parseBytesRef(String value) {     return new BytesRef(value). }
false;public;0;4;;@Override public String getWriteableName() {     return "binary". }
false;public;1;3;;@Override public void writeTo(StreamOutput out) { }
false;public;1;6;;@Override public String format(BytesRef value) {     return Base64.getEncoder().withoutPadding().encodeToString(Arrays.copyOfRange(value.bytes, value.offset, value.offset + value.length)). }
false;public;1;4;;@Override public BytesRef parseBytesRef(String value) {     return new BytesRef(Base64.getDecoder().decode(value)). }
false;static;1;8;;static DocValueFormat withNanosecondResolution(final DocValueFormat format) {     if (format instanceof DateTime) {         DateTime dateTime = (DateTime) format.         return new DateTime(dateTime.formatter, dateTime.timeZone, DateFieldMapper.Resolution.NANOSECONDS).     } else {         throw new IllegalArgumentException("trying to convert a known date time formatter to a nanosecond one, wrong field used?").     } }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
false;public;1;10;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeString(formatter.pattern()).     if (out.getVersion().before(Version.V_7_0_0)) {         out.writeString(DateUtils.zoneIdToDateTimeZone(timeZone).getID()).     } else {         out.writeString(timeZone.getId()).         out.writeVInt(resolution.ordinal()).     } }
false;public;1;4;;@Override public String format(long value) {     return formatter.format(resolution.toInstant(value).atZone(timeZone)). }
false;public;1;4;;@Override public String format(double value) {     return format((long) value). }
false;public;3;4;;@Override public long parseLong(String value, boolean roundUp, LongSupplier now) {     return resolution.convert(parser.parse(value, now, roundUp, timeZone)). }
false;public;3;4;;@Override public double parseDouble(String value, boolean roundUp, LongSupplier now) {     return parseLong(value, roundUp, now). }
false;public;0;4;;@Override public String getWriteableName() {     return "geo_hash". }
false;public;1;3;;@Override public void writeTo(StreamOutput out) { }
false;public;1;4;;@Override public String format(long value) {     return GeoHashUtils.stringEncode(value). }
false;public;1;4;;@Override public String format(double value) {     return format((long) value). }
false;public;0;4;;@Override public String getWriteableName() {     return "bool". }
false;public;1;3;;@Override public void writeTo(StreamOutput out) { }
false;public;1;4;;@Override public Boolean format(long value) {     return value != 0. }
false;public;1;4;;@Override public Boolean format(double value) {     return value != 0. }
false;public;3;10;;@Override public long parseLong(String value, boolean roundUp, LongSupplier now) {     switch(value) {         case "false":             return 0.         case "true":             return 1.     }     throw new IllegalArgumentException("Cannot parse boolean [" + value + "], expected either [true] or [false]"). }
false;public;3;4;;@Override public double parseDouble(String value, boolean roundUp, LongSupplier now) {     return parseLong(value, roundUp, now). }
false;public;0;4;;@Override public String getWriteableName() {     return "ip". }
false;public;1;3;;@Override public void writeTo(StreamOutput out) { }
false;public;1;6;;@Override public String format(BytesRef value) {     byte[] bytes = Arrays.copyOfRange(value.bytes, value.offset, value.offset + value.length).     InetAddress inet = InetAddressPoint.decode(bytes).     return NetworkAddress.format(inet). }
false;public;1;4;;@Override public BytesRef parseBytesRef(String value) {     return new BytesRef(InetAddressPoint.encode(InetAddresses.forString(value))). }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
false;public;1;4;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeString(pattern). }
false;public;1;4;;@Override public String format(long value) {     return format.format(value). }
false;public;1;20;;@Override public String format(double value) {     /*              * Explicitly check for NaN, since it formats to "�" or "NaN" depending on JDK version.              *              * Decimal formatter uses the JRE's default symbol list (via Locale.ROOT above).  In JDK8,              * this translates into using {@link sun.util.locale.provider.JRELocaleProviderAdapter}, which loads              * {@link sun.text.resources.FormatData} for symbols.  There, `NaN` is defined as `\ufffd` (�)              *              * In JDK9+, {@link sun.util.cldr.CLDRLocaleProviderAdapter} is used instead, which loads              * {@link sun.text.resources.cldr.FormatData}.  There, `NaN` is defined as `"NaN"`              *              * Since the character � isn't very useful, and makes the output change depending on JDK version,              * we manually check to see if the value is NaN and return the string directly.              */     if (Double.isNaN(value)) {         return String.valueOf(Double.NaN).     }     return format.format(value). }
false;public;3;20;;@Override public long parseLong(String value, boolean roundUp, LongSupplier now) {     Number n.     try {         n = format.parse(value).     } catch (ParseException e) {         throw new RuntimeException(e).     }     if (format.isParseIntegerOnly()) {         return n.longValue().     } else {         double d = n.doubleValue().         if (roundUp) {             d = Math.ceil(d).         } else {             d = Math.floor(d).         }         return Math.round(d).     } }
false;public;3;10;;@Override public double parseDouble(String value, boolean roundUp, LongSupplier now) {     Number n.     try {         n = format.parse(value).     } catch (ParseException e) {         throw new RuntimeException(e).     }     return n.doubleValue(). }
false;public;1;11;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (o == null || getClass() != o.getClass()) {         return false.     }     Decimal that = (Decimal) o.     return Objects.equals(pattern, that.pattern). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(pattern). }
