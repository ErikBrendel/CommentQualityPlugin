commented;modifiers;parameterAmount;loc;comment;code
false;public;1;7;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeBoolean(fetchFields).     if (fetchFields) {         out.writeGenericValue(fieldNames).     } }
true;public;0;3;/**  * Gets the field names to load and return as part of the search request.  */ ;/**  * Gets the field names to load and return as part of the search request.  */ public List<String> fieldNames() {     return fieldNames. }
true;public;1;7;/**  * Adds the field names {@code fieldNames} to the list of fields to load.  */ ;/**  * Adds the field names {@code fieldNames} to the list of fields to load.  */ public StoredFieldsContext addFieldNames(List<String> fieldNames) {     if (fetchFields == false || fieldNames.contains(_NONE_)) {         throw new IllegalArgumentException("cannot combine _none_ with other fields").     }     this.fieldNames.addAll(fieldNames).     return this. }
true;public;1;7;/**  * Adds a field name {@code field} to the list of fields to load.  */ ;/**  * Adds a field name {@code field} to the list of fields to load.  */ public StoredFieldsContext addFieldName(String field) {     if (fetchFields == false || _NONE_.equals(field)) {         throw new IllegalArgumentException("cannot combine _none_ with other fields").     }     this.fieldNames.add(field).     return this. }
true;public;0;3;/**  * Returns true if the stored fields should be fetched, false otherwise.  */ ;/**  * Returns true if the stored fields should be fetched, false otherwise.  */ public boolean fetchFields() {     return fetchFields. }
false;public;1;11;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     StoredFieldsContext that = (StoredFieldsContext) o.     if (fetchFields != that.fetchFields)         return false.     return fieldNames != null ? fieldNames.equals(that.fieldNames) : that.fieldNames == null. }
false;public;0;6;;@Override public int hashCode() {     int result = fieldNames != null ? fieldNames.hashCode() : 0.     result = 31 * result + (fetchFields ? 1 : 0).     return result. }
false;public;2;16;;public void toXContent(String preferredName, XContentBuilder builder) throws IOException {     if (fetchFields == false) {         builder.field(preferredName, _NONE_).     }     if (fieldNames != null) {         if (fieldNames.size() == 1) {             builder.field(preferredName, fieldNames.get(0)).         } else {             builder.startArray(preferredName).             for (String fieldName : fieldNames) {                 builder.value(fieldName).             }             builder.endArray().         }     } }
false;public,static;1;9;;public static StoredFieldsContext fromList(List<String> fieldNames) {     if (fieldNames.size() == 1 && _NONE_.equals(fieldNames.get(0))) {         return new StoredFieldsContext(false).     }     if (fieldNames.contains(_NONE_)) {         throw new IllegalArgumentException("cannot combine _none_ with other fields").     }     return new StoredFieldsContext(fieldNames). }
false;public,static;2;18;;public static StoredFieldsContext fromXContent(String fieldName, XContentParser parser) throws IOException {     XContentParser.Token token = parser.currentToken().     if (token == XContentParser.Token.VALUE_STRING) {         return fromList(Collections.singletonList(parser.text())).     } else if (token == XContentParser.Token.START_ARRAY) {         ArrayList<String> list = new ArrayList<>().         while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {             list.add(parser.text()).         }         return fromList(list).     } else {         throw new ParsingException(parser.getTokenLocation(), "Expected [" + XContentParser.Token.VALUE_STRING + "] or [" + XContentParser.Token.START_ARRAY + "] in [" + fieldName + "] but found [" + token + "]", parser.getTokenLocation()).     } }
false;public,static;2;8;;public static StoredFieldsContext fromRestRequest(String name, RestRequest request) {     String sField = request.param(name).     if (sField != null) {         String[] sFields = Strings.splitStringByCommaToArray(sField).         return fromList(Arrays.asList(sFields)).     }     return null. }
