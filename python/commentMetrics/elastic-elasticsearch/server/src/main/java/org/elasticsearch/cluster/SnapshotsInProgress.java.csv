commented;modifiers;parameterAmount;loc;comment;code
false;public;1;11;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     SnapshotsInProgress that = (SnapshotsInProgress) o.     if (!entries.equals(that.entries))         return false.     return true. }
false;public;0;4;;@Override public int hashCode() {     return entries.hashCode(). }
false;public;0;11;;@Override public String toString() {     StringBuilder builder = new StringBuilder("SnapshotsInProgress[").     for (int i = 0. i < entries.size(). i++) {         builder.append(entries.get(i).snapshot().getSnapshotId().getName()).         if (i + 1 < entries.size()) {             builder.append(",").         }     }     return builder.append("]").toString(). }
false;public;0;3;;public Snapshot snapshot() {     return this.snapshot. }
false;public;0;3;;public ImmutableOpenMap<ShardId, ShardSnapshotStatus> shards() {     return this.shards. }
false;public;0;3;;public State state() {     return state. }
false;public;0;3;;public List<IndexId> indices() {     return indices. }
false;public;0;3;;public ImmutableOpenMap<String, List<ShardId>> waitingIndices() {     return waitingIndices. }
false;public;0;3;;public boolean includeGlobalState() {     return includeGlobalState. }
false;public;0;3;;public boolean partial() {     return partial. }
false;public;0;3;;public long startTime() {     return startTime. }
false;public;0;3;;public long getRepositoryStateId() {     return repositoryStateId. }
false;public;0;3;;public String failure() {     return failure. }
false;public;1;19;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     Entry entry = (Entry) o.     if (includeGlobalState != entry.includeGlobalState)         return false.     if (partial != entry.partial)         return false.     if (startTime != entry.startTime)         return false.     if (!indices.equals(entry.indices))         return false.     if (!shards.equals(entry.shards))         return false.     if (!snapshot.equals(entry.snapshot))         return false.     if (state != entry.state)         return false.     if (!waitingIndices.equals(entry.waitingIndices))         return false.     if (repositoryStateId != entry.repositoryStateId)         return false.     return true. }
false;public;0;13;;@Override public int hashCode() {     int result = state.hashCode().     result = 31 * result + snapshot.hashCode().     result = 31 * result + (includeGlobalState ? 1 : 0).     result = 31 * result + (partial ? 1 : 0).     result = 31 * result + shards.hashCode().     result = 31 * result + indices.hashCode().     result = 31 * result + waitingIndices.hashCode().     result = 31 * result + Long.hashCode(startTime).     result = 31 * result + Long.hashCode(repositoryStateId).     return result. }
false;public;0;4;;@Override public String toString() {     return snapshot.toString(). }
true;;1;22;// package private for testing ;// package private for testing ImmutableOpenMap<String, List<ShardId>> findWaitingIndices(ImmutableOpenMap<ShardId, ShardSnapshotStatus> shards) {     Map<String, List<ShardId>> waitingIndicesMap = new HashMap<>().     for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> entry : shards) {         if (entry.value.state() == State.WAITING) {             final String indexName = entry.key.getIndexName().             List<ShardId> waitingShards = waitingIndicesMap.get(indexName).             if (waitingShards == null) {                 waitingShards = new ArrayList<>().                 waitingIndicesMap.put(indexName, waitingShards).             }             waitingShards.add(entry.key).         }     }     if (waitingIndicesMap.isEmpty()) {         return ImmutableOpenMap.of().     }     ImmutableOpenMap.Builder<String, List<ShardId>> waitingIndicesBuilder = ImmutableOpenMap.builder().     for (Map.Entry<String, List<ShardId>> entry : waitingIndicesMap.entrySet()) {         waitingIndicesBuilder.put(entry.getKey(), Collections.unmodifiableList(entry.getValue())).     }     return waitingIndicesBuilder.build(). }
true;public,static;1;8;/**  * Checks if all shards in the list have completed  *  * @param shards list of shard statuses  * @return true if all shards have completed (either successfully or failed), false otherwise  */ ;/**  * Checks if all shards in the list have completed  *  * @param shards list of shard statuses  * @return true if all shards have completed (either successfully or failed), false otherwise  */ public static boolean completed(ObjectContainer<ShardSnapshotStatus> shards) {     for (ObjectCursor<ShardSnapshotStatus> status : shards) {         if (status.value.state().completed() == false) {             return false.         }     }     return true. }
false;public;0;3;;public State state() {     return state. }
false;public;0;3;;public String nodeId() {     return nodeId. }
false;public;0;3;;public String reason() {     return reason. }
false;public;1;5;;public void writeTo(StreamOutput out) throws IOException {     out.writeOptionalString(nodeId).     out.writeByte(state.value).     out.writeOptionalString(reason). }
false;public;1;13;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     ShardSnapshotStatus status = (ShardSnapshotStatus) o.     if (nodeId != null ? !nodeId.equals(status.nodeId) : status.nodeId != null)         return false.     if (reason != null ? !reason.equals(status.reason) : status.reason != null)         return false.     if (state != status.state)         return false.     return true. }
false;public;0;7;;@Override public int hashCode() {     int result = state != null ? state.hashCode() : 0.     result = 31 * result + (nodeId != null ? nodeId.hashCode() : 0).     result = 31 * result + (reason != null ? reason.hashCode() : 0).     return result. }
false;public;0;4;;@Override public String toString() {     return "ShardSnapshotStatus[state=" + state + ", nodeId=" + nodeId + ", reason=" + reason + "]". }
false;public;0;3;;public byte value() {     return value. }
false;public;0;3;;public boolean completed() {     return completed. }
false;public;0;3;;public boolean failed() {     return failed. }
false;public,static;1;20;;public static State fromValue(byte value) {     switch(value) {         case 0:             return INIT.         case 1:             return STARTED.         case 2:             return SUCCESS.         case 3:             return FAILED.         case 4:             return ABORTED.         case 5:             return MISSING.         case 6:             return WAITING.         default:             throw new IllegalArgumentException("No snapshot state for value [" + value + "]").     } }
false;public;0;3;;public List<Entry> entries() {     return this.entries. }
false;public;1;9;;public Entry snapshot(final Snapshot snapshot) {     for (Entry entry : entries) {         final Snapshot curr = entry.snapshot().         if (curr.equals(snapshot)) {             return entry.         }     }     return null. }
false;public;0;4;;@Override public String getWriteableName() {     return TYPE. }
false;public;0;4;;@Override public Version getMinimalSupportedVersion() {     return Version.CURRENT.minimumCompatibilityVersion(). }
false;public,static;1;3;;public static NamedDiff<Custom> readDiffFrom(StreamInput in) throws IOException {     return readDiffFrom(Custom.class, TYPE, in). }
false;public;1;29;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeVInt(entries.size()).     for (Entry entry : entries) {         entry.snapshot().writeTo(out).         out.writeBoolean(entry.includeGlobalState()).         out.writeBoolean(entry.partial()).         out.writeByte(entry.state().value()).         out.writeVInt(entry.indices().size()).         for (IndexId index : entry.indices()) {             index.writeTo(out).         }         out.writeLong(entry.startTime()).         out.writeVInt(entry.shards().size()).         for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardEntry : entry.shards()) {             shardEntry.key.writeTo(out).             if (out.getVersion().onOrAfter(Version.V_6_0_0_beta1)) {                 shardEntry.value.writeTo(out).             } else {                 out.writeOptionalString(shardEntry.value.nodeId()).                 out.writeByte(shardEntry.value.state().value()).             }         }         out.writeLong(entry.repositoryStateId).         if (out.getVersion().onOrAfter(Version.V_7_0_0)) {             out.writeOptionalString(entry.failure).         }     } }
false;public;2;9;;@Override public XContentBuilder toXContent(XContentBuilder builder, ToXContent.Params params) throws IOException {     builder.startArray(SNAPSHOTS).     for (Entry entry : entries) {         toXContent(entry, builder, params).     }     builder.endArray().     return builder. }
false;public;3;35;;public void toXContent(Entry entry, XContentBuilder builder, ToXContent.Params params) throws IOException {     builder.startObject().     builder.field(REPOSITORY, entry.snapshot().getRepository()).     builder.field(SNAPSHOT, entry.snapshot().getSnapshotId().getName()).     builder.field(UUID, entry.snapshot().getSnapshotId().getUUID()).     builder.field(INCLUDE_GLOBAL_STATE, entry.includeGlobalState()).     builder.field(PARTIAL, entry.partial()).     builder.field(STATE, entry.state()).     builder.startArray(INDICES).     {         for (IndexId index : entry.indices()) {             index.toXContent(builder, params).         }     }     builder.endArray().     builder.humanReadableField(START_TIME_MILLIS, START_TIME, new TimeValue(entry.startTime())).     builder.field(REPOSITORY_STATE_ID, entry.getRepositoryStateId()).     builder.startArray(SHARDS).     {         for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardEntry : entry.shards) {             ShardId shardId = shardEntry.key.             ShardSnapshotStatus status = shardEntry.value.             builder.startObject().             {                 builder.field(INDEX, shardId.getIndex()).                 builder.field(SHARD, shardId.getId()).                 builder.field(STATE, status.state()).                 builder.field(NODE, status.nodeId()).             }             builder.endObject().         }     }     builder.endArray().     builder.endObject(). }
