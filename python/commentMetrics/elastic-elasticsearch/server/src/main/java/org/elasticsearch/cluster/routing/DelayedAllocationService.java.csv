commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public long scheduledTimeToRunInNanos() {     return baseTimestampNanos + nextDelay.nanos(). }
false;public;0;7;;public void cancelScheduling() {     cancelScheduling.set(true).     if (cancellable != null) {         cancellable.cancel().     }     removeIfSameTask(this). }
false;protected;0;7;;@Override protected void doRun() throws Exception {     if (cancelScheduling.get()) {         return.     }     clusterService.submitStateUpdateTask(CLUSTER_UPDATE_TASK_SOURCE, DelayedRerouteTask.this). }
false;public;1;5;;@Override public void onFailure(Exception e) {     logger.warn("failed to submit schedule/execute reroute post unassigned shard", e).     removeIfSameTask(DelayedRerouteTask.this). }
false;public;0;17;;public void schedule() {     cancellable = threadPool.schedule(new AbstractRunnable() {          @Override         protected void doRun() throws Exception {             if (cancelScheduling.get()) {                 return.             }             clusterService.submitStateUpdateTask(CLUSTER_UPDATE_TASK_SOURCE, DelayedRerouteTask.this).         }          @Override         public void onFailure(Exception e) {             logger.warn("failed to submit schedule/execute reroute post unassigned shard", e).             removeIfSameTask(DelayedRerouteTask.this).         }     }, nextDelay, ThreadPool.Names.SAME). }
false;public;1;5;;@Override public ClusterState execute(ClusterState currentState) throws Exception {     removeIfSameTask(this).     return allocationService.reroute(currentState, "assign delayed unassigned shards"). }
false;public;3;9;;@Override public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {     if (oldState == newState) {         // no state changed, check when we should remove the delay flag from the shards the next time.         // if cluster state changed, we can leave the scheduling of the next delay up to the clusterChangedEvent         // this should not be needed, but we want to be extra safe here         scheduleIfNeeded(currentNanoTime(), newState).     } }
false;public;2;5;;@Override public void onFailure(String source, Exception e) {     removeIfSameTask(this).     logger.warn("failed to schedule/execute reroute post unassigned shard", e). }
false;protected;0;3;;@Override protected void doStart() { }
false;protected;0;3;;@Override protected void doStop() { }
false;protected;0;5;;@Override protected void doClose() {     clusterService.removeListener(this).     removeTaskAndCancel(). }
true;protected;0;3;/**  * override this to control time based decisions during delayed allocation  */ ;/**  * override this to control time based decisions during delayed allocation  */ protected long currentNanoTime() {     return System.nanoTime(). }
false;public;1;7;;@Override public void clusterChanged(ClusterChangedEvent event) {     long currentNanoTime = currentNanoTime().     if (event.state().nodes().isLocalNodeElectedMaster()) {         scheduleIfNeeded(currentNanoTime, event.state()).     } }
false;private;0;7;;private void removeTaskAndCancel() {     DelayedRerouteTask existingTask = delayedRerouteTask.getAndSet(null).     if (existingTask != null) {         logger.trace("cancelling existing delayed reroute task").         existingTask.cancelScheduling().     } }
false;private;1;3;;private void removeIfSameTask(DelayedRerouteTask expectedTask) {     delayedRerouteTask.compareAndSet(expectedTask, null). }
true;private,synchronized;2;34;/**  * Figure out if an existing scheduled reroute is good enough or whether we need to cancel and reschedule.  */ ;/**  * Figure out if an existing scheduled reroute is good enough or whether we need to cancel and reschedule.  */ private synchronized void scheduleIfNeeded(long currentNanoTime, ClusterState state) {     assertClusterOrMasterStateThread().     long nextDelayNanos = UnassignedInfo.findNextDelayedAllocation(currentNanoTime, state).     if (nextDelayNanos < 0) {         logger.trace("no need to schedule reroute - no delayed unassigned shards").         removeTaskAndCancel().     } else {         TimeValue nextDelay = TimeValue.timeValueNanos(nextDelayNanos).         final boolean earlierRerouteNeeded.         DelayedRerouteTask existingTask = delayedRerouteTask.get().         DelayedRerouteTask newTask = new DelayedRerouteTask(nextDelay, currentNanoTime).         if (existingTask == null) {             earlierRerouteNeeded = true.         } else if (newTask.scheduledTimeToRunInNanos() < existingTask.scheduledTimeToRunInNanos()) {             // we need an earlier delayed reroute             logger.trace("cancelling existing delayed reroute task as delayed reroute has to happen [{}] earlier", TimeValue.timeValueNanos(existingTask.scheduledTimeToRunInNanos() - newTask.scheduledTimeToRunInNanos())).             existingTask.cancelScheduling().             earlierRerouteNeeded = true.         } else {             earlierRerouteNeeded = false.         }         if (earlierRerouteNeeded) {             logger.info("scheduling reroute for delayed shards in [{}] ({} delayed shards)", nextDelay, UnassignedInfo.getNumberOfDelayedUnassigned(state)).             DelayedRerouteTask currentTask = delayedRerouteTask.getAndSet(newTask).             assert existingTask == currentTask || currentTask == null.             newTask.schedule().         } else {             logger.trace("no need to reschedule delayed reroute - currently scheduled delayed reroute in [{}] is enough", nextDelay).         }     } }
true;protected;0;3;// protected so that it can be overridden (and disabled) by unit tests ;// protected so that it can be overridden (and disabled) by unit tests protected void assertClusterOrMasterStateThread() {     assert ClusterService.assertClusterOrMasterStateThread(). }
