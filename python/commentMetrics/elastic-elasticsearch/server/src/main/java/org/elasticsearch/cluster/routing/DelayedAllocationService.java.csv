# id;timestamp;commentText;codeText;commentWords;codeWords
DelayedAllocationService -> protected long currentNanoTime();1524684173;override this to control time based decisions during delayed allocation;protected long currentNanoTime() {_        return System.nanoTime()__    };override,this,to,control,time,based,decisions,during,delayed,allocation;protected,long,current,nano,time,return,system,nano,time
DelayedAllocationService -> protected long currentNanoTime();1531179852;override this to control time based decisions during delayed allocation;protected long currentNanoTime() {_        return System.nanoTime()__    };override,this,to,control,time,based,decisions,during,delayed,allocation;protected,long,current,nano,time,return,system,nano,time
DelayedAllocationService -> protected long currentNanoTime();1542646292;override this to control time based decisions during delayed allocation;protected long currentNanoTime() {_        return System.nanoTime()__    };override,this,to,control,time,based,decisions,during,delayed,allocation;protected,long,current,nano,time,return,system,nano,time
DelayedAllocationService -> protected long currentNanoTime();1547625930;override this to control time based decisions during delayed allocation;protected long currentNanoTime() {_        return System.nanoTime()__    };override,this,to,control,time,based,decisions,during,delayed,allocation;protected,long,current,nano,time,return,system,nano,time
DelayedAllocationService -> protected long currentNanoTime();1548259585;override this to control time based decisions during delayed allocation;protected long currentNanoTime() {_        return System.nanoTime()__    };override,this,to,control,time,based,decisions,during,delayed,allocation;protected,long,current,nano,time,return,system,nano,time
DelayedAllocationService -> protected long currentNanoTime();1548953505;override this to control time based decisions during delayed allocation;protected long currentNanoTime() {_        return System.nanoTime()__    };override,this,to,control,time,based,decisions,during,delayed,allocation;protected,long,current,nano,time,return,system,nano,time
DelayedAllocationService -> private synchronized void scheduleIfNeeded(long currentNanoTime, ClusterState state);1524684173;Figure out if an existing scheduled reroute is good enough or whether we need to cancel and reschedule.;private synchronized void scheduleIfNeeded(long currentNanoTime, ClusterState state) {_        assertClusterOrMasterStateThread()__        long nextDelayNanos = UnassignedInfo.findNextDelayedAllocation(currentNanoTime, state)__        if (nextDelayNanos < 0) {_            logger.trace("no need to schedule reroute - no delayed unassigned shards")__            removeTaskAndCancel()__        } else {_            TimeValue nextDelay = TimeValue.timeValueNanos(nextDelayNanos)__            final boolean earlierRerouteNeeded__            DelayedRerouteTask existingTask = delayedRerouteTask.get()__            DelayedRerouteTask newTask = new DelayedRerouteTask(nextDelay, currentNanoTime)__            if (existingTask == null) {_                earlierRerouteNeeded = true__            } else if (newTask.scheduledTimeToRunInNanos() < existingTask.scheduledTimeToRunInNanos()) {_                _                logger.trace("cancelling existing delayed reroute task as delayed reroute has to happen [{}] earlier",_                    TimeValue.timeValueNanos(existingTask.scheduledTimeToRunInNanos() - newTask.scheduledTimeToRunInNanos()))__                existingTask.cancelScheduling()__                earlierRerouteNeeded = true__            } else {_                earlierRerouteNeeded = false__            }__            if (earlierRerouteNeeded) {_                logger.info("scheduling reroute for delayed shards in [{}] ({} delayed shards)", nextDelay,_                    UnassignedInfo.getNumberOfDelayedUnassigned(state))__                DelayedRerouteTask currentTask = delayedRerouteTask.getAndSet(newTask)__                assert existingTask == currentTask || currentTask == null__                newTask.schedule()__            } else {_                logger.trace("no need to reschedule delayed reroute - currently scheduled delayed reroute in [{}] is enough", nextDelay)__            }_        }_    };figure,out,if,an,existing,scheduled,reroute,is,good,enough,or,whether,we,need,to,cancel,and,reschedule;private,synchronized,void,schedule,if,needed,long,current,nano,time,cluster,state,state,assert,cluster,or,master,state,thread,long,next,delay,nanos,unassigned,info,find,next,delayed,allocation,current,nano,time,state,if,next,delay,nanos,0,logger,trace,no,need,to,schedule,reroute,no,delayed,unassigned,shards,remove,task,and,cancel,else,time,value,next,delay,time,value,time,value,nanos,next,delay,nanos,final,boolean,earlier,reroute,needed,delayed,reroute,task,existing,task,delayed,reroute,task,get,delayed,reroute,task,new,task,new,delayed,reroute,task,next,delay,current,nano,time,if,existing,task,null,earlier,reroute,needed,true,else,if,new,task,scheduled,time,to,run,in,nanos,existing,task,scheduled,time,to,run,in,nanos,logger,trace,cancelling,existing,delayed,reroute,task,as,delayed,reroute,has,to,happen,earlier,time,value,time,value,nanos,existing,task,scheduled,time,to,run,in,nanos,new,task,scheduled,time,to,run,in,nanos,existing,task,cancel,scheduling,earlier,reroute,needed,true,else,earlier,reroute,needed,false,if,earlier,reroute,needed,logger,info,scheduling,reroute,for,delayed,shards,in,delayed,shards,next,delay,unassigned,info,get,number,of,delayed,unassigned,state,delayed,reroute,task,current,task,delayed,reroute,task,get,and,set,new,task,assert,existing,task,current,task,current,task,null,new,task,schedule,else,logger,trace,no,need,to,reschedule,delayed,reroute,currently,scheduled,delayed,reroute,in,is,enough,next,delay
DelayedAllocationService -> private synchronized void scheduleIfNeeded(long currentNanoTime, ClusterState state);1531179852;Figure out if an existing scheduled reroute is good enough or whether we need to cancel and reschedule.;private synchronized void scheduleIfNeeded(long currentNanoTime, ClusterState state) {_        assertClusterOrMasterStateThread()__        long nextDelayNanos = UnassignedInfo.findNextDelayedAllocation(currentNanoTime, state)__        if (nextDelayNanos < 0) {_            logger.trace("no need to schedule reroute - no delayed unassigned shards")__            removeTaskAndCancel()__        } else {_            TimeValue nextDelay = TimeValue.timeValueNanos(nextDelayNanos)__            final boolean earlierRerouteNeeded__            DelayedRerouteTask existingTask = delayedRerouteTask.get()__            DelayedRerouteTask newTask = new DelayedRerouteTask(nextDelay, currentNanoTime)__            if (existingTask == null) {_                earlierRerouteNeeded = true__            } else if (newTask.scheduledTimeToRunInNanos() < existingTask.scheduledTimeToRunInNanos()) {_                _                logger.trace("cancelling existing delayed reroute task as delayed reroute has to happen [{}] earlier",_                    TimeValue.timeValueNanos(existingTask.scheduledTimeToRunInNanos() - newTask.scheduledTimeToRunInNanos()))__                existingTask.cancelScheduling()__                earlierRerouteNeeded = true__            } else {_                earlierRerouteNeeded = false__            }__            if (earlierRerouteNeeded) {_                logger.info("scheduling reroute for delayed shards in [{}] ({} delayed shards)", nextDelay,_                    UnassignedInfo.getNumberOfDelayedUnassigned(state))__                DelayedRerouteTask currentTask = delayedRerouteTask.getAndSet(newTask)__                assert existingTask == currentTask || currentTask == null__                newTask.schedule()__            } else {_                logger.trace("no need to reschedule delayed reroute - currently scheduled delayed reroute in [{}] is enough", nextDelay)__            }_        }_    };figure,out,if,an,existing,scheduled,reroute,is,good,enough,or,whether,we,need,to,cancel,and,reschedule;private,synchronized,void,schedule,if,needed,long,current,nano,time,cluster,state,state,assert,cluster,or,master,state,thread,long,next,delay,nanos,unassigned,info,find,next,delayed,allocation,current,nano,time,state,if,next,delay,nanos,0,logger,trace,no,need,to,schedule,reroute,no,delayed,unassigned,shards,remove,task,and,cancel,else,time,value,next,delay,time,value,time,value,nanos,next,delay,nanos,final,boolean,earlier,reroute,needed,delayed,reroute,task,existing,task,delayed,reroute,task,get,delayed,reroute,task,new,task,new,delayed,reroute,task,next,delay,current,nano,time,if,existing,task,null,earlier,reroute,needed,true,else,if,new,task,scheduled,time,to,run,in,nanos,existing,task,scheduled,time,to,run,in,nanos,logger,trace,cancelling,existing,delayed,reroute,task,as,delayed,reroute,has,to,happen,earlier,time,value,time,value,nanos,existing,task,scheduled,time,to,run,in,nanos,new,task,scheduled,time,to,run,in,nanos,existing,task,cancel,scheduling,earlier,reroute,needed,true,else,earlier,reroute,needed,false,if,earlier,reroute,needed,logger,info,scheduling,reroute,for,delayed,shards,in,delayed,shards,next,delay,unassigned,info,get,number,of,delayed,unassigned,state,delayed,reroute,task,current,task,delayed,reroute,task,get,and,set,new,task,assert,existing,task,current,task,current,task,null,new,task,schedule,else,logger,trace,no,need,to,reschedule,delayed,reroute,currently,scheduled,delayed,reroute,in,is,enough,next,delay
DelayedAllocationService -> private synchronized void scheduleIfNeeded(long currentNanoTime, ClusterState state);1542646292;Figure out if an existing scheduled reroute is good enough or whether we need to cancel and reschedule.;private synchronized void scheduleIfNeeded(long currentNanoTime, ClusterState state) {_        assertClusterOrMasterStateThread()__        long nextDelayNanos = UnassignedInfo.findNextDelayedAllocation(currentNanoTime, state)__        if (nextDelayNanos < 0) {_            logger.trace("no need to schedule reroute - no delayed unassigned shards")__            removeTaskAndCancel()__        } else {_            TimeValue nextDelay = TimeValue.timeValueNanos(nextDelayNanos)__            final boolean earlierRerouteNeeded__            DelayedRerouteTask existingTask = delayedRerouteTask.get()__            DelayedRerouteTask newTask = new DelayedRerouteTask(nextDelay, currentNanoTime)__            if (existingTask == null) {_                earlierRerouteNeeded = true__            } else if (newTask.scheduledTimeToRunInNanos() < existingTask.scheduledTimeToRunInNanos()) {_                _                logger.trace("cancelling existing delayed reroute task as delayed reroute has to happen [{}] earlier",_                    TimeValue.timeValueNanos(existingTask.scheduledTimeToRunInNanos() - newTask.scheduledTimeToRunInNanos()))__                existingTask.cancelScheduling()__                earlierRerouteNeeded = true__            } else {_                earlierRerouteNeeded = false__            }__            if (earlierRerouteNeeded) {_                logger.info("scheduling reroute for delayed shards in [{}] ({} delayed shards)", nextDelay,_                    UnassignedInfo.getNumberOfDelayedUnassigned(state))__                DelayedRerouteTask currentTask = delayedRerouteTask.getAndSet(newTask)__                assert existingTask == currentTask || currentTask == null__                newTask.schedule()__            } else {_                logger.trace("no need to reschedule delayed reroute - currently scheduled delayed reroute in [{}] is enough", nextDelay)__            }_        }_    };figure,out,if,an,existing,scheduled,reroute,is,good,enough,or,whether,we,need,to,cancel,and,reschedule;private,synchronized,void,schedule,if,needed,long,current,nano,time,cluster,state,state,assert,cluster,or,master,state,thread,long,next,delay,nanos,unassigned,info,find,next,delayed,allocation,current,nano,time,state,if,next,delay,nanos,0,logger,trace,no,need,to,schedule,reroute,no,delayed,unassigned,shards,remove,task,and,cancel,else,time,value,next,delay,time,value,time,value,nanos,next,delay,nanos,final,boolean,earlier,reroute,needed,delayed,reroute,task,existing,task,delayed,reroute,task,get,delayed,reroute,task,new,task,new,delayed,reroute,task,next,delay,current,nano,time,if,existing,task,null,earlier,reroute,needed,true,else,if,new,task,scheduled,time,to,run,in,nanos,existing,task,scheduled,time,to,run,in,nanos,logger,trace,cancelling,existing,delayed,reroute,task,as,delayed,reroute,has,to,happen,earlier,time,value,time,value,nanos,existing,task,scheduled,time,to,run,in,nanos,new,task,scheduled,time,to,run,in,nanos,existing,task,cancel,scheduling,earlier,reroute,needed,true,else,earlier,reroute,needed,false,if,earlier,reroute,needed,logger,info,scheduling,reroute,for,delayed,shards,in,delayed,shards,next,delay,unassigned,info,get,number,of,delayed,unassigned,state,delayed,reroute,task,current,task,delayed,reroute,task,get,and,set,new,task,assert,existing,task,current,task,current,task,null,new,task,schedule,else,logger,trace,no,need,to,reschedule,delayed,reroute,currently,scheduled,delayed,reroute,in,is,enough,next,delay
DelayedAllocationService -> private synchronized void scheduleIfNeeded(long currentNanoTime, ClusterState state);1547625930;Figure out if an existing scheduled reroute is good enough or whether we need to cancel and reschedule.;private synchronized void scheduleIfNeeded(long currentNanoTime, ClusterState state) {_        assertClusterOrMasterStateThread()__        long nextDelayNanos = UnassignedInfo.findNextDelayedAllocation(currentNanoTime, state)__        if (nextDelayNanos < 0) {_            logger.trace("no need to schedule reroute - no delayed unassigned shards")__            removeTaskAndCancel()__        } else {_            TimeValue nextDelay = TimeValue.timeValueNanos(nextDelayNanos)__            final boolean earlierRerouteNeeded__            DelayedRerouteTask existingTask = delayedRerouteTask.get()__            DelayedRerouteTask newTask = new DelayedRerouteTask(nextDelay, currentNanoTime)__            if (existingTask == null) {_                earlierRerouteNeeded = true__            } else if (newTask.scheduledTimeToRunInNanos() < existingTask.scheduledTimeToRunInNanos()) {_                _                logger.trace("cancelling existing delayed reroute task as delayed reroute has to happen [{}] earlier",_                    TimeValue.timeValueNanos(existingTask.scheduledTimeToRunInNanos() - newTask.scheduledTimeToRunInNanos()))__                existingTask.cancelScheduling()__                earlierRerouteNeeded = true__            } else {_                earlierRerouteNeeded = false__            }__            if (earlierRerouteNeeded) {_                logger.info("scheduling reroute for delayed shards in [{}] ({} delayed shards)", nextDelay,_                    UnassignedInfo.getNumberOfDelayedUnassigned(state))__                DelayedRerouteTask currentTask = delayedRerouteTask.getAndSet(newTask)__                assert existingTask == currentTask || currentTask == null__                newTask.schedule()__            } else {_                logger.trace("no need to reschedule delayed reroute - currently scheduled delayed reroute in [{}] is enough", nextDelay)__            }_        }_    };figure,out,if,an,existing,scheduled,reroute,is,good,enough,or,whether,we,need,to,cancel,and,reschedule;private,synchronized,void,schedule,if,needed,long,current,nano,time,cluster,state,state,assert,cluster,or,master,state,thread,long,next,delay,nanos,unassigned,info,find,next,delayed,allocation,current,nano,time,state,if,next,delay,nanos,0,logger,trace,no,need,to,schedule,reroute,no,delayed,unassigned,shards,remove,task,and,cancel,else,time,value,next,delay,time,value,time,value,nanos,next,delay,nanos,final,boolean,earlier,reroute,needed,delayed,reroute,task,existing,task,delayed,reroute,task,get,delayed,reroute,task,new,task,new,delayed,reroute,task,next,delay,current,nano,time,if,existing,task,null,earlier,reroute,needed,true,else,if,new,task,scheduled,time,to,run,in,nanos,existing,task,scheduled,time,to,run,in,nanos,logger,trace,cancelling,existing,delayed,reroute,task,as,delayed,reroute,has,to,happen,earlier,time,value,time,value,nanos,existing,task,scheduled,time,to,run,in,nanos,new,task,scheduled,time,to,run,in,nanos,existing,task,cancel,scheduling,earlier,reroute,needed,true,else,earlier,reroute,needed,false,if,earlier,reroute,needed,logger,info,scheduling,reroute,for,delayed,shards,in,delayed,shards,next,delay,unassigned,info,get,number,of,delayed,unassigned,state,delayed,reroute,task,current,task,delayed,reroute,task,get,and,set,new,task,assert,existing,task,current,task,current,task,null,new,task,schedule,else,logger,trace,no,need,to,reschedule,delayed,reroute,currently,scheduled,delayed,reroute,in,is,enough,next,delay
DelayedAllocationService -> private synchronized void scheduleIfNeeded(long currentNanoTime, ClusterState state);1548259585;Figure out if an existing scheduled reroute is good enough or whether we need to cancel and reschedule.;private synchronized void scheduleIfNeeded(long currentNanoTime, ClusterState state) {_        assertClusterOrMasterStateThread()__        long nextDelayNanos = UnassignedInfo.findNextDelayedAllocation(currentNanoTime, state)__        if (nextDelayNanos < 0) {_            logger.trace("no need to schedule reroute - no delayed unassigned shards")__            removeTaskAndCancel()__        } else {_            TimeValue nextDelay = TimeValue.timeValueNanos(nextDelayNanos)__            final boolean earlierRerouteNeeded__            DelayedRerouteTask existingTask = delayedRerouteTask.get()__            DelayedRerouteTask newTask = new DelayedRerouteTask(nextDelay, currentNanoTime)__            if (existingTask == null) {_                earlierRerouteNeeded = true__            } else if (newTask.scheduledTimeToRunInNanos() < existingTask.scheduledTimeToRunInNanos()) {_                _                logger.trace("cancelling existing delayed reroute task as delayed reroute has to happen [{}] earlier",_                    TimeValue.timeValueNanos(existingTask.scheduledTimeToRunInNanos() - newTask.scheduledTimeToRunInNanos()))__                existingTask.cancelScheduling()__                earlierRerouteNeeded = true__            } else {_                earlierRerouteNeeded = false__            }__            if (earlierRerouteNeeded) {_                logger.info("scheduling reroute for delayed shards in [{}] ({} delayed shards)", nextDelay,_                    UnassignedInfo.getNumberOfDelayedUnassigned(state))__                DelayedRerouteTask currentTask = delayedRerouteTask.getAndSet(newTask)__                assert existingTask == currentTask || currentTask == null__                newTask.schedule()__            } else {_                logger.trace("no need to reschedule delayed reroute - currently scheduled delayed reroute in [{}] is enough", nextDelay)__            }_        }_    };figure,out,if,an,existing,scheduled,reroute,is,good,enough,or,whether,we,need,to,cancel,and,reschedule;private,synchronized,void,schedule,if,needed,long,current,nano,time,cluster,state,state,assert,cluster,or,master,state,thread,long,next,delay,nanos,unassigned,info,find,next,delayed,allocation,current,nano,time,state,if,next,delay,nanos,0,logger,trace,no,need,to,schedule,reroute,no,delayed,unassigned,shards,remove,task,and,cancel,else,time,value,next,delay,time,value,time,value,nanos,next,delay,nanos,final,boolean,earlier,reroute,needed,delayed,reroute,task,existing,task,delayed,reroute,task,get,delayed,reroute,task,new,task,new,delayed,reroute,task,next,delay,current,nano,time,if,existing,task,null,earlier,reroute,needed,true,else,if,new,task,scheduled,time,to,run,in,nanos,existing,task,scheduled,time,to,run,in,nanos,logger,trace,cancelling,existing,delayed,reroute,task,as,delayed,reroute,has,to,happen,earlier,time,value,time,value,nanos,existing,task,scheduled,time,to,run,in,nanos,new,task,scheduled,time,to,run,in,nanos,existing,task,cancel,scheduling,earlier,reroute,needed,true,else,earlier,reroute,needed,false,if,earlier,reroute,needed,logger,info,scheduling,reroute,for,delayed,shards,in,delayed,shards,next,delay,unassigned,info,get,number,of,delayed,unassigned,state,delayed,reroute,task,current,task,delayed,reroute,task,get,and,set,new,task,assert,existing,task,current,task,current,task,null,new,task,schedule,else,logger,trace,no,need,to,reschedule,delayed,reroute,currently,scheduled,delayed,reroute,in,is,enough,next,delay
DelayedAllocationService -> private synchronized void scheduleIfNeeded(long currentNanoTime, ClusterState state);1548953505;Figure out if an existing scheduled reroute is good enough or whether we need to cancel and reschedule.;private synchronized void scheduleIfNeeded(long currentNanoTime, ClusterState state) {_        assertClusterOrMasterStateThread()__        long nextDelayNanos = UnassignedInfo.findNextDelayedAllocation(currentNanoTime, state)__        if (nextDelayNanos < 0) {_            logger.trace("no need to schedule reroute - no delayed unassigned shards")__            removeTaskAndCancel()__        } else {_            TimeValue nextDelay = TimeValue.timeValueNanos(nextDelayNanos)__            final boolean earlierRerouteNeeded__            DelayedRerouteTask existingTask = delayedRerouteTask.get()__            DelayedRerouteTask newTask = new DelayedRerouteTask(nextDelay, currentNanoTime)__            if (existingTask == null) {_                earlierRerouteNeeded = true__            } else if (newTask.scheduledTimeToRunInNanos() < existingTask.scheduledTimeToRunInNanos()) {_                _                logger.trace("cancelling existing delayed reroute task as delayed reroute has to happen [{}] earlier",_                    TimeValue.timeValueNanos(existingTask.scheduledTimeToRunInNanos() - newTask.scheduledTimeToRunInNanos()))__                existingTask.cancelScheduling()__                earlierRerouteNeeded = true__            } else {_                earlierRerouteNeeded = false__            }__            if (earlierRerouteNeeded) {_                logger.info("scheduling reroute for delayed shards in [{}] ({} delayed shards)", nextDelay,_                    UnassignedInfo.getNumberOfDelayedUnassigned(state))__                DelayedRerouteTask currentTask = delayedRerouteTask.getAndSet(newTask)__                assert existingTask == currentTask || currentTask == null__                newTask.schedule()__            } else {_                logger.trace("no need to reschedule delayed reroute - currently scheduled delayed reroute in [{}] is enough", nextDelay)__            }_        }_    };figure,out,if,an,existing,scheduled,reroute,is,good,enough,or,whether,we,need,to,cancel,and,reschedule;private,synchronized,void,schedule,if,needed,long,current,nano,time,cluster,state,state,assert,cluster,or,master,state,thread,long,next,delay,nanos,unassigned,info,find,next,delayed,allocation,current,nano,time,state,if,next,delay,nanos,0,logger,trace,no,need,to,schedule,reroute,no,delayed,unassigned,shards,remove,task,and,cancel,else,time,value,next,delay,time,value,time,value,nanos,next,delay,nanos,final,boolean,earlier,reroute,needed,delayed,reroute,task,existing,task,delayed,reroute,task,get,delayed,reroute,task,new,task,new,delayed,reroute,task,next,delay,current,nano,time,if,existing,task,null,earlier,reroute,needed,true,else,if,new,task,scheduled,time,to,run,in,nanos,existing,task,scheduled,time,to,run,in,nanos,logger,trace,cancelling,existing,delayed,reroute,task,as,delayed,reroute,has,to,happen,earlier,time,value,time,value,nanos,existing,task,scheduled,time,to,run,in,nanos,new,task,scheduled,time,to,run,in,nanos,existing,task,cancel,scheduling,earlier,reroute,needed,true,else,earlier,reroute,needed,false,if,earlier,reroute,needed,logger,info,scheduling,reroute,for,delayed,shards,in,delayed,shards,next,delay,unassigned,info,get,number,of,delayed,unassigned,state,delayed,reroute,task,current,task,delayed,reroute,task,get,and,set,new,task,assert,existing,task,current,task,current,task,null,new,task,schedule,else,logger,trace,no,need,to,reschedule,delayed,reroute,currently,scheduled,delayed,reroute,in,is,enough,next,delay
