commented;modifiers;parameterAmount;loc;comment;code
false;public,static;2;3;;public static DateHistogramAggregationBuilder parse(String aggregationName, XContentParser parser) throws IOException {     return PARSER.parse(parser, new DateHistogramAggregationBuilder(aggregationName), null). }
false;protected;2;4;;@Override protected AggregationBuilder shallowCopy(Builder factoriesBuilder, Map<String, Object> metaData) {     return new DateHistogramAggregationBuilder(this, factoriesBuilder, metaData). }
false;protected;1;10;;@Override protected void innerWriteTo(StreamOutput out) throws IOException {     InternalOrder.Streams.writeHistogramOrder(order, out, true).     out.writeBoolean(keyed).     out.writeVLong(minDocCount).     out.writeLong(interval).     out.writeOptionalWriteable(dateHistogramInterval).     out.writeLong(offset).     out.writeOptionalWriteable(extendedBounds). }
true;public;0;3;/**  * Get the current interval in milliseconds that is set on this builder.  */ ;/**  * Get the current interval in milliseconds that is set on this builder.  */ public long interval() {     return interval. }
true;public;1;7;/**  * Set the interval on this builder, and return the builder so that calls can be chained.  *  If both {@link #interval()} and {@link #dateHistogramInterval()} are set, then the  *  {@link #dateHistogramInterval()} wins.  */ ;/**  * Set the interval on this builder, and return the builder so that calls can be chained.  *  If both {@link #interval()} and {@link #dateHistogramInterval()} are set, then the  *  {@link #dateHistogramInterval()} wins.  */ public DateHistogramAggregationBuilder interval(long interval) {     if (interval < 1) {         throw new IllegalArgumentException("[interval] must be 1 or greater for histogram aggregation [" + name + "]").     }     this.interval = interval.     return this. }
true;public;0;3;/**  * Get the current date interval that is set on this builder.  */ ;/**  * Get the current date interval that is set on this builder.  */ public DateHistogramInterval dateHistogramInterval() {     return dateHistogramInterval. }
true;public;1;7;/**  * Set the interval on this builder, and return the builder so that calls can be chained.  *  If both {@link #interval()} and {@link #dateHistogramInterval()} are set, then the  *  {@link #dateHistogramInterval()} wins.  */ ;/**  * Set the interval on this builder, and return the builder so that calls can be chained.  *  If both {@link #interval()} and {@link #dateHistogramInterval()} are set, then the  *  {@link #dateHistogramInterval()} wins.  */ public DateHistogramAggregationBuilder dateHistogramInterval(DateHistogramInterval dateHistogramInterval) {     if (dateHistogramInterval == null) {         throw new IllegalArgumentException("[dateHistogramInterval] must not be null: [" + name + "]").     }     this.dateHistogramInterval = dateHistogramInterval.     return this. }
true;public;0;3;/**  * Get the offset to use when rounding, which is a number of milliseconds.  */ ;/**  * Get the offset to use when rounding, which is a number of milliseconds.  */ public long offset() {     return offset. }
true;public;1;4;/**  * Set the offset on this builder, which is a number of milliseconds, and  *  return the builder so that calls can be chained.  */ ;/**  * Set the offset on this builder, which is a number of milliseconds, and  *  return the builder so that calls can be chained.  */ public DateHistogramAggregationBuilder offset(long offset) {     this.offset = offset.     return this. }
true;public;1;6;/**  * Set the offset on this builder, as a time value, and  *  return the builder so that calls can be chained.  */ ;/**  * Set the offset on this builder, as a time value, and  *  return the builder so that calls can be chained.  */ public DateHistogramAggregationBuilder offset(String offset) {     if (offset == null) {         throw new IllegalArgumentException("[offset] must not be null: [" + name + "]").     }     return offset(parseStringOffset(offset)). }
false;static;1;11;;static long parseStringOffset(String offset) {     if (offset.charAt(0) == '-') {         return -TimeValue.parseTimeValue(offset.substring(1), null, DateHistogramAggregationBuilder.class.getSimpleName() + ".parseOffset").millis().     }     int beginIndex = offset.charAt(0) == '+' ? 1 : 0.     return TimeValue.parseTimeValue(offset.substring(beginIndex), null, DateHistogramAggregationBuilder.class.getSimpleName() + ".parseOffset").millis(). }
true;public;0;3;/**  * Return extended bounds for this histogram, or {@code null} if none are set.  */ ;/**  * Return extended bounds for this histogram, or {@code null} if none are set.  */ public ExtendedBounds extendedBounds() {     return extendedBounds. }
true;public;1;7;/**  * Set extended bounds on this histogram, so that buckets would also be  *  generated on intervals that did not match any documents.  */ ;/**  * Set extended bounds on this histogram, so that buckets would also be  *  generated on intervals that did not match any documents.  */ public DateHistogramAggregationBuilder extendedBounds(ExtendedBounds extendedBounds) {     if (extendedBounds == null) {         throw new IllegalArgumentException("[extendedBounds] must not be null: [" + name + "]").     }     this.extendedBounds = extendedBounds.     return this. }
true;public;0;3;/**  * Return the order to use to sort buckets of this histogram.  */ ;/**  * Return the order to use to sort buckets of this histogram.  */ public BucketOrder order() {     return order. }
true;public;1;11;/**  * Set a new order on this builder and return the builder so that calls  *  can be chained. A tie-breaker may be added to avoid non-deterministic ordering.  */ ;/**  * Set a new order on this builder and return the builder so that calls  *  can be chained. A tie-breaker may be added to avoid non-deterministic ordering.  */ public DateHistogramAggregationBuilder order(BucketOrder order) {     if (order == null) {         throw new IllegalArgumentException("[order] must not be null: [" + name + "]").     }     if (order instanceof CompoundOrder || InternalOrder.isKeyOrder(order)) {         // if order already contains a tie-breaker we are good to go         this.order = order.     } else {         // otherwise add a tie-breaker by using a compound order         this.order = BucketOrder.compound(order).     }     return this. }
true;public;1;8;/**  * Sets the order in which the buckets will be returned. A tie-breaker may be added to avoid non-deterministic  * ordering.  */ ;/**  * Sets the order in which the buckets will be returned. A tie-breaker may be added to avoid non-deterministic  * ordering.  */ public DateHistogramAggregationBuilder order(List<BucketOrder> orders) {     if (orders == null) {         throw new IllegalArgumentException("[orders] must not be null: [" + name + "]").     }     // if the list only contains one order use that to avoid inconsistent xcontent     order(orders.size() > 1 ? BucketOrder.compound(orders) : orders.get(0)).     return this. }
true;public;0;3;/**  * Return whether buckets should be returned as a hash. In case  *  {@code keyed} is false, buckets will be returned as an array.  */ ;/**  * Return whether buckets should be returned as a hash. In case  *  {@code keyed} is false, buckets will be returned as an array.  */ public boolean keyed() {     return keyed. }
true;public;1;4;/**  * Set whether to return buckets as a hash or as an array, and return the  *  builder so that calls can be chained.  */ ;/**  * Set whether to return buckets as a hash or as an array, and return the  *  builder so that calls can be chained.  */ public DateHistogramAggregationBuilder keyed(boolean keyed) {     this.keyed = keyed.     return this. }
true;public;0;3;/**  * Return the minimum count of documents that buckets need to have in order  *  to be included in the response.  */ ;/**  * Return the minimum count of documents that buckets need to have in order  *  to be included in the response.  */ public long minDocCount() {     return minDocCount. }
true;public;1;8;/**  * Set the minimum count of matching documents that buckets need to have  *  and return this builder so that calls can be chained.  */ ;/**  * Set the minimum count of matching documents that buckets need to have  *  and return this builder so that calls can be chained.  */ public DateHistogramAggregationBuilder minDocCount(long minDocCount) {     if (minDocCount < 0) {         throw new IllegalArgumentException("[minDocCount] must be greater than or equal to 0. Found [" + minDocCount + "] in [" + name + "]").     }     this.minDocCount = minDocCount.     return this. }
false;protected;2;25;;@Override protected XContentBuilder doXContentBody(XContentBuilder builder, Params params) throws IOException {     if (dateHistogramInterval == null) {         builder.field(Histogram.INTERVAL_FIELD.getPreferredName(), interval).     } else {         builder.field(Histogram.INTERVAL_FIELD.getPreferredName(), dateHistogramInterval.toString()).     }     builder.field(Histogram.OFFSET_FIELD.getPreferredName(), offset).     if (order != null) {         builder.field(Histogram.ORDER_FIELD.getPreferredName()).         order.toXContent(builder, params).     }     builder.field(Histogram.KEYED_FIELD.getPreferredName(), keyed).     builder.field(Histogram.MIN_DOC_COUNT_FIELD.getPreferredName(), minDocCount).     if (extendedBounds != null) {         extendedBounds.toXContent(builder, params).     }     return builder. }
false;public;0;4;;@Override public String getType() {     return NAME. }
true;;1;64;/*      * NOTE: this can't be done in rewrite() because the timezone is then also used on the      * coordinating node in order to generate missing buckets, which may cross a transition      * even though data on the shards doesn't.      */ ;/*      * NOTE: this can't be done in rewrite() because the timezone is then also used on the      * coordinating node in order to generate missing buckets, which may cross a transition      * even though data on the shards doesn't.      */ ZoneId rewriteTimeZone(QueryShardContext context) throws IOException {     final ZoneId tz = timeZone().     if (field() != null && tz != null && tz.getRules().isFixedOffset() == false && field() != null && script() == null) {         final MappedFieldType ft = context.fieldMapper(field()).         final IndexReader reader = context.getIndexReader().         if (ft != null && reader != null) {             Long anyInstant = null.             final IndexNumericFieldData fieldData = context.getForField(ft).             for (LeafReaderContext ctx : reader.leaves()) {                 AtomicNumericFieldData leafFD = fieldData.load(ctx).                 SortedNumericDocValues values = leafFD.getLongValues().                 if (values.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {                     anyInstant = values.nextValue().                     break.                 }             }             if (anyInstant != null) {                 Instant instant = Instant.ofEpochMilli(anyInstant).                 ZoneOffsetTransition prevOffsetTransition = tz.getRules().previousTransition(instant).                 final long prevTransition.                 if (prevOffsetTransition != null) {                     prevTransition = prevOffsetTransition.getInstant().toEpochMilli().                 } else {                     prevTransition = instant.toEpochMilli().                 }                 ZoneOffsetTransition nextOffsetTransition = tz.getRules().nextTransition(instant).                 final long nextTransition.                 if (nextOffsetTransition != null) {                     nextTransition = nextOffsetTransition.getInstant().toEpochMilli().                 } else {                     nextTransition = instant.toEpochMilli().                 }                 // We need all not only values but also rounded values to be within                 // [prevTransition, nextTransition].                 final long low.                 Rounding.DateTimeUnit intervalAsUnit = getIntervalAsDateTimeUnit().                 if (intervalAsUnit != null) {                     Rounding rounding = Rounding.builder(intervalAsUnit).timeZone(timeZone()).build().                     low = rounding.nextRoundingValue(prevTransition).                 } else {                     final TimeValue intervalAsMillis = getIntervalAsTimeValue().                     low = Math.addExact(prevTransition, intervalAsMillis.millis()).                 }                 // rounding rounds down, so 'nextTransition' is a good upper bound                 final long high = nextTransition.                 if (ft.isFieldWithinQuery(reader, low, high, true, false, ZoneOffset.UTC, EPOCH_MILLIS_PARSER, context) == Relation.WITHIN) {                     // combination with time-based indices.                     return ZoneOffset.ofTotalSeconds(tz.getRules().getOffset(instant).getTotalSeconds()).                 }             }         }     }     return tz. }
false;protected;4;21;;@Override protected ValuesSourceAggregatorFactory<Numeric, ?> innerBuild(SearchContext context, ValuesSourceConfig<Numeric> config, AggregatorFactory<?> parent, Builder subFactoriesBuilder) throws IOException {     final ZoneId tz = timeZone().     final Rounding rounding = createRounding(tz).     final ZoneId rewrittenTimeZone = rewriteTimeZone(context.getQueryShardContext()).     final Rounding shardRounding.     if (tz == rewrittenTimeZone) {         shardRounding = rounding.     } else {         shardRounding = createRounding(rewrittenTimeZone).     }     ExtendedBounds roundedBounds = null.     if (this.extendedBounds != null) {         // parse any string bounds to longs and round         roundedBounds = this.extendedBounds.parseAndValidate(name, context, config.format()).round(rounding).     }     return new DateHistogramAggregatorFactory(name, config, offset, order, keyed, minDocCount, rounding, shardRounding, roundedBounds, context, parent, subFactoriesBuilder, metaData). }
true;private;0;6;/**  * Return the interval as a date time unit if applicable. If this returns  *  {@code null} then it means that the interval is expressed as a fixed  *  {@link TimeValue} and may be accessed via  *  {@link #getIntervalAsTimeValue()}.  */ ;/**  * Return the interval as a date time unit if applicable. If this returns  *  {@code null} then it means that the interval is expressed as a fixed  *  {@link TimeValue} and may be accessed via  *  {@link #getIntervalAsTimeValue()}.  */ private Rounding.DateTimeUnit getIntervalAsDateTimeUnit() {     if (dateHistogramInterval != null) {         return DATE_FIELD_UNITS.get(dateHistogramInterval.toString()).     }     return null. }
true;private;0;7;/**  * Get the interval as a {@link TimeValue}. Should only be called if  * {@link #getIntervalAsDateTimeUnit()} returned {@code null}.  */ ;/**  * Get the interval as a {@link TimeValue}. Should only be called if  * {@link #getIntervalAsDateTimeUnit()} returned {@code null}.  */ private TimeValue getIntervalAsTimeValue() {     if (dateHistogramInterval != null) {         return TimeValue.parseTimeValue(dateHistogramInterval.toString(), null, getClass().getSimpleName() + ".interval").     } else {         return TimeValue.timeValueMillis(interval).     } }
false;private;1;14;;private Rounding createRounding(ZoneId timeZone) {     Rounding.Builder tzRoundingBuilder.     Rounding.DateTimeUnit intervalAsUnit = getIntervalAsDateTimeUnit().     if (intervalAsUnit != null) {         tzRoundingBuilder = Rounding.builder(intervalAsUnit).     } else {         tzRoundingBuilder = Rounding.builder(getIntervalAsTimeValue()).     }     if (timeZone != null) {         tzRoundingBuilder.timeZone(timeZone).     }     Rounding rounding = tzRoundingBuilder.build().     return rounding. }
false;protected;0;4;;@Override protected int innerHashCode() {     return Objects.hash(order, keyed, minDocCount, interval, dateHistogramInterval, minDocCount, extendedBounds). }
false;protected;1;11;;@Override protected boolean innerEquals(Object obj) {     DateHistogramAggregationBuilder other = (DateHistogramAggregationBuilder) obj.     return Objects.equals(order, other.order) && Objects.equals(keyed, other.keyed) && Objects.equals(minDocCount, other.minDocCount) && Objects.equals(interval, other.interval) && Objects.equals(dateHistogramInterval, other.dateHistogramInterval) && Objects.equals(offset, other.offset) && Objects.equals(extendedBounds, other.extendedBounds). }
