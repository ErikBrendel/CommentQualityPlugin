# id;timestamp;commentText;codeText;commentWords;codeWords
PersistentTasksClusterService -> private <Params extends PersistentTaskParams> Assignment createAssignment(final String taskName,                                                                               final Params taskParams,                                                                               final ClusterState currentState);1528103657;Creates a new {@link Assignment} for the given persistent task.__@param taskName the task's name_@param taskParams the task's parameters_@param currentState the current {@link ClusterState}__@return a new {@link Assignment};private <Params extends PersistentTaskParams> Assignment createAssignment(final String taskName,_                                                                              final Params taskParams,_                                                                              final ClusterState currentState) {_        PersistentTasksExecutor<Params> persistentTasksExecutor = registry.getPersistentTaskExecutorSafe(taskName)___        AssignmentDecision decision = decider.canAssign()__        if (decision.getType() == AssignmentDecision.Type.NO) {_            return new Assignment(null, "persistent task [" + taskName + "] cannot be assigned [" + decision.getReason() + "]")__        }__        return persistentTasksExecutor.getAssignment(taskParams, currentState)__    };creates,a,new,link,assignment,for,the,given,persistent,task,param,task,name,the,task,s,name,param,task,params,the,task,s,parameters,param,current,state,the,current,link,cluster,state,return,a,new,link,assignment;private,params,extends,persistent,task,params,assignment,create,assignment,final,string,task,name,final,params,task,params,final,cluster,state,current,state,persistent,tasks,executor,params,persistent,tasks,executor,registry,get,persistent,task,executor,safe,task,name,assignment,decision,decision,decider,can,assign,if,decision,get,type,assignment,decision,type,no,return,new,assignment,null,persistent,task,task,name,cannot,be,assigned,decision,get,reason,return,persistent,tasks,executor,get,assignment,task,params,current,state
PersistentTasksClusterService -> private <Params extends PersistentTaskParams> Assignment createAssignment(final String taskName,                                                                               final Params taskParams,                                                                               final ClusterState currentState);1529076503;Creates a new {@link Assignment} for the given persistent task.__@param taskName the task's name_@param taskParams the task's parameters_@param currentState the current {@link ClusterState}__@return a new {@link Assignment};private <Params extends PersistentTaskParams> Assignment createAssignment(final String taskName,_                                                                              final Params taskParams,_                                                                              final ClusterState currentState) {_        PersistentTasksExecutor<Params> persistentTasksExecutor = registry.getPersistentTaskExecutorSafe(taskName)___        AssignmentDecision decision = decider.canAssign()__        if (decision.getType() == AssignmentDecision.Type.NO) {_            return new Assignment(null, "persistent task [" + taskName + "] cannot be assigned [" + decision.getReason() + "]")__        }__        return persistentTasksExecutor.getAssignment(taskParams, currentState)__    };creates,a,new,link,assignment,for,the,given,persistent,task,param,task,name,the,task,s,name,param,task,params,the,task,s,parameters,param,current,state,the,current,link,cluster,state,return,a,new,link,assignment;private,params,extends,persistent,task,params,assignment,create,assignment,final,string,task,name,final,params,task,params,final,cluster,state,current,state,persistent,tasks,executor,params,persistent,tasks,executor,registry,get,persistent,task,executor,safe,task,name,assignment,decision,decision,decider,can,assign,if,decision,get,type,assignment,decision,type,no,return,new,assignment,null,persistent,task,task,name,cannot,be,assigned,decision,get,reason,return,persistent,tasks,executor,get,assignment,task,params,current,state
PersistentTasksClusterService -> private <Params extends PersistentTaskParams> Assignment createAssignment(final String taskName,                                                                               final Params taskParams,                                                                               final ClusterState currentState);1532353780;Creates a new {@link Assignment} for the given persistent task.__@param taskName the task's name_@param taskParams the task's parameters_@param currentState the current {@link ClusterState}__@return a new {@link Assignment};private <Params extends PersistentTaskParams> Assignment createAssignment(final String taskName,_                                                                              final Params taskParams,_                                                                              final ClusterState currentState) {_        PersistentTasksExecutor<Params> persistentTasksExecutor = registry.getPersistentTaskExecutorSafe(taskName)___        AssignmentDecision decision = decider.canAssign()__        if (decision.getType() == AssignmentDecision.Type.NO) {_            return new Assignment(null, "persistent task [" + taskName + "] cannot be assigned [" + decision.getReason() + "]")__        }__        return persistentTasksExecutor.getAssignment(taskParams, currentState)__    };creates,a,new,link,assignment,for,the,given,persistent,task,param,task,name,the,task,s,name,param,task,params,the,task,s,parameters,param,current,state,the,current,link,cluster,state,return,a,new,link,assignment;private,params,extends,persistent,task,params,assignment,create,assignment,final,string,task,name,final,params,task,params,final,cluster,state,current,state,persistent,tasks,executor,params,persistent,tasks,executor,registry,get,persistent,task,executor,safe,task,name,assignment,decision,decision,decider,can,assign,if,decision,get,type,assignment,decision,type,no,return,new,assignment,null,persistent,task,task,name,cannot,be,assigned,decision,get,reason,return,persistent,tasks,executor,get,assignment,task,params,current,state
PersistentTasksClusterService -> private <Params extends PersistentTaskParams> Assignment createAssignment(final String taskName,                                                                               final Params taskParams,                                                                               final ClusterState currentState);1541092382;Creates a new {@link Assignment} for the given persistent task.__@param taskName the task's name_@param taskParams the task's parameters_@param currentState the current {@link ClusterState}__@return a new {@link Assignment};private <Params extends PersistentTaskParams> Assignment createAssignment(final String taskName,_                                                                              final Params taskParams,_                                                                              final ClusterState currentState) {_        PersistentTasksExecutor<Params> persistentTasksExecutor = registry.getPersistentTaskExecutorSafe(taskName)___        AssignmentDecision decision = decider.canAssign()__        if (decision.getType() == AssignmentDecision.Type.NO) {_            return new Assignment(null, "persistent task [" + taskName + "] cannot be assigned [" + decision.getReason() + "]")__        }__        return persistentTasksExecutor.getAssignment(taskParams, currentState)__    };creates,a,new,link,assignment,for,the,given,persistent,task,param,task,name,the,task,s,name,param,task,params,the,task,s,parameters,param,current,state,the,current,link,cluster,state,return,a,new,link,assignment;private,params,extends,persistent,task,params,assignment,create,assignment,final,string,task,name,final,params,task,params,final,cluster,state,current,state,persistent,tasks,executor,params,persistent,tasks,executor,registry,get,persistent,task,executor,safe,task,name,assignment,decision,decision,decider,can,assign,if,decision,get,type,assignment,decision,type,no,return,new,assignment,null,persistent,task,task,name,cannot,be,assigned,decision,get,reason,return,persistent,tasks,executor,get,assignment,task,params,current,state
PersistentTasksClusterService -> private <Params extends PersistentTaskParams> Assignment createAssignment(final String taskName,                                                                               final Params taskParams,                                                                               final ClusterState currentState);1542402632;Creates a new {@link Assignment} for the given persistent task.__@param taskName the task's name_@param taskParams the task's parameters_@param currentState the current {@link ClusterState}__@return a new {@link Assignment};private <Params extends PersistentTaskParams> Assignment createAssignment(final String taskName,_                                                                              final Params taskParams,_                                                                              final ClusterState currentState) {_        PersistentTasksExecutor<Params> persistentTasksExecutor = registry.getPersistentTaskExecutorSafe(taskName)___        AssignmentDecision decision = decider.canAssign()__        if (decision.getType() == AssignmentDecision.Type.NO) {_            return new Assignment(null, "persistent task [" + taskName + "] cannot be assigned [" + decision.getReason() + "]")__        }__        return persistentTasksExecutor.getAssignment(taskParams, currentState)__    };creates,a,new,link,assignment,for,the,given,persistent,task,param,task,name,the,task,s,name,param,task,params,the,task,s,parameters,param,current,state,the,current,link,cluster,state,return,a,new,link,assignment;private,params,extends,persistent,task,params,assignment,create,assignment,final,string,task,name,final,params,task,params,final,cluster,state,current,state,persistent,tasks,executor,params,persistent,tasks,executor,registry,get,persistent,task,executor,safe,task,name,assignment,decision,decision,decider,can,assign,if,decision,get,type,assignment,decision,type,no,return,new,assignment,null,persistent,task,task,name,cannot,be,assigned,decision,get,reason,return,persistent,tasks,executor,get,assignment,task,params,current,state
PersistentTasksClusterService -> private <Params extends PersistentTaskParams> Assignment createAssignment(final String taskName,                                                                               final Params taskParams,                                                                               final ClusterState currentState);1544692527;Creates a new {@link Assignment} for the given persistent task.__@param taskName the task's name_@param taskParams the task's parameters_@param currentState the current {@link ClusterState}__@return a new {@link Assignment};private <Params extends PersistentTaskParams> Assignment createAssignment(final String taskName,_                                                                              final Params taskParams,_                                                                              final ClusterState currentState) {_        PersistentTasksExecutor<Params> persistentTasksExecutor = registry.getPersistentTaskExecutorSafe(taskName)___        AssignmentDecision decision = decider.canAssign()__        if (decision.getType() == AssignmentDecision.Type.NO) {_            return new Assignment(null, "persistent task [" + taskName + "] cannot be assigned [" + decision.getReason() + "]")__        }__        return persistentTasksExecutor.getAssignment(taskParams, currentState)__    };creates,a,new,link,assignment,for,the,given,persistent,task,param,task,name,the,task,s,name,param,task,params,the,task,s,parameters,param,current,state,the,current,link,cluster,state,return,a,new,link,assignment;private,params,extends,persistent,task,params,assignment,create,assignment,final,string,task,name,final,params,task,params,final,cluster,state,current,state,persistent,tasks,executor,params,persistent,tasks,executor,registry,get,persistent,task,executor,safe,task,name,assignment,decision,decision,decider,can,assign,if,decision,get,type,assignment,decision,type,no,return,new,assignment,null,persistent,task,task,name,cannot,be,assigned,decision,get,reason,return,persistent,tasks,executor,get,assignment,task,params,current,state
PersistentTasksClusterService -> private <Params extends PersistentTaskParams> Assignment createAssignment(final String taskName,                                                                               final Params taskParams,                                                                               final ClusterState currentState);1545310416;Creates a new {@link Assignment} for the given persistent task.__@param taskName the task's name_@param taskParams the task's parameters_@param currentState the current {@link ClusterState}__@return a new {@link Assignment};private <Params extends PersistentTaskParams> Assignment createAssignment(final String taskName,_                                                                              final Params taskParams,_                                                                              final ClusterState currentState) {_        PersistentTasksExecutor<Params> persistentTasksExecutor = registry.getPersistentTaskExecutorSafe(taskName)___        AssignmentDecision decision = decider.canAssign()__        if (decision.getType() == AssignmentDecision.Type.NO) {_            return new Assignment(null, "persistent task [" + taskName + "] cannot be assigned [" + decision.getReason() + "]")__        }__        return persistentTasksExecutor.getAssignment(taskParams, currentState)__    };creates,a,new,link,assignment,for,the,given,persistent,task,param,task,name,the,task,s,name,param,task,params,the,task,s,parameters,param,current,state,the,current,link,cluster,state,return,a,new,link,assignment;private,params,extends,persistent,task,params,assignment,create,assignment,final,string,task,name,final,params,task,params,final,cluster,state,current,state,persistent,tasks,executor,params,persistent,tasks,executor,registry,get,persistent,task,executor,safe,task,name,assignment,decision,decision,decider,can,assign,if,decision,get,type,assignment,decision,type,no,return,new,assignment,null,persistent,task,task,name,cannot,be,assigned,decision,get,reason,return,persistent,tasks,executor,get,assignment,task,params,current,state
PersistentTasksClusterService -> private <Params extends PersistentTaskParams> Assignment createAssignment(final String taskName,                                                                               final Params taskParams,                                                                               final ClusterState currentState);1548265712;Creates a new {@link Assignment} for the given persistent task.__@param taskName the task's name_@param taskParams the task's parameters_@param currentState the current {@link ClusterState}__@return a new {@link Assignment};private <Params extends PersistentTaskParams> Assignment createAssignment(final String taskName,_                                                                              final Params taskParams,_                                                                              final ClusterState currentState) {_        PersistentTasksExecutor<Params> persistentTasksExecutor = registry.getPersistentTaskExecutorSafe(taskName)___        AssignmentDecision decision = decider.canAssign()__        if (decision.getType() == AssignmentDecision.Type.NO) {_            return unassignedAssignment("persistent task [" + taskName + "] cannot be assigned [" + decision.getReason() + "]")__        }__        return persistentTasksExecutor.getAssignment(taskParams, currentState)__    };creates,a,new,link,assignment,for,the,given,persistent,task,param,task,name,the,task,s,name,param,task,params,the,task,s,parameters,param,current,state,the,current,link,cluster,state,return,a,new,link,assignment;private,params,extends,persistent,task,params,assignment,create,assignment,final,string,task,name,final,params,task,params,final,cluster,state,current,state,persistent,tasks,executor,params,persistent,tasks,executor,registry,get,persistent,task,executor,safe,task,name,assignment,decision,decision,decider,can,assign,if,decision,get,type,assignment,decision,type,no,return,unassigned,assignment,persistent,task,task,name,cannot,be,assigned,decision,get,reason,return,persistent,tasks,executor,get,assignment,task,params,current,state
PersistentTasksClusterService -> public void updatePersistentTaskState(final String taskId,                                           final long taskAllocationId,                                           final PersistentTaskState taskState,                                           final ActionListener<PersistentTask<?>> listener);1529076503;Update the state of a persistent task__@param taskId           the id of a persistent task_@param taskAllocationId the expected allocation id of the persistent task_@param taskState        new state_@param listener         the listener that will be called when task is removed;public void updatePersistentTaskState(final String taskId,_                                          final long taskAllocationId,_                                          final PersistentTaskState taskState,_                                          final ActionListener<PersistentTask<?>> listener) {_        clusterService.submitStateUpdateTask("update task state", new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                PersistentTasksCustomMetaData.Builder tasksInProgress = builder(currentState)__                if (tasksInProgress.hasTask(taskId, taskAllocationId)) {_                    return update(currentState, tasksInProgress.updateTaskState(taskId, taskState))__                } else {_                    if (tasksInProgress.hasTask(taskId)) {_                        logger.warn("trying to update state on task {} with unexpected allocation id {}", taskId, taskAllocationId)__                    } else {_                        logger.warn("trying to update state on non-existing task {}", taskId)__                    }_                    throw new ResourceNotFoundException("the task with id {} and allocation id {} doesn't exist", taskId, taskAllocationId)__                }_            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                listener.onResponse(PersistentTasksCustomMetaData.getTaskWithId(newState, taskId))__            }_        })__    };update,the,state,of,a,persistent,task,param,task,id,the,id,of,a,persistent,task,param,task,allocation,id,the,expected,allocation,id,of,the,persistent,task,param,task,state,new,state,param,listener,the,listener,that,will,be,called,when,task,is,removed;public,void,update,persistent,task,state,final,string,task,id,final,long,task,allocation,id,final,persistent,task,state,task,state,final,action,listener,persistent,task,listener,cluster,service,submit,state,update,task,update,task,state,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,persistent,tasks,custom,meta,data,builder,tasks,in,progress,builder,current,state,if,tasks,in,progress,has,task,task,id,task,allocation,id,return,update,current,state,tasks,in,progress,update,task,state,task,id,task,state,else,if,tasks,in,progress,has,task,task,id,logger,warn,trying,to,update,state,on,task,with,unexpected,allocation,id,task,id,task,allocation,id,else,logger,warn,trying,to,update,state,on,non,existing,task,task,id,throw,new,resource,not,found,exception,the,task,with,id,and,allocation,id,doesn,t,exist,task,id,task,allocation,id,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,persistent,tasks,custom,meta,data,get,task,with,id,new,state,task,id
PersistentTasksClusterService -> public void updatePersistentTaskState(final String taskId,                                           final long taskAllocationId,                                           final PersistentTaskState taskState,                                           final ActionListener<PersistentTask<?>> listener);1532353780;Update the state of a persistent task__@param taskId           the id of a persistent task_@param taskAllocationId the expected allocation id of the persistent task_@param taskState        new state_@param listener         the listener that will be called when task is removed;public void updatePersistentTaskState(final String taskId,_                                          final long taskAllocationId,_                                          final PersistentTaskState taskState,_                                          final ActionListener<PersistentTask<?>> listener) {_        clusterService.submitStateUpdateTask("update task state", new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                PersistentTasksCustomMetaData.Builder tasksInProgress = builder(currentState)__                if (tasksInProgress.hasTask(taskId, taskAllocationId)) {_                    return update(currentState, tasksInProgress.updateTaskState(taskId, taskState))__                } else {_                    if (tasksInProgress.hasTask(taskId)) {_                        logger.warn("trying to update state on task {} with unexpected allocation id {}", taskId, taskAllocationId)__                    } else {_                        logger.warn("trying to update state on non-existing task {}", taskId)__                    }_                    throw new ResourceNotFoundException("the task with id {} and allocation id {} doesn't exist", taskId, taskAllocationId)__                }_            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                listener.onResponse(PersistentTasksCustomMetaData.getTaskWithId(newState, taskId))__            }_        })__    };update,the,state,of,a,persistent,task,param,task,id,the,id,of,a,persistent,task,param,task,allocation,id,the,expected,allocation,id,of,the,persistent,task,param,task,state,new,state,param,listener,the,listener,that,will,be,called,when,task,is,removed;public,void,update,persistent,task,state,final,string,task,id,final,long,task,allocation,id,final,persistent,task,state,task,state,final,action,listener,persistent,task,listener,cluster,service,submit,state,update,task,update,task,state,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,persistent,tasks,custom,meta,data,builder,tasks,in,progress,builder,current,state,if,tasks,in,progress,has,task,task,id,task,allocation,id,return,update,current,state,tasks,in,progress,update,task,state,task,id,task,state,else,if,tasks,in,progress,has,task,task,id,logger,warn,trying,to,update,state,on,task,with,unexpected,allocation,id,task,id,task,allocation,id,else,logger,warn,trying,to,update,state,on,non,existing,task,task,id,throw,new,resource,not,found,exception,the,task,with,id,and,allocation,id,doesn,t,exist,task,id,task,allocation,id,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,persistent,tasks,custom,meta,data,get,task,with,id,new,state,task,id
PersistentTasksClusterService -> public void updatePersistentTaskState(final String taskId,                                           final long taskAllocationId,                                           final PersistentTaskState taskState,                                           final ActionListener<PersistentTask<?>> listener);1541092382;Update the state of a persistent task__@param taskId           the id of a persistent task_@param taskAllocationId the expected allocation id of the persistent task_@param taskState        new state_@param listener         the listener that will be called when task is removed;public void updatePersistentTaskState(final String taskId,_                                          final long taskAllocationId,_                                          final PersistentTaskState taskState,_                                          final ActionListener<PersistentTask<?>> listener) {_        clusterService.submitStateUpdateTask("update task state", new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                PersistentTasksCustomMetaData.Builder tasksInProgress = builder(currentState)__                if (tasksInProgress.hasTask(taskId, taskAllocationId)) {_                    return update(currentState, tasksInProgress.updateTaskState(taskId, taskState))__                } else {_                    if (tasksInProgress.hasTask(taskId)) {_                        logger.warn("trying to update state on task {} with unexpected allocation id {}", taskId, taskAllocationId)__                    } else {_                        logger.warn("trying to update state on non-existing task {}", taskId)__                    }_                    throw new ResourceNotFoundException("the task with id {} and allocation id {} doesn't exist", taskId, taskAllocationId)__                }_            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                listener.onResponse(PersistentTasksCustomMetaData.getTaskWithId(newState, taskId))__            }_        })__    };update,the,state,of,a,persistent,task,param,task,id,the,id,of,a,persistent,task,param,task,allocation,id,the,expected,allocation,id,of,the,persistent,task,param,task,state,new,state,param,listener,the,listener,that,will,be,called,when,task,is,removed;public,void,update,persistent,task,state,final,string,task,id,final,long,task,allocation,id,final,persistent,task,state,task,state,final,action,listener,persistent,task,listener,cluster,service,submit,state,update,task,update,task,state,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,persistent,tasks,custom,meta,data,builder,tasks,in,progress,builder,current,state,if,tasks,in,progress,has,task,task,id,task,allocation,id,return,update,current,state,tasks,in,progress,update,task,state,task,id,task,state,else,if,tasks,in,progress,has,task,task,id,logger,warn,trying,to,update,state,on,task,with,unexpected,allocation,id,task,id,task,allocation,id,else,logger,warn,trying,to,update,state,on,non,existing,task,task,id,throw,new,resource,not,found,exception,the,task,with,id,and,allocation,id,doesn,t,exist,task,id,task,allocation,id,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,persistent,tasks,custom,meta,data,get,task,with,id,new,state,task,id
PersistentTasksClusterService -> public void updatePersistentTaskState(final String taskId,                                           final long taskAllocationId,                                           final PersistentTaskState taskState,                                           final ActionListener<PersistentTask<?>> listener);1542402632;Update the state of a persistent task__@param taskId           the id of a persistent task_@param taskAllocationId the expected allocation id of the persistent task_@param taskState        new state_@param listener         the listener that will be called when task is removed;public void updatePersistentTaskState(final String taskId,_                                          final long taskAllocationId,_                                          final PersistentTaskState taskState,_                                          final ActionListener<PersistentTask<?>> listener) {_        clusterService.submitStateUpdateTask("update task state", new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                PersistentTasksCustomMetaData.Builder tasksInProgress = builder(currentState)__                if (tasksInProgress.hasTask(taskId, taskAllocationId)) {_                    return update(currentState, tasksInProgress.updateTaskState(taskId, taskState))__                } else {_                    if (tasksInProgress.hasTask(taskId)) {_                        logger.warn("trying to update state on task {} with unexpected allocation id {}", taskId, taskAllocationId)__                    } else {_                        logger.warn("trying to update state on non-existing task {}", taskId)__                    }_                    throw new ResourceNotFoundException("the task with id {} and allocation id {} doesn't exist", taskId, taskAllocationId)__                }_            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                listener.onResponse(PersistentTasksCustomMetaData.getTaskWithId(newState, taskId))__            }_        })__    };update,the,state,of,a,persistent,task,param,task,id,the,id,of,a,persistent,task,param,task,allocation,id,the,expected,allocation,id,of,the,persistent,task,param,task,state,new,state,param,listener,the,listener,that,will,be,called,when,task,is,removed;public,void,update,persistent,task,state,final,string,task,id,final,long,task,allocation,id,final,persistent,task,state,task,state,final,action,listener,persistent,task,listener,cluster,service,submit,state,update,task,update,task,state,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,persistent,tasks,custom,meta,data,builder,tasks,in,progress,builder,current,state,if,tasks,in,progress,has,task,task,id,task,allocation,id,return,update,current,state,tasks,in,progress,update,task,state,task,id,task,state,else,if,tasks,in,progress,has,task,task,id,logger,warn,trying,to,update,state,on,task,with,unexpected,allocation,id,task,id,task,allocation,id,else,logger,warn,trying,to,update,state,on,non,existing,task,task,id,throw,new,resource,not,found,exception,the,task,with,id,and,allocation,id,doesn,t,exist,task,id,task,allocation,id,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,persistent,tasks,custom,meta,data,get,task,with,id,new,state,task,id
PersistentTasksClusterService -> public void updatePersistentTaskState(final String taskId,                                           final long taskAllocationId,                                           final PersistentTaskState taskState,                                           final ActionListener<PersistentTask<?>> listener);1544692527;Update the state of a persistent task__@param taskId           the id of a persistent task_@param taskAllocationId the expected allocation id of the persistent task_@param taskState        new state_@param listener         the listener that will be called when task is removed;public void updatePersistentTaskState(final String taskId,_                                          final long taskAllocationId,_                                          final PersistentTaskState taskState,_                                          final ActionListener<PersistentTask<?>> listener) {_        clusterService.submitStateUpdateTask("update task state", new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                PersistentTasksCustomMetaData.Builder tasksInProgress = builder(currentState)__                if (tasksInProgress.hasTask(taskId, taskAllocationId)) {_                    return update(currentState, tasksInProgress.updateTaskState(taskId, taskState))__                } else {_                    if (tasksInProgress.hasTask(taskId)) {_                        logger.warn("trying to update state on task {} with unexpected allocation id {}", taskId, taskAllocationId)__                    } else {_                        logger.warn("trying to update state on non-existing task {}", taskId)__                    }_                    throw new ResourceNotFoundException("the task with id {} and allocation id {} doesn't exist", taskId, taskAllocationId)__                }_            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                listener.onResponse(PersistentTasksCustomMetaData.getTaskWithId(newState, taskId))__            }_        })__    };update,the,state,of,a,persistent,task,param,task,id,the,id,of,a,persistent,task,param,task,allocation,id,the,expected,allocation,id,of,the,persistent,task,param,task,state,new,state,param,listener,the,listener,that,will,be,called,when,task,is,removed;public,void,update,persistent,task,state,final,string,task,id,final,long,task,allocation,id,final,persistent,task,state,task,state,final,action,listener,persistent,task,listener,cluster,service,submit,state,update,task,update,task,state,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,persistent,tasks,custom,meta,data,builder,tasks,in,progress,builder,current,state,if,tasks,in,progress,has,task,task,id,task,allocation,id,return,update,current,state,tasks,in,progress,update,task,state,task,id,task,state,else,if,tasks,in,progress,has,task,task,id,logger,warn,trying,to,update,state,on,task,with,unexpected,allocation,id,task,id,task,allocation,id,else,logger,warn,trying,to,update,state,on,non,existing,task,task,id,throw,new,resource,not,found,exception,the,task,with,id,and,allocation,id,doesn,t,exist,task,id,task,allocation,id,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,persistent,tasks,custom,meta,data,get,task,with,id,new,state,task,id
PersistentTasksClusterService -> public void updatePersistentTaskState(final String taskId,                                           final long taskAllocationId,                                           final PersistentTaskState taskState,                                           final ActionListener<PersistentTask<?>> listener);1545310416;Update the state of a persistent task__@param taskId           the id of a persistent task_@param taskAllocationId the expected allocation id of the persistent task_@param taskState        new state_@param listener         the listener that will be called when task is removed;public void updatePersistentTaskState(final String taskId,_                                          final long taskAllocationId,_                                          final PersistentTaskState taskState,_                                          final ActionListener<PersistentTask<?>> listener) {_        clusterService.submitStateUpdateTask("update task state", new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                PersistentTasksCustomMetaData.Builder tasksInProgress = builder(currentState)__                if (tasksInProgress.hasTask(taskId, taskAllocationId)) {_                    return update(currentState, tasksInProgress.updateTaskState(taskId, taskState))__                } else {_                    if (tasksInProgress.hasTask(taskId)) {_                        logger.warn("trying to update state on task {} with unexpected allocation id {}", taskId, taskAllocationId)__                    } else {_                        logger.warn("trying to update state on non-existing task {}", taskId)__                    }_                    throw new ResourceNotFoundException("the task with id {} and allocation id {} doesn't exist", taskId, taskAllocationId)__                }_            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                listener.onResponse(PersistentTasksCustomMetaData.getTaskWithId(newState, taskId))__            }_        })__    };update,the,state,of,a,persistent,task,param,task,id,the,id,of,a,persistent,task,param,task,allocation,id,the,expected,allocation,id,of,the,persistent,task,param,task,state,new,state,param,listener,the,listener,that,will,be,called,when,task,is,removed;public,void,update,persistent,task,state,final,string,task,id,final,long,task,allocation,id,final,persistent,task,state,task,state,final,action,listener,persistent,task,listener,cluster,service,submit,state,update,task,update,task,state,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,persistent,tasks,custom,meta,data,builder,tasks,in,progress,builder,current,state,if,tasks,in,progress,has,task,task,id,task,allocation,id,return,update,current,state,tasks,in,progress,update,task,state,task,id,task,state,else,if,tasks,in,progress,has,task,task,id,logger,warn,trying,to,update,state,on,task,with,unexpected,allocation,id,task,id,task,allocation,id,else,logger,warn,trying,to,update,state,on,non,existing,task,task,id,throw,new,resource,not,found,exception,the,task,with,id,and,allocation,id,doesn,t,exist,task,id,task,allocation,id,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,persistent,tasks,custom,meta,data,get,task,with,id,new,state,task,id
PersistentTasksClusterService -> public void updatePersistentTaskState(final String taskId,                                           final long taskAllocationId,                                           final PersistentTaskState taskState,                                           final ActionListener<PersistentTask<?>> listener);1548265712;Update the state of a persistent task__@param taskId           the id of a persistent task_@param taskAllocationId the expected allocation id of the persistent task_@param taskState        new state_@param listener         the listener that will be called when task is removed;public void updatePersistentTaskState(final String taskId,_                                          final long taskAllocationId,_                                          final PersistentTaskState taskState,_                                          final ActionListener<PersistentTask<?>> listener) {_        clusterService.submitStateUpdateTask("update task state", new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                PersistentTasksCustomMetaData.Builder tasksInProgress = builder(currentState)__                if (tasksInProgress.hasTask(taskId, taskAllocationId)) {_                    return update(currentState, tasksInProgress.updateTaskState(taskId, taskState))__                } else {_                    if (tasksInProgress.hasTask(taskId)) {_                        logger.warn("trying to update state on task {} with unexpected allocation id {}", taskId, taskAllocationId)__                    } else {_                        logger.warn("trying to update state on non-existing task {}", taskId)__                    }_                    throw new ResourceNotFoundException("the task with id {} and allocation id {} doesn't exist", taskId, taskAllocationId)__                }_            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                listener.onResponse(PersistentTasksCustomMetaData.getTaskWithId(newState, taskId))__            }_        })__    };update,the,state,of,a,persistent,task,param,task,id,the,id,of,a,persistent,task,param,task,allocation,id,the,expected,allocation,id,of,the,persistent,task,param,task,state,new,state,param,listener,the,listener,that,will,be,called,when,task,is,removed;public,void,update,persistent,task,state,final,string,task,id,final,long,task,allocation,id,final,persistent,task,state,task,state,final,action,listener,persistent,task,listener,cluster,service,submit,state,update,task,update,task,state,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,persistent,tasks,custom,meta,data,builder,tasks,in,progress,builder,current,state,if,tasks,in,progress,has,task,task,id,task,allocation,id,return,update,current,state,tasks,in,progress,update,task,state,task,id,task,state,else,if,tasks,in,progress,has,task,task,id,logger,warn,trying,to,update,state,on,task,with,unexpected,allocation,id,task,id,task,allocation,id,else,logger,warn,trying,to,update,state,on,non,existing,task,task,id,throw,new,resource,not,found,exception,the,task,with,id,and,allocation,id,doesn,t,exist,task,id,task,allocation,id,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,persistent,tasks,custom,meta,data,get,task,with,id,new,state,task,id
PersistentTasksClusterService -> private void reassignPersistentTasks();1544692527;Submit a cluster state update to reassign any persistent tasks that need reassigning;private void reassignPersistentTasks() {_        clusterService.submitStateUpdateTask("reassign persistent tasks", new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                return reassignTasks(currentState)__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn("failed to reassign persistent tasks", e)__                _                _                periodicRechecker.rescheduleIfNecessary()__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                if (isAnyTaskUnassigned(newState.getMetaData().custom(PersistentTasksCustomMetaData.TYPE))) {_                    periodicRechecker.rescheduleIfNecessary()__                }_            }_        })__    };submit,a,cluster,state,update,to,reassign,any,persistent,tasks,that,need,reassigning;private,void,reassign,persistent,tasks,cluster,service,submit,state,update,task,reassign,persistent,tasks,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,return,reassign,tasks,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,failed,to,reassign,persistent,tasks,e,periodic,rechecker,reschedule,if,necessary,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,if,is,any,task,unassigned,new,state,get,meta,data,custom,persistent,tasks,custom,meta,data,type,periodic,rechecker,reschedule,if,necessary
PersistentTasksClusterService -> private void reassignPersistentTasks();1545310416;Submit a cluster state update to reassign any persistent tasks that need reassigning;private void reassignPersistentTasks() {_        clusterService.submitStateUpdateTask("reassign persistent tasks", new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                return reassignTasks(currentState)__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn("failed to reassign persistent tasks", e)__                _                _                periodicRechecker.rescheduleIfNecessary()__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                if (isAnyTaskUnassigned(newState.getMetaData().custom(PersistentTasksCustomMetaData.TYPE))) {_                    periodicRechecker.rescheduleIfNecessary()__                }_            }_        })__    };submit,a,cluster,state,update,to,reassign,any,persistent,tasks,that,need,reassigning;private,void,reassign,persistent,tasks,cluster,service,submit,state,update,task,reassign,persistent,tasks,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,return,reassign,tasks,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,failed,to,reassign,persistent,tasks,e,periodic,rechecker,reschedule,if,necessary,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,if,is,any,task,unassigned,new,state,get,meta,data,custom,persistent,tasks,custom,meta,data,type,periodic,rechecker,reschedule,if,necessary
PersistentTasksClusterService -> private void reassignPersistentTasks();1548265712;Submit a cluster state update to reassign any persistent tasks that need reassigning;private void reassignPersistentTasks() {_        clusterService.submitStateUpdateTask("reassign persistent tasks", new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                return reassignTasks(currentState)__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn("failed to reassign persistent tasks", e)__                _                _                periodicRechecker.rescheduleIfNecessary()__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                if (isAnyTaskUnassigned(newState.getMetaData().custom(PersistentTasksCustomMetaData.TYPE))) {_                    periodicRechecker.rescheduleIfNecessary()__                }_            }_        })__    };submit,a,cluster,state,update,to,reassign,any,persistent,tasks,that,need,reassigning;private,void,reassign,persistent,tasks,cluster,service,submit,state,update,task,reassign,persistent,tasks,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,return,reassign,tasks,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,failed,to,reassign,persistent,tasks,e,periodic,rechecker,reschedule,if,necessary,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,if,is,any,task,unassigned,new,state,get,meta,data,custom,persistent,tasks,custom,meta,data,type,periodic,rechecker,reschedule,if,necessary
PersistentTasksClusterService -> public <Params extends PersistentTaskParams> void createPersistentTask(String taskId, String taskName, Params taskParams,                                                                            ActionListener<PersistentTask<?>> listener);1528103657;Creates a new persistent task on master node__@param taskId     the task's id_@param taskName   the task's name_@param taskParams the task's parameters_@param listener   the listener that will be called when task is started;public <Params extends PersistentTaskParams> void createPersistentTask(String taskId, String taskName, Params taskParams,_                                                                           ActionListener<PersistentTask<?>> listener) {_        clusterService.submitStateUpdateTask("create persistent task", new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                PersistentTasksCustomMetaData.Builder builder = builder(currentState)__                if (builder.hasTask(taskId)) {_                    throw new ResourceAlreadyExistsException("task with id {" + taskId + "} already exist")__                }__                PersistentTasksExecutor<Params> taskExecutor = registry.getPersistentTaskExecutorSafe(taskName)__                taskExecutor.validate(taskParams, currentState)___                Assignment assignment = createAssignment(taskName, taskParams, currentState)__                return update(currentState, builder.addTask(taskId, taskName, taskParams, assignment))__            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @SuppressWarnings("unchecked")_            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                PersistentTasksCustomMetaData tasks = newState.getMetaData().custom(PersistentTasksCustomMetaData.TYPE)__                if (tasks != null) {_                    listener.onResponse(tasks.getTask(taskId))__                } else {_                    listener.onResponse(null)__                }_            }_        })__    };creates,a,new,persistent,task,on,master,node,param,task,id,the,task,s,id,param,task,name,the,task,s,name,param,task,params,the,task,s,parameters,param,listener,the,listener,that,will,be,called,when,task,is,started;public,params,extends,persistent,task,params,void,create,persistent,task,string,task,id,string,task,name,params,task,params,action,listener,persistent,task,listener,cluster,service,submit,state,update,task,create,persistent,task,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,persistent,tasks,custom,meta,data,builder,builder,builder,current,state,if,builder,has,task,task,id,throw,new,resource,already,exists,exception,task,with,id,task,id,already,exist,persistent,tasks,executor,params,task,executor,registry,get,persistent,task,executor,safe,task,name,task,executor,validate,task,params,current,state,assignment,assignment,create,assignment,task,name,task,params,current,state,return,update,current,state,builder,add,task,task,id,task,name,task,params,assignment,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,suppress,warnings,unchecked,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,persistent,tasks,custom,meta,data,tasks,new,state,get,meta,data,custom,persistent,tasks,custom,meta,data,type,if,tasks,null,listener,on,response,tasks,get,task,task,id,else,listener,on,response,null
PersistentTasksClusterService -> public <Params extends PersistentTaskParams> void createPersistentTask(String taskId, String taskName, Params taskParams,                                                                            ActionListener<PersistentTask<?>> listener);1529076503;Creates a new persistent task on master node__@param taskId     the task's id_@param taskName   the task's name_@param taskParams the task's parameters_@param listener   the listener that will be called when task is started;public <Params extends PersistentTaskParams> void createPersistentTask(String taskId, String taskName, Params taskParams,_                                                                           ActionListener<PersistentTask<?>> listener) {_        clusterService.submitStateUpdateTask("create persistent task", new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                PersistentTasksCustomMetaData.Builder builder = builder(currentState)__                if (builder.hasTask(taskId)) {_                    throw new ResourceAlreadyExistsException("task with id {" + taskId + "} already exist")__                }__                PersistentTasksExecutor<Params> taskExecutor = registry.getPersistentTaskExecutorSafe(taskName)__                taskExecutor.validate(taskParams, currentState)___                Assignment assignment = createAssignment(taskName, taskParams, currentState)__                return update(currentState, builder.addTask(taskId, taskName, taskParams, assignment))__            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @SuppressWarnings("unchecked")_            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                PersistentTasksCustomMetaData tasks = newState.getMetaData().custom(PersistentTasksCustomMetaData.TYPE)__                if (tasks != null) {_                    listener.onResponse(tasks.getTask(taskId))__                } else {_                    listener.onResponse(null)__                }_            }_        })__    };creates,a,new,persistent,task,on,master,node,param,task,id,the,task,s,id,param,task,name,the,task,s,name,param,task,params,the,task,s,parameters,param,listener,the,listener,that,will,be,called,when,task,is,started;public,params,extends,persistent,task,params,void,create,persistent,task,string,task,id,string,task,name,params,task,params,action,listener,persistent,task,listener,cluster,service,submit,state,update,task,create,persistent,task,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,persistent,tasks,custom,meta,data,builder,builder,builder,current,state,if,builder,has,task,task,id,throw,new,resource,already,exists,exception,task,with,id,task,id,already,exist,persistent,tasks,executor,params,task,executor,registry,get,persistent,task,executor,safe,task,name,task,executor,validate,task,params,current,state,assignment,assignment,create,assignment,task,name,task,params,current,state,return,update,current,state,builder,add,task,task,id,task,name,task,params,assignment,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,suppress,warnings,unchecked,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,persistent,tasks,custom,meta,data,tasks,new,state,get,meta,data,custom,persistent,tasks,custom,meta,data,type,if,tasks,null,listener,on,response,tasks,get,task,task,id,else,listener,on,response,null
PersistentTasksClusterService -> public <Params extends PersistentTaskParams> void createPersistentTask(String taskId, String taskName, Params taskParams,                                                                            ActionListener<PersistentTask<?>> listener);1532353780;Creates a new persistent task on master node__@param taskId     the task's id_@param taskName   the task's name_@param taskParams the task's parameters_@param listener   the listener that will be called when task is started;public <Params extends PersistentTaskParams> void createPersistentTask(String taskId, String taskName, Params taskParams,_                                                                           ActionListener<PersistentTask<?>> listener) {_        clusterService.submitStateUpdateTask("create persistent task", new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                PersistentTasksCustomMetaData.Builder builder = builder(currentState)__                if (builder.hasTask(taskId)) {_                    throw new ResourceAlreadyExistsException("task with id {" + taskId + "} already exist")__                }__                PersistentTasksExecutor<Params> taskExecutor = registry.getPersistentTaskExecutorSafe(taskName)__                taskExecutor.validate(taskParams, currentState)___                Assignment assignment = createAssignment(taskName, taskParams, currentState)__                return update(currentState, builder.addTask(taskId, taskName, taskParams, assignment))__            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                PersistentTasksCustomMetaData tasks = newState.getMetaData().custom(PersistentTasksCustomMetaData.TYPE)__                if (tasks != null) {_                    listener.onResponse(tasks.getTask(taskId))__                } else {_                    listener.onResponse(null)__                }_            }_        })__    };creates,a,new,persistent,task,on,master,node,param,task,id,the,task,s,id,param,task,name,the,task,s,name,param,task,params,the,task,s,parameters,param,listener,the,listener,that,will,be,called,when,task,is,started;public,params,extends,persistent,task,params,void,create,persistent,task,string,task,id,string,task,name,params,task,params,action,listener,persistent,task,listener,cluster,service,submit,state,update,task,create,persistent,task,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,persistent,tasks,custom,meta,data,builder,builder,builder,current,state,if,builder,has,task,task,id,throw,new,resource,already,exists,exception,task,with,id,task,id,already,exist,persistent,tasks,executor,params,task,executor,registry,get,persistent,task,executor,safe,task,name,task,executor,validate,task,params,current,state,assignment,assignment,create,assignment,task,name,task,params,current,state,return,update,current,state,builder,add,task,task,id,task,name,task,params,assignment,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,persistent,tasks,custom,meta,data,tasks,new,state,get,meta,data,custom,persistent,tasks,custom,meta,data,type,if,tasks,null,listener,on,response,tasks,get,task,task,id,else,listener,on,response,null
PersistentTasksClusterService -> public <Params extends PersistentTaskParams> void createPersistentTask(String taskId, String taskName, Params taskParams,                                                                            ActionListener<PersistentTask<?>> listener);1541092382;Creates a new persistent task on master node__@param taskId     the task's id_@param taskName   the task's name_@param taskParams the task's parameters_@param listener   the listener that will be called when task is started;public <Params extends PersistentTaskParams> void createPersistentTask(String taskId, String taskName, Params taskParams,_                                                                           ActionListener<PersistentTask<?>> listener) {_        clusterService.submitStateUpdateTask("create persistent task", new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                PersistentTasksCustomMetaData.Builder builder = builder(currentState)__                if (builder.hasTask(taskId)) {_                    throw new ResourceAlreadyExistsException("task with id {" + taskId + "} already exist")__                }__                PersistentTasksExecutor<Params> taskExecutor = registry.getPersistentTaskExecutorSafe(taskName)__                taskExecutor.validate(taskParams, currentState)___                Assignment assignment = createAssignment(taskName, taskParams, currentState)__                return update(currentState, builder.addTask(taskId, taskName, taskParams, assignment))__            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                PersistentTasksCustomMetaData tasks = newState.getMetaData().custom(PersistentTasksCustomMetaData.TYPE)__                if (tasks != null) {_                    listener.onResponse(tasks.getTask(taskId))__                } else {_                    listener.onResponse(null)__                }_            }_        })__    };creates,a,new,persistent,task,on,master,node,param,task,id,the,task,s,id,param,task,name,the,task,s,name,param,task,params,the,task,s,parameters,param,listener,the,listener,that,will,be,called,when,task,is,started;public,params,extends,persistent,task,params,void,create,persistent,task,string,task,id,string,task,name,params,task,params,action,listener,persistent,task,listener,cluster,service,submit,state,update,task,create,persistent,task,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,persistent,tasks,custom,meta,data,builder,builder,builder,current,state,if,builder,has,task,task,id,throw,new,resource,already,exists,exception,task,with,id,task,id,already,exist,persistent,tasks,executor,params,task,executor,registry,get,persistent,task,executor,safe,task,name,task,executor,validate,task,params,current,state,assignment,assignment,create,assignment,task,name,task,params,current,state,return,update,current,state,builder,add,task,task,id,task,name,task,params,assignment,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,persistent,tasks,custom,meta,data,tasks,new,state,get,meta,data,custom,persistent,tasks,custom,meta,data,type,if,tasks,null,listener,on,response,tasks,get,task,task,id,else,listener,on,response,null
PersistentTasksClusterService -> public <Params extends PersistentTaskParams> void createPersistentTask(String taskId, String taskName, Params taskParams,                                                                            ActionListener<PersistentTask<?>> listener);1542402632;Creates a new persistent task on master node__@param taskId     the task's id_@param taskName   the task's name_@param taskParams the task's parameters_@param listener   the listener that will be called when task is started;public <Params extends PersistentTaskParams> void createPersistentTask(String taskId, String taskName, Params taskParams,_                                                                           ActionListener<PersistentTask<?>> listener) {_        clusterService.submitStateUpdateTask("create persistent task", new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                PersistentTasksCustomMetaData.Builder builder = builder(currentState)__                if (builder.hasTask(taskId)) {_                    throw new ResourceAlreadyExistsException("task with id {" + taskId + "} already exist")__                }__                PersistentTasksExecutor<Params> taskExecutor = registry.getPersistentTaskExecutorSafe(taskName)__                taskExecutor.validate(taskParams, currentState)___                Assignment assignment = createAssignment(taskName, taskParams, currentState)__                return update(currentState, builder.addTask(taskId, taskName, taskParams, assignment))__            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                PersistentTasksCustomMetaData tasks = newState.getMetaData().custom(PersistentTasksCustomMetaData.TYPE)__                if (tasks != null) {_                    listener.onResponse(tasks.getTask(taskId))__                } else {_                    listener.onResponse(null)__                }_            }_        })__    };creates,a,new,persistent,task,on,master,node,param,task,id,the,task,s,id,param,task,name,the,task,s,name,param,task,params,the,task,s,parameters,param,listener,the,listener,that,will,be,called,when,task,is,started;public,params,extends,persistent,task,params,void,create,persistent,task,string,task,id,string,task,name,params,task,params,action,listener,persistent,task,listener,cluster,service,submit,state,update,task,create,persistent,task,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,persistent,tasks,custom,meta,data,builder,builder,builder,current,state,if,builder,has,task,task,id,throw,new,resource,already,exists,exception,task,with,id,task,id,already,exist,persistent,tasks,executor,params,task,executor,registry,get,persistent,task,executor,safe,task,name,task,executor,validate,task,params,current,state,assignment,assignment,create,assignment,task,name,task,params,current,state,return,update,current,state,builder,add,task,task,id,task,name,task,params,assignment,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,persistent,tasks,custom,meta,data,tasks,new,state,get,meta,data,custom,persistent,tasks,custom,meta,data,type,if,tasks,null,listener,on,response,tasks,get,task,task,id,else,listener,on,response,null
PersistentTasksClusterService -> public <Params extends PersistentTaskParams> void createPersistentTask(String taskId, String taskName, Params taskParams,                                                                            ActionListener<PersistentTask<?>> listener);1544692527;Creates a new persistent task on master node__@param taskId     the task's id_@param taskName   the task's name_@param taskParams the task's parameters_@param listener   the listener that will be called when task is started;public <Params extends PersistentTaskParams> void createPersistentTask(String taskId, String taskName, Params taskParams,_                                                                           ActionListener<PersistentTask<?>> listener) {_        clusterService.submitStateUpdateTask("create persistent task", new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                PersistentTasksCustomMetaData.Builder builder = builder(currentState)__                if (builder.hasTask(taskId)) {_                    throw new ResourceAlreadyExistsException("task with id {" + taskId + "} already exist")__                }__                PersistentTasksExecutor<Params> taskExecutor = registry.getPersistentTaskExecutorSafe(taskName)__                taskExecutor.validate(taskParams, currentState)___                Assignment assignment = createAssignment(taskName, taskParams, currentState)__                return update(currentState, builder.addTask(taskId, taskName, taskParams, assignment))__            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                PersistentTasksCustomMetaData tasks = newState.getMetaData().custom(PersistentTasksCustomMetaData.TYPE)__                if (tasks != null) {_                    PersistentTask<?> task = tasks.getTask(taskId)__                    listener.onResponse(task)__                    if (task != null && task.isAssigned() == false && periodicRechecker.isScheduled() == false) {_                        periodicRechecker.rescheduleIfNecessary()__                    }_                } else {_                    listener.onResponse(null)__                }_            }_        })__    };creates,a,new,persistent,task,on,master,node,param,task,id,the,task,s,id,param,task,name,the,task,s,name,param,task,params,the,task,s,parameters,param,listener,the,listener,that,will,be,called,when,task,is,started;public,params,extends,persistent,task,params,void,create,persistent,task,string,task,id,string,task,name,params,task,params,action,listener,persistent,task,listener,cluster,service,submit,state,update,task,create,persistent,task,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,persistent,tasks,custom,meta,data,builder,builder,builder,current,state,if,builder,has,task,task,id,throw,new,resource,already,exists,exception,task,with,id,task,id,already,exist,persistent,tasks,executor,params,task,executor,registry,get,persistent,task,executor,safe,task,name,task,executor,validate,task,params,current,state,assignment,assignment,create,assignment,task,name,task,params,current,state,return,update,current,state,builder,add,task,task,id,task,name,task,params,assignment,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,persistent,tasks,custom,meta,data,tasks,new,state,get,meta,data,custom,persistent,tasks,custom,meta,data,type,if,tasks,null,persistent,task,task,tasks,get,task,task,id,listener,on,response,task,if,task,null,task,is,assigned,false,periodic,rechecker,is,scheduled,false,periodic,rechecker,reschedule,if,necessary,else,listener,on,response,null
PersistentTasksClusterService -> public <Params extends PersistentTaskParams> void createPersistentTask(String taskId, String taskName, Params taskParams,                                                                            ActionListener<PersistentTask<?>> listener);1545310416;Creates a new persistent task on master node__@param taskId     the task's id_@param taskName   the task's name_@param taskParams the task's parameters_@param listener   the listener that will be called when task is started;public <Params extends PersistentTaskParams> void createPersistentTask(String taskId, String taskName, Params taskParams,_                                                                           ActionListener<PersistentTask<?>> listener) {_        clusterService.submitStateUpdateTask("create persistent task", new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                PersistentTasksCustomMetaData.Builder builder = builder(currentState)__                if (builder.hasTask(taskId)) {_                    throw new ResourceAlreadyExistsException("task with id {" + taskId + "} already exist")__                }__                PersistentTasksExecutor<Params> taskExecutor = registry.getPersistentTaskExecutorSafe(taskName)__                taskExecutor.validate(taskParams, currentState)___                Assignment assignment = createAssignment(taskName, taskParams, currentState)__                return update(currentState, builder.addTask(taskId, taskName, taskParams, assignment))__            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                PersistentTasksCustomMetaData tasks = newState.getMetaData().custom(PersistentTasksCustomMetaData.TYPE)__                if (tasks != null) {_                    PersistentTask<?> task = tasks.getTask(taskId)__                    listener.onResponse(task)__                    if (task != null && task.isAssigned() == false && periodicRechecker.isScheduled() == false) {_                        periodicRechecker.rescheduleIfNecessary()__                    }_                } else {_                    listener.onResponse(null)__                }_            }_        })__    };creates,a,new,persistent,task,on,master,node,param,task,id,the,task,s,id,param,task,name,the,task,s,name,param,task,params,the,task,s,parameters,param,listener,the,listener,that,will,be,called,when,task,is,started;public,params,extends,persistent,task,params,void,create,persistent,task,string,task,id,string,task,name,params,task,params,action,listener,persistent,task,listener,cluster,service,submit,state,update,task,create,persistent,task,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,persistent,tasks,custom,meta,data,builder,builder,builder,current,state,if,builder,has,task,task,id,throw,new,resource,already,exists,exception,task,with,id,task,id,already,exist,persistent,tasks,executor,params,task,executor,registry,get,persistent,task,executor,safe,task,name,task,executor,validate,task,params,current,state,assignment,assignment,create,assignment,task,name,task,params,current,state,return,update,current,state,builder,add,task,task,id,task,name,task,params,assignment,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,persistent,tasks,custom,meta,data,tasks,new,state,get,meta,data,custom,persistent,tasks,custom,meta,data,type,if,tasks,null,persistent,task,task,tasks,get,task,task,id,listener,on,response,task,if,task,null,task,is,assigned,false,periodic,rechecker,is,scheduled,false,periodic,rechecker,reschedule,if,necessary,else,listener,on,response,null
PersistentTasksClusterService -> public <Params extends PersistentTaskParams> void createPersistentTask(String taskId, String taskName, Params taskParams,                                                                            ActionListener<PersistentTask<?>> listener);1548265712;Creates a new persistent task on master node__@param taskId     the task's id_@param taskName   the task's name_@param taskParams the task's parameters_@param listener   the listener that will be called when task is started;public <Params extends PersistentTaskParams> void createPersistentTask(String taskId, String taskName, Params taskParams,_                                                                           ActionListener<PersistentTask<?>> listener) {_        clusterService.submitStateUpdateTask("create persistent task", new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                PersistentTasksCustomMetaData.Builder builder = builder(currentState)__                if (builder.hasTask(taskId)) {_                    throw new ResourceAlreadyExistsException("task with id {" + taskId + "} already exist")__                }__                PersistentTasksExecutor<Params> taskExecutor = registry.getPersistentTaskExecutorSafe(taskName)__                taskExecutor.validate(taskParams, currentState)___                Assignment assignment = createAssignment(taskName, taskParams, currentState)__                return update(currentState, builder.addTask(taskId, taskName, taskParams, assignment))__            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                PersistentTasksCustomMetaData tasks = newState.getMetaData().custom(PersistentTasksCustomMetaData.TYPE)__                if (tasks != null) {_                    PersistentTask<?> task = tasks.getTask(taskId)__                    listener.onResponse(task)__                    if (task != null && task.isAssigned() == false && periodicRechecker.isScheduled() == false) {_                        periodicRechecker.rescheduleIfNecessary()__                    }_                } else {_                    listener.onResponse(null)__                }_            }_        })__    };creates,a,new,persistent,task,on,master,node,param,task,id,the,task,s,id,param,task,name,the,task,s,name,param,task,params,the,task,s,parameters,param,listener,the,listener,that,will,be,called,when,task,is,started;public,params,extends,persistent,task,params,void,create,persistent,task,string,task,id,string,task,name,params,task,params,action,listener,persistent,task,listener,cluster,service,submit,state,update,task,create,persistent,task,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,persistent,tasks,custom,meta,data,builder,builder,builder,current,state,if,builder,has,task,task,id,throw,new,resource,already,exists,exception,task,with,id,task,id,already,exist,persistent,tasks,executor,params,task,executor,registry,get,persistent,task,executor,safe,task,name,task,executor,validate,task,params,current,state,assignment,assignment,create,assignment,task,name,task,params,current,state,return,update,current,state,builder,add,task,task,id,task,name,task,params,assignment,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,persistent,tasks,custom,meta,data,tasks,new,state,get,meta,data,custom,persistent,tasks,custom,meta,data,type,if,tasks,null,persistent,task,task,tasks,get,task,task,id,listener,on,response,task,if,task,null,task,is,assigned,false,periodic,rechecker,is,scheduled,false,periodic,rechecker,reschedule,if,necessary,else,listener,on,response,null
PersistentTasksClusterService -> ClusterState reassignTasks(final ClusterState currentState);1524684173;Evaluates the cluster state and tries to assign tasks to nodes.__@param currentState the cluster state to analyze_@return an updated version of the cluster state;ClusterState reassignTasks(final ClusterState currentState) {_        ClusterState clusterState = currentState___        final PersistentTasksCustomMetaData tasks = currentState.getMetaData().custom(PersistentTasksCustomMetaData.TYPE)__        if (tasks != null) {_            logger.trace("reassigning {} persistent tasks", tasks.tasks().size())__            final DiscoveryNodes nodes = currentState.nodes()___            _            for (PersistentTask<?> task : tasks.tasks()) {_                if (needsReassignment(task.getAssignment(), nodes)) {_                    Assignment assignment = createAssignment(task.getTaskName(), task.getParams(), clusterState)__                    if (Objects.equals(assignment, task.getAssignment()) == false) {_                        logger.trace("reassigning task {} from node {} to node {}", task.getId(),_                                task.getAssignment().getExecutorNode(), assignment.getExecutorNode())__                        clusterState = update(clusterState, builder(clusterState).reassignTask(task.getId(), assignment))__                    } else {_                        logger.trace("ignoring task {} because assignment is the same {}", task.getId(), assignment)__                    }_                } else {_                    logger.trace("ignoring task {} because it is still running", task.getId())__                }_            }_        }_        return clusterState__    };evaluates,the,cluster,state,and,tries,to,assign,tasks,to,nodes,param,current,state,the,cluster,state,to,analyze,return,an,updated,version,of,the,cluster,state;cluster,state,reassign,tasks,final,cluster,state,current,state,cluster,state,cluster,state,current,state,final,persistent,tasks,custom,meta,data,tasks,current,state,get,meta,data,custom,persistent,tasks,custom,meta,data,type,if,tasks,null,logger,trace,reassigning,persistent,tasks,tasks,tasks,size,final,discovery,nodes,nodes,current,state,nodes,for,persistent,task,task,tasks,tasks,if,needs,reassignment,task,get,assignment,nodes,assignment,assignment,create,assignment,task,get,task,name,task,get,params,cluster,state,if,objects,equals,assignment,task,get,assignment,false,logger,trace,reassigning,task,from,node,to,node,task,get,id,task,get,assignment,get,executor,node,assignment,get,executor,node,cluster,state,update,cluster,state,builder,cluster,state,reassign,task,task,get,id,assignment,else,logger,trace,ignoring,task,because,assignment,is,the,same,task,get,id,assignment,else,logger,trace,ignoring,task,because,it,is,still,running,task,get,id,return,cluster,state
PersistentTasksClusterService -> ClusterState reassignTasks(final ClusterState currentState);1528103657;Evaluates the cluster state and tries to assign tasks to nodes.__@param currentState the cluster state to analyze_@return an updated version of the cluster state;ClusterState reassignTasks(final ClusterState currentState) {_        ClusterState clusterState = currentState___        final PersistentTasksCustomMetaData tasks = currentState.getMetaData().custom(PersistentTasksCustomMetaData.TYPE)__        if (tasks != null) {_            logger.trace("reassigning {} persistent tasks", tasks.tasks().size())__            final DiscoveryNodes nodes = currentState.nodes()___            _            for (PersistentTask<?> task : tasks.tasks()) {_                if (needsReassignment(task.getAssignment(), nodes)) {_                    Assignment assignment = createAssignment(task.getTaskName(), task.getParams(), clusterState)__                    if (Objects.equals(assignment, task.getAssignment()) == false) {_                        logger.trace("reassigning task {} from node {} to node {}", task.getId(),_                                task.getAssignment().getExecutorNode(), assignment.getExecutorNode())__                        clusterState = update(clusterState, builder(clusterState).reassignTask(task.getId(), assignment))__                    } else {_                        logger.trace("ignoring task {} because assignment is the same {}", task.getId(), assignment)__                    }_                } else {_                    logger.trace("ignoring task {} because it is still running", task.getId())__                }_            }_        }_        return clusterState__    };evaluates,the,cluster,state,and,tries,to,assign,tasks,to,nodes,param,current,state,the,cluster,state,to,analyze,return,an,updated,version,of,the,cluster,state;cluster,state,reassign,tasks,final,cluster,state,current,state,cluster,state,cluster,state,current,state,final,persistent,tasks,custom,meta,data,tasks,current,state,get,meta,data,custom,persistent,tasks,custom,meta,data,type,if,tasks,null,logger,trace,reassigning,persistent,tasks,tasks,tasks,size,final,discovery,nodes,nodes,current,state,nodes,for,persistent,task,task,tasks,tasks,if,needs,reassignment,task,get,assignment,nodes,assignment,assignment,create,assignment,task,get,task,name,task,get,params,cluster,state,if,objects,equals,assignment,task,get,assignment,false,logger,trace,reassigning,task,from,node,to,node,task,get,id,task,get,assignment,get,executor,node,assignment,get,executor,node,cluster,state,update,cluster,state,builder,cluster,state,reassign,task,task,get,id,assignment,else,logger,trace,ignoring,task,because,assignment,is,the,same,task,get,id,assignment,else,logger,trace,ignoring,task,because,it,is,still,running,task,get,id,return,cluster,state
PersistentTasksClusterService -> ClusterState reassignTasks(final ClusterState currentState);1529076503;Evaluates the cluster state and tries to assign tasks to nodes.__@param currentState the cluster state to analyze_@return an updated version of the cluster state;ClusterState reassignTasks(final ClusterState currentState) {_        ClusterState clusterState = currentState___        final PersistentTasksCustomMetaData tasks = currentState.getMetaData().custom(PersistentTasksCustomMetaData.TYPE)__        if (tasks != null) {_            logger.trace("reassigning {} persistent tasks", tasks.tasks().size())__            final DiscoveryNodes nodes = currentState.nodes()___            _            for (PersistentTask<?> task : tasks.tasks()) {_                if (needsReassignment(task.getAssignment(), nodes)) {_                    Assignment assignment = createAssignment(task.getTaskName(), task.getParams(), clusterState)__                    if (Objects.equals(assignment, task.getAssignment()) == false) {_                        logger.trace("reassigning task {} from node {} to node {}", task.getId(),_                                task.getAssignment().getExecutorNode(), assignment.getExecutorNode())__                        clusterState = update(clusterState, builder(clusterState).reassignTask(task.getId(), assignment))__                    } else {_                        logger.trace("ignoring task {} because assignment is the same {}", task.getId(), assignment)__                    }_                } else {_                    logger.trace("ignoring task {} because it is still running", task.getId())__                }_            }_        }_        return clusterState__    };evaluates,the,cluster,state,and,tries,to,assign,tasks,to,nodes,param,current,state,the,cluster,state,to,analyze,return,an,updated,version,of,the,cluster,state;cluster,state,reassign,tasks,final,cluster,state,current,state,cluster,state,cluster,state,current,state,final,persistent,tasks,custom,meta,data,tasks,current,state,get,meta,data,custom,persistent,tasks,custom,meta,data,type,if,tasks,null,logger,trace,reassigning,persistent,tasks,tasks,tasks,size,final,discovery,nodes,nodes,current,state,nodes,for,persistent,task,task,tasks,tasks,if,needs,reassignment,task,get,assignment,nodes,assignment,assignment,create,assignment,task,get,task,name,task,get,params,cluster,state,if,objects,equals,assignment,task,get,assignment,false,logger,trace,reassigning,task,from,node,to,node,task,get,id,task,get,assignment,get,executor,node,assignment,get,executor,node,cluster,state,update,cluster,state,builder,cluster,state,reassign,task,task,get,id,assignment,else,logger,trace,ignoring,task,because,assignment,is,the,same,task,get,id,assignment,else,logger,trace,ignoring,task,because,it,is,still,running,task,get,id,return,cluster,state
PersistentTasksClusterService -> ClusterState reassignTasks(final ClusterState currentState);1532353780;Evaluates the cluster state and tries to assign tasks to nodes.__@param currentState the cluster state to analyze_@return an updated version of the cluster state;ClusterState reassignTasks(final ClusterState currentState) {_        ClusterState clusterState = currentState___        final PersistentTasksCustomMetaData tasks = currentState.getMetaData().custom(PersistentTasksCustomMetaData.TYPE)__        if (tasks != null) {_            logger.trace("reassigning {} persistent tasks", tasks.tasks().size())__            final DiscoveryNodes nodes = currentState.nodes()___            _            for (PersistentTask<?> task : tasks.tasks()) {_                if (needsReassignment(task.getAssignment(), nodes)) {_                    Assignment assignment = createAssignment(task.getTaskName(), task.getParams(), clusterState)__                    if (Objects.equals(assignment, task.getAssignment()) == false) {_                        logger.trace("reassigning task {} from node {} to node {}", task.getId(),_                                task.getAssignment().getExecutorNode(), assignment.getExecutorNode())__                        clusterState = update(clusterState, builder(clusterState).reassignTask(task.getId(), assignment))__                    } else {_                        logger.trace("ignoring task {} because assignment is the same {}", task.getId(), assignment)__                    }_                } else {_                    logger.trace("ignoring task {} because it is still running", task.getId())__                }_            }_        }_        return clusterState__    };evaluates,the,cluster,state,and,tries,to,assign,tasks,to,nodes,param,current,state,the,cluster,state,to,analyze,return,an,updated,version,of,the,cluster,state;cluster,state,reassign,tasks,final,cluster,state,current,state,cluster,state,cluster,state,current,state,final,persistent,tasks,custom,meta,data,tasks,current,state,get,meta,data,custom,persistent,tasks,custom,meta,data,type,if,tasks,null,logger,trace,reassigning,persistent,tasks,tasks,tasks,size,final,discovery,nodes,nodes,current,state,nodes,for,persistent,task,task,tasks,tasks,if,needs,reassignment,task,get,assignment,nodes,assignment,assignment,create,assignment,task,get,task,name,task,get,params,cluster,state,if,objects,equals,assignment,task,get,assignment,false,logger,trace,reassigning,task,from,node,to,node,task,get,id,task,get,assignment,get,executor,node,assignment,get,executor,node,cluster,state,update,cluster,state,builder,cluster,state,reassign,task,task,get,id,assignment,else,logger,trace,ignoring,task,because,assignment,is,the,same,task,get,id,assignment,else,logger,trace,ignoring,task,because,it,is,still,running,task,get,id,return,cluster,state
PersistentTasksClusterService -> ClusterState reassignTasks(final ClusterState currentState);1541092382;Evaluates the cluster state and tries to assign tasks to nodes.__@param currentState the cluster state to analyze_@return an updated version of the cluster state;ClusterState reassignTasks(final ClusterState currentState) {_        ClusterState clusterState = currentState___        final PersistentTasksCustomMetaData tasks = currentState.getMetaData().custom(PersistentTasksCustomMetaData.TYPE)__        if (tasks != null) {_            logger.trace("reassigning {} persistent tasks", tasks.tasks().size())__            final DiscoveryNodes nodes = currentState.nodes()___            _            for (PersistentTask<?> task : tasks.tasks()) {_                if (needsReassignment(task.getAssignment(), nodes)) {_                    Assignment assignment = createAssignment(task.getTaskName(), task.getParams(), clusterState)__                    if (Objects.equals(assignment, task.getAssignment()) == false) {_                        logger.trace("reassigning task {} from node {} to node {}", task.getId(),_                                task.getAssignment().getExecutorNode(), assignment.getExecutorNode())__                        clusterState = update(clusterState, builder(clusterState).reassignTask(task.getId(), assignment))__                    } else {_                        logger.trace("ignoring task {} because assignment is the same {}", task.getId(), assignment)__                    }_                } else {_                    logger.trace("ignoring task {} because it is still running", task.getId())__                }_            }_        }_        return clusterState__    };evaluates,the,cluster,state,and,tries,to,assign,tasks,to,nodes,param,current,state,the,cluster,state,to,analyze,return,an,updated,version,of,the,cluster,state;cluster,state,reassign,tasks,final,cluster,state,current,state,cluster,state,cluster,state,current,state,final,persistent,tasks,custom,meta,data,tasks,current,state,get,meta,data,custom,persistent,tasks,custom,meta,data,type,if,tasks,null,logger,trace,reassigning,persistent,tasks,tasks,tasks,size,final,discovery,nodes,nodes,current,state,nodes,for,persistent,task,task,tasks,tasks,if,needs,reassignment,task,get,assignment,nodes,assignment,assignment,create,assignment,task,get,task,name,task,get,params,cluster,state,if,objects,equals,assignment,task,get,assignment,false,logger,trace,reassigning,task,from,node,to,node,task,get,id,task,get,assignment,get,executor,node,assignment,get,executor,node,cluster,state,update,cluster,state,builder,cluster,state,reassign,task,task,get,id,assignment,else,logger,trace,ignoring,task,because,assignment,is,the,same,task,get,id,assignment,else,logger,trace,ignoring,task,because,it,is,still,running,task,get,id,return,cluster,state
PersistentTasksClusterService -> ClusterState reassignTasks(final ClusterState currentState);1542402632;Evaluates the cluster state and tries to assign tasks to nodes.__@param currentState the cluster state to analyze_@return an updated version of the cluster state;ClusterState reassignTasks(final ClusterState currentState) {_        ClusterState clusterState = currentState___        final PersistentTasksCustomMetaData tasks = currentState.getMetaData().custom(PersistentTasksCustomMetaData.TYPE)__        if (tasks != null) {_            logger.trace("reassigning {} persistent tasks", tasks.tasks().size())__            final DiscoveryNodes nodes = currentState.nodes()___            _            for (PersistentTask<?> task : tasks.tasks()) {_                if (needsReassignment(task.getAssignment(), nodes)) {_                    Assignment assignment = createAssignment(task.getTaskName(), task.getParams(), clusterState)__                    if (Objects.equals(assignment, task.getAssignment()) == false) {_                        logger.trace("reassigning task {} from node {} to node {}", task.getId(),_                                task.getAssignment().getExecutorNode(), assignment.getExecutorNode())__                        clusterState = update(clusterState, builder(clusterState).reassignTask(task.getId(), assignment))__                    } else {_                        logger.trace("ignoring task {} because assignment is the same {}", task.getId(), assignment)__                    }_                } else {_                    logger.trace("ignoring task {} because it is still running", task.getId())__                }_            }_        }_        return clusterState__    };evaluates,the,cluster,state,and,tries,to,assign,tasks,to,nodes,param,current,state,the,cluster,state,to,analyze,return,an,updated,version,of,the,cluster,state;cluster,state,reassign,tasks,final,cluster,state,current,state,cluster,state,cluster,state,current,state,final,persistent,tasks,custom,meta,data,tasks,current,state,get,meta,data,custom,persistent,tasks,custom,meta,data,type,if,tasks,null,logger,trace,reassigning,persistent,tasks,tasks,tasks,size,final,discovery,nodes,nodes,current,state,nodes,for,persistent,task,task,tasks,tasks,if,needs,reassignment,task,get,assignment,nodes,assignment,assignment,create,assignment,task,get,task,name,task,get,params,cluster,state,if,objects,equals,assignment,task,get,assignment,false,logger,trace,reassigning,task,from,node,to,node,task,get,id,task,get,assignment,get,executor,node,assignment,get,executor,node,cluster,state,update,cluster,state,builder,cluster,state,reassign,task,task,get,id,assignment,else,logger,trace,ignoring,task,because,assignment,is,the,same,task,get,id,assignment,else,logger,trace,ignoring,task,because,it,is,still,running,task,get,id,return,cluster,state
PersistentTasksClusterService -> ClusterState reassignTasks(final ClusterState currentState);1544692527;Evaluates the cluster state and tries to assign tasks to nodes.__@param currentState the cluster state to analyze_@return an updated version of the cluster state;ClusterState reassignTasks(final ClusterState currentState) {_        ClusterState clusterState = currentState___        final PersistentTasksCustomMetaData tasks = currentState.getMetaData().custom(PersistentTasksCustomMetaData.TYPE)__        if (tasks != null) {_            logger.trace("reassigning {} persistent tasks", tasks.tasks().size())__            final DiscoveryNodes nodes = currentState.nodes()___            _            for (PersistentTask<?> task : tasks.tasks()) {_                if (needsReassignment(task.getAssignment(), nodes)) {_                    Assignment assignment = createAssignment(task.getTaskName(), task.getParams(), clusterState)__                    if (Objects.equals(assignment, task.getAssignment()) == false) {_                        logger.trace("reassigning task {} from node {} to node {}", task.getId(),_                                task.getAssignment().getExecutorNode(), assignment.getExecutorNode())__                        clusterState = update(clusterState, builder(clusterState).reassignTask(task.getId(), assignment))__                    } else {_                        logger.trace("ignoring task {} because assignment is the same {}", task.getId(), assignment)__                    }_                } else {_                    logger.trace("ignoring task {} because it is still running", task.getId())__                }_            }_        }_        return clusterState__    };evaluates,the,cluster,state,and,tries,to,assign,tasks,to,nodes,param,current,state,the,cluster,state,to,analyze,return,an,updated,version,of,the,cluster,state;cluster,state,reassign,tasks,final,cluster,state,current,state,cluster,state,cluster,state,current,state,final,persistent,tasks,custom,meta,data,tasks,current,state,get,meta,data,custom,persistent,tasks,custom,meta,data,type,if,tasks,null,logger,trace,reassigning,persistent,tasks,tasks,tasks,size,final,discovery,nodes,nodes,current,state,nodes,for,persistent,task,task,tasks,tasks,if,needs,reassignment,task,get,assignment,nodes,assignment,assignment,create,assignment,task,get,task,name,task,get,params,cluster,state,if,objects,equals,assignment,task,get,assignment,false,logger,trace,reassigning,task,from,node,to,node,task,get,id,task,get,assignment,get,executor,node,assignment,get,executor,node,cluster,state,update,cluster,state,builder,cluster,state,reassign,task,task,get,id,assignment,else,logger,trace,ignoring,task,because,assignment,is,the,same,task,get,id,assignment,else,logger,trace,ignoring,task,because,it,is,still,running,task,get,id,return,cluster,state
PersistentTasksClusterService -> ClusterState reassignTasks(final ClusterState currentState);1545310416;Evaluates the cluster state and tries to assign tasks to nodes.__@param currentState the cluster state to analyze_@return an updated version of the cluster state;ClusterState reassignTasks(final ClusterState currentState) {_        ClusterState clusterState = currentState___        final PersistentTasksCustomMetaData tasks = currentState.getMetaData().custom(PersistentTasksCustomMetaData.TYPE)__        if (tasks != null) {_            logger.trace("reassigning {} persistent tasks", tasks.tasks().size())__            final DiscoveryNodes nodes = currentState.nodes()___            _            for (PersistentTask<?> task : tasks.tasks()) {_                if (needsReassignment(task.getAssignment(), nodes)) {_                    Assignment assignment = createAssignment(task.getTaskName(), task.getParams(), clusterState)__                    if (Objects.equals(assignment, task.getAssignment()) == false) {_                        logger.trace("reassigning task {} from node {} to node {}", task.getId(),_                                task.getAssignment().getExecutorNode(), assignment.getExecutorNode())__                        clusterState = update(clusterState, builder(clusterState).reassignTask(task.getId(), assignment))__                    } else {_                        logger.trace("ignoring task {} because assignment is the same {}", task.getId(), assignment)__                    }_                } else {_                    logger.trace("ignoring task {} because it is still running", task.getId())__                }_            }_        }_        return clusterState__    };evaluates,the,cluster,state,and,tries,to,assign,tasks,to,nodes,param,current,state,the,cluster,state,to,analyze,return,an,updated,version,of,the,cluster,state;cluster,state,reassign,tasks,final,cluster,state,current,state,cluster,state,cluster,state,current,state,final,persistent,tasks,custom,meta,data,tasks,current,state,get,meta,data,custom,persistent,tasks,custom,meta,data,type,if,tasks,null,logger,trace,reassigning,persistent,tasks,tasks,tasks,size,final,discovery,nodes,nodes,current,state,nodes,for,persistent,task,task,tasks,tasks,if,needs,reassignment,task,get,assignment,nodes,assignment,assignment,create,assignment,task,get,task,name,task,get,params,cluster,state,if,objects,equals,assignment,task,get,assignment,false,logger,trace,reassigning,task,from,node,to,node,task,get,id,task,get,assignment,get,executor,node,assignment,get,executor,node,cluster,state,update,cluster,state,builder,cluster,state,reassign,task,task,get,id,assignment,else,logger,trace,ignoring,task,because,assignment,is,the,same,task,get,id,assignment,else,logger,trace,ignoring,task,because,it,is,still,running,task,get,id,return,cluster,state
PersistentTasksClusterService -> ClusterState reassignTasks(final ClusterState currentState);1548265712;Evaluates the cluster state and tries to assign tasks to nodes.__@param currentState the cluster state to analyze_@return an updated version of the cluster state;ClusterState reassignTasks(final ClusterState currentState) {_        ClusterState clusterState = currentState___        final PersistentTasksCustomMetaData tasks = currentState.getMetaData().custom(PersistentTasksCustomMetaData.TYPE)__        if (tasks != null) {_            logger.trace("reassigning {} persistent tasks", tasks.tasks().size())__            final DiscoveryNodes nodes = currentState.nodes()___            _            for (PersistentTask<?> task : tasks.tasks()) {_                if (needsReassignment(task.getAssignment(), nodes)) {_                    Assignment assignment = createAssignment(task.getTaskName(), task.getParams(), clusterState)__                    if (Objects.equals(assignment, task.getAssignment()) == false) {_                        logger.trace("reassigning task {} from node {} to node {}", task.getId(),_                                task.getAssignment().getExecutorNode(), assignment.getExecutorNode())__                        clusterState = update(clusterState, builder(clusterState).reassignTask(task.getId(), assignment))__                    } else {_                        logger.trace("ignoring task {} because assignment is the same {}", task.getId(), assignment)__                    }_                } else {_                    logger.trace("ignoring task {} because it is still running", task.getId())__                }_            }_        }_        return clusterState__    };evaluates,the,cluster,state,and,tries,to,assign,tasks,to,nodes,param,current,state,the,cluster,state,to,analyze,return,an,updated,version,of,the,cluster,state;cluster,state,reassign,tasks,final,cluster,state,current,state,cluster,state,cluster,state,current,state,final,persistent,tasks,custom,meta,data,tasks,current,state,get,meta,data,custom,persistent,tasks,custom,meta,data,type,if,tasks,null,logger,trace,reassigning,persistent,tasks,tasks,tasks,size,final,discovery,nodes,nodes,current,state,nodes,for,persistent,task,task,tasks,tasks,if,needs,reassignment,task,get,assignment,nodes,assignment,assignment,create,assignment,task,get,task,name,task,get,params,cluster,state,if,objects,equals,assignment,task,get,assignment,false,logger,trace,reassigning,task,from,node,to,node,task,get,id,task,get,assignment,get,executor,node,assignment,get,executor,node,cluster,state,update,cluster,state,builder,cluster,state,reassign,task,task,get,id,assignment,else,logger,trace,ignoring,task,because,assignment,is,the,same,task,get,id,assignment,else,logger,trace,ignoring,task,because,it,is,still,running,task,get,id,return,cluster,state
PersistentTasksClusterService -> boolean shouldReassignPersistentTasks(final ClusterChangedEvent event);1524684173;Returns true if the cluster state change(s) require to reassign some persistent tasks. It can happen in the following_situations: a node left or is added, the routing table changed, the master node changed, the metadata changed or the_persistent tasks changed.;boolean shouldReassignPersistentTasks(final ClusterChangedEvent event) {_        final PersistentTasksCustomMetaData tasks = event.state().getMetaData().custom(PersistentTasksCustomMetaData.TYPE)__        if (tasks == null) {_            return false__        }__        boolean masterChanged = event.previousState().nodes().isLocalNodeElectedMaster() == false___        if (persistentTasksChanged(event)_            || event.nodesChanged()_            || event.routingTableChanged()_            || event.metaDataChanged()_            || masterChanged) {__            for (PersistentTask<?> task : tasks.tasks()) {_                if (needsReassignment(task.getAssignment(), event.state().nodes())) {_                    Assignment assignment = createAssignment(task.getTaskName(), task.getParams(), event.state())__                    if (Objects.equals(assignment, task.getAssignment()) == false) {_                        return true__                    }_                }_            }_        }_        return false__    };returns,true,if,the,cluster,state,change,s,require,to,reassign,some,persistent,tasks,it,can,happen,in,the,following,situations,a,node,left,or,is,added,the,routing,table,changed,the,master,node,changed,the,metadata,changed,or,the,persistent,tasks,changed;boolean,should,reassign,persistent,tasks,final,cluster,changed,event,event,final,persistent,tasks,custom,meta,data,tasks,event,state,get,meta,data,custom,persistent,tasks,custom,meta,data,type,if,tasks,null,return,false,boolean,master,changed,event,previous,state,nodes,is,local,node,elected,master,false,if,persistent,tasks,changed,event,event,nodes,changed,event,routing,table,changed,event,meta,data,changed,master,changed,for,persistent,task,task,tasks,tasks,if,needs,reassignment,task,get,assignment,event,state,nodes,assignment,assignment,create,assignment,task,get,task,name,task,get,params,event,state,if,objects,equals,assignment,task,get,assignment,false,return,true,return,false
PersistentTasksClusterService -> boolean shouldReassignPersistentTasks(final ClusterChangedEvent event);1528103657;Returns true if the cluster state change(s) require to reassign some persistent tasks. It can happen in the following_situations: a node left or is added, the routing table changed, the master node changed, the metadata changed or the_persistent tasks changed.;boolean shouldReassignPersistentTasks(final ClusterChangedEvent event) {_        final PersistentTasksCustomMetaData tasks = event.state().getMetaData().custom(PersistentTasksCustomMetaData.TYPE)__        if (tasks == null) {_            return false__        }__        boolean masterChanged = event.previousState().nodes().isLocalNodeElectedMaster() == false___        if (persistentTasksChanged(event)_            || event.nodesChanged()_            || event.routingTableChanged()_            || event.metaDataChanged()_            || masterChanged) {__            for (PersistentTask<?> task : tasks.tasks()) {_                if (needsReassignment(task.getAssignment(), event.state().nodes())) {_                    Assignment assignment = createAssignment(task.getTaskName(), task.getParams(), event.state())__                    if (Objects.equals(assignment, task.getAssignment()) == false) {_                        return true__                    }_                }_            }_        }_        return false__    };returns,true,if,the,cluster,state,change,s,require,to,reassign,some,persistent,tasks,it,can,happen,in,the,following,situations,a,node,left,or,is,added,the,routing,table,changed,the,master,node,changed,the,metadata,changed,or,the,persistent,tasks,changed;boolean,should,reassign,persistent,tasks,final,cluster,changed,event,event,final,persistent,tasks,custom,meta,data,tasks,event,state,get,meta,data,custom,persistent,tasks,custom,meta,data,type,if,tasks,null,return,false,boolean,master,changed,event,previous,state,nodes,is,local,node,elected,master,false,if,persistent,tasks,changed,event,event,nodes,changed,event,routing,table,changed,event,meta,data,changed,master,changed,for,persistent,task,task,tasks,tasks,if,needs,reassignment,task,get,assignment,event,state,nodes,assignment,assignment,create,assignment,task,get,task,name,task,get,params,event,state,if,objects,equals,assignment,task,get,assignment,false,return,true,return,false
PersistentTasksClusterService -> boolean shouldReassignPersistentTasks(final ClusterChangedEvent event);1529076503;Returns true if the cluster state change(s) require to reassign some persistent tasks. It can happen in the following_situations: a node left or is added, the routing table changed, the master node changed, the metadata changed or the_persistent tasks changed.;boolean shouldReassignPersistentTasks(final ClusterChangedEvent event) {_        final PersistentTasksCustomMetaData tasks = event.state().getMetaData().custom(PersistentTasksCustomMetaData.TYPE)__        if (tasks == null) {_            return false__        }__        boolean masterChanged = event.previousState().nodes().isLocalNodeElectedMaster() == false___        if (persistentTasksChanged(event)_            || event.nodesChanged()_            || event.routingTableChanged()_            || event.metaDataChanged()_            || masterChanged) {__            for (PersistentTask<?> task : tasks.tasks()) {_                if (needsReassignment(task.getAssignment(), event.state().nodes())) {_                    Assignment assignment = createAssignment(task.getTaskName(), task.getParams(), event.state())__                    if (Objects.equals(assignment, task.getAssignment()) == false) {_                        return true__                    }_                }_            }_        }_        return false__    };returns,true,if,the,cluster,state,change,s,require,to,reassign,some,persistent,tasks,it,can,happen,in,the,following,situations,a,node,left,or,is,added,the,routing,table,changed,the,master,node,changed,the,metadata,changed,or,the,persistent,tasks,changed;boolean,should,reassign,persistent,tasks,final,cluster,changed,event,event,final,persistent,tasks,custom,meta,data,tasks,event,state,get,meta,data,custom,persistent,tasks,custom,meta,data,type,if,tasks,null,return,false,boolean,master,changed,event,previous,state,nodes,is,local,node,elected,master,false,if,persistent,tasks,changed,event,event,nodes,changed,event,routing,table,changed,event,meta,data,changed,master,changed,for,persistent,task,task,tasks,tasks,if,needs,reassignment,task,get,assignment,event,state,nodes,assignment,assignment,create,assignment,task,get,task,name,task,get,params,event,state,if,objects,equals,assignment,task,get,assignment,false,return,true,return,false
PersistentTasksClusterService -> boolean shouldReassignPersistentTasks(final ClusterChangedEvent event);1532353780;Returns true if the cluster state change(s) require to reassign some persistent tasks. It can happen in the following_situations: a node left or is added, the routing table changed, the master node changed, the metadata changed or the_persistent tasks changed.;boolean shouldReassignPersistentTasks(final ClusterChangedEvent event) {_        final PersistentTasksCustomMetaData tasks = event.state().getMetaData().custom(PersistentTasksCustomMetaData.TYPE)__        if (tasks == null) {_            return false__        }__        boolean masterChanged = event.previousState().nodes().isLocalNodeElectedMaster() == false___        if (persistentTasksChanged(event)_            || event.nodesChanged()_            || event.routingTableChanged()_            || event.metaDataChanged()_            || masterChanged) {__            for (PersistentTask<?> task : tasks.tasks()) {_                if (needsReassignment(task.getAssignment(), event.state().nodes())) {_                    Assignment assignment = createAssignment(task.getTaskName(), task.getParams(), event.state())__                    if (Objects.equals(assignment, task.getAssignment()) == false) {_                        return true__                    }_                }_            }_        }_        return false__    };returns,true,if,the,cluster,state,change,s,require,to,reassign,some,persistent,tasks,it,can,happen,in,the,following,situations,a,node,left,or,is,added,the,routing,table,changed,the,master,node,changed,the,metadata,changed,or,the,persistent,tasks,changed;boolean,should,reassign,persistent,tasks,final,cluster,changed,event,event,final,persistent,tasks,custom,meta,data,tasks,event,state,get,meta,data,custom,persistent,tasks,custom,meta,data,type,if,tasks,null,return,false,boolean,master,changed,event,previous,state,nodes,is,local,node,elected,master,false,if,persistent,tasks,changed,event,event,nodes,changed,event,routing,table,changed,event,meta,data,changed,master,changed,for,persistent,task,task,tasks,tasks,if,needs,reassignment,task,get,assignment,event,state,nodes,assignment,assignment,create,assignment,task,get,task,name,task,get,params,event,state,if,objects,equals,assignment,task,get,assignment,false,return,true,return,false
PersistentTasksClusterService -> boolean shouldReassignPersistentTasks(final ClusterChangedEvent event);1541092382;Returns true if the cluster state change(s) require to reassign some persistent tasks. It can happen in the following_situations: a node left or is added, the routing table changed, the master node changed, the metadata changed or the_persistent tasks changed.;boolean shouldReassignPersistentTasks(final ClusterChangedEvent event) {_        final PersistentTasksCustomMetaData tasks = event.state().getMetaData().custom(PersistentTasksCustomMetaData.TYPE)__        if (tasks == null) {_            return false__        }__        boolean masterChanged = event.previousState().nodes().isLocalNodeElectedMaster() == false___        if (persistentTasksChanged(event)_            || event.nodesChanged()_            || event.routingTableChanged()_            || event.metaDataChanged()_            || masterChanged) {__            for (PersistentTask<?> task : tasks.tasks()) {_                if (needsReassignment(task.getAssignment(), event.state().nodes())) {_                    Assignment assignment = createAssignment(task.getTaskName(), task.getParams(), event.state())__                    if (Objects.equals(assignment, task.getAssignment()) == false) {_                        return true__                    }_                }_            }_        }_        return false__    };returns,true,if,the,cluster,state,change,s,require,to,reassign,some,persistent,tasks,it,can,happen,in,the,following,situations,a,node,left,or,is,added,the,routing,table,changed,the,master,node,changed,the,metadata,changed,or,the,persistent,tasks,changed;boolean,should,reassign,persistent,tasks,final,cluster,changed,event,event,final,persistent,tasks,custom,meta,data,tasks,event,state,get,meta,data,custom,persistent,tasks,custom,meta,data,type,if,tasks,null,return,false,boolean,master,changed,event,previous,state,nodes,is,local,node,elected,master,false,if,persistent,tasks,changed,event,event,nodes,changed,event,routing,table,changed,event,meta,data,changed,master,changed,for,persistent,task,task,tasks,tasks,if,needs,reassignment,task,get,assignment,event,state,nodes,assignment,assignment,create,assignment,task,get,task,name,task,get,params,event,state,if,objects,equals,assignment,task,get,assignment,false,return,true,return,false
PersistentTasksClusterService -> boolean shouldReassignPersistentTasks(final ClusterChangedEvent event);1542402632;Returns true if the cluster state change(s) require to reassign some persistent tasks. It can happen in the following_situations: a node left or is added, the routing table changed, the master node changed, the metadata changed or the_persistent tasks changed.;boolean shouldReassignPersistentTasks(final ClusterChangedEvent event) {_        final PersistentTasksCustomMetaData tasks = event.state().getMetaData().custom(PersistentTasksCustomMetaData.TYPE)__        if (tasks == null) {_            return false__        }__        boolean masterChanged = event.previousState().nodes().isLocalNodeElectedMaster() == false___        if (persistentTasksChanged(event)_            || event.nodesChanged()_            || event.routingTableChanged()_            || event.metaDataChanged()_            || masterChanged) {__            for (PersistentTask<?> task : tasks.tasks()) {_                if (needsReassignment(task.getAssignment(), event.state().nodes())) {_                    Assignment assignment = createAssignment(task.getTaskName(), task.getParams(), event.state())__                    if (Objects.equals(assignment, task.getAssignment()) == false) {_                        return true__                    }_                }_            }_        }_        return false__    };returns,true,if,the,cluster,state,change,s,require,to,reassign,some,persistent,tasks,it,can,happen,in,the,following,situations,a,node,left,or,is,added,the,routing,table,changed,the,master,node,changed,the,metadata,changed,or,the,persistent,tasks,changed;boolean,should,reassign,persistent,tasks,final,cluster,changed,event,event,final,persistent,tasks,custom,meta,data,tasks,event,state,get,meta,data,custom,persistent,tasks,custom,meta,data,type,if,tasks,null,return,false,boolean,master,changed,event,previous,state,nodes,is,local,node,elected,master,false,if,persistent,tasks,changed,event,event,nodes,changed,event,routing,table,changed,event,meta,data,changed,master,changed,for,persistent,task,task,tasks,tasks,if,needs,reassignment,task,get,assignment,event,state,nodes,assignment,assignment,create,assignment,task,get,task,name,task,get,params,event,state,if,objects,equals,assignment,task,get,assignment,false,return,true,return,false
PersistentTasksClusterService -> boolean shouldReassignPersistentTasks(final ClusterChangedEvent event);1544692527;Returns true if the cluster state change(s) require to reassign some persistent tasks. It can happen in the following_situations: a node left or is added, the routing table changed, the master node changed, the metadata changed or the_persistent tasks changed.;boolean shouldReassignPersistentTasks(final ClusterChangedEvent event) {_        final PersistentTasksCustomMetaData tasks = event.state().getMetaData().custom(PersistentTasksCustomMetaData.TYPE)__        if (tasks == null) {_            return false__        }__        boolean masterChanged = event.previousState().nodes().isLocalNodeElectedMaster() == false___        if (persistentTasksChanged(event)_            || event.nodesChanged()_            || event.routingTableChanged()_            || event.metaDataChanged()_            || masterChanged) {__            for (PersistentTask<?> task : tasks.tasks()) {_                if (needsReassignment(task.getAssignment(), event.state().nodes())) {_                    Assignment assignment = createAssignment(task.getTaskName(), task.getParams(), event.state())__                    if (Objects.equals(assignment, task.getAssignment()) == false) {_                        return true__                    }_                }_            }_        }_        return false__    };returns,true,if,the,cluster,state,change,s,require,to,reassign,some,persistent,tasks,it,can,happen,in,the,following,situations,a,node,left,or,is,added,the,routing,table,changed,the,master,node,changed,the,metadata,changed,or,the,persistent,tasks,changed;boolean,should,reassign,persistent,tasks,final,cluster,changed,event,event,final,persistent,tasks,custom,meta,data,tasks,event,state,get,meta,data,custom,persistent,tasks,custom,meta,data,type,if,tasks,null,return,false,boolean,master,changed,event,previous,state,nodes,is,local,node,elected,master,false,if,persistent,tasks,changed,event,event,nodes,changed,event,routing,table,changed,event,meta,data,changed,master,changed,for,persistent,task,task,tasks,tasks,if,needs,reassignment,task,get,assignment,event,state,nodes,assignment,assignment,create,assignment,task,get,task,name,task,get,params,event,state,if,objects,equals,assignment,task,get,assignment,false,return,true,return,false
PersistentTasksClusterService -> boolean shouldReassignPersistentTasks(final ClusterChangedEvent event);1545310416;Returns true if the cluster state change(s) require to reassign some persistent tasks. It can happen in the following_situations: a node left or is added, the routing table changed, the master node changed, the metadata changed or the_persistent tasks changed.;boolean shouldReassignPersistentTasks(final ClusterChangedEvent event) {_        final PersistentTasksCustomMetaData tasks = event.state().getMetaData().custom(PersistentTasksCustomMetaData.TYPE)__        if (tasks == null) {_            return false__        }__        boolean masterChanged = event.previousState().nodes().isLocalNodeElectedMaster() == false___        if (persistentTasksChanged(event)_            || event.nodesChanged()_            || event.routingTableChanged()_            || event.metaDataChanged()_            || masterChanged) {__            for (PersistentTask<?> task : tasks.tasks()) {_                if (needsReassignment(task.getAssignment(), event.state().nodes())) {_                    Assignment assignment = createAssignment(task.getTaskName(), task.getParams(), event.state())__                    if (Objects.equals(assignment, task.getAssignment()) == false) {_                        return true__                    }_                }_            }_        }_        return false__    };returns,true,if,the,cluster,state,change,s,require,to,reassign,some,persistent,tasks,it,can,happen,in,the,following,situations,a,node,left,or,is,added,the,routing,table,changed,the,master,node,changed,the,metadata,changed,or,the,persistent,tasks,changed;boolean,should,reassign,persistent,tasks,final,cluster,changed,event,event,final,persistent,tasks,custom,meta,data,tasks,event,state,get,meta,data,custom,persistent,tasks,custom,meta,data,type,if,tasks,null,return,false,boolean,master,changed,event,previous,state,nodes,is,local,node,elected,master,false,if,persistent,tasks,changed,event,event,nodes,changed,event,routing,table,changed,event,meta,data,changed,master,changed,for,persistent,task,task,tasks,tasks,if,needs,reassignment,task,get,assignment,event,state,nodes,assignment,assignment,create,assignment,task,get,task,name,task,get,params,event,state,if,objects,equals,assignment,task,get,assignment,false,return,true,return,false
PersistentTasksClusterService -> boolean shouldReassignPersistentTasks(final ClusterChangedEvent event);1548265712;Returns true if the cluster state change(s) require to reassign some persistent tasks. It can happen in the following_situations: a node left or is added, the routing table changed, the master node changed, the metadata changed or the_persistent tasks changed.;boolean shouldReassignPersistentTasks(final ClusterChangedEvent event) {_        final PersistentTasksCustomMetaData tasks = event.state().getMetaData().custom(PersistentTasksCustomMetaData.TYPE)__        if (tasks == null) {_            return false__        }__        boolean masterChanged = event.previousState().nodes().isLocalNodeElectedMaster() == false___        if (persistentTasksChanged(event)_            || event.nodesChanged()_            || event.routingTableChanged()_            || event.metaDataChanged()_            || masterChanged) {__            for (PersistentTask<?> task : tasks.tasks()) {_                if (needsReassignment(task.getAssignment(), event.state().nodes())) {_                    Assignment assignment = createAssignment(task.getTaskName(), task.getParams(), event.state())__                    if (Objects.equals(assignment, task.getAssignment()) == false) {_                        return true__                    }_                }_            }_        }_        return false__    };returns,true,if,the,cluster,state,change,s,require,to,reassign,some,persistent,tasks,it,can,happen,in,the,following,situations,a,node,left,or,is,added,the,routing,table,changed,the,master,node,changed,the,metadata,changed,or,the,persistent,tasks,changed;boolean,should,reassign,persistent,tasks,final,cluster,changed,event,event,final,persistent,tasks,custom,meta,data,tasks,event,state,get,meta,data,custom,persistent,tasks,custom,meta,data,type,if,tasks,null,return,false,boolean,master,changed,event,previous,state,nodes,is,local,node,elected,master,false,if,persistent,tasks,changed,event,event,nodes,changed,event,routing,table,changed,event,meta,data,changed,master,changed,for,persistent,task,task,tasks,tasks,if,needs,reassignment,task,get,assignment,event,state,nodes,assignment,assignment,create,assignment,task,get,task,name,task,get,params,event,state,if,objects,equals,assignment,task,get,assignment,false,return,true,return,false
PersistentTasksClusterService -> public void completePersistentTask(String id, long allocationId, Exception failure, ActionListener<PersistentTask<?>> listener);1524684173;Restarts a record about a running persistent task from cluster state__@param id           the id of the persistent task_@param allocationId the allocation id of the persistent task_@param failure      the reason for restarting the task or null if the task completed successfully_@param listener     the listener that will be called when task is removed;public void completePersistentTask(String id, long allocationId, Exception failure, ActionListener<PersistentTask<?>> listener) {_        final String source__        if (failure != null) {_            logger.warn("persistent task " + id + " failed", failure)__            source = "finish persistent task (failed)"__        } else {_            source = "finish persistent task (success)"__        }_        clusterService.submitStateUpdateTask(source, new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                PersistentTasksCustomMetaData.Builder tasksInProgress = builder(currentState)__                if (tasksInProgress.hasTask(id, allocationId)) {_                    tasksInProgress.removeTask(id)__                    return update(currentState, tasksInProgress)__                } else {_                    if (tasksInProgress.hasTask(id)) {_                        logger.warn("The task [{}] with id [{}] was found but it has a different allocation id [{}], status is not updated",_                                PersistentTasksCustomMetaData.getTaskWithId(currentState, id).getTaskName(), id, allocationId)__                    } else {_                        logger.warn("The task [{}] wasn't found, status is not updated", id)__                    }_                    throw new ResourceNotFoundException("the task with id [" + id + "] and allocation id [" + allocationId + "] not found")__                }_            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                _                listener.onResponse(PersistentTasksCustomMetaData.getTaskWithId(oldState, id))__            }_        })__    };restarts,a,record,about,a,running,persistent,task,from,cluster,state,param,id,the,id,of,the,persistent,task,param,allocation,id,the,allocation,id,of,the,persistent,task,param,failure,the,reason,for,restarting,the,task,or,null,if,the,task,completed,successfully,param,listener,the,listener,that,will,be,called,when,task,is,removed;public,void,complete,persistent,task,string,id,long,allocation,id,exception,failure,action,listener,persistent,task,listener,final,string,source,if,failure,null,logger,warn,persistent,task,id,failed,failure,source,finish,persistent,task,failed,else,source,finish,persistent,task,success,cluster,service,submit,state,update,task,source,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,persistent,tasks,custom,meta,data,builder,tasks,in,progress,builder,current,state,if,tasks,in,progress,has,task,id,allocation,id,tasks,in,progress,remove,task,id,return,update,current,state,tasks,in,progress,else,if,tasks,in,progress,has,task,id,logger,warn,the,task,with,id,was,found,but,it,has,a,different,allocation,id,status,is,not,updated,persistent,tasks,custom,meta,data,get,task,with,id,current,state,id,get,task,name,id,allocation,id,else,logger,warn,the,task,wasn,t,found,status,is,not,updated,id,throw,new,resource,not,found,exception,the,task,with,id,id,and,allocation,id,allocation,id,not,found,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,persistent,tasks,custom,meta,data,get,task,with,id,old,state,id
PersistentTasksClusterService -> public void completePersistentTask(String id, long allocationId, Exception failure, ActionListener<PersistentTask<?>> listener);1528103657;Restarts a record about a running persistent task from cluster state__@param id           the id of the persistent task_@param allocationId the allocation id of the persistent task_@param failure      the reason for restarting the task or null if the task completed successfully_@param listener     the listener that will be called when task is removed;public void completePersistentTask(String id, long allocationId, Exception failure, ActionListener<PersistentTask<?>> listener) {_        final String source__        if (failure != null) {_            logger.warn("persistent task " + id + " failed", failure)__            source = "finish persistent task (failed)"__        } else {_            source = "finish persistent task (success)"__        }_        clusterService.submitStateUpdateTask(source, new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                PersistentTasksCustomMetaData.Builder tasksInProgress = builder(currentState)__                if (tasksInProgress.hasTask(id, allocationId)) {_                    tasksInProgress.removeTask(id)__                    return update(currentState, tasksInProgress)__                } else {_                    if (tasksInProgress.hasTask(id)) {_                        logger.warn("The task [{}] with id [{}] was found but it has a different allocation id [{}], status is not updated",_                                PersistentTasksCustomMetaData.getTaskWithId(currentState, id).getTaskName(), id, allocationId)__                    } else {_                        logger.warn("The task [{}] wasn't found, status is not updated", id)__                    }_                    throw new ResourceNotFoundException("the task with id [" + id + "] and allocation id [" + allocationId + "] not found")__                }_            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                _                listener.onResponse(PersistentTasksCustomMetaData.getTaskWithId(oldState, id))__            }_        })__    };restarts,a,record,about,a,running,persistent,task,from,cluster,state,param,id,the,id,of,the,persistent,task,param,allocation,id,the,allocation,id,of,the,persistent,task,param,failure,the,reason,for,restarting,the,task,or,null,if,the,task,completed,successfully,param,listener,the,listener,that,will,be,called,when,task,is,removed;public,void,complete,persistent,task,string,id,long,allocation,id,exception,failure,action,listener,persistent,task,listener,final,string,source,if,failure,null,logger,warn,persistent,task,id,failed,failure,source,finish,persistent,task,failed,else,source,finish,persistent,task,success,cluster,service,submit,state,update,task,source,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,persistent,tasks,custom,meta,data,builder,tasks,in,progress,builder,current,state,if,tasks,in,progress,has,task,id,allocation,id,tasks,in,progress,remove,task,id,return,update,current,state,tasks,in,progress,else,if,tasks,in,progress,has,task,id,logger,warn,the,task,with,id,was,found,but,it,has,a,different,allocation,id,status,is,not,updated,persistent,tasks,custom,meta,data,get,task,with,id,current,state,id,get,task,name,id,allocation,id,else,logger,warn,the,task,wasn,t,found,status,is,not,updated,id,throw,new,resource,not,found,exception,the,task,with,id,id,and,allocation,id,allocation,id,not,found,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,persistent,tasks,custom,meta,data,get,task,with,id,old,state,id
PersistentTasksClusterService -> public void completePersistentTask(String id, long allocationId, Exception failure, ActionListener<PersistentTask<?>> listener);1529076503;Restarts a record about a running persistent task from cluster state__@param id           the id of the persistent task_@param allocationId the allocation id of the persistent task_@param failure      the reason for restarting the task or null if the task completed successfully_@param listener     the listener that will be called when task is removed;public void completePersistentTask(String id, long allocationId, Exception failure, ActionListener<PersistentTask<?>> listener) {_        final String source__        if (failure != null) {_            logger.warn("persistent task " + id + " failed", failure)__            source = "finish persistent task (failed)"__        } else {_            source = "finish persistent task (success)"__        }_        clusterService.submitStateUpdateTask(source, new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                PersistentTasksCustomMetaData.Builder tasksInProgress = builder(currentState)__                if (tasksInProgress.hasTask(id, allocationId)) {_                    tasksInProgress.removeTask(id)__                    return update(currentState, tasksInProgress)__                } else {_                    if (tasksInProgress.hasTask(id)) {_                        logger.warn("The task [{}] with id [{}] was found but it has a different allocation id [{}], status is not updated",_                                PersistentTasksCustomMetaData.getTaskWithId(currentState, id).getTaskName(), id, allocationId)__                    } else {_                        logger.warn("The task [{}] wasn't found, status is not updated", id)__                    }_                    throw new ResourceNotFoundException("the task with id [" + id + "] and allocation id [" + allocationId + "] not found")__                }_            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                _                listener.onResponse(PersistentTasksCustomMetaData.getTaskWithId(oldState, id))__            }_        })__    };restarts,a,record,about,a,running,persistent,task,from,cluster,state,param,id,the,id,of,the,persistent,task,param,allocation,id,the,allocation,id,of,the,persistent,task,param,failure,the,reason,for,restarting,the,task,or,null,if,the,task,completed,successfully,param,listener,the,listener,that,will,be,called,when,task,is,removed;public,void,complete,persistent,task,string,id,long,allocation,id,exception,failure,action,listener,persistent,task,listener,final,string,source,if,failure,null,logger,warn,persistent,task,id,failed,failure,source,finish,persistent,task,failed,else,source,finish,persistent,task,success,cluster,service,submit,state,update,task,source,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,persistent,tasks,custom,meta,data,builder,tasks,in,progress,builder,current,state,if,tasks,in,progress,has,task,id,allocation,id,tasks,in,progress,remove,task,id,return,update,current,state,tasks,in,progress,else,if,tasks,in,progress,has,task,id,logger,warn,the,task,with,id,was,found,but,it,has,a,different,allocation,id,status,is,not,updated,persistent,tasks,custom,meta,data,get,task,with,id,current,state,id,get,task,name,id,allocation,id,else,logger,warn,the,task,wasn,t,found,status,is,not,updated,id,throw,new,resource,not,found,exception,the,task,with,id,id,and,allocation,id,allocation,id,not,found,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,persistent,tasks,custom,meta,data,get,task,with,id,old,state,id
PersistentTasksClusterService -> public void completePersistentTask(String id, long allocationId, Exception failure, ActionListener<PersistentTask<?>> listener);1532353780;Restarts a record about a running persistent task from cluster state__@param id           the id of the persistent task_@param allocationId the allocation id of the persistent task_@param failure      the reason for restarting the task or null if the task completed successfully_@param listener     the listener that will be called when task is removed;public void completePersistentTask(String id, long allocationId, Exception failure, ActionListener<PersistentTask<?>> listener) {_        final String source__        if (failure != null) {_            logger.warn("persistent task " + id + " failed", failure)__            source = "finish persistent task (failed)"__        } else {_            source = "finish persistent task (success)"__        }_        clusterService.submitStateUpdateTask(source, new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                PersistentTasksCustomMetaData.Builder tasksInProgress = builder(currentState)__                if (tasksInProgress.hasTask(id, allocationId)) {_                    tasksInProgress.removeTask(id)__                    return update(currentState, tasksInProgress)__                } else {_                    if (tasksInProgress.hasTask(id)) {_                        logger.warn("The task [{}] with id [{}] was found but it has a different allocation id [{}], status is not updated",_                                PersistentTasksCustomMetaData.getTaskWithId(currentState, id).getTaskName(), id, allocationId)__                    } else {_                        logger.warn("The task [{}] wasn't found, status is not updated", id)__                    }_                    throw new ResourceNotFoundException("the task with id [" + id + "] and allocation id [" + allocationId + "] not found")__                }_            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                _                listener.onResponse(PersistentTasksCustomMetaData.getTaskWithId(oldState, id))__            }_        })__    };restarts,a,record,about,a,running,persistent,task,from,cluster,state,param,id,the,id,of,the,persistent,task,param,allocation,id,the,allocation,id,of,the,persistent,task,param,failure,the,reason,for,restarting,the,task,or,null,if,the,task,completed,successfully,param,listener,the,listener,that,will,be,called,when,task,is,removed;public,void,complete,persistent,task,string,id,long,allocation,id,exception,failure,action,listener,persistent,task,listener,final,string,source,if,failure,null,logger,warn,persistent,task,id,failed,failure,source,finish,persistent,task,failed,else,source,finish,persistent,task,success,cluster,service,submit,state,update,task,source,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,persistent,tasks,custom,meta,data,builder,tasks,in,progress,builder,current,state,if,tasks,in,progress,has,task,id,allocation,id,tasks,in,progress,remove,task,id,return,update,current,state,tasks,in,progress,else,if,tasks,in,progress,has,task,id,logger,warn,the,task,with,id,was,found,but,it,has,a,different,allocation,id,status,is,not,updated,persistent,tasks,custom,meta,data,get,task,with,id,current,state,id,get,task,name,id,allocation,id,else,logger,warn,the,task,wasn,t,found,status,is,not,updated,id,throw,new,resource,not,found,exception,the,task,with,id,id,and,allocation,id,allocation,id,not,found,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,persistent,tasks,custom,meta,data,get,task,with,id,old,state,id
PersistentTasksClusterService -> public void completePersistentTask(String id, long allocationId, Exception failure, ActionListener<PersistentTask<?>> listener);1541092382;Restarts a record about a running persistent task from cluster state__@param id           the id of the persistent task_@param allocationId the allocation id of the persistent task_@param failure      the reason for restarting the task or null if the task completed successfully_@param listener     the listener that will be called when task is removed;public void completePersistentTask(String id, long allocationId, Exception failure, ActionListener<PersistentTask<?>> listener) {_        final String source__        if (failure != null) {_            logger.warn("persistent task " + id + " failed", failure)__            source = "finish persistent task (failed)"__        } else {_            source = "finish persistent task (success)"__        }_        clusterService.submitStateUpdateTask(source, new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                PersistentTasksCustomMetaData.Builder tasksInProgress = builder(currentState)__                if (tasksInProgress.hasTask(id, allocationId)) {_                    tasksInProgress.removeTask(id)__                    return update(currentState, tasksInProgress)__                } else {_                    if (tasksInProgress.hasTask(id)) {_                        logger.warn("The task [{}] with id [{}] was found but it has a different allocation id [{}], status is not updated",_                                PersistentTasksCustomMetaData.getTaskWithId(currentState, id).getTaskName(), id, allocationId)__                    } else {_                        logger.warn("The task [{}] wasn't found, status is not updated", id)__                    }_                    throw new ResourceNotFoundException("the task with id [" + id + "] and allocation id [" + allocationId + "] not found")__                }_            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                _                listener.onResponse(PersistentTasksCustomMetaData.getTaskWithId(oldState, id))__            }_        })__    };restarts,a,record,about,a,running,persistent,task,from,cluster,state,param,id,the,id,of,the,persistent,task,param,allocation,id,the,allocation,id,of,the,persistent,task,param,failure,the,reason,for,restarting,the,task,or,null,if,the,task,completed,successfully,param,listener,the,listener,that,will,be,called,when,task,is,removed;public,void,complete,persistent,task,string,id,long,allocation,id,exception,failure,action,listener,persistent,task,listener,final,string,source,if,failure,null,logger,warn,persistent,task,id,failed,failure,source,finish,persistent,task,failed,else,source,finish,persistent,task,success,cluster,service,submit,state,update,task,source,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,persistent,tasks,custom,meta,data,builder,tasks,in,progress,builder,current,state,if,tasks,in,progress,has,task,id,allocation,id,tasks,in,progress,remove,task,id,return,update,current,state,tasks,in,progress,else,if,tasks,in,progress,has,task,id,logger,warn,the,task,with,id,was,found,but,it,has,a,different,allocation,id,status,is,not,updated,persistent,tasks,custom,meta,data,get,task,with,id,current,state,id,get,task,name,id,allocation,id,else,logger,warn,the,task,wasn,t,found,status,is,not,updated,id,throw,new,resource,not,found,exception,the,task,with,id,id,and,allocation,id,allocation,id,not,found,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,persistent,tasks,custom,meta,data,get,task,with,id,old,state,id
PersistentTasksClusterService -> public void completePersistentTask(String id, long allocationId, Exception failure, ActionListener<PersistentTask<?>> listener);1542402632;Restarts a record about a running persistent task from cluster state__@param id           the id of the persistent task_@param allocationId the allocation id of the persistent task_@param failure      the reason for restarting the task or null if the task completed successfully_@param listener     the listener that will be called when task is removed;public void completePersistentTask(String id, long allocationId, Exception failure, ActionListener<PersistentTask<?>> listener) {_        final String source__        if (failure != null) {_            logger.warn("persistent task " + id + " failed", failure)__            source = "finish persistent task (failed)"__        } else {_            source = "finish persistent task (success)"__        }_        clusterService.submitStateUpdateTask(source, new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                PersistentTasksCustomMetaData.Builder tasksInProgress = builder(currentState)__                if (tasksInProgress.hasTask(id, allocationId)) {_                    tasksInProgress.removeTask(id)__                    return update(currentState, tasksInProgress)__                } else {_                    if (tasksInProgress.hasTask(id)) {_                        logger.warn("The task [{}] with id [{}] was found but it has a different allocation id [{}], status is not updated",_                                PersistentTasksCustomMetaData.getTaskWithId(currentState, id).getTaskName(), id, allocationId)__                    } else {_                        logger.warn("The task [{}] wasn't found, status is not updated", id)__                    }_                    throw new ResourceNotFoundException("the task with id [" + id + "] and allocation id [" + allocationId + "] not found")__                }_            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                _                listener.onResponse(PersistentTasksCustomMetaData.getTaskWithId(oldState, id))__            }_        })__    };restarts,a,record,about,a,running,persistent,task,from,cluster,state,param,id,the,id,of,the,persistent,task,param,allocation,id,the,allocation,id,of,the,persistent,task,param,failure,the,reason,for,restarting,the,task,or,null,if,the,task,completed,successfully,param,listener,the,listener,that,will,be,called,when,task,is,removed;public,void,complete,persistent,task,string,id,long,allocation,id,exception,failure,action,listener,persistent,task,listener,final,string,source,if,failure,null,logger,warn,persistent,task,id,failed,failure,source,finish,persistent,task,failed,else,source,finish,persistent,task,success,cluster,service,submit,state,update,task,source,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,persistent,tasks,custom,meta,data,builder,tasks,in,progress,builder,current,state,if,tasks,in,progress,has,task,id,allocation,id,tasks,in,progress,remove,task,id,return,update,current,state,tasks,in,progress,else,if,tasks,in,progress,has,task,id,logger,warn,the,task,with,id,was,found,but,it,has,a,different,allocation,id,status,is,not,updated,persistent,tasks,custom,meta,data,get,task,with,id,current,state,id,get,task,name,id,allocation,id,else,logger,warn,the,task,wasn,t,found,status,is,not,updated,id,throw,new,resource,not,found,exception,the,task,with,id,id,and,allocation,id,allocation,id,not,found,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,persistent,tasks,custom,meta,data,get,task,with,id,old,state,id
PersistentTasksClusterService -> public void completePersistentTask(String id, long allocationId, Exception failure, ActionListener<PersistentTask<?>> listener);1544692527;Restarts a record about a running persistent task from cluster state__@param id           the id of the persistent task_@param allocationId the allocation id of the persistent task_@param failure      the reason for restarting the task or null if the task completed successfully_@param listener     the listener that will be called when task is removed;public void completePersistentTask(String id, long allocationId, Exception failure, ActionListener<PersistentTask<?>> listener) {_        final String source__        if (failure != null) {_            logger.warn("persistent task " + id + " failed", failure)__            source = "finish persistent task (failed)"__        } else {_            source = "finish persistent task (success)"__        }_        clusterService.submitStateUpdateTask(source, new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                PersistentTasksCustomMetaData.Builder tasksInProgress = builder(currentState)__                if (tasksInProgress.hasTask(id, allocationId)) {_                    tasksInProgress.removeTask(id)__                    return update(currentState, tasksInProgress)__                } else {_                    if (tasksInProgress.hasTask(id)) {_                        logger.warn("The task [{}] with id [{}] was found but it has a different allocation id [{}], status is not updated",_                                PersistentTasksCustomMetaData.getTaskWithId(currentState, id).getTaskName(), id, allocationId)__                    } else {_                        logger.warn("The task [{}] wasn't found, status is not updated", id)__                    }_                    throw new ResourceNotFoundException("the task with id [" + id + "] and allocation id [" + allocationId + "] not found")__                }_            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                _                listener.onResponse(PersistentTasksCustomMetaData.getTaskWithId(oldState, id))__            }_        })__    };restarts,a,record,about,a,running,persistent,task,from,cluster,state,param,id,the,id,of,the,persistent,task,param,allocation,id,the,allocation,id,of,the,persistent,task,param,failure,the,reason,for,restarting,the,task,or,null,if,the,task,completed,successfully,param,listener,the,listener,that,will,be,called,when,task,is,removed;public,void,complete,persistent,task,string,id,long,allocation,id,exception,failure,action,listener,persistent,task,listener,final,string,source,if,failure,null,logger,warn,persistent,task,id,failed,failure,source,finish,persistent,task,failed,else,source,finish,persistent,task,success,cluster,service,submit,state,update,task,source,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,persistent,tasks,custom,meta,data,builder,tasks,in,progress,builder,current,state,if,tasks,in,progress,has,task,id,allocation,id,tasks,in,progress,remove,task,id,return,update,current,state,tasks,in,progress,else,if,tasks,in,progress,has,task,id,logger,warn,the,task,with,id,was,found,but,it,has,a,different,allocation,id,status,is,not,updated,persistent,tasks,custom,meta,data,get,task,with,id,current,state,id,get,task,name,id,allocation,id,else,logger,warn,the,task,wasn,t,found,status,is,not,updated,id,throw,new,resource,not,found,exception,the,task,with,id,id,and,allocation,id,allocation,id,not,found,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,persistent,tasks,custom,meta,data,get,task,with,id,old,state,id
PersistentTasksClusterService -> public void completePersistentTask(String id, long allocationId, Exception failure, ActionListener<PersistentTask<?>> listener);1545310416;Restarts a record about a running persistent task from cluster state__@param id           the id of the persistent task_@param allocationId the allocation id of the persistent task_@param failure      the reason for restarting the task or null if the task completed successfully_@param listener     the listener that will be called when task is removed;public void completePersistentTask(String id, long allocationId, Exception failure, ActionListener<PersistentTask<?>> listener) {_        final String source__        if (failure != null) {_            logger.warn("persistent task " + id + " failed", failure)__            source = "finish persistent task (failed)"__        } else {_            source = "finish persistent task (success)"__        }_        clusterService.submitStateUpdateTask(source, new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                PersistentTasksCustomMetaData.Builder tasksInProgress = builder(currentState)__                if (tasksInProgress.hasTask(id, allocationId)) {_                    tasksInProgress.removeTask(id)__                    return update(currentState, tasksInProgress)__                } else {_                    if (tasksInProgress.hasTask(id)) {_                        logger.warn("The task [{}] with id [{}] was found but it has a different allocation id [{}], status is not updated",_                                PersistentTasksCustomMetaData.getTaskWithId(currentState, id).getTaskName(), id, allocationId)__                    } else {_                        logger.warn("The task [{}] wasn't found, status is not updated", id)__                    }_                    throw new ResourceNotFoundException("the task with id [" + id + "] and allocation id [" + allocationId + "] not found")__                }_            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                _                listener.onResponse(PersistentTasksCustomMetaData.getTaskWithId(oldState, id))__            }_        })__    };restarts,a,record,about,a,running,persistent,task,from,cluster,state,param,id,the,id,of,the,persistent,task,param,allocation,id,the,allocation,id,of,the,persistent,task,param,failure,the,reason,for,restarting,the,task,or,null,if,the,task,completed,successfully,param,listener,the,listener,that,will,be,called,when,task,is,removed;public,void,complete,persistent,task,string,id,long,allocation,id,exception,failure,action,listener,persistent,task,listener,final,string,source,if,failure,null,logger,warn,persistent,task,id,failed,failure,source,finish,persistent,task,failed,else,source,finish,persistent,task,success,cluster,service,submit,state,update,task,source,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,persistent,tasks,custom,meta,data,builder,tasks,in,progress,builder,current,state,if,tasks,in,progress,has,task,id,allocation,id,tasks,in,progress,remove,task,id,return,update,current,state,tasks,in,progress,else,if,tasks,in,progress,has,task,id,logger,warn,the,task,with,id,was,found,but,it,has,a,different,allocation,id,status,is,not,updated,persistent,tasks,custom,meta,data,get,task,with,id,current,state,id,get,task,name,id,allocation,id,else,logger,warn,the,task,wasn,t,found,status,is,not,updated,id,throw,new,resource,not,found,exception,the,task,with,id,id,and,allocation,id,allocation,id,not,found,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,persistent,tasks,custom,meta,data,get,task,with,id,old,state,id
PersistentTasksClusterService -> public void completePersistentTask(String id, long allocationId, Exception failure, ActionListener<PersistentTask<?>> listener);1548265712;Restarts a record about a running persistent task from cluster state__@param id           the id of the persistent task_@param allocationId the allocation id of the persistent task_@param failure      the reason for restarting the task or null if the task completed successfully_@param listener     the listener that will be called when task is removed;public void completePersistentTask(String id, long allocationId, Exception failure, ActionListener<PersistentTask<?>> listener) {_        final String source__        if (failure != null) {_            logger.warn("persistent task " + id + " failed", failure)__            source = "finish persistent task (failed)"__        } else {_            source = "finish persistent task (success)"__        }_        clusterService.submitStateUpdateTask(source, new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                PersistentTasksCustomMetaData.Builder tasksInProgress = builder(currentState)__                if (tasksInProgress.hasTask(id, allocationId)) {_                    tasksInProgress.removeTask(id)__                    return update(currentState, tasksInProgress)__                } else {_                    if (tasksInProgress.hasTask(id)) {_                        logger.warn("The task [{}] with id [{}] was found but it has a different allocation id [{}], status is not updated",_                                PersistentTasksCustomMetaData.getTaskWithId(currentState, id).getTaskName(), id, allocationId)__                    } else {_                        logger.warn("The task [{}] wasn't found, status is not updated", id)__                    }_                    throw new ResourceNotFoundException("the task with id [" + id + "] and allocation id [" + allocationId + "] not found")__                }_            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                _                listener.onResponse(PersistentTasksCustomMetaData.getTaskWithId(oldState, id))__            }_        })__    };restarts,a,record,about,a,running,persistent,task,from,cluster,state,param,id,the,id,of,the,persistent,task,param,allocation,id,the,allocation,id,of,the,persistent,task,param,failure,the,reason,for,restarting,the,task,or,null,if,the,task,completed,successfully,param,listener,the,listener,that,will,be,called,when,task,is,removed;public,void,complete,persistent,task,string,id,long,allocation,id,exception,failure,action,listener,persistent,task,listener,final,string,source,if,failure,null,logger,warn,persistent,task,id,failed,failure,source,finish,persistent,task,failed,else,source,finish,persistent,task,success,cluster,service,submit,state,update,task,source,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,persistent,tasks,custom,meta,data,builder,tasks,in,progress,builder,current,state,if,tasks,in,progress,has,task,id,allocation,id,tasks,in,progress,remove,task,id,return,update,current,state,tasks,in,progress,else,if,tasks,in,progress,has,task,id,logger,warn,the,task,with,id,was,found,but,it,has,a,different,allocation,id,status,is,not,updated,persistent,tasks,custom,meta,data,get,task,with,id,current,state,id,get,task,name,id,allocation,id,else,logger,warn,the,task,wasn,t,found,status,is,not,updated,id,throw,new,resource,not,found,exception,the,task,with,id,id,and,allocation,id,allocation,id,not,found,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,persistent,tasks,custom,meta,data,get,task,with,id,old,state,id
PersistentTasksClusterService -> static boolean persistentTasksChanged(final ClusterChangedEvent event);1524684173;Returns true if the persistent tasks are not equal between the previous and the current cluster state *;static boolean persistentTasksChanged(final ClusterChangedEvent event) {_        String type = PersistentTasksCustomMetaData.TYPE__        return Objects.equals(event.state().metaData().custom(type), event.previousState().metaData().custom(type)) == false__    };returns,true,if,the,persistent,tasks,are,not,equal,between,the,previous,and,the,current,cluster,state;static,boolean,persistent,tasks,changed,final,cluster,changed,event,event,string,type,persistent,tasks,custom,meta,data,type,return,objects,equals,event,state,meta,data,custom,type,event,previous,state,meta,data,custom,type,false
PersistentTasksClusterService -> static boolean persistentTasksChanged(final ClusterChangedEvent event);1528103657;Returns true if the persistent tasks are not equal between the previous and the current cluster state *;static boolean persistentTasksChanged(final ClusterChangedEvent event) {_        String type = PersistentTasksCustomMetaData.TYPE__        return Objects.equals(event.state().metaData().custom(type), event.previousState().metaData().custom(type)) == false__    };returns,true,if,the,persistent,tasks,are,not,equal,between,the,previous,and,the,current,cluster,state;static,boolean,persistent,tasks,changed,final,cluster,changed,event,event,string,type,persistent,tasks,custom,meta,data,type,return,objects,equals,event,state,meta,data,custom,type,event,previous,state,meta,data,custom,type,false
PersistentTasksClusterService -> static boolean persistentTasksChanged(final ClusterChangedEvent event);1529076503;Returns true if the persistent tasks are not equal between the previous and the current cluster state *;static boolean persistentTasksChanged(final ClusterChangedEvent event) {_        String type = PersistentTasksCustomMetaData.TYPE__        return Objects.equals(event.state().metaData().custom(type), event.previousState().metaData().custom(type)) == false__    };returns,true,if,the,persistent,tasks,are,not,equal,between,the,previous,and,the,current,cluster,state;static,boolean,persistent,tasks,changed,final,cluster,changed,event,event,string,type,persistent,tasks,custom,meta,data,type,return,objects,equals,event,state,meta,data,custom,type,event,previous,state,meta,data,custom,type,false
PersistentTasksClusterService -> static boolean persistentTasksChanged(final ClusterChangedEvent event);1532353780;Returns true if the persistent tasks are not equal between the previous and the current cluster state *;static boolean persistentTasksChanged(final ClusterChangedEvent event) {_        String type = PersistentTasksCustomMetaData.TYPE__        return Objects.equals(event.state().metaData().custom(type), event.previousState().metaData().custom(type)) == false__    };returns,true,if,the,persistent,tasks,are,not,equal,between,the,previous,and,the,current,cluster,state;static,boolean,persistent,tasks,changed,final,cluster,changed,event,event,string,type,persistent,tasks,custom,meta,data,type,return,objects,equals,event,state,meta,data,custom,type,event,previous,state,meta,data,custom,type,false
PersistentTasksClusterService -> static boolean persistentTasksChanged(final ClusterChangedEvent event);1541092382;Returns true if the persistent tasks are not equal between the previous and the current cluster state *;static boolean persistentTasksChanged(final ClusterChangedEvent event) {_        String type = PersistentTasksCustomMetaData.TYPE__        return Objects.equals(event.state().metaData().custom(type), event.previousState().metaData().custom(type)) == false__    };returns,true,if,the,persistent,tasks,are,not,equal,between,the,previous,and,the,current,cluster,state;static,boolean,persistent,tasks,changed,final,cluster,changed,event,event,string,type,persistent,tasks,custom,meta,data,type,return,objects,equals,event,state,meta,data,custom,type,event,previous,state,meta,data,custom,type,false
PersistentTasksClusterService -> static boolean persistentTasksChanged(final ClusterChangedEvent event);1542402632;Returns true if the persistent tasks are not equal between the previous and the current cluster state *;static boolean persistentTasksChanged(final ClusterChangedEvent event) {_        String type = PersistentTasksCustomMetaData.TYPE__        return Objects.equals(event.state().metaData().custom(type), event.previousState().metaData().custom(type)) == false__    };returns,true,if,the,persistent,tasks,are,not,equal,between,the,previous,and,the,current,cluster,state;static,boolean,persistent,tasks,changed,final,cluster,changed,event,event,string,type,persistent,tasks,custom,meta,data,type,return,objects,equals,event,state,meta,data,custom,type,event,previous,state,meta,data,custom,type,false
PersistentTasksClusterService -> static boolean persistentTasksChanged(final ClusterChangedEvent event);1544692527;Returns true if the persistent tasks are not equal between the previous and the current cluster state *;static boolean persistentTasksChanged(final ClusterChangedEvent event) {_        String type = PersistentTasksCustomMetaData.TYPE__        return Objects.equals(event.state().metaData().custom(type), event.previousState().metaData().custom(type)) == false__    };returns,true,if,the,persistent,tasks,are,not,equal,between,the,previous,and,the,current,cluster,state;static,boolean,persistent,tasks,changed,final,cluster,changed,event,event,string,type,persistent,tasks,custom,meta,data,type,return,objects,equals,event,state,meta,data,custom,type,event,previous,state,meta,data,custom,type,false
PersistentTasksClusterService -> static boolean persistentTasksChanged(final ClusterChangedEvent event);1545310416;Returns true if the persistent tasks are not equal between the previous and the current cluster state *;static boolean persistentTasksChanged(final ClusterChangedEvent event) {_        String type = PersistentTasksCustomMetaData.TYPE__        return Objects.equals(event.state().metaData().custom(type), event.previousState().metaData().custom(type)) == false__    };returns,true,if,the,persistent,tasks,are,not,equal,between,the,previous,and,the,current,cluster,state;static,boolean,persistent,tasks,changed,final,cluster,changed,event,event,string,type,persistent,tasks,custom,meta,data,type,return,objects,equals,event,state,meta,data,custom,type,event,previous,state,meta,data,custom,type,false
PersistentTasksClusterService -> static boolean persistentTasksChanged(final ClusterChangedEvent event);1548265712;Returns true if the persistent tasks are not equal between the previous and the current cluster state *;static boolean persistentTasksChanged(final ClusterChangedEvent event) {_        String type = PersistentTasksCustomMetaData.TYPE__        return Objects.equals(event.state().metaData().custom(type), event.previousState().metaData().custom(type)) == false__    };returns,true,if,the,persistent,tasks,are,not,equal,between,the,previous,and,the,current,cluster,state;static,boolean,persistent,tasks,changed,final,cluster,changed,event,event,string,type,persistent,tasks,custom,meta,data,type,return,objects,equals,event,state,meta,data,custom,type,event,previous,state,meta,data,custom,type,false
PersistentTasksClusterService -> private boolean isAnyTaskUnassigned(final PersistentTasksCustomMetaData tasks);1544692527;Returns true if any persistent task is unassigned.;private boolean isAnyTaskUnassigned(final PersistentTasksCustomMetaData tasks) {_        return tasks != null && tasks.tasks().stream().anyMatch(task -> task.getAssignment().isAssigned() == false)__    };returns,true,if,any,persistent,task,is,unassigned;private,boolean,is,any,task,unassigned,final,persistent,tasks,custom,meta,data,tasks,return,tasks,null,tasks,tasks,stream,any,match,task,task,get,assignment,is,assigned,false
PersistentTasksClusterService -> private boolean isAnyTaskUnassigned(final PersistentTasksCustomMetaData tasks);1545310416;Returns true if any persistent task is unassigned.;private boolean isAnyTaskUnassigned(final PersistentTasksCustomMetaData tasks) {_        return tasks != null && tasks.tasks().stream().anyMatch(task -> task.getAssignment().isAssigned() == false)__    };returns,true,if,any,persistent,task,is,unassigned;private,boolean,is,any,task,unassigned,final,persistent,tasks,custom,meta,data,tasks,return,tasks,null,tasks,tasks,stream,any,match,task,task,get,assignment,is,assigned,false
PersistentTasksClusterService -> private boolean isAnyTaskUnassigned(final PersistentTasksCustomMetaData tasks);1548265712;Returns true if any persistent task is unassigned.;private boolean isAnyTaskUnassigned(final PersistentTasksCustomMetaData tasks) {_        return tasks != null && tasks.tasks().stream().anyMatch(task -> task.getAssignment().isAssigned() == false)__    };returns,true,if,any,persistent,task,is,unassigned;private,boolean,is,any,task,unassigned,final,persistent,tasks,custom,meta,data,tasks,return,tasks,null,tasks,tasks,stream,any,match,task,task,get,assignment,is,assigned,false
PersistentTasksClusterService -> public void removePersistentTask(String id, ActionListener<PersistentTask<?>> listener);1524684173;Removes the persistent task__@param id       the id of a persistent task_@param listener the listener that will be called when task is removed;public void removePersistentTask(String id, ActionListener<PersistentTask<?>> listener) {_        clusterService.submitStateUpdateTask("remove persistent task", new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) throws Exception {_                PersistentTasksCustomMetaData.Builder tasksInProgress = builder(currentState)__                if (tasksInProgress.hasTask(id)) {_                    return update(currentState, tasksInProgress.removeTask(id))__                } else {_                    throw new ResourceNotFoundException("the task with id {} doesn't exist", id)__                }_            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                _                listener.onResponse(PersistentTasksCustomMetaData.getTaskWithId(oldState, id))__            }_        })__    };removes,the,persistent,task,param,id,the,id,of,a,persistent,task,param,listener,the,listener,that,will,be,called,when,task,is,removed;public,void,remove,persistent,task,string,id,action,listener,persistent,task,listener,cluster,service,submit,state,update,task,remove,persistent,task,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,persistent,tasks,custom,meta,data,builder,tasks,in,progress,builder,current,state,if,tasks,in,progress,has,task,id,return,update,current,state,tasks,in,progress,remove,task,id,else,throw,new,resource,not,found,exception,the,task,with,id,doesn,t,exist,id,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,persistent,tasks,custom,meta,data,get,task,with,id,old,state,id
PersistentTasksClusterService -> public void removePersistentTask(String id, ActionListener<PersistentTask<?>> listener);1528103657;Removes the persistent task__@param id       the id of a persistent task_@param listener the listener that will be called when task is removed;public void removePersistentTask(String id, ActionListener<PersistentTask<?>> listener) {_        clusterService.submitStateUpdateTask("remove persistent task", new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) throws Exception {_                PersistentTasksCustomMetaData.Builder tasksInProgress = builder(currentState)__                if (tasksInProgress.hasTask(id)) {_                    return update(currentState, tasksInProgress.removeTask(id))__                } else {_                    throw new ResourceNotFoundException("the task with id {} doesn't exist", id)__                }_            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                _                listener.onResponse(PersistentTasksCustomMetaData.getTaskWithId(oldState, id))__            }_        })__    };removes,the,persistent,task,param,id,the,id,of,a,persistent,task,param,listener,the,listener,that,will,be,called,when,task,is,removed;public,void,remove,persistent,task,string,id,action,listener,persistent,task,listener,cluster,service,submit,state,update,task,remove,persistent,task,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,persistent,tasks,custom,meta,data,builder,tasks,in,progress,builder,current,state,if,tasks,in,progress,has,task,id,return,update,current,state,tasks,in,progress,remove,task,id,else,throw,new,resource,not,found,exception,the,task,with,id,doesn,t,exist,id,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,persistent,tasks,custom,meta,data,get,task,with,id,old,state,id
PersistentTasksClusterService -> public void removePersistentTask(String id, ActionListener<PersistentTask<?>> listener);1529076503;Removes the persistent task__@param id       the id of a persistent task_@param listener the listener that will be called when task is removed;public void removePersistentTask(String id, ActionListener<PersistentTask<?>> listener) {_        clusterService.submitStateUpdateTask("remove persistent task", new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) throws Exception {_                PersistentTasksCustomMetaData.Builder tasksInProgress = builder(currentState)__                if (tasksInProgress.hasTask(id)) {_                    return update(currentState, tasksInProgress.removeTask(id))__                } else {_                    throw new ResourceNotFoundException("the task with id {} doesn't exist", id)__                }_            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                _                listener.onResponse(PersistentTasksCustomMetaData.getTaskWithId(oldState, id))__            }_        })__    };removes,the,persistent,task,param,id,the,id,of,a,persistent,task,param,listener,the,listener,that,will,be,called,when,task,is,removed;public,void,remove,persistent,task,string,id,action,listener,persistent,task,listener,cluster,service,submit,state,update,task,remove,persistent,task,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,persistent,tasks,custom,meta,data,builder,tasks,in,progress,builder,current,state,if,tasks,in,progress,has,task,id,return,update,current,state,tasks,in,progress,remove,task,id,else,throw,new,resource,not,found,exception,the,task,with,id,doesn,t,exist,id,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,persistent,tasks,custom,meta,data,get,task,with,id,old,state,id
PersistentTasksClusterService -> public void removePersistentTask(String id, ActionListener<PersistentTask<?>> listener);1532353780;Removes the persistent task__@param id       the id of a persistent task_@param listener the listener that will be called when task is removed;public void removePersistentTask(String id, ActionListener<PersistentTask<?>> listener) {_        clusterService.submitStateUpdateTask("remove persistent task", new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) throws Exception {_                PersistentTasksCustomMetaData.Builder tasksInProgress = builder(currentState)__                if (tasksInProgress.hasTask(id)) {_                    return update(currentState, tasksInProgress.removeTask(id))__                } else {_                    throw new ResourceNotFoundException("the task with id {} doesn't exist", id)__                }_            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                _                listener.onResponse(PersistentTasksCustomMetaData.getTaskWithId(oldState, id))__            }_        })__    };removes,the,persistent,task,param,id,the,id,of,a,persistent,task,param,listener,the,listener,that,will,be,called,when,task,is,removed;public,void,remove,persistent,task,string,id,action,listener,persistent,task,listener,cluster,service,submit,state,update,task,remove,persistent,task,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,persistent,tasks,custom,meta,data,builder,tasks,in,progress,builder,current,state,if,tasks,in,progress,has,task,id,return,update,current,state,tasks,in,progress,remove,task,id,else,throw,new,resource,not,found,exception,the,task,with,id,doesn,t,exist,id,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,persistent,tasks,custom,meta,data,get,task,with,id,old,state,id
PersistentTasksClusterService -> public void removePersistentTask(String id, ActionListener<PersistentTask<?>> listener);1541092382;Removes the persistent task__@param id       the id of a persistent task_@param listener the listener that will be called when task is removed;public void removePersistentTask(String id, ActionListener<PersistentTask<?>> listener) {_        clusterService.submitStateUpdateTask("remove persistent task", new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) throws Exception {_                PersistentTasksCustomMetaData.Builder tasksInProgress = builder(currentState)__                if (tasksInProgress.hasTask(id)) {_                    return update(currentState, tasksInProgress.removeTask(id))__                } else {_                    throw new ResourceNotFoundException("the task with id {} doesn't exist", id)__                }_            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                _                listener.onResponse(PersistentTasksCustomMetaData.getTaskWithId(oldState, id))__            }_        })__    };removes,the,persistent,task,param,id,the,id,of,a,persistent,task,param,listener,the,listener,that,will,be,called,when,task,is,removed;public,void,remove,persistent,task,string,id,action,listener,persistent,task,listener,cluster,service,submit,state,update,task,remove,persistent,task,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,persistent,tasks,custom,meta,data,builder,tasks,in,progress,builder,current,state,if,tasks,in,progress,has,task,id,return,update,current,state,tasks,in,progress,remove,task,id,else,throw,new,resource,not,found,exception,the,task,with,id,doesn,t,exist,id,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,persistent,tasks,custom,meta,data,get,task,with,id,old,state,id
PersistentTasksClusterService -> public void removePersistentTask(String id, ActionListener<PersistentTask<?>> listener);1542402632;Removes the persistent task__@param id       the id of a persistent task_@param listener the listener that will be called when task is removed;public void removePersistentTask(String id, ActionListener<PersistentTask<?>> listener) {_        clusterService.submitStateUpdateTask("remove persistent task", new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) throws Exception {_                PersistentTasksCustomMetaData.Builder tasksInProgress = builder(currentState)__                if (tasksInProgress.hasTask(id)) {_                    return update(currentState, tasksInProgress.removeTask(id))__                } else {_                    throw new ResourceNotFoundException("the task with id {} doesn't exist", id)__                }_            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                _                listener.onResponse(PersistentTasksCustomMetaData.getTaskWithId(oldState, id))__            }_        })__    };removes,the,persistent,task,param,id,the,id,of,a,persistent,task,param,listener,the,listener,that,will,be,called,when,task,is,removed;public,void,remove,persistent,task,string,id,action,listener,persistent,task,listener,cluster,service,submit,state,update,task,remove,persistent,task,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,persistent,tasks,custom,meta,data,builder,tasks,in,progress,builder,current,state,if,tasks,in,progress,has,task,id,return,update,current,state,tasks,in,progress,remove,task,id,else,throw,new,resource,not,found,exception,the,task,with,id,doesn,t,exist,id,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,persistent,tasks,custom,meta,data,get,task,with,id,old,state,id
PersistentTasksClusterService -> public void removePersistentTask(String id, ActionListener<PersistentTask<?>> listener);1544692527;Removes the persistent task__@param id       the id of a persistent task_@param listener the listener that will be called when task is removed;public void removePersistentTask(String id, ActionListener<PersistentTask<?>> listener) {_        clusterService.submitStateUpdateTask("remove persistent task", new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                PersistentTasksCustomMetaData.Builder tasksInProgress = builder(currentState)__                if (tasksInProgress.hasTask(id)) {_                    return update(currentState, tasksInProgress.removeTask(id))__                } else {_                    throw new ResourceNotFoundException("the task with id {} doesn't exist", id)__                }_            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                _                listener.onResponse(PersistentTasksCustomMetaData.getTaskWithId(oldState, id))__            }_        })__    };removes,the,persistent,task,param,id,the,id,of,a,persistent,task,param,listener,the,listener,that,will,be,called,when,task,is,removed;public,void,remove,persistent,task,string,id,action,listener,persistent,task,listener,cluster,service,submit,state,update,task,remove,persistent,task,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,persistent,tasks,custom,meta,data,builder,tasks,in,progress,builder,current,state,if,tasks,in,progress,has,task,id,return,update,current,state,tasks,in,progress,remove,task,id,else,throw,new,resource,not,found,exception,the,task,with,id,doesn,t,exist,id,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,persistent,tasks,custom,meta,data,get,task,with,id,old,state,id
PersistentTasksClusterService -> public void removePersistentTask(String id, ActionListener<PersistentTask<?>> listener);1545310416;Removes the persistent task__@param id       the id of a persistent task_@param listener the listener that will be called when task is removed;public void removePersistentTask(String id, ActionListener<PersistentTask<?>> listener) {_        clusterService.submitStateUpdateTask("remove persistent task", new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                PersistentTasksCustomMetaData.Builder tasksInProgress = builder(currentState)__                if (tasksInProgress.hasTask(id)) {_                    return update(currentState, tasksInProgress.removeTask(id))__                } else {_                    throw new ResourceNotFoundException("the task with id {} doesn't exist", id)__                }_            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                _                listener.onResponse(PersistentTasksCustomMetaData.getTaskWithId(oldState, id))__            }_        })__    };removes,the,persistent,task,param,id,the,id,of,a,persistent,task,param,listener,the,listener,that,will,be,called,when,task,is,removed;public,void,remove,persistent,task,string,id,action,listener,persistent,task,listener,cluster,service,submit,state,update,task,remove,persistent,task,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,persistent,tasks,custom,meta,data,builder,tasks,in,progress,builder,current,state,if,tasks,in,progress,has,task,id,return,update,current,state,tasks,in,progress,remove,task,id,else,throw,new,resource,not,found,exception,the,task,with,id,doesn,t,exist,id,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,persistent,tasks,custom,meta,data,get,task,with,id,old,state,id
PersistentTasksClusterService -> public void removePersistentTask(String id, ActionListener<PersistentTask<?>> listener);1548265712;Removes the persistent task__@param id       the id of a persistent task_@param listener the listener that will be called when task is removed;public void removePersistentTask(String id, ActionListener<PersistentTask<?>> listener) {_        clusterService.submitStateUpdateTask("remove persistent task", new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                PersistentTasksCustomMetaData.Builder tasksInProgress = builder(currentState)__                if (tasksInProgress.hasTask(id)) {_                    return update(currentState, tasksInProgress.removeTask(id))__                } else {_                    throw new ResourceNotFoundException("the task with id {} doesn't exist", id)__                }_            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                _                listener.onResponse(PersistentTasksCustomMetaData.getTaskWithId(oldState, id))__            }_        })__    };removes,the,persistent,task,param,id,the,id,of,a,persistent,task,param,listener,the,listener,that,will,be,called,when,task,is,removed;public,void,remove,persistent,task,string,id,action,listener,persistent,task,listener,cluster,service,submit,state,update,task,remove,persistent,task,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,persistent,tasks,custom,meta,data,builder,tasks,in,progress,builder,current,state,if,tasks,in,progress,has,task,id,return,update,current,state,tasks,in,progress,remove,task,id,else,throw,new,resource,not,found,exception,the,task,with,id,doesn,t,exist,id,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,persistent,tasks,custom,meta,data,get,task,with,id,old,state,id
PersistentTasksClusterService -> public static boolean needsReassignment(final Assignment assignment, final DiscoveryNodes nodes);1524684173;Returns true if the task is not assigned or is assigned to a non-existing node;public static boolean needsReassignment(final Assignment assignment, final DiscoveryNodes nodes) {_        return (assignment.isAssigned() == false || nodes.nodeExists(assignment.getExecutorNode()) == false)__    };returns,true,if,the,task,is,not,assigned,or,is,assigned,to,a,non,existing,node;public,static,boolean,needs,reassignment,final,assignment,assignment,final,discovery,nodes,nodes,return,assignment,is,assigned,false,nodes,node,exists,assignment,get,executor,node,false
PersistentTasksClusterService -> public static boolean needsReassignment(final Assignment assignment, final DiscoveryNodes nodes);1528103657;Returns true if the task is not assigned or is assigned to a non-existing node;public static boolean needsReassignment(final Assignment assignment, final DiscoveryNodes nodes) {_        return (assignment.isAssigned() == false || nodes.nodeExists(assignment.getExecutorNode()) == false)__    };returns,true,if,the,task,is,not,assigned,or,is,assigned,to,a,non,existing,node;public,static,boolean,needs,reassignment,final,assignment,assignment,final,discovery,nodes,nodes,return,assignment,is,assigned,false,nodes,node,exists,assignment,get,executor,node,false
PersistentTasksClusterService -> public static boolean needsReassignment(final Assignment assignment, final DiscoveryNodes nodes);1529076503;Returns true if the task is not assigned or is assigned to a non-existing node;public static boolean needsReassignment(final Assignment assignment, final DiscoveryNodes nodes) {_        return (assignment.isAssigned() == false || nodes.nodeExists(assignment.getExecutorNode()) == false)__    };returns,true,if,the,task,is,not,assigned,or,is,assigned,to,a,non,existing,node;public,static,boolean,needs,reassignment,final,assignment,assignment,final,discovery,nodes,nodes,return,assignment,is,assigned,false,nodes,node,exists,assignment,get,executor,node,false
PersistentTasksClusterService -> public static boolean needsReassignment(final Assignment assignment, final DiscoveryNodes nodes);1532353780;Returns true if the task is not assigned or is assigned to a non-existing node;public static boolean needsReassignment(final Assignment assignment, final DiscoveryNodes nodes) {_        return (assignment.isAssigned() == false || nodes.nodeExists(assignment.getExecutorNode()) == false)__    };returns,true,if,the,task,is,not,assigned,or,is,assigned,to,a,non,existing,node;public,static,boolean,needs,reassignment,final,assignment,assignment,final,discovery,nodes,nodes,return,assignment,is,assigned,false,nodes,node,exists,assignment,get,executor,node,false
PersistentTasksClusterService -> public static boolean needsReassignment(final Assignment assignment, final DiscoveryNodes nodes);1541092382;Returns true if the task is not assigned or is assigned to a non-existing node;public static boolean needsReassignment(final Assignment assignment, final DiscoveryNodes nodes) {_        return (assignment.isAssigned() == false || nodes.nodeExists(assignment.getExecutorNode()) == false)__    };returns,true,if,the,task,is,not,assigned,or,is,assigned,to,a,non,existing,node;public,static,boolean,needs,reassignment,final,assignment,assignment,final,discovery,nodes,nodes,return,assignment,is,assigned,false,nodes,node,exists,assignment,get,executor,node,false
PersistentTasksClusterService -> public static boolean needsReassignment(final Assignment assignment, final DiscoveryNodes nodes);1542402632;Returns true if the task is not assigned or is assigned to a non-existing node;public static boolean needsReassignment(final Assignment assignment, final DiscoveryNodes nodes) {_        return (assignment.isAssigned() == false || nodes.nodeExists(assignment.getExecutorNode()) == false)__    };returns,true,if,the,task,is,not,assigned,or,is,assigned,to,a,non,existing,node;public,static,boolean,needs,reassignment,final,assignment,assignment,final,discovery,nodes,nodes,return,assignment,is,assigned,false,nodes,node,exists,assignment,get,executor,node,false
PersistentTasksClusterService -> public static boolean needsReassignment(final Assignment assignment, final DiscoveryNodes nodes);1544692527;Returns true if the task is not assigned or is assigned to a non-existing node;public static boolean needsReassignment(final Assignment assignment, final DiscoveryNodes nodes) {_        return (assignment.isAssigned() == false || nodes.nodeExists(assignment.getExecutorNode()) == false)__    };returns,true,if,the,task,is,not,assigned,or,is,assigned,to,a,non,existing,node;public,static,boolean,needs,reassignment,final,assignment,assignment,final,discovery,nodes,nodes,return,assignment,is,assigned,false,nodes,node,exists,assignment,get,executor,node,false
PersistentTasksClusterService -> public static boolean needsReassignment(final Assignment assignment, final DiscoveryNodes nodes);1545310416;Returns true if the task is not assigned or is assigned to a non-existing node;public static boolean needsReassignment(final Assignment assignment, final DiscoveryNodes nodes) {_        return (assignment.isAssigned() == false || nodes.nodeExists(assignment.getExecutorNode()) == false)__    };returns,true,if,the,task,is,not,assigned,or,is,assigned,to,a,non,existing,node;public,static,boolean,needs,reassignment,final,assignment,assignment,final,discovery,nodes,nodes,return,assignment,is,assigned,false,nodes,node,exists,assignment,get,executor,node,false
PersistentTasksClusterService -> public static boolean needsReassignment(final Assignment assignment, final DiscoveryNodes nodes);1548265712;Returns true if the task is not assigned or is assigned to a non-existing node;public static boolean needsReassignment(final Assignment assignment, final DiscoveryNodes nodes) {_        return (assignment.isAssigned() == false || nodes.nodeExists(assignment.getExecutorNode()) == false)__    };returns,true,if,the,task,is,not,assigned,or,is,assigned,to,a,non,existing,node;public,static,boolean,needs,reassignment,final,assignment,assignment,final,discovery,nodes,nodes,return,assignment,is,assigned,false,nodes,node,exists,assignment,get,executor,node,false
PersistentTasksClusterService -> public void updatePersistentTaskStatus(String id, long allocationId, Task.Status status, ActionListener<PersistentTask<?>> listener);1524684173;Update task status__@param id           the id of a persistent task_@param allocationId the expected allocation id of the persistent task_@param status       new status_@param listener     the listener that will be called when task is removed;public void updatePersistentTaskStatus(String id, long allocationId, Task.Status status, ActionListener<PersistentTask<?>> listener) {_        clusterService.submitStateUpdateTask("update task status", new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                PersistentTasksCustomMetaData.Builder tasksInProgress = builder(currentState)__                if (tasksInProgress.hasTask(id, allocationId)) {_                    return update(currentState, tasksInProgress.updateTaskStatus(id, status))__                } else {_                    if (tasksInProgress.hasTask(id)) {_                        logger.warn("trying to update status on task {} with unexpected allocation id {}", id, allocationId)__                    } else {_                        logger.warn("trying to update status on non-existing task {}", id)__                    }_                    throw new ResourceNotFoundException("the task with id {} and allocation id {} doesn't exist", id, allocationId)__                }_            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                listener.onResponse(PersistentTasksCustomMetaData.getTaskWithId(newState, id))__            }_        })__    };update,task,status,param,id,the,id,of,a,persistent,task,param,allocation,id,the,expected,allocation,id,of,the,persistent,task,param,status,new,status,param,listener,the,listener,that,will,be,called,when,task,is,removed;public,void,update,persistent,task,status,string,id,long,allocation,id,task,status,status,action,listener,persistent,task,listener,cluster,service,submit,state,update,task,update,task,status,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,persistent,tasks,custom,meta,data,builder,tasks,in,progress,builder,current,state,if,tasks,in,progress,has,task,id,allocation,id,return,update,current,state,tasks,in,progress,update,task,status,id,status,else,if,tasks,in,progress,has,task,id,logger,warn,trying,to,update,status,on,task,with,unexpected,allocation,id,id,allocation,id,else,logger,warn,trying,to,update,status,on,non,existing,task,id,throw,new,resource,not,found,exception,the,task,with,id,and,allocation,id,doesn,t,exist,id,allocation,id,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,persistent,tasks,custom,meta,data,get,task,with,id,new,state,id
PersistentTasksClusterService -> public void updatePersistentTaskStatus(String id, long allocationId, Task.Status status, ActionListener<PersistentTask<?>> listener);1528103657;Update task status__@param id           the id of a persistent task_@param allocationId the expected allocation id of the persistent task_@param status       new status_@param listener     the listener that will be called when task is removed;public void updatePersistentTaskStatus(String id, long allocationId, Task.Status status, ActionListener<PersistentTask<?>> listener) {_        clusterService.submitStateUpdateTask("update task status", new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                PersistentTasksCustomMetaData.Builder tasksInProgress = builder(currentState)__                if (tasksInProgress.hasTask(id, allocationId)) {_                    return update(currentState, tasksInProgress.updateTaskStatus(id, status))__                } else {_                    if (tasksInProgress.hasTask(id)) {_                        logger.warn("trying to update status on task {} with unexpected allocation id {}", id, allocationId)__                    } else {_                        logger.warn("trying to update status on non-existing task {}", id)__                    }_                    throw new ResourceNotFoundException("the task with id {} and allocation id {} doesn't exist", id, allocationId)__                }_            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                listener.onResponse(PersistentTasksCustomMetaData.getTaskWithId(newState, id))__            }_        })__    };update,task,status,param,id,the,id,of,a,persistent,task,param,allocation,id,the,expected,allocation,id,of,the,persistent,task,param,status,new,status,param,listener,the,listener,that,will,be,called,when,task,is,removed;public,void,update,persistent,task,status,string,id,long,allocation,id,task,status,status,action,listener,persistent,task,listener,cluster,service,submit,state,update,task,update,task,status,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,persistent,tasks,custom,meta,data,builder,tasks,in,progress,builder,current,state,if,tasks,in,progress,has,task,id,allocation,id,return,update,current,state,tasks,in,progress,update,task,status,id,status,else,if,tasks,in,progress,has,task,id,logger,warn,trying,to,update,status,on,task,with,unexpected,allocation,id,id,allocation,id,else,logger,warn,trying,to,update,status,on,non,existing,task,id,throw,new,resource,not,found,exception,the,task,with,id,and,allocation,id,doesn,t,exist,id,allocation,id,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,persistent,tasks,custom,meta,data,get,task,with,id,new,state,id
