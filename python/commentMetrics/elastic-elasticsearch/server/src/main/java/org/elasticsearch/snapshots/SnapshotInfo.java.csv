commented;modifiers;parameterAmount;loc;comment;code
false;private;1;3;;private void setSnapshotName(String snapshotName) {     this.snapshotName = snapshotName. }
false;private;1;3;;private void setSnapshotUUID(String snapshotUUID) {     this.snapshotUUID = snapshotUUID. }
false;private;1;3;;private void setState(String state) {     this.state = state. }
false;private;1;3;;private void setReason(String reason) {     this.reason = reason. }
false;private;1;3;;private void setIndices(List<String> indices) {     this.indices = indices. }
false;private;1;3;;private void setStartTime(long startTime) {     this.startTime = startTime. }
false;private;1;3;;private void setEndTime(long endTime) {     this.endTime = endTime. }
false;private;1;3;;private void setShardStatsBuilder(ShardStatsBuilder shardStatsBuilder) {     this.shardStatsBuilder = shardStatsBuilder. }
false;private;1;3;;private void setIncludeGlobalState(Boolean includeGlobalState) {     this.includeGlobalState = includeGlobalState. }
false;private;1;3;;private void setVersion(int version) {     this.version = version. }
false;private;1;3;;private void setShardFailures(List<SnapshotShardFailure> shardFailures) {     this.shardFailures = shardFailures. }
false;public;0;20;;public SnapshotInfo build() {     SnapshotId snapshotId = new SnapshotId(snapshotName, snapshotUUID).     if (indices == null) {         indices = Collections.emptyList().     }     SnapshotState snapshotState = state == null ? null : SnapshotState.valueOf(state).     Version version = this.version == -1 ? Version.CURRENT : Version.fromId(this.version).     int totalShards = shardStatsBuilder == null ? 0 : shardStatsBuilder.getTotalShards().     int successfulShards = shardStatsBuilder == null ? 0 : shardStatsBuilder.getSuccessfulShards().     if (shardFailures == null) {         shardFailures = new ArrayList<>().     }     return new SnapshotInfo(snapshotId, indices, snapshotState, reason, version, startTime, endTime, totalShards, successfulShards, shardFailures, includeGlobalState). }
false;private;1;3;;private void setTotalShards(int totalShards) {     this.totalShards = totalShards. }
false;;0;3;;int getTotalShards() {     return totalShards. }
false;private;1;3;;private void setSuccessfulShards(int successfulShards) {     this.successfulShards = successfulShards. }
false;;0;3;;int getSuccessfulShards() {     return successfulShards. }
true;public,static;1;6;/**  * Gets a new {@link SnapshotInfo} instance for a snapshot that is incompatible with the  * current version of the cluster.  */ ;/**  * Gets a new {@link SnapshotInfo} instance for a snapshot that is incompatible with the  * current version of the cluster.  */ public static SnapshotInfo incompatible(SnapshotId snapshotId) {     return new SnapshotInfo(snapshotId, Collections.emptyList(), SnapshotState.INCOMPATIBLE, "the snapshot is incompatible with the current version of Elasticsearch and its exact version is unknown", null, 0L, 0L, 0, 0, Collections.emptyList(), null). }
true;public;0;3;/**  * Gets a new {@link SnapshotInfo} instance from the given {@link SnapshotInfo} with  * all information stripped out except the snapshot id, state, and indices.  */ ;/**  * Gets a new {@link SnapshotInfo} instance from the given {@link SnapshotInfo} with  * all information stripped out except the snapshot id, state, and indices.  */ public SnapshotInfo basic() {     return new SnapshotInfo(snapshotId, indices, state). }
true;public;0;3;/**  * Returns snapshot id  *  * @return snapshot id  */ ;/**  * Returns snapshot id  *  * @return snapshot id  */ public SnapshotId snapshotId() {     return snapshotId. }
true;public;0;4;/**  * Returns snapshot state. {@code null} if the state is unknown.  *  * @return snapshot state  */ ;/**  * Returns snapshot state. {@code null} if the state is unknown.  *  * @return snapshot state  */ @Nullable public SnapshotState state() {     return state. }
true;public;0;4;/**  * Returns snapshot failure reason. {@code null} if the snapshot succeeded.  *  * @return snapshot failure reason  */ ;/**  * Returns snapshot failure reason. {@code null} if the snapshot succeeded.  *  * @return snapshot failure reason  */ @Nullable public String reason() {     return reason. }
true;public;0;3;/**  * Returns indices that were included in this snapshot.  *  * @return list of indices  */ ;/**  * Returns indices that were included in this snapshot.  *  * @return list of indices  */ public List<String> indices() {     return indices. }
true;public;0;3;/**  * Returns time when snapshot started. a value of {@code 0L} will be returned if  * {@link #state()} returns {@code null}.  *  * @return snapshot start time  */ ;/**  * Returns time when snapshot started. a value of {@code 0L} will be returned if  * {@link #state()} returns {@code null}.  *  * @return snapshot start time  */ public long startTime() {     return startTime. }
true;public;0;3;/**  * Returns time when snapshot ended. a value of {@code 0L} will be returned if the  * snapshot is still running or if {@link #state()} returns {@code null}.  *  * @return snapshot end time  */ ;/**  * Returns time when snapshot ended. a value of {@code 0L} will be returned if the  * snapshot is still running or if {@link #state()} returns {@code null}.  *  * @return snapshot end time  */ public long endTime() {     return endTime. }
true;public;0;3;/**  * Returns total number of shards that were snapshotted. a value of {@code 0} will  * be returned if {@link #state()} returns {@code null}.  *  * @return number of shards  */ ;/**  * Returns total number of shards that were snapshotted. a value of {@code 0} will  * be returned if {@link #state()} returns {@code null}.  *  * @return number of shards  */ public int totalShards() {     return totalShards. }
true;public;0;3;/**  * Number of failed shards. a value of {@code 0} will be returned if there were no  * failed shards, or if {@link #state()} returns {@code null}.  *  * @return number of failed shards  */ ;/**  * Number of failed shards. a value of {@code 0} will be returned if there were no  * failed shards, or if {@link #state()} returns {@code null}.  *  * @return number of failed shards  */ public int failedShards() {     return totalShards - successfulShards. }
true;public;0;3;/**  * Returns total number of shards that were successfully snapshotted. a value of  * {@code 0} will be returned if {@link #state()} returns {@code null}.  *  * @return number of successful shards  */ ;/**  * Returns total number of shards that were successfully snapshotted. a value of  * {@code 0} will be returned if {@link #state()} returns {@code null}.  *  * @return number of successful shards  */ public int successfulShards() {     return successfulShards. }
false;public;0;3;;public Boolean includeGlobalState() {     return includeGlobalState. }
true;public;0;3;/**  * Returns shard failures. an empty list will be returned if there were no shard  * failures, or if {@link #state()} returns {@code null}.  *  * @return shard failures  */ ;/**  * Returns shard failures. an empty list will be returned if there were no shard  * failures, or if {@link #state()} returns {@code null}.  *  * @return shard failures  */ public List<SnapshotShardFailure> shardFailures() {     return shardFailures. }
true;public;0;4;/**  * Returns the version of elasticsearch that the snapshot was created with.  Will only  * return {@code null} if {@link #state()} returns {@code null} or {@link SnapshotState#INCOMPATIBLE}.  *  * @return version of elasticsearch that the snapshot was created with  */ ;/**  * Returns the version of elasticsearch that the snapshot was created with.  Will only  * return {@code null} if {@link #state()} returns {@code null} or {@link SnapshotState#INCOMPATIBLE}.  *  * @return version of elasticsearch that the snapshot was created with  */ @Nullable public Version version() {     return version. }
true;public;1;4;/**  * Compares two snapshots by their start time. if the start times are the same, then  * compares the two snapshots by their snapshot ids.  */ ;/**  * Compares two snapshots by their start time. if the start times are the same, then  * compares the two snapshots by their snapshot ids.  */ @Override public int compareTo(final SnapshotInfo o) {     return COMPARATOR.compare(this, o). }
false;public;0;16;;@Override public String toString() {     return "SnapshotInfo{" + "snapshotId=" + snapshotId + ", state=" + state + ", reason='" + reason + '\'' + ", indices=" + indices + ", startTime=" + startTime + ", endTime=" + endTime + ", totalShards=" + totalShards + ", successfulShards=" + successfulShards + ", includeGlobalState=" + includeGlobalState + ", version=" + version + ", shardFailures=" + shardFailures + '}'. }
true;public;0;10;/**  * Returns snapshot REST status  */ ;/**  * Returns snapshot REST status  */ public RestStatus status() {     if (state == SnapshotState.FAILED) {         return RestStatus.INTERNAL_SERVER_ERROR.     }     if (shardFailures.size() == 0) {         return RestStatus.OK.     }     return RestStatus.status(successfulShards, totalShards, shardFailures.toArray(new ShardOperationFailedException[shardFailures.size()])). }
false;public;2;58;;@Override public XContentBuilder toXContent(final XContentBuilder builder, final Params params) throws IOException {     // write snapshot info to repository snapshot blob format     if (CONTEXT_MODE_SNAPSHOT.equals(params.param(CONTEXT_MODE_PARAM))) {         return toXContentInternal(builder, params).     }     final boolean verbose = params.paramAsBoolean("verbose", GetSnapshotsRequest.DEFAULT_VERBOSE_MODE).     // write snapshot info for the API and any other situations     builder.startObject().     builder.field(SNAPSHOT, snapshotId.getName()).     builder.field(UUID, snapshotId.getUUID()).     if (version != null) {         builder.field(VERSION_ID, version.id).         builder.field(VERSION, version.toString()).     }     builder.startArray(INDICES).     for (String index : indices) {         builder.value(index).     }     builder.endArray().     if (includeGlobalState != null) {         builder.field(INCLUDE_GLOBAL_STATE, includeGlobalState).     }     if (verbose || state != null) {         builder.field(STATE, state).     }     if (reason != null) {         builder.field(REASON, reason).     }     if (verbose || startTime != 0) {         builder.field(START_TIME, DATE_TIME_FORMATTER.format(Instant.ofEpochMilli(startTime).atZone(ZoneOffset.UTC))).         builder.field(START_TIME_IN_MILLIS, startTime).     }     if (verbose || endTime != 0) {         builder.field(END_TIME, DATE_TIME_FORMATTER.format(Instant.ofEpochMilli(endTime).atZone(ZoneOffset.UTC))).         builder.field(END_TIME_IN_MILLIS, endTime).         builder.humanReadableField(DURATION_IN_MILLIS, DURATION, new TimeValue(endTime - startTime)).     }     if (verbose || !shardFailures.isEmpty()) {         builder.startArray(FAILURES).         for (SnapshotShardFailure shardFailure : shardFailures) {             builder.startObject().             shardFailure.toXContent(builder, params).             builder.endObject().         }         builder.endArray().     }     if (verbose || totalShards != 0) {         builder.startObject(SHARDS).         builder.field(TOTAL, totalShards).         builder.field(FAILED, failedShards()).         builder.field(SUCCESSFUL, successfulShards).         builder.endObject().     }     builder.endObject().     return builder. }
false;private;2;32;;private XContentBuilder toXContentInternal(final XContentBuilder builder, final ToXContent.Params params) throws IOException {     builder.startObject(SNAPSHOT).     builder.field(NAME, snapshotId.getName()).     builder.field(UUID, snapshotId.getUUID()).     assert version != null : "version must always be known when writing a snapshot metadata blob".     builder.field(VERSION_ID, version.id).     builder.startArray(INDICES).     for (String index : indices) {         builder.value(index).     }     builder.endArray().     builder.field(STATE, state).     if (reason != null) {         builder.field(REASON, reason).     }     if (includeGlobalState != null) {         builder.field(INCLUDE_GLOBAL_STATE, includeGlobalState).     }     builder.field(START_TIME, startTime).     builder.field(END_TIME, endTime).     builder.field(TOTAL_SHARDS, totalShards).     builder.field(SUCCESSFUL_SHARDS, successfulShards).     builder.startArray(FAILURES).     for (SnapshotShardFailure shardFailure : shardFailures) {         builder.startObject().         shardFailure.toXContent(builder, params).         builder.endObject().     }     builder.endArray().     builder.endObject().     return builder. }
true;public,static;1;92;/**  * This method creates a SnapshotInfo from internal x-content.  It does not  * handle x-content written with the external version as external x-content  * is only for display purposes and does not need to be parsed.  */ ;/**  * This method creates a SnapshotInfo from internal x-content.  It does not  * handle x-content written with the external version as external x-content  * is only for display purposes and does not need to be parsed.  */ public static SnapshotInfo fromXContentInternal(final XContentParser parser) throws IOException {     String name = null.     String uuid = null.     Version version = Version.CURRENT.     SnapshotState state = SnapshotState.IN_PROGRESS.     String reason = null.     List<String> indices = Collections.emptyList().     long startTime = 0.     long endTime = 0.     int totalShards = 0.     int successfulShards = 0.     Boolean includeGlobalState = null.     List<SnapshotShardFailure> shardFailures = Collections.emptyList().     if (parser.currentToken() == null) {         // fresh parser? move to the first token         parser.nextToken().     }     if (parser.currentToken() == XContentParser.Token.START_OBJECT) {         // on a start object move to next token         parser.nextToken().     }     XContentParser.Token token.     if ((token = parser.nextToken()) == XContentParser.Token.START_OBJECT) {         String currentFieldName = parser.currentName().         if (SNAPSHOT.equals(currentFieldName)) {             while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {                 if (token == XContentParser.Token.FIELD_NAME) {                     currentFieldName = parser.currentName().                     token = parser.nextToken().                     if (token.isValue()) {                         if (NAME.equals(currentFieldName)) {                             name = parser.text().                         } else if (UUID.equals(currentFieldName)) {                             uuid = parser.text().                         } else if (STATE.equals(currentFieldName)) {                             state = SnapshotState.valueOf(parser.text()).                         } else if (REASON.equals(currentFieldName)) {                             reason = parser.text().                         } else if (START_TIME.equals(currentFieldName)) {                             startTime = parser.longValue().                         } else if (END_TIME.equals(currentFieldName)) {                             endTime = parser.longValue().                         } else if (TOTAL_SHARDS.equals(currentFieldName)) {                             totalShards = parser.intValue().                         } else if (SUCCESSFUL_SHARDS.equals(currentFieldName)) {                             successfulShards = parser.intValue().                         } else if (VERSION_ID.equals(currentFieldName)) {                             version = Version.fromId(parser.intValue()).                         } else if (INCLUDE_GLOBAL_STATE.equals(currentFieldName)) {                             includeGlobalState = parser.booleanValue().                         }                     } else if (token == XContentParser.Token.START_ARRAY) {                         if (INDICES.equals(currentFieldName)) {                             ArrayList<String> indicesArray = new ArrayList<>().                             while (parser.nextToken() != XContentParser.Token.END_ARRAY) {                                 indicesArray.add(parser.text()).                             }                             indices = Collections.unmodifiableList(indicesArray).                         } else if (FAILURES.equals(currentFieldName)) {                             ArrayList<SnapshotShardFailure> shardFailureArrayList = new ArrayList<>().                             while (parser.nextToken() != XContentParser.Token.END_ARRAY) {                                 shardFailureArrayList.add(SnapshotShardFailure.fromXContent(parser)).                             }                             shardFailures = Collections.unmodifiableList(shardFailureArrayList).                         } else {                             // It was probably created by newer version - ignoring                             parser.skipChildren().                         }                     } else if (token == XContentParser.Token.START_OBJECT) {                         // It was probably created by newer version - ignoring                         parser.skipChildren().                     }                 }             }         }     } else {         throw new ElasticsearchParseException("unexpected token  [" + token + "]").     }     if (uuid == null) {         // the old format where there wasn't a UUID         uuid = name.     }     return new SnapshotInfo(new SnapshotId(name, uuid), indices, state, reason, version, startTime, endTime, totalShards, successfulShards, shardFailures, includeGlobalState). }
false;public;1;32;;@Override public void writeTo(final StreamOutput out) throws IOException {     snapshotId.writeTo(out).     out.writeVInt(indices.size()).     for (String index : indices) {         out.writeString(index).     }     if (state != null) {         out.writeBoolean(true).         out.writeByte(state.value()).     } else {         out.writeBoolean(false).     }     out.writeOptionalString(reason).     out.writeVLong(startTime).     out.writeVLong(endTime).     out.writeVInt(totalShards).     out.writeVInt(successfulShards).     out.writeVInt(shardFailures.size()).     for (SnapshotShardFailure failure : shardFailures) {         failure.writeTo(out).     }     if (version != null) {         out.writeBoolean(true).         Version.writeVersion(version, out).     } else {         out.writeBoolean(false).     }     if (out.getVersion().onOrAfter(INCLUDE_GLOBAL_STATE_INTRODUCED)) {         out.writeOptionalBoolean(includeGlobalState).     } }
false;private,static;2;11;;private static SnapshotState snapshotState(final String reason, final List<SnapshotShardFailure> shardFailures) {     if (reason == null) {         if (shardFailures.isEmpty()) {             return SnapshotState.SUCCESS.         } else {             return SnapshotState.PARTIAL.         }     } else {         return SnapshotState.FAILED.     } }
false;public;1;17;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     SnapshotInfo that = (SnapshotInfo) o.     return startTime == that.startTime && endTime == that.endTime && totalShards == that.totalShards && successfulShards == that.successfulShards && Objects.equals(snapshotId, that.snapshotId) && state == that.state && Objects.equals(reason, that.reason) && Objects.equals(indices, that.indices) && Objects.equals(includeGlobalState, that.includeGlobalState) && Objects.equals(version, that.version) && Objects.equals(shardFailures, that.shardFailures). }
false;public;0;6;;@Override public int hashCode() {     return Objects.hash(snapshotId, state, reason, indices, startTime, endTime, totalShards, successfulShards, includeGlobalState, version, shardFailures). }
