commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public boolean required() {     return required. }
false;public;1;9;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     Routing routing = (Routing) o.     return required == routing.required. }
false;public;0;4;;@Override public int hashCode() {     return getClass().hashCode() + (required ? 1 : 0). }
false;private;1;21;;private void initMappers(Map<String, Object> withoutType) {     if (withoutType.containsKey("_routing")) {         boolean required = false.         Map<String, Object> routingNode = (Map<String, Object>) withoutType.get("_routing").         for (Map.Entry<String, Object> entry : routingNode.entrySet()) {             String fieldName = entry.getKey().             Object fieldNode = entry.getValue().             if (fieldName.equals("required")) {                 try {                     required = nodeBooleanValue(fieldNode).                 } catch (IllegalArgumentException ex) {                     throw new IllegalArgumentException("Failed to create mapping for type [" + this.type() + "]. " + "Illegal value in field [_routing.required].", ex).                 }             }         }         this.routing = new Routing(required).     } else {         this.routing = Routing.EMPTY.     } }
false;;1;5;;void updateDefaultMapping(MappingMetaData defaultMapping) {     if (routing == Routing.EMPTY) {         routing = defaultMapping.routing().     } }
false;public;0;3;;public String type() {     return this.type. }
false;public;0;3;;public CompressedXContent source() {     return this.source. }
true;public;0;8;/**  * Converts the serialized compressed form of the mappings into a parsed map.  */ ;/**  * Converts the serialized compressed form of the mappings into a parsed map.  */ public Map<String, Object> sourceAsMap() throws ElasticsearchParseException {     Map<String, Object> mapping = XContentHelper.convertToMap(source.compressedReference(), true).v2().     if (mapping.size() == 1 && mapping.containsKey(type())) {         // the type name is the root value, reduce it         mapping = (Map<String, Object>) mapping.get(type()).     }     return mapping. }
true;public;0;3;/**  * Converts the serialized compressed form of the mappings into a parsed map.  */ ;/**  * Converts the serialized compressed form of the mappings into a parsed map.  */ public Map<String, Object> getSourceAsMap() throws ElasticsearchParseException {     return sourceAsMap(). }
false;public;0;3;;public Routing routing() {     return this.routing. }
false;public;1;17;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeString(type()).     source().writeTo(out).     // routing     out.writeBoolean(routing().required()).     if (out.getVersion().before(Version.V_6_0_0_alpha1)) {         // timestamp         // enabled         out.writeBoolean(false).         out.writeString(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.pattern()).         // 5.x default         out.writeOptionalString("now").         out.writeOptionalBoolean(null).     }     if (out.getVersion().before(Version.V_7_0_0)) {         // hasParentField         out.writeBoolean(false).     } }
false;public;1;13;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     MappingMetaData that = (MappingMetaData) o.     if (!routing.equals(that.routing))         return false.     if (!source.equals(that.source))         return false.     if (!type.equals(that.type))         return false.     return true. }
false;public;0;7;;@Override public int hashCode() {     int result = type.hashCode().     result = 31 * result + source.hashCode().     result = 31 * result + routing.hashCode().     return result. }
false;public,static;1;3;;public static Diff<MappingMetaData> readDiffFrom(StreamInput in) throws IOException {     return readDiffFrom(MappingMetaData::new, in). }
