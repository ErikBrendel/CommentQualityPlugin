commented;modifiers;parameterAmount;loc;comment;code
true;;2;1;/**  * Update the cluster state based on the current state and the given tasks. Return the *same instance* if no state  * should be changed.  */ ;/**  * Update the cluster state based on the current state and the given tasks. Return the *same instance* if no state  * should be changed.  */ ClusterTasksResult<T> execute(ClusterState currentState, List<T> tasks) throws Exception.
true;default;0;3;/**  * indicates whether this executor should only run if the current node is master  */ ;/**  * indicates whether this executor should only run if the current node is master  */ default boolean runOnlyOnMaster() {     return true. }
true;default;1;2;/**  * Callback invoked after new cluster state is published. Note that  * this method is not invoked if the cluster state was not updated.  *  * Note that this method will be executed using system context.  *  * @param clusterChangedEvent the change event for this cluster state change, containing  *                            both old and new states  */ ;/**  * Callback invoked after new cluster state is published. Note that  * this method is not invoked if the cluster state was not updated.  *  * Note that this method will be executed using system context.  *  * @param clusterChangedEvent the change event for this cluster state change, containing  *                            both old and new states  */ default void clusterStatePublished(ClusterChangedEvent clusterChangedEvent) { }
true;default;1;3;/**  * Builds a concise description of a list of tasks (to be used in logging etc.).  *  * Note that the tasks given are not necessarily the same as those that will be passed to {@link #execute(ClusterState, List)}.  * but are guaranteed to be a subset of them. This method can be called multiple times with different lists before execution.  * This allows groupd task description but the submitting source.  */ ;/**  * Builds a concise description of a list of tasks (to be used in logging etc.).  *  * Note that the tasks given are not necessarily the same as those that will be passed to {@link #execute(ClusterState, List)}.  * but are guaranteed to be a subset of them. This method can be called multiple times with different lists before execution.  * This allows groupd task description but the submitting source.  */ default String describeTasks(List<T> tasks) {     return String.join(", ", tasks.stream().map(t -> (CharSequence) t.toString()).filter(t -> t.length() > 0)::iterator). }
false;public,static;0;3;;public static <T> Builder<T> builder() {     return new Builder<>(). }
false;public;1;3;;public Builder<T> success(T task) {     return result(task, TaskResult.success()). }
false;public;1;6;;public Builder<T> successes(Iterable<T> tasks) {     for (T task : tasks) {         success(task).     }     return this. }
false;public;2;3;;public Builder<T> failure(T task, Exception e) {     return result(task, TaskResult.failure(e)). }
false;public;2;6;;public Builder<T> failures(Iterable<T> tasks, Exception e) {     for (T task : tasks) {         failure(task, e).     }     return this. }
false;private;2;5;;private Builder<T> result(T task, TaskResult executionResult) {     TaskResult existing = executionResults.put(task, executionResult).     assert existing == null : task + " already has result " + existing.     return this. }
false;public;1;3;;public ClusterTasksResult<T> build(ClusterState resultingState) {     return new ClusterTasksResult<>(resultingState, executionResults). }
false;;2;4;;ClusterTasksResult<T> build(ClusterTasksResult<T> result, ClusterState previousState) {     return new ClusterTasksResult<>(result.resultingState == null ? previousState : result.resultingState, executionResults). }
false;public,static;0;3;;public static TaskResult success() {     return SUCCESS. }
false;public,static;1;3;;public static TaskResult failure(Exception failure) {     return new TaskResult(failure). }
false;public;0;3;;public boolean isSuccess() {     return this == SUCCESS. }
false;public;0;4;;public Exception getFailure() {     assert !isSuccess().     return failure. }
