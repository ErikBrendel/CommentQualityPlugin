commented;modifiers;parameterAmount;loc;comment;code
false;static;2;3;;static DateHistogramValuesSourceBuilder parse(String name, XContentParser parser) throws IOException {     return PARSER.parse(parser, new DateHistogramValuesSourceBuilder(name), null). }
false;protected;1;10;;@Override protected void innerWriteTo(StreamOutput out) throws IOException {     out.writeLong(interval).     out.writeOptionalWriteable(dateHistogramInterval).     if (out.getVersion().before(Version.V_7_0_0)) {         out.writeOptionalTimeZone(DateUtils.zoneIdToDateTimeZone(timeZone)).     } else {         out.writeOptionalZoneId(timeZone).     } }
false;protected;2;11;;@Override protected void doXContentBody(XContentBuilder builder, Params params) throws IOException {     if (dateHistogramInterval == null) {         builder.field(Histogram.INTERVAL_FIELD.getPreferredName(), interval).     } else {         builder.field(Histogram.INTERVAL_FIELD.getPreferredName(), dateHistogramInterval.toString()).     }     if (timeZone != null) {         builder.field("time_zone", timeZone.toString()).     } }
false;protected;0;4;;@Override protected int innerHashCode() {     return Objects.hash(interval, dateHistogramInterval, timeZone). }
false;protected;1;6;;@Override protected boolean innerEquals(DateHistogramValuesSourceBuilder other) {     return Objects.equals(interval, other.interval) && Objects.equals(dateHistogramInterval, other.dateHistogramInterval) && Objects.equals(timeZone, other.timeZone). }
false;public;0;4;;@Override public String type() {     return TYPE. }
true;public;0;3;/**  * Returns the interval in milliseconds that is set on this source  */ ;/**  * Returns the interval in milliseconds that is set on this source  */ public long interval() {     return interval. }
true;public;1;7;/**  * Sets the interval on this source.  * If both {@link #interval()} and {@link #dateHistogramInterval()} are set,  * then the {@link #dateHistogramInterval()} wins.  */ ;/**  * Sets the interval on this source.  * If both {@link #interval()} and {@link #dateHistogramInterval()} are set,  * then the {@link #dateHistogramInterval()} wins.  */ public DateHistogramValuesSourceBuilder interval(long interval) {     if (interval < 1) {         throw new IllegalArgumentException("[interval] must be 1 or greater for [date_histogram] source").     }     this.interval = interval.     return this. }
true;public;0;3;/**  * Returns the date interval that is set on this source  */ ;/**  * Returns the date interval that is set on this source  */ public DateHistogramInterval dateHistogramInterval() {     return dateHistogramInterval. }
false;public;1;7;;public DateHistogramValuesSourceBuilder dateHistogramInterval(DateHistogramInterval dateHistogramInterval) {     if (dateHistogramInterval == null) {         throw new IllegalArgumentException("[dateHistogramInterval] must not be null").     }     this.dateHistogramInterval = dateHistogramInterval.     return this. }
true;public;1;7;/**  * Sets the time zone to use for this aggregation  */ ;/**  * Sets the time zone to use for this aggregation  */ public DateHistogramValuesSourceBuilder timeZone(ZoneId timeZone) {     if (timeZone == null) {         throw new IllegalArgumentException("[timeZone] must not be null: [" + name + "]").     }     this.timeZone = timeZone.     return this. }
true;public;0;3;/**  * Gets the time zone to use for this aggregation  */ ;/**  * Gets the time zone to use for this aggregation  */ public ZoneId timeZone() {     return timeZone. }
false;private;0;21;;private Rounding createRounding() {     Rounding.Builder tzRoundingBuilder.     if (dateHistogramInterval != null) {         Rounding.DateTimeUnit dateTimeUnit = DATE_FIELD_UNITS.get(dateHistogramInterval.toString()).         if (dateTimeUnit != null) {             tzRoundingBuilder = Rounding.builder(dateTimeUnit).         } else {             // the interval is a time value?             tzRoundingBuilder = Rounding.builder(TimeValue.parseTimeValue(dateHistogramInterval.toString(), null, getClass().getSimpleName() + ".interval")).         }     } else {         // the interval is an integer time value in millis?         tzRoundingBuilder = Rounding.builder(TimeValue.timeValueMillis(interval)).     }     if (timeZone() != null) {         tzRoundingBuilder.timeZone(timeZone()).     }     Rounding rounding = tzRoundingBuilder.build().     return rounding. }
false;protected;2;18;;@Override protected CompositeValuesSourceConfig innerBuild(SearchContext context, ValuesSourceConfig<?> config) throws IOException {     Rounding rounding = createRounding().     ValuesSource orig = config.toValuesSource(context.getQueryShardContext()).     if (orig == null) {         orig = ValuesSource.Numeric.EMPTY.     }     if (orig instanceof ValuesSource.Numeric) {         ValuesSource.Numeric numeric = (ValuesSource.Numeric) orig.         RoundingValuesSource vs = new RoundingValuesSource(numeric, rounding).         // is specified in the builder.         final DocValueFormat docValueFormat = format() == null ? DocValueFormat.RAW : config.format().         final MappedFieldType fieldType = config.fieldContext() != null ? config.fieldContext().fieldType() : null.         return new CompositeValuesSourceConfig(name, fieldType, vs, docValueFormat, order(), missingBucket()).     } else {         throw new IllegalArgumentException("invalid source, expected numeric, got " + orig.getClass().getSimpleName()).     } }
