commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;5;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     out.writeString(field).     out.writeNamedWriteable(sourceProvider). }
false;protected;2;10;;@Override protected void doXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject(NAME).     builder.field(field).     builder.startObject().     sourceProvider.toXContent(builder, params).     printBoostAndQueryName(builder).     builder.endObject().     builder.endObject(). }
false;public,static;1;49;;public static IntervalQueryBuilder fromXContent(XContentParser parser) throws IOException {     if (parser.nextToken() != XContentParser.Token.FIELD_NAME) {         throw new ParsingException(parser.getTokenLocation(), "Expected [FIELD_NAME] but got [" + parser.currentToken() + "]").     }     String field = parser.currentName().     if (parser.nextToken() != XContentParser.Token.START_OBJECT) {         throw new ParsingException(parser.getTokenLocation(), "Expected [START_OBJECT] but got [" + parser.currentToken() + "]").     }     String name = null.     float boost = 1.     IntervalsSourceProvider provider = null.     String providerName = null.     while (parser.nextToken() != XContentParser.Token.END_OBJECT) {         if (parser.currentToken() != XContentParser.Token.FIELD_NAME) {             throw new ParsingException(parser.getTokenLocation(), "Expected [FIELD_NAME] but got [" + parser.currentToken() + "]").         }         switch(parser.currentName()) {             case "_name":                 parser.nextToken().                 name = parser.text().                 break.             case "boost":                 parser.nextToken().                 boost = parser.floatValue().                 break.             default:                 if (providerName != null) {                     throw new ParsingException(parser.getTokenLocation(), "Only one interval rule can be specified, found [" + providerName + "] and [" + parser.currentName() + "]").                 }                 providerName = parser.currentName().                 provider = IntervalsSourceProvider.fromXContent(parser).         }     }     if (parser.nextToken() != XContentParser.Token.END_OBJECT) {         throw new ParsingException(parser.getTokenLocation(), "Expected [END_OBJECT] but got [" + parser.currentToken() + "]").     }     if (provider == null) {         throw new ParsingException(parser.getTokenLocation(), "Missing intervals from interval query definition").     }     IntervalQueryBuilder builder = new IntervalQueryBuilder(field, provider).     builder.queryName(name).     builder.boost(boost).     return builder. }
false;protected;1;13;;@Override protected Query doToQuery(QueryShardContext context) throws IOException {     MappedFieldType fieldType = context.fieldMapper(field).     if (fieldType == null) {         // Be lenient with unmapped fields so that cross-index search will work nicely         return new MatchNoDocsQuery().     }     if (fieldType.tokenized() == false || fieldType.indexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) < 0) {         throw new IllegalArgumentException("Cannot create IntervalQuery over field [" + field + "] with no indexed positions").     }     return new IntervalQuery(field, sourceProvider.getSource(context, fieldType)). }
false;protected;1;4;;@Override protected boolean doEquals(IntervalQueryBuilder other) {     return Objects.equals(field, other.field) && Objects.equals(sourceProvider, other.sourceProvider). }
false;protected;0;4;;@Override protected int doHashCode() {     return Objects.hash(field, sourceProvider). }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
