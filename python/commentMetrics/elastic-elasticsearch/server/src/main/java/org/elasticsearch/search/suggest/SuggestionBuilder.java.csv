commented;modifiers;parameterAmount;loc;comment;code
false;public,final;1;11;;@Override public final void writeTo(StreamOutput out) throws IOException {     out.writeString(field).     out.writeOptionalString(text).     out.writeOptionalString(prefix).     out.writeOptionalString(regex).     out.writeOptionalString(analyzer).     out.writeOptionalVInt(size).     out.writeOptionalVInt(shardSize).     doWriteTo(out). }
false;protected,abstract;1;1;;protected abstract void doWriteTo(StreamOutput out) throws IOException.
true;public;1;5;/**  * Same as in {@link SuggestBuilder#setGlobalText(String)}, but in the suggestion scope.  */ ;/**  * Same as in {@link SuggestBuilder#setGlobalText(String)}, but in the suggestion scope.  */ @SuppressWarnings("unchecked") public T text(String text) {     this.text = text.     return (T) this. }
true;public;0;3;/**  * get the text for this suggestion  */ ;/**  * get the text for this suggestion  */ public String text() {     return this.text. }
false;protected;1;5;;@SuppressWarnings("unchecked") protected T prefix(String prefix) {     this.prefix = prefix.     return (T) this. }
true;public;0;3;/**  * get the prefix for this suggestion  */ ;/**  * get the prefix for this suggestion  */ public String prefix() {     return this.prefix. }
false;protected;1;5;;@SuppressWarnings("unchecked") protected T regex(String regex) {     this.regex = regex.     return (T) this. }
true;public;0;3;/**  * get the regex for this suggestion  */ ;/**  * get the regex for this suggestion  */ public String regex() {     return this.regex. }
true;public;0;3;/**  * get the {@link #field()} parameter  */ ;/**  * get the {@link #field()} parameter  */ public String field() {     return this.field. }
true;public;1;5;/**  * Sets the analyzer to analyse to suggest text with. Defaults to the search  * analyzer of the suggest field.  */ ;/**  * Sets the analyzer to analyse to suggest text with. Defaults to the search  * analyzer of the suggest field.  */ @SuppressWarnings("unchecked") public T analyzer(String analyzer) {     this.analyzer = analyzer.     return (T) this. }
true;public;0;3;/**  * get the {@link #analyzer()} parameter  */ ;/**  * get the {@link #analyzer()} parameter  */ public String analyzer() {     return this.analyzer. }
true;public;1;8;/**  * Sets the maximum suggestions to be returned per suggest text term.  */ ;/**  * Sets the maximum suggestions to be returned per suggest text term.  */ @SuppressWarnings("unchecked") public T size(int size) {     if (size <= 0) {         throw new IllegalArgumentException("size must be positive").     }     this.size = size.     return (T) this. }
true;public;0;3;/**  * get the {@link #size()} parameter  */ ;/**  * get the {@link #size()} parameter  */ public Integer size() {     return this.size. }
true;public;1;5;/**  * Sets the maximum number of suggested term to be retrieved from each  * individual shard. During the reduce phase the only the top N suggestions  * are returned based on the <code>size</code> option. Defaults to the  * <code>size</code> option.  * <p>  * Setting this to a value higher than the `size` can be useful in order to  * get a more accurate document frequency for suggested terms. Due to the  * fact that terms are partitioned amongst shards, the shard level document  * frequencies of suggestions may not be precise. Increasing this will make  * these document frequencies more precise.  */ ;/**  * Sets the maximum number of suggested term to be retrieved from each  * individual shard. During the reduce phase the only the top N suggestions  * are returned based on the <code>size</code> option. Defaults to the  * <code>size</code> option.  * <p>  * Setting this to a value higher than the `size` can be useful in order to  * get a more accurate document frequency for suggested terms. Due to the  * fact that terms are partitioned amongst shards, the shard level document  * frequencies of suggestions may not be precise. Increasing this will make  * these document frequencies more precise.  */ @SuppressWarnings("unchecked") public T shardSize(Integer shardSize) {     this.shardSize = shardSize.     return (T) this. }
true;public;0;3;/**  * get the {@link #shardSize()} parameter  */ ;/**  * get the {@link #shardSize()} parameter  */ public Integer shardSize() {     return this.shardSize. }
false;public;2;27;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     if (text != null) {         builder.field(TEXT_FIELD.getPreferredName(), text).     }     if (prefix != null) {         builder.field(PREFIX_FIELD.getPreferredName(), prefix).     }     if (regex != null) {         builder.field(REGEX_FIELD.getPreferredName(), regex).     }     builder.startObject(getSuggesterName()).     if (analyzer != null) {         builder.field(ANALYZER_FIELD.getPreferredName(), analyzer).     }     builder.field(FIELDNAME_FIELD.getPreferredName(), field).     if (size != null) {         builder.field(SIZE_FIELD.getPreferredName(), size).     }     if (shardSize != null) {         builder.field(SHARDSIZE_FIELD.getPreferredName(), shardSize).     }     builder = innerToXContent(builder, params).     builder.endObject().     return builder. }
false;protected,abstract;2;1;;protected abstract XContentBuilder innerToXContent(XContentBuilder builder, Params params) throws IOException.
false;static;1;39;;static SuggestionBuilder<?> fromXContent(XContentParser parser) throws IOException {     XContentParser.Token token.     String currentFieldName = null.     String suggestText = null.     String prefix = null.     String regex = null.     SuggestionBuilder<?> suggestionBuilder = null.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token.isValue()) {             if (TEXT_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 suggestText = parser.text().             } else if (PREFIX_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 prefix = parser.text().             } else if (REGEX_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 regex = parser.text().             } else {                 throw new ParsingException(parser.getTokenLocation(), "suggestion does not support [" + currentFieldName + "]").             }         } else if (token == XContentParser.Token.START_OBJECT) {             suggestionBuilder = parser.namedObject(SuggestionBuilder.class, currentFieldName, null).         }     }     if (suggestionBuilder == null) {         throw new ElasticsearchParseException("missing suggestion object").     }     if (suggestText != null) {         suggestionBuilder.text(suggestText).     }     if (prefix != null) {         suggestionBuilder.prefix(prefix).     }     if (regex != null) {         suggestionBuilder.regex(regex).     }     return suggestionBuilder. }
false;protected,abstract;1;1;;protected abstract SuggestionContext build(QueryShardContext context) throws IOException.
true;protected;2;52;/**  * Transfers the text, prefix, regex, analyzer, field, size and shard size settings from the  * original {@link SuggestionBuilder} to the target {@link SuggestionContext}  */ ;/**  * Transfers the text, prefix, regex, analyzer, field, size and shard size settings from the  * original {@link SuggestionBuilder} to the target {@link SuggestionContext}  */ protected void populateCommonFields(MapperService mapperService, SuggestionSearchContext.SuggestionContext suggestionContext) {     Objects.requireNonNull(field, "field must not be null").     MappedFieldType fieldType = mapperService.fullName(field).     if (fieldType == null) {         throw new IllegalArgumentException("no mapping found for field [" + field + "]").     } else if (analyzer == null) {         // no analyzer name passed in, so try the field's analyzer, or the default analyzer         if (fieldType.searchAnalyzer() == null) {             suggestionContext.setAnalyzer(mapperService.searchAnalyzer()).         } else {             suggestionContext.setAnalyzer(fieldType.searchAnalyzer()).         }     } else {         Analyzer luceneAnalyzer = mapperService.getNamedAnalyzer(analyzer).         if (luceneAnalyzer == null) {             throw new IllegalArgumentException("analyzer [" + analyzer + "] doesn't exists").         }         suggestionContext.setAnalyzer(luceneAnalyzer).     }     suggestionContext.setField(fieldType.name()).     if (size != null) {         suggestionContext.setSize(size).     }     if (shardSize != null) {         suggestionContext.setShardSize(shardSize).     } else {         // if no shard size is set in builder, use size (or at least 5)         suggestionContext.setShardSize(Math.max(suggestionContext.getSize(), 5)).     }     if (text != null) {         suggestionContext.setText(BytesRefs.toBytesRef(text)).     }     if (prefix != null) {         suggestionContext.setPrefix(BytesRefs.toBytesRef(prefix)).     }     if (regex != null) {         suggestionContext.setRegex(BytesRefs.toBytesRef(regex)).     }     if (text != null && prefix == null) {         suggestionContext.setPrefix(BytesRefs.toBytesRef(text)).     } else if (text == null && prefix != null) {         suggestionContext.setText(BytesRefs.toBytesRef(prefix)).     } else if (text == null && regex != null) {         suggestionContext.setText(BytesRefs.toBytesRef(regex)).     } }
false;private;0;4;;private String getSuggesterName() {     // default impl returns the same as writeable name, but we keep the distinction between the two just to make sure     return getWriteableName(). }
false;public,final;1;19;;@Override public final boolean equals(Object obj) {     if (this == obj) {         return true.     }     if (obj == null || getClass() != obj.getClass()) {         return false.     }     @SuppressWarnings("unchecked")     T other = (T) obj.     return Objects.equals(text, other.text()) && Objects.equals(prefix, other.prefix()) && Objects.equals(regex, other.regex()) && Objects.equals(field, other.field()) && Objects.equals(analyzer, other.analyzer()) && Objects.equals(size, other.size()) && Objects.equals(shardSize, other.shardSize()) && doEquals(other). }
true;protected,abstract;1;1;/**  * Indicates whether some other {@link SuggestionBuilder} of the same type is "equal to" this one.  */ ;/**  * Indicates whether some other {@link SuggestionBuilder} of the same type is "equal to" this one.  */ protected abstract boolean doEquals(T other).
false;public,final;0;4;;@Override public final int hashCode() {     return Objects.hash(text, prefix, regex, field, analyzer, size, shardSize, doHashCode()). }
true;protected,abstract;0;1;/**  * HashCode for the subclass of {@link SuggestionBuilder} to implement.  */ ;/**  * HashCode for the subclass of {@link SuggestionBuilder} to implement.  */ protected abstract int doHashCode().
