# id;timestamp;commentText;codeText;commentWords;codeWords
RemoteClusterAware -> protected Map<String, List<String>> groupClusterIndices(Set<String> remoteClusterNames, String[] requestIndices,                                                             Predicate<String> indexExists);1543959410;Groups indices per cluster by splitting remote cluster-alias, index-name pairs on {@link #REMOTE_CLUSTER_INDEX_SEPARATOR}. All_indices per cluster are collected as a list in the returned map keyed by the cluster alias. Local indices are grouped under_{@link #LOCAL_CLUSTER_GROUP_KEY}. The returned map is mutable.__@param remoteClusterNames the remote cluster names_@param requestIndices the indices in the search request to filter_@param indexExists a predicate that can test if a certain index or alias exists in the local cluster__@return a map of grouped remote and local indices;protected Map<String, List<String>> groupClusterIndices(Set<String> remoteClusterNames, String[] requestIndices,_                                                            Predicate<String> indexExists) {_        Map<String, List<String>> perClusterIndices = new HashMap<>()__        for (String index : requestIndices) {_            int i = index.indexOf(RemoteClusterService.REMOTE_CLUSTER_INDEX_SEPARATOR)__            if (i >= 0) {_                String remoteClusterName = index.substring(0, i)__                List<String> clusters = clusterNameResolver.resolveClusterNames(remoteClusterNames, remoteClusterName)__                if (clusters.isEmpty() == false) {_                    if (indexExists.test(index)) {_                        _                        _                        _                        _                        throw new IllegalArgumentException("Can not filter indices_ index " + index +_                                " exists but there is also a remote cluster named: " + remoteClusterName)__                    }_                    String indexName = index.substring(i + 1)__                    for (String clusterName : clusters) {_                        perClusterIndices.computeIfAbsent(clusterName, k -> new ArrayList<>()).add(indexName)__                    }_                } else {_                    _                    _                    _                    perClusterIndices.computeIfAbsent(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY, k -> new ArrayList<>()).add(index)__                }_            } else {_                perClusterIndices.computeIfAbsent(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY, k -> new ArrayList<>()).add(index)__            }_        }_        return perClusterIndices__    };groups,indices,per,cluster,by,splitting,remote,cluster,alias,index,name,pairs,on,link,all,indices,per,cluster,are,collected,as,a,list,in,the,returned,map,keyed,by,the,cluster,alias,local,indices,are,grouped,under,link,the,returned,map,is,mutable,param,remote,cluster,names,the,remote,cluster,names,param,request,indices,the,indices,in,the,search,request,to,filter,param,index,exists,a,predicate,that,can,test,if,a,certain,index,or,alias,exists,in,the,local,cluster,return,a,map,of,grouped,remote,and,local,indices;protected,map,string,list,string,group,cluster,indices,set,string,remote,cluster,names,string,request,indices,predicate,string,index,exists,map,string,list,string,per,cluster,indices,new,hash,map,for,string,index,request,indices,int,i,index,index,of,remote,cluster,service,if,i,0,string,remote,cluster,name,index,substring,0,i,list,string,clusters,cluster,name,resolver,resolve,cluster,names,remote,cluster,names,remote,cluster,name,if,clusters,is,empty,false,if,index,exists,test,index,throw,new,illegal,argument,exception,can,not,filter,indices,index,index,exists,but,there,is,also,a,remote,cluster,named,remote,cluster,name,string,index,name,index,substring,i,1,for,string,cluster,name,clusters,per,cluster,indices,compute,if,absent,cluster,name,k,new,array,list,add,index,name,else,per,cluster,indices,compute,if,absent,remote,cluster,aware,k,new,array,list,add,index,else,per,cluster,indices,compute,if,absent,remote,cluster,aware,k,new,array,list,add,index,return,per,cluster,indices
RemoteClusterAware -> protected Map<String, List<String>> groupClusterIndices(Set<String> remoteClusterNames, String[] requestIndices,                                                             Predicate<String> indexExists);1545071071;Groups indices per cluster by splitting remote cluster-alias, index-name pairs on {@link #REMOTE_CLUSTER_INDEX_SEPARATOR}. All_indices per cluster are collected as a list in the returned map keyed by the cluster alias. Local indices are grouped under_{@link #LOCAL_CLUSTER_GROUP_KEY}. The returned map is mutable.__@param remoteClusterNames the remote cluster names_@param requestIndices the indices in the search request to filter_@param indexExists a predicate that can test if a certain index or alias exists in the local cluster__@return a map of grouped remote and local indices;protected Map<String, List<String>> groupClusterIndices(Set<String> remoteClusterNames, String[] requestIndices,_                                                            Predicate<String> indexExists) {_        Map<String, List<String>> perClusterIndices = new HashMap<>()__        for (String index : requestIndices) {_            int i = index.indexOf(RemoteClusterService.REMOTE_CLUSTER_INDEX_SEPARATOR)__            if (i >= 0) {_                String remoteClusterName = index.substring(0, i)__                List<String> clusters = clusterNameResolver.resolveClusterNames(remoteClusterNames, remoteClusterName)__                if (clusters.isEmpty() == false) {_                    if (indexExists.test(index)) {_                        _                        _                        _                        _                        throw new IllegalArgumentException("Can not filter indices_ index " + index +_                                " exists but there is also a remote cluster named: " + remoteClusterName)__                    }_                    String indexName = index.substring(i + 1)__                    for (String clusterName : clusters) {_                        perClusterIndices.computeIfAbsent(clusterName, k -> new ArrayList<>()).add(indexName)__                    }_                } else {_                    _                    _                    _                    perClusterIndices.computeIfAbsent(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY, k -> new ArrayList<>()).add(index)__                }_            } else {_                perClusterIndices.computeIfAbsent(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY, k -> new ArrayList<>()).add(index)__            }_        }_        return perClusterIndices__    };groups,indices,per,cluster,by,splitting,remote,cluster,alias,index,name,pairs,on,link,all,indices,per,cluster,are,collected,as,a,list,in,the,returned,map,keyed,by,the,cluster,alias,local,indices,are,grouped,under,link,the,returned,map,is,mutable,param,remote,cluster,names,the,remote,cluster,names,param,request,indices,the,indices,in,the,search,request,to,filter,param,index,exists,a,predicate,that,can,test,if,a,certain,index,or,alias,exists,in,the,local,cluster,return,a,map,of,grouped,remote,and,local,indices;protected,map,string,list,string,group,cluster,indices,set,string,remote,cluster,names,string,request,indices,predicate,string,index,exists,map,string,list,string,per,cluster,indices,new,hash,map,for,string,index,request,indices,int,i,index,index,of,remote,cluster,service,if,i,0,string,remote,cluster,name,index,substring,0,i,list,string,clusters,cluster,name,resolver,resolve,cluster,names,remote,cluster,names,remote,cluster,name,if,clusters,is,empty,false,if,index,exists,test,index,throw,new,illegal,argument,exception,can,not,filter,indices,index,index,exists,but,there,is,also,a,remote,cluster,named,remote,cluster,name,string,index,name,index,substring,i,1,for,string,cluster,name,clusters,per,cluster,indices,compute,if,absent,cluster,name,k,new,array,list,add,index,name,else,per,cluster,indices,compute,if,absent,remote,cluster,aware,k,new,array,list,add,index,else,per,cluster,indices,compute,if,absent,remote,cluster,aware,k,new,array,list,add,index,return,per,cluster,indices
RemoteClusterAware -> protected Map<String, List<String>> groupClusterIndices(Set<String> remoteClusterNames, String[] requestIndices,                                                             Predicate<String> indexExists);1546600771;Groups indices per cluster by splitting remote cluster-alias, index-name pairs on {@link #REMOTE_CLUSTER_INDEX_SEPARATOR}. All_indices per cluster are collected as a list in the returned map keyed by the cluster alias. Local indices are grouped under_{@link #LOCAL_CLUSTER_GROUP_KEY}. The returned map is mutable.__@param remoteClusterNames the remote cluster names_@param requestIndices the indices in the search request to filter_@param indexExists a predicate that can test if a certain index or alias exists in the local cluster__@return a map of grouped remote and local indices;protected Map<String, List<String>> groupClusterIndices(Set<String> remoteClusterNames, String[] requestIndices,_                                                            Predicate<String> indexExists) {_        Map<String, List<String>> perClusterIndices = new HashMap<>()__        for (String index : requestIndices) {_            int i = index.indexOf(RemoteClusterService.REMOTE_CLUSTER_INDEX_SEPARATOR)__            if (i >= 0) {_                String remoteClusterName = index.substring(0, i)__                List<String> clusters = clusterNameResolver.resolveClusterNames(remoteClusterNames, remoteClusterName)__                if (clusters.isEmpty() == false) {_                    if (indexExists.test(index)) {_                        _                        _                        _                        _                        throw new IllegalArgumentException("Can not filter indices_ index " + index +_                                " exists but there is also a remote cluster named: " + remoteClusterName)__                    }_                    String indexName = index.substring(i + 1)__                    for (String clusterName : clusters) {_                        perClusterIndices.computeIfAbsent(clusterName, k -> new ArrayList<>()).add(indexName)__                    }_                } else {_                    _                    _                    _                    perClusterIndices.computeIfAbsent(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY, k -> new ArrayList<>()).add(index)__                }_            } else {_                perClusterIndices.computeIfAbsent(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY, k -> new ArrayList<>()).add(index)__            }_        }_        return perClusterIndices__    };groups,indices,per,cluster,by,splitting,remote,cluster,alias,index,name,pairs,on,link,all,indices,per,cluster,are,collected,as,a,list,in,the,returned,map,keyed,by,the,cluster,alias,local,indices,are,grouped,under,link,the,returned,map,is,mutable,param,remote,cluster,names,the,remote,cluster,names,param,request,indices,the,indices,in,the,search,request,to,filter,param,index,exists,a,predicate,that,can,test,if,a,certain,index,or,alias,exists,in,the,local,cluster,return,a,map,of,grouped,remote,and,local,indices;protected,map,string,list,string,group,cluster,indices,set,string,remote,cluster,names,string,request,indices,predicate,string,index,exists,map,string,list,string,per,cluster,indices,new,hash,map,for,string,index,request,indices,int,i,index,index,of,remote,cluster,service,if,i,0,string,remote,cluster,name,index,substring,0,i,list,string,clusters,cluster,name,resolver,resolve,cluster,names,remote,cluster,names,remote,cluster,name,if,clusters,is,empty,false,if,index,exists,test,index,throw,new,illegal,argument,exception,can,not,filter,indices,index,index,exists,but,there,is,also,a,remote,cluster,named,remote,cluster,name,string,index,name,index,substring,i,1,for,string,cluster,name,clusters,per,cluster,indices,compute,if,absent,cluster,name,k,new,array,list,add,index,name,else,per,cluster,indices,compute,if,absent,remote,cluster,aware,k,new,array,list,add,index,else,per,cluster,indices,compute,if,absent,remote,cluster,aware,k,new,array,list,add,index,return,per,cluster,indices
RemoteClusterAware -> protected Map<String, List<String>> groupClusterIndices(Set<String> remoteClusterNames, String[] requestIndices,                                                             Predicate<String> indexExists);1546877578;Groups indices per cluster by splitting remote cluster-alias, index-name pairs on {@link #REMOTE_CLUSTER_INDEX_SEPARATOR}. All_indices per cluster are collected as a list in the returned map keyed by the cluster alias. Local indices are grouped under_{@link #LOCAL_CLUSTER_GROUP_KEY}. The returned map is mutable.__@param remoteClusterNames the remote cluster names_@param requestIndices the indices in the search request to filter_@param indexExists a predicate that can test if a certain index or alias exists in the local cluster__@return a map of grouped remote and local indices;protected Map<String, List<String>> groupClusterIndices(Set<String> remoteClusterNames, String[] requestIndices,_                                                            Predicate<String> indexExists) {_        Map<String, List<String>> perClusterIndices = new HashMap<>()__        for (String index : requestIndices) {_            int i = index.indexOf(RemoteClusterService.REMOTE_CLUSTER_INDEX_SEPARATOR)__            if (i >= 0) {_                String remoteClusterName = index.substring(0, i)__                List<String> clusters = clusterNameResolver.resolveClusterNames(remoteClusterNames, remoteClusterName)__                if (clusters.isEmpty() == false) {_                    if (indexExists.test(index)) {_                        _                        _                        _                        _                        throw new IllegalArgumentException("Can not filter indices_ index " + index +_                                " exists but there is also a remote cluster named: " + remoteClusterName)__                    }_                    String indexName = index.substring(i + 1)__                    for (String clusterName : clusters) {_                        perClusterIndices.computeIfAbsent(clusterName, k -> new ArrayList<>()).add(indexName)__                    }_                } else {_                    _                    _                    _                    perClusterIndices.computeIfAbsent(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY, k -> new ArrayList<>()).add(index)__                }_            } else {_                perClusterIndices.computeIfAbsent(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY, k -> new ArrayList<>()).add(index)__            }_        }_        return perClusterIndices__    };groups,indices,per,cluster,by,splitting,remote,cluster,alias,index,name,pairs,on,link,all,indices,per,cluster,are,collected,as,a,list,in,the,returned,map,keyed,by,the,cluster,alias,local,indices,are,grouped,under,link,the,returned,map,is,mutable,param,remote,cluster,names,the,remote,cluster,names,param,request,indices,the,indices,in,the,search,request,to,filter,param,index,exists,a,predicate,that,can,test,if,a,certain,index,or,alias,exists,in,the,local,cluster,return,a,map,of,grouped,remote,and,local,indices;protected,map,string,list,string,group,cluster,indices,set,string,remote,cluster,names,string,request,indices,predicate,string,index,exists,map,string,list,string,per,cluster,indices,new,hash,map,for,string,index,request,indices,int,i,index,index,of,remote,cluster,service,if,i,0,string,remote,cluster,name,index,substring,0,i,list,string,clusters,cluster,name,resolver,resolve,cluster,names,remote,cluster,names,remote,cluster,name,if,clusters,is,empty,false,if,index,exists,test,index,throw,new,illegal,argument,exception,can,not,filter,indices,index,index,exists,but,there,is,also,a,remote,cluster,named,remote,cluster,name,string,index,name,index,substring,i,1,for,string,cluster,name,clusters,per,cluster,indices,compute,if,absent,cluster,name,k,new,array,list,add,index,name,else,per,cluster,indices,compute,if,absent,remote,cluster,aware,k,new,array,list,add,index,else,per,cluster,indices,compute,if,absent,remote,cluster,aware,k,new,array,list,add,index,return,per,cluster,indices
RemoteClusterAware -> protected Map<String, List<String>> groupClusterIndices(Set<String> remoteClusterNames, String[] requestIndices,                                                             Predicate<String> indexExists);1549608646;Groups indices per cluster by splitting remote cluster-alias, index-name pairs on {@link #REMOTE_CLUSTER_INDEX_SEPARATOR}. All_indices per cluster are collected as a list in the returned map keyed by the cluster alias. Local indices are grouped under_{@link #LOCAL_CLUSTER_GROUP_KEY}. The returned map is mutable.__@param remoteClusterNames the remote cluster names_@param requestIndices the indices in the search request to filter_@param indexExists a predicate that can test if a certain index or alias exists in the local cluster__@return a map of grouped remote and local indices;protected Map<String, List<String>> groupClusterIndices(Set<String> remoteClusterNames, String[] requestIndices,_                                                            Predicate<String> indexExists) {_        Map<String, List<String>> perClusterIndices = new HashMap<>()__        for (String index : requestIndices) {_            int i = index.indexOf(RemoteClusterService.REMOTE_CLUSTER_INDEX_SEPARATOR)__            if (i >= 0) {_                String remoteClusterName = index.substring(0, i)__                List<String> clusters = clusterNameResolver.resolveClusterNames(remoteClusterNames, remoteClusterName)__                if (clusters.isEmpty() == false) {_                    if (indexExists.test(index)) {_                        _                        _                        _                        _                        throw new IllegalArgumentException("Can not filter indices_ index " + index +_                                " exists but there is also a remote cluster named: " + remoteClusterName)__                    }_                    String indexName = index.substring(i + 1)__                    for (String clusterName : clusters) {_                        perClusterIndices.computeIfAbsent(clusterName, k -> new ArrayList<>()).add(indexName)__                    }_                } else {_                    _                    _                    _                    perClusterIndices.computeIfAbsent(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY, k -> new ArrayList<>()).add(index)__                }_            } else {_                perClusterIndices.computeIfAbsent(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY, k -> new ArrayList<>()).add(index)__            }_        }_        return perClusterIndices__    };groups,indices,per,cluster,by,splitting,remote,cluster,alias,index,name,pairs,on,link,all,indices,per,cluster,are,collected,as,a,list,in,the,returned,map,keyed,by,the,cluster,alias,local,indices,are,grouped,under,link,the,returned,map,is,mutable,param,remote,cluster,names,the,remote,cluster,names,param,request,indices,the,indices,in,the,search,request,to,filter,param,index,exists,a,predicate,that,can,test,if,a,certain,index,or,alias,exists,in,the,local,cluster,return,a,map,of,grouped,remote,and,local,indices;protected,map,string,list,string,group,cluster,indices,set,string,remote,cluster,names,string,request,indices,predicate,string,index,exists,map,string,list,string,per,cluster,indices,new,hash,map,for,string,index,request,indices,int,i,index,index,of,remote,cluster,service,if,i,0,string,remote,cluster,name,index,substring,0,i,list,string,clusters,cluster,name,resolver,resolve,cluster,names,remote,cluster,names,remote,cluster,name,if,clusters,is,empty,false,if,index,exists,test,index,throw,new,illegal,argument,exception,can,not,filter,indices,index,index,exists,but,there,is,also,a,remote,cluster,named,remote,cluster,name,string,index,name,index,substring,i,1,for,string,cluster,name,clusters,per,cluster,indices,compute,if,absent,cluster,name,k,new,array,list,add,index,name,else,per,cluster,indices,compute,if,absent,remote,cluster,aware,k,new,array,list,add,index,else,per,cluster,indices,compute,if,absent,remote,cluster,aware,k,new,array,list,add,index,return,per,cluster,indices
RemoteClusterAware -> protected Map<String, List<String>> groupClusterIndices(Set<String> remoteClusterNames, String[] requestIndices,                                                             Predicate<String> indexExists);1550601141;Groups indices per cluster by splitting remote cluster-alias, index-name pairs on {@link #REMOTE_CLUSTER_INDEX_SEPARATOR}. All_indices per cluster are collected as a list in the returned map keyed by the cluster alias. Local indices are grouped under_{@link #LOCAL_CLUSTER_GROUP_KEY}. The returned map is mutable.__@param remoteClusterNames the remote cluster names_@param requestIndices the indices in the search request to filter_@param indexExists a predicate that can test if a certain index or alias exists in the local cluster__@return a map of grouped remote and local indices;protected Map<String, List<String>> groupClusterIndices(Set<String> remoteClusterNames, String[] requestIndices,_                                                            Predicate<String> indexExists) {_        Map<String, List<String>> perClusterIndices = new HashMap<>()__        for (String index : requestIndices) {_            int i = index.indexOf(RemoteClusterService.REMOTE_CLUSTER_INDEX_SEPARATOR)__            if (i >= 0) {_                String remoteClusterName = index.substring(0, i)__                List<String> clusters = clusterNameResolver.resolveClusterNames(remoteClusterNames, remoteClusterName)__                if (clusters.isEmpty() == false) {_                    if (indexExists.test(index)) {_                        _                        _                        _                        _                        throw new IllegalArgumentException("Can not filter indices_ index " + index +_                                " exists but there is also a remote cluster named: " + remoteClusterName)__                    }_                    String indexName = index.substring(i + 1)__                    for (String clusterName : clusters) {_                        perClusterIndices.computeIfAbsent(clusterName, k -> new ArrayList<>()).add(indexName)__                    }_                } else {_                    _                    _                    _                    perClusterIndices.computeIfAbsent(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY, k -> new ArrayList<>()).add(index)__                }_            } else {_                perClusterIndices.computeIfAbsent(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY, k -> new ArrayList<>()).add(index)__            }_        }_        return perClusterIndices__    };groups,indices,per,cluster,by,splitting,remote,cluster,alias,index,name,pairs,on,link,all,indices,per,cluster,are,collected,as,a,list,in,the,returned,map,keyed,by,the,cluster,alias,local,indices,are,grouped,under,link,the,returned,map,is,mutable,param,remote,cluster,names,the,remote,cluster,names,param,request,indices,the,indices,in,the,search,request,to,filter,param,index,exists,a,predicate,that,can,test,if,a,certain,index,or,alias,exists,in,the,local,cluster,return,a,map,of,grouped,remote,and,local,indices;protected,map,string,list,string,group,cluster,indices,set,string,remote,cluster,names,string,request,indices,predicate,string,index,exists,map,string,list,string,per,cluster,indices,new,hash,map,for,string,index,request,indices,int,i,index,index,of,remote,cluster,service,if,i,0,string,remote,cluster,name,index,substring,0,i,list,string,clusters,cluster,name,resolver,resolve,cluster,names,remote,cluster,names,remote,cluster,name,if,clusters,is,empty,false,if,index,exists,test,index,throw,new,illegal,argument,exception,can,not,filter,indices,index,index,exists,but,there,is,also,a,remote,cluster,named,remote,cluster,name,string,index,name,index,substring,i,1,for,string,cluster,name,clusters,per,cluster,indices,compute,if,absent,cluster,name,k,new,array,list,add,index,name,else,per,cluster,indices,compute,if,absent,remote,cluster,aware,k,new,array,list,add,index,else,per,cluster,indices,compute,if,absent,remote,cluster,aware,k,new,array,list,add,index,return,per,cluster,indices
RemoteClusterAware -> protected RemoteClusterAware(Settings settings);1524684173;Creates a new {@link RemoteClusterAware} instance_@param settings the nodes level settings;protected RemoteClusterAware(Settings settings) {_        super(settings)__        this.clusterNameResolver = new ClusterNameExpressionResolver(settings)__    };creates,a,new,link,remote,cluster,aware,instance,param,settings,the,nodes,level,settings;protected,remote,cluster,aware,settings,settings,super,settings,this,cluster,name,resolver,new,cluster,name,expression,resolver,settings
RemoteClusterAware -> protected RemoteClusterAware(Settings settings);1534755962;Creates a new {@link RemoteClusterAware} instance_@param settings the nodes level settings;protected RemoteClusterAware(Settings settings) {_        super(settings)__        this.clusterNameResolver = new ClusterNameExpressionResolver(settings)__    };creates,a,new,link,remote,cluster,aware,instance,param,settings,the,nodes,level,settings;protected,remote,cluster,aware,settings,settings,super,settings,this,cluster,name,resolver,new,cluster,name,expression,resolver,settings
RemoteClusterAware -> protected RemoteClusterAware(Settings settings);1535383145;Creates a new {@link RemoteClusterAware} instance_@param settings the nodes level settings;protected RemoteClusterAware(Settings settings) {_        super(settings)__        this.clusterNameResolver = new ClusterNameExpressionResolver(settings)__    };creates,a,new,link,remote,cluster,aware,instance,param,settings,the,nodes,level,settings;protected,remote,cluster,aware,settings,settings,super,settings,this,cluster,name,resolver,new,cluster,name,expression,resolver,settings
RemoteClusterAware -> protected RemoteClusterAware(Settings settings);1536218260;Creates a new {@link RemoteClusterAware} instance_@param settings the nodes level settings;protected RemoteClusterAware(Settings settings) {_        super(settings)__        this.clusterNameResolver = new ClusterNameExpressionResolver(settings)__    };creates,a,new,link,remote,cluster,aware,instance,param,settings,the,nodes,level,settings;protected,remote,cluster,aware,settings,settings,super,settings,this,cluster,name,resolver,new,cluster,name,expression,resolver,settings
RemoteClusterAware -> protected RemoteClusterAware(Settings settings);1536828374;Creates a new {@link RemoteClusterAware} instance_@param settings the nodes level settings;protected RemoteClusterAware(Settings settings) {_        super(settings)__        this.clusterNameResolver = new ClusterNameExpressionResolver(settings)__    };creates,a,new,link,remote,cluster,aware,instance,param,settings,the,nodes,level,settings;protected,remote,cluster,aware,settings,settings,super,settings,this,cluster,name,resolver,new,cluster,name,expression,resolver,settings
RemoteClusterAware -> protected RemoteClusterAware(Settings settings);1538067637;Creates a new {@link RemoteClusterAware} instance_@param settings the nodes level settings;protected RemoteClusterAware(Settings settings) {_        super(settings)__        this.clusterNameResolver = new ClusterNameExpressionResolver(settings)__    };creates,a,new,link,remote,cluster,aware,instance,param,settings,the,nodes,level,settings;protected,remote,cluster,aware,settings,settings,super,settings,this,cluster,name,resolver,new,cluster,name,expression,resolver,settings
RemoteClusterAware -> protected RemoteClusterAware(Settings settings);1539796943;Creates a new {@link RemoteClusterAware} instance_@param settings the nodes level settings;protected RemoteClusterAware(Settings settings) {_        super(settings)__        this.clusterNameResolver = new ClusterNameExpressionResolver(settings)__    };creates,a,new,link,remote,cluster,aware,instance,param,settings,the,nodes,level,settings;protected,remote,cluster,aware,settings,settings,super,settings,this,cluster,name,resolver,new,cluster,name,expression,resolver,settings
RemoteClusterAware -> protected RemoteClusterAware(Settings settings);1541008027;Creates a new {@link RemoteClusterAware} instance_@param settings the nodes level settings;protected RemoteClusterAware(Settings settings) {_        super(settings)__        this.settings = settings__        this.clusterNameResolver = new ClusterNameExpressionResolver(settings)__    };creates,a,new,link,remote,cluster,aware,instance,param,settings,the,nodes,level,settings;protected,remote,cluster,aware,settings,settings,super,settings,this,settings,settings,this,cluster,name,resolver,new,cluster,name,expression,resolver,settings
RemoteClusterAware -> protected RemoteClusterAware(Settings settings);1541092382;Creates a new {@link RemoteClusterAware} instance_@param settings the nodes level settings;protected RemoteClusterAware(Settings settings) {_        this.settings = settings__        this.clusterNameResolver = new ClusterNameExpressionResolver()__    };creates,a,new,link,remote,cluster,aware,instance,param,settings,the,nodes,level,settings;protected,remote,cluster,aware,settings,settings,this,settings,settings,this,cluster,name,resolver,new,cluster,name,expression,resolver
RemoteClusterAware -> protected RemoteClusterAware(Settings settings);1542402632;Creates a new {@link RemoteClusterAware} instance_@param settings the nodes level settings;protected RemoteClusterAware(Settings settings) {_        this.settings = settings__        this.clusterNameResolver = new ClusterNameExpressionResolver()__    };creates,a,new,link,remote,cluster,aware,instance,param,settings,the,nodes,level,settings;protected,remote,cluster,aware,settings,settings,this,settings,settings,this,cluster,name,resolver,new,cluster,name,expression,resolver
RemoteClusterAware -> protected RemoteClusterAware(Settings settings);1543959410;Creates a new {@link RemoteClusterAware} instance_@param settings the nodes level settings;protected RemoteClusterAware(Settings settings) {_        this.settings = settings__        this.clusterNameResolver = new ClusterNameExpressionResolver()__    };creates,a,new,link,remote,cluster,aware,instance,param,settings,the,nodes,level,settings;protected,remote,cluster,aware,settings,settings,this,settings,settings,this,cluster,name,resolver,new,cluster,name,expression,resolver
RemoteClusterAware -> protected RemoteClusterAware(Settings settings);1545071071;Creates a new {@link RemoteClusterAware} instance_@param settings the nodes level settings;protected RemoteClusterAware(Settings settings) {_        this.settings = settings__        this.clusterNameResolver = new ClusterNameExpressionResolver()__    };creates,a,new,link,remote,cluster,aware,instance,param,settings,the,nodes,level,settings;protected,remote,cluster,aware,settings,settings,this,settings,settings,this,cluster,name,resolver,new,cluster,name,expression,resolver
RemoteClusterAware -> protected RemoteClusterAware(Settings settings);1546600771;Creates a new {@link RemoteClusterAware} instance_@param settings the nodes level settings;protected RemoteClusterAware(Settings settings) {_        this.settings = settings__        this.clusterNameResolver = new ClusterNameExpressionResolver()__    };creates,a,new,link,remote,cluster,aware,instance,param,settings,the,nodes,level,settings;protected,remote,cluster,aware,settings,settings,this,settings,settings,this,cluster,name,resolver,new,cluster,name,expression,resolver
RemoteClusterAware -> protected RemoteClusterAware(Settings settings);1546877578;Creates a new {@link RemoteClusterAware} instance_@param settings the nodes level settings;protected RemoteClusterAware(Settings settings) {_        this.settings = settings__        this.clusterNameResolver = new ClusterNameExpressionResolver()__    };creates,a,new,link,remote,cluster,aware,instance,param,settings,the,nodes,level,settings;protected,remote,cluster,aware,settings,settings,this,settings,settings,this,cluster,name,resolver,new,cluster,name,expression,resolver
RemoteClusterAware -> protected RemoteClusterAware(Settings settings);1549608646;Creates a new {@link RemoteClusterAware} instance_@param settings the nodes level settings;protected RemoteClusterAware(Settings settings) {_        this.settings = settings__        this.clusterNameResolver = new ClusterNameExpressionResolver()__    };creates,a,new,link,remote,cluster,aware,instance,param,settings,the,nodes,level,settings;protected,remote,cluster,aware,settings,settings,this,settings,settings,this,cluster,name,resolver,new,cluster,name,expression,resolver
RemoteClusterAware -> protected RemoteClusterAware(Settings settings);1550601141;Creates a new {@link RemoteClusterAware} instance_@param settings the nodes level settings;protected RemoteClusterAware(Settings settings) {_        this.settings = settings__        this.clusterNameResolver = new ClusterNameExpressionResolver()__    };creates,a,new,link,remote,cluster,aware,instance,param,settings,the,nodes,level,settings;protected,remote,cluster,aware,settings,settings,this,settings,settings,this,cluster,name,resolver,new,cluster,name,expression,resolver
RemoteClusterAware -> protected static Map<String, Tuple<String, List<Tuple<String, Supplier<DiscoveryNode>>>>> buildRemoteClustersDynamicConfig(             final Settings settings);1545071071;Builds the dynamic per-cluster config from the given settings. This is a map keyed by the cluster alias that points to a tuple_(ProxyAddresss, [SeedNodeSuppliers]). If a cluster is configured with a proxy address all seed nodes will point to_{@link TransportAddress#META_ADDRESS} and their configured address will be used as the hostname for the generated discovery node.;protected static Map<String, Tuple<String, List<Tuple<String, Supplier<DiscoveryNode>>>>> buildRemoteClustersDynamicConfig(_            final Settings settings) {_        final Map<String, Tuple<String, List<Tuple<String, Supplier<DiscoveryNode>>>>> remoteSeeds =_                buildRemoteClustersDynamicConfig(settings, REMOTE_CLUSTERS_SEEDS)__        final Map<String, Tuple<String, List<Tuple<String, Supplier<DiscoveryNode>>>>> searchRemoteSeeds =_                buildRemoteClustersDynamicConfig(settings, SEARCH_REMOTE_CLUSTERS_SEEDS)__        _        final NavigableSet<String> intersection =_                new TreeSet<>(Arrays.asList(_                        searchRemoteSeeds.keySet().stream().filter(s -> remoteSeeds.keySet().contains(s)).sorted().toArray(String[]::new)))__        if (intersection.isEmpty() == false) {_            final String message = String.format(_                    Locale.ROOT,_                    "found duplicate remote cluster configurations for cluster alias%s [%s]",_                    intersection.size() == 1 ? "" : "es",_                    String.join(",", intersection))__            throw new IllegalArgumentException(message)__        }_        return Stream_                .concat(remoteSeeds.entrySet().stream(), searchRemoteSeeds.entrySet().stream())_                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue))__    };builds,the,dynamic,per,cluster,config,from,the,given,settings,this,is,a,map,keyed,by,the,cluster,alias,that,points,to,a,tuple,proxy,addresss,seed,node,suppliers,if,a,cluster,is,configured,with,a,proxy,address,all,seed,nodes,will,point,to,link,transport,address,and,their,configured,address,will,be,used,as,the,hostname,for,the,generated,discovery,node;protected,static,map,string,tuple,string,list,tuple,string,supplier,discovery,node,build,remote,clusters,dynamic,config,final,settings,settings,final,map,string,tuple,string,list,tuple,string,supplier,discovery,node,remote,seeds,build,remote,clusters,dynamic,config,settings,final,map,string,tuple,string,list,tuple,string,supplier,discovery,node,search,remote,seeds,build,remote,clusters,dynamic,config,settings,final,navigable,set,string,intersection,new,tree,set,arrays,as,list,search,remote,seeds,key,set,stream,filter,s,remote,seeds,key,set,contains,s,sorted,to,array,string,new,if,intersection,is,empty,false,final,string,message,string,format,locale,root,found,duplicate,remote,cluster,configurations,for,cluster,alias,s,s,intersection,size,1,es,string,join,intersection,throw,new,illegal,argument,exception,message,return,stream,concat,remote,seeds,entry,set,stream,search,remote,seeds,entry,set,stream,collect,collectors,to,map,map,entry,get,key,map,entry,get,value
RemoteClusterAware -> protected static Map<String, Tuple<String, List<Tuple<String, Supplier<DiscoveryNode>>>>> buildRemoteClustersDynamicConfig(             final Settings settings);1546600771;Builds the dynamic per-cluster config from the given settings. This is a map keyed by the cluster alias that points to a tuple_(ProxyAddresss, [SeedNodeSuppliers]). If a cluster is configured with a proxy address all seed nodes will point to_{@link TransportAddress#META_ADDRESS} and their configured address will be used as the hostname for the generated discovery node.;protected static Map<String, Tuple<String, List<Tuple<String, Supplier<DiscoveryNode>>>>> buildRemoteClustersDynamicConfig(_            final Settings settings) {_        final Map<String, Tuple<String, List<Tuple<String, Supplier<DiscoveryNode>>>>> remoteSeeds =_                buildRemoteClustersDynamicConfig(settings, REMOTE_CLUSTERS_SEEDS)__        final Map<String, Tuple<String, List<Tuple<String, Supplier<DiscoveryNode>>>>> searchRemoteSeeds =_                buildRemoteClustersDynamicConfig(settings, SEARCH_REMOTE_CLUSTERS_SEEDS)__        _        final NavigableSet<String> intersection =_                new TreeSet<>(Arrays.asList(_                        searchRemoteSeeds.keySet().stream().filter(s -> remoteSeeds.keySet().contains(s)).sorted().toArray(String[]::new)))__        if (intersection.isEmpty() == false) {_            final String message = String.format(_                    Locale.ROOT,_                    "found duplicate remote cluster configurations for cluster alias%s [%s]",_                    intersection.size() == 1 ? "" : "es",_                    String.join(",", intersection))__            throw new IllegalArgumentException(message)__        }_        return Stream_                .concat(remoteSeeds.entrySet().stream(), searchRemoteSeeds.entrySet().stream())_                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue))__    };builds,the,dynamic,per,cluster,config,from,the,given,settings,this,is,a,map,keyed,by,the,cluster,alias,that,points,to,a,tuple,proxy,addresss,seed,node,suppliers,if,a,cluster,is,configured,with,a,proxy,address,all,seed,nodes,will,point,to,link,transport,address,and,their,configured,address,will,be,used,as,the,hostname,for,the,generated,discovery,node;protected,static,map,string,tuple,string,list,tuple,string,supplier,discovery,node,build,remote,clusters,dynamic,config,final,settings,settings,final,map,string,tuple,string,list,tuple,string,supplier,discovery,node,remote,seeds,build,remote,clusters,dynamic,config,settings,final,map,string,tuple,string,list,tuple,string,supplier,discovery,node,search,remote,seeds,build,remote,clusters,dynamic,config,settings,final,navigable,set,string,intersection,new,tree,set,arrays,as,list,search,remote,seeds,key,set,stream,filter,s,remote,seeds,key,set,contains,s,sorted,to,array,string,new,if,intersection,is,empty,false,final,string,message,string,format,locale,root,found,duplicate,remote,cluster,configurations,for,cluster,alias,s,s,intersection,size,1,es,string,join,intersection,throw,new,illegal,argument,exception,message,return,stream,concat,remote,seeds,entry,set,stream,search,remote,seeds,entry,set,stream,collect,collectors,to,map,map,entry,get,key,map,entry,get,value
RemoteClusterAware -> protected static Map<String, Tuple<String, List<Tuple<String, Supplier<DiscoveryNode>>>>> buildRemoteClustersDynamicConfig(             final Settings settings);1546877578;Builds the dynamic per-cluster config from the given settings. This is a map keyed by the cluster alias that points to a tuple_(ProxyAddresss, [SeedNodeSuppliers]). If a cluster is configured with a proxy address all seed nodes will point to_{@link TransportAddress#META_ADDRESS} and their configured address will be used as the hostname for the generated discovery node.;protected static Map<String, Tuple<String, List<Tuple<String, Supplier<DiscoveryNode>>>>> buildRemoteClustersDynamicConfig(_            final Settings settings) {_        final Map<String, Tuple<String, List<Tuple<String, Supplier<DiscoveryNode>>>>> remoteSeeds =_                buildRemoteClustersDynamicConfig(settings, REMOTE_CLUSTERS_SEEDS)__        final Map<String, Tuple<String, List<Tuple<String, Supplier<DiscoveryNode>>>>> searchRemoteSeeds =_                buildRemoteClustersDynamicConfig(settings, SEARCH_REMOTE_CLUSTERS_SEEDS)__        _        final NavigableSet<String> intersection =_                new TreeSet<>(Arrays.asList(_                        searchRemoteSeeds.keySet().stream().filter(s -> remoteSeeds.keySet().contains(s)).sorted().toArray(String[]::new)))__        if (intersection.isEmpty() == false) {_            final String message = String.format(_                    Locale.ROOT,_                    "found duplicate remote cluster configurations for cluster alias%s [%s]",_                    intersection.size() == 1 ? "" : "es",_                    String.join(",", intersection))__            throw new IllegalArgumentException(message)__        }_        return Stream_                .concat(remoteSeeds.entrySet().stream(), searchRemoteSeeds.entrySet().stream())_                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue))__    };builds,the,dynamic,per,cluster,config,from,the,given,settings,this,is,a,map,keyed,by,the,cluster,alias,that,points,to,a,tuple,proxy,addresss,seed,node,suppliers,if,a,cluster,is,configured,with,a,proxy,address,all,seed,nodes,will,point,to,link,transport,address,and,their,configured,address,will,be,used,as,the,hostname,for,the,generated,discovery,node;protected,static,map,string,tuple,string,list,tuple,string,supplier,discovery,node,build,remote,clusters,dynamic,config,final,settings,settings,final,map,string,tuple,string,list,tuple,string,supplier,discovery,node,remote,seeds,build,remote,clusters,dynamic,config,settings,final,map,string,tuple,string,list,tuple,string,supplier,discovery,node,search,remote,seeds,build,remote,clusters,dynamic,config,settings,final,navigable,set,string,intersection,new,tree,set,arrays,as,list,search,remote,seeds,key,set,stream,filter,s,remote,seeds,key,set,contains,s,sorted,to,array,string,new,if,intersection,is,empty,false,final,string,message,string,format,locale,root,found,duplicate,remote,cluster,configurations,for,cluster,alias,s,s,intersection,size,1,es,string,join,intersection,throw,new,illegal,argument,exception,message,return,stream,concat,remote,seeds,entry,set,stream,search,remote,seeds,entry,set,stream,collect,collectors,to,map,map,entry,get,key,map,entry,get,value
RemoteClusterAware -> protected static Map<String, Tuple<String, List<Tuple<String, Supplier<DiscoveryNode>>>>> buildRemoteClustersDynamicConfig(             final Settings settings);1549608646;Builds the dynamic per-cluster config from the given settings. This is a map keyed by the cluster alias that points to a tuple_(ProxyAddresss, [SeedNodeSuppliers]). If a cluster is configured with a proxy address all seed nodes will point to_{@link TransportAddress#META_ADDRESS} and their configured address will be used as the hostname for the generated discovery node.;protected static Map<String, Tuple<String, List<Tuple<String, Supplier<DiscoveryNode>>>>> buildRemoteClustersDynamicConfig(_            final Settings settings) {_        final Map<String, Tuple<String, List<Tuple<String, Supplier<DiscoveryNode>>>>> remoteSeeds =_                buildRemoteClustersDynamicConfig(settings, REMOTE_CLUSTERS_SEEDS)__        final Map<String, Tuple<String, List<Tuple<String, Supplier<DiscoveryNode>>>>> searchRemoteSeeds =_                buildRemoteClustersDynamicConfig(settings, SEARCH_REMOTE_CLUSTERS_SEEDS)__        _        final NavigableSet<String> intersection =_                new TreeSet<>(Arrays.asList(_                        searchRemoteSeeds.keySet().stream().filter(s -> remoteSeeds.keySet().contains(s)).sorted().toArray(String[]::new)))__        if (intersection.isEmpty() == false) {_            final String message = String.format(_                    Locale.ROOT,_                    "found duplicate remote cluster configurations for cluster alias%s [%s]",_                    intersection.size() == 1 ? "" : "es",_                    String.join(",", intersection))__            throw new IllegalArgumentException(message)__        }_        return Stream_                .concat(remoteSeeds.entrySet().stream(), searchRemoteSeeds.entrySet().stream())_                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue))__    };builds,the,dynamic,per,cluster,config,from,the,given,settings,this,is,a,map,keyed,by,the,cluster,alias,that,points,to,a,tuple,proxy,addresss,seed,node,suppliers,if,a,cluster,is,configured,with,a,proxy,address,all,seed,nodes,will,point,to,link,transport,address,and,their,configured,address,will,be,used,as,the,hostname,for,the,generated,discovery,node;protected,static,map,string,tuple,string,list,tuple,string,supplier,discovery,node,build,remote,clusters,dynamic,config,final,settings,settings,final,map,string,tuple,string,list,tuple,string,supplier,discovery,node,remote,seeds,build,remote,clusters,dynamic,config,settings,final,map,string,tuple,string,list,tuple,string,supplier,discovery,node,search,remote,seeds,build,remote,clusters,dynamic,config,settings,final,navigable,set,string,intersection,new,tree,set,arrays,as,list,search,remote,seeds,key,set,stream,filter,s,remote,seeds,key,set,contains,s,sorted,to,array,string,new,if,intersection,is,empty,false,final,string,message,string,format,locale,root,found,duplicate,remote,cluster,configurations,for,cluster,alias,s,s,intersection,size,1,es,string,join,intersection,throw,new,illegal,argument,exception,message,return,stream,concat,remote,seeds,entry,set,stream,search,remote,seeds,entry,set,stream,collect,collectors,to,map,map,entry,get,key,map,entry,get,value
RemoteClusterAware -> protected static Map<String, Tuple<String, List<Tuple<String, Supplier<DiscoveryNode>>>>> buildRemoteClustersDynamicConfig(             final Settings settings);1550601141;Builds the dynamic per-cluster config from the given settings. This is a map keyed by the cluster alias that points to a tuple_(ProxyAddresss, [SeedNodeSuppliers]). If a cluster is configured with a proxy address all seed nodes will point to_{@link TransportAddress#META_ADDRESS} and their configured address will be used as the hostname for the generated discovery node.;protected static Map<String, Tuple<String, List<Tuple<String, Supplier<DiscoveryNode>>>>> buildRemoteClustersDynamicConfig(_            final Settings settings) {_        final Map<String, Tuple<String, List<Tuple<String, Supplier<DiscoveryNode>>>>> remoteSeeds =_                buildRemoteClustersDynamicConfig(settings, REMOTE_CLUSTERS_SEEDS)__        final Map<String, Tuple<String, List<Tuple<String, Supplier<DiscoveryNode>>>>> searchRemoteSeeds =_                buildRemoteClustersDynamicConfig(settings, SEARCH_REMOTE_CLUSTERS_SEEDS)__        _        final NavigableSet<String> intersection =_                new TreeSet<>(Arrays.asList(_                        searchRemoteSeeds.keySet().stream().filter(s -> remoteSeeds.keySet().contains(s)).sorted().toArray(String[]::new)))__        if (intersection.isEmpty() == false) {_            final String message = String.format(_                    Locale.ROOT,_                    "found duplicate remote cluster configurations for cluster alias%s [%s]",_                    intersection.size() == 1 ? "" : "es",_                    String.join(",", intersection))__            throw new IllegalArgumentException(message)__        }_        return Stream_                .concat(remoteSeeds.entrySet().stream(), searchRemoteSeeds.entrySet().stream())_                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue))__    };builds,the,dynamic,per,cluster,config,from,the,given,settings,this,is,a,map,keyed,by,the,cluster,alias,that,points,to,a,tuple,proxy,addresss,seed,node,suppliers,if,a,cluster,is,configured,with,a,proxy,address,all,seed,nodes,will,point,to,link,transport,address,and,their,configured,address,will,be,used,as,the,hostname,for,the,generated,discovery,node;protected,static,map,string,tuple,string,list,tuple,string,supplier,discovery,node,build,remote,clusters,dynamic,config,final,settings,settings,final,map,string,tuple,string,list,tuple,string,supplier,discovery,node,remote,seeds,build,remote,clusters,dynamic,config,settings,final,map,string,tuple,string,list,tuple,string,supplier,discovery,node,search,remote,seeds,build,remote,clusters,dynamic,config,settings,final,navigable,set,string,intersection,new,tree,set,arrays,as,list,search,remote,seeds,key,set,stream,filter,s,remote,seeds,key,set,contains,s,sorted,to,array,string,new,if,intersection,is,empty,false,final,string,message,string,format,locale,root,found,duplicate,remote,cluster,configurations,for,cluster,alias,s,s,intersection,size,1,es,string,join,intersection,throw,new,illegal,argument,exception,message,return,stream,concat,remote,seeds,entry,set,stream,search,remote,seeds,entry,set,stream,collect,collectors,to,map,map,entry,get,key,map,entry,get,value
RemoteClusterAware -> public void listenForUpdates(ClusterSettings clusterSettings);1524684173;Registers this instance to listen to updates on the cluster settings.;public void listenForUpdates(ClusterSettings clusterSettings) {_        clusterSettings.addAffixUpdateConsumer(RemoteClusterAware.REMOTE_CLUSTERS_SEEDS, this::updateRemoteCluster,_            (namespace, value) -> {})__    };registers,this,instance,to,listen,to,updates,on,the,cluster,settings;public,void,listen,for,updates,cluster,settings,cluster,settings,cluster,settings,add,affix,update,consumer,remote,cluster,aware,this,update,remote,cluster,namespace,value
RemoteClusterAware -> public void listenForUpdates(ClusterSettings clusterSettings);1534755962;Registers this instance to listen to updates on the cluster settings.;public void listenForUpdates(ClusterSettings clusterSettings) {_        clusterSettings.addAffixUpdateConsumer(RemoteClusterAware.REMOTE_CLUSTERS_SEEDS, this::updateRemoteCluster,_            (namespace, value) -> {})__    };registers,this,instance,to,listen,to,updates,on,the,cluster,settings;public,void,listen,for,updates,cluster,settings,cluster,settings,cluster,settings,add,affix,update,consumer,remote,cluster,aware,this,update,remote,cluster,namespace,value
RemoteClusterAware -> public void listenForUpdates(ClusterSettings clusterSettings);1535383145;Registers this instance to listen to updates on the cluster settings.;public void listenForUpdates(ClusterSettings clusterSettings) {_        clusterSettings.addAffixUpdateConsumer(RemoteClusterAware.REMOTE_CLUSTERS_PROXY,_            RemoteClusterAware.REMOTE_CLUSTERS_SEEDS,_            (key, value) -> updateRemoteCluster(key, value.v2(), value.v1()),_            (namespace, value) -> {})__    };registers,this,instance,to,listen,to,updates,on,the,cluster,settings;public,void,listen,for,updates,cluster,settings,cluster,settings,cluster,settings,add,affix,update,consumer,remote,cluster,aware,remote,cluster,aware,key,value,update,remote,cluster,key,value,v2,value,v1,namespace,value
RemoteClusterAware -> public void listenForUpdates(ClusterSettings clusterSettings);1536218260;Registers this instance to listen to updates on the cluster settings.;public void listenForUpdates(ClusterSettings clusterSettings) {_        clusterSettings.addAffixUpdateConsumer(_                RemoteClusterAware.REMOTE_CLUSTERS_PROXY,_                RemoteClusterAware.REMOTE_CLUSTERS_SEEDS,_                (key, value) -> updateRemoteCluster(key, value.v2(), value.v1()),_                (namespace, value) -> {})__        clusterSettings.addAffixUpdateConsumer(_                RemoteClusterAware.SEARCH_REMOTE_CLUSTERS_PROXY,_                RemoteClusterAware.SEARCH_REMOTE_CLUSTERS_SEEDS,_                (key, value) -> updateRemoteCluster(key, value.v2(), value.v1()),_                (namespace, value) -> {})__    };registers,this,instance,to,listen,to,updates,on,the,cluster,settings;public,void,listen,for,updates,cluster,settings,cluster,settings,cluster,settings,add,affix,update,consumer,remote,cluster,aware,remote,cluster,aware,key,value,update,remote,cluster,key,value,v2,value,v1,namespace,value,cluster,settings,add,affix,update,consumer,remote,cluster,aware,remote,cluster,aware,key,value,update,remote,cluster,key,value,v2,value,v1,namespace,value
RemoteClusterAware -> public void listenForUpdates(ClusterSettings clusterSettings);1536828374;Registers this instance to listen to updates on the cluster settings.;public void listenForUpdates(ClusterSettings clusterSettings) {_        clusterSettings.addAffixUpdateConsumer(_                RemoteClusterAware.REMOTE_CLUSTERS_PROXY,_                RemoteClusterAware.REMOTE_CLUSTERS_SEEDS,_                (key, value) -> updateRemoteCluster(key, value.v2(), value.v1()),_                (namespace, value) -> {})__        clusterSettings.addAffixUpdateConsumer(_                RemoteClusterAware.SEARCH_REMOTE_CLUSTERS_PROXY,_                RemoteClusterAware.SEARCH_REMOTE_CLUSTERS_SEEDS,_                (key, value) -> updateRemoteCluster(key, value.v2(), value.v1()),_                (namespace, value) -> {})__    };registers,this,instance,to,listen,to,updates,on,the,cluster,settings;public,void,listen,for,updates,cluster,settings,cluster,settings,cluster,settings,add,affix,update,consumer,remote,cluster,aware,remote,cluster,aware,key,value,update,remote,cluster,key,value,v2,value,v1,namespace,value,cluster,settings,add,affix,update,consumer,remote,cluster,aware,remote,cluster,aware,key,value,update,remote,cluster,key,value,v2,value,v1,namespace,value
RemoteClusterAware -> public void listenForUpdates(ClusterSettings clusterSettings);1538067637;Registers this instance to listen to updates on the cluster settings.;public void listenForUpdates(ClusterSettings clusterSettings) {_        clusterSettings.addAffixUpdateConsumer(_                RemoteClusterAware.REMOTE_CLUSTERS_PROXY,_                RemoteClusterAware.REMOTE_CLUSTERS_SEEDS,_                (key, value) -> updateRemoteCluster(key, value.v2(), value.v1()),_                (namespace, value) -> {})__        clusterSettings.addAffixUpdateConsumer(_                RemoteClusterAware.SEARCH_REMOTE_CLUSTERS_PROXY,_                RemoteClusterAware.SEARCH_REMOTE_CLUSTERS_SEEDS,_                (key, value) -> updateRemoteCluster(key, value.v2(), value.v1()),_                (namespace, value) -> {})__    };registers,this,instance,to,listen,to,updates,on,the,cluster,settings;public,void,listen,for,updates,cluster,settings,cluster,settings,cluster,settings,add,affix,update,consumer,remote,cluster,aware,remote,cluster,aware,key,value,update,remote,cluster,key,value,v2,value,v1,namespace,value,cluster,settings,add,affix,update,consumer,remote,cluster,aware,remote,cluster,aware,key,value,update,remote,cluster,key,value,v2,value,v1,namespace,value
RemoteClusterAware -> public void listenForUpdates(ClusterSettings clusterSettings);1539796943;Registers this instance to listen to updates on the cluster settings.;public void listenForUpdates(ClusterSettings clusterSettings) {_        clusterSettings.addAffixUpdateConsumer(_                RemoteClusterAware.REMOTE_CLUSTERS_PROXY,_                RemoteClusterAware.REMOTE_CLUSTERS_SEEDS,_                (key, value) -> updateRemoteCluster(key, value.v2(), value.v1()),_                (namespace, value) -> {})__        clusterSettings.addAffixUpdateConsumer(_                RemoteClusterAware.SEARCH_REMOTE_CLUSTERS_PROXY,_                RemoteClusterAware.SEARCH_REMOTE_CLUSTERS_SEEDS,_                (key, value) -> updateRemoteCluster(key, value.v2(), value.v1()),_                (namespace, value) -> {})__    };registers,this,instance,to,listen,to,updates,on,the,cluster,settings;public,void,listen,for,updates,cluster,settings,cluster,settings,cluster,settings,add,affix,update,consumer,remote,cluster,aware,remote,cluster,aware,key,value,update,remote,cluster,key,value,v2,value,v1,namespace,value,cluster,settings,add,affix,update,consumer,remote,cluster,aware,remote,cluster,aware,key,value,update,remote,cluster,key,value,v2,value,v1,namespace,value
RemoteClusterAware -> public void listenForUpdates(ClusterSettings clusterSettings);1541008027;Registers this instance to listen to updates on the cluster settings.;public void listenForUpdates(ClusterSettings clusterSettings) {_        clusterSettings.addAffixUpdateConsumer(_                RemoteClusterAware.REMOTE_CLUSTERS_PROXY,_                RemoteClusterAware.REMOTE_CLUSTERS_SEEDS,_                (key, value) -> updateRemoteCluster(key, value.v2(), value.v1()),_                (namespace, value) -> {})__        clusterSettings.addAffixUpdateConsumer(_                RemoteClusterAware.SEARCH_REMOTE_CLUSTERS_PROXY,_                RemoteClusterAware.SEARCH_REMOTE_CLUSTERS_SEEDS,_                (key, value) -> updateRemoteCluster(key, value.v2(), value.v1()),_                (namespace, value) -> {})__    };registers,this,instance,to,listen,to,updates,on,the,cluster,settings;public,void,listen,for,updates,cluster,settings,cluster,settings,cluster,settings,add,affix,update,consumer,remote,cluster,aware,remote,cluster,aware,key,value,update,remote,cluster,key,value,v2,value,v1,namespace,value,cluster,settings,add,affix,update,consumer,remote,cluster,aware,remote,cluster,aware,key,value,update,remote,cluster,key,value,v2,value,v1,namespace,value
RemoteClusterAware -> public void listenForUpdates(ClusterSettings clusterSettings);1541092382;Registers this instance to listen to updates on the cluster settings.;public void listenForUpdates(ClusterSettings clusterSettings) {_        clusterSettings.addAffixUpdateConsumer(_                RemoteClusterAware.REMOTE_CLUSTERS_PROXY,_                RemoteClusterAware.REMOTE_CLUSTERS_SEEDS,_                (key, value) -> updateRemoteCluster(key, value.v2(), value.v1()),_                (namespace, value) -> {})__        clusterSettings.addAffixUpdateConsumer(_                RemoteClusterAware.SEARCH_REMOTE_CLUSTERS_PROXY,_                RemoteClusterAware.SEARCH_REMOTE_CLUSTERS_SEEDS,_                (key, value) -> updateRemoteCluster(key, value.v2(), value.v1()),_                (namespace, value) -> {})__    };registers,this,instance,to,listen,to,updates,on,the,cluster,settings;public,void,listen,for,updates,cluster,settings,cluster,settings,cluster,settings,add,affix,update,consumer,remote,cluster,aware,remote,cluster,aware,key,value,update,remote,cluster,key,value,v2,value,v1,namespace,value,cluster,settings,add,affix,update,consumer,remote,cluster,aware,remote,cluster,aware,key,value,update,remote,cluster,key,value,v2,value,v1,namespace,value
RemoteClusterAware -> public void listenForUpdates(ClusterSettings clusterSettings);1542402632;Registers this instance to listen to updates on the cluster settings.;public void listenForUpdates(ClusterSettings clusterSettings) {_        clusterSettings.addAffixUpdateConsumer(_                RemoteClusterAware.REMOTE_CLUSTERS_PROXY,_                RemoteClusterAware.REMOTE_CLUSTERS_SEEDS,_                (key, value) -> updateRemoteCluster(key, value.v2(), value.v1()),_                (namespace, value) -> {})__        clusterSettings.addAffixUpdateConsumer(_                RemoteClusterAware.SEARCH_REMOTE_CLUSTERS_PROXY,_                RemoteClusterAware.SEARCH_REMOTE_CLUSTERS_SEEDS,_                (key, value) -> updateRemoteCluster(key, value.v2(), value.v1()),_                (namespace, value) -> {})__    };registers,this,instance,to,listen,to,updates,on,the,cluster,settings;public,void,listen,for,updates,cluster,settings,cluster,settings,cluster,settings,add,affix,update,consumer,remote,cluster,aware,remote,cluster,aware,key,value,update,remote,cluster,key,value,v2,value,v1,namespace,value,cluster,settings,add,affix,update,consumer,remote,cluster,aware,remote,cluster,aware,key,value,update,remote,cluster,key,value,v2,value,v1,namespace,value
RemoteClusterAware -> public void listenForUpdates(ClusterSettings clusterSettings);1543959410;Registers this instance to listen to updates on the cluster settings.;public void listenForUpdates(ClusterSettings clusterSettings) {_        clusterSettings.addAffixUpdateConsumer(_                RemoteClusterAware.REMOTE_CLUSTERS_PROXY,_                RemoteClusterAware.REMOTE_CLUSTERS_SEEDS,_                (key, value) -> updateRemoteCluster(key, value.v2(), value.v1()),_                (namespace, value) -> {})__        clusterSettings.addAffixUpdateConsumer(_                RemoteClusterAware.SEARCH_REMOTE_CLUSTERS_PROXY,_                RemoteClusterAware.SEARCH_REMOTE_CLUSTERS_SEEDS,_                (key, value) -> updateRemoteCluster(key, value.v2(), value.v1()),_                (namespace, value) -> {})__    };registers,this,instance,to,listen,to,updates,on,the,cluster,settings;public,void,listen,for,updates,cluster,settings,cluster,settings,cluster,settings,add,affix,update,consumer,remote,cluster,aware,remote,cluster,aware,key,value,update,remote,cluster,key,value,v2,value,v1,namespace,value,cluster,settings,add,affix,update,consumer,remote,cluster,aware,remote,cluster,aware,key,value,update,remote,cluster,key,value,v2,value,v1,namespace,value
RemoteClusterAware -> public void listenForUpdates(ClusterSettings clusterSettings);1545071071;Registers this instance to listen to updates on the cluster settings.;public void listenForUpdates(ClusterSettings clusterSettings) {_        clusterSettings.addAffixUpdateConsumer(_                RemoteClusterAware.REMOTE_CLUSTERS_PROXY,_                RemoteClusterAware.REMOTE_CLUSTERS_SEEDS,_                (key, value) -> updateRemoteCluster(key, value.v2(), value.v1()),_                (namespace, value) -> {})__        clusterSettings.addAffixUpdateConsumer(_                RemoteClusterAware.SEARCH_REMOTE_CLUSTERS_PROXY,_                RemoteClusterAware.SEARCH_REMOTE_CLUSTERS_SEEDS,_                (key, value) -> updateRemoteCluster(key, value.v2(), value.v1()),_                (namespace, value) -> {})__    };registers,this,instance,to,listen,to,updates,on,the,cluster,settings;public,void,listen,for,updates,cluster,settings,cluster,settings,cluster,settings,add,affix,update,consumer,remote,cluster,aware,remote,cluster,aware,key,value,update,remote,cluster,key,value,v2,value,v1,namespace,value,cluster,settings,add,affix,update,consumer,remote,cluster,aware,remote,cluster,aware,key,value,update,remote,cluster,key,value,v2,value,v1,namespace,value
RemoteClusterAware -> public void listenForUpdates(ClusterSettings clusterSettings);1546600771;Registers this instance to listen to updates on the cluster settings.;public void listenForUpdates(ClusterSettings clusterSettings) {_        clusterSettings.addAffixUpdateConsumer(_                RemoteClusterAware.REMOTE_CLUSTERS_PROXY,_                RemoteClusterAware.REMOTE_CLUSTERS_SEEDS,_                (key, value) -> updateRemoteCluster(key, value.v2(), value.v1()),_                (namespace, value) -> {})__        clusterSettings.addAffixUpdateConsumer(_                RemoteClusterAware.SEARCH_REMOTE_CLUSTERS_PROXY,_                RemoteClusterAware.SEARCH_REMOTE_CLUSTERS_SEEDS,_                (key, value) -> updateRemoteCluster(key, value.v2(), value.v1()),_                (namespace, value) -> {})__    };registers,this,instance,to,listen,to,updates,on,the,cluster,settings;public,void,listen,for,updates,cluster,settings,cluster,settings,cluster,settings,add,affix,update,consumer,remote,cluster,aware,remote,cluster,aware,key,value,update,remote,cluster,key,value,v2,value,v1,namespace,value,cluster,settings,add,affix,update,consumer,remote,cluster,aware,remote,cluster,aware,key,value,update,remote,cluster,key,value,v2,value,v1,namespace,value
RemoteClusterAware -> public void listenForUpdates(ClusterSettings clusterSettings);1546877578;Registers this instance to listen to updates on the cluster settings.;public void listenForUpdates(ClusterSettings clusterSettings) {_        clusterSettings.addAffixUpdateConsumer(_                RemoteClusterAware.REMOTE_CLUSTERS_PROXY,_                RemoteClusterAware.REMOTE_CLUSTERS_SEEDS,_                (key, value) -> updateRemoteCluster(key, value.v2(), value.v1()),_                (namespace, value) -> {})__        clusterSettings.addAffixUpdateConsumer(_                RemoteClusterAware.SEARCH_REMOTE_CLUSTERS_PROXY,_                RemoteClusterAware.SEARCH_REMOTE_CLUSTERS_SEEDS,_                (key, value) -> updateRemoteCluster(key, value.v2(), value.v1()),_                (namespace, value) -> {})__    };registers,this,instance,to,listen,to,updates,on,the,cluster,settings;public,void,listen,for,updates,cluster,settings,cluster,settings,cluster,settings,add,affix,update,consumer,remote,cluster,aware,remote,cluster,aware,key,value,update,remote,cluster,key,value,v2,value,v1,namespace,value,cluster,settings,add,affix,update,consumer,remote,cluster,aware,remote,cluster,aware,key,value,update,remote,cluster,key,value,v2,value,v1,namespace,value
RemoteClusterAware -> public void listenForUpdates(ClusterSettings clusterSettings);1549608646;Registers this instance to listen to updates on the cluster settings.;public void listenForUpdates(ClusterSettings clusterSettings) {_        clusterSettings.addAffixUpdateConsumer(_                RemoteClusterAware.REMOTE_CLUSTERS_PROXY,_                RemoteClusterAware.REMOTE_CLUSTERS_SEEDS,_                (key, value) -> updateRemoteCluster(key, value.v2(), value.v1()),_                (namespace, value) -> {})__        clusterSettings.addAffixUpdateConsumer(_                RemoteClusterAware.SEARCH_REMOTE_CLUSTERS_PROXY,_                RemoteClusterAware.SEARCH_REMOTE_CLUSTERS_SEEDS,_                (key, value) -> updateRemoteCluster(key, value.v2(), value.v1()),_                (namespace, value) -> {})__    };registers,this,instance,to,listen,to,updates,on,the,cluster,settings;public,void,listen,for,updates,cluster,settings,cluster,settings,cluster,settings,add,affix,update,consumer,remote,cluster,aware,remote,cluster,aware,key,value,update,remote,cluster,key,value,v2,value,v1,namespace,value,cluster,settings,add,affix,update,consumer,remote,cluster,aware,remote,cluster,aware,key,value,update,remote,cluster,key,value,v2,value,v1,namespace,value
RemoteClusterAware -> public void listenForUpdates(ClusterSettings clusterSettings);1550601141;Registers this instance to listen to updates on the cluster settings.;public void listenForUpdates(ClusterSettings clusterSettings) {_        List<Setting.AffixSetting<?>> remoteClusterSettings = Arrays.asList(RemoteClusterAware.REMOTE_CLUSTERS_PROXY,_            RemoteClusterAware.REMOTE_CLUSTERS_SEEDS, RemoteClusterService.REMOTE_CLUSTER_COMPRESS,_            RemoteClusterService.REMOTE_CLUSTER_PING_SCHEDULE)__        clusterSettings.addAffixGroupUpdateConsumer(remoteClusterSettings, this::updateRemoteCluster)__        clusterSettings.addAffixUpdateConsumer(_                RemoteClusterAware.SEARCH_REMOTE_CLUSTERS_PROXY,_                RemoteClusterAware.SEARCH_REMOTE_CLUSTERS_SEEDS,_                (key, value) -> updateRemoteCluster(key, value.v2(), value.v1()),_                (namespace, value) -> {})__    };registers,this,instance,to,listen,to,updates,on,the,cluster,settings;public,void,listen,for,updates,cluster,settings,cluster,settings,list,setting,affix,setting,remote,cluster,settings,arrays,as,list,remote,cluster,aware,remote,cluster,aware,remote,cluster,service,remote,cluster,service,cluster,settings,add,affix,group,update,consumer,remote,cluster,settings,this,update,remote,cluster,cluster,settings,add,affix,update,consumer,remote,cluster,aware,remote,cluster,aware,key,value,update,remote,cluster,key,value,v2,value,v1,namespace,value
RemoteClusterAware -> public Map<String, List<String>> groupClusterIndices(String[] requestIndices, Predicate<String> indexExists);1524684173;Groups indices per cluster by splitting remote cluster-alias, index-name pairs on {@link #REMOTE_CLUSTER_INDEX_SEPARATOR}. All_indices per cluster are collected as a list in the returned map keyed by the cluster alias. Local indices are grouped under_{@link #LOCAL_CLUSTER_GROUP_KEY}. The returned map is mutable.__@param requestIndices the indices in the search request to filter_@param indexExists a predicate that can test if a certain index or alias exists in the local cluster__@return a map of grouped remote and local indices;public Map<String, List<String>> groupClusterIndices(String[] requestIndices, Predicate<String> indexExists) {_        Map<String, List<String>> perClusterIndices = new HashMap<>()__        Set<String> remoteClusterNames = getRemoteClusterNames()__        for (String index : requestIndices) {_            int i = index.indexOf(RemoteClusterService.REMOTE_CLUSTER_INDEX_SEPARATOR)__            if (i >= 0) {_                String remoteClusterName = index.substring(0, i)__                List<String> clusters = clusterNameResolver.resolveClusterNames(remoteClusterNames, remoteClusterName)__                if (clusters.isEmpty() == false) {_                    if (indexExists.test(index)) {_                        _                        _                        _                        throw new IllegalArgumentException("Can not filter indices_ index " + index +_                            " exists but there is also a remote cluster named: " + remoteClusterName)__                        }_                    String indexName = index.substring(i + 1)__                    for (String clusterName : clusters) {_                        perClusterIndices.computeIfAbsent(clusterName, k -> new ArrayList<>()).add(indexName)__                    }_                } else {_                    perClusterIndices.computeIfAbsent(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY, k -> new ArrayList<>()).add(index)__                }_            } else {_                perClusterIndices.computeIfAbsent(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY, k -> new ArrayList<>()).add(index)__            }_        }_        return perClusterIndices__    };groups,indices,per,cluster,by,splitting,remote,cluster,alias,index,name,pairs,on,link,all,indices,per,cluster,are,collected,as,a,list,in,the,returned,map,keyed,by,the,cluster,alias,local,indices,are,grouped,under,link,the,returned,map,is,mutable,param,request,indices,the,indices,in,the,search,request,to,filter,param,index,exists,a,predicate,that,can,test,if,a,certain,index,or,alias,exists,in,the,local,cluster,return,a,map,of,grouped,remote,and,local,indices;public,map,string,list,string,group,cluster,indices,string,request,indices,predicate,string,index,exists,map,string,list,string,per,cluster,indices,new,hash,map,set,string,remote,cluster,names,get,remote,cluster,names,for,string,index,request,indices,int,i,index,index,of,remote,cluster,service,if,i,0,string,remote,cluster,name,index,substring,0,i,list,string,clusters,cluster,name,resolver,resolve,cluster,names,remote,cluster,names,remote,cluster,name,if,clusters,is,empty,false,if,index,exists,test,index,throw,new,illegal,argument,exception,can,not,filter,indices,index,index,exists,but,there,is,also,a,remote,cluster,named,remote,cluster,name,string,index,name,index,substring,i,1,for,string,cluster,name,clusters,per,cluster,indices,compute,if,absent,cluster,name,k,new,array,list,add,index,name,else,per,cluster,indices,compute,if,absent,remote,cluster,aware,k,new,array,list,add,index,else,per,cluster,indices,compute,if,absent,remote,cluster,aware,k,new,array,list,add,index,return,per,cluster,indices
RemoteClusterAware -> public Map<String, List<String>> groupClusterIndices(String[] requestIndices, Predicate<String> indexExists);1534755962;Groups indices per cluster by splitting remote cluster-alias, index-name pairs on {@link #REMOTE_CLUSTER_INDEX_SEPARATOR}. All_indices per cluster are collected as a list in the returned map keyed by the cluster alias. Local indices are grouped under_{@link #LOCAL_CLUSTER_GROUP_KEY}. The returned map is mutable.__@param requestIndices the indices in the search request to filter_@param indexExists a predicate that can test if a certain index or alias exists in the local cluster__@return a map of grouped remote and local indices;public Map<String, List<String>> groupClusterIndices(String[] requestIndices, Predicate<String> indexExists) {_        Map<String, List<String>> perClusterIndices = new HashMap<>()__        Set<String> remoteClusterNames = getRemoteClusterNames()__        for (String index : requestIndices) {_            int i = index.indexOf(RemoteClusterService.REMOTE_CLUSTER_INDEX_SEPARATOR)__            if (i >= 0) {_                String remoteClusterName = index.substring(0, i)__                List<String> clusters = clusterNameResolver.resolveClusterNames(remoteClusterNames, remoteClusterName)__                if (clusters.isEmpty() == false) {_                    if (indexExists.test(index)) {_                        _                        _                        _                        throw new IllegalArgumentException("Can not filter indices_ index " + index +_                            " exists but there is also a remote cluster named: " + remoteClusterName)__                        }_                    String indexName = index.substring(i + 1)__                    for (String clusterName : clusters) {_                        perClusterIndices.computeIfAbsent(clusterName, k -> new ArrayList<>()).add(indexName)__                    }_                } else {_                    perClusterIndices.computeIfAbsent(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY, k -> new ArrayList<>()).add(index)__                }_            } else {_                perClusterIndices.computeIfAbsent(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY, k -> new ArrayList<>()).add(index)__            }_        }_        return perClusterIndices__    };groups,indices,per,cluster,by,splitting,remote,cluster,alias,index,name,pairs,on,link,all,indices,per,cluster,are,collected,as,a,list,in,the,returned,map,keyed,by,the,cluster,alias,local,indices,are,grouped,under,link,the,returned,map,is,mutable,param,request,indices,the,indices,in,the,search,request,to,filter,param,index,exists,a,predicate,that,can,test,if,a,certain,index,or,alias,exists,in,the,local,cluster,return,a,map,of,grouped,remote,and,local,indices;public,map,string,list,string,group,cluster,indices,string,request,indices,predicate,string,index,exists,map,string,list,string,per,cluster,indices,new,hash,map,set,string,remote,cluster,names,get,remote,cluster,names,for,string,index,request,indices,int,i,index,index,of,remote,cluster,service,if,i,0,string,remote,cluster,name,index,substring,0,i,list,string,clusters,cluster,name,resolver,resolve,cluster,names,remote,cluster,names,remote,cluster,name,if,clusters,is,empty,false,if,index,exists,test,index,throw,new,illegal,argument,exception,can,not,filter,indices,index,index,exists,but,there,is,also,a,remote,cluster,named,remote,cluster,name,string,index,name,index,substring,i,1,for,string,cluster,name,clusters,per,cluster,indices,compute,if,absent,cluster,name,k,new,array,list,add,index,name,else,per,cluster,indices,compute,if,absent,remote,cluster,aware,k,new,array,list,add,index,else,per,cluster,indices,compute,if,absent,remote,cluster,aware,k,new,array,list,add,index,return,per,cluster,indices
RemoteClusterAware -> public Map<String, List<String>> groupClusterIndices(String[] requestIndices, Predicate<String> indexExists);1535383145;Groups indices per cluster by splitting remote cluster-alias, index-name pairs on {@link #REMOTE_CLUSTER_INDEX_SEPARATOR}. All_indices per cluster are collected as a list in the returned map keyed by the cluster alias. Local indices are grouped under_{@link #LOCAL_CLUSTER_GROUP_KEY}. The returned map is mutable.__@param requestIndices the indices in the search request to filter_@param indexExists a predicate that can test if a certain index or alias exists in the local cluster__@return a map of grouped remote and local indices;public Map<String, List<String>> groupClusterIndices(String[] requestIndices, Predicate<String> indexExists) {_        Map<String, List<String>> perClusterIndices = new HashMap<>()__        Set<String> remoteClusterNames = getRemoteClusterNames()__        for (String index : requestIndices) {_            int i = index.indexOf(RemoteClusterService.REMOTE_CLUSTER_INDEX_SEPARATOR)__            if (i >= 0) {_                String remoteClusterName = index.substring(0, i)__                List<String> clusters = clusterNameResolver.resolveClusterNames(remoteClusterNames, remoteClusterName)__                if (clusters.isEmpty() == false) {_                    if (indexExists.test(index)) {_                        _                        _                        _                        throw new IllegalArgumentException("Can not filter indices_ index " + index +_                            " exists but there is also a remote cluster named: " + remoteClusterName)__                        }_                    String indexName = index.substring(i + 1)__                    for (String clusterName : clusters) {_                        perClusterIndices.computeIfAbsent(clusterName, k -> new ArrayList<>()).add(indexName)__                    }_                } else {_                    perClusterIndices.computeIfAbsent(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY, k -> new ArrayList<>()).add(index)__                }_            } else {_                perClusterIndices.computeIfAbsent(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY, k -> new ArrayList<>()).add(index)__            }_        }_        return perClusterIndices__    };groups,indices,per,cluster,by,splitting,remote,cluster,alias,index,name,pairs,on,link,all,indices,per,cluster,are,collected,as,a,list,in,the,returned,map,keyed,by,the,cluster,alias,local,indices,are,grouped,under,link,the,returned,map,is,mutable,param,request,indices,the,indices,in,the,search,request,to,filter,param,index,exists,a,predicate,that,can,test,if,a,certain,index,or,alias,exists,in,the,local,cluster,return,a,map,of,grouped,remote,and,local,indices;public,map,string,list,string,group,cluster,indices,string,request,indices,predicate,string,index,exists,map,string,list,string,per,cluster,indices,new,hash,map,set,string,remote,cluster,names,get,remote,cluster,names,for,string,index,request,indices,int,i,index,index,of,remote,cluster,service,if,i,0,string,remote,cluster,name,index,substring,0,i,list,string,clusters,cluster,name,resolver,resolve,cluster,names,remote,cluster,names,remote,cluster,name,if,clusters,is,empty,false,if,index,exists,test,index,throw,new,illegal,argument,exception,can,not,filter,indices,index,index,exists,but,there,is,also,a,remote,cluster,named,remote,cluster,name,string,index,name,index,substring,i,1,for,string,cluster,name,clusters,per,cluster,indices,compute,if,absent,cluster,name,k,new,array,list,add,index,name,else,per,cluster,indices,compute,if,absent,remote,cluster,aware,k,new,array,list,add,index,else,per,cluster,indices,compute,if,absent,remote,cluster,aware,k,new,array,list,add,index,return,per,cluster,indices
RemoteClusterAware -> public Map<String, List<String>> groupClusterIndices(String[] requestIndices, Predicate<String> indexExists);1536218260;Groups indices per cluster by splitting remote cluster-alias, index-name pairs on {@link #REMOTE_CLUSTER_INDEX_SEPARATOR}. All_indices per cluster are collected as a list in the returned map keyed by the cluster alias. Local indices are grouped under_{@link #LOCAL_CLUSTER_GROUP_KEY}. The returned map is mutable.__@param requestIndices the indices in the search request to filter_@param indexExists a predicate that can test if a certain index or alias exists in the local cluster__@return a map of grouped remote and local indices;public Map<String, List<String>> groupClusterIndices(String[] requestIndices, Predicate<String> indexExists) {_        Map<String, List<String>> perClusterIndices = new HashMap<>()__        Set<String> remoteClusterNames = getRemoteClusterNames()__        for (String index : requestIndices) {_            int i = index.indexOf(RemoteClusterService.REMOTE_CLUSTER_INDEX_SEPARATOR)__            if (i >= 0) {_                String remoteClusterName = index.substring(0, i)__                List<String> clusters = clusterNameResolver.resolveClusterNames(remoteClusterNames, remoteClusterName)__                if (clusters.isEmpty() == false) {_                    if (indexExists.test(index)) {_                        _                        _                        _                        throw new IllegalArgumentException("Can not filter indices_ index " + index +_                                " exists but there is also a remote cluster named: " + remoteClusterName)__                    }_                    String indexName = index.substring(i + 1)__                    for (String clusterName : clusters) {_                        perClusterIndices.computeIfAbsent(clusterName, k -> new ArrayList<>()).add(indexName)__                    }_                } else {_                    perClusterIndices.computeIfAbsent(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY, k -> new ArrayList<>()).add(index)__                }_            } else {_                perClusterIndices.computeIfAbsent(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY, k -> new ArrayList<>()).add(index)__            }_        }_        return perClusterIndices__    };groups,indices,per,cluster,by,splitting,remote,cluster,alias,index,name,pairs,on,link,all,indices,per,cluster,are,collected,as,a,list,in,the,returned,map,keyed,by,the,cluster,alias,local,indices,are,grouped,under,link,the,returned,map,is,mutable,param,request,indices,the,indices,in,the,search,request,to,filter,param,index,exists,a,predicate,that,can,test,if,a,certain,index,or,alias,exists,in,the,local,cluster,return,a,map,of,grouped,remote,and,local,indices;public,map,string,list,string,group,cluster,indices,string,request,indices,predicate,string,index,exists,map,string,list,string,per,cluster,indices,new,hash,map,set,string,remote,cluster,names,get,remote,cluster,names,for,string,index,request,indices,int,i,index,index,of,remote,cluster,service,if,i,0,string,remote,cluster,name,index,substring,0,i,list,string,clusters,cluster,name,resolver,resolve,cluster,names,remote,cluster,names,remote,cluster,name,if,clusters,is,empty,false,if,index,exists,test,index,throw,new,illegal,argument,exception,can,not,filter,indices,index,index,exists,but,there,is,also,a,remote,cluster,named,remote,cluster,name,string,index,name,index,substring,i,1,for,string,cluster,name,clusters,per,cluster,indices,compute,if,absent,cluster,name,k,new,array,list,add,index,name,else,per,cluster,indices,compute,if,absent,remote,cluster,aware,k,new,array,list,add,index,else,per,cluster,indices,compute,if,absent,remote,cluster,aware,k,new,array,list,add,index,return,per,cluster,indices
RemoteClusterAware -> public Map<String, List<String>> groupClusterIndices(String[] requestIndices, Predicate<String> indexExists);1536828374;Groups indices per cluster by splitting remote cluster-alias, index-name pairs on {@link #REMOTE_CLUSTER_INDEX_SEPARATOR}. All_indices per cluster are collected as a list in the returned map keyed by the cluster alias. Local indices are grouped under_{@link #LOCAL_CLUSTER_GROUP_KEY}. The returned map is mutable.__@param requestIndices the indices in the search request to filter_@param indexExists a predicate that can test if a certain index or alias exists in the local cluster__@return a map of grouped remote and local indices;public Map<String, List<String>> groupClusterIndices(String[] requestIndices, Predicate<String> indexExists) {_        Map<String, List<String>> perClusterIndices = new HashMap<>()__        Set<String> remoteClusterNames = getRemoteClusterNames()__        for (String index : requestIndices) {_            int i = index.indexOf(RemoteClusterService.REMOTE_CLUSTER_INDEX_SEPARATOR)__            if (i >= 0) {_                String remoteClusterName = index.substring(0, i)__                List<String> clusters = clusterNameResolver.resolveClusterNames(remoteClusterNames, remoteClusterName)__                if (clusters.isEmpty() == false) {_                    if (indexExists.test(index)) {_                        _                        _                        _                        throw new IllegalArgumentException("Can not filter indices_ index " + index +_                                " exists but there is also a remote cluster named: " + remoteClusterName)__                    }_                    String indexName = index.substring(i + 1)__                    for (String clusterName : clusters) {_                        perClusterIndices.computeIfAbsent(clusterName, k -> new ArrayList<>()).add(indexName)__                    }_                } else {_                    perClusterIndices.computeIfAbsent(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY, k -> new ArrayList<>()).add(index)__                }_            } else {_                perClusterIndices.computeIfAbsent(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY, k -> new ArrayList<>()).add(index)__            }_        }_        return perClusterIndices__    };groups,indices,per,cluster,by,splitting,remote,cluster,alias,index,name,pairs,on,link,all,indices,per,cluster,are,collected,as,a,list,in,the,returned,map,keyed,by,the,cluster,alias,local,indices,are,grouped,under,link,the,returned,map,is,mutable,param,request,indices,the,indices,in,the,search,request,to,filter,param,index,exists,a,predicate,that,can,test,if,a,certain,index,or,alias,exists,in,the,local,cluster,return,a,map,of,grouped,remote,and,local,indices;public,map,string,list,string,group,cluster,indices,string,request,indices,predicate,string,index,exists,map,string,list,string,per,cluster,indices,new,hash,map,set,string,remote,cluster,names,get,remote,cluster,names,for,string,index,request,indices,int,i,index,index,of,remote,cluster,service,if,i,0,string,remote,cluster,name,index,substring,0,i,list,string,clusters,cluster,name,resolver,resolve,cluster,names,remote,cluster,names,remote,cluster,name,if,clusters,is,empty,false,if,index,exists,test,index,throw,new,illegal,argument,exception,can,not,filter,indices,index,index,exists,but,there,is,also,a,remote,cluster,named,remote,cluster,name,string,index,name,index,substring,i,1,for,string,cluster,name,clusters,per,cluster,indices,compute,if,absent,cluster,name,k,new,array,list,add,index,name,else,per,cluster,indices,compute,if,absent,remote,cluster,aware,k,new,array,list,add,index,else,per,cluster,indices,compute,if,absent,remote,cluster,aware,k,new,array,list,add,index,return,per,cluster,indices
RemoteClusterAware -> public Map<String, List<String>> groupClusterIndices(String[] requestIndices, Predicate<String> indexExists);1538067637;Groups indices per cluster by splitting remote cluster-alias, index-name pairs on {@link #REMOTE_CLUSTER_INDEX_SEPARATOR}. All_indices per cluster are collected as a list in the returned map keyed by the cluster alias. Local indices are grouped under_{@link #LOCAL_CLUSTER_GROUP_KEY}. The returned map is mutable.__@param requestIndices the indices in the search request to filter_@param indexExists a predicate that can test if a certain index or alias exists in the local cluster__@return a map of grouped remote and local indices;public Map<String, List<String>> groupClusterIndices(String[] requestIndices, Predicate<String> indexExists) {_        Map<String, List<String>> perClusterIndices = new HashMap<>()__        Set<String> remoteClusterNames = getRemoteClusterNames()__        for (String index : requestIndices) {_            int i = index.indexOf(RemoteClusterService.REMOTE_CLUSTER_INDEX_SEPARATOR)__            if (i >= 0) {_                String remoteClusterName = index.substring(0, i)__                List<String> clusters = clusterNameResolver.resolveClusterNames(remoteClusterNames, remoteClusterName)__                if (clusters.isEmpty() == false) {_                    if (indexExists.test(index)) {_                        _                        _                        _                        _                        throw new IllegalArgumentException("Can not filter indices_ index " + index +_                                " exists but there is also a remote cluster named: " + remoteClusterName)__                    }_                    String indexName = index.substring(i + 1)__                    for (String clusterName : clusters) {_                        perClusterIndices.computeIfAbsent(clusterName, k -> new ArrayList<>()).add(indexName)__                    }_                } else {_                    _                    _                    _                    perClusterIndices.computeIfAbsent(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY, k -> new ArrayList<>()).add(index)__                }_            } else {_                perClusterIndices.computeIfAbsent(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY, k -> new ArrayList<>()).add(index)__            }_        }_        return perClusterIndices__    };groups,indices,per,cluster,by,splitting,remote,cluster,alias,index,name,pairs,on,link,all,indices,per,cluster,are,collected,as,a,list,in,the,returned,map,keyed,by,the,cluster,alias,local,indices,are,grouped,under,link,the,returned,map,is,mutable,param,request,indices,the,indices,in,the,search,request,to,filter,param,index,exists,a,predicate,that,can,test,if,a,certain,index,or,alias,exists,in,the,local,cluster,return,a,map,of,grouped,remote,and,local,indices;public,map,string,list,string,group,cluster,indices,string,request,indices,predicate,string,index,exists,map,string,list,string,per,cluster,indices,new,hash,map,set,string,remote,cluster,names,get,remote,cluster,names,for,string,index,request,indices,int,i,index,index,of,remote,cluster,service,if,i,0,string,remote,cluster,name,index,substring,0,i,list,string,clusters,cluster,name,resolver,resolve,cluster,names,remote,cluster,names,remote,cluster,name,if,clusters,is,empty,false,if,index,exists,test,index,throw,new,illegal,argument,exception,can,not,filter,indices,index,index,exists,but,there,is,also,a,remote,cluster,named,remote,cluster,name,string,index,name,index,substring,i,1,for,string,cluster,name,clusters,per,cluster,indices,compute,if,absent,cluster,name,k,new,array,list,add,index,name,else,per,cluster,indices,compute,if,absent,remote,cluster,aware,k,new,array,list,add,index,else,per,cluster,indices,compute,if,absent,remote,cluster,aware,k,new,array,list,add,index,return,per,cluster,indices
RemoteClusterAware -> public Map<String, List<String>> groupClusterIndices(String[] requestIndices, Predicate<String> indexExists);1539796943;Groups indices per cluster by splitting remote cluster-alias, index-name pairs on {@link #REMOTE_CLUSTER_INDEX_SEPARATOR}. All_indices per cluster are collected as a list in the returned map keyed by the cluster alias. Local indices are grouped under_{@link #LOCAL_CLUSTER_GROUP_KEY}. The returned map is mutable.__@param requestIndices the indices in the search request to filter_@param indexExists a predicate that can test if a certain index or alias exists in the local cluster__@return a map of grouped remote and local indices;public Map<String, List<String>> groupClusterIndices(String[] requestIndices, Predicate<String> indexExists) {_        Map<String, List<String>> perClusterIndices = new HashMap<>()__        Set<String> remoteClusterNames = getRemoteClusterNames()__        for (String index : requestIndices) {_            int i = index.indexOf(RemoteClusterService.REMOTE_CLUSTER_INDEX_SEPARATOR)__            if (i >= 0) {_                String remoteClusterName = index.substring(0, i)__                List<String> clusters = clusterNameResolver.resolveClusterNames(remoteClusterNames, remoteClusterName)__                if (clusters.isEmpty() == false) {_                    if (indexExists.test(index)) {_                        _                        _                        _                        _                        throw new IllegalArgumentException("Can not filter indices_ index " + index +_                                " exists but there is also a remote cluster named: " + remoteClusterName)__                    }_                    String indexName = index.substring(i + 1)__                    for (String clusterName : clusters) {_                        perClusterIndices.computeIfAbsent(clusterName, k -> new ArrayList<>()).add(indexName)__                    }_                } else {_                    _                    _                    _                    perClusterIndices.computeIfAbsent(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY, k -> new ArrayList<>()).add(index)__                }_            } else {_                perClusterIndices.computeIfAbsent(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY, k -> new ArrayList<>()).add(index)__            }_        }_        return perClusterIndices__    };groups,indices,per,cluster,by,splitting,remote,cluster,alias,index,name,pairs,on,link,all,indices,per,cluster,are,collected,as,a,list,in,the,returned,map,keyed,by,the,cluster,alias,local,indices,are,grouped,under,link,the,returned,map,is,mutable,param,request,indices,the,indices,in,the,search,request,to,filter,param,index,exists,a,predicate,that,can,test,if,a,certain,index,or,alias,exists,in,the,local,cluster,return,a,map,of,grouped,remote,and,local,indices;public,map,string,list,string,group,cluster,indices,string,request,indices,predicate,string,index,exists,map,string,list,string,per,cluster,indices,new,hash,map,set,string,remote,cluster,names,get,remote,cluster,names,for,string,index,request,indices,int,i,index,index,of,remote,cluster,service,if,i,0,string,remote,cluster,name,index,substring,0,i,list,string,clusters,cluster,name,resolver,resolve,cluster,names,remote,cluster,names,remote,cluster,name,if,clusters,is,empty,false,if,index,exists,test,index,throw,new,illegal,argument,exception,can,not,filter,indices,index,index,exists,but,there,is,also,a,remote,cluster,named,remote,cluster,name,string,index,name,index,substring,i,1,for,string,cluster,name,clusters,per,cluster,indices,compute,if,absent,cluster,name,k,new,array,list,add,index,name,else,per,cluster,indices,compute,if,absent,remote,cluster,aware,k,new,array,list,add,index,else,per,cluster,indices,compute,if,absent,remote,cluster,aware,k,new,array,list,add,index,return,per,cluster,indices
RemoteClusterAware -> public Map<String, List<String>> groupClusterIndices(String[] requestIndices, Predicate<String> indexExists);1541008027;Groups indices per cluster by splitting remote cluster-alias, index-name pairs on {@link #REMOTE_CLUSTER_INDEX_SEPARATOR}. All_indices per cluster are collected as a list in the returned map keyed by the cluster alias. Local indices are grouped under_{@link #LOCAL_CLUSTER_GROUP_KEY}. The returned map is mutable.__@param requestIndices the indices in the search request to filter_@param indexExists a predicate that can test if a certain index or alias exists in the local cluster__@return a map of grouped remote and local indices;public Map<String, List<String>> groupClusterIndices(String[] requestIndices, Predicate<String> indexExists) {_        Map<String, List<String>> perClusterIndices = new HashMap<>()__        Set<String> remoteClusterNames = getRemoteClusterNames()__        for (String index : requestIndices) {_            int i = index.indexOf(RemoteClusterService.REMOTE_CLUSTER_INDEX_SEPARATOR)__            if (i >= 0) {_                String remoteClusterName = index.substring(0, i)__                List<String> clusters = clusterNameResolver.resolveClusterNames(remoteClusterNames, remoteClusterName)__                if (clusters.isEmpty() == false) {_                    if (indexExists.test(index)) {_                        _                        _                        _                        _                        throw new IllegalArgumentException("Can not filter indices_ index " + index +_                                " exists but there is also a remote cluster named: " + remoteClusterName)__                    }_                    String indexName = index.substring(i + 1)__                    for (String clusterName : clusters) {_                        perClusterIndices.computeIfAbsent(clusterName, k -> new ArrayList<>()).add(indexName)__                    }_                } else {_                    _                    _                    _                    perClusterIndices.computeIfAbsent(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY, k -> new ArrayList<>()).add(index)__                }_            } else {_                perClusterIndices.computeIfAbsent(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY, k -> new ArrayList<>()).add(index)__            }_        }_        return perClusterIndices__    };groups,indices,per,cluster,by,splitting,remote,cluster,alias,index,name,pairs,on,link,all,indices,per,cluster,are,collected,as,a,list,in,the,returned,map,keyed,by,the,cluster,alias,local,indices,are,grouped,under,link,the,returned,map,is,mutable,param,request,indices,the,indices,in,the,search,request,to,filter,param,index,exists,a,predicate,that,can,test,if,a,certain,index,or,alias,exists,in,the,local,cluster,return,a,map,of,grouped,remote,and,local,indices;public,map,string,list,string,group,cluster,indices,string,request,indices,predicate,string,index,exists,map,string,list,string,per,cluster,indices,new,hash,map,set,string,remote,cluster,names,get,remote,cluster,names,for,string,index,request,indices,int,i,index,index,of,remote,cluster,service,if,i,0,string,remote,cluster,name,index,substring,0,i,list,string,clusters,cluster,name,resolver,resolve,cluster,names,remote,cluster,names,remote,cluster,name,if,clusters,is,empty,false,if,index,exists,test,index,throw,new,illegal,argument,exception,can,not,filter,indices,index,index,exists,but,there,is,also,a,remote,cluster,named,remote,cluster,name,string,index,name,index,substring,i,1,for,string,cluster,name,clusters,per,cluster,indices,compute,if,absent,cluster,name,k,new,array,list,add,index,name,else,per,cluster,indices,compute,if,absent,remote,cluster,aware,k,new,array,list,add,index,else,per,cluster,indices,compute,if,absent,remote,cluster,aware,k,new,array,list,add,index,return,per,cluster,indices
RemoteClusterAware -> public Map<String, List<String>> groupClusterIndices(String[] requestIndices, Predicate<String> indexExists);1541092382;Groups indices per cluster by splitting remote cluster-alias, index-name pairs on {@link #REMOTE_CLUSTER_INDEX_SEPARATOR}. All_indices per cluster are collected as a list in the returned map keyed by the cluster alias. Local indices are grouped under_{@link #LOCAL_CLUSTER_GROUP_KEY}. The returned map is mutable.__@param requestIndices the indices in the search request to filter_@param indexExists a predicate that can test if a certain index or alias exists in the local cluster__@return a map of grouped remote and local indices;public Map<String, List<String>> groupClusterIndices(String[] requestIndices, Predicate<String> indexExists) {_        Map<String, List<String>> perClusterIndices = new HashMap<>()__        Set<String> remoteClusterNames = getRemoteClusterNames()__        for (String index : requestIndices) {_            int i = index.indexOf(RemoteClusterService.REMOTE_CLUSTER_INDEX_SEPARATOR)__            if (i >= 0) {_                String remoteClusterName = index.substring(0, i)__                List<String> clusters = clusterNameResolver.resolveClusterNames(remoteClusterNames, remoteClusterName)__                if (clusters.isEmpty() == false) {_                    if (indexExists.test(index)) {_                        _                        _                        _                        _                        throw new IllegalArgumentException("Can not filter indices_ index " + index +_                                " exists but there is also a remote cluster named: " + remoteClusterName)__                    }_                    String indexName = index.substring(i + 1)__                    for (String clusterName : clusters) {_                        perClusterIndices.computeIfAbsent(clusterName, k -> new ArrayList<>()).add(indexName)__                    }_                } else {_                    _                    _                    _                    perClusterIndices.computeIfAbsent(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY, k -> new ArrayList<>()).add(index)__                }_            } else {_                perClusterIndices.computeIfAbsent(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY, k -> new ArrayList<>()).add(index)__            }_        }_        return perClusterIndices__    };groups,indices,per,cluster,by,splitting,remote,cluster,alias,index,name,pairs,on,link,all,indices,per,cluster,are,collected,as,a,list,in,the,returned,map,keyed,by,the,cluster,alias,local,indices,are,grouped,under,link,the,returned,map,is,mutable,param,request,indices,the,indices,in,the,search,request,to,filter,param,index,exists,a,predicate,that,can,test,if,a,certain,index,or,alias,exists,in,the,local,cluster,return,a,map,of,grouped,remote,and,local,indices;public,map,string,list,string,group,cluster,indices,string,request,indices,predicate,string,index,exists,map,string,list,string,per,cluster,indices,new,hash,map,set,string,remote,cluster,names,get,remote,cluster,names,for,string,index,request,indices,int,i,index,index,of,remote,cluster,service,if,i,0,string,remote,cluster,name,index,substring,0,i,list,string,clusters,cluster,name,resolver,resolve,cluster,names,remote,cluster,names,remote,cluster,name,if,clusters,is,empty,false,if,index,exists,test,index,throw,new,illegal,argument,exception,can,not,filter,indices,index,index,exists,but,there,is,also,a,remote,cluster,named,remote,cluster,name,string,index,name,index,substring,i,1,for,string,cluster,name,clusters,per,cluster,indices,compute,if,absent,cluster,name,k,new,array,list,add,index,name,else,per,cluster,indices,compute,if,absent,remote,cluster,aware,k,new,array,list,add,index,else,per,cluster,indices,compute,if,absent,remote,cluster,aware,k,new,array,list,add,index,return,per,cluster,indices
RemoteClusterAware -> public Map<String, List<String>> groupClusterIndices(String[] requestIndices, Predicate<String> indexExists);1542402632;Groups indices per cluster by splitting remote cluster-alias, index-name pairs on {@link #REMOTE_CLUSTER_INDEX_SEPARATOR}. All_indices per cluster are collected as a list in the returned map keyed by the cluster alias. Local indices are grouped under_{@link #LOCAL_CLUSTER_GROUP_KEY}. The returned map is mutable.__@param requestIndices the indices in the search request to filter_@param indexExists a predicate that can test if a certain index or alias exists in the local cluster__@return a map of grouped remote and local indices;public Map<String, List<String>> groupClusterIndices(String[] requestIndices, Predicate<String> indexExists) {_        Map<String, List<String>> perClusterIndices = new HashMap<>()__        Set<String> remoteClusterNames = getRemoteClusterNames()__        for (String index : requestIndices) {_            int i = index.indexOf(RemoteClusterService.REMOTE_CLUSTER_INDEX_SEPARATOR)__            if (i >= 0) {_                String remoteClusterName = index.substring(0, i)__                List<String> clusters = clusterNameResolver.resolveClusterNames(remoteClusterNames, remoteClusterName)__                if (clusters.isEmpty() == false) {_                    if (indexExists.test(index)) {_                        _                        _                        _                        _                        throw new IllegalArgumentException("Can not filter indices_ index " + index +_                                " exists but there is also a remote cluster named: " + remoteClusterName)__                    }_                    String indexName = index.substring(i + 1)__                    for (String clusterName : clusters) {_                        perClusterIndices.computeIfAbsent(clusterName, k -> new ArrayList<>()).add(indexName)__                    }_                } else {_                    _                    _                    _                    perClusterIndices.computeIfAbsent(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY, k -> new ArrayList<>()).add(index)__                }_            } else {_                perClusterIndices.computeIfAbsent(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY, k -> new ArrayList<>()).add(index)__            }_        }_        return perClusterIndices__    };groups,indices,per,cluster,by,splitting,remote,cluster,alias,index,name,pairs,on,link,all,indices,per,cluster,are,collected,as,a,list,in,the,returned,map,keyed,by,the,cluster,alias,local,indices,are,grouped,under,link,the,returned,map,is,mutable,param,request,indices,the,indices,in,the,search,request,to,filter,param,index,exists,a,predicate,that,can,test,if,a,certain,index,or,alias,exists,in,the,local,cluster,return,a,map,of,grouped,remote,and,local,indices;public,map,string,list,string,group,cluster,indices,string,request,indices,predicate,string,index,exists,map,string,list,string,per,cluster,indices,new,hash,map,set,string,remote,cluster,names,get,remote,cluster,names,for,string,index,request,indices,int,i,index,index,of,remote,cluster,service,if,i,0,string,remote,cluster,name,index,substring,0,i,list,string,clusters,cluster,name,resolver,resolve,cluster,names,remote,cluster,names,remote,cluster,name,if,clusters,is,empty,false,if,index,exists,test,index,throw,new,illegal,argument,exception,can,not,filter,indices,index,index,exists,but,there,is,also,a,remote,cluster,named,remote,cluster,name,string,index,name,index,substring,i,1,for,string,cluster,name,clusters,per,cluster,indices,compute,if,absent,cluster,name,k,new,array,list,add,index,name,else,per,cluster,indices,compute,if,absent,remote,cluster,aware,k,new,array,list,add,index,else,per,cluster,indices,compute,if,absent,remote,cluster,aware,k,new,array,list,add,index,return,per,cluster,indices
RemoteClusterAware -> protected static Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> buildRemoteClustersDynamicConfig(Settings settings);1535383145;Builds the dynamic per-cluster config from the given settings. This is a map keyed by the cluster alias that points to a tuple_(ProxyAddresss, [SeedNodeSuppliers]). If a cluster is configured with a proxy address all seed nodes will point to_{@link TransportAddress#META_ADDRESS} and their configured address will be used as the hostname for the generated discovery node.;protected static Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> buildRemoteClustersDynamicConfig(Settings settings) {_        Stream<Setting<List<String>>> allConcreteSettings = REMOTE_CLUSTERS_SEEDS.getAllConcreteSettings(settings)__        return allConcreteSettings.collect(_            Collectors.toMap(REMOTE_CLUSTERS_SEEDS::getNamespace, concreteSetting -> {_                String clusterName = REMOTE_CLUSTERS_SEEDS.getNamespace(concreteSetting)__                List<String> addresses = concreteSetting.get(settings)__                final boolean proxyMode = REMOTE_CLUSTERS_PROXY.getConcreteSettingForNamespace(clusterName).exists(settings)__                List<Supplier<DiscoveryNode>> nodes = new ArrayList<>(addresses.size())__                for (String address : addresses) {_                    nodes.add(() -> buildSeedNode(clusterName, address, proxyMode))__                }_                return new Tuple<>(REMOTE_CLUSTERS_PROXY.getConcreteSettingForNamespace(clusterName).get(settings), nodes)__            }))__    };builds,the,dynamic,per,cluster,config,from,the,given,settings,this,is,a,map,keyed,by,the,cluster,alias,that,points,to,a,tuple,proxy,addresss,seed,node,suppliers,if,a,cluster,is,configured,with,a,proxy,address,all,seed,nodes,will,point,to,link,transport,address,and,their,configured,address,will,be,used,as,the,hostname,for,the,generated,discovery,node;protected,static,map,string,tuple,string,list,supplier,discovery,node,build,remote,clusters,dynamic,config,settings,settings,stream,setting,list,string,all,concrete,settings,get,all,concrete,settings,settings,return,all,concrete,settings,collect,collectors,to,map,get,namespace,concrete,setting,string,cluster,name,get,namespace,concrete,setting,list,string,addresses,concrete,setting,get,settings,final,boolean,proxy,mode,get,concrete,setting,for,namespace,cluster,name,exists,settings,list,supplier,discovery,node,nodes,new,array,list,addresses,size,for,string,address,addresses,nodes,add,build,seed,node,cluster,name,address,proxy,mode,return,new,tuple,get,concrete,setting,for,namespace,cluster,name,get,settings,nodes
RemoteClusterAware -> protected static Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> buildRemoteClustersDynamicConfig(Settings settings);1536218260;Builds the dynamic per-cluster config from the given settings. This is a map keyed by the cluster alias that points to a tuple_(ProxyAddresss, [SeedNodeSuppliers]). If a cluster is configured with a proxy address all seed nodes will point to_{@link TransportAddress#META_ADDRESS} and their configured address will be used as the hostname for the generated discovery node.;protected static Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> buildRemoteClustersDynamicConfig(Settings settings) {_        Stream<Setting<List<String>>> allConcreteSettings = REMOTE_CLUSTERS_SEEDS.getAllConcreteSettings(settings)__        return allConcreteSettings.collect(_                Collectors.toMap(REMOTE_CLUSTERS_SEEDS::getNamespace, concreteSetting -> {_                    String clusterName = REMOTE_CLUSTERS_SEEDS.getNamespace(concreteSetting)__                    List<String> addresses = concreteSetting.get(settings)__                    final boolean proxyMode = REMOTE_CLUSTERS_PROXY.getConcreteSettingForNamespace(clusterName).exists(settings)__                    List<Supplier<DiscoveryNode>> nodes = new ArrayList<>(addresses.size())__                    for (String address : addresses) {_                        nodes.add(() -> buildSeedNode(clusterName, address, proxyMode))__                    }_                    return new Tuple<>(REMOTE_CLUSTERS_PROXY.getConcreteSettingForNamespace(clusterName).get(settings), nodes)__                }))__    };builds,the,dynamic,per,cluster,config,from,the,given,settings,this,is,a,map,keyed,by,the,cluster,alias,that,points,to,a,tuple,proxy,addresss,seed,node,suppliers,if,a,cluster,is,configured,with,a,proxy,address,all,seed,nodes,will,point,to,link,transport,address,and,their,configured,address,will,be,used,as,the,hostname,for,the,generated,discovery,node;protected,static,map,string,tuple,string,list,supplier,discovery,node,build,remote,clusters,dynamic,config,settings,settings,stream,setting,list,string,all,concrete,settings,get,all,concrete,settings,settings,return,all,concrete,settings,collect,collectors,to,map,get,namespace,concrete,setting,string,cluster,name,get,namespace,concrete,setting,list,string,addresses,concrete,setting,get,settings,final,boolean,proxy,mode,get,concrete,setting,for,namespace,cluster,name,exists,settings,list,supplier,discovery,node,nodes,new,array,list,addresses,size,for,string,address,addresses,nodes,add,build,seed,node,cluster,name,address,proxy,mode,return,new,tuple,get,concrete,setting,for,namespace,cluster,name,get,settings,nodes
RemoteClusterAware -> protected static Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> buildRemoteClustersDynamicConfig(Settings settings);1536828374;Builds the dynamic per-cluster config from the given settings. This is a map keyed by the cluster alias that points to a tuple_(ProxyAddresss, [SeedNodeSuppliers]). If a cluster is configured with a proxy address all seed nodes will point to_{@link TransportAddress#META_ADDRESS} and their configured address will be used as the hostname for the generated discovery node.;protected static Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> buildRemoteClustersDynamicConfig(Settings settings) {_        Stream<Setting<List<String>>> allConcreteSettings = REMOTE_CLUSTERS_SEEDS.getAllConcreteSettings(settings)__        return allConcreteSettings.collect(_                Collectors.toMap(REMOTE_CLUSTERS_SEEDS::getNamespace, concreteSetting -> {_                    String clusterName = REMOTE_CLUSTERS_SEEDS.getNamespace(concreteSetting)__                    List<String> addresses = concreteSetting.get(settings)__                    final boolean proxyMode = REMOTE_CLUSTERS_PROXY.getConcreteSettingForNamespace(clusterName).exists(settings)__                    List<Supplier<DiscoveryNode>> nodes = new ArrayList<>(addresses.size())__                    for (String address : addresses) {_                        nodes.add(() -> buildSeedNode(clusterName, address, proxyMode))__                    }_                    return new Tuple<>(REMOTE_CLUSTERS_PROXY.getConcreteSettingForNamespace(clusterName).get(settings), nodes)__                }))__    };builds,the,dynamic,per,cluster,config,from,the,given,settings,this,is,a,map,keyed,by,the,cluster,alias,that,points,to,a,tuple,proxy,addresss,seed,node,suppliers,if,a,cluster,is,configured,with,a,proxy,address,all,seed,nodes,will,point,to,link,transport,address,and,their,configured,address,will,be,used,as,the,hostname,for,the,generated,discovery,node;protected,static,map,string,tuple,string,list,supplier,discovery,node,build,remote,clusters,dynamic,config,settings,settings,stream,setting,list,string,all,concrete,settings,get,all,concrete,settings,settings,return,all,concrete,settings,collect,collectors,to,map,get,namespace,concrete,setting,string,cluster,name,get,namespace,concrete,setting,list,string,addresses,concrete,setting,get,settings,final,boolean,proxy,mode,get,concrete,setting,for,namespace,cluster,name,exists,settings,list,supplier,discovery,node,nodes,new,array,list,addresses,size,for,string,address,addresses,nodes,add,build,seed,node,cluster,name,address,proxy,mode,return,new,tuple,get,concrete,setting,for,namespace,cluster,name,get,settings,nodes
RemoteClusterAware -> protected static Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> buildRemoteClustersDynamicConfig(Settings settings);1538067637;Builds the dynamic per-cluster config from the given settings. This is a map keyed by the cluster alias that points to a tuple_(ProxyAddresss, [SeedNodeSuppliers]). If a cluster is configured with a proxy address all seed nodes will point to_{@link TransportAddress#META_ADDRESS} and their configured address will be used as the hostname for the generated discovery node.;protected static Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> buildRemoteClustersDynamicConfig(Settings settings) {_        final Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> remoteSeeds =_                buildRemoteClustersDynamicConfig(settings, REMOTE_CLUSTERS_SEEDS)__        final Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> searchRemoteSeeds =_                buildRemoteClustersDynamicConfig(settings, SEARCH_REMOTE_CLUSTERS_SEEDS)__        _        final NavigableSet<String> intersection =_                new TreeSet<>(Arrays.asList(_                        searchRemoteSeeds.keySet().stream().filter(s -> remoteSeeds.keySet().contains(s)).sorted().toArray(String[]::new)))__        if (intersection.isEmpty() == false) {_            final String message = String.format(_                    Locale.ROOT,_                    "found duplicate remote cluster configurations for cluster alias%s [%s]",_                    intersection.size() == 1 ? "" : "es",_                    String.join(",", intersection))__            throw new IllegalArgumentException(message)__        }_        return Stream_                .concat(remoteSeeds.entrySet().stream(), searchRemoteSeeds.entrySet().stream())_                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue))__    };builds,the,dynamic,per,cluster,config,from,the,given,settings,this,is,a,map,keyed,by,the,cluster,alias,that,points,to,a,tuple,proxy,addresss,seed,node,suppliers,if,a,cluster,is,configured,with,a,proxy,address,all,seed,nodes,will,point,to,link,transport,address,and,their,configured,address,will,be,used,as,the,hostname,for,the,generated,discovery,node;protected,static,map,string,tuple,string,list,supplier,discovery,node,build,remote,clusters,dynamic,config,settings,settings,final,map,string,tuple,string,list,supplier,discovery,node,remote,seeds,build,remote,clusters,dynamic,config,settings,final,map,string,tuple,string,list,supplier,discovery,node,search,remote,seeds,build,remote,clusters,dynamic,config,settings,final,navigable,set,string,intersection,new,tree,set,arrays,as,list,search,remote,seeds,key,set,stream,filter,s,remote,seeds,key,set,contains,s,sorted,to,array,string,new,if,intersection,is,empty,false,final,string,message,string,format,locale,root,found,duplicate,remote,cluster,configurations,for,cluster,alias,s,s,intersection,size,1,es,string,join,intersection,throw,new,illegal,argument,exception,message,return,stream,concat,remote,seeds,entry,set,stream,search,remote,seeds,entry,set,stream,collect,collectors,to,map,map,entry,get,key,map,entry,get,value
RemoteClusterAware -> protected static Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> buildRemoteClustersDynamicConfig(Settings settings);1539796943;Builds the dynamic per-cluster config from the given settings. This is a map keyed by the cluster alias that points to a tuple_(ProxyAddresss, [SeedNodeSuppliers]). If a cluster is configured with a proxy address all seed nodes will point to_{@link TransportAddress#META_ADDRESS} and their configured address will be used as the hostname for the generated discovery node.;protected static Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> buildRemoteClustersDynamicConfig(Settings settings) {_        final Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> remoteSeeds =_                buildRemoteClustersDynamicConfig(settings, REMOTE_CLUSTERS_SEEDS)__        final Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> searchRemoteSeeds =_                buildRemoteClustersDynamicConfig(settings, SEARCH_REMOTE_CLUSTERS_SEEDS)__        _        final NavigableSet<String> intersection =_                new TreeSet<>(Arrays.asList(_                        searchRemoteSeeds.keySet().stream().filter(s -> remoteSeeds.keySet().contains(s)).sorted().toArray(String[]::new)))__        if (intersection.isEmpty() == false) {_            final String message = String.format(_                    Locale.ROOT,_                    "found duplicate remote cluster configurations for cluster alias%s [%s]",_                    intersection.size() == 1 ? "" : "es",_                    String.join(",", intersection))__            throw new IllegalArgumentException(message)__        }_        return Stream_                .concat(remoteSeeds.entrySet().stream(), searchRemoteSeeds.entrySet().stream())_                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue))__    };builds,the,dynamic,per,cluster,config,from,the,given,settings,this,is,a,map,keyed,by,the,cluster,alias,that,points,to,a,tuple,proxy,addresss,seed,node,suppliers,if,a,cluster,is,configured,with,a,proxy,address,all,seed,nodes,will,point,to,link,transport,address,and,their,configured,address,will,be,used,as,the,hostname,for,the,generated,discovery,node;protected,static,map,string,tuple,string,list,supplier,discovery,node,build,remote,clusters,dynamic,config,settings,settings,final,map,string,tuple,string,list,supplier,discovery,node,remote,seeds,build,remote,clusters,dynamic,config,settings,final,map,string,tuple,string,list,supplier,discovery,node,search,remote,seeds,build,remote,clusters,dynamic,config,settings,final,navigable,set,string,intersection,new,tree,set,arrays,as,list,search,remote,seeds,key,set,stream,filter,s,remote,seeds,key,set,contains,s,sorted,to,array,string,new,if,intersection,is,empty,false,final,string,message,string,format,locale,root,found,duplicate,remote,cluster,configurations,for,cluster,alias,s,s,intersection,size,1,es,string,join,intersection,throw,new,illegal,argument,exception,message,return,stream,concat,remote,seeds,entry,set,stream,search,remote,seeds,entry,set,stream,collect,collectors,to,map,map,entry,get,key,map,entry,get,value
RemoteClusterAware -> protected static Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> buildRemoteClustersDynamicConfig(Settings settings);1541008027;Builds the dynamic per-cluster config from the given settings. This is a map keyed by the cluster alias that points to a tuple_(ProxyAddresss, [SeedNodeSuppliers]). If a cluster is configured with a proxy address all seed nodes will point to_{@link TransportAddress#META_ADDRESS} and their configured address will be used as the hostname for the generated discovery node.;protected static Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> buildRemoteClustersDynamicConfig(Settings settings) {_        final Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> remoteSeeds =_                buildRemoteClustersDynamicConfig(settings, REMOTE_CLUSTERS_SEEDS)__        final Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> searchRemoteSeeds =_                buildRemoteClustersDynamicConfig(settings, SEARCH_REMOTE_CLUSTERS_SEEDS)__        _        final NavigableSet<String> intersection =_                new TreeSet<>(Arrays.asList(_                        searchRemoteSeeds.keySet().stream().filter(s -> remoteSeeds.keySet().contains(s)).sorted().toArray(String[]::new)))__        if (intersection.isEmpty() == false) {_            final String message = String.format(_                    Locale.ROOT,_                    "found duplicate remote cluster configurations for cluster alias%s [%s]",_                    intersection.size() == 1 ? "" : "es",_                    String.join(",", intersection))__            throw new IllegalArgumentException(message)__        }_        return Stream_                .concat(remoteSeeds.entrySet().stream(), searchRemoteSeeds.entrySet().stream())_                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue))__    };builds,the,dynamic,per,cluster,config,from,the,given,settings,this,is,a,map,keyed,by,the,cluster,alias,that,points,to,a,tuple,proxy,addresss,seed,node,suppliers,if,a,cluster,is,configured,with,a,proxy,address,all,seed,nodes,will,point,to,link,transport,address,and,their,configured,address,will,be,used,as,the,hostname,for,the,generated,discovery,node;protected,static,map,string,tuple,string,list,supplier,discovery,node,build,remote,clusters,dynamic,config,settings,settings,final,map,string,tuple,string,list,supplier,discovery,node,remote,seeds,build,remote,clusters,dynamic,config,settings,final,map,string,tuple,string,list,supplier,discovery,node,search,remote,seeds,build,remote,clusters,dynamic,config,settings,final,navigable,set,string,intersection,new,tree,set,arrays,as,list,search,remote,seeds,key,set,stream,filter,s,remote,seeds,key,set,contains,s,sorted,to,array,string,new,if,intersection,is,empty,false,final,string,message,string,format,locale,root,found,duplicate,remote,cluster,configurations,for,cluster,alias,s,s,intersection,size,1,es,string,join,intersection,throw,new,illegal,argument,exception,message,return,stream,concat,remote,seeds,entry,set,stream,search,remote,seeds,entry,set,stream,collect,collectors,to,map,map,entry,get,key,map,entry,get,value
RemoteClusterAware -> protected static Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> buildRemoteClustersDynamicConfig(Settings settings);1541092382;Builds the dynamic per-cluster config from the given settings. This is a map keyed by the cluster alias that points to a tuple_(ProxyAddresss, [SeedNodeSuppliers]). If a cluster is configured with a proxy address all seed nodes will point to_{@link TransportAddress#META_ADDRESS} and their configured address will be used as the hostname for the generated discovery node.;protected static Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> buildRemoteClustersDynamicConfig(Settings settings) {_        final Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> remoteSeeds =_                buildRemoteClustersDynamicConfig(settings, REMOTE_CLUSTERS_SEEDS)__        final Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> searchRemoteSeeds =_                buildRemoteClustersDynamicConfig(settings, SEARCH_REMOTE_CLUSTERS_SEEDS)__        _        final NavigableSet<String> intersection =_                new TreeSet<>(Arrays.asList(_                        searchRemoteSeeds.keySet().stream().filter(s -> remoteSeeds.keySet().contains(s)).sorted().toArray(String[]::new)))__        if (intersection.isEmpty() == false) {_            final String message = String.format(_                    Locale.ROOT,_                    "found duplicate remote cluster configurations for cluster alias%s [%s]",_                    intersection.size() == 1 ? "" : "es",_                    String.join(",", intersection))__            throw new IllegalArgumentException(message)__        }_        return Stream_                .concat(remoteSeeds.entrySet().stream(), searchRemoteSeeds.entrySet().stream())_                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue))__    };builds,the,dynamic,per,cluster,config,from,the,given,settings,this,is,a,map,keyed,by,the,cluster,alias,that,points,to,a,tuple,proxy,addresss,seed,node,suppliers,if,a,cluster,is,configured,with,a,proxy,address,all,seed,nodes,will,point,to,link,transport,address,and,their,configured,address,will,be,used,as,the,hostname,for,the,generated,discovery,node;protected,static,map,string,tuple,string,list,supplier,discovery,node,build,remote,clusters,dynamic,config,settings,settings,final,map,string,tuple,string,list,supplier,discovery,node,remote,seeds,build,remote,clusters,dynamic,config,settings,final,map,string,tuple,string,list,supplier,discovery,node,search,remote,seeds,build,remote,clusters,dynamic,config,settings,final,navigable,set,string,intersection,new,tree,set,arrays,as,list,search,remote,seeds,key,set,stream,filter,s,remote,seeds,key,set,contains,s,sorted,to,array,string,new,if,intersection,is,empty,false,final,string,message,string,format,locale,root,found,duplicate,remote,cluster,configurations,for,cluster,alias,s,s,intersection,size,1,es,string,join,intersection,throw,new,illegal,argument,exception,message,return,stream,concat,remote,seeds,entry,set,stream,search,remote,seeds,entry,set,stream,collect,collectors,to,map,map,entry,get,key,map,entry,get,value
RemoteClusterAware -> protected static Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> buildRemoteClustersDynamicConfig(Settings settings);1542402632;Builds the dynamic per-cluster config from the given settings. This is a map keyed by the cluster alias that points to a tuple_(ProxyAddresss, [SeedNodeSuppliers]). If a cluster is configured with a proxy address all seed nodes will point to_{@link TransportAddress#META_ADDRESS} and their configured address will be used as the hostname for the generated discovery node.;protected static Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> buildRemoteClustersDynamicConfig(Settings settings) {_        final Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> remoteSeeds =_                buildRemoteClustersDynamicConfig(settings, REMOTE_CLUSTERS_SEEDS)__        final Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> searchRemoteSeeds =_                buildRemoteClustersDynamicConfig(settings, SEARCH_REMOTE_CLUSTERS_SEEDS)__        _        final NavigableSet<String> intersection =_                new TreeSet<>(Arrays.asList(_                        searchRemoteSeeds.keySet().stream().filter(s -> remoteSeeds.keySet().contains(s)).sorted().toArray(String[]::new)))__        if (intersection.isEmpty() == false) {_            final String message = String.format(_                    Locale.ROOT,_                    "found duplicate remote cluster configurations for cluster alias%s [%s]",_                    intersection.size() == 1 ? "" : "es",_                    String.join(",", intersection))__            throw new IllegalArgumentException(message)__        }_        return Stream_                .concat(remoteSeeds.entrySet().stream(), searchRemoteSeeds.entrySet().stream())_                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue))__    };builds,the,dynamic,per,cluster,config,from,the,given,settings,this,is,a,map,keyed,by,the,cluster,alias,that,points,to,a,tuple,proxy,addresss,seed,node,suppliers,if,a,cluster,is,configured,with,a,proxy,address,all,seed,nodes,will,point,to,link,transport,address,and,their,configured,address,will,be,used,as,the,hostname,for,the,generated,discovery,node;protected,static,map,string,tuple,string,list,supplier,discovery,node,build,remote,clusters,dynamic,config,settings,settings,final,map,string,tuple,string,list,supplier,discovery,node,remote,seeds,build,remote,clusters,dynamic,config,settings,final,map,string,tuple,string,list,supplier,discovery,node,search,remote,seeds,build,remote,clusters,dynamic,config,settings,final,navigable,set,string,intersection,new,tree,set,arrays,as,list,search,remote,seeds,key,set,stream,filter,s,remote,seeds,key,set,contains,s,sorted,to,array,string,new,if,intersection,is,empty,false,final,string,message,string,format,locale,root,found,duplicate,remote,cluster,configurations,for,cluster,alias,s,s,intersection,size,1,es,string,join,intersection,throw,new,illegal,argument,exception,message,return,stream,concat,remote,seeds,entry,set,stream,search,remote,seeds,entry,set,stream,collect,collectors,to,map,map,entry,get,key,map,entry,get,value
RemoteClusterAware -> protected static Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> buildRemoteClustersDynamicConfig(Settings settings);1543959410;Builds the dynamic per-cluster config from the given settings. This is a map keyed by the cluster alias that points to a tuple_(ProxyAddresss, [SeedNodeSuppliers]). If a cluster is configured with a proxy address all seed nodes will point to_{@link TransportAddress#META_ADDRESS} and their configured address will be used as the hostname for the generated discovery node.;protected static Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> buildRemoteClustersDynamicConfig(Settings settings) {_        final Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> remoteSeeds =_                buildRemoteClustersDynamicConfig(settings, REMOTE_CLUSTERS_SEEDS)__        final Map<String, Tuple<String, List<Supplier<DiscoveryNode>>>> searchRemoteSeeds =_                buildRemoteClustersDynamicConfig(settings, SEARCH_REMOTE_CLUSTERS_SEEDS)__        _        final NavigableSet<String> intersection =_                new TreeSet<>(Arrays.asList(_                        searchRemoteSeeds.keySet().stream().filter(s -> remoteSeeds.keySet().contains(s)).sorted().toArray(String[]::new)))__        if (intersection.isEmpty() == false) {_            final String message = String.format(_                    Locale.ROOT,_                    "found duplicate remote cluster configurations for cluster alias%s [%s]",_                    intersection.size() == 1 ? "" : "es",_                    String.join(",", intersection))__            throw new IllegalArgumentException(message)__        }_        return Stream_                .concat(remoteSeeds.entrySet().stream(), searchRemoteSeeds.entrySet().stream())_                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue))__    };builds,the,dynamic,per,cluster,config,from,the,given,settings,this,is,a,map,keyed,by,the,cluster,alias,that,points,to,a,tuple,proxy,addresss,seed,node,suppliers,if,a,cluster,is,configured,with,a,proxy,address,all,seed,nodes,will,point,to,link,transport,address,and,their,configured,address,will,be,used,as,the,hostname,for,the,generated,discovery,node;protected,static,map,string,tuple,string,list,supplier,discovery,node,build,remote,clusters,dynamic,config,settings,settings,final,map,string,tuple,string,list,supplier,discovery,node,remote,seeds,build,remote,clusters,dynamic,config,settings,final,map,string,tuple,string,list,supplier,discovery,node,search,remote,seeds,build,remote,clusters,dynamic,config,settings,final,navigable,set,string,intersection,new,tree,set,arrays,as,list,search,remote,seeds,key,set,stream,filter,s,remote,seeds,key,set,contains,s,sorted,to,array,string,new,if,intersection,is,empty,false,final,string,message,string,format,locale,root,found,duplicate,remote,cluster,configurations,for,cluster,alias,s,s,intersection,size,1,es,string,join,intersection,throw,new,illegal,argument,exception,message,return,stream,concat,remote,seeds,entry,set,stream,search,remote,seeds,entry,set,stream,collect,collectors,to,map,map,entry,get,key,map,entry,get,value
RemoteClusterAware -> protected abstract void updateRemoteCluster(String clusterAlias, List<String> addresses, String proxy)_;1535383145;Subclasses must implement this to receive information about updated cluster aliases. If the given address list is_empty the cluster alias is unregistered and should be removed.;protected abstract void updateRemoteCluster(String clusterAlias, List<String> addresses, String proxy)_;subclasses,must,implement,this,to,receive,information,about,updated,cluster,aliases,if,the,given,address,list,is,empty,the,cluster,alias,is,unregistered,and,should,be,removed;protected,abstract,void,update,remote,cluster,string,cluster,alias,list,string,addresses,string,proxy
RemoteClusterAware -> protected abstract void updateRemoteCluster(String clusterAlias, List<String> addresses, String proxy)_;1536218260;Subclasses must implement this to receive information about updated cluster aliases. If the given address list is_empty the cluster alias is unregistered and should be removed.;protected abstract void updateRemoteCluster(String clusterAlias, List<String> addresses, String proxy)_;subclasses,must,implement,this,to,receive,information,about,updated,cluster,aliases,if,the,given,address,list,is,empty,the,cluster,alias,is,unregistered,and,should,be,removed;protected,abstract,void,update,remote,cluster,string,cluster,alias,list,string,addresses,string,proxy
RemoteClusterAware -> protected abstract void updateRemoteCluster(String clusterAlias, List<String> addresses, String proxy)_;1536828374;Subclasses must implement this to receive information about updated cluster aliases. If the given address list is_empty the cluster alias is unregistered and should be removed.;protected abstract void updateRemoteCluster(String clusterAlias, List<String> addresses, String proxy)_;subclasses,must,implement,this,to,receive,information,about,updated,cluster,aliases,if,the,given,address,list,is,empty,the,cluster,alias,is,unregistered,and,should,be,removed;protected,abstract,void,update,remote,cluster,string,cluster,alias,list,string,addresses,string,proxy
RemoteClusterAware -> protected abstract void updateRemoteCluster(String clusterAlias, List<String> addresses, String proxy)_;1538067637;Subclasses must implement this to receive information about updated cluster aliases. If the given address list is_empty the cluster alias is unregistered and should be removed.;protected abstract void updateRemoteCluster(String clusterAlias, List<String> addresses, String proxy)_;subclasses,must,implement,this,to,receive,information,about,updated,cluster,aliases,if,the,given,address,list,is,empty,the,cluster,alias,is,unregistered,and,should,be,removed;protected,abstract,void,update,remote,cluster,string,cluster,alias,list,string,addresses,string,proxy
RemoteClusterAware -> protected abstract void updateRemoteCluster(String clusterAlias, List<String> addresses, String proxy)_;1539796943;Subclasses must implement this to receive information about updated cluster aliases. If the given address list is_empty the cluster alias is unregistered and should be removed.;protected abstract void updateRemoteCluster(String clusterAlias, List<String> addresses, String proxy)_;subclasses,must,implement,this,to,receive,information,about,updated,cluster,aliases,if,the,given,address,list,is,empty,the,cluster,alias,is,unregistered,and,should,be,removed;protected,abstract,void,update,remote,cluster,string,cluster,alias,list,string,addresses,string,proxy
RemoteClusterAware -> protected abstract void updateRemoteCluster(String clusterAlias, List<String> addresses, String proxy)_;1541008027;Subclasses must implement this to receive information about updated cluster aliases. If the given address list is_empty the cluster alias is unregistered and should be removed.;protected abstract void updateRemoteCluster(String clusterAlias, List<String> addresses, String proxy)_;subclasses,must,implement,this,to,receive,information,about,updated,cluster,aliases,if,the,given,address,list,is,empty,the,cluster,alias,is,unregistered,and,should,be,removed;protected,abstract,void,update,remote,cluster,string,cluster,alias,list,string,addresses,string,proxy
RemoteClusterAware -> protected abstract void updateRemoteCluster(String clusterAlias, List<String> addresses, String proxy)_;1541092382;Subclasses must implement this to receive information about updated cluster aliases. If the given address list is_empty the cluster alias is unregistered and should be removed.;protected abstract void updateRemoteCluster(String clusterAlias, List<String> addresses, String proxy)_;subclasses,must,implement,this,to,receive,information,about,updated,cluster,aliases,if,the,given,address,list,is,empty,the,cluster,alias,is,unregistered,and,should,be,removed;protected,abstract,void,update,remote,cluster,string,cluster,alias,list,string,addresses,string,proxy
RemoteClusterAware -> protected abstract void updateRemoteCluster(String clusterAlias, List<String> addresses, String proxy)_;1542402632;Subclasses must implement this to receive information about updated cluster aliases. If the given address list is_empty the cluster alias is unregistered and should be removed.;protected abstract void updateRemoteCluster(String clusterAlias, List<String> addresses, String proxy)_;subclasses,must,implement,this,to,receive,information,about,updated,cluster,aliases,if,the,given,address,list,is,empty,the,cluster,alias,is,unregistered,and,should,be,removed;protected,abstract,void,update,remote,cluster,string,cluster,alias,list,string,addresses,string,proxy
RemoteClusterAware -> protected abstract void updateRemoteCluster(String clusterAlias, List<String> addresses, String proxy)_;1543959410;Subclasses must implement this to receive information about updated cluster aliases. If the given address list is_empty the cluster alias is unregistered and should be removed.;protected abstract void updateRemoteCluster(String clusterAlias, List<String> addresses, String proxy)_;subclasses,must,implement,this,to,receive,information,about,updated,cluster,aliases,if,the,given,address,list,is,empty,the,cluster,alias,is,unregistered,and,should,be,removed;protected,abstract,void,update,remote,cluster,string,cluster,alias,list,string,addresses,string,proxy
RemoteClusterAware -> protected abstract void updateRemoteCluster(String clusterAlias, List<String> addresses, String proxy)_;1545071071;Subclasses must implement this to receive information about updated cluster aliases. If the given address list is_empty the cluster alias is unregistered and should be removed.;protected abstract void updateRemoteCluster(String clusterAlias, List<String> addresses, String proxy)_;subclasses,must,implement,this,to,receive,information,about,updated,cluster,aliases,if,the,given,address,list,is,empty,the,cluster,alias,is,unregistered,and,should,be,removed;protected,abstract,void,update,remote,cluster,string,cluster,alias,list,string,addresses,string,proxy
RemoteClusterAware -> protected abstract void updateRemoteCluster(String clusterAlias, List<String> addresses, String proxy)_;1546600771;Subclasses must implement this to receive information about updated cluster aliases. If the given address list is_empty the cluster alias is unregistered and should be removed.;protected abstract void updateRemoteCluster(String clusterAlias, List<String> addresses, String proxy)_;subclasses,must,implement,this,to,receive,information,about,updated,cluster,aliases,if,the,given,address,list,is,empty,the,cluster,alias,is,unregistered,and,should,be,removed;protected,abstract,void,update,remote,cluster,string,cluster,alias,list,string,addresses,string,proxy
RemoteClusterAware -> protected abstract void updateRemoteCluster(String clusterAlias, List<String> addresses, String proxy)_;1546877578;Subclasses must implement this to receive information about updated cluster aliases. If the given address list is_empty the cluster alias is unregistered and should be removed.;protected abstract void updateRemoteCluster(String clusterAlias, List<String> addresses, String proxy)_;subclasses,must,implement,this,to,receive,information,about,updated,cluster,aliases,if,the,given,address,list,is,empty,the,cluster,alias,is,unregistered,and,should,be,removed;protected,abstract,void,update,remote,cluster,string,cluster,alias,list,string,addresses,string,proxy
RemoteClusterAware -> protected abstract void updateRemoteCluster(String clusterAlias, List<String> addresses, String proxy)_;1549608646;Subclasses must implement this to receive information about updated cluster aliases. If the given address list is_empty the cluster alias is unregistered and should be removed.;protected abstract void updateRemoteCluster(String clusterAlias, List<String> addresses, String proxy)_;subclasses,must,implement,this,to,receive,information,about,updated,cluster,aliases,if,the,given,address,list,is,empty,the,cluster,alias,is,unregistered,and,should,be,removed;protected,abstract,void,update,remote,cluster,string,cluster,alias,list,string,addresses,string,proxy
