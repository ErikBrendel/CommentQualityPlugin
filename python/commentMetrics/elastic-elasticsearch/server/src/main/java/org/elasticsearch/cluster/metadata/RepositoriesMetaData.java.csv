commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Returns list of currently registered repositories  *  * @return list of repositories  */ ;/**  * Returns list of currently registered repositories  *  * @return list of repositories  */ public List<RepositoryMetaData> repositories() {     return this.repositories. }
true;public;1;8;/**  * Returns a repository with a given name or null if such repository doesn't exist  *  * @param name name of repository  * @return repository metadata  */ ;/**  * Returns a repository with a given name or null if such repository doesn't exist  *  * @param name name of repository  * @return repository metadata  */ public RepositoryMetaData repository(String name) {     for (RepositoryMetaData repository : repositories) {         if (name.equals(repository.name())) {             return repository.         }     }     return null. }
false;public;1;10;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     RepositoriesMetaData that = (RepositoriesMetaData) o.     return repositories.equals(that.repositories). }
false;public;0;4;;@Override public int hashCode() {     return repositories.hashCode(). }
true;public;0;4;/**  * {@inheritDoc}  */ ;/**  * {@inheritDoc}  */ @Override public String getWriteableName() {     return TYPE. }
false;public;0;4;;@Override public Version getMinimalSupportedVersion() {     return Version.CURRENT.minimumCompatibilityVersion(). }
false;public,static;1;3;;public static NamedDiff<Custom> readDiffFrom(StreamInput in) throws IOException {     return readDiffFrom(Custom.class, TYPE, in). }
true;public;1;7;/**  * {@inheritDoc}  */ ;/**  * {@inheritDoc}  */ @Override public void writeTo(StreamOutput out) throws IOException {     out.writeVInt(repositories.size()).     for (RepositoryMetaData repository : repositories) {         repository.writeTo(out).     } }
false;public,static;1;42;;public static RepositoriesMetaData fromXContent(XContentParser parser) throws IOException {     XContentParser.Token token.     List<RepositoryMetaData> repository = new ArrayList<>().     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             String name = parser.currentName().             if (parser.nextToken() != XContentParser.Token.START_OBJECT) {                 throw new ElasticsearchParseException("failed to parse repository [{}], expected object", name).             }             String type = null.             Settings settings = Settings.EMPTY.             while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {                 if (token == XContentParser.Token.FIELD_NAME) {                     String currentFieldName = parser.currentName().                     if ("type".equals(currentFieldName)) {                         if (parser.nextToken() != XContentParser.Token.VALUE_STRING) {                             throw new ElasticsearchParseException("failed to parse repository [{}], unknown type", name).                         }                         type = parser.text().                     } else if ("settings".equals(currentFieldName)) {                         if (parser.nextToken() != XContentParser.Token.START_OBJECT) {                             throw new ElasticsearchParseException("failed to parse repository [{}], incompatible params", name).                         }                         settings = Settings.fromXContent(parser).                     } else {                         throw new ElasticsearchParseException("failed to parse repository [{}], unknown field [{}]", name, currentFieldName).                     }                 } else {                     throw new ElasticsearchParseException("failed to parse repository [{}]", name).                 }             }             if (type == null) {                 throw new ElasticsearchParseException("failed to parse repository [{}], missing repository type", name).             }             repository.add(new RepositoryMetaData(name, type, settings)).         } else {             throw new ElasticsearchParseException("failed to parse repositories").         }     }     return new RepositoriesMetaData(repository). }
true;public;2;7;/**  * {@inheritDoc}  */ ;/**  * {@inheritDoc}  */ @Override public XContentBuilder toXContent(XContentBuilder builder, ToXContent.Params params) throws IOException {     for (RepositoryMetaData repository : repositories) {         toXContent(repository, builder, params).     }     return builder. }
false;public;0;4;;@Override public EnumSet<MetaData.XContentContext> context() {     return MetaData.API_AND_GATEWAY. }
true;public,static;3;9;/**  * Serializes information about a single repository  *  * @param repository repository metadata  * @param builder    XContent builder  * @param params     serialization parameters  */ ;/**  * Serializes information about a single repository  *  * @param repository repository metadata  * @param builder    XContent builder  * @param params     serialization parameters  */ public static void toXContent(RepositoryMetaData repository, XContentBuilder builder, ToXContent.Params params) throws IOException {     builder.startObject(repository.name()).     builder.field("type", repository.type()).     builder.startObject("settings").     repository.settings().toXContent(builder, params).     builder.endObject().     builder.endObject(). }
