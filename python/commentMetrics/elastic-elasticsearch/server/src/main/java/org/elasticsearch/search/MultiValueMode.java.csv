commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;9;;@Override protected long pick(SortedNumericDocValues values) throws IOException {     final int count = values.docValueCount().     long total = 0.     for (int index = 0. index < count. ++index) {         total += values.nextValue().     }     return total. }
false;protected;6;21;;@Override protected long pick(SortedNumericDocValues values, long missingValue, DocIdSetIterator docItr, int startDoc, int endDoc, int maxChildren) throws IOException {     int totalCount = 0.     long totalValue = 0.     int count = 0.     for (int doc = startDoc. doc < endDoc. doc = docItr.nextDoc()) {         if (values.advanceExact(doc)) {             if (++count > maxChildren) {                 break.             }             final int docCount = values.docValueCount().             for (int index = 0. index < docCount. ++index) {                 totalValue += values.nextValue().             }             totalCount += docCount.         }     }     return totalCount > 0 ? totalValue : missingValue. }
false;protected;1;9;;@Override protected double pick(SortedNumericDoubleValues values) throws IOException {     final int count = values.docValueCount().     double total = 0.     for (int index = 0. index < count. ++index) {         total += values.nextValue().     }     return total. }
false;protected;6;21;;@Override protected double pick(SortedNumericDoubleValues values, double missingValue, DocIdSetIterator docItr, int startDoc, int endDoc, int maxChildren) throws IOException {     int totalCount = 0.     double totalValue = 0.     int count = 0.     for (int doc = startDoc. doc < endDoc. doc = docItr.nextDoc()) {         if (values.advanceExact(doc)) {             if (++count > maxChildren) {                 break.             }             final int docCount = values.docValueCount().             for (int index = 0. index < docCount. ++index) {                 totalValue += values.nextValue().             }             totalCount += docCount.         }     }     return totalCount > 0 ? totalValue : missingValue. }
false;protected;1;9;;@Override protected long pick(SortedNumericDocValues values) throws IOException {     final int count = values.docValueCount().     long total = 0.     for (int index = 0. index < count. ++index) {         total += values.nextValue().     }     return count > 1 ? Math.round((double) total / (double) count) : total. }
false;protected;6;23;;@Override protected long pick(SortedNumericDocValues values, long missingValue, DocIdSetIterator docItr, int startDoc, int endDoc, int maxChildren) throws IOException {     int totalCount = 0.     long totalValue = 0.     int count = 0.     for (int doc = startDoc. doc < endDoc. doc = docItr.nextDoc()) {         if (values.advanceExact(doc)) {             if (++count > maxChildren) {                 break.             }             final int docCount = values.docValueCount().             for (int index = 0. index < docCount. ++index) {                 totalValue += values.nextValue().             }             totalCount += docCount.         }     }     if (totalCount < 1) {         return missingValue.     }     return totalCount > 1 ? Math.round((double) totalValue / (double) totalCount) : totalValue. }
false;protected;1;9;;@Override protected double pick(SortedNumericDoubleValues values) throws IOException {     final int count = values.docValueCount().     double total = 0.     for (int index = 0. index < count. ++index) {         total += values.nextValue().     }     return total / count. }
false;protected;6;23;;@Override protected double pick(SortedNumericDoubleValues values, double missingValue, DocIdSetIterator docItr, int startDoc, int endDoc, int maxChildren) throws IOException {     int totalCount = 0.     double totalValue = 0.     int count = 0.     for (int doc = startDoc. doc < endDoc. doc = docItr.nextDoc()) {         if (values.advanceExact(doc)) {             if (++count > maxChildren) {                 break.             }             final int docCount = values.docValueCount().             for (int index = 0. index < docCount. ++index) {                 totalValue += values.nextValue().             }             totalCount += docCount.         }     }     if (totalCount < 1) {         return missingValue.     }     return totalValue / totalCount. }
false;protected;1;12;;@Override protected long pick(SortedNumericDocValues values) throws IOException {     int count = values.docValueCount().     for (int i = 0. i < (count - 1) / 2. ++i) {         values.nextValue().     }     if (count % 2 == 0) {         return Math.round(((double) values.nextValue() + values.nextValue()) / 2).     } else {         return values.nextValue().     } }
false;protected;1;12;;@Override protected double pick(SortedNumericDoubleValues values) throws IOException {     int count = values.docValueCount().     for (int i = 0. i < (count - 1) / 2. ++i) {         values.nextValue().     }     if (count % 2 == 0) {         return (values.nextValue() + values.nextValue()) / 2.     } else {         return values.nextValue().     } }
false;protected;1;4;;@Override protected long pick(SortedNumericDocValues values) throws IOException {     return values.nextValue(). }
false;protected;6;17;;@Override protected long pick(SortedNumericDocValues values, long missingValue, DocIdSetIterator docItr, int startDoc, int endDoc, int maxChildren) throws IOException {     boolean hasValue = false.     long minValue = Long.MAX_VALUE.     int count = 0.     for (int doc = startDoc. doc < endDoc. doc = docItr.nextDoc()) {         if (values.advanceExact(doc)) {             if (++count > maxChildren) {                 break.             }             minValue = Math.min(minValue, values.nextValue()).             hasValue = true.         }     }     return hasValue ? minValue : missingValue. }
false;protected;1;4;;@Override protected double pick(SortedNumericDoubleValues values) throws IOException {     return values.nextValue(). }
false;protected;6;17;;@Override protected double pick(SortedNumericDoubleValues values, double missingValue, DocIdSetIterator docItr, int startDoc, int endDoc, int maxChildren) throws IOException {     boolean hasValue = false.     double minValue = Double.POSITIVE_INFINITY.     int count = 0.     for (int doc = startDoc. doc < endDoc. doc = docItr.nextDoc()) {         if (values.advanceExact(doc)) {             if (++count > maxChildren) {                 break.             }             minValue = Math.min(minValue, values.nextValue()).             hasValue = true.         }     }     return hasValue ? minValue : missingValue. }
false;protected;1;4;;@Override protected BytesRef pick(SortedBinaryDocValues values) throws IOException {     return values.nextValue(). }
false;protected;6;24;;@Override protected BytesRef pick(BinaryDocValues values, BytesRefBuilder builder, DocIdSetIterator docItr, int startDoc, int endDoc, int maxChildren) throws IOException {     BytesRefBuilder bytesRefBuilder = null.     int count = 0.     for (int doc = startDoc. doc < endDoc. doc = docItr.nextDoc()) {         if (values.advanceExact(doc)) {             if (++count > maxChildren) {                 break.             }             final BytesRef innerValue = values.binaryValue().             if (bytesRefBuilder == null) {                 builder.copyBytes(innerValue).                 bytesRefBuilder = builder.             } else {                 final BytesRef min = bytesRefBuilder.get().compareTo(innerValue) <= 0 ? bytesRefBuilder.get() : innerValue.                 if (min == innerValue) {                     bytesRefBuilder.copyBytes(min).                 }             }         }     }     return bytesRefBuilder == null ? null : bytesRefBuilder.get(). }
false;protected;1;4;;@Override protected int pick(SortedSetDocValues values) throws IOException {     return Math.toIntExact(values.nextOrd()). }
false;protected;5;18;;@Override protected int pick(SortedDocValues values, DocIdSetIterator docItr, int startDoc, int endDoc, int maxChildren) throws IOException {     int ord = Integer.MAX_VALUE.     boolean hasValue = false.     int count = 0.     for (int doc = startDoc. doc < endDoc. doc = docItr.nextDoc()) {         if (values.advanceExact(doc)) {             if (++count > maxChildren) {                 break.             }             final int innerOrd = values.ordValue().             ord = Math.min(ord, innerOrd).             hasValue = true.         }     }     return hasValue ? ord : -1. }
false;protected;1;8;;@Override protected long pick(SortedNumericDocValues values) throws IOException {     final int count = values.docValueCount().     for (int i = 0. i < count - 1. ++i) {         values.nextValue().     }     return values.nextValue(). }
false;protected;6;21;;@Override protected long pick(SortedNumericDocValues values, long missingValue, DocIdSetIterator docItr, int startDoc, int endDoc, int maxChildren) throws IOException {     boolean hasValue = false.     long maxValue = Long.MIN_VALUE.     int count = 0.     for (int doc = startDoc. doc < endDoc. doc = docItr.nextDoc()) {         if (values.advanceExact(doc)) {             if (++count > maxChildren) {                 break.             }             final int docCount = values.docValueCount().             for (int i = 0. i < docCount - 1. ++i) {                 values.nextValue().             }             maxValue = Math.max(maxValue, values.nextValue()).             hasValue = true.         }     }     return hasValue ? maxValue : missingValue. }
false;protected;1;8;;@Override protected double pick(SortedNumericDoubleValues values) throws IOException {     final int count = values.docValueCount().     for (int i = 0. i < count - 1. ++i) {         values.nextValue().     }     return values.nextValue(). }
false;protected;6;21;;@Override protected double pick(SortedNumericDoubleValues values, double missingValue, DocIdSetIterator docItr, int startDoc, int endDoc, int maxChildren) throws IOException {     boolean hasValue = false.     double maxValue = Double.NEGATIVE_INFINITY.     int count = 0.     for (int doc = startDoc. doc < endDoc. doc = docItr.nextDoc()) {         if (values.advanceExact(doc)) {             if (++count > maxChildren) {                 break.             }             final int docCount = values.docValueCount().             for (int i = 0. i < docCount - 1. ++i) {                 values.nextValue().             }             maxValue = Math.max(maxValue, values.nextValue()).             hasValue = true.         }     }     return hasValue ? maxValue : missingValue. }
false;protected;1;8;;@Override protected BytesRef pick(SortedBinaryDocValues values) throws IOException {     int count = values.docValueCount().     for (int i = 0. i < count - 1. ++i) {         values.nextValue().     }     return values.nextValue(). }
false;protected;6;24;;@Override protected BytesRef pick(BinaryDocValues values, BytesRefBuilder builder, DocIdSetIterator docItr, int startDoc, int endDoc, int maxChildren) throws IOException {     BytesRefBuilder bytesRefBuilder = null.     int count = 0.     for (int doc = startDoc. doc < endDoc. doc = docItr.nextDoc()) {         if (values.advanceExact(doc)) {             if (++count > maxChildren) {                 break.             }             final BytesRef innerValue = values.binaryValue().             if (bytesRefBuilder == null) {                 builder.copyBytes(innerValue).                 bytesRefBuilder = builder.             } else {                 final BytesRef max = bytesRefBuilder.get().compareTo(innerValue) > 0 ? bytesRefBuilder.get() : innerValue.                 if (max == innerValue) {                     bytesRefBuilder.copyBytes(max).                 }             }         }     }     return bytesRefBuilder == null ? null : bytesRefBuilder.get(). }
false;protected;1;8;;@Override protected int pick(SortedSetDocValues values) throws IOException {     long maxOrd = -1.     for (long ord = values.nextOrd(). ord != SortedSetDocValues.NO_MORE_ORDS. ord = values.nextOrd()) {         maxOrd = ord.     }     return Math.toIntExact(maxOrd). }
false;protected;5;14;;@Override protected int pick(SortedDocValues values, DocIdSetIterator docItr, int startDoc, int endDoc, int maxChildren) throws IOException {     int ord = -1.     int count = 0.     for (int doc = startDoc. doc < endDoc. doc = docItr.nextDoc()) {         if (values.advanceExact(doc)) {             if (++count > maxChildren) {                 break.             }             ord = Math.max(ord, values.ordValue()).         }     }     return ord. }
true;public,static;1;7;/**  * A case insensitive version of {@link #valueOf(String)}  *  * @throws IllegalArgumentException if the given string doesn't match a sort mode or is <code>null</code>.  */ ;/**  * A case insensitive version of {@link #valueOf(String)}  *  * @throws IllegalArgumentException if the given string doesn't match a sort mode or is <code>null</code>.  */ public static MultiValueMode fromString(String sortMode) {     try {         return valueOf(sortMode.toUpperCase(Locale.ROOT)).     } catch (Exception e) {         throw new IllegalArgumentException("Illegal sort mode: " + sortMode).     } }
false;public;1;8;;@Override public boolean advanceExact(int target) throws IOException {     if (values.advanceExact(target)) {         value = pick(values).         return true.     }     return false. }
false;public;0;4;;@Override public int docID() {     return values.docID(). }
false;public;0;4;;@Override public long longValue() throws IOException {     return value. }
true;public;1;30;/**  * Return a {@link NumericDocValues} instance that can be used to sort documents  * with this mode and the provided values. When a document has no value,  * <code>missingValue</code> is returned.  *  * Allowed Modes: SUM, AVG, MEDIAN, MIN, MAX  */ ;/**  * Return a {@link NumericDocValues} instance that can be used to sort documents  * with this mode and the provided values. When a document has no value,  * <code>missingValue</code> is returned.  *  * Allowed Modes: SUM, AVG, MEDIAN, MIN, MAX  */ public NumericDocValues select(final SortedNumericDocValues values) {     final NumericDocValues singleton = DocValues.unwrapSingleton(values).     if (singleton != null) {         return singleton.     } else {         return new AbstractNumericDocValues() {              private long value.              @Override             public boolean advanceExact(int target) throws IOException {                 if (values.advanceExact(target)) {                     value = pick(values).                     return true.                 }                 return false.             }              @Override             public int docID() {                 return values.docID().             }              @Override             public long longValue() throws IOException {                 return value.             }         }.     } }
false;protected;1;3;;protected long pick(SortedNumericDocValues values) throws IOException {     throw new IllegalArgumentException("Unsupported sort mode: " + this). }
false;public;1;21;;@Override public boolean advanceExact(int parentDoc) throws IOException {     assert parentDoc >= lastSeenParentDoc : "can only evaluate current and upcoming parent docs".     if (parentDoc == lastSeenParentDoc) {         return true.     } else if (parentDoc == 0) {         lastEmittedValue = missingValue.         return true.     }     final int prevParentDoc = parentDocs.prevSetBit(parentDoc - 1).     final int firstChildDoc.     if (childDocs.docID() > prevParentDoc) {         firstChildDoc = childDocs.docID().     } else {         firstChildDoc = childDocs.advance(prevParentDoc + 1).     }     lastSeenParentDoc = parentDoc.     lastEmittedValue = pick(values, missingValue, childDocs, firstChildDoc, parentDoc, maxChildren).     return true. }
false;public;0;4;;@Override public int docID() {     return lastSeenParentDoc. }
false;public;0;4;;@Override public long longValue() {     return lastEmittedValue. }
true;public;6;44;/**  * Return a {@link NumericDocValues} instance that can be used to sort root documents  * with this mode, the provided values and filters for root/inner documents.  *  * For every root document, the values of its inner documents will be aggregated.  * If none of the inner documents has a value, then <code>missingValue</code> is returned.  *  * Allowed Modes: SUM, AVG, MIN, MAX  *  * NOTE: Calling the returned instance on docs that are not root docs is illegal  *       The returned instance can only be evaluate the current and upcoming docs  */ ;/**  * Return a {@link NumericDocValues} instance that can be used to sort root documents  * with this mode, the provided values and filters for root/inner documents.  *  * For every root document, the values of its inner documents will be aggregated.  * If none of the inner documents has a value, then <code>missingValue</code> is returned.  *  * Allowed Modes: SUM, AVG, MIN, MAX  *  * NOTE: Calling the returned instance on docs that are not root docs is illegal  *       The returned instance can only be evaluate the current and upcoming docs  */ public NumericDocValues select(final SortedNumericDocValues values, final long missingValue, final BitSet parentDocs, final DocIdSetIterator childDocs, int maxDoc, int maxChildren) throws IOException {     if (parentDocs == null || childDocs == null) {         return FieldData.replaceMissing(DocValues.emptyNumeric(), missingValue).     }     return new AbstractNumericDocValues() {          int lastSeenParentDoc = -1.          long lastEmittedValue = missingValue.          @Override         public boolean advanceExact(int parentDoc) throws IOException {             assert parentDoc >= lastSeenParentDoc : "can only evaluate current and upcoming parent docs".             if (parentDoc == lastSeenParentDoc) {                 return true.             } else if (parentDoc == 0) {                 lastEmittedValue = missingValue.                 return true.             }             final int prevParentDoc = parentDocs.prevSetBit(parentDoc - 1).             final int firstChildDoc.             if (childDocs.docID() > prevParentDoc) {                 firstChildDoc = childDocs.docID().             } else {                 firstChildDoc = childDocs.advance(prevParentDoc + 1).             }             lastSeenParentDoc = parentDoc.             lastEmittedValue = pick(values, missingValue, childDocs, firstChildDoc, parentDoc, maxChildren).             return true.         }          @Override         public int docID() {             return lastSeenParentDoc.         }          @Override         public long longValue() {             return lastEmittedValue.         }     }. }
false;protected;6;4;;protected long pick(SortedNumericDocValues values, long missingValue, DocIdSetIterator docItr, int startDoc, int endDoc, int maxChildren) throws IOException {     throw new IllegalArgumentException("Unsupported sort mode: " + this). }
false;public;1;8;;@Override public boolean advanceExact(int target) throws IOException {     if (values.advanceExact(target)) {         value = pick(values).         return true.     }     return false. }
false;public;0;4;;@Override public double doubleValue() throws IOException {     return this.value. }
true;public;1;25;/**  * Return a {@link NumericDoubleValues} instance that can be used to sort documents  * with this mode and the provided values. When a document has no value,  * <code>missingValue</code> is returned.  *  * Allowed Modes: SUM, AVG, MEDIAN, MIN, MAX  */ ;/**  * Return a {@link NumericDoubleValues} instance that can be used to sort documents  * with this mode and the provided values. When a document has no value,  * <code>missingValue</code> is returned.  *  * Allowed Modes: SUM, AVG, MEDIAN, MIN, MAX  */ public NumericDoubleValues select(final SortedNumericDoubleValues values) {     final NumericDoubleValues singleton = FieldData.unwrapSingleton(values).     if (singleton != null) {         return singleton.     } else {         return new NumericDoubleValues() {              private double value.              @Override             public boolean advanceExact(int target) throws IOException {                 if (values.advanceExact(target)) {                     value = pick(values).                     return true.                 }                 return false.             }              @Override             public double doubleValue() throws IOException {                 return this.value.             }         }.     } }
false;protected;1;3;;protected double pick(SortedNumericDoubleValues values) throws IOException {     throw new IllegalArgumentException("Unsupported sort mode: " + this). }
false;public;1;18;;@Override public boolean advanceExact(int parentDoc) throws IOException {     assert parentDoc >= lastSeenParentDoc : "can only evaluate current and upcoming parent docs".     if (parentDoc == lastSeenParentDoc) {         return true.     }     final int prevParentDoc = parentDocs.prevSetBit(parentDoc - 1).     final int firstChildDoc.     if (childDocs.docID() > prevParentDoc) {         firstChildDoc = childDocs.docID().     } else {         firstChildDoc = childDocs.advance(prevParentDoc + 1).     }     lastSeenParentDoc = parentDoc.     lastEmittedValue = pick(values, missingValue, childDocs, firstChildDoc, parentDoc, maxChildren).     return true. }
false;public;0;4;;@Override public double doubleValue() throws IOException {     return lastEmittedValue. }
true;public;6;36;/**  * Return a {@link NumericDoubleValues} instance that can be used to sort root documents  * with this mode, the provided values and filters for root/inner documents.  *  * For every root document, the values of its inner documents will be aggregated.  * If none of the inner documents has a value, then <code>missingValue</code> is returned.  *  * Allowed Modes: SUM, AVG, MIN, MAX  *  * NOTE: Calling the returned instance on docs that are not root docs is illegal  *       The returned instance can only be evaluate the current and upcoming docs  */ ;/**  * Return a {@link NumericDoubleValues} instance that can be used to sort root documents  * with this mode, the provided values and filters for root/inner documents.  *  * For every root document, the values of its inner documents will be aggregated.  * If none of the inner documents has a value, then <code>missingValue</code> is returned.  *  * Allowed Modes: SUM, AVG, MIN, MAX  *  * NOTE: Calling the returned instance on docs that are not root docs is illegal  *       The returned instance can only be evaluate the current and upcoming docs  */ public NumericDoubleValues select(final SortedNumericDoubleValues values, final double missingValue, final BitSet parentDocs, final DocIdSetIterator childDocs, int maxDoc, int maxChildren) throws IOException {     if (parentDocs == null || childDocs == null) {         return FieldData.replaceMissing(FieldData.emptyNumericDouble(), missingValue).     }     return new NumericDoubleValues() {          int lastSeenParentDoc = 0.          double lastEmittedValue = missingValue.          @Override         public boolean advanceExact(int parentDoc) throws IOException {             assert parentDoc >= lastSeenParentDoc : "can only evaluate current and upcoming parent docs".             if (parentDoc == lastSeenParentDoc) {                 return true.             }             final int prevParentDoc = parentDocs.prevSetBit(parentDoc - 1).             final int firstChildDoc.             if (childDocs.docID() > prevParentDoc) {                 firstChildDoc = childDocs.docID().             } else {                 firstChildDoc = childDocs.advance(prevParentDoc + 1).             }             lastSeenParentDoc = parentDoc.             lastEmittedValue = pick(values, missingValue, childDocs, firstChildDoc, parentDoc, maxChildren).             return true.         }          @Override         public double doubleValue() throws IOException {             return lastEmittedValue.         }     }. }
false;protected;6;4;;protected double pick(SortedNumericDoubleValues values, double missingValue, DocIdSetIterator docItr, int startDoc, int endDoc, int maxChildren) throws IOException {     throw new IllegalArgumentException("Unsupported sort mode: " + this). }
false;public;1;10;;@Override public boolean advanceExact(int target) throws IOException {     if (values.advanceExact(target)) {         value = pick(values).         return true.     } else {         value = missingValue.         return missingValue != null.     } }
false;public;0;4;;@Override public BytesRef binaryValue() throws IOException {     return value. }
false;public;1;5;;@Override public boolean advanceExact(int target) throws IOException {     this.value = singleton.advanceExact(target) ? singleton.binaryValue() : missingValue.     return true. }
false;public;0;4;;@Override public BytesRef binaryValue() throws IOException {     return this.value. }
true;public;2;44;/**  * Return a {@link BinaryDocValues} instance that can be used to sort documents  * with this mode and the provided values. When a document has no value,  * <code>missingValue</code> is returned.  *  * Allowed Modes: MIN, MAX  */ ;/**  * Return a {@link BinaryDocValues} instance that can be used to sort documents  * with this mode and the provided values. When a document has no value,  * <code>missingValue</code> is returned.  *  * Allowed Modes: MIN, MAX  */ public BinaryDocValues select(final SortedBinaryDocValues values, final BytesRef missingValue) {     final BinaryDocValues singleton = FieldData.unwrapSingleton(values).     if (singleton != null) {         if (missingValue == null) {             return singleton.         }         return new AbstractBinaryDocValues() {              private BytesRef value.              @Override             public boolean advanceExact(int target) throws IOException {                 this.value = singleton.advanceExact(target) ? singleton.binaryValue() : missingValue.                 return true.             }              @Override             public BytesRef binaryValue() throws IOException {                 return this.value.             }         }.     } else {         return new AbstractBinaryDocValues() {              private BytesRef value.              @Override             public boolean advanceExact(int target) throws IOException {                 if (values.advanceExact(target)) {                     value = pick(values).                     return true.                 } else {                     value = missingValue.                     return missingValue != null.                 }             }              @Override             public BytesRef binaryValue() throws IOException {                 return value.             }         }.     } }
false;protected;1;3;;protected BytesRef pick(SortedBinaryDocValues values) throws IOException {     throw new IllegalArgumentException("Unsupported sort mode: " + this). }
false;public;1;22;;@Override public boolean advanceExact(int parentDoc) throws IOException {     assert parentDoc >= lastSeenParentDoc : "can only evaluate current and upcoming root docs".     if (parentDoc == lastSeenParentDoc) {         return true.     }     final int prevParentDoc = parentDocs.prevSetBit(parentDoc - 1).     final int firstChildDoc.     if (childDocs.docID() > prevParentDoc) {         firstChildDoc = childDocs.docID().     } else {         firstChildDoc = childDocs.advance(prevParentDoc + 1).     }     lastSeenParentDoc = parentDoc.     lastEmittedValue = pick(selectedValues, builder, childDocs, firstChildDoc, parentDoc, maxChildren).     if (lastEmittedValue == null) {         lastEmittedValue = missingValue.     }     return true. }
false;public;0;4;;@Override public BytesRef binaryValue() throws IOException {     return lastEmittedValue. }
true;public;6;43;/**  * Return a {@link BinaryDocValues} instance that can be used to sort root documents  * with this mode, the provided values and filters for root/inner documents.  *  * For every root document, the values of its inner documents will be aggregated.  * If none of the inner documents has a value, then <code>missingValue</code> is returned.  *  * Allowed Modes: MIN, MAX  *  * NOTE: Calling the returned instance on docs that are not root docs is illegal  *       The returned instance can only be evaluate the current and upcoming docs  */ ;/**  * Return a {@link BinaryDocValues} instance that can be used to sort root documents  * with this mode, the provided values and filters for root/inner documents.  *  * For every root document, the values of its inner documents will be aggregated.  * If none of the inner documents has a value, then <code>missingValue</code> is returned.  *  * Allowed Modes: MIN, MAX  *  * NOTE: Calling the returned instance on docs that are not root docs is illegal  *       The returned instance can only be evaluate the current and upcoming docs  */ public BinaryDocValues select(final SortedBinaryDocValues values, final BytesRef missingValue, final BitSet parentDocs, final DocIdSetIterator childDocs, int maxDoc, int maxChildren) throws IOException {     if (parentDocs == null || childDocs == null) {         return select(FieldData.emptySortedBinary(), missingValue).     }     final BinaryDocValues selectedValues = select(values, null).     return new AbstractBinaryDocValues() {          final BytesRefBuilder builder = new BytesRefBuilder().          int lastSeenParentDoc = 0.          BytesRef lastEmittedValue = missingValue.          @Override         public boolean advanceExact(int parentDoc) throws IOException {             assert parentDoc >= lastSeenParentDoc : "can only evaluate current and upcoming root docs".             if (parentDoc == lastSeenParentDoc) {                 return true.             }             final int prevParentDoc = parentDocs.prevSetBit(parentDoc - 1).             final int firstChildDoc.             if (childDocs.docID() > prevParentDoc) {                 firstChildDoc = childDocs.docID().             } else {                 firstChildDoc = childDocs.advance(prevParentDoc + 1).             }             lastSeenParentDoc = parentDoc.             lastEmittedValue = pick(selectedValues, builder, childDocs, firstChildDoc, parentDoc, maxChildren).             if (lastEmittedValue == null) {                 lastEmittedValue = missingValue.             }             return true.         }          @Override         public BytesRef binaryValue() throws IOException {             return lastEmittedValue.         }     }. }
false;protected;6;4;;protected BytesRef pick(BinaryDocValues values, BytesRefBuilder builder, DocIdSetIterator docItr, int startDoc, int endDoc, int maxChildren) throws IOException {     throw new IllegalArgumentException("Unsupported sort mode: " + this). }
false;public;1;10;;@Override public boolean advanceExact(int target) throws IOException {     if (values.advanceExact(target)) {         ord = pick(values).         return true.     } else {         ord = -1.         return false.     } }
false;public;0;4;;@Override public int docID() {     return values.docID(). }
false;public;0;5;;@Override public int ordValue() {     assert ord != -1.     return ord. }
false;public;1;4;;@Override public BytesRef lookupOrd(int ord) throws IOException {     return values.lookupOrd(ord). }
false;public;0;4;;@Override public int getValueCount() {     return (int) values.getValueCount(). }
true;public;1;48;/**  * Return a {@link SortedDocValues} instance that can be used to sort documents  * with this mode and the provided values.  *  * Allowed Modes: MIN, MAX  */ ;/**  * Return a {@link SortedDocValues} instance that can be used to sort documents  * with this mode and the provided values.  *  * Allowed Modes: MIN, MAX  */ public SortedDocValues select(final SortedSetDocValues values) {     if (values.getValueCount() >= Integer.MAX_VALUE) {         throw new UnsupportedOperationException("fields containing more than " + (Integer.MAX_VALUE - 1) + " unique terms are unsupported").     }     final SortedDocValues singleton = DocValues.unwrapSingleton(values).     if (singleton != null) {         return singleton.     } else {         return new AbstractSortedDocValues() {              int ord.              @Override             public boolean advanceExact(int target) throws IOException {                 if (values.advanceExact(target)) {                     ord = pick(values).                     return true.                 } else {                     ord = -1.                     return false.                 }             }              @Override             public int docID() {                 return values.docID().             }              @Override             public int ordValue() {                 assert ord != -1.                 return ord.             }              @Override             public BytesRef lookupOrd(int ord) throws IOException {                 return values.lookupOrd(ord).             }              @Override             public int getValueCount() {                 return (int) values.getValueCount().             }         }.     } }
false;protected;1;3;;protected int pick(SortedSetDocValues values) throws IOException {     throw new IllegalArgumentException("Unsupported sort mode: " + this). }
false;public;1;4;;@Override public BytesRef lookupOrd(int ord) throws IOException {     return selectedValues.lookupOrd(ord). }
false;public;0;4;;@Override public int getValueCount() {     return selectedValues.getValueCount(). }
false;public;1;19;;@Override public boolean advanceExact(int parentDoc) throws IOException {     assert parentDoc >= lastSeenParentDoc : "can only evaluate current and upcoming root docs".     if (parentDoc == lastSeenParentDoc) {         return lastEmittedOrd != -1.     }     final int prevParentDoc = parentDocs.prevSetBit(parentDoc - 1).     final int firstChildDoc.     if (childDocs.docID() > prevParentDoc) {         firstChildDoc = childDocs.docID().     } else {         firstChildDoc = childDocs.advance(prevParentDoc + 1).     }     docID = lastSeenParentDoc = parentDoc.     lastEmittedOrd = pick(selectedValues, childDocs, firstChildDoc, parentDoc, maxChildren).     return lastEmittedOrd != -1. }
false;public;0;4;;@Override public int docID() {     return docID. }
false;public;0;4;;@Override public int ordValue() {     return lastEmittedOrd. }
true;public;4;54;/**  * Return a {@link SortedDocValues} instance that can be used to sort root documents  * with this mode, the provided values and filters for root/inner documents.  *  * For every root document, the values of its inner documents will be aggregated.  *  * Allowed Modes: MIN, MAX  *  * NOTE: Calling the returned instance on docs that are not root docs is illegal  *       The returned instance can only be evaluate the current and upcoming docs  */ ;/**  * Return a {@link SortedDocValues} instance that can be used to sort root documents  * with this mode, the provided values and filters for root/inner documents.  *  * For every root document, the values of its inner documents will be aggregated.  *  * Allowed Modes: MIN, MAX  *  * NOTE: Calling the returned instance on docs that are not root docs is illegal  *       The returned instance can only be evaluate the current and upcoming docs  */ public SortedDocValues select(final SortedSetDocValues values, final BitSet parentDocs, final DocIdSetIterator childDocs, int maxChildren) throws IOException {     if (parentDocs == null || childDocs == null) {         return select(DocValues.emptySortedSet()).     }     final SortedDocValues selectedValues = select(values).     return new AbstractSortedDocValues() {          int docID = -1.          int lastSeenParentDoc = 0.          int lastEmittedOrd = -1.          @Override         public BytesRef lookupOrd(int ord) throws IOException {             return selectedValues.lookupOrd(ord).         }          @Override         public int getValueCount() {             return selectedValues.getValueCount().         }          @Override         public boolean advanceExact(int parentDoc) throws IOException {             assert parentDoc >= lastSeenParentDoc : "can only evaluate current and upcoming root docs".             if (parentDoc == lastSeenParentDoc) {                 return lastEmittedOrd != -1.             }             final int prevParentDoc = parentDocs.prevSetBit(parentDoc - 1).             final int firstChildDoc.             if (childDocs.docID() > prevParentDoc) {                 firstChildDoc = childDocs.docID().             } else {                 firstChildDoc = childDocs.advance(prevParentDoc + 1).             }             docID = lastSeenParentDoc = parentDoc.             lastEmittedOrd = pick(selectedValues, childDocs, firstChildDoc, parentDoc, maxChildren).             return lastEmittedOrd != -1.         }          @Override         public int docID() {             return docID.         }          @Override         public int ordValue() {             return lastEmittedOrd.         }     }. }
false;protected;5;3;;protected int pick(SortedDocValues values, DocIdSetIterator docItr, int startDoc, int endDoc, int maxChildren) throws IOException {     throw new IllegalArgumentException("Unsupported sort mode: " + this). }
false;public;1;4;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeEnum(this). }
false;public,static;1;3;;public static MultiValueMode readMultiValueModeFrom(StreamInput in) throws IOException {     return in.readEnum(MultiValueMode.class). }
