commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;23;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     out.writeString(queryText).     out.writeInt(fieldsAndWeights.size()).     for (Map.Entry<String, Float> entry : fieldsAndWeights.entrySet()) {         out.writeString(entry.getKey()).         out.writeFloat(entry.getValue()).     }     out.writeInt(flags).     out.writeOptionalString(analyzer).     defaultOperator.writeTo(out).     out.writeBoolean(settings.lenient()).     out.writeBoolean(lenientSet).     out.writeBoolean(settings.analyzeWildcard()).     out.writeOptionalString(minimumShouldMatch).     out.writeOptionalString(settings.quoteFieldSuffix()).     if (out.getVersion().onOrAfter(Version.V_6_1_0)) {         out.writeBoolean(settings.autoGenerateSynonymsPhraseQuery()).         out.writeVInt(settings.fuzzyPrefixLength()).         out.writeVInt(settings.fuzzyMaxExpansions()).         out.writeBoolean(settings.fuzzyTranspositions()).     } }
true;public;0;3;/**  * Returns the text to parse the query from.  */ ;/**  * Returns the text to parse the query from.  */ public String value() {     return this.queryText. }
true;public;1;7;/**  * Add a field to run the query against.  */ ;/**  * Add a field to run the query against.  */ public SimpleQueryStringBuilder field(String field) {     if (Strings.isEmpty(field)) {         throw new IllegalArgumentException("supplied field is null or empty").     }     this.fieldsAndWeights.put(field, AbstractQueryBuilder.DEFAULT_BOOST).     return this. }
true;public;2;8;/**  * Add a field to run the query against with a specific boost.  */ ;/**  * Add a field to run the query against with a specific boost.  */ public SimpleQueryStringBuilder field(String field, float boost) {     if (Strings.isEmpty(field)) {         throw new IllegalArgumentException("supplied field is null or empty").     }     checkNegativeBoost(boost).     this.fieldsAndWeights.put(field, boost).     return this. }
true;public;1;8;/**  * Add several fields to run the query against with a specific boost.  */ ;/**  * Add several fields to run the query against with a specific boost.  */ public SimpleQueryStringBuilder fields(Map<String, Float> fields) {     Objects.requireNonNull(fields, "fields cannot be null").     for (float fieldBoost : fields.values()) {         checkNegativeBoost(fieldBoost).     }     this.fieldsAndWeights.putAll(fields).     return this. }
true;public;0;3;/**  * Returns the fields including their respective boosts to run the query against.  */ ;/**  * Returns the fields including their respective boosts to run the query against.  */ public Map<String, Float> fields() {     return this.fieldsAndWeights. }
true;public;1;4;/**  * Specify an analyzer to use for the query.  */ ;/**  * Specify an analyzer to use for the query.  */ public SimpleQueryStringBuilder analyzer(String analyzer) {     this.analyzer = analyzer.     return this. }
true;public;0;3;/**  * Returns the analyzer to use for the query.  */ ;/**  * Returns the analyzer to use for the query.  */ public String analyzer() {     return this.analyzer. }
true;public;1;4;/**  * Specify the default operator for the query. Defaults to "OR" if no  * operator is specified.  */ ;/**  * Specify the default operator for the query. Defaults to "OR" if no  * operator is specified.  */ public SimpleQueryStringBuilder defaultOperator(Operator defaultOperator) {     this.defaultOperator = (defaultOperator != null) ? defaultOperator : DEFAULT_OPERATOR.     return this. }
true;public;0;3;/**  * Returns the default operator for the query.  */ ;/**  * Returns the default operator for the query.  */ public Operator defaultOperator() {     return this.defaultOperator. }
true;public;1;13;/**  * Specify the enabled features of the SimpleQueryString. Defaults to ALL if  * none are specified.  */ ;/**  * Specify the enabled features of the SimpleQueryString. Defaults to ALL if  * none are specified.  */ public SimpleQueryStringBuilder flags(SimpleQueryStringFlag... flags) {     if (flags != null && flags.length > 0) {         int value = 0.         for (SimpleQueryStringFlag flag : flags) {             value |= flag.value.         }         this.flags = value.     } else {         this.flags = DEFAULT_FLAGS.     }     return this. }
true;;1;4;/**  * For testing and serialisation only.  */ ;/**  * For testing and serialisation only.  */ SimpleQueryStringBuilder flags(int flags) {     this.flags = flags.     return this. }
true;;0;3;/**  * For testing only: Return the flags set for this query.  */ ;/**  * For testing only: Return the flags set for this query.  */ int flags() {     return this.flags. }
true;public;1;4;/**  * Set the suffix to append to field names for phrase matching.  */ ;/**  * Set the suffix to append to field names for phrase matching.  */ public SimpleQueryStringBuilder quoteFieldSuffix(String suffix) {     settings.quoteFieldSuffix(suffix).     return this. }
true;public;0;3;/**  * Return the suffix to append to field names for phrase matching.  */ ;/**  * Return the suffix to append to field names for phrase matching.  */ public String quoteFieldSuffix() {     return settings.quoteFieldSuffix(). }
true;public;1;5;/**  * Specifies whether query parsing should be lenient. Defaults to false.  */ ;/**  * Specifies whether query parsing should be lenient. Defaults to false.  */ public SimpleQueryStringBuilder lenient(boolean lenient) {     this.settings.lenient(lenient).     this.lenientSet = true.     return this. }
true;public;0;3;/**  * Returns whether query parsing should be lenient.  */ ;/**  * Returns whether query parsing should be lenient.  */ public boolean lenient() {     return this.settings.lenient(). }
true;public;1;4;/**  * Specifies whether wildcards should be analyzed. Defaults to false.  */ ;/**  * Specifies whether wildcards should be analyzed. Defaults to false.  */ public SimpleQueryStringBuilder analyzeWildcard(boolean analyzeWildcard) {     this.settings.analyzeWildcard(analyzeWildcard).     return this. }
true;public;0;3;/**  * Returns whether wildcards should by analyzed.  */ ;/**  * Returns whether wildcards should by analyzed.  */ public boolean analyzeWildcard() {     return this.settings.analyzeWildcard(). }
true;public;1;4;/**  * Specifies the minimumShouldMatch to apply to the resulting query should  * that be a Boolean query.  */ ;/**  * Specifies the minimumShouldMatch to apply to the resulting query should  * that be a Boolean query.  */ public SimpleQueryStringBuilder minimumShouldMatch(String minimumShouldMatch) {     this.minimumShouldMatch = minimumShouldMatch.     return this. }
true;public;0;3;/**  * Returns the minimumShouldMatch to apply to the resulting query should  * that be a Boolean query.  */ ;/**  * Returns the minimumShouldMatch to apply to the resulting query should  * that be a Boolean query.  */ public String minimumShouldMatch() {     return minimumShouldMatch. }
false;public;1;4;;public SimpleQueryStringBuilder autoGenerateSynonymsPhraseQuery(boolean value) {     this.settings.autoGenerateSynonymsPhraseQuery(value).     return this. }
true;public;0;3;/**  * Whether phrase queries should be automatically generated for multi terms synonyms.  * Defaults to {@code true}.  */ ;/**  * Whether phrase queries should be automatically generated for multi terms synonyms.  * Defaults to {@code true}.  */ public boolean autoGenerateSynonymsPhraseQuery() {     return settings.autoGenerateSynonymsPhraseQuery(). }
false;public;1;4;;public SimpleQueryStringBuilder fuzzyPrefixLength(int fuzzyPrefixLength) {     this.settings.fuzzyPrefixLength(fuzzyPrefixLength).     return this. }
false;public;0;3;;public int fuzzyPrefixLength() {     return settings.fuzzyPrefixLength(). }
false;public;1;4;;public SimpleQueryStringBuilder fuzzyMaxExpansions(int fuzzyMaxExpansions) {     this.settings.fuzzyMaxExpansions(fuzzyMaxExpansions).     return this. }
false;public;0;3;;public int fuzzyMaxExpansions() {     return settings.fuzzyMaxExpansions(). }
false;public;0;3;;public boolean fuzzyTranspositions() {     return settings.fuzzyTranspositions(). }
true;public;1;4;/**  * Sets whether transpositions are supported in fuzzy queries.<p>  * The default metric used by fuzzy queries to determine a match is the Damerau-Levenshtein  * distance formula which supports transpositions. Setting transposition to false will  * switch to classic Levenshtein distance.<br>  * If not set, Damerau-Levenshtein distance metric will be used.  */ ;/**  * Sets whether transpositions are supported in fuzzy queries.<p>  * The default metric used by fuzzy queries to determine a match is the Damerau-Levenshtein  * distance formula which supports transpositions. Setting transposition to false will  * switch to classic Levenshtein distance.<br>  * If not set, Damerau-Levenshtein distance metric will be used.  */ public SimpleQueryStringBuilder fuzzyTranspositions(boolean fuzzyTranspositions) {     this.settings.fuzzyTranspositions(fuzzyTranspositions).     return this. }
false;protected;1;31;;@Override protected Query doToQuery(QueryShardContext context) throws IOException {     Settings newSettings = new Settings(settings).     final Map<String, Float> resolvedFieldsAndWeights.     if (fieldsAndWeights.isEmpty() == false) {         resolvedFieldsAndWeights = QueryParserHelper.resolveMappingFields(context, fieldsAndWeights).     } else {         List<String> defaultFields = context.defaultFields().         boolean isAllField = defaultFields.size() == 1 && Regex.isMatchAllPattern(defaultFields.get(0)).         if (isAllField) {             newSettings.lenient(lenientSet ? settings.lenient() : true).         }         resolvedFieldsAndWeights = QueryParserHelper.resolveMappingFields(context, QueryParserHelper.parseFieldsAndWeights(defaultFields)).     }     final SimpleQueryStringQueryParser sqp.     if (analyzer == null) {         sqp = new SimpleQueryStringQueryParser(resolvedFieldsAndWeights, flags, newSettings, context).     } else {         Analyzer luceneAnalyzer = context.getIndexAnalyzers().get(analyzer).         if (luceneAnalyzer == null) {             throw new QueryShardException(context, "[" + SimpleQueryStringBuilder.NAME + "] analyzer [" + analyzer + "] not found").         }         sqp = new SimpleQueryStringQueryParser(luceneAnalyzer, resolvedFieldsAndWeights, flags, newSettings, context).     }     sqp.setDefaultOperator(defaultOperator.toBooleanClauseOccur()).     Query query = sqp.parse(queryText).     return Queries.maybeApplyMinimumShouldMatch(query, minimumShouldMatch). }
false;protected;2;38;;@Override protected void doXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject(NAME).     builder.field(QUERY_FIELD.getPreferredName(), queryText).     if (fieldsAndWeights.size() > 0) {         builder.startArray(FIELDS_FIELD.getPreferredName()).         for (Map.Entry<String, Float> entry : fieldsAndWeights.entrySet()) {             builder.value(entry.getKey() + "^" + entry.getValue()).         }         builder.endArray().     }     if (analyzer != null) {         builder.field(ANALYZER_FIELD.getPreferredName(), analyzer).     }     builder.field(FLAGS_FIELD.getPreferredName(), flags).     builder.field(DEFAULT_OPERATOR_FIELD.getPreferredName(), defaultOperator.name().toLowerCase(Locale.ROOT)).     if (lenientSet) {         builder.field(LENIENT_FIELD.getPreferredName(), settings.lenient()).     }     builder.field(ANALYZE_WILDCARD_FIELD.getPreferredName(), settings.analyzeWildcard()).     if (settings.quoteFieldSuffix() != null) {         builder.field(QUOTE_FIELD_SUFFIX_FIELD.getPreferredName(), settings.quoteFieldSuffix()).     }     if (minimumShouldMatch != null) {         builder.field(MINIMUM_SHOULD_MATCH_FIELD.getPreferredName(), minimumShouldMatch).     }     builder.field(GENERATE_SYNONYMS_PHRASE_QUERY.getPreferredName(), settings.autoGenerateSynonymsPhraseQuery()).     builder.field(FUZZY_PREFIX_LENGTH_FIELD.getPreferredName(), settings.fuzzyPrefixLength()).     builder.field(FUZZY_MAX_EXPANSIONS_FIELD.getPreferredName(), settings.fuzzyMaxExpansions()).     builder.field(FUZZY_TRANSPOSITIONS_FIELD.getPreferredName(), settings.fuzzyTranspositions()).     printBoostAndQueryName(builder).     builder.endObject(). }
false;public,static;1;108;;public static SimpleQueryStringBuilder fromXContent(XContentParser parser) throws IOException {     String currentFieldName = null.     String queryBody = null.     float boost = AbstractQueryBuilder.DEFAULT_BOOST.     String queryName = null.     String minimumShouldMatch = null.     Map<String, Float> fieldsAndWeights = null.     Operator defaultOperator = null.     String analyzerName = null.     int flags = SimpleQueryStringFlag.ALL.value().     Boolean lenient = null.     boolean analyzeWildcard = SimpleQueryStringBuilder.DEFAULT_ANALYZE_WILDCARD.     String quoteFieldSuffix = null.     boolean autoGenerateSynonymsPhraseQuery = true.     int fuzzyPrefixLenght = SimpleQueryStringBuilder.DEFAULT_FUZZY_PREFIX_LENGTH.     int fuzzyMaxExpansions = SimpleQueryStringBuilder.DEFAULT_FUZZY_MAX_EXPANSIONS.     boolean fuzzyTranspositions = SimpleQueryStringBuilder.DEFAULT_FUZZY_TRANSPOSITIONS.     XContentParser.Token token.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token == XContentParser.Token.START_ARRAY) {             if (FIELDS_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 List<String> fields = new ArrayList<>().                 while (parser.nextToken() != XContentParser.Token.END_ARRAY) {                     fields.add(parser.text()).                 }                 fieldsAndWeights = QueryParserHelper.parseFieldsAndWeights(fields).             } else {                 throw new ParsingException(parser.getTokenLocation(), "[" + SimpleQueryStringBuilder.NAME + "] query does not support [" + currentFieldName + "]").             }         } else if (token.isValue()) {             if (QUERY_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 queryBody = parser.text().             } else if (AbstractQueryBuilder.BOOST_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 boost = parser.floatValue().             } else if (ANALYZER_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 analyzerName = parser.text().             } else if (DEFAULT_OPERATOR_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 defaultOperator = Operator.fromString(parser.text()).             } else if (FLAGS_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 if (parser.currentToken() != XContentParser.Token.VALUE_NUMBER) {                     // Possible options are:                     // ALL, NONE, AND, OR, PREFIX, PHRASE, PRECEDENCE, ESCAPE, WHITESPACE, FUZZY, NEAR, SLOP                     flags = SimpleQueryStringFlag.resolveFlags(parser.text()).                 } else {                     flags = parser.intValue().                     if (flags < 0) {                         flags = SimpleQueryStringFlag.ALL.value().                     }                 }             } else if (LOCALE_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {             // ignore, deprecated setting             } else if (LOWERCASE_EXPANDED_TERMS_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {             // ignore, deprecated setting             } else if (LENIENT_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 lenient = parser.booleanValue().             } else if (ANALYZE_WILDCARD_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 analyzeWildcard = parser.booleanValue().             } else if (AbstractQueryBuilder.NAME_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 queryName = parser.text().             } else if (MINIMUM_SHOULD_MATCH_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 minimumShouldMatch = parser.textOrNull().             } else if (QUOTE_FIELD_SUFFIX_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 quoteFieldSuffix = parser.textOrNull().             } else if (ALL_FIELDS_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {             // Ignore deprecated option             } else if (GENERATE_SYNONYMS_PHRASE_QUERY.match(currentFieldName, parser.getDeprecationHandler())) {                 autoGenerateSynonymsPhraseQuery = parser.booleanValue().             } else if (FUZZY_PREFIX_LENGTH_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 fuzzyPrefixLenght = parser.intValue().             } else if (FUZZY_MAX_EXPANSIONS_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 fuzzyMaxExpansions = parser.intValue().             } else if (FUZZY_TRANSPOSITIONS_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 fuzzyTranspositions = parser.booleanValue().             } else {                 throw new ParsingException(parser.getTokenLocation(), "[" + SimpleQueryStringBuilder.NAME + "] unsupported field [" + parser.currentName() + "]").             }         } else {             throw new ParsingException(parser.getTokenLocation(), "[" + SimpleQueryStringBuilder.NAME + "] unknown token [" + token + "] after [" + currentFieldName + "]").         }     }     // Query text is required     if (queryBody == null) {         throw new ParsingException(parser.getTokenLocation(), "[" + SimpleQueryStringBuilder.NAME + "] query text missing").     }     SimpleQueryStringBuilder qb = new SimpleQueryStringBuilder(queryBody).     if (fieldsAndWeights != null) {         qb.fields(fieldsAndWeights).     }     qb.boost(boost).analyzer(analyzerName).queryName(queryName).minimumShouldMatch(minimumShouldMatch).     qb.flags(flags).defaultOperator(defaultOperator).     if (lenient != null) {         qb.lenient(lenient).     }     qb.analyzeWildcard(analyzeWildcard).boost(boost).quoteFieldSuffix(quoteFieldSuffix).     qb.autoGenerateSynonymsPhraseQuery(autoGenerateSynonymsPhraseQuery).     qb.fuzzyPrefixLength(fuzzyPrefixLenght).     qb.fuzzyMaxExpansions(fuzzyMaxExpansions).     qb.fuzzyTranspositions(fuzzyTranspositions).     return qb. }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
false;protected;0;4;;@Override protected int doHashCode() {     return Objects.hash(fieldsAndWeights, analyzer, defaultOperator, queryText, minimumShouldMatch, settings, flags). }
false;protected;1;8;;@Override protected boolean doEquals(SimpleQueryStringBuilder other) {     return Objects.equals(fieldsAndWeights, other.fieldsAndWeights) && Objects.equals(analyzer, other.analyzer) && Objects.equals(defaultOperator, other.defaultOperator) && Objects.equals(queryText, other.queryText) && Objects.equals(minimumShouldMatch, other.minimumShouldMatch) && Objects.equals(settings, other.settings) && (flags == other.flags). }
