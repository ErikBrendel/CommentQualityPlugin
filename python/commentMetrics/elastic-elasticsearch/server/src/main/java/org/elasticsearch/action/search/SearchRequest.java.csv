commented;modifiers;parameterAmount;loc;comment;code
true;static;5;10;/**  * Creates a new search request by providing the search request to copy all fields from, the indices to search against, the alias of  * the cluster where it will be executed, as well as the start time in milliseconds from the epoch time and whether the reduction  * should be final or not. Used when a {@link SearchRequest} is created and executed as part of a cross-cluster search request  * performing reduction on each cluster in order to minimize network round-trips between the coordinating node and the remote clusters.  *  * @param originalSearchRequest the original search request  * @param indices the indices to search against  * @param clusterAlias the alias to prefix index names with in the returned search results  * @param absoluteStartMillis the absolute start time to be used on the remote clusters to ensure that the same value is used  * @param finalReduce whether the reduction should be final or not  */ ;/**  * Creates a new search request by providing the search request to copy all fields from, the indices to search against, the alias of  * the cluster where it will be executed, as well as the start time in milliseconds from the epoch time and whether the reduction  * should be final or not. Used when a {@link SearchRequest} is created and executed as part of a cross-cluster search request  * performing reduction on each cluster in order to minimize network round-trips between the coordinating node and the remote clusters.  *  * @param originalSearchRequest the original search request  * @param indices the indices to search against  * @param clusterAlias the alias to prefix index names with in the returned search results  * @param absoluteStartMillis the absolute start time to be used on the remote clusters to ensure that the same value is used  * @param finalReduce whether the reduction should be final or not  */ static SearchRequest crossClusterSearch(SearchRequest originalSearchRequest, String[] indices, String clusterAlias, long absoluteStartMillis, boolean finalReduce) {     Objects.requireNonNull(originalSearchRequest, "search request must not be null").     validateIndices(indices).     Objects.requireNonNull(clusterAlias, "cluster alias must not be null").     if (absoluteStartMillis < 0) {         throw new IllegalArgumentException("absoluteStartMillis must not be negative but was [" + absoluteStartMillis + "]").     }     return new SearchRequest(originalSearchRequest, indices, clusterAlias, absoluteStartMillis, finalReduce). }
false;public;1;29;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeByte(searchType.id()).     out.writeStringArray(indices).     out.writeOptionalString(routing).     out.writeOptionalString(preference).     out.writeOptionalWriteable(scroll).     out.writeOptionalWriteable(source).     out.writeStringArray(types).     indicesOptions.writeIndicesOptions(out).     out.writeOptionalBoolean(requestCache).     out.writeVInt(batchedReduceSize).     out.writeVInt(maxConcurrentShardRequests).     out.writeVInt(preFilterShardSize).     if (out.getVersion().onOrAfter(Version.V_6_3_0)) {         out.writeOptionalBoolean(allowPartialSearchResults).     }     if (out.getVersion().onOrAfter(Version.V_6_7_0)) {         out.writeOptionalString(localClusterAlias).         if (localClusterAlias != null) {             out.writeVLong(absoluteStartMillis).             out.writeBoolean(finalReduce).         }     }     if (out.getVersion().onOrAfter(Version.V_7_0_0)) {         out.writeBoolean(ccsMinimizeRoundtrips).     } }
false;public;0;29;;@Override public ActionRequestValidationException validate() {     ActionRequestValidationException validationException = null.     boolean scroll = scroll() != null.     if (scroll) {         if (source != null) {             if (source.trackTotalHitsUpTo() != null && source.trackTotalHitsUpTo() != SearchContext.TRACK_TOTAL_HITS_ACCURATE) {                 validationException = addValidationError("disabling [track_total_hits] is not allowed in a scroll context", validationException).             }             if (source.from() > 0) {                 validationException = addValidationError("using [from] is not allowed in a scroll context", validationException).             }             if (source.size() == 0) {                 validationException = addValidationError("[size] cannot be [0] in a scroll context", validationException).             }             if (source.rescores() != null && source.rescores().isEmpty() == false) {                 validationException = addValidationError("using [rescore] is not allowed in a scroll context", validationException).             }         }         if (requestCache != null && requestCache) {             validationException = addValidationError("[request_cache] cannot be used in a scroll context", validationException).         }     }     return validationException. }
true;;0;4;/**  * Returns the alias of the cluster that this search request is being executed on. A non-null value indicates that this search request  * is being executed as part of a locally reduced cross-cluster search request. The cluster alias is used to prefix index names  * returned as part of search hits with the alias of the cluster they came from.  */ ;/**  * Returns the alias of the cluster that this search request is being executed on. A non-null value indicates that this search request  * is being executed as part of a locally reduced cross-cluster search request. The cluster alias is used to prefix index names  * returned as part of search hits with the alias of the cluster they came from.  */ @Nullable String getLocalClusterAlias() {     return localClusterAlias. }
true;;0;3;/**  * Returns whether the reduction phase that will be performed needs to be final or not.  */ ;/**  * Returns whether the reduction phase that will be performed needs to be final or not.  */ boolean isFinalReduce() {     return finalReduce. }
true;;0;3;/**  * Returns the current time in milliseconds from the time epoch, to be used for the execution of this search request. Used to  * ensure that the same value, determined by the coordinating node, is used on all nodes involved in the execution of the search  * request. When created through {@link #crossClusterSearch(SearchRequest, String[], String, long, boolean)}, this method returns  * the provided current time, otherwise it will return {@link System#currentTimeMillis()}.  */ ;/**  * Returns the current time in milliseconds from the time epoch, to be used for the execution of this search request. Used to  * ensure that the same value, determined by the coordinating node, is used on all nodes involved in the execution of the search  * request. When created through {@link #crossClusterSearch(SearchRequest, String[], String, long, boolean)}, this method returns  * the provided current time, otherwise it will return {@link System#currentTimeMillis()}.  */ long getOrCreateAbsoluteStartMillis() {     return absoluteStartMillis == DEFAULT_ABSOLUTE_START_MILLIS ? System.currentTimeMillis() : absoluteStartMillis. }
true;public;1;6;/**  * Sets the indices the search will be executed on.  */ ;/**  * Sets the indices the search will be executed on.  */ @Override public SearchRequest indices(String... indices) {     validateIndices(indices).     this.indices = indices.     return this. }
false;private,static;1;6;;private static void validateIndices(String... indices) {     Objects.requireNonNull(indices, "indices must not be null").     for (String index : indices) {         Objects.requireNonNull(index, "index must not be null").     } }
false;public;0;4;;@Override public IndicesOptions indicesOptions() {     return indicesOptions. }
false;public;1;4;;public SearchRequest indicesOptions(IndicesOptions indicesOptions) {     this.indicesOptions = Objects.requireNonNull(indicesOptions, "indicesOptions must not be null").     return this. }
true;public;0;3;/**  * Returns whether network round-trips should be minimized when executing cross-cluster search requests.  * Defaults to <code>true</code>.  */ ;/**  * Returns whether network round-trips should be minimized when executing cross-cluster search requests.  * Defaults to <code>true</code>.  */ public boolean isCcsMinimizeRoundtrips() {     return ccsMinimizeRoundtrips. }
true;public;1;3;/**  * Sets whether network round-trips should be minimized when executing cross-cluster search requests. Defaults to <code>true</code>.  */ ;/**  * Sets whether network round-trips should be minimized when executing cross-cluster search requests. Defaults to <code>true</code>.  */ public void setCcsMinimizeRoundtrips(boolean ccsMinimizeRoundtrips) {     this.ccsMinimizeRoundtrips = ccsMinimizeRoundtrips. }
true;public;0;4;/**  * The document types to execute the search against. Defaults to be executed against  * all types.  *  * @deprecated Types are in the process of being removed. Instead of using a type, prefer to  * filter on a field on the document.  */ ;/**  * The document types to execute the search against. Defaults to be executed against  * all types.  *  * @deprecated Types are in the process of being removed. Instead of using a type, prefer to  * filter on a field on the document.  */ @Deprecated public String[] types() {     return types. }
true;public;1;9;/**  * The document types to execute the search against. Defaults to be executed against  * all types.  *  * @deprecated Types are in the process of being removed. Instead of using a type, prefer to  * filter on a field on the document.  */ ;/**  * The document types to execute the search against. Defaults to be executed against  * all types.  *  * @deprecated Types are in the process of being removed. Instead of using a type, prefer to  * filter on a field on the document.  */ @Deprecated public SearchRequest types(String... types) {     Objects.requireNonNull(types, "types must not be null").     for (String type : types) {         Objects.requireNonNull(type, "type must not be null").     }     this.types = types.     return this. }
true;public;0;3;/**  * A comma separated list of routing values to control the shards the search will be executed on.  */ ;/**  * A comma separated list of routing values to control the shards the search will be executed on.  */ public String routing() {     return this.routing. }
true;public;1;4;/**  * A comma separated list of routing values to control the shards the search will be executed on.  */ ;/**  * A comma separated list of routing values to control the shards the search will be executed on.  */ public SearchRequest routing(String routing) {     this.routing = routing.     return this. }
true;public;1;4;/**  * The routing values to control the shards that the search will be executed on.  */ ;/**  * The routing values to control the shards that the search will be executed on.  */ public SearchRequest routing(String... routings) {     this.routing = Strings.arrayToCommaDelimitedString(routings).     return this. }
true;public;1;4;/**  * Sets the preference to execute the search. Defaults to randomize across shards. Can be set to  * {@code _local} to prefer local shards or a custom value, which guarantees that the same order  * will be used across different requests.  */ ;/**  * Sets the preference to execute the search. Defaults to randomize across shards. Can be set to  * {@code _local} to prefer local shards or a custom value, which guarantees that the same order  * will be used across different requests.  */ public SearchRequest preference(String preference) {     this.preference = preference.     return this. }
false;public;0;3;;public String preference() {     return this.preference. }
true;public;1;4;/**  * The search type to execute, defaults to {@link SearchType#DEFAULT}.  */ ;/**  * The search type to execute, defaults to {@link SearchType#DEFAULT}.  */ public SearchRequest searchType(SearchType searchType) {     this.searchType = Objects.requireNonNull(searchType, "searchType must not be null").     return this. }
true;public;1;3;/**  * The a string representation search type to execute, defaults to {@link SearchType#DEFAULT}. Can be  * one of "dfs_query_then_fetch"/"dfsQueryThenFetch", "dfs_query_and_fetch"/"dfsQueryAndFetch",  * "query_then_fetch"/"queryThenFetch", and "query_and_fetch"/"queryAndFetch".  */ ;/**  * The a string representation search type to execute, defaults to {@link SearchType#DEFAULT}. Can be  * one of "dfs_query_then_fetch"/"dfsQueryThenFetch", "dfs_query_and_fetch"/"dfsQueryAndFetch",  * "query_then_fetch"/"queryThenFetch", and "query_and_fetch"/"queryAndFetch".  */ public SearchRequest searchType(String searchType) {     return searchType(SearchType.fromString(searchType)). }
true;public;1;4;/**  * The source of the search request.  */ ;/**  * The source of the search request.  */ public SearchRequest source(SearchSourceBuilder sourceBuilder) {     this.source = Objects.requireNonNull(sourceBuilder, "source must not be null").     return this. }
true;public;0;3;/**  * The search source to execute.  */ ;/**  * The search source to execute.  */ public SearchSourceBuilder source() {     return source. }
true;public;0;3;/**  * The tye of search to execute.  */ ;/**  * The tye of search to execute.  */ public SearchType searchType() {     return searchType. }
true;public;0;4;/**  * The indices  */ ;/**  * The indices  */ @Override public String[] indices() {     return indices. }
true;public;0;3;/**  * If set, will enable scrolling of the search request.  */ ;/**  * If set, will enable scrolling of the search request.  */ public Scroll scroll() {     return scroll. }
true;public;1;4;/**  * If set, will enable scrolling of the search request.  */ ;/**  * If set, will enable scrolling of the search request.  */ public SearchRequest scroll(Scroll scroll) {     this.scroll = scroll.     return this. }
true;public;1;3;/**  * If set, will enable scrolling of the search request for the specified timeout.  */ ;/**  * If set, will enable scrolling of the search request for the specified timeout.  */ public SearchRequest scroll(TimeValue keepAlive) {     return scroll(new Scroll(keepAlive)). }
true;public;1;3;/**  * If set, will enable scrolling of the search request for the specified timeout.  */ ;/**  * If set, will enable scrolling of the search request for the specified timeout.  */ public SearchRequest scroll(String keepAlive) {     return scroll(new Scroll(TimeValue.parseTimeValue(keepAlive, null, getClass().getSimpleName() + ".Scroll.keepAlive"))). }
true;public;1;4;/**  * Sets if this request should use the request cache or not, assuming that it can (for  * example, if "now" is used, it will never be cached). By default (not set, or null,  * will default to the index level setting if request cache is enabled or not).  */ ;/**  * Sets if this request should use the request cache or not, assuming that it can (for  * example, if "now" is used, it will never be cached). By default (not set, or null,  * will default to the index level setting if request cache is enabled or not).  */ public SearchRequest requestCache(Boolean requestCache) {     this.requestCache = requestCache.     return this. }
false;public;0;3;;public Boolean requestCache() {     return this.requestCache. }
true;public;1;4;/**  * Sets if this request should allow partial results. (If method is not called,  * will default to the cluster level setting).  */ ;/**  * Sets if this request should allow partial results. (If method is not called,  * will default to the cluster level setting).  */ public SearchRequest allowPartialSearchResults(boolean allowPartialSearchResults) {     this.allowPartialSearchResults = allowPartialSearchResults.     return this. }
false;public;0;3;;public Boolean allowPartialSearchResults() {     return this.allowPartialSearchResults. }
true;public;1;6;/**  * Sets the number of shard results that should be reduced at once on the coordinating node. This value should be used as a protection  * mechanism to reduce the memory overhead per search request if the potential number of shards in the request can be large.  */ ;/**  * Sets the number of shard results that should be reduced at once on the coordinating node. This value should be used as a protection  * mechanism to reduce the memory overhead per search request if the potential number of shards in the request can be large.  */ public void setBatchedReduceSize(int batchedReduceSize) {     if (batchedReduceSize <= 1) {         throw new IllegalArgumentException("batchedReduceSize must be >= 2").     }     this.batchedReduceSize = batchedReduceSize. }
true;public;0;3;/**  * Returns the number of shard results that should be reduced at once on the coordinating node. This value should be used as a  * protection mechanism to reduce the memory overhead per search request if the potential number of shards in the request can be large.  */ ;/**  * Returns the number of shard results that should be reduced at once on the coordinating node. This value should be used as a  * protection mechanism to reduce the memory overhead per search request if the potential number of shards in the request can be large.  */ public int getBatchedReduceSize() {     return batchedReduceSize. }
true;public;0;3;/**  * Returns the number of shard requests that should be executed concurrently on a single node. This value should be used as a  * protection mechanism to reduce the number of shard requests fired per high level search request. Searches that hit the entire  * cluster can be throttled with this number to reduce the cluster load. The default is {@code 5}  */ ;/**  * Returns the number of shard requests that should be executed concurrently on a single node. This value should be used as a  * protection mechanism to reduce the number of shard requests fired per high level search request. Searches that hit the entire  * cluster can be throttled with this number to reduce the cluster load. The default is {@code 5}  */ public int getMaxConcurrentShardRequests() {     return maxConcurrentShardRequests == 0 ? 5 : maxConcurrentShardRequests. }
true;public;1;6;/**  * Sets the number of shard requests that should be executed concurrently on a single node. This value should be used as a  * protection mechanism to reduce the number of shard requests fired per high level search request. Searches that hit the entire  * cluster can be throttled with this number to reduce the cluster load. The default is {@code 5}  */ ;/**  * Sets the number of shard requests that should be executed concurrently on a single node. This value should be used as a  * protection mechanism to reduce the number of shard requests fired per high level search request. Searches that hit the entire  * cluster can be throttled with this number to reduce the cluster load. The default is {@code 5}  */ public void setMaxConcurrentShardRequests(int maxConcurrentShardRequests) {     if (maxConcurrentShardRequests < 1) {         throw new IllegalArgumentException("maxConcurrentShardRequests must be >= 1").     }     this.maxConcurrentShardRequests = maxConcurrentShardRequests. }
true;public;1;6;/**  * Sets a threshold that enforces a pre-filter roundtrip to pre-filter search shards based on query rewriting if the number of shards  * the search request expands to exceeds the threshold. This filter roundtrip can limit the number of shards significantly if for  * instance a shard can not match any documents based on it's rewrite method ie. if date filters are mandatory to match but the shard  * bounds and the query are disjoint. The default is {@code 128}  */ ;/**  * Sets a threshold that enforces a pre-filter roundtrip to pre-filter search shards based on query rewriting if the number of shards  * the search request expands to exceeds the threshold. This filter roundtrip can limit the number of shards significantly if for  * instance a shard can not match any documents based on it's rewrite method ie. if date filters are mandatory to match but the shard  * bounds and the query are disjoint. The default is {@code 128}  */ public void setPreFilterShardSize(int preFilterShardSize) {     if (preFilterShardSize < 1) {         throw new IllegalArgumentException("preFilterShardSize must be >= 1").     }     this.preFilterShardSize = preFilterShardSize. }
true;public;0;3;/**  * Returns a threshold that enforces a pre-filter roundtrip to pre-filter search shards based on query rewriting if the number of shards  * the search request expands to exceeds the threshold. This filter roundtrip can limit the number of shards significantly if for  * instance a shard can not match any documents based on it's rewrite method ie. if date filters are mandatory to match but the shard  * bounds and the query are disjoint. The default is {@code 128}  */ ;/**  * Returns a threshold that enforces a pre-filter roundtrip to pre-filter search shards based on query rewriting if the number of shards  * the search request expands to exceeds the threshold. This filter roundtrip can limit the number of shards significantly if for  * instance a shard can not match any documents based on it's rewrite method ie. if date filters are mandatory to match but the shard  * bounds and the query are disjoint. The default is {@code 128}  */ public int getPreFilterShardSize() {     return preFilterShardSize. }
true;public;0;3;/**  * @return true if the request only has suggest  */ ;/**  * @return true if the request only has suggest  */ public boolean isSuggestOnly() {     return source != null && source.isSuggestOnly(). }
false;public;0;18;;@Override public String getDescription() {     StringBuilder sb = new StringBuilder().     sb.append("indices[").     Strings.arrayToDelimitedString(indices, ",", sb).     sb.append("], ").     sb.append("types[").     Strings.arrayToDelimitedString(types, ",", sb).     sb.append("], ").     sb.append("search_type[").append(searchType).append("], ").     if (source != null) {         sb.append("source[").append(source.toString(FORMAT_PARAMS)).append("]").     } else {         sb.append("source[]").     }     return sb.toString(). }
false;public;5;24;;@Override public Task createTask(long id, String type, String action, TaskId parentTaskId, Map<String, String> headers) {     // generating description in a lazy way since source can be quite big     return new SearchTask(id, type, action, null, parentTaskId, headers) {          @Override         public String getDescription() {             StringBuilder sb = new StringBuilder().             sb.append("indices[").             Strings.arrayToDelimitedString(indices, ",", sb).             sb.append("], ").             sb.append("types[").             Strings.arrayToDelimitedString(types, ",", sb).             sb.append("], ").             sb.append("search_type[").append(searchType).append("], ").             if (source != null) {                 sb.append("source[").append(source.toString(FORMAT_PARAMS)).append("]").             } else {                 sb.append("source[]").             }             return sb.toString().         }     }. }
false;public;1;4;;@Override public void readFrom(StreamInput in) {     throw new UnsupportedOperationException("usage of Streamable is to be replaced by Writeable"). }
false;public;1;26;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (o == null || getClass() != o.getClass()) {         return false.     }     SearchRequest that = (SearchRequest) o.     return searchType == that.searchType && Arrays.equals(indices, that.indices) && Objects.equals(routing, that.routing) && Objects.equals(preference, that.preference) && Objects.equals(source, that.source) && Objects.equals(requestCache, that.requestCache) && Objects.equals(scroll, that.scroll) && Arrays.equals(types, that.types) && Objects.equals(batchedReduceSize, that.batchedReduceSize) && Objects.equals(maxConcurrentShardRequests, that.maxConcurrentShardRequests) && Objects.equals(preFilterShardSize, that.preFilterShardSize) && Objects.equals(indicesOptions, that.indicesOptions) && Objects.equals(allowPartialSearchResults, that.allowPartialSearchResults) && Objects.equals(localClusterAlias, that.localClusterAlias) && absoluteStartMillis == that.absoluteStartMillis && ccsMinimizeRoundtrips == that.ccsMinimizeRoundtrips. }
false;public;0;6;;@Override public int hashCode() {     return Objects.hash(searchType, Arrays.hashCode(indices), routing, preference, source, requestCache, scroll, Arrays.hashCode(types), indicesOptions, batchedReduceSize, maxConcurrentShardRequests, preFilterShardSize, allowPartialSearchResults, localClusterAlias, absoluteStartMillis, ccsMinimizeRoundtrips). }
false;public;0;20;;@Override public String toString() {     return "SearchRequest{" + "searchType=" + searchType + ", indices=" + Arrays.toString(indices) + ", indicesOptions=" + indicesOptions + ", types=" + Arrays.toString(types) + ", routing='" + routing + '\'' + ", preference='" + preference + '\'' + ", requestCache=" + requestCache + ", scroll=" + scroll + ", maxConcurrentShardRequests=" + maxConcurrentShardRequests + ", batchedReduceSize=" + batchedReduceSize + ", preFilterShardSize=" + preFilterShardSize + ", allowPartialSearchResults=" + allowPartialSearchResults + ", localClusterAlias=" + localClusterAlias + ", getOrCreateAbsoluteStartMillis=" + absoluteStartMillis + ", ccsMinimizeRoundtrips=" + ccsMinimizeRoundtrips + ", source=" + source + '}'. }
