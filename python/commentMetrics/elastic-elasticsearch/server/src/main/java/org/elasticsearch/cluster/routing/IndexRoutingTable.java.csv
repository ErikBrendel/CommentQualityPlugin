# id;timestamp;commentText;codeText;commentWords;codeWords
IndexRoutingTable -> public int numberOfNodesShardsAreAllocatedOn(String... excludedNodes);1524684173;Calculates the number of nodes that hold one or more shards of this index_{@link IndexRoutingTable} excluding the nodes with the node ids give as_the <code>excludedNodes</code> parameter.__@param excludedNodes id of nodes that will be excluded_@return number of distinct nodes this index has at least one shard allocated on;public int numberOfNodesShardsAreAllocatedOn(String... excludedNodes) {_        Set<String> nodes = new HashSet<>()__        for (IndexShardRoutingTable shardRoutingTable : this) {_            for (ShardRouting shardRouting : shardRoutingTable) {_                if (shardRouting.assignedToNode()) {_                    String currentNodeId = shardRouting.currentNodeId()__                    boolean excluded = false__                    if (excludedNodes != null) {_                        for (String excludedNode : excludedNodes) {_                            if (currentNodeId.equals(excludedNode)) {_                                excluded = true__                                break__                            }_                        }_                    }_                    if (!excluded) {_                        nodes.add(currentNodeId)__                    }_                }_            }_        }_        return nodes.size()__    };calculates,the,number,of,nodes,that,hold,one,or,more,shards,of,this,index,link,index,routing,table,excluding,the,nodes,with,the,node,ids,give,as,the,code,excluded,nodes,code,parameter,param,excluded,nodes,id,of,nodes,that,will,be,excluded,return,number,of,distinct,nodes,this,index,has,at,least,one,shard,allocated,on;public,int,number,of,nodes,shards,are,allocated,on,string,excluded,nodes,set,string,nodes,new,hash,set,for,index,shard,routing,table,shard,routing,table,this,for,shard,routing,shard,routing,shard,routing,table,if,shard,routing,assigned,to,node,string,current,node,id,shard,routing,current,node,id,boolean,excluded,false,if,excluded,nodes,null,for,string,excluded,node,excluded,nodes,if,current,node,id,equals,excluded,node,excluded,true,break,if,excluded,nodes,add,current,node,id,return,nodes,size
IndexRoutingTable -> public int numberOfNodesShardsAreAllocatedOn(String... excludedNodes);1525334055;Calculates the number of nodes that hold one or more shards of this index_{@link IndexRoutingTable} excluding the nodes with the node ids give as_the <code>excludedNodes</code> parameter.__@param excludedNodes id of nodes that will be excluded_@return number of distinct nodes this index has at least one shard allocated on;public int numberOfNodesShardsAreAllocatedOn(String... excludedNodes) {_        Set<String> nodes = new HashSet<>()__        for (IndexShardRoutingTable shardRoutingTable : this) {_            for (ShardRouting shardRouting : shardRoutingTable) {_                if (shardRouting.assignedToNode()) {_                    String currentNodeId = shardRouting.currentNodeId()__                    boolean excluded = false__                    if (excludedNodes != null) {_                        for (String excludedNode : excludedNodes) {_                            if (currentNodeId.equals(excludedNode)) {_                                excluded = true__                                break__                            }_                        }_                    }_                    if (!excluded) {_                        nodes.add(currentNodeId)__                    }_                }_            }_        }_        return nodes.size()__    };calculates,the,number,of,nodes,that,hold,one,or,more,shards,of,this,index,link,index,routing,table,excluding,the,nodes,with,the,node,ids,give,as,the,code,excluded,nodes,code,parameter,param,excluded,nodes,id,of,nodes,that,will,be,excluded,return,number,of,distinct,nodes,this,index,has,at,least,one,shard,allocated,on;public,int,number,of,nodes,shards,are,allocated,on,string,excluded,nodes,set,string,nodes,new,hash,set,for,index,shard,routing,table,shard,routing,table,this,for,shard,routing,shard,routing,shard,routing,table,if,shard,routing,assigned,to,node,string,current,node,id,shard,routing,current,node,id,boolean,excluded,false,if,excluded,nodes,null,for,string,excluded,node,excluded,nodes,if,current,node,id,equals,excluded,node,excluded,true,break,if,excluded,nodes,add,current,node,id,return,nodes,size
IndexRoutingTable -> public int numberOfNodesShardsAreAllocatedOn(String... excludedNodes);1536611444;Calculates the number of nodes that hold one or more shards of this index_{@link IndexRoutingTable} excluding the nodes with the node ids give as_the <code>excludedNodes</code> parameter.__@param excludedNodes id of nodes that will be excluded_@return number of distinct nodes this index has at least one shard allocated on;public int numberOfNodesShardsAreAllocatedOn(String... excludedNodes) {_        Set<String> nodes = new HashSet<>()__        for (IndexShardRoutingTable shardRoutingTable : this) {_            for (ShardRouting shardRouting : shardRoutingTable) {_                if (shardRouting.assignedToNode()) {_                    String currentNodeId = shardRouting.currentNodeId()__                    boolean excluded = false__                    if (excludedNodes != null) {_                        for (String excludedNode : excludedNodes) {_                            if (currentNodeId.equals(excludedNode)) {_                                excluded = true__                                break__                            }_                        }_                    }_                    if (!excluded) {_                        nodes.add(currentNodeId)__                    }_                }_            }_        }_        return nodes.size()__    };calculates,the,number,of,nodes,that,hold,one,or,more,shards,of,this,index,link,index,routing,table,excluding,the,nodes,with,the,node,ids,give,as,the,code,excluded,nodes,code,parameter,param,excluded,nodes,id,of,nodes,that,will,be,excluded,return,number,of,distinct,nodes,this,index,has,at,least,one,shard,allocated,on;public,int,number,of,nodes,shards,are,allocated,on,string,excluded,nodes,set,string,nodes,new,hash,set,for,index,shard,routing,table,shard,routing,table,this,for,shard,routing,shard,routing,shard,routing,table,if,shard,routing,assigned,to,node,string,current,node,id,shard,routing,current,node,id,boolean,excluded,false,if,excluded,nodes,null,for,string,excluded,node,excluded,nodes,if,current,node,id,equals,excluded,node,excluded,true,break,if,excluded,nodes,add,current,node,id,return,nodes,size
IndexRoutingTable -> public int numberOfNodesShardsAreAllocatedOn(String... excludedNodes);1540847035;Calculates the number of nodes that hold one or more shards of this index_{@link IndexRoutingTable} excluding the nodes with the node ids give as_the <code>excludedNodes</code> parameter.__@param excludedNodes id of nodes that will be excluded_@return number of distinct nodes this index has at least one shard allocated on;public int numberOfNodesShardsAreAllocatedOn(String... excludedNodes) {_        Set<String> nodes = new HashSet<>()__        for (IndexShardRoutingTable shardRoutingTable : this) {_            for (ShardRouting shardRouting : shardRoutingTable) {_                if (shardRouting.assignedToNode()) {_                    String currentNodeId = shardRouting.currentNodeId()__                    boolean excluded = false__                    if (excludedNodes != null) {_                        for (String excludedNode : excludedNodes) {_                            if (currentNodeId.equals(excludedNode)) {_                                excluded = true__                                break__                            }_                        }_                    }_                    if (!excluded) {_                        nodes.add(currentNodeId)__                    }_                }_            }_        }_        return nodes.size()__    };calculates,the,number,of,nodes,that,hold,one,or,more,shards,of,this,index,link,index,routing,table,excluding,the,nodes,with,the,node,ids,give,as,the,code,excluded,nodes,code,parameter,param,excluded,nodes,id,of,nodes,that,will,be,excluded,return,number,of,distinct,nodes,this,index,has,at,least,one,shard,allocated,on;public,int,number,of,nodes,shards,are,allocated,on,string,excluded,nodes,set,string,nodes,new,hash,set,for,index,shard,routing,table,shard,routing,table,this,for,shard,routing,shard,routing,shard,routing,table,if,shard,routing,assigned,to,node,string,current,node,id,shard,routing,current,node,id,boolean,excluded,false,if,excluded,nodes,null,for,string,excluded,node,excluded,nodes,if,current,node,id,equals,excluded,node,excluded,true,break,if,excluded,nodes,add,current,node,id,return,nodes,size
IndexRoutingTable -> public int numberOfNodesShardsAreAllocatedOn(String... excludedNodes);1541618291;Calculates the number of nodes that hold one or more shards of this index_{@link IndexRoutingTable} excluding the nodes with the node ids give as_the <code>excludedNodes</code> parameter.__@param excludedNodes id of nodes that will be excluded_@return number of distinct nodes this index has at least one shard allocated on;public int numberOfNodesShardsAreAllocatedOn(String... excludedNodes) {_        Set<String> nodes = new HashSet<>()__        for (IndexShardRoutingTable shardRoutingTable : this) {_            for (ShardRouting shardRouting : shardRoutingTable) {_                if (shardRouting.assignedToNode()) {_                    String currentNodeId = shardRouting.currentNodeId()__                    boolean excluded = false__                    if (excludedNodes != null) {_                        for (String excludedNode : excludedNodes) {_                            if (currentNodeId.equals(excludedNode)) {_                                excluded = true__                                break__                            }_                        }_                    }_                    if (!excluded) {_                        nodes.add(currentNodeId)__                    }_                }_            }_        }_        return nodes.size()__    };calculates,the,number,of,nodes,that,hold,one,or,more,shards,of,this,index,link,index,routing,table,excluding,the,nodes,with,the,node,ids,give,as,the,code,excluded,nodes,code,parameter,param,excluded,nodes,id,of,nodes,that,will,be,excluded,return,number,of,distinct,nodes,this,index,has,at,least,one,shard,allocated,on;public,int,number,of,nodes,shards,are,allocated,on,string,excluded,nodes,set,string,nodes,new,hash,set,for,index,shard,routing,table,shard,routing,table,this,for,shard,routing,shard,routing,shard,routing,table,if,shard,routing,assigned,to,node,string,current,node,id,shard,routing,current,node,id,boolean,excluded,false,if,excluded,nodes,null,for,string,excluded,node,excluded,nodes,if,current,node,id,equals,excluded,node,excluded,true,break,if,excluded,nodes,add,current,node,id,return,nodes,size
IndexRoutingTable -> Builder -> public Builder initializeAsFromCloseToOpen(IndexMetaData indexMetaData);1524684173;Initializes a new empty index, as as a result of opening a closed index.;public Builder initializeAsFromCloseToOpen(IndexMetaData indexMetaData) {_            return initializeEmpty(indexMetaData, new UnassignedInfo(UnassignedInfo.Reason.INDEX_REOPENED, null))__        };initializes,a,new,empty,index,as,as,a,result,of,opening,a,closed,index;public,builder,initialize,as,from,close,to,open,index,meta,data,index,meta,data,return,initialize,empty,index,meta,data,new,unassigned,info,unassigned,info,reason,null
IndexRoutingTable -> Builder -> public Builder initializeAsFromCloseToOpen(IndexMetaData indexMetaData);1525334055;Initializes a new empty index, as as a result of opening a closed index.;public Builder initializeAsFromCloseToOpen(IndexMetaData indexMetaData) {_            return initializeEmpty(indexMetaData, new UnassignedInfo(UnassignedInfo.Reason.INDEX_REOPENED, null))__        };initializes,a,new,empty,index,as,as,a,result,of,opening,a,closed,index;public,builder,initialize,as,from,close,to,open,index,meta,data,index,meta,data,return,initialize,empty,index,meta,data,new,unassigned,info,unassigned,info,reason,null
IndexRoutingTable -> Builder -> public Builder initializeAsFromCloseToOpen(IndexMetaData indexMetaData);1536611444;Initializes a new empty index, as as a result of opening a closed index.;public Builder initializeAsFromCloseToOpen(IndexMetaData indexMetaData) {_            return initializeEmpty(indexMetaData, new UnassignedInfo(UnassignedInfo.Reason.INDEX_REOPENED, null))__        };initializes,a,new,empty,index,as,as,a,result,of,opening,a,closed,index;public,builder,initialize,as,from,close,to,open,index,meta,data,index,meta,data,return,initialize,empty,index,meta,data,new,unassigned,info,unassigned,info,reason,null
IndexRoutingTable -> Builder -> public Builder initializeAsFromCloseToOpen(IndexMetaData indexMetaData);1540847035;Initializes a new empty index, as as a result of opening a closed index.;public Builder initializeAsFromCloseToOpen(IndexMetaData indexMetaData) {_            return initializeEmpty(indexMetaData, new UnassignedInfo(UnassignedInfo.Reason.INDEX_REOPENED, null))__        };initializes,a,new,empty,index,as,as,a,result,of,opening,a,closed,index;public,builder,initialize,as,from,close,to,open,index,meta,data,index,meta,data,return,initialize,empty,index,meta,data,new,unassigned,info,unassigned,info,reason,null
IndexRoutingTable -> Builder -> public Builder initializeAsFromCloseToOpen(IndexMetaData indexMetaData);1541618291;Initializes a new empty index, as as a result of opening a closed index.;public Builder initializeAsFromCloseToOpen(IndexMetaData indexMetaData) {_            return initializeEmpty(indexMetaData, new UnassignedInfo(UnassignedInfo.Reason.INDEX_REOPENED, null))__        };initializes,a,new,empty,index,as,as,a,result,of,opening,a,closed,index;public,builder,initialize,as,from,close,to,open,index,meta,data,index,meta,data,return,initialize,empty,index,meta,data,new,unassigned,info,unassigned,info,reason,null
IndexRoutingTable -> Builder -> public Builder addShard(ShardRouting shard);1524684173;Adds a new shard routing (makes a copy of it), with reference data used from the index shard routing table_if it needs to be created.;public Builder addShard(ShardRouting shard) {_            IndexShardRoutingTable indexShard = shards.get(shard.id())__            if (indexShard == null) {_                indexShard = new IndexShardRoutingTable.Builder(shard.shardId()).addShard(shard).build()__            } else {_                indexShard = new IndexShardRoutingTable.Builder(indexShard).addShard(shard).build()__            }_            shards.put(indexShard.shardId().id(), indexShard)__            return this__        };adds,a,new,shard,routing,makes,a,copy,of,it,with,reference,data,used,from,the,index,shard,routing,table,if,it,needs,to,be,created;public,builder,add,shard,shard,routing,shard,index,shard,routing,table,index,shard,shards,get,shard,id,if,index,shard,null,index,shard,new,index,shard,routing,table,builder,shard,shard,id,add,shard,shard,build,else,index,shard,new,index,shard,routing,table,builder,index,shard,add,shard,shard,build,shards,put,index,shard,shard,id,id,index,shard,return,this
IndexRoutingTable -> Builder -> public Builder addShard(ShardRouting shard);1525334055;Adds a new shard routing (makes a copy of it), with reference data used from the index shard routing table_if it needs to be created.;public Builder addShard(ShardRouting shard) {_            IndexShardRoutingTable indexShard = shards.get(shard.id())__            if (indexShard == null) {_                indexShard = new IndexShardRoutingTable.Builder(shard.shardId()).addShard(shard).build()__            } else {_                indexShard = new IndexShardRoutingTable.Builder(indexShard).addShard(shard).build()__            }_            shards.put(indexShard.shardId().id(), indexShard)__            return this__        };adds,a,new,shard,routing,makes,a,copy,of,it,with,reference,data,used,from,the,index,shard,routing,table,if,it,needs,to,be,created;public,builder,add,shard,shard,routing,shard,index,shard,routing,table,index,shard,shards,get,shard,id,if,index,shard,null,index,shard,new,index,shard,routing,table,builder,shard,shard,id,add,shard,shard,build,else,index,shard,new,index,shard,routing,table,builder,index,shard,add,shard,shard,build,shards,put,index,shard,shard,id,id,index,shard,return,this
IndexRoutingTable -> Builder -> public Builder addShard(ShardRouting shard);1536611444;Adds a new shard routing (makes a copy of it), with reference data used from the index shard routing table_if it needs to be created.;public Builder addShard(ShardRouting shard) {_            IndexShardRoutingTable indexShard = shards.get(shard.id())__            if (indexShard == null) {_                indexShard = new IndexShardRoutingTable.Builder(shard.shardId()).addShard(shard).build()__            } else {_                indexShard = new IndexShardRoutingTable.Builder(indexShard).addShard(shard).build()__            }_            shards.put(indexShard.shardId().id(), indexShard)__            return this__        };adds,a,new,shard,routing,makes,a,copy,of,it,with,reference,data,used,from,the,index,shard,routing,table,if,it,needs,to,be,created;public,builder,add,shard,shard,routing,shard,index,shard,routing,table,index,shard,shards,get,shard,id,if,index,shard,null,index,shard,new,index,shard,routing,table,builder,shard,shard,id,add,shard,shard,build,else,index,shard,new,index,shard,routing,table,builder,index,shard,add,shard,shard,build,shards,put,index,shard,shard,id,id,index,shard,return,this
IndexRoutingTable -> Builder -> public Builder addShard(ShardRouting shard);1540847035;Adds a new shard routing (makes a copy of it), with reference data used from the index shard routing table_if it needs to be created.;public Builder addShard(ShardRouting shard) {_            IndexShardRoutingTable indexShard = shards.get(shard.id())__            if (indexShard == null) {_                indexShard = new IndexShardRoutingTable.Builder(shard.shardId()).addShard(shard).build()__            } else {_                indexShard = new IndexShardRoutingTable.Builder(indexShard).addShard(shard).build()__            }_            shards.put(indexShard.shardId().id(), indexShard)__            return this__        };adds,a,new,shard,routing,makes,a,copy,of,it,with,reference,data,used,from,the,index,shard,routing,table,if,it,needs,to,be,created;public,builder,add,shard,shard,routing,shard,index,shard,routing,table,index,shard,shards,get,shard,id,if,index,shard,null,index,shard,new,index,shard,routing,table,builder,shard,shard,id,add,shard,shard,build,else,index,shard,new,index,shard,routing,table,builder,index,shard,add,shard,shard,build,shards,put,index,shard,shard,id,id,index,shard,return,this
IndexRoutingTable -> Builder -> public Builder addShard(ShardRouting shard);1541618291;Adds a new shard routing (makes a copy of it), with reference data used from the index shard routing table_if it needs to be created.;public Builder addShard(ShardRouting shard) {_            IndexShardRoutingTable indexShard = shards.get(shard.id())__            if (indexShard == null) {_                indexShard = new IndexShardRoutingTable.Builder(shard.shardId()).addShard(shard).build()__            } else {_                indexShard = new IndexShardRoutingTable.Builder(indexShard).addShard(shard).build()__            }_            shards.put(indexShard.shardId().id(), indexShard)__            return this__        };adds,a,new,shard,routing,makes,a,copy,of,it,with,reference,data,used,from,the,index,shard,routing,table,if,it,needs,to,be,created;public,builder,add,shard,shard,routing,shard,index,shard,routing,table,index,shard,shards,get,shard,id,if,index,shard,null,index,shard,new,index,shard,routing,table,builder,shard,shard,id,add,shard,shard,build,else,index,shard,new,index,shard,routing,table,builder,index,shard,add,shard,shard,build,shards,put,index,shard,shard,id,id,index,shard,return,this
IndexRoutingTable -> public int primaryShardsActive();1524684173;Calculates the number of primary shards in active state in routing table__@return number of active primary shards;public int primaryShardsActive() {_        int counter = 0__        for (IndexShardRoutingTable shardRoutingTable : this) {_            if (shardRoutingTable.primaryShard().active()) {_                counter++__            }_        }_        return counter__    };calculates,the,number,of,primary,shards,in,active,state,in,routing,table,return,number,of,active,primary,shards;public,int,primary,shards,active,int,counter,0,for,index,shard,routing,table,shard,routing,table,this,if,shard,routing,table,primary,shard,active,counter,return,counter
IndexRoutingTable -> public int primaryShardsActive();1525334055;Calculates the number of primary shards in active state in routing table__@return number of active primary shards;public int primaryShardsActive() {_        int counter = 0__        for (IndexShardRoutingTable shardRoutingTable : this) {_            if (shardRoutingTable.primaryShard().active()) {_                counter++__            }_        }_        return counter__    };calculates,the,number,of,primary,shards,in,active,state,in,routing,table,return,number,of,active,primary,shards;public,int,primary,shards,active,int,counter,0,for,index,shard,routing,table,shard,routing,table,this,if,shard,routing,table,primary,shard,active,counter,return,counter
IndexRoutingTable -> public int primaryShardsActive();1536611444;Calculates the number of primary shards in active state in routing table__@return number of active primary shards;public int primaryShardsActive() {_        int counter = 0__        for (IndexShardRoutingTable shardRoutingTable : this) {_            if (shardRoutingTable.primaryShard().active()) {_                counter++__            }_        }_        return counter__    };calculates,the,number,of,primary,shards,in,active,state,in,routing,table,return,number,of,active,primary,shards;public,int,primary,shards,active,int,counter,0,for,index,shard,routing,table,shard,routing,table,this,if,shard,routing,table,primary,shard,active,counter,return,counter
IndexRoutingTable -> public int primaryShardsActive();1540847035;Calculates the number of primary shards in active state in routing table__@return number of active primary shards;public int primaryShardsActive() {_        int counter = 0__        for (IndexShardRoutingTable shardRoutingTable : this) {_            if (shardRoutingTable.primaryShard().active()) {_                counter++__            }_        }_        return counter__    };calculates,the,number,of,primary,shards,in,active,state,in,routing,table,return,number,of,active,primary,shards;public,int,primary,shards,active,int,counter,0,for,index,shard,routing,table,shard,routing,table,this,if,shard,routing,table,primary,shard,active,counter,return,counter
IndexRoutingTable -> public int primaryShardsActive();1541618291;Calculates the number of primary shards in active state in routing table__@return number of active primary shards;public int primaryShardsActive() {_        int counter = 0__        for (IndexShardRoutingTable shardRoutingTable : this) {_            if (shardRoutingTable.primaryShard().active()) {_                counter++__            }_        }_        return counter__    };calculates,the,number,of,primary,shards,in,active,state,in,routing,table,return,number,of,active,primary,shards;public,int,primary,shards,active,int,counter,0,for,index,shard,routing,table,shard,routing,table,this,if,shard,routing,table,primary,shard,active,counter,return,counter
IndexRoutingTable -> Builder -> private Builder initializeEmpty(IndexMetaData indexMetaData, UnassignedInfo unassignedInfo);1524684173;Initializes a new empty index, with an option to control if its from an API or not.;private Builder initializeEmpty(IndexMetaData indexMetaData, UnassignedInfo unassignedInfo) {_            assert indexMetaData.getIndex().equals(index)__            if (!shards.isEmpty()) {_                throw new IllegalStateException("trying to initialize an index with fresh shards, but already has shards created")__            }_            for (int shardNumber = 0_ shardNumber < indexMetaData.getNumberOfShards()_ shardNumber++) {_                ShardId shardId = new ShardId(index, shardNumber)__                final RecoverySource primaryRecoverySource__                if (indexMetaData.inSyncAllocationIds(shardNumber).isEmpty() == false) {_                    _                    primaryRecoverySource = StoreRecoverySource.EXISTING_STORE_INSTANCE__                } else if (indexMetaData.getResizeSourceIndex() != null) {_                    _                    primaryRecoverySource = LocalShardsRecoverySource.INSTANCE__                } else {_                    _                    primaryRecoverySource = StoreRecoverySource.EMPTY_STORE_INSTANCE__                }_                IndexShardRoutingTable.Builder indexShardRoutingBuilder = new IndexShardRoutingTable.Builder(shardId)__                for (int i = 0_ i <= indexMetaData.getNumberOfReplicas()_ i++) {_                    boolean primary = i == 0__                    indexShardRoutingBuilder.addShard(ShardRouting.newUnassigned(shardId, primary,_                        primary ? primaryRecoverySource : PeerRecoverySource.INSTANCE, unassignedInfo))__                }_                shards.put(shardNumber, indexShardRoutingBuilder.build())__            }_            return this__        };initializes,a,new,empty,index,with,an,option,to,control,if,its,from,an,api,or,not;private,builder,initialize,empty,index,meta,data,index,meta,data,unassigned,info,unassigned,info,assert,index,meta,data,get,index,equals,index,if,shards,is,empty,throw,new,illegal,state,exception,trying,to,initialize,an,index,with,fresh,shards,but,already,has,shards,created,for,int,shard,number,0,shard,number,index,meta,data,get,number,of,shards,shard,number,shard,id,shard,id,new,shard,id,index,shard,number,final,recovery,source,primary,recovery,source,if,index,meta,data,in,sync,allocation,ids,shard,number,is,empty,false,primary,recovery,source,store,recovery,source,else,if,index,meta,data,get,resize,source,index,null,primary,recovery,source,local,shards,recovery,source,instance,else,primary,recovery,source,store,recovery,source,index,shard,routing,table,builder,index,shard,routing,builder,new,index,shard,routing,table,builder,shard,id,for,int,i,0,i,index,meta,data,get,number,of,replicas,i,boolean,primary,i,0,index,shard,routing,builder,add,shard,shard,routing,new,unassigned,shard,id,primary,primary,primary,recovery,source,peer,recovery,source,instance,unassigned,info,shards,put,shard,number,index,shard,routing,builder,build,return,this
IndexRoutingTable -> Builder -> private Builder initializeEmpty(IndexMetaData indexMetaData, UnassignedInfo unassignedInfo);1525334055;Initializes a new empty index, with an option to control if its from an API or not.;private Builder initializeEmpty(IndexMetaData indexMetaData, UnassignedInfo unassignedInfo) {_            assert indexMetaData.getIndex().equals(index)__            if (!shards.isEmpty()) {_                throw new IllegalStateException("trying to initialize an index with fresh shards, but already has shards created")__            }_            for (int shardNumber = 0_ shardNumber < indexMetaData.getNumberOfShards()_ shardNumber++) {_                ShardId shardId = new ShardId(index, shardNumber)__                final RecoverySource primaryRecoverySource__                if (indexMetaData.inSyncAllocationIds(shardNumber).isEmpty() == false) {_                    _                    primaryRecoverySource = StoreRecoverySource.EXISTING_STORE_INSTANCE__                } else if (indexMetaData.getResizeSourceIndex() != null) {_                    _                    primaryRecoverySource = LocalShardsRecoverySource.INSTANCE__                } else {_                    _                    primaryRecoverySource = StoreRecoverySource.EMPTY_STORE_INSTANCE__                }_                IndexShardRoutingTable.Builder indexShardRoutingBuilder = new IndexShardRoutingTable.Builder(shardId)__                for (int i = 0_ i <= indexMetaData.getNumberOfReplicas()_ i++) {_                    boolean primary = i == 0__                    indexShardRoutingBuilder.addShard(ShardRouting.newUnassigned(shardId, primary,_                        primary ? primaryRecoverySource : PeerRecoverySource.INSTANCE, unassignedInfo))__                }_                shards.put(shardNumber, indexShardRoutingBuilder.build())__            }_            return this__        };initializes,a,new,empty,index,with,an,option,to,control,if,its,from,an,api,or,not;private,builder,initialize,empty,index,meta,data,index,meta,data,unassigned,info,unassigned,info,assert,index,meta,data,get,index,equals,index,if,shards,is,empty,throw,new,illegal,state,exception,trying,to,initialize,an,index,with,fresh,shards,but,already,has,shards,created,for,int,shard,number,0,shard,number,index,meta,data,get,number,of,shards,shard,number,shard,id,shard,id,new,shard,id,index,shard,number,final,recovery,source,primary,recovery,source,if,index,meta,data,in,sync,allocation,ids,shard,number,is,empty,false,primary,recovery,source,store,recovery,source,else,if,index,meta,data,get,resize,source,index,null,primary,recovery,source,local,shards,recovery,source,instance,else,primary,recovery,source,store,recovery,source,index,shard,routing,table,builder,index,shard,routing,builder,new,index,shard,routing,table,builder,shard,id,for,int,i,0,i,index,meta,data,get,number,of,replicas,i,boolean,primary,i,0,index,shard,routing,builder,add,shard,shard,routing,new,unassigned,shard,id,primary,primary,primary,recovery,source,peer,recovery,source,instance,unassigned,info,shards,put,shard,number,index,shard,routing,builder,build,return,this
IndexRoutingTable -> Builder -> private Builder initializeEmpty(IndexMetaData indexMetaData, UnassignedInfo unassignedInfo);1536611444;Initializes a new empty index, with an option to control if its from an API or not.;private Builder initializeEmpty(IndexMetaData indexMetaData, UnassignedInfo unassignedInfo) {_            assert indexMetaData.getIndex().equals(index)__            if (!shards.isEmpty()) {_                throw new IllegalStateException("trying to initialize an index with fresh shards, but already has shards created")__            }_            for (int shardNumber = 0_ shardNumber < indexMetaData.getNumberOfShards()_ shardNumber++) {_                ShardId shardId = new ShardId(index, shardNumber)__                final RecoverySource primaryRecoverySource__                if (indexMetaData.inSyncAllocationIds(shardNumber).isEmpty() == false) {_                    _                    primaryRecoverySource = ExistingStoreRecoverySource.INSTANCE__                } else if (indexMetaData.getResizeSourceIndex() != null) {_                    _                    primaryRecoverySource = LocalShardsRecoverySource.INSTANCE__                } else {_                    _                    primaryRecoverySource = EmptyStoreRecoverySource.INSTANCE__                }_                IndexShardRoutingTable.Builder indexShardRoutingBuilder = new IndexShardRoutingTable.Builder(shardId)__                for (int i = 0_ i <= indexMetaData.getNumberOfReplicas()_ i++) {_                    boolean primary = i == 0__                    indexShardRoutingBuilder.addShard(ShardRouting.newUnassigned(shardId, primary,_                        primary ? primaryRecoverySource : PeerRecoverySource.INSTANCE, unassignedInfo))__                }_                shards.put(shardNumber, indexShardRoutingBuilder.build())__            }_            return this__        };initializes,a,new,empty,index,with,an,option,to,control,if,its,from,an,api,or,not;private,builder,initialize,empty,index,meta,data,index,meta,data,unassigned,info,unassigned,info,assert,index,meta,data,get,index,equals,index,if,shards,is,empty,throw,new,illegal,state,exception,trying,to,initialize,an,index,with,fresh,shards,but,already,has,shards,created,for,int,shard,number,0,shard,number,index,meta,data,get,number,of,shards,shard,number,shard,id,shard,id,new,shard,id,index,shard,number,final,recovery,source,primary,recovery,source,if,index,meta,data,in,sync,allocation,ids,shard,number,is,empty,false,primary,recovery,source,existing,store,recovery,source,instance,else,if,index,meta,data,get,resize,source,index,null,primary,recovery,source,local,shards,recovery,source,instance,else,primary,recovery,source,empty,store,recovery,source,instance,index,shard,routing,table,builder,index,shard,routing,builder,new,index,shard,routing,table,builder,shard,id,for,int,i,0,i,index,meta,data,get,number,of,replicas,i,boolean,primary,i,0,index,shard,routing,builder,add,shard,shard,routing,new,unassigned,shard,id,primary,primary,primary,recovery,source,peer,recovery,source,instance,unassigned,info,shards,put,shard,number,index,shard,routing,builder,build,return,this
IndexRoutingTable -> Builder -> private Builder initializeEmpty(IndexMetaData indexMetaData, UnassignedInfo unassignedInfo);1540847035;Initializes a new empty index, with an option to control if its from an API or not.;private Builder initializeEmpty(IndexMetaData indexMetaData, UnassignedInfo unassignedInfo) {_            assert indexMetaData.getIndex().equals(index)__            if (!shards.isEmpty()) {_                throw new IllegalStateException("trying to initialize an index with fresh shards, but already has shards created")__            }_            for (int shardNumber = 0_ shardNumber < indexMetaData.getNumberOfShards()_ shardNumber++) {_                ShardId shardId = new ShardId(index, shardNumber)__                final RecoverySource primaryRecoverySource__                if (indexMetaData.inSyncAllocationIds(shardNumber).isEmpty() == false) {_                    _                    primaryRecoverySource = ExistingStoreRecoverySource.INSTANCE__                } else if (indexMetaData.getResizeSourceIndex() != null) {_                    _                    primaryRecoverySource = LocalShardsRecoverySource.INSTANCE__                } else {_                    _                    primaryRecoverySource = EmptyStoreRecoverySource.INSTANCE__                }_                IndexShardRoutingTable.Builder indexShardRoutingBuilder = new IndexShardRoutingTable.Builder(shardId)__                for (int i = 0_ i <= indexMetaData.getNumberOfReplicas()_ i++) {_                    boolean primary = i == 0__                    indexShardRoutingBuilder.addShard(ShardRouting.newUnassigned(shardId, primary,_                        primary ? primaryRecoverySource : PeerRecoverySource.INSTANCE, unassignedInfo))__                }_                shards.put(shardNumber, indexShardRoutingBuilder.build())__            }_            return this__        };initializes,a,new,empty,index,with,an,option,to,control,if,its,from,an,api,or,not;private,builder,initialize,empty,index,meta,data,index,meta,data,unassigned,info,unassigned,info,assert,index,meta,data,get,index,equals,index,if,shards,is,empty,throw,new,illegal,state,exception,trying,to,initialize,an,index,with,fresh,shards,but,already,has,shards,created,for,int,shard,number,0,shard,number,index,meta,data,get,number,of,shards,shard,number,shard,id,shard,id,new,shard,id,index,shard,number,final,recovery,source,primary,recovery,source,if,index,meta,data,in,sync,allocation,ids,shard,number,is,empty,false,primary,recovery,source,existing,store,recovery,source,instance,else,if,index,meta,data,get,resize,source,index,null,primary,recovery,source,local,shards,recovery,source,instance,else,primary,recovery,source,empty,store,recovery,source,instance,index,shard,routing,table,builder,index,shard,routing,builder,new,index,shard,routing,table,builder,shard,id,for,int,i,0,i,index,meta,data,get,number,of,replicas,i,boolean,primary,i,0,index,shard,routing,builder,add,shard,shard,routing,new,unassigned,shard,id,primary,primary,primary,recovery,source,peer,recovery,source,instance,unassigned,info,shards,put,shard,number,index,shard,routing,builder,build,return,this
IndexRoutingTable -> Builder -> private Builder initializeEmpty(IndexMetaData indexMetaData, UnassignedInfo unassignedInfo);1541618291;Initializes a new empty index, with an option to control if its from an API or not.;private Builder initializeEmpty(IndexMetaData indexMetaData, UnassignedInfo unassignedInfo) {_            assert indexMetaData.getIndex().equals(index)__            if (!shards.isEmpty()) {_                throw new IllegalStateException("trying to initialize an index with fresh shards, but already has shards created")__            }_            for (int shardNumber = 0_ shardNumber < indexMetaData.getNumberOfShards()_ shardNumber++) {_                ShardId shardId = new ShardId(index, shardNumber)__                final RecoverySource primaryRecoverySource__                if (indexMetaData.inSyncAllocationIds(shardNumber).isEmpty() == false) {_                    _                    primaryRecoverySource = ExistingStoreRecoverySource.INSTANCE__                } else if (indexMetaData.getResizeSourceIndex() != null) {_                    _                    primaryRecoverySource = LocalShardsRecoverySource.INSTANCE__                } else {_                    _                    primaryRecoverySource = EmptyStoreRecoverySource.INSTANCE__                }_                IndexShardRoutingTable.Builder indexShardRoutingBuilder = new IndexShardRoutingTable.Builder(shardId)__                for (int i = 0_ i <= indexMetaData.getNumberOfReplicas()_ i++) {_                    boolean primary = i == 0__                    indexShardRoutingBuilder.addShard(ShardRouting.newUnassigned(shardId, primary,_                        primary ? primaryRecoverySource : PeerRecoverySource.INSTANCE, unassignedInfo))__                }_                shards.put(shardNumber, indexShardRoutingBuilder.build())__            }_            return this__        };initializes,a,new,empty,index,with,an,option,to,control,if,its,from,an,api,or,not;private,builder,initialize,empty,index,meta,data,index,meta,data,unassigned,info,unassigned,info,assert,index,meta,data,get,index,equals,index,if,shards,is,empty,throw,new,illegal,state,exception,trying,to,initialize,an,index,with,fresh,shards,but,already,has,shards,created,for,int,shard,number,0,shard,number,index,meta,data,get,number,of,shards,shard,number,shard,id,shard,id,new,shard,id,index,shard,number,final,recovery,source,primary,recovery,source,if,index,meta,data,in,sync,allocation,ids,shard,number,is,empty,false,primary,recovery,source,existing,store,recovery,source,instance,else,if,index,meta,data,get,resize,source,index,null,primary,recovery,source,local,shards,recovery,source,instance,else,primary,recovery,source,empty,store,recovery,source,instance,index,shard,routing,table,builder,index,shard,routing,builder,new,index,shard,routing,table,builder,shard,id,for,int,i,0,i,index,meta,data,get,number,of,replicas,i,boolean,primary,i,0,index,shard,routing,builder,add,shard,shard,routing,new,unassigned,shard,id,primary,primary,primary,recovery,source,peer,recovery,source,instance,unassigned,info,shards,put,shard,number,index,shard,routing,builder,build,return,this
IndexRoutingTable -> Builder -> public Builder initializeAsFromDangling(IndexMetaData indexMetaData);1524684173;Initializes a new index caused by dangling index imported.;public Builder initializeAsFromDangling(IndexMetaData indexMetaData) {_            return initializeEmpty(indexMetaData, new UnassignedInfo(UnassignedInfo.Reason.DANGLING_INDEX_IMPORTED, null))__        };initializes,a,new,index,caused,by,dangling,index,imported;public,builder,initialize,as,from,dangling,index,meta,data,index,meta,data,return,initialize,empty,index,meta,data,new,unassigned,info,unassigned,info,reason,null
IndexRoutingTable -> Builder -> public Builder initializeAsFromDangling(IndexMetaData indexMetaData);1525334055;Initializes a new index caused by dangling index imported.;public Builder initializeAsFromDangling(IndexMetaData indexMetaData) {_            return initializeEmpty(indexMetaData, new UnassignedInfo(UnassignedInfo.Reason.DANGLING_INDEX_IMPORTED, null))__        };initializes,a,new,index,caused,by,dangling,index,imported;public,builder,initialize,as,from,dangling,index,meta,data,index,meta,data,return,initialize,empty,index,meta,data,new,unassigned,info,unassigned,info,reason,null
IndexRoutingTable -> Builder -> public Builder initializeAsFromDangling(IndexMetaData indexMetaData);1536611444;Initializes a new index caused by dangling index imported.;public Builder initializeAsFromDangling(IndexMetaData indexMetaData) {_            return initializeEmpty(indexMetaData, new UnassignedInfo(UnassignedInfo.Reason.DANGLING_INDEX_IMPORTED, null))__        };initializes,a,new,index,caused,by,dangling,index,imported;public,builder,initialize,as,from,dangling,index,meta,data,index,meta,data,return,initialize,empty,index,meta,data,new,unassigned,info,unassigned,info,reason,null
IndexRoutingTable -> Builder -> public Builder initializeAsFromDangling(IndexMetaData indexMetaData);1540847035;Initializes a new index caused by dangling index imported.;public Builder initializeAsFromDangling(IndexMetaData indexMetaData) {_            return initializeEmpty(indexMetaData, new UnassignedInfo(UnassignedInfo.Reason.DANGLING_INDEX_IMPORTED, null))__        };initializes,a,new,index,caused,by,dangling,index,imported;public,builder,initialize,as,from,dangling,index,meta,data,index,meta,data,return,initialize,empty,index,meta,data,new,unassigned,info,unassigned,info,reason,null
IndexRoutingTable -> Builder -> public Builder initializeAsFromDangling(IndexMetaData indexMetaData);1541618291;Initializes a new index caused by dangling index imported.;public Builder initializeAsFromDangling(IndexMetaData indexMetaData) {_            return initializeEmpty(indexMetaData, new UnassignedInfo(UnassignedInfo.Reason.DANGLING_INDEX_IMPORTED, null))__        };initializes,a,new,index,caused,by,dangling,index,imported;public,builder,initialize,as,from,dangling,index,meta,data,index,meta,data,return,initialize,empty,index,meta,data,new,unassigned,info,unassigned,info,reason,null
IndexRoutingTable -> public ShardsIterator randomAllActiveShardsIt();1524684173;Returns an unordered iterator over all active shards (including replicas).;public ShardsIterator randomAllActiveShardsIt() {_        return new PlainShardsIterator(shuffler.shuffle(allActiveShards))__    };returns,an,unordered,iterator,over,all,active,shards,including,replicas;public,shards,iterator,random,all,active,shards,it,return,new,plain,shards,iterator,shuffler,shuffle,all,active,shards
IndexRoutingTable -> public ShardsIterator randomAllActiveShardsIt();1525334055;Returns an unordered iterator over all active shards (including replicas).;public ShardsIterator randomAllActiveShardsIt() {_        return new PlainShardsIterator(shuffler.shuffle(allActiveShards))__    };returns,an,unordered,iterator,over,all,active,shards,including,replicas;public,shards,iterator,random,all,active,shards,it,return,new,plain,shards,iterator,shuffler,shuffle,all,active,shards
IndexRoutingTable -> public ShardsIterator randomAllActiveShardsIt();1536611444;Returns an unordered iterator over all active shards (including replicas).;public ShardsIterator randomAllActiveShardsIt() {_        return new PlainShardsIterator(shuffler.shuffle(allActiveShards))__    };returns,an,unordered,iterator,over,all,active,shards,including,replicas;public,shards,iterator,random,all,active,shards,it,return,new,plain,shards,iterator,shuffler,shuffle,all,active,shards
IndexRoutingTable -> public ShardsIterator randomAllActiveShardsIt();1540847035;Returns an unordered iterator over all active shards (including replicas).;public ShardsIterator randomAllActiveShardsIt() {_        return new PlainShardsIterator(shuffler.shuffle(allActiveShards))__    };returns,an,unordered,iterator,over,all,active,shards,including,replicas;public,shards,iterator,random,all,active,shards,it,return,new,plain,shards,iterator,shuffler,shuffle,all,active,shards
IndexRoutingTable -> public ShardsIterator randomAllActiveShardsIt();1541618291;Returns an unordered iterator over all active shards (including replicas).;public ShardsIterator randomAllActiveShardsIt() {_        return new PlainShardsIterator(shuffler.shuffle(allActiveShards))__    };returns,an,unordered,iterator,over,all,active,shards,including,replicas;public,shards,iterator,random,all,active,shards,it,return,new,plain,shards,iterator,shuffler,shuffle,all,active,shards
IndexRoutingTable -> Builder -> public Builder initializeAsNewRestore(IndexMetaData indexMetaData, SnapshotRecoverySource recoverySource, IntSet ignoreShards);1524684173;Initializes a new empty index, to be restored from a snapshot;public Builder initializeAsNewRestore(IndexMetaData indexMetaData, SnapshotRecoverySource recoverySource, IntSet ignoreShards) {_            final UnassignedInfo unassignedInfo = new UnassignedInfo(UnassignedInfo.Reason.NEW_INDEX_RESTORED,_                                                                     "restore_source[" + recoverySource.snapshot().getRepository() + "/" +_                                                                         recoverySource.snapshot().getSnapshotId().getName() + "]")__            return initializeAsRestore(indexMetaData, recoverySource, ignoreShards, true, unassignedInfo)__        };initializes,a,new,empty,index,to,be,restored,from,a,snapshot;public,builder,initialize,as,new,restore,index,meta,data,index,meta,data,snapshot,recovery,source,recovery,source,int,set,ignore,shards,final,unassigned,info,unassigned,info,new,unassigned,info,unassigned,info,reason,recovery,source,snapshot,get,repository,recovery,source,snapshot,get,snapshot,id,get,name,return,initialize,as,restore,index,meta,data,recovery,source,ignore,shards,true,unassigned,info
IndexRoutingTable -> Builder -> public Builder initializeAsNewRestore(IndexMetaData indexMetaData, SnapshotRecoverySource recoverySource, IntSet ignoreShards);1525334055;Initializes a new empty index, to be restored from a snapshot;public Builder initializeAsNewRestore(IndexMetaData indexMetaData, SnapshotRecoverySource recoverySource, IntSet ignoreShards) {_            final UnassignedInfo unassignedInfo = new UnassignedInfo(UnassignedInfo.Reason.NEW_INDEX_RESTORED,_                                                                     "restore_source[" + recoverySource.snapshot().getRepository() + "/" +_                                                                         recoverySource.snapshot().getSnapshotId().getName() + "]")__            return initializeAsRestore(indexMetaData, recoverySource, ignoreShards, true, unassignedInfo)__        };initializes,a,new,empty,index,to,be,restored,from,a,snapshot;public,builder,initialize,as,new,restore,index,meta,data,index,meta,data,snapshot,recovery,source,recovery,source,int,set,ignore,shards,final,unassigned,info,unassigned,info,new,unassigned,info,unassigned,info,reason,recovery,source,snapshot,get,repository,recovery,source,snapshot,get,snapshot,id,get,name,return,initialize,as,restore,index,meta,data,recovery,source,ignore,shards,true,unassigned,info
IndexRoutingTable -> Builder -> public Builder initializeAsNewRestore(IndexMetaData indexMetaData, SnapshotRecoverySource recoverySource, IntSet ignoreShards);1536611444;Initializes a new empty index, to be restored from a snapshot;public Builder initializeAsNewRestore(IndexMetaData indexMetaData, SnapshotRecoverySource recoverySource, IntSet ignoreShards) {_            final UnassignedInfo unassignedInfo = new UnassignedInfo(UnassignedInfo.Reason.NEW_INDEX_RESTORED,_                                                                     "restore_source[" + recoverySource.snapshot().getRepository() + "/" +_                                                                         recoverySource.snapshot().getSnapshotId().getName() + "]")__            return initializeAsRestore(indexMetaData, recoverySource, ignoreShards, true, unassignedInfo)__        };initializes,a,new,empty,index,to,be,restored,from,a,snapshot;public,builder,initialize,as,new,restore,index,meta,data,index,meta,data,snapshot,recovery,source,recovery,source,int,set,ignore,shards,final,unassigned,info,unassigned,info,new,unassigned,info,unassigned,info,reason,recovery,source,snapshot,get,repository,recovery,source,snapshot,get,snapshot,id,get,name,return,initialize,as,restore,index,meta,data,recovery,source,ignore,shards,true,unassigned,info
IndexRoutingTable -> Builder -> public Builder initializeAsNewRestore(IndexMetaData indexMetaData, SnapshotRecoverySource recoverySource, IntSet ignoreShards);1540847035;Initializes a new empty index, to be restored from a snapshot;public Builder initializeAsNewRestore(IndexMetaData indexMetaData, SnapshotRecoverySource recoverySource, IntSet ignoreShards) {_            final UnassignedInfo unassignedInfo = new UnassignedInfo(UnassignedInfo.Reason.NEW_INDEX_RESTORED,_                "restore_source[" + recoverySource.snapshot().getRepository() + "/" +_                 recoverySource.snapshot().getSnapshotId().getName() + "]")__            return initializeAsRestore(indexMetaData, recoverySource, ignoreShards, true, unassignedInfo)__        };initializes,a,new,empty,index,to,be,restored,from,a,snapshot;public,builder,initialize,as,new,restore,index,meta,data,index,meta,data,snapshot,recovery,source,recovery,source,int,set,ignore,shards,final,unassigned,info,unassigned,info,new,unassigned,info,unassigned,info,reason,recovery,source,snapshot,get,repository,recovery,source,snapshot,get,snapshot,id,get,name,return,initialize,as,restore,index,meta,data,recovery,source,ignore,shards,true,unassigned,info
IndexRoutingTable -> Builder -> public Builder initializeAsNewRestore(IndexMetaData indexMetaData, SnapshotRecoverySource recoverySource, IntSet ignoreShards);1541618291;Initializes a new empty index, to be restored from a snapshot;public Builder initializeAsNewRestore(IndexMetaData indexMetaData, SnapshotRecoverySource recoverySource, IntSet ignoreShards) {_            final UnassignedInfo unassignedInfo = new UnassignedInfo(UnassignedInfo.Reason.NEW_INDEX_RESTORED,_                "restore_source[" + recoverySource.snapshot().getRepository() + "/" +_                 recoverySource.snapshot().getSnapshotId().getName() + "]")__            return initializeAsRestore(indexMetaData, recoverySource, ignoreShards, true, unassignedInfo)__        };initializes,a,new,empty,index,to,be,restored,from,a,snapshot;public,builder,initialize,as,new,restore,index,meta,data,index,meta,data,snapshot,recovery,source,recovery,source,int,set,ignore,shards,final,unassigned,info,unassigned,info,new,unassigned,info,unassigned,info,reason,recovery,source,snapshot,get,repository,recovery,source,snapshot,get,snapshot,id,get,name,return,initialize,as,restore,index,meta,data,recovery,source,ignore,shards,true,unassigned,info
IndexRoutingTable -> public boolean allPrimaryShardsUnassigned();1524684173;Returns <code>true</code> if all primary shards are in_{@link ShardRoutingState#UNASSIGNED} state. Otherwise <code>false</code>.;public boolean allPrimaryShardsUnassigned() {_        return primaryShardsUnassigned() == shards.size()__    };returns,code,true,code,if,all,primary,shards,are,in,link,shard,routing,state,unassigned,state,otherwise,code,false,code;public,boolean,all,primary,shards,unassigned,return,primary,shards,unassigned,shards,size
IndexRoutingTable -> public boolean allPrimaryShardsUnassigned();1525334055;Returns <code>true</code> if all primary shards are in_{@link ShardRoutingState#UNASSIGNED} state. Otherwise <code>false</code>.;public boolean allPrimaryShardsUnassigned() {_        return primaryShardsUnassigned() == shards.size()__    };returns,code,true,code,if,all,primary,shards,are,in,link,shard,routing,state,unassigned,state,otherwise,code,false,code;public,boolean,all,primary,shards,unassigned,return,primary,shards,unassigned,shards,size
IndexRoutingTable -> public boolean allPrimaryShardsUnassigned();1536611444;Returns <code>true</code> if all primary shards are in_{@link ShardRoutingState#UNASSIGNED} state. Otherwise <code>false</code>.;public boolean allPrimaryShardsUnassigned() {_        return primaryShardsUnassigned() == shards.size()__    };returns,code,true,code,if,all,primary,shards,are,in,link,shard,routing,state,unassigned,state,otherwise,code,false,code;public,boolean,all,primary,shards,unassigned,return,primary,shards,unassigned,shards,size
IndexRoutingTable -> public boolean allPrimaryShardsUnassigned();1540847035;Returns <code>true</code> if all primary shards are in_{@link ShardRoutingState#UNASSIGNED} state. Otherwise <code>false</code>.;public boolean allPrimaryShardsUnassigned() {_        return primaryShardsUnassigned() == shards.size()__    };returns,code,true,code,if,all,primary,shards,are,in,link,shard,routing,state,unassigned,state,otherwise,code,false,code;public,boolean,all,primary,shards,unassigned,return,primary,shards,unassigned,shards,size
IndexRoutingTable -> public boolean allPrimaryShardsUnassigned();1541618291;Returns <code>true</code> if all primary shards are in_{@link ShardRoutingState#UNASSIGNED} state. Otherwise <code>false</code>.;public boolean allPrimaryShardsUnassigned() {_        return primaryShardsUnassigned() == shards.size()__    };returns,code,true,code,if,all,primary,shards,are,in,link,shard,routing,state,unassigned,state,otherwise,code,false,code;public,boolean,all,primary,shards,unassigned,return,primary,shards,unassigned,shards,size
IndexRoutingTable -> public int primaryShardsUnassigned();1524684173;Calculates the number of primary shards in the routing table the are in_{@link ShardRoutingState#UNASSIGNED} state.;public int primaryShardsUnassigned() {_        int counter = 0__        for (IndexShardRoutingTable shardRoutingTable : this) {_            if (shardRoutingTable.primaryShard().unassigned()) {_                counter++__            }_        }_        return counter__    };calculates,the,number,of,primary,shards,in,the,routing,table,the,are,in,link,shard,routing,state,unassigned,state;public,int,primary,shards,unassigned,int,counter,0,for,index,shard,routing,table,shard,routing,table,this,if,shard,routing,table,primary,shard,unassigned,counter,return,counter
IndexRoutingTable -> public int primaryShardsUnassigned();1525334055;Calculates the number of primary shards in the routing table the are in_{@link ShardRoutingState#UNASSIGNED} state.;public int primaryShardsUnassigned() {_        int counter = 0__        for (IndexShardRoutingTable shardRoutingTable : this) {_            if (shardRoutingTable.primaryShard().unassigned()) {_                counter++__            }_        }_        return counter__    };calculates,the,number,of,primary,shards,in,the,routing,table,the,are,in,link,shard,routing,state,unassigned,state;public,int,primary,shards,unassigned,int,counter,0,for,index,shard,routing,table,shard,routing,table,this,if,shard,routing,table,primary,shard,unassigned,counter,return,counter
IndexRoutingTable -> public int primaryShardsUnassigned();1536611444;Calculates the number of primary shards in the routing table the are in_{@link ShardRoutingState#UNASSIGNED} state.;public int primaryShardsUnassigned() {_        int counter = 0__        for (IndexShardRoutingTable shardRoutingTable : this) {_            if (shardRoutingTable.primaryShard().unassigned()) {_                counter++__            }_        }_        return counter__    };calculates,the,number,of,primary,shards,in,the,routing,table,the,are,in,link,shard,routing,state,unassigned,state;public,int,primary,shards,unassigned,int,counter,0,for,index,shard,routing,table,shard,routing,table,this,if,shard,routing,table,primary,shard,unassigned,counter,return,counter
IndexRoutingTable -> public int primaryShardsUnassigned();1540847035;Calculates the number of primary shards in the routing table the are in_{@link ShardRoutingState#UNASSIGNED} state.;public int primaryShardsUnassigned() {_        int counter = 0__        for (IndexShardRoutingTable shardRoutingTable : this) {_            if (shardRoutingTable.primaryShard().unassigned()) {_                counter++__            }_        }_        return counter__    };calculates,the,number,of,primary,shards,in,the,routing,table,the,are,in,link,shard,routing,state,unassigned,state;public,int,primary,shards,unassigned,int,counter,0,for,index,shard,routing,table,shard,routing,table,this,if,shard,routing,table,primary,shard,unassigned,counter,return,counter
IndexRoutingTable -> public int primaryShardsUnassigned();1541618291;Calculates the number of primary shards in the routing table the are in_{@link ShardRoutingState#UNASSIGNED} state.;public int primaryShardsUnassigned() {_        int counter = 0__        for (IndexShardRoutingTable shardRoutingTable : this) {_            if (shardRoutingTable.primaryShard().unassigned()) {_                counter++__            }_        }_        return counter__    };calculates,the,number,of,primary,shards,in,the,routing,table,the,are,in,link,shard,routing,state,unassigned,state;public,int,primary,shards,unassigned,int,counter,0,for,index,shard,routing,table,shard,routing,table,this,if,shard,routing,table,primary,shard,unassigned,counter,return,counter
IndexRoutingTable -> public boolean allPrimaryShardsActive();1524684173;Returns <code>true</code> if all shards are primary and active. Otherwise <code>false</code>.;public boolean allPrimaryShardsActive() {_        return primaryShardsActive() == shards().size()__    };returns,code,true,code,if,all,shards,are,primary,and,active,otherwise,code,false,code;public,boolean,all,primary,shards,active,return,primary,shards,active,shards,size
IndexRoutingTable -> public boolean allPrimaryShardsActive();1525334055;Returns <code>true</code> if all shards are primary and active. Otherwise <code>false</code>.;public boolean allPrimaryShardsActive() {_        return primaryShardsActive() == shards().size()__    };returns,code,true,code,if,all,shards,are,primary,and,active,otherwise,code,false,code;public,boolean,all,primary,shards,active,return,primary,shards,active,shards,size
IndexRoutingTable -> public boolean allPrimaryShardsActive();1536611444;Returns <code>true</code> if all shards are primary and active. Otherwise <code>false</code>.;public boolean allPrimaryShardsActive() {_        return primaryShardsActive() == shards().size()__    };returns,code,true,code,if,all,shards,are,primary,and,active,otherwise,code,false,code;public,boolean,all,primary,shards,active,return,primary,shards,active,shards,size
IndexRoutingTable -> public boolean allPrimaryShardsActive();1540847035;Returns <code>true</code> if all shards are primary and active. Otherwise <code>false</code>.;public boolean allPrimaryShardsActive() {_        return primaryShardsActive() == shards().size()__    };returns,code,true,code,if,all,shards,are,primary,and,active,otherwise,code,false,code;public,boolean,all,primary,shards,active,return,primary,shards,active,shards,size
IndexRoutingTable -> public boolean allPrimaryShardsActive();1541618291;Returns <code>true</code> if all shards are primary and active. Otherwise <code>false</code>.;public boolean allPrimaryShardsActive() {_        return primaryShardsActive() == shards().size()__    };returns,code,true,code,if,all,shards,are,primary,and,active,otherwise,code,false,code;public,boolean,all,primary,shards,active,return,primary,shards,active,shards,size
IndexRoutingTable -> public List<ShardRouting> shardsWithState(ShardRoutingState state);1524684173;Returns a {@link List} of shards that match one of the states listed in {@link ShardRoutingState states}__@param state {@link ShardRoutingState} to retrieve_@return a {@link List} of shards that match one of the given {@link ShardRoutingState states};public List<ShardRouting> shardsWithState(ShardRoutingState state) {_        List<ShardRouting> shards = new ArrayList<>()__        for (IndexShardRoutingTable shardRoutingTable : this) {_            shards.addAll(shardRoutingTable.shardsWithState(state))__        }_        return shards__    };returns,a,link,list,of,shards,that,match,one,of,the,states,listed,in,link,shard,routing,state,states,param,state,link,shard,routing,state,to,retrieve,return,a,link,list,of,shards,that,match,one,of,the,given,link,shard,routing,state,states;public,list,shard,routing,shards,with,state,shard,routing,state,state,list,shard,routing,shards,new,array,list,for,index,shard,routing,table,shard,routing,table,this,shards,add,all,shard,routing,table,shards,with,state,state,return,shards
IndexRoutingTable -> public List<ShardRouting> shardsWithState(ShardRoutingState state);1525334055;Returns a {@link List} of shards that match one of the states listed in {@link ShardRoutingState states}__@param state {@link ShardRoutingState} to retrieve_@return a {@link List} of shards that match one of the given {@link ShardRoutingState states};public List<ShardRouting> shardsWithState(ShardRoutingState state) {_        List<ShardRouting> shards = new ArrayList<>()__        for (IndexShardRoutingTable shardRoutingTable : this) {_            shards.addAll(shardRoutingTable.shardsWithState(state))__        }_        return shards__    };returns,a,link,list,of,shards,that,match,one,of,the,states,listed,in,link,shard,routing,state,states,param,state,link,shard,routing,state,to,retrieve,return,a,link,list,of,shards,that,match,one,of,the,given,link,shard,routing,state,states;public,list,shard,routing,shards,with,state,shard,routing,state,state,list,shard,routing,shards,new,array,list,for,index,shard,routing,table,shard,routing,table,this,shards,add,all,shard,routing,table,shards,with,state,state,return,shards
IndexRoutingTable -> public List<ShardRouting> shardsWithState(ShardRoutingState state);1536611444;Returns a {@link List} of shards that match one of the states listed in {@link ShardRoutingState states}__@param state {@link ShardRoutingState} to retrieve_@return a {@link List} of shards that match one of the given {@link ShardRoutingState states};public List<ShardRouting> shardsWithState(ShardRoutingState state) {_        List<ShardRouting> shards = new ArrayList<>()__        for (IndexShardRoutingTable shardRoutingTable : this) {_            shards.addAll(shardRoutingTable.shardsWithState(state))__        }_        return shards__    };returns,a,link,list,of,shards,that,match,one,of,the,states,listed,in,link,shard,routing,state,states,param,state,link,shard,routing,state,to,retrieve,return,a,link,list,of,shards,that,match,one,of,the,given,link,shard,routing,state,states;public,list,shard,routing,shards,with,state,shard,routing,state,state,list,shard,routing,shards,new,array,list,for,index,shard,routing,table,shard,routing,table,this,shards,add,all,shard,routing,table,shards,with,state,state,return,shards
IndexRoutingTable -> public List<ShardRouting> shardsWithState(ShardRoutingState state);1540847035;Returns a {@link List} of shards that match one of the states listed in {@link ShardRoutingState states}__@param state {@link ShardRoutingState} to retrieve_@return a {@link List} of shards that match one of the given {@link ShardRoutingState states};public List<ShardRouting> shardsWithState(ShardRoutingState state) {_        List<ShardRouting> shards = new ArrayList<>()__        for (IndexShardRoutingTable shardRoutingTable : this) {_            shards.addAll(shardRoutingTable.shardsWithState(state))__        }_        return shards__    };returns,a,link,list,of,shards,that,match,one,of,the,states,listed,in,link,shard,routing,state,states,param,state,link,shard,routing,state,to,retrieve,return,a,link,list,of,shards,that,match,one,of,the,given,link,shard,routing,state,states;public,list,shard,routing,shards,with,state,shard,routing,state,state,list,shard,routing,shards,new,array,list,for,index,shard,routing,table,shard,routing,table,this,shards,add,all,shard,routing,table,shards,with,state,state,return,shards
IndexRoutingTable -> public List<ShardRouting> shardsWithState(ShardRoutingState state);1541618291;Returns a {@link List} of shards that match one of the states listed in {@link ShardRoutingState states}__@param state {@link ShardRoutingState} to retrieve_@return a {@link List} of shards that match one of the given {@link ShardRoutingState states};public List<ShardRouting> shardsWithState(ShardRoutingState state) {_        List<ShardRouting> shards = new ArrayList<>()__        for (IndexShardRoutingTable shardRoutingTable : this) {_            shards.addAll(shardRoutingTable.shardsWithState(state))__        }_        return shards__    };returns,a,link,list,of,shards,that,match,one,of,the,states,listed,in,link,shard,routing,state,states,param,state,link,shard,routing,state,to,retrieve,return,a,link,list,of,shards,that,match,one,of,the,given,link,shard,routing,state,states;public,list,shard,routing,shards,with,state,shard,routing,state,state,list,shard,routing,shards,new,array,list,for,index,shard,routing,table,shard,routing,table,this,shards,add,all,shard,routing,table,shards,with,state,state,return,shards
IndexRoutingTable -> Builder -> public Builder initializeAsRestore(IndexMetaData indexMetaData, SnapshotRecoverySource recoverySource);1524684173;Initializes an existing index, to be restored from a snapshot;public Builder initializeAsRestore(IndexMetaData indexMetaData, SnapshotRecoverySource recoverySource) {_            final UnassignedInfo unassignedInfo = new UnassignedInfo(UnassignedInfo.Reason.EXISTING_INDEX_RESTORED,_                                                                     "restore_source[" + recoverySource.snapshot().getRepository() + "/" +_                                                                         recoverySource.snapshot().getSnapshotId().getName() + "]")__            return initializeAsRestore(indexMetaData, recoverySource, null, false, unassignedInfo)__        };initializes,an,existing,index,to,be,restored,from,a,snapshot;public,builder,initialize,as,restore,index,meta,data,index,meta,data,snapshot,recovery,source,recovery,source,final,unassigned,info,unassigned,info,new,unassigned,info,unassigned,info,reason,recovery,source,snapshot,get,repository,recovery,source,snapshot,get,snapshot,id,get,name,return,initialize,as,restore,index,meta,data,recovery,source,null,false,unassigned,info
IndexRoutingTable -> Builder -> public Builder initializeAsRestore(IndexMetaData indexMetaData, SnapshotRecoverySource recoverySource);1525334055;Initializes an existing index, to be restored from a snapshot;public Builder initializeAsRestore(IndexMetaData indexMetaData, SnapshotRecoverySource recoverySource) {_            final UnassignedInfo unassignedInfo = new UnassignedInfo(UnassignedInfo.Reason.EXISTING_INDEX_RESTORED,_                                                                     "restore_source[" + recoverySource.snapshot().getRepository() + "/" +_                                                                         recoverySource.snapshot().getSnapshotId().getName() + "]")__            return initializeAsRestore(indexMetaData, recoverySource, null, false, unassignedInfo)__        };initializes,an,existing,index,to,be,restored,from,a,snapshot;public,builder,initialize,as,restore,index,meta,data,index,meta,data,snapshot,recovery,source,recovery,source,final,unassigned,info,unassigned,info,new,unassigned,info,unassigned,info,reason,recovery,source,snapshot,get,repository,recovery,source,snapshot,get,snapshot,id,get,name,return,initialize,as,restore,index,meta,data,recovery,source,null,false,unassigned,info
IndexRoutingTable -> Builder -> public Builder initializeAsRestore(IndexMetaData indexMetaData, SnapshotRecoverySource recoverySource);1536611444;Initializes an existing index, to be restored from a snapshot;public Builder initializeAsRestore(IndexMetaData indexMetaData, SnapshotRecoverySource recoverySource) {_            final UnassignedInfo unassignedInfo = new UnassignedInfo(UnassignedInfo.Reason.EXISTING_INDEX_RESTORED,_                                                                     "restore_source[" + recoverySource.snapshot().getRepository() + "/" +_                                                                         recoverySource.snapshot().getSnapshotId().getName() + "]")__            return initializeAsRestore(indexMetaData, recoverySource, null, false, unassignedInfo)__        };initializes,an,existing,index,to,be,restored,from,a,snapshot;public,builder,initialize,as,restore,index,meta,data,index,meta,data,snapshot,recovery,source,recovery,source,final,unassigned,info,unassigned,info,new,unassigned,info,unassigned,info,reason,recovery,source,snapshot,get,repository,recovery,source,snapshot,get,snapshot,id,get,name,return,initialize,as,restore,index,meta,data,recovery,source,null,false,unassigned,info
IndexRoutingTable -> Builder -> public Builder initializeAsRestore(IndexMetaData indexMetaData, SnapshotRecoverySource recoverySource);1540847035;Initializes an existing index, to be restored from a snapshot;public Builder initializeAsRestore(IndexMetaData indexMetaData, SnapshotRecoverySource recoverySource) {_            final UnassignedInfo unassignedInfo = new UnassignedInfo(UnassignedInfo.Reason.EXISTING_INDEX_RESTORED,_                 "restore_source[" + recoverySource.snapshot().getRepository() + "/" +_                 recoverySource.snapshot().getSnapshotId().getName() + "]")__            return initializeAsRestore(indexMetaData, recoverySource, null, false, unassignedInfo)__        };initializes,an,existing,index,to,be,restored,from,a,snapshot;public,builder,initialize,as,restore,index,meta,data,index,meta,data,snapshot,recovery,source,recovery,source,final,unassigned,info,unassigned,info,new,unassigned,info,unassigned,info,reason,recovery,source,snapshot,get,repository,recovery,source,snapshot,get,snapshot,id,get,name,return,initialize,as,restore,index,meta,data,recovery,source,null,false,unassigned,info
IndexRoutingTable -> Builder -> public Builder initializeAsRestore(IndexMetaData indexMetaData, SnapshotRecoverySource recoverySource);1541618291;Initializes an existing index, to be restored from a snapshot;public Builder initializeAsRestore(IndexMetaData indexMetaData, SnapshotRecoverySource recoverySource) {_            final UnassignedInfo unassignedInfo = new UnassignedInfo(UnassignedInfo.Reason.EXISTING_INDEX_RESTORED,_                 "restore_source[" + recoverySource.snapshot().getRepository() + "/" +_                 recoverySource.snapshot().getSnapshotId().getName() + "]")__            return initializeAsRestore(indexMetaData, recoverySource, null, false, unassignedInfo)__        };initializes,an,existing,index,to,be,restored,from,a,snapshot;public,builder,initialize,as,restore,index,meta,data,index,meta,data,snapshot,recovery,source,recovery,source,final,unassigned,info,unassigned,info,new,unassigned,info,unassigned,info,reason,recovery,source,snapshot,get,repository,recovery,source,snapshot,get,snapshot,id,get,name,return,initialize,as,restore,index,meta,data,recovery,source,null,false,unassigned,info
IndexRoutingTable -> Builder -> private Builder initializeAsRestore(IndexMetaData indexMetaData, SnapshotRecoverySource recoverySource, IntSet ignoreShards,                                             boolean asNew, UnassignedInfo unassignedInfo);1540847035;Initializes an index, to be restored from snapshot;private Builder initializeAsRestore(IndexMetaData indexMetaData, SnapshotRecoverySource recoverySource, IntSet ignoreShards,_                                            boolean asNew, UnassignedInfo unassignedInfo) {_            assert indexMetaData.getIndex().equals(index)__            if (!shards.isEmpty()) {_                throw new IllegalStateException("trying to initialize an index with fresh shards, but already has shards created")__            }_            for (int shardNumber = 0_ shardNumber < indexMetaData.getNumberOfShards()_ shardNumber++) {_                ShardId shardId = new ShardId(index, shardNumber)__                IndexShardRoutingTable.Builder indexShardRoutingBuilder = new IndexShardRoutingTable.Builder(shardId)__                for (int i = 0_ i <= indexMetaData.getNumberOfReplicas()_ i++) {_                    boolean primary = i == 0__                    if (asNew && ignoreShards.contains(shardNumber)) {_                        _                        indexShardRoutingBuilder.addShard(ShardRouting.newUnassigned(shardId, primary,_                            primary ? EmptyStoreRecoverySource.INSTANCE : PeerRecoverySource.INSTANCE, unassignedInfo))__                    } else {_                        indexShardRoutingBuilder.addShard(ShardRouting.newUnassigned(shardId, primary,_                            primary ? recoverySource : PeerRecoverySource.INSTANCE, unassignedInfo))__                    }_                }_                shards.put(shardNumber, indexShardRoutingBuilder.build())__            }_            return this__        };initializes,an,index,to,be,restored,from,snapshot;private,builder,initialize,as,restore,index,meta,data,index,meta,data,snapshot,recovery,source,recovery,source,int,set,ignore,shards,boolean,as,new,unassigned,info,unassigned,info,assert,index,meta,data,get,index,equals,index,if,shards,is,empty,throw,new,illegal,state,exception,trying,to,initialize,an,index,with,fresh,shards,but,already,has,shards,created,for,int,shard,number,0,shard,number,index,meta,data,get,number,of,shards,shard,number,shard,id,shard,id,new,shard,id,index,shard,number,index,shard,routing,table,builder,index,shard,routing,builder,new,index,shard,routing,table,builder,shard,id,for,int,i,0,i,index,meta,data,get,number,of,replicas,i,boolean,primary,i,0,if,as,new,ignore,shards,contains,shard,number,index,shard,routing,builder,add,shard,shard,routing,new,unassigned,shard,id,primary,primary,empty,store,recovery,source,instance,peer,recovery,source,instance,unassigned,info,else,index,shard,routing,builder,add,shard,shard,routing,new,unassigned,shard,id,primary,primary,recovery,source,peer,recovery,source,instance,unassigned,info,shards,put,shard,number,index,shard,routing,builder,build,return,this
IndexRoutingTable -> Builder -> private Builder initializeAsRestore(IndexMetaData indexMetaData, SnapshotRecoverySource recoverySource, IntSet ignoreShards,                                             boolean asNew, UnassignedInfo unassignedInfo);1541618291;Initializes an index, to be restored from snapshot;private Builder initializeAsRestore(IndexMetaData indexMetaData, SnapshotRecoverySource recoverySource, IntSet ignoreShards,_                                            boolean asNew, UnassignedInfo unassignedInfo) {_            assert indexMetaData.getIndex().equals(index)__            if (!shards.isEmpty()) {_                throw new IllegalStateException("trying to initialize an index with fresh shards, but already has shards created")__            }_            for (int shardNumber = 0_ shardNumber < indexMetaData.getNumberOfShards()_ shardNumber++) {_                ShardId shardId = new ShardId(index, shardNumber)__                IndexShardRoutingTable.Builder indexShardRoutingBuilder = new IndexShardRoutingTable.Builder(shardId)__                for (int i = 0_ i <= indexMetaData.getNumberOfReplicas()_ i++) {_                    boolean primary = i == 0__                    if (asNew && ignoreShards.contains(shardNumber)) {_                        _                        indexShardRoutingBuilder.addShard(ShardRouting.newUnassigned(shardId, primary,_                            primary ? EmptyStoreRecoverySource.INSTANCE : PeerRecoverySource.INSTANCE, unassignedInfo))__                    } else {_                        indexShardRoutingBuilder.addShard(ShardRouting.newUnassigned(shardId, primary,_                            primary ? recoverySource : PeerRecoverySource.INSTANCE, unassignedInfo))__                    }_                }_                shards.put(shardNumber, indexShardRoutingBuilder.build())__            }_            return this__        };initializes,an,index,to,be,restored,from,snapshot;private,builder,initialize,as,restore,index,meta,data,index,meta,data,snapshot,recovery,source,recovery,source,int,set,ignore,shards,boolean,as,new,unassigned,info,unassigned,info,assert,index,meta,data,get,index,equals,index,if,shards,is,empty,throw,new,illegal,state,exception,trying,to,initialize,an,index,with,fresh,shards,but,already,has,shards,created,for,int,shard,number,0,shard,number,index,meta,data,get,number,of,shards,shard,number,shard,id,shard,id,new,shard,id,index,shard,number,index,shard,routing,table,builder,index,shard,routing,builder,new,index,shard,routing,table,builder,shard,id,for,int,i,0,i,index,meta,data,get,number,of,replicas,i,boolean,primary,i,0,if,as,new,ignore,shards,contains,shard,number,index,shard,routing,builder,add,shard,shard,routing,new,unassigned,shard,id,primary,primary,empty,store,recovery,source,instance,peer,recovery,source,instance,unassigned,info,else,index,shard,routing,builder,add,shard,shard,routing,new,unassigned,shard,id,primary,primary,recovery,source,peer,recovery,source,instance,unassigned,info,shards,put,shard,number,index,shard,routing,builder,build,return,this
IndexRoutingTable -> Builder -> public Builder initializeAsRecovery(IndexMetaData indexMetaData);1524684173;Initializes an existing index.;public Builder initializeAsRecovery(IndexMetaData indexMetaData) {_            return initializeEmpty(indexMetaData, new UnassignedInfo(UnassignedInfo.Reason.CLUSTER_RECOVERED, null))__        };initializes,an,existing,index;public,builder,initialize,as,recovery,index,meta,data,index,meta,data,return,initialize,empty,index,meta,data,new,unassigned,info,unassigned,info,reason,null
IndexRoutingTable -> Builder -> public Builder initializeAsRecovery(IndexMetaData indexMetaData);1525334055;Initializes an existing index.;public Builder initializeAsRecovery(IndexMetaData indexMetaData) {_            return initializeEmpty(indexMetaData, new UnassignedInfo(UnassignedInfo.Reason.CLUSTER_RECOVERED, null))__        };initializes,an,existing,index;public,builder,initialize,as,recovery,index,meta,data,index,meta,data,return,initialize,empty,index,meta,data,new,unassigned,info,unassigned,info,reason,null
IndexRoutingTable -> Builder -> public Builder initializeAsRecovery(IndexMetaData indexMetaData);1536611444;Initializes an existing index.;public Builder initializeAsRecovery(IndexMetaData indexMetaData) {_            return initializeEmpty(indexMetaData, new UnassignedInfo(UnassignedInfo.Reason.CLUSTER_RECOVERED, null))__        };initializes,an,existing,index;public,builder,initialize,as,recovery,index,meta,data,index,meta,data,return,initialize,empty,index,meta,data,new,unassigned,info,unassigned,info,reason,null
IndexRoutingTable -> Builder -> public Builder initializeAsRecovery(IndexMetaData indexMetaData);1540847035;Initializes an existing index.;public Builder initializeAsRecovery(IndexMetaData indexMetaData) {_            return initializeEmpty(indexMetaData, new UnassignedInfo(UnassignedInfo.Reason.CLUSTER_RECOVERED, null))__        };initializes,an,existing,index;public,builder,initialize,as,recovery,index,meta,data,index,meta,data,return,initialize,empty,index,meta,data,new,unassigned,info,unassigned,info,reason,null
IndexRoutingTable -> Builder -> public Builder initializeAsRecovery(IndexMetaData indexMetaData);1541618291;Initializes an existing index.;public Builder initializeAsRecovery(IndexMetaData indexMetaData) {_            return initializeEmpty(indexMetaData, new UnassignedInfo(UnassignedInfo.Reason.CLUSTER_RECOVERED, null))__        };initializes,an,existing,index;public,builder,initialize,as,recovery,index,meta,data,index,meta,data,return,initialize,empty,index,meta,data,new,unassigned,info,unassigned,info,reason,null
IndexRoutingTable -> Builder -> public Builder initializeAsNew(IndexMetaData indexMetaData);1524684173;Initializes a new empty index, as if it was created from an API.;public Builder initializeAsNew(IndexMetaData indexMetaData) {_            return initializeEmpty(indexMetaData, new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, null))__        };initializes,a,new,empty,index,as,if,it,was,created,from,an,api;public,builder,initialize,as,new,index,meta,data,index,meta,data,return,initialize,empty,index,meta,data,new,unassigned,info,unassigned,info,reason,null
IndexRoutingTable -> Builder -> public Builder initializeAsNew(IndexMetaData indexMetaData);1525334055;Initializes a new empty index, as if it was created from an API.;public Builder initializeAsNew(IndexMetaData indexMetaData) {_            return initializeEmpty(indexMetaData, new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, null))__        };initializes,a,new,empty,index,as,if,it,was,created,from,an,api;public,builder,initialize,as,new,index,meta,data,index,meta,data,return,initialize,empty,index,meta,data,new,unassigned,info,unassigned,info,reason,null
IndexRoutingTable -> Builder -> public Builder initializeAsNew(IndexMetaData indexMetaData);1536611444;Initializes a new empty index, as if it was created from an API.;public Builder initializeAsNew(IndexMetaData indexMetaData) {_            return initializeEmpty(indexMetaData, new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, null))__        };initializes,a,new,empty,index,as,if,it,was,created,from,an,api;public,builder,initialize,as,new,index,meta,data,index,meta,data,return,initialize,empty,index,meta,data,new,unassigned,info,unassigned,info,reason,null
IndexRoutingTable -> Builder -> public Builder initializeAsNew(IndexMetaData indexMetaData);1540847035;Initializes a new empty index, as if it was created from an API.;public Builder initializeAsNew(IndexMetaData indexMetaData) {_            return initializeEmpty(indexMetaData, new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, null))__        };initializes,a,new,empty,index,as,if,it,was,created,from,an,api;public,builder,initialize,as,new,index,meta,data,index,meta,data,return,initialize,empty,index,meta,data,new,unassigned,info,unassigned,info,reason,null
IndexRoutingTable -> Builder -> public Builder initializeAsNew(IndexMetaData indexMetaData);1541618291;Initializes a new empty index, as if it was created from an API.;public Builder initializeAsNew(IndexMetaData indexMetaData) {_            return initializeEmpty(indexMetaData, new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, null))__        };initializes,a,new,empty,index,as,if,it,was,created,from,an,api;public,builder,initialize,as,new,index,meta,data,index,meta,data,return,initialize,empty,index,meta,data,new,unassigned,info,unassigned,info,reason,null
IndexRoutingTable -> Builder -> private Builder initializeAsRestore(IndexMetaData indexMetaData, SnapshotRecoverySource recoverySource, IntSet ignoreShards, boolean asNew, UnassignedInfo unassignedInfo);1524684173;Initializes an index, to be restored from snapshot;private Builder initializeAsRestore(IndexMetaData indexMetaData, SnapshotRecoverySource recoverySource, IntSet ignoreShards, boolean asNew, UnassignedInfo unassignedInfo) {_            assert indexMetaData.getIndex().equals(index)__            if (!shards.isEmpty()) {_                throw new IllegalStateException("trying to initialize an index with fresh shards, but already has shards created")__            }_            for (int shardNumber = 0_ shardNumber < indexMetaData.getNumberOfShards()_ shardNumber++) {_                ShardId shardId = new ShardId(index, shardNumber)__                IndexShardRoutingTable.Builder indexShardRoutingBuilder = new IndexShardRoutingTable.Builder(shardId)__                for (int i = 0_ i <= indexMetaData.getNumberOfReplicas()_ i++) {_                    boolean primary = i == 0__                    if (asNew && ignoreShards.contains(shardNumber)) {_                        _                        indexShardRoutingBuilder.addShard(ShardRouting.newUnassigned(shardId, primary,_                            primary ? StoreRecoverySource.EMPTY_STORE_INSTANCE : PeerRecoverySource.INSTANCE, unassignedInfo))__                    } else {_                        indexShardRoutingBuilder.addShard(ShardRouting.newUnassigned(shardId, primary,_                            primary ? recoverySource : PeerRecoverySource.INSTANCE, unassignedInfo))__                    }_                }_                shards.put(shardNumber, indexShardRoutingBuilder.build())__            }_            return this__        };initializes,an,index,to,be,restored,from,snapshot;private,builder,initialize,as,restore,index,meta,data,index,meta,data,snapshot,recovery,source,recovery,source,int,set,ignore,shards,boolean,as,new,unassigned,info,unassigned,info,assert,index,meta,data,get,index,equals,index,if,shards,is,empty,throw,new,illegal,state,exception,trying,to,initialize,an,index,with,fresh,shards,but,already,has,shards,created,for,int,shard,number,0,shard,number,index,meta,data,get,number,of,shards,shard,number,shard,id,shard,id,new,shard,id,index,shard,number,index,shard,routing,table,builder,index,shard,routing,builder,new,index,shard,routing,table,builder,shard,id,for,int,i,0,i,index,meta,data,get,number,of,replicas,i,boolean,primary,i,0,if,as,new,ignore,shards,contains,shard,number,index,shard,routing,builder,add,shard,shard,routing,new,unassigned,shard,id,primary,primary,store,recovery,source,peer,recovery,source,instance,unassigned,info,else,index,shard,routing,builder,add,shard,shard,routing,new,unassigned,shard,id,primary,primary,recovery,source,peer,recovery,source,instance,unassigned,info,shards,put,shard,number,index,shard,routing,builder,build,return,this
IndexRoutingTable -> Builder -> private Builder initializeAsRestore(IndexMetaData indexMetaData, SnapshotRecoverySource recoverySource, IntSet ignoreShards, boolean asNew, UnassignedInfo unassignedInfo);1525334055;Initializes an index, to be restored from snapshot;private Builder initializeAsRestore(IndexMetaData indexMetaData, SnapshotRecoverySource recoverySource, IntSet ignoreShards, boolean asNew, UnassignedInfo unassignedInfo) {_            assert indexMetaData.getIndex().equals(index)__            if (!shards.isEmpty()) {_                throw new IllegalStateException("trying to initialize an index with fresh shards, but already has shards created")__            }_            for (int shardNumber = 0_ shardNumber < indexMetaData.getNumberOfShards()_ shardNumber++) {_                ShardId shardId = new ShardId(index, shardNumber)__                IndexShardRoutingTable.Builder indexShardRoutingBuilder = new IndexShardRoutingTable.Builder(shardId)__                for (int i = 0_ i <= indexMetaData.getNumberOfReplicas()_ i++) {_                    boolean primary = i == 0__                    if (asNew && ignoreShards.contains(shardNumber)) {_                        _                        indexShardRoutingBuilder.addShard(ShardRouting.newUnassigned(shardId, primary,_                            primary ? StoreRecoverySource.EMPTY_STORE_INSTANCE : PeerRecoverySource.INSTANCE, unassignedInfo))__                    } else {_                        indexShardRoutingBuilder.addShard(ShardRouting.newUnassigned(shardId, primary,_                            primary ? recoverySource : PeerRecoverySource.INSTANCE, unassignedInfo))__                    }_                }_                shards.put(shardNumber, indexShardRoutingBuilder.build())__            }_            return this__        };initializes,an,index,to,be,restored,from,snapshot;private,builder,initialize,as,restore,index,meta,data,index,meta,data,snapshot,recovery,source,recovery,source,int,set,ignore,shards,boolean,as,new,unassigned,info,unassigned,info,assert,index,meta,data,get,index,equals,index,if,shards,is,empty,throw,new,illegal,state,exception,trying,to,initialize,an,index,with,fresh,shards,but,already,has,shards,created,for,int,shard,number,0,shard,number,index,meta,data,get,number,of,shards,shard,number,shard,id,shard,id,new,shard,id,index,shard,number,index,shard,routing,table,builder,index,shard,routing,builder,new,index,shard,routing,table,builder,shard,id,for,int,i,0,i,index,meta,data,get,number,of,replicas,i,boolean,primary,i,0,if,as,new,ignore,shards,contains,shard,number,index,shard,routing,builder,add,shard,shard,routing,new,unassigned,shard,id,primary,primary,store,recovery,source,peer,recovery,source,instance,unassigned,info,else,index,shard,routing,builder,add,shard,shard,routing,new,unassigned,shard,id,primary,primary,recovery,source,peer,recovery,source,instance,unassigned,info,shards,put,shard,number,index,shard,routing,builder,build,return,this
IndexRoutingTable -> Builder -> private Builder initializeAsRestore(IndexMetaData indexMetaData, SnapshotRecoverySource recoverySource, IntSet ignoreShards, boolean asNew, UnassignedInfo unassignedInfo);1536611444;Initializes an index, to be restored from snapshot;private Builder initializeAsRestore(IndexMetaData indexMetaData, SnapshotRecoverySource recoverySource, IntSet ignoreShards, boolean asNew, UnassignedInfo unassignedInfo) {_            assert indexMetaData.getIndex().equals(index)__            if (!shards.isEmpty()) {_                throw new IllegalStateException("trying to initialize an index with fresh shards, but already has shards created")__            }_            for (int shardNumber = 0_ shardNumber < indexMetaData.getNumberOfShards()_ shardNumber++) {_                ShardId shardId = new ShardId(index, shardNumber)__                IndexShardRoutingTable.Builder indexShardRoutingBuilder = new IndexShardRoutingTable.Builder(shardId)__                for (int i = 0_ i <= indexMetaData.getNumberOfReplicas()_ i++) {_                    boolean primary = i == 0__                    if (asNew && ignoreShards.contains(shardNumber)) {_                        _                        indexShardRoutingBuilder.addShard(ShardRouting.newUnassigned(shardId, primary,_                            primary ? EmptyStoreRecoverySource.INSTANCE : PeerRecoverySource.INSTANCE, unassignedInfo))__                    } else {_                        indexShardRoutingBuilder.addShard(ShardRouting.newUnassigned(shardId, primary,_                            primary ? recoverySource : PeerRecoverySource.INSTANCE, unassignedInfo))__                    }_                }_                shards.put(shardNumber, indexShardRoutingBuilder.build())__            }_            return this__        };initializes,an,index,to,be,restored,from,snapshot;private,builder,initialize,as,restore,index,meta,data,index,meta,data,snapshot,recovery,source,recovery,source,int,set,ignore,shards,boolean,as,new,unassigned,info,unassigned,info,assert,index,meta,data,get,index,equals,index,if,shards,is,empty,throw,new,illegal,state,exception,trying,to,initialize,an,index,with,fresh,shards,but,already,has,shards,created,for,int,shard,number,0,shard,number,index,meta,data,get,number,of,shards,shard,number,shard,id,shard,id,new,shard,id,index,shard,number,index,shard,routing,table,builder,index,shard,routing,builder,new,index,shard,routing,table,builder,shard,id,for,int,i,0,i,index,meta,data,get,number,of,replicas,i,boolean,primary,i,0,if,as,new,ignore,shards,contains,shard,number,index,shard,routing,builder,add,shard,shard,routing,new,unassigned,shard,id,primary,primary,empty,store,recovery,source,instance,peer,recovery,source,instance,unassigned,info,else,index,shard,routing,builder,add,shard,shard,routing,new,unassigned,shard,id,primary,primary,recovery,source,peer,recovery,source,instance,unassigned,info,shards,put,shard,number,index,shard,routing,builder,build,return,this
IndexRoutingTable -> public Index getIndex();1524684173;Return the index id__@return id of the index;public Index getIndex() {_        return index__    };return,the,index,id,return,id,of,the,index;public,index,get,index,return,index
IndexRoutingTable -> public Index getIndex();1525334055;Return the index id__@return id of the index;public Index getIndex() {_        return index__    };return,the,index,id,return,id,of,the,index;public,index,get,index,return,index
IndexRoutingTable -> public Index getIndex();1536611444;Return the index id__@return id of the index;public Index getIndex() {_        return index__    };return,the,index,id,return,id,of,the,index;public,index,get,index,return,index
IndexRoutingTable -> public Index getIndex();1540847035;Return the index id__@return id of the index;public Index getIndex() {_        return index__    };return,the,index,id,return,id,of,the,index;public,index,get,index,return,index
IndexRoutingTable -> public Index getIndex();1541618291;Return the index id__@return id of the index;public Index getIndex() {_        return index__    };return,the,index,id,return,id,of,the,index;public,index,get,index,return,index
