commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Return the index id  *  * @return id of the index  */ ;/**  * Return the index id  *  * @return id of the index  */ public Index getIndex() {     return index. }
false;;1;60;;boolean validate(MetaData metaData) {     // check index exists     if (!metaData.hasIndex(index.getName())) {         throw new IllegalStateException(index + " exists in routing does not exists in metadata").     }     IndexMetaData indexMetaData = metaData.index(index.getName()).     if (indexMetaData.getIndexUUID().equals(index.getUUID()) == false) {         throw new IllegalStateException(index.getName() + " exists in routing does not exists in metadata with the same uuid").     }     // check the number of shards     if (indexMetaData.getNumberOfShards() != shards().size()) {         Set<Integer> expected = new HashSet<>().         for (int i = 0. i < indexMetaData.getNumberOfShards(). i++) {             expected.add(i).         }         for (IndexShardRoutingTable indexShardRoutingTable : this) {             expected.remove(indexShardRoutingTable.shardId().id()).         }         throw new IllegalStateException("Wrong number of shards in routing table, missing: " + expected).     }     // check the replicas     for (IndexShardRoutingTable indexShardRoutingTable : this) {         int routingNumberOfReplicas = indexShardRoutingTable.size() - 1.         if (routingNumberOfReplicas != indexMetaData.getNumberOfReplicas()) {             throw new IllegalStateException("Shard [" + indexShardRoutingTable.shardId().id() + "] routing table has wrong number of replicas, expected [" + indexMetaData.getNumberOfReplicas() + "], got [" + routingNumberOfReplicas + "]").         }         for (ShardRouting shardRouting : indexShardRoutingTable) {             if (!shardRouting.index().equals(index)) {                 throw new IllegalStateException("shard routing has an index [" + shardRouting.index() + "] that is different " + "from the routing table").             }             final Set<String> inSyncAllocationIds = indexMetaData.inSyncAllocationIds(shardRouting.id()).             if (shardRouting.active() && inSyncAllocationIds.contains(shardRouting.allocationId().getId()) == false) {                 throw new IllegalStateException("active shard routing " + shardRouting + " has no corresponding entry in the in-sync " + "allocation set " + inSyncAllocationIds).             }             if (shardRouting.primary() && shardRouting.initializing() && shardRouting.recoverySource().getType() == RecoverySource.Type.EXISTING_STORE) {                 if (inSyncAllocationIds.contains(RecoverySource.ExistingStoreRecoverySource.FORCED_ALLOCATION_ID)) {                     if (inSyncAllocationIds.size() != 1) {                         throw new IllegalStateException("a primary shard routing " + shardRouting + " is a primary that is recovering from a stale primary has unexpected allocation ids in in-sync " + "allocation set " + inSyncAllocationIds).                     }                 } else if (inSyncAllocationIds.contains(shardRouting.allocationId().getId()) == false) {                     throw new IllegalStateException("a primary shard routing " + shardRouting + " is a primary that is recovering from a known allocation id but has no corresponding entry in the in-sync " + "allocation set " + inSyncAllocationIds).                 }             }         }     }     return true. }
false;public;0;4;;@Override public Iterator<IndexShardRoutingTable> iterator() {     return shards.valuesIt(). }
true;public;1;23;/**  * Calculates the number of nodes that hold one or more shards of this index  * {@link IndexRoutingTable} excluding the nodes with the node ids give as  * the <code>excludedNodes</code> parameter.  *  * @param excludedNodes id of nodes that will be excluded  * @return number of distinct nodes this index has at least one shard allocated on  */ ;/**  * Calculates the number of nodes that hold one or more shards of this index  * {@link IndexRoutingTable} excluding the nodes with the node ids give as  * the <code>excludedNodes</code> parameter.  *  * @param excludedNodes id of nodes that will be excluded  * @return number of distinct nodes this index has at least one shard allocated on  */ public int numberOfNodesShardsAreAllocatedOn(String... excludedNodes) {     Set<String> nodes = new HashSet<>().     for (IndexShardRoutingTable shardRoutingTable : this) {         for (ShardRouting shardRouting : shardRoutingTable) {             if (shardRouting.assignedToNode()) {                 String currentNodeId = shardRouting.currentNodeId().                 boolean excluded = false.                 if (excludedNodes != null) {                     for (String excludedNode : excludedNodes) {                         if (currentNodeId.equals(excludedNode)) {                             excluded = true.                             break.                         }                     }                 }                 if (!excluded) {                     nodes.add(currentNodeId).                 }             }         }     }     return nodes.size(). }
false;public;0;3;;public ImmutableOpenIntMap<IndexShardRoutingTable> shards() {     return shards. }
false;public;0;3;;public ImmutableOpenIntMap<IndexShardRoutingTable> getShards() {     return shards(). }
false;public;1;3;;public IndexShardRoutingTable shard(int shardId) {     return shards.get(shardId). }
true;public;0;3;/**  * Returns <code>true</code> if all shards are primary and active. Otherwise <code>false</code>.  */ ;/**  * Returns <code>true</code> if all shards are primary and active. Otherwise <code>false</code>.  */ public boolean allPrimaryShardsActive() {     return primaryShardsActive() == shards().size(). }
true;public;0;9;/**  * Calculates the number of primary shards in active state in routing table  *  * @return number of active primary shards  */ ;/**  * Calculates the number of primary shards in active state in routing table  *  * @return number of active primary shards  */ public int primaryShardsActive() {     int counter = 0.     for (IndexShardRoutingTable shardRoutingTable : this) {         if (shardRoutingTable.primaryShard().active()) {             counter++.         }     }     return counter. }
true;public;0;3;/**  * Returns <code>true</code> if all primary shards are in  * {@link ShardRoutingState#UNASSIGNED} state. Otherwise <code>false</code>.  */ ;/**  * Returns <code>true</code> if all primary shards are in  * {@link ShardRoutingState#UNASSIGNED} state. Otherwise <code>false</code>.  */ public boolean allPrimaryShardsUnassigned() {     return primaryShardsUnassigned() == shards.size(). }
true;public;0;9;/**  * Calculates the number of primary shards in the routing table the are in  * {@link ShardRoutingState#UNASSIGNED} state.  */ ;/**  * Calculates the number of primary shards in the routing table the are in  * {@link ShardRoutingState#UNASSIGNED} state.  */ public int primaryShardsUnassigned() {     int counter = 0.     for (IndexShardRoutingTable shardRoutingTable : this) {         if (shardRoutingTable.primaryShard().unassigned()) {             counter++.         }     }     return counter. }
true;public;1;7;/**  * Returns a {@link List} of shards that match one of the states listed in {@link ShardRoutingState states}  *  * @param state {@link ShardRoutingState} to retrieve  * @return a {@link List} of shards that match one of the given {@link ShardRoutingState states}  */ ;/**  * Returns a {@link List} of shards that match one of the states listed in {@link ShardRoutingState states}  *  * @param state {@link ShardRoutingState} to retrieve  * @return a {@link List} of shards that match one of the given {@link ShardRoutingState states}  */ public List<ShardRouting> shardsWithState(ShardRoutingState state) {     List<ShardRouting> shards = new ArrayList<>().     for (IndexShardRoutingTable shardRoutingTable : this) {         shards.addAll(shardRoutingTable.shardsWithState(state)).     }     return shards. }
true;public;0;3;/**  * Returns an unordered iterator over all active shards (including replicas).  */ ;/**  * Returns an unordered iterator over all active shards (including replicas).  */ public ShardsIterator randomAllActiveShardsIt() {     return new PlainShardsIterator(shuffler.shuffle(allActiveShards)). }
false;public;1;12;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     IndexRoutingTable that = (IndexRoutingTable) o.     if (!index.equals(that.index))         return false.     if (!shards.equals(that.shards))         return false.     return true. }
false;public;0;6;;@Override public int hashCode() {     int result = index.hashCode().     result = 31 * result + shards.hashCode().     return result. }
false;public,static;1;11;;public static IndexRoutingTable readFrom(StreamInput in) throws IOException {     Index index = new Index(in).     Builder builder = new Builder(index).     int size = in.readVInt().     for (int i = 0. i < size. i++) {         builder.addIndexShard(IndexShardRoutingTable.Builder.readFromThin(in, index)).     }     return builder.build(). }
false;public,static;1;3;;public static Diff<IndexRoutingTable> readDiffFrom(StreamInput in) throws IOException {     return readDiffFrom(IndexRoutingTable::readFrom, in). }
false;public;1;8;;@Override public void writeTo(StreamOutput out) throws IOException {     index.writeTo(out).     out.writeVInt(shards.size()).     for (IndexShardRoutingTable indexShard : this) {         IndexShardRoutingTable.Builder.writeToThin(indexShard, out).     } }
false;public,static;1;3;;public static Builder builder(Index index) {     return new Builder(index). }
true;public;1;3;/**  * Initializes a new empty index, as if it was created from an API.  */ ;/**  * Initializes a new empty index, as if it was created from an API.  */ public Builder initializeAsNew(IndexMetaData indexMetaData) {     return initializeEmpty(indexMetaData, new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, null)). }
true;public;1;3;/**  * Initializes an existing index.  */ ;/**  * Initializes an existing index.  */ public Builder initializeAsRecovery(IndexMetaData indexMetaData) {     return initializeEmpty(indexMetaData, new UnassignedInfo(UnassignedInfo.Reason.CLUSTER_RECOVERED, null)). }
true;public;1;3;/**  * Initializes a new index caused by dangling index imported.  */ ;/**  * Initializes a new index caused by dangling index imported.  */ public Builder initializeAsFromDangling(IndexMetaData indexMetaData) {     return initializeEmpty(indexMetaData, new UnassignedInfo(UnassignedInfo.Reason.DANGLING_INDEX_IMPORTED, null)). }
true;public;1;3;/**  * Initializes a new empty index, as as a result of opening a closed index.  */ ;/**  * Initializes a new empty index, as as a result of opening a closed index.  */ public Builder initializeAsFromCloseToOpen(IndexMetaData indexMetaData) {     return initializeEmpty(indexMetaData, new UnassignedInfo(UnassignedInfo.Reason.INDEX_REOPENED, null)). }
true;public;1;3;/**  * Initializes a new empty index, as as a result of closing an opened index.  */ ;/**  * Initializes a new empty index, as as a result of closing an opened index.  */ public Builder initializeAsFromOpenToClose(IndexMetaData indexMetaData) {     return initializeEmpty(indexMetaData, new UnassignedInfo(UnassignedInfo.Reason.INDEX_CLOSED, null)). }
true;public;3;6;/**  * Initializes a new empty index, to be restored from a snapshot  */ ;/**  * Initializes a new empty index, to be restored from a snapshot  */ public Builder initializeAsNewRestore(IndexMetaData indexMetaData, SnapshotRecoverySource recoverySource, IntSet ignoreShards) {     final UnassignedInfo unassignedInfo = new UnassignedInfo(UnassignedInfo.Reason.NEW_INDEX_RESTORED, "restore_source[" + recoverySource.snapshot().getRepository() + "/" + recoverySource.snapshot().getSnapshotId().getName() + "]").     return initializeAsRestore(indexMetaData, recoverySource, ignoreShards, true, unassignedInfo). }
true;public;2;6;/**  * Initializes an existing index, to be restored from a snapshot  */ ;/**  * Initializes an existing index, to be restored from a snapshot  */ public Builder initializeAsRestore(IndexMetaData indexMetaData, SnapshotRecoverySource recoverySource) {     final UnassignedInfo unassignedInfo = new UnassignedInfo(UnassignedInfo.Reason.EXISTING_INDEX_RESTORED, "restore_source[" + recoverySource.snapshot().getRepository() + "/" + recoverySource.snapshot().getSnapshotId().getName() + "]").     return initializeAsRestore(indexMetaData, recoverySource, null, false, unassignedInfo). }
true;private;5;24;/**  * Initializes an index, to be restored from snapshot  */ ;/**  * Initializes an index, to be restored from snapshot  */ private Builder initializeAsRestore(IndexMetaData indexMetaData, SnapshotRecoverySource recoverySource, IntSet ignoreShards, boolean asNew, UnassignedInfo unassignedInfo) {     assert indexMetaData.getIndex().equals(index).     if (!shards.isEmpty()) {         throw new IllegalStateException("trying to initialize an index with fresh shards, but already has shards created").     }     for (int shardNumber = 0. shardNumber < indexMetaData.getNumberOfShards(). shardNumber++) {         ShardId shardId = new ShardId(index, shardNumber).         IndexShardRoutingTable.Builder indexShardRoutingBuilder = new IndexShardRoutingTable.Builder(shardId).         for (int i = 0. i <= indexMetaData.getNumberOfReplicas(). i++) {             boolean primary = i == 0.             if (asNew && ignoreShards.contains(shardNumber)) {                 // This shards wasn't completely snapshotted - restore it as new shard                 indexShardRoutingBuilder.addShard(ShardRouting.newUnassigned(shardId, primary, primary ? EmptyStoreRecoverySource.INSTANCE : PeerRecoverySource.INSTANCE, unassignedInfo)).             } else {                 indexShardRoutingBuilder.addShard(ShardRouting.newUnassigned(shardId, primary, primary ? recoverySource : PeerRecoverySource.INSTANCE, unassignedInfo)).             }         }         shards.put(shardNumber, indexShardRoutingBuilder.build()).     }     return this. }
true;private;2;28;/**  * Initializes a new empty index, with an option to control if its from an API or not.  */ ;/**  * Initializes a new empty index, with an option to control if its from an API or not.  */ private Builder initializeEmpty(IndexMetaData indexMetaData, UnassignedInfo unassignedInfo) {     assert indexMetaData.getIndex().equals(index).     if (!shards.isEmpty()) {         throw new IllegalStateException("trying to initialize an index with fresh shards, but already has shards created").     }     for (int shardNumber = 0. shardNumber < indexMetaData.getNumberOfShards(). shardNumber++) {         ShardId shardId = new ShardId(index, shardNumber).         final RecoverySource primaryRecoverySource.         if (indexMetaData.inSyncAllocationIds(shardNumber).isEmpty() == false) {             // we have previous valid copies for this shard. use them for recovery             primaryRecoverySource = ExistingStoreRecoverySource.INSTANCE.         } else if (indexMetaData.getResizeSourceIndex() != null) {             // this is a new index but the initial shards should merged from another index             primaryRecoverySource = LocalShardsRecoverySource.INSTANCE.         } else {             // a freshly created index with no restriction             primaryRecoverySource = EmptyStoreRecoverySource.INSTANCE.         }         IndexShardRoutingTable.Builder indexShardRoutingBuilder = new IndexShardRoutingTable.Builder(shardId).         for (int i = 0. i <= indexMetaData.getNumberOfReplicas(). i++) {             boolean primary = i == 0.             indexShardRoutingBuilder.addShard(ShardRouting.newUnassigned(shardId, primary, primary ? primaryRecoverySource : PeerRecoverySource.INSTANCE, unassignedInfo)).         }         shards.put(shardNumber, indexShardRoutingBuilder.build()).     }     return this. }
false;public;0;13;;public Builder addReplica() {     for (IntCursor cursor : shards.keys()) {         int shardNumber = cursor.value.         ShardId shardId = new ShardId(index, shardNumber).         // version 0, will get updated when reroute will happen         ShardRouting shard = ShardRouting.newUnassigned(shardId, false, PeerRecoverySource.INSTANCE, new UnassignedInfo(UnassignedInfo.Reason.REPLICA_ADDED, null)).         shards.put(shardNumber, new IndexShardRoutingTable.Builder(shards.get(shard.id())).addShard(shard).build()).     }     return this. }
false;public;0;34;;public Builder removeReplica() {     for (IntCursor cursor : shards.keys()) {         int shardId = cursor.value.         IndexShardRoutingTable indexShard = shards.get(shardId).         if (indexShard.replicaShards().isEmpty()) {             // nothing to do here!             return this.         }         // re-add all the current ones         IndexShardRoutingTable.Builder builder = new IndexShardRoutingTable.Builder(indexShard.shardId()).         for (ShardRouting shardRouting : indexShard) {             builder.addShard(shardRouting).         }         // first check if there is one that is not assigned to a node, and remove it         boolean removed = false.         for (ShardRouting shardRouting : indexShard) {             if (!shardRouting.primary() && !shardRouting.assignedToNode()) {                 builder.removeShard(shardRouting).                 removed = true.                 break.             }         }         if (!removed) {             for (ShardRouting shardRouting : indexShard) {                 if (!shardRouting.primary()) {                     builder.removeShard(shardRouting).                     break.                 }             }         }         shards.put(shardId, builder.build()).     }     return this. }
false;public;1;4;;public Builder addIndexShard(IndexShardRoutingTable indexShard) {     shards.put(indexShard.shardId().id(), indexShard).     return this. }
true;public;1;10;/**  * Adds a new shard routing (makes a copy of it), with reference data used from the index shard routing table  * if it needs to be created.  */ ;/**  * Adds a new shard routing (makes a copy of it), with reference data used from the index shard routing table  * if it needs to be created.  */ public Builder addShard(ShardRouting shard) {     IndexShardRoutingTable indexShard = shards.get(shard.id()).     if (indexShard == null) {         indexShard = new IndexShardRoutingTable.Builder(shard.shardId()).addShard(shard).build().     } else {         indexShard = new IndexShardRoutingTable.Builder(indexShard).addShard(shard).build().     }     shards.put(indexShard.shardId().id(), indexShard).     return this. }
false;public;0;3;;public IndexRoutingTable build() {     return new IndexRoutingTable(index, shards.build()). }
false;public;0;27;;public String prettyPrint() {     StringBuilder sb = new StringBuilder("-- index [" + index + "]\n").     List<IndexShardRoutingTable> ordered = new ArrayList<>().     for (IndexShardRoutingTable indexShard : this) {         ordered.add(indexShard).     }     CollectionUtil.timSort(ordered, (o1, o2) -> {         int v = o1.shardId().getIndex().getName().compareTo(o2.shardId().getIndex().getName()).         if (v == 0) {             v = Integer.compare(o1.shardId().id(), o2.shardId().id()).         }         return v.     }).     for (IndexShardRoutingTable indexShard : ordered) {         sb.append("----shard_id [").append(indexShard.shardId().getIndex().getName()).append("][").append(indexShard.shardId().id()).append("]\n").         for (ShardRouting shard : indexShard) {             sb.append("--------").append(shard.shortSummary()).append("\n").         }     }     return sb.toString(). }
