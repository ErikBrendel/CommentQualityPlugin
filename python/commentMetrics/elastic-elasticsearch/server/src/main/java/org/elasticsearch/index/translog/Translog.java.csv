# id;timestamp;commentText;codeText;commentWords;codeWords
Translog -> public long currentFileGeneration();1524684173;Returns the generation of the current transaction log.;public long currentFileGeneration() {_        try (ReleasableLock ignored = readLock.acquire()) {_            return current.getGeneration()__        }_    };returns,the,generation,of,the,current,transaction,log;public,long,current,file,generation,try,releasable,lock,ignored,read,lock,acquire,return,current,get,generation
Translog -> public long currentFileGeneration();1525334055;Returns the generation of the current transaction log.;public long currentFileGeneration() {_        try (ReleasableLock ignored = readLock.acquire()) {_            return current.getGeneration()__        }_    };returns,the,generation,of,the,current,transaction,log;public,long,current,file,generation,try,releasable,lock,ignored,read,lock,acquire,return,current,get,generation
Translog -> public long currentFileGeneration();1528706846;Returns the generation of the current transaction log.;public long currentFileGeneration() {_        try (ReleasableLock ignored = readLock.acquire()) {_            return current.getGeneration()__        }_    };returns,the,generation,of,the,current,transaction,log;public,long,current,file,generation,try,releasable,lock,ignored,read,lock,acquire,return,current,get,generation
Translog -> public long currentFileGeneration();1531910483;Returns the generation of the current transaction log.;public long currentFileGeneration() {_        try (ReleasableLock ignored = readLock.acquire()) {_            return current.getGeneration()__        }_    };returns,the,generation,of,the,current,transaction,log;public,long,current,file,generation,try,releasable,lock,ignored,read,lock,acquire,return,current,get,generation
Translog -> public long currentFileGeneration();1533295538;Returns the generation of the current transaction log.;public long currentFileGeneration() {_        try (ReleasableLock ignored = readLock.acquire()) {_            return current.getGeneration()__        }_    };returns,the,generation,of,the,current,transaction,log;public,long,current,file,generation,try,releasable,lock,ignored,read,lock,acquire,return,current,get,generation
Translog -> public long currentFileGeneration();1533641732;Returns the generation of the current transaction log.;public long currentFileGeneration() {_        try (ReleasableLock ignored = readLock.acquire()) {_            return current.getGeneration()__        }_    };returns,the,generation,of,the,current,transaction,log;public,long,current,file,generation,try,releasable,lock,ignored,read,lock,acquire,return,current,get,generation
Translog -> public long currentFileGeneration();1534848846;Returns the generation of the current transaction log.;public long currentFileGeneration() {_        try (ReleasableLock ignored = readLock.acquire()) {_            return current.getGeneration()__        }_    };returns,the,generation,of,the,current,transaction,log;public,long,current,file,generation,try,releasable,lock,ignored,read,lock,acquire,return,current,get,generation
Translog -> public long currentFileGeneration();1535046779;Returns the generation of the current transaction log.;public long currentFileGeneration() {_        try (ReleasableLock ignored = readLock.acquire()) {_            return current.getGeneration()__        }_    };returns,the,generation,of,the,current,transaction,log;public,long,current,file,generation,try,releasable,lock,ignored,read,lock,acquire,return,current,get,generation
Translog -> public long currentFileGeneration();1535723122;Returns the generation of the current transaction log.;public long currentFileGeneration() {_        try (ReleasableLock ignored = readLock.acquire()) {_            return current.getGeneration()__        }_    };returns,the,generation,of,the,current,transaction,log;public,long,current,file,generation,try,releasable,lock,ignored,read,lock,acquire,return,current,get,generation
Translog -> public long currentFileGeneration();1537806831;Returns the generation of the current transaction log.;public long currentFileGeneration() {_        try (ReleasableLock ignored = readLock.acquire()) {_            return current.getGeneration()__        }_    };returns,the,generation,of,the,current,transaction,log;public,long,current,file,generation,try,releasable,lock,ignored,read,lock,acquire,return,current,get,generation
Translog -> public long currentFileGeneration();1541592065;Returns the generation of the current transaction log.;public long currentFileGeneration() {_        try (ReleasableLock ignored = readLock.acquire()) {_            return current.getGeneration()__        }_    };returns,the,generation,of,the,current,transaction,log;public,long,current,file,generation,try,releasable,lock,ignored,read,lock,acquire,return,current,get,generation
Translog -> public long currentFileGeneration();1542697754;Returns the generation of the current transaction log.;public long currentFileGeneration() {_        try (ReleasableLock ignored = readLock.acquire()) {_            return current.getGeneration()__        }_    };returns,the,generation,of,the,current,transaction,log;public,long,current,file,generation,try,releasable,lock,ignored,read,lock,acquire,return,current,get,generation
Translog -> public long currentFileGeneration();1542962614;Returns the generation of the current transaction log.;public long currentFileGeneration() {_        try (ReleasableLock ignored = readLock.acquire()) {_            return current.getGeneration()__        }_    };returns,the,generation,of,the,current,transaction,log;public,long,current,file,generation,try,releasable,lock,ignored,read,lock,acquire,return,current,get,generation
Translog -> public long currentFileGeneration();1545236365;Returns the generation of the current transaction log.;public long currentFileGeneration() {_        try (ReleasableLock ignored = readLock.acquire()) {_            return current.getGeneration()__        }_    };returns,the,generation,of,the,current,transaction,log;public,long,current,file,generation,try,releasable,lock,ignored,read,lock,acquire,return,current,get,generation
Translog -> public static long readMinTranslogGeneration(final Path location, final String expectedTranslogUUID) throws IOException;1524684173;Returns the minimum translog generation retained by the translog at the given location._This ensures that the translogUUID from this translog matches with the provided translogUUID.__@param location the location of the translog_@return the minimum translog generation_@throws IOException                if an I/O exception occurred reading the checkpoint_@throws TranslogCorruptedException if the translog is corrupted or mismatched with the given uuid;public static long readMinTranslogGeneration(final Path location, final String expectedTranslogUUID) throws IOException {_        final Checkpoint checkpoint = readCheckpoint(location, expectedTranslogUUID)__        return checkpoint.minTranslogGeneration__    };returns,the,minimum,translog,generation,retained,by,the,translog,at,the,given,location,this,ensures,that,the,translog,uuid,from,this,translog,matches,with,the,provided,translog,uuid,param,location,the,location,of,the,translog,return,the,minimum,translog,generation,throws,ioexception,if,an,i,o,exception,occurred,reading,the,checkpoint,throws,translog,corrupted,exception,if,the,translog,is,corrupted,or,mismatched,with,the,given,uuid;public,static,long,read,min,translog,generation,final,path,location,final,string,expected,translog,uuid,throws,ioexception,final,checkpoint,checkpoint,read,checkpoint,location,expected,translog,uuid,return,checkpoint,min,translog,generation
Translog -> public static long readMinTranslogGeneration(final Path location, final String expectedTranslogUUID) throws IOException;1525334055;Returns the minimum translog generation retained by the translog at the given location._This ensures that the translogUUID from this translog matches with the provided translogUUID.__@param location the location of the translog_@return the minimum translog generation_@throws IOException                if an I/O exception occurred reading the checkpoint_@throws TranslogCorruptedException if the translog is corrupted or mismatched with the given uuid;public static long readMinTranslogGeneration(final Path location, final String expectedTranslogUUID) throws IOException {_        final Checkpoint checkpoint = readCheckpoint(location, expectedTranslogUUID)__        return checkpoint.minTranslogGeneration__    };returns,the,minimum,translog,generation,retained,by,the,translog,at,the,given,location,this,ensures,that,the,translog,uuid,from,this,translog,matches,with,the,provided,translog,uuid,param,location,the,location,of,the,translog,return,the,minimum,translog,generation,throws,ioexception,if,an,i,o,exception,occurred,reading,the,checkpoint,throws,translog,corrupted,exception,if,the,translog,is,corrupted,or,mismatched,with,the,given,uuid;public,static,long,read,min,translog,generation,final,path,location,final,string,expected,translog,uuid,throws,ioexception,final,checkpoint,checkpoint,read,checkpoint,location,expected,translog,uuid,return,checkpoint,min,translog,generation
Translog -> public static long readMinTranslogGeneration(final Path location, final String expectedTranslogUUID) throws IOException;1528706846;Returns the minimum translog generation retained by the translog at the given location._This ensures that the translogUUID from this translog matches with the provided translogUUID.__@param location the location of the translog_@return the minimum translog generation_@throws IOException                if an I/O exception occurred reading the checkpoint_@throws TranslogCorruptedException if the translog is corrupted or mismatched with the given uuid;public static long readMinTranslogGeneration(final Path location, final String expectedTranslogUUID) throws IOException {_        final Checkpoint checkpoint = readCheckpoint(location, expectedTranslogUUID)__        return checkpoint.minTranslogGeneration__    };returns,the,minimum,translog,generation,retained,by,the,translog,at,the,given,location,this,ensures,that,the,translog,uuid,from,this,translog,matches,with,the,provided,translog,uuid,param,location,the,location,of,the,translog,return,the,minimum,translog,generation,throws,ioexception,if,an,i,o,exception,occurred,reading,the,checkpoint,throws,translog,corrupted,exception,if,the,translog,is,corrupted,or,mismatched,with,the,given,uuid;public,static,long,read,min,translog,generation,final,path,location,final,string,expected,translog,uuid,throws,ioexception,final,checkpoint,checkpoint,read,checkpoint,location,expected,translog,uuid,return,checkpoint,min,translog,generation
Translog -> public static long readMinTranslogGeneration(final Path location, final String expectedTranslogUUID) throws IOException;1531910483;Returns the minimum translog generation retained by the translog at the given location._This ensures that the translogUUID from this translog matches with the provided translogUUID.__@param location the location of the translog_@return the minimum translog generation_@throws IOException                if an I/O exception occurred reading the checkpoint_@throws TranslogCorruptedException if the translog is corrupted or mismatched with the given uuid;public static long readMinTranslogGeneration(final Path location, final String expectedTranslogUUID) throws IOException {_        final Checkpoint checkpoint = readCheckpoint(location, expectedTranslogUUID)__        return checkpoint.minTranslogGeneration__    };returns,the,minimum,translog,generation,retained,by,the,translog,at,the,given,location,this,ensures,that,the,translog,uuid,from,this,translog,matches,with,the,provided,translog,uuid,param,location,the,location,of,the,translog,return,the,minimum,translog,generation,throws,ioexception,if,an,i,o,exception,occurred,reading,the,checkpoint,throws,translog,corrupted,exception,if,the,translog,is,corrupted,or,mismatched,with,the,given,uuid;public,static,long,read,min,translog,generation,final,path,location,final,string,expected,translog,uuid,throws,ioexception,final,checkpoint,checkpoint,read,checkpoint,location,expected,translog,uuid,return,checkpoint,min,translog,generation
Translog -> public static long readMinTranslogGeneration(final Path location, final String expectedTranslogUUID) throws IOException;1533295538;Returns the minimum translog generation retained by the translog at the given location._This ensures that the translogUUID from this translog matches with the provided translogUUID.__@param location the location of the translog_@return the minimum translog generation_@throws IOException                if an I/O exception occurred reading the checkpoint_@throws TranslogCorruptedException if the translog is corrupted or mismatched with the given uuid;public static long readMinTranslogGeneration(final Path location, final String expectedTranslogUUID) throws IOException {_        final Checkpoint checkpoint = readCheckpoint(location, expectedTranslogUUID)__        return checkpoint.minTranslogGeneration__    };returns,the,minimum,translog,generation,retained,by,the,translog,at,the,given,location,this,ensures,that,the,translog,uuid,from,this,translog,matches,with,the,provided,translog,uuid,param,location,the,location,of,the,translog,return,the,minimum,translog,generation,throws,ioexception,if,an,i,o,exception,occurred,reading,the,checkpoint,throws,translog,corrupted,exception,if,the,translog,is,corrupted,or,mismatched,with,the,given,uuid;public,static,long,read,min,translog,generation,final,path,location,final,string,expected,translog,uuid,throws,ioexception,final,checkpoint,checkpoint,read,checkpoint,location,expected,translog,uuid,return,checkpoint,min,translog,generation
Translog -> public static long readMinTranslogGeneration(final Path location, final String expectedTranslogUUID) throws IOException;1533641732;Returns the minimum translog generation retained by the translog at the given location._This ensures that the translogUUID from this translog matches with the provided translogUUID.__@param location the location of the translog_@return the minimum translog generation_@throws IOException                if an I/O exception occurred reading the checkpoint_@throws TranslogCorruptedException if the translog is corrupted or mismatched with the given uuid;public static long readMinTranslogGeneration(final Path location, final String expectedTranslogUUID) throws IOException {_        final Checkpoint checkpoint = readCheckpoint(location, expectedTranslogUUID)__        return checkpoint.minTranslogGeneration__    };returns,the,minimum,translog,generation,retained,by,the,translog,at,the,given,location,this,ensures,that,the,translog,uuid,from,this,translog,matches,with,the,provided,translog,uuid,param,location,the,location,of,the,translog,return,the,minimum,translog,generation,throws,ioexception,if,an,i,o,exception,occurred,reading,the,checkpoint,throws,translog,corrupted,exception,if,the,translog,is,corrupted,or,mismatched,with,the,given,uuid;public,static,long,read,min,translog,generation,final,path,location,final,string,expected,translog,uuid,throws,ioexception,final,checkpoint,checkpoint,read,checkpoint,location,expected,translog,uuid,return,checkpoint,min,translog,generation
Translog -> public static long readMinTranslogGeneration(final Path location, final String expectedTranslogUUID) throws IOException;1534848846;Returns the minimum translog generation retained by the translog at the given location._This ensures that the translogUUID from this translog matches with the provided translogUUID.__@param location the location of the translog_@return the minimum translog generation_@throws IOException                if an I/O exception occurred reading the checkpoint_@throws TranslogCorruptedException if the translog is corrupted or mismatched with the given uuid;public static long readMinTranslogGeneration(final Path location, final String expectedTranslogUUID) throws IOException {_        final Checkpoint checkpoint = readCheckpoint(location, expectedTranslogUUID)__        return checkpoint.minTranslogGeneration__    };returns,the,minimum,translog,generation,retained,by,the,translog,at,the,given,location,this,ensures,that,the,translog,uuid,from,this,translog,matches,with,the,provided,translog,uuid,param,location,the,location,of,the,translog,return,the,minimum,translog,generation,throws,ioexception,if,an,i,o,exception,occurred,reading,the,checkpoint,throws,translog,corrupted,exception,if,the,translog,is,corrupted,or,mismatched,with,the,given,uuid;public,static,long,read,min,translog,generation,final,path,location,final,string,expected,translog,uuid,throws,ioexception,final,checkpoint,checkpoint,read,checkpoint,location,expected,translog,uuid,return,checkpoint,min,translog,generation
Translog -> public static long readMinTranslogGeneration(final Path location, final String expectedTranslogUUID) throws IOException;1535046779;Returns the minimum translog generation retained by the translog at the given location._This ensures that the translogUUID from this translog matches with the provided translogUUID.__@param location the location of the translog_@return the minimum translog generation_@throws IOException                if an I/O exception occurred reading the checkpoint_@throws TranslogCorruptedException if the translog is corrupted or mismatched with the given uuid;public static long readMinTranslogGeneration(final Path location, final String expectedTranslogUUID) throws IOException {_        final Checkpoint checkpoint = readCheckpoint(location, expectedTranslogUUID)__        return checkpoint.minTranslogGeneration__    };returns,the,minimum,translog,generation,retained,by,the,translog,at,the,given,location,this,ensures,that,the,translog,uuid,from,this,translog,matches,with,the,provided,translog,uuid,param,location,the,location,of,the,translog,return,the,minimum,translog,generation,throws,ioexception,if,an,i,o,exception,occurred,reading,the,checkpoint,throws,translog,corrupted,exception,if,the,translog,is,corrupted,or,mismatched,with,the,given,uuid;public,static,long,read,min,translog,generation,final,path,location,final,string,expected,translog,uuid,throws,ioexception,final,checkpoint,checkpoint,read,checkpoint,location,expected,translog,uuid,return,checkpoint,min,translog,generation
Translog -> public static long readMinTranslogGeneration(final Path location, final String expectedTranslogUUID) throws IOException;1535723122;Returns the minimum translog generation retained by the translog at the given location._This ensures that the translogUUID from this translog matches with the provided translogUUID.__@param location the location of the translog_@return the minimum translog generation_@throws IOException                if an I/O exception occurred reading the checkpoint_@throws TranslogCorruptedException if the translog is corrupted or mismatched with the given uuid;public static long readMinTranslogGeneration(final Path location, final String expectedTranslogUUID) throws IOException {_        final Checkpoint checkpoint = readCheckpoint(location, expectedTranslogUUID)__        return checkpoint.minTranslogGeneration__    };returns,the,minimum,translog,generation,retained,by,the,translog,at,the,given,location,this,ensures,that,the,translog,uuid,from,this,translog,matches,with,the,provided,translog,uuid,param,location,the,location,of,the,translog,return,the,minimum,translog,generation,throws,ioexception,if,an,i,o,exception,occurred,reading,the,checkpoint,throws,translog,corrupted,exception,if,the,translog,is,corrupted,or,mismatched,with,the,given,uuid;public,static,long,read,min,translog,generation,final,path,location,final,string,expected,translog,uuid,throws,ioexception,final,checkpoint,checkpoint,read,checkpoint,location,expected,translog,uuid,return,checkpoint,min,translog,generation
Translog -> public static long readMinTranslogGeneration(final Path location, final String expectedTranslogUUID) throws IOException;1537806831;Returns the minimum translog generation retained by the translog at the given location._This ensures that the translogUUID from this translog matches with the provided translogUUID.__@param location the location of the translog_@return the minimum translog generation_@throws IOException                if an I/O exception occurred reading the checkpoint_@throws TranslogCorruptedException if the translog is corrupted or mismatched with the given uuid;public static long readMinTranslogGeneration(final Path location, final String expectedTranslogUUID) throws IOException {_        final Checkpoint checkpoint = readCheckpoint(location, expectedTranslogUUID)__        return checkpoint.minTranslogGeneration__    };returns,the,minimum,translog,generation,retained,by,the,translog,at,the,given,location,this,ensures,that,the,translog,uuid,from,this,translog,matches,with,the,provided,translog,uuid,param,location,the,location,of,the,translog,return,the,minimum,translog,generation,throws,ioexception,if,an,i,o,exception,occurred,reading,the,checkpoint,throws,translog,corrupted,exception,if,the,translog,is,corrupted,or,mismatched,with,the,given,uuid;public,static,long,read,min,translog,generation,final,path,location,final,string,expected,translog,uuid,throws,ioexception,final,checkpoint,checkpoint,read,checkpoint,location,expected,translog,uuid,return,checkpoint,min,translog,generation
Translog -> public static long readMinTranslogGeneration(final Path location, final String expectedTranslogUUID) throws IOException;1541592065;Returns the minimum translog generation retained by the translog at the given location._This ensures that the translogUUID from this translog matches with the provided translogUUID.__@param location the location of the translog_@return the minimum translog generation_@throws IOException                if an I/O exception occurred reading the checkpoint_@throws TranslogCorruptedException if the translog is corrupted or mismatched with the given uuid;public static long readMinTranslogGeneration(final Path location, final String expectedTranslogUUID) throws IOException {_        final Checkpoint checkpoint = readCheckpoint(location, expectedTranslogUUID)__        return checkpoint.minTranslogGeneration__    };returns,the,minimum,translog,generation,retained,by,the,translog,at,the,given,location,this,ensures,that,the,translog,uuid,from,this,translog,matches,with,the,provided,translog,uuid,param,location,the,location,of,the,translog,return,the,minimum,translog,generation,throws,ioexception,if,an,i,o,exception,occurred,reading,the,checkpoint,throws,translog,corrupted,exception,if,the,translog,is,corrupted,or,mismatched,with,the,given,uuid;public,static,long,read,min,translog,generation,final,path,location,final,string,expected,translog,uuid,throws,ioexception,final,checkpoint,checkpoint,read,checkpoint,location,expected,translog,uuid,return,checkpoint,min,translog,generation
Translog -> public static long readMinTranslogGeneration(final Path location, final String expectedTranslogUUID) throws IOException;1542697754;Returns the minimum translog generation retained by the translog at the given location._This ensures that the translogUUID from this translog matches with the provided translogUUID.__@param location the location of the translog_@return the minimum translog generation_@throws IOException                if an I/O exception occurred reading the checkpoint_@throws TranslogCorruptedException if the translog is corrupted or mismatched with the given uuid;public static long readMinTranslogGeneration(final Path location, final String expectedTranslogUUID) throws IOException {_        final Checkpoint checkpoint = readCheckpoint(location, expectedTranslogUUID)__        return checkpoint.minTranslogGeneration__    };returns,the,minimum,translog,generation,retained,by,the,translog,at,the,given,location,this,ensures,that,the,translog,uuid,from,this,translog,matches,with,the,provided,translog,uuid,param,location,the,location,of,the,translog,return,the,minimum,translog,generation,throws,ioexception,if,an,i,o,exception,occurred,reading,the,checkpoint,throws,translog,corrupted,exception,if,the,translog,is,corrupted,or,mismatched,with,the,given,uuid;public,static,long,read,min,translog,generation,final,path,location,final,string,expected,translog,uuid,throws,ioexception,final,checkpoint,checkpoint,read,checkpoint,location,expected,translog,uuid,return,checkpoint,min,translog,generation
Translog -> public static long readMinTranslogGeneration(final Path location, final String expectedTranslogUUID) throws IOException;1542962614;Returns the minimum translog generation retained by the translog at the given location._This ensures that the translogUUID from this translog matches with the provided translogUUID.__@param location the location of the translog_@return the minimum translog generation_@throws IOException                if an I/O exception occurred reading the checkpoint_@throws TranslogCorruptedException if the translog is corrupted or mismatched with the given uuid;public static long readMinTranslogGeneration(final Path location, final String expectedTranslogUUID) throws IOException {_        final Checkpoint checkpoint = readCheckpoint(location, expectedTranslogUUID)__        return checkpoint.minTranslogGeneration__    };returns,the,minimum,translog,generation,retained,by,the,translog,at,the,given,location,this,ensures,that,the,translog,uuid,from,this,translog,matches,with,the,provided,translog,uuid,param,location,the,location,of,the,translog,return,the,minimum,translog,generation,throws,ioexception,if,an,i,o,exception,occurred,reading,the,checkpoint,throws,translog,corrupted,exception,if,the,translog,is,corrupted,or,mismatched,with,the,given,uuid;public,static,long,read,min,translog,generation,final,path,location,final,string,expected,translog,uuid,throws,ioexception,final,checkpoint,checkpoint,read,checkpoint,location,expected,translog,uuid,return,checkpoint,min,translog,generation
Translog -> public static long readMinTranslogGeneration(final Path location, final String expectedTranslogUUID) throws IOException;1545236365;Returns the minimum translog generation retained by the translog at the given location._This ensures that the translogUUID from this translog matches with the provided translogUUID.__@param location the location of the translog_@return the minimum translog generation_@throws IOException                if an I/O exception occurred reading the checkpoint_@throws TranslogCorruptedException if the translog is corrupted or mismatched with the given uuid;public static long readMinTranslogGeneration(final Path location, final String expectedTranslogUUID) throws IOException {_        final Checkpoint checkpoint = readCheckpoint(location, expectedTranslogUUID)__        return checkpoint.minTranslogGeneration__    };returns,the,minimum,translog,generation,retained,by,the,translog,at,the,given,location,this,ensures,that,the,translog,uuid,from,this,translog,matches,with,the,provided,translog,uuid,param,location,the,location,of,the,translog,return,the,minimum,translog,generation,throws,ioexception,if,an,i,o,exception,occurred,reading,the,checkpoint,throws,translog,corrupted,exception,if,the,translog,is,corrupted,or,mismatched,with,the,given,uuid;public,static,long,read,min,translog,generation,final,path,location,final,string,expected,translog,uuid,throws,ioexception,final,checkpoint,checkpoint,read,checkpoint,location,expected,translog,uuid,return,checkpoint,min,translog,generation
Translog -> public int totalOperations();1524684173;Returns the number of operations in the translog files;public int totalOperations() {_        return totalOperationsByMinGen(-1)__    };returns,the,number,of,operations,in,the,translog,files;public,int,total,operations,return,total,operations,by,min,gen,1
Translog -> public int totalOperations();1525334055;Returns the number of operations in the translog files;public int totalOperations() {_        return totalOperationsByMinGen(-1)__    };returns,the,number,of,operations,in,the,translog,files;public,int,total,operations,return,total,operations,by,min,gen,1
Translog -> public int totalOperations();1528706846;Returns the number of operations in the translog files;public int totalOperations() {_        return totalOperationsByMinGen(-1)__    };returns,the,number,of,operations,in,the,translog,files;public,int,total,operations,return,total,operations,by,min,gen,1
Translog -> public int totalOperations();1531910483;Returns the number of operations in the translog files;public int totalOperations() {_        return totalOperationsByMinGen(-1)__    };returns,the,number,of,operations,in,the,translog,files;public,int,total,operations,return,total,operations,by,min,gen,1
Translog -> public int totalOperations();1533295538;Returns the number of operations in the translog files;public int totalOperations() {_        return totalOperationsByMinGen(-1)__    };returns,the,number,of,operations,in,the,translog,files;public,int,total,operations,return,total,operations,by,min,gen,1
Translog -> public int totalOperations();1533641732;Returns the number of operations in the translog files;public int totalOperations() {_        return totalOperationsByMinGen(-1)__    };returns,the,number,of,operations,in,the,translog,files;public,int,total,operations,return,total,operations,by,min,gen,1
Translog -> public int totalOperations();1534848846;Returns the number of operations in the translog files;public int totalOperations() {_        return totalOperationsByMinGen(-1)__    };returns,the,number,of,operations,in,the,translog,files;public,int,total,operations,return,total,operations,by,min,gen,1
Translog -> public int totalOperations();1535046779;Returns the number of operations in the translog files;public int totalOperations() {_        return totalOperationsByMinGen(-1)__    };returns,the,number,of,operations,in,the,translog,files;public,int,total,operations,return,total,operations,by,min,gen,1
Translog -> public int totalOperations();1535723122;Returns the number of operations in the translog files;public int totalOperations() {_        return totalOperationsByMinGen(-1)__    };returns,the,number,of,operations,in,the,translog,files;public,int,total,operations,return,total,operations,by,min,gen,1
Translog -> public int totalOperations();1537806831;Returns the number of operations in the translog files;public int totalOperations() {_        return totalOperationsByMinGen(-1)__    };returns,the,number,of,operations,in,the,translog,files;public,int,total,operations,return,total,operations,by,min,gen,1
Translog -> public int totalOperations();1541592065;Returns the number of operations in the translog files;public int totalOperations() {_        return totalOperationsByMinGen(-1)__    };returns,the,number,of,operations,in,the,translog,files;public,int,total,operations,return,total,operations,by,min,gen,1
Translog -> public int totalOperations();1542697754;Returns the number of operations in the translog files;public int totalOperations() {_        return totalOperationsByMinGen(-1)__    };returns,the,number,of,operations,in,the,translog,files;public,int,total,operations,return,total,operations,by,min,gen,1
Translog -> public int totalOperations();1542962614;Returns the number of operations in the translog files;public int totalOperations() {_        return totalOperationsByMinGen(-1)__    };returns,the,number,of,operations,in,the,translog,files;public,int,total,operations,return,total,operations,by,min,gen,1
Translog -> public int totalOperations();1545236365;Returns the number of operations in the translog files;public int totalOperations() {_        return totalOperationsByMinGen(-1)__    };returns,the,number,of,operations,in,the,translog,files;public,int,total,operations,return,total,operations,by,min,gen,1
Translog -> public Operation readOperation(Location location) throws IOException;1524684173;Reads and returns the operation from the given location if the generation it references is still available. Otherwise_this method will return <code>null</code>.;public Operation readOperation(Location location) throws IOException {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            if (location.generation < getMinFileGeneration()) {_                return null__            }_            if (current.generation == location.generation) {_                _                _                return current.read(location)__            } else {_                _                for (int i = readers.size() - 1_ i >= 0_ i--) {_                    TranslogReader translogReader = readers.get(i)__                    if (translogReader.generation == location.generation) {_                        return translogReader.read(location)__                    }_                }_            }_        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_        return null__    };reads,and,returns,the,operation,from,the,given,location,if,the,generation,it,references,is,still,available,otherwise,this,method,will,return,code,null,code;public,operation,read,operation,location,location,throws,ioexception,try,releasable,lock,ignored,read,lock,acquire,ensure,open,if,location,generation,get,min,file,generation,return,null,if,current,generation,location,generation,return,current,read,location,else,for,int,i,readers,size,1,i,0,i,translog,reader,translog,reader,readers,get,i,if,translog,reader,generation,location,generation,return,translog,reader,read,location,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex,return,null
Translog -> public Operation readOperation(Location location) throws IOException;1525334055;Reads and returns the operation from the given location if the generation it references is still available. Otherwise_this method will return <code>null</code>.;public Operation readOperation(Location location) throws IOException {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            if (location.generation < getMinFileGeneration()) {_                return null__            }_            if (current.generation == location.generation) {_                _                _                return current.read(location)__            } else {_                _                for (int i = readers.size() - 1_ i >= 0_ i--) {_                    TranslogReader translogReader = readers.get(i)__                    if (translogReader.generation == location.generation) {_                        return translogReader.read(location)__                    }_                }_            }_        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_        return null__    };reads,and,returns,the,operation,from,the,given,location,if,the,generation,it,references,is,still,available,otherwise,this,method,will,return,code,null,code;public,operation,read,operation,location,location,throws,ioexception,try,releasable,lock,ignored,read,lock,acquire,ensure,open,if,location,generation,get,min,file,generation,return,null,if,current,generation,location,generation,return,current,read,location,else,for,int,i,readers,size,1,i,0,i,translog,reader,translog,reader,readers,get,i,if,translog,reader,generation,location,generation,return,translog,reader,read,location,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex,return,null
Translog -> public Operation readOperation(Location location) throws IOException;1528706846;Reads and returns the operation from the given location if the generation it references is still available. Otherwise_this method will return <code>null</code>.;public Operation readOperation(Location location) throws IOException {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            if (location.generation < getMinFileGeneration()) {_                return null__            }_            if (current.generation == location.generation) {_                _                _                return current.read(location)__            } else {_                _                for (int i = readers.size() - 1_ i >= 0_ i--) {_                    TranslogReader translogReader = readers.get(i)__                    if (translogReader.generation == location.generation) {_                        return translogReader.read(location)__                    }_                }_            }_        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_        return null__    };reads,and,returns,the,operation,from,the,given,location,if,the,generation,it,references,is,still,available,otherwise,this,method,will,return,code,null,code;public,operation,read,operation,location,location,throws,ioexception,try,releasable,lock,ignored,read,lock,acquire,ensure,open,if,location,generation,get,min,file,generation,return,null,if,current,generation,location,generation,return,current,read,location,else,for,int,i,readers,size,1,i,0,i,translog,reader,translog,reader,readers,get,i,if,translog,reader,generation,location,generation,return,translog,reader,read,location,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex,return,null
Translog -> public Operation readOperation(Location location) throws IOException;1531910483;Reads and returns the operation from the given location if the generation it references is still available. Otherwise_this method will return <code>null</code>.;public Operation readOperation(Location location) throws IOException {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            if (location.generation < getMinFileGeneration()) {_                return null__            }_            if (current.generation == location.generation) {_                _                _                return current.read(location)__            } else {_                _                for (int i = readers.size() - 1_ i >= 0_ i--) {_                    TranslogReader translogReader = readers.get(i)__                    if (translogReader.generation == location.generation) {_                        return translogReader.read(location)__                    }_                }_            }_        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_        return null__    };reads,and,returns,the,operation,from,the,given,location,if,the,generation,it,references,is,still,available,otherwise,this,method,will,return,code,null,code;public,operation,read,operation,location,location,throws,ioexception,try,releasable,lock,ignored,read,lock,acquire,ensure,open,if,location,generation,get,min,file,generation,return,null,if,current,generation,location,generation,return,current,read,location,else,for,int,i,readers,size,1,i,0,i,translog,reader,translog,reader,readers,get,i,if,translog,reader,generation,location,generation,return,translog,reader,read,location,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex,return,null
Translog -> public Operation readOperation(Location location) throws IOException;1533295538;Reads and returns the operation from the given location if the generation it references is still available. Otherwise_this method will return <code>null</code>.;public Operation readOperation(Location location) throws IOException {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            if (location.generation < getMinFileGeneration()) {_                return null__            }_            if (current.generation == location.generation) {_                _                _                return current.read(location)__            } else {_                _                for (int i = readers.size() - 1_ i >= 0_ i--) {_                    TranslogReader translogReader = readers.get(i)__                    if (translogReader.generation == location.generation) {_                        return translogReader.read(location)__                    }_                }_            }_        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_        return null__    };reads,and,returns,the,operation,from,the,given,location,if,the,generation,it,references,is,still,available,otherwise,this,method,will,return,code,null,code;public,operation,read,operation,location,location,throws,ioexception,try,releasable,lock,ignored,read,lock,acquire,ensure,open,if,location,generation,get,min,file,generation,return,null,if,current,generation,location,generation,return,current,read,location,else,for,int,i,readers,size,1,i,0,i,translog,reader,translog,reader,readers,get,i,if,translog,reader,generation,location,generation,return,translog,reader,read,location,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex,return,null
Translog -> public Operation readOperation(Location location) throws IOException;1533641732;Reads and returns the operation from the given location if the generation it references is still available. Otherwise_this method will return <code>null</code>.;public Operation readOperation(Location location) throws IOException {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            if (location.generation < getMinFileGeneration()) {_                return null__            }_            if (current.generation == location.generation) {_                _                _                return current.read(location)__            } else {_                _                for (int i = readers.size() - 1_ i >= 0_ i--) {_                    TranslogReader translogReader = readers.get(i)__                    if (translogReader.generation == location.generation) {_                        return translogReader.read(location)__                    }_                }_            }_        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_        return null__    };reads,and,returns,the,operation,from,the,given,location,if,the,generation,it,references,is,still,available,otherwise,this,method,will,return,code,null,code;public,operation,read,operation,location,location,throws,ioexception,try,releasable,lock,ignored,read,lock,acquire,ensure,open,if,location,generation,get,min,file,generation,return,null,if,current,generation,location,generation,return,current,read,location,else,for,int,i,readers,size,1,i,0,i,translog,reader,translog,reader,readers,get,i,if,translog,reader,generation,location,generation,return,translog,reader,read,location,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex,return,null
Translog -> public Operation readOperation(Location location) throws IOException;1534848846;Reads and returns the operation from the given location if the generation it references is still available. Otherwise_this method will return <code>null</code>.;public Operation readOperation(Location location) throws IOException {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            if (location.generation < getMinFileGeneration()) {_                return null__            }_            if (current.generation == location.generation) {_                _                _                return current.read(location)__            } else {_                _                for (int i = readers.size() - 1_ i >= 0_ i--) {_                    TranslogReader translogReader = readers.get(i)__                    if (translogReader.generation == location.generation) {_                        return translogReader.read(location)__                    }_                }_            }_        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_        return null__    };reads,and,returns,the,operation,from,the,given,location,if,the,generation,it,references,is,still,available,otherwise,this,method,will,return,code,null,code;public,operation,read,operation,location,location,throws,ioexception,try,releasable,lock,ignored,read,lock,acquire,ensure,open,if,location,generation,get,min,file,generation,return,null,if,current,generation,location,generation,return,current,read,location,else,for,int,i,readers,size,1,i,0,i,translog,reader,translog,reader,readers,get,i,if,translog,reader,generation,location,generation,return,translog,reader,read,location,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex,return,null
Translog -> public Operation readOperation(Location location) throws IOException;1535046779;Reads and returns the operation from the given location if the generation it references is still available. Otherwise_this method will return <code>null</code>.;public Operation readOperation(Location location) throws IOException {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            if (location.generation < getMinFileGeneration()) {_                return null__            }_            if (current.generation == location.generation) {_                _                _                return current.read(location)__            } else {_                _                for (int i = readers.size() - 1_ i >= 0_ i--) {_                    TranslogReader translogReader = readers.get(i)__                    if (translogReader.generation == location.generation) {_                        return translogReader.read(location)__                    }_                }_            }_        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_        return null__    };reads,and,returns,the,operation,from,the,given,location,if,the,generation,it,references,is,still,available,otherwise,this,method,will,return,code,null,code;public,operation,read,operation,location,location,throws,ioexception,try,releasable,lock,ignored,read,lock,acquire,ensure,open,if,location,generation,get,min,file,generation,return,null,if,current,generation,location,generation,return,current,read,location,else,for,int,i,readers,size,1,i,0,i,translog,reader,translog,reader,readers,get,i,if,translog,reader,generation,location,generation,return,translog,reader,read,location,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex,return,null
Translog -> public Operation readOperation(Location location) throws IOException;1535723122;Reads and returns the operation from the given location if the generation it references is still available. Otherwise_this method will return <code>null</code>.;public Operation readOperation(Location location) throws IOException {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            if (location.generation < getMinFileGeneration()) {_                return null__            }_            if (current.generation == location.generation) {_                _                _                return current.read(location)__            } else {_                _                for (int i = readers.size() - 1_ i >= 0_ i--) {_                    TranslogReader translogReader = readers.get(i)__                    if (translogReader.generation == location.generation) {_                        return translogReader.read(location)__                    }_                }_            }_        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_        return null__    };reads,and,returns,the,operation,from,the,given,location,if,the,generation,it,references,is,still,available,otherwise,this,method,will,return,code,null,code;public,operation,read,operation,location,location,throws,ioexception,try,releasable,lock,ignored,read,lock,acquire,ensure,open,if,location,generation,get,min,file,generation,return,null,if,current,generation,location,generation,return,current,read,location,else,for,int,i,readers,size,1,i,0,i,translog,reader,translog,reader,readers,get,i,if,translog,reader,generation,location,generation,return,translog,reader,read,location,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex,return,null
Translog -> public Operation readOperation(Location location) throws IOException;1537806831;Reads and returns the operation from the given location if the generation it references is still available. Otherwise_this method will return <code>null</code>.;public Operation readOperation(Location location) throws IOException {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            if (location.generation < getMinFileGeneration()) {_                return null__            }_            if (current.generation == location.generation) {_                _                _                return current.read(location)__            } else {_                _                for (int i = readers.size() - 1_ i >= 0_ i--) {_                    TranslogReader translogReader = readers.get(i)__                    if (translogReader.generation == location.generation) {_                        return translogReader.read(location)__                    }_                }_            }_        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_        return null__    };reads,and,returns,the,operation,from,the,given,location,if,the,generation,it,references,is,still,available,otherwise,this,method,will,return,code,null,code;public,operation,read,operation,location,location,throws,ioexception,try,releasable,lock,ignored,read,lock,acquire,ensure,open,if,location,generation,get,min,file,generation,return,null,if,current,generation,location,generation,return,current,read,location,else,for,int,i,readers,size,1,i,0,i,translog,reader,translog,reader,readers,get,i,if,translog,reader,generation,location,generation,return,translog,reader,read,location,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex,return,null
Translog -> public Operation readOperation(Location location) throws IOException;1541592065;Reads and returns the operation from the given location if the generation it references is still available. Otherwise_this method will return <code>null</code>.;public Operation readOperation(Location location) throws IOException {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            if (location.generation < getMinFileGeneration()) {_                return null__            }_            if (current.generation == location.generation) {_                _                _                return current.read(location)__            } else {_                _                for (int i = readers.size() - 1_ i >= 0_ i--) {_                    TranslogReader translogReader = readers.get(i)__                    if (translogReader.generation == location.generation) {_                        return translogReader.read(location)__                    }_                }_            }_        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_        return null__    };reads,and,returns,the,operation,from,the,given,location,if,the,generation,it,references,is,still,available,otherwise,this,method,will,return,code,null,code;public,operation,read,operation,location,location,throws,ioexception,try,releasable,lock,ignored,read,lock,acquire,ensure,open,if,location,generation,get,min,file,generation,return,null,if,current,generation,location,generation,return,current,read,location,else,for,int,i,readers,size,1,i,0,i,translog,reader,translog,reader,readers,get,i,if,translog,reader,generation,location,generation,return,translog,reader,read,location,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex,return,null
Translog -> public Operation readOperation(Location location) throws IOException;1542697754;Reads and returns the operation from the given location if the generation it references is still available. Otherwise_this method will return <code>null</code>.;public Operation readOperation(Location location) throws IOException {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            if (location.generation < getMinFileGeneration()) {_                return null__            }_            if (current.generation == location.generation) {_                _                _                return current.read(location)__            } else {_                _                for (int i = readers.size() - 1_ i >= 0_ i--) {_                    TranslogReader translogReader = readers.get(i)__                    if (translogReader.generation == location.generation) {_                        return translogReader.read(location)__                    }_                }_            }_        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_        return null__    };reads,and,returns,the,operation,from,the,given,location,if,the,generation,it,references,is,still,available,otherwise,this,method,will,return,code,null,code;public,operation,read,operation,location,location,throws,ioexception,try,releasable,lock,ignored,read,lock,acquire,ensure,open,if,location,generation,get,min,file,generation,return,null,if,current,generation,location,generation,return,current,read,location,else,for,int,i,readers,size,1,i,0,i,translog,reader,translog,reader,readers,get,i,if,translog,reader,generation,location,generation,return,translog,reader,read,location,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex,return,null
Translog -> public Operation readOperation(Location location) throws IOException;1542962614;Reads and returns the operation from the given location if the generation it references is still available. Otherwise_this method will return <code>null</code>.;public Operation readOperation(Location location) throws IOException {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            if (location.generation < getMinFileGeneration()) {_                return null__            }_            if (current.generation == location.generation) {_                _                _                return current.read(location)__            } else {_                _                for (int i = readers.size() - 1_ i >= 0_ i--) {_                    TranslogReader translogReader = readers.get(i)__                    if (translogReader.generation == location.generation) {_                        return translogReader.read(location)__                    }_                }_            }_        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_        return null__    };reads,and,returns,the,operation,from,the,given,location,if,the,generation,it,references,is,still,available,otherwise,this,method,will,return,code,null,code;public,operation,read,operation,location,location,throws,ioexception,try,releasable,lock,ignored,read,lock,acquire,ensure,open,if,location,generation,get,min,file,generation,return,null,if,current,generation,location,generation,return,current,read,location,else,for,int,i,readers,size,1,i,0,i,translog,reader,translog,reader,readers,get,i,if,translog,reader,generation,location,generation,return,translog,reader,read,location,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex,return,null
Translog -> public Operation readOperation(Location location) throws IOException;1545236365;Reads and returns the operation from the given location if the generation it references is still available. Otherwise_this method will return <code>null</code>.;public Operation readOperation(Location location) throws IOException {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            if (location.generation < getMinFileGeneration()) {_                return null__            }_            if (current.generation == location.generation) {_                _                _                return current.read(location)__            } else {_                _                for (int i = readers.size() - 1_ i >= 0_ i--) {_                    TranslogReader translogReader = readers.get(i)__                    if (translogReader.generation == location.generation) {_                        return translogReader.read(location)__                    }_                }_            }_        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_        return null__    };reads,and,returns,the,operation,from,the,given,location,if,the,generation,it,references,is,still,available,otherwise,this,method,will,return,code,null,code;public,operation,read,operation,location,location,throws,ioexception,try,releasable,lock,ignored,read,lock,acquire,ensure,open,if,location,generation,get,min,file,generation,return,null,if,current,generation,location,generation,return,current,read,location,else,for,int,i,readers,size,1,i,0,i,translog,reader,translog,reader,readers,get,i,if,translog,reader,generation,location,generation,return,translog,reader,read,location,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex,return,null
Translog -> public long sizeInBytesByMinGen(long minGeneration);1524684173;Returns the size in bytes of the translog files at least the given generation;public long sizeInBytesByMinGen(long minGeneration) {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            return Stream.concat(readers.stream(), Stream.of(current))_                .filter(r -> r.getGeneration() >= minGeneration)_                .mapToLong(BaseTranslogReader::sizeInBytes)_                .sum()__        }_    };returns,the,size,in,bytes,of,the,translog,files,at,least,the,given,generation;public,long,size,in,bytes,by,min,gen,long,min,generation,try,releasable,lock,ignored,read,lock,acquire,ensure,open,return,stream,concat,readers,stream,stream,of,current,filter,r,r,get,generation,min,generation,map,to,long,base,translog,reader,size,in,bytes,sum
Translog -> public long sizeInBytesByMinGen(long minGeneration);1525334055;Returns the size in bytes of the translog files at least the given generation;public long sizeInBytesByMinGen(long minGeneration) {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            return Stream.concat(readers.stream(), Stream.of(current))_                .filter(r -> r.getGeneration() >= minGeneration)_                .mapToLong(BaseTranslogReader::sizeInBytes)_                .sum()__        }_    };returns,the,size,in,bytes,of,the,translog,files,at,least,the,given,generation;public,long,size,in,bytes,by,min,gen,long,min,generation,try,releasable,lock,ignored,read,lock,acquire,ensure,open,return,stream,concat,readers,stream,stream,of,current,filter,r,r,get,generation,min,generation,map,to,long,base,translog,reader,size,in,bytes,sum
Translog -> public long sizeInBytesByMinGen(long minGeneration);1528706846;Returns the size in bytes of the translog files at least the given generation;public long sizeInBytesByMinGen(long minGeneration) {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            return Stream.concat(readers.stream(), Stream.of(current))_                .filter(r -> r.getGeneration() >= minGeneration)_                .mapToLong(BaseTranslogReader::sizeInBytes)_                .sum()__        }_    };returns,the,size,in,bytes,of,the,translog,files,at,least,the,given,generation;public,long,size,in,bytes,by,min,gen,long,min,generation,try,releasable,lock,ignored,read,lock,acquire,ensure,open,return,stream,concat,readers,stream,stream,of,current,filter,r,r,get,generation,min,generation,map,to,long,base,translog,reader,size,in,bytes,sum
Translog -> public long sizeInBytesByMinGen(long minGeneration);1531910483;Returns the size in bytes of the translog files at least the given generation;public long sizeInBytesByMinGen(long minGeneration) {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            return Stream.concat(readers.stream(), Stream.of(current))_                .filter(r -> r.getGeneration() >= minGeneration)_                .mapToLong(BaseTranslogReader::sizeInBytes)_                .sum()__        }_    };returns,the,size,in,bytes,of,the,translog,files,at,least,the,given,generation;public,long,size,in,bytes,by,min,gen,long,min,generation,try,releasable,lock,ignored,read,lock,acquire,ensure,open,return,stream,concat,readers,stream,stream,of,current,filter,r,r,get,generation,min,generation,map,to,long,base,translog,reader,size,in,bytes,sum
Translog -> public long sizeInBytesByMinGen(long minGeneration);1533295538;Returns the size in bytes of the translog files at least the given generation;public long sizeInBytesByMinGen(long minGeneration) {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            return Stream.concat(readers.stream(), Stream.of(current))_                .filter(r -> r.getGeneration() >= minGeneration)_                .mapToLong(BaseTranslogReader::sizeInBytes)_                .sum()__        }_    };returns,the,size,in,bytes,of,the,translog,files,at,least,the,given,generation;public,long,size,in,bytes,by,min,gen,long,min,generation,try,releasable,lock,ignored,read,lock,acquire,ensure,open,return,stream,concat,readers,stream,stream,of,current,filter,r,r,get,generation,min,generation,map,to,long,base,translog,reader,size,in,bytes,sum
Translog -> public long sizeInBytesByMinGen(long minGeneration);1533641732;Returns the size in bytes of the translog files at least the given generation;public long sizeInBytesByMinGen(long minGeneration) {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            return Stream.concat(readers.stream(), Stream.of(current))_                .filter(r -> r.getGeneration() >= minGeneration)_                .mapToLong(BaseTranslogReader::sizeInBytes)_                .sum()__        }_    };returns,the,size,in,bytes,of,the,translog,files,at,least,the,given,generation;public,long,size,in,bytes,by,min,gen,long,min,generation,try,releasable,lock,ignored,read,lock,acquire,ensure,open,return,stream,concat,readers,stream,stream,of,current,filter,r,r,get,generation,min,generation,map,to,long,base,translog,reader,size,in,bytes,sum
Translog -> public long sizeInBytesByMinGen(long minGeneration);1534848846;Returns the size in bytes of the translog files at least the given generation;public long sizeInBytesByMinGen(long minGeneration) {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            return Stream.concat(readers.stream(), Stream.of(current))_                .filter(r -> r.getGeneration() >= minGeneration)_                .mapToLong(BaseTranslogReader::sizeInBytes)_                .sum()__        }_    };returns,the,size,in,bytes,of,the,translog,files,at,least,the,given,generation;public,long,size,in,bytes,by,min,gen,long,min,generation,try,releasable,lock,ignored,read,lock,acquire,ensure,open,return,stream,concat,readers,stream,stream,of,current,filter,r,r,get,generation,min,generation,map,to,long,base,translog,reader,size,in,bytes,sum
Translog -> public long sizeInBytesByMinGen(long minGeneration);1535046779;Returns the size in bytes of the translog files at least the given generation;public long sizeInBytesByMinGen(long minGeneration) {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            return Stream.concat(readers.stream(), Stream.of(current))_                .filter(r -> r.getGeneration() >= minGeneration)_                .mapToLong(BaseTranslogReader::sizeInBytes)_                .sum()__        }_    };returns,the,size,in,bytes,of,the,translog,files,at,least,the,given,generation;public,long,size,in,bytes,by,min,gen,long,min,generation,try,releasable,lock,ignored,read,lock,acquire,ensure,open,return,stream,concat,readers,stream,stream,of,current,filter,r,r,get,generation,min,generation,map,to,long,base,translog,reader,size,in,bytes,sum
Translog -> public long sizeInBytesByMinGen(long minGeneration);1535723122;Returns the size in bytes of the translog files at least the given generation;public long sizeInBytesByMinGen(long minGeneration) {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            return Stream.concat(readers.stream(), Stream.of(current))_                .filter(r -> r.getGeneration() >= minGeneration)_                .mapToLong(BaseTranslogReader::sizeInBytes)_                .sum()__        }_    };returns,the,size,in,bytes,of,the,translog,files,at,least,the,given,generation;public,long,size,in,bytes,by,min,gen,long,min,generation,try,releasable,lock,ignored,read,lock,acquire,ensure,open,return,stream,concat,readers,stream,stream,of,current,filter,r,r,get,generation,min,generation,map,to,long,base,translog,reader,size,in,bytes,sum
Translog -> public long sizeInBytesByMinGen(long minGeneration);1537806831;Returns the size in bytes of the translog files at least the given generation;public long sizeInBytesByMinGen(long minGeneration) {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            return Stream.concat(readers.stream(), Stream.of(current))_                .filter(r -> r.getGeneration() >= minGeneration)_                .mapToLong(BaseTranslogReader::sizeInBytes)_                .sum()__        }_    };returns,the,size,in,bytes,of,the,translog,files,at,least,the,given,generation;public,long,size,in,bytes,by,min,gen,long,min,generation,try,releasable,lock,ignored,read,lock,acquire,ensure,open,return,stream,concat,readers,stream,stream,of,current,filter,r,r,get,generation,min,generation,map,to,long,base,translog,reader,size,in,bytes,sum
Translog -> public long sizeInBytesByMinGen(long minGeneration);1541592065;Returns the size in bytes of the translog files at least the given generation;public long sizeInBytesByMinGen(long minGeneration) {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            return Stream.concat(readers.stream(), Stream.of(current))_                .filter(r -> r.getGeneration() >= minGeneration)_                .mapToLong(BaseTranslogReader::sizeInBytes)_                .sum()__        }_    };returns,the,size,in,bytes,of,the,translog,files,at,least,the,given,generation;public,long,size,in,bytes,by,min,gen,long,min,generation,try,releasable,lock,ignored,read,lock,acquire,ensure,open,return,stream,concat,readers,stream,stream,of,current,filter,r,r,get,generation,min,generation,map,to,long,base,translog,reader,size,in,bytes,sum
Translog -> public long sizeInBytesByMinGen(long minGeneration);1542697754;Returns the size in bytes of the translog files at least the given generation;public long sizeInBytesByMinGen(long minGeneration) {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            return Stream.concat(readers.stream(), Stream.of(current))_                .filter(r -> r.getGeneration() >= minGeneration)_                .mapToLong(BaseTranslogReader::sizeInBytes)_                .sum()__        }_    };returns,the,size,in,bytes,of,the,translog,files,at,least,the,given,generation;public,long,size,in,bytes,by,min,gen,long,min,generation,try,releasable,lock,ignored,read,lock,acquire,ensure,open,return,stream,concat,readers,stream,stream,of,current,filter,r,r,get,generation,min,generation,map,to,long,base,translog,reader,size,in,bytes,sum
Translog -> public long sizeInBytesByMinGen(long minGeneration);1542962614;Returns the size in bytes of the translog files at least the given generation;public long sizeInBytesByMinGen(long minGeneration) {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            return Stream.concat(readers.stream(), Stream.of(current))_                .filter(r -> r.getGeneration() >= minGeneration)_                .mapToLong(BaseTranslogReader::sizeInBytes)_                .sum()__        }_    };returns,the,size,in,bytes,of,the,translog,files,at,least,the,given,generation;public,long,size,in,bytes,by,min,gen,long,min,generation,try,releasable,lock,ignored,read,lock,acquire,ensure,open,return,stream,concat,readers,stream,stream,of,current,filter,r,r,get,generation,min,generation,map,to,long,base,translog,reader,size,in,bytes,sum
Translog -> public long sizeInBytesByMinGen(long minGeneration);1545236365;Returns the size in bytes of the translog files at least the given generation;public long sizeInBytesByMinGen(long minGeneration) {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            return Stream.concat(readers.stream(), Stream.of(current))_                .filter(r -> r.getGeneration() >= minGeneration)_                .mapToLong(BaseTranslogReader::sizeInBytes)_                .sum()__        }_    };returns,the,size,in,bytes,of,the,translog,files,at,least,the,given,generation;public,long,size,in,bytes,by,min,gen,long,min,generation,try,releasable,lock,ignored,read,lock,acquire,ensure,open,return,stream,concat,readers,stream,stream,of,current,filter,r,r,get,generation,min,generation,map,to,long,base,translog,reader,size,in,bytes,sum
Translog -> public Exception getTragicException();1524684173;If this {@code Translog} was closed as a side-effect of a tragic exception,_e.g. disk full while flushing a new segment, this returns the root cause exception._Otherwise (no tragic exception has occurred) it returns null.;public Exception getTragicException() {_        return current.getTragicException()__    };if,this,code,translog,was,closed,as,a,side,effect,of,a,tragic,exception,e,g,disk,full,while,flushing,a,new,segment,this,returns,the,root,cause,exception,otherwise,no,tragic,exception,has,occurred,it,returns,null;public,exception,get,tragic,exception,return,current,get,tragic,exception
Translog -> public Exception getTragicException();1525334055;If this {@code Translog} was closed as a side-effect of a tragic exception,_e.g. disk full while flushing a new segment, this returns the root cause exception._Otherwise (no tragic exception has occurred) it returns null.;public Exception getTragicException() {_        return current.getTragicException()__    };if,this,code,translog,was,closed,as,a,side,effect,of,a,tragic,exception,e,g,disk,full,while,flushing,a,new,segment,this,returns,the,root,cause,exception,otherwise,no,tragic,exception,has,occurred,it,returns,null;public,exception,get,tragic,exception,return,current,get,tragic,exception
Translog -> public Exception getTragicException();1528706846;If this {@code Translog} was closed as a side-effect of a tragic exception,_e.g. disk full while flushing a new segment, this returns the root cause exception._Otherwise (no tragic exception has occurred) it returns null.;public Exception getTragicException() {_        return current.getTragicException()__    };if,this,code,translog,was,closed,as,a,side,effect,of,a,tragic,exception,e,g,disk,full,while,flushing,a,new,segment,this,returns,the,root,cause,exception,otherwise,no,tragic,exception,has,occurred,it,returns,null;public,exception,get,tragic,exception,return,current,get,tragic,exception
Translog -> public Exception getTragicException();1531910483;If this {@code Translog} was closed as a side-effect of a tragic exception,_e.g. disk full while flushing a new segment, this returns the root cause exception._Otherwise (no tragic exception has occurred) it returns null.;public Exception getTragicException() {_        return current.getTragicException()__    };if,this,code,translog,was,closed,as,a,side,effect,of,a,tragic,exception,e,g,disk,full,while,flushing,a,new,segment,this,returns,the,root,cause,exception,otherwise,no,tragic,exception,has,occurred,it,returns,null;public,exception,get,tragic,exception,return,current,get,tragic,exception
Translog -> public Exception getTragicException();1533295538;If this {@code Translog} was closed as a side-effect of a tragic exception,_e.g. disk full while flushing a new segment, this returns the root cause exception._Otherwise (no tragic exception has occurred) it returns null.;public Exception getTragicException() {_        return current.getTragicException()__    };if,this,code,translog,was,closed,as,a,side,effect,of,a,tragic,exception,e,g,disk,full,while,flushing,a,new,segment,this,returns,the,root,cause,exception,otherwise,no,tragic,exception,has,occurred,it,returns,null;public,exception,get,tragic,exception,return,current,get,tragic,exception
Translog -> public Exception getTragicException();1533641732;If this {@code Translog} was closed as a side-effect of a tragic exception,_e.g. disk full while flushing a new segment, this returns the root cause exception._Otherwise (no tragic exception has occurred) it returns null.;public Exception getTragicException() {_        return current.getTragicException()__    };if,this,code,translog,was,closed,as,a,side,effect,of,a,tragic,exception,e,g,disk,full,while,flushing,a,new,segment,this,returns,the,root,cause,exception,otherwise,no,tragic,exception,has,occurred,it,returns,null;public,exception,get,tragic,exception,return,current,get,tragic,exception
Translog -> public Exception getTragicException();1534848846;If this {@code Translog} was closed as a side-effect of a tragic exception,_e.g. disk full while flushing a new segment, this returns the root cause exception._Otherwise (no tragic exception has occurred) it returns null.;public Exception getTragicException() {_        return tragedy.get()__    };if,this,code,translog,was,closed,as,a,side,effect,of,a,tragic,exception,e,g,disk,full,while,flushing,a,new,segment,this,returns,the,root,cause,exception,otherwise,no,tragic,exception,has,occurred,it,returns,null;public,exception,get,tragic,exception,return,tragedy,get
Translog -> public Exception getTragicException();1535046779;If this {@code Translog} was closed as a side-effect of a tragic exception,_e.g. disk full while flushing a new segment, this returns the root cause exception._Otherwise (no tragic exception has occurred) it returns null.;public Exception getTragicException() {_        return tragedy.get()__    };if,this,code,translog,was,closed,as,a,side,effect,of,a,tragic,exception,e,g,disk,full,while,flushing,a,new,segment,this,returns,the,root,cause,exception,otherwise,no,tragic,exception,has,occurred,it,returns,null;public,exception,get,tragic,exception,return,tragedy,get
Translog -> public Exception getTragicException();1535723122;If this {@code Translog} was closed as a side-effect of a tragic exception,_e.g. disk full while flushing a new segment, this returns the root cause exception._Otherwise (no tragic exception has occurred) it returns null.;public Exception getTragicException() {_        return tragedy.get()__    };if,this,code,translog,was,closed,as,a,side,effect,of,a,tragic,exception,e,g,disk,full,while,flushing,a,new,segment,this,returns,the,root,cause,exception,otherwise,no,tragic,exception,has,occurred,it,returns,null;public,exception,get,tragic,exception,return,tragedy,get
Translog -> public Exception getTragicException();1537806831;If this {@code Translog} was closed as a side-effect of a tragic exception,_e.g. disk full while flushing a new segment, this returns the root cause exception._Otherwise (no tragic exception has occurred) it returns null.;public Exception getTragicException() {_        return tragedy.get()__    };if,this,code,translog,was,closed,as,a,side,effect,of,a,tragic,exception,e,g,disk,full,while,flushing,a,new,segment,this,returns,the,root,cause,exception,otherwise,no,tragic,exception,has,occurred,it,returns,null;public,exception,get,tragic,exception,return,tragedy,get
Translog -> public Exception getTragicException();1541592065;If this {@code Translog} was closed as a side-effect of a tragic exception,_e.g. disk full while flushing a new segment, this returns the root cause exception._Otherwise (no tragic exception has occurred) it returns null.;public Exception getTragicException() {_        return tragedy.get()__    };if,this,code,translog,was,closed,as,a,side,effect,of,a,tragic,exception,e,g,disk,full,while,flushing,a,new,segment,this,returns,the,root,cause,exception,otherwise,no,tragic,exception,has,occurred,it,returns,null;public,exception,get,tragic,exception,return,tragedy,get
Translog -> public Exception getTragicException();1542697754;If this {@code Translog} was closed as a side-effect of a tragic exception,_e.g. disk full while flushing a new segment, this returns the root cause exception._Otherwise (no tragic exception has occurred) it returns null.;public Exception getTragicException() {_        return tragedy.get()__    };if,this,code,translog,was,closed,as,a,side,effect,of,a,tragic,exception,e,g,disk,full,while,flushing,a,new,segment,this,returns,the,root,cause,exception,otherwise,no,tragic,exception,has,occurred,it,returns,null;public,exception,get,tragic,exception,return,tragedy,get
Translog -> public Exception getTragicException();1542962614;If this {@code Translog} was closed as a side-effect of a tragic exception,_e.g. disk full while flushing a new segment, this returns the root cause exception._Otherwise (no tragic exception has occurred) it returns null.;public Exception getTragicException() {_        return tragedy.get()__    };if,this,code,translog,was,closed,as,a,side,effect,of,a,tragic,exception,e,g,disk,full,while,flushing,a,new,segment,this,returns,the,root,cause,exception,otherwise,no,tragic,exception,has,occurred,it,returns,null;public,exception,get,tragic,exception,return,tragedy,get
Translog -> public Exception getTragicException();1545236365;If this {@code Translog} was closed as a side-effect of a tragic exception,_e.g. disk full while flushing a new segment, this returns the root cause exception._Otherwise (no tragic exception has occurred) it returns null.;public Exception getTragicException() {_        return tragedy.get()__    };if,this,code,translog,was,closed,as,a,side,effect,of,a,tragic,exception,e,g,disk,full,while,flushing,a,new,segment,this,returns,the,root,cause,exception,otherwise,no,tragic,exception,has,occurred,it,returns,null;public,exception,get,tragic,exception,return,tragedy,get
Translog -> Operation -> static Operation readOperation(final StreamInput input) throws IOException;1524684173;Reads the type and the operation from the given stream. The operation must be written with_{@link Operation#writeOperation(StreamOutput, Operation)};static Operation readOperation(final StreamInput input) throws IOException {_            final Translog.Operation.Type type = Translog.Operation.Type.fromId(input.readByte())__            switch (type) {_                case CREATE:_                    _                case INDEX:_                    return new Index(input)__                case DELETE:_                    return new Delete(input)__                case NO_OP:_                    return new NoOp(input)__                default:_                    throw new AssertionError("no case for [" + type + "]")__            }_        };reads,the,type,and,the,operation,from,the,given,stream,the,operation,must,be,written,with,link,operation,write,operation,stream,output,operation;static,operation,read,operation,final,stream,input,input,throws,ioexception,final,translog,operation,type,type,translog,operation,type,from,id,input,read,byte,switch,type,case,create,case,index,return,new,index,input,case,delete,return,new,delete,input,case,return,new,no,op,input,default,throw,new,assertion,error,no,case,for,type
Translog -> Operation -> static Operation readOperation(final StreamInput input) throws IOException;1525334055;Reads the type and the operation from the given stream. The operation must be written with_{@link Operation#writeOperation(StreamOutput, Operation)};static Operation readOperation(final StreamInput input) throws IOException {_            final Translog.Operation.Type type = Translog.Operation.Type.fromId(input.readByte())__            switch (type) {_                case CREATE:_                    _                case INDEX:_                    return new Index(input)__                case DELETE:_                    return new Delete(input)__                case NO_OP:_                    return new NoOp(input)__                default:_                    throw new AssertionError("no case for [" + type + "]")__            }_        };reads,the,type,and,the,operation,from,the,given,stream,the,operation,must,be,written,with,link,operation,write,operation,stream,output,operation;static,operation,read,operation,final,stream,input,input,throws,ioexception,final,translog,operation,type,type,translog,operation,type,from,id,input,read,byte,switch,type,case,create,case,index,return,new,index,input,case,delete,return,new,delete,input,case,return,new,no,op,input,default,throw,new,assertion,error,no,case,for,type
Translog -> Operation -> static Operation readOperation(final StreamInput input) throws IOException;1528706846;Reads the type and the operation from the given stream. The operation must be written with_{@link Operation#writeOperation(StreamOutput, Operation)};static Operation readOperation(final StreamInput input) throws IOException {_            final Translog.Operation.Type type = Translog.Operation.Type.fromId(input.readByte())__            switch (type) {_                case CREATE:_                    _                case INDEX:_                    return new Index(input)__                case DELETE:_                    return new Delete(input)__                case NO_OP:_                    return new NoOp(input)__                default:_                    throw new AssertionError("no case for [" + type + "]")__            }_        };reads,the,type,and,the,operation,from,the,given,stream,the,operation,must,be,written,with,link,operation,write,operation,stream,output,operation;static,operation,read,operation,final,stream,input,input,throws,ioexception,final,translog,operation,type,type,translog,operation,type,from,id,input,read,byte,switch,type,case,create,case,index,return,new,index,input,case,delete,return,new,delete,input,case,return,new,no,op,input,default,throw,new,assertion,error,no,case,for,type
Translog -> Operation -> static Operation readOperation(final StreamInput input) throws IOException;1531910483;Reads the type and the operation from the given stream. The operation must be written with_{@link Operation#writeOperation(StreamOutput, Operation)};static Operation readOperation(final StreamInput input) throws IOException {_            final Translog.Operation.Type type = Translog.Operation.Type.fromId(input.readByte())__            switch (type) {_                case CREATE:_                    _                case INDEX:_                    return new Index(input)__                case DELETE:_                    return new Delete(input)__                case NO_OP:_                    return new NoOp(input)__                default:_                    throw new AssertionError("no case for [" + type + "]")__            }_        };reads,the,type,and,the,operation,from,the,given,stream,the,operation,must,be,written,with,link,operation,write,operation,stream,output,operation;static,operation,read,operation,final,stream,input,input,throws,ioexception,final,translog,operation,type,type,translog,operation,type,from,id,input,read,byte,switch,type,case,create,case,index,return,new,index,input,case,delete,return,new,delete,input,case,return,new,no,op,input,default,throw,new,assertion,error,no,case,for,type
Translog -> Operation -> static Operation readOperation(final StreamInput input) throws IOException;1533295538;Reads the type and the operation from the given stream. The operation must be written with_{@link Operation#writeOperation(StreamOutput, Operation)};static Operation readOperation(final StreamInput input) throws IOException {_            final Translog.Operation.Type type = Translog.Operation.Type.fromId(input.readByte())__            switch (type) {_                case CREATE:_                    _                case INDEX:_                    return new Index(input)__                case DELETE:_                    return new Delete(input)__                case NO_OP:_                    return new NoOp(input)__                default:_                    throw new AssertionError("no case for [" + type + "]")__            }_        };reads,the,type,and,the,operation,from,the,given,stream,the,operation,must,be,written,with,link,operation,write,operation,stream,output,operation;static,operation,read,operation,final,stream,input,input,throws,ioexception,final,translog,operation,type,type,translog,operation,type,from,id,input,read,byte,switch,type,case,create,case,index,return,new,index,input,case,delete,return,new,delete,input,case,return,new,no,op,input,default,throw,new,assertion,error,no,case,for,type
Translog -> Operation -> static Operation readOperation(final StreamInput input) throws IOException;1533641732;Reads the type and the operation from the given stream. The operation must be written with_{@link Operation#writeOperation(StreamOutput, Operation)};static Operation readOperation(final StreamInput input) throws IOException {_            final Translog.Operation.Type type = Translog.Operation.Type.fromId(input.readByte())__            switch (type) {_                case CREATE:_                    _                case INDEX:_                    return new Index(input)__                case DELETE:_                    return new Delete(input)__                case NO_OP:_                    return new NoOp(input)__                default:_                    throw new AssertionError("no case for [" + type + "]")__            }_        };reads,the,type,and,the,operation,from,the,given,stream,the,operation,must,be,written,with,link,operation,write,operation,stream,output,operation;static,operation,read,operation,final,stream,input,input,throws,ioexception,final,translog,operation,type,type,translog,operation,type,from,id,input,read,byte,switch,type,case,create,case,index,return,new,index,input,case,delete,return,new,delete,input,case,return,new,no,op,input,default,throw,new,assertion,error,no,case,for,type
Translog -> Operation -> static Operation readOperation(final StreamInput input) throws IOException;1534848846;Reads the type and the operation from the given stream. The operation must be written with_{@link Operation#writeOperation(StreamOutput, Operation)};static Operation readOperation(final StreamInput input) throws IOException {_            final Translog.Operation.Type type = Translog.Operation.Type.fromId(input.readByte())__            switch (type) {_                case CREATE:_                    _                case INDEX:_                    return new Index(input)__                case DELETE:_                    return new Delete(input)__                case NO_OP:_                    return new NoOp(input)__                default:_                    throw new AssertionError("no case for [" + type + "]")__            }_        };reads,the,type,and,the,operation,from,the,given,stream,the,operation,must,be,written,with,link,operation,write,operation,stream,output,operation;static,operation,read,operation,final,stream,input,input,throws,ioexception,final,translog,operation,type,type,translog,operation,type,from,id,input,read,byte,switch,type,case,create,case,index,return,new,index,input,case,delete,return,new,delete,input,case,return,new,no,op,input,default,throw,new,assertion,error,no,case,for,type
Translog -> Operation -> static Operation readOperation(final StreamInput input) throws IOException;1535046779;Reads the type and the operation from the given stream. The operation must be written with_{@link Operation#writeOperation(StreamOutput, Operation)};static Operation readOperation(final StreamInput input) throws IOException {_            final Translog.Operation.Type type = Translog.Operation.Type.fromId(input.readByte())__            switch (type) {_                case CREATE:_                    _                case INDEX:_                    return new Index(input)__                case DELETE:_                    return new Delete(input)__                case NO_OP:_                    return new NoOp(input)__                default:_                    throw new AssertionError("no case for [" + type + "]")__            }_        };reads,the,type,and,the,operation,from,the,given,stream,the,operation,must,be,written,with,link,operation,write,operation,stream,output,operation;static,operation,read,operation,final,stream,input,input,throws,ioexception,final,translog,operation,type,type,translog,operation,type,from,id,input,read,byte,switch,type,case,create,case,index,return,new,index,input,case,delete,return,new,delete,input,case,return,new,no,op,input,default,throw,new,assertion,error,no,case,for,type
Translog -> Operation -> static Operation readOperation(final StreamInput input) throws IOException;1535723122;Reads the type and the operation from the given stream. The operation must be written with_{@link Operation#writeOperation(StreamOutput, Operation)};static Operation readOperation(final StreamInput input) throws IOException {_            final Translog.Operation.Type type = Translog.Operation.Type.fromId(input.readByte())__            switch (type) {_                case CREATE:_                    _                case INDEX:_                    return new Index(input)__                case DELETE:_                    return new Delete(input)__                case NO_OP:_                    return new NoOp(input)__                default:_                    throw new AssertionError("no case for [" + type + "]")__            }_        };reads,the,type,and,the,operation,from,the,given,stream,the,operation,must,be,written,with,link,operation,write,operation,stream,output,operation;static,operation,read,operation,final,stream,input,input,throws,ioexception,final,translog,operation,type,type,translog,operation,type,from,id,input,read,byte,switch,type,case,create,case,index,return,new,index,input,case,delete,return,new,delete,input,case,return,new,no,op,input,default,throw,new,assertion,error,no,case,for,type
Translog -> Operation -> static Operation readOperation(final StreamInput input) throws IOException;1537806831;Reads the type and the operation from the given stream. The operation must be written with_{@link Operation#writeOperation(StreamOutput, Operation)};static Operation readOperation(final StreamInput input) throws IOException {_            final Translog.Operation.Type type = Translog.Operation.Type.fromId(input.readByte())__            switch (type) {_                case CREATE:_                    _                case INDEX:_                    return new Index(input)__                case DELETE:_                    return new Delete(input)__                case NO_OP:_                    return new NoOp(input)__                default:_                    throw new AssertionError("no case for [" + type + "]")__            }_        };reads,the,type,and,the,operation,from,the,given,stream,the,operation,must,be,written,with,link,operation,write,operation,stream,output,operation;static,operation,read,operation,final,stream,input,input,throws,ioexception,final,translog,operation,type,type,translog,operation,type,from,id,input,read,byte,switch,type,case,create,case,index,return,new,index,input,case,delete,return,new,delete,input,case,return,new,no,op,input,default,throw,new,assertion,error,no,case,for,type
Translog -> Operation -> static Operation readOperation(final StreamInput input) throws IOException;1541592065;Reads the type and the operation from the given stream. The operation must be written with_{@link Operation#writeOperation(StreamOutput, Operation)};static Operation readOperation(final StreamInput input) throws IOException {_            final Translog.Operation.Type type = Translog.Operation.Type.fromId(input.readByte())__            switch (type) {_                case CREATE:_                    _                case INDEX:_                    return new Index(input)__                case DELETE:_                    return new Delete(input)__                case NO_OP:_                    return new NoOp(input)__                default:_                    throw new AssertionError("no case for [" + type + "]")__            }_        };reads,the,type,and,the,operation,from,the,given,stream,the,operation,must,be,written,with,link,operation,write,operation,stream,output,operation;static,operation,read,operation,final,stream,input,input,throws,ioexception,final,translog,operation,type,type,translog,operation,type,from,id,input,read,byte,switch,type,case,create,case,index,return,new,index,input,case,delete,return,new,delete,input,case,return,new,no,op,input,default,throw,new,assertion,error,no,case,for,type
Translog -> Operation -> static Operation readOperation(final StreamInput input) throws IOException;1542697754;Reads the type and the operation from the given stream. The operation must be written with_{@link Operation#writeOperation(StreamOutput, Operation)};static Operation readOperation(final StreamInput input) throws IOException {_            final Translog.Operation.Type type = Translog.Operation.Type.fromId(input.readByte())__            switch (type) {_                case CREATE:_                    _                case INDEX:_                    return new Index(input)__                case DELETE:_                    return new Delete(input)__                case NO_OP:_                    return new NoOp(input)__                default:_                    throw new AssertionError("no case for [" + type + "]")__            }_        };reads,the,type,and,the,operation,from,the,given,stream,the,operation,must,be,written,with,link,operation,write,operation,stream,output,operation;static,operation,read,operation,final,stream,input,input,throws,ioexception,final,translog,operation,type,type,translog,operation,type,from,id,input,read,byte,switch,type,case,create,case,index,return,new,index,input,case,delete,return,new,delete,input,case,return,new,no,op,input,default,throw,new,assertion,error,no,case,for,type
Translog -> Operation -> static Operation readOperation(final StreamInput input) throws IOException;1542962614;Reads the type and the operation from the given stream. The operation must be written with_{@link Operation#writeOperation(StreamOutput, Operation)};static Operation readOperation(final StreamInput input) throws IOException {_            final Translog.Operation.Type type = Translog.Operation.Type.fromId(input.readByte())__            switch (type) {_                case CREATE:_                    _                case INDEX:_                    return new Index(input)__                case DELETE:_                    return new Delete(input)__                case NO_OP:_                    return new NoOp(input)__                default:_                    throw new AssertionError("no case for [" + type + "]")__            }_        };reads,the,type,and,the,operation,from,the,given,stream,the,operation,must,be,written,with,link,operation,write,operation,stream,output,operation;static,operation,read,operation,final,stream,input,input,throws,ioexception,final,translog,operation,type,type,translog,operation,type,from,id,input,read,byte,switch,type,case,create,case,index,return,new,index,input,case,delete,return,new,delete,input,case,return,new,no,op,input,default,throw,new,assertion,error,no,case,for,type
Translog -> Operation -> static Operation readOperation(final StreamInput input) throws IOException;1545236365;Reads the type and the operation from the given stream. The operation must be written with_{@link Operation#writeOperation(StreamOutput, Operation)};static Operation readOperation(final StreamInput input) throws IOException {_            final Translog.Operation.Type type = Translog.Operation.Type.fromId(input.readByte())__            switch (type) {_                case CREATE:_                    _                case INDEX:_                    return new Index(input)__                case DELETE:_                    return new Delete(input)__                case NO_OP:_                    return new NoOp(input)__                default:_                    throw new AssertionError("no case for [" + type + "]")__            }_        };reads,the,type,and,the,operation,from,the,given,stream,the,operation,must,be,written,with,link,operation,write,operation,stream,output,operation;static,operation,read,operation,final,stream,input,input,throws,ioexception,final,translog,operation,type,type,translog,operation,type,from,id,input,read,byte,switch,type,case,create,case,index,return,new,index,input,case,delete,return,new,delete,input,case,return,new,no,op,input,default,throw,new,assertion,error,no,case,for,type
Translog -> Snapshot -> default int skippedOperations();1528706846;The number of operations have been skipped (overridden or trimmed) in the snapshot so far.;default int skippedOperations() {_            return 0__        };the,number,of,operations,have,been,skipped,overridden,or,trimmed,in,the,snapshot,so,far;default,int,skipped,operations,return,0
Translog -> Snapshot -> default int skippedOperations();1531910483;The number of operations have been skipped (overridden or trimmed) in the snapshot so far.;default int skippedOperations() {_            return 0__        };the,number,of,operations,have,been,skipped,overridden,or,trimmed,in,the,snapshot,so,far;default,int,skipped,operations,return,0
Translog -> Snapshot -> default int skippedOperations();1533295538;The number of operations have been skipped (overridden or trimmed) in the snapshot so far.;default int skippedOperations() {_            return 0__        };the,number,of,operations,have,been,skipped,overridden,or,trimmed,in,the,snapshot,so,far;default,int,skipped,operations,return,0
Translog -> Snapshot -> default int skippedOperations();1533641732;The number of operations have been skipped (overridden or trimmed) in the snapshot so far.;default int skippedOperations() {_            return 0__        };the,number,of,operations,have,been,skipped,overridden,or,trimmed,in,the,snapshot,so,far;default,int,skipped,operations,return,0
Translog -> Snapshot -> default int skippedOperations();1534848846;The number of operations have been skipped (overridden or trimmed) in the snapshot so far.;default int skippedOperations() {_            return 0__        };the,number,of,operations,have,been,skipped,overridden,or,trimmed,in,the,snapshot,so,far;default,int,skipped,operations,return,0
Translog -> Snapshot -> default int skippedOperations();1535046779;The number of operations have been skipped (overridden or trimmed) in the snapshot so far.;default int skippedOperations() {_            return 0__        };the,number,of,operations,have,been,skipped,overridden,or,trimmed,in,the,snapshot,so,far;default,int,skipped,operations,return,0
Translog -> Snapshot -> default int skippedOperations();1535723122;The number of operations have been skipped (overridden or trimmed) in the snapshot so far.;default int skippedOperations() {_            return 0__        };the,number,of,operations,have,been,skipped,overridden,or,trimmed,in,the,snapshot,so,far;default,int,skipped,operations,return,0
Translog -> Snapshot -> default int skippedOperations();1537806831;The number of operations have been skipped (overridden or trimmed) in the snapshot so far.;default int skippedOperations() {_            return 0__        };the,number,of,operations,have,been,skipped,overridden,or,trimmed,in,the,snapshot,so,far;default,int,skipped,operations,return,0
Translog -> Snapshot -> default int skippedOperations();1541592065;The number of operations have been skipped (overridden or trimmed) in the snapshot so far.;default int skippedOperations() {_            return 0__        };the,number,of,operations,have,been,skipped,overridden,or,trimmed,in,the,snapshot,so,far;default,int,skipped,operations,return,0
Translog -> Snapshot -> default int skippedOperations();1542697754;The number of operations have been skipped (overridden or trimmed) in the snapshot so far.;default int skippedOperations() {_            return 0__        };the,number,of,operations,have,been,skipped,overridden,or,trimmed,in,the,snapshot,so,far;default,int,skipped,operations,return,0
Translog -> Snapshot -> default int skippedOperations();1542962614;The number of operations have been skipped (overridden or trimmed) in the snapshot so far.;default int skippedOperations() {_            return 0__        };the,number,of,operations,have,been,skipped,overridden,or,trimmed,in,the,snapshot,so,far;default,int,skipped,operations,return,0
Translog -> Snapshot -> default int skippedOperations();1545236365;The number of operations have been skipped (overridden or trimmed) in the snapshot so far.;default int skippedOperations() {_            return 0__        };the,number,of,operations,have,been,skipped,overridden,or,trimmed,in,the,snapshot,so,far;default,int,skipped,operations,return,0
Translog -> public boolean ensureSynced(Stream<Location> locations) throws IOException;1524684173;Ensures that all locations in the given stream have been synced / written to the underlying storage._This method allows for internal optimization to minimize the amount of fsync operations if multiple_locations must be synced.__@return Returns <code>true</code> iff this call caused an actual sync operation otherwise <code>false</code>;public boolean ensureSynced(Stream<Location> locations) throws IOException {_        final Optional<Location> max = locations.max(Location::compareTo)__        _        _        if (max.isPresent()) {_            return ensureSynced(max.get())__        } else {_            return false__        }_    };ensures,that,all,locations,in,the,given,stream,have,been,synced,written,to,the,underlying,storage,this,method,allows,for,internal,optimization,to,minimize,the,amount,of,fsync,operations,if,multiple,locations,must,be,synced,return,returns,code,true,code,iff,this,call,caused,an,actual,sync,operation,otherwise,code,false,code;public,boolean,ensure,synced,stream,location,locations,throws,ioexception,final,optional,location,max,locations,max,location,compare,to,if,max,is,present,return,ensure,synced,max,get,else,return,false
Translog -> public boolean ensureSynced(Stream<Location> locations) throws IOException;1525334055;Ensures that all locations in the given stream have been synced / written to the underlying storage._This method allows for internal optimization to minimize the amount of fsync operations if multiple_locations must be synced.__@return Returns <code>true</code> iff this call caused an actual sync operation otherwise <code>false</code>;public boolean ensureSynced(Stream<Location> locations) throws IOException {_        final Optional<Location> max = locations.max(Location::compareTo)__        _        _        if (max.isPresent()) {_            return ensureSynced(max.get())__        } else {_            return false__        }_    };ensures,that,all,locations,in,the,given,stream,have,been,synced,written,to,the,underlying,storage,this,method,allows,for,internal,optimization,to,minimize,the,amount,of,fsync,operations,if,multiple,locations,must,be,synced,return,returns,code,true,code,iff,this,call,caused,an,actual,sync,operation,otherwise,code,false,code;public,boolean,ensure,synced,stream,location,locations,throws,ioexception,final,optional,location,max,locations,max,location,compare,to,if,max,is,present,return,ensure,synced,max,get,else,return,false
Translog -> public boolean ensureSynced(Stream<Location> locations) throws IOException;1528706846;Ensures that all locations in the given stream have been synced / written to the underlying storage._This method allows for internal optimization to minimize the amount of fsync operations if multiple_locations must be synced.__@return Returns <code>true</code> iff this call caused an actual sync operation otherwise <code>false</code>;public boolean ensureSynced(Stream<Location> locations) throws IOException {_        final Optional<Location> max = locations.max(Location::compareTo)__        _        _        if (max.isPresent()) {_            return ensureSynced(max.get())__        } else {_            return false__        }_    };ensures,that,all,locations,in,the,given,stream,have,been,synced,written,to,the,underlying,storage,this,method,allows,for,internal,optimization,to,minimize,the,amount,of,fsync,operations,if,multiple,locations,must,be,synced,return,returns,code,true,code,iff,this,call,caused,an,actual,sync,operation,otherwise,code,false,code;public,boolean,ensure,synced,stream,location,locations,throws,ioexception,final,optional,location,max,locations,max,location,compare,to,if,max,is,present,return,ensure,synced,max,get,else,return,false
Translog -> public boolean ensureSynced(Stream<Location> locations) throws IOException;1531910483;Ensures that all locations in the given stream have been synced / written to the underlying storage._This method allows for internal optimization to minimize the amount of fsync operations if multiple_locations must be synced.__@return Returns <code>true</code> iff this call caused an actual sync operation otherwise <code>false</code>;public boolean ensureSynced(Stream<Location> locations) throws IOException {_        final Optional<Location> max = locations.max(Location::compareTo)__        _        _        if (max.isPresent()) {_            return ensureSynced(max.get())__        } else {_            return false__        }_    };ensures,that,all,locations,in,the,given,stream,have,been,synced,written,to,the,underlying,storage,this,method,allows,for,internal,optimization,to,minimize,the,amount,of,fsync,operations,if,multiple,locations,must,be,synced,return,returns,code,true,code,iff,this,call,caused,an,actual,sync,operation,otherwise,code,false,code;public,boolean,ensure,synced,stream,location,locations,throws,ioexception,final,optional,location,max,locations,max,location,compare,to,if,max,is,present,return,ensure,synced,max,get,else,return,false
Translog -> public boolean ensureSynced(Stream<Location> locations) throws IOException;1533295538;Ensures that all locations in the given stream have been synced / written to the underlying storage._This method allows for internal optimization to minimize the amount of fsync operations if multiple_locations must be synced.__@return Returns <code>true</code> iff this call caused an actual sync operation otherwise <code>false</code>;public boolean ensureSynced(Stream<Location> locations) throws IOException {_        final Optional<Location> max = locations.max(Location::compareTo)__        _        _        if (max.isPresent()) {_            return ensureSynced(max.get())__        } else {_            return false__        }_    };ensures,that,all,locations,in,the,given,stream,have,been,synced,written,to,the,underlying,storage,this,method,allows,for,internal,optimization,to,minimize,the,amount,of,fsync,operations,if,multiple,locations,must,be,synced,return,returns,code,true,code,iff,this,call,caused,an,actual,sync,operation,otherwise,code,false,code;public,boolean,ensure,synced,stream,location,locations,throws,ioexception,final,optional,location,max,locations,max,location,compare,to,if,max,is,present,return,ensure,synced,max,get,else,return,false
Translog -> public boolean ensureSynced(Stream<Location> locations) throws IOException;1533641732;Ensures that all locations in the given stream have been synced / written to the underlying storage._This method allows for internal optimization to minimize the amount of fsync operations if multiple_locations must be synced.__@return Returns <code>true</code> iff this call caused an actual sync operation otherwise <code>false</code>;public boolean ensureSynced(Stream<Location> locations) throws IOException {_        final Optional<Location> max = locations.max(Location::compareTo)__        _        _        if (max.isPresent()) {_            return ensureSynced(max.get())__        } else {_            return false__        }_    };ensures,that,all,locations,in,the,given,stream,have,been,synced,written,to,the,underlying,storage,this,method,allows,for,internal,optimization,to,minimize,the,amount,of,fsync,operations,if,multiple,locations,must,be,synced,return,returns,code,true,code,iff,this,call,caused,an,actual,sync,operation,otherwise,code,false,code;public,boolean,ensure,synced,stream,location,locations,throws,ioexception,final,optional,location,max,locations,max,location,compare,to,if,max,is,present,return,ensure,synced,max,get,else,return,false
Translog -> public boolean ensureSynced(Stream<Location> locations) throws IOException;1534848846;Ensures that all locations in the given stream have been synced / written to the underlying storage._This method allows for internal optimization to minimize the amount of fsync operations if multiple_locations must be synced.__@return Returns <code>true</code> iff this call caused an actual sync operation otherwise <code>false</code>;public boolean ensureSynced(Stream<Location> locations) throws IOException {_        final Optional<Location> max = locations.max(Location::compareTo)__        _        _        if (max.isPresent()) {_            return ensureSynced(max.get())__        } else {_            return false__        }_    };ensures,that,all,locations,in,the,given,stream,have,been,synced,written,to,the,underlying,storage,this,method,allows,for,internal,optimization,to,minimize,the,amount,of,fsync,operations,if,multiple,locations,must,be,synced,return,returns,code,true,code,iff,this,call,caused,an,actual,sync,operation,otherwise,code,false,code;public,boolean,ensure,synced,stream,location,locations,throws,ioexception,final,optional,location,max,locations,max,location,compare,to,if,max,is,present,return,ensure,synced,max,get,else,return,false
Translog -> public boolean ensureSynced(Stream<Location> locations) throws IOException;1535046779;Ensures that all locations in the given stream have been synced / written to the underlying storage._This method allows for internal optimization to minimize the amount of fsync operations if multiple_locations must be synced.__@return Returns <code>true</code> iff this call caused an actual sync operation otherwise <code>false</code>;public boolean ensureSynced(Stream<Location> locations) throws IOException {_        final Optional<Location> max = locations.max(Location::compareTo)__        _        _        if (max.isPresent()) {_            return ensureSynced(max.get())__        } else {_            return false__        }_    };ensures,that,all,locations,in,the,given,stream,have,been,synced,written,to,the,underlying,storage,this,method,allows,for,internal,optimization,to,minimize,the,amount,of,fsync,operations,if,multiple,locations,must,be,synced,return,returns,code,true,code,iff,this,call,caused,an,actual,sync,operation,otherwise,code,false,code;public,boolean,ensure,synced,stream,location,locations,throws,ioexception,final,optional,location,max,locations,max,location,compare,to,if,max,is,present,return,ensure,synced,max,get,else,return,false
Translog -> public boolean ensureSynced(Stream<Location> locations) throws IOException;1535723122;Ensures that all locations in the given stream have been synced / written to the underlying storage._This method allows for internal optimization to minimize the amount of fsync operations if multiple_locations must be synced.__@return Returns <code>true</code> iff this call caused an actual sync operation otherwise <code>false</code>;public boolean ensureSynced(Stream<Location> locations) throws IOException {_        final Optional<Location> max = locations.max(Location::compareTo)__        _        _        if (max.isPresent()) {_            return ensureSynced(max.get())__        } else {_            return false__        }_    };ensures,that,all,locations,in,the,given,stream,have,been,synced,written,to,the,underlying,storage,this,method,allows,for,internal,optimization,to,minimize,the,amount,of,fsync,operations,if,multiple,locations,must,be,synced,return,returns,code,true,code,iff,this,call,caused,an,actual,sync,operation,otherwise,code,false,code;public,boolean,ensure,synced,stream,location,locations,throws,ioexception,final,optional,location,max,locations,max,location,compare,to,if,max,is,present,return,ensure,synced,max,get,else,return,false
Translog -> public boolean ensureSynced(Stream<Location> locations) throws IOException;1537806831;Ensures that all locations in the given stream have been synced / written to the underlying storage._This method allows for internal optimization to minimize the amount of fsync operations if multiple_locations must be synced.__@return Returns <code>true</code> iff this call caused an actual sync operation otherwise <code>false</code>;public boolean ensureSynced(Stream<Location> locations) throws IOException {_        final Optional<Location> max = locations.max(Location::compareTo)__        _        _        if (max.isPresent()) {_            return ensureSynced(max.get())__        } else {_            return false__        }_    };ensures,that,all,locations,in,the,given,stream,have,been,synced,written,to,the,underlying,storage,this,method,allows,for,internal,optimization,to,minimize,the,amount,of,fsync,operations,if,multiple,locations,must,be,synced,return,returns,code,true,code,iff,this,call,caused,an,actual,sync,operation,otherwise,code,false,code;public,boolean,ensure,synced,stream,location,locations,throws,ioexception,final,optional,location,max,locations,max,location,compare,to,if,max,is,present,return,ensure,synced,max,get,else,return,false
Translog -> public boolean ensureSynced(Stream<Location> locations) throws IOException;1541592065;Ensures that all locations in the given stream have been synced / written to the underlying storage._This method allows for internal optimization to minimize the amount of fsync operations if multiple_locations must be synced.__@return Returns <code>true</code> iff this call caused an actual sync operation otherwise <code>false</code>;public boolean ensureSynced(Stream<Location> locations) throws IOException {_        final Optional<Location> max = locations.max(Location::compareTo)__        _        _        if (max.isPresent()) {_            return ensureSynced(max.get())__        } else {_            return false__        }_    };ensures,that,all,locations,in,the,given,stream,have,been,synced,written,to,the,underlying,storage,this,method,allows,for,internal,optimization,to,minimize,the,amount,of,fsync,operations,if,multiple,locations,must,be,synced,return,returns,code,true,code,iff,this,call,caused,an,actual,sync,operation,otherwise,code,false,code;public,boolean,ensure,synced,stream,location,locations,throws,ioexception,final,optional,location,max,locations,max,location,compare,to,if,max,is,present,return,ensure,synced,max,get,else,return,false
Translog -> public boolean ensureSynced(Stream<Location> locations) throws IOException;1542697754;Ensures that all locations in the given stream have been synced / written to the underlying storage._This method allows for internal optimization to minimize the amount of fsync operations if multiple_locations must be synced.__@return Returns <code>true</code> iff this call caused an actual sync operation otherwise <code>false</code>;public boolean ensureSynced(Stream<Location> locations) throws IOException {_        final Optional<Location> max = locations.max(Location::compareTo)__        _        _        if (max.isPresent()) {_            return ensureSynced(max.get())__        } else {_            return false__        }_    };ensures,that,all,locations,in,the,given,stream,have,been,synced,written,to,the,underlying,storage,this,method,allows,for,internal,optimization,to,minimize,the,amount,of,fsync,operations,if,multiple,locations,must,be,synced,return,returns,code,true,code,iff,this,call,caused,an,actual,sync,operation,otherwise,code,false,code;public,boolean,ensure,synced,stream,location,locations,throws,ioexception,final,optional,location,max,locations,max,location,compare,to,if,max,is,present,return,ensure,synced,max,get,else,return,false
Translog -> public boolean ensureSynced(Stream<Location> locations) throws IOException;1542962614;Ensures that all locations in the given stream have been synced / written to the underlying storage._This method allows for internal optimization to minimize the amount of fsync operations if multiple_locations must be synced.__@return Returns <code>true</code> iff this call caused an actual sync operation otherwise <code>false</code>;public boolean ensureSynced(Stream<Location> locations) throws IOException {_        final Optional<Location> max = locations.max(Location::compareTo)__        _        _        if (max.isPresent()) {_            return ensureSynced(max.get())__        } else {_            return false__        }_    };ensures,that,all,locations,in,the,given,stream,have,been,synced,written,to,the,underlying,storage,this,method,allows,for,internal,optimization,to,minimize,the,amount,of,fsync,operations,if,multiple,locations,must,be,synced,return,returns,code,true,code,iff,this,call,caused,an,actual,sync,operation,otherwise,code,false,code;public,boolean,ensure,synced,stream,location,locations,throws,ioexception,final,optional,location,max,locations,max,location,compare,to,if,max,is,present,return,ensure,synced,max,get,else,return,false
Translog -> public boolean ensureSynced(Stream<Location> locations) throws IOException;1545236365;Ensures that all locations in the given stream have been synced / written to the underlying storage._This method allows for internal optimization to minimize the amount of fsync operations if multiple_locations must be synced.__@return Returns <code>true</code> iff this call caused an actual sync operation otherwise <code>false</code>;public boolean ensureSynced(Stream<Location> locations) throws IOException {_        final Optional<Location> max = locations.max(Location::compareTo)__        _        _        if (max.isPresent()) {_            return ensureSynced(max.get())__        } else {_            return false__        }_    };ensures,that,all,locations,in,the,given,stream,have,been,synced,written,to,the,underlying,storage,this,method,allows,for,internal,optimization,to,minimize,the,amount,of,fsync,operations,if,multiple,locations,must,be,synced,return,returns,code,true,code,iff,this,call,caused,an,actual,sync,operation,otherwise,code,false,code;public,boolean,ensure,synced,stream,location,locations,throws,ioexception,final,optional,location,max,locations,max,location,compare,to,if,max,is,present,return,ensure,synced,max,get,else,return,false
Translog -> public long getMinFileGeneration();1524684173;Returns the minimum file generation referenced by the translog;public long getMinFileGeneration() {_        try (ReleasableLock ignored = readLock.acquire()) {_            if (readers.isEmpty()) {_                return current.getGeneration()__            } else {_                assert readers.stream().map(TranslogReader::getGeneration).min(Long::compareTo).get()_                    .equals(readers.get(0).getGeneration()) : "the first translog isn't the one with the minimum generation:" + readers__                return readers.get(0).getGeneration()__            }_        }_    };returns,the,minimum,file,generation,referenced,by,the,translog;public,long,get,min,file,generation,try,releasable,lock,ignored,read,lock,acquire,if,readers,is,empty,return,current,get,generation,else,assert,readers,stream,map,translog,reader,get,generation,min,long,compare,to,get,equals,readers,get,0,get,generation,the,first,translog,isn,t,the,one,with,the,minimum,generation,readers,return,readers,get,0,get,generation
Translog -> public long getMinFileGeneration();1525334055;Returns the minimum file generation referenced by the translog;public long getMinFileGeneration() {_        try (ReleasableLock ignored = readLock.acquire()) {_            if (readers.isEmpty()) {_                return current.getGeneration()__            } else {_                assert readers.stream().map(TranslogReader::getGeneration).min(Long::compareTo).get()_                    .equals(readers.get(0).getGeneration()) : "the first translog isn't the one with the minimum generation:" + readers__                return readers.get(0).getGeneration()__            }_        }_    };returns,the,minimum,file,generation,referenced,by,the,translog;public,long,get,min,file,generation,try,releasable,lock,ignored,read,lock,acquire,if,readers,is,empty,return,current,get,generation,else,assert,readers,stream,map,translog,reader,get,generation,min,long,compare,to,get,equals,readers,get,0,get,generation,the,first,translog,isn,t,the,one,with,the,minimum,generation,readers,return,readers,get,0,get,generation
Translog -> public long getMinFileGeneration();1528706846;Returns the minimum file generation referenced by the translog;public long getMinFileGeneration() {_        try (ReleasableLock ignored = readLock.acquire()) {_            if (readers.isEmpty()) {_                return current.getGeneration()__            } else {_                assert readers.stream().map(TranslogReader::getGeneration).min(Long::compareTo).get()_                    .equals(readers.get(0).getGeneration()) : "the first translog isn't the one with the minimum generation:" + readers__                return readers.get(0).getGeneration()__            }_        }_    };returns,the,minimum,file,generation,referenced,by,the,translog;public,long,get,min,file,generation,try,releasable,lock,ignored,read,lock,acquire,if,readers,is,empty,return,current,get,generation,else,assert,readers,stream,map,translog,reader,get,generation,min,long,compare,to,get,equals,readers,get,0,get,generation,the,first,translog,isn,t,the,one,with,the,minimum,generation,readers,return,readers,get,0,get,generation
Translog -> public long getMinFileGeneration();1531910483;Returns the minimum file generation referenced by the translog;public long getMinFileGeneration() {_        try (ReleasableLock ignored = readLock.acquire()) {_            if (readers.isEmpty()) {_                return current.getGeneration()__            } else {_                assert readers.stream().map(TranslogReader::getGeneration).min(Long::compareTo).get()_                    .equals(readers.get(0).getGeneration()) : "the first translog isn't the one with the minimum generation:" + readers__                return readers.get(0).getGeneration()__            }_        }_    };returns,the,minimum,file,generation,referenced,by,the,translog;public,long,get,min,file,generation,try,releasable,lock,ignored,read,lock,acquire,if,readers,is,empty,return,current,get,generation,else,assert,readers,stream,map,translog,reader,get,generation,min,long,compare,to,get,equals,readers,get,0,get,generation,the,first,translog,isn,t,the,one,with,the,minimum,generation,readers,return,readers,get,0,get,generation
Translog -> public long getMinFileGeneration();1533295538;Returns the minimum file generation referenced by the translog;public long getMinFileGeneration() {_        try (ReleasableLock ignored = readLock.acquire()) {_            if (readers.isEmpty()) {_                return current.getGeneration()__            } else {_                assert readers.stream().map(TranslogReader::getGeneration).min(Long::compareTo).get()_                    .equals(readers.get(0).getGeneration()) : "the first translog isn't the one with the minimum generation:" + readers__                return readers.get(0).getGeneration()__            }_        }_    };returns,the,minimum,file,generation,referenced,by,the,translog;public,long,get,min,file,generation,try,releasable,lock,ignored,read,lock,acquire,if,readers,is,empty,return,current,get,generation,else,assert,readers,stream,map,translog,reader,get,generation,min,long,compare,to,get,equals,readers,get,0,get,generation,the,first,translog,isn,t,the,one,with,the,minimum,generation,readers,return,readers,get,0,get,generation
Translog -> public long getMinFileGeneration();1533641732;Returns the minimum file generation referenced by the translog;public long getMinFileGeneration() {_        try (ReleasableLock ignored = readLock.acquire()) {_            if (readers.isEmpty()) {_                return current.getGeneration()__            } else {_                assert readers.stream().map(TranslogReader::getGeneration).min(Long::compareTo).get()_                    .equals(readers.get(0).getGeneration()) : "the first translog isn't the one with the minimum generation:" + readers__                return readers.get(0).getGeneration()__            }_        }_    };returns,the,minimum,file,generation,referenced,by,the,translog;public,long,get,min,file,generation,try,releasable,lock,ignored,read,lock,acquire,if,readers,is,empty,return,current,get,generation,else,assert,readers,stream,map,translog,reader,get,generation,min,long,compare,to,get,equals,readers,get,0,get,generation,the,first,translog,isn,t,the,one,with,the,minimum,generation,readers,return,readers,get,0,get,generation
Translog -> public long getMinFileGeneration();1534848846;Returns the minimum file generation referenced by the translog;public long getMinFileGeneration() {_        try (ReleasableLock ignored = readLock.acquire()) {_            if (readers.isEmpty()) {_                return current.getGeneration()__            } else {_                assert readers.stream().map(TranslogReader::getGeneration).min(Long::compareTo).get()_                    .equals(readers.get(0).getGeneration()) : "the first translog isn't the one with the minimum generation:" + readers__                return readers.get(0).getGeneration()__            }_        }_    };returns,the,minimum,file,generation,referenced,by,the,translog;public,long,get,min,file,generation,try,releasable,lock,ignored,read,lock,acquire,if,readers,is,empty,return,current,get,generation,else,assert,readers,stream,map,translog,reader,get,generation,min,long,compare,to,get,equals,readers,get,0,get,generation,the,first,translog,isn,t,the,one,with,the,minimum,generation,readers,return,readers,get,0,get,generation
Translog -> public long getMinFileGeneration();1535046779;Returns the minimum file generation referenced by the translog;public long getMinFileGeneration() {_        try (ReleasableLock ignored = readLock.acquire()) {_            if (readers.isEmpty()) {_                return current.getGeneration()__            } else {_                assert readers.stream().map(TranslogReader::getGeneration).min(Long::compareTo).get()_                    .equals(readers.get(0).getGeneration()) : "the first translog isn't the one with the minimum generation:" + readers__                return readers.get(0).getGeneration()__            }_        }_    };returns,the,minimum,file,generation,referenced,by,the,translog;public,long,get,min,file,generation,try,releasable,lock,ignored,read,lock,acquire,if,readers,is,empty,return,current,get,generation,else,assert,readers,stream,map,translog,reader,get,generation,min,long,compare,to,get,equals,readers,get,0,get,generation,the,first,translog,isn,t,the,one,with,the,minimum,generation,readers,return,readers,get,0,get,generation
Translog -> public long getMinFileGeneration();1535723122;Returns the minimum file generation referenced by the translog;public long getMinFileGeneration() {_        try (ReleasableLock ignored = readLock.acquire()) {_            if (readers.isEmpty()) {_                return current.getGeneration()__            } else {_                assert readers.stream().map(TranslogReader::getGeneration).min(Long::compareTo).get()_                    .equals(readers.get(0).getGeneration()) : "the first translog isn't the one with the minimum generation:" + readers__                return readers.get(0).getGeneration()__            }_        }_    };returns,the,minimum,file,generation,referenced,by,the,translog;public,long,get,min,file,generation,try,releasable,lock,ignored,read,lock,acquire,if,readers,is,empty,return,current,get,generation,else,assert,readers,stream,map,translog,reader,get,generation,min,long,compare,to,get,equals,readers,get,0,get,generation,the,first,translog,isn,t,the,one,with,the,minimum,generation,readers,return,readers,get,0,get,generation
Translog -> public long getMinFileGeneration();1537806831;Returns the minimum file generation referenced by the translog;public long getMinFileGeneration() {_        try (ReleasableLock ignored = readLock.acquire()) {_            if (readers.isEmpty()) {_                return current.getGeneration()__            } else {_                assert readers.stream().map(TranslogReader::getGeneration).min(Long::compareTo).get()_                    .equals(readers.get(0).getGeneration()) : "the first translog isn't the one with the minimum generation:" + readers__                return readers.get(0).getGeneration()__            }_        }_    };returns,the,minimum,file,generation,referenced,by,the,translog;public,long,get,min,file,generation,try,releasable,lock,ignored,read,lock,acquire,if,readers,is,empty,return,current,get,generation,else,assert,readers,stream,map,translog,reader,get,generation,min,long,compare,to,get,equals,readers,get,0,get,generation,the,first,translog,isn,t,the,one,with,the,minimum,generation,readers,return,readers,get,0,get,generation
Translog -> public long getMinFileGeneration();1541592065;Returns the minimum file generation referenced by the translog;public long getMinFileGeneration() {_        try (ReleasableLock ignored = readLock.acquire()) {_            if (readers.isEmpty()) {_                return current.getGeneration()__            } else {_                assert readers.stream().map(TranslogReader::getGeneration).min(Long::compareTo).get()_                    .equals(readers.get(0).getGeneration()) : "the first translog isn't the one with the minimum generation:" + readers__                return readers.get(0).getGeneration()__            }_        }_    };returns,the,minimum,file,generation,referenced,by,the,translog;public,long,get,min,file,generation,try,releasable,lock,ignored,read,lock,acquire,if,readers,is,empty,return,current,get,generation,else,assert,readers,stream,map,translog,reader,get,generation,min,long,compare,to,get,equals,readers,get,0,get,generation,the,first,translog,isn,t,the,one,with,the,minimum,generation,readers,return,readers,get,0,get,generation
Translog -> public long getMinFileGeneration();1542697754;Returns the minimum file generation referenced by the translog;public long getMinFileGeneration() {_        try (ReleasableLock ignored = readLock.acquire()) {_            if (readers.isEmpty()) {_                return current.getGeneration()__            } else {_                assert readers.stream().map(TranslogReader::getGeneration).min(Long::compareTo).get()_                    .equals(readers.get(0).getGeneration()) : "the first translog isn't the one with the minimum generation:" + readers__                return readers.get(0).getGeneration()__            }_        }_    };returns,the,minimum,file,generation,referenced,by,the,translog;public,long,get,min,file,generation,try,releasable,lock,ignored,read,lock,acquire,if,readers,is,empty,return,current,get,generation,else,assert,readers,stream,map,translog,reader,get,generation,min,long,compare,to,get,equals,readers,get,0,get,generation,the,first,translog,isn,t,the,one,with,the,minimum,generation,readers,return,readers,get,0,get,generation
Translog -> public long getMinFileGeneration();1542962614;Returns the minimum file generation referenced by the translog;public long getMinFileGeneration() {_        try (ReleasableLock ignored = readLock.acquire()) {_            if (readers.isEmpty()) {_                return current.getGeneration()__            } else {_                assert readers.stream().map(TranslogReader::getGeneration).min(Long::compareTo).get()_                    .equals(readers.get(0).getGeneration()) : "the first translog isn't the one with the minimum generation:" + readers__                return readers.get(0).getGeneration()__            }_        }_    };returns,the,minimum,file,generation,referenced,by,the,translog;public,long,get,min,file,generation,try,releasable,lock,ignored,read,lock,acquire,if,readers,is,empty,return,current,get,generation,else,assert,readers,stream,map,translog,reader,get,generation,min,long,compare,to,get,equals,readers,get,0,get,generation,the,first,translog,isn,t,the,one,with,the,minimum,generation,readers,return,readers,get,0,get,generation
Translog -> public long getMinFileGeneration();1545236365;Returns the minimum file generation referenced by the translog;public long getMinFileGeneration() {_        try (ReleasableLock ignored = readLock.acquire()) {_            if (readers.isEmpty()) {_                return current.getGeneration()__            } else {_                assert readers.stream().map(TranslogReader::getGeneration).min(Long::compareTo).get()_                    .equals(readers.get(0).getGeneration()) : "the first translog isn't the one with the minimum generation:" + readers__                return readers.get(0).getGeneration()__            }_        }_    };returns,the,minimum,file,generation,referenced,by,the,translog;public,long,get,min,file,generation,try,releasable,lock,ignored,read,lock,acquire,if,readers,is,empty,return,current,get,generation,else,assert,readers,stream,map,translog,reader,get,generation,min,long,compare,to,get,equals,readers,get,0,get,generation,the,first,translog,isn,t,the,one,with,the,minimum,generation,readers,return,readers,get,0,get,generation
Translog -> Snapshot -> int totalOperations()_;1524684173;The total estimated number of operations in the snapshot.;int totalOperations()_;the,total,estimated,number,of,operations,in,the,snapshot;int,total,operations
Translog -> Snapshot -> int totalOperations()_;1525334055;The total estimated number of operations in the snapshot.;int totalOperations()_;the,total,estimated,number,of,operations,in,the,snapshot;int,total,operations
Translog -> Snapshot -> int totalOperations()_;1528706846;The total estimated number of operations in the snapshot.;int totalOperations()_;the,total,estimated,number,of,operations,in,the,snapshot;int,total,operations
Translog -> Snapshot -> int totalOperations()_;1531910483;The total estimated number of operations in the snapshot.;int totalOperations()_;the,total,estimated,number,of,operations,in,the,snapshot;int,total,operations
Translog -> Snapshot -> int totalOperations()_;1533295538;The total estimated number of operations in the snapshot.;int totalOperations()_;the,total,estimated,number,of,operations,in,the,snapshot;int,total,operations
Translog -> Snapshot -> int totalOperations()_;1533641732;The total estimated number of operations in the snapshot.;int totalOperations()_;the,total,estimated,number,of,operations,in,the,snapshot;int,total,operations
Translog -> Snapshot -> int totalOperations()_;1534848846;The total estimated number of operations in the snapshot.;int totalOperations()_;the,total,estimated,number,of,operations,in,the,snapshot;int,total,operations
Translog -> Snapshot -> int totalOperations()_;1535046779;The total estimated number of operations in the snapshot.;int totalOperations()_;the,total,estimated,number,of,operations,in,the,snapshot;int,total,operations
Translog -> Snapshot -> int totalOperations()_;1535723122;The total estimated number of operations in the snapshot.;int totalOperations()_;the,total,estimated,number,of,operations,in,the,snapshot;int,total,operations
Translog -> Snapshot -> int totalOperations()_;1537806831;The total estimated number of operations in the snapshot.;int totalOperations()_;the,total,estimated,number,of,operations,in,the,snapshot;int,total,operations
Translog -> Snapshot -> int totalOperations()_;1541592065;The total estimated number of operations in the snapshot.;int totalOperations()_;the,total,estimated,number,of,operations,in,the,snapshot;int,total,operations
Translog -> Snapshot -> int totalOperations()_;1542697754;The total estimated number of operations in the snapshot.;int totalOperations()_;the,total,estimated,number,of,operations,in,the,snapshot;int,total,operations
Translog -> Snapshot -> int totalOperations()_;1542962614;The total estimated number of operations in the snapshot.;int totalOperations()_;the,total,estimated,number,of,operations,in,the,snapshot;int,total,operations
Translog -> Snapshot -> int totalOperations()_;1545236365;The total estimated number of operations in the snapshot.;int totalOperations()_;the,total,estimated,number,of,operations,in,the,snapshot;int,total,operations
Translog -> public long sizeInBytes();1524684173;Returns the size in bytes of the v files;public long sizeInBytes() {_        return sizeInBytesByMinGen(-1)__    };returns,the,size,in,bytes,of,the,v,files;public,long,size,in,bytes,return,size,in,bytes,by,min,gen,1
Translog -> public long sizeInBytes();1525334055;Returns the size in bytes of the v files;public long sizeInBytes() {_        return sizeInBytesByMinGen(-1)__    };returns,the,size,in,bytes,of,the,v,files;public,long,size,in,bytes,return,size,in,bytes,by,min,gen,1
Translog -> public long sizeInBytes();1528706846;Returns the size in bytes of the v files;public long sizeInBytes() {_        return sizeInBytesByMinGen(-1)__    };returns,the,size,in,bytes,of,the,v,files;public,long,size,in,bytes,return,size,in,bytes,by,min,gen,1
Translog -> public long sizeInBytes();1531910483;Returns the size in bytes of the v files;public long sizeInBytes() {_        return sizeInBytesByMinGen(-1)__    };returns,the,size,in,bytes,of,the,v,files;public,long,size,in,bytes,return,size,in,bytes,by,min,gen,1
Translog -> public long sizeInBytes();1533295538;Returns the size in bytes of the v files;public long sizeInBytes() {_        return sizeInBytesByMinGen(-1)__    };returns,the,size,in,bytes,of,the,v,files;public,long,size,in,bytes,return,size,in,bytes,by,min,gen,1
Translog -> public long sizeInBytes();1533641732;Returns the size in bytes of the v files;public long sizeInBytes() {_        return sizeInBytesByMinGen(-1)__    };returns,the,size,in,bytes,of,the,v,files;public,long,size,in,bytes,return,size,in,bytes,by,min,gen,1
Translog -> public long sizeInBytes();1534848846;Returns the size in bytes of the v files;public long sizeInBytes() {_        return sizeInBytesByMinGen(-1)__    };returns,the,size,in,bytes,of,the,v,files;public,long,size,in,bytes,return,size,in,bytes,by,min,gen,1
Translog -> public long sizeInBytes();1535046779;Returns the size in bytes of the v files;public long sizeInBytes() {_        return sizeInBytesByMinGen(-1)__    };returns,the,size,in,bytes,of,the,v,files;public,long,size,in,bytes,return,size,in,bytes,by,min,gen,1
Translog -> public long sizeInBytes();1535723122;Returns the size in bytes of the v files;public long sizeInBytes() {_        return sizeInBytesByMinGen(-1)__    };returns,the,size,in,bytes,of,the,v,files;public,long,size,in,bytes,return,size,in,bytes,by,min,gen,1
Translog -> public long sizeInBytes();1537806831;Returns the size in bytes of the v files;public long sizeInBytes() {_        return sizeInBytesByMinGen(-1)__    };returns,the,size,in,bytes,of,the,v,files;public,long,size,in,bytes,return,size,in,bytes,by,min,gen,1
Translog -> public long sizeInBytes();1541592065;Returns the size in bytes of the v files;public long sizeInBytes() {_        return sizeInBytesByMinGen(-1)__    };returns,the,size,in,bytes,of,the,v,files;public,long,size,in,bytes,return,size,in,bytes,by,min,gen,1
Translog -> public long sizeInBytes();1542697754;Returns the size in bytes of the v files;public long sizeInBytes() {_        return sizeInBytesByMinGen(-1)__    };returns,the,size,in,bytes,of,the,v,files;public,long,size,in,bytes,return,size,in,bytes,by,min,gen,1
Translog -> public long sizeInBytes();1542962614;Returns the size in bytes of the v files;public long sizeInBytes() {_        return sizeInBytesByMinGen(-1)__    };returns,the,size,in,bytes,of,the,v,files;public,long,size,in,bytes,return,size,in,bytes,by,min,gen,1
Translog -> public long sizeInBytes();1545236365;Returns the size in bytes of the v files;public long sizeInBytes() {_        return sizeInBytesByMinGen(-1)__    };returns,the,size,in,bytes,of,the,v,files;public,long,size,in,bytes,return,size,in,bytes,by,min,gen,1
Translog -> static Checkpoint readCheckpoint(final Path location) throws IOException;1524684173;Reads and returns the current checkpoint;static Checkpoint readCheckpoint(final Path location) throws IOException {_        return Checkpoint.read(location.resolve(CHECKPOINT_FILE_NAME))__    };reads,and,returns,the,current,checkpoint;static,checkpoint,read,checkpoint,final,path,location,throws,ioexception,return,checkpoint,read,location,resolve
Translog -> static Checkpoint readCheckpoint(final Path location) throws IOException;1525334055;Reads and returns the current checkpoint;static Checkpoint readCheckpoint(final Path location) throws IOException {_        return Checkpoint.read(location.resolve(CHECKPOINT_FILE_NAME))__    };reads,and,returns,the,current,checkpoint;static,checkpoint,read,checkpoint,final,path,location,throws,ioexception,return,checkpoint,read,location,resolve
Translog -> static Checkpoint readCheckpoint(final Path location) throws IOException;1528706846;Reads and returns the current checkpoint;static Checkpoint readCheckpoint(final Path location) throws IOException {_        return Checkpoint.read(location.resolve(CHECKPOINT_FILE_NAME))__    };reads,and,returns,the,current,checkpoint;static,checkpoint,read,checkpoint,final,path,location,throws,ioexception,return,checkpoint,read,location,resolve
Translog -> static Checkpoint readCheckpoint(final Path location) throws IOException;1531910483;Reads and returns the current checkpoint;static Checkpoint readCheckpoint(final Path location) throws IOException {_        return Checkpoint.read(location.resolve(CHECKPOINT_FILE_NAME))__    };reads,and,returns,the,current,checkpoint;static,checkpoint,read,checkpoint,final,path,location,throws,ioexception,return,checkpoint,read,location,resolve
Translog -> static Checkpoint readCheckpoint(final Path location) throws IOException;1533295538;Reads and returns the current checkpoint;static Checkpoint readCheckpoint(final Path location) throws IOException {_        return Checkpoint.read(location.resolve(CHECKPOINT_FILE_NAME))__    };reads,and,returns,the,current,checkpoint;static,checkpoint,read,checkpoint,final,path,location,throws,ioexception,return,checkpoint,read,location,resolve
Translog -> static Checkpoint readCheckpoint(final Path location) throws IOException;1533641732;Reads and returns the current checkpoint;static Checkpoint readCheckpoint(final Path location) throws IOException {_        return Checkpoint.read(location.resolve(CHECKPOINT_FILE_NAME))__    };reads,and,returns,the,current,checkpoint;static,checkpoint,read,checkpoint,final,path,location,throws,ioexception,return,checkpoint,read,location,resolve
Translog -> static Checkpoint readCheckpoint(final Path location) throws IOException;1534848846;Reads and returns the current checkpoint;static Checkpoint readCheckpoint(final Path location) throws IOException {_        return Checkpoint.read(location.resolve(CHECKPOINT_FILE_NAME))__    };reads,and,returns,the,current,checkpoint;static,checkpoint,read,checkpoint,final,path,location,throws,ioexception,return,checkpoint,read,location,resolve
Translog -> static Checkpoint readCheckpoint(final Path location) throws IOException;1535046779;Reads and returns the current checkpoint;static Checkpoint readCheckpoint(final Path location) throws IOException {_        return Checkpoint.read(location.resolve(CHECKPOINT_FILE_NAME))__    };reads,and,returns,the,current,checkpoint;static,checkpoint,read,checkpoint,final,path,location,throws,ioexception,return,checkpoint,read,location,resolve
Translog -> static Checkpoint readCheckpoint(final Path location) throws IOException;1535723122;Reads and returns the current checkpoint;static Checkpoint readCheckpoint(final Path location) throws IOException {_        return Checkpoint.read(location.resolve(CHECKPOINT_FILE_NAME))__    };reads,and,returns,the,current,checkpoint;static,checkpoint,read,checkpoint,final,path,location,throws,ioexception,return,checkpoint,read,location,resolve
Translog -> static Checkpoint readCheckpoint(final Path location) throws IOException;1537806831;Reads and returns the current checkpoint;static Checkpoint readCheckpoint(final Path location) throws IOException {_        return Checkpoint.read(location.resolve(CHECKPOINT_FILE_NAME))__    };reads,and,returns,the,current,checkpoint;static,checkpoint,read,checkpoint,final,path,location,throws,ioexception,return,checkpoint,read,location,resolve
Translog -> static Checkpoint readCheckpoint(final Path location) throws IOException;1541592065;Reads and returns the current checkpoint;static Checkpoint readCheckpoint(final Path location) throws IOException {_        return Checkpoint.read(location.resolve(CHECKPOINT_FILE_NAME))__    };reads,and,returns,the,current,checkpoint;static,checkpoint,read,checkpoint,final,path,location,throws,ioexception,return,checkpoint,read,location,resolve
Translog -> static Checkpoint readCheckpoint(final Path location) throws IOException;1542697754;Reads and returns the current checkpoint;static Checkpoint readCheckpoint(final Path location) throws IOException {_        return Checkpoint.read(location.resolve(CHECKPOINT_FILE_NAME))__    };reads,and,returns,the,current,checkpoint;static,checkpoint,read,checkpoint,final,path,location,throws,ioexception,return,checkpoint,read,location,resolve
Translog -> static Checkpoint readCheckpoint(final Path location) throws IOException;1542962614;Reads and returns the current checkpoint;static Checkpoint readCheckpoint(final Path location) throws IOException {_        return Checkpoint.read(location.resolve(CHECKPOINT_FILE_NAME))__    };reads,and,returns,the,current,checkpoint;static,checkpoint,read,checkpoint,final,path,location,throws,ioexception,return,checkpoint,read,location,resolve
Translog -> static Checkpoint readCheckpoint(final Path location) throws IOException;1545236365;Reads and returns the current checkpoint;static Checkpoint readCheckpoint(final Path location) throws IOException {_        return Checkpoint.read(location.resolve(CHECKPOINT_FILE_NAME))__    };reads,and,returns,the,current,checkpoint;static,checkpoint,read,checkpoint,final,path,location,throws,ioexception,return,checkpoint,read,location,resolve
Translog -> Operation -> static void writeOperation(final StreamOutput output, final Operation operation) throws IOException;1524684173;Writes the type and translog operation to the given stream;static void writeOperation(final StreamOutput output, final Operation operation) throws IOException {_            output.writeByte(operation.opType().id())__            switch(operation.opType()) {_                case CREATE:_                    _                case INDEX:_                    ((Index) operation).write(output)__                    break__                case DELETE:_                    ((Delete) operation).write(output)__                    break__                case NO_OP:_                    ((NoOp) operation).write(output)__                    break__                default:_                    throw new AssertionError("no case for [" + operation.opType() + "]")__            }_        };writes,the,type,and,translog,operation,to,the,given,stream;static,void,write,operation,final,stream,output,output,final,operation,operation,throws,ioexception,output,write,byte,operation,op,type,id,switch,operation,op,type,case,create,case,index,index,operation,write,output,break,case,delete,delete,operation,write,output,break,case,no,op,operation,write,output,break,default,throw,new,assertion,error,no,case,for,operation,op,type
Translog -> Operation -> static void writeOperation(final StreamOutput output, final Operation operation) throws IOException;1525334055;Writes the type and translog operation to the given stream;static void writeOperation(final StreamOutput output, final Operation operation) throws IOException {_            output.writeByte(operation.opType().id())__            switch(operation.opType()) {_                case CREATE:_                    _                case INDEX:_                    ((Index) operation).write(output)__                    break__                case DELETE:_                    ((Delete) operation).write(output)__                    break__                case NO_OP:_                    ((NoOp) operation).write(output)__                    break__                default:_                    throw new AssertionError("no case for [" + operation.opType() + "]")__            }_        };writes,the,type,and,translog,operation,to,the,given,stream;static,void,write,operation,final,stream,output,output,final,operation,operation,throws,ioexception,output,write,byte,operation,op,type,id,switch,operation,op,type,case,create,case,index,index,operation,write,output,break,case,delete,delete,operation,write,output,break,case,no,op,operation,write,output,break,default,throw,new,assertion,error,no,case,for,operation,op,type
Translog -> Operation -> static void writeOperation(final StreamOutput output, final Operation operation) throws IOException;1528706846;Writes the type and translog operation to the given stream;static void writeOperation(final StreamOutput output, final Operation operation) throws IOException {_            output.writeByte(operation.opType().id())__            switch(operation.opType()) {_                case CREATE:_                    _                case INDEX:_                    ((Index) operation).write(output)__                    break__                case DELETE:_                    ((Delete) operation).write(output)__                    break__                case NO_OP:_                    ((NoOp) operation).write(output)__                    break__                default:_                    throw new AssertionError("no case for [" + operation.opType() + "]")__            }_        };writes,the,type,and,translog,operation,to,the,given,stream;static,void,write,operation,final,stream,output,output,final,operation,operation,throws,ioexception,output,write,byte,operation,op,type,id,switch,operation,op,type,case,create,case,index,index,operation,write,output,break,case,delete,delete,operation,write,output,break,case,no,op,operation,write,output,break,default,throw,new,assertion,error,no,case,for,operation,op,type
Translog -> Operation -> static void writeOperation(final StreamOutput output, final Operation operation) throws IOException;1531910483;Writes the type and translog operation to the given stream;static void writeOperation(final StreamOutput output, final Operation operation) throws IOException {_            output.writeByte(operation.opType().id())__            switch(operation.opType()) {_                case CREATE:_                    _                case INDEX:_                    ((Index) operation).write(output)__                    break__                case DELETE:_                    ((Delete) operation).write(output)__                    break__                case NO_OP:_                    ((NoOp) operation).write(output)__                    break__                default:_                    throw new AssertionError("no case for [" + operation.opType() + "]")__            }_        };writes,the,type,and,translog,operation,to,the,given,stream;static,void,write,operation,final,stream,output,output,final,operation,operation,throws,ioexception,output,write,byte,operation,op,type,id,switch,operation,op,type,case,create,case,index,index,operation,write,output,break,case,delete,delete,operation,write,output,break,case,no,op,operation,write,output,break,default,throw,new,assertion,error,no,case,for,operation,op,type
Translog -> Operation -> static void writeOperation(final StreamOutput output, final Operation operation) throws IOException;1533295538;Writes the type and translog operation to the given stream;static void writeOperation(final StreamOutput output, final Operation operation) throws IOException {_            output.writeByte(operation.opType().id())__            switch(operation.opType()) {_                case CREATE:_                    _                case INDEX:_                    ((Index) operation).write(output)__                    break__                case DELETE:_                    ((Delete) operation).write(output)__                    break__                case NO_OP:_                    ((NoOp) operation).write(output)__                    break__                default:_                    throw new AssertionError("no case for [" + operation.opType() + "]")__            }_        };writes,the,type,and,translog,operation,to,the,given,stream;static,void,write,operation,final,stream,output,output,final,operation,operation,throws,ioexception,output,write,byte,operation,op,type,id,switch,operation,op,type,case,create,case,index,index,operation,write,output,break,case,delete,delete,operation,write,output,break,case,no,op,operation,write,output,break,default,throw,new,assertion,error,no,case,for,operation,op,type
Translog -> Operation -> static void writeOperation(final StreamOutput output, final Operation operation) throws IOException;1533641732;Writes the type and translog operation to the given stream;static void writeOperation(final StreamOutput output, final Operation operation) throws IOException {_            output.writeByte(operation.opType().id())__            switch(operation.opType()) {_                case CREATE:_                    _                case INDEX:_                    ((Index) operation).write(output)__                    break__                case DELETE:_                    ((Delete) operation).write(output)__                    break__                case NO_OP:_                    ((NoOp) operation).write(output)__                    break__                default:_                    throw new AssertionError("no case for [" + operation.opType() + "]")__            }_        };writes,the,type,and,translog,operation,to,the,given,stream;static,void,write,operation,final,stream,output,output,final,operation,operation,throws,ioexception,output,write,byte,operation,op,type,id,switch,operation,op,type,case,create,case,index,index,operation,write,output,break,case,delete,delete,operation,write,output,break,case,no,op,operation,write,output,break,default,throw,new,assertion,error,no,case,for,operation,op,type
Translog -> Operation -> static void writeOperation(final StreamOutput output, final Operation operation) throws IOException;1534848846;Writes the type and translog operation to the given stream;static void writeOperation(final StreamOutput output, final Operation operation) throws IOException {_            output.writeByte(operation.opType().id())__            switch(operation.opType()) {_                case CREATE:_                    _                case INDEX:_                    ((Index) operation).write(output)__                    break__                case DELETE:_                    ((Delete) operation).write(output)__                    break__                case NO_OP:_                    ((NoOp) operation).write(output)__                    break__                default:_                    throw new AssertionError("no case for [" + operation.opType() + "]")__            }_        };writes,the,type,and,translog,operation,to,the,given,stream;static,void,write,operation,final,stream,output,output,final,operation,operation,throws,ioexception,output,write,byte,operation,op,type,id,switch,operation,op,type,case,create,case,index,index,operation,write,output,break,case,delete,delete,operation,write,output,break,case,no,op,operation,write,output,break,default,throw,new,assertion,error,no,case,for,operation,op,type
Translog -> Operation -> static void writeOperation(final StreamOutput output, final Operation operation) throws IOException;1535046779;Writes the type and translog operation to the given stream;static void writeOperation(final StreamOutput output, final Operation operation) throws IOException {_            output.writeByte(operation.opType().id())__            switch(operation.opType()) {_                case CREATE:_                    _                case INDEX:_                    ((Index) operation).write(output)__                    break__                case DELETE:_                    ((Delete) operation).write(output)__                    break__                case NO_OP:_                    ((NoOp) operation).write(output)__                    break__                default:_                    throw new AssertionError("no case for [" + operation.opType() + "]")__            }_        };writes,the,type,and,translog,operation,to,the,given,stream;static,void,write,operation,final,stream,output,output,final,operation,operation,throws,ioexception,output,write,byte,operation,op,type,id,switch,operation,op,type,case,create,case,index,index,operation,write,output,break,case,delete,delete,operation,write,output,break,case,no,op,operation,write,output,break,default,throw,new,assertion,error,no,case,for,operation,op,type
Translog -> Operation -> static void writeOperation(final StreamOutput output, final Operation operation) throws IOException;1535723122;Writes the type and translog operation to the given stream;static void writeOperation(final StreamOutput output, final Operation operation) throws IOException {_            output.writeByte(operation.opType().id())__            switch(operation.opType()) {_                case CREATE:_                    _                case INDEX:_                    ((Index) operation).write(output)__                    break__                case DELETE:_                    ((Delete) operation).write(output)__                    break__                case NO_OP:_                    ((NoOp) operation).write(output)__                    break__                default:_                    throw new AssertionError("no case for [" + operation.opType() + "]")__            }_        };writes,the,type,and,translog,operation,to,the,given,stream;static,void,write,operation,final,stream,output,output,final,operation,operation,throws,ioexception,output,write,byte,operation,op,type,id,switch,operation,op,type,case,create,case,index,index,operation,write,output,break,case,delete,delete,operation,write,output,break,case,no,op,operation,write,output,break,default,throw,new,assertion,error,no,case,for,operation,op,type
Translog -> Operation -> static void writeOperation(final StreamOutput output, final Operation operation) throws IOException;1537806831;Writes the type and translog operation to the given stream;static void writeOperation(final StreamOutput output, final Operation operation) throws IOException {_            output.writeByte(operation.opType().id())__            switch(operation.opType()) {_                case CREATE:_                    _                case INDEX:_                    ((Index) operation).write(output)__                    break__                case DELETE:_                    ((Delete) operation).write(output)__                    break__                case NO_OP:_                    ((NoOp) operation).write(output)__                    break__                default:_                    throw new AssertionError("no case for [" + operation.opType() + "]")__            }_        };writes,the,type,and,translog,operation,to,the,given,stream;static,void,write,operation,final,stream,output,output,final,operation,operation,throws,ioexception,output,write,byte,operation,op,type,id,switch,operation,op,type,case,create,case,index,index,operation,write,output,break,case,delete,delete,operation,write,output,break,case,no,op,operation,write,output,break,default,throw,new,assertion,error,no,case,for,operation,op,type
Translog -> Operation -> static void writeOperation(final StreamOutput output, final Operation operation) throws IOException;1541592065;Writes the type and translog operation to the given stream;static void writeOperation(final StreamOutput output, final Operation operation) throws IOException {_            output.writeByte(operation.opType().id())__            switch(operation.opType()) {_                case CREATE:_                    _                case INDEX:_                    ((Index) operation).write(output)__                    break__                case DELETE:_                    ((Delete) operation).write(output)__                    break__                case NO_OP:_                    ((NoOp) operation).write(output)__                    break__                default:_                    throw new AssertionError("no case for [" + operation.opType() + "]")__            }_        };writes,the,type,and,translog,operation,to,the,given,stream;static,void,write,operation,final,stream,output,output,final,operation,operation,throws,ioexception,output,write,byte,operation,op,type,id,switch,operation,op,type,case,create,case,index,index,operation,write,output,break,case,delete,delete,operation,write,output,break,case,no,op,operation,write,output,break,default,throw,new,assertion,error,no,case,for,operation,op,type
Translog -> Operation -> static void writeOperation(final StreamOutput output, final Operation operation) throws IOException;1542697754;Writes the type and translog operation to the given stream;static void writeOperation(final StreamOutput output, final Operation operation) throws IOException {_            output.writeByte(operation.opType().id())__            switch(operation.opType()) {_                case CREATE:_                    _                case INDEX:_                    ((Index) operation).write(output)__                    break__                case DELETE:_                    ((Delete) operation).write(output)__                    break__                case NO_OP:_                    ((NoOp) operation).write(output)__                    break__                default:_                    throw new AssertionError("no case for [" + operation.opType() + "]")__            }_        };writes,the,type,and,translog,operation,to,the,given,stream;static,void,write,operation,final,stream,output,output,final,operation,operation,throws,ioexception,output,write,byte,operation,op,type,id,switch,operation,op,type,case,create,case,index,index,operation,write,output,break,case,delete,delete,operation,write,output,break,case,no,op,operation,write,output,break,default,throw,new,assertion,error,no,case,for,operation,op,type
Translog -> Operation -> static void writeOperation(final StreamOutput output, final Operation operation) throws IOException;1542962614;Writes the type and translog operation to the given stream;static void writeOperation(final StreamOutput output, final Operation operation) throws IOException {_            output.writeByte(operation.opType().id())__            switch(operation.opType()) {_                case CREATE:_                    _                case INDEX:_                    ((Index) operation).write(output)__                    break__                case DELETE:_                    ((Delete) operation).write(output)__                    break__                case NO_OP:_                    ((NoOp) operation).write(output)__                    break__                default:_                    throw new AssertionError("no case for [" + operation.opType() + "]")__            }_        };writes,the,type,and,translog,operation,to,the,given,stream;static,void,write,operation,final,stream,output,output,final,operation,operation,throws,ioexception,output,write,byte,operation,op,type,id,switch,operation,op,type,case,create,case,index,index,operation,write,output,break,case,delete,delete,operation,write,output,break,case,no,op,operation,write,output,break,default,throw,new,assertion,error,no,case,for,operation,op,type
Translog -> Operation -> static void writeOperation(final StreamOutput output, final Operation operation) throws IOException;1545236365;Writes the type and translog operation to the given stream;static void writeOperation(final StreamOutput output, final Operation operation) throws IOException {_            output.writeByte(operation.opType().id())__            switch(operation.opType()) {_                case CREATE:_                    _                case INDEX:_                    ((Index) operation).write(output)__                    break__                case DELETE:_                    ((Delete) operation).write(output)__                    break__                case NO_OP:_                    ((NoOp) operation).write(output)__                    break__                default:_                    throw new AssertionError("no case for [" + operation.opType() + "]")__            }_        };writes,the,type,and,translog,operation,to,the,given,stream;static,void,write,operation,final,stream,output,output,final,operation,operation,throws,ioexception,output,write,byte,operation,op,type,id,switch,operation,op,type,case,create,case,index,index,operation,write,output,break,case,delete,delete,operation,write,output,break,case,no,op,operation,write,output,break,default,throw,new,assertion,error,no,case,for,operation,op,type
Translog -> void deleteReaderFiles(TranslogReader reader);1524684173;deletes all files associated with a reader. package-private to be able to simulate node failures at this point;void deleteReaderFiles(TranslogReader reader) {_        IOUtils.deleteFilesIgnoringExceptions(reader.path(),_            reader.path().resolveSibling(getCommitCheckpointFileName(reader.getGeneration())))__    };deletes,all,files,associated,with,a,reader,package,private,to,be,able,to,simulate,node,failures,at,this,point;void,delete,reader,files,translog,reader,reader,ioutils,delete,files,ignoring,exceptions,reader,path,reader,path,resolve,sibling,get,commit,checkpoint,file,name,reader,get,generation
Translog -> void deleteReaderFiles(TranslogReader reader);1525334055;deletes all files associated with a reader. package-private to be able to simulate node failures at this point;void deleteReaderFiles(TranslogReader reader) {_        IOUtils.deleteFilesIgnoringExceptions(reader.path(),_            reader.path().resolveSibling(getCommitCheckpointFileName(reader.getGeneration())))__    };deletes,all,files,associated,with,a,reader,package,private,to,be,able,to,simulate,node,failures,at,this,point;void,delete,reader,files,translog,reader,reader,ioutils,delete,files,ignoring,exceptions,reader,path,reader,path,resolve,sibling,get,commit,checkpoint,file,name,reader,get,generation
Translog -> void deleteReaderFiles(TranslogReader reader);1528706846;deletes all files associated with a reader. package-private to be able to simulate node failures at this point;void deleteReaderFiles(TranslogReader reader) {_        IOUtils.deleteFilesIgnoringExceptions(reader.path(),_            reader.path().resolveSibling(getCommitCheckpointFileName(reader.getGeneration())))__    };deletes,all,files,associated,with,a,reader,package,private,to,be,able,to,simulate,node,failures,at,this,point;void,delete,reader,files,translog,reader,reader,ioutils,delete,files,ignoring,exceptions,reader,path,reader,path,resolve,sibling,get,commit,checkpoint,file,name,reader,get,generation
Translog -> void deleteReaderFiles(TranslogReader reader);1531910483;deletes all files associated with a reader. package-private to be able to simulate node failures at this point;void deleteReaderFiles(TranslogReader reader) {_        IOUtils.deleteFilesIgnoringExceptions(reader.path(),_            reader.path().resolveSibling(getCommitCheckpointFileName(reader.getGeneration())))__    };deletes,all,files,associated,with,a,reader,package,private,to,be,able,to,simulate,node,failures,at,this,point;void,delete,reader,files,translog,reader,reader,ioutils,delete,files,ignoring,exceptions,reader,path,reader,path,resolve,sibling,get,commit,checkpoint,file,name,reader,get,generation
Translog -> void deleteReaderFiles(TranslogReader reader);1533295538;deletes all files associated with a reader. package-private to be able to simulate node failures at this point;void deleteReaderFiles(TranslogReader reader) {_        IOUtils.deleteFilesIgnoringExceptions(reader.path(),_            reader.path().resolveSibling(getCommitCheckpointFileName(reader.getGeneration())))__    };deletes,all,files,associated,with,a,reader,package,private,to,be,able,to,simulate,node,failures,at,this,point;void,delete,reader,files,translog,reader,reader,ioutils,delete,files,ignoring,exceptions,reader,path,reader,path,resolve,sibling,get,commit,checkpoint,file,name,reader,get,generation
Translog -> void deleteReaderFiles(TranslogReader reader);1533641732;deletes all files associated with a reader. package-private to be able to simulate node failures at this point;void deleteReaderFiles(TranslogReader reader) {_        IOUtils.deleteFilesIgnoringExceptions(reader.path(),_            reader.path().resolveSibling(getCommitCheckpointFileName(reader.getGeneration())))__    };deletes,all,files,associated,with,a,reader,package,private,to,be,able,to,simulate,node,failures,at,this,point;void,delete,reader,files,translog,reader,reader,ioutils,delete,files,ignoring,exceptions,reader,path,reader,path,resolve,sibling,get,commit,checkpoint,file,name,reader,get,generation
Translog -> void deleteReaderFiles(TranslogReader reader);1534848846;deletes all files associated with a reader. package-private to be able to simulate node failures at this point;void deleteReaderFiles(TranslogReader reader) {_        IOUtils.deleteFilesIgnoringExceptions(reader.path(),_            reader.path().resolveSibling(getCommitCheckpointFileName(reader.getGeneration())))__    };deletes,all,files,associated,with,a,reader,package,private,to,be,able,to,simulate,node,failures,at,this,point;void,delete,reader,files,translog,reader,reader,ioutils,delete,files,ignoring,exceptions,reader,path,reader,path,resolve,sibling,get,commit,checkpoint,file,name,reader,get,generation
Translog -> void deleteReaderFiles(TranslogReader reader);1535046779;deletes all files associated with a reader. package-private to be able to simulate node failures at this point;void deleteReaderFiles(TranslogReader reader) {_        IOUtils.deleteFilesIgnoringExceptions(reader.path(),_            reader.path().resolveSibling(getCommitCheckpointFileName(reader.getGeneration())))__    };deletes,all,files,associated,with,a,reader,package,private,to,be,able,to,simulate,node,failures,at,this,point;void,delete,reader,files,translog,reader,reader,ioutils,delete,files,ignoring,exceptions,reader,path,reader,path,resolve,sibling,get,commit,checkpoint,file,name,reader,get,generation
Translog -> void deleteReaderFiles(TranslogReader reader);1535723122;deletes all files associated with a reader. package-private to be able to simulate node failures at this point;void deleteReaderFiles(TranslogReader reader) {_        IOUtils.deleteFilesIgnoringExceptions(reader.path(),_            reader.path().resolveSibling(getCommitCheckpointFileName(reader.getGeneration())))__    };deletes,all,files,associated,with,a,reader,package,private,to,be,able,to,simulate,node,failures,at,this,point;void,delete,reader,files,translog,reader,reader,ioutils,delete,files,ignoring,exceptions,reader,path,reader,path,resolve,sibling,get,commit,checkpoint,file,name,reader,get,generation
Translog -> void deleteReaderFiles(TranslogReader reader);1537806831;deletes all files associated with a reader. package-private to be able to simulate node failures at this point;void deleteReaderFiles(TranslogReader reader) {_        IOUtils.deleteFilesIgnoringExceptions(reader.path(),_            reader.path().resolveSibling(getCommitCheckpointFileName(reader.getGeneration())))__    };deletes,all,files,associated,with,a,reader,package,private,to,be,able,to,simulate,node,failures,at,this,point;void,delete,reader,files,translog,reader,reader,ioutils,delete,files,ignoring,exceptions,reader,path,reader,path,resolve,sibling,get,commit,checkpoint,file,name,reader,get,generation
Translog -> void deleteReaderFiles(TranslogReader reader);1541592065;deletes all files associated with a reader. package-private to be able to simulate node failures at this point;void deleteReaderFiles(TranslogReader reader) {_        IOUtils.deleteFilesIgnoringExceptions(reader.path(),_            reader.path().resolveSibling(getCommitCheckpointFileName(reader.getGeneration())))__    };deletes,all,files,associated,with,a,reader,package,private,to,be,able,to,simulate,node,failures,at,this,point;void,delete,reader,files,translog,reader,reader,ioutils,delete,files,ignoring,exceptions,reader,path,reader,path,resolve,sibling,get,commit,checkpoint,file,name,reader,get,generation
Translog -> void deleteReaderFiles(TranslogReader reader);1542697754;deletes all files associated with a reader. package-private to be able to simulate node failures at this point;void deleteReaderFiles(TranslogReader reader) {_        IOUtils.deleteFilesIgnoringExceptions(reader.path(),_            reader.path().resolveSibling(getCommitCheckpointFileName(reader.getGeneration())))__    };deletes,all,files,associated,with,a,reader,package,private,to,be,able,to,simulate,node,failures,at,this,point;void,delete,reader,files,translog,reader,reader,ioutils,delete,files,ignoring,exceptions,reader,path,reader,path,resolve,sibling,get,commit,checkpoint,file,name,reader,get,generation
Translog -> void deleteReaderFiles(TranslogReader reader);1542962614;deletes all files associated with a reader. package-private to be able to simulate node failures at this point;void deleteReaderFiles(TranslogReader reader) {_        IOUtils.deleteFilesIgnoringExceptions(reader.path(),_            reader.path().resolveSibling(getCommitCheckpointFileName(reader.getGeneration())))__    };deletes,all,files,associated,with,a,reader,package,private,to,be,able,to,simulate,node,failures,at,this,point;void,delete,reader,files,translog,reader,reader,ioutils,delete,files,ignoring,exceptions,reader,path,reader,path,resolve,sibling,get,commit,checkpoint,file,name,reader,get,generation
Translog -> void deleteReaderFiles(TranslogReader reader);1545236365;deletes all files associated with a reader. package-private to be able to simulate node failures at this point;void deleteReaderFiles(TranslogReader reader) {_        IOUtils.deleteFilesIgnoringExceptions(reader.path(),_            reader.path().resolveSibling(getCommitCheckpointFileName(reader.getGeneration())))__    };deletes,all,files,associated,with,a,reader,package,private,to,be,able,to,simulate,node,failures,at,this,point;void,delete,reader,files,translog,reader,reader,ioutils,delete,files,ignoring,exceptions,reader,path,reader,path,resolve,sibling,get,commit,checkpoint,file,name,reader,get,generation
Translog -> public Location add(final Operation operation) throws IOException;1524684173;Adds an operation to the transaction log.__@param operation the operation to add_@return the location of the operation in the translog_@throws IOException if adding the operation to the translog resulted in an I/O exception;public Location add(final Operation operation) throws IOException {_        final ReleasableBytesStreamOutput out = new ReleasableBytesStreamOutput(bigArrays)__        try {_            final long start = out.position()__            out.skip(Integer.BYTES)__            writeOperationNoSize(new BufferedChecksumStreamOutput(out), operation)__            final long end = out.position()__            final int operationSize = (int) (end - Integer.BYTES - start)__            out.seek(start)__            out.writeInt(operationSize)__            out.seek(end)__            final ReleasablePagedBytesReference bytes = out.bytes()__            try (ReleasableLock ignored = readLock.acquire()) {_                ensureOpen()__                if (operation.primaryTerm() > current.getPrimaryTerm()) {_                    throw new IllegalArgumentException("Operation term is newer than the current term_"_                        + "current term[" + current.getPrimaryTerm() + "], operation term[" + operation + "]")__                }_                return current.add(bytes, operation.seqNo())__            }_        } catch (final AlreadyClosedException | IOException ex) {_            closeOnTragicEvent(ex)__            throw ex__        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw new TranslogException(shardId, "Failed to write operation [" + operation + "]", ex)__        } finally {_            Releasables.close(out)__        }_    };adds,an,operation,to,the,transaction,log,param,operation,the,operation,to,add,return,the,location,of,the,operation,in,the,translog,throws,ioexception,if,adding,the,operation,to,the,translog,resulted,in,an,i,o,exception;public,location,add,final,operation,operation,throws,ioexception,final,releasable,bytes,stream,output,out,new,releasable,bytes,stream,output,big,arrays,try,final,long,start,out,position,out,skip,integer,bytes,write,operation,no,size,new,buffered,checksum,stream,output,out,operation,final,long,end,out,position,final,int,operation,size,int,end,integer,bytes,start,out,seek,start,out,write,int,operation,size,out,seek,end,final,releasable,paged,bytes,reference,bytes,out,bytes,try,releasable,lock,ignored,read,lock,acquire,ensure,open,if,operation,primary,term,current,get,primary,term,throw,new,illegal,argument,exception,operation,term,is,newer,than,the,current,term,current,term,current,get,primary,term,operation,term,operation,return,current,add,bytes,operation,seq,no,catch,final,already,closed,exception,ioexception,ex,close,on,tragic,event,ex,throw,ex,catch,final,exception,ex,close,on,tragic,event,ex,throw,new,translog,exception,shard,id,failed,to,write,operation,operation,ex,finally,releasables,close,out
Translog -> public Location add(final Operation operation) throws IOException;1525334055;Adds an operation to the transaction log.__@param operation the operation to add_@return the location of the operation in the translog_@throws IOException if adding the operation to the translog resulted in an I/O exception;public Location add(final Operation operation) throws IOException {_        final ReleasableBytesStreamOutput out = new ReleasableBytesStreamOutput(bigArrays)__        try {_            final long start = out.position()__            out.skip(Integer.BYTES)__            writeOperationNoSize(new BufferedChecksumStreamOutput(out), operation)__            final long end = out.position()__            final int operationSize = (int) (end - Integer.BYTES - start)__            out.seek(start)__            out.writeInt(operationSize)__            out.seek(end)__            final ReleasablePagedBytesReference bytes = out.bytes()__            try (ReleasableLock ignored = readLock.acquire()) {_                ensureOpen()__                if (operation.primaryTerm() > current.getPrimaryTerm()) {_                    throw new IllegalArgumentException("Operation term is newer than the current term_"_                        + "current term[" + current.getPrimaryTerm() + "], operation term[" + operation + "]")__                }_                return current.add(bytes, operation.seqNo())__            }_        } catch (final AlreadyClosedException | IOException ex) {_            closeOnTragicEvent(ex)__            throw ex__        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw new TranslogException(shardId, "Failed to write operation [" + operation + "]", ex)__        } finally {_            Releasables.close(out)__        }_    };adds,an,operation,to,the,transaction,log,param,operation,the,operation,to,add,return,the,location,of,the,operation,in,the,translog,throws,ioexception,if,adding,the,operation,to,the,translog,resulted,in,an,i,o,exception;public,location,add,final,operation,operation,throws,ioexception,final,releasable,bytes,stream,output,out,new,releasable,bytes,stream,output,big,arrays,try,final,long,start,out,position,out,skip,integer,bytes,write,operation,no,size,new,buffered,checksum,stream,output,out,operation,final,long,end,out,position,final,int,operation,size,int,end,integer,bytes,start,out,seek,start,out,write,int,operation,size,out,seek,end,final,releasable,paged,bytes,reference,bytes,out,bytes,try,releasable,lock,ignored,read,lock,acquire,ensure,open,if,operation,primary,term,current,get,primary,term,throw,new,illegal,argument,exception,operation,term,is,newer,than,the,current,term,current,term,current,get,primary,term,operation,term,operation,return,current,add,bytes,operation,seq,no,catch,final,already,closed,exception,ioexception,ex,close,on,tragic,event,ex,throw,ex,catch,final,exception,ex,close,on,tragic,event,ex,throw,new,translog,exception,shard,id,failed,to,write,operation,operation,ex,finally,releasables,close,out
Translog -> public Location add(final Operation operation) throws IOException;1528706846;Adds an operation to the transaction log.__@param operation the operation to add_@return the location of the operation in the translog_@throws IOException if adding the operation to the translog resulted in an I/O exception;public Location add(final Operation operation) throws IOException {_        final ReleasableBytesStreamOutput out = new ReleasableBytesStreamOutput(bigArrays)__        try {_            final long start = out.position()__            out.skip(Integer.BYTES)__            writeOperationNoSize(new BufferedChecksumStreamOutput(out), operation)__            final long end = out.position()__            final int operationSize = (int) (end - Integer.BYTES - start)__            out.seek(start)__            out.writeInt(operationSize)__            out.seek(end)__            final ReleasablePagedBytesReference bytes = out.bytes()__            try (ReleasableLock ignored = readLock.acquire()) {_                ensureOpen()__                if (operation.primaryTerm() > current.getPrimaryTerm()) {_                    throw new IllegalArgumentException("Operation term is newer than the current term_"_                        + "current term[" + current.getPrimaryTerm() + "], operation term[" + operation + "]")__                }_                return current.add(bytes, operation.seqNo())__            }_        } catch (final AlreadyClosedException | IOException ex) {_            closeOnTragicEvent(ex)__            throw ex__        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw new TranslogException(shardId, "Failed to write operation [" + operation + "]", ex)__        } finally {_            Releasables.close(out)__        }_    };adds,an,operation,to,the,transaction,log,param,operation,the,operation,to,add,return,the,location,of,the,operation,in,the,translog,throws,ioexception,if,adding,the,operation,to,the,translog,resulted,in,an,i,o,exception;public,location,add,final,operation,operation,throws,ioexception,final,releasable,bytes,stream,output,out,new,releasable,bytes,stream,output,big,arrays,try,final,long,start,out,position,out,skip,integer,bytes,write,operation,no,size,new,buffered,checksum,stream,output,out,operation,final,long,end,out,position,final,int,operation,size,int,end,integer,bytes,start,out,seek,start,out,write,int,operation,size,out,seek,end,final,releasable,paged,bytes,reference,bytes,out,bytes,try,releasable,lock,ignored,read,lock,acquire,ensure,open,if,operation,primary,term,current,get,primary,term,throw,new,illegal,argument,exception,operation,term,is,newer,than,the,current,term,current,term,current,get,primary,term,operation,term,operation,return,current,add,bytes,operation,seq,no,catch,final,already,closed,exception,ioexception,ex,close,on,tragic,event,ex,throw,ex,catch,final,exception,ex,close,on,tragic,event,ex,throw,new,translog,exception,shard,id,failed,to,write,operation,operation,ex,finally,releasables,close,out
Translog -> public Location add(final Operation operation) throws IOException;1531910483;Adds an operation to the transaction log.__@param operation the operation to add_@return the location of the operation in the translog_@throws IOException if adding the operation to the translog resulted in an I/O exception;public Location add(final Operation operation) throws IOException {_        final ReleasableBytesStreamOutput out = new ReleasableBytesStreamOutput(bigArrays)__        try {_            final long start = out.position()__            out.skip(Integer.BYTES)__            writeOperationNoSize(new BufferedChecksumStreamOutput(out), operation)__            final long end = out.position()__            final int operationSize = (int) (end - Integer.BYTES - start)__            out.seek(start)__            out.writeInt(operationSize)__            out.seek(end)__            final ReleasablePagedBytesReference bytes = out.bytes()__            try (ReleasableLock ignored = readLock.acquire()) {_                ensureOpen()__                if (operation.primaryTerm() > current.getPrimaryTerm()) {_                    throw new IllegalArgumentException("Operation term is newer than the current term_"_                        + "current term[" + current.getPrimaryTerm() + "], operation term[" + operation + "]")__                }_                return current.add(bytes, operation.seqNo())__            }_        } catch (final AlreadyClosedException | IOException ex) {_            closeOnTragicEvent(ex)__            throw ex__        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw new TranslogException(shardId, "Failed to write operation [" + operation + "]", ex)__        } finally {_            Releasables.close(out)__        }_    };adds,an,operation,to,the,transaction,log,param,operation,the,operation,to,add,return,the,location,of,the,operation,in,the,translog,throws,ioexception,if,adding,the,operation,to,the,translog,resulted,in,an,i,o,exception;public,location,add,final,operation,operation,throws,ioexception,final,releasable,bytes,stream,output,out,new,releasable,bytes,stream,output,big,arrays,try,final,long,start,out,position,out,skip,integer,bytes,write,operation,no,size,new,buffered,checksum,stream,output,out,operation,final,long,end,out,position,final,int,operation,size,int,end,integer,bytes,start,out,seek,start,out,write,int,operation,size,out,seek,end,final,releasable,paged,bytes,reference,bytes,out,bytes,try,releasable,lock,ignored,read,lock,acquire,ensure,open,if,operation,primary,term,current,get,primary,term,throw,new,illegal,argument,exception,operation,term,is,newer,than,the,current,term,current,term,current,get,primary,term,operation,term,operation,return,current,add,bytes,operation,seq,no,catch,final,already,closed,exception,ioexception,ex,close,on,tragic,event,ex,throw,ex,catch,final,exception,ex,close,on,tragic,event,ex,throw,new,translog,exception,shard,id,failed,to,write,operation,operation,ex,finally,releasables,close,out
Translog -> public Location add(final Operation operation) throws IOException;1533295538;Adds an operation to the transaction log.__@param operation the operation to add_@return the location of the operation in the translog_@throws IOException if adding the operation to the translog resulted in an I/O exception;public Location add(final Operation operation) throws IOException {_        final ReleasableBytesStreamOutput out = new ReleasableBytesStreamOutput(bigArrays)__        try {_            final long start = out.position()__            out.skip(Integer.BYTES)__            writeOperationNoSize(new BufferedChecksumStreamOutput(out), operation)__            final long end = out.position()__            final int operationSize = (int) (end - Integer.BYTES - start)__            out.seek(start)__            out.writeInt(operationSize)__            out.seek(end)__            final ReleasablePagedBytesReference bytes = out.bytes()__            try (ReleasableLock ignored = readLock.acquire()) {_                ensureOpen()__                if (operation.primaryTerm() > current.getPrimaryTerm()) {_                    assert false :_                        "Operation term is newer than the current term_ "_                            + "current term[" + current.getPrimaryTerm() + "], operation term[" + operation + "]"__                    throw new IllegalArgumentException("Operation term is newer than the current term_ "_                        + "current term[" + current.getPrimaryTerm() + "], operation term[" + operation + "]")__                }_                return current.add(bytes, operation.seqNo())__            }_        } catch (final AlreadyClosedException | IOException ex) {_            closeOnTragicEvent(ex)__            throw ex__        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw new TranslogException(shardId, "Failed to write operation [" + operation + "]", ex)__        } finally {_            Releasables.close(out)__        }_    };adds,an,operation,to,the,transaction,log,param,operation,the,operation,to,add,return,the,location,of,the,operation,in,the,translog,throws,ioexception,if,adding,the,operation,to,the,translog,resulted,in,an,i,o,exception;public,location,add,final,operation,operation,throws,ioexception,final,releasable,bytes,stream,output,out,new,releasable,bytes,stream,output,big,arrays,try,final,long,start,out,position,out,skip,integer,bytes,write,operation,no,size,new,buffered,checksum,stream,output,out,operation,final,long,end,out,position,final,int,operation,size,int,end,integer,bytes,start,out,seek,start,out,write,int,operation,size,out,seek,end,final,releasable,paged,bytes,reference,bytes,out,bytes,try,releasable,lock,ignored,read,lock,acquire,ensure,open,if,operation,primary,term,current,get,primary,term,assert,false,operation,term,is,newer,than,the,current,term,current,term,current,get,primary,term,operation,term,operation,throw,new,illegal,argument,exception,operation,term,is,newer,than,the,current,term,current,term,current,get,primary,term,operation,term,operation,return,current,add,bytes,operation,seq,no,catch,final,already,closed,exception,ioexception,ex,close,on,tragic,event,ex,throw,ex,catch,final,exception,ex,close,on,tragic,event,ex,throw,new,translog,exception,shard,id,failed,to,write,operation,operation,ex,finally,releasables,close,out
Translog -> public Location add(final Operation operation) throws IOException;1533641732;Adds an operation to the transaction log.__@param operation the operation to add_@return the location of the operation in the translog_@throws IOException if adding the operation to the translog resulted in an I/O exception;public Location add(final Operation operation) throws IOException {_        final ReleasableBytesStreamOutput out = new ReleasableBytesStreamOutput(bigArrays)__        try {_            final long start = out.position()__            out.skip(Integer.BYTES)__            writeOperationNoSize(new BufferedChecksumStreamOutput(out), operation)__            final long end = out.position()__            final int operationSize = (int) (end - Integer.BYTES - start)__            out.seek(start)__            out.writeInt(operationSize)__            out.seek(end)__            final ReleasablePagedBytesReference bytes = out.bytes()__            try (ReleasableLock ignored = readLock.acquire()) {_                ensureOpen()__                if (operation.primaryTerm() > current.getPrimaryTerm()) {_                    assert false :_                        "Operation term is newer than the current term_ "_                            + "current term[" + current.getPrimaryTerm() + "], operation term[" + operation + "]"__                    throw new IllegalArgumentException("Operation term is newer than the current term_ "_                        + "current term[" + current.getPrimaryTerm() + "], operation term[" + operation + "]")__                }_                return current.add(bytes, operation.seqNo())__            }_        } catch (final AlreadyClosedException | IOException ex) {_            closeOnTragicEvent(ex)__            throw ex__        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw new TranslogException(shardId, "Failed to write operation [" + operation + "]", ex)__        } finally {_            Releasables.close(out)__        }_    };adds,an,operation,to,the,transaction,log,param,operation,the,operation,to,add,return,the,location,of,the,operation,in,the,translog,throws,ioexception,if,adding,the,operation,to,the,translog,resulted,in,an,i,o,exception;public,location,add,final,operation,operation,throws,ioexception,final,releasable,bytes,stream,output,out,new,releasable,bytes,stream,output,big,arrays,try,final,long,start,out,position,out,skip,integer,bytes,write,operation,no,size,new,buffered,checksum,stream,output,out,operation,final,long,end,out,position,final,int,operation,size,int,end,integer,bytes,start,out,seek,start,out,write,int,operation,size,out,seek,end,final,releasable,paged,bytes,reference,bytes,out,bytes,try,releasable,lock,ignored,read,lock,acquire,ensure,open,if,operation,primary,term,current,get,primary,term,assert,false,operation,term,is,newer,than,the,current,term,current,term,current,get,primary,term,operation,term,operation,throw,new,illegal,argument,exception,operation,term,is,newer,than,the,current,term,current,term,current,get,primary,term,operation,term,operation,return,current,add,bytes,operation,seq,no,catch,final,already,closed,exception,ioexception,ex,close,on,tragic,event,ex,throw,ex,catch,final,exception,ex,close,on,tragic,event,ex,throw,new,translog,exception,shard,id,failed,to,write,operation,operation,ex,finally,releasables,close,out
Translog -> public Location add(final Operation operation) throws IOException;1534848846;Adds an operation to the transaction log.__@param operation the operation to add_@return the location of the operation in the translog_@throws IOException if adding the operation to the translog resulted in an I/O exception;public Location add(final Operation operation) throws IOException {_        final ReleasableBytesStreamOutput out = new ReleasableBytesStreamOutput(bigArrays)__        try {_            final long start = out.position()__            out.skip(Integer.BYTES)__            writeOperationNoSize(new BufferedChecksumStreamOutput(out), operation)__            final long end = out.position()__            final int operationSize = (int) (end - Integer.BYTES - start)__            out.seek(start)__            out.writeInt(operationSize)__            out.seek(end)__            final ReleasablePagedBytesReference bytes = out.bytes()__            try (ReleasableLock ignored = readLock.acquire()) {_                ensureOpen()__                if (operation.primaryTerm() > current.getPrimaryTerm()) {_                    assert false :_                        "Operation term is newer than the current term_ "_                            + "current term[" + current.getPrimaryTerm() + "], operation term[" + operation + "]"__                    throw new IllegalArgumentException("Operation term is newer than the current term_ "_                        + "current term[" + current.getPrimaryTerm() + "], operation term[" + operation + "]")__                }_                return current.add(bytes, operation.seqNo())__            }_        } catch (final AlreadyClosedException | IOException ex) {_            closeOnTragicEvent(ex)__            throw ex__        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw new TranslogException(shardId, "Failed to write operation [" + operation + "]", ex)__        } finally {_            Releasables.close(out)__        }_    };adds,an,operation,to,the,transaction,log,param,operation,the,operation,to,add,return,the,location,of,the,operation,in,the,translog,throws,ioexception,if,adding,the,operation,to,the,translog,resulted,in,an,i,o,exception;public,location,add,final,operation,operation,throws,ioexception,final,releasable,bytes,stream,output,out,new,releasable,bytes,stream,output,big,arrays,try,final,long,start,out,position,out,skip,integer,bytes,write,operation,no,size,new,buffered,checksum,stream,output,out,operation,final,long,end,out,position,final,int,operation,size,int,end,integer,bytes,start,out,seek,start,out,write,int,operation,size,out,seek,end,final,releasable,paged,bytes,reference,bytes,out,bytes,try,releasable,lock,ignored,read,lock,acquire,ensure,open,if,operation,primary,term,current,get,primary,term,assert,false,operation,term,is,newer,than,the,current,term,current,term,current,get,primary,term,operation,term,operation,throw,new,illegal,argument,exception,operation,term,is,newer,than,the,current,term,current,term,current,get,primary,term,operation,term,operation,return,current,add,bytes,operation,seq,no,catch,final,already,closed,exception,ioexception,ex,close,on,tragic,event,ex,throw,ex,catch,final,exception,ex,close,on,tragic,event,ex,throw,new,translog,exception,shard,id,failed,to,write,operation,operation,ex,finally,releasables,close,out
Translog -> public Location add(final Operation operation) throws IOException;1535046779;Adds an operation to the transaction log.__@param operation the operation to add_@return the location of the operation in the translog_@throws IOException if adding the operation to the translog resulted in an I/O exception;public Location add(final Operation operation) throws IOException {_        final ReleasableBytesStreamOutput out = new ReleasableBytesStreamOutput(bigArrays)__        try {_            final long start = out.position()__            out.skip(Integer.BYTES)__            writeOperationNoSize(new BufferedChecksumStreamOutput(out), operation)__            final long end = out.position()__            final int operationSize = (int) (end - Integer.BYTES - start)__            out.seek(start)__            out.writeInt(operationSize)__            out.seek(end)__            final ReleasablePagedBytesReference bytes = out.bytes()__            try (ReleasableLock ignored = readLock.acquire()) {_                ensureOpen()__                if (operation.primaryTerm() > current.getPrimaryTerm()) {_                    assert false :_                        "Operation term is newer than the current term_ "_                            + "current term[" + current.getPrimaryTerm() + "], operation term[" + operation + "]"__                    throw new IllegalArgumentException("Operation term is newer than the current term_ "_                        + "current term[" + current.getPrimaryTerm() + "], operation term[" + operation + "]")__                }_                return current.add(bytes, operation.seqNo())__            }_        } catch (final AlreadyClosedException | IOException ex) {_            closeOnTragicEvent(ex)__            throw ex__        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw new TranslogException(shardId, "Failed to write operation [" + operation + "]", ex)__        } finally {_            Releasables.close(out)__        }_    };adds,an,operation,to,the,transaction,log,param,operation,the,operation,to,add,return,the,location,of,the,operation,in,the,translog,throws,ioexception,if,adding,the,operation,to,the,translog,resulted,in,an,i,o,exception;public,location,add,final,operation,operation,throws,ioexception,final,releasable,bytes,stream,output,out,new,releasable,bytes,stream,output,big,arrays,try,final,long,start,out,position,out,skip,integer,bytes,write,operation,no,size,new,buffered,checksum,stream,output,out,operation,final,long,end,out,position,final,int,operation,size,int,end,integer,bytes,start,out,seek,start,out,write,int,operation,size,out,seek,end,final,releasable,paged,bytes,reference,bytes,out,bytes,try,releasable,lock,ignored,read,lock,acquire,ensure,open,if,operation,primary,term,current,get,primary,term,assert,false,operation,term,is,newer,than,the,current,term,current,term,current,get,primary,term,operation,term,operation,throw,new,illegal,argument,exception,operation,term,is,newer,than,the,current,term,current,term,current,get,primary,term,operation,term,operation,return,current,add,bytes,operation,seq,no,catch,final,already,closed,exception,ioexception,ex,close,on,tragic,event,ex,throw,ex,catch,final,exception,ex,close,on,tragic,event,ex,throw,new,translog,exception,shard,id,failed,to,write,operation,operation,ex,finally,releasables,close,out
Translog -> public Location add(final Operation operation) throws IOException;1535723122;Adds an operation to the transaction log.__@param operation the operation to add_@return the location of the operation in the translog_@throws IOException if adding the operation to the translog resulted in an I/O exception;public Location add(final Operation operation) throws IOException {_        final ReleasableBytesStreamOutput out = new ReleasableBytesStreamOutput(bigArrays)__        try {_            final long start = out.position()__            out.skip(Integer.BYTES)__            writeOperationNoSize(new BufferedChecksumStreamOutput(out), operation)__            final long end = out.position()__            final int operationSize = (int) (end - Integer.BYTES - start)__            out.seek(start)__            out.writeInt(operationSize)__            out.seek(end)__            final ReleasablePagedBytesReference bytes = out.bytes()__            try (ReleasableLock ignored = readLock.acquire()) {_                ensureOpen()__                if (operation.primaryTerm() > current.getPrimaryTerm()) {_                    assert false :_                        "Operation term is newer than the current term_ "_                            + "current term[" + current.getPrimaryTerm() + "], operation term[" + operation + "]"__                    throw new IllegalArgumentException("Operation term is newer than the current term_ "_                        + "current term[" + current.getPrimaryTerm() + "], operation term[" + operation + "]")__                }_                return current.add(bytes, operation.seqNo())__            }_        } catch (final AlreadyClosedException | IOException ex) {_            closeOnTragicEvent(ex)__            throw ex__        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw new TranslogException(shardId, "Failed to write operation [" + operation + "]", ex)__        } finally {_            Releasables.close(out)__        }_    };adds,an,operation,to,the,transaction,log,param,operation,the,operation,to,add,return,the,location,of,the,operation,in,the,translog,throws,ioexception,if,adding,the,operation,to,the,translog,resulted,in,an,i,o,exception;public,location,add,final,operation,operation,throws,ioexception,final,releasable,bytes,stream,output,out,new,releasable,bytes,stream,output,big,arrays,try,final,long,start,out,position,out,skip,integer,bytes,write,operation,no,size,new,buffered,checksum,stream,output,out,operation,final,long,end,out,position,final,int,operation,size,int,end,integer,bytes,start,out,seek,start,out,write,int,operation,size,out,seek,end,final,releasable,paged,bytes,reference,bytes,out,bytes,try,releasable,lock,ignored,read,lock,acquire,ensure,open,if,operation,primary,term,current,get,primary,term,assert,false,operation,term,is,newer,than,the,current,term,current,term,current,get,primary,term,operation,term,operation,throw,new,illegal,argument,exception,operation,term,is,newer,than,the,current,term,current,term,current,get,primary,term,operation,term,operation,return,current,add,bytes,operation,seq,no,catch,final,already,closed,exception,ioexception,ex,close,on,tragic,event,ex,throw,ex,catch,final,exception,ex,close,on,tragic,event,ex,throw,new,translog,exception,shard,id,failed,to,write,operation,operation,ex,finally,releasables,close,out
Translog -> public Location add(final Operation operation) throws IOException;1537806831;Adds an operation to the transaction log.__@param operation the operation to add_@return the location of the operation in the translog_@throws IOException if adding the operation to the translog resulted in an I/O exception;public Location add(final Operation operation) throws IOException {_        final ReleasableBytesStreamOutput out = new ReleasableBytesStreamOutput(bigArrays)__        try {_            final long start = out.position()__            out.skip(Integer.BYTES)__            writeOperationNoSize(new BufferedChecksumStreamOutput(out), operation)__            final long end = out.position()__            final int operationSize = (int) (end - Integer.BYTES - start)__            out.seek(start)__            out.writeInt(operationSize)__            out.seek(end)__            final ReleasablePagedBytesReference bytes = out.bytes()__            try (ReleasableLock ignored = readLock.acquire()) {_                ensureOpen()__                if (operation.primaryTerm() > current.getPrimaryTerm()) {_                    assert false :_                        "Operation term is newer than the current term_ "_                            + "current term[" + current.getPrimaryTerm() + "], operation term[" + operation + "]"__                    throw new IllegalArgumentException("Operation term is newer than the current term_ "_                        + "current term[" + current.getPrimaryTerm() + "], operation term[" + operation + "]")__                }_                return current.add(bytes, operation.seqNo())__            }_        } catch (final AlreadyClosedException | IOException ex) {_            closeOnTragicEvent(ex)__            throw ex__        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw new TranslogException(shardId, "Failed to write operation [" + operation + "]", ex)__        } finally {_            Releasables.close(out)__        }_    };adds,an,operation,to,the,transaction,log,param,operation,the,operation,to,add,return,the,location,of,the,operation,in,the,translog,throws,ioexception,if,adding,the,operation,to,the,translog,resulted,in,an,i,o,exception;public,location,add,final,operation,operation,throws,ioexception,final,releasable,bytes,stream,output,out,new,releasable,bytes,stream,output,big,arrays,try,final,long,start,out,position,out,skip,integer,bytes,write,operation,no,size,new,buffered,checksum,stream,output,out,operation,final,long,end,out,position,final,int,operation,size,int,end,integer,bytes,start,out,seek,start,out,write,int,operation,size,out,seek,end,final,releasable,paged,bytes,reference,bytes,out,bytes,try,releasable,lock,ignored,read,lock,acquire,ensure,open,if,operation,primary,term,current,get,primary,term,assert,false,operation,term,is,newer,than,the,current,term,current,term,current,get,primary,term,operation,term,operation,throw,new,illegal,argument,exception,operation,term,is,newer,than,the,current,term,current,term,current,get,primary,term,operation,term,operation,return,current,add,bytes,operation,seq,no,catch,final,already,closed,exception,ioexception,ex,close,on,tragic,event,ex,throw,ex,catch,final,exception,ex,close,on,tragic,event,ex,throw,new,translog,exception,shard,id,failed,to,write,operation,operation,ex,finally,releasables,close,out
Translog -> public Location add(final Operation operation) throws IOException;1541592065;Adds an operation to the transaction log.__@param operation the operation to add_@return the location of the operation in the translog_@throws IOException if adding the operation to the translog resulted in an I/O exception;public Location add(final Operation operation) throws IOException {_        final ReleasableBytesStreamOutput out = new ReleasableBytesStreamOutput(bigArrays)__        try {_            final long start = out.position()__            out.skip(Integer.BYTES)__            writeOperationNoSize(new BufferedChecksumStreamOutput(out), operation)__            final long end = out.position()__            final int operationSize = (int) (end - Integer.BYTES - start)__            out.seek(start)__            out.writeInt(operationSize)__            out.seek(end)__            final ReleasablePagedBytesReference bytes = out.bytes()__            try (ReleasableLock ignored = readLock.acquire()) {_                ensureOpen()__                if (operation.primaryTerm() > current.getPrimaryTerm()) {_                    assert false :_                        "Operation term is newer than the current term_ "_                            + "current term[" + current.getPrimaryTerm() + "], operation term[" + operation + "]"__                    throw new IllegalArgumentException("Operation term is newer than the current term_ "_                        + "current term[" + current.getPrimaryTerm() + "], operation term[" + operation + "]")__                }_                return current.add(bytes, operation.seqNo())__            }_        } catch (final AlreadyClosedException | IOException ex) {_            closeOnTragicEvent(ex)__            throw ex__        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw new TranslogException(shardId, "Failed to write operation [" + operation + "]", ex)__        } finally {_            Releasables.close(out)__        }_    };adds,an,operation,to,the,transaction,log,param,operation,the,operation,to,add,return,the,location,of,the,operation,in,the,translog,throws,ioexception,if,adding,the,operation,to,the,translog,resulted,in,an,i,o,exception;public,location,add,final,operation,operation,throws,ioexception,final,releasable,bytes,stream,output,out,new,releasable,bytes,stream,output,big,arrays,try,final,long,start,out,position,out,skip,integer,bytes,write,operation,no,size,new,buffered,checksum,stream,output,out,operation,final,long,end,out,position,final,int,operation,size,int,end,integer,bytes,start,out,seek,start,out,write,int,operation,size,out,seek,end,final,releasable,paged,bytes,reference,bytes,out,bytes,try,releasable,lock,ignored,read,lock,acquire,ensure,open,if,operation,primary,term,current,get,primary,term,assert,false,operation,term,is,newer,than,the,current,term,current,term,current,get,primary,term,operation,term,operation,throw,new,illegal,argument,exception,operation,term,is,newer,than,the,current,term,current,term,current,get,primary,term,operation,term,operation,return,current,add,bytes,operation,seq,no,catch,final,already,closed,exception,ioexception,ex,close,on,tragic,event,ex,throw,ex,catch,final,exception,ex,close,on,tragic,event,ex,throw,new,translog,exception,shard,id,failed,to,write,operation,operation,ex,finally,releasables,close,out
Translog -> public Location add(final Operation operation) throws IOException;1542697754;Adds an operation to the transaction log.__@param operation the operation to add_@return the location of the operation in the translog_@throws IOException if adding the operation to the translog resulted in an I/O exception;public Location add(final Operation operation) throws IOException {_        final ReleasableBytesStreamOutput out = new ReleasableBytesStreamOutput(bigArrays)__        try {_            final long start = out.position()__            out.skip(Integer.BYTES)__            writeOperationNoSize(new BufferedChecksumStreamOutput(out), operation)__            final long end = out.position()__            final int operationSize = (int) (end - Integer.BYTES - start)__            out.seek(start)__            out.writeInt(operationSize)__            out.seek(end)__            final ReleasablePagedBytesReference bytes = out.bytes()__            try (ReleasableLock ignored = readLock.acquire()) {_                ensureOpen()__                if (operation.primaryTerm() > current.getPrimaryTerm()) {_                    assert false :_                        "Operation term is newer than the current term_ "_                            + "current term[" + current.getPrimaryTerm() + "], operation term[" + operation + "]"__                    throw new IllegalArgumentException("Operation term is newer than the current term_ "_                        + "current term[" + current.getPrimaryTerm() + "], operation term[" + operation + "]")__                }_                return current.add(bytes, operation.seqNo())__            }_        } catch (final AlreadyClosedException | IOException ex) {_            closeOnTragicEvent(ex)__            throw ex__        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw new TranslogException(shardId, "Failed to write operation [" + operation + "]", ex)__        } finally {_            Releasables.close(out)__        }_    };adds,an,operation,to,the,transaction,log,param,operation,the,operation,to,add,return,the,location,of,the,operation,in,the,translog,throws,ioexception,if,adding,the,operation,to,the,translog,resulted,in,an,i,o,exception;public,location,add,final,operation,operation,throws,ioexception,final,releasable,bytes,stream,output,out,new,releasable,bytes,stream,output,big,arrays,try,final,long,start,out,position,out,skip,integer,bytes,write,operation,no,size,new,buffered,checksum,stream,output,out,operation,final,long,end,out,position,final,int,operation,size,int,end,integer,bytes,start,out,seek,start,out,write,int,operation,size,out,seek,end,final,releasable,paged,bytes,reference,bytes,out,bytes,try,releasable,lock,ignored,read,lock,acquire,ensure,open,if,operation,primary,term,current,get,primary,term,assert,false,operation,term,is,newer,than,the,current,term,current,term,current,get,primary,term,operation,term,operation,throw,new,illegal,argument,exception,operation,term,is,newer,than,the,current,term,current,term,current,get,primary,term,operation,term,operation,return,current,add,bytes,operation,seq,no,catch,final,already,closed,exception,ioexception,ex,close,on,tragic,event,ex,throw,ex,catch,final,exception,ex,close,on,tragic,event,ex,throw,new,translog,exception,shard,id,failed,to,write,operation,operation,ex,finally,releasables,close,out
Translog -> public Location add(final Operation operation) throws IOException;1542962614;Adds an operation to the transaction log.__@param operation the operation to add_@return the location of the operation in the translog_@throws IOException if adding the operation to the translog resulted in an I/O exception;public Location add(final Operation operation) throws IOException {_        final ReleasableBytesStreamOutput out = new ReleasableBytesStreamOutput(bigArrays)__        try {_            final long start = out.position()__            out.skip(Integer.BYTES)__            writeOperationNoSize(new BufferedChecksumStreamOutput(out), operation)__            final long end = out.position()__            final int operationSize = (int) (end - Integer.BYTES - start)__            out.seek(start)__            out.writeInt(operationSize)__            out.seek(end)__            final ReleasablePagedBytesReference bytes = out.bytes()__            try (ReleasableLock ignored = readLock.acquire()) {_                ensureOpen()__                if (operation.primaryTerm() > current.getPrimaryTerm()) {_                    assert false :_                        "Operation term is newer than the current term_ "_                            + "current term[" + current.getPrimaryTerm() + "], operation term[" + operation + "]"__                    throw new IllegalArgumentException("Operation term is newer than the current term_ "_                        + "current term[" + current.getPrimaryTerm() + "], operation term[" + operation + "]")__                }_                return current.add(bytes, operation.seqNo())__            }_        } catch (final AlreadyClosedException | IOException ex) {_            closeOnTragicEvent(ex)__            throw ex__        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw new TranslogException(shardId, "Failed to write operation [" + operation + "]", ex)__        } finally {_            Releasables.close(out)__        }_    };adds,an,operation,to,the,transaction,log,param,operation,the,operation,to,add,return,the,location,of,the,operation,in,the,translog,throws,ioexception,if,adding,the,operation,to,the,translog,resulted,in,an,i,o,exception;public,location,add,final,operation,operation,throws,ioexception,final,releasable,bytes,stream,output,out,new,releasable,bytes,stream,output,big,arrays,try,final,long,start,out,position,out,skip,integer,bytes,write,operation,no,size,new,buffered,checksum,stream,output,out,operation,final,long,end,out,position,final,int,operation,size,int,end,integer,bytes,start,out,seek,start,out,write,int,operation,size,out,seek,end,final,releasable,paged,bytes,reference,bytes,out,bytes,try,releasable,lock,ignored,read,lock,acquire,ensure,open,if,operation,primary,term,current,get,primary,term,assert,false,operation,term,is,newer,than,the,current,term,current,term,current,get,primary,term,operation,term,operation,throw,new,illegal,argument,exception,operation,term,is,newer,than,the,current,term,current,term,current,get,primary,term,operation,term,operation,return,current,add,bytes,operation,seq,no,catch,final,already,closed,exception,ioexception,ex,close,on,tragic,event,ex,throw,ex,catch,final,exception,ex,close,on,tragic,event,ex,throw,new,translog,exception,shard,id,failed,to,write,operation,operation,ex,finally,releasables,close,out
Translog -> public Location add(final Operation operation) throws IOException;1545236365;Adds an operation to the transaction log.__@param operation the operation to add_@return the location of the operation in the translog_@throws IOException if adding the operation to the translog resulted in an I/O exception;public Location add(final Operation operation) throws IOException {_        final ReleasableBytesStreamOutput out = new ReleasableBytesStreamOutput(bigArrays)__        try {_            final long start = out.position()__            out.skip(Integer.BYTES)__            writeOperationNoSize(new BufferedChecksumStreamOutput(out), operation)__            final long end = out.position()__            final int operationSize = (int) (end - Integer.BYTES - start)__            out.seek(start)__            out.writeInt(operationSize)__            out.seek(end)__            final ReleasablePagedBytesReference bytes = out.bytes()__            try (ReleasableLock ignored = readLock.acquire()) {_                ensureOpen()__                if (operation.primaryTerm() > current.getPrimaryTerm()) {_                    assert false :_                        "Operation term is newer than the current term_ "_                            + "current term[" + current.getPrimaryTerm() + "], operation term[" + operation + "]"__                    throw new IllegalArgumentException("Operation term is newer than the current term_ "_                        + "current term[" + current.getPrimaryTerm() + "], operation term[" + operation + "]")__                }_                return current.add(bytes, operation.seqNo())__            }_        } catch (final AlreadyClosedException | IOException ex) {_            closeOnTragicEvent(ex)__            throw ex__        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw new TranslogException(shardId, "Failed to write operation [" + operation + "]", ex)__        } finally {_            Releasables.close(out)__        }_    };adds,an,operation,to,the,transaction,log,param,operation,the,operation,to,add,return,the,location,of,the,operation,in,the,translog,throws,ioexception,if,adding,the,operation,to,the,translog,resulted,in,an,i,o,exception;public,location,add,final,operation,operation,throws,ioexception,final,releasable,bytes,stream,output,out,new,releasable,bytes,stream,output,big,arrays,try,final,long,start,out,position,out,skip,integer,bytes,write,operation,no,size,new,buffered,checksum,stream,output,out,operation,final,long,end,out,position,final,int,operation,size,int,end,integer,bytes,start,out,seek,start,out,write,int,operation,size,out,seek,end,final,releasable,paged,bytes,reference,bytes,out,bytes,try,releasable,lock,ignored,read,lock,acquire,ensure,open,if,operation,primary,term,current,get,primary,term,assert,false,operation,term,is,newer,than,the,current,term,current,term,current,get,primary,term,operation,term,operation,throw,new,illegal,argument,exception,operation,term,is,newer,than,the,current,term,current,term,current,get,primary,term,operation,term,operation,return,current,add,bytes,operation,seq,no,catch,final,already,closed,exception,ioexception,ex,close,on,tragic,event,ex,throw,ex,catch,final,exception,ex,close,on,tragic,event,ex,throw,new,translog,exception,shard,id,failed,to,write,operation,operation,ex,finally,releasables,close,out
Translog -> public void trimUnreferencedReaders() throws IOException;1524684173;Trims unreferenced translog generations by asking {@link TranslogDeletionPolicy} for the minimum_required generation;public void trimUnreferencedReaders() throws IOException {_        try (ReleasableLock ignored = writeLock.acquire()) {_            if (closed.get()) {_                _                return__            }_            long minReferencedGen = deletionPolicy.minTranslogGenRequired(readers, current)__            assert minReferencedGen >= getMinFileGeneration() :_                "deletion policy requires a minReferenceGen of [" + minReferencedGen + "] but the lowest gen available is ["_                    + getMinFileGeneration() + "]"__            assert minReferencedGen <= currentFileGeneration() :_                "deletion policy requires a minReferenceGen of [" + minReferencedGen + "] which is higher than the current generation ["_                    + currentFileGeneration() + "]"____            for (Iterator<TranslogReader> iterator = readers.iterator()_ iterator.hasNext()_ ) {_                TranslogReader reader = iterator.next()__                if (reader.getGeneration() >= minReferencedGen) {_                    break__                }_                iterator.remove()__                IOUtils.closeWhileHandlingException(reader)__                final Path translogPath = reader.path()__                logger.trace("delete translog file [{}], not referenced and not current anymore", translogPath)__                _                _                _                _                current.sync()__                deleteReaderFiles(reader)__            }_            assert readers.isEmpty() == false || current.generation == minReferencedGen :_                "all readers were cleaned but the minReferenceGen [" + minReferencedGen + "] is not the current writer's gen [" +_                    current.generation + "]"__        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_    };trims,unreferenced,translog,generations,by,asking,link,translog,deletion,policy,for,the,minimum,required,generation;public,void,trim,unreferenced,readers,throws,ioexception,try,releasable,lock,ignored,write,lock,acquire,if,closed,get,return,long,min,referenced,gen,deletion,policy,min,translog,gen,required,readers,current,assert,min,referenced,gen,get,min,file,generation,deletion,policy,requires,a,min,reference,gen,of,min,referenced,gen,but,the,lowest,gen,available,is,get,min,file,generation,assert,min,referenced,gen,current,file,generation,deletion,policy,requires,a,min,reference,gen,of,min,referenced,gen,which,is,higher,than,the,current,generation,current,file,generation,for,iterator,translog,reader,iterator,readers,iterator,iterator,has,next,translog,reader,reader,iterator,next,if,reader,get,generation,min,referenced,gen,break,iterator,remove,ioutils,close,while,handling,exception,reader,final,path,translog,path,reader,path,logger,trace,delete,translog,file,not,referenced,and,not,current,anymore,translog,path,current,sync,delete,reader,files,reader,assert,readers,is,empty,false,current,generation,min,referenced,gen,all,readers,were,cleaned,but,the,min,reference,gen,min,referenced,gen,is,not,the,current,writer,s,gen,current,generation,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex
Translog -> public void trimUnreferencedReaders() throws IOException;1525334055;Trims unreferenced translog generations by asking {@link TranslogDeletionPolicy} for the minimum_required generation;public void trimUnreferencedReaders() throws IOException {_        try (ReleasableLock ignored = writeLock.acquire()) {_            if (closed.get()) {_                _                return__            }_            long minReferencedGen = deletionPolicy.minTranslogGenRequired(readers, current)__            assert minReferencedGen >= getMinFileGeneration() :_                "deletion policy requires a minReferenceGen of [" + minReferencedGen + "] but the lowest gen available is ["_                    + getMinFileGeneration() + "]"__            assert minReferencedGen <= currentFileGeneration() :_                "deletion policy requires a minReferenceGen of [" + minReferencedGen + "] which is higher than the current generation ["_                    + currentFileGeneration() + "]"____            for (Iterator<TranslogReader> iterator = readers.iterator()_ iterator.hasNext()_ ) {_                TranslogReader reader = iterator.next()__                if (reader.getGeneration() >= minReferencedGen) {_                    break__                }_                iterator.remove()__                IOUtils.closeWhileHandlingException(reader)__                final Path translogPath = reader.path()__                logger.trace("delete translog file [{}], not referenced and not current anymore", translogPath)__                _                _                _                _                current.sync()__                deleteReaderFiles(reader)__            }_            assert readers.isEmpty() == false || current.generation == minReferencedGen :_                "all readers were cleaned but the minReferenceGen [" + minReferencedGen + "] is not the current writer's gen [" +_                    current.generation + "]"__        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_    };trims,unreferenced,translog,generations,by,asking,link,translog,deletion,policy,for,the,minimum,required,generation;public,void,trim,unreferenced,readers,throws,ioexception,try,releasable,lock,ignored,write,lock,acquire,if,closed,get,return,long,min,referenced,gen,deletion,policy,min,translog,gen,required,readers,current,assert,min,referenced,gen,get,min,file,generation,deletion,policy,requires,a,min,reference,gen,of,min,referenced,gen,but,the,lowest,gen,available,is,get,min,file,generation,assert,min,referenced,gen,current,file,generation,deletion,policy,requires,a,min,reference,gen,of,min,referenced,gen,which,is,higher,than,the,current,generation,current,file,generation,for,iterator,translog,reader,iterator,readers,iterator,iterator,has,next,translog,reader,reader,iterator,next,if,reader,get,generation,min,referenced,gen,break,iterator,remove,ioutils,close,while,handling,exception,reader,final,path,translog,path,reader,path,logger,trace,delete,translog,file,not,referenced,and,not,current,anymore,translog,path,current,sync,delete,reader,files,reader,assert,readers,is,empty,false,current,generation,min,referenced,gen,all,readers,were,cleaned,but,the,min,reference,gen,min,referenced,gen,is,not,the,current,writer,s,gen,current,generation,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex
Translog -> public void trimUnreferencedReaders() throws IOException;1528706846;Trims unreferenced translog generations by asking {@link TranslogDeletionPolicy} for the minimum_required generation;public void trimUnreferencedReaders() throws IOException {_        try (ReleasableLock ignored = writeLock.acquire()) {_            if (closed.get()) {_                _                return__            }_            long minReferencedGen = deletionPolicy.minTranslogGenRequired(readers, current)__            assert minReferencedGen >= getMinFileGeneration() :_                "deletion policy requires a minReferenceGen of [" + minReferencedGen + "] but the lowest gen available is ["_                    + getMinFileGeneration() + "]"__            assert minReferencedGen <= currentFileGeneration() :_                "deletion policy requires a minReferenceGen of [" + minReferencedGen + "] which is higher than the current generation ["_                    + currentFileGeneration() + "]"____            for (Iterator<TranslogReader> iterator = readers.iterator()_ iterator.hasNext()_ ) {_                TranslogReader reader = iterator.next()__                if (reader.getGeneration() >= minReferencedGen) {_                    break__                }_                iterator.remove()__                IOUtils.closeWhileHandlingException(reader)__                final Path translogPath = reader.path()__                logger.trace("delete translog file [{}], not referenced and not current anymore", translogPath)__                _                _                _                _                current.sync()__                deleteReaderFiles(reader)__            }_            assert readers.isEmpty() == false || current.generation == minReferencedGen :_                "all readers were cleaned but the minReferenceGen [" + minReferencedGen + "] is not the current writer's gen [" +_                    current.generation + "]"__        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_    };trims,unreferenced,translog,generations,by,asking,link,translog,deletion,policy,for,the,minimum,required,generation;public,void,trim,unreferenced,readers,throws,ioexception,try,releasable,lock,ignored,write,lock,acquire,if,closed,get,return,long,min,referenced,gen,deletion,policy,min,translog,gen,required,readers,current,assert,min,referenced,gen,get,min,file,generation,deletion,policy,requires,a,min,reference,gen,of,min,referenced,gen,but,the,lowest,gen,available,is,get,min,file,generation,assert,min,referenced,gen,current,file,generation,deletion,policy,requires,a,min,reference,gen,of,min,referenced,gen,which,is,higher,than,the,current,generation,current,file,generation,for,iterator,translog,reader,iterator,readers,iterator,iterator,has,next,translog,reader,reader,iterator,next,if,reader,get,generation,min,referenced,gen,break,iterator,remove,ioutils,close,while,handling,exception,reader,final,path,translog,path,reader,path,logger,trace,delete,translog,file,not,referenced,and,not,current,anymore,translog,path,current,sync,delete,reader,files,reader,assert,readers,is,empty,false,current,generation,min,referenced,gen,all,readers,were,cleaned,but,the,min,reference,gen,min,referenced,gen,is,not,the,current,writer,s,gen,current,generation,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex
Translog -> public void trimUnreferencedReaders() throws IOException;1531910483;Trims unreferenced translog generations by asking {@link TranslogDeletionPolicy} for the minimum_required generation;public void trimUnreferencedReaders() throws IOException {_        try (ReleasableLock ignored = writeLock.acquire()) {_            if (closed.get()) {_                _                return__            }_            long minReferencedGen = deletionPolicy.minTranslogGenRequired(readers, current)__            assert minReferencedGen >= getMinFileGeneration() :_                "deletion policy requires a minReferenceGen of [" + minReferencedGen + "] but the lowest gen available is ["_                    + getMinFileGeneration() + "]"__            assert minReferencedGen <= currentFileGeneration() :_                "deletion policy requires a minReferenceGen of [" + minReferencedGen + "] which is higher than the current generation ["_                    + currentFileGeneration() + "]"____            for (Iterator<TranslogReader> iterator = readers.iterator()_ iterator.hasNext()_ ) {_                TranslogReader reader = iterator.next()__                if (reader.getGeneration() >= minReferencedGen) {_                    break__                }_                iterator.remove()__                IOUtils.closeWhileHandlingException(reader)__                final Path translogPath = reader.path()__                logger.trace("delete translog file [{}], not referenced and not current anymore", translogPath)__                _                _                _                _                current.sync()__                deleteReaderFiles(reader)__            }_            assert readers.isEmpty() == false || current.generation == minReferencedGen :_                "all readers were cleaned but the minReferenceGen [" + minReferencedGen + "] is not the current writer's gen [" +_                    current.generation + "]"__        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_    };trims,unreferenced,translog,generations,by,asking,link,translog,deletion,policy,for,the,minimum,required,generation;public,void,trim,unreferenced,readers,throws,ioexception,try,releasable,lock,ignored,write,lock,acquire,if,closed,get,return,long,min,referenced,gen,deletion,policy,min,translog,gen,required,readers,current,assert,min,referenced,gen,get,min,file,generation,deletion,policy,requires,a,min,reference,gen,of,min,referenced,gen,but,the,lowest,gen,available,is,get,min,file,generation,assert,min,referenced,gen,current,file,generation,deletion,policy,requires,a,min,reference,gen,of,min,referenced,gen,which,is,higher,than,the,current,generation,current,file,generation,for,iterator,translog,reader,iterator,readers,iterator,iterator,has,next,translog,reader,reader,iterator,next,if,reader,get,generation,min,referenced,gen,break,iterator,remove,ioutils,close,while,handling,exception,reader,final,path,translog,path,reader,path,logger,trace,delete,translog,file,not,referenced,and,not,current,anymore,translog,path,current,sync,delete,reader,files,reader,assert,readers,is,empty,false,current,generation,min,referenced,gen,all,readers,were,cleaned,but,the,min,reference,gen,min,referenced,gen,is,not,the,current,writer,s,gen,current,generation,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex
Translog -> public void trimUnreferencedReaders() throws IOException;1533295538;Trims unreferenced translog generations by asking {@link TranslogDeletionPolicy} for the minimum_required generation;public void trimUnreferencedReaders() throws IOException {_        try (ReleasableLock ignored = writeLock.acquire()) {_            if (closed.get()) {_                _                return__            }_            long minReferencedGen = deletionPolicy.minTranslogGenRequired(readers, current)__            assert minReferencedGen >= getMinFileGeneration() :_                "deletion policy requires a minReferenceGen of [" + minReferencedGen + "] but the lowest gen available is ["_                    + getMinFileGeneration() + "]"__            assert minReferencedGen <= currentFileGeneration() :_                "deletion policy requires a minReferenceGen of [" + minReferencedGen + "] which is higher than the current generation ["_                    + currentFileGeneration() + "]"____            for (Iterator<TranslogReader> iterator = readers.iterator()_ iterator.hasNext()_ ) {_                TranslogReader reader = iterator.next()__                if (reader.getGeneration() >= minReferencedGen) {_                    break__                }_                iterator.remove()__                IOUtils.closeWhileHandlingException(reader)__                final Path translogPath = reader.path()__                logger.trace("delete translog file [{}], not referenced and not current anymore", translogPath)__                _                _                _                _                current.sync()__                deleteReaderFiles(reader)__            }_            assert readers.isEmpty() == false || current.generation == minReferencedGen :_                "all readers were cleaned but the minReferenceGen [" + minReferencedGen + "] is not the current writer's gen [" +_                    current.generation + "]"__        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_    };trims,unreferenced,translog,generations,by,asking,link,translog,deletion,policy,for,the,minimum,required,generation;public,void,trim,unreferenced,readers,throws,ioexception,try,releasable,lock,ignored,write,lock,acquire,if,closed,get,return,long,min,referenced,gen,deletion,policy,min,translog,gen,required,readers,current,assert,min,referenced,gen,get,min,file,generation,deletion,policy,requires,a,min,reference,gen,of,min,referenced,gen,but,the,lowest,gen,available,is,get,min,file,generation,assert,min,referenced,gen,current,file,generation,deletion,policy,requires,a,min,reference,gen,of,min,referenced,gen,which,is,higher,than,the,current,generation,current,file,generation,for,iterator,translog,reader,iterator,readers,iterator,iterator,has,next,translog,reader,reader,iterator,next,if,reader,get,generation,min,referenced,gen,break,iterator,remove,ioutils,close,while,handling,exception,reader,final,path,translog,path,reader,path,logger,trace,delete,translog,file,not,referenced,and,not,current,anymore,translog,path,current,sync,delete,reader,files,reader,assert,readers,is,empty,false,current,generation,min,referenced,gen,all,readers,were,cleaned,but,the,min,reference,gen,min,referenced,gen,is,not,the,current,writer,s,gen,current,generation,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex
Translog -> public void trimUnreferencedReaders() throws IOException;1533641732;Trims unreferenced translog generations by asking {@link TranslogDeletionPolicy} for the minimum_required generation;public void trimUnreferencedReaders() throws IOException {_        try (ReleasableLock ignored = writeLock.acquire()) {_            if (closed.get()) {_                _                return__            }_            long minReferencedGen = deletionPolicy.minTranslogGenRequired(readers, current)__            assert minReferencedGen >= getMinFileGeneration() :_                "deletion policy requires a minReferenceGen of [" + minReferencedGen + "] but the lowest gen available is ["_                    + getMinFileGeneration() + "]"__            assert minReferencedGen <= currentFileGeneration() :_                "deletion policy requires a minReferenceGen of [" + minReferencedGen + "] which is higher than the current generation ["_                    + currentFileGeneration() + "]"____            for (Iterator<TranslogReader> iterator = readers.iterator()_ iterator.hasNext()_ ) {_                TranslogReader reader = iterator.next()__                if (reader.getGeneration() >= minReferencedGen) {_                    break__                }_                iterator.remove()__                IOUtils.closeWhileHandlingException(reader)__                final Path translogPath = reader.path()__                logger.trace("delete translog file [{}], not referenced and not current anymore", translogPath)__                _                _                _                _                current.sync()__                deleteReaderFiles(reader)__            }_            assert readers.isEmpty() == false || current.generation == minReferencedGen :_                "all readers were cleaned but the minReferenceGen [" + minReferencedGen + "] is not the current writer's gen [" +_                    current.generation + "]"__        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_    };trims,unreferenced,translog,generations,by,asking,link,translog,deletion,policy,for,the,minimum,required,generation;public,void,trim,unreferenced,readers,throws,ioexception,try,releasable,lock,ignored,write,lock,acquire,if,closed,get,return,long,min,referenced,gen,deletion,policy,min,translog,gen,required,readers,current,assert,min,referenced,gen,get,min,file,generation,deletion,policy,requires,a,min,reference,gen,of,min,referenced,gen,but,the,lowest,gen,available,is,get,min,file,generation,assert,min,referenced,gen,current,file,generation,deletion,policy,requires,a,min,reference,gen,of,min,referenced,gen,which,is,higher,than,the,current,generation,current,file,generation,for,iterator,translog,reader,iterator,readers,iterator,iterator,has,next,translog,reader,reader,iterator,next,if,reader,get,generation,min,referenced,gen,break,iterator,remove,ioutils,close,while,handling,exception,reader,final,path,translog,path,reader,path,logger,trace,delete,translog,file,not,referenced,and,not,current,anymore,translog,path,current,sync,delete,reader,files,reader,assert,readers,is,empty,false,current,generation,min,referenced,gen,all,readers,were,cleaned,but,the,min,reference,gen,min,referenced,gen,is,not,the,current,writer,s,gen,current,generation,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex
Translog -> public void trimUnreferencedReaders() throws IOException;1534848846;Trims unreferenced translog generations by asking {@link TranslogDeletionPolicy} for the minimum_required generation;public void trimUnreferencedReaders() throws IOException {_        try (ReleasableLock ignored = writeLock.acquire()) {_            if (closed.get()) {_                _                return__            }_            long minReferencedGen = deletionPolicy.minTranslogGenRequired(readers, current)__            assert minReferencedGen >= getMinFileGeneration() :_                "deletion policy requires a minReferenceGen of [" + minReferencedGen + "] but the lowest gen available is ["_                    + getMinFileGeneration() + "]"__            assert minReferencedGen <= currentFileGeneration() :_                "deletion policy requires a minReferenceGen of [" + minReferencedGen + "] which is higher than the current generation ["_                    + currentFileGeneration() + "]"____            for (Iterator<TranslogReader> iterator = readers.iterator()_ iterator.hasNext()_ ) {_                TranslogReader reader = iterator.next()__                if (reader.getGeneration() >= minReferencedGen) {_                    break__                }_                iterator.remove()__                IOUtils.closeWhileHandlingException(reader)__                final Path translogPath = reader.path()__                logger.trace("delete translog file [{}], not referenced and not current anymore", translogPath)__                _                _                _                _                current.sync()__                deleteReaderFiles(reader)__            }_            assert readers.isEmpty() == false || current.generation == minReferencedGen :_                "all readers were cleaned but the minReferenceGen [" + minReferencedGen + "] is not the current writer's gen [" +_                    current.generation + "]"__        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_    };trims,unreferenced,translog,generations,by,asking,link,translog,deletion,policy,for,the,minimum,required,generation;public,void,trim,unreferenced,readers,throws,ioexception,try,releasable,lock,ignored,write,lock,acquire,if,closed,get,return,long,min,referenced,gen,deletion,policy,min,translog,gen,required,readers,current,assert,min,referenced,gen,get,min,file,generation,deletion,policy,requires,a,min,reference,gen,of,min,referenced,gen,but,the,lowest,gen,available,is,get,min,file,generation,assert,min,referenced,gen,current,file,generation,deletion,policy,requires,a,min,reference,gen,of,min,referenced,gen,which,is,higher,than,the,current,generation,current,file,generation,for,iterator,translog,reader,iterator,readers,iterator,iterator,has,next,translog,reader,reader,iterator,next,if,reader,get,generation,min,referenced,gen,break,iterator,remove,ioutils,close,while,handling,exception,reader,final,path,translog,path,reader,path,logger,trace,delete,translog,file,not,referenced,and,not,current,anymore,translog,path,current,sync,delete,reader,files,reader,assert,readers,is,empty,false,current,generation,min,referenced,gen,all,readers,were,cleaned,but,the,min,reference,gen,min,referenced,gen,is,not,the,current,writer,s,gen,current,generation,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex
Translog -> public void trimUnreferencedReaders() throws IOException;1535046779;Trims unreferenced translog generations by asking {@link TranslogDeletionPolicy} for the minimum_required generation;public void trimUnreferencedReaders() throws IOException {_        try (ReleasableLock ignored = writeLock.acquire()) {_            if (closed.get()) {_                _                return__            }_            long minReferencedGen = deletionPolicy.minTranslogGenRequired(readers, current)__            assert minReferencedGen >= getMinFileGeneration() :_                "deletion policy requires a minReferenceGen of [" + minReferencedGen + "] but the lowest gen available is ["_                    + getMinFileGeneration() + "]"__            assert minReferencedGen <= currentFileGeneration() :_                "deletion policy requires a minReferenceGen of [" + minReferencedGen + "] which is higher than the current generation ["_                    + currentFileGeneration() + "]"____            for (Iterator<TranslogReader> iterator = readers.iterator()_ iterator.hasNext()_ ) {_                TranslogReader reader = iterator.next()__                if (reader.getGeneration() >= minReferencedGen) {_                    break__                }_                iterator.remove()__                IOUtils.closeWhileHandlingException(reader)__                final Path translogPath = reader.path()__                logger.trace("delete translog file [{}], not referenced and not current anymore", translogPath)__                _                _                _                _                current.sync()__                deleteReaderFiles(reader)__            }_            assert readers.isEmpty() == false || current.generation == minReferencedGen :_                "all readers were cleaned but the minReferenceGen [" + minReferencedGen + "] is not the current writer's gen [" +_                    current.generation + "]"__        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_    };trims,unreferenced,translog,generations,by,asking,link,translog,deletion,policy,for,the,minimum,required,generation;public,void,trim,unreferenced,readers,throws,ioexception,try,releasable,lock,ignored,write,lock,acquire,if,closed,get,return,long,min,referenced,gen,deletion,policy,min,translog,gen,required,readers,current,assert,min,referenced,gen,get,min,file,generation,deletion,policy,requires,a,min,reference,gen,of,min,referenced,gen,but,the,lowest,gen,available,is,get,min,file,generation,assert,min,referenced,gen,current,file,generation,deletion,policy,requires,a,min,reference,gen,of,min,referenced,gen,which,is,higher,than,the,current,generation,current,file,generation,for,iterator,translog,reader,iterator,readers,iterator,iterator,has,next,translog,reader,reader,iterator,next,if,reader,get,generation,min,referenced,gen,break,iterator,remove,ioutils,close,while,handling,exception,reader,final,path,translog,path,reader,path,logger,trace,delete,translog,file,not,referenced,and,not,current,anymore,translog,path,current,sync,delete,reader,files,reader,assert,readers,is,empty,false,current,generation,min,referenced,gen,all,readers,were,cleaned,but,the,min,reference,gen,min,referenced,gen,is,not,the,current,writer,s,gen,current,generation,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex
Translog -> public void trimUnreferencedReaders() throws IOException;1535723122;Trims unreferenced translog generations by asking {@link TranslogDeletionPolicy} for the minimum_required generation;public void trimUnreferencedReaders() throws IOException {_        try (ReleasableLock ignored = writeLock.acquire()) {_            if (closed.get()) {_                _                return__            }_            long minReferencedGen = deletionPolicy.minTranslogGenRequired(readers, current)__            assert minReferencedGen >= getMinFileGeneration() :_                "deletion policy requires a minReferenceGen of [" + minReferencedGen + "] but the lowest gen available is ["_                    + getMinFileGeneration() + "]"__            assert minReferencedGen <= currentFileGeneration() :_                "deletion policy requires a minReferenceGen of [" + minReferencedGen + "] which is higher than the current generation ["_                    + currentFileGeneration() + "]"____            for (Iterator<TranslogReader> iterator = readers.iterator()_ iterator.hasNext()_ ) {_                TranslogReader reader = iterator.next()__                if (reader.getGeneration() >= minReferencedGen) {_                    break__                }_                iterator.remove()__                IOUtils.closeWhileHandlingException(reader)__                final Path translogPath = reader.path()__                logger.trace("delete translog file [{}], not referenced and not current anymore", translogPath)__                _                _                _                _                current.sync()__                deleteReaderFiles(reader)__            }_            assert readers.isEmpty() == false || current.generation == minReferencedGen :_                "all readers were cleaned but the minReferenceGen [" + minReferencedGen + "] is not the current writer's gen [" +_                    current.generation + "]"__        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_    };trims,unreferenced,translog,generations,by,asking,link,translog,deletion,policy,for,the,minimum,required,generation;public,void,trim,unreferenced,readers,throws,ioexception,try,releasable,lock,ignored,write,lock,acquire,if,closed,get,return,long,min,referenced,gen,deletion,policy,min,translog,gen,required,readers,current,assert,min,referenced,gen,get,min,file,generation,deletion,policy,requires,a,min,reference,gen,of,min,referenced,gen,but,the,lowest,gen,available,is,get,min,file,generation,assert,min,referenced,gen,current,file,generation,deletion,policy,requires,a,min,reference,gen,of,min,referenced,gen,which,is,higher,than,the,current,generation,current,file,generation,for,iterator,translog,reader,iterator,readers,iterator,iterator,has,next,translog,reader,reader,iterator,next,if,reader,get,generation,min,referenced,gen,break,iterator,remove,ioutils,close,while,handling,exception,reader,final,path,translog,path,reader,path,logger,trace,delete,translog,file,not,referenced,and,not,current,anymore,translog,path,current,sync,delete,reader,files,reader,assert,readers,is,empty,false,current,generation,min,referenced,gen,all,readers,were,cleaned,but,the,min,reference,gen,min,referenced,gen,is,not,the,current,writer,s,gen,current,generation,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex
Translog -> public void trimUnreferencedReaders() throws IOException;1537806831;Trims unreferenced translog generations by asking {@link TranslogDeletionPolicy} for the minimum_required generation;public void trimUnreferencedReaders() throws IOException {_        try (ReleasableLock ignored = writeLock.acquire()) {_            if (closed.get()) {_                _                return__            }_            long minReferencedGen = deletionPolicy.minTranslogGenRequired(readers, current)__            assert minReferencedGen >= getMinFileGeneration() :_                "deletion policy requires a minReferenceGen of [" + minReferencedGen + "] but the lowest gen available is ["_                    + getMinFileGeneration() + "]"__            assert minReferencedGen <= currentFileGeneration() :_                "deletion policy requires a minReferenceGen of [" + minReferencedGen + "] which is higher than the current generation ["_                    + currentFileGeneration() + "]"____            for (Iterator<TranslogReader> iterator = readers.iterator()_ iterator.hasNext()_ ) {_                TranslogReader reader = iterator.next()__                if (reader.getGeneration() >= minReferencedGen) {_                    break__                }_                iterator.remove()__                IOUtils.closeWhileHandlingException(reader)__                final Path translogPath = reader.path()__                logger.trace("delete translog file [{}], not referenced and not current anymore", translogPath)__                _                _                _                _                current.sync()__                deleteReaderFiles(reader)__            }_            assert readers.isEmpty() == false || current.generation == minReferencedGen :_                "all readers were cleaned but the minReferenceGen [" + minReferencedGen + "] is not the current writer's gen [" +_                    current.generation + "]"__        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_    };trims,unreferenced,translog,generations,by,asking,link,translog,deletion,policy,for,the,minimum,required,generation;public,void,trim,unreferenced,readers,throws,ioexception,try,releasable,lock,ignored,write,lock,acquire,if,closed,get,return,long,min,referenced,gen,deletion,policy,min,translog,gen,required,readers,current,assert,min,referenced,gen,get,min,file,generation,deletion,policy,requires,a,min,reference,gen,of,min,referenced,gen,but,the,lowest,gen,available,is,get,min,file,generation,assert,min,referenced,gen,current,file,generation,deletion,policy,requires,a,min,reference,gen,of,min,referenced,gen,which,is,higher,than,the,current,generation,current,file,generation,for,iterator,translog,reader,iterator,readers,iterator,iterator,has,next,translog,reader,reader,iterator,next,if,reader,get,generation,min,referenced,gen,break,iterator,remove,ioutils,close,while,handling,exception,reader,final,path,translog,path,reader,path,logger,trace,delete,translog,file,not,referenced,and,not,current,anymore,translog,path,current,sync,delete,reader,files,reader,assert,readers,is,empty,false,current,generation,min,referenced,gen,all,readers,were,cleaned,but,the,min,reference,gen,min,referenced,gen,is,not,the,current,writer,s,gen,current,generation,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex
Translog -> public void trimUnreferencedReaders() throws IOException;1541592065;Trims unreferenced translog generations by asking {@link TranslogDeletionPolicy} for the minimum_required generation;public void trimUnreferencedReaders() throws IOException {_        try (ReleasableLock ignored = writeLock.acquire()) {_            if (closed.get()) {_                _                return__            }_            long minReferencedGen = deletionPolicy.minTranslogGenRequired(readers, current)__            assert minReferencedGen >= getMinFileGeneration() :_                "deletion policy requires a minReferenceGen of [" + minReferencedGen + "] but the lowest gen available is ["_                    + getMinFileGeneration() + "]"__            assert minReferencedGen <= currentFileGeneration() :_                "deletion policy requires a minReferenceGen of [" + minReferencedGen + "] which is higher than the current generation ["_                    + currentFileGeneration() + "]"____            for (Iterator<TranslogReader> iterator = readers.iterator()_ iterator.hasNext()_ ) {_                TranslogReader reader = iterator.next()__                if (reader.getGeneration() >= minReferencedGen) {_                    break__                }_                iterator.remove()__                IOUtils.closeWhileHandlingException(reader)__                final Path translogPath = reader.path()__                logger.trace("delete translog file [{}], not referenced and not current anymore", translogPath)__                _                _                _                _                current.sync()__                deleteReaderFiles(reader)__            }_            assert readers.isEmpty() == false || current.generation == minReferencedGen :_                "all readers were cleaned but the minReferenceGen [" + minReferencedGen + "] is not the current writer's gen [" +_                    current.generation + "]"__        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_    };trims,unreferenced,translog,generations,by,asking,link,translog,deletion,policy,for,the,minimum,required,generation;public,void,trim,unreferenced,readers,throws,ioexception,try,releasable,lock,ignored,write,lock,acquire,if,closed,get,return,long,min,referenced,gen,deletion,policy,min,translog,gen,required,readers,current,assert,min,referenced,gen,get,min,file,generation,deletion,policy,requires,a,min,reference,gen,of,min,referenced,gen,but,the,lowest,gen,available,is,get,min,file,generation,assert,min,referenced,gen,current,file,generation,deletion,policy,requires,a,min,reference,gen,of,min,referenced,gen,which,is,higher,than,the,current,generation,current,file,generation,for,iterator,translog,reader,iterator,readers,iterator,iterator,has,next,translog,reader,reader,iterator,next,if,reader,get,generation,min,referenced,gen,break,iterator,remove,ioutils,close,while,handling,exception,reader,final,path,translog,path,reader,path,logger,trace,delete,translog,file,not,referenced,and,not,current,anymore,translog,path,current,sync,delete,reader,files,reader,assert,readers,is,empty,false,current,generation,min,referenced,gen,all,readers,were,cleaned,but,the,min,reference,gen,min,referenced,gen,is,not,the,current,writer,s,gen,current,generation,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex
Translog -> public void trimUnreferencedReaders() throws IOException;1542697754;Trims unreferenced translog generations by asking {@link TranslogDeletionPolicy} for the minimum_required generation;public void trimUnreferencedReaders() throws IOException {_        try (ReleasableLock ignored = writeLock.acquire()) {_            if (closed.get()) {_                _                return__            }_            long minReferencedGen = deletionPolicy.minTranslogGenRequired(readers, current)__            assert minReferencedGen >= getMinFileGeneration() :_                "deletion policy requires a minReferenceGen of [" + minReferencedGen + "] but the lowest gen available is ["_                    + getMinFileGeneration() + "]"__            assert minReferencedGen <= currentFileGeneration() :_                "deletion policy requires a minReferenceGen of [" + minReferencedGen + "] which is higher than the current generation ["_                    + currentFileGeneration() + "]"____            for (Iterator<TranslogReader> iterator = readers.iterator()_ iterator.hasNext()_ ) {_                TranslogReader reader = iterator.next()__                if (reader.getGeneration() >= minReferencedGen) {_                    break__                }_                iterator.remove()__                IOUtils.closeWhileHandlingException(reader)__                final Path translogPath = reader.path()__                logger.trace("delete translog file [{}], not referenced and not current anymore", translogPath)__                _                _                _                _                current.sync()__                deleteReaderFiles(reader)__            }_            assert readers.isEmpty() == false || current.generation == minReferencedGen :_                "all readers were cleaned but the minReferenceGen [" + minReferencedGen + "] is not the current writer's gen [" +_                    current.generation + "]"__        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_    };trims,unreferenced,translog,generations,by,asking,link,translog,deletion,policy,for,the,minimum,required,generation;public,void,trim,unreferenced,readers,throws,ioexception,try,releasable,lock,ignored,write,lock,acquire,if,closed,get,return,long,min,referenced,gen,deletion,policy,min,translog,gen,required,readers,current,assert,min,referenced,gen,get,min,file,generation,deletion,policy,requires,a,min,reference,gen,of,min,referenced,gen,but,the,lowest,gen,available,is,get,min,file,generation,assert,min,referenced,gen,current,file,generation,deletion,policy,requires,a,min,reference,gen,of,min,referenced,gen,which,is,higher,than,the,current,generation,current,file,generation,for,iterator,translog,reader,iterator,readers,iterator,iterator,has,next,translog,reader,reader,iterator,next,if,reader,get,generation,min,referenced,gen,break,iterator,remove,ioutils,close,while,handling,exception,reader,final,path,translog,path,reader,path,logger,trace,delete,translog,file,not,referenced,and,not,current,anymore,translog,path,current,sync,delete,reader,files,reader,assert,readers,is,empty,false,current,generation,min,referenced,gen,all,readers,were,cleaned,but,the,min,reference,gen,min,referenced,gen,is,not,the,current,writer,s,gen,current,generation,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex
Translog -> public void trimUnreferencedReaders() throws IOException;1542962614;Trims unreferenced translog generations by asking {@link TranslogDeletionPolicy} for the minimum_required generation;public void trimUnreferencedReaders() throws IOException {_        try (ReleasableLock ignored = writeLock.acquire()) {_            if (closed.get()) {_                _                return__            }_            long minReferencedGen = deletionPolicy.minTranslogGenRequired(readers, current)__            assert minReferencedGen >= getMinFileGeneration() :_                "deletion policy requires a minReferenceGen of [" + minReferencedGen + "] but the lowest gen available is ["_                    + getMinFileGeneration() + "]"__            assert minReferencedGen <= currentFileGeneration() :_                "deletion policy requires a minReferenceGen of [" + minReferencedGen + "] which is higher than the current generation ["_                    + currentFileGeneration() + "]"____            for (Iterator<TranslogReader> iterator = readers.iterator()_ iterator.hasNext()_ ) {_                TranslogReader reader = iterator.next()__                if (reader.getGeneration() >= minReferencedGen) {_                    break__                }_                iterator.remove()__                IOUtils.closeWhileHandlingException(reader)__                final Path translogPath = reader.path()__                logger.trace("delete translog file [{}], not referenced and not current anymore", translogPath)__                _                _                _                _                current.sync()__                deleteReaderFiles(reader)__            }_            assert readers.isEmpty() == false || current.generation == minReferencedGen :_                "all readers were cleaned but the minReferenceGen [" + minReferencedGen + "] is not the current writer's gen [" +_                    current.generation + "]"__        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_    };trims,unreferenced,translog,generations,by,asking,link,translog,deletion,policy,for,the,minimum,required,generation;public,void,trim,unreferenced,readers,throws,ioexception,try,releasable,lock,ignored,write,lock,acquire,if,closed,get,return,long,min,referenced,gen,deletion,policy,min,translog,gen,required,readers,current,assert,min,referenced,gen,get,min,file,generation,deletion,policy,requires,a,min,reference,gen,of,min,referenced,gen,but,the,lowest,gen,available,is,get,min,file,generation,assert,min,referenced,gen,current,file,generation,deletion,policy,requires,a,min,reference,gen,of,min,referenced,gen,which,is,higher,than,the,current,generation,current,file,generation,for,iterator,translog,reader,iterator,readers,iterator,iterator,has,next,translog,reader,reader,iterator,next,if,reader,get,generation,min,referenced,gen,break,iterator,remove,ioutils,close,while,handling,exception,reader,final,path,translog,path,reader,path,logger,trace,delete,translog,file,not,referenced,and,not,current,anymore,translog,path,current,sync,delete,reader,files,reader,assert,readers,is,empty,false,current,generation,min,referenced,gen,all,readers,were,cleaned,but,the,min,reference,gen,min,referenced,gen,is,not,the,current,writer,s,gen,current,generation,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex
Translog -> public void trimUnreferencedReaders() throws IOException;1545236365;Trims unreferenced translog generations by asking {@link TranslogDeletionPolicy} for the minimum_required generation;public void trimUnreferencedReaders() throws IOException {_        try (ReleasableLock ignored = writeLock.acquire()) {_            if (closed.get()) {_                _                return__            }_            long minReferencedGen = deletionPolicy.minTranslogGenRequired(readers, current)__            assert minReferencedGen >= getMinFileGeneration() :_                "deletion policy requires a minReferenceGen of [" + minReferencedGen + "] but the lowest gen available is ["_                    + getMinFileGeneration() + "]"__            assert minReferencedGen <= currentFileGeneration() :_                "deletion policy requires a minReferenceGen of [" + minReferencedGen + "] which is higher than the current generation ["_                    + currentFileGeneration() + "]"____            for (Iterator<TranslogReader> iterator = readers.iterator()_ iterator.hasNext()_ ) {_                TranslogReader reader = iterator.next()__                if (reader.getGeneration() >= minReferencedGen) {_                    break__                }_                iterator.remove()__                IOUtils.closeWhileHandlingException(reader)__                final Path translogPath = reader.path()__                logger.trace("delete translog file [{}], not referenced and not current anymore", translogPath)__                _                _                _                _                current.sync()__                deleteReaderFiles(reader)__            }_            assert readers.isEmpty() == false || current.generation == minReferencedGen :_                "all readers were cleaned but the minReferenceGen [" + minReferencedGen + "] is not the current writer's gen [" +_                    current.generation + "]"__        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_    };trims,unreferenced,translog,generations,by,asking,link,translog,deletion,policy,for,the,minimum,required,generation;public,void,trim,unreferenced,readers,throws,ioexception,try,releasable,lock,ignored,write,lock,acquire,if,closed,get,return,long,min,referenced,gen,deletion,policy,min,translog,gen,required,readers,current,assert,min,referenced,gen,get,min,file,generation,deletion,policy,requires,a,min,reference,gen,of,min,referenced,gen,but,the,lowest,gen,available,is,get,min,file,generation,assert,min,referenced,gen,current,file,generation,deletion,policy,requires,a,min,reference,gen,of,min,referenced,gen,which,is,higher,than,the,current,generation,current,file,generation,for,iterator,translog,reader,iterator,readers,iterator,iterator,has,next,translog,reader,reader,iterator,next,if,reader,get,generation,min,referenced,gen,break,iterator,remove,ioutils,close,while,handling,exception,reader,final,path,translog,path,reader,path,logger,trace,delete,translog,file,not,referenced,and,not,current,anymore,translog,path,current,sync,delete,reader,files,reader,assert,readers,is,empty,false,current,generation,min,referenced,gen,all,readers,were,cleaned,but,the,min,reference,gen,min,referenced,gen,is,not,the,current,writer,s,gen,current,generation,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex
Translog -> Delete -> public Delete(String type, String id, long seqNo, long primaryTerm, Term uid);1524684173;utility for testing;public Delete(String type, String id, long seqNo, long primaryTerm, Term uid) {_            this(type, id, uid, seqNo, primaryTerm, Versions.MATCH_ANY, VersionType.INTERNAL)__        };utility,for,testing;public,delete,string,type,string,id,long,seq,no,long,primary,term,term,uid,this,type,id,uid,seq,no,primary,term,versions,version,type,internal
Translog -> Delete -> public Delete(String type, String id, long seqNo, long primaryTerm, Term uid);1525334055;utility for testing;public Delete(String type, String id, long seqNo, long primaryTerm, Term uid) {_            this(type, id, uid, seqNo, primaryTerm, Versions.MATCH_ANY, VersionType.INTERNAL)__        };utility,for,testing;public,delete,string,type,string,id,long,seq,no,long,primary,term,term,uid,this,type,id,uid,seq,no,primary,term,versions,version,type,internal
Translog -> Delete -> public Delete(String type, String id, long seqNo, long primaryTerm, Term uid);1528706846;utility for testing;public Delete(String type, String id, long seqNo, long primaryTerm, Term uid) {_            this(type, id, uid, seqNo, primaryTerm, Versions.MATCH_ANY, VersionType.INTERNAL)__        };utility,for,testing;public,delete,string,type,string,id,long,seq,no,long,primary,term,term,uid,this,type,id,uid,seq,no,primary,term,versions,version,type,internal
Translog -> Delete -> public Delete(String type, String id, long seqNo, long primaryTerm, Term uid);1531910483;utility for testing;public Delete(String type, String id, long seqNo, long primaryTerm, Term uid) {_            this(type, id, uid, seqNo, primaryTerm, Versions.MATCH_ANY)__        };utility,for,testing;public,delete,string,type,string,id,long,seq,no,long,primary,term,term,uid,this,type,id,uid,seq,no,primary,term,versions
Translog -> Delete -> public Delete(String type, String id, long seqNo, long primaryTerm, Term uid);1533295538;utility for testing;public Delete(String type, String id, long seqNo, long primaryTerm, Term uid) {_            this(type, id, uid, seqNo, primaryTerm, Versions.MATCH_ANY)__        };utility,for,testing;public,delete,string,type,string,id,long,seq,no,long,primary,term,term,uid,this,type,id,uid,seq,no,primary,term,versions
Translog -> Delete -> public Delete(String type, String id, long seqNo, long primaryTerm, Term uid);1533641732;utility for testing;public Delete(String type, String id, long seqNo, long primaryTerm, Term uid) {_            this(type, id, uid, seqNo, primaryTerm, Versions.MATCH_ANY)__        };utility,for,testing;public,delete,string,type,string,id,long,seq,no,long,primary,term,term,uid,this,type,id,uid,seq,no,primary,term,versions
Translog -> Delete -> public Delete(String type, String id, long seqNo, long primaryTerm, Term uid);1534848846;utility for testing;public Delete(String type, String id, long seqNo, long primaryTerm, Term uid) {_            this(type, id, uid, seqNo, primaryTerm, Versions.MATCH_ANY)__        };utility,for,testing;public,delete,string,type,string,id,long,seq,no,long,primary,term,term,uid,this,type,id,uid,seq,no,primary,term,versions
Translog -> Delete -> public Delete(String type, String id, long seqNo, long primaryTerm, Term uid);1535046779;utility for testing;public Delete(String type, String id, long seqNo, long primaryTerm, Term uid) {_            this(type, id, uid, seqNo, primaryTerm, Versions.MATCH_ANY)__        };utility,for,testing;public,delete,string,type,string,id,long,seq,no,long,primary,term,term,uid,this,type,id,uid,seq,no,primary,term,versions
Translog -> Delete -> public Delete(String type, String id, long seqNo, long primaryTerm, Term uid);1535723122;utility for testing;public Delete(String type, String id, long seqNo, long primaryTerm, Term uid) {_            this(type, id, uid, seqNo, primaryTerm, Versions.MATCH_ANY)__        };utility,for,testing;public,delete,string,type,string,id,long,seq,no,long,primary,term,term,uid,this,type,id,uid,seq,no,primary,term,versions
Translog -> Delete -> public Delete(String type, String id, long seqNo, long primaryTerm, Term uid);1537806831;utility for testing;public Delete(String type, String id, long seqNo, long primaryTerm, Term uid) {_            this(type, id, uid, seqNo, primaryTerm, Versions.MATCH_ANY)__        };utility,for,testing;public,delete,string,type,string,id,long,seq,no,long,primary,term,term,uid,this,type,id,uid,seq,no,primary,term,versions
Translog -> Delete -> public Delete(String type, String id, long seqNo, long primaryTerm, Term uid);1541592065;utility for testing;public Delete(String type, String id, long seqNo, long primaryTerm, Term uid) {_            this(type, id, uid, seqNo, primaryTerm, Versions.MATCH_ANY)__        };utility,for,testing;public,delete,string,type,string,id,long,seq,no,long,primary,term,term,uid,this,type,id,uid,seq,no,primary,term,versions
Translog -> Delete -> public Delete(String type, String id, long seqNo, long primaryTerm, Term uid);1542697754;utility for testing;public Delete(String type, String id, long seqNo, long primaryTerm, Term uid) {_            this(type, id, uid, seqNo, primaryTerm, Versions.MATCH_ANY)__        };utility,for,testing;public,delete,string,type,string,id,long,seq,no,long,primary,term,term,uid,this,type,id,uid,seq,no,primary,term,versions
Translog -> Delete -> public Delete(String type, String id, long seqNo, long primaryTerm, Term uid);1542962614;utility for testing;public Delete(String type, String id, long seqNo, long primaryTerm, Term uid) {_            this(type, id, uid, seqNo, primaryTerm, Versions.MATCH_ANY)__        };utility,for,testing;public,delete,string,type,string,id,long,seq,no,long,primary,term,term,uid,this,type,id,uid,seq,no,primary,term,versions
Translog -> Delete -> public Delete(String type, String id, long seqNo, long primaryTerm, Term uid);1545236365;utility for testing;public Delete(String type, String id, long seqNo, long primaryTerm, Term uid) {_            this(type, id, uid, seqNo, primaryTerm, Versions.MATCH_ANY)__        };utility,for,testing;public,delete,string,type,string,id,long,seq,no,long,primary,term,term,uid,this,type,id,uid,seq,no,primary,term,versions
Translog -> public static List<Operation> readOperations(StreamInput input, String source) throws IOException;1533641732;Reads a list of operations written with {@link #writeOperations(StreamOutput, List)};public static List<Operation> readOperations(StreamInput input, String source) throws IOException {_        ArrayList<Operation> operations = new ArrayList<>()__        int numOps = input.readInt()__        final BufferedChecksumStreamInput checksumStreamInput = new BufferedChecksumStreamInput(input, source)__        for (int i = 0_ i < numOps_ i++) {_            operations.add(readOperation(checksumStreamInput))__        }_        return operations__    };reads,a,list,of,operations,written,with,link,write,operations,stream,output,list;public,static,list,operation,read,operations,stream,input,input,string,source,throws,ioexception,array,list,operation,operations,new,array,list,int,num,ops,input,read,int,final,buffered,checksum,stream,input,checksum,stream,input,new,buffered,checksum,stream,input,input,source,for,int,i,0,i,num,ops,i,operations,add,read,operation,checksum,stream,input,return,operations
Translog -> public static List<Operation> readOperations(StreamInput input, String source) throws IOException;1534848846;Reads a list of operations written with {@link #writeOperations(StreamOutput, List)};public static List<Operation> readOperations(StreamInput input, String source) throws IOException {_        ArrayList<Operation> operations = new ArrayList<>()__        int numOps = input.readInt()__        final BufferedChecksumStreamInput checksumStreamInput = new BufferedChecksumStreamInput(input, source)__        for (int i = 0_ i < numOps_ i++) {_            operations.add(readOperation(checksumStreamInput))__        }_        return operations__    };reads,a,list,of,operations,written,with,link,write,operations,stream,output,list;public,static,list,operation,read,operations,stream,input,input,string,source,throws,ioexception,array,list,operation,operations,new,array,list,int,num,ops,input,read,int,final,buffered,checksum,stream,input,checksum,stream,input,new,buffered,checksum,stream,input,input,source,for,int,i,0,i,num,ops,i,operations,add,read,operation,checksum,stream,input,return,operations
Translog -> public static List<Operation> readOperations(StreamInput input, String source) throws IOException;1535046779;Reads a list of operations written with {@link #writeOperations(StreamOutput, List)};public static List<Operation> readOperations(StreamInput input, String source) throws IOException {_        ArrayList<Operation> operations = new ArrayList<>()__        int numOps = input.readInt()__        final BufferedChecksumStreamInput checksumStreamInput = new BufferedChecksumStreamInput(input, source)__        for (int i = 0_ i < numOps_ i++) {_            operations.add(readOperation(checksumStreamInput))__        }_        return operations__    };reads,a,list,of,operations,written,with,link,write,operations,stream,output,list;public,static,list,operation,read,operations,stream,input,input,string,source,throws,ioexception,array,list,operation,operations,new,array,list,int,num,ops,input,read,int,final,buffered,checksum,stream,input,checksum,stream,input,new,buffered,checksum,stream,input,input,source,for,int,i,0,i,num,ops,i,operations,add,read,operation,checksum,stream,input,return,operations
Translog -> public static List<Operation> readOperations(StreamInput input, String source) throws IOException;1535723122;Reads a list of operations written with {@link #writeOperations(StreamOutput, List)};public static List<Operation> readOperations(StreamInput input, String source) throws IOException {_        ArrayList<Operation> operations = new ArrayList<>()__        int numOps = input.readInt()__        final BufferedChecksumStreamInput checksumStreamInput = new BufferedChecksumStreamInput(input, source)__        for (int i = 0_ i < numOps_ i++) {_            operations.add(readOperation(checksumStreamInput))__        }_        return operations__    };reads,a,list,of,operations,written,with,link,write,operations,stream,output,list;public,static,list,operation,read,operations,stream,input,input,string,source,throws,ioexception,array,list,operation,operations,new,array,list,int,num,ops,input,read,int,final,buffered,checksum,stream,input,checksum,stream,input,new,buffered,checksum,stream,input,input,source,for,int,i,0,i,num,ops,i,operations,add,read,operation,checksum,stream,input,return,operations
Translog -> public static List<Operation> readOperations(StreamInput input, String source) throws IOException;1537806831;Reads a list of operations written with {@link #writeOperations(StreamOutput, List)};public static List<Operation> readOperations(StreamInput input, String source) throws IOException {_        ArrayList<Operation> operations = new ArrayList<>()__        int numOps = input.readInt()__        final BufferedChecksumStreamInput checksumStreamInput = new BufferedChecksumStreamInput(input, source)__        for (int i = 0_ i < numOps_ i++) {_            operations.add(readOperation(checksumStreamInput))__        }_        return operations__    };reads,a,list,of,operations,written,with,link,write,operations,stream,output,list;public,static,list,operation,read,operations,stream,input,input,string,source,throws,ioexception,array,list,operation,operations,new,array,list,int,num,ops,input,read,int,final,buffered,checksum,stream,input,checksum,stream,input,new,buffered,checksum,stream,input,input,source,for,int,i,0,i,num,ops,i,operations,add,read,operation,checksum,stream,input,return,operations
Translog -> public static List<Operation> readOperations(StreamInput input, String source) throws IOException;1541592065;Reads a list of operations written with {@link #writeOperations(StreamOutput, List)};public static List<Operation> readOperations(StreamInput input, String source) throws IOException {_        ArrayList<Operation> operations = new ArrayList<>()__        int numOps = input.readInt()__        final BufferedChecksumStreamInput checksumStreamInput = new BufferedChecksumStreamInput(input, source)__        for (int i = 0_ i < numOps_ i++) {_            operations.add(readOperation(checksumStreamInput))__        }_        return operations__    };reads,a,list,of,operations,written,with,link,write,operations,stream,output,list;public,static,list,operation,read,operations,stream,input,input,string,source,throws,ioexception,array,list,operation,operations,new,array,list,int,num,ops,input,read,int,final,buffered,checksum,stream,input,checksum,stream,input,new,buffered,checksum,stream,input,input,source,for,int,i,0,i,num,ops,i,operations,add,read,operation,checksum,stream,input,return,operations
Translog -> public static List<Operation> readOperations(StreamInput input, String source) throws IOException;1542697754;Reads a list of operations written with {@link #writeOperations(StreamOutput, List)};public static List<Operation> readOperations(StreamInput input, String source) throws IOException {_        ArrayList<Operation> operations = new ArrayList<>()__        int numOps = input.readInt()__        final BufferedChecksumStreamInput checksumStreamInput = new BufferedChecksumStreamInput(input, source)__        for (int i = 0_ i < numOps_ i++) {_            operations.add(readOperation(checksumStreamInput))__        }_        return operations__    };reads,a,list,of,operations,written,with,link,write,operations,stream,output,list;public,static,list,operation,read,operations,stream,input,input,string,source,throws,ioexception,array,list,operation,operations,new,array,list,int,num,ops,input,read,int,final,buffered,checksum,stream,input,checksum,stream,input,new,buffered,checksum,stream,input,input,source,for,int,i,0,i,num,ops,i,operations,add,read,operation,checksum,stream,input,return,operations
Translog -> public static List<Operation> readOperations(StreamInput input, String source) throws IOException;1542962614;Reads a list of operations written with {@link #writeOperations(StreamOutput, List)};public static List<Operation> readOperations(StreamInput input, String source) throws IOException {_        ArrayList<Operation> operations = new ArrayList<>()__        int numOps = input.readInt()__        final BufferedChecksumStreamInput checksumStreamInput = new BufferedChecksumStreamInput(input, source)__        for (int i = 0_ i < numOps_ i++) {_            operations.add(readOperation(checksumStreamInput))__        }_        return operations__    };reads,a,list,of,operations,written,with,link,write,operations,stream,output,list;public,static,list,operation,read,operations,stream,input,input,string,source,throws,ioexception,array,list,operation,operations,new,array,list,int,num,ops,input,read,int,final,buffered,checksum,stream,input,checksum,stream,input,new,buffered,checksum,stream,input,input,source,for,int,i,0,i,num,ops,i,operations,add,read,operation,checksum,stream,input,return,operations
Translog -> public static List<Operation> readOperations(StreamInput input, String source) throws IOException;1545236365;Reads a list of operations written with {@link #writeOperations(StreamOutput, List)};public static List<Operation> readOperations(StreamInput input, String source) throws IOException {_        ArrayList<Operation> operations = new ArrayList<>()__        int numOps = input.readInt()__        final BufferedChecksumStreamInput checksumStreamInput = new BufferedChecksumStreamInput(input, source)__        for (int i = 0_ i < numOps_ i++) {_            operations.add(readOperation(checksumStreamInput))__        }_        return operations__    };reads,a,list,of,operations,written,with,link,write,operations,stream,output,list;public,static,list,operation,read,operations,stream,input,input,string,source,throws,ioexception,array,list,operation,operations,new,array,list,int,num,ops,input,read,int,final,buffered,checksum,stream,input,checksum,stream,input,new,buffered,checksum,stream,input,input,source,for,int,i,0,i,num,ops,i,operations,add,read,operation,checksum,stream,input,return,operations
Translog -> TranslogWriter createWriter(long fileGeneration) throws IOException;1524684173;Creates a new translog for the specified generation.__@param fileGeneration the translog generation_@return a writer for the new translog_@throws IOException if creating the translog failed;TranslogWriter createWriter(long fileGeneration) throws IOException {_        final TranslogWriter writer = createWriter(fileGeneration, getMinFileGeneration(), globalCheckpointSupplier.getAsLong())__        assert writer.sizeInBytes() == DEFAULT_HEADER_SIZE_IN_BYTES : "Mismatch translog header size_ " +_            "empty translog size [" + writer.sizeInBytes() + ", header size [" + DEFAULT_HEADER_SIZE_IN_BYTES + "]"__        return writer__    };creates,a,new,translog,for,the,specified,generation,param,file,generation,the,translog,generation,return,a,writer,for,the,new,translog,throws,ioexception,if,creating,the,translog,failed;translog,writer,create,writer,long,file,generation,throws,ioexception,final,translog,writer,writer,create,writer,file,generation,get,min,file,generation,global,checkpoint,supplier,get,as,long,assert,writer,size,in,bytes,mismatch,translog,header,size,empty,translog,size,writer,size,in,bytes,header,size,return,writer
Translog -> TranslogWriter createWriter(long fileGeneration) throws IOException;1525334055;Creates a new translog for the specified generation.__@param fileGeneration the translog generation_@return a writer for the new translog_@throws IOException if creating the translog failed;TranslogWriter createWriter(long fileGeneration) throws IOException {_        final TranslogWriter writer = createWriter(fileGeneration, getMinFileGeneration(), globalCheckpointSupplier.getAsLong())__        assert writer.sizeInBytes() == DEFAULT_HEADER_SIZE_IN_BYTES : "Mismatch translog header size_ " +_            "empty translog size [" + writer.sizeInBytes() + ", header size [" + DEFAULT_HEADER_SIZE_IN_BYTES + "]"__        return writer__    };creates,a,new,translog,for,the,specified,generation,param,file,generation,the,translog,generation,return,a,writer,for,the,new,translog,throws,ioexception,if,creating,the,translog,failed;translog,writer,create,writer,long,file,generation,throws,ioexception,final,translog,writer,writer,create,writer,file,generation,get,min,file,generation,global,checkpoint,supplier,get,as,long,assert,writer,size,in,bytes,mismatch,translog,header,size,empty,translog,size,writer,size,in,bytes,header,size,return,writer
Translog -> TranslogWriter createWriter(long fileGeneration) throws IOException;1528706846;Creates a new translog for the specified generation.__@param fileGeneration the translog generation_@return a writer for the new translog_@throws IOException if creating the translog failed;TranslogWriter createWriter(long fileGeneration) throws IOException {_        final TranslogWriter writer = createWriter(fileGeneration, getMinFileGeneration(), globalCheckpointSupplier.getAsLong())__        assert writer.sizeInBytes() == DEFAULT_HEADER_SIZE_IN_BYTES : "Mismatch translog header size_ " +_            "empty translog size [" + writer.sizeInBytes() + ", header size [" + DEFAULT_HEADER_SIZE_IN_BYTES + "]"__        return writer__    };creates,a,new,translog,for,the,specified,generation,param,file,generation,the,translog,generation,return,a,writer,for,the,new,translog,throws,ioexception,if,creating,the,translog,failed;translog,writer,create,writer,long,file,generation,throws,ioexception,final,translog,writer,writer,create,writer,file,generation,get,min,file,generation,global,checkpoint,supplier,get,as,long,assert,writer,size,in,bytes,mismatch,translog,header,size,empty,translog,size,writer,size,in,bytes,header,size,return,writer
Translog -> TranslogWriter createWriter(long fileGeneration) throws IOException;1531910483;Creates a new translog for the specified generation.__@param fileGeneration the translog generation_@return a writer for the new translog_@throws IOException if creating the translog failed;TranslogWriter createWriter(long fileGeneration) throws IOException {_        final TranslogWriter writer = createWriter(fileGeneration, getMinFileGeneration(), globalCheckpointSupplier.getAsLong())__        assert writer.sizeInBytes() == DEFAULT_HEADER_SIZE_IN_BYTES : "Mismatch translog header size_ " +_            "empty translog size [" + writer.sizeInBytes() + ", header size [" + DEFAULT_HEADER_SIZE_IN_BYTES + "]"__        return writer__    };creates,a,new,translog,for,the,specified,generation,param,file,generation,the,translog,generation,return,a,writer,for,the,new,translog,throws,ioexception,if,creating,the,translog,failed;translog,writer,create,writer,long,file,generation,throws,ioexception,final,translog,writer,writer,create,writer,file,generation,get,min,file,generation,global,checkpoint,supplier,get,as,long,assert,writer,size,in,bytes,mismatch,translog,header,size,empty,translog,size,writer,size,in,bytes,header,size,return,writer
Translog -> TranslogWriter createWriter(long fileGeneration) throws IOException;1533295538;Creates a new translog for the specified generation.__@param fileGeneration the translog generation_@return a writer for the new translog_@throws IOException if creating the translog failed;TranslogWriter createWriter(long fileGeneration) throws IOException {_        final TranslogWriter writer = createWriter(fileGeneration, getMinFileGeneration(), globalCheckpointSupplier.getAsLong())__        assert writer.sizeInBytes() == DEFAULT_HEADER_SIZE_IN_BYTES : "Mismatch translog header size_ " +_            "empty translog size [" + writer.sizeInBytes() + ", header size [" + DEFAULT_HEADER_SIZE_IN_BYTES + "]"__        return writer__    };creates,a,new,translog,for,the,specified,generation,param,file,generation,the,translog,generation,return,a,writer,for,the,new,translog,throws,ioexception,if,creating,the,translog,failed;translog,writer,create,writer,long,file,generation,throws,ioexception,final,translog,writer,writer,create,writer,file,generation,get,min,file,generation,global,checkpoint,supplier,get,as,long,assert,writer,size,in,bytes,mismatch,translog,header,size,empty,translog,size,writer,size,in,bytes,header,size,return,writer
Translog -> TranslogWriter createWriter(long fileGeneration) throws IOException;1533641732;Creates a new translog for the specified generation.__@param fileGeneration the translog generation_@return a writer for the new translog_@throws IOException if creating the translog failed;TranslogWriter createWriter(long fileGeneration) throws IOException {_        final TranslogWriter writer = createWriter(fileGeneration, getMinFileGeneration(), globalCheckpointSupplier.getAsLong())__        assert writer.sizeInBytes() == DEFAULT_HEADER_SIZE_IN_BYTES : "Mismatch translog header size_ " +_            "empty translog size [" + writer.sizeInBytes() + ", header size [" + DEFAULT_HEADER_SIZE_IN_BYTES + "]"__        return writer__    };creates,a,new,translog,for,the,specified,generation,param,file,generation,the,translog,generation,return,a,writer,for,the,new,translog,throws,ioexception,if,creating,the,translog,failed;translog,writer,create,writer,long,file,generation,throws,ioexception,final,translog,writer,writer,create,writer,file,generation,get,min,file,generation,global,checkpoint,supplier,get,as,long,assert,writer,size,in,bytes,mismatch,translog,header,size,empty,translog,size,writer,size,in,bytes,header,size,return,writer
Translog -> TranslogWriter createWriter(long fileGeneration) throws IOException;1534848846;Creates a new translog for the specified generation.__@param fileGeneration the translog generation_@return a writer for the new translog_@throws IOException if creating the translog failed;TranslogWriter createWriter(long fileGeneration) throws IOException {_        final TranslogWriter writer = createWriter(fileGeneration, getMinFileGeneration(), globalCheckpointSupplier.getAsLong())__        assert writer.sizeInBytes() == DEFAULT_HEADER_SIZE_IN_BYTES : "Mismatch translog header size_ " +_            "empty translog size [" + writer.sizeInBytes() + ", header size [" + DEFAULT_HEADER_SIZE_IN_BYTES + "]"__        return writer__    };creates,a,new,translog,for,the,specified,generation,param,file,generation,the,translog,generation,return,a,writer,for,the,new,translog,throws,ioexception,if,creating,the,translog,failed;translog,writer,create,writer,long,file,generation,throws,ioexception,final,translog,writer,writer,create,writer,file,generation,get,min,file,generation,global,checkpoint,supplier,get,as,long,assert,writer,size,in,bytes,mismatch,translog,header,size,empty,translog,size,writer,size,in,bytes,header,size,return,writer
Translog -> TranslogWriter createWriter(long fileGeneration) throws IOException;1535046779;Creates a new translog for the specified generation.__@param fileGeneration the translog generation_@return a writer for the new translog_@throws IOException if creating the translog failed;TranslogWriter createWriter(long fileGeneration) throws IOException {_        final TranslogWriter writer = createWriter(fileGeneration, getMinFileGeneration(), globalCheckpointSupplier.getAsLong())__        assert writer.sizeInBytes() == DEFAULT_HEADER_SIZE_IN_BYTES : "Mismatch translog header size_ " +_            "empty translog size [" + writer.sizeInBytes() + ", header size [" + DEFAULT_HEADER_SIZE_IN_BYTES + "]"__        return writer__    };creates,a,new,translog,for,the,specified,generation,param,file,generation,the,translog,generation,return,a,writer,for,the,new,translog,throws,ioexception,if,creating,the,translog,failed;translog,writer,create,writer,long,file,generation,throws,ioexception,final,translog,writer,writer,create,writer,file,generation,get,min,file,generation,global,checkpoint,supplier,get,as,long,assert,writer,size,in,bytes,mismatch,translog,header,size,empty,translog,size,writer,size,in,bytes,header,size,return,writer
Translog -> TranslogWriter createWriter(long fileGeneration) throws IOException;1535723122;Creates a new translog for the specified generation.__@param fileGeneration the translog generation_@return a writer for the new translog_@throws IOException if creating the translog failed;TranslogWriter createWriter(long fileGeneration) throws IOException {_        final TranslogWriter writer = createWriter(fileGeneration, getMinFileGeneration(), globalCheckpointSupplier.getAsLong())__        assert writer.sizeInBytes() == DEFAULT_HEADER_SIZE_IN_BYTES : "Mismatch translog header size_ " +_            "empty translog size [" + writer.sizeInBytes() + ", header size [" + DEFAULT_HEADER_SIZE_IN_BYTES + "]"__        return writer__    };creates,a,new,translog,for,the,specified,generation,param,file,generation,the,translog,generation,return,a,writer,for,the,new,translog,throws,ioexception,if,creating,the,translog,failed;translog,writer,create,writer,long,file,generation,throws,ioexception,final,translog,writer,writer,create,writer,file,generation,get,min,file,generation,global,checkpoint,supplier,get,as,long,assert,writer,size,in,bytes,mismatch,translog,header,size,empty,translog,size,writer,size,in,bytes,header,size,return,writer
Translog -> TranslogWriter createWriter(long fileGeneration) throws IOException;1537806831;Creates a new translog for the specified generation.__@param fileGeneration the translog generation_@return a writer for the new translog_@throws IOException if creating the translog failed;TranslogWriter createWriter(long fileGeneration) throws IOException {_        final TranslogWriter writer = createWriter(fileGeneration, getMinFileGeneration(), globalCheckpointSupplier.getAsLong())__        assert writer.sizeInBytes() == DEFAULT_HEADER_SIZE_IN_BYTES : "Mismatch translog header size_ " +_            "empty translog size [" + writer.sizeInBytes() + ", header size [" + DEFAULT_HEADER_SIZE_IN_BYTES + "]"__        return writer__    };creates,a,new,translog,for,the,specified,generation,param,file,generation,the,translog,generation,return,a,writer,for,the,new,translog,throws,ioexception,if,creating,the,translog,failed;translog,writer,create,writer,long,file,generation,throws,ioexception,final,translog,writer,writer,create,writer,file,generation,get,min,file,generation,global,checkpoint,supplier,get,as,long,assert,writer,size,in,bytes,mismatch,translog,header,size,empty,translog,size,writer,size,in,bytes,header,size,return,writer
Translog -> TranslogWriter createWriter(long fileGeneration) throws IOException;1541592065;Creates a new translog for the specified generation.__@param fileGeneration the translog generation_@return a writer for the new translog_@throws IOException if creating the translog failed;TranslogWriter createWriter(long fileGeneration) throws IOException {_        final TranslogWriter writer = createWriter(fileGeneration, getMinFileGeneration(), globalCheckpointSupplier.getAsLong())__        assert writer.sizeInBytes() == DEFAULT_HEADER_SIZE_IN_BYTES : "Mismatch translog header size_ " +_            "empty translog size [" + writer.sizeInBytes() + ", header size [" + DEFAULT_HEADER_SIZE_IN_BYTES + "]"__        return writer__    };creates,a,new,translog,for,the,specified,generation,param,file,generation,the,translog,generation,return,a,writer,for,the,new,translog,throws,ioexception,if,creating,the,translog,failed;translog,writer,create,writer,long,file,generation,throws,ioexception,final,translog,writer,writer,create,writer,file,generation,get,min,file,generation,global,checkpoint,supplier,get,as,long,assert,writer,size,in,bytes,mismatch,translog,header,size,empty,translog,size,writer,size,in,bytes,header,size,return,writer
Translog -> TranslogWriter createWriter(long fileGeneration) throws IOException;1542697754;Creates a new translog for the specified generation.__@param fileGeneration the translog generation_@return a writer for the new translog_@throws IOException if creating the translog failed;TranslogWriter createWriter(long fileGeneration) throws IOException {_        final TranslogWriter writer = createWriter(fileGeneration, getMinFileGeneration(), globalCheckpointSupplier.getAsLong())__        assert writer.sizeInBytes() == DEFAULT_HEADER_SIZE_IN_BYTES : "Mismatch translog header size_ " +_            "empty translog size [" + writer.sizeInBytes() + ", header size [" + DEFAULT_HEADER_SIZE_IN_BYTES + "]"__        return writer__    };creates,a,new,translog,for,the,specified,generation,param,file,generation,the,translog,generation,return,a,writer,for,the,new,translog,throws,ioexception,if,creating,the,translog,failed;translog,writer,create,writer,long,file,generation,throws,ioexception,final,translog,writer,writer,create,writer,file,generation,get,min,file,generation,global,checkpoint,supplier,get,as,long,assert,writer,size,in,bytes,mismatch,translog,header,size,empty,translog,size,writer,size,in,bytes,header,size,return,writer
Translog -> TranslogWriter createWriter(long fileGeneration) throws IOException;1542962614;Creates a new translog for the specified generation.__@param fileGeneration the translog generation_@return a writer for the new translog_@throws IOException if creating the translog failed;TranslogWriter createWriter(long fileGeneration) throws IOException {_        final TranslogWriter writer = createWriter(fileGeneration, getMinFileGeneration(), globalCheckpointSupplier.getAsLong())__        assert writer.sizeInBytes() == DEFAULT_HEADER_SIZE_IN_BYTES : "Mismatch translog header size_ " +_            "empty translog size [" + writer.sizeInBytes() + ", header size [" + DEFAULT_HEADER_SIZE_IN_BYTES + "]"__        return writer__    };creates,a,new,translog,for,the,specified,generation,param,file,generation,the,translog,generation,return,a,writer,for,the,new,translog,throws,ioexception,if,creating,the,translog,failed;translog,writer,create,writer,long,file,generation,throws,ioexception,final,translog,writer,writer,create,writer,file,generation,get,min,file,generation,global,checkpoint,supplier,get,as,long,assert,writer,size,in,bytes,mismatch,translog,header,size,empty,translog,size,writer,size,in,bytes,header,size,return,writer
Translog -> TranslogWriter createWriter(long fileGeneration) throws IOException;1545236365;Creates a new translog for the specified generation.__@param fileGeneration the translog generation_@return a writer for the new translog_@throws IOException if creating the translog failed;TranslogWriter createWriter(long fileGeneration) throws IOException {_        final TranslogWriter writer = createWriter(fileGeneration, getMinFileGeneration(), globalCheckpointSupplier.getAsLong())__        assert writer.sizeInBytes() == DEFAULT_HEADER_SIZE_IN_BYTES : "Mismatch translog header size_ " +_            "empty translog size [" + writer.sizeInBytes() + ", header size [" + DEFAULT_HEADER_SIZE_IN_BYTES + "]"__        return writer__    };creates,a,new,translog,for,the,specified,generation,param,file,generation,the,translog,generation,return,a,writer,for,the,new,translog,throws,ioexception,if,creating,the,translog,failed;translog,writer,create,writer,long,file,generation,throws,ioexception,final,translog,writer,writer,create,writer,file,generation,get,min,file,generation,global,checkpoint,supplier,get,as,long,assert,writer,size,in,bytes,mismatch,translog,header,size,empty,translog,size,writer,size,in,bytes,header,size,return,writer
Translog -> public long getLastSyncedGlobalCheckpoint();1524684173;The last synced checkpoint for this translog.__@return the last synced checkpoint;public long getLastSyncedGlobalCheckpoint() {_        try (ReleasableLock ignored = readLock.acquire()) {_            return current.getLastSyncedCheckpoint().globalCheckpoint__        }_    };the,last,synced,checkpoint,for,this,translog,return,the,last,synced,checkpoint;public,long,get,last,synced,global,checkpoint,try,releasable,lock,ignored,read,lock,acquire,return,current,get,last,synced,checkpoint,global,checkpoint
Translog -> public long getLastSyncedGlobalCheckpoint();1525334055;The last synced checkpoint for this translog.__@return the last synced checkpoint;public long getLastSyncedGlobalCheckpoint() {_        try (ReleasableLock ignored = readLock.acquire()) {_            return current.getLastSyncedCheckpoint().globalCheckpoint__        }_    };the,last,synced,checkpoint,for,this,translog,return,the,last,synced,checkpoint;public,long,get,last,synced,global,checkpoint,try,releasable,lock,ignored,read,lock,acquire,return,current,get,last,synced,checkpoint,global,checkpoint
Translog -> public long getLastSyncedGlobalCheckpoint();1528706846;The last synced checkpoint for this translog.__@return the last synced checkpoint;public long getLastSyncedGlobalCheckpoint() {_        try (ReleasableLock ignored = readLock.acquire()) {_            return current.getLastSyncedCheckpoint().globalCheckpoint__        }_    };the,last,synced,checkpoint,for,this,translog,return,the,last,synced,checkpoint;public,long,get,last,synced,global,checkpoint,try,releasable,lock,ignored,read,lock,acquire,return,current,get,last,synced,checkpoint,global,checkpoint
Translog -> public long getLastSyncedGlobalCheckpoint();1531910483;The last synced checkpoint for this translog.__@return the last synced checkpoint;public long getLastSyncedGlobalCheckpoint() {_        try (ReleasableLock ignored = readLock.acquire()) {_            return current.getLastSyncedCheckpoint().globalCheckpoint__        }_    };the,last,synced,checkpoint,for,this,translog,return,the,last,synced,checkpoint;public,long,get,last,synced,global,checkpoint,try,releasable,lock,ignored,read,lock,acquire,return,current,get,last,synced,checkpoint,global,checkpoint
Translog -> public long getLastSyncedGlobalCheckpoint();1533295538;The last synced checkpoint for this translog.__@return the last synced checkpoint;public long getLastSyncedGlobalCheckpoint() {_        try (ReleasableLock ignored = readLock.acquire()) {_            return current.getLastSyncedCheckpoint().globalCheckpoint__        }_    };the,last,synced,checkpoint,for,this,translog,return,the,last,synced,checkpoint;public,long,get,last,synced,global,checkpoint,try,releasable,lock,ignored,read,lock,acquire,return,current,get,last,synced,checkpoint,global,checkpoint
Translog -> public long getLastSyncedGlobalCheckpoint();1533641732;The last synced checkpoint for this translog.__@return the last synced checkpoint;public long getLastSyncedGlobalCheckpoint() {_        try (ReleasableLock ignored = readLock.acquire()) {_            return current.getLastSyncedCheckpoint().globalCheckpoint__        }_    };the,last,synced,checkpoint,for,this,translog,return,the,last,synced,checkpoint;public,long,get,last,synced,global,checkpoint,try,releasable,lock,ignored,read,lock,acquire,return,current,get,last,synced,checkpoint,global,checkpoint
Translog -> public long getLastSyncedGlobalCheckpoint();1534848846;The last synced checkpoint for this translog.__@return the last synced checkpoint;public long getLastSyncedGlobalCheckpoint() {_        try (ReleasableLock ignored = readLock.acquire()) {_            return current.getLastSyncedCheckpoint().globalCheckpoint__        }_    };the,last,synced,checkpoint,for,this,translog,return,the,last,synced,checkpoint;public,long,get,last,synced,global,checkpoint,try,releasable,lock,ignored,read,lock,acquire,return,current,get,last,synced,checkpoint,global,checkpoint
Translog -> public long getLastSyncedGlobalCheckpoint();1535046779;The last synced checkpoint for this translog.__@return the last synced checkpoint;public long getLastSyncedGlobalCheckpoint() {_        try (ReleasableLock ignored = readLock.acquire()) {_            return current.getLastSyncedCheckpoint().globalCheckpoint__        }_    };the,last,synced,checkpoint,for,this,translog,return,the,last,synced,checkpoint;public,long,get,last,synced,global,checkpoint,try,releasable,lock,ignored,read,lock,acquire,return,current,get,last,synced,checkpoint,global,checkpoint
Translog -> public long getLastSyncedGlobalCheckpoint();1535723122;The last synced checkpoint for this translog.__@return the last synced checkpoint;public long getLastSyncedGlobalCheckpoint() {_        try (ReleasableLock ignored = readLock.acquire()) {_            return current.getLastSyncedCheckpoint().globalCheckpoint__        }_    };the,last,synced,checkpoint,for,this,translog,return,the,last,synced,checkpoint;public,long,get,last,synced,global,checkpoint,try,releasable,lock,ignored,read,lock,acquire,return,current,get,last,synced,checkpoint,global,checkpoint
Translog -> public long getLastSyncedGlobalCheckpoint();1537806831;The last synced checkpoint for this translog.__@return the last synced checkpoint;public long getLastSyncedGlobalCheckpoint() {_        try (ReleasableLock ignored = readLock.acquire()) {_            return current.getLastSyncedCheckpoint().globalCheckpoint__        }_    };the,last,synced,checkpoint,for,this,translog,return,the,last,synced,checkpoint;public,long,get,last,synced,global,checkpoint,try,releasable,lock,ignored,read,lock,acquire,return,current,get,last,synced,checkpoint,global,checkpoint
Translog -> public long getLastSyncedGlobalCheckpoint();1541592065;The last synced checkpoint for this translog.__@return the last synced checkpoint;public long getLastSyncedGlobalCheckpoint() {_        try (ReleasableLock ignored = readLock.acquire()) {_            return current.getLastSyncedCheckpoint().globalCheckpoint__        }_    };the,last,synced,checkpoint,for,this,translog,return,the,last,synced,checkpoint;public,long,get,last,synced,global,checkpoint,try,releasable,lock,ignored,read,lock,acquire,return,current,get,last,synced,checkpoint,global,checkpoint
Translog -> public long getLastSyncedGlobalCheckpoint();1542697754;The last synced checkpoint for this translog.__@return the last synced checkpoint;public long getLastSyncedGlobalCheckpoint() {_        try (ReleasableLock ignored = readLock.acquire()) {_            return current.getLastSyncedCheckpoint().globalCheckpoint__        }_    };the,last,synced,checkpoint,for,this,translog,return,the,last,synced,checkpoint;public,long,get,last,synced,global,checkpoint,try,releasable,lock,ignored,read,lock,acquire,return,current,get,last,synced,checkpoint,global,checkpoint
Translog -> public long getLastSyncedGlobalCheckpoint();1542962614;The last synced checkpoint for this translog.__@return the last synced checkpoint;public long getLastSyncedGlobalCheckpoint() {_        try (ReleasableLock ignored = readLock.acquire()) {_            return current.getLastSyncedCheckpoint().globalCheckpoint__        }_    };the,last,synced,checkpoint,for,this,translog,return,the,last,synced,checkpoint;public,long,get,last,synced,global,checkpoint,try,releasable,lock,ignored,read,lock,acquire,return,current,get,last,synced,checkpoint,global,checkpoint
Translog -> public long getLastSyncedGlobalCheckpoint();1545236365;The last synced checkpoint for this translog.__@return the last synced checkpoint;public long getLastSyncedGlobalCheckpoint() {_        try (ReleasableLock ignored = readLock.acquire()) {_            return current.getLastSyncedCheckpoint().globalCheckpoint__        }_    };the,last,synced,checkpoint,for,this,translog,return,the,last,synced,checkpoint;public,long,get,last,synced,global,checkpoint,try,releasable,lock,ignored,read,lock,acquire,return,current,get,last,synced,checkpoint,global,checkpoint
Translog -> public int estimateTotalOperationsFromMinSeq(long minSeqNo);1524684173;Returns the number of operations in the transaction files that contain operations with seq# above the given number.;public int estimateTotalOperationsFromMinSeq(long minSeqNo) {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            return readersAboveMinSeqNo(minSeqNo).mapToInt(BaseTranslogReader::totalOperations).sum()__        }_    };returns,the,number,of,operations,in,the,transaction,files,that,contain,operations,with,seq,above,the,given,number;public,int,estimate,total,operations,from,min,seq,long,min,seq,no,try,releasable,lock,ignored,read,lock,acquire,ensure,open,return,readers,above,min,seq,no,min,seq,no,map,to,int,base,translog,reader,total,operations,sum
Translog -> public int estimateTotalOperationsFromMinSeq(long minSeqNo);1525334055;Returns the number of operations in the transaction files that contain operations with seq# above the given number.;public int estimateTotalOperationsFromMinSeq(long minSeqNo) {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            return readersAboveMinSeqNo(minSeqNo).mapToInt(BaseTranslogReader::totalOperations).sum()__        }_    };returns,the,number,of,operations,in,the,transaction,files,that,contain,operations,with,seq,above,the,given,number;public,int,estimate,total,operations,from,min,seq,long,min,seq,no,try,releasable,lock,ignored,read,lock,acquire,ensure,open,return,readers,above,min,seq,no,min,seq,no,map,to,int,base,translog,reader,total,operations,sum
Translog -> public int estimateTotalOperationsFromMinSeq(long minSeqNo);1528706846;Returns the number of operations in the transaction files that contain operations with seq# above the given number.;public int estimateTotalOperationsFromMinSeq(long minSeqNo) {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            return readersAboveMinSeqNo(minSeqNo).mapToInt(BaseTranslogReader::totalOperations).sum()__        }_    };returns,the,number,of,operations,in,the,transaction,files,that,contain,operations,with,seq,above,the,given,number;public,int,estimate,total,operations,from,min,seq,long,min,seq,no,try,releasable,lock,ignored,read,lock,acquire,ensure,open,return,readers,above,min,seq,no,min,seq,no,map,to,int,base,translog,reader,total,operations,sum
Translog -> public int estimateTotalOperationsFromMinSeq(long minSeqNo);1531910483;Returns the number of operations in the transaction files that contain operations with seq# above the given number.;public int estimateTotalOperationsFromMinSeq(long minSeqNo) {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            return readersAboveMinSeqNo(minSeqNo).mapToInt(BaseTranslogReader::totalOperations).sum()__        }_    };returns,the,number,of,operations,in,the,transaction,files,that,contain,operations,with,seq,above,the,given,number;public,int,estimate,total,operations,from,min,seq,long,min,seq,no,try,releasable,lock,ignored,read,lock,acquire,ensure,open,return,readers,above,min,seq,no,min,seq,no,map,to,int,base,translog,reader,total,operations,sum
Translog -> public int estimateTotalOperationsFromMinSeq(long minSeqNo);1533295538;Returns the number of operations in the transaction files that contain operations with seq# above the given number.;public int estimateTotalOperationsFromMinSeq(long minSeqNo) {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            return readersAboveMinSeqNo(minSeqNo).mapToInt(BaseTranslogReader::totalOperations).sum()__        }_    };returns,the,number,of,operations,in,the,transaction,files,that,contain,operations,with,seq,above,the,given,number;public,int,estimate,total,operations,from,min,seq,long,min,seq,no,try,releasable,lock,ignored,read,lock,acquire,ensure,open,return,readers,above,min,seq,no,min,seq,no,map,to,int,base,translog,reader,total,operations,sum
Translog -> public int estimateTotalOperationsFromMinSeq(long minSeqNo);1533641732;Returns the number of operations in the transaction files that contain operations with seq# above the given number.;public int estimateTotalOperationsFromMinSeq(long minSeqNo) {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            return readersAboveMinSeqNo(minSeqNo).mapToInt(BaseTranslogReader::totalOperations).sum()__        }_    };returns,the,number,of,operations,in,the,transaction,files,that,contain,operations,with,seq,above,the,given,number;public,int,estimate,total,operations,from,min,seq,long,min,seq,no,try,releasable,lock,ignored,read,lock,acquire,ensure,open,return,readers,above,min,seq,no,min,seq,no,map,to,int,base,translog,reader,total,operations,sum
Translog -> public int estimateTotalOperationsFromMinSeq(long minSeqNo);1534848846;Returns the number of operations in the transaction files that contain operations with seq# above the given number.;public int estimateTotalOperationsFromMinSeq(long minSeqNo) {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            return readersAboveMinSeqNo(minSeqNo).mapToInt(BaseTranslogReader::totalOperations).sum()__        }_    };returns,the,number,of,operations,in,the,transaction,files,that,contain,operations,with,seq,above,the,given,number;public,int,estimate,total,operations,from,min,seq,long,min,seq,no,try,releasable,lock,ignored,read,lock,acquire,ensure,open,return,readers,above,min,seq,no,min,seq,no,map,to,int,base,translog,reader,total,operations,sum
Translog -> public int estimateTotalOperationsFromMinSeq(long minSeqNo);1535046779;Returns the number of operations in the transaction files that contain operations with seq# above the given number.;public int estimateTotalOperationsFromMinSeq(long minSeqNo) {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            return readersAboveMinSeqNo(minSeqNo).mapToInt(BaseTranslogReader::totalOperations).sum()__        }_    };returns,the,number,of,operations,in,the,transaction,files,that,contain,operations,with,seq,above,the,given,number;public,int,estimate,total,operations,from,min,seq,long,min,seq,no,try,releasable,lock,ignored,read,lock,acquire,ensure,open,return,readers,above,min,seq,no,min,seq,no,map,to,int,base,translog,reader,total,operations,sum
Translog -> public int estimateTotalOperationsFromMinSeq(long minSeqNo);1535723122;Returns the number of operations in the transaction files that contain operations with seq# above the given number.;public int estimateTotalOperationsFromMinSeq(long minSeqNo) {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            return readersAboveMinSeqNo(minSeqNo).mapToInt(BaseTranslogReader::totalOperations).sum()__        }_    };returns,the,number,of,operations,in,the,transaction,files,that,contain,operations,with,seq,above,the,given,number;public,int,estimate,total,operations,from,min,seq,long,min,seq,no,try,releasable,lock,ignored,read,lock,acquire,ensure,open,return,readers,above,min,seq,no,min,seq,no,map,to,int,base,translog,reader,total,operations,sum
Translog -> public int estimateTotalOperationsFromMinSeq(long minSeqNo);1537806831;Returns the number of operations in the transaction files that contain operations with seq# above the given number.;public int estimateTotalOperationsFromMinSeq(long minSeqNo) {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            return readersAboveMinSeqNo(minSeqNo).mapToInt(BaseTranslogReader::totalOperations).sum()__        }_    };returns,the,number,of,operations,in,the,transaction,files,that,contain,operations,with,seq,above,the,given,number;public,int,estimate,total,operations,from,min,seq,long,min,seq,no,try,releasable,lock,ignored,read,lock,acquire,ensure,open,return,readers,above,min,seq,no,min,seq,no,map,to,int,base,translog,reader,total,operations,sum
Translog -> public int estimateTotalOperationsFromMinSeq(long minSeqNo);1541592065;Returns the number of operations in the transaction files that contain operations with seq# above the given number.;public int estimateTotalOperationsFromMinSeq(long minSeqNo) {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            return readersAboveMinSeqNo(minSeqNo).mapToInt(BaseTranslogReader::totalOperations).sum()__        }_    };returns,the,number,of,operations,in,the,transaction,files,that,contain,operations,with,seq,above,the,given,number;public,int,estimate,total,operations,from,min,seq,long,min,seq,no,try,releasable,lock,ignored,read,lock,acquire,ensure,open,return,readers,above,min,seq,no,min,seq,no,map,to,int,base,translog,reader,total,operations,sum
Translog -> public int estimateTotalOperationsFromMinSeq(long minSeqNo);1542697754;Returns the number of operations in the transaction files that contain operations with seq# above the given number.;public int estimateTotalOperationsFromMinSeq(long minSeqNo) {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            return readersAboveMinSeqNo(minSeqNo).mapToInt(BaseTranslogReader::totalOperations).sum()__        }_    };returns,the,number,of,operations,in,the,transaction,files,that,contain,operations,with,seq,above,the,given,number;public,int,estimate,total,operations,from,min,seq,long,min,seq,no,try,releasable,lock,ignored,read,lock,acquire,ensure,open,return,readers,above,min,seq,no,min,seq,no,map,to,int,base,translog,reader,total,operations,sum
Translog -> public int estimateTotalOperationsFromMinSeq(long minSeqNo);1542962614;Returns the number of operations in the transaction files that contain operations with seq# above the given number.;public int estimateTotalOperationsFromMinSeq(long minSeqNo) {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            return readersAboveMinSeqNo(minSeqNo).mapToInt(BaseTranslogReader::totalOperations).sum()__        }_    };returns,the,number,of,operations,in,the,transaction,files,that,contain,operations,with,seq,above,the,given,number;public,int,estimate,total,operations,from,min,seq,long,min,seq,no,try,releasable,lock,ignored,read,lock,acquire,ensure,open,return,readers,above,min,seq,no,min,seq,no,map,to,int,base,translog,reader,total,operations,sum
Translog -> public int estimateTotalOperationsFromMinSeq(long minSeqNo);1545236365;Returns the number of operations in the transaction files that contain operations with seq# above the given number.;public int estimateTotalOperationsFromMinSeq(long minSeqNo) {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            return readersAboveMinSeqNo(minSeqNo).mapToInt(BaseTranslogReader::totalOperations).sum()__        }_    };returns,the,number,of,operations,in,the,transaction,files,that,contain,operations,with,seq,above,the,given,number;public,int,estimate,total,operations,from,min,seq,long,min,seq,no,try,releasable,lock,ignored,read,lock,acquire,ensure,open,return,readers,above,min,seq,no,min,seq,no,map,to,int,base,translog,reader,total,operations,sum
Translog -> public TranslogGeneration getGeneration();1524684173;Returns the current generation of this translog. This corresponds to the latest uncommitted translog generation;public TranslogGeneration getGeneration() {_        try (ReleasableLock lock = writeLock.acquire()) {_            return new TranslogGeneration(translogUUID, currentFileGeneration())__        }_    };returns,the,current,generation,of,this,translog,this,corresponds,to,the,latest,uncommitted,translog,generation;public,translog,generation,get,generation,try,releasable,lock,lock,write,lock,acquire,return,new,translog,generation,translog,uuid,current,file,generation
Translog -> public TranslogGeneration getGeneration();1525334055;Returns the current generation of this translog. This corresponds to the latest uncommitted translog generation;public TranslogGeneration getGeneration() {_        try (ReleasableLock lock = writeLock.acquire()) {_            return new TranslogGeneration(translogUUID, currentFileGeneration())__        }_    };returns,the,current,generation,of,this,translog,this,corresponds,to,the,latest,uncommitted,translog,generation;public,translog,generation,get,generation,try,releasable,lock,lock,write,lock,acquire,return,new,translog,generation,translog,uuid,current,file,generation
Translog -> public TranslogGeneration getGeneration();1528706846;Returns the current generation of this translog. This corresponds to the latest uncommitted translog generation;public TranslogGeneration getGeneration() {_        try (ReleasableLock lock = writeLock.acquire()) {_            return new TranslogGeneration(translogUUID, currentFileGeneration())__        }_    };returns,the,current,generation,of,this,translog,this,corresponds,to,the,latest,uncommitted,translog,generation;public,translog,generation,get,generation,try,releasable,lock,lock,write,lock,acquire,return,new,translog,generation,translog,uuid,current,file,generation
Translog -> public TranslogGeneration getGeneration();1531910483;Returns the current generation of this translog. This corresponds to the latest uncommitted translog generation;public TranslogGeneration getGeneration() {_        try (ReleasableLock lock = writeLock.acquire()) {_            return new TranslogGeneration(translogUUID, currentFileGeneration())__        }_    };returns,the,current,generation,of,this,translog,this,corresponds,to,the,latest,uncommitted,translog,generation;public,translog,generation,get,generation,try,releasable,lock,lock,write,lock,acquire,return,new,translog,generation,translog,uuid,current,file,generation
Translog -> public TranslogGeneration getGeneration();1533295538;Returns the current generation of this translog. This corresponds to the latest uncommitted translog generation;public TranslogGeneration getGeneration() {_        try (ReleasableLock lock = writeLock.acquire()) {_            return new TranslogGeneration(translogUUID, currentFileGeneration())__        }_    };returns,the,current,generation,of,this,translog,this,corresponds,to,the,latest,uncommitted,translog,generation;public,translog,generation,get,generation,try,releasable,lock,lock,write,lock,acquire,return,new,translog,generation,translog,uuid,current,file,generation
Translog -> public TranslogGeneration getGeneration();1533641732;Returns the current generation of this translog. This corresponds to the latest uncommitted translog generation;public TranslogGeneration getGeneration() {_        try (ReleasableLock lock = writeLock.acquire()) {_            return new TranslogGeneration(translogUUID, currentFileGeneration())__        }_    };returns,the,current,generation,of,this,translog,this,corresponds,to,the,latest,uncommitted,translog,generation;public,translog,generation,get,generation,try,releasable,lock,lock,write,lock,acquire,return,new,translog,generation,translog,uuid,current,file,generation
Translog -> public TranslogGeneration getGeneration();1534848846;Returns the current generation of this translog. This corresponds to the latest uncommitted translog generation;public TranslogGeneration getGeneration() {_        try (ReleasableLock lock = writeLock.acquire()) {_            return new TranslogGeneration(translogUUID, currentFileGeneration())__        }_    };returns,the,current,generation,of,this,translog,this,corresponds,to,the,latest,uncommitted,translog,generation;public,translog,generation,get,generation,try,releasable,lock,lock,write,lock,acquire,return,new,translog,generation,translog,uuid,current,file,generation
Translog -> public TranslogGeneration getGeneration();1535046779;Returns the current generation of this translog. This corresponds to the latest uncommitted translog generation;public TranslogGeneration getGeneration() {_        try (ReleasableLock lock = writeLock.acquire()) {_            return new TranslogGeneration(translogUUID, currentFileGeneration())__        }_    };returns,the,current,generation,of,this,translog,this,corresponds,to,the,latest,uncommitted,translog,generation;public,translog,generation,get,generation,try,releasable,lock,lock,write,lock,acquire,return,new,translog,generation,translog,uuid,current,file,generation
Translog -> public TranslogGeneration getGeneration();1535723122;Returns the current generation of this translog. This corresponds to the latest uncommitted translog generation;public TranslogGeneration getGeneration() {_        try (ReleasableLock lock = writeLock.acquire()) {_            return new TranslogGeneration(translogUUID, currentFileGeneration())__        }_    };returns,the,current,generation,of,this,translog,this,corresponds,to,the,latest,uncommitted,translog,generation;public,translog,generation,get,generation,try,releasable,lock,lock,write,lock,acquire,return,new,translog,generation,translog,uuid,current,file,generation
Translog -> public TranslogGeneration getGeneration();1537806831;Returns the current generation of this translog. This corresponds to the latest uncommitted translog generation;public TranslogGeneration getGeneration() {_        try (ReleasableLock lock = writeLock.acquire()) {_            return new TranslogGeneration(translogUUID, currentFileGeneration())__        }_    };returns,the,current,generation,of,this,translog,this,corresponds,to,the,latest,uncommitted,translog,generation;public,translog,generation,get,generation,try,releasable,lock,lock,write,lock,acquire,return,new,translog,generation,translog,uuid,current,file,generation
Translog -> public TranslogGeneration getGeneration();1541592065;Returns the current generation of this translog. This corresponds to the latest uncommitted translog generation;public TranslogGeneration getGeneration() {_        try (ReleasableLock lock = writeLock.acquire()) {_            return new TranslogGeneration(translogUUID, currentFileGeneration())__        }_    };returns,the,current,generation,of,this,translog,this,corresponds,to,the,latest,uncommitted,translog,generation;public,translog,generation,get,generation,try,releasable,lock,lock,write,lock,acquire,return,new,translog,generation,translog,uuid,current,file,generation
Translog -> public TranslogGeneration getGeneration();1542697754;Returns the current generation of this translog. This corresponds to the latest uncommitted translog generation;public TranslogGeneration getGeneration() {_        try (ReleasableLock lock = writeLock.acquire()) {_            return new TranslogGeneration(translogUUID, currentFileGeneration())__        }_    };returns,the,current,generation,of,this,translog,this,corresponds,to,the,latest,uncommitted,translog,generation;public,translog,generation,get,generation,try,releasable,lock,lock,write,lock,acquire,return,new,translog,generation,translog,uuid,current,file,generation
Translog -> public TranslogGeneration getGeneration();1542962614;Returns the current generation of this translog. This corresponds to the latest uncommitted translog generation;public TranslogGeneration getGeneration() {_        try (ReleasableLock lock = writeLock.acquire()) {_            return new TranslogGeneration(translogUUID, currentFileGeneration())__        }_    };returns,the,current,generation,of,this,translog,this,corresponds,to,the,latest,uncommitted,translog,generation;public,translog,generation,get,generation,try,releasable,lock,lock,write,lock,acquire,return,new,translog,generation,translog,uuid,current,file,generation
Translog -> public TranslogGeneration getGeneration();1545236365;Returns the current generation of this translog. This corresponds to the latest uncommitted translog generation;public TranslogGeneration getGeneration() {_        try (ReleasableLock lock = writeLock.acquire()) {_            return new TranslogGeneration(translogUUID, currentFileGeneration())__        }_    };returns,the,current,generation,of,this,translog,this,corresponds,to,the,latest,uncommitted,translog,generation;public,translog,generation,get,generation,try,releasable,lock,lock,write,lock,acquire,return,new,translog,generation,translog,uuid,current,file,generation
Translog -> public void sync() throws IOException;1524684173;Sync's the translog.;public void sync() throws IOException {_        try (ReleasableLock lock = readLock.acquire()) {_            if (closed.get() == false) {_                current.sync()__            }_        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_    };sync,s,the,translog;public,void,sync,throws,ioexception,try,releasable,lock,lock,read,lock,acquire,if,closed,get,false,current,sync,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex
Translog -> public void sync() throws IOException;1525334055;Sync's the translog.;public void sync() throws IOException {_        try (ReleasableLock lock = readLock.acquire()) {_            if (closed.get() == false) {_                current.sync()__            }_        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_    };sync,s,the,translog;public,void,sync,throws,ioexception,try,releasable,lock,lock,read,lock,acquire,if,closed,get,false,current,sync,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex
Translog -> public void sync() throws IOException;1528706846;Sync's the translog.;public void sync() throws IOException {_        try (ReleasableLock lock = readLock.acquire()) {_            if (closed.get() == false) {_                current.sync()__            }_        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_    };sync,s,the,translog;public,void,sync,throws,ioexception,try,releasable,lock,lock,read,lock,acquire,if,closed,get,false,current,sync,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex
Translog -> public void sync() throws IOException;1531910483;Sync's the translog.;public void sync() throws IOException {_        try (ReleasableLock lock = readLock.acquire()) {_            if (closed.get() == false) {_                current.sync()__            }_        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_    };sync,s,the,translog;public,void,sync,throws,ioexception,try,releasable,lock,lock,read,lock,acquire,if,closed,get,false,current,sync,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex
Translog -> public void sync() throws IOException;1533295538;Sync's the translog.;public void sync() throws IOException {_        try (ReleasableLock lock = readLock.acquire()) {_            if (closed.get() == false) {_                current.sync()__            }_        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_    };sync,s,the,translog;public,void,sync,throws,ioexception,try,releasable,lock,lock,read,lock,acquire,if,closed,get,false,current,sync,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex
Translog -> public void sync() throws IOException;1533641732;Sync's the translog.;public void sync() throws IOException {_        try (ReleasableLock lock = readLock.acquire()) {_            if (closed.get() == false) {_                current.sync()__            }_        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_    };sync,s,the,translog;public,void,sync,throws,ioexception,try,releasable,lock,lock,read,lock,acquire,if,closed,get,false,current,sync,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex
Translog -> public void sync() throws IOException;1534848846;Sync's the translog.;public void sync() throws IOException {_        try (ReleasableLock lock = readLock.acquire()) {_            if (closed.get() == false) {_                current.sync()__            }_        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_    };sync,s,the,translog;public,void,sync,throws,ioexception,try,releasable,lock,lock,read,lock,acquire,if,closed,get,false,current,sync,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex
Translog -> public void sync() throws IOException;1535046779;Sync's the translog.;public void sync() throws IOException {_        try (ReleasableLock lock = readLock.acquire()) {_            if (closed.get() == false) {_                current.sync()__            }_        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_    };sync,s,the,translog;public,void,sync,throws,ioexception,try,releasable,lock,lock,read,lock,acquire,if,closed,get,false,current,sync,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex
Translog -> public void sync() throws IOException;1535723122;Sync's the translog.;public void sync() throws IOException {_        try (ReleasableLock lock = readLock.acquire()) {_            if (closed.get() == false) {_                current.sync()__            }_        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_    };sync,s,the,translog;public,void,sync,throws,ioexception,try,releasable,lock,lock,read,lock,acquire,if,closed,get,false,current,sync,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex
Translog -> public void sync() throws IOException;1537806831;Sync's the translog.;public void sync() throws IOException {_        try (ReleasableLock lock = readLock.acquire()) {_            if (closed.get() == false) {_                current.sync()__            }_        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_    };sync,s,the,translog;public,void,sync,throws,ioexception,try,releasable,lock,lock,read,lock,acquire,if,closed,get,false,current,sync,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex
Translog -> public void sync() throws IOException;1541592065;Sync's the translog.;public void sync() throws IOException {_        try (ReleasableLock lock = readLock.acquire()) {_            if (closed.get() == false) {_                current.sync()__            }_        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_    };sync,s,the,translog;public,void,sync,throws,ioexception,try,releasable,lock,lock,read,lock,acquire,if,closed,get,false,current,sync,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex
Translog -> public void sync() throws IOException;1542697754;Sync's the translog.;public void sync() throws IOException {_        try (ReleasableLock lock = readLock.acquire()) {_            if (closed.get() == false) {_                current.sync()__            }_        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_    };sync,s,the,translog;public,void,sync,throws,ioexception,try,releasable,lock,lock,read,lock,acquire,if,closed,get,false,current,sync,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex
Translog -> public void sync() throws IOException;1542962614;Sync's the translog.;public void sync() throws IOException {_        try (ReleasableLock lock = readLock.acquire()) {_            if (closed.get() == false) {_                current.sync()__            }_        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_    };sync,s,the,translog;public,void,sync,throws,ioexception,try,releasable,lock,lock,read,lock,acquire,if,closed,get,false,current,sync,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex
Translog -> public void sync() throws IOException;1545236365;Sync's the translog.;public void sync() throws IOException {_        try (ReleasableLock lock = readLock.acquire()) {_            if (closed.get() == false) {_                current.sync()__            }_        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_    };sync,s,the,translog;public,void,sync,throws,ioexception,try,releasable,lock,lock,read,lock,acquire,if,closed,get,false,current,sync,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex
Translog -> public static long readGlobalCheckpoint(final Path location, final String expectedTranslogUUID) throws IOException;1524684173;Reads the sequence numbers global checkpoint from the translog checkpoint._This ensures that the translogUUID from this translog matches with the provided translogUUID.__@param location the location of the translog_@return the global checkpoint_@throws IOException                if an I/O exception occurred reading the checkpoint_@throws TranslogCorruptedException if the translog is corrupted or mismatched with the given uuid;public static long readGlobalCheckpoint(final Path location, final String expectedTranslogUUID) throws IOException {_        final Checkpoint checkpoint = readCheckpoint(location, expectedTranslogUUID)__        return checkpoint.globalCheckpoint__    };reads,the,sequence,numbers,global,checkpoint,from,the,translog,checkpoint,this,ensures,that,the,translog,uuid,from,this,translog,matches,with,the,provided,translog,uuid,param,location,the,location,of,the,translog,return,the,global,checkpoint,throws,ioexception,if,an,i,o,exception,occurred,reading,the,checkpoint,throws,translog,corrupted,exception,if,the,translog,is,corrupted,or,mismatched,with,the,given,uuid;public,static,long,read,global,checkpoint,final,path,location,final,string,expected,translog,uuid,throws,ioexception,final,checkpoint,checkpoint,read,checkpoint,location,expected,translog,uuid,return,checkpoint,global,checkpoint
Translog -> public static long readGlobalCheckpoint(final Path location, final String expectedTranslogUUID) throws IOException;1525334055;Reads the sequence numbers global checkpoint from the translog checkpoint._This ensures that the translogUUID from this translog matches with the provided translogUUID.__@param location the location of the translog_@return the global checkpoint_@throws IOException                if an I/O exception occurred reading the checkpoint_@throws TranslogCorruptedException if the translog is corrupted or mismatched with the given uuid;public static long readGlobalCheckpoint(final Path location, final String expectedTranslogUUID) throws IOException {_        final Checkpoint checkpoint = readCheckpoint(location, expectedTranslogUUID)__        return checkpoint.globalCheckpoint__    };reads,the,sequence,numbers,global,checkpoint,from,the,translog,checkpoint,this,ensures,that,the,translog,uuid,from,this,translog,matches,with,the,provided,translog,uuid,param,location,the,location,of,the,translog,return,the,global,checkpoint,throws,ioexception,if,an,i,o,exception,occurred,reading,the,checkpoint,throws,translog,corrupted,exception,if,the,translog,is,corrupted,or,mismatched,with,the,given,uuid;public,static,long,read,global,checkpoint,final,path,location,final,string,expected,translog,uuid,throws,ioexception,final,checkpoint,checkpoint,read,checkpoint,location,expected,translog,uuid,return,checkpoint,global,checkpoint
Translog -> public static long readGlobalCheckpoint(final Path location, final String expectedTranslogUUID) throws IOException;1528706846;Reads the sequence numbers global checkpoint from the translog checkpoint._This ensures that the translogUUID from this translog matches with the provided translogUUID.__@param location the location of the translog_@return the global checkpoint_@throws IOException                if an I/O exception occurred reading the checkpoint_@throws TranslogCorruptedException if the translog is corrupted or mismatched with the given uuid;public static long readGlobalCheckpoint(final Path location, final String expectedTranslogUUID) throws IOException {_        final Checkpoint checkpoint = readCheckpoint(location, expectedTranslogUUID)__        return checkpoint.globalCheckpoint__    };reads,the,sequence,numbers,global,checkpoint,from,the,translog,checkpoint,this,ensures,that,the,translog,uuid,from,this,translog,matches,with,the,provided,translog,uuid,param,location,the,location,of,the,translog,return,the,global,checkpoint,throws,ioexception,if,an,i,o,exception,occurred,reading,the,checkpoint,throws,translog,corrupted,exception,if,the,translog,is,corrupted,or,mismatched,with,the,given,uuid;public,static,long,read,global,checkpoint,final,path,location,final,string,expected,translog,uuid,throws,ioexception,final,checkpoint,checkpoint,read,checkpoint,location,expected,translog,uuid,return,checkpoint,global,checkpoint
Translog -> public static long readGlobalCheckpoint(final Path location, final String expectedTranslogUUID) throws IOException;1531910483;Reads the sequence numbers global checkpoint from the translog checkpoint._This ensures that the translogUUID from this translog matches with the provided translogUUID.__@param location the location of the translog_@return the global checkpoint_@throws IOException                if an I/O exception occurred reading the checkpoint_@throws TranslogCorruptedException if the translog is corrupted or mismatched with the given uuid;public static long readGlobalCheckpoint(final Path location, final String expectedTranslogUUID) throws IOException {_        final Checkpoint checkpoint = readCheckpoint(location, expectedTranslogUUID)__        return checkpoint.globalCheckpoint__    };reads,the,sequence,numbers,global,checkpoint,from,the,translog,checkpoint,this,ensures,that,the,translog,uuid,from,this,translog,matches,with,the,provided,translog,uuid,param,location,the,location,of,the,translog,return,the,global,checkpoint,throws,ioexception,if,an,i,o,exception,occurred,reading,the,checkpoint,throws,translog,corrupted,exception,if,the,translog,is,corrupted,or,mismatched,with,the,given,uuid;public,static,long,read,global,checkpoint,final,path,location,final,string,expected,translog,uuid,throws,ioexception,final,checkpoint,checkpoint,read,checkpoint,location,expected,translog,uuid,return,checkpoint,global,checkpoint
Translog -> public static long readGlobalCheckpoint(final Path location, final String expectedTranslogUUID) throws IOException;1533295538;Reads the sequence numbers global checkpoint from the translog checkpoint._This ensures that the translogUUID from this translog matches with the provided translogUUID.__@param location the location of the translog_@return the global checkpoint_@throws IOException                if an I/O exception occurred reading the checkpoint_@throws TranslogCorruptedException if the translog is corrupted or mismatched with the given uuid;public static long readGlobalCheckpoint(final Path location, final String expectedTranslogUUID) throws IOException {_        final Checkpoint checkpoint = readCheckpoint(location, expectedTranslogUUID)__        return checkpoint.globalCheckpoint__    };reads,the,sequence,numbers,global,checkpoint,from,the,translog,checkpoint,this,ensures,that,the,translog,uuid,from,this,translog,matches,with,the,provided,translog,uuid,param,location,the,location,of,the,translog,return,the,global,checkpoint,throws,ioexception,if,an,i,o,exception,occurred,reading,the,checkpoint,throws,translog,corrupted,exception,if,the,translog,is,corrupted,or,mismatched,with,the,given,uuid;public,static,long,read,global,checkpoint,final,path,location,final,string,expected,translog,uuid,throws,ioexception,final,checkpoint,checkpoint,read,checkpoint,location,expected,translog,uuid,return,checkpoint,global,checkpoint
Translog -> public static long readGlobalCheckpoint(final Path location, final String expectedTranslogUUID) throws IOException;1533641732;Reads the sequence numbers global checkpoint from the translog checkpoint._This ensures that the translogUUID from this translog matches with the provided translogUUID.__@param location the location of the translog_@return the global checkpoint_@throws IOException                if an I/O exception occurred reading the checkpoint_@throws TranslogCorruptedException if the translog is corrupted or mismatched with the given uuid;public static long readGlobalCheckpoint(final Path location, final String expectedTranslogUUID) throws IOException {_        final Checkpoint checkpoint = readCheckpoint(location, expectedTranslogUUID)__        return checkpoint.globalCheckpoint__    };reads,the,sequence,numbers,global,checkpoint,from,the,translog,checkpoint,this,ensures,that,the,translog,uuid,from,this,translog,matches,with,the,provided,translog,uuid,param,location,the,location,of,the,translog,return,the,global,checkpoint,throws,ioexception,if,an,i,o,exception,occurred,reading,the,checkpoint,throws,translog,corrupted,exception,if,the,translog,is,corrupted,or,mismatched,with,the,given,uuid;public,static,long,read,global,checkpoint,final,path,location,final,string,expected,translog,uuid,throws,ioexception,final,checkpoint,checkpoint,read,checkpoint,location,expected,translog,uuid,return,checkpoint,global,checkpoint
Translog -> public static long readGlobalCheckpoint(final Path location, final String expectedTranslogUUID) throws IOException;1534848846;Reads the sequence numbers global checkpoint from the translog checkpoint._This ensures that the translogUUID from this translog matches with the provided translogUUID.__@param location the location of the translog_@return the global checkpoint_@throws IOException                if an I/O exception occurred reading the checkpoint_@throws TranslogCorruptedException if the translog is corrupted or mismatched with the given uuid;public static long readGlobalCheckpoint(final Path location, final String expectedTranslogUUID) throws IOException {_        final Checkpoint checkpoint = readCheckpoint(location, expectedTranslogUUID)__        return checkpoint.globalCheckpoint__    };reads,the,sequence,numbers,global,checkpoint,from,the,translog,checkpoint,this,ensures,that,the,translog,uuid,from,this,translog,matches,with,the,provided,translog,uuid,param,location,the,location,of,the,translog,return,the,global,checkpoint,throws,ioexception,if,an,i,o,exception,occurred,reading,the,checkpoint,throws,translog,corrupted,exception,if,the,translog,is,corrupted,or,mismatched,with,the,given,uuid;public,static,long,read,global,checkpoint,final,path,location,final,string,expected,translog,uuid,throws,ioexception,final,checkpoint,checkpoint,read,checkpoint,location,expected,translog,uuid,return,checkpoint,global,checkpoint
Translog -> public static long readGlobalCheckpoint(final Path location, final String expectedTranslogUUID) throws IOException;1535046779;Reads the sequence numbers global checkpoint from the translog checkpoint._This ensures that the translogUUID from this translog matches with the provided translogUUID.__@param location the location of the translog_@return the global checkpoint_@throws IOException                if an I/O exception occurred reading the checkpoint_@throws TranslogCorruptedException if the translog is corrupted or mismatched with the given uuid;public static long readGlobalCheckpoint(final Path location, final String expectedTranslogUUID) throws IOException {_        final Checkpoint checkpoint = readCheckpoint(location, expectedTranslogUUID)__        return checkpoint.globalCheckpoint__    };reads,the,sequence,numbers,global,checkpoint,from,the,translog,checkpoint,this,ensures,that,the,translog,uuid,from,this,translog,matches,with,the,provided,translog,uuid,param,location,the,location,of,the,translog,return,the,global,checkpoint,throws,ioexception,if,an,i,o,exception,occurred,reading,the,checkpoint,throws,translog,corrupted,exception,if,the,translog,is,corrupted,or,mismatched,with,the,given,uuid;public,static,long,read,global,checkpoint,final,path,location,final,string,expected,translog,uuid,throws,ioexception,final,checkpoint,checkpoint,read,checkpoint,location,expected,translog,uuid,return,checkpoint,global,checkpoint
Translog -> public static long readGlobalCheckpoint(final Path location, final String expectedTranslogUUID) throws IOException;1535723122;Reads the sequence numbers global checkpoint from the translog checkpoint._This ensures that the translogUUID from this translog matches with the provided translogUUID.__@param location the location of the translog_@return the global checkpoint_@throws IOException                if an I/O exception occurred reading the checkpoint_@throws TranslogCorruptedException if the translog is corrupted or mismatched with the given uuid;public static long readGlobalCheckpoint(final Path location, final String expectedTranslogUUID) throws IOException {_        final Checkpoint checkpoint = readCheckpoint(location, expectedTranslogUUID)__        return checkpoint.globalCheckpoint__    };reads,the,sequence,numbers,global,checkpoint,from,the,translog,checkpoint,this,ensures,that,the,translog,uuid,from,this,translog,matches,with,the,provided,translog,uuid,param,location,the,location,of,the,translog,return,the,global,checkpoint,throws,ioexception,if,an,i,o,exception,occurred,reading,the,checkpoint,throws,translog,corrupted,exception,if,the,translog,is,corrupted,or,mismatched,with,the,given,uuid;public,static,long,read,global,checkpoint,final,path,location,final,string,expected,translog,uuid,throws,ioexception,final,checkpoint,checkpoint,read,checkpoint,location,expected,translog,uuid,return,checkpoint,global,checkpoint
Translog -> public static long readGlobalCheckpoint(final Path location, final String expectedTranslogUUID) throws IOException;1537806831;Reads the sequence numbers global checkpoint from the translog checkpoint._This ensures that the translogUUID from this translog matches with the provided translogUUID.__@param location the location of the translog_@return the global checkpoint_@throws IOException                if an I/O exception occurred reading the checkpoint_@throws TranslogCorruptedException if the translog is corrupted or mismatched with the given uuid;public static long readGlobalCheckpoint(final Path location, final String expectedTranslogUUID) throws IOException {_        final Checkpoint checkpoint = readCheckpoint(location, expectedTranslogUUID)__        return checkpoint.globalCheckpoint__    };reads,the,sequence,numbers,global,checkpoint,from,the,translog,checkpoint,this,ensures,that,the,translog,uuid,from,this,translog,matches,with,the,provided,translog,uuid,param,location,the,location,of,the,translog,return,the,global,checkpoint,throws,ioexception,if,an,i,o,exception,occurred,reading,the,checkpoint,throws,translog,corrupted,exception,if,the,translog,is,corrupted,or,mismatched,with,the,given,uuid;public,static,long,read,global,checkpoint,final,path,location,final,string,expected,translog,uuid,throws,ioexception,final,checkpoint,checkpoint,read,checkpoint,location,expected,translog,uuid,return,checkpoint,global,checkpoint
Translog -> public static long readGlobalCheckpoint(final Path location, final String expectedTranslogUUID) throws IOException;1541592065;Reads the sequence numbers global checkpoint from the translog checkpoint._This ensures that the translogUUID from this translog matches with the provided translogUUID.__@param location the location of the translog_@return the global checkpoint_@throws IOException                if an I/O exception occurred reading the checkpoint_@throws TranslogCorruptedException if the translog is corrupted or mismatched with the given uuid;public static long readGlobalCheckpoint(final Path location, final String expectedTranslogUUID) throws IOException {_        final Checkpoint checkpoint = readCheckpoint(location, expectedTranslogUUID)__        return checkpoint.globalCheckpoint__    };reads,the,sequence,numbers,global,checkpoint,from,the,translog,checkpoint,this,ensures,that,the,translog,uuid,from,this,translog,matches,with,the,provided,translog,uuid,param,location,the,location,of,the,translog,return,the,global,checkpoint,throws,ioexception,if,an,i,o,exception,occurred,reading,the,checkpoint,throws,translog,corrupted,exception,if,the,translog,is,corrupted,or,mismatched,with,the,given,uuid;public,static,long,read,global,checkpoint,final,path,location,final,string,expected,translog,uuid,throws,ioexception,final,checkpoint,checkpoint,read,checkpoint,location,expected,translog,uuid,return,checkpoint,global,checkpoint
Translog -> public static long readGlobalCheckpoint(final Path location, final String expectedTranslogUUID) throws IOException;1542697754;Reads the sequence numbers global checkpoint from the translog checkpoint._This ensures that the translogUUID from this translog matches with the provided translogUUID.__@param location the location of the translog_@return the global checkpoint_@throws IOException                if an I/O exception occurred reading the checkpoint_@throws TranslogCorruptedException if the translog is corrupted or mismatched with the given uuid;public static long readGlobalCheckpoint(final Path location, final String expectedTranslogUUID) throws IOException {_        final Checkpoint checkpoint = readCheckpoint(location, expectedTranslogUUID)__        return checkpoint.globalCheckpoint__    };reads,the,sequence,numbers,global,checkpoint,from,the,translog,checkpoint,this,ensures,that,the,translog,uuid,from,this,translog,matches,with,the,provided,translog,uuid,param,location,the,location,of,the,translog,return,the,global,checkpoint,throws,ioexception,if,an,i,o,exception,occurred,reading,the,checkpoint,throws,translog,corrupted,exception,if,the,translog,is,corrupted,or,mismatched,with,the,given,uuid;public,static,long,read,global,checkpoint,final,path,location,final,string,expected,translog,uuid,throws,ioexception,final,checkpoint,checkpoint,read,checkpoint,location,expected,translog,uuid,return,checkpoint,global,checkpoint
Translog -> public static long readGlobalCheckpoint(final Path location, final String expectedTranslogUUID) throws IOException;1542962614;Reads the sequence numbers global checkpoint from the translog checkpoint._This ensures that the translogUUID from this translog matches with the provided translogUUID.__@param location the location of the translog_@return the global checkpoint_@throws IOException                if an I/O exception occurred reading the checkpoint_@throws TranslogCorruptedException if the translog is corrupted or mismatched with the given uuid;public static long readGlobalCheckpoint(final Path location, final String expectedTranslogUUID) throws IOException {_        final Checkpoint checkpoint = readCheckpoint(location, expectedTranslogUUID)__        return checkpoint.globalCheckpoint__    };reads,the,sequence,numbers,global,checkpoint,from,the,translog,checkpoint,this,ensures,that,the,translog,uuid,from,this,translog,matches,with,the,provided,translog,uuid,param,location,the,location,of,the,translog,return,the,global,checkpoint,throws,ioexception,if,an,i,o,exception,occurred,reading,the,checkpoint,throws,translog,corrupted,exception,if,the,translog,is,corrupted,or,mismatched,with,the,given,uuid;public,static,long,read,global,checkpoint,final,path,location,final,string,expected,translog,uuid,throws,ioexception,final,checkpoint,checkpoint,read,checkpoint,location,expected,translog,uuid,return,checkpoint,global,checkpoint
Translog -> public static long readGlobalCheckpoint(final Path location, final String expectedTranslogUUID) throws IOException;1545236365;Reads the sequence numbers global checkpoint from the translog checkpoint._This ensures that the translogUUID from this translog matches with the provided translogUUID.__@param location the location of the translog_@return the global checkpoint_@throws IOException                if an I/O exception occurred reading the checkpoint_@throws TranslogCorruptedException if the translog is corrupted or mismatched with the given uuid;public static long readGlobalCheckpoint(final Path location, final String expectedTranslogUUID) throws IOException {_        final Checkpoint checkpoint = readCheckpoint(location, expectedTranslogUUID)__        return checkpoint.globalCheckpoint__    };reads,the,sequence,numbers,global,checkpoint,from,the,translog,checkpoint,this,ensures,that,the,translog,uuid,from,this,translog,matches,with,the,provided,translog,uuid,param,location,the,location,of,the,translog,return,the,global,checkpoint,throws,ioexception,if,an,i,o,exception,occurred,reading,the,checkpoint,throws,translog,corrupted,exception,if,the,translog,is,corrupted,or,mismatched,with,the,given,uuid;public,static,long,read,global,checkpoint,final,path,location,final,string,expected,translog,uuid,throws,ioexception,final,checkpoint,checkpoint,read,checkpoint,location,expected,translog,uuid,return,checkpoint,global,checkpoint
Translog -> Snapshot -> default int overriddenOperations();1524684173;The number of operations have been overridden (eg. superseded) in the snapshot so far._If two operations have the same sequence number, the operation with a lower term will be overridden by the operation_with a higher term. Unlike {@link #totalOperations()}, this value is updated each time after {@link #next()}) is called.;default int overriddenOperations() {_            return 0__        };the,number,of,operations,have,been,overridden,eg,superseded,in,the,snapshot,so,far,if,two,operations,have,the,same,sequence,number,the,operation,with,a,lower,term,will,be,overridden,by,the,operation,with,a,higher,term,unlike,link,total,operations,this,value,is,updated,each,time,after,link,next,is,called;default,int,overridden,operations,return,0
Translog -> Snapshot -> default int overriddenOperations();1525334055;The number of operations have been overridden (eg. superseded) in the snapshot so far._If two operations have the same sequence number, the operation with a lower term will be overridden by the operation_with a higher term. Unlike {@link #totalOperations()}, this value is updated each time after {@link #next()}) is called.;default int overriddenOperations() {_            return 0__        };the,number,of,operations,have,been,overridden,eg,superseded,in,the,snapshot,so,far,if,two,operations,have,the,same,sequence,number,the,operation,with,a,lower,term,will,be,overridden,by,the,operation,with,a,higher,term,unlike,link,total,operations,this,value,is,updated,each,time,after,link,next,is,called;default,int,overridden,operations,return,0
Translog -> Snapshot -> default int overriddenOperations();1528706846;The number of operations have been overridden (eg. superseded) in the snapshot so far._If two operations have the same sequence number, the operation with a lower term will be overridden by the operation_with a higher term. Unlike {@link #totalOperations()}, this value is updated each time after {@link #next()}) is called.;default int overriddenOperations() {_            return 0__        };the,number,of,operations,have,been,overridden,eg,superseded,in,the,snapshot,so,far,if,two,operations,have,the,same,sequence,number,the,operation,with,a,lower,term,will,be,overridden,by,the,operation,with,a,higher,term,unlike,link,total,operations,this,value,is,updated,each,time,after,link,next,is,called;default,int,overridden,operations,return,0
Translog -> Snapshot -> default int overriddenOperations();1531910483;The number of operations have been overridden (eg. superseded) in the snapshot so far._If two operations have the same sequence number, the operation with a lower term will be overridden by the operation_with a higher term. Unlike {@link #totalOperations()}, this value is updated each time after {@link #next()}) is called.;default int overriddenOperations() {_            return 0__        };the,number,of,operations,have,been,overridden,eg,superseded,in,the,snapshot,so,far,if,two,operations,have,the,same,sequence,number,the,operation,with,a,lower,term,will,be,overridden,by,the,operation,with,a,higher,term,unlike,link,total,operations,this,value,is,updated,each,time,after,link,next,is,called;default,int,overridden,operations,return,0
Translog -> Snapshot -> default int overriddenOperations();1533295538;The number of operations have been overridden (eg. superseded) in the snapshot so far._If two operations have the same sequence number, the operation with a lower term will be overridden by the operation_with a higher term. Unlike {@link #totalOperations()}, this value is updated each time after {@link #next()}) is called.;default int overriddenOperations() {_            return 0__        };the,number,of,operations,have,been,overridden,eg,superseded,in,the,snapshot,so,far,if,two,operations,have,the,same,sequence,number,the,operation,with,a,lower,term,will,be,overridden,by,the,operation,with,a,higher,term,unlike,link,total,operations,this,value,is,updated,each,time,after,link,next,is,called;default,int,overridden,operations,return,0
Translog -> Snapshot -> default int overriddenOperations();1533641732;The number of operations have been overridden (eg. superseded) in the snapshot so far._If two operations have the same sequence number, the operation with a lower term will be overridden by the operation_with a higher term. Unlike {@link #totalOperations()}, this value is updated each time after {@link #next()}) is called.;default int overriddenOperations() {_            return 0__        };the,number,of,operations,have,been,overridden,eg,superseded,in,the,snapshot,so,far,if,two,operations,have,the,same,sequence,number,the,operation,with,a,lower,term,will,be,overridden,by,the,operation,with,a,higher,term,unlike,link,total,operations,this,value,is,updated,each,time,after,link,next,is,called;default,int,overridden,operations,return,0
Translog -> Snapshot -> default int overriddenOperations();1534848846;The number of operations have been overridden (eg. superseded) in the snapshot so far._If two operations have the same sequence number, the operation with a lower term will be overridden by the operation_with a higher term. Unlike {@link #totalOperations()}, this value is updated each time after {@link #next()}) is called.;default int overriddenOperations() {_            return 0__        };the,number,of,operations,have,been,overridden,eg,superseded,in,the,snapshot,so,far,if,two,operations,have,the,same,sequence,number,the,operation,with,a,lower,term,will,be,overridden,by,the,operation,with,a,higher,term,unlike,link,total,operations,this,value,is,updated,each,time,after,link,next,is,called;default,int,overridden,operations,return,0
Translog -> Snapshot -> default int overriddenOperations();1535046779;The number of operations have been overridden (eg. superseded) in the snapshot so far._If two operations have the same sequence number, the operation with a lower term will be overridden by the operation_with a higher term. Unlike {@link #totalOperations()}, this value is updated each time after {@link #next()}) is called.;default int overriddenOperations() {_            return 0__        };the,number,of,operations,have,been,overridden,eg,superseded,in,the,snapshot,so,far,if,two,operations,have,the,same,sequence,number,the,operation,with,a,lower,term,will,be,overridden,by,the,operation,with,a,higher,term,unlike,link,total,operations,this,value,is,updated,each,time,after,link,next,is,called;default,int,overridden,operations,return,0
Translog -> Snapshot -> default int overriddenOperations();1535723122;The number of operations have been overridden (eg. superseded) in the snapshot so far._If two operations have the same sequence number, the operation with a lower term will be overridden by the operation_with a higher term. Unlike {@link #totalOperations()}, this value is updated each time after {@link #next()}) is called.;default int overriddenOperations() {_            return 0__        };the,number,of,operations,have,been,overridden,eg,superseded,in,the,snapshot,so,far,if,two,operations,have,the,same,sequence,number,the,operation,with,a,lower,term,will,be,overridden,by,the,operation,with,a,higher,term,unlike,link,total,operations,this,value,is,updated,each,time,after,link,next,is,called;default,int,overridden,operations,return,0
Translog -> Snapshot -> default int overriddenOperations();1537806831;The number of operations have been overridden (eg. superseded) in the snapshot so far._If two operations have the same sequence number, the operation with a lower term will be overridden by the operation_with a higher term. Unlike {@link #totalOperations()}, this value is updated each time after {@link #next()}) is called.;default int overriddenOperations() {_            return 0__        };the,number,of,operations,have,been,overridden,eg,superseded,in,the,snapshot,so,far,if,two,operations,have,the,same,sequence,number,the,operation,with,a,lower,term,will,be,overridden,by,the,operation,with,a,higher,term,unlike,link,total,operations,this,value,is,updated,each,time,after,link,next,is,called;default,int,overridden,operations,return,0
Translog -> Snapshot -> default int overriddenOperations();1541592065;The number of operations have been overridden (eg. superseded) in the snapshot so far._If two operations have the same sequence number, the operation with a lower term will be overridden by the operation_with a higher term. Unlike {@link #totalOperations()}, this value is updated each time after {@link #next()}) is called.;default int overriddenOperations() {_            return 0__        };the,number,of,operations,have,been,overridden,eg,superseded,in,the,snapshot,so,far,if,two,operations,have,the,same,sequence,number,the,operation,with,a,lower,term,will,be,overridden,by,the,operation,with,a,higher,term,unlike,link,total,operations,this,value,is,updated,each,time,after,link,next,is,called;default,int,overridden,operations,return,0
Translog -> Snapshot -> default int overriddenOperations();1542697754;The number of operations have been overridden (eg. superseded) in the snapshot so far._If two operations have the same sequence number, the operation with a lower term will be overridden by the operation_with a higher term. Unlike {@link #totalOperations()}, this value is updated each time after {@link #next()}) is called.;default int overriddenOperations() {_            return 0__        };the,number,of,operations,have,been,overridden,eg,superseded,in,the,snapshot,so,far,if,two,operations,have,the,same,sequence,number,the,operation,with,a,lower,term,will,be,overridden,by,the,operation,with,a,higher,term,unlike,link,total,operations,this,value,is,updated,each,time,after,link,next,is,called;default,int,overridden,operations,return,0
Translog -> Snapshot -> default int overriddenOperations();1542962614;The number of operations have been overridden (eg. superseded) in the snapshot so far._If two operations have the same sequence number, the operation with a lower term will be overridden by the operation_with a higher term. Unlike {@link #totalOperations()}, this value is updated each time after {@link #next()}) is called.;default int overriddenOperations() {_            return 0__        };the,number,of,operations,have,been,overridden,eg,superseded,in,the,snapshot,so,far,if,two,operations,have,the,same,sequence,number,the,operation,with,a,lower,term,will,be,overridden,by,the,operation,with,a,higher,term,unlike,link,total,operations,this,value,is,updated,each,time,after,link,next,is,called;default,int,overridden,operations,return,0
Translog -> Snapshot -> default int overriddenOperations();1545236365;The number of operations have been overridden (eg. superseded) in the snapshot so far._If two operations have the same sequence number, the operation with a lower term will be overridden by the operation_with a higher term. Unlike {@link #totalOperations()}, this value is updated each time after {@link #next()}) is called.;default int overriddenOperations() {_            return 0__        };the,number,of,operations,have,been,overridden,eg,superseded,in,the,snapshot,so,far,if,two,operations,have,the,same,sequence,number,the,operation,with,a,lower,term,will,be,overridden,by,the,operation,with,a,higher,term,unlike,link,total,operations,this,value,is,updated,each,time,after,link,next,is,called;default,int,overridden,operations,return,0
Translog -> public void trimOperations(long belowTerm, long aboveSeqNo) throws IOException;1528706846;Trims translog for terms of files below <code>belowTerm</code> and seq# above <code>aboveSeqNo</code>._Effectively it moves max visible seq# {@link Checkpoint#trimmedAboveSeqNo} therefore {@link TranslogSnapshot} skips those operations.;public void trimOperations(long belowTerm, long aboveSeqNo) throws IOException {_        assert aboveSeqNo >= SequenceNumbers.NO_OPS_PERFORMED : "aboveSeqNo has to a valid sequence number"___        try (ReleasableLock lock = writeLock.acquire()) {_            ensureOpen()__            if (current.getPrimaryTerm() < belowTerm) {_                throw new IllegalArgumentException("Trimming the translog can only be done for terms lower than the current one. " +_                    "Trim requested for term [ " + belowTerm + " ] , current is [ " + current.getPrimaryTerm() + " ]")__            }_            _            assert current.assertNoSeqAbove(belowTerm, aboveSeqNo)__            _            final List<TranslogReader> newReaders = new ArrayList<>(readers.size())__            try {_                for (TranslogReader reader : readers) {_                    final TranslogReader newReader =_                        reader.getPrimaryTerm() < belowTerm_                            ? reader.closeIntoTrimmedReader(aboveSeqNo, getChannelFactory())_                            : reader__                    newReaders.add(newReader)__                }_            } catch (IOException e) {_                IOUtils.closeWhileHandlingException(newReaders)__                close()__                throw e__            }__            this.readers.clear()__            this.readers.addAll(newReaders)__        }_    };trims,translog,for,terms,of,files,below,code,below,term,code,and,seq,above,code,above,seq,no,code,effectively,it,moves,max,visible,seq,link,checkpoint,trimmed,above,seq,no,therefore,link,translog,snapshot,skips,those,operations;public,void,trim,operations,long,below,term,long,above,seq,no,throws,ioexception,assert,above,seq,no,sequence,numbers,above,seq,no,has,to,a,valid,sequence,number,try,releasable,lock,lock,write,lock,acquire,ensure,open,if,current,get,primary,term,below,term,throw,new,illegal,argument,exception,trimming,the,translog,can,only,be,done,for,terms,lower,than,the,current,one,trim,requested,for,term,below,term,current,is,current,get,primary,term,assert,current,assert,no,seq,above,below,term,above,seq,no,final,list,translog,reader,new,readers,new,array,list,readers,size,try,for,translog,reader,reader,readers,final,translog,reader,new,reader,reader,get,primary,term,below,term,reader,close,into,trimmed,reader,above,seq,no,get,channel,factory,reader,new,readers,add,new,reader,catch,ioexception,e,ioutils,close,while,handling,exception,new,readers,close,throw,e,this,readers,clear,this,readers,add,all,new,readers
Translog -> public void trimOperations(long belowTerm, long aboveSeqNo) throws IOException;1531910483;Trims translog for terms of files below <code>belowTerm</code> and seq# above <code>aboveSeqNo</code>._Effectively it moves max visible seq# {@link Checkpoint#trimmedAboveSeqNo} therefore {@link TranslogSnapshot} skips those operations.;public void trimOperations(long belowTerm, long aboveSeqNo) throws IOException {_        assert aboveSeqNo >= SequenceNumbers.NO_OPS_PERFORMED : "aboveSeqNo has to a valid sequence number"___        try (ReleasableLock lock = writeLock.acquire()) {_            ensureOpen()__            if (current.getPrimaryTerm() < belowTerm) {_                throw new IllegalArgumentException("Trimming the translog can only be done for terms lower than the current one. " +_                    "Trim requested for term [ " + belowTerm + " ] , current is [ " + current.getPrimaryTerm() + " ]")__            }_            _            assert current.assertNoSeqAbove(belowTerm, aboveSeqNo)__            _            final List<TranslogReader> newReaders = new ArrayList<>(readers.size())__            try {_                for (TranslogReader reader : readers) {_                    final TranslogReader newReader =_                        reader.getPrimaryTerm() < belowTerm_                            ? reader.closeIntoTrimmedReader(aboveSeqNo, getChannelFactory())_                            : reader__                    newReaders.add(newReader)__                }_            } catch (IOException e) {_                IOUtils.closeWhileHandlingException(newReaders)__                close()__                throw e__            }__            this.readers.clear()__            this.readers.addAll(newReaders)__        }_    };trims,translog,for,terms,of,files,below,code,below,term,code,and,seq,above,code,above,seq,no,code,effectively,it,moves,max,visible,seq,link,checkpoint,trimmed,above,seq,no,therefore,link,translog,snapshot,skips,those,operations;public,void,trim,operations,long,below,term,long,above,seq,no,throws,ioexception,assert,above,seq,no,sequence,numbers,above,seq,no,has,to,a,valid,sequence,number,try,releasable,lock,lock,write,lock,acquire,ensure,open,if,current,get,primary,term,below,term,throw,new,illegal,argument,exception,trimming,the,translog,can,only,be,done,for,terms,lower,than,the,current,one,trim,requested,for,term,below,term,current,is,current,get,primary,term,assert,current,assert,no,seq,above,below,term,above,seq,no,final,list,translog,reader,new,readers,new,array,list,readers,size,try,for,translog,reader,reader,readers,final,translog,reader,new,reader,reader,get,primary,term,below,term,reader,close,into,trimmed,reader,above,seq,no,get,channel,factory,reader,new,readers,add,new,reader,catch,ioexception,e,ioutils,close,while,handling,exception,new,readers,close,throw,e,this,readers,clear,this,readers,add,all,new,readers
Translog -> public void trimOperations(long belowTerm, long aboveSeqNo) throws IOException;1533295538;Trims translog for terms of files below <code>belowTerm</code> and seq# above <code>aboveSeqNo</code>._Effectively it moves max visible seq# {@link Checkpoint#trimmedAboveSeqNo} therefore {@link TranslogSnapshot} skips those operations.;public void trimOperations(long belowTerm, long aboveSeqNo) throws IOException {_        assert aboveSeqNo >= SequenceNumbers.NO_OPS_PERFORMED : "aboveSeqNo has to a valid sequence number"___        try (ReleasableLock lock = writeLock.acquire()) {_            ensureOpen()__            if (current.getPrimaryTerm() < belowTerm) {_                throw new IllegalArgumentException("Trimming the translog can only be done for terms lower than the current one. " +_                    "Trim requested for term [ " + belowTerm + " ] , current is [ " + current.getPrimaryTerm() + " ]")__            }_            _            assert current.assertNoSeqAbove(belowTerm, aboveSeqNo)__            _            final List<TranslogReader> newReaders = new ArrayList<>(readers.size())__            try {_                for (TranslogReader reader : readers) {_                    final TranslogReader newReader =_                        reader.getPrimaryTerm() < belowTerm_                            ? reader.closeIntoTrimmedReader(aboveSeqNo, getChannelFactory())_                            : reader__                    newReaders.add(newReader)__                }_            } catch (IOException e) {_                IOUtils.closeWhileHandlingException(newReaders)__                close()__                throw e__            }__            this.readers.clear()__            this.readers.addAll(newReaders)__        }_    };trims,translog,for,terms,of,files,below,code,below,term,code,and,seq,above,code,above,seq,no,code,effectively,it,moves,max,visible,seq,link,checkpoint,trimmed,above,seq,no,therefore,link,translog,snapshot,skips,those,operations;public,void,trim,operations,long,below,term,long,above,seq,no,throws,ioexception,assert,above,seq,no,sequence,numbers,above,seq,no,has,to,a,valid,sequence,number,try,releasable,lock,lock,write,lock,acquire,ensure,open,if,current,get,primary,term,below,term,throw,new,illegal,argument,exception,trimming,the,translog,can,only,be,done,for,terms,lower,than,the,current,one,trim,requested,for,term,below,term,current,is,current,get,primary,term,assert,current,assert,no,seq,above,below,term,above,seq,no,final,list,translog,reader,new,readers,new,array,list,readers,size,try,for,translog,reader,reader,readers,final,translog,reader,new,reader,reader,get,primary,term,below,term,reader,close,into,trimmed,reader,above,seq,no,get,channel,factory,reader,new,readers,add,new,reader,catch,ioexception,e,ioutils,close,while,handling,exception,new,readers,close,throw,e,this,readers,clear,this,readers,add,all,new,readers
Translog -> public void trimOperations(long belowTerm, long aboveSeqNo) throws IOException;1533641732;Trims translog for terms of files below <code>belowTerm</code> and seq# above <code>aboveSeqNo</code>._Effectively it moves max visible seq# {@link Checkpoint#trimmedAboveSeqNo} therefore {@link TranslogSnapshot} skips those operations.;public void trimOperations(long belowTerm, long aboveSeqNo) throws IOException {_        assert aboveSeqNo >= SequenceNumbers.NO_OPS_PERFORMED : "aboveSeqNo has to a valid sequence number"___        try (ReleasableLock lock = writeLock.acquire()) {_            ensureOpen()__            if (current.getPrimaryTerm() < belowTerm) {_                throw new IllegalArgumentException("Trimming the translog can only be done for terms lower than the current one. " +_                    "Trim requested for term [ " + belowTerm + " ] , current is [ " + current.getPrimaryTerm() + " ]")__            }_            _            assert current.assertNoSeqAbove(belowTerm, aboveSeqNo)__            _            final List<TranslogReader> newReaders = new ArrayList<>(readers.size())__            try {_                for (TranslogReader reader : readers) {_                    final TranslogReader newReader =_                        reader.getPrimaryTerm() < belowTerm_                            ? reader.closeIntoTrimmedReader(aboveSeqNo, getChannelFactory())_                            : reader__                    newReaders.add(newReader)__                }_            } catch (IOException e) {_                IOUtils.closeWhileHandlingException(newReaders)__                close()__                throw e__            }__            this.readers.clear()__            this.readers.addAll(newReaders)__        }_    };trims,translog,for,terms,of,files,below,code,below,term,code,and,seq,above,code,above,seq,no,code,effectively,it,moves,max,visible,seq,link,checkpoint,trimmed,above,seq,no,therefore,link,translog,snapshot,skips,those,operations;public,void,trim,operations,long,below,term,long,above,seq,no,throws,ioexception,assert,above,seq,no,sequence,numbers,above,seq,no,has,to,a,valid,sequence,number,try,releasable,lock,lock,write,lock,acquire,ensure,open,if,current,get,primary,term,below,term,throw,new,illegal,argument,exception,trimming,the,translog,can,only,be,done,for,terms,lower,than,the,current,one,trim,requested,for,term,below,term,current,is,current,get,primary,term,assert,current,assert,no,seq,above,below,term,above,seq,no,final,list,translog,reader,new,readers,new,array,list,readers,size,try,for,translog,reader,reader,readers,final,translog,reader,new,reader,reader,get,primary,term,below,term,reader,close,into,trimmed,reader,above,seq,no,get,channel,factory,reader,new,readers,add,new,reader,catch,ioexception,e,ioutils,close,while,handling,exception,new,readers,close,throw,e,this,readers,clear,this,readers,add,all,new,readers
Translog -> public void trimOperations(long belowTerm, long aboveSeqNo) throws IOException;1534848846;Trims translog for terms of files below <code>belowTerm</code> and seq# above <code>aboveSeqNo</code>._Effectively it moves max visible seq# {@link Checkpoint#trimmedAboveSeqNo} therefore {@link TranslogSnapshot} skips those operations.;public void trimOperations(long belowTerm, long aboveSeqNo) throws IOException {_        assert aboveSeqNo >= SequenceNumbers.NO_OPS_PERFORMED : "aboveSeqNo has to a valid sequence number"___        try (ReleasableLock lock = writeLock.acquire()) {_            ensureOpen()__            if (current.getPrimaryTerm() < belowTerm) {_                throw new IllegalArgumentException("Trimming the translog can only be done for terms lower than the current one. " +_                    "Trim requested for term [ " + belowTerm + " ] , current is [ " + current.getPrimaryTerm() + " ]")__            }_            _            assert current.assertNoSeqAbove(belowTerm, aboveSeqNo)__            _            final List<TranslogReader> newReaders = new ArrayList<>(readers.size())__            try {_                for (TranslogReader reader : readers) {_                    final TranslogReader newReader =_                        reader.getPrimaryTerm() < belowTerm_                            ? reader.closeIntoTrimmedReader(aboveSeqNo, getChannelFactory())_                            : reader__                    newReaders.add(newReader)__                }_            } catch (IOException e) {_                IOUtils.closeWhileHandlingException(newReaders)__                tragedy.setTragicException(e)__                closeOnTragicEvent(e)__                throw e__            }__            this.readers.clear()__            this.readers.addAll(newReaders)__        }_    };trims,translog,for,terms,of,files,below,code,below,term,code,and,seq,above,code,above,seq,no,code,effectively,it,moves,max,visible,seq,link,checkpoint,trimmed,above,seq,no,therefore,link,translog,snapshot,skips,those,operations;public,void,trim,operations,long,below,term,long,above,seq,no,throws,ioexception,assert,above,seq,no,sequence,numbers,above,seq,no,has,to,a,valid,sequence,number,try,releasable,lock,lock,write,lock,acquire,ensure,open,if,current,get,primary,term,below,term,throw,new,illegal,argument,exception,trimming,the,translog,can,only,be,done,for,terms,lower,than,the,current,one,trim,requested,for,term,below,term,current,is,current,get,primary,term,assert,current,assert,no,seq,above,below,term,above,seq,no,final,list,translog,reader,new,readers,new,array,list,readers,size,try,for,translog,reader,reader,readers,final,translog,reader,new,reader,reader,get,primary,term,below,term,reader,close,into,trimmed,reader,above,seq,no,get,channel,factory,reader,new,readers,add,new,reader,catch,ioexception,e,ioutils,close,while,handling,exception,new,readers,tragedy,set,tragic,exception,e,close,on,tragic,event,e,throw,e,this,readers,clear,this,readers,add,all,new,readers
Translog -> public void trimOperations(long belowTerm, long aboveSeqNo) throws IOException;1535046779;Trims translog for terms of files below <code>belowTerm</code> and seq# above <code>aboveSeqNo</code>._Effectively it moves max visible seq# {@link Checkpoint#trimmedAboveSeqNo} therefore {@link TranslogSnapshot} skips those operations.;public void trimOperations(long belowTerm, long aboveSeqNo) throws IOException {_        assert aboveSeqNo >= SequenceNumbers.NO_OPS_PERFORMED : "aboveSeqNo has to a valid sequence number"___        try (ReleasableLock lock = writeLock.acquire()) {_            ensureOpen()__            if (current.getPrimaryTerm() < belowTerm) {_                throw new IllegalArgumentException("Trimming the translog can only be done for terms lower than the current one. " +_                    "Trim requested for term [ " + belowTerm + " ] , current is [ " + current.getPrimaryTerm() + " ]")__            }_            _            assert current.assertNoSeqAbove(belowTerm, aboveSeqNo)__            _            final List<TranslogReader> newReaders = new ArrayList<>(readers.size())__            try {_                for (TranslogReader reader : readers) {_                    final TranslogReader newReader =_                        reader.getPrimaryTerm() < belowTerm_                            ? reader.closeIntoTrimmedReader(aboveSeqNo, getChannelFactory())_                            : reader__                    newReaders.add(newReader)__                }_            } catch (IOException e) {_                IOUtils.closeWhileHandlingException(newReaders)__                tragedy.setTragicException(e)__                closeOnTragicEvent(e)__                throw e__            }__            this.readers.clear()__            this.readers.addAll(newReaders)__        }_    };trims,translog,for,terms,of,files,below,code,below,term,code,and,seq,above,code,above,seq,no,code,effectively,it,moves,max,visible,seq,link,checkpoint,trimmed,above,seq,no,therefore,link,translog,snapshot,skips,those,operations;public,void,trim,operations,long,below,term,long,above,seq,no,throws,ioexception,assert,above,seq,no,sequence,numbers,above,seq,no,has,to,a,valid,sequence,number,try,releasable,lock,lock,write,lock,acquire,ensure,open,if,current,get,primary,term,below,term,throw,new,illegal,argument,exception,trimming,the,translog,can,only,be,done,for,terms,lower,than,the,current,one,trim,requested,for,term,below,term,current,is,current,get,primary,term,assert,current,assert,no,seq,above,below,term,above,seq,no,final,list,translog,reader,new,readers,new,array,list,readers,size,try,for,translog,reader,reader,readers,final,translog,reader,new,reader,reader,get,primary,term,below,term,reader,close,into,trimmed,reader,above,seq,no,get,channel,factory,reader,new,readers,add,new,reader,catch,ioexception,e,ioutils,close,while,handling,exception,new,readers,tragedy,set,tragic,exception,e,close,on,tragic,event,e,throw,e,this,readers,clear,this,readers,add,all,new,readers
Translog -> public void trimOperations(long belowTerm, long aboveSeqNo) throws IOException;1535723122;Trims translog for terms of files below <code>belowTerm</code> and seq# above <code>aboveSeqNo</code>._Effectively it moves max visible seq# {@link Checkpoint#trimmedAboveSeqNo} therefore {@link TranslogSnapshot} skips those operations.;public void trimOperations(long belowTerm, long aboveSeqNo) throws IOException {_        assert aboveSeqNo >= SequenceNumbers.NO_OPS_PERFORMED : "aboveSeqNo has to a valid sequence number"___        try (ReleasableLock lock = writeLock.acquire()) {_            ensureOpen()__            if (current.getPrimaryTerm() < belowTerm) {_                throw new IllegalArgumentException("Trimming the translog can only be done for terms lower than the current one. " +_                    "Trim requested for term [ " + belowTerm + " ] , current is [ " + current.getPrimaryTerm() + " ]")__            }_            _            assert current.assertNoSeqAbove(belowTerm, aboveSeqNo)__            _            final List<TranslogReader> newReaders = new ArrayList<>(readers.size())__            try {_                for (TranslogReader reader : readers) {_                    final TranslogReader newReader =_                        reader.getPrimaryTerm() < belowTerm_                            ? reader.closeIntoTrimmedReader(aboveSeqNo, getChannelFactory())_                            : reader__                    newReaders.add(newReader)__                }_            } catch (IOException e) {_                IOUtils.closeWhileHandlingException(newReaders)__                tragedy.setTragicException(e)__                closeOnTragicEvent(e)__                throw e__            }__            this.readers.clear()__            this.readers.addAll(newReaders)__        }_    };trims,translog,for,terms,of,files,below,code,below,term,code,and,seq,above,code,above,seq,no,code,effectively,it,moves,max,visible,seq,link,checkpoint,trimmed,above,seq,no,therefore,link,translog,snapshot,skips,those,operations;public,void,trim,operations,long,below,term,long,above,seq,no,throws,ioexception,assert,above,seq,no,sequence,numbers,above,seq,no,has,to,a,valid,sequence,number,try,releasable,lock,lock,write,lock,acquire,ensure,open,if,current,get,primary,term,below,term,throw,new,illegal,argument,exception,trimming,the,translog,can,only,be,done,for,terms,lower,than,the,current,one,trim,requested,for,term,below,term,current,is,current,get,primary,term,assert,current,assert,no,seq,above,below,term,above,seq,no,final,list,translog,reader,new,readers,new,array,list,readers,size,try,for,translog,reader,reader,readers,final,translog,reader,new,reader,reader,get,primary,term,below,term,reader,close,into,trimmed,reader,above,seq,no,get,channel,factory,reader,new,readers,add,new,reader,catch,ioexception,e,ioutils,close,while,handling,exception,new,readers,tragedy,set,tragic,exception,e,close,on,tragic,event,e,throw,e,this,readers,clear,this,readers,add,all,new,readers
Translog -> public void trimOperations(long belowTerm, long aboveSeqNo) throws IOException;1537806831;Trims translog for terms of files below <code>belowTerm</code> and seq# above <code>aboveSeqNo</code>._Effectively it moves max visible seq# {@link Checkpoint#trimmedAboveSeqNo} therefore {@link TranslogSnapshot} skips those operations.;public void trimOperations(long belowTerm, long aboveSeqNo) throws IOException {_        assert aboveSeqNo >= SequenceNumbers.NO_OPS_PERFORMED : "aboveSeqNo has to a valid sequence number"___        try (ReleasableLock lock = writeLock.acquire()) {_            ensureOpen()__            if (current.getPrimaryTerm() < belowTerm) {_                throw new IllegalArgumentException("Trimming the translog can only be done for terms lower than the current one. " +_                    "Trim requested for term [ " + belowTerm + " ] , current is [ " + current.getPrimaryTerm() + " ]")__            }_            _            assert current.assertNoSeqAbove(belowTerm, aboveSeqNo)__            _            final List<TranslogReader> newReaders = new ArrayList<>(readers.size())__            try {_                for (TranslogReader reader : readers) {_                    final TranslogReader newReader =_                        reader.getPrimaryTerm() < belowTerm_                            ? reader.closeIntoTrimmedReader(aboveSeqNo, getChannelFactory())_                            : reader__                    newReaders.add(newReader)__                }_            } catch (IOException e) {_                IOUtils.closeWhileHandlingException(newReaders)__                tragedy.setTragicException(e)__                closeOnTragicEvent(e)__                throw e__            }__            this.readers.clear()__            this.readers.addAll(newReaders)__        }_    };trims,translog,for,terms,of,files,below,code,below,term,code,and,seq,above,code,above,seq,no,code,effectively,it,moves,max,visible,seq,link,checkpoint,trimmed,above,seq,no,therefore,link,translog,snapshot,skips,those,operations;public,void,trim,operations,long,below,term,long,above,seq,no,throws,ioexception,assert,above,seq,no,sequence,numbers,above,seq,no,has,to,a,valid,sequence,number,try,releasable,lock,lock,write,lock,acquire,ensure,open,if,current,get,primary,term,below,term,throw,new,illegal,argument,exception,trimming,the,translog,can,only,be,done,for,terms,lower,than,the,current,one,trim,requested,for,term,below,term,current,is,current,get,primary,term,assert,current,assert,no,seq,above,below,term,above,seq,no,final,list,translog,reader,new,readers,new,array,list,readers,size,try,for,translog,reader,reader,readers,final,translog,reader,new,reader,reader,get,primary,term,below,term,reader,close,into,trimmed,reader,above,seq,no,get,channel,factory,reader,new,readers,add,new,reader,catch,ioexception,e,ioutils,close,while,handling,exception,new,readers,tragedy,set,tragic,exception,e,close,on,tragic,event,e,throw,e,this,readers,clear,this,readers,add,all,new,readers
Translog -> public void trimOperations(long belowTerm, long aboveSeqNo) throws IOException;1541592065;Trims translog for terms of files below <code>belowTerm</code> and seq# above <code>aboveSeqNo</code>._Effectively it moves max visible seq# {@link Checkpoint#trimmedAboveSeqNo} therefore {@link TranslogSnapshot} skips those operations.;public void trimOperations(long belowTerm, long aboveSeqNo) throws IOException {_        assert aboveSeqNo >= SequenceNumbers.NO_OPS_PERFORMED : "aboveSeqNo has to a valid sequence number"___        try (ReleasableLock lock = writeLock.acquire()) {_            ensureOpen()__            if (current.getPrimaryTerm() < belowTerm) {_                throw new IllegalArgumentException("Trimming the translog can only be done for terms lower than the current one. " +_                    "Trim requested for term [ " + belowTerm + " ] , current is [ " + current.getPrimaryTerm() + " ]")__            }_            _            assert current.assertNoSeqAbove(belowTerm, aboveSeqNo)__            _            final List<TranslogReader> newReaders = new ArrayList<>(readers.size())__            try {_                for (TranslogReader reader : readers) {_                    final TranslogReader newReader =_                        reader.getPrimaryTerm() < belowTerm_                            ? reader.closeIntoTrimmedReader(aboveSeqNo, getChannelFactory())_                            : reader__                    newReaders.add(newReader)__                }_            } catch (IOException e) {_                IOUtils.closeWhileHandlingException(newReaders)__                tragedy.setTragicException(e)__                closeOnTragicEvent(e)__                throw e__            }__            this.readers.clear()__            this.readers.addAll(newReaders)__        }_    };trims,translog,for,terms,of,files,below,code,below,term,code,and,seq,above,code,above,seq,no,code,effectively,it,moves,max,visible,seq,link,checkpoint,trimmed,above,seq,no,therefore,link,translog,snapshot,skips,those,operations;public,void,trim,operations,long,below,term,long,above,seq,no,throws,ioexception,assert,above,seq,no,sequence,numbers,above,seq,no,has,to,a,valid,sequence,number,try,releasable,lock,lock,write,lock,acquire,ensure,open,if,current,get,primary,term,below,term,throw,new,illegal,argument,exception,trimming,the,translog,can,only,be,done,for,terms,lower,than,the,current,one,trim,requested,for,term,below,term,current,is,current,get,primary,term,assert,current,assert,no,seq,above,below,term,above,seq,no,final,list,translog,reader,new,readers,new,array,list,readers,size,try,for,translog,reader,reader,readers,final,translog,reader,new,reader,reader,get,primary,term,below,term,reader,close,into,trimmed,reader,above,seq,no,get,channel,factory,reader,new,readers,add,new,reader,catch,ioexception,e,ioutils,close,while,handling,exception,new,readers,tragedy,set,tragic,exception,e,close,on,tragic,event,e,throw,e,this,readers,clear,this,readers,add,all,new,readers
Translog -> public void trimOperations(long belowTerm, long aboveSeqNo) throws IOException;1542697754;Trims translog for terms of files below <code>belowTerm</code> and seq# above <code>aboveSeqNo</code>._Effectively it moves max visible seq# {@link Checkpoint#trimmedAboveSeqNo} therefore {@link TranslogSnapshot} skips those operations.;public void trimOperations(long belowTerm, long aboveSeqNo) throws IOException {_        assert aboveSeqNo >= SequenceNumbers.NO_OPS_PERFORMED : "aboveSeqNo has to a valid sequence number"___        try (ReleasableLock lock = writeLock.acquire()) {_            ensureOpen()__            if (current.getPrimaryTerm() < belowTerm) {_                throw new IllegalArgumentException("Trimming the translog can only be done for terms lower than the current one. " +_                    "Trim requested for term [ " + belowTerm + " ] , current is [ " + current.getPrimaryTerm() + " ]")__            }_            _            assert current.assertNoSeqAbove(belowTerm, aboveSeqNo)__            _            final List<TranslogReader> newReaders = new ArrayList<>(readers.size())__            try {_                for (TranslogReader reader : readers) {_                    final TranslogReader newReader =_                        reader.getPrimaryTerm() < belowTerm_                            ? reader.closeIntoTrimmedReader(aboveSeqNo, getChannelFactory())_                            : reader__                    newReaders.add(newReader)__                }_            } catch (IOException e) {_                IOUtils.closeWhileHandlingException(newReaders)__                tragedy.setTragicException(e)__                closeOnTragicEvent(e)__                throw e__            }__            this.readers.clear()__            this.readers.addAll(newReaders)__        }_    };trims,translog,for,terms,of,files,below,code,below,term,code,and,seq,above,code,above,seq,no,code,effectively,it,moves,max,visible,seq,link,checkpoint,trimmed,above,seq,no,therefore,link,translog,snapshot,skips,those,operations;public,void,trim,operations,long,below,term,long,above,seq,no,throws,ioexception,assert,above,seq,no,sequence,numbers,above,seq,no,has,to,a,valid,sequence,number,try,releasable,lock,lock,write,lock,acquire,ensure,open,if,current,get,primary,term,below,term,throw,new,illegal,argument,exception,trimming,the,translog,can,only,be,done,for,terms,lower,than,the,current,one,trim,requested,for,term,below,term,current,is,current,get,primary,term,assert,current,assert,no,seq,above,below,term,above,seq,no,final,list,translog,reader,new,readers,new,array,list,readers,size,try,for,translog,reader,reader,readers,final,translog,reader,new,reader,reader,get,primary,term,below,term,reader,close,into,trimmed,reader,above,seq,no,get,channel,factory,reader,new,readers,add,new,reader,catch,ioexception,e,ioutils,close,while,handling,exception,new,readers,tragedy,set,tragic,exception,e,close,on,tragic,event,e,throw,e,this,readers,clear,this,readers,add,all,new,readers
Translog -> public void trimOperations(long belowTerm, long aboveSeqNo) throws IOException;1542962614;Trims translog for terms of files below <code>belowTerm</code> and seq# above <code>aboveSeqNo</code>._Effectively it moves max visible seq# {@link Checkpoint#trimmedAboveSeqNo} therefore {@link TranslogSnapshot} skips those operations.;public void trimOperations(long belowTerm, long aboveSeqNo) throws IOException {_        assert aboveSeqNo >= SequenceNumbers.NO_OPS_PERFORMED : "aboveSeqNo has to a valid sequence number"___        try (ReleasableLock lock = writeLock.acquire()) {_            ensureOpen()__            if (current.getPrimaryTerm() < belowTerm) {_                throw new IllegalArgumentException("Trimming the translog can only be done for terms lower than the current one. " +_                    "Trim requested for term [ " + belowTerm + " ] , current is [ " + current.getPrimaryTerm() + " ]")__            }_            _            assert current.assertNoSeqAbove(belowTerm, aboveSeqNo)__            _            final List<TranslogReader> newReaders = new ArrayList<>(readers.size())__            try {_                for (TranslogReader reader : readers) {_                    final TranslogReader newReader =_                        reader.getPrimaryTerm() < belowTerm_                            ? reader.closeIntoTrimmedReader(aboveSeqNo, getChannelFactory())_                            : reader__                    newReaders.add(newReader)__                }_            } catch (IOException e) {_                IOUtils.closeWhileHandlingException(newReaders)__                tragedy.setTragicException(e)__                closeOnTragicEvent(e)__                throw e__            }__            this.readers.clear()__            this.readers.addAll(newReaders)__        }_    };trims,translog,for,terms,of,files,below,code,below,term,code,and,seq,above,code,above,seq,no,code,effectively,it,moves,max,visible,seq,link,checkpoint,trimmed,above,seq,no,therefore,link,translog,snapshot,skips,those,operations;public,void,trim,operations,long,below,term,long,above,seq,no,throws,ioexception,assert,above,seq,no,sequence,numbers,above,seq,no,has,to,a,valid,sequence,number,try,releasable,lock,lock,write,lock,acquire,ensure,open,if,current,get,primary,term,below,term,throw,new,illegal,argument,exception,trimming,the,translog,can,only,be,done,for,terms,lower,than,the,current,one,trim,requested,for,term,below,term,current,is,current,get,primary,term,assert,current,assert,no,seq,above,below,term,above,seq,no,final,list,translog,reader,new,readers,new,array,list,readers,size,try,for,translog,reader,reader,readers,final,translog,reader,new,reader,reader,get,primary,term,below,term,reader,close,into,trimmed,reader,above,seq,no,get,channel,factory,reader,new,readers,add,new,reader,catch,ioexception,e,ioutils,close,while,handling,exception,new,readers,tragedy,set,tragic,exception,e,close,on,tragic,event,e,throw,e,this,readers,clear,this,readers,add,all,new,readers
Translog -> public void trimOperations(long belowTerm, long aboveSeqNo) throws IOException;1545236365;Trims translog for terms of files below <code>belowTerm</code> and seq# above <code>aboveSeqNo</code>._Effectively it moves max visible seq# {@link Checkpoint#trimmedAboveSeqNo} therefore {@link TranslogSnapshot} skips those operations.;public void trimOperations(long belowTerm, long aboveSeqNo) throws IOException {_        assert aboveSeqNo >= SequenceNumbers.NO_OPS_PERFORMED : "aboveSeqNo has to a valid sequence number"___        try (ReleasableLock lock = writeLock.acquire()) {_            ensureOpen()__            if (current.getPrimaryTerm() < belowTerm) {_                throw new IllegalArgumentException("Trimming the translog can only be done for terms lower than the current one. " +_                    "Trim requested for term [ " + belowTerm + " ] , current is [ " + current.getPrimaryTerm() + " ]")__            }_            _            assert current.assertNoSeqAbove(belowTerm, aboveSeqNo)__            _            final List<TranslogReader> newReaders = new ArrayList<>(readers.size())__            try {_                for (TranslogReader reader : readers) {_                    final TranslogReader newReader =_                        reader.getPrimaryTerm() < belowTerm_                            ? reader.closeIntoTrimmedReader(aboveSeqNo, getChannelFactory())_                            : reader__                    newReaders.add(newReader)__                }_            } catch (IOException e) {_                IOUtils.closeWhileHandlingException(newReaders)__                tragedy.setTragicException(e)__                closeOnTragicEvent(e)__                throw e__            }__            this.readers.clear()__            this.readers.addAll(newReaders)__        }_    };trims,translog,for,terms,of,files,below,code,below,term,code,and,seq,above,code,above,seq,no,code,effectively,it,moves,max,visible,seq,link,checkpoint,trimmed,above,seq,no,therefore,link,translog,snapshot,skips,those,operations;public,void,trim,operations,long,below,term,long,above,seq,no,throws,ioexception,assert,above,seq,no,sequence,numbers,above,seq,no,has,to,a,valid,sequence,number,try,releasable,lock,lock,write,lock,acquire,ensure,open,if,current,get,primary,term,below,term,throw,new,illegal,argument,exception,trimming,the,translog,can,only,be,done,for,terms,lower,than,the,current,one,trim,requested,for,term,below,term,current,is,current,get,primary,term,assert,current,assert,no,seq,above,below,term,above,seq,no,final,list,translog,reader,new,readers,new,array,list,readers,size,try,for,translog,reader,reader,readers,final,translog,reader,new,reader,reader,get,primary,term,below,term,reader,close,into,trimmed,reader,above,seq,no,get,channel,factory,reader,new,readers,add,new,reader,catch,ioexception,e,ioutils,close,while,handling,exception,new,readers,tragedy,set,tragic,exception,e,close,on,tragic,event,e,throw,e,this,readers,clear,this,readers,add,all,new,readers
Translog -> public String getTranslogUUID();1524684173;Returns the translog uuid used to associate a lucene index with a translog.;public String getTranslogUUID() {_        return translogUUID__    };returns,the,translog,uuid,used,to,associate,a,lucene,index,with,a,translog;public,string,get,translog,uuid,return,translog,uuid
Translog -> public String getTranslogUUID();1525334055;Returns the translog uuid used to associate a lucene index with a translog.;public String getTranslogUUID() {_        return translogUUID__    };returns,the,translog,uuid,used,to,associate,a,lucene,index,with,a,translog;public,string,get,translog,uuid,return,translog,uuid
Translog -> public String getTranslogUUID();1528706846;Returns the translog uuid used to associate a lucene index with a translog.;public String getTranslogUUID() {_        return translogUUID__    };returns,the,translog,uuid,used,to,associate,a,lucene,index,with,a,translog;public,string,get,translog,uuid,return,translog,uuid
Translog -> public String getTranslogUUID();1531910483;Returns the translog uuid used to associate a lucene index with a translog.;public String getTranslogUUID() {_        return translogUUID__    };returns,the,translog,uuid,used,to,associate,a,lucene,index,with,a,translog;public,string,get,translog,uuid,return,translog,uuid
Translog -> public String getTranslogUUID();1533295538;Returns the translog uuid used to associate a lucene index with a translog.;public String getTranslogUUID() {_        return translogUUID__    };returns,the,translog,uuid,used,to,associate,a,lucene,index,with,a,translog;public,string,get,translog,uuid,return,translog,uuid
Translog -> public String getTranslogUUID();1533641732;Returns the translog uuid used to associate a lucene index with a translog.;public String getTranslogUUID() {_        return translogUUID__    };returns,the,translog,uuid,used,to,associate,a,lucene,index,with,a,translog;public,string,get,translog,uuid,return,translog,uuid
Translog -> public String getTranslogUUID();1534848846;Returns the translog uuid used to associate a lucene index with a translog.;public String getTranslogUUID() {_        return translogUUID__    };returns,the,translog,uuid,used,to,associate,a,lucene,index,with,a,translog;public,string,get,translog,uuid,return,translog,uuid
Translog -> public String getTranslogUUID();1535046779;Returns the translog uuid used to associate a lucene index with a translog.;public String getTranslogUUID() {_        return translogUUID__    };returns,the,translog,uuid,used,to,associate,a,lucene,index,with,a,translog;public,string,get,translog,uuid,return,translog,uuid
Translog -> public String getTranslogUUID();1535723122;Returns the translog uuid used to associate a lucene index with a translog.;public String getTranslogUUID() {_        return translogUUID__    };returns,the,translog,uuid,used,to,associate,a,lucene,index,with,a,translog;public,string,get,translog,uuid,return,translog,uuid
Translog -> public String getTranslogUUID();1537806831;Returns the translog uuid used to associate a lucene index with a translog.;public String getTranslogUUID() {_        return translogUUID__    };returns,the,translog,uuid,used,to,associate,a,lucene,index,with,a,translog;public,string,get,translog,uuid,return,translog,uuid
Translog -> public String getTranslogUUID();1541592065;Returns the translog uuid used to associate a lucene index with a translog.;public String getTranslogUUID() {_        return translogUUID__    };returns,the,translog,uuid,used,to,associate,a,lucene,index,with,a,translog;public,string,get,translog,uuid,return,translog,uuid
Translog -> public String getTranslogUUID();1542697754;Returns the translog uuid used to associate a lucene index with a translog.;public String getTranslogUUID() {_        return translogUUID__    };returns,the,translog,uuid,used,to,associate,a,lucene,index,with,a,translog;public,string,get,translog,uuid,return,translog,uuid
Translog -> public String getTranslogUUID();1542962614;Returns the translog uuid used to associate a lucene index with a translog.;public String getTranslogUUID() {_        return translogUUID__    };returns,the,translog,uuid,used,to,associate,a,lucene,index,with,a,translog;public,string,get,translog,uuid,return,translog,uuid
Translog -> public String getTranslogUUID();1545236365;Returns the translog uuid used to associate a lucene index with a translog.;public String getTranslogUUID() {_        return translogUUID__    };returns,the,translog,uuid,used,to,associate,a,lucene,index,with,a,translog;public,string,get,translog,uuid,return,translog,uuid
Translog -> public long getMaxSeqNo();1537806831;Returns the max seq_no of translog operations found in this translog. Since this value is calculated based on the current_existing readers, this value is not necessary to be the max seq_no of all operations have been stored in this translog.;public long getMaxSeqNo() {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            final OptionalLong maxSeqNo = Stream.concat(readers.stream(), Stream.of(current))_                .mapToLong(reader -> reader.getCheckpoint().maxSeqNo).max()__            assert maxSeqNo.isPresent() : "must have at least one translog generation"__            return maxSeqNo.getAsLong()__        }_    };returns,the,max,of,translog,operations,found,in,this,translog,since,this,value,is,calculated,based,on,the,current,existing,readers,this,value,is,not,necessary,to,be,the,max,of,all,operations,have,been,stored,in,this,translog;public,long,get,max,seq,no,try,releasable,lock,ignored,read,lock,acquire,ensure,open,final,optional,long,max,seq,no,stream,concat,readers,stream,stream,of,current,map,to,long,reader,reader,get,checkpoint,max,seq,no,max,assert,max,seq,no,is,present,must,have,at,least,one,translog,generation,return,max,seq,no,get,as,long
Translog -> public long getMaxSeqNo();1541592065;Returns the max seq_no of translog operations found in this translog. Since this value is calculated based on the current_existing readers, this value is not necessary to be the max seq_no of all operations have been stored in this translog.;public long getMaxSeqNo() {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            final OptionalLong maxSeqNo = Stream.concat(readers.stream(), Stream.of(current))_                .mapToLong(reader -> reader.getCheckpoint().maxSeqNo).max()__            assert maxSeqNo.isPresent() : "must have at least one translog generation"__            return maxSeqNo.getAsLong()__        }_    };returns,the,max,of,translog,operations,found,in,this,translog,since,this,value,is,calculated,based,on,the,current,existing,readers,this,value,is,not,necessary,to,be,the,max,of,all,operations,have,been,stored,in,this,translog;public,long,get,max,seq,no,try,releasable,lock,ignored,read,lock,acquire,ensure,open,final,optional,long,max,seq,no,stream,concat,readers,stream,stream,of,current,map,to,long,reader,reader,get,checkpoint,max,seq,no,max,assert,max,seq,no,is,present,must,have,at,least,one,translog,generation,return,max,seq,no,get,as,long
Translog -> public long getMaxSeqNo();1542697754;Returns the max seq_no of translog operations found in this translog. Since this value is calculated based on the current_existing readers, this value is not necessary to be the max seq_no of all operations have been stored in this translog.;public long getMaxSeqNo() {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            final OptionalLong maxSeqNo = Stream.concat(readers.stream(), Stream.of(current))_                .mapToLong(reader -> reader.getCheckpoint().maxSeqNo).max()__            assert maxSeqNo.isPresent() : "must have at least one translog generation"__            return maxSeqNo.getAsLong()__        }_    };returns,the,max,of,translog,operations,found,in,this,translog,since,this,value,is,calculated,based,on,the,current,existing,readers,this,value,is,not,necessary,to,be,the,max,of,all,operations,have,been,stored,in,this,translog;public,long,get,max,seq,no,try,releasable,lock,ignored,read,lock,acquire,ensure,open,final,optional,long,max,seq,no,stream,concat,readers,stream,stream,of,current,map,to,long,reader,reader,get,checkpoint,max,seq,no,max,assert,max,seq,no,is,present,must,have,at,least,one,translog,generation,return,max,seq,no,get,as,long
Translog -> public long getMaxSeqNo();1542962614;Returns the max seq_no of translog operations found in this translog. Since this value is calculated based on the current_existing readers, this value is not necessary to be the max seq_no of all operations have been stored in this translog.;public long getMaxSeqNo() {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            final OptionalLong maxSeqNo = Stream.concat(readers.stream(), Stream.of(current))_                .mapToLong(reader -> reader.getCheckpoint().maxSeqNo).max()__            assert maxSeqNo.isPresent() : "must have at least one translog generation"__            return maxSeqNo.getAsLong()__        }_    };returns,the,max,of,translog,operations,found,in,this,translog,since,this,value,is,calculated,based,on,the,current,existing,readers,this,value,is,not,necessary,to,be,the,max,of,all,operations,have,been,stored,in,this,translog;public,long,get,max,seq,no,try,releasable,lock,ignored,read,lock,acquire,ensure,open,final,optional,long,max,seq,no,stream,concat,readers,stream,stream,of,current,map,to,long,reader,reader,get,checkpoint,max,seq,no,max,assert,max,seq,no,is,present,must,have,at,least,one,translog,generation,return,max,seq,no,get,as,long
Translog -> public long getMaxSeqNo();1545236365;Returns the max seq_no of translog operations found in this translog. Since this value is calculated based on the current_existing readers, this value is not necessary to be the max seq_no of all operations have been stored in this translog.;public long getMaxSeqNo() {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            final OptionalLong maxSeqNo = Stream.concat(readers.stream(), Stream.of(current))_                .mapToLong(reader -> reader.getCheckpoint().maxSeqNo).max()__            assert maxSeqNo.isPresent() : "must have at least one translog generation"__            return maxSeqNo.getAsLong()__        }_    };returns,the,max,of,translog,operations,found,in,this,translog,since,this,value,is,calculated,based,on,the,current,existing,readers,this,value,is,not,necessary,to,be,the,max,of,all,operations,have,been,stored,in,this,translog;public,long,get,max,seq,no,try,releasable,lock,ignored,read,lock,acquire,ensure,open,final,optional,long,max,seq,no,stream,concat,readers,stream,stream,of,current,map,to,long,reader,reader,get,checkpoint,max,seq,no,max,assert,max,seq,no,is,present,must,have,at,least,one,translog,generation,return,max,seq,no,get,as,long
Translog -> public Path location();1524684173;Returns all translog locations as absolute paths._These paths don't contain actual translog files they are_directories holding the transaction logs.;public Path location() {_        return location__    };returns,all,translog,locations,as,absolute,paths,these,paths,don,t,contain,actual,translog,files,they,are,directories,holding,the,transaction,logs;public,path,location,return,location
Translog -> public Path location();1525334055;Returns all translog locations as absolute paths._These paths don't contain actual translog files they are_directories holding the transaction logs.;public Path location() {_        return location__    };returns,all,translog,locations,as,absolute,paths,these,paths,don,t,contain,actual,translog,files,they,are,directories,holding,the,transaction,logs;public,path,location,return,location
Translog -> public Path location();1528706846;Returns all translog locations as absolute paths._These paths don't contain actual translog files they are_directories holding the transaction logs.;public Path location() {_        return location__    };returns,all,translog,locations,as,absolute,paths,these,paths,don,t,contain,actual,translog,files,they,are,directories,holding,the,transaction,logs;public,path,location,return,location
Translog -> public Path location();1531910483;Returns all translog locations as absolute paths._These paths don't contain actual translog files they are_directories holding the transaction logs.;public Path location() {_        return location__    };returns,all,translog,locations,as,absolute,paths,these,paths,don,t,contain,actual,translog,files,they,are,directories,holding,the,transaction,logs;public,path,location,return,location
Translog -> public Path location();1533295538;Returns all translog locations as absolute paths._These paths don't contain actual translog files they are_directories holding the transaction logs.;public Path location() {_        return location__    };returns,all,translog,locations,as,absolute,paths,these,paths,don,t,contain,actual,translog,files,they,are,directories,holding,the,transaction,logs;public,path,location,return,location
Translog -> public Path location();1533641732;Returns all translog locations as absolute paths._These paths don't contain actual translog files they are_directories holding the transaction logs.;public Path location() {_        return location__    };returns,all,translog,locations,as,absolute,paths,these,paths,don,t,contain,actual,translog,files,they,are,directories,holding,the,transaction,logs;public,path,location,return,location
Translog -> public Path location();1534848846;Returns all translog locations as absolute paths._These paths don't contain actual translog files they are_directories holding the transaction logs.;public Path location() {_        return location__    };returns,all,translog,locations,as,absolute,paths,these,paths,don,t,contain,actual,translog,files,they,are,directories,holding,the,transaction,logs;public,path,location,return,location
Translog -> public Path location();1535046779;Returns all translog locations as absolute paths._These paths don't contain actual translog files they are_directories holding the transaction logs.;public Path location() {_        return location__    };returns,all,translog,locations,as,absolute,paths,these,paths,don,t,contain,actual,translog,files,they,are,directories,holding,the,transaction,logs;public,path,location,return,location
Translog -> public Path location();1535723122;Returns all translog locations as absolute paths._These paths don't contain actual translog files they are_directories holding the transaction logs.;public Path location() {_        return location__    };returns,all,translog,locations,as,absolute,paths,these,paths,don,t,contain,actual,translog,files,they,are,directories,holding,the,transaction,logs;public,path,location,return,location
Translog -> public Path location();1537806831;Returns all translog locations as absolute paths._These paths don't contain actual translog files they are_directories holding the transaction logs.;public Path location() {_        return location__    };returns,all,translog,locations,as,absolute,paths,these,paths,don,t,contain,actual,translog,files,they,are,directories,holding,the,transaction,logs;public,path,location,return,location
Translog -> public Path location();1541592065;Returns all translog locations as absolute paths._These paths don't contain actual translog files they are_directories holding the transaction logs.;public Path location() {_        return location__    };returns,all,translog,locations,as,absolute,paths,these,paths,don,t,contain,actual,translog,files,they,are,directories,holding,the,transaction,logs;public,path,location,return,location
Translog -> public Path location();1542697754;Returns all translog locations as absolute paths._These paths don't contain actual translog files they are_directories holding the transaction logs.;public Path location() {_        return location__    };returns,all,translog,locations,as,absolute,paths,these,paths,don,t,contain,actual,translog,files,they,are,directories,holding,the,transaction,logs;public,path,location,return,location
Translog -> public Path location();1542962614;Returns all translog locations as absolute paths._These paths don't contain actual translog files they are_directories holding the transaction logs.;public Path location() {_        return location__    };returns,all,translog,locations,as,absolute,paths,these,paths,don,t,contain,actual,translog,files,they,are,directories,holding,the,transaction,logs;public,path,location,return,location
Translog -> public Path location();1545236365;Returns all translog locations as absolute paths._These paths don't contain actual translog files they are_directories holding the transaction logs.;public Path location() {_        return location__    };returns,all,translog,locations,as,absolute,paths,these,paths,don,t,contain,actual,translog,files,they,are,directories,holding,the,transaction,logs;public,path,location,return,location
Translog -> public Location getLastWriteLocation();1524684173;The a {@linkplain Location} that will sort after the {@linkplain Location} returned by the last write but before any locations which_can be returned by the next write.;public Location getLastWriteLocation() {_        try (ReleasableLock lock = readLock.acquire()) {_            _            return new Location(current.generation, current.sizeInBytes() - 1, Integer.MAX_VALUE)__        }_    };the,a,linkplain,location,that,will,sort,after,the,linkplain,location,returned,by,the,last,write,but,before,any,locations,which,can,be,returned,by,the,next,write;public,location,get,last,write,location,try,releasable,lock,lock,read,lock,acquire,return,new,location,current,generation,current,size,in,bytes,1,integer
Translog -> public Location getLastWriteLocation();1525334055;The a {@linkplain Location} that will sort after the {@linkplain Location} returned by the last write but before any locations which_can be returned by the next write.;public Location getLastWriteLocation() {_        try (ReleasableLock lock = readLock.acquire()) {_            _            return new Location(current.generation, current.sizeInBytes() - 1, Integer.MAX_VALUE)__        }_    };the,a,linkplain,location,that,will,sort,after,the,linkplain,location,returned,by,the,last,write,but,before,any,locations,which,can,be,returned,by,the,next,write;public,location,get,last,write,location,try,releasable,lock,lock,read,lock,acquire,return,new,location,current,generation,current,size,in,bytes,1,integer
Translog -> public Location getLastWriteLocation();1528706846;The a {@linkplain Location} that will sort after the {@linkplain Location} returned by the last write but before any locations which_can be returned by the next write.;public Location getLastWriteLocation() {_        try (ReleasableLock lock = readLock.acquire()) {_            _            return new Location(current.generation, current.sizeInBytes() - 1, Integer.MAX_VALUE)__        }_    };the,a,linkplain,location,that,will,sort,after,the,linkplain,location,returned,by,the,last,write,but,before,any,locations,which,can,be,returned,by,the,next,write;public,location,get,last,write,location,try,releasable,lock,lock,read,lock,acquire,return,new,location,current,generation,current,size,in,bytes,1,integer
Translog -> public Location getLastWriteLocation();1531910483;The a {@linkplain Location} that will sort after the {@linkplain Location} returned by the last write but before any locations which_can be returned by the next write.;public Location getLastWriteLocation() {_        try (ReleasableLock lock = readLock.acquire()) {_            _            return new Location(current.generation, current.sizeInBytes() - 1, Integer.MAX_VALUE)__        }_    };the,a,linkplain,location,that,will,sort,after,the,linkplain,location,returned,by,the,last,write,but,before,any,locations,which,can,be,returned,by,the,next,write;public,location,get,last,write,location,try,releasable,lock,lock,read,lock,acquire,return,new,location,current,generation,current,size,in,bytes,1,integer
Translog -> public Location getLastWriteLocation();1533295538;The a {@linkplain Location} that will sort after the {@linkplain Location} returned by the last write but before any locations which_can be returned by the next write.;public Location getLastWriteLocation() {_        try (ReleasableLock lock = readLock.acquire()) {_            _            return new Location(current.generation, current.sizeInBytes() - 1, Integer.MAX_VALUE)__        }_    };the,a,linkplain,location,that,will,sort,after,the,linkplain,location,returned,by,the,last,write,but,before,any,locations,which,can,be,returned,by,the,next,write;public,location,get,last,write,location,try,releasable,lock,lock,read,lock,acquire,return,new,location,current,generation,current,size,in,bytes,1,integer
Translog -> public Location getLastWriteLocation();1533641732;The a {@linkplain Location} that will sort after the {@linkplain Location} returned by the last write but before any locations which_can be returned by the next write.;public Location getLastWriteLocation() {_        try (ReleasableLock lock = readLock.acquire()) {_            _            return new Location(current.generation, current.sizeInBytes() - 1, Integer.MAX_VALUE)__        }_    };the,a,linkplain,location,that,will,sort,after,the,linkplain,location,returned,by,the,last,write,but,before,any,locations,which,can,be,returned,by,the,next,write;public,location,get,last,write,location,try,releasable,lock,lock,read,lock,acquire,return,new,location,current,generation,current,size,in,bytes,1,integer
Translog -> public Location getLastWriteLocation();1534848846;The a {@linkplain Location} that will sort after the {@linkplain Location} returned by the last write but before any locations which_can be returned by the next write.;public Location getLastWriteLocation() {_        try (ReleasableLock lock = readLock.acquire()) {_            _            return new Location(current.generation, current.sizeInBytes() - 1, Integer.MAX_VALUE)__        }_    };the,a,linkplain,location,that,will,sort,after,the,linkplain,location,returned,by,the,last,write,but,before,any,locations,which,can,be,returned,by,the,next,write;public,location,get,last,write,location,try,releasable,lock,lock,read,lock,acquire,return,new,location,current,generation,current,size,in,bytes,1,integer
Translog -> public Location getLastWriteLocation();1535046779;The a {@linkplain Location} that will sort after the {@linkplain Location} returned by the last write but before any locations which_can be returned by the next write.;public Location getLastWriteLocation() {_        try (ReleasableLock lock = readLock.acquire()) {_            _            return new Location(current.generation, current.sizeInBytes() - 1, Integer.MAX_VALUE)__        }_    };the,a,linkplain,location,that,will,sort,after,the,linkplain,location,returned,by,the,last,write,but,before,any,locations,which,can,be,returned,by,the,next,write;public,location,get,last,write,location,try,releasable,lock,lock,read,lock,acquire,return,new,location,current,generation,current,size,in,bytes,1,integer
Translog -> public Location getLastWriteLocation();1535723122;The a {@linkplain Location} that will sort after the {@linkplain Location} returned by the last write but before any locations which_can be returned by the next write.;public Location getLastWriteLocation() {_        try (ReleasableLock lock = readLock.acquire()) {_            _            return new Location(current.generation, current.sizeInBytes() - 1, Integer.MAX_VALUE)__        }_    };the,a,linkplain,location,that,will,sort,after,the,linkplain,location,returned,by,the,last,write,but,before,any,locations,which,can,be,returned,by,the,next,write;public,location,get,last,write,location,try,releasable,lock,lock,read,lock,acquire,return,new,location,current,generation,current,size,in,bytes,1,integer
Translog -> public Location getLastWriteLocation();1537806831;The a {@linkplain Location} that will sort after the {@linkplain Location} returned by the last write but before any locations which_can be returned by the next write.;public Location getLastWriteLocation() {_        try (ReleasableLock lock = readLock.acquire()) {_            _            return new Location(current.generation, current.sizeInBytes() - 1, Integer.MAX_VALUE)__        }_    };the,a,linkplain,location,that,will,sort,after,the,linkplain,location,returned,by,the,last,write,but,before,any,locations,which,can,be,returned,by,the,next,write;public,location,get,last,write,location,try,releasable,lock,lock,read,lock,acquire,return,new,location,current,generation,current,size,in,bytes,1,integer
Translog -> public Location getLastWriteLocation();1541592065;The a {@linkplain Location} that will sort after the {@linkplain Location} returned by the last write but before any locations which_can be returned by the next write.;public Location getLastWriteLocation() {_        try (ReleasableLock lock = readLock.acquire()) {_            _            return new Location(current.generation, current.sizeInBytes() - 1, Integer.MAX_VALUE)__        }_    };the,a,linkplain,location,that,will,sort,after,the,linkplain,location,returned,by,the,last,write,but,before,any,locations,which,can,be,returned,by,the,next,write;public,location,get,last,write,location,try,releasable,lock,lock,read,lock,acquire,return,new,location,current,generation,current,size,in,bytes,1,integer
Translog -> public Location getLastWriteLocation();1542697754;The a {@linkplain Location} that will sort after the {@linkplain Location} returned by the last write but before any locations which_can be returned by the next write.;public Location getLastWriteLocation() {_        try (ReleasableLock lock = readLock.acquire()) {_            _            return new Location(current.generation, current.sizeInBytes() - 1, Integer.MAX_VALUE)__        }_    };the,a,linkplain,location,that,will,sort,after,the,linkplain,location,returned,by,the,last,write,but,before,any,locations,which,can,be,returned,by,the,next,write;public,location,get,last,write,location,try,releasable,lock,lock,read,lock,acquire,return,new,location,current,generation,current,size,in,bytes,1,integer
Translog -> public Location getLastWriteLocation();1542962614;The a {@linkplain Location} that will sort after the {@linkplain Location} returned by the last write but before any locations which_can be returned by the next write.;public Location getLastWriteLocation() {_        try (ReleasableLock lock = readLock.acquire()) {_            _            return new Location(current.generation, current.sizeInBytes() - 1, Integer.MAX_VALUE)__        }_    };the,a,linkplain,location,that,will,sort,after,the,linkplain,location,returned,by,the,last,write,but,before,any,locations,which,can,be,returned,by,the,next,write;public,location,get,last,write,location,try,releasable,lock,lock,read,lock,acquire,return,new,location,current,generation,current,size,in,bytes,1,integer
Translog -> public Location getLastWriteLocation();1545236365;The a {@linkplain Location} that will sort after the {@linkplain Location} returned by the last write but before any locations which_can be returned by the next write.;public Location getLastWriteLocation() {_        try (ReleasableLock lock = readLock.acquire()) {_            _            return new Location(current.generation, current.sizeInBytes() - 1, Integer.MAX_VALUE)__        }_    };the,a,linkplain,location,that,will,sort,after,the,linkplain,location,returned,by,the,last,write,but,before,any,locations,which,can,be,returned,by,the,next,write;public,location,get,last,write,location,try,releasable,lock,lock,read,lock,acquire,return,new,location,current,generation,current,size,in,bytes,1,integer
Translog -> public TranslogStats stats();1524684173;return stats;public TranslogStats stats() {_        _        try (ReleasableLock lock = readLock.acquire()) {_            final long uncommittedGen = deletionPolicy.getTranslogGenerationOfLastCommit()__            return new TranslogStats(totalOperations(), sizeInBytes(), totalOperationsByMinGen(uncommittedGen), sizeInBytesByMinGen(uncommittedGen), earliestLastModifiedAge())__        }_    };return,stats;public,translog,stats,stats,try,releasable,lock,lock,read,lock,acquire,final,long,uncommitted,gen,deletion,policy,get,translog,generation,of,last,commit,return,new,translog,stats,total,operations,size,in,bytes,total,operations,by,min,gen,uncommitted,gen,size,in,bytes,by,min,gen,uncommitted,gen,earliest,last,modified,age
Translog -> public TranslogStats stats();1525334055;return stats;public TranslogStats stats() {_        _        try (ReleasableLock lock = readLock.acquire()) {_            final long uncommittedGen = deletionPolicy.getTranslogGenerationOfLastCommit()__            return new TranslogStats(totalOperations(), sizeInBytes(), totalOperationsByMinGen(uncommittedGen), sizeInBytesByMinGen(uncommittedGen), earliestLastModifiedAge())__        }_    };return,stats;public,translog,stats,stats,try,releasable,lock,lock,read,lock,acquire,final,long,uncommitted,gen,deletion,policy,get,translog,generation,of,last,commit,return,new,translog,stats,total,operations,size,in,bytes,total,operations,by,min,gen,uncommitted,gen,size,in,bytes,by,min,gen,uncommitted,gen,earliest,last,modified,age
Translog -> public TranslogStats stats();1528706846;return stats;public TranslogStats stats() {_        _        try (ReleasableLock lock = readLock.acquire()) {_            final long uncommittedGen = deletionPolicy.getTranslogGenerationOfLastCommit()__            return new TranslogStats(totalOperations(), sizeInBytes(), totalOperationsByMinGen(uncommittedGen), sizeInBytesByMinGen(uncommittedGen), earliestLastModifiedAge())__        }_    };return,stats;public,translog,stats,stats,try,releasable,lock,lock,read,lock,acquire,final,long,uncommitted,gen,deletion,policy,get,translog,generation,of,last,commit,return,new,translog,stats,total,operations,size,in,bytes,total,operations,by,min,gen,uncommitted,gen,size,in,bytes,by,min,gen,uncommitted,gen,earliest,last,modified,age
Translog -> public TranslogStats stats();1531910483;return stats;public TranslogStats stats() {_        _        try (ReleasableLock lock = readLock.acquire()) {_            final long uncommittedGen = deletionPolicy.getTranslogGenerationOfLastCommit()__            return new TranslogStats(totalOperations(), sizeInBytes(), totalOperationsByMinGen(uncommittedGen), sizeInBytesByMinGen(uncommittedGen), earliestLastModifiedAge())__        }_    };return,stats;public,translog,stats,stats,try,releasable,lock,lock,read,lock,acquire,final,long,uncommitted,gen,deletion,policy,get,translog,generation,of,last,commit,return,new,translog,stats,total,operations,size,in,bytes,total,operations,by,min,gen,uncommitted,gen,size,in,bytes,by,min,gen,uncommitted,gen,earliest,last,modified,age
Translog -> public TranslogStats stats();1533295538;return stats;public TranslogStats stats() {_        _        try (ReleasableLock lock = readLock.acquire()) {_            final long uncommittedGen = deletionPolicy.getTranslogGenerationOfLastCommit()__            return new TranslogStats(totalOperations(), sizeInBytes(), totalOperationsByMinGen(uncommittedGen), sizeInBytesByMinGen(uncommittedGen), earliestLastModifiedAge())__        }_    };return,stats;public,translog,stats,stats,try,releasable,lock,lock,read,lock,acquire,final,long,uncommitted,gen,deletion,policy,get,translog,generation,of,last,commit,return,new,translog,stats,total,operations,size,in,bytes,total,operations,by,min,gen,uncommitted,gen,size,in,bytes,by,min,gen,uncommitted,gen,earliest,last,modified,age
Translog -> public TranslogStats stats();1533641732;return stats;public TranslogStats stats() {_        _        try (ReleasableLock lock = readLock.acquire()) {_            final long uncommittedGen = deletionPolicy.getTranslogGenerationOfLastCommit()__            return new TranslogStats(totalOperations(), sizeInBytes(), totalOperationsByMinGen(uncommittedGen), sizeInBytesByMinGen(uncommittedGen), earliestLastModifiedAge())__        }_    };return,stats;public,translog,stats,stats,try,releasable,lock,lock,read,lock,acquire,final,long,uncommitted,gen,deletion,policy,get,translog,generation,of,last,commit,return,new,translog,stats,total,operations,size,in,bytes,total,operations,by,min,gen,uncommitted,gen,size,in,bytes,by,min,gen,uncommitted,gen,earliest,last,modified,age
Translog -> public TranslogStats stats();1534848846;return stats;public TranslogStats stats() {_        _        try (ReleasableLock lock = readLock.acquire()) {_            final long uncommittedGen = deletionPolicy.getTranslogGenerationOfLastCommit()__            return new TranslogStats(totalOperations(), sizeInBytes(), totalOperationsByMinGen(uncommittedGen), sizeInBytesByMinGen(uncommittedGen), earliestLastModifiedAge())__        }_    };return,stats;public,translog,stats,stats,try,releasable,lock,lock,read,lock,acquire,final,long,uncommitted,gen,deletion,policy,get,translog,generation,of,last,commit,return,new,translog,stats,total,operations,size,in,bytes,total,operations,by,min,gen,uncommitted,gen,size,in,bytes,by,min,gen,uncommitted,gen,earliest,last,modified,age
Translog -> public TranslogStats stats();1535046779;return stats;public TranslogStats stats() {_        _        try (ReleasableLock lock = readLock.acquire()) {_            final long uncommittedGen = deletionPolicy.getTranslogGenerationOfLastCommit()__            return new TranslogStats(totalOperations(), sizeInBytes(), totalOperationsByMinGen(uncommittedGen), sizeInBytesByMinGen(uncommittedGen), earliestLastModifiedAge())__        }_    };return,stats;public,translog,stats,stats,try,releasable,lock,lock,read,lock,acquire,final,long,uncommitted,gen,deletion,policy,get,translog,generation,of,last,commit,return,new,translog,stats,total,operations,size,in,bytes,total,operations,by,min,gen,uncommitted,gen,size,in,bytes,by,min,gen,uncommitted,gen,earliest,last,modified,age
Translog -> public TranslogStats stats();1535723122;return stats;public TranslogStats stats() {_        _        try (ReleasableLock lock = readLock.acquire()) {_            final long uncommittedGen = deletionPolicy.getTranslogGenerationOfLastCommit()__            return new TranslogStats(totalOperations(), sizeInBytes(), totalOperationsByMinGen(uncommittedGen), sizeInBytesByMinGen(uncommittedGen), earliestLastModifiedAge())__        }_    };return,stats;public,translog,stats,stats,try,releasable,lock,lock,read,lock,acquire,final,long,uncommitted,gen,deletion,policy,get,translog,generation,of,last,commit,return,new,translog,stats,total,operations,size,in,bytes,total,operations,by,min,gen,uncommitted,gen,size,in,bytes,by,min,gen,uncommitted,gen,earliest,last,modified,age
Translog -> public TranslogStats stats();1537806831;return stats;public TranslogStats stats() {_        _        try (ReleasableLock lock = readLock.acquire()) {_            final long uncommittedGen = deletionPolicy.getTranslogGenerationOfLastCommit()__            return new TranslogStats(totalOperations(), sizeInBytes(), totalOperationsByMinGen(uncommittedGen), sizeInBytesByMinGen(uncommittedGen), earliestLastModifiedAge())__        }_    };return,stats;public,translog,stats,stats,try,releasable,lock,lock,read,lock,acquire,final,long,uncommitted,gen,deletion,policy,get,translog,generation,of,last,commit,return,new,translog,stats,total,operations,size,in,bytes,total,operations,by,min,gen,uncommitted,gen,size,in,bytes,by,min,gen,uncommitted,gen,earliest,last,modified,age
Translog -> public TranslogStats stats();1541592065;return stats;public TranslogStats stats() {_        _        try (ReleasableLock lock = readLock.acquire()) {_            final long uncommittedGen = deletionPolicy.getTranslogGenerationOfLastCommit()__            return new TranslogStats(totalOperations(), sizeInBytes(), totalOperationsByMinGen(uncommittedGen), sizeInBytesByMinGen(uncommittedGen), earliestLastModifiedAge())__        }_    };return,stats;public,translog,stats,stats,try,releasable,lock,lock,read,lock,acquire,final,long,uncommitted,gen,deletion,policy,get,translog,generation,of,last,commit,return,new,translog,stats,total,operations,size,in,bytes,total,operations,by,min,gen,uncommitted,gen,size,in,bytes,by,min,gen,uncommitted,gen,earliest,last,modified,age
Translog -> public TranslogStats stats();1542697754;return stats;public TranslogStats stats() {_        _        try (ReleasableLock lock = readLock.acquire()) {_            final long uncommittedGen = deletionPolicy.getTranslogGenerationOfLastCommit()__            return new TranslogStats(totalOperations(), sizeInBytes(), totalOperationsByMinGen(uncommittedGen),_                sizeInBytesByMinGen(uncommittedGen), earliestLastModifiedAge())__        }_    };return,stats;public,translog,stats,stats,try,releasable,lock,lock,read,lock,acquire,final,long,uncommitted,gen,deletion,policy,get,translog,generation,of,last,commit,return,new,translog,stats,total,operations,size,in,bytes,total,operations,by,min,gen,uncommitted,gen,size,in,bytes,by,min,gen,uncommitted,gen,earliest,last,modified,age
Translog -> public TranslogStats stats();1542962614;return stats;public TranslogStats stats() {_        _        try (ReleasableLock lock = readLock.acquire()) {_            final long uncommittedGen = deletionPolicy.getTranslogGenerationOfLastCommit()__            return new TranslogStats(totalOperations(), sizeInBytes(), totalOperationsByMinGen(uncommittedGen),_                sizeInBytesByMinGen(uncommittedGen), earliestLastModifiedAge())__        }_    };return,stats;public,translog,stats,stats,try,releasable,lock,lock,read,lock,acquire,final,long,uncommitted,gen,deletion,policy,get,translog,generation,of,last,commit,return,new,translog,stats,total,operations,size,in,bytes,total,operations,by,min,gen,uncommitted,gen,size,in,bytes,by,min,gen,uncommitted,gen,earliest,last,modified,age
Translog -> public TranslogStats stats();1545236365;return stats;public TranslogStats stats() {_        _        try (ReleasableLock lock = readLock.acquire()) {_            final long uncommittedGen = deletionPolicy.getTranslogGenerationOfLastCommit()__            return new TranslogStats(totalOperations(), sizeInBytes(), totalOperationsByMinGen(uncommittedGen),_                sizeInBytesByMinGen(uncommittedGen), earliestLastModifiedAge())__        }_    };return,stats;public,translog,stats,stats,try,releasable,lock,lock,read,lock,acquire,final,long,uncommitted,gen,deletion,policy,get,translog,generation,of,last,commit,return,new,translog,stats,total,operations,size,in,bytes,total,operations,by,min,gen,uncommitted,gen,size,in,bytes,by,min,gen,uncommitted,gen,earliest,last,modified,age
Translog -> public boolean syncNeeded();1524684173;Returns <code>true</code> if an fsync is required to ensure durability of the translogs operations or it's metadata.;public boolean syncNeeded() {_        try (ReleasableLock lock = readLock.acquire()) {_            return current.syncNeeded()__        }_    };returns,code,true,code,if,an,fsync,is,required,to,ensure,durability,of,the,translogs,operations,or,it,s,metadata;public,boolean,sync,needed,try,releasable,lock,lock,read,lock,acquire,return,current,sync,needed
Translog -> public boolean syncNeeded();1525334055;Returns <code>true</code> if an fsync is required to ensure durability of the translogs operations or it's metadata.;public boolean syncNeeded() {_        try (ReleasableLock lock = readLock.acquire()) {_            return current.syncNeeded()__        }_    };returns,code,true,code,if,an,fsync,is,required,to,ensure,durability,of,the,translogs,operations,or,it,s,metadata;public,boolean,sync,needed,try,releasable,lock,lock,read,lock,acquire,return,current,sync,needed
Translog -> public boolean syncNeeded();1528706846;Returns <code>true</code> if an fsync is required to ensure durability of the translogs operations or it's metadata.;public boolean syncNeeded() {_        try (ReleasableLock lock = readLock.acquire()) {_            return current.syncNeeded()__        }_    };returns,code,true,code,if,an,fsync,is,required,to,ensure,durability,of,the,translogs,operations,or,it,s,metadata;public,boolean,sync,needed,try,releasable,lock,lock,read,lock,acquire,return,current,sync,needed
Translog -> public boolean syncNeeded();1531910483;Returns <code>true</code> if an fsync is required to ensure durability of the translogs operations or it's metadata.;public boolean syncNeeded() {_        try (ReleasableLock lock = readLock.acquire()) {_            return current.syncNeeded()__        }_    };returns,code,true,code,if,an,fsync,is,required,to,ensure,durability,of,the,translogs,operations,or,it,s,metadata;public,boolean,sync,needed,try,releasable,lock,lock,read,lock,acquire,return,current,sync,needed
Translog -> public boolean syncNeeded();1533295538;Returns <code>true</code> if an fsync is required to ensure durability of the translogs operations or it's metadata.;public boolean syncNeeded() {_        try (ReleasableLock lock = readLock.acquire()) {_            return current.syncNeeded()__        }_    };returns,code,true,code,if,an,fsync,is,required,to,ensure,durability,of,the,translogs,operations,or,it,s,metadata;public,boolean,sync,needed,try,releasable,lock,lock,read,lock,acquire,return,current,sync,needed
Translog -> public boolean syncNeeded();1533641732;Returns <code>true</code> if an fsync is required to ensure durability of the translogs operations or it's metadata.;public boolean syncNeeded() {_        try (ReleasableLock lock = readLock.acquire()) {_            return current.syncNeeded()__        }_    };returns,code,true,code,if,an,fsync,is,required,to,ensure,durability,of,the,translogs,operations,or,it,s,metadata;public,boolean,sync,needed,try,releasable,lock,lock,read,lock,acquire,return,current,sync,needed
Translog -> public boolean syncNeeded();1534848846;Returns <code>true</code> if an fsync is required to ensure durability of the translogs operations or it's metadata.;public boolean syncNeeded() {_        try (ReleasableLock lock = readLock.acquire()) {_            return current.syncNeeded()__        }_    };returns,code,true,code,if,an,fsync,is,required,to,ensure,durability,of,the,translogs,operations,or,it,s,metadata;public,boolean,sync,needed,try,releasable,lock,lock,read,lock,acquire,return,current,sync,needed
Translog -> public boolean syncNeeded();1535046779;Returns <code>true</code> if an fsync is required to ensure durability of the translogs operations or it's metadata.;public boolean syncNeeded() {_        try (ReleasableLock lock = readLock.acquire()) {_            return current.syncNeeded()__        }_    };returns,code,true,code,if,an,fsync,is,required,to,ensure,durability,of,the,translogs,operations,or,it,s,metadata;public,boolean,sync,needed,try,releasable,lock,lock,read,lock,acquire,return,current,sync,needed
Translog -> public boolean syncNeeded();1535723122;Returns <code>true</code> if an fsync is required to ensure durability of the translogs operations or it's metadata.;public boolean syncNeeded() {_        try (ReleasableLock lock = readLock.acquire()) {_            return current.syncNeeded()__        }_    };returns,code,true,code,if,an,fsync,is,required,to,ensure,durability,of,the,translogs,operations,or,it,s,metadata;public,boolean,sync,needed,try,releasable,lock,lock,read,lock,acquire,return,current,sync,needed
Translog -> public boolean syncNeeded();1537806831;Returns <code>true</code> if an fsync is required to ensure durability of the translogs operations or it's metadata.;public boolean syncNeeded() {_        try (ReleasableLock lock = readLock.acquire()) {_            return current.syncNeeded()__        }_    };returns,code,true,code,if,an,fsync,is,required,to,ensure,durability,of,the,translogs,operations,or,it,s,metadata;public,boolean,sync,needed,try,releasable,lock,lock,read,lock,acquire,return,current,sync,needed
Translog -> public boolean syncNeeded();1541592065;Returns <code>true</code> if an fsync is required to ensure durability of the translogs operations or it's metadata.;public boolean syncNeeded() {_        try (ReleasableLock lock = readLock.acquire()) {_            return current.syncNeeded()__        }_    };returns,code,true,code,if,an,fsync,is,required,to,ensure,durability,of,the,translogs,operations,or,it,s,metadata;public,boolean,sync,needed,try,releasable,lock,lock,read,lock,acquire,return,current,sync,needed
Translog -> public boolean syncNeeded();1542697754;Returns <code>true</code> if an fsync is required to ensure durability of the translogs operations or it's metadata.;public boolean syncNeeded() {_        try (ReleasableLock lock = readLock.acquire()) {_            return current.syncNeeded()__        }_    };returns,code,true,code,if,an,fsync,is,required,to,ensure,durability,of,the,translogs,operations,or,it,s,metadata;public,boolean,sync,needed,try,releasable,lock,lock,read,lock,acquire,return,current,sync,needed
Translog -> public boolean syncNeeded();1542962614;Returns <code>true</code> if an fsync is required to ensure durability of the translogs operations or it's metadata.;public boolean syncNeeded() {_        try (ReleasableLock lock = readLock.acquire()) {_            return current.syncNeeded()__        }_    };returns,code,true,code,if,an,fsync,is,required,to,ensure,durability,of,the,translogs,operations,or,it,s,metadata;public,boolean,sync,needed,try,releasable,lock,lock,read,lock,acquire,return,current,sync,needed
Translog -> public boolean syncNeeded();1545236365;Returns <code>true</code> if an fsync is required to ensure durability of the translogs operations or it's metadata.;public boolean syncNeeded() {_        try (ReleasableLock lock = readLock.acquire()) {_            return current.syncNeeded()__        }_    };returns,code,true,code,if,an,fsync,is,required,to,ensure,durability,of,the,translogs,operations,or,it,s,metadata;public,boolean,sync,needed,try,releasable,lock,lock,read,lock,acquire,return,current,sync,needed
Translog -> public void rollGeneration() throws IOException;1524684173;Roll the current translog generation into a new generation. This does not commit the_translog.__@throws IOException if an I/O exception occurred during any file operations;public void rollGeneration() throws IOException {_        try (Releasable ignored = writeLock.acquire()) {_            try {_                final TranslogReader reader = current.closeIntoReader()__                readers.add(reader)__                final Path checkpoint = location.resolve(CHECKPOINT_FILE_NAME)__                assert Checkpoint.read(checkpoint).generation == current.getGeneration()__                final Path generationCheckpoint =_                    location.resolve(getCommitCheckpointFileName(current.getGeneration()))__                Files.copy(checkpoint, generationCheckpoint)__                IOUtils.fsync(generationCheckpoint, false)__                IOUtils.fsync(generationCheckpoint.getParent(), true)__                _                current = createWriter(current.getGeneration() + 1)__                logger.trace("current translog set to [{}]", current.getGeneration())__            } catch (final Exception e) {_                IOUtils.closeWhileHandlingException(this)_ _                throw e__            }_        }_    };roll,the,current,translog,generation,into,a,new,generation,this,does,not,commit,the,translog,throws,ioexception,if,an,i,o,exception,occurred,during,any,file,operations;public,void,roll,generation,throws,ioexception,try,releasable,ignored,write,lock,acquire,try,final,translog,reader,reader,current,close,into,reader,readers,add,reader,final,path,checkpoint,location,resolve,assert,checkpoint,read,checkpoint,generation,current,get,generation,final,path,generation,checkpoint,location,resolve,get,commit,checkpoint,file,name,current,get,generation,files,copy,checkpoint,generation,checkpoint,ioutils,fsync,generation,checkpoint,false,ioutils,fsync,generation,checkpoint,get,parent,true,current,create,writer,current,get,generation,1,logger,trace,current,translog,set,to,current,get,generation,catch,final,exception,e,ioutils,close,while,handling,exception,this,throw,e
Translog -> public void rollGeneration() throws IOException;1525334055;Roll the current translog generation into a new generation. This does not commit the_translog.__@throws IOException if an I/O exception occurred during any file operations;public void rollGeneration() throws IOException {_        try (Releasable ignored = writeLock.acquire()) {_            try {_                final TranslogReader reader = current.closeIntoReader()__                readers.add(reader)__                final Path checkpoint = location.resolve(CHECKPOINT_FILE_NAME)__                assert Checkpoint.read(checkpoint).generation == current.getGeneration()__                final Path generationCheckpoint =_                    location.resolve(getCommitCheckpointFileName(current.getGeneration()))__                Files.copy(checkpoint, generationCheckpoint)__                IOUtils.fsync(generationCheckpoint, false)__                IOUtils.fsync(generationCheckpoint.getParent(), true)__                _                current = createWriter(current.getGeneration() + 1)__                logger.trace("current translog set to [{}]", current.getGeneration())__            } catch (final Exception e) {_                IOUtils.closeWhileHandlingException(this)_ _                throw e__            }_        }_    };roll,the,current,translog,generation,into,a,new,generation,this,does,not,commit,the,translog,throws,ioexception,if,an,i,o,exception,occurred,during,any,file,operations;public,void,roll,generation,throws,ioexception,try,releasable,ignored,write,lock,acquire,try,final,translog,reader,reader,current,close,into,reader,readers,add,reader,final,path,checkpoint,location,resolve,assert,checkpoint,read,checkpoint,generation,current,get,generation,final,path,generation,checkpoint,location,resolve,get,commit,checkpoint,file,name,current,get,generation,files,copy,checkpoint,generation,checkpoint,ioutils,fsync,generation,checkpoint,false,ioutils,fsync,generation,checkpoint,get,parent,true,current,create,writer,current,get,generation,1,logger,trace,current,translog,set,to,current,get,generation,catch,final,exception,e,ioutils,close,while,handling,exception,this,throw,e
Translog -> public void rollGeneration() throws IOException;1528706846;Roll the current translog generation into a new generation. This does not commit the_translog.__@throws IOException if an I/O exception occurred during any file operations;public void rollGeneration() throws IOException {_        try (Releasable ignored = writeLock.acquire()) {_            try {_                final TranslogReader reader = current.closeIntoReader()__                readers.add(reader)__                final Path checkpoint = location.resolve(CHECKPOINT_FILE_NAME)__                assert Checkpoint.read(checkpoint).generation == current.getGeneration()__                final Path generationCheckpoint =_                    location.resolve(getCommitCheckpointFileName(current.getGeneration()))__                Files.copy(checkpoint, generationCheckpoint)__                IOUtils.fsync(generationCheckpoint, false)__                IOUtils.fsync(generationCheckpoint.getParent(), true)__                _                current = createWriter(current.getGeneration() + 1)__                logger.trace("current translog set to [{}]", current.getGeneration())__            } catch (final Exception e) {_                IOUtils.closeWhileHandlingException(this)_ _                throw e__            }_        }_    };roll,the,current,translog,generation,into,a,new,generation,this,does,not,commit,the,translog,throws,ioexception,if,an,i,o,exception,occurred,during,any,file,operations;public,void,roll,generation,throws,ioexception,try,releasable,ignored,write,lock,acquire,try,final,translog,reader,reader,current,close,into,reader,readers,add,reader,final,path,checkpoint,location,resolve,assert,checkpoint,read,checkpoint,generation,current,get,generation,final,path,generation,checkpoint,location,resolve,get,commit,checkpoint,file,name,current,get,generation,files,copy,checkpoint,generation,checkpoint,ioutils,fsync,generation,checkpoint,false,ioutils,fsync,generation,checkpoint,get,parent,true,current,create,writer,current,get,generation,1,logger,trace,current,translog,set,to,current,get,generation,catch,final,exception,e,ioutils,close,while,handling,exception,this,throw,e
Translog -> public void rollGeneration() throws IOException;1531910483;Roll the current translog generation into a new generation. This does not commit the_translog.__@throws IOException if an I/O exception occurred during any file operations;public void rollGeneration() throws IOException {_        try (Releasable ignored = writeLock.acquire()) {_            try {_                final TranslogReader reader = current.closeIntoReader()__                readers.add(reader)__                final Path checkpoint = location.resolve(CHECKPOINT_FILE_NAME)__                assert Checkpoint.read(checkpoint).generation == current.getGeneration()__                final Path generationCheckpoint =_                    location.resolve(getCommitCheckpointFileName(current.getGeneration()))__                Files.copy(checkpoint, generationCheckpoint)__                IOUtils.fsync(generationCheckpoint, false)__                IOUtils.fsync(generationCheckpoint.getParent(), true)__                _                current = createWriter(current.getGeneration() + 1)__                logger.trace("current translog set to [{}]", current.getGeneration())__            } catch (final Exception e) {_                IOUtils.closeWhileHandlingException(this)_ _                throw e__            }_        }_    };roll,the,current,translog,generation,into,a,new,generation,this,does,not,commit,the,translog,throws,ioexception,if,an,i,o,exception,occurred,during,any,file,operations;public,void,roll,generation,throws,ioexception,try,releasable,ignored,write,lock,acquire,try,final,translog,reader,reader,current,close,into,reader,readers,add,reader,final,path,checkpoint,location,resolve,assert,checkpoint,read,checkpoint,generation,current,get,generation,final,path,generation,checkpoint,location,resolve,get,commit,checkpoint,file,name,current,get,generation,files,copy,checkpoint,generation,checkpoint,ioutils,fsync,generation,checkpoint,false,ioutils,fsync,generation,checkpoint,get,parent,true,current,create,writer,current,get,generation,1,logger,trace,current,translog,set,to,current,get,generation,catch,final,exception,e,ioutils,close,while,handling,exception,this,throw,e
Translog -> public void rollGeneration() throws IOException;1533295538;Roll the current translog generation into a new generation. This does not commit the_translog.__@throws IOException if an I/O exception occurred during any file operations;public void rollGeneration() throws IOException {_        try (Releasable ignored = writeLock.acquire()) {_            try {_                final TranslogReader reader = current.closeIntoReader()__                readers.add(reader)__                final Path checkpoint = location.resolve(CHECKPOINT_FILE_NAME)__                assert Checkpoint.read(checkpoint).generation == current.getGeneration()__                final Path generationCheckpoint =_                    location.resolve(getCommitCheckpointFileName(current.getGeneration()))__                Files.copy(checkpoint, generationCheckpoint)__                IOUtils.fsync(generationCheckpoint, false)__                IOUtils.fsync(generationCheckpoint.getParent(), true)__                _                current = createWriter(current.getGeneration() + 1)__                logger.trace("current translog set to [{}]", current.getGeneration())__            } catch (final Exception e) {_                IOUtils.closeWhileHandlingException(this)_ _                throw e__            }_        }_    };roll,the,current,translog,generation,into,a,new,generation,this,does,not,commit,the,translog,throws,ioexception,if,an,i,o,exception,occurred,during,any,file,operations;public,void,roll,generation,throws,ioexception,try,releasable,ignored,write,lock,acquire,try,final,translog,reader,reader,current,close,into,reader,readers,add,reader,final,path,checkpoint,location,resolve,assert,checkpoint,read,checkpoint,generation,current,get,generation,final,path,generation,checkpoint,location,resolve,get,commit,checkpoint,file,name,current,get,generation,files,copy,checkpoint,generation,checkpoint,ioutils,fsync,generation,checkpoint,false,ioutils,fsync,generation,checkpoint,get,parent,true,current,create,writer,current,get,generation,1,logger,trace,current,translog,set,to,current,get,generation,catch,final,exception,e,ioutils,close,while,handling,exception,this,throw,e
Translog -> public void rollGeneration() throws IOException;1533641732;Roll the current translog generation into a new generation. This does not commit the_translog.__@throws IOException if an I/O exception occurred during any file operations;public void rollGeneration() throws IOException {_        try (Releasable ignored = writeLock.acquire()) {_            try {_                final TranslogReader reader = current.closeIntoReader()__                readers.add(reader)__                final Path checkpoint = location.resolve(CHECKPOINT_FILE_NAME)__                assert Checkpoint.read(checkpoint).generation == current.getGeneration()__                final Path generationCheckpoint =_                    location.resolve(getCommitCheckpointFileName(current.getGeneration()))__                Files.copy(checkpoint, generationCheckpoint)__                IOUtils.fsync(generationCheckpoint, false)__                IOUtils.fsync(generationCheckpoint.getParent(), true)__                _                current = createWriter(current.getGeneration() + 1)__                logger.trace("current translog set to [{}]", current.getGeneration())__            } catch (final Exception e) {_                IOUtils.closeWhileHandlingException(this)_ _                throw e__            }_        }_    };roll,the,current,translog,generation,into,a,new,generation,this,does,not,commit,the,translog,throws,ioexception,if,an,i,o,exception,occurred,during,any,file,operations;public,void,roll,generation,throws,ioexception,try,releasable,ignored,write,lock,acquire,try,final,translog,reader,reader,current,close,into,reader,readers,add,reader,final,path,checkpoint,location,resolve,assert,checkpoint,read,checkpoint,generation,current,get,generation,final,path,generation,checkpoint,location,resolve,get,commit,checkpoint,file,name,current,get,generation,files,copy,checkpoint,generation,checkpoint,ioutils,fsync,generation,checkpoint,false,ioutils,fsync,generation,checkpoint,get,parent,true,current,create,writer,current,get,generation,1,logger,trace,current,translog,set,to,current,get,generation,catch,final,exception,e,ioutils,close,while,handling,exception,this,throw,e
Translog -> public void rollGeneration() throws IOException;1534848846;Roll the current translog generation into a new generation. This does not commit the_translog.__@throws IOException if an I/O exception occurred during any file operations;public void rollGeneration() throws IOException {_        try (Releasable ignored = writeLock.acquire()) {_            try {_                final TranslogReader reader = current.closeIntoReader()__                readers.add(reader)__                final Path checkpoint = location.resolve(CHECKPOINT_FILE_NAME)__                assert Checkpoint.read(checkpoint).generation == current.getGeneration()__                final Path generationCheckpoint =_                    location.resolve(getCommitCheckpointFileName(current.getGeneration()))__                Files.copy(checkpoint, generationCheckpoint)__                IOUtils.fsync(generationCheckpoint, false)__                IOUtils.fsync(generationCheckpoint.getParent(), true)__                _                current = createWriter(current.getGeneration() + 1)__                logger.trace("current translog set to [{}]", current.getGeneration())__            } catch (final Exception e) {_                tragedy.setTragicException(e)__                closeOnTragicEvent(e)__                throw e__            }_        }_    };roll,the,current,translog,generation,into,a,new,generation,this,does,not,commit,the,translog,throws,ioexception,if,an,i,o,exception,occurred,during,any,file,operations;public,void,roll,generation,throws,ioexception,try,releasable,ignored,write,lock,acquire,try,final,translog,reader,reader,current,close,into,reader,readers,add,reader,final,path,checkpoint,location,resolve,assert,checkpoint,read,checkpoint,generation,current,get,generation,final,path,generation,checkpoint,location,resolve,get,commit,checkpoint,file,name,current,get,generation,files,copy,checkpoint,generation,checkpoint,ioutils,fsync,generation,checkpoint,false,ioutils,fsync,generation,checkpoint,get,parent,true,current,create,writer,current,get,generation,1,logger,trace,current,translog,set,to,current,get,generation,catch,final,exception,e,tragedy,set,tragic,exception,e,close,on,tragic,event,e,throw,e
Translog -> public void rollGeneration() throws IOException;1535046779;Roll the current translog generation into a new generation. This does not commit the_translog.__@throws IOException if an I/O exception occurred during any file operations;public void rollGeneration() throws IOException {_        try (Releasable ignored = writeLock.acquire()) {_            try {_                final TranslogReader reader = current.closeIntoReader()__                readers.add(reader)__                final Path checkpoint = location.resolve(CHECKPOINT_FILE_NAME)__                assert Checkpoint.read(checkpoint).generation == current.getGeneration()__                final Path generationCheckpoint =_                    location.resolve(getCommitCheckpointFileName(current.getGeneration()))__                Files.copy(checkpoint, generationCheckpoint)__                IOUtils.fsync(generationCheckpoint, false)__                IOUtils.fsync(generationCheckpoint.getParent(), true)__                _                current = createWriter(current.getGeneration() + 1)__                logger.trace("current translog set to [{}]", current.getGeneration())__            } catch (final Exception e) {_                tragedy.setTragicException(e)__                closeOnTragicEvent(e)__                throw e__            }_        }_    };roll,the,current,translog,generation,into,a,new,generation,this,does,not,commit,the,translog,throws,ioexception,if,an,i,o,exception,occurred,during,any,file,operations;public,void,roll,generation,throws,ioexception,try,releasable,ignored,write,lock,acquire,try,final,translog,reader,reader,current,close,into,reader,readers,add,reader,final,path,checkpoint,location,resolve,assert,checkpoint,read,checkpoint,generation,current,get,generation,final,path,generation,checkpoint,location,resolve,get,commit,checkpoint,file,name,current,get,generation,files,copy,checkpoint,generation,checkpoint,ioutils,fsync,generation,checkpoint,false,ioutils,fsync,generation,checkpoint,get,parent,true,current,create,writer,current,get,generation,1,logger,trace,current,translog,set,to,current,get,generation,catch,final,exception,e,tragedy,set,tragic,exception,e,close,on,tragic,event,e,throw,e
Translog -> public void rollGeneration() throws IOException;1535723122;Roll the current translog generation into a new generation. This does not commit the_translog.__@throws IOException if an I/O exception occurred during any file operations;public void rollGeneration() throws IOException {_        try (Releasable ignored = writeLock.acquire()) {_            try {_                final TranslogReader reader = current.closeIntoReader()__                readers.add(reader)__                final Path checkpoint = location.resolve(CHECKPOINT_FILE_NAME)__                assert Checkpoint.read(checkpoint).generation == current.getGeneration()__                final Path generationCheckpoint =_                    location.resolve(getCommitCheckpointFileName(current.getGeneration()))__                Files.copy(checkpoint, generationCheckpoint)__                IOUtils.fsync(generationCheckpoint, false)__                IOUtils.fsync(generationCheckpoint.getParent(), true)__                _                current = createWriter(current.getGeneration() + 1)__                logger.trace("current translog set to [{}]", current.getGeneration())__            } catch (final Exception e) {_                tragedy.setTragicException(e)__                closeOnTragicEvent(e)__                throw e__            }_        }_    };roll,the,current,translog,generation,into,a,new,generation,this,does,not,commit,the,translog,throws,ioexception,if,an,i,o,exception,occurred,during,any,file,operations;public,void,roll,generation,throws,ioexception,try,releasable,ignored,write,lock,acquire,try,final,translog,reader,reader,current,close,into,reader,readers,add,reader,final,path,checkpoint,location,resolve,assert,checkpoint,read,checkpoint,generation,current,get,generation,final,path,generation,checkpoint,location,resolve,get,commit,checkpoint,file,name,current,get,generation,files,copy,checkpoint,generation,checkpoint,ioutils,fsync,generation,checkpoint,false,ioutils,fsync,generation,checkpoint,get,parent,true,current,create,writer,current,get,generation,1,logger,trace,current,translog,set,to,current,get,generation,catch,final,exception,e,tragedy,set,tragic,exception,e,close,on,tragic,event,e,throw,e
Translog -> public void rollGeneration() throws IOException;1537806831;Roll the current translog generation into a new generation. This does not commit the_translog.__@throws IOException if an I/O exception occurred during any file operations;public void rollGeneration() throws IOException {_        try (Releasable ignored = writeLock.acquire()) {_            try {_                final TranslogReader reader = current.closeIntoReader()__                readers.add(reader)__                final Path checkpoint = location.resolve(CHECKPOINT_FILE_NAME)__                assert Checkpoint.read(checkpoint).generation == current.getGeneration()__                final Path generationCheckpoint =_                    location.resolve(getCommitCheckpointFileName(current.getGeneration()))__                Files.copy(checkpoint, generationCheckpoint)__                IOUtils.fsync(generationCheckpoint, false)__                IOUtils.fsync(generationCheckpoint.getParent(), true)__                _                current = createWriter(current.getGeneration() + 1)__                logger.trace("current translog set to [{}]", current.getGeneration())__            } catch (final Exception e) {_                tragedy.setTragicException(e)__                closeOnTragicEvent(e)__                throw e__            }_        }_    };roll,the,current,translog,generation,into,a,new,generation,this,does,not,commit,the,translog,throws,ioexception,if,an,i,o,exception,occurred,during,any,file,operations;public,void,roll,generation,throws,ioexception,try,releasable,ignored,write,lock,acquire,try,final,translog,reader,reader,current,close,into,reader,readers,add,reader,final,path,checkpoint,location,resolve,assert,checkpoint,read,checkpoint,generation,current,get,generation,final,path,generation,checkpoint,location,resolve,get,commit,checkpoint,file,name,current,get,generation,files,copy,checkpoint,generation,checkpoint,ioutils,fsync,generation,checkpoint,false,ioutils,fsync,generation,checkpoint,get,parent,true,current,create,writer,current,get,generation,1,logger,trace,current,translog,set,to,current,get,generation,catch,final,exception,e,tragedy,set,tragic,exception,e,close,on,tragic,event,e,throw,e
Translog -> public void rollGeneration() throws IOException;1541592065;Roll the current translog generation into a new generation. This does not commit the_translog.__@throws IOException if an I/O exception occurred during any file operations;public void rollGeneration() throws IOException {_        try (Releasable ignored = writeLock.acquire()) {_            try {_                final TranslogReader reader = current.closeIntoReader()__                readers.add(reader)__                final Path checkpoint = location.resolve(CHECKPOINT_FILE_NAME)__                assert Checkpoint.read(checkpoint).generation == current.getGeneration()__                final Path generationCheckpoint =_                    location.resolve(getCommitCheckpointFileName(current.getGeneration()))__                Files.copy(checkpoint, generationCheckpoint)__                IOUtils.fsync(generationCheckpoint, false)__                IOUtils.fsync(generationCheckpoint.getParent(), true)__                _                current = createWriter(current.getGeneration() + 1)__                logger.trace("current translog set to [{}]", current.getGeneration())__            } catch (final Exception e) {_                tragedy.setTragicException(e)__                closeOnTragicEvent(e)__                throw e__            }_        }_    };roll,the,current,translog,generation,into,a,new,generation,this,does,not,commit,the,translog,throws,ioexception,if,an,i,o,exception,occurred,during,any,file,operations;public,void,roll,generation,throws,ioexception,try,releasable,ignored,write,lock,acquire,try,final,translog,reader,reader,current,close,into,reader,readers,add,reader,final,path,checkpoint,location,resolve,assert,checkpoint,read,checkpoint,generation,current,get,generation,final,path,generation,checkpoint,location,resolve,get,commit,checkpoint,file,name,current,get,generation,files,copy,checkpoint,generation,checkpoint,ioutils,fsync,generation,checkpoint,false,ioutils,fsync,generation,checkpoint,get,parent,true,current,create,writer,current,get,generation,1,logger,trace,current,translog,set,to,current,get,generation,catch,final,exception,e,tragedy,set,tragic,exception,e,close,on,tragic,event,e,throw,e
Translog -> public void rollGeneration() throws IOException;1542697754;Roll the current translog generation into a new generation. This does not commit the_translog.__@throws IOException if an I/O exception occurred during any file operations;public void rollGeneration() throws IOException {_        try (Releasable ignored = writeLock.acquire()) {_            try {_                final TranslogReader reader = current.closeIntoReader()__                readers.add(reader)__                final Path checkpoint = location.resolve(CHECKPOINT_FILE_NAME)__                assert Checkpoint.read(checkpoint).generation == current.getGeneration()__                final Path generationCheckpoint =_                    location.resolve(getCommitCheckpointFileName(current.getGeneration()))__                Files.copy(checkpoint, generationCheckpoint)__                IOUtils.fsync(generationCheckpoint, false)__                IOUtils.fsync(generationCheckpoint.getParent(), true)__                _                current = createWriter(current.getGeneration() + 1)__                logger.trace("current translog set to [{}]", current.getGeneration())__            } catch (final Exception e) {_                tragedy.setTragicException(e)__                closeOnTragicEvent(e)__                throw e__            }_        }_    };roll,the,current,translog,generation,into,a,new,generation,this,does,not,commit,the,translog,throws,ioexception,if,an,i,o,exception,occurred,during,any,file,operations;public,void,roll,generation,throws,ioexception,try,releasable,ignored,write,lock,acquire,try,final,translog,reader,reader,current,close,into,reader,readers,add,reader,final,path,checkpoint,location,resolve,assert,checkpoint,read,checkpoint,generation,current,get,generation,final,path,generation,checkpoint,location,resolve,get,commit,checkpoint,file,name,current,get,generation,files,copy,checkpoint,generation,checkpoint,ioutils,fsync,generation,checkpoint,false,ioutils,fsync,generation,checkpoint,get,parent,true,current,create,writer,current,get,generation,1,logger,trace,current,translog,set,to,current,get,generation,catch,final,exception,e,tragedy,set,tragic,exception,e,close,on,tragic,event,e,throw,e
Translog -> public void rollGeneration() throws IOException;1542962614;Roll the current translog generation into a new generation. This does not commit the_translog.__@throws IOException if an I/O exception occurred during any file operations;public void rollGeneration() throws IOException {_        try (Releasable ignored = writeLock.acquire()) {_            try {_                final TranslogReader reader = current.closeIntoReader()__                readers.add(reader)__                assert Checkpoint.read(location.resolve(CHECKPOINT_FILE_NAME)).generation == current.getGeneration()__                copyCheckpointTo(location.resolve(getCommitCheckpointFileName(current.getGeneration())))__                _                current = createWriter(current.getGeneration() + 1)__                logger.trace("current translog set to [{}]", current.getGeneration())__            } catch (final Exception e) {_                tragedy.setTragicException(e)__                closeOnTragicEvent(e)__                throw e__            }_        }_    };roll,the,current,translog,generation,into,a,new,generation,this,does,not,commit,the,translog,throws,ioexception,if,an,i,o,exception,occurred,during,any,file,operations;public,void,roll,generation,throws,ioexception,try,releasable,ignored,write,lock,acquire,try,final,translog,reader,reader,current,close,into,reader,readers,add,reader,assert,checkpoint,read,location,resolve,generation,current,get,generation,copy,checkpoint,to,location,resolve,get,commit,checkpoint,file,name,current,get,generation,current,create,writer,current,get,generation,1,logger,trace,current,translog,set,to,current,get,generation,catch,final,exception,e,tragedy,set,tragic,exception,e,close,on,tragic,event,e,throw,e
Translog -> public void rollGeneration() throws IOException;1545236365;Roll the current translog generation into a new generation. This does not commit the_translog.__@throws IOException if an I/O exception occurred during any file operations;public void rollGeneration() throws IOException {_        try (Releasable ignored = writeLock.acquire()) {_            try {_                final TranslogReader reader = current.closeIntoReader()__                readers.add(reader)__                assert Checkpoint.read(location.resolve(CHECKPOINT_FILE_NAME)).generation == current.getGeneration()__                copyCheckpointTo(location.resolve(getCommitCheckpointFileName(current.getGeneration())))__                _                current = createWriter(current.getGeneration() + 1)__                logger.trace("current translog set to [{}]", current.getGeneration())__            } catch (final Exception e) {_                tragedy.setTragicException(e)__                closeOnTragicEvent(e)__                throw e__            }_        }_    };roll,the,current,translog,generation,into,a,new,generation,this,does,not,commit,the,translog,throws,ioexception,if,an,i,o,exception,occurred,during,any,file,operations;public,void,roll,generation,throws,ioexception,try,releasable,ignored,write,lock,acquire,try,final,translog,reader,reader,current,close,into,reader,readers,add,reader,assert,checkpoint,read,location,resolve,generation,current,get,generation,copy,checkpoint,to,location,resolve,get,commit,checkpoint,file,name,current,get,generation,current,create,writer,current,get,generation,1,logger,trace,current,translog,set,to,current,get,generation,catch,final,exception,e,tragedy,set,tragic,exception,e,close,on,tragic,event,e,throw,e
Translog -> public int totalOperationsByMinGen(long minGeneration);1524684173;Returns the number of operations in the translog files at least the given generation;public int totalOperationsByMinGen(long minGeneration) {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            return Stream.concat(readers.stream(), Stream.of(current))_                .filter(r -> r.getGeneration() >= minGeneration)_                .mapToInt(BaseTranslogReader::totalOperations)_                .sum()__        }_    };returns,the,number,of,operations,in,the,translog,files,at,least,the,given,generation;public,int,total,operations,by,min,gen,long,min,generation,try,releasable,lock,ignored,read,lock,acquire,ensure,open,return,stream,concat,readers,stream,stream,of,current,filter,r,r,get,generation,min,generation,map,to,int,base,translog,reader,total,operations,sum
Translog -> public int totalOperationsByMinGen(long minGeneration);1525334055;Returns the number of operations in the translog files at least the given generation;public int totalOperationsByMinGen(long minGeneration) {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            return Stream.concat(readers.stream(), Stream.of(current))_                .filter(r -> r.getGeneration() >= minGeneration)_                .mapToInt(BaseTranslogReader::totalOperations)_                .sum()__        }_    };returns,the,number,of,operations,in,the,translog,files,at,least,the,given,generation;public,int,total,operations,by,min,gen,long,min,generation,try,releasable,lock,ignored,read,lock,acquire,ensure,open,return,stream,concat,readers,stream,stream,of,current,filter,r,r,get,generation,min,generation,map,to,int,base,translog,reader,total,operations,sum
Translog -> public int totalOperationsByMinGen(long minGeneration);1528706846;Returns the number of operations in the translog files at least the given generation;public int totalOperationsByMinGen(long minGeneration) {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            return Stream.concat(readers.stream(), Stream.of(current))_                .filter(r -> r.getGeneration() >= minGeneration)_                .mapToInt(BaseTranslogReader::totalOperations)_                .sum()__        }_    };returns,the,number,of,operations,in,the,translog,files,at,least,the,given,generation;public,int,total,operations,by,min,gen,long,min,generation,try,releasable,lock,ignored,read,lock,acquire,ensure,open,return,stream,concat,readers,stream,stream,of,current,filter,r,r,get,generation,min,generation,map,to,int,base,translog,reader,total,operations,sum
Translog -> public int totalOperationsByMinGen(long minGeneration);1531910483;Returns the number of operations in the translog files at least the given generation;public int totalOperationsByMinGen(long minGeneration) {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            return Stream.concat(readers.stream(), Stream.of(current))_                .filter(r -> r.getGeneration() >= minGeneration)_                .mapToInt(BaseTranslogReader::totalOperations)_                .sum()__        }_    };returns,the,number,of,operations,in,the,translog,files,at,least,the,given,generation;public,int,total,operations,by,min,gen,long,min,generation,try,releasable,lock,ignored,read,lock,acquire,ensure,open,return,stream,concat,readers,stream,stream,of,current,filter,r,r,get,generation,min,generation,map,to,int,base,translog,reader,total,operations,sum
Translog -> public int totalOperationsByMinGen(long minGeneration);1533295538;Returns the number of operations in the translog files at least the given generation;public int totalOperationsByMinGen(long minGeneration) {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            return Stream.concat(readers.stream(), Stream.of(current))_                .filter(r -> r.getGeneration() >= minGeneration)_                .mapToInt(BaseTranslogReader::totalOperations)_                .sum()__        }_    };returns,the,number,of,operations,in,the,translog,files,at,least,the,given,generation;public,int,total,operations,by,min,gen,long,min,generation,try,releasable,lock,ignored,read,lock,acquire,ensure,open,return,stream,concat,readers,stream,stream,of,current,filter,r,r,get,generation,min,generation,map,to,int,base,translog,reader,total,operations,sum
Translog -> public int totalOperationsByMinGen(long minGeneration);1533641732;Returns the number of operations in the translog files at least the given generation;public int totalOperationsByMinGen(long minGeneration) {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            return Stream.concat(readers.stream(), Stream.of(current))_                .filter(r -> r.getGeneration() >= minGeneration)_                .mapToInt(BaseTranslogReader::totalOperations)_                .sum()__        }_    };returns,the,number,of,operations,in,the,translog,files,at,least,the,given,generation;public,int,total,operations,by,min,gen,long,min,generation,try,releasable,lock,ignored,read,lock,acquire,ensure,open,return,stream,concat,readers,stream,stream,of,current,filter,r,r,get,generation,min,generation,map,to,int,base,translog,reader,total,operations,sum
Translog -> public int totalOperationsByMinGen(long minGeneration);1534848846;Returns the number of operations in the translog files at least the given generation;public int totalOperationsByMinGen(long minGeneration) {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            return Stream.concat(readers.stream(), Stream.of(current))_                .filter(r -> r.getGeneration() >= minGeneration)_                .mapToInt(BaseTranslogReader::totalOperations)_                .sum()__        }_    };returns,the,number,of,operations,in,the,translog,files,at,least,the,given,generation;public,int,total,operations,by,min,gen,long,min,generation,try,releasable,lock,ignored,read,lock,acquire,ensure,open,return,stream,concat,readers,stream,stream,of,current,filter,r,r,get,generation,min,generation,map,to,int,base,translog,reader,total,operations,sum
Translog -> public int totalOperationsByMinGen(long minGeneration);1535046779;Returns the number of operations in the translog files at least the given generation;public int totalOperationsByMinGen(long minGeneration) {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            return Stream.concat(readers.stream(), Stream.of(current))_                .filter(r -> r.getGeneration() >= minGeneration)_                .mapToInt(BaseTranslogReader::totalOperations)_                .sum()__        }_    };returns,the,number,of,operations,in,the,translog,files,at,least,the,given,generation;public,int,total,operations,by,min,gen,long,min,generation,try,releasable,lock,ignored,read,lock,acquire,ensure,open,return,stream,concat,readers,stream,stream,of,current,filter,r,r,get,generation,min,generation,map,to,int,base,translog,reader,total,operations,sum
Translog -> public int totalOperationsByMinGen(long minGeneration);1535723122;Returns the number of operations in the translog files at least the given generation;public int totalOperationsByMinGen(long minGeneration) {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            return Stream.concat(readers.stream(), Stream.of(current))_                .filter(r -> r.getGeneration() >= minGeneration)_                .mapToInt(BaseTranslogReader::totalOperations)_                .sum()__        }_    };returns,the,number,of,operations,in,the,translog,files,at,least,the,given,generation;public,int,total,operations,by,min,gen,long,min,generation,try,releasable,lock,ignored,read,lock,acquire,ensure,open,return,stream,concat,readers,stream,stream,of,current,filter,r,r,get,generation,min,generation,map,to,int,base,translog,reader,total,operations,sum
Translog -> public int totalOperationsByMinGen(long minGeneration);1537806831;Returns the number of operations in the translog files at least the given generation;public int totalOperationsByMinGen(long minGeneration) {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            return Stream.concat(readers.stream(), Stream.of(current))_                .filter(r -> r.getGeneration() >= minGeneration)_                .mapToInt(BaseTranslogReader::totalOperations)_                .sum()__        }_    };returns,the,number,of,operations,in,the,translog,files,at,least,the,given,generation;public,int,total,operations,by,min,gen,long,min,generation,try,releasable,lock,ignored,read,lock,acquire,ensure,open,return,stream,concat,readers,stream,stream,of,current,filter,r,r,get,generation,min,generation,map,to,int,base,translog,reader,total,operations,sum
Translog -> public int totalOperationsByMinGen(long minGeneration);1541592065;Returns the number of operations in the translog files at least the given generation;public int totalOperationsByMinGen(long minGeneration) {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            return Stream.concat(readers.stream(), Stream.of(current))_                .filter(r -> r.getGeneration() >= minGeneration)_                .mapToInt(BaseTranslogReader::totalOperations)_                .sum()__        }_    };returns,the,number,of,operations,in,the,translog,files,at,least,the,given,generation;public,int,total,operations,by,min,gen,long,min,generation,try,releasable,lock,ignored,read,lock,acquire,ensure,open,return,stream,concat,readers,stream,stream,of,current,filter,r,r,get,generation,min,generation,map,to,int,base,translog,reader,total,operations,sum
Translog -> public int totalOperationsByMinGen(long minGeneration);1542697754;Returns the number of operations in the translog files at least the given generation;public int totalOperationsByMinGen(long minGeneration) {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            return Stream.concat(readers.stream(), Stream.of(current))_                .filter(r -> r.getGeneration() >= minGeneration)_                .mapToInt(BaseTranslogReader::totalOperations)_                .sum()__        }_    };returns,the,number,of,operations,in,the,translog,files,at,least,the,given,generation;public,int,total,operations,by,min,gen,long,min,generation,try,releasable,lock,ignored,read,lock,acquire,ensure,open,return,stream,concat,readers,stream,stream,of,current,filter,r,r,get,generation,min,generation,map,to,int,base,translog,reader,total,operations,sum
Translog -> public int totalOperationsByMinGen(long minGeneration);1542962614;Returns the number of operations in the translog files at least the given generation;public int totalOperationsByMinGen(long minGeneration) {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            return Stream.concat(readers.stream(), Stream.of(current))_                .filter(r -> r.getGeneration() >= minGeneration)_                .mapToInt(BaseTranslogReader::totalOperations)_                .sum()__        }_    };returns,the,number,of,operations,in,the,translog,files,at,least,the,given,generation;public,int,total,operations,by,min,gen,long,min,generation,try,releasable,lock,ignored,read,lock,acquire,ensure,open,return,stream,concat,readers,stream,stream,of,current,filter,r,r,get,generation,min,generation,map,to,int,base,translog,reader,total,operations,sum
Translog -> public int totalOperationsByMinGen(long minGeneration);1545236365;Returns the number of operations in the translog files at least the given generation;public int totalOperationsByMinGen(long minGeneration) {_        try (ReleasableLock ignored = readLock.acquire()) {_            ensureOpen()__            return Stream.concat(readers.stream(), Stream.of(current))_                .filter(r -> r.getGeneration() >= minGeneration)_                .mapToInt(BaseTranslogReader::totalOperations)_                .sum()__        }_    };returns,the,number,of,operations,in,the,translog,files,at,least,the,given,generation;public,int,total,operations,by,min,gen,long,min,generation,try,releasable,lock,ignored,read,lock,acquire,ensure,open,return,stream,concat,readers,stream,stream,of,current,filter,r,r,get,generation,min,generation,map,to,int,base,translog,reader,total,operations,sum
Translog -> public boolean isOpen();1524684173;Returns {@code true} if this {@code Translog} is still open.;public boolean isOpen() {_        return closed.get() == false__    };returns,code,true,if,this,code,translog,is,still,open;public,boolean,is,open,return,closed,get,false
Translog -> public boolean isOpen();1525334055;Returns {@code true} if this {@code Translog} is still open.;public boolean isOpen() {_        return closed.get() == false__    };returns,code,true,if,this,code,translog,is,still,open;public,boolean,is,open,return,closed,get,false
Translog -> public boolean isOpen();1528706846;Returns {@code true} if this {@code Translog} is still open.;public boolean isOpen() {_        return closed.get() == false__    };returns,code,true,if,this,code,translog,is,still,open;public,boolean,is,open,return,closed,get,false
Translog -> public boolean isOpen();1531910483;Returns {@code true} if this {@code Translog} is still open.;public boolean isOpen() {_        return closed.get() == false__    };returns,code,true,if,this,code,translog,is,still,open;public,boolean,is,open,return,closed,get,false
Translog -> public boolean isOpen();1533295538;Returns {@code true} if this {@code Translog} is still open.;public boolean isOpen() {_        return closed.get() == false__    };returns,code,true,if,this,code,translog,is,still,open;public,boolean,is,open,return,closed,get,false
Translog -> public boolean isOpen();1533641732;Returns {@code true} if this {@code Translog} is still open.;public boolean isOpen() {_        return closed.get() == false__    };returns,code,true,if,this,code,translog,is,still,open;public,boolean,is,open,return,closed,get,false
Translog -> public boolean isOpen();1534848846;Returns {@code true} if this {@code Translog} is still open.;public boolean isOpen() {_        return closed.get() == false__    };returns,code,true,if,this,code,translog,is,still,open;public,boolean,is,open,return,closed,get,false
Translog -> public boolean isOpen();1535046779;Returns {@code true} if this {@code Translog} is still open.;public boolean isOpen() {_        return closed.get() == false__    };returns,code,true,if,this,code,translog,is,still,open;public,boolean,is,open,return,closed,get,false
Translog -> public boolean isOpen();1535723122;Returns {@code true} if this {@code Translog} is still open.;public boolean isOpen() {_        return closed.get() == false__    };returns,code,true,if,this,code,translog,is,still,open;public,boolean,is,open,return,closed,get,false
Translog -> public boolean isOpen();1537806831;Returns {@code true} if this {@code Translog} is still open.;public boolean isOpen() {_        return closed.get() == false__    };returns,code,true,if,this,code,translog,is,still,open;public,boolean,is,open,return,closed,get,false
Translog -> public boolean isOpen();1541592065;Returns {@code true} if this {@code Translog} is still open.;public boolean isOpen() {_        return closed.get() == false__    };returns,code,true,if,this,code,translog,is,still,open;public,boolean,is,open,return,closed,get,false
Translog -> public boolean isOpen();1542697754;Returns {@code true} if this {@code Translog} is still open.;public boolean isOpen() {_        return closed.get() == false__    };returns,code,true,if,this,code,translog,is,still,open;public,boolean,is,open,return,closed,get,false
Translog -> public boolean isOpen();1542962614;Returns {@code true} if this {@code Translog} is still open.;public boolean isOpen() {_        return closed.get() == false__    };returns,code,true,if,this,code,translog,is,still,open;public,boolean,is,open,return,closed,get,false
Translog -> public boolean isOpen();1545236365;Returns {@code true} if this {@code Translog} is still open.;public boolean isOpen() {_        return closed.get() == false__    };returns,code,true,if,this,code,translog,is,still,open;public,boolean,is,open,return,closed,get,false
Translog -> public static String getFilename(long generation);1524684173;package private for testing;public static String getFilename(long generation) {_        return TRANSLOG_FILE_PREFIX + generation + TRANSLOG_FILE_SUFFIX__    };package,private,for,testing;public,static,string,get,filename,long,generation,return,generation
Translog -> public static String getFilename(long generation);1525334055;package private for testing;public static String getFilename(long generation) {_        return TRANSLOG_FILE_PREFIX + generation + TRANSLOG_FILE_SUFFIX__    };package,private,for,testing;public,static,string,get,filename,long,generation,return,generation
Translog -> public static String getFilename(long generation);1528706846;package private for testing;public static String getFilename(long generation) {_        return TRANSLOG_FILE_PREFIX + generation + TRANSLOG_FILE_SUFFIX__    };package,private,for,testing;public,static,string,get,filename,long,generation,return,generation
Translog -> public static String getFilename(long generation);1531910483;package private for testing;public static String getFilename(long generation) {_        return TRANSLOG_FILE_PREFIX + generation + TRANSLOG_FILE_SUFFIX__    };package,private,for,testing;public,static,string,get,filename,long,generation,return,generation
Translog -> public static String getFilename(long generation);1533295538;package private for testing;public static String getFilename(long generation) {_        return TRANSLOG_FILE_PREFIX + generation + TRANSLOG_FILE_SUFFIX__    };package,private,for,testing;public,static,string,get,filename,long,generation,return,generation
Translog -> public static String getFilename(long generation);1533641732;package private for testing;public static String getFilename(long generation) {_        return TRANSLOG_FILE_PREFIX + generation + TRANSLOG_FILE_SUFFIX__    };package,private,for,testing;public,static,string,get,filename,long,generation,return,generation
Translog -> public static String getFilename(long generation);1534848846;package private for testing;public static String getFilename(long generation) {_        return TRANSLOG_FILE_PREFIX + generation + TRANSLOG_FILE_SUFFIX__    };package,private,for,testing;public,static,string,get,filename,long,generation,return,generation
Translog -> public static String getFilename(long generation);1535046779;package private for testing;public static String getFilename(long generation) {_        return TRANSLOG_FILE_PREFIX + generation + TRANSLOG_FILE_SUFFIX__    };package,private,for,testing;public,static,string,get,filename,long,generation,return,generation
Translog -> public static String getFilename(long generation);1535723122;package private for testing;public static String getFilename(long generation) {_        return TRANSLOG_FILE_PREFIX + generation + TRANSLOG_FILE_SUFFIX__    };package,private,for,testing;public,static,string,get,filename,long,generation,return,generation
Translog -> public static String getFilename(long generation);1537806831;package private for testing;public static String getFilename(long generation) {_        return TRANSLOG_FILE_PREFIX + generation + TRANSLOG_FILE_SUFFIX__    };package,private,for,testing;public,static,string,get,filename,long,generation,return,generation
Translog -> public static String getFilename(long generation);1541592065;package private for testing;public static String getFilename(long generation) {_        return TRANSLOG_FILE_PREFIX + generation + TRANSLOG_FILE_SUFFIX__    };package,private,for,testing;public,static,string,get,filename,long,generation,return,generation
Translog -> public static String getFilename(long generation);1542697754;package private for testing;public static String getFilename(long generation) {_        return TRANSLOG_FILE_PREFIX + generation + TRANSLOG_FILE_SUFFIX__    };package,private,for,testing;public,static,string,get,filename,long,generation,return,generation
Translog -> public static String getFilename(long generation);1542962614;package private for testing;public static String getFilename(long generation) {_        return TRANSLOG_FILE_PREFIX + generation + TRANSLOG_FILE_SUFFIX__    };package,private,for,testing;public,static,string,get,filename,long,generation,return,generation
Translog -> public static String getFilename(long generation);1545236365;package private for testing;public static String getFilename(long generation) {_        return TRANSLOG_FILE_PREFIX + generation + TRANSLOG_FILE_SUFFIX__    };package,private,for,testing;public,static,string,get,filename,long,generation,return,generation
Translog -> public Translog(         final TranslogConfig config, final String translogUUID, TranslogDeletionPolicy deletionPolicy,         final LongSupplier globalCheckpointSupplier, final LongSupplier primaryTermSupplier) throws IOException;1524684173;Creates a new Translog instance. This method will create a new transaction log unless the given {@link TranslogGeneration} is_{@code null}. If the generation is {@code null} this method is destructive and will delete all files in the translog path given. If_the generation is not {@code null}, this method tries to open the given translog generation. The generation is treated as the last_generation referenced from already committed data. This means all operations that have not yet been committed should be in the_translog file referenced by this generation. The translog creation will fail if this generation can't be opened.__@param config                   the configuration of this translog_@param translogUUID             the translog uuid to open, null for a new translog_@param deletionPolicy           an instance of {@link TranslogDeletionPolicy} that controls when a translog file can be safely_deleted_@param globalCheckpointSupplier a supplier for the global checkpoint_@param primaryTermSupplier      a supplier for the latest value of primary term of the owning index shard. The latest term value is_examined and stored in the header whenever a new generation is rolled. It's guaranteed from outside_that a new generation is rolled when the term is increased. This guarantee allows to us to validate_and reject operation whose term is higher than the primary term stored in the translog header.;public Translog(_        final TranslogConfig config, final String translogUUID, TranslogDeletionPolicy deletionPolicy,_        final LongSupplier globalCheckpointSupplier, final LongSupplier primaryTermSupplier) throws IOException {_        super(config.getShardId(), config.getIndexSettings())__        this.config = config__        this.globalCheckpointSupplier = globalCheckpointSupplier__        this.primaryTermSupplier = primaryTermSupplier__        this.deletionPolicy = deletionPolicy__        this.translogUUID = translogUUID__        bigArrays = config.getBigArrays()__        ReadWriteLock rwl = new ReentrantReadWriteLock()__        readLock = new ReleasableLock(rwl.readLock())__        writeLock = new ReleasableLock(rwl.writeLock())__        this.location = config.getTranslogPath()__        Files.createDirectories(this.location)___        try {_            final Checkpoint checkpoint = readCheckpoint(location)__            final Path nextTranslogFile = location.resolve(getFilename(checkpoint.generation + 1))__            final Path currentCheckpointFile = location.resolve(getCommitCheckpointFileName(checkpoint.generation))__            _            _            _            _            _            _            _            _            assert Files.exists(nextTranslogFile) == false || Files.size(nextTranslogFile) <= TranslogHeader.headerSizeInBytes(translogUUID) : "unexpected translog file: [" + nextTranslogFile + "]"__            if (Files.exists(currentCheckpointFile) _                && Files.deleteIfExists(nextTranslogFile)) { _                logger.warn("deleted previously created, but not yet committed, next generation [{}]. This can happen due to a tragic exception when creating a new generation", nextTranslogFile.getFileName())__            }_            this.readers.addAll(recoverFromFiles(checkpoint))__            if (readers.isEmpty()) {_                throw new IllegalStateException("at least one reader must be recovered")__            }_            boolean success = false__            current = null__            try {_                current = createWriter(checkpoint.generation + 1, getMinFileGeneration(), checkpoint.globalCheckpoint)__                success = true__            } finally {_                _                _                _                if (success == false) {_                    IOUtils.closeWhileHandlingException(readers)__                }_            }_        } catch (Exception e) {_            _            IOUtils.closeWhileHandlingException(current)__            IOUtils.closeWhileHandlingException(readers)__            throw e__        }_    };creates,a,new,translog,instance,this,method,will,create,a,new,transaction,log,unless,the,given,link,translog,generation,is,code,null,if,the,generation,is,code,null,this,method,is,destructive,and,will,delete,all,files,in,the,translog,path,given,if,the,generation,is,not,code,null,this,method,tries,to,open,the,given,translog,generation,the,generation,is,treated,as,the,last,generation,referenced,from,already,committed,data,this,means,all,operations,that,have,not,yet,been,committed,should,be,in,the,translog,file,referenced,by,this,generation,the,translog,creation,will,fail,if,this,generation,can,t,be,opened,param,config,the,configuration,of,this,translog,param,translog,uuid,the,translog,uuid,to,open,null,for,a,new,translog,param,deletion,policy,an,instance,of,link,translog,deletion,policy,that,controls,when,a,translog,file,can,be,safely,deleted,param,global,checkpoint,supplier,a,supplier,for,the,global,checkpoint,param,primary,term,supplier,a,supplier,for,the,latest,value,of,primary,term,of,the,owning,index,shard,the,latest,term,value,is,examined,and,stored,in,the,header,whenever,a,new,generation,is,rolled,it,s,guaranteed,from,outside,that,a,new,generation,is,rolled,when,the,term,is,increased,this,guarantee,allows,to,us,to,validate,and,reject,operation,whose,term,is,higher,than,the,primary,term,stored,in,the,translog,header;public,translog,final,translog,config,config,final,string,translog,uuid,translog,deletion,policy,deletion,policy,final,long,supplier,global,checkpoint,supplier,final,long,supplier,primary,term,supplier,throws,ioexception,super,config,get,shard,id,config,get,index,settings,this,config,config,this,global,checkpoint,supplier,global,checkpoint,supplier,this,primary,term,supplier,primary,term,supplier,this,deletion,policy,deletion,policy,this,translog,uuid,translog,uuid,big,arrays,config,get,big,arrays,read,write,lock,rwl,new,reentrant,read,write,lock,read,lock,new,releasable,lock,rwl,read,lock,write,lock,new,releasable,lock,rwl,write,lock,this,location,config,get,translog,path,files,create,directories,this,location,try,final,checkpoint,checkpoint,read,checkpoint,location,final,path,next,translog,file,location,resolve,get,filename,checkpoint,generation,1,final,path,current,checkpoint,file,location,resolve,get,commit,checkpoint,file,name,checkpoint,generation,assert,files,exists,next,translog,file,false,files,size,next,translog,file,translog,header,header,size,in,bytes,translog,uuid,unexpected,translog,file,next,translog,file,if,files,exists,current,checkpoint,file,files,delete,if,exists,next,translog,file,logger,warn,deleted,previously,created,but,not,yet,committed,next,generation,this,can,happen,due,to,a,tragic,exception,when,creating,a,new,generation,next,translog,file,get,file,name,this,readers,add,all,recover,from,files,checkpoint,if,readers,is,empty,throw,new,illegal,state,exception,at,least,one,reader,must,be,recovered,boolean,success,false,current,null,try,current,create,writer,checkpoint,generation,1,get,min,file,generation,checkpoint,global,checkpoint,success,true,finally,if,success,false,ioutils,close,while,handling,exception,readers,catch,exception,e,ioutils,close,while,handling,exception,current,ioutils,close,while,handling,exception,readers,throw,e
Translog -> public Translog(         final TranslogConfig config, final String translogUUID, TranslogDeletionPolicy deletionPolicy,         final LongSupplier globalCheckpointSupplier, final LongSupplier primaryTermSupplier) throws IOException;1525334055;Creates a new Translog instance. This method will create a new transaction log unless the given {@link TranslogGeneration} is_{@code null}. If the generation is {@code null} this method is destructive and will delete all files in the translog path given. If_the generation is not {@code null}, this method tries to open the given translog generation. The generation is treated as the last_generation referenced from already committed data. This means all operations that have not yet been committed should be in the_translog file referenced by this generation. The translog creation will fail if this generation can't be opened.__@param config                   the configuration of this translog_@param translogUUID             the translog uuid to open, null for a new translog_@param deletionPolicy           an instance of {@link TranslogDeletionPolicy} that controls when a translog file can be safely_deleted_@param globalCheckpointSupplier a supplier for the global checkpoint_@param primaryTermSupplier      a supplier for the latest value of primary term of the owning index shard. The latest term value is_examined and stored in the header whenever a new generation is rolled. It's guaranteed from outside_that a new generation is rolled when the term is increased. This guarantee allows to us to validate_and reject operation whose term is higher than the primary term stored in the translog header.;public Translog(_        final TranslogConfig config, final String translogUUID, TranslogDeletionPolicy deletionPolicy,_        final LongSupplier globalCheckpointSupplier, final LongSupplier primaryTermSupplier) throws IOException {_        super(config.getShardId(), config.getIndexSettings())__        this.config = config__        this.globalCheckpointSupplier = globalCheckpointSupplier__        this.primaryTermSupplier = primaryTermSupplier__        this.deletionPolicy = deletionPolicy__        this.translogUUID = translogUUID__        bigArrays = config.getBigArrays()__        ReadWriteLock rwl = new ReentrantReadWriteLock()__        readLock = new ReleasableLock(rwl.readLock())__        writeLock = new ReleasableLock(rwl.writeLock())__        this.location = config.getTranslogPath()__        Files.createDirectories(this.location)___        try {_            final Checkpoint checkpoint = readCheckpoint(location)__            final Path nextTranslogFile = location.resolve(getFilename(checkpoint.generation + 1))__            final Path currentCheckpointFile = location.resolve(getCommitCheckpointFileName(checkpoint.generation))__            _            _            _            _            _            _            _            _            assert Files.exists(nextTranslogFile) == false || Files.size(nextTranslogFile) <= TranslogHeader.headerSizeInBytes(translogUUID) : "unexpected translog file: [" + nextTranslogFile + "]"__            if (Files.exists(currentCheckpointFile) _                && Files.deleteIfExists(nextTranslogFile)) { _                logger.warn("deleted previously created, but not yet committed, next generation [{}]. This can happen due to a tragic exception when creating a new generation", nextTranslogFile.getFileName())__            }_            this.readers.addAll(recoverFromFiles(checkpoint))__            if (readers.isEmpty()) {_                throw new IllegalStateException("at least one reader must be recovered")__            }_            boolean success = false__            current = null__            try {_                current = createWriter(checkpoint.generation + 1, getMinFileGeneration(), checkpoint.globalCheckpoint)__                success = true__            } finally {_                _                _                _                if (success == false) {_                    IOUtils.closeWhileHandlingException(readers)__                }_            }_        } catch (Exception e) {_            _            IOUtils.closeWhileHandlingException(current)__            IOUtils.closeWhileHandlingException(readers)__            throw e__        }_    };creates,a,new,translog,instance,this,method,will,create,a,new,transaction,log,unless,the,given,link,translog,generation,is,code,null,if,the,generation,is,code,null,this,method,is,destructive,and,will,delete,all,files,in,the,translog,path,given,if,the,generation,is,not,code,null,this,method,tries,to,open,the,given,translog,generation,the,generation,is,treated,as,the,last,generation,referenced,from,already,committed,data,this,means,all,operations,that,have,not,yet,been,committed,should,be,in,the,translog,file,referenced,by,this,generation,the,translog,creation,will,fail,if,this,generation,can,t,be,opened,param,config,the,configuration,of,this,translog,param,translog,uuid,the,translog,uuid,to,open,null,for,a,new,translog,param,deletion,policy,an,instance,of,link,translog,deletion,policy,that,controls,when,a,translog,file,can,be,safely,deleted,param,global,checkpoint,supplier,a,supplier,for,the,global,checkpoint,param,primary,term,supplier,a,supplier,for,the,latest,value,of,primary,term,of,the,owning,index,shard,the,latest,term,value,is,examined,and,stored,in,the,header,whenever,a,new,generation,is,rolled,it,s,guaranteed,from,outside,that,a,new,generation,is,rolled,when,the,term,is,increased,this,guarantee,allows,to,us,to,validate,and,reject,operation,whose,term,is,higher,than,the,primary,term,stored,in,the,translog,header;public,translog,final,translog,config,config,final,string,translog,uuid,translog,deletion,policy,deletion,policy,final,long,supplier,global,checkpoint,supplier,final,long,supplier,primary,term,supplier,throws,ioexception,super,config,get,shard,id,config,get,index,settings,this,config,config,this,global,checkpoint,supplier,global,checkpoint,supplier,this,primary,term,supplier,primary,term,supplier,this,deletion,policy,deletion,policy,this,translog,uuid,translog,uuid,big,arrays,config,get,big,arrays,read,write,lock,rwl,new,reentrant,read,write,lock,read,lock,new,releasable,lock,rwl,read,lock,write,lock,new,releasable,lock,rwl,write,lock,this,location,config,get,translog,path,files,create,directories,this,location,try,final,checkpoint,checkpoint,read,checkpoint,location,final,path,next,translog,file,location,resolve,get,filename,checkpoint,generation,1,final,path,current,checkpoint,file,location,resolve,get,commit,checkpoint,file,name,checkpoint,generation,assert,files,exists,next,translog,file,false,files,size,next,translog,file,translog,header,header,size,in,bytes,translog,uuid,unexpected,translog,file,next,translog,file,if,files,exists,current,checkpoint,file,files,delete,if,exists,next,translog,file,logger,warn,deleted,previously,created,but,not,yet,committed,next,generation,this,can,happen,due,to,a,tragic,exception,when,creating,a,new,generation,next,translog,file,get,file,name,this,readers,add,all,recover,from,files,checkpoint,if,readers,is,empty,throw,new,illegal,state,exception,at,least,one,reader,must,be,recovered,boolean,success,false,current,null,try,current,create,writer,checkpoint,generation,1,get,min,file,generation,checkpoint,global,checkpoint,success,true,finally,if,success,false,ioutils,close,while,handling,exception,readers,catch,exception,e,ioutils,close,while,handling,exception,current,ioutils,close,while,handling,exception,readers,throw,e
Translog -> public Translog(         final TranslogConfig config, final String translogUUID, TranslogDeletionPolicy deletionPolicy,         final LongSupplier globalCheckpointSupplier, final LongSupplier primaryTermSupplier) throws IOException;1528706846;Creates a new Translog instance. This method will create a new transaction log unless the given {@link TranslogGeneration} is_{@code null}. If the generation is {@code null} this method is destructive and will delete all files in the translog path given. If_the generation is not {@code null}, this method tries to open the given translog generation. The generation is treated as the last_generation referenced from already committed data. This means all operations that have not yet been committed should be in the_translog file referenced by this generation. The translog creation will fail if this generation can't be opened.__@param config                   the configuration of this translog_@param translogUUID             the translog uuid to open, null for a new translog_@param deletionPolicy           an instance of {@link TranslogDeletionPolicy} that controls when a translog file can be safely_deleted_@param globalCheckpointSupplier a supplier for the global checkpoint_@param primaryTermSupplier      a supplier for the latest value of primary term of the owning index shard. The latest term value is_examined and stored in the header whenever a new generation is rolled. It's guaranteed from outside_that a new generation is rolled when the term is increased. This guarantee allows to us to validate_and reject operation whose term is higher than the primary term stored in the translog header.;public Translog(_        final TranslogConfig config, final String translogUUID, TranslogDeletionPolicy deletionPolicy,_        final LongSupplier globalCheckpointSupplier, final LongSupplier primaryTermSupplier) throws IOException {_        super(config.getShardId(), config.getIndexSettings())__        this.config = config__        this.globalCheckpointSupplier = globalCheckpointSupplier__        this.primaryTermSupplier = primaryTermSupplier__        this.deletionPolicy = deletionPolicy__        this.translogUUID = translogUUID__        bigArrays = config.getBigArrays()__        ReadWriteLock rwl = new ReentrantReadWriteLock()__        readLock = new ReleasableLock(rwl.readLock())__        writeLock = new ReleasableLock(rwl.writeLock())__        this.location = config.getTranslogPath()__        Files.createDirectories(this.location)___        try {_            final Checkpoint checkpoint = readCheckpoint(location)__            final Path nextTranslogFile = location.resolve(getFilename(checkpoint.generation + 1))__            final Path currentCheckpointFile = location.resolve(getCommitCheckpointFileName(checkpoint.generation))__            _            _            _            _            _            _            _            _            assert Files.exists(nextTranslogFile) == false || Files.size(nextTranslogFile) <= TranslogHeader.headerSizeInBytes(translogUUID) : "unexpected translog file: [" + nextTranslogFile + "]"__            if (Files.exists(currentCheckpointFile) _                && Files.deleteIfExists(nextTranslogFile)) { _                logger.warn("deleted previously created, but not yet committed, next generation [{}]. This can happen due to a tragic exception when creating a new generation", nextTranslogFile.getFileName())__            }_            this.readers.addAll(recoverFromFiles(checkpoint))__            if (readers.isEmpty()) {_                throw new IllegalStateException("at least one reader must be recovered")__            }_            boolean success = false__            current = null__            try {_                current = createWriter(checkpoint.generation + 1, getMinFileGeneration(), checkpoint.globalCheckpoint)__                success = true__            } finally {_                _                _                _                if (success == false) {_                    IOUtils.closeWhileHandlingException(readers)__                }_            }_        } catch (Exception e) {_            _            IOUtils.closeWhileHandlingException(current)__            IOUtils.closeWhileHandlingException(readers)__            throw e__        }_    };creates,a,new,translog,instance,this,method,will,create,a,new,transaction,log,unless,the,given,link,translog,generation,is,code,null,if,the,generation,is,code,null,this,method,is,destructive,and,will,delete,all,files,in,the,translog,path,given,if,the,generation,is,not,code,null,this,method,tries,to,open,the,given,translog,generation,the,generation,is,treated,as,the,last,generation,referenced,from,already,committed,data,this,means,all,operations,that,have,not,yet,been,committed,should,be,in,the,translog,file,referenced,by,this,generation,the,translog,creation,will,fail,if,this,generation,can,t,be,opened,param,config,the,configuration,of,this,translog,param,translog,uuid,the,translog,uuid,to,open,null,for,a,new,translog,param,deletion,policy,an,instance,of,link,translog,deletion,policy,that,controls,when,a,translog,file,can,be,safely,deleted,param,global,checkpoint,supplier,a,supplier,for,the,global,checkpoint,param,primary,term,supplier,a,supplier,for,the,latest,value,of,primary,term,of,the,owning,index,shard,the,latest,term,value,is,examined,and,stored,in,the,header,whenever,a,new,generation,is,rolled,it,s,guaranteed,from,outside,that,a,new,generation,is,rolled,when,the,term,is,increased,this,guarantee,allows,to,us,to,validate,and,reject,operation,whose,term,is,higher,than,the,primary,term,stored,in,the,translog,header;public,translog,final,translog,config,config,final,string,translog,uuid,translog,deletion,policy,deletion,policy,final,long,supplier,global,checkpoint,supplier,final,long,supplier,primary,term,supplier,throws,ioexception,super,config,get,shard,id,config,get,index,settings,this,config,config,this,global,checkpoint,supplier,global,checkpoint,supplier,this,primary,term,supplier,primary,term,supplier,this,deletion,policy,deletion,policy,this,translog,uuid,translog,uuid,big,arrays,config,get,big,arrays,read,write,lock,rwl,new,reentrant,read,write,lock,read,lock,new,releasable,lock,rwl,read,lock,write,lock,new,releasable,lock,rwl,write,lock,this,location,config,get,translog,path,files,create,directories,this,location,try,final,checkpoint,checkpoint,read,checkpoint,location,final,path,next,translog,file,location,resolve,get,filename,checkpoint,generation,1,final,path,current,checkpoint,file,location,resolve,get,commit,checkpoint,file,name,checkpoint,generation,assert,files,exists,next,translog,file,false,files,size,next,translog,file,translog,header,header,size,in,bytes,translog,uuid,unexpected,translog,file,next,translog,file,if,files,exists,current,checkpoint,file,files,delete,if,exists,next,translog,file,logger,warn,deleted,previously,created,but,not,yet,committed,next,generation,this,can,happen,due,to,a,tragic,exception,when,creating,a,new,generation,next,translog,file,get,file,name,this,readers,add,all,recover,from,files,checkpoint,if,readers,is,empty,throw,new,illegal,state,exception,at,least,one,reader,must,be,recovered,boolean,success,false,current,null,try,current,create,writer,checkpoint,generation,1,get,min,file,generation,checkpoint,global,checkpoint,success,true,finally,if,success,false,ioutils,close,while,handling,exception,readers,catch,exception,e,ioutils,close,while,handling,exception,current,ioutils,close,while,handling,exception,readers,throw,e
Translog -> public Translog(         final TranslogConfig config, final String translogUUID, TranslogDeletionPolicy deletionPolicy,         final LongSupplier globalCheckpointSupplier, final LongSupplier primaryTermSupplier) throws IOException;1531910483;Creates a new Translog instance. This method will create a new transaction log unless the given {@link TranslogGeneration} is_{@code null}. If the generation is {@code null} this method is destructive and will delete all files in the translog path given. If_the generation is not {@code null}, this method tries to open the given translog generation. The generation is treated as the last_generation referenced from already committed data. This means all operations that have not yet been committed should be in the_translog file referenced by this generation. The translog creation will fail if this generation can't be opened.__@param config                   the configuration of this translog_@param translogUUID             the translog uuid to open, null for a new translog_@param deletionPolicy           an instance of {@link TranslogDeletionPolicy} that controls when a translog file can be safely_deleted_@param globalCheckpointSupplier a supplier for the global checkpoint_@param primaryTermSupplier      a supplier for the latest value of primary term of the owning index shard. The latest term value is_examined and stored in the header whenever a new generation is rolled. It's guaranteed from outside_that a new generation is rolled when the term is increased. This guarantee allows to us to validate_and reject operation whose term is higher than the primary term stored in the translog header.;public Translog(_        final TranslogConfig config, final String translogUUID, TranslogDeletionPolicy deletionPolicy,_        final LongSupplier globalCheckpointSupplier, final LongSupplier primaryTermSupplier) throws IOException {_        super(config.getShardId(), config.getIndexSettings())__        this.config = config__        this.globalCheckpointSupplier = globalCheckpointSupplier__        this.primaryTermSupplier = primaryTermSupplier__        this.deletionPolicy = deletionPolicy__        this.translogUUID = translogUUID__        bigArrays = config.getBigArrays()__        ReadWriteLock rwl = new ReentrantReadWriteLock()__        readLock = new ReleasableLock(rwl.readLock())__        writeLock = new ReleasableLock(rwl.writeLock())__        this.location = config.getTranslogPath()__        Files.createDirectories(this.location)___        try {_            final Checkpoint checkpoint = readCheckpoint(location)__            final Path nextTranslogFile = location.resolve(getFilename(checkpoint.generation + 1))__            final Path currentCheckpointFile = location.resolve(getCommitCheckpointFileName(checkpoint.generation))__            _            _            _            _            _            _            _            _            assert Files.exists(nextTranslogFile) == false || Files.size(nextTranslogFile) <= TranslogHeader.headerSizeInBytes(translogUUID) : "unexpected translog file: [" + nextTranslogFile + "]"__            if (Files.exists(currentCheckpointFile) _                && Files.deleteIfExists(nextTranslogFile)) { _                logger.warn("deleted previously created, but not yet committed, next generation [{}]. This can happen due to a tragic exception when creating a new generation", nextTranslogFile.getFileName())__            }_            this.readers.addAll(recoverFromFiles(checkpoint))__            if (readers.isEmpty()) {_                throw new IllegalStateException("at least one reader must be recovered")__            }_            boolean success = false__            current = null__            try {_                current = createWriter(checkpoint.generation + 1, getMinFileGeneration(), checkpoint.globalCheckpoint)__                success = true__            } finally {_                _                _                _                if (success == false) {_                    IOUtils.closeWhileHandlingException(readers)__                }_            }_        } catch (Exception e) {_            _            IOUtils.closeWhileHandlingException(current)__            IOUtils.closeWhileHandlingException(readers)__            throw e__        }_    };creates,a,new,translog,instance,this,method,will,create,a,new,transaction,log,unless,the,given,link,translog,generation,is,code,null,if,the,generation,is,code,null,this,method,is,destructive,and,will,delete,all,files,in,the,translog,path,given,if,the,generation,is,not,code,null,this,method,tries,to,open,the,given,translog,generation,the,generation,is,treated,as,the,last,generation,referenced,from,already,committed,data,this,means,all,operations,that,have,not,yet,been,committed,should,be,in,the,translog,file,referenced,by,this,generation,the,translog,creation,will,fail,if,this,generation,can,t,be,opened,param,config,the,configuration,of,this,translog,param,translog,uuid,the,translog,uuid,to,open,null,for,a,new,translog,param,deletion,policy,an,instance,of,link,translog,deletion,policy,that,controls,when,a,translog,file,can,be,safely,deleted,param,global,checkpoint,supplier,a,supplier,for,the,global,checkpoint,param,primary,term,supplier,a,supplier,for,the,latest,value,of,primary,term,of,the,owning,index,shard,the,latest,term,value,is,examined,and,stored,in,the,header,whenever,a,new,generation,is,rolled,it,s,guaranteed,from,outside,that,a,new,generation,is,rolled,when,the,term,is,increased,this,guarantee,allows,to,us,to,validate,and,reject,operation,whose,term,is,higher,than,the,primary,term,stored,in,the,translog,header;public,translog,final,translog,config,config,final,string,translog,uuid,translog,deletion,policy,deletion,policy,final,long,supplier,global,checkpoint,supplier,final,long,supplier,primary,term,supplier,throws,ioexception,super,config,get,shard,id,config,get,index,settings,this,config,config,this,global,checkpoint,supplier,global,checkpoint,supplier,this,primary,term,supplier,primary,term,supplier,this,deletion,policy,deletion,policy,this,translog,uuid,translog,uuid,big,arrays,config,get,big,arrays,read,write,lock,rwl,new,reentrant,read,write,lock,read,lock,new,releasable,lock,rwl,read,lock,write,lock,new,releasable,lock,rwl,write,lock,this,location,config,get,translog,path,files,create,directories,this,location,try,final,checkpoint,checkpoint,read,checkpoint,location,final,path,next,translog,file,location,resolve,get,filename,checkpoint,generation,1,final,path,current,checkpoint,file,location,resolve,get,commit,checkpoint,file,name,checkpoint,generation,assert,files,exists,next,translog,file,false,files,size,next,translog,file,translog,header,header,size,in,bytes,translog,uuid,unexpected,translog,file,next,translog,file,if,files,exists,current,checkpoint,file,files,delete,if,exists,next,translog,file,logger,warn,deleted,previously,created,but,not,yet,committed,next,generation,this,can,happen,due,to,a,tragic,exception,when,creating,a,new,generation,next,translog,file,get,file,name,this,readers,add,all,recover,from,files,checkpoint,if,readers,is,empty,throw,new,illegal,state,exception,at,least,one,reader,must,be,recovered,boolean,success,false,current,null,try,current,create,writer,checkpoint,generation,1,get,min,file,generation,checkpoint,global,checkpoint,success,true,finally,if,success,false,ioutils,close,while,handling,exception,readers,catch,exception,e,ioutils,close,while,handling,exception,current,ioutils,close,while,handling,exception,readers,throw,e
Translog -> public Translog(         final TranslogConfig config, final String translogUUID, TranslogDeletionPolicy deletionPolicy,         final LongSupplier globalCheckpointSupplier, final LongSupplier primaryTermSupplier) throws IOException;1533295538;Creates a new Translog instance. This method will create a new transaction log unless the given {@link TranslogGeneration} is_{@code null}. If the generation is {@code null} this method is destructive and will delete all files in the translog path given. If_the generation is not {@code null}, this method tries to open the given translog generation. The generation is treated as the last_generation referenced from already committed data. This means all operations that have not yet been committed should be in the_translog file referenced by this generation. The translog creation will fail if this generation can't be opened.__@param config                   the configuration of this translog_@param translogUUID             the translog uuid to open, null for a new translog_@param deletionPolicy           an instance of {@link TranslogDeletionPolicy} that controls when a translog file can be safely_deleted_@param globalCheckpointSupplier a supplier for the global checkpoint_@param primaryTermSupplier      a supplier for the latest value of primary term of the owning index shard. The latest term value is_examined and stored in the header whenever a new generation is rolled. It's guaranteed from outside_that a new generation is rolled when the term is increased. This guarantee allows to us to validate_and reject operation whose term is higher than the primary term stored in the translog header.;public Translog(_        final TranslogConfig config, final String translogUUID, TranslogDeletionPolicy deletionPolicy,_        final LongSupplier globalCheckpointSupplier, final LongSupplier primaryTermSupplier) throws IOException {_        super(config.getShardId(), config.getIndexSettings())__        this.config = config__        this.globalCheckpointSupplier = globalCheckpointSupplier__        this.primaryTermSupplier = primaryTermSupplier__        this.deletionPolicy = deletionPolicy__        this.translogUUID = translogUUID__        bigArrays = config.getBigArrays()__        ReadWriteLock rwl = new ReentrantReadWriteLock()__        readLock = new ReleasableLock(rwl.readLock())__        writeLock = new ReleasableLock(rwl.writeLock())__        this.location = config.getTranslogPath()__        Files.createDirectories(this.location)___        try {_            final Checkpoint checkpoint = readCheckpoint(location)__            final Path nextTranslogFile = location.resolve(getFilename(checkpoint.generation + 1))__            final Path currentCheckpointFile = location.resolve(getCommitCheckpointFileName(checkpoint.generation))__            _            _            _            _            _            _            _            _            assert Files.exists(nextTranslogFile) == false || Files.size(nextTranslogFile) <= TranslogHeader.headerSizeInBytes(translogUUID) : "unexpected translog file: [" + nextTranslogFile + "]"__            if (Files.exists(currentCheckpointFile) _                && Files.deleteIfExists(nextTranslogFile)) { _                logger.warn("deleted previously created, but not yet committed, next generation [{}]. This can happen due to a tragic exception when creating a new generation", nextTranslogFile.getFileName())__            }_            this.readers.addAll(recoverFromFiles(checkpoint))__            if (readers.isEmpty()) {_                throw new IllegalStateException("at least one reader must be recovered")__            }_            boolean success = false__            current = null__            try {_                current = createWriter(checkpoint.generation + 1, getMinFileGeneration(), checkpoint.globalCheckpoint)__                success = true__            } finally {_                _                _                _                if (success == false) {_                    IOUtils.closeWhileHandlingException(readers)__                }_            }_        } catch (Exception e) {_            _            IOUtils.closeWhileHandlingException(current)__            IOUtils.closeWhileHandlingException(readers)__            throw e__        }_    };creates,a,new,translog,instance,this,method,will,create,a,new,transaction,log,unless,the,given,link,translog,generation,is,code,null,if,the,generation,is,code,null,this,method,is,destructive,and,will,delete,all,files,in,the,translog,path,given,if,the,generation,is,not,code,null,this,method,tries,to,open,the,given,translog,generation,the,generation,is,treated,as,the,last,generation,referenced,from,already,committed,data,this,means,all,operations,that,have,not,yet,been,committed,should,be,in,the,translog,file,referenced,by,this,generation,the,translog,creation,will,fail,if,this,generation,can,t,be,opened,param,config,the,configuration,of,this,translog,param,translog,uuid,the,translog,uuid,to,open,null,for,a,new,translog,param,deletion,policy,an,instance,of,link,translog,deletion,policy,that,controls,when,a,translog,file,can,be,safely,deleted,param,global,checkpoint,supplier,a,supplier,for,the,global,checkpoint,param,primary,term,supplier,a,supplier,for,the,latest,value,of,primary,term,of,the,owning,index,shard,the,latest,term,value,is,examined,and,stored,in,the,header,whenever,a,new,generation,is,rolled,it,s,guaranteed,from,outside,that,a,new,generation,is,rolled,when,the,term,is,increased,this,guarantee,allows,to,us,to,validate,and,reject,operation,whose,term,is,higher,than,the,primary,term,stored,in,the,translog,header;public,translog,final,translog,config,config,final,string,translog,uuid,translog,deletion,policy,deletion,policy,final,long,supplier,global,checkpoint,supplier,final,long,supplier,primary,term,supplier,throws,ioexception,super,config,get,shard,id,config,get,index,settings,this,config,config,this,global,checkpoint,supplier,global,checkpoint,supplier,this,primary,term,supplier,primary,term,supplier,this,deletion,policy,deletion,policy,this,translog,uuid,translog,uuid,big,arrays,config,get,big,arrays,read,write,lock,rwl,new,reentrant,read,write,lock,read,lock,new,releasable,lock,rwl,read,lock,write,lock,new,releasable,lock,rwl,write,lock,this,location,config,get,translog,path,files,create,directories,this,location,try,final,checkpoint,checkpoint,read,checkpoint,location,final,path,next,translog,file,location,resolve,get,filename,checkpoint,generation,1,final,path,current,checkpoint,file,location,resolve,get,commit,checkpoint,file,name,checkpoint,generation,assert,files,exists,next,translog,file,false,files,size,next,translog,file,translog,header,header,size,in,bytes,translog,uuid,unexpected,translog,file,next,translog,file,if,files,exists,current,checkpoint,file,files,delete,if,exists,next,translog,file,logger,warn,deleted,previously,created,but,not,yet,committed,next,generation,this,can,happen,due,to,a,tragic,exception,when,creating,a,new,generation,next,translog,file,get,file,name,this,readers,add,all,recover,from,files,checkpoint,if,readers,is,empty,throw,new,illegal,state,exception,at,least,one,reader,must,be,recovered,boolean,success,false,current,null,try,current,create,writer,checkpoint,generation,1,get,min,file,generation,checkpoint,global,checkpoint,success,true,finally,if,success,false,ioutils,close,while,handling,exception,readers,catch,exception,e,ioutils,close,while,handling,exception,current,ioutils,close,while,handling,exception,readers,throw,e
Translog -> public Translog(         final TranslogConfig config, final String translogUUID, TranslogDeletionPolicy deletionPolicy,         final LongSupplier globalCheckpointSupplier, final LongSupplier primaryTermSupplier) throws IOException;1533641732;Creates a new Translog instance. This method will create a new transaction log unless the given {@link TranslogGeneration} is_{@code null}. If the generation is {@code null} this method is destructive and will delete all files in the translog path given. If_the generation is not {@code null}, this method tries to open the given translog generation. The generation is treated as the last_generation referenced from already committed data. This means all operations that have not yet been committed should be in the_translog file referenced by this generation. The translog creation will fail if this generation can't be opened.__@param config                   the configuration of this translog_@param translogUUID             the translog uuid to open, null for a new translog_@param deletionPolicy           an instance of {@link TranslogDeletionPolicy} that controls when a translog file can be safely_deleted_@param globalCheckpointSupplier a supplier for the global checkpoint_@param primaryTermSupplier      a supplier for the latest value of primary term of the owning index shard. The latest term value is_examined and stored in the header whenever a new generation is rolled. It's guaranteed from outside_that a new generation is rolled when the term is increased. This guarantee allows to us to validate_and reject operation whose term is higher than the primary term stored in the translog header.;public Translog(_        final TranslogConfig config, final String translogUUID, TranslogDeletionPolicy deletionPolicy,_        final LongSupplier globalCheckpointSupplier, final LongSupplier primaryTermSupplier) throws IOException {_        super(config.getShardId(), config.getIndexSettings())__        this.config = config__        this.globalCheckpointSupplier = globalCheckpointSupplier__        this.primaryTermSupplier = primaryTermSupplier__        this.deletionPolicy = deletionPolicy__        this.translogUUID = translogUUID__        bigArrays = config.getBigArrays()__        ReadWriteLock rwl = new ReentrantReadWriteLock()__        readLock = new ReleasableLock(rwl.readLock())__        writeLock = new ReleasableLock(rwl.writeLock())__        this.location = config.getTranslogPath()__        Files.createDirectories(this.location)___        try {_            final Checkpoint checkpoint = readCheckpoint(location)__            final Path nextTranslogFile = location.resolve(getFilename(checkpoint.generation + 1))__            final Path currentCheckpointFile = location.resolve(getCommitCheckpointFileName(checkpoint.generation))__            _            _            _            _            _            _            _            _            assert Files.exists(nextTranslogFile) == false || Files.size(nextTranslogFile) <= TranslogHeader.headerSizeInBytes(translogUUID) : "unexpected translog file: [" + nextTranslogFile + "]"__            if (Files.exists(currentCheckpointFile) _                && Files.deleteIfExists(nextTranslogFile)) { _                logger.warn("deleted previously created, but not yet committed, next generation [{}]. This can happen due to a tragic exception when creating a new generation", nextTranslogFile.getFileName())__            }_            this.readers.addAll(recoverFromFiles(checkpoint))__            if (readers.isEmpty()) {_                throw new IllegalStateException("at least one reader must be recovered")__            }_            boolean success = false__            current = null__            try {_                current = createWriter(checkpoint.generation + 1, getMinFileGeneration(), checkpoint.globalCheckpoint)__                success = true__            } finally {_                _                _                _                if (success == false) {_                    IOUtils.closeWhileHandlingException(readers)__                }_            }_        } catch (Exception e) {_            _            IOUtils.closeWhileHandlingException(current)__            IOUtils.closeWhileHandlingException(readers)__            throw e__        }_    };creates,a,new,translog,instance,this,method,will,create,a,new,transaction,log,unless,the,given,link,translog,generation,is,code,null,if,the,generation,is,code,null,this,method,is,destructive,and,will,delete,all,files,in,the,translog,path,given,if,the,generation,is,not,code,null,this,method,tries,to,open,the,given,translog,generation,the,generation,is,treated,as,the,last,generation,referenced,from,already,committed,data,this,means,all,operations,that,have,not,yet,been,committed,should,be,in,the,translog,file,referenced,by,this,generation,the,translog,creation,will,fail,if,this,generation,can,t,be,opened,param,config,the,configuration,of,this,translog,param,translog,uuid,the,translog,uuid,to,open,null,for,a,new,translog,param,deletion,policy,an,instance,of,link,translog,deletion,policy,that,controls,when,a,translog,file,can,be,safely,deleted,param,global,checkpoint,supplier,a,supplier,for,the,global,checkpoint,param,primary,term,supplier,a,supplier,for,the,latest,value,of,primary,term,of,the,owning,index,shard,the,latest,term,value,is,examined,and,stored,in,the,header,whenever,a,new,generation,is,rolled,it,s,guaranteed,from,outside,that,a,new,generation,is,rolled,when,the,term,is,increased,this,guarantee,allows,to,us,to,validate,and,reject,operation,whose,term,is,higher,than,the,primary,term,stored,in,the,translog,header;public,translog,final,translog,config,config,final,string,translog,uuid,translog,deletion,policy,deletion,policy,final,long,supplier,global,checkpoint,supplier,final,long,supplier,primary,term,supplier,throws,ioexception,super,config,get,shard,id,config,get,index,settings,this,config,config,this,global,checkpoint,supplier,global,checkpoint,supplier,this,primary,term,supplier,primary,term,supplier,this,deletion,policy,deletion,policy,this,translog,uuid,translog,uuid,big,arrays,config,get,big,arrays,read,write,lock,rwl,new,reentrant,read,write,lock,read,lock,new,releasable,lock,rwl,read,lock,write,lock,new,releasable,lock,rwl,write,lock,this,location,config,get,translog,path,files,create,directories,this,location,try,final,checkpoint,checkpoint,read,checkpoint,location,final,path,next,translog,file,location,resolve,get,filename,checkpoint,generation,1,final,path,current,checkpoint,file,location,resolve,get,commit,checkpoint,file,name,checkpoint,generation,assert,files,exists,next,translog,file,false,files,size,next,translog,file,translog,header,header,size,in,bytes,translog,uuid,unexpected,translog,file,next,translog,file,if,files,exists,current,checkpoint,file,files,delete,if,exists,next,translog,file,logger,warn,deleted,previously,created,but,not,yet,committed,next,generation,this,can,happen,due,to,a,tragic,exception,when,creating,a,new,generation,next,translog,file,get,file,name,this,readers,add,all,recover,from,files,checkpoint,if,readers,is,empty,throw,new,illegal,state,exception,at,least,one,reader,must,be,recovered,boolean,success,false,current,null,try,current,create,writer,checkpoint,generation,1,get,min,file,generation,checkpoint,global,checkpoint,success,true,finally,if,success,false,ioutils,close,while,handling,exception,readers,catch,exception,e,ioutils,close,while,handling,exception,current,ioutils,close,while,handling,exception,readers,throw,e
Translog -> public Translog(         final TranslogConfig config, final String translogUUID, TranslogDeletionPolicy deletionPolicy,         final LongSupplier globalCheckpointSupplier, final LongSupplier primaryTermSupplier) throws IOException;1534848846;Creates a new Translog instance. This method will create a new transaction log unless the given {@link TranslogGeneration} is_{@code null}. If the generation is {@code null} this method is destructive and will delete all files in the translog path given. If_the generation is not {@code null}, this method tries to open the given translog generation. The generation is treated as the last_generation referenced from already committed data. This means all operations that have not yet been committed should be in the_translog file referenced by this generation. The translog creation will fail if this generation can't be opened.__@param config                   the configuration of this translog_@param translogUUID             the translog uuid to open, null for a new translog_@param deletionPolicy           an instance of {@link TranslogDeletionPolicy} that controls when a translog file can be safely_deleted_@param globalCheckpointSupplier a supplier for the global checkpoint_@param primaryTermSupplier      a supplier for the latest value of primary term of the owning index shard. The latest term value is_examined and stored in the header whenever a new generation is rolled. It's guaranteed from outside_that a new generation is rolled when the term is increased. This guarantee allows to us to validate_and reject operation whose term is higher than the primary term stored in the translog header.;public Translog(_        final TranslogConfig config, final String translogUUID, TranslogDeletionPolicy deletionPolicy,_        final LongSupplier globalCheckpointSupplier, final LongSupplier primaryTermSupplier) throws IOException {_        super(config.getShardId(), config.getIndexSettings())__        this.config = config__        this.globalCheckpointSupplier = globalCheckpointSupplier__        this.primaryTermSupplier = primaryTermSupplier__        this.deletionPolicy = deletionPolicy__        this.translogUUID = translogUUID__        bigArrays = config.getBigArrays()__        ReadWriteLock rwl = new ReentrantReadWriteLock()__        readLock = new ReleasableLock(rwl.readLock())__        writeLock = new ReleasableLock(rwl.writeLock())__        this.location = config.getTranslogPath()__        Files.createDirectories(this.location)___        try {_            final Checkpoint checkpoint = readCheckpoint(location)__            final Path nextTranslogFile = location.resolve(getFilename(checkpoint.generation + 1))__            final Path currentCheckpointFile = location.resolve(getCommitCheckpointFileName(checkpoint.generation))__            _            _            _            _            _            _            _            _            assert Files.exists(nextTranslogFile) == false || Files.size(nextTranslogFile) <= TranslogHeader.headerSizeInBytes(translogUUID) : "unexpected translog file: [" + nextTranslogFile + "]"__            if (Files.exists(currentCheckpointFile) _                && Files.deleteIfExists(nextTranslogFile)) { _                logger.warn("deleted previously created, but not yet committed, next generation [{}]. This can happen due to a tragic exception when creating a new generation", nextTranslogFile.getFileName())__            }_            this.readers.addAll(recoverFromFiles(checkpoint))__            if (readers.isEmpty()) {_                throw new IllegalStateException("at least one reader must be recovered")__            }_            boolean success = false__            current = null__            try {_                current = createWriter(checkpoint.generation + 1, getMinFileGeneration(), checkpoint.globalCheckpoint)__                success = true__            } finally {_                _                _                _                if (success == false) {_                    IOUtils.closeWhileHandlingException(readers)__                }_            }_        } catch (Exception e) {_            _            IOUtils.closeWhileHandlingException(current)__            IOUtils.closeWhileHandlingException(readers)__            throw e__        }_    };creates,a,new,translog,instance,this,method,will,create,a,new,transaction,log,unless,the,given,link,translog,generation,is,code,null,if,the,generation,is,code,null,this,method,is,destructive,and,will,delete,all,files,in,the,translog,path,given,if,the,generation,is,not,code,null,this,method,tries,to,open,the,given,translog,generation,the,generation,is,treated,as,the,last,generation,referenced,from,already,committed,data,this,means,all,operations,that,have,not,yet,been,committed,should,be,in,the,translog,file,referenced,by,this,generation,the,translog,creation,will,fail,if,this,generation,can,t,be,opened,param,config,the,configuration,of,this,translog,param,translog,uuid,the,translog,uuid,to,open,null,for,a,new,translog,param,deletion,policy,an,instance,of,link,translog,deletion,policy,that,controls,when,a,translog,file,can,be,safely,deleted,param,global,checkpoint,supplier,a,supplier,for,the,global,checkpoint,param,primary,term,supplier,a,supplier,for,the,latest,value,of,primary,term,of,the,owning,index,shard,the,latest,term,value,is,examined,and,stored,in,the,header,whenever,a,new,generation,is,rolled,it,s,guaranteed,from,outside,that,a,new,generation,is,rolled,when,the,term,is,increased,this,guarantee,allows,to,us,to,validate,and,reject,operation,whose,term,is,higher,than,the,primary,term,stored,in,the,translog,header;public,translog,final,translog,config,config,final,string,translog,uuid,translog,deletion,policy,deletion,policy,final,long,supplier,global,checkpoint,supplier,final,long,supplier,primary,term,supplier,throws,ioexception,super,config,get,shard,id,config,get,index,settings,this,config,config,this,global,checkpoint,supplier,global,checkpoint,supplier,this,primary,term,supplier,primary,term,supplier,this,deletion,policy,deletion,policy,this,translog,uuid,translog,uuid,big,arrays,config,get,big,arrays,read,write,lock,rwl,new,reentrant,read,write,lock,read,lock,new,releasable,lock,rwl,read,lock,write,lock,new,releasable,lock,rwl,write,lock,this,location,config,get,translog,path,files,create,directories,this,location,try,final,checkpoint,checkpoint,read,checkpoint,location,final,path,next,translog,file,location,resolve,get,filename,checkpoint,generation,1,final,path,current,checkpoint,file,location,resolve,get,commit,checkpoint,file,name,checkpoint,generation,assert,files,exists,next,translog,file,false,files,size,next,translog,file,translog,header,header,size,in,bytes,translog,uuid,unexpected,translog,file,next,translog,file,if,files,exists,current,checkpoint,file,files,delete,if,exists,next,translog,file,logger,warn,deleted,previously,created,but,not,yet,committed,next,generation,this,can,happen,due,to,a,tragic,exception,when,creating,a,new,generation,next,translog,file,get,file,name,this,readers,add,all,recover,from,files,checkpoint,if,readers,is,empty,throw,new,illegal,state,exception,at,least,one,reader,must,be,recovered,boolean,success,false,current,null,try,current,create,writer,checkpoint,generation,1,get,min,file,generation,checkpoint,global,checkpoint,success,true,finally,if,success,false,ioutils,close,while,handling,exception,readers,catch,exception,e,ioutils,close,while,handling,exception,current,ioutils,close,while,handling,exception,readers,throw,e
Translog -> public Translog(         final TranslogConfig config, final String translogUUID, TranslogDeletionPolicy deletionPolicy,         final LongSupplier globalCheckpointSupplier, final LongSupplier primaryTermSupplier) throws IOException;1535046779;Creates a new Translog instance. This method will create a new transaction log unless the given {@link TranslogGeneration} is_{@code null}. If the generation is {@code null} this method is destructive and will delete all files in the translog path given. If_the generation is not {@code null}, this method tries to open the given translog generation. The generation is treated as the last_generation referenced from already committed data. This means all operations that have not yet been committed should be in the_translog file referenced by this generation. The translog creation will fail if this generation can't be opened.__@param config                   the configuration of this translog_@param translogUUID             the translog uuid to open, null for a new translog_@param deletionPolicy           an instance of {@link TranslogDeletionPolicy} that controls when a translog file can be safely_deleted_@param globalCheckpointSupplier a supplier for the global checkpoint_@param primaryTermSupplier      a supplier for the latest value of primary term of the owning index shard. The latest term value is_examined and stored in the header whenever a new generation is rolled. It's guaranteed from outside_that a new generation is rolled when the term is increased. This guarantee allows to us to validate_and reject operation whose term is higher than the primary term stored in the translog header.;public Translog(_        final TranslogConfig config, final String translogUUID, TranslogDeletionPolicy deletionPolicy,_        final LongSupplier globalCheckpointSupplier, final LongSupplier primaryTermSupplier) throws IOException {_        super(config.getShardId(), config.getIndexSettings())__        this.config = config__        this.globalCheckpointSupplier = globalCheckpointSupplier__        this.primaryTermSupplier = primaryTermSupplier__        this.deletionPolicy = deletionPolicy__        this.translogUUID = translogUUID__        bigArrays = config.getBigArrays()__        ReadWriteLock rwl = new ReentrantReadWriteLock()__        readLock = new ReleasableLock(rwl.readLock())__        writeLock = new ReleasableLock(rwl.writeLock())__        this.location = config.getTranslogPath()__        Files.createDirectories(this.location)___        try {_            final Checkpoint checkpoint = readCheckpoint(location)__            final Path nextTranslogFile = location.resolve(getFilename(checkpoint.generation + 1))__            final Path currentCheckpointFile = location.resolve(getCommitCheckpointFileName(checkpoint.generation))__            _            _            _            _            _            _            _            _            assert Files.exists(nextTranslogFile) == false || Files.size(nextTranslogFile) <= TranslogHeader.headerSizeInBytes(translogUUID) : "unexpected translog file: [" + nextTranslogFile + "]"__            if (Files.exists(currentCheckpointFile) _                && Files.deleteIfExists(nextTranslogFile)) { _                logger.warn("deleted previously created, but not yet committed, next generation [{}]. This can happen due to a tragic exception when creating a new generation", nextTranslogFile.getFileName())__            }_            this.readers.addAll(recoverFromFiles(checkpoint))__            if (readers.isEmpty()) {_                throw new IllegalStateException("at least one reader must be recovered")__            }_            boolean success = false__            current = null__            try {_                current = createWriter(checkpoint.generation + 1, getMinFileGeneration(), checkpoint.globalCheckpoint)__                success = true__            } finally {_                _                _                _                if (success == false) {_                    IOUtils.closeWhileHandlingException(readers)__                }_            }_        } catch (Exception e) {_            _            IOUtils.closeWhileHandlingException(current)__            IOUtils.closeWhileHandlingException(readers)__            throw e__        }_    };creates,a,new,translog,instance,this,method,will,create,a,new,transaction,log,unless,the,given,link,translog,generation,is,code,null,if,the,generation,is,code,null,this,method,is,destructive,and,will,delete,all,files,in,the,translog,path,given,if,the,generation,is,not,code,null,this,method,tries,to,open,the,given,translog,generation,the,generation,is,treated,as,the,last,generation,referenced,from,already,committed,data,this,means,all,operations,that,have,not,yet,been,committed,should,be,in,the,translog,file,referenced,by,this,generation,the,translog,creation,will,fail,if,this,generation,can,t,be,opened,param,config,the,configuration,of,this,translog,param,translog,uuid,the,translog,uuid,to,open,null,for,a,new,translog,param,deletion,policy,an,instance,of,link,translog,deletion,policy,that,controls,when,a,translog,file,can,be,safely,deleted,param,global,checkpoint,supplier,a,supplier,for,the,global,checkpoint,param,primary,term,supplier,a,supplier,for,the,latest,value,of,primary,term,of,the,owning,index,shard,the,latest,term,value,is,examined,and,stored,in,the,header,whenever,a,new,generation,is,rolled,it,s,guaranteed,from,outside,that,a,new,generation,is,rolled,when,the,term,is,increased,this,guarantee,allows,to,us,to,validate,and,reject,operation,whose,term,is,higher,than,the,primary,term,stored,in,the,translog,header;public,translog,final,translog,config,config,final,string,translog,uuid,translog,deletion,policy,deletion,policy,final,long,supplier,global,checkpoint,supplier,final,long,supplier,primary,term,supplier,throws,ioexception,super,config,get,shard,id,config,get,index,settings,this,config,config,this,global,checkpoint,supplier,global,checkpoint,supplier,this,primary,term,supplier,primary,term,supplier,this,deletion,policy,deletion,policy,this,translog,uuid,translog,uuid,big,arrays,config,get,big,arrays,read,write,lock,rwl,new,reentrant,read,write,lock,read,lock,new,releasable,lock,rwl,read,lock,write,lock,new,releasable,lock,rwl,write,lock,this,location,config,get,translog,path,files,create,directories,this,location,try,final,checkpoint,checkpoint,read,checkpoint,location,final,path,next,translog,file,location,resolve,get,filename,checkpoint,generation,1,final,path,current,checkpoint,file,location,resolve,get,commit,checkpoint,file,name,checkpoint,generation,assert,files,exists,next,translog,file,false,files,size,next,translog,file,translog,header,header,size,in,bytes,translog,uuid,unexpected,translog,file,next,translog,file,if,files,exists,current,checkpoint,file,files,delete,if,exists,next,translog,file,logger,warn,deleted,previously,created,but,not,yet,committed,next,generation,this,can,happen,due,to,a,tragic,exception,when,creating,a,new,generation,next,translog,file,get,file,name,this,readers,add,all,recover,from,files,checkpoint,if,readers,is,empty,throw,new,illegal,state,exception,at,least,one,reader,must,be,recovered,boolean,success,false,current,null,try,current,create,writer,checkpoint,generation,1,get,min,file,generation,checkpoint,global,checkpoint,success,true,finally,if,success,false,ioutils,close,while,handling,exception,readers,catch,exception,e,ioutils,close,while,handling,exception,current,ioutils,close,while,handling,exception,readers,throw,e
Translog -> public Translog(         final TranslogConfig config, final String translogUUID, TranslogDeletionPolicy deletionPolicy,         final LongSupplier globalCheckpointSupplier, final LongSupplier primaryTermSupplier) throws IOException;1535723122;Creates a new Translog instance. This method will create a new transaction log unless the given {@link TranslogGeneration} is_{@code null}. If the generation is {@code null} this method is destructive and will delete all files in the translog path given. If_the generation is not {@code null}, this method tries to open the given translog generation. The generation is treated as the last_generation referenced from already committed data. This means all operations that have not yet been committed should be in the_translog file referenced by this generation. The translog creation will fail if this generation can't be opened.__@param config                   the configuration of this translog_@param translogUUID             the translog uuid to open, null for a new translog_@param deletionPolicy           an instance of {@link TranslogDeletionPolicy} that controls when a translog file can be safely_deleted_@param globalCheckpointSupplier a supplier for the global checkpoint_@param primaryTermSupplier      a supplier for the latest value of primary term of the owning index shard. The latest term value is_examined and stored in the header whenever a new generation is rolled. It's guaranteed from outside_that a new generation is rolled when the term is increased. This guarantee allows to us to validate_and reject operation whose term is higher than the primary term stored in the translog header.;public Translog(_        final TranslogConfig config, final String translogUUID, TranslogDeletionPolicy deletionPolicy,_        final LongSupplier globalCheckpointSupplier, final LongSupplier primaryTermSupplier) throws IOException {_        super(config.getShardId(), config.getIndexSettings())__        this.config = config__        this.globalCheckpointSupplier = globalCheckpointSupplier__        this.primaryTermSupplier = primaryTermSupplier__        this.deletionPolicy = deletionPolicy__        this.translogUUID = translogUUID__        bigArrays = config.getBigArrays()__        ReadWriteLock rwl = new ReentrantReadWriteLock()__        readLock = new ReleasableLock(rwl.readLock())__        writeLock = new ReleasableLock(rwl.writeLock())__        this.location = config.getTranslogPath()__        Files.createDirectories(this.location)___        try {_            final Checkpoint checkpoint = readCheckpoint(location)__            final Path nextTranslogFile = location.resolve(getFilename(checkpoint.generation + 1))__            final Path currentCheckpointFile = location.resolve(getCommitCheckpointFileName(checkpoint.generation))__            _            _            _            _            _            _            _            _            assert Files.exists(nextTranslogFile) == false || Files.size(nextTranslogFile) <= TranslogHeader.headerSizeInBytes(translogUUID) : "unexpected translog file: [" + nextTranslogFile + "]"__            if (Files.exists(currentCheckpointFile) _                && Files.deleteIfExists(nextTranslogFile)) { _                logger.warn("deleted previously created, but not yet committed, next generation [{}]. This can happen due to a tragic exception when creating a new generation", nextTranslogFile.getFileName())__            }_            this.readers.addAll(recoverFromFiles(checkpoint))__            if (readers.isEmpty()) {_                throw new IllegalStateException("at least one reader must be recovered")__            }_            boolean success = false__            current = null__            try {_                current = createWriter(checkpoint.generation + 1, getMinFileGeneration(), checkpoint.globalCheckpoint)__                success = true__            } finally {_                _                _                _                if (success == false) {_                    IOUtils.closeWhileHandlingException(readers)__                }_            }_        } catch (Exception e) {_            _            IOUtils.closeWhileHandlingException(current)__            IOUtils.closeWhileHandlingException(readers)__            throw e__        }_    };creates,a,new,translog,instance,this,method,will,create,a,new,transaction,log,unless,the,given,link,translog,generation,is,code,null,if,the,generation,is,code,null,this,method,is,destructive,and,will,delete,all,files,in,the,translog,path,given,if,the,generation,is,not,code,null,this,method,tries,to,open,the,given,translog,generation,the,generation,is,treated,as,the,last,generation,referenced,from,already,committed,data,this,means,all,operations,that,have,not,yet,been,committed,should,be,in,the,translog,file,referenced,by,this,generation,the,translog,creation,will,fail,if,this,generation,can,t,be,opened,param,config,the,configuration,of,this,translog,param,translog,uuid,the,translog,uuid,to,open,null,for,a,new,translog,param,deletion,policy,an,instance,of,link,translog,deletion,policy,that,controls,when,a,translog,file,can,be,safely,deleted,param,global,checkpoint,supplier,a,supplier,for,the,global,checkpoint,param,primary,term,supplier,a,supplier,for,the,latest,value,of,primary,term,of,the,owning,index,shard,the,latest,term,value,is,examined,and,stored,in,the,header,whenever,a,new,generation,is,rolled,it,s,guaranteed,from,outside,that,a,new,generation,is,rolled,when,the,term,is,increased,this,guarantee,allows,to,us,to,validate,and,reject,operation,whose,term,is,higher,than,the,primary,term,stored,in,the,translog,header;public,translog,final,translog,config,config,final,string,translog,uuid,translog,deletion,policy,deletion,policy,final,long,supplier,global,checkpoint,supplier,final,long,supplier,primary,term,supplier,throws,ioexception,super,config,get,shard,id,config,get,index,settings,this,config,config,this,global,checkpoint,supplier,global,checkpoint,supplier,this,primary,term,supplier,primary,term,supplier,this,deletion,policy,deletion,policy,this,translog,uuid,translog,uuid,big,arrays,config,get,big,arrays,read,write,lock,rwl,new,reentrant,read,write,lock,read,lock,new,releasable,lock,rwl,read,lock,write,lock,new,releasable,lock,rwl,write,lock,this,location,config,get,translog,path,files,create,directories,this,location,try,final,checkpoint,checkpoint,read,checkpoint,location,final,path,next,translog,file,location,resolve,get,filename,checkpoint,generation,1,final,path,current,checkpoint,file,location,resolve,get,commit,checkpoint,file,name,checkpoint,generation,assert,files,exists,next,translog,file,false,files,size,next,translog,file,translog,header,header,size,in,bytes,translog,uuid,unexpected,translog,file,next,translog,file,if,files,exists,current,checkpoint,file,files,delete,if,exists,next,translog,file,logger,warn,deleted,previously,created,but,not,yet,committed,next,generation,this,can,happen,due,to,a,tragic,exception,when,creating,a,new,generation,next,translog,file,get,file,name,this,readers,add,all,recover,from,files,checkpoint,if,readers,is,empty,throw,new,illegal,state,exception,at,least,one,reader,must,be,recovered,boolean,success,false,current,null,try,current,create,writer,checkpoint,generation,1,get,min,file,generation,checkpoint,global,checkpoint,success,true,finally,if,success,false,ioutils,close,while,handling,exception,readers,catch,exception,e,ioutils,close,while,handling,exception,current,ioutils,close,while,handling,exception,readers,throw,e
Translog -> public Translog(         final TranslogConfig config, final String translogUUID, TranslogDeletionPolicy deletionPolicy,         final LongSupplier globalCheckpointSupplier, final LongSupplier primaryTermSupplier) throws IOException;1537806831;Creates a new Translog instance. This method will create a new transaction log unless the given {@link TranslogGeneration} is_{@code null}. If the generation is {@code null} this method is destructive and will delete all files in the translog path given. If_the generation is not {@code null}, this method tries to open the given translog generation. The generation is treated as the last_generation referenced from already committed data. This means all operations that have not yet been committed should be in the_translog file referenced by this generation. The translog creation will fail if this generation can't be opened.__@param config                   the configuration of this translog_@param translogUUID             the translog uuid to open, null for a new translog_@param deletionPolicy           an instance of {@link TranslogDeletionPolicy} that controls when a translog file can be safely_deleted_@param globalCheckpointSupplier a supplier for the global checkpoint_@param primaryTermSupplier      a supplier for the latest value of primary term of the owning index shard. The latest term value is_examined and stored in the header whenever a new generation is rolled. It's guaranteed from outside_that a new generation is rolled when the term is increased. This guarantee allows to us to validate_and reject operation whose term is higher than the primary term stored in the translog header.;public Translog(_        final TranslogConfig config, final String translogUUID, TranslogDeletionPolicy deletionPolicy,_        final LongSupplier globalCheckpointSupplier, final LongSupplier primaryTermSupplier) throws IOException {_        super(config.getShardId(), config.getIndexSettings())__        this.config = config__        this.globalCheckpointSupplier = globalCheckpointSupplier__        this.primaryTermSupplier = primaryTermSupplier__        this.deletionPolicy = deletionPolicy__        this.translogUUID = translogUUID__        bigArrays = config.getBigArrays()__        ReadWriteLock rwl = new ReentrantReadWriteLock()__        readLock = new ReleasableLock(rwl.readLock())__        writeLock = new ReleasableLock(rwl.writeLock())__        this.location = config.getTranslogPath()__        Files.createDirectories(this.location)___        try {_            final Checkpoint checkpoint = readCheckpoint(location)__            final Path nextTranslogFile = location.resolve(getFilename(checkpoint.generation + 1))__            final Path currentCheckpointFile = location.resolve(getCommitCheckpointFileName(checkpoint.generation))__            _            _            _            _            _            _            _            _            assert Files.exists(nextTranslogFile) == false || Files.size(nextTranslogFile) <= TranslogHeader.headerSizeInBytes(translogUUID) : "unexpected translog file: [" + nextTranslogFile + "]"__            if (Files.exists(currentCheckpointFile) _                && Files.deleteIfExists(nextTranslogFile)) { _                logger.warn("deleted previously created, but not yet committed, next generation [{}]. This can happen due to a tragic exception when creating a new generation", nextTranslogFile.getFileName())__            }_            this.readers.addAll(recoverFromFiles(checkpoint))__            if (readers.isEmpty()) {_                throw new IllegalStateException("at least one reader must be recovered")__            }_            boolean success = false__            current = null__            try {_                current = createWriter(checkpoint.generation + 1, getMinFileGeneration(), checkpoint.globalCheckpoint)__                success = true__            } finally {_                _                _                _                if (success == false) {_                    IOUtils.closeWhileHandlingException(readers)__                }_            }_        } catch (Exception e) {_            _            IOUtils.closeWhileHandlingException(current)__            IOUtils.closeWhileHandlingException(readers)__            throw e__        }_    };creates,a,new,translog,instance,this,method,will,create,a,new,transaction,log,unless,the,given,link,translog,generation,is,code,null,if,the,generation,is,code,null,this,method,is,destructive,and,will,delete,all,files,in,the,translog,path,given,if,the,generation,is,not,code,null,this,method,tries,to,open,the,given,translog,generation,the,generation,is,treated,as,the,last,generation,referenced,from,already,committed,data,this,means,all,operations,that,have,not,yet,been,committed,should,be,in,the,translog,file,referenced,by,this,generation,the,translog,creation,will,fail,if,this,generation,can,t,be,opened,param,config,the,configuration,of,this,translog,param,translog,uuid,the,translog,uuid,to,open,null,for,a,new,translog,param,deletion,policy,an,instance,of,link,translog,deletion,policy,that,controls,when,a,translog,file,can,be,safely,deleted,param,global,checkpoint,supplier,a,supplier,for,the,global,checkpoint,param,primary,term,supplier,a,supplier,for,the,latest,value,of,primary,term,of,the,owning,index,shard,the,latest,term,value,is,examined,and,stored,in,the,header,whenever,a,new,generation,is,rolled,it,s,guaranteed,from,outside,that,a,new,generation,is,rolled,when,the,term,is,increased,this,guarantee,allows,to,us,to,validate,and,reject,operation,whose,term,is,higher,than,the,primary,term,stored,in,the,translog,header;public,translog,final,translog,config,config,final,string,translog,uuid,translog,deletion,policy,deletion,policy,final,long,supplier,global,checkpoint,supplier,final,long,supplier,primary,term,supplier,throws,ioexception,super,config,get,shard,id,config,get,index,settings,this,config,config,this,global,checkpoint,supplier,global,checkpoint,supplier,this,primary,term,supplier,primary,term,supplier,this,deletion,policy,deletion,policy,this,translog,uuid,translog,uuid,big,arrays,config,get,big,arrays,read,write,lock,rwl,new,reentrant,read,write,lock,read,lock,new,releasable,lock,rwl,read,lock,write,lock,new,releasable,lock,rwl,write,lock,this,location,config,get,translog,path,files,create,directories,this,location,try,final,checkpoint,checkpoint,read,checkpoint,location,final,path,next,translog,file,location,resolve,get,filename,checkpoint,generation,1,final,path,current,checkpoint,file,location,resolve,get,commit,checkpoint,file,name,checkpoint,generation,assert,files,exists,next,translog,file,false,files,size,next,translog,file,translog,header,header,size,in,bytes,translog,uuid,unexpected,translog,file,next,translog,file,if,files,exists,current,checkpoint,file,files,delete,if,exists,next,translog,file,logger,warn,deleted,previously,created,but,not,yet,committed,next,generation,this,can,happen,due,to,a,tragic,exception,when,creating,a,new,generation,next,translog,file,get,file,name,this,readers,add,all,recover,from,files,checkpoint,if,readers,is,empty,throw,new,illegal,state,exception,at,least,one,reader,must,be,recovered,boolean,success,false,current,null,try,current,create,writer,checkpoint,generation,1,get,min,file,generation,checkpoint,global,checkpoint,success,true,finally,if,success,false,ioutils,close,while,handling,exception,readers,catch,exception,e,ioutils,close,while,handling,exception,current,ioutils,close,while,handling,exception,readers,throw,e
Translog -> public Translog(         final TranslogConfig config, final String translogUUID, TranslogDeletionPolicy deletionPolicy,         final LongSupplier globalCheckpointSupplier, final LongSupplier primaryTermSupplier) throws IOException;1541592065;Creates a new Translog instance. This method will create a new transaction log unless the given {@link TranslogGeneration} is_{@code null}. If the generation is {@code null} this method is destructive and will delete all files in the translog path given. If_the generation is not {@code null}, this method tries to open the given translog generation. The generation is treated as the last_generation referenced from already committed data. This means all operations that have not yet been committed should be in the_translog file referenced by this generation. The translog creation will fail if this generation can't be opened.__@param config                   the configuration of this translog_@param translogUUID             the translog uuid to open, null for a new translog_@param deletionPolicy           an instance of {@link TranslogDeletionPolicy} that controls when a translog file can be safely_deleted_@param globalCheckpointSupplier a supplier for the global checkpoint_@param primaryTermSupplier      a supplier for the latest value of primary term of the owning index shard. The latest term value is_examined and stored in the header whenever a new generation is rolled. It's guaranteed from outside_that a new generation is rolled when the term is increased. This guarantee allows to us to validate_and reject operation whose term is higher than the primary term stored in the translog header.;public Translog(_        final TranslogConfig config, final String translogUUID, TranslogDeletionPolicy deletionPolicy,_        final LongSupplier globalCheckpointSupplier, final LongSupplier primaryTermSupplier) throws IOException {_        super(config.getShardId(), config.getIndexSettings())__        this.config = config__        this.globalCheckpointSupplier = globalCheckpointSupplier__        this.primaryTermSupplier = primaryTermSupplier__        this.deletionPolicy = deletionPolicy__        this.translogUUID = translogUUID__        bigArrays = config.getBigArrays()__        ReadWriteLock rwl = new ReentrantReadWriteLock()__        readLock = new ReleasableLock(rwl.readLock())__        writeLock = new ReleasableLock(rwl.writeLock())__        this.location = config.getTranslogPath()__        Files.createDirectories(this.location)___        try {_            final Checkpoint checkpoint = readCheckpoint(location)__            final Path nextTranslogFile = location.resolve(getFilename(checkpoint.generation + 1))__            final Path currentCheckpointFile = location.resolve(getCommitCheckpointFileName(checkpoint.generation))__            _            _            _            _            _            _            _            _            assert Files.exists(nextTranslogFile) == false || Files.size(nextTranslogFile) <= TranslogHeader.headerSizeInBytes(translogUUID) : "unexpected translog file: [" + nextTranslogFile + "]"__            if (Files.exists(currentCheckpointFile) _                && Files.deleteIfExists(nextTranslogFile)) { _                logger.warn("deleted previously created, but not yet committed, next generation [{}]. This can happen due to a tragic exception when creating a new generation", nextTranslogFile.getFileName())__            }_            this.readers.addAll(recoverFromFiles(checkpoint))__            if (readers.isEmpty()) {_                throw new IllegalStateException("at least one reader must be recovered")__            }_            boolean success = false__            current = null__            try {_                current = createWriter(checkpoint.generation + 1, getMinFileGeneration(), checkpoint.globalCheckpoint)__                success = true__            } finally {_                _                _                _                if (success == false) {_                    IOUtils.closeWhileHandlingException(readers)__                }_            }_        } catch (Exception e) {_            _            IOUtils.closeWhileHandlingException(current)__            IOUtils.closeWhileHandlingException(readers)__            throw e__        }_    };creates,a,new,translog,instance,this,method,will,create,a,new,transaction,log,unless,the,given,link,translog,generation,is,code,null,if,the,generation,is,code,null,this,method,is,destructive,and,will,delete,all,files,in,the,translog,path,given,if,the,generation,is,not,code,null,this,method,tries,to,open,the,given,translog,generation,the,generation,is,treated,as,the,last,generation,referenced,from,already,committed,data,this,means,all,operations,that,have,not,yet,been,committed,should,be,in,the,translog,file,referenced,by,this,generation,the,translog,creation,will,fail,if,this,generation,can,t,be,opened,param,config,the,configuration,of,this,translog,param,translog,uuid,the,translog,uuid,to,open,null,for,a,new,translog,param,deletion,policy,an,instance,of,link,translog,deletion,policy,that,controls,when,a,translog,file,can,be,safely,deleted,param,global,checkpoint,supplier,a,supplier,for,the,global,checkpoint,param,primary,term,supplier,a,supplier,for,the,latest,value,of,primary,term,of,the,owning,index,shard,the,latest,term,value,is,examined,and,stored,in,the,header,whenever,a,new,generation,is,rolled,it,s,guaranteed,from,outside,that,a,new,generation,is,rolled,when,the,term,is,increased,this,guarantee,allows,to,us,to,validate,and,reject,operation,whose,term,is,higher,than,the,primary,term,stored,in,the,translog,header;public,translog,final,translog,config,config,final,string,translog,uuid,translog,deletion,policy,deletion,policy,final,long,supplier,global,checkpoint,supplier,final,long,supplier,primary,term,supplier,throws,ioexception,super,config,get,shard,id,config,get,index,settings,this,config,config,this,global,checkpoint,supplier,global,checkpoint,supplier,this,primary,term,supplier,primary,term,supplier,this,deletion,policy,deletion,policy,this,translog,uuid,translog,uuid,big,arrays,config,get,big,arrays,read,write,lock,rwl,new,reentrant,read,write,lock,read,lock,new,releasable,lock,rwl,read,lock,write,lock,new,releasable,lock,rwl,write,lock,this,location,config,get,translog,path,files,create,directories,this,location,try,final,checkpoint,checkpoint,read,checkpoint,location,final,path,next,translog,file,location,resolve,get,filename,checkpoint,generation,1,final,path,current,checkpoint,file,location,resolve,get,commit,checkpoint,file,name,checkpoint,generation,assert,files,exists,next,translog,file,false,files,size,next,translog,file,translog,header,header,size,in,bytes,translog,uuid,unexpected,translog,file,next,translog,file,if,files,exists,current,checkpoint,file,files,delete,if,exists,next,translog,file,logger,warn,deleted,previously,created,but,not,yet,committed,next,generation,this,can,happen,due,to,a,tragic,exception,when,creating,a,new,generation,next,translog,file,get,file,name,this,readers,add,all,recover,from,files,checkpoint,if,readers,is,empty,throw,new,illegal,state,exception,at,least,one,reader,must,be,recovered,boolean,success,false,current,null,try,current,create,writer,checkpoint,generation,1,get,min,file,generation,checkpoint,global,checkpoint,success,true,finally,if,success,false,ioutils,close,while,handling,exception,readers,catch,exception,e,ioutils,close,while,handling,exception,current,ioutils,close,while,handling,exception,readers,throw,e
Translog -> public Translog(         final TranslogConfig config, final String translogUUID, TranslogDeletionPolicy deletionPolicy,         final LongSupplier globalCheckpointSupplier, final LongSupplier primaryTermSupplier) throws IOException;1542697754;Creates a new Translog instance. This method will create a new transaction log unless the given {@link TranslogGeneration} is_{@code null}. If the generation is {@code null} this method is destructive and will delete all files in the translog path given. If_the generation is not {@code null}, this method tries to open the given translog generation. The generation is treated as the last_generation referenced from already committed data. This means all operations that have not yet been committed should be in the_translog file referenced by this generation. The translog creation will fail if this generation can't be opened.__@param config                   the configuration of this translog_@param translogUUID             the translog uuid to open, null for a new translog_@param deletionPolicy           an instance of {@link TranslogDeletionPolicy} that controls when a translog file can be safely_deleted_@param globalCheckpointSupplier a supplier for the global checkpoint_@param primaryTermSupplier      a supplier for the latest value of primary term of the owning index shard. The latest term value is_examined and stored in the header whenever a new generation is rolled. It's guaranteed from outside_that a new generation is rolled when the term is increased. This guarantee allows to us to validate_and reject operation whose term is higher than the primary term stored in the translog header.;public Translog(_        final TranslogConfig config, final String translogUUID, TranslogDeletionPolicy deletionPolicy,_        final LongSupplier globalCheckpointSupplier, final LongSupplier primaryTermSupplier) throws IOException {_        super(config.getShardId(), config.getIndexSettings())__        this.config = config__        this.globalCheckpointSupplier = globalCheckpointSupplier__        this.primaryTermSupplier = primaryTermSupplier__        this.deletionPolicy = deletionPolicy__        this.translogUUID = translogUUID__        bigArrays = config.getBigArrays()__        ReadWriteLock rwl = new ReentrantReadWriteLock()__        readLock = new ReleasableLock(rwl.readLock())__        writeLock = new ReleasableLock(rwl.writeLock())__        this.location = config.getTranslogPath()__        Files.createDirectories(this.location)___        try {_            final Checkpoint checkpoint = readCheckpoint(location)__            final Path nextTranslogFile = location.resolve(getFilename(checkpoint.generation + 1))__            final Path currentCheckpointFile = location.resolve(getCommitCheckpointFileName(checkpoint.generation))__            _            _            _            _            _            _            _            _            assert Files.exists(nextTranslogFile) == false ||_                    Files.size(nextTranslogFile) <= TranslogHeader.headerSizeInBytes(translogUUID) :_                        "unexpected translog file: [" + nextTranslogFile + "]"__            if (Files.exists(currentCheckpointFile) _                && Files.deleteIfExists(nextTranslogFile)) { _                logger.warn("deleted previously created, but not yet committed, next generation [{}]. This can happen due to a" +_                    " tragic exception when creating a new generation", nextTranslogFile.getFileName())__            }_            this.readers.addAll(recoverFromFiles(checkpoint))__            if (readers.isEmpty()) {_                throw new IllegalStateException("at least one reader must be recovered")__            }_            boolean success = false__            current = null__            try {_                current = createWriter(checkpoint.generation + 1, getMinFileGeneration(), checkpoint.globalCheckpoint)__                success = true__            } finally {_                _                _                _                if (success == false) {_                    IOUtils.closeWhileHandlingException(readers)__                }_            }_        } catch (Exception e) {_            _            IOUtils.closeWhileHandlingException(current)__            IOUtils.closeWhileHandlingException(readers)__            throw e__        }_    };creates,a,new,translog,instance,this,method,will,create,a,new,transaction,log,unless,the,given,link,translog,generation,is,code,null,if,the,generation,is,code,null,this,method,is,destructive,and,will,delete,all,files,in,the,translog,path,given,if,the,generation,is,not,code,null,this,method,tries,to,open,the,given,translog,generation,the,generation,is,treated,as,the,last,generation,referenced,from,already,committed,data,this,means,all,operations,that,have,not,yet,been,committed,should,be,in,the,translog,file,referenced,by,this,generation,the,translog,creation,will,fail,if,this,generation,can,t,be,opened,param,config,the,configuration,of,this,translog,param,translog,uuid,the,translog,uuid,to,open,null,for,a,new,translog,param,deletion,policy,an,instance,of,link,translog,deletion,policy,that,controls,when,a,translog,file,can,be,safely,deleted,param,global,checkpoint,supplier,a,supplier,for,the,global,checkpoint,param,primary,term,supplier,a,supplier,for,the,latest,value,of,primary,term,of,the,owning,index,shard,the,latest,term,value,is,examined,and,stored,in,the,header,whenever,a,new,generation,is,rolled,it,s,guaranteed,from,outside,that,a,new,generation,is,rolled,when,the,term,is,increased,this,guarantee,allows,to,us,to,validate,and,reject,operation,whose,term,is,higher,than,the,primary,term,stored,in,the,translog,header;public,translog,final,translog,config,config,final,string,translog,uuid,translog,deletion,policy,deletion,policy,final,long,supplier,global,checkpoint,supplier,final,long,supplier,primary,term,supplier,throws,ioexception,super,config,get,shard,id,config,get,index,settings,this,config,config,this,global,checkpoint,supplier,global,checkpoint,supplier,this,primary,term,supplier,primary,term,supplier,this,deletion,policy,deletion,policy,this,translog,uuid,translog,uuid,big,arrays,config,get,big,arrays,read,write,lock,rwl,new,reentrant,read,write,lock,read,lock,new,releasable,lock,rwl,read,lock,write,lock,new,releasable,lock,rwl,write,lock,this,location,config,get,translog,path,files,create,directories,this,location,try,final,checkpoint,checkpoint,read,checkpoint,location,final,path,next,translog,file,location,resolve,get,filename,checkpoint,generation,1,final,path,current,checkpoint,file,location,resolve,get,commit,checkpoint,file,name,checkpoint,generation,assert,files,exists,next,translog,file,false,files,size,next,translog,file,translog,header,header,size,in,bytes,translog,uuid,unexpected,translog,file,next,translog,file,if,files,exists,current,checkpoint,file,files,delete,if,exists,next,translog,file,logger,warn,deleted,previously,created,but,not,yet,committed,next,generation,this,can,happen,due,to,a,tragic,exception,when,creating,a,new,generation,next,translog,file,get,file,name,this,readers,add,all,recover,from,files,checkpoint,if,readers,is,empty,throw,new,illegal,state,exception,at,least,one,reader,must,be,recovered,boolean,success,false,current,null,try,current,create,writer,checkpoint,generation,1,get,min,file,generation,checkpoint,global,checkpoint,success,true,finally,if,success,false,ioutils,close,while,handling,exception,readers,catch,exception,e,ioutils,close,while,handling,exception,current,ioutils,close,while,handling,exception,readers,throw,e
Translog -> public Translog(         final TranslogConfig config, final String translogUUID, TranslogDeletionPolicy deletionPolicy,         final LongSupplier globalCheckpointSupplier, final LongSupplier primaryTermSupplier) throws IOException;1542962614;Creates a new Translog instance. This method will create a new transaction log unless the given {@link TranslogGeneration} is_{@code null}. If the generation is {@code null} this method is destructive and will delete all files in the translog path given. If_the generation is not {@code null}, this method tries to open the given translog generation. The generation is treated as the last_generation referenced from already committed data. This means all operations that have not yet been committed should be in the_translog file referenced by this generation. The translog creation will fail if this generation can't be opened.__@param config                   the configuration of this translog_@param translogUUID             the translog uuid to open, null for a new translog_@param deletionPolicy           an instance of {@link TranslogDeletionPolicy} that controls when a translog file can be safely_deleted_@param globalCheckpointSupplier a supplier for the global checkpoint_@param primaryTermSupplier      a supplier for the latest value of primary term of the owning index shard. The latest term value is_examined and stored in the header whenever a new generation is rolled. It's guaranteed from outside_that a new generation is rolled when the term is increased. This guarantee allows to us to validate_and reject operation whose term is higher than the primary term stored in the translog header.;public Translog(_        final TranslogConfig config, final String translogUUID, TranslogDeletionPolicy deletionPolicy,_        final LongSupplier globalCheckpointSupplier, final LongSupplier primaryTermSupplier) throws IOException {_        super(config.getShardId(), config.getIndexSettings())__        this.config = config__        this.globalCheckpointSupplier = globalCheckpointSupplier__        this.primaryTermSupplier = primaryTermSupplier__        this.deletionPolicy = deletionPolicy__        this.translogUUID = translogUUID__        bigArrays = config.getBigArrays()__        ReadWriteLock rwl = new ReentrantReadWriteLock()__        readLock = new ReleasableLock(rwl.readLock())__        writeLock = new ReleasableLock(rwl.writeLock())__        this.location = config.getTranslogPath()__        Files.createDirectories(this.location)___        try {_            final Checkpoint checkpoint = readCheckpoint(location)__            final Path nextTranslogFile = location.resolve(getFilename(checkpoint.generation + 1))__            final Path currentCheckpointFile = location.resolve(getCommitCheckpointFileName(checkpoint.generation))__            _            _            _            _            _            _            _            _            assert Files.exists(nextTranslogFile) == false ||_                    Files.size(nextTranslogFile) <= TranslogHeader.headerSizeInBytes(translogUUID) :_                        "unexpected translog file: [" + nextTranslogFile + "]"__            if (Files.exists(currentCheckpointFile) _                && Files.deleteIfExists(nextTranslogFile)) { _                logger.warn("deleted previously created, but not yet committed, next generation [{}]. This can happen due to a" +_                    " tragic exception when creating a new generation", nextTranslogFile.getFileName())__            }_            this.readers.addAll(recoverFromFiles(checkpoint))__            if (readers.isEmpty()) {_                throw new IllegalStateException("at least one reader must be recovered")__            }_            boolean success = false__            current = null__            try {_                current = createWriter(checkpoint.generation + 1, getMinFileGeneration(), checkpoint.globalCheckpoint)__                success = true__            } finally {_                _                _                _                if (success == false) {_                    IOUtils.closeWhileHandlingException(readers)__                }_            }_        } catch (Exception e) {_            _            IOUtils.closeWhileHandlingException(current)__            IOUtils.closeWhileHandlingException(readers)__            throw e__        }_    };creates,a,new,translog,instance,this,method,will,create,a,new,transaction,log,unless,the,given,link,translog,generation,is,code,null,if,the,generation,is,code,null,this,method,is,destructive,and,will,delete,all,files,in,the,translog,path,given,if,the,generation,is,not,code,null,this,method,tries,to,open,the,given,translog,generation,the,generation,is,treated,as,the,last,generation,referenced,from,already,committed,data,this,means,all,operations,that,have,not,yet,been,committed,should,be,in,the,translog,file,referenced,by,this,generation,the,translog,creation,will,fail,if,this,generation,can,t,be,opened,param,config,the,configuration,of,this,translog,param,translog,uuid,the,translog,uuid,to,open,null,for,a,new,translog,param,deletion,policy,an,instance,of,link,translog,deletion,policy,that,controls,when,a,translog,file,can,be,safely,deleted,param,global,checkpoint,supplier,a,supplier,for,the,global,checkpoint,param,primary,term,supplier,a,supplier,for,the,latest,value,of,primary,term,of,the,owning,index,shard,the,latest,term,value,is,examined,and,stored,in,the,header,whenever,a,new,generation,is,rolled,it,s,guaranteed,from,outside,that,a,new,generation,is,rolled,when,the,term,is,increased,this,guarantee,allows,to,us,to,validate,and,reject,operation,whose,term,is,higher,than,the,primary,term,stored,in,the,translog,header;public,translog,final,translog,config,config,final,string,translog,uuid,translog,deletion,policy,deletion,policy,final,long,supplier,global,checkpoint,supplier,final,long,supplier,primary,term,supplier,throws,ioexception,super,config,get,shard,id,config,get,index,settings,this,config,config,this,global,checkpoint,supplier,global,checkpoint,supplier,this,primary,term,supplier,primary,term,supplier,this,deletion,policy,deletion,policy,this,translog,uuid,translog,uuid,big,arrays,config,get,big,arrays,read,write,lock,rwl,new,reentrant,read,write,lock,read,lock,new,releasable,lock,rwl,read,lock,write,lock,new,releasable,lock,rwl,write,lock,this,location,config,get,translog,path,files,create,directories,this,location,try,final,checkpoint,checkpoint,read,checkpoint,location,final,path,next,translog,file,location,resolve,get,filename,checkpoint,generation,1,final,path,current,checkpoint,file,location,resolve,get,commit,checkpoint,file,name,checkpoint,generation,assert,files,exists,next,translog,file,false,files,size,next,translog,file,translog,header,header,size,in,bytes,translog,uuid,unexpected,translog,file,next,translog,file,if,files,exists,current,checkpoint,file,files,delete,if,exists,next,translog,file,logger,warn,deleted,previously,created,but,not,yet,committed,next,generation,this,can,happen,due,to,a,tragic,exception,when,creating,a,new,generation,next,translog,file,get,file,name,this,readers,add,all,recover,from,files,checkpoint,if,readers,is,empty,throw,new,illegal,state,exception,at,least,one,reader,must,be,recovered,boolean,success,false,current,null,try,current,create,writer,checkpoint,generation,1,get,min,file,generation,checkpoint,global,checkpoint,success,true,finally,if,success,false,ioutils,close,while,handling,exception,readers,catch,exception,e,ioutils,close,while,handling,exception,current,ioutils,close,while,handling,exception,readers,throw,e
Translog -> public Translog(         final TranslogConfig config, final String translogUUID, TranslogDeletionPolicy deletionPolicy,         final LongSupplier globalCheckpointSupplier, final LongSupplier primaryTermSupplier) throws IOException;1545236365;Creates a new Translog instance. This method will create a new transaction log unless the given {@link TranslogGeneration} is_{@code null}. If the generation is {@code null} this method is destructive and will delete all files in the translog path given. If_the generation is not {@code null}, this method tries to open the given translog generation. The generation is treated as the last_generation referenced from already committed data. This means all operations that have not yet been committed should be in the_translog file referenced by this generation. The translog creation will fail if this generation can't be opened.__@param config                   the configuration of this translog_@param translogUUID             the translog uuid to open, null for a new translog_@param deletionPolicy           an instance of {@link TranslogDeletionPolicy} that controls when a translog file can be safely_deleted_@param globalCheckpointSupplier a supplier for the global checkpoint_@param primaryTermSupplier      a supplier for the latest value of primary term of the owning index shard. The latest term value is_examined and stored in the header whenever a new generation is rolled. It's guaranteed from outside_that a new generation is rolled when the term is increased. This guarantee allows to us to validate_and reject operation whose term is higher than the primary term stored in the translog header.;public Translog(_        final TranslogConfig config, final String translogUUID, TranslogDeletionPolicy deletionPolicy,_        final LongSupplier globalCheckpointSupplier, final LongSupplier primaryTermSupplier) throws IOException {_        super(config.getShardId(), config.getIndexSettings())__        this.config = config__        this.globalCheckpointSupplier = globalCheckpointSupplier__        this.primaryTermSupplier = primaryTermSupplier__        this.deletionPolicy = deletionPolicy__        this.translogUUID = translogUUID__        bigArrays = config.getBigArrays()__        ReadWriteLock rwl = new ReentrantReadWriteLock()__        readLock = new ReleasableLock(rwl.readLock())__        writeLock = new ReleasableLock(rwl.writeLock())__        this.location = config.getTranslogPath()__        Files.createDirectories(this.location)___        try {_            final Checkpoint checkpoint = readCheckpoint(location)__            final Path nextTranslogFile = location.resolve(getFilename(checkpoint.generation + 1))__            final Path currentCheckpointFile = location.resolve(getCommitCheckpointFileName(checkpoint.generation))__            _            _            _            _            _            _            _            _            assert Files.exists(nextTranslogFile) == false ||_                    Files.size(nextTranslogFile) <= TranslogHeader.headerSizeInBytes(translogUUID) :_                        "unexpected translog file: [" + nextTranslogFile + "]"__            if (Files.exists(currentCheckpointFile) _                && Files.deleteIfExists(nextTranslogFile)) { _                logger.warn("deleted previously created, but not yet committed, next generation [{}]. This can happen due to a" +_                    " tragic exception when creating a new generation", nextTranslogFile.getFileName())__            }_            this.readers.addAll(recoverFromFiles(checkpoint))__            if (readers.isEmpty()) {_                throw new IllegalStateException("at least one reader must be recovered")__            }_            boolean success = false__            current = null__            try {_                current = createWriter(checkpoint.generation + 1, getMinFileGeneration(), checkpoint.globalCheckpoint)__                success = true__            } finally {_                _                _                _                if (success == false) {_                    IOUtils.closeWhileHandlingException(readers)__                }_            }_        } catch (Exception e) {_            _            IOUtils.closeWhileHandlingException(current)__            IOUtils.closeWhileHandlingException(readers)__            throw e__        }_    };creates,a,new,translog,instance,this,method,will,create,a,new,transaction,log,unless,the,given,link,translog,generation,is,code,null,if,the,generation,is,code,null,this,method,is,destructive,and,will,delete,all,files,in,the,translog,path,given,if,the,generation,is,not,code,null,this,method,tries,to,open,the,given,translog,generation,the,generation,is,treated,as,the,last,generation,referenced,from,already,committed,data,this,means,all,operations,that,have,not,yet,been,committed,should,be,in,the,translog,file,referenced,by,this,generation,the,translog,creation,will,fail,if,this,generation,can,t,be,opened,param,config,the,configuration,of,this,translog,param,translog,uuid,the,translog,uuid,to,open,null,for,a,new,translog,param,deletion,policy,an,instance,of,link,translog,deletion,policy,that,controls,when,a,translog,file,can,be,safely,deleted,param,global,checkpoint,supplier,a,supplier,for,the,global,checkpoint,param,primary,term,supplier,a,supplier,for,the,latest,value,of,primary,term,of,the,owning,index,shard,the,latest,term,value,is,examined,and,stored,in,the,header,whenever,a,new,generation,is,rolled,it,s,guaranteed,from,outside,that,a,new,generation,is,rolled,when,the,term,is,increased,this,guarantee,allows,to,us,to,validate,and,reject,operation,whose,term,is,higher,than,the,primary,term,stored,in,the,translog,header;public,translog,final,translog,config,config,final,string,translog,uuid,translog,deletion,policy,deletion,policy,final,long,supplier,global,checkpoint,supplier,final,long,supplier,primary,term,supplier,throws,ioexception,super,config,get,shard,id,config,get,index,settings,this,config,config,this,global,checkpoint,supplier,global,checkpoint,supplier,this,primary,term,supplier,primary,term,supplier,this,deletion,policy,deletion,policy,this,translog,uuid,translog,uuid,big,arrays,config,get,big,arrays,read,write,lock,rwl,new,reentrant,read,write,lock,read,lock,new,releasable,lock,rwl,read,lock,write,lock,new,releasable,lock,rwl,write,lock,this,location,config,get,translog,path,files,create,directories,this,location,try,final,checkpoint,checkpoint,read,checkpoint,location,final,path,next,translog,file,location,resolve,get,filename,checkpoint,generation,1,final,path,current,checkpoint,file,location,resolve,get,commit,checkpoint,file,name,checkpoint,generation,assert,files,exists,next,translog,file,false,files,size,next,translog,file,translog,header,header,size,in,bytes,translog,uuid,unexpected,translog,file,next,translog,file,if,files,exists,current,checkpoint,file,files,delete,if,exists,next,translog,file,logger,warn,deleted,previously,created,but,not,yet,committed,next,generation,this,can,happen,due,to,a,tragic,exception,when,creating,a,new,generation,next,translog,file,get,file,name,this,readers,add,all,recover,from,files,checkpoint,if,readers,is,empty,throw,new,illegal,state,exception,at,least,one,reader,must,be,recovered,boolean,success,false,current,null,try,current,create,writer,checkpoint,generation,1,get,min,file,generation,checkpoint,global,checkpoint,success,true,finally,if,success,false,ioutils,close,while,handling,exception,readers,catch,exception,e,ioutils,close,while,handling,exception,current,ioutils,close,while,handling,exception,readers,throw,e
Translog -> public TranslogGeneration getMinGenerationForSeqNo(final long seqNo);1524684173;Gets the minimum generation that could contain any sequence number after the specified sequence number, or the current generation if_there is no generation that could any such sequence number.__@param seqNo the sequence number_@return the minimum generation for the sequence number;public TranslogGeneration getMinGenerationForSeqNo(final long seqNo) {_        try (ReleasableLock ignored = readLock.acquire()) {_            _            long minTranslogFileGeneration = this.currentFileGeneration()__            for (final TranslogReader reader : readers) {_                if (seqNo <= reader.getCheckpoint().maxSeqNo) {_                    minTranslogFileGeneration = Math.min(minTranslogFileGeneration, reader.getGeneration())__                }_            }_            return new TranslogGeneration(translogUUID, minTranslogFileGeneration)__        }_    };gets,the,minimum,generation,that,could,contain,any,sequence,number,after,the,specified,sequence,number,or,the,current,generation,if,there,is,no,generation,that,could,any,such,sequence,number,param,seq,no,the,sequence,number,return,the,minimum,generation,for,the,sequence,number;public,translog,generation,get,min,generation,for,seq,no,final,long,seq,no,try,releasable,lock,ignored,read,lock,acquire,long,min,translog,file,generation,this,current,file,generation,for,final,translog,reader,reader,readers,if,seq,no,reader,get,checkpoint,max,seq,no,min,translog,file,generation,math,min,min,translog,file,generation,reader,get,generation,return,new,translog,generation,translog,uuid,min,translog,file,generation
Translog -> public TranslogGeneration getMinGenerationForSeqNo(final long seqNo);1525334055;Gets the minimum generation that could contain any sequence number after the specified sequence number, or the current generation if_there is no generation that could any such sequence number.__@param seqNo the sequence number_@return the minimum generation for the sequence number;public TranslogGeneration getMinGenerationForSeqNo(final long seqNo) {_        try (ReleasableLock ignored = readLock.acquire()) {_            _            long minTranslogFileGeneration = this.currentFileGeneration()__            for (final TranslogReader reader : readers) {_                if (seqNo <= reader.getCheckpoint().maxSeqNo) {_                    minTranslogFileGeneration = Math.min(minTranslogFileGeneration, reader.getGeneration())__                }_            }_            return new TranslogGeneration(translogUUID, minTranslogFileGeneration)__        }_    };gets,the,minimum,generation,that,could,contain,any,sequence,number,after,the,specified,sequence,number,or,the,current,generation,if,there,is,no,generation,that,could,any,such,sequence,number,param,seq,no,the,sequence,number,return,the,minimum,generation,for,the,sequence,number;public,translog,generation,get,min,generation,for,seq,no,final,long,seq,no,try,releasable,lock,ignored,read,lock,acquire,long,min,translog,file,generation,this,current,file,generation,for,final,translog,reader,reader,readers,if,seq,no,reader,get,checkpoint,max,seq,no,min,translog,file,generation,math,min,min,translog,file,generation,reader,get,generation,return,new,translog,generation,translog,uuid,min,translog,file,generation
Translog -> public TranslogGeneration getMinGenerationForSeqNo(final long seqNo);1528706846;Gets the minimum generation that could contain any sequence number after the specified sequence number, or the current generation if_there is no generation that could any such sequence number.__@param seqNo the sequence number_@return the minimum generation for the sequence number;public TranslogGeneration getMinGenerationForSeqNo(final long seqNo) {_        try (ReleasableLock ignored = readLock.acquire()) {_            _            long minTranslogFileGeneration = this.currentFileGeneration()__            for (final TranslogReader reader : readers) {_                if (seqNo <= reader.getCheckpoint().maxSeqNo) {_                    minTranslogFileGeneration = Math.min(minTranslogFileGeneration, reader.getGeneration())__                }_            }_            return new TranslogGeneration(translogUUID, minTranslogFileGeneration)__        }_    };gets,the,minimum,generation,that,could,contain,any,sequence,number,after,the,specified,sequence,number,or,the,current,generation,if,there,is,no,generation,that,could,any,such,sequence,number,param,seq,no,the,sequence,number,return,the,minimum,generation,for,the,sequence,number;public,translog,generation,get,min,generation,for,seq,no,final,long,seq,no,try,releasable,lock,ignored,read,lock,acquire,long,min,translog,file,generation,this,current,file,generation,for,final,translog,reader,reader,readers,if,seq,no,reader,get,checkpoint,max,seq,no,min,translog,file,generation,math,min,min,translog,file,generation,reader,get,generation,return,new,translog,generation,translog,uuid,min,translog,file,generation
Translog -> public TranslogGeneration getMinGenerationForSeqNo(final long seqNo);1531910483;Gets the minimum generation that could contain any sequence number after the specified sequence number, or the current generation if_there is no generation that could any such sequence number.__@param seqNo the sequence number_@return the minimum generation for the sequence number;public TranslogGeneration getMinGenerationForSeqNo(final long seqNo) {_        try (ReleasableLock ignored = readLock.acquire()) {_            _            long minTranslogFileGeneration = this.currentFileGeneration()__            for (final TranslogReader reader : readers) {_                if (seqNo <= reader.getCheckpoint().maxSeqNo) {_                    minTranslogFileGeneration = Math.min(minTranslogFileGeneration, reader.getGeneration())__                }_            }_            return new TranslogGeneration(translogUUID, minTranslogFileGeneration)__        }_    };gets,the,minimum,generation,that,could,contain,any,sequence,number,after,the,specified,sequence,number,or,the,current,generation,if,there,is,no,generation,that,could,any,such,sequence,number,param,seq,no,the,sequence,number,return,the,minimum,generation,for,the,sequence,number;public,translog,generation,get,min,generation,for,seq,no,final,long,seq,no,try,releasable,lock,ignored,read,lock,acquire,long,min,translog,file,generation,this,current,file,generation,for,final,translog,reader,reader,readers,if,seq,no,reader,get,checkpoint,max,seq,no,min,translog,file,generation,math,min,min,translog,file,generation,reader,get,generation,return,new,translog,generation,translog,uuid,min,translog,file,generation
Translog -> public TranslogGeneration getMinGenerationForSeqNo(final long seqNo);1533295538;Gets the minimum generation that could contain any sequence number after the specified sequence number, or the current generation if_there is no generation that could any such sequence number.__@param seqNo the sequence number_@return the minimum generation for the sequence number;public TranslogGeneration getMinGenerationForSeqNo(final long seqNo) {_        try (ReleasableLock ignored = readLock.acquire()) {_            _            long minTranslogFileGeneration = this.currentFileGeneration()__            for (final TranslogReader reader : readers) {_                if (seqNo <= reader.getCheckpoint().maxSeqNo) {_                    minTranslogFileGeneration = Math.min(minTranslogFileGeneration, reader.getGeneration())__                }_            }_            return new TranslogGeneration(translogUUID, minTranslogFileGeneration)__        }_    };gets,the,minimum,generation,that,could,contain,any,sequence,number,after,the,specified,sequence,number,or,the,current,generation,if,there,is,no,generation,that,could,any,such,sequence,number,param,seq,no,the,sequence,number,return,the,minimum,generation,for,the,sequence,number;public,translog,generation,get,min,generation,for,seq,no,final,long,seq,no,try,releasable,lock,ignored,read,lock,acquire,long,min,translog,file,generation,this,current,file,generation,for,final,translog,reader,reader,readers,if,seq,no,reader,get,checkpoint,max,seq,no,min,translog,file,generation,math,min,min,translog,file,generation,reader,get,generation,return,new,translog,generation,translog,uuid,min,translog,file,generation
Translog -> public TranslogGeneration getMinGenerationForSeqNo(final long seqNo);1533641732;Gets the minimum generation that could contain any sequence number after the specified sequence number, or the current generation if_there is no generation that could any such sequence number.__@param seqNo the sequence number_@return the minimum generation for the sequence number;public TranslogGeneration getMinGenerationForSeqNo(final long seqNo) {_        try (ReleasableLock ignored = readLock.acquire()) {_            _            long minTranslogFileGeneration = this.currentFileGeneration()__            for (final TranslogReader reader : readers) {_                if (seqNo <= reader.getCheckpoint().maxSeqNo) {_                    minTranslogFileGeneration = Math.min(minTranslogFileGeneration, reader.getGeneration())__                }_            }_            return new TranslogGeneration(translogUUID, minTranslogFileGeneration)__        }_    };gets,the,minimum,generation,that,could,contain,any,sequence,number,after,the,specified,sequence,number,or,the,current,generation,if,there,is,no,generation,that,could,any,such,sequence,number,param,seq,no,the,sequence,number,return,the,minimum,generation,for,the,sequence,number;public,translog,generation,get,min,generation,for,seq,no,final,long,seq,no,try,releasable,lock,ignored,read,lock,acquire,long,min,translog,file,generation,this,current,file,generation,for,final,translog,reader,reader,readers,if,seq,no,reader,get,checkpoint,max,seq,no,min,translog,file,generation,math,min,min,translog,file,generation,reader,get,generation,return,new,translog,generation,translog,uuid,min,translog,file,generation
Translog -> public TranslogGeneration getMinGenerationForSeqNo(final long seqNo);1534848846;Gets the minimum generation that could contain any sequence number after the specified sequence number, or the current generation if_there is no generation that could any such sequence number.__@param seqNo the sequence number_@return the minimum generation for the sequence number;public TranslogGeneration getMinGenerationForSeqNo(final long seqNo) {_        try (ReleasableLock ignored = readLock.acquire()) {_            _            long minTranslogFileGeneration = this.currentFileGeneration()__            for (final TranslogReader reader : readers) {_                if (seqNo <= reader.getCheckpoint().maxSeqNo) {_                    minTranslogFileGeneration = Math.min(minTranslogFileGeneration, reader.getGeneration())__                }_            }_            return new TranslogGeneration(translogUUID, minTranslogFileGeneration)__        }_    };gets,the,minimum,generation,that,could,contain,any,sequence,number,after,the,specified,sequence,number,or,the,current,generation,if,there,is,no,generation,that,could,any,such,sequence,number,param,seq,no,the,sequence,number,return,the,minimum,generation,for,the,sequence,number;public,translog,generation,get,min,generation,for,seq,no,final,long,seq,no,try,releasable,lock,ignored,read,lock,acquire,long,min,translog,file,generation,this,current,file,generation,for,final,translog,reader,reader,readers,if,seq,no,reader,get,checkpoint,max,seq,no,min,translog,file,generation,math,min,min,translog,file,generation,reader,get,generation,return,new,translog,generation,translog,uuid,min,translog,file,generation
Translog -> public TranslogGeneration getMinGenerationForSeqNo(final long seqNo);1535046779;Gets the minimum generation that could contain any sequence number after the specified sequence number, or the current generation if_there is no generation that could any such sequence number.__@param seqNo the sequence number_@return the minimum generation for the sequence number;public TranslogGeneration getMinGenerationForSeqNo(final long seqNo) {_        try (ReleasableLock ignored = readLock.acquire()) {_            _            long minTranslogFileGeneration = this.currentFileGeneration()__            for (final TranslogReader reader : readers) {_                if (seqNo <= reader.getCheckpoint().maxSeqNo) {_                    minTranslogFileGeneration = Math.min(minTranslogFileGeneration, reader.getGeneration())__                }_            }_            return new TranslogGeneration(translogUUID, minTranslogFileGeneration)__        }_    };gets,the,minimum,generation,that,could,contain,any,sequence,number,after,the,specified,sequence,number,or,the,current,generation,if,there,is,no,generation,that,could,any,such,sequence,number,param,seq,no,the,sequence,number,return,the,minimum,generation,for,the,sequence,number;public,translog,generation,get,min,generation,for,seq,no,final,long,seq,no,try,releasable,lock,ignored,read,lock,acquire,long,min,translog,file,generation,this,current,file,generation,for,final,translog,reader,reader,readers,if,seq,no,reader,get,checkpoint,max,seq,no,min,translog,file,generation,math,min,min,translog,file,generation,reader,get,generation,return,new,translog,generation,translog,uuid,min,translog,file,generation
Translog -> public TranslogGeneration getMinGenerationForSeqNo(final long seqNo);1535723122;Gets the minimum generation that could contain any sequence number after the specified sequence number, or the current generation if_there is no generation that could any such sequence number.__@param seqNo the sequence number_@return the minimum generation for the sequence number;public TranslogGeneration getMinGenerationForSeqNo(final long seqNo) {_        try (ReleasableLock ignored = readLock.acquire()) {_            _            long minTranslogFileGeneration = this.currentFileGeneration()__            for (final TranslogReader reader : readers) {_                if (seqNo <= reader.getCheckpoint().maxSeqNo) {_                    minTranslogFileGeneration = Math.min(minTranslogFileGeneration, reader.getGeneration())__                }_            }_            return new TranslogGeneration(translogUUID, minTranslogFileGeneration)__        }_    };gets,the,minimum,generation,that,could,contain,any,sequence,number,after,the,specified,sequence,number,or,the,current,generation,if,there,is,no,generation,that,could,any,such,sequence,number,param,seq,no,the,sequence,number,return,the,minimum,generation,for,the,sequence,number;public,translog,generation,get,min,generation,for,seq,no,final,long,seq,no,try,releasable,lock,ignored,read,lock,acquire,long,min,translog,file,generation,this,current,file,generation,for,final,translog,reader,reader,readers,if,seq,no,reader,get,checkpoint,max,seq,no,min,translog,file,generation,math,min,min,translog,file,generation,reader,get,generation,return,new,translog,generation,translog,uuid,min,translog,file,generation
Translog -> public TranslogGeneration getMinGenerationForSeqNo(final long seqNo);1537806831;Gets the minimum generation that could contain any sequence number after the specified sequence number, or the current generation if_there is no generation that could any such sequence number.__@param seqNo the sequence number_@return the minimum generation for the sequence number;public TranslogGeneration getMinGenerationForSeqNo(final long seqNo) {_        try (ReleasableLock ignored = readLock.acquire()) {_            _            long minTranslogFileGeneration = this.currentFileGeneration()__            for (final TranslogReader reader : readers) {_                if (seqNo <= reader.getCheckpoint().maxSeqNo) {_                    minTranslogFileGeneration = Math.min(minTranslogFileGeneration, reader.getGeneration())__                }_            }_            return new TranslogGeneration(translogUUID, minTranslogFileGeneration)__        }_    };gets,the,minimum,generation,that,could,contain,any,sequence,number,after,the,specified,sequence,number,or,the,current,generation,if,there,is,no,generation,that,could,any,such,sequence,number,param,seq,no,the,sequence,number,return,the,minimum,generation,for,the,sequence,number;public,translog,generation,get,min,generation,for,seq,no,final,long,seq,no,try,releasable,lock,ignored,read,lock,acquire,long,min,translog,file,generation,this,current,file,generation,for,final,translog,reader,reader,readers,if,seq,no,reader,get,checkpoint,max,seq,no,min,translog,file,generation,math,min,min,translog,file,generation,reader,get,generation,return,new,translog,generation,translog,uuid,min,translog,file,generation
Translog -> public TranslogGeneration getMinGenerationForSeqNo(final long seqNo);1541592065;Gets the minimum generation that could contain any sequence number after the specified sequence number, or the current generation if_there is no generation that could any such sequence number.__@param seqNo the sequence number_@return the minimum generation for the sequence number;public TranslogGeneration getMinGenerationForSeqNo(final long seqNo) {_        try (ReleasableLock ignored = readLock.acquire()) {_            _            long minTranslogFileGeneration = this.currentFileGeneration()__            for (final TranslogReader reader : readers) {_                if (seqNo <= reader.getCheckpoint().maxSeqNo) {_                    minTranslogFileGeneration = Math.min(minTranslogFileGeneration, reader.getGeneration())__                }_            }_            return new TranslogGeneration(translogUUID, minTranslogFileGeneration)__        }_    };gets,the,minimum,generation,that,could,contain,any,sequence,number,after,the,specified,sequence,number,or,the,current,generation,if,there,is,no,generation,that,could,any,such,sequence,number,param,seq,no,the,sequence,number,return,the,minimum,generation,for,the,sequence,number;public,translog,generation,get,min,generation,for,seq,no,final,long,seq,no,try,releasable,lock,ignored,read,lock,acquire,long,min,translog,file,generation,this,current,file,generation,for,final,translog,reader,reader,readers,if,seq,no,reader,get,checkpoint,max,seq,no,min,translog,file,generation,math,min,min,translog,file,generation,reader,get,generation,return,new,translog,generation,translog,uuid,min,translog,file,generation
Translog -> public TranslogGeneration getMinGenerationForSeqNo(final long seqNo);1542697754;Gets the minimum generation that could contain any sequence number after the specified sequence number, or the current generation if_there is no generation that could any such sequence number.__@param seqNo the sequence number_@return the minimum generation for the sequence number;public TranslogGeneration getMinGenerationForSeqNo(final long seqNo) {_        try (ReleasableLock ignored = readLock.acquire()) {_            _            long minTranslogFileGeneration = this.currentFileGeneration()__            for (final TranslogReader reader : readers) {_                if (seqNo <= reader.getCheckpoint().maxSeqNo) {_                    minTranslogFileGeneration = Math.min(minTranslogFileGeneration, reader.getGeneration())__                }_            }_            return new TranslogGeneration(translogUUID, minTranslogFileGeneration)__        }_    };gets,the,minimum,generation,that,could,contain,any,sequence,number,after,the,specified,sequence,number,or,the,current,generation,if,there,is,no,generation,that,could,any,such,sequence,number,param,seq,no,the,sequence,number,return,the,minimum,generation,for,the,sequence,number;public,translog,generation,get,min,generation,for,seq,no,final,long,seq,no,try,releasable,lock,ignored,read,lock,acquire,long,min,translog,file,generation,this,current,file,generation,for,final,translog,reader,reader,readers,if,seq,no,reader,get,checkpoint,max,seq,no,min,translog,file,generation,math,min,min,translog,file,generation,reader,get,generation,return,new,translog,generation,translog,uuid,min,translog,file,generation
Translog -> public TranslogGeneration getMinGenerationForSeqNo(final long seqNo);1542962614;Gets the minimum generation that could contain any sequence number after the specified sequence number, or the current generation if_there is no generation that could any such sequence number.__@param seqNo the sequence number_@return the minimum generation for the sequence number;public TranslogGeneration getMinGenerationForSeqNo(final long seqNo) {_        try (ReleasableLock ignored = readLock.acquire()) {_            _            long minTranslogFileGeneration = this.currentFileGeneration()__            for (final TranslogReader reader : readers) {_                if (seqNo <= reader.getCheckpoint().maxSeqNo) {_                    minTranslogFileGeneration = Math.min(minTranslogFileGeneration, reader.getGeneration())__                }_            }_            return new TranslogGeneration(translogUUID, minTranslogFileGeneration)__        }_    };gets,the,minimum,generation,that,could,contain,any,sequence,number,after,the,specified,sequence,number,or,the,current,generation,if,there,is,no,generation,that,could,any,such,sequence,number,param,seq,no,the,sequence,number,return,the,minimum,generation,for,the,sequence,number;public,translog,generation,get,min,generation,for,seq,no,final,long,seq,no,try,releasable,lock,ignored,read,lock,acquire,long,min,translog,file,generation,this,current,file,generation,for,final,translog,reader,reader,readers,if,seq,no,reader,get,checkpoint,max,seq,no,min,translog,file,generation,math,min,min,translog,file,generation,reader,get,generation,return,new,translog,generation,translog,uuid,min,translog,file,generation
Translog -> public TranslogGeneration getMinGenerationForSeqNo(final long seqNo);1545236365;Gets the minimum generation that could contain any sequence number after the specified sequence number, or the current generation if_there is no generation that could any such sequence number.__@param seqNo the sequence number_@return the minimum generation for the sequence number;public TranslogGeneration getMinGenerationForSeqNo(final long seqNo) {_        try (ReleasableLock ignored = readLock.acquire()) {_            _            long minTranslogFileGeneration = this.currentFileGeneration()__            for (final TranslogReader reader : readers) {_                if (seqNo <= reader.getCheckpoint().maxSeqNo) {_                    minTranslogFileGeneration = Math.min(minTranslogFileGeneration, reader.getGeneration())__                }_            }_            return new TranslogGeneration(translogUUID, minTranslogFileGeneration)__        }_    };gets,the,minimum,generation,that,could,contain,any,sequence,number,after,the,specified,sequence,number,or,the,current,generation,if,there,is,no,generation,that,could,any,such,sequence,number,param,seq,no,the,sequence,number,return,the,minimum,generation,for,the,sequence,number;public,translog,generation,get,min,generation,for,seq,no,final,long,seq,no,try,releasable,lock,ignored,read,lock,acquire,long,min,translog,file,generation,this,current,file,generation,for,final,translog,reader,reader,readers,if,seq,no,reader,get,checkpoint,max,seq,no,min,translog,file,generation,math,min,min,translog,file,generation,reader,get,generation,return,new,translog,generation,translog,uuid,min,translog,file,generation
Translog -> private void closeOnTragicEvent(final Exception ex);1524684173;Closes the translog if the current translog writer experienced a tragic exception.__Note that in case this thread closes the translog it must not already be holding a read lock on the translog as it will acquire a_write lock in the course of closing the translog__@param ex if an exception occurs closing the translog, it will be suppressed into the provided exception;private void closeOnTragicEvent(final Exception ex) {_        _        assert readLock.isHeldByCurrentThread() == false : Thread.currentThread().getName()__        if (current.getTragicException() != null) {_            try {_                close()__            } catch (final AlreadyClosedException inner) {_                _            } catch (final Exception inner) {_                assert ex != inner.getCause()__                ex.addSuppressed(inner)__            }_        }_    };closes,the,translog,if,the,current,translog,writer,experienced,a,tragic,exception,note,that,in,case,this,thread,closes,the,translog,it,must,not,already,be,holding,a,read,lock,on,the,translog,as,it,will,acquire,a,write,lock,in,the,course,of,closing,the,translog,param,ex,if,an,exception,occurs,closing,the,translog,it,will,be,suppressed,into,the,provided,exception;private,void,close,on,tragic,event,final,exception,ex,assert,read,lock,is,held,by,current,thread,false,thread,current,thread,get,name,if,current,get,tragic,exception,null,try,close,catch,final,already,closed,exception,inner,catch,final,exception,inner,assert,ex,inner,get,cause,ex,add,suppressed,inner
Translog -> private void closeOnTragicEvent(final Exception ex);1525334055;Closes the translog if the current translog writer experienced a tragic exception.__Note that in case this thread closes the translog it must not already be holding a read lock on the translog as it will acquire a_write lock in the course of closing the translog__@param ex if an exception occurs closing the translog, it will be suppressed into the provided exception;private void closeOnTragicEvent(final Exception ex) {_        _        assert readLock.isHeldByCurrentThread() == false : Thread.currentThread().getName()__        if (current.getTragicException() != null) {_            try {_                close()__            } catch (final AlreadyClosedException inner) {_                _            } catch (final Exception inner) {_                assert ex != inner.getCause()__                ex.addSuppressed(inner)__            }_        }_    };closes,the,translog,if,the,current,translog,writer,experienced,a,tragic,exception,note,that,in,case,this,thread,closes,the,translog,it,must,not,already,be,holding,a,read,lock,on,the,translog,as,it,will,acquire,a,write,lock,in,the,course,of,closing,the,translog,param,ex,if,an,exception,occurs,closing,the,translog,it,will,be,suppressed,into,the,provided,exception;private,void,close,on,tragic,event,final,exception,ex,assert,read,lock,is,held,by,current,thread,false,thread,current,thread,get,name,if,current,get,tragic,exception,null,try,close,catch,final,already,closed,exception,inner,catch,final,exception,inner,assert,ex,inner,get,cause,ex,add,suppressed,inner
Translog -> private void closeOnTragicEvent(final Exception ex);1528706846;Closes the translog if the current translog writer experienced a tragic exception.__Note that in case this thread closes the translog it must not already be holding a read lock on the translog as it will acquire a_write lock in the course of closing the translog__@param ex if an exception occurs closing the translog, it will be suppressed into the provided exception;private void closeOnTragicEvent(final Exception ex) {_        _        assert readLock.isHeldByCurrentThread() == false : Thread.currentThread().getName()__        if (current.getTragicException() != null) {_            try {_                close()__            } catch (final AlreadyClosedException inner) {_                _            } catch (final Exception inner) {_                assert ex != inner.getCause()__                ex.addSuppressed(inner)__            }_        }_    };closes,the,translog,if,the,current,translog,writer,experienced,a,tragic,exception,note,that,in,case,this,thread,closes,the,translog,it,must,not,already,be,holding,a,read,lock,on,the,translog,as,it,will,acquire,a,write,lock,in,the,course,of,closing,the,translog,param,ex,if,an,exception,occurs,closing,the,translog,it,will,be,suppressed,into,the,provided,exception;private,void,close,on,tragic,event,final,exception,ex,assert,read,lock,is,held,by,current,thread,false,thread,current,thread,get,name,if,current,get,tragic,exception,null,try,close,catch,final,already,closed,exception,inner,catch,final,exception,inner,assert,ex,inner,get,cause,ex,add,suppressed,inner
Translog -> private void closeOnTragicEvent(final Exception ex);1531910483;Closes the translog if the current translog writer experienced a tragic exception.__Note that in case this thread closes the translog it must not already be holding a read lock on the translog as it will acquire a_write lock in the course of closing the translog__@param ex if an exception occurs closing the translog, it will be suppressed into the provided exception;private void closeOnTragicEvent(final Exception ex) {_        _        assert readLock.isHeldByCurrentThread() == false : Thread.currentThread().getName()__        if (current.getTragicException() != null) {_            try {_                close()__            } catch (final AlreadyClosedException inner) {_                _            } catch (final Exception inner) {_                assert ex != inner.getCause()__                ex.addSuppressed(inner)__            }_        }_    };closes,the,translog,if,the,current,translog,writer,experienced,a,tragic,exception,note,that,in,case,this,thread,closes,the,translog,it,must,not,already,be,holding,a,read,lock,on,the,translog,as,it,will,acquire,a,write,lock,in,the,course,of,closing,the,translog,param,ex,if,an,exception,occurs,closing,the,translog,it,will,be,suppressed,into,the,provided,exception;private,void,close,on,tragic,event,final,exception,ex,assert,read,lock,is,held,by,current,thread,false,thread,current,thread,get,name,if,current,get,tragic,exception,null,try,close,catch,final,already,closed,exception,inner,catch,final,exception,inner,assert,ex,inner,get,cause,ex,add,suppressed,inner
Translog -> private void closeOnTragicEvent(final Exception ex);1533295538;Closes the translog if the current translog writer experienced a tragic exception.__Note that in case this thread closes the translog it must not already be holding a read lock on the translog as it will acquire a_write lock in the course of closing the translog__@param ex if an exception occurs closing the translog, it will be suppressed into the provided exception;private void closeOnTragicEvent(final Exception ex) {_        _        assert readLock.isHeldByCurrentThread() == false : Thread.currentThread().getName()__        if (current.getTragicException() != null) {_            try {_                close()__            } catch (final AlreadyClosedException inner) {_                _            } catch (final Exception inner) {_                assert ex != inner.getCause()__                ex.addSuppressed(inner)__            }_        }_    };closes,the,translog,if,the,current,translog,writer,experienced,a,tragic,exception,note,that,in,case,this,thread,closes,the,translog,it,must,not,already,be,holding,a,read,lock,on,the,translog,as,it,will,acquire,a,write,lock,in,the,course,of,closing,the,translog,param,ex,if,an,exception,occurs,closing,the,translog,it,will,be,suppressed,into,the,provided,exception;private,void,close,on,tragic,event,final,exception,ex,assert,read,lock,is,held,by,current,thread,false,thread,current,thread,get,name,if,current,get,tragic,exception,null,try,close,catch,final,already,closed,exception,inner,catch,final,exception,inner,assert,ex,inner,get,cause,ex,add,suppressed,inner
Translog -> private void closeOnTragicEvent(final Exception ex);1533641732;Closes the translog if the current translog writer experienced a tragic exception.__Note that in case this thread closes the translog it must not already be holding a read lock on the translog as it will acquire a_write lock in the course of closing the translog__@param ex if an exception occurs closing the translog, it will be suppressed into the provided exception;private void closeOnTragicEvent(final Exception ex) {_        _        assert readLock.isHeldByCurrentThread() == false : Thread.currentThread().getName()__        if (current.getTragicException() != null) {_            try {_                close()__            } catch (final AlreadyClosedException inner) {_                _            } catch (final Exception inner) {_                assert ex != inner.getCause()__                ex.addSuppressed(inner)__            }_        }_    };closes,the,translog,if,the,current,translog,writer,experienced,a,tragic,exception,note,that,in,case,this,thread,closes,the,translog,it,must,not,already,be,holding,a,read,lock,on,the,translog,as,it,will,acquire,a,write,lock,in,the,course,of,closing,the,translog,param,ex,if,an,exception,occurs,closing,the,translog,it,will,be,suppressed,into,the,provided,exception;private,void,close,on,tragic,event,final,exception,ex,assert,read,lock,is,held,by,current,thread,false,thread,current,thread,get,name,if,current,get,tragic,exception,null,try,close,catch,final,already,closed,exception,inner,catch,final,exception,inner,assert,ex,inner,get,cause,ex,add,suppressed,inner
Translog -> Snapshot -> Translog.Operation next() throws IOException_;1524684173;Returns the next operation in the snapshot or <code>null</code> if we reached the end.;Translog.Operation next() throws IOException_;returns,the,next,operation,in,the,snapshot,or,code,null,code,if,we,reached,the,end;translog,operation,next,throws,ioexception
Translog -> Snapshot -> Translog.Operation next() throws IOException_;1525334055;Returns the next operation in the snapshot or <code>null</code> if we reached the end.;Translog.Operation next() throws IOException_;returns,the,next,operation,in,the,snapshot,or,code,null,code,if,we,reached,the,end;translog,operation,next,throws,ioexception
Translog -> Snapshot -> Translog.Operation next() throws IOException_;1528706846;Returns the next operation in the snapshot or <code>null</code> if we reached the end.;Translog.Operation next() throws IOException_;returns,the,next,operation,in,the,snapshot,or,code,null,code,if,we,reached,the,end;translog,operation,next,throws,ioexception
Translog -> Snapshot -> Translog.Operation next() throws IOException_;1531910483;Returns the next operation in the snapshot or <code>null</code> if we reached the end.;Translog.Operation next() throws IOException_;returns,the,next,operation,in,the,snapshot,or,code,null,code,if,we,reached,the,end;translog,operation,next,throws,ioexception
Translog -> Snapshot -> Translog.Operation next() throws IOException_;1533295538;Returns the next operation in the snapshot or <code>null</code> if we reached the end.;Translog.Operation next() throws IOException_;returns,the,next,operation,in,the,snapshot,or,code,null,code,if,we,reached,the,end;translog,operation,next,throws,ioexception
Translog -> Snapshot -> Translog.Operation next() throws IOException_;1533641732;Returns the next operation in the snapshot or <code>null</code> if we reached the end.;Translog.Operation next() throws IOException_;returns,the,next,operation,in,the,snapshot,or,code,null,code,if,we,reached,the,end;translog,operation,next,throws,ioexception
Translog -> Snapshot -> Translog.Operation next() throws IOException_;1534848846;Returns the next operation in the snapshot or <code>null</code> if we reached the end.;Translog.Operation next() throws IOException_;returns,the,next,operation,in,the,snapshot,or,code,null,code,if,we,reached,the,end;translog,operation,next,throws,ioexception
Translog -> Snapshot -> Translog.Operation next() throws IOException_;1535046779;Returns the next operation in the snapshot or <code>null</code> if we reached the end.;Translog.Operation next() throws IOException_;returns,the,next,operation,in,the,snapshot,or,code,null,code,if,we,reached,the,end;translog,operation,next,throws,ioexception
Translog -> Snapshot -> Translog.Operation next() throws IOException_;1535723122;Returns the next operation in the snapshot or <code>null</code> if we reached the end.;Translog.Operation next() throws IOException_;returns,the,next,operation,in,the,snapshot,or,code,null,code,if,we,reached,the,end;translog,operation,next,throws,ioexception
Translog -> Snapshot -> Translog.Operation next() throws IOException_;1537806831;Returns the next operation in the snapshot or <code>null</code> if we reached the end.;Translog.Operation next() throws IOException_;returns,the,next,operation,in,the,snapshot,or,code,null,code,if,we,reached,the,end;translog,operation,next,throws,ioexception
Translog -> Snapshot -> Translog.Operation next() throws IOException_;1541592065;Returns the next operation in the snapshot or <code>null</code> if we reached the end.;Translog.Operation next() throws IOException_;returns,the,next,operation,in,the,snapshot,or,code,null,code,if,we,reached,the,end;translog,operation,next,throws,ioexception
Translog -> Snapshot -> Translog.Operation next() throws IOException_;1542697754;Returns the next operation in the snapshot or <code>null</code> if we reached the end.;Translog.Operation next() throws IOException_;returns,the,next,operation,in,the,snapshot,or,code,null,code,if,we,reached,the,end;translog,operation,next,throws,ioexception
Translog -> Snapshot -> Translog.Operation next() throws IOException_;1542962614;Returns the next operation in the snapshot or <code>null</code> if we reached the end.;Translog.Operation next() throws IOException_;returns,the,next,operation,in,the,snapshot,or,code,null,code,if,we,reached,the,end;translog,operation,next,throws,ioexception
Translog -> Snapshot -> Translog.Operation next() throws IOException_;1545236365;Returns the next operation in the snapshot or <code>null</code> if we reached the end.;Translog.Operation next() throws IOException_;returns,the,next,operation,in,the,snapshot,or,code,null,code,if,we,reached,the,end;translog,operation,next,throws,ioexception
Translog -> public static List<Operation> readOperations(StreamInput input) throws IOException;1524684173;Reads a list of operations written with {@link #writeOperations(StreamOutput, List)};public static List<Operation> readOperations(StreamInput input) throws IOException {_        ArrayList<Operation> operations = new ArrayList<>()__        int numOps = input.readInt()__        final BufferedChecksumStreamInput checksumStreamInput = new BufferedChecksumStreamInput(input)__        for (int i = 0_ i < numOps_ i++) {_            operations.add(readOperation(checksumStreamInput))__        }_        return operations__    };reads,a,list,of,operations,written,with,link,write,operations,stream,output,list;public,static,list,operation,read,operations,stream,input,input,throws,ioexception,array,list,operation,operations,new,array,list,int,num,ops,input,read,int,final,buffered,checksum,stream,input,checksum,stream,input,new,buffered,checksum,stream,input,input,for,int,i,0,i,num,ops,i,operations,add,read,operation,checksum,stream,input,return,operations
Translog -> public static List<Operation> readOperations(StreamInput input) throws IOException;1525334055;Reads a list of operations written with {@link #writeOperations(StreamOutput, List)};public static List<Operation> readOperations(StreamInput input) throws IOException {_        ArrayList<Operation> operations = new ArrayList<>()__        int numOps = input.readInt()__        final BufferedChecksumStreamInput checksumStreamInput = new BufferedChecksumStreamInput(input)__        for (int i = 0_ i < numOps_ i++) {_            operations.add(readOperation(checksumStreamInput))__        }_        return operations__    };reads,a,list,of,operations,written,with,link,write,operations,stream,output,list;public,static,list,operation,read,operations,stream,input,input,throws,ioexception,array,list,operation,operations,new,array,list,int,num,ops,input,read,int,final,buffered,checksum,stream,input,checksum,stream,input,new,buffered,checksum,stream,input,input,for,int,i,0,i,num,ops,i,operations,add,read,operation,checksum,stream,input,return,operations
Translog -> public static List<Operation> readOperations(StreamInput input) throws IOException;1528706846;Reads a list of operations written with {@link #writeOperations(StreamOutput, List)};public static List<Operation> readOperations(StreamInput input) throws IOException {_        ArrayList<Operation> operations = new ArrayList<>()__        int numOps = input.readInt()__        final BufferedChecksumStreamInput checksumStreamInput = new BufferedChecksumStreamInput(input)__        for (int i = 0_ i < numOps_ i++) {_            operations.add(readOperation(checksumStreamInput))__        }_        return operations__    };reads,a,list,of,operations,written,with,link,write,operations,stream,output,list;public,static,list,operation,read,operations,stream,input,input,throws,ioexception,array,list,operation,operations,new,array,list,int,num,ops,input,read,int,final,buffered,checksum,stream,input,checksum,stream,input,new,buffered,checksum,stream,input,input,for,int,i,0,i,num,ops,i,operations,add,read,operation,checksum,stream,input,return,operations
Translog -> public static List<Operation> readOperations(StreamInput input) throws IOException;1531910483;Reads a list of operations written with {@link #writeOperations(StreamOutput, List)};public static List<Operation> readOperations(StreamInput input) throws IOException {_        ArrayList<Operation> operations = new ArrayList<>()__        int numOps = input.readInt()__        final BufferedChecksumStreamInput checksumStreamInput = new BufferedChecksumStreamInput(input)__        for (int i = 0_ i < numOps_ i++) {_            operations.add(readOperation(checksumStreamInput))__        }_        return operations__    };reads,a,list,of,operations,written,with,link,write,operations,stream,output,list;public,static,list,operation,read,operations,stream,input,input,throws,ioexception,array,list,operation,operations,new,array,list,int,num,ops,input,read,int,final,buffered,checksum,stream,input,checksum,stream,input,new,buffered,checksum,stream,input,input,for,int,i,0,i,num,ops,i,operations,add,read,operation,checksum,stream,input,return,operations
Translog -> public static List<Operation> readOperations(StreamInput input) throws IOException;1533295538;Reads a list of operations written with {@link #writeOperations(StreamOutput, List)};public static List<Operation> readOperations(StreamInput input) throws IOException {_        ArrayList<Operation> operations = new ArrayList<>()__        int numOps = input.readInt()__        final BufferedChecksumStreamInput checksumStreamInput = new BufferedChecksumStreamInput(input)__        for (int i = 0_ i < numOps_ i++) {_            operations.add(readOperation(checksumStreamInput))__        }_        return operations__    };reads,a,list,of,operations,written,with,link,write,operations,stream,output,list;public,static,list,operation,read,operations,stream,input,input,throws,ioexception,array,list,operation,operations,new,array,list,int,num,ops,input,read,int,final,buffered,checksum,stream,input,checksum,stream,input,new,buffered,checksum,stream,input,input,for,int,i,0,i,num,ops,i,operations,add,read,operation,checksum,stream,input,return,operations
Translog -> private ArrayList<TranslogReader> recoverFromFiles(Checkpoint checkpoint) throws IOException;1524684173;recover all translog files found on disk;private ArrayList<TranslogReader> recoverFromFiles(Checkpoint checkpoint) throws IOException {_        boolean success = false__        ArrayList<TranslogReader> foundTranslogs = new ArrayList<>()__        final Path tempFile = Files.createTempFile(location, TRANSLOG_FILE_PREFIX, TRANSLOG_FILE_SUFFIX)_ _        boolean tempFileRenamed = false__        try (ReleasableLock lock = writeLock.acquire()) {_            logger.debug("open uncommitted translog checkpoint {}", checkpoint)___            final long minGenerationToRecoverFrom__            if (checkpoint.minTranslogGeneration < 0) {_                final Version indexVersionCreated = indexSettings().getIndexVersionCreated()__                assert indexVersionCreated.before(Version.V_6_0_0_beta1) :_                    "no minTranslogGeneration in checkpoint, but index was created with version [" + indexVersionCreated + "]"__                minGenerationToRecoverFrom = deletionPolicy.getMinTranslogGenerationForRecovery()__            } else {_                minGenerationToRecoverFrom = checkpoint.minTranslogGeneration__            }__            final String checkpointTranslogFile = getFilename(checkpoint.generation)__            _            _            _            foundTranslogs.add(openReader(location.resolve(checkpointTranslogFile), checkpoint))__            for (long i = checkpoint.generation - 1_ i >= minGenerationToRecoverFrom_ i--) {_                Path committedTranslogFile = location.resolve(getFilename(i))__                if (Files.exists(committedTranslogFile) == false) {_                    throw new IllegalStateException("translog file doesn't exist with generation: " + i + " recovering from: " +_                        minGenerationToRecoverFrom + " checkpoint: " + checkpoint.generation + " - translog ids must be consecutive")__                }_                final TranslogReader reader = openReader(committedTranslogFile, Checkpoint.read(location.resolve(getCommitCheckpointFileName(i))))__                assert reader.getPrimaryTerm() <= primaryTermSupplier.getAsLong() :_                    "Primary terms go backwards_ current term [" + primaryTermSupplier.getAsLong() + "]" +_                        "translog path [ " + committedTranslogFile + ", existing term [" + reader.getPrimaryTerm() + "]"__                foundTranslogs.add(reader)__                logger.debug("recovered local translog from checkpoint {}", checkpoint)__            }_            Collections.reverse(foundTranslogs)___            _            _            IOUtils.deleteFilesIgnoringExceptions(location.resolve(getFilename(minGenerationToRecoverFrom - 1)),_                location.resolve(getCommitCheckpointFileName(minGenerationToRecoverFrom - 1)))___            Path commitCheckpoint = location.resolve(getCommitCheckpointFileName(checkpoint.generation))__            if (Files.exists(commitCheckpoint)) {_                Checkpoint checkpointFromDisk = Checkpoint.read(commitCheckpoint)__                if (checkpoint.equals(checkpointFromDisk) == false) {_                    throw new IllegalStateException("Checkpoint file " + commitCheckpoint.getFileName() + " already exists but has corrupted content expected: " + checkpoint + " but got: " + checkpointFromDisk)__                }_            } else {_                _                _                Files.copy(location.resolve(CHECKPOINT_FILE_NAME), tempFile, StandardCopyOption.REPLACE_EXISTING)__                IOUtils.fsync(tempFile, false)__                Files.move(tempFile, commitCheckpoint, StandardCopyOption.ATOMIC_MOVE)__                tempFileRenamed = true__                _                IOUtils.fsync(commitCheckpoint.getParent(), true)__            }_            success = true__        } finally {_            if (success == false) {_                IOUtils.closeWhileHandlingException(foundTranslogs)__            }_            if (tempFileRenamed == false) {_                try {_                    Files.delete(tempFile)__                } catch (IOException ex) {_                    logger.warn(() -> new ParameterizedMessage("failed to delete temp file {}", tempFile), ex)__                }_            }_        }_        return foundTranslogs__    };recover,all,translog,files,found,on,disk;private,array,list,translog,reader,recover,from,files,checkpoint,checkpoint,throws,ioexception,boolean,success,false,array,list,translog,reader,found,translogs,new,array,list,final,path,temp,file,files,create,temp,file,location,boolean,temp,file,renamed,false,try,releasable,lock,lock,write,lock,acquire,logger,debug,open,uncommitted,translog,checkpoint,checkpoint,final,long,min,generation,to,recover,from,if,checkpoint,min,translog,generation,0,final,version,index,version,created,index,settings,get,index,version,created,assert,index,version,created,before,version,no,min,translog,generation,in,checkpoint,but,index,was,created,with,version,index,version,created,min,generation,to,recover,from,deletion,policy,get,min,translog,generation,for,recovery,else,min,generation,to,recover,from,checkpoint,min,translog,generation,final,string,checkpoint,translog,file,get,filename,checkpoint,generation,found,translogs,add,open,reader,location,resolve,checkpoint,translog,file,checkpoint,for,long,i,checkpoint,generation,1,i,min,generation,to,recover,from,i,path,committed,translog,file,location,resolve,get,filename,i,if,files,exists,committed,translog,file,false,throw,new,illegal,state,exception,translog,file,doesn,t,exist,with,generation,i,recovering,from,min,generation,to,recover,from,checkpoint,checkpoint,generation,translog,ids,must,be,consecutive,final,translog,reader,reader,open,reader,committed,translog,file,checkpoint,read,location,resolve,get,commit,checkpoint,file,name,i,assert,reader,get,primary,term,primary,term,supplier,get,as,long,primary,terms,go,backwards,current,term,primary,term,supplier,get,as,long,translog,path,committed,translog,file,existing,term,reader,get,primary,term,found,translogs,add,reader,logger,debug,recovered,local,translog,from,checkpoint,checkpoint,collections,reverse,found,translogs,ioutils,delete,files,ignoring,exceptions,location,resolve,get,filename,min,generation,to,recover,from,1,location,resolve,get,commit,checkpoint,file,name,min,generation,to,recover,from,1,path,commit,checkpoint,location,resolve,get,commit,checkpoint,file,name,checkpoint,generation,if,files,exists,commit,checkpoint,checkpoint,checkpoint,from,disk,checkpoint,read,commit,checkpoint,if,checkpoint,equals,checkpoint,from,disk,false,throw,new,illegal,state,exception,checkpoint,file,commit,checkpoint,get,file,name,already,exists,but,has,corrupted,content,expected,checkpoint,but,got,checkpoint,from,disk,else,files,copy,location,resolve,temp,file,standard,copy,option,ioutils,fsync,temp,file,false,files,move,temp,file,commit,checkpoint,standard,copy,option,temp,file,renamed,true,ioutils,fsync,commit,checkpoint,get,parent,true,success,true,finally,if,success,false,ioutils,close,while,handling,exception,found,translogs,if,temp,file,renamed,false,try,files,delete,temp,file,catch,ioexception,ex,logger,warn,new,parameterized,message,failed,to,delete,temp,file,temp,file,ex,return,found,translogs
Translog -> private ArrayList<TranslogReader> recoverFromFiles(Checkpoint checkpoint) throws IOException;1525334055;recover all translog files found on disk;private ArrayList<TranslogReader> recoverFromFiles(Checkpoint checkpoint) throws IOException {_        boolean success = false__        ArrayList<TranslogReader> foundTranslogs = new ArrayList<>()__        final Path tempFile = Files.createTempFile(location, TRANSLOG_FILE_PREFIX, TRANSLOG_FILE_SUFFIX)_ _        boolean tempFileRenamed = false__        try (ReleasableLock lock = writeLock.acquire()) {_            logger.debug("open uncommitted translog checkpoint {}", checkpoint)___            final long minGenerationToRecoverFrom__            if (checkpoint.minTranslogGeneration < 0) {_                final Version indexVersionCreated = indexSettings().getIndexVersionCreated()__                assert indexVersionCreated.before(Version.V_6_0_0_beta1) :_                    "no minTranslogGeneration in checkpoint, but index was created with version [" + indexVersionCreated + "]"__                minGenerationToRecoverFrom = deletionPolicy.getMinTranslogGenerationForRecovery()__            } else {_                minGenerationToRecoverFrom = checkpoint.minTranslogGeneration__            }__            final String checkpointTranslogFile = getFilename(checkpoint.generation)__            _            _            _            foundTranslogs.add(openReader(location.resolve(checkpointTranslogFile), checkpoint))__            for (long i = checkpoint.generation - 1_ i >= minGenerationToRecoverFrom_ i--) {_                Path committedTranslogFile = location.resolve(getFilename(i))__                if (Files.exists(committedTranslogFile) == false) {_                    throw new IllegalStateException("translog file doesn't exist with generation: " + i + " recovering from: " +_                        minGenerationToRecoverFrom + " checkpoint: " + checkpoint.generation + " - translog ids must be consecutive")__                }_                final TranslogReader reader = openReader(committedTranslogFile, Checkpoint.read(location.resolve(getCommitCheckpointFileName(i))))__                assert reader.getPrimaryTerm() <= primaryTermSupplier.getAsLong() :_                    "Primary terms go backwards_ current term [" + primaryTermSupplier.getAsLong() + "]" +_                        "translog path [ " + committedTranslogFile + ", existing term [" + reader.getPrimaryTerm() + "]"__                foundTranslogs.add(reader)__                logger.debug("recovered local translog from checkpoint {}", checkpoint)__            }_            Collections.reverse(foundTranslogs)___            _            _            IOUtils.deleteFilesIgnoringExceptions(location.resolve(getFilename(minGenerationToRecoverFrom - 1)),_                location.resolve(getCommitCheckpointFileName(minGenerationToRecoverFrom - 1)))___            Path commitCheckpoint = location.resolve(getCommitCheckpointFileName(checkpoint.generation))__            if (Files.exists(commitCheckpoint)) {_                Checkpoint checkpointFromDisk = Checkpoint.read(commitCheckpoint)__                if (checkpoint.equals(checkpointFromDisk) == false) {_                    throw new IllegalStateException("Checkpoint file " + commitCheckpoint.getFileName() + " already exists but has corrupted content expected: " + checkpoint + " but got: " + checkpointFromDisk)__                }_            } else {_                _                _                Files.copy(location.resolve(CHECKPOINT_FILE_NAME), tempFile, StandardCopyOption.REPLACE_EXISTING)__                IOUtils.fsync(tempFile, false)__                Files.move(tempFile, commitCheckpoint, StandardCopyOption.ATOMIC_MOVE)__                tempFileRenamed = true__                _                IOUtils.fsync(commitCheckpoint.getParent(), true)__            }_            success = true__        } finally {_            if (success == false) {_                IOUtils.closeWhileHandlingException(foundTranslogs)__            }_            if (tempFileRenamed == false) {_                try {_                    Files.delete(tempFile)__                } catch (IOException ex) {_                    logger.warn(() -> new ParameterizedMessage("failed to delete temp file {}", tempFile), ex)__                }_            }_        }_        return foundTranslogs__    };recover,all,translog,files,found,on,disk;private,array,list,translog,reader,recover,from,files,checkpoint,checkpoint,throws,ioexception,boolean,success,false,array,list,translog,reader,found,translogs,new,array,list,final,path,temp,file,files,create,temp,file,location,boolean,temp,file,renamed,false,try,releasable,lock,lock,write,lock,acquire,logger,debug,open,uncommitted,translog,checkpoint,checkpoint,final,long,min,generation,to,recover,from,if,checkpoint,min,translog,generation,0,final,version,index,version,created,index,settings,get,index,version,created,assert,index,version,created,before,version,no,min,translog,generation,in,checkpoint,but,index,was,created,with,version,index,version,created,min,generation,to,recover,from,deletion,policy,get,min,translog,generation,for,recovery,else,min,generation,to,recover,from,checkpoint,min,translog,generation,final,string,checkpoint,translog,file,get,filename,checkpoint,generation,found,translogs,add,open,reader,location,resolve,checkpoint,translog,file,checkpoint,for,long,i,checkpoint,generation,1,i,min,generation,to,recover,from,i,path,committed,translog,file,location,resolve,get,filename,i,if,files,exists,committed,translog,file,false,throw,new,illegal,state,exception,translog,file,doesn,t,exist,with,generation,i,recovering,from,min,generation,to,recover,from,checkpoint,checkpoint,generation,translog,ids,must,be,consecutive,final,translog,reader,reader,open,reader,committed,translog,file,checkpoint,read,location,resolve,get,commit,checkpoint,file,name,i,assert,reader,get,primary,term,primary,term,supplier,get,as,long,primary,terms,go,backwards,current,term,primary,term,supplier,get,as,long,translog,path,committed,translog,file,existing,term,reader,get,primary,term,found,translogs,add,reader,logger,debug,recovered,local,translog,from,checkpoint,checkpoint,collections,reverse,found,translogs,ioutils,delete,files,ignoring,exceptions,location,resolve,get,filename,min,generation,to,recover,from,1,location,resolve,get,commit,checkpoint,file,name,min,generation,to,recover,from,1,path,commit,checkpoint,location,resolve,get,commit,checkpoint,file,name,checkpoint,generation,if,files,exists,commit,checkpoint,checkpoint,checkpoint,from,disk,checkpoint,read,commit,checkpoint,if,checkpoint,equals,checkpoint,from,disk,false,throw,new,illegal,state,exception,checkpoint,file,commit,checkpoint,get,file,name,already,exists,but,has,corrupted,content,expected,checkpoint,but,got,checkpoint,from,disk,else,files,copy,location,resolve,temp,file,standard,copy,option,ioutils,fsync,temp,file,false,files,move,temp,file,commit,checkpoint,standard,copy,option,temp,file,renamed,true,ioutils,fsync,commit,checkpoint,get,parent,true,success,true,finally,if,success,false,ioutils,close,while,handling,exception,found,translogs,if,temp,file,renamed,false,try,files,delete,temp,file,catch,ioexception,ex,logger,warn,new,parameterized,message,failed,to,delete,temp,file,temp,file,ex,return,found,translogs
Translog -> private ArrayList<TranslogReader> recoverFromFiles(Checkpoint checkpoint) throws IOException;1528706846;recover all translog files found on disk;private ArrayList<TranslogReader> recoverFromFiles(Checkpoint checkpoint) throws IOException {_        boolean success = false__        ArrayList<TranslogReader> foundTranslogs = new ArrayList<>()__        final Path tempFile = Files.createTempFile(location, TRANSLOG_FILE_PREFIX, TRANSLOG_FILE_SUFFIX)_ _        boolean tempFileRenamed = false__        try (ReleasableLock lock = writeLock.acquire()) {_            logger.debug("open uncommitted translog checkpoint {}", checkpoint)___            final long minGenerationToRecoverFrom__            if (checkpoint.minTranslogGeneration < 0) {_                final Version indexVersionCreated = indexSettings().getIndexVersionCreated()__                assert indexVersionCreated.before(Version.V_6_0_0_beta1) :_                    "no minTranslogGeneration in checkpoint, but index was created with version [" + indexVersionCreated + "]"__                minGenerationToRecoverFrom = deletionPolicy.getMinTranslogGenerationForRecovery()__            } else {_                minGenerationToRecoverFrom = checkpoint.minTranslogGeneration__            }__            final String checkpointTranslogFile = getFilename(checkpoint.generation)__            _            _            _            foundTranslogs.add(openReader(location.resolve(checkpointTranslogFile), checkpoint))__            for (long i = checkpoint.generation - 1_ i >= minGenerationToRecoverFrom_ i--) {_                Path committedTranslogFile = location.resolve(getFilename(i))__                if (Files.exists(committedTranslogFile) == false) {_                    throw new IllegalStateException("translog file doesn't exist with generation: " + i + " recovering from: " +_                        minGenerationToRecoverFrom + " checkpoint: " + checkpoint.generation + " - translog ids must be consecutive")__                }_                final TranslogReader reader = openReader(committedTranslogFile, Checkpoint.read(location.resolve(getCommitCheckpointFileName(i))))__                assert reader.getPrimaryTerm() <= primaryTermSupplier.getAsLong() :_                    "Primary terms go backwards_ current term [" + primaryTermSupplier.getAsLong() + "]" +_                        "translog path [ " + committedTranslogFile + ", existing term [" + reader.getPrimaryTerm() + "]"__                foundTranslogs.add(reader)__                logger.debug("recovered local translog from checkpoint {}", checkpoint)__            }_            Collections.reverse(foundTranslogs)___            _            _            IOUtils.deleteFilesIgnoringExceptions(location.resolve(getFilename(minGenerationToRecoverFrom - 1)),_                location.resolve(getCommitCheckpointFileName(minGenerationToRecoverFrom - 1)))___            Path commitCheckpoint = location.resolve(getCommitCheckpointFileName(checkpoint.generation))__            if (Files.exists(commitCheckpoint)) {_                Checkpoint checkpointFromDisk = Checkpoint.read(commitCheckpoint)__                if (checkpoint.equals(checkpointFromDisk) == false) {_                    throw new IllegalStateException("Checkpoint file " + commitCheckpoint.getFileName() + " already exists but has corrupted content expected: " + checkpoint + " but got: " + checkpointFromDisk)__                }_            } else {_                _                _                Files.copy(location.resolve(CHECKPOINT_FILE_NAME), tempFile, StandardCopyOption.REPLACE_EXISTING)__                IOUtils.fsync(tempFile, false)__                Files.move(tempFile, commitCheckpoint, StandardCopyOption.ATOMIC_MOVE)__                tempFileRenamed = true__                _                IOUtils.fsync(commitCheckpoint.getParent(), true)__            }_            success = true__        } finally {_            if (success == false) {_                IOUtils.closeWhileHandlingException(foundTranslogs)__            }_            if (tempFileRenamed == false) {_                try {_                    Files.delete(tempFile)__                } catch (IOException ex) {_                    logger.warn(() -> new ParameterizedMessage("failed to delete temp file {}", tempFile), ex)__                }_            }_        }_        return foundTranslogs__    };recover,all,translog,files,found,on,disk;private,array,list,translog,reader,recover,from,files,checkpoint,checkpoint,throws,ioexception,boolean,success,false,array,list,translog,reader,found,translogs,new,array,list,final,path,temp,file,files,create,temp,file,location,boolean,temp,file,renamed,false,try,releasable,lock,lock,write,lock,acquire,logger,debug,open,uncommitted,translog,checkpoint,checkpoint,final,long,min,generation,to,recover,from,if,checkpoint,min,translog,generation,0,final,version,index,version,created,index,settings,get,index,version,created,assert,index,version,created,before,version,no,min,translog,generation,in,checkpoint,but,index,was,created,with,version,index,version,created,min,generation,to,recover,from,deletion,policy,get,min,translog,generation,for,recovery,else,min,generation,to,recover,from,checkpoint,min,translog,generation,final,string,checkpoint,translog,file,get,filename,checkpoint,generation,found,translogs,add,open,reader,location,resolve,checkpoint,translog,file,checkpoint,for,long,i,checkpoint,generation,1,i,min,generation,to,recover,from,i,path,committed,translog,file,location,resolve,get,filename,i,if,files,exists,committed,translog,file,false,throw,new,illegal,state,exception,translog,file,doesn,t,exist,with,generation,i,recovering,from,min,generation,to,recover,from,checkpoint,checkpoint,generation,translog,ids,must,be,consecutive,final,translog,reader,reader,open,reader,committed,translog,file,checkpoint,read,location,resolve,get,commit,checkpoint,file,name,i,assert,reader,get,primary,term,primary,term,supplier,get,as,long,primary,terms,go,backwards,current,term,primary,term,supplier,get,as,long,translog,path,committed,translog,file,existing,term,reader,get,primary,term,found,translogs,add,reader,logger,debug,recovered,local,translog,from,checkpoint,checkpoint,collections,reverse,found,translogs,ioutils,delete,files,ignoring,exceptions,location,resolve,get,filename,min,generation,to,recover,from,1,location,resolve,get,commit,checkpoint,file,name,min,generation,to,recover,from,1,path,commit,checkpoint,location,resolve,get,commit,checkpoint,file,name,checkpoint,generation,if,files,exists,commit,checkpoint,checkpoint,checkpoint,from,disk,checkpoint,read,commit,checkpoint,if,checkpoint,equals,checkpoint,from,disk,false,throw,new,illegal,state,exception,checkpoint,file,commit,checkpoint,get,file,name,already,exists,but,has,corrupted,content,expected,checkpoint,but,got,checkpoint,from,disk,else,files,copy,location,resolve,temp,file,standard,copy,option,ioutils,fsync,temp,file,false,files,move,temp,file,commit,checkpoint,standard,copy,option,temp,file,renamed,true,ioutils,fsync,commit,checkpoint,get,parent,true,success,true,finally,if,success,false,ioutils,close,while,handling,exception,found,translogs,if,temp,file,renamed,false,try,files,delete,temp,file,catch,ioexception,ex,logger,warn,new,parameterized,message,failed,to,delete,temp,file,temp,file,ex,return,found,translogs
Translog -> private ArrayList<TranslogReader> recoverFromFiles(Checkpoint checkpoint) throws IOException;1531910483;recover all translog files found on disk;private ArrayList<TranslogReader> recoverFromFiles(Checkpoint checkpoint) throws IOException {_        boolean success = false__        ArrayList<TranslogReader> foundTranslogs = new ArrayList<>()__        final Path tempFile = Files.createTempFile(location, TRANSLOG_FILE_PREFIX, TRANSLOG_FILE_SUFFIX)_ _        boolean tempFileRenamed = false__        try (ReleasableLock lock = writeLock.acquire()) {_            logger.debug("open uncommitted translog checkpoint {}", checkpoint)___            final long minGenerationToRecoverFrom__            if (checkpoint.minTranslogGeneration < 0) {_                final Version indexVersionCreated = indexSettings().getIndexVersionCreated()__                assert indexVersionCreated.before(Version.V_6_0_0_beta1) :_                    "no minTranslogGeneration in checkpoint, but index was created with version [" + indexVersionCreated + "]"__                minGenerationToRecoverFrom = deletionPolicy.getMinTranslogGenerationForRecovery()__            } else {_                minGenerationToRecoverFrom = checkpoint.minTranslogGeneration__            }__            final String checkpointTranslogFile = getFilename(checkpoint.generation)__            _            _            _            foundTranslogs.add(openReader(location.resolve(checkpointTranslogFile), checkpoint))__            for (long i = checkpoint.generation - 1_ i >= minGenerationToRecoverFrom_ i--) {_                Path committedTranslogFile = location.resolve(getFilename(i))__                if (Files.exists(committedTranslogFile) == false) {_                    throw new IllegalStateException("translog file doesn't exist with generation: " + i + " recovering from: " +_                        minGenerationToRecoverFrom + " checkpoint: " + checkpoint.generation + " - translog ids must be consecutive")__                }_                final TranslogReader reader = openReader(committedTranslogFile, Checkpoint.read(location.resolve(getCommitCheckpointFileName(i))))__                assert reader.getPrimaryTerm() <= primaryTermSupplier.getAsLong() :_                    "Primary terms go backwards_ current term [" + primaryTermSupplier.getAsLong() + "]" +_                        "translog path [ " + committedTranslogFile + ", existing term [" + reader.getPrimaryTerm() + "]"__                foundTranslogs.add(reader)__                logger.debug("recovered local translog from checkpoint {}", checkpoint)__            }_            Collections.reverse(foundTranslogs)___            _            _            IOUtils.deleteFilesIgnoringExceptions(location.resolve(getFilename(minGenerationToRecoverFrom - 1)),_                location.resolve(getCommitCheckpointFileName(minGenerationToRecoverFrom - 1)))___            Path commitCheckpoint = location.resolve(getCommitCheckpointFileName(checkpoint.generation))__            if (Files.exists(commitCheckpoint)) {_                Checkpoint checkpointFromDisk = Checkpoint.read(commitCheckpoint)__                if (checkpoint.equals(checkpointFromDisk) == false) {_                    throw new IllegalStateException("Checkpoint file " + commitCheckpoint.getFileName() + " already exists but has corrupted content expected: " + checkpoint + " but got: " + checkpointFromDisk)__                }_            } else {_                _                _                Files.copy(location.resolve(CHECKPOINT_FILE_NAME), tempFile, StandardCopyOption.REPLACE_EXISTING)__                IOUtils.fsync(tempFile, false)__                Files.move(tempFile, commitCheckpoint, StandardCopyOption.ATOMIC_MOVE)__                tempFileRenamed = true__                _                IOUtils.fsync(commitCheckpoint.getParent(), true)__            }_            success = true__        } finally {_            if (success == false) {_                IOUtils.closeWhileHandlingException(foundTranslogs)__            }_            if (tempFileRenamed == false) {_                try {_                    Files.delete(tempFile)__                } catch (IOException ex) {_                    logger.warn(() -> new ParameterizedMessage("failed to delete temp file {}", tempFile), ex)__                }_            }_        }_        return foundTranslogs__    };recover,all,translog,files,found,on,disk;private,array,list,translog,reader,recover,from,files,checkpoint,checkpoint,throws,ioexception,boolean,success,false,array,list,translog,reader,found,translogs,new,array,list,final,path,temp,file,files,create,temp,file,location,boolean,temp,file,renamed,false,try,releasable,lock,lock,write,lock,acquire,logger,debug,open,uncommitted,translog,checkpoint,checkpoint,final,long,min,generation,to,recover,from,if,checkpoint,min,translog,generation,0,final,version,index,version,created,index,settings,get,index,version,created,assert,index,version,created,before,version,no,min,translog,generation,in,checkpoint,but,index,was,created,with,version,index,version,created,min,generation,to,recover,from,deletion,policy,get,min,translog,generation,for,recovery,else,min,generation,to,recover,from,checkpoint,min,translog,generation,final,string,checkpoint,translog,file,get,filename,checkpoint,generation,found,translogs,add,open,reader,location,resolve,checkpoint,translog,file,checkpoint,for,long,i,checkpoint,generation,1,i,min,generation,to,recover,from,i,path,committed,translog,file,location,resolve,get,filename,i,if,files,exists,committed,translog,file,false,throw,new,illegal,state,exception,translog,file,doesn,t,exist,with,generation,i,recovering,from,min,generation,to,recover,from,checkpoint,checkpoint,generation,translog,ids,must,be,consecutive,final,translog,reader,reader,open,reader,committed,translog,file,checkpoint,read,location,resolve,get,commit,checkpoint,file,name,i,assert,reader,get,primary,term,primary,term,supplier,get,as,long,primary,terms,go,backwards,current,term,primary,term,supplier,get,as,long,translog,path,committed,translog,file,existing,term,reader,get,primary,term,found,translogs,add,reader,logger,debug,recovered,local,translog,from,checkpoint,checkpoint,collections,reverse,found,translogs,ioutils,delete,files,ignoring,exceptions,location,resolve,get,filename,min,generation,to,recover,from,1,location,resolve,get,commit,checkpoint,file,name,min,generation,to,recover,from,1,path,commit,checkpoint,location,resolve,get,commit,checkpoint,file,name,checkpoint,generation,if,files,exists,commit,checkpoint,checkpoint,checkpoint,from,disk,checkpoint,read,commit,checkpoint,if,checkpoint,equals,checkpoint,from,disk,false,throw,new,illegal,state,exception,checkpoint,file,commit,checkpoint,get,file,name,already,exists,but,has,corrupted,content,expected,checkpoint,but,got,checkpoint,from,disk,else,files,copy,location,resolve,temp,file,standard,copy,option,ioutils,fsync,temp,file,false,files,move,temp,file,commit,checkpoint,standard,copy,option,temp,file,renamed,true,ioutils,fsync,commit,checkpoint,get,parent,true,success,true,finally,if,success,false,ioutils,close,while,handling,exception,found,translogs,if,temp,file,renamed,false,try,files,delete,temp,file,catch,ioexception,ex,logger,warn,new,parameterized,message,failed,to,delete,temp,file,temp,file,ex,return,found,translogs
Translog -> private ArrayList<TranslogReader> recoverFromFiles(Checkpoint checkpoint) throws IOException;1533295538;recover all translog files found on disk;private ArrayList<TranslogReader> recoverFromFiles(Checkpoint checkpoint) throws IOException {_        boolean success = false__        ArrayList<TranslogReader> foundTranslogs = new ArrayList<>()__        final Path tempFile = Files.createTempFile(location, TRANSLOG_FILE_PREFIX, TRANSLOG_FILE_SUFFIX)_ _        boolean tempFileRenamed = false__        try (ReleasableLock lock = writeLock.acquire()) {_            logger.debug("open uncommitted translog checkpoint {}", checkpoint)___            final long minGenerationToRecoverFrom__            if (checkpoint.minTranslogGeneration < 0) {_                final Version indexVersionCreated = indexSettings().getIndexVersionCreated()__                assert indexVersionCreated.before(Version.V_6_0_0_beta1) :_                    "no minTranslogGeneration in checkpoint, but index was created with version [" + indexVersionCreated + "]"__                minGenerationToRecoverFrom = deletionPolicy.getMinTranslogGenerationForRecovery()__            } else {_                minGenerationToRecoverFrom = checkpoint.minTranslogGeneration__            }__            final String checkpointTranslogFile = getFilename(checkpoint.generation)__            _            _            _            foundTranslogs.add(openReader(location.resolve(checkpointTranslogFile), checkpoint))__            for (long i = checkpoint.generation - 1_ i >= minGenerationToRecoverFrom_ i--) {_                Path committedTranslogFile = location.resolve(getFilename(i))__                if (Files.exists(committedTranslogFile) == false) {_                    throw new IllegalStateException("translog file doesn't exist with generation: " + i + " recovering from: " +_                        minGenerationToRecoverFrom + " checkpoint: " + checkpoint.generation + " - translog ids must be consecutive")__                }_                final TranslogReader reader = openReader(committedTranslogFile, Checkpoint.read(location.resolve(getCommitCheckpointFileName(i))))__                assert reader.getPrimaryTerm() <= primaryTermSupplier.getAsLong() :_                    "Primary terms go backwards_ current term [" + primaryTermSupplier.getAsLong() + "]" +_                        "translog path [ " + committedTranslogFile + ", existing term [" + reader.getPrimaryTerm() + "]"__                foundTranslogs.add(reader)__                logger.debug("recovered local translog from checkpoint {}", checkpoint)__            }_            Collections.reverse(foundTranslogs)___            _            _            IOUtils.deleteFilesIgnoringExceptions(location.resolve(getFilename(minGenerationToRecoverFrom - 1)),_                location.resolve(getCommitCheckpointFileName(minGenerationToRecoverFrom - 1)))___            Path commitCheckpoint = location.resolve(getCommitCheckpointFileName(checkpoint.generation))__            if (Files.exists(commitCheckpoint)) {_                Checkpoint checkpointFromDisk = Checkpoint.read(commitCheckpoint)__                if (checkpoint.equals(checkpointFromDisk) == false) {_                    throw new IllegalStateException("Checkpoint file " + commitCheckpoint.getFileName() + " already exists but has corrupted content expected: " + checkpoint + " but got: " + checkpointFromDisk)__                }_            } else {_                _                _                Files.copy(location.resolve(CHECKPOINT_FILE_NAME), tempFile, StandardCopyOption.REPLACE_EXISTING)__                IOUtils.fsync(tempFile, false)__                Files.move(tempFile, commitCheckpoint, StandardCopyOption.ATOMIC_MOVE)__                tempFileRenamed = true__                _                IOUtils.fsync(commitCheckpoint.getParent(), true)__            }_            success = true__        } finally {_            if (success == false) {_                IOUtils.closeWhileHandlingException(foundTranslogs)__            }_            if (tempFileRenamed == false) {_                try {_                    Files.delete(tempFile)__                } catch (IOException ex) {_                    logger.warn(() -> new ParameterizedMessage("failed to delete temp file {}", tempFile), ex)__                }_            }_        }_        return foundTranslogs__    };recover,all,translog,files,found,on,disk;private,array,list,translog,reader,recover,from,files,checkpoint,checkpoint,throws,ioexception,boolean,success,false,array,list,translog,reader,found,translogs,new,array,list,final,path,temp,file,files,create,temp,file,location,boolean,temp,file,renamed,false,try,releasable,lock,lock,write,lock,acquire,logger,debug,open,uncommitted,translog,checkpoint,checkpoint,final,long,min,generation,to,recover,from,if,checkpoint,min,translog,generation,0,final,version,index,version,created,index,settings,get,index,version,created,assert,index,version,created,before,version,no,min,translog,generation,in,checkpoint,but,index,was,created,with,version,index,version,created,min,generation,to,recover,from,deletion,policy,get,min,translog,generation,for,recovery,else,min,generation,to,recover,from,checkpoint,min,translog,generation,final,string,checkpoint,translog,file,get,filename,checkpoint,generation,found,translogs,add,open,reader,location,resolve,checkpoint,translog,file,checkpoint,for,long,i,checkpoint,generation,1,i,min,generation,to,recover,from,i,path,committed,translog,file,location,resolve,get,filename,i,if,files,exists,committed,translog,file,false,throw,new,illegal,state,exception,translog,file,doesn,t,exist,with,generation,i,recovering,from,min,generation,to,recover,from,checkpoint,checkpoint,generation,translog,ids,must,be,consecutive,final,translog,reader,reader,open,reader,committed,translog,file,checkpoint,read,location,resolve,get,commit,checkpoint,file,name,i,assert,reader,get,primary,term,primary,term,supplier,get,as,long,primary,terms,go,backwards,current,term,primary,term,supplier,get,as,long,translog,path,committed,translog,file,existing,term,reader,get,primary,term,found,translogs,add,reader,logger,debug,recovered,local,translog,from,checkpoint,checkpoint,collections,reverse,found,translogs,ioutils,delete,files,ignoring,exceptions,location,resolve,get,filename,min,generation,to,recover,from,1,location,resolve,get,commit,checkpoint,file,name,min,generation,to,recover,from,1,path,commit,checkpoint,location,resolve,get,commit,checkpoint,file,name,checkpoint,generation,if,files,exists,commit,checkpoint,checkpoint,checkpoint,from,disk,checkpoint,read,commit,checkpoint,if,checkpoint,equals,checkpoint,from,disk,false,throw,new,illegal,state,exception,checkpoint,file,commit,checkpoint,get,file,name,already,exists,but,has,corrupted,content,expected,checkpoint,but,got,checkpoint,from,disk,else,files,copy,location,resolve,temp,file,standard,copy,option,ioutils,fsync,temp,file,false,files,move,temp,file,commit,checkpoint,standard,copy,option,temp,file,renamed,true,ioutils,fsync,commit,checkpoint,get,parent,true,success,true,finally,if,success,false,ioutils,close,while,handling,exception,found,translogs,if,temp,file,renamed,false,try,files,delete,temp,file,catch,ioexception,ex,logger,warn,new,parameterized,message,failed,to,delete,temp,file,temp,file,ex,return,found,translogs
Translog -> private ArrayList<TranslogReader> recoverFromFiles(Checkpoint checkpoint) throws IOException;1533641732;recover all translog files found on disk;private ArrayList<TranslogReader> recoverFromFiles(Checkpoint checkpoint) throws IOException {_        boolean success = false__        ArrayList<TranslogReader> foundTranslogs = new ArrayList<>()__        final Path tempFile = Files.createTempFile(location, TRANSLOG_FILE_PREFIX, TRANSLOG_FILE_SUFFIX)_ _        boolean tempFileRenamed = false__        try (ReleasableLock lock = writeLock.acquire()) {_            logger.debug("open uncommitted translog checkpoint {}", checkpoint)___            final long minGenerationToRecoverFrom__            if (checkpoint.minTranslogGeneration < 0) {_                final Version indexVersionCreated = indexSettings().getIndexVersionCreated()__                assert indexVersionCreated.before(Version.V_6_0_0_beta1) :_                    "no minTranslogGeneration in checkpoint, but index was created with version [" + indexVersionCreated + "]"__                minGenerationToRecoverFrom = deletionPolicy.getMinTranslogGenerationForRecovery()__            } else {_                minGenerationToRecoverFrom = checkpoint.minTranslogGeneration__            }__            final String checkpointTranslogFile = getFilename(checkpoint.generation)__            _            _            _            foundTranslogs.add(openReader(location.resolve(checkpointTranslogFile), checkpoint))__            for (long i = checkpoint.generation - 1_ i >= minGenerationToRecoverFrom_ i--) {_                Path committedTranslogFile = location.resolve(getFilename(i))__                if (Files.exists(committedTranslogFile) == false) {_                    throw new IllegalStateException("translog file doesn't exist with generation: " + i + " recovering from: " +_                        minGenerationToRecoverFrom + " checkpoint: " + checkpoint.generation + " - translog ids must be consecutive")__                }_                final TranslogReader reader = openReader(committedTranslogFile, Checkpoint.read(location.resolve(getCommitCheckpointFileName(i))))__                assert reader.getPrimaryTerm() <= primaryTermSupplier.getAsLong() :_                    "Primary terms go backwards_ current term [" + primaryTermSupplier.getAsLong() + "]" +_                        "translog path [ " + committedTranslogFile + ", existing term [" + reader.getPrimaryTerm() + "]"__                foundTranslogs.add(reader)__                logger.debug("recovered local translog from checkpoint {}", checkpoint)__            }_            Collections.reverse(foundTranslogs)___            _            _            IOUtils.deleteFilesIgnoringExceptions(location.resolve(getFilename(minGenerationToRecoverFrom - 1)),_                location.resolve(getCommitCheckpointFileName(minGenerationToRecoverFrom - 1)))___            Path commitCheckpoint = location.resolve(getCommitCheckpointFileName(checkpoint.generation))__            if (Files.exists(commitCheckpoint)) {_                Checkpoint checkpointFromDisk = Checkpoint.read(commitCheckpoint)__                if (checkpoint.equals(checkpointFromDisk) == false) {_                    throw new IllegalStateException("Checkpoint file " + commitCheckpoint.getFileName() + " already exists but has corrupted content expected: " + checkpoint + " but got: " + checkpointFromDisk)__                }_            } else {_                _                _                Files.copy(location.resolve(CHECKPOINT_FILE_NAME), tempFile, StandardCopyOption.REPLACE_EXISTING)__                IOUtils.fsync(tempFile, false)__                Files.move(tempFile, commitCheckpoint, StandardCopyOption.ATOMIC_MOVE)__                tempFileRenamed = true__                _                IOUtils.fsync(commitCheckpoint.getParent(), true)__            }_            success = true__        } finally {_            if (success == false) {_                IOUtils.closeWhileHandlingException(foundTranslogs)__            }_            if (tempFileRenamed == false) {_                try {_                    Files.delete(tempFile)__                } catch (IOException ex) {_                    logger.warn(() -> new ParameterizedMessage("failed to delete temp file {}", tempFile), ex)__                }_            }_        }_        return foundTranslogs__    };recover,all,translog,files,found,on,disk;private,array,list,translog,reader,recover,from,files,checkpoint,checkpoint,throws,ioexception,boolean,success,false,array,list,translog,reader,found,translogs,new,array,list,final,path,temp,file,files,create,temp,file,location,boolean,temp,file,renamed,false,try,releasable,lock,lock,write,lock,acquire,logger,debug,open,uncommitted,translog,checkpoint,checkpoint,final,long,min,generation,to,recover,from,if,checkpoint,min,translog,generation,0,final,version,index,version,created,index,settings,get,index,version,created,assert,index,version,created,before,version,no,min,translog,generation,in,checkpoint,but,index,was,created,with,version,index,version,created,min,generation,to,recover,from,deletion,policy,get,min,translog,generation,for,recovery,else,min,generation,to,recover,from,checkpoint,min,translog,generation,final,string,checkpoint,translog,file,get,filename,checkpoint,generation,found,translogs,add,open,reader,location,resolve,checkpoint,translog,file,checkpoint,for,long,i,checkpoint,generation,1,i,min,generation,to,recover,from,i,path,committed,translog,file,location,resolve,get,filename,i,if,files,exists,committed,translog,file,false,throw,new,illegal,state,exception,translog,file,doesn,t,exist,with,generation,i,recovering,from,min,generation,to,recover,from,checkpoint,checkpoint,generation,translog,ids,must,be,consecutive,final,translog,reader,reader,open,reader,committed,translog,file,checkpoint,read,location,resolve,get,commit,checkpoint,file,name,i,assert,reader,get,primary,term,primary,term,supplier,get,as,long,primary,terms,go,backwards,current,term,primary,term,supplier,get,as,long,translog,path,committed,translog,file,existing,term,reader,get,primary,term,found,translogs,add,reader,logger,debug,recovered,local,translog,from,checkpoint,checkpoint,collections,reverse,found,translogs,ioutils,delete,files,ignoring,exceptions,location,resolve,get,filename,min,generation,to,recover,from,1,location,resolve,get,commit,checkpoint,file,name,min,generation,to,recover,from,1,path,commit,checkpoint,location,resolve,get,commit,checkpoint,file,name,checkpoint,generation,if,files,exists,commit,checkpoint,checkpoint,checkpoint,from,disk,checkpoint,read,commit,checkpoint,if,checkpoint,equals,checkpoint,from,disk,false,throw,new,illegal,state,exception,checkpoint,file,commit,checkpoint,get,file,name,already,exists,but,has,corrupted,content,expected,checkpoint,but,got,checkpoint,from,disk,else,files,copy,location,resolve,temp,file,standard,copy,option,ioutils,fsync,temp,file,false,files,move,temp,file,commit,checkpoint,standard,copy,option,temp,file,renamed,true,ioutils,fsync,commit,checkpoint,get,parent,true,success,true,finally,if,success,false,ioutils,close,while,handling,exception,found,translogs,if,temp,file,renamed,false,try,files,delete,temp,file,catch,ioexception,ex,logger,warn,new,parameterized,message,failed,to,delete,temp,file,temp,file,ex,return,found,translogs
Translog -> private ArrayList<TranslogReader> recoverFromFiles(Checkpoint checkpoint) throws IOException;1534848846;recover all translog files found on disk;private ArrayList<TranslogReader> recoverFromFiles(Checkpoint checkpoint) throws IOException {_        boolean success = false__        ArrayList<TranslogReader> foundTranslogs = new ArrayList<>()__        final Path tempFile = Files.createTempFile(location, TRANSLOG_FILE_PREFIX, TRANSLOG_FILE_SUFFIX)_ _        boolean tempFileRenamed = false__        try (ReleasableLock lock = writeLock.acquire()) {_            logger.debug("open uncommitted translog checkpoint {}", checkpoint)___            final long minGenerationToRecoverFrom__            if (checkpoint.minTranslogGeneration < 0) {_                final Version indexVersionCreated = indexSettings().getIndexVersionCreated()__                assert indexVersionCreated.before(Version.V_6_0_0_beta1) :_                    "no minTranslogGeneration in checkpoint, but index was created with version [" + indexVersionCreated + "]"__                minGenerationToRecoverFrom = deletionPolicy.getMinTranslogGenerationForRecovery()__            } else {_                minGenerationToRecoverFrom = checkpoint.minTranslogGeneration__            }__            final String checkpointTranslogFile = getFilename(checkpoint.generation)__            _            _            _            foundTranslogs.add(openReader(location.resolve(checkpointTranslogFile), checkpoint))__            for (long i = checkpoint.generation - 1_ i >= minGenerationToRecoverFrom_ i--) {_                Path committedTranslogFile = location.resolve(getFilename(i))__                if (Files.exists(committedTranslogFile) == false) {_                    throw new IllegalStateException("translog file doesn't exist with generation: " + i + " recovering from: " +_                        minGenerationToRecoverFrom + " checkpoint: " + checkpoint.generation + " - translog ids must be consecutive")__                }_                final TranslogReader reader = openReader(committedTranslogFile, Checkpoint.read(location.resolve(getCommitCheckpointFileName(i))))__                assert reader.getPrimaryTerm() <= primaryTermSupplier.getAsLong() :_                    "Primary terms go backwards_ current term [" + primaryTermSupplier.getAsLong() + "]" +_                        "translog path [ " + committedTranslogFile + ", existing term [" + reader.getPrimaryTerm() + "]"__                foundTranslogs.add(reader)__                logger.debug("recovered local translog from checkpoint {}", checkpoint)__            }_            Collections.reverse(foundTranslogs)___            _            _            IOUtils.deleteFilesIgnoringExceptions(location.resolve(getFilename(minGenerationToRecoverFrom - 1)),_                location.resolve(getCommitCheckpointFileName(minGenerationToRecoverFrom - 1)))___            Path commitCheckpoint = location.resolve(getCommitCheckpointFileName(checkpoint.generation))__            if (Files.exists(commitCheckpoint)) {_                Checkpoint checkpointFromDisk = Checkpoint.read(commitCheckpoint)__                if (checkpoint.equals(checkpointFromDisk) == false) {_                    throw new IllegalStateException("Checkpoint file " + commitCheckpoint.getFileName() + " already exists but has corrupted content expected: " + checkpoint + " but got: " + checkpointFromDisk)__                }_            } else {_                _                _                Files.copy(location.resolve(CHECKPOINT_FILE_NAME), tempFile, StandardCopyOption.REPLACE_EXISTING)__                IOUtils.fsync(tempFile, false)__                Files.move(tempFile, commitCheckpoint, StandardCopyOption.ATOMIC_MOVE)__                tempFileRenamed = true__                _                IOUtils.fsync(commitCheckpoint.getParent(), true)__            }_            success = true__        } finally {_            if (success == false) {_                IOUtils.closeWhileHandlingException(foundTranslogs)__            }_            if (tempFileRenamed == false) {_                try {_                    Files.delete(tempFile)__                } catch (IOException ex) {_                    logger.warn(() -> new ParameterizedMessage("failed to delete temp file {}", tempFile), ex)__                }_            }_        }_        return foundTranslogs__    };recover,all,translog,files,found,on,disk;private,array,list,translog,reader,recover,from,files,checkpoint,checkpoint,throws,ioexception,boolean,success,false,array,list,translog,reader,found,translogs,new,array,list,final,path,temp,file,files,create,temp,file,location,boolean,temp,file,renamed,false,try,releasable,lock,lock,write,lock,acquire,logger,debug,open,uncommitted,translog,checkpoint,checkpoint,final,long,min,generation,to,recover,from,if,checkpoint,min,translog,generation,0,final,version,index,version,created,index,settings,get,index,version,created,assert,index,version,created,before,version,no,min,translog,generation,in,checkpoint,but,index,was,created,with,version,index,version,created,min,generation,to,recover,from,deletion,policy,get,min,translog,generation,for,recovery,else,min,generation,to,recover,from,checkpoint,min,translog,generation,final,string,checkpoint,translog,file,get,filename,checkpoint,generation,found,translogs,add,open,reader,location,resolve,checkpoint,translog,file,checkpoint,for,long,i,checkpoint,generation,1,i,min,generation,to,recover,from,i,path,committed,translog,file,location,resolve,get,filename,i,if,files,exists,committed,translog,file,false,throw,new,illegal,state,exception,translog,file,doesn,t,exist,with,generation,i,recovering,from,min,generation,to,recover,from,checkpoint,checkpoint,generation,translog,ids,must,be,consecutive,final,translog,reader,reader,open,reader,committed,translog,file,checkpoint,read,location,resolve,get,commit,checkpoint,file,name,i,assert,reader,get,primary,term,primary,term,supplier,get,as,long,primary,terms,go,backwards,current,term,primary,term,supplier,get,as,long,translog,path,committed,translog,file,existing,term,reader,get,primary,term,found,translogs,add,reader,logger,debug,recovered,local,translog,from,checkpoint,checkpoint,collections,reverse,found,translogs,ioutils,delete,files,ignoring,exceptions,location,resolve,get,filename,min,generation,to,recover,from,1,location,resolve,get,commit,checkpoint,file,name,min,generation,to,recover,from,1,path,commit,checkpoint,location,resolve,get,commit,checkpoint,file,name,checkpoint,generation,if,files,exists,commit,checkpoint,checkpoint,checkpoint,from,disk,checkpoint,read,commit,checkpoint,if,checkpoint,equals,checkpoint,from,disk,false,throw,new,illegal,state,exception,checkpoint,file,commit,checkpoint,get,file,name,already,exists,but,has,corrupted,content,expected,checkpoint,but,got,checkpoint,from,disk,else,files,copy,location,resolve,temp,file,standard,copy,option,ioutils,fsync,temp,file,false,files,move,temp,file,commit,checkpoint,standard,copy,option,temp,file,renamed,true,ioutils,fsync,commit,checkpoint,get,parent,true,success,true,finally,if,success,false,ioutils,close,while,handling,exception,found,translogs,if,temp,file,renamed,false,try,files,delete,temp,file,catch,ioexception,ex,logger,warn,new,parameterized,message,failed,to,delete,temp,file,temp,file,ex,return,found,translogs
Translog -> private ArrayList<TranslogReader> recoverFromFiles(Checkpoint checkpoint) throws IOException;1535046779;recover all translog files found on disk;private ArrayList<TranslogReader> recoverFromFiles(Checkpoint checkpoint) throws IOException {_        boolean success = false__        ArrayList<TranslogReader> foundTranslogs = new ArrayList<>()__        final Path tempFile = Files.createTempFile(location, TRANSLOG_FILE_PREFIX, TRANSLOG_FILE_SUFFIX)_ _        boolean tempFileRenamed = false__        try (ReleasableLock lock = writeLock.acquire()) {_            logger.debug("open uncommitted translog checkpoint {}", checkpoint)___            final long minGenerationToRecoverFrom__            if (checkpoint.minTranslogGeneration < 0) {_                final Version indexVersionCreated = indexSettings().getIndexVersionCreated()__                assert indexVersionCreated.before(Version.V_6_0_0_beta1) :_                    "no minTranslogGeneration in checkpoint, but index was created with version [" + indexVersionCreated + "]"__                minGenerationToRecoverFrom = deletionPolicy.getMinTranslogGenerationForRecovery()__            } else {_                minGenerationToRecoverFrom = checkpoint.minTranslogGeneration__            }__            final String checkpointTranslogFile = getFilename(checkpoint.generation)__            _            _            _            foundTranslogs.add(openReader(location.resolve(checkpointTranslogFile), checkpoint))__            for (long i = checkpoint.generation - 1_ i >= minGenerationToRecoverFrom_ i--) {_                Path committedTranslogFile = location.resolve(getFilename(i))__                if (Files.exists(committedTranslogFile) == false) {_                    throw new IllegalStateException("translog file doesn't exist with generation: " + i + " recovering from: " +_                        minGenerationToRecoverFrom + " checkpoint: " + checkpoint.generation + " - translog ids must be consecutive")__                }_                final TranslogReader reader = openReader(committedTranslogFile, Checkpoint.read(location.resolve(getCommitCheckpointFileName(i))))__                assert reader.getPrimaryTerm() <= primaryTermSupplier.getAsLong() :_                    "Primary terms go backwards_ current term [" + primaryTermSupplier.getAsLong() + "]" +_                        "translog path [ " + committedTranslogFile + ", existing term [" + reader.getPrimaryTerm() + "]"__                foundTranslogs.add(reader)__                logger.debug("recovered local translog from checkpoint {}", checkpoint)__            }_            Collections.reverse(foundTranslogs)___            _            _            IOUtils.deleteFilesIgnoringExceptions(location.resolve(getFilename(minGenerationToRecoverFrom - 1)),_                location.resolve(getCommitCheckpointFileName(minGenerationToRecoverFrom - 1)))___            Path commitCheckpoint = location.resolve(getCommitCheckpointFileName(checkpoint.generation))__            if (Files.exists(commitCheckpoint)) {_                Checkpoint checkpointFromDisk = Checkpoint.read(commitCheckpoint)__                if (checkpoint.equals(checkpointFromDisk) == false) {_                    throw new IllegalStateException("Checkpoint file " + commitCheckpoint.getFileName() + " already exists but has corrupted content expected: " + checkpoint + " but got: " + checkpointFromDisk)__                }_            } else {_                _                _                Files.copy(location.resolve(CHECKPOINT_FILE_NAME), tempFile, StandardCopyOption.REPLACE_EXISTING)__                IOUtils.fsync(tempFile, false)__                Files.move(tempFile, commitCheckpoint, StandardCopyOption.ATOMIC_MOVE)__                tempFileRenamed = true__                _                IOUtils.fsync(commitCheckpoint.getParent(), true)__            }_            success = true__        } finally {_            if (success == false) {_                IOUtils.closeWhileHandlingException(foundTranslogs)__            }_            if (tempFileRenamed == false) {_                try {_                    Files.delete(tempFile)__                } catch (IOException ex) {_                    logger.warn(() -> new ParameterizedMessage("failed to delete temp file {}", tempFile), ex)__                }_            }_        }_        return foundTranslogs__    };recover,all,translog,files,found,on,disk;private,array,list,translog,reader,recover,from,files,checkpoint,checkpoint,throws,ioexception,boolean,success,false,array,list,translog,reader,found,translogs,new,array,list,final,path,temp,file,files,create,temp,file,location,boolean,temp,file,renamed,false,try,releasable,lock,lock,write,lock,acquire,logger,debug,open,uncommitted,translog,checkpoint,checkpoint,final,long,min,generation,to,recover,from,if,checkpoint,min,translog,generation,0,final,version,index,version,created,index,settings,get,index,version,created,assert,index,version,created,before,version,no,min,translog,generation,in,checkpoint,but,index,was,created,with,version,index,version,created,min,generation,to,recover,from,deletion,policy,get,min,translog,generation,for,recovery,else,min,generation,to,recover,from,checkpoint,min,translog,generation,final,string,checkpoint,translog,file,get,filename,checkpoint,generation,found,translogs,add,open,reader,location,resolve,checkpoint,translog,file,checkpoint,for,long,i,checkpoint,generation,1,i,min,generation,to,recover,from,i,path,committed,translog,file,location,resolve,get,filename,i,if,files,exists,committed,translog,file,false,throw,new,illegal,state,exception,translog,file,doesn,t,exist,with,generation,i,recovering,from,min,generation,to,recover,from,checkpoint,checkpoint,generation,translog,ids,must,be,consecutive,final,translog,reader,reader,open,reader,committed,translog,file,checkpoint,read,location,resolve,get,commit,checkpoint,file,name,i,assert,reader,get,primary,term,primary,term,supplier,get,as,long,primary,terms,go,backwards,current,term,primary,term,supplier,get,as,long,translog,path,committed,translog,file,existing,term,reader,get,primary,term,found,translogs,add,reader,logger,debug,recovered,local,translog,from,checkpoint,checkpoint,collections,reverse,found,translogs,ioutils,delete,files,ignoring,exceptions,location,resolve,get,filename,min,generation,to,recover,from,1,location,resolve,get,commit,checkpoint,file,name,min,generation,to,recover,from,1,path,commit,checkpoint,location,resolve,get,commit,checkpoint,file,name,checkpoint,generation,if,files,exists,commit,checkpoint,checkpoint,checkpoint,from,disk,checkpoint,read,commit,checkpoint,if,checkpoint,equals,checkpoint,from,disk,false,throw,new,illegal,state,exception,checkpoint,file,commit,checkpoint,get,file,name,already,exists,but,has,corrupted,content,expected,checkpoint,but,got,checkpoint,from,disk,else,files,copy,location,resolve,temp,file,standard,copy,option,ioutils,fsync,temp,file,false,files,move,temp,file,commit,checkpoint,standard,copy,option,temp,file,renamed,true,ioutils,fsync,commit,checkpoint,get,parent,true,success,true,finally,if,success,false,ioutils,close,while,handling,exception,found,translogs,if,temp,file,renamed,false,try,files,delete,temp,file,catch,ioexception,ex,logger,warn,new,parameterized,message,failed,to,delete,temp,file,temp,file,ex,return,found,translogs
Translog -> private ArrayList<TranslogReader> recoverFromFiles(Checkpoint checkpoint) throws IOException;1535723122;recover all translog files found on disk;private ArrayList<TranslogReader> recoverFromFiles(Checkpoint checkpoint) throws IOException {_        boolean success = false__        ArrayList<TranslogReader> foundTranslogs = new ArrayList<>()__        final Path tempFile = Files.createTempFile(location, TRANSLOG_FILE_PREFIX, TRANSLOG_FILE_SUFFIX)_ _        boolean tempFileRenamed = false__        try (ReleasableLock lock = writeLock.acquire()) {_            logger.debug("open uncommitted translog checkpoint {}", checkpoint)___            final long minGenerationToRecoverFrom__            if (checkpoint.minTranslogGeneration < 0) {_                final Version indexVersionCreated = indexSettings().getIndexVersionCreated()__                assert indexVersionCreated.before(Version.V_6_0_0_beta1) :_                    "no minTranslogGeneration in checkpoint, but index was created with version [" + indexVersionCreated + "]"__                minGenerationToRecoverFrom = deletionPolicy.getMinTranslogGenerationForRecovery()__            } else {_                minGenerationToRecoverFrom = checkpoint.minTranslogGeneration__            }__            final String checkpointTranslogFile = getFilename(checkpoint.generation)__            _            _            _            foundTranslogs.add(openReader(location.resolve(checkpointTranslogFile), checkpoint))__            for (long i = checkpoint.generation - 1_ i >= minGenerationToRecoverFrom_ i--) {_                Path committedTranslogFile = location.resolve(getFilename(i))__                if (Files.exists(committedTranslogFile) == false) {_                    throw new IllegalStateException("translog file doesn't exist with generation: " + i + " recovering from: " +_                        minGenerationToRecoverFrom + " checkpoint: " + checkpoint.generation + " - translog ids must be consecutive")__                }_                final TranslogReader reader = openReader(committedTranslogFile, Checkpoint.read(location.resolve(getCommitCheckpointFileName(i))))__                assert reader.getPrimaryTerm() <= primaryTermSupplier.getAsLong() :_                    "Primary terms go backwards_ current term [" + primaryTermSupplier.getAsLong() + "]" +_                        "translog path [ " + committedTranslogFile + ", existing term [" + reader.getPrimaryTerm() + "]"__                foundTranslogs.add(reader)__                logger.debug("recovered local translog from checkpoint {}", checkpoint)__            }_            Collections.reverse(foundTranslogs)___            _            _            IOUtils.deleteFilesIgnoringExceptions(location.resolve(getFilename(minGenerationToRecoverFrom - 1)),_                location.resolve(getCommitCheckpointFileName(minGenerationToRecoverFrom - 1)))___            Path commitCheckpoint = location.resolve(getCommitCheckpointFileName(checkpoint.generation))__            if (Files.exists(commitCheckpoint)) {_                Checkpoint checkpointFromDisk = Checkpoint.read(commitCheckpoint)__                if (checkpoint.equals(checkpointFromDisk) == false) {_                    throw new IllegalStateException("Checkpoint file " + commitCheckpoint.getFileName() + " already exists but has corrupted content expected: " + checkpoint + " but got: " + checkpointFromDisk)__                }_            } else {_                _                _                Files.copy(location.resolve(CHECKPOINT_FILE_NAME), tempFile, StandardCopyOption.REPLACE_EXISTING)__                IOUtils.fsync(tempFile, false)__                Files.move(tempFile, commitCheckpoint, StandardCopyOption.ATOMIC_MOVE)__                tempFileRenamed = true__                _                IOUtils.fsync(commitCheckpoint.getParent(), true)__            }_            success = true__        } finally {_            if (success == false) {_                IOUtils.closeWhileHandlingException(foundTranslogs)__            }_            if (tempFileRenamed == false) {_                try {_                    Files.delete(tempFile)__                } catch (IOException ex) {_                    logger.warn(() -> new ParameterizedMessage("failed to delete temp file {}", tempFile), ex)__                }_            }_        }_        return foundTranslogs__    };recover,all,translog,files,found,on,disk;private,array,list,translog,reader,recover,from,files,checkpoint,checkpoint,throws,ioexception,boolean,success,false,array,list,translog,reader,found,translogs,new,array,list,final,path,temp,file,files,create,temp,file,location,boolean,temp,file,renamed,false,try,releasable,lock,lock,write,lock,acquire,logger,debug,open,uncommitted,translog,checkpoint,checkpoint,final,long,min,generation,to,recover,from,if,checkpoint,min,translog,generation,0,final,version,index,version,created,index,settings,get,index,version,created,assert,index,version,created,before,version,no,min,translog,generation,in,checkpoint,but,index,was,created,with,version,index,version,created,min,generation,to,recover,from,deletion,policy,get,min,translog,generation,for,recovery,else,min,generation,to,recover,from,checkpoint,min,translog,generation,final,string,checkpoint,translog,file,get,filename,checkpoint,generation,found,translogs,add,open,reader,location,resolve,checkpoint,translog,file,checkpoint,for,long,i,checkpoint,generation,1,i,min,generation,to,recover,from,i,path,committed,translog,file,location,resolve,get,filename,i,if,files,exists,committed,translog,file,false,throw,new,illegal,state,exception,translog,file,doesn,t,exist,with,generation,i,recovering,from,min,generation,to,recover,from,checkpoint,checkpoint,generation,translog,ids,must,be,consecutive,final,translog,reader,reader,open,reader,committed,translog,file,checkpoint,read,location,resolve,get,commit,checkpoint,file,name,i,assert,reader,get,primary,term,primary,term,supplier,get,as,long,primary,terms,go,backwards,current,term,primary,term,supplier,get,as,long,translog,path,committed,translog,file,existing,term,reader,get,primary,term,found,translogs,add,reader,logger,debug,recovered,local,translog,from,checkpoint,checkpoint,collections,reverse,found,translogs,ioutils,delete,files,ignoring,exceptions,location,resolve,get,filename,min,generation,to,recover,from,1,location,resolve,get,commit,checkpoint,file,name,min,generation,to,recover,from,1,path,commit,checkpoint,location,resolve,get,commit,checkpoint,file,name,checkpoint,generation,if,files,exists,commit,checkpoint,checkpoint,checkpoint,from,disk,checkpoint,read,commit,checkpoint,if,checkpoint,equals,checkpoint,from,disk,false,throw,new,illegal,state,exception,checkpoint,file,commit,checkpoint,get,file,name,already,exists,but,has,corrupted,content,expected,checkpoint,but,got,checkpoint,from,disk,else,files,copy,location,resolve,temp,file,standard,copy,option,ioutils,fsync,temp,file,false,files,move,temp,file,commit,checkpoint,standard,copy,option,temp,file,renamed,true,ioutils,fsync,commit,checkpoint,get,parent,true,success,true,finally,if,success,false,ioutils,close,while,handling,exception,found,translogs,if,temp,file,renamed,false,try,files,delete,temp,file,catch,ioexception,ex,logger,warn,new,parameterized,message,failed,to,delete,temp,file,temp,file,ex,return,found,translogs
Translog -> private ArrayList<TranslogReader> recoverFromFiles(Checkpoint checkpoint) throws IOException;1537806831;recover all translog files found on disk;private ArrayList<TranslogReader> recoverFromFiles(Checkpoint checkpoint) throws IOException {_        boolean success = false__        ArrayList<TranslogReader> foundTranslogs = new ArrayList<>()__        final Path tempFile = Files.createTempFile(location, TRANSLOG_FILE_PREFIX, TRANSLOG_FILE_SUFFIX)_ _        boolean tempFileRenamed = false__        try (ReleasableLock lock = writeLock.acquire()) {_            logger.debug("open uncommitted translog checkpoint {}", checkpoint)___            final long minGenerationToRecoverFrom__            if (checkpoint.minTranslogGeneration < 0) {_                final Version indexVersionCreated = indexSettings().getIndexVersionCreated()__                assert indexVersionCreated.before(Version.V_6_0_0_beta1) :_                    "no minTranslogGeneration in checkpoint, but index was created with version [" + indexVersionCreated + "]"__                minGenerationToRecoverFrom = deletionPolicy.getMinTranslogGenerationForRecovery()__            } else {_                minGenerationToRecoverFrom = checkpoint.minTranslogGeneration__            }__            final String checkpointTranslogFile = getFilename(checkpoint.generation)__            _            _            _            foundTranslogs.add(openReader(location.resolve(checkpointTranslogFile), checkpoint))__            for (long i = checkpoint.generation - 1_ i >= minGenerationToRecoverFrom_ i--) {_                Path committedTranslogFile = location.resolve(getFilename(i))__                if (Files.exists(committedTranslogFile) == false) {_                    throw new IllegalStateException("translog file doesn't exist with generation: " + i + " recovering from: " +_                        minGenerationToRecoverFrom + " checkpoint: " + checkpoint.generation + " - translog ids must be consecutive")__                }_                final TranslogReader reader = openReader(committedTranslogFile, Checkpoint.read(location.resolve(getCommitCheckpointFileName(i))))__                assert reader.getPrimaryTerm() <= primaryTermSupplier.getAsLong() :_                    "Primary terms go backwards_ current term [" + primaryTermSupplier.getAsLong() + "]" +_                        "translog path [ " + committedTranslogFile + ", existing term [" + reader.getPrimaryTerm() + "]"__                foundTranslogs.add(reader)__                logger.debug("recovered local translog from checkpoint {}", checkpoint)__            }_            Collections.reverse(foundTranslogs)___            _            _            IOUtils.deleteFilesIgnoringExceptions(location.resolve(getFilename(minGenerationToRecoverFrom - 1)),_                location.resolve(getCommitCheckpointFileName(minGenerationToRecoverFrom - 1)))___            Path commitCheckpoint = location.resolve(getCommitCheckpointFileName(checkpoint.generation))__            if (Files.exists(commitCheckpoint)) {_                Checkpoint checkpointFromDisk = Checkpoint.read(commitCheckpoint)__                if (checkpoint.equals(checkpointFromDisk) == false) {_                    throw new IllegalStateException("Checkpoint file " + commitCheckpoint.getFileName() + " already exists but has corrupted content expected: " + checkpoint + " but got: " + checkpointFromDisk)__                }_            } else {_                _                _                Files.copy(location.resolve(CHECKPOINT_FILE_NAME), tempFile, StandardCopyOption.REPLACE_EXISTING)__                IOUtils.fsync(tempFile, false)__                Files.move(tempFile, commitCheckpoint, StandardCopyOption.ATOMIC_MOVE)__                tempFileRenamed = true__                _                IOUtils.fsync(commitCheckpoint.getParent(), true)__            }_            success = true__        } finally {_            if (success == false) {_                IOUtils.closeWhileHandlingException(foundTranslogs)__            }_            if (tempFileRenamed == false) {_                try {_                    Files.delete(tempFile)__                } catch (IOException ex) {_                    logger.warn(() -> new ParameterizedMessage("failed to delete temp file {}", tempFile), ex)__                }_            }_        }_        return foundTranslogs__    };recover,all,translog,files,found,on,disk;private,array,list,translog,reader,recover,from,files,checkpoint,checkpoint,throws,ioexception,boolean,success,false,array,list,translog,reader,found,translogs,new,array,list,final,path,temp,file,files,create,temp,file,location,boolean,temp,file,renamed,false,try,releasable,lock,lock,write,lock,acquire,logger,debug,open,uncommitted,translog,checkpoint,checkpoint,final,long,min,generation,to,recover,from,if,checkpoint,min,translog,generation,0,final,version,index,version,created,index,settings,get,index,version,created,assert,index,version,created,before,version,no,min,translog,generation,in,checkpoint,but,index,was,created,with,version,index,version,created,min,generation,to,recover,from,deletion,policy,get,min,translog,generation,for,recovery,else,min,generation,to,recover,from,checkpoint,min,translog,generation,final,string,checkpoint,translog,file,get,filename,checkpoint,generation,found,translogs,add,open,reader,location,resolve,checkpoint,translog,file,checkpoint,for,long,i,checkpoint,generation,1,i,min,generation,to,recover,from,i,path,committed,translog,file,location,resolve,get,filename,i,if,files,exists,committed,translog,file,false,throw,new,illegal,state,exception,translog,file,doesn,t,exist,with,generation,i,recovering,from,min,generation,to,recover,from,checkpoint,checkpoint,generation,translog,ids,must,be,consecutive,final,translog,reader,reader,open,reader,committed,translog,file,checkpoint,read,location,resolve,get,commit,checkpoint,file,name,i,assert,reader,get,primary,term,primary,term,supplier,get,as,long,primary,terms,go,backwards,current,term,primary,term,supplier,get,as,long,translog,path,committed,translog,file,existing,term,reader,get,primary,term,found,translogs,add,reader,logger,debug,recovered,local,translog,from,checkpoint,checkpoint,collections,reverse,found,translogs,ioutils,delete,files,ignoring,exceptions,location,resolve,get,filename,min,generation,to,recover,from,1,location,resolve,get,commit,checkpoint,file,name,min,generation,to,recover,from,1,path,commit,checkpoint,location,resolve,get,commit,checkpoint,file,name,checkpoint,generation,if,files,exists,commit,checkpoint,checkpoint,checkpoint,from,disk,checkpoint,read,commit,checkpoint,if,checkpoint,equals,checkpoint,from,disk,false,throw,new,illegal,state,exception,checkpoint,file,commit,checkpoint,get,file,name,already,exists,but,has,corrupted,content,expected,checkpoint,but,got,checkpoint,from,disk,else,files,copy,location,resolve,temp,file,standard,copy,option,ioutils,fsync,temp,file,false,files,move,temp,file,commit,checkpoint,standard,copy,option,temp,file,renamed,true,ioutils,fsync,commit,checkpoint,get,parent,true,success,true,finally,if,success,false,ioutils,close,while,handling,exception,found,translogs,if,temp,file,renamed,false,try,files,delete,temp,file,catch,ioexception,ex,logger,warn,new,parameterized,message,failed,to,delete,temp,file,temp,file,ex,return,found,translogs
Translog -> private ArrayList<TranslogReader> recoverFromFiles(Checkpoint checkpoint) throws IOException;1541592065;recover all translog files found on disk;private ArrayList<TranslogReader> recoverFromFiles(Checkpoint checkpoint) throws IOException {_        boolean success = false__        ArrayList<TranslogReader> foundTranslogs = new ArrayList<>()__        final Path tempFile = Files.createTempFile(location, TRANSLOG_FILE_PREFIX, TRANSLOG_FILE_SUFFIX)_ _        boolean tempFileRenamed = false__        try (ReleasableLock lock = writeLock.acquire()) {_            logger.debug("open uncommitted translog checkpoint {}", checkpoint)___            final long minGenerationToRecoverFrom__            if (checkpoint.minTranslogGeneration < 0) {_                final Version indexVersionCreated = indexSettings().getIndexVersionCreated()__                assert indexVersionCreated.before(Version.V_6_0_0_beta1) :_                    "no minTranslogGeneration in checkpoint, but index was created with version [" + indexVersionCreated + "]"__                minGenerationToRecoverFrom = deletionPolicy.getMinTranslogGenerationForRecovery()__            } else {_                minGenerationToRecoverFrom = checkpoint.minTranslogGeneration__            }__            final String checkpointTranslogFile = getFilename(checkpoint.generation)__            _            _            _            foundTranslogs.add(openReader(location.resolve(checkpointTranslogFile), checkpoint))__            for (long i = checkpoint.generation - 1_ i >= minGenerationToRecoverFrom_ i--) {_                Path committedTranslogFile = location.resolve(getFilename(i))__                if (Files.exists(committedTranslogFile) == false) {_                    throw new IllegalStateException("translog file doesn't exist with generation: " + i + " recovering from: " +_                        minGenerationToRecoverFrom + " checkpoint: " + checkpoint.generation + " - translog ids must be consecutive")__                }_                final TranslogReader reader = openReader(committedTranslogFile, Checkpoint.read(location.resolve(getCommitCheckpointFileName(i))))__                assert reader.getPrimaryTerm() <= primaryTermSupplier.getAsLong() :_                    "Primary terms go backwards_ current term [" + primaryTermSupplier.getAsLong() + "]" +_                        "translog path [ " + committedTranslogFile + ", existing term [" + reader.getPrimaryTerm() + "]"__                foundTranslogs.add(reader)__                logger.debug("recovered local translog from checkpoint {}", checkpoint)__            }_            Collections.reverse(foundTranslogs)___            _            _            IOUtils.deleteFilesIgnoringExceptions(location.resolve(getFilename(minGenerationToRecoverFrom - 1)),_                location.resolve(getCommitCheckpointFileName(minGenerationToRecoverFrom - 1)))___            Path commitCheckpoint = location.resolve(getCommitCheckpointFileName(checkpoint.generation))__            if (Files.exists(commitCheckpoint)) {_                Checkpoint checkpointFromDisk = Checkpoint.read(commitCheckpoint)__                if (checkpoint.equals(checkpointFromDisk) == false) {_                    throw new IllegalStateException("Checkpoint file " + commitCheckpoint.getFileName() + " already exists but has corrupted content expected: " + checkpoint + " but got: " + checkpointFromDisk)__                }_            } else {_                _                _                Files.copy(location.resolve(CHECKPOINT_FILE_NAME), tempFile, StandardCopyOption.REPLACE_EXISTING)__                IOUtils.fsync(tempFile, false)__                Files.move(tempFile, commitCheckpoint, StandardCopyOption.ATOMIC_MOVE)__                tempFileRenamed = true__                _                IOUtils.fsync(commitCheckpoint.getParent(), true)__            }_            success = true__        } finally {_            if (success == false) {_                IOUtils.closeWhileHandlingException(foundTranslogs)__            }_            if (tempFileRenamed == false) {_                try {_                    Files.delete(tempFile)__                } catch (IOException ex) {_                    logger.warn(() -> new ParameterizedMessage("failed to delete temp file {}", tempFile), ex)__                }_            }_        }_        return foundTranslogs__    };recover,all,translog,files,found,on,disk;private,array,list,translog,reader,recover,from,files,checkpoint,checkpoint,throws,ioexception,boolean,success,false,array,list,translog,reader,found,translogs,new,array,list,final,path,temp,file,files,create,temp,file,location,boolean,temp,file,renamed,false,try,releasable,lock,lock,write,lock,acquire,logger,debug,open,uncommitted,translog,checkpoint,checkpoint,final,long,min,generation,to,recover,from,if,checkpoint,min,translog,generation,0,final,version,index,version,created,index,settings,get,index,version,created,assert,index,version,created,before,version,no,min,translog,generation,in,checkpoint,but,index,was,created,with,version,index,version,created,min,generation,to,recover,from,deletion,policy,get,min,translog,generation,for,recovery,else,min,generation,to,recover,from,checkpoint,min,translog,generation,final,string,checkpoint,translog,file,get,filename,checkpoint,generation,found,translogs,add,open,reader,location,resolve,checkpoint,translog,file,checkpoint,for,long,i,checkpoint,generation,1,i,min,generation,to,recover,from,i,path,committed,translog,file,location,resolve,get,filename,i,if,files,exists,committed,translog,file,false,throw,new,illegal,state,exception,translog,file,doesn,t,exist,with,generation,i,recovering,from,min,generation,to,recover,from,checkpoint,checkpoint,generation,translog,ids,must,be,consecutive,final,translog,reader,reader,open,reader,committed,translog,file,checkpoint,read,location,resolve,get,commit,checkpoint,file,name,i,assert,reader,get,primary,term,primary,term,supplier,get,as,long,primary,terms,go,backwards,current,term,primary,term,supplier,get,as,long,translog,path,committed,translog,file,existing,term,reader,get,primary,term,found,translogs,add,reader,logger,debug,recovered,local,translog,from,checkpoint,checkpoint,collections,reverse,found,translogs,ioutils,delete,files,ignoring,exceptions,location,resolve,get,filename,min,generation,to,recover,from,1,location,resolve,get,commit,checkpoint,file,name,min,generation,to,recover,from,1,path,commit,checkpoint,location,resolve,get,commit,checkpoint,file,name,checkpoint,generation,if,files,exists,commit,checkpoint,checkpoint,checkpoint,from,disk,checkpoint,read,commit,checkpoint,if,checkpoint,equals,checkpoint,from,disk,false,throw,new,illegal,state,exception,checkpoint,file,commit,checkpoint,get,file,name,already,exists,but,has,corrupted,content,expected,checkpoint,but,got,checkpoint,from,disk,else,files,copy,location,resolve,temp,file,standard,copy,option,ioutils,fsync,temp,file,false,files,move,temp,file,commit,checkpoint,standard,copy,option,temp,file,renamed,true,ioutils,fsync,commit,checkpoint,get,parent,true,success,true,finally,if,success,false,ioutils,close,while,handling,exception,found,translogs,if,temp,file,renamed,false,try,files,delete,temp,file,catch,ioexception,ex,logger,warn,new,parameterized,message,failed,to,delete,temp,file,temp,file,ex,return,found,translogs
Translog -> private ArrayList<TranslogReader> recoverFromFiles(Checkpoint checkpoint) throws IOException;1542697754;recover all translog files found on disk;private ArrayList<TranslogReader> recoverFromFiles(Checkpoint checkpoint) throws IOException {_        boolean success = false__        ArrayList<TranslogReader> foundTranslogs = new ArrayList<>()__        _        final Path tempFile = Files.createTempFile(location, TRANSLOG_FILE_PREFIX, TRANSLOG_FILE_SUFFIX)__        boolean tempFileRenamed = false__        try (ReleasableLock lock = writeLock.acquire()) {_            logger.debug("open uncommitted translog checkpoint {}", checkpoint)___            final long minGenerationToRecoverFrom__            if (checkpoint.minTranslogGeneration < 0) {_                final Version indexVersionCreated = indexSettings().getIndexVersionCreated()__                assert indexVersionCreated.before(Version.V_6_0_0_beta1) :_                    "no minTranslogGeneration in checkpoint, but index was created with version [" + indexVersionCreated + "]"__                minGenerationToRecoverFrom = deletionPolicy.getMinTranslogGenerationForRecovery()__            } else {_                minGenerationToRecoverFrom = checkpoint.minTranslogGeneration__            }__            final String checkpointTranslogFile = getFilename(checkpoint.generation)__            _            _            _            foundTranslogs.add(openReader(location.resolve(checkpointTranslogFile), checkpoint))__            for (long i = checkpoint.generation - 1_ i >= minGenerationToRecoverFrom_ i--) {_                Path committedTranslogFile = location.resolve(getFilename(i))__                if (Files.exists(committedTranslogFile) == false) {_                    throw new IllegalStateException("translog file doesn't exist with generation: " + i + " recovering from: " +_                        minGenerationToRecoverFrom + " checkpoint: " + checkpoint.generation + " - translog ids must be consecutive")__                }_                final TranslogReader reader = openReader(committedTranslogFile,_                    Checkpoint.read(location.resolve(getCommitCheckpointFileName(i))))__                assert reader.getPrimaryTerm() <= primaryTermSupplier.getAsLong() :_                    "Primary terms go backwards_ current term [" + primaryTermSupplier.getAsLong() + "]" +_                        "translog path [ " + committedTranslogFile + ", existing term [" + reader.getPrimaryTerm() + "]"__                foundTranslogs.add(reader)__                logger.debug("recovered local translog from checkpoint {}", checkpoint)__            }_            Collections.reverse(foundTranslogs)___            _            _            IOUtils.deleteFilesIgnoringExceptions(location.resolve(getFilename(minGenerationToRecoverFrom - 1)),_                location.resolve(getCommitCheckpointFileName(minGenerationToRecoverFrom - 1)))___            Path commitCheckpoint = location.resolve(getCommitCheckpointFileName(checkpoint.generation))__            if (Files.exists(commitCheckpoint)) {_                Checkpoint checkpointFromDisk = Checkpoint.read(commitCheckpoint)__                if (checkpoint.equals(checkpointFromDisk) == false) {_                    throw new IllegalStateException("Checkpoint file " + commitCheckpoint.getFileName() +_                        " already exists but has corrupted content expected: " + checkpoint + " but got: " + checkpointFromDisk)__                }_            } else {_                _                _                Files.copy(location.resolve(CHECKPOINT_FILE_NAME), tempFile, StandardCopyOption.REPLACE_EXISTING)__                IOUtils.fsync(tempFile, false)__                Files.move(tempFile, commitCheckpoint, StandardCopyOption.ATOMIC_MOVE)__                tempFileRenamed = true__                _                IOUtils.fsync(commitCheckpoint.getParent(), true)__            }_            success = true__        } finally {_            if (success == false) {_                IOUtils.closeWhileHandlingException(foundTranslogs)__            }_            if (tempFileRenamed == false) {_                try {_                    Files.delete(tempFile)__                } catch (IOException ex) {_                    logger.warn(() -> new ParameterizedMessage("failed to delete temp file {}", tempFile), ex)__                }_            }_        }_        return foundTranslogs__    };recover,all,translog,files,found,on,disk;private,array,list,translog,reader,recover,from,files,checkpoint,checkpoint,throws,ioexception,boolean,success,false,array,list,translog,reader,found,translogs,new,array,list,final,path,temp,file,files,create,temp,file,location,boolean,temp,file,renamed,false,try,releasable,lock,lock,write,lock,acquire,logger,debug,open,uncommitted,translog,checkpoint,checkpoint,final,long,min,generation,to,recover,from,if,checkpoint,min,translog,generation,0,final,version,index,version,created,index,settings,get,index,version,created,assert,index,version,created,before,version,no,min,translog,generation,in,checkpoint,but,index,was,created,with,version,index,version,created,min,generation,to,recover,from,deletion,policy,get,min,translog,generation,for,recovery,else,min,generation,to,recover,from,checkpoint,min,translog,generation,final,string,checkpoint,translog,file,get,filename,checkpoint,generation,found,translogs,add,open,reader,location,resolve,checkpoint,translog,file,checkpoint,for,long,i,checkpoint,generation,1,i,min,generation,to,recover,from,i,path,committed,translog,file,location,resolve,get,filename,i,if,files,exists,committed,translog,file,false,throw,new,illegal,state,exception,translog,file,doesn,t,exist,with,generation,i,recovering,from,min,generation,to,recover,from,checkpoint,checkpoint,generation,translog,ids,must,be,consecutive,final,translog,reader,reader,open,reader,committed,translog,file,checkpoint,read,location,resolve,get,commit,checkpoint,file,name,i,assert,reader,get,primary,term,primary,term,supplier,get,as,long,primary,terms,go,backwards,current,term,primary,term,supplier,get,as,long,translog,path,committed,translog,file,existing,term,reader,get,primary,term,found,translogs,add,reader,logger,debug,recovered,local,translog,from,checkpoint,checkpoint,collections,reverse,found,translogs,ioutils,delete,files,ignoring,exceptions,location,resolve,get,filename,min,generation,to,recover,from,1,location,resolve,get,commit,checkpoint,file,name,min,generation,to,recover,from,1,path,commit,checkpoint,location,resolve,get,commit,checkpoint,file,name,checkpoint,generation,if,files,exists,commit,checkpoint,checkpoint,checkpoint,from,disk,checkpoint,read,commit,checkpoint,if,checkpoint,equals,checkpoint,from,disk,false,throw,new,illegal,state,exception,checkpoint,file,commit,checkpoint,get,file,name,already,exists,but,has,corrupted,content,expected,checkpoint,but,got,checkpoint,from,disk,else,files,copy,location,resolve,temp,file,standard,copy,option,ioutils,fsync,temp,file,false,files,move,temp,file,commit,checkpoint,standard,copy,option,temp,file,renamed,true,ioutils,fsync,commit,checkpoint,get,parent,true,success,true,finally,if,success,false,ioutils,close,while,handling,exception,found,translogs,if,temp,file,renamed,false,try,files,delete,temp,file,catch,ioexception,ex,logger,warn,new,parameterized,message,failed,to,delete,temp,file,temp,file,ex,return,found,translogs
Translog -> private ArrayList<TranslogReader> recoverFromFiles(Checkpoint checkpoint) throws IOException;1542962614;recover all translog files found on disk;private ArrayList<TranslogReader> recoverFromFiles(Checkpoint checkpoint) throws IOException {_        boolean success = false__        ArrayList<TranslogReader> foundTranslogs = new ArrayList<>()__        try (ReleasableLock lock = writeLock.acquire()) {_            logger.debug("open uncommitted translog checkpoint {}", checkpoint)___            final long minGenerationToRecoverFrom__            if (checkpoint.minTranslogGeneration < 0) {_                final Version indexVersionCreated = indexSettings().getIndexVersionCreated()__                assert indexVersionCreated.before(Version.V_6_0_0_beta1) :_                    "no minTranslogGeneration in checkpoint, but index was created with version [" + indexVersionCreated + "]"__                minGenerationToRecoverFrom = deletionPolicy.getMinTranslogGenerationForRecovery()__            } else {_                minGenerationToRecoverFrom = checkpoint.minTranslogGeneration__            }__            final String checkpointTranslogFile = getFilename(checkpoint.generation)__            _            _            _            foundTranslogs.add(openReader(location.resolve(checkpointTranslogFile), checkpoint))__            for (long i = checkpoint.generation - 1_ i >= minGenerationToRecoverFrom_ i--) {_                Path committedTranslogFile = location.resolve(getFilename(i))__                if (Files.exists(committedTranslogFile) == false) {_                    throw new IllegalStateException("translog file doesn't exist with generation: " + i + " recovering from: " +_                        minGenerationToRecoverFrom + " checkpoint: " + checkpoint.generation + " - translog ids must be consecutive")__                }_                final TranslogReader reader = openReader(committedTranslogFile,_                    Checkpoint.read(location.resolve(getCommitCheckpointFileName(i))))__                assert reader.getPrimaryTerm() <= primaryTermSupplier.getAsLong() :_                    "Primary terms go backwards_ current term [" + primaryTermSupplier.getAsLong() + "]" +_                        "translog path [ " + committedTranslogFile + ", existing term [" + reader.getPrimaryTerm() + "]"__                foundTranslogs.add(reader)__                logger.debug("recovered local translog from checkpoint {}", checkpoint)__            }_            Collections.reverse(foundTranslogs)___            _            _            IOUtils.deleteFilesIgnoringExceptions(location.resolve(getFilename(minGenerationToRecoverFrom - 1)),_                location.resolve(getCommitCheckpointFileName(minGenerationToRecoverFrom - 1)))___            Path commitCheckpoint = location.resolve(getCommitCheckpointFileName(checkpoint.generation))__            if (Files.exists(commitCheckpoint)) {_                Checkpoint checkpointFromDisk = Checkpoint.read(commitCheckpoint)__                if (checkpoint.equals(checkpointFromDisk) == false) {_                    throw new IllegalStateException("Checkpoint file " + commitCheckpoint.getFileName() +_                        " already exists but has corrupted content expected: " + checkpoint + " but got: " + checkpointFromDisk)__                }_            } else {_                copyCheckpointTo(commitCheckpoint)__            }_            success = true__        } finally {_            if (success == false) {_                IOUtils.closeWhileHandlingException(foundTranslogs)__            }_        }_        return foundTranslogs__    };recover,all,translog,files,found,on,disk;private,array,list,translog,reader,recover,from,files,checkpoint,checkpoint,throws,ioexception,boolean,success,false,array,list,translog,reader,found,translogs,new,array,list,try,releasable,lock,lock,write,lock,acquire,logger,debug,open,uncommitted,translog,checkpoint,checkpoint,final,long,min,generation,to,recover,from,if,checkpoint,min,translog,generation,0,final,version,index,version,created,index,settings,get,index,version,created,assert,index,version,created,before,version,no,min,translog,generation,in,checkpoint,but,index,was,created,with,version,index,version,created,min,generation,to,recover,from,deletion,policy,get,min,translog,generation,for,recovery,else,min,generation,to,recover,from,checkpoint,min,translog,generation,final,string,checkpoint,translog,file,get,filename,checkpoint,generation,found,translogs,add,open,reader,location,resolve,checkpoint,translog,file,checkpoint,for,long,i,checkpoint,generation,1,i,min,generation,to,recover,from,i,path,committed,translog,file,location,resolve,get,filename,i,if,files,exists,committed,translog,file,false,throw,new,illegal,state,exception,translog,file,doesn,t,exist,with,generation,i,recovering,from,min,generation,to,recover,from,checkpoint,checkpoint,generation,translog,ids,must,be,consecutive,final,translog,reader,reader,open,reader,committed,translog,file,checkpoint,read,location,resolve,get,commit,checkpoint,file,name,i,assert,reader,get,primary,term,primary,term,supplier,get,as,long,primary,terms,go,backwards,current,term,primary,term,supplier,get,as,long,translog,path,committed,translog,file,existing,term,reader,get,primary,term,found,translogs,add,reader,logger,debug,recovered,local,translog,from,checkpoint,checkpoint,collections,reverse,found,translogs,ioutils,delete,files,ignoring,exceptions,location,resolve,get,filename,min,generation,to,recover,from,1,location,resolve,get,commit,checkpoint,file,name,min,generation,to,recover,from,1,path,commit,checkpoint,location,resolve,get,commit,checkpoint,file,name,checkpoint,generation,if,files,exists,commit,checkpoint,checkpoint,checkpoint,from,disk,checkpoint,read,commit,checkpoint,if,checkpoint,equals,checkpoint,from,disk,false,throw,new,illegal,state,exception,checkpoint,file,commit,checkpoint,get,file,name,already,exists,but,has,corrupted,content,expected,checkpoint,but,got,checkpoint,from,disk,else,copy,checkpoint,to,commit,checkpoint,success,true,finally,if,success,false,ioutils,close,while,handling,exception,found,translogs,return,found,translogs
Translog -> private ArrayList<TranslogReader> recoverFromFiles(Checkpoint checkpoint) throws IOException;1545236365;recover all translog files found on disk;private ArrayList<TranslogReader> recoverFromFiles(Checkpoint checkpoint) throws IOException {_        boolean success = false__        ArrayList<TranslogReader> foundTranslogs = new ArrayList<>()__        try (ReleasableLock lock = writeLock.acquire()) {_            logger.debug("open uncommitted translog checkpoint {}", checkpoint)___            final long minGenerationToRecoverFrom__            if (checkpoint.minTranslogGeneration < 0) {_                final Version indexVersionCreated = indexSettings().getIndexVersionCreated()__                assert indexVersionCreated.before(Version.V_6_0_0_beta1) :_                    "no minTranslogGeneration in checkpoint, but index was created with version [" + indexVersionCreated + "]"__                minGenerationToRecoverFrom = deletionPolicy.getMinTranslogGenerationForRecovery()__            } else {_                minGenerationToRecoverFrom = checkpoint.minTranslogGeneration__            }__            final String checkpointTranslogFile = getFilename(checkpoint.generation)__            _            _            _            foundTranslogs.add(openReader(location.resolve(checkpointTranslogFile), checkpoint))__            for (long i = checkpoint.generation - 1_ i >= minGenerationToRecoverFrom_ i--) {_                Path committedTranslogFile = location.resolve(getFilename(i))__                if (Files.exists(committedTranslogFile) == false) {_                    throw new IllegalStateException("translog file doesn't exist with generation: " + i + " recovering from: " +_                        minGenerationToRecoverFrom + " checkpoint: " + checkpoint.generation + " - translog ids must be consecutive")__                }_                final TranslogReader reader = openReader(committedTranslogFile,_                    Checkpoint.read(location.resolve(getCommitCheckpointFileName(i))))__                assert reader.getPrimaryTerm() <= primaryTermSupplier.getAsLong() :_                    "Primary terms go backwards_ current term [" + primaryTermSupplier.getAsLong() + "]" +_                        "translog path [ " + committedTranslogFile + ", existing term [" + reader.getPrimaryTerm() + "]"__                foundTranslogs.add(reader)__                logger.debug("recovered local translog from checkpoint {}", checkpoint)__            }_            Collections.reverse(foundTranslogs)___            _            _            IOUtils.deleteFilesIgnoringExceptions(location.resolve(getFilename(minGenerationToRecoverFrom - 1)),_                location.resolve(getCommitCheckpointFileName(minGenerationToRecoverFrom - 1)))___            Path commitCheckpoint = location.resolve(getCommitCheckpointFileName(checkpoint.generation))__            if (Files.exists(commitCheckpoint)) {_                Checkpoint checkpointFromDisk = Checkpoint.read(commitCheckpoint)__                if (checkpoint.equals(checkpointFromDisk) == false) {_                    throw new IllegalStateException("Checkpoint file " + commitCheckpoint.getFileName() +_                        " already exists but has corrupted content expected: " + checkpoint + " but got: " + checkpointFromDisk)__                }_            } else {_                copyCheckpointTo(commitCheckpoint)__            }_            success = true__        } finally {_            if (success == false) {_                IOUtils.closeWhileHandlingException(foundTranslogs)__            }_        }_        return foundTranslogs__    };recover,all,translog,files,found,on,disk;private,array,list,translog,reader,recover,from,files,checkpoint,checkpoint,throws,ioexception,boolean,success,false,array,list,translog,reader,found,translogs,new,array,list,try,releasable,lock,lock,write,lock,acquire,logger,debug,open,uncommitted,translog,checkpoint,checkpoint,final,long,min,generation,to,recover,from,if,checkpoint,min,translog,generation,0,final,version,index,version,created,index,settings,get,index,version,created,assert,index,version,created,before,version,no,min,translog,generation,in,checkpoint,but,index,was,created,with,version,index,version,created,min,generation,to,recover,from,deletion,policy,get,min,translog,generation,for,recovery,else,min,generation,to,recover,from,checkpoint,min,translog,generation,final,string,checkpoint,translog,file,get,filename,checkpoint,generation,found,translogs,add,open,reader,location,resolve,checkpoint,translog,file,checkpoint,for,long,i,checkpoint,generation,1,i,min,generation,to,recover,from,i,path,committed,translog,file,location,resolve,get,filename,i,if,files,exists,committed,translog,file,false,throw,new,illegal,state,exception,translog,file,doesn,t,exist,with,generation,i,recovering,from,min,generation,to,recover,from,checkpoint,checkpoint,generation,translog,ids,must,be,consecutive,final,translog,reader,reader,open,reader,committed,translog,file,checkpoint,read,location,resolve,get,commit,checkpoint,file,name,i,assert,reader,get,primary,term,primary,term,supplier,get,as,long,primary,terms,go,backwards,current,term,primary,term,supplier,get,as,long,translog,path,committed,translog,file,existing,term,reader,get,primary,term,found,translogs,add,reader,logger,debug,recovered,local,translog,from,checkpoint,checkpoint,collections,reverse,found,translogs,ioutils,delete,files,ignoring,exceptions,location,resolve,get,filename,min,generation,to,recover,from,1,location,resolve,get,commit,checkpoint,file,name,min,generation,to,recover,from,1,path,commit,checkpoint,location,resolve,get,commit,checkpoint,file,name,checkpoint,generation,if,files,exists,commit,checkpoint,checkpoint,checkpoint,from,disk,checkpoint,read,commit,checkpoint,if,checkpoint,equals,checkpoint,from,disk,false,throw,new,illegal,state,exception,checkpoint,file,commit,checkpoint,get,file,name,already,exists,but,has,corrupted,content,expected,checkpoint,but,got,checkpoint,from,disk,else,copy,checkpoint,to,commit,checkpoint,success,true,finally,if,success,false,ioutils,close,while,handling,exception,found,translogs,return,found,translogs
Translog -> public Closeable acquireRetentionLock();1524684173;Acquires a lock on the translog files, preventing them from being trimmed;public Closeable acquireRetentionLock() {_        try (ReleasableLock lock = readLock.acquire()) {_            ensureOpen()__            final long viewGen = getMinFileGeneration()__            return acquireTranslogGenFromDeletionPolicy(viewGen)__        }_    };acquires,a,lock,on,the,translog,files,preventing,them,from,being,trimmed;public,closeable,acquire,retention,lock,try,releasable,lock,lock,read,lock,acquire,ensure,open,final,long,view,gen,get,min,file,generation,return,acquire,translog,gen,from,deletion,policy,view,gen
Translog -> public Closeable acquireRetentionLock();1525334055;Acquires a lock on the translog files, preventing them from being trimmed;public Closeable acquireRetentionLock() {_        try (ReleasableLock lock = readLock.acquire()) {_            ensureOpen()__            final long viewGen = getMinFileGeneration()__            return acquireTranslogGenFromDeletionPolicy(viewGen)__        }_    };acquires,a,lock,on,the,translog,files,preventing,them,from,being,trimmed;public,closeable,acquire,retention,lock,try,releasable,lock,lock,read,lock,acquire,ensure,open,final,long,view,gen,get,min,file,generation,return,acquire,translog,gen,from,deletion,policy,view,gen
Translog -> public Closeable acquireRetentionLock();1528706846;Acquires a lock on the translog files, preventing them from being trimmed;public Closeable acquireRetentionLock() {_        try (ReleasableLock lock = readLock.acquire()) {_            ensureOpen()__            final long viewGen = getMinFileGeneration()__            return acquireTranslogGenFromDeletionPolicy(viewGen)__        }_    };acquires,a,lock,on,the,translog,files,preventing,them,from,being,trimmed;public,closeable,acquire,retention,lock,try,releasable,lock,lock,read,lock,acquire,ensure,open,final,long,view,gen,get,min,file,generation,return,acquire,translog,gen,from,deletion,policy,view,gen
Translog -> public Closeable acquireRetentionLock();1531910483;Acquires a lock on the translog files, preventing them from being trimmed;public Closeable acquireRetentionLock() {_        try (ReleasableLock lock = readLock.acquire()) {_            ensureOpen()__            final long viewGen = getMinFileGeneration()__            return acquireTranslogGenFromDeletionPolicy(viewGen)__        }_    };acquires,a,lock,on,the,translog,files,preventing,them,from,being,trimmed;public,closeable,acquire,retention,lock,try,releasable,lock,lock,read,lock,acquire,ensure,open,final,long,view,gen,get,min,file,generation,return,acquire,translog,gen,from,deletion,policy,view,gen
Translog -> public Closeable acquireRetentionLock();1533295538;Acquires a lock on the translog files, preventing them from being trimmed;public Closeable acquireRetentionLock() {_        try (ReleasableLock lock = readLock.acquire()) {_            ensureOpen()__            final long viewGen = getMinFileGeneration()__            return acquireTranslogGenFromDeletionPolicy(viewGen)__        }_    };acquires,a,lock,on,the,translog,files,preventing,them,from,being,trimmed;public,closeable,acquire,retention,lock,try,releasable,lock,lock,read,lock,acquire,ensure,open,final,long,view,gen,get,min,file,generation,return,acquire,translog,gen,from,deletion,policy,view,gen
Translog -> public Closeable acquireRetentionLock();1533641732;Acquires a lock on the translog files, preventing them from being trimmed;public Closeable acquireRetentionLock() {_        try (ReleasableLock lock = readLock.acquire()) {_            ensureOpen()__            final long viewGen = getMinFileGeneration()__            return acquireTranslogGenFromDeletionPolicy(viewGen)__        }_    };acquires,a,lock,on,the,translog,files,preventing,them,from,being,trimmed;public,closeable,acquire,retention,lock,try,releasable,lock,lock,read,lock,acquire,ensure,open,final,long,view,gen,get,min,file,generation,return,acquire,translog,gen,from,deletion,policy,view,gen
Translog -> public Closeable acquireRetentionLock();1534848846;Acquires a lock on the translog files, preventing them from being trimmed;public Closeable acquireRetentionLock() {_        try (ReleasableLock lock = readLock.acquire()) {_            ensureOpen()__            final long viewGen = getMinFileGeneration()__            return acquireTranslogGenFromDeletionPolicy(viewGen)__        }_    };acquires,a,lock,on,the,translog,files,preventing,them,from,being,trimmed;public,closeable,acquire,retention,lock,try,releasable,lock,lock,read,lock,acquire,ensure,open,final,long,view,gen,get,min,file,generation,return,acquire,translog,gen,from,deletion,policy,view,gen
Translog -> public Closeable acquireRetentionLock();1535046779;Acquires a lock on the translog files, preventing them from being trimmed;public Closeable acquireRetentionLock() {_        try (ReleasableLock lock = readLock.acquire()) {_            ensureOpen()__            final long viewGen = getMinFileGeneration()__            return acquireTranslogGenFromDeletionPolicy(viewGen)__        }_    };acquires,a,lock,on,the,translog,files,preventing,them,from,being,trimmed;public,closeable,acquire,retention,lock,try,releasable,lock,lock,read,lock,acquire,ensure,open,final,long,view,gen,get,min,file,generation,return,acquire,translog,gen,from,deletion,policy,view,gen
Translog -> public Closeable acquireRetentionLock();1535723122;Acquires a lock on the translog files, preventing them from being trimmed;public Closeable acquireRetentionLock() {_        try (ReleasableLock lock = readLock.acquire()) {_            ensureOpen()__            final long viewGen = getMinFileGeneration()__            return acquireTranslogGenFromDeletionPolicy(viewGen)__        }_    };acquires,a,lock,on,the,translog,files,preventing,them,from,being,trimmed;public,closeable,acquire,retention,lock,try,releasable,lock,lock,read,lock,acquire,ensure,open,final,long,view,gen,get,min,file,generation,return,acquire,translog,gen,from,deletion,policy,view,gen
Translog -> public Closeable acquireRetentionLock();1537806831;Acquires a lock on the translog files, preventing them from being trimmed;public Closeable acquireRetentionLock() {_        try (ReleasableLock lock = readLock.acquire()) {_            ensureOpen()__            final long viewGen = getMinFileGeneration()__            return acquireTranslogGenFromDeletionPolicy(viewGen)__        }_    };acquires,a,lock,on,the,translog,files,preventing,them,from,being,trimmed;public,closeable,acquire,retention,lock,try,releasable,lock,lock,read,lock,acquire,ensure,open,final,long,view,gen,get,min,file,generation,return,acquire,translog,gen,from,deletion,policy,view,gen
Translog -> public Closeable acquireRetentionLock();1541592065;Acquires a lock on the translog files, preventing them from being trimmed;public Closeable acquireRetentionLock() {_        try (ReleasableLock lock = readLock.acquire()) {_            ensureOpen()__            final long viewGen = getMinFileGeneration()__            return acquireTranslogGenFromDeletionPolicy(viewGen)__        }_    };acquires,a,lock,on,the,translog,files,preventing,them,from,being,trimmed;public,closeable,acquire,retention,lock,try,releasable,lock,lock,read,lock,acquire,ensure,open,final,long,view,gen,get,min,file,generation,return,acquire,translog,gen,from,deletion,policy,view,gen
Translog -> public Closeable acquireRetentionLock();1542697754;Acquires a lock on the translog files, preventing them from being trimmed;public Closeable acquireRetentionLock() {_        try (ReleasableLock lock = readLock.acquire()) {_            ensureOpen()__            final long viewGen = getMinFileGeneration()__            return acquireTranslogGenFromDeletionPolicy(viewGen)__        }_    };acquires,a,lock,on,the,translog,files,preventing,them,from,being,trimmed;public,closeable,acquire,retention,lock,try,releasable,lock,lock,read,lock,acquire,ensure,open,final,long,view,gen,get,min,file,generation,return,acquire,translog,gen,from,deletion,policy,view,gen
Translog -> public Closeable acquireRetentionLock();1542962614;Acquires a lock on the translog files, preventing them from being trimmed;public Closeable acquireRetentionLock() {_        try (ReleasableLock lock = readLock.acquire()) {_            ensureOpen()__            final long viewGen = getMinFileGeneration()__            return acquireTranslogGenFromDeletionPolicy(viewGen)__        }_    };acquires,a,lock,on,the,translog,files,preventing,them,from,being,trimmed;public,closeable,acquire,retention,lock,try,releasable,lock,lock,read,lock,acquire,ensure,open,final,long,view,gen,get,min,file,generation,return,acquire,translog,gen,from,deletion,policy,view,gen
Translog -> public Closeable acquireRetentionLock();1545236365;Acquires a lock on the translog files, preventing them from being trimmed;public Closeable acquireRetentionLock() {_        try (ReleasableLock lock = readLock.acquire()) {_            ensureOpen()__            final long viewGen = getMinFileGeneration()__            return acquireTranslogGenFromDeletionPolicy(viewGen)__        }_    };acquires,a,lock,on,the,translog,files,preventing,them,from,being,trimmed;public,closeable,acquire,retention,lock,try,releasable,lock,lock,read,lock,acquire,ensure,open,final,long,view,gen,get,min,file,generation,return,acquire,translog,gen,from,deletion,policy,view,gen
Translog -> public static void writeOperations(StreamOutput outStream, List<Operation> toWrite) throws IOException;1524684173;Writes all operations in the given iterable to the given output stream including the size of the array_use {@link #readOperations(StreamInput)} to read it back.;public static void writeOperations(StreamOutput outStream, List<Operation> toWrite) throws IOException {_        final ReleasableBytesStreamOutput out = new ReleasableBytesStreamOutput(BigArrays.NON_RECYCLING_INSTANCE)__        try {_            outStream.writeInt(toWrite.size())__            final BufferedChecksumStreamOutput checksumStreamOutput = new BufferedChecksumStreamOutput(out)__            for (Operation op : toWrite) {_                out.reset()__                final long start = out.position()__                out.skip(Integer.BYTES)__                writeOperationNoSize(checksumStreamOutput, op)__                long end = out.position()__                int operationSize = (int) (out.position() - Integer.BYTES - start)__                out.seek(start)__                out.writeInt(operationSize)__                out.seek(end)__                ReleasablePagedBytesReference bytes = out.bytes()__                bytes.writeTo(outStream)__            }_        } finally {_            Releasables.close(out)__        }__    };writes,all,operations,in,the,given,iterable,to,the,given,output,stream,including,the,size,of,the,array,use,link,read,operations,stream,input,to,read,it,back;public,static,void,write,operations,stream,output,out,stream,list,operation,to,write,throws,ioexception,final,releasable,bytes,stream,output,out,new,releasable,bytes,stream,output,big,arrays,try,out,stream,write,int,to,write,size,final,buffered,checksum,stream,output,checksum,stream,output,new,buffered,checksum,stream,output,out,for,operation,op,to,write,out,reset,final,long,start,out,position,out,skip,integer,bytes,write,operation,no,size,checksum,stream,output,op,long,end,out,position,int,operation,size,int,out,position,integer,bytes,start,out,seek,start,out,write,int,operation,size,out,seek,end,releasable,paged,bytes,reference,bytes,out,bytes,bytes,write,to,out,stream,finally,releasables,close,out
Translog -> public static void writeOperations(StreamOutput outStream, List<Operation> toWrite) throws IOException;1525334055;Writes all operations in the given iterable to the given output stream including the size of the array_use {@link #readOperations(StreamInput)} to read it back.;public static void writeOperations(StreamOutput outStream, List<Operation> toWrite) throws IOException {_        final ReleasableBytesStreamOutput out = new ReleasableBytesStreamOutput(BigArrays.NON_RECYCLING_INSTANCE)__        try {_            outStream.writeInt(toWrite.size())__            final BufferedChecksumStreamOutput checksumStreamOutput = new BufferedChecksumStreamOutput(out)__            for (Operation op : toWrite) {_                out.reset()__                final long start = out.position()__                out.skip(Integer.BYTES)__                writeOperationNoSize(checksumStreamOutput, op)__                long end = out.position()__                int operationSize = (int) (out.position() - Integer.BYTES - start)__                out.seek(start)__                out.writeInt(operationSize)__                out.seek(end)__                ReleasablePagedBytesReference bytes = out.bytes()__                bytes.writeTo(outStream)__            }_        } finally {_            Releasables.close(out)__        }__    };writes,all,operations,in,the,given,iterable,to,the,given,output,stream,including,the,size,of,the,array,use,link,read,operations,stream,input,to,read,it,back;public,static,void,write,operations,stream,output,out,stream,list,operation,to,write,throws,ioexception,final,releasable,bytes,stream,output,out,new,releasable,bytes,stream,output,big,arrays,try,out,stream,write,int,to,write,size,final,buffered,checksum,stream,output,checksum,stream,output,new,buffered,checksum,stream,output,out,for,operation,op,to,write,out,reset,final,long,start,out,position,out,skip,integer,bytes,write,operation,no,size,checksum,stream,output,op,long,end,out,position,int,operation,size,int,out,position,integer,bytes,start,out,seek,start,out,write,int,operation,size,out,seek,end,releasable,paged,bytes,reference,bytes,out,bytes,bytes,write,to,out,stream,finally,releasables,close,out
Translog -> public static void writeOperations(StreamOutput outStream, List<Operation> toWrite) throws IOException;1528706846;Writes all operations in the given iterable to the given output stream including the size of the array_use {@link #readOperations(StreamInput)} to read it back.;public static void writeOperations(StreamOutput outStream, List<Operation> toWrite) throws IOException {_        final ReleasableBytesStreamOutput out = new ReleasableBytesStreamOutput(BigArrays.NON_RECYCLING_INSTANCE)__        try {_            outStream.writeInt(toWrite.size())__            final BufferedChecksumStreamOutput checksumStreamOutput = new BufferedChecksumStreamOutput(out)__            for (Operation op : toWrite) {_                out.reset()__                final long start = out.position()__                out.skip(Integer.BYTES)__                writeOperationNoSize(checksumStreamOutput, op)__                long end = out.position()__                int operationSize = (int) (out.position() - Integer.BYTES - start)__                out.seek(start)__                out.writeInt(operationSize)__                out.seek(end)__                ReleasablePagedBytesReference bytes = out.bytes()__                bytes.writeTo(outStream)__            }_        } finally {_            Releasables.close(out)__        }__    };writes,all,operations,in,the,given,iterable,to,the,given,output,stream,including,the,size,of,the,array,use,link,read,operations,stream,input,to,read,it,back;public,static,void,write,operations,stream,output,out,stream,list,operation,to,write,throws,ioexception,final,releasable,bytes,stream,output,out,new,releasable,bytes,stream,output,big,arrays,try,out,stream,write,int,to,write,size,final,buffered,checksum,stream,output,checksum,stream,output,new,buffered,checksum,stream,output,out,for,operation,op,to,write,out,reset,final,long,start,out,position,out,skip,integer,bytes,write,operation,no,size,checksum,stream,output,op,long,end,out,position,int,operation,size,int,out,position,integer,bytes,start,out,seek,start,out,write,int,operation,size,out,seek,end,releasable,paged,bytes,reference,bytes,out,bytes,bytes,write,to,out,stream,finally,releasables,close,out
Translog -> public static void writeOperations(StreamOutput outStream, List<Operation> toWrite) throws IOException;1531910483;Writes all operations in the given iterable to the given output stream including the size of the array_use {@link #readOperations(StreamInput)} to read it back.;public static void writeOperations(StreamOutput outStream, List<Operation> toWrite) throws IOException {_        final ReleasableBytesStreamOutput out = new ReleasableBytesStreamOutput(BigArrays.NON_RECYCLING_INSTANCE)__        try {_            outStream.writeInt(toWrite.size())__            final BufferedChecksumStreamOutput checksumStreamOutput = new BufferedChecksumStreamOutput(out)__            for (Operation op : toWrite) {_                out.reset()__                final long start = out.position()__                out.skip(Integer.BYTES)__                writeOperationNoSize(checksumStreamOutput, op)__                long end = out.position()__                int operationSize = (int) (out.position() - Integer.BYTES - start)__                out.seek(start)__                out.writeInt(operationSize)__                out.seek(end)__                ReleasablePagedBytesReference bytes = out.bytes()__                bytes.writeTo(outStream)__            }_        } finally {_            Releasables.close(out)__        }__    };writes,all,operations,in,the,given,iterable,to,the,given,output,stream,including,the,size,of,the,array,use,link,read,operations,stream,input,to,read,it,back;public,static,void,write,operations,stream,output,out,stream,list,operation,to,write,throws,ioexception,final,releasable,bytes,stream,output,out,new,releasable,bytes,stream,output,big,arrays,try,out,stream,write,int,to,write,size,final,buffered,checksum,stream,output,checksum,stream,output,new,buffered,checksum,stream,output,out,for,operation,op,to,write,out,reset,final,long,start,out,position,out,skip,integer,bytes,write,operation,no,size,checksum,stream,output,op,long,end,out,position,int,operation,size,int,out,position,integer,bytes,start,out,seek,start,out,write,int,operation,size,out,seek,end,releasable,paged,bytes,reference,bytes,out,bytes,bytes,write,to,out,stream,finally,releasables,close,out
Translog -> public static void writeOperations(StreamOutput outStream, List<Operation> toWrite) throws IOException;1533295538;Writes all operations in the given iterable to the given output stream including the size of the array_use {@link #readOperations(StreamInput)} to read it back.;public static void writeOperations(StreamOutput outStream, List<Operation> toWrite) throws IOException {_        final ReleasableBytesStreamOutput out = new ReleasableBytesStreamOutput(BigArrays.NON_RECYCLING_INSTANCE)__        try {_            outStream.writeInt(toWrite.size())__            final BufferedChecksumStreamOutput checksumStreamOutput = new BufferedChecksumStreamOutput(out)__            for (Operation op : toWrite) {_                out.reset()__                final long start = out.position()__                out.skip(Integer.BYTES)__                writeOperationNoSize(checksumStreamOutput, op)__                long end = out.position()__                int operationSize = (int) (out.position() - Integer.BYTES - start)__                out.seek(start)__                out.writeInt(operationSize)__                out.seek(end)__                ReleasablePagedBytesReference bytes = out.bytes()__                bytes.writeTo(outStream)__            }_        } finally {_            Releasables.close(out)__        }__    };writes,all,operations,in,the,given,iterable,to,the,given,output,stream,including,the,size,of,the,array,use,link,read,operations,stream,input,to,read,it,back;public,static,void,write,operations,stream,output,out,stream,list,operation,to,write,throws,ioexception,final,releasable,bytes,stream,output,out,new,releasable,bytes,stream,output,big,arrays,try,out,stream,write,int,to,write,size,final,buffered,checksum,stream,output,checksum,stream,output,new,buffered,checksum,stream,output,out,for,operation,op,to,write,out,reset,final,long,start,out,position,out,skip,integer,bytes,write,operation,no,size,checksum,stream,output,op,long,end,out,position,int,operation,size,int,out,position,integer,bytes,start,out,seek,start,out,write,int,operation,size,out,seek,end,releasable,paged,bytes,reference,bytes,out,bytes,bytes,write,to,out,stream,finally,releasables,close,out
Translog -> public static void writeOperations(StreamOutput outStream, List<Operation> toWrite) throws IOException;1533641732;Writes all operations in the given iterable to the given output stream including the size of the array_use {@link #readOperations(StreamInput, String)} to read it back.;public static void writeOperations(StreamOutput outStream, List<Operation> toWrite) throws IOException {_        final ReleasableBytesStreamOutput out = new ReleasableBytesStreamOutput(BigArrays.NON_RECYCLING_INSTANCE)__        try {_            outStream.writeInt(toWrite.size())__            final BufferedChecksumStreamOutput checksumStreamOutput = new BufferedChecksumStreamOutput(out)__            for (Operation op : toWrite) {_                out.reset()__                final long start = out.position()__                out.skip(Integer.BYTES)__                writeOperationNoSize(checksumStreamOutput, op)__                long end = out.position()__                int operationSize = (int) (out.position() - Integer.BYTES - start)__                out.seek(start)__                out.writeInt(operationSize)__                out.seek(end)__                ReleasablePagedBytesReference bytes = out.bytes()__                bytes.writeTo(outStream)__            }_        } finally {_            Releasables.close(out)__        }__    };writes,all,operations,in,the,given,iterable,to,the,given,output,stream,including,the,size,of,the,array,use,link,read,operations,stream,input,string,to,read,it,back;public,static,void,write,operations,stream,output,out,stream,list,operation,to,write,throws,ioexception,final,releasable,bytes,stream,output,out,new,releasable,bytes,stream,output,big,arrays,try,out,stream,write,int,to,write,size,final,buffered,checksum,stream,output,checksum,stream,output,new,buffered,checksum,stream,output,out,for,operation,op,to,write,out,reset,final,long,start,out,position,out,skip,integer,bytes,write,operation,no,size,checksum,stream,output,op,long,end,out,position,int,operation,size,int,out,position,integer,bytes,start,out,seek,start,out,write,int,operation,size,out,seek,end,releasable,paged,bytes,reference,bytes,out,bytes,bytes,write,to,out,stream,finally,releasables,close,out
Translog -> public static void writeOperations(StreamOutput outStream, List<Operation> toWrite) throws IOException;1534848846;Writes all operations in the given iterable to the given output stream including the size of the array_use {@link #readOperations(StreamInput, String)} to read it back.;public static void writeOperations(StreamOutput outStream, List<Operation> toWrite) throws IOException {_        final ReleasableBytesStreamOutput out = new ReleasableBytesStreamOutput(BigArrays.NON_RECYCLING_INSTANCE)__        try {_            outStream.writeInt(toWrite.size())__            final BufferedChecksumStreamOutput checksumStreamOutput = new BufferedChecksumStreamOutput(out)__            for (Operation op : toWrite) {_                out.reset()__                final long start = out.position()__                out.skip(Integer.BYTES)__                writeOperationNoSize(checksumStreamOutput, op)__                long end = out.position()__                int operationSize = (int) (out.position() - Integer.BYTES - start)__                out.seek(start)__                out.writeInt(operationSize)__                out.seek(end)__                ReleasablePagedBytesReference bytes = out.bytes()__                bytes.writeTo(outStream)__            }_        } finally {_            Releasables.close(out)__        }__    };writes,all,operations,in,the,given,iterable,to,the,given,output,stream,including,the,size,of,the,array,use,link,read,operations,stream,input,string,to,read,it,back;public,static,void,write,operations,stream,output,out,stream,list,operation,to,write,throws,ioexception,final,releasable,bytes,stream,output,out,new,releasable,bytes,stream,output,big,arrays,try,out,stream,write,int,to,write,size,final,buffered,checksum,stream,output,checksum,stream,output,new,buffered,checksum,stream,output,out,for,operation,op,to,write,out,reset,final,long,start,out,position,out,skip,integer,bytes,write,operation,no,size,checksum,stream,output,op,long,end,out,position,int,operation,size,int,out,position,integer,bytes,start,out,seek,start,out,write,int,operation,size,out,seek,end,releasable,paged,bytes,reference,bytes,out,bytes,bytes,write,to,out,stream,finally,releasables,close,out
Translog -> public static void writeOperations(StreamOutput outStream, List<Operation> toWrite) throws IOException;1535046779;Writes all operations in the given iterable to the given output stream including the size of the array_use {@link #readOperations(StreamInput, String)} to read it back.;public static void writeOperations(StreamOutput outStream, List<Operation> toWrite) throws IOException {_        final ReleasableBytesStreamOutput out = new ReleasableBytesStreamOutput(BigArrays.NON_RECYCLING_INSTANCE)__        try {_            outStream.writeInt(toWrite.size())__            final BufferedChecksumStreamOutput checksumStreamOutput = new BufferedChecksumStreamOutput(out)__            for (Operation op : toWrite) {_                out.reset()__                final long start = out.position()__                out.skip(Integer.BYTES)__                writeOperationNoSize(checksumStreamOutput, op)__                long end = out.position()__                int operationSize = (int) (out.position() - Integer.BYTES - start)__                out.seek(start)__                out.writeInt(operationSize)__                out.seek(end)__                ReleasablePagedBytesReference bytes = out.bytes()__                bytes.writeTo(outStream)__            }_        } finally {_            Releasables.close(out)__        }__    };writes,all,operations,in,the,given,iterable,to,the,given,output,stream,including,the,size,of,the,array,use,link,read,operations,stream,input,string,to,read,it,back;public,static,void,write,operations,stream,output,out,stream,list,operation,to,write,throws,ioexception,final,releasable,bytes,stream,output,out,new,releasable,bytes,stream,output,big,arrays,try,out,stream,write,int,to,write,size,final,buffered,checksum,stream,output,checksum,stream,output,new,buffered,checksum,stream,output,out,for,operation,op,to,write,out,reset,final,long,start,out,position,out,skip,integer,bytes,write,operation,no,size,checksum,stream,output,op,long,end,out,position,int,operation,size,int,out,position,integer,bytes,start,out,seek,start,out,write,int,operation,size,out,seek,end,releasable,paged,bytes,reference,bytes,out,bytes,bytes,write,to,out,stream,finally,releasables,close,out
Translog -> public static void writeOperations(StreamOutput outStream, List<Operation> toWrite) throws IOException;1535723122;Writes all operations in the given iterable to the given output stream including the size of the array_use {@link #readOperations(StreamInput, String)} to read it back.;public static void writeOperations(StreamOutput outStream, List<Operation> toWrite) throws IOException {_        final ReleasableBytesStreamOutput out = new ReleasableBytesStreamOutput(BigArrays.NON_RECYCLING_INSTANCE)__        try {_            outStream.writeInt(toWrite.size())__            final BufferedChecksumStreamOutput checksumStreamOutput = new BufferedChecksumStreamOutput(out)__            for (Operation op : toWrite) {_                out.reset()__                final long start = out.position()__                out.skip(Integer.BYTES)__                writeOperationNoSize(checksumStreamOutput, op)__                long end = out.position()__                int operationSize = (int) (out.position() - Integer.BYTES - start)__                out.seek(start)__                out.writeInt(operationSize)__                out.seek(end)__                ReleasablePagedBytesReference bytes = out.bytes()__                bytes.writeTo(outStream)__            }_        } finally {_            Releasables.close(out)__        }__    };writes,all,operations,in,the,given,iterable,to,the,given,output,stream,including,the,size,of,the,array,use,link,read,operations,stream,input,string,to,read,it,back;public,static,void,write,operations,stream,output,out,stream,list,operation,to,write,throws,ioexception,final,releasable,bytes,stream,output,out,new,releasable,bytes,stream,output,big,arrays,try,out,stream,write,int,to,write,size,final,buffered,checksum,stream,output,checksum,stream,output,new,buffered,checksum,stream,output,out,for,operation,op,to,write,out,reset,final,long,start,out,position,out,skip,integer,bytes,write,operation,no,size,checksum,stream,output,op,long,end,out,position,int,operation,size,int,out,position,integer,bytes,start,out,seek,start,out,write,int,operation,size,out,seek,end,releasable,paged,bytes,reference,bytes,out,bytes,bytes,write,to,out,stream,finally,releasables,close,out
Translog -> public static void writeOperations(StreamOutput outStream, List<Operation> toWrite) throws IOException;1537806831;Writes all operations in the given iterable to the given output stream including the size of the array_use {@link #readOperations(StreamInput, String)} to read it back.;public static void writeOperations(StreamOutput outStream, List<Operation> toWrite) throws IOException {_        final ReleasableBytesStreamOutput out = new ReleasableBytesStreamOutput(BigArrays.NON_RECYCLING_INSTANCE)__        try {_            outStream.writeInt(toWrite.size())__            final BufferedChecksumStreamOutput checksumStreamOutput = new BufferedChecksumStreamOutput(out)__            for (Operation op : toWrite) {_                out.reset()__                final long start = out.position()__                out.skip(Integer.BYTES)__                writeOperationNoSize(checksumStreamOutput, op)__                long end = out.position()__                int operationSize = (int) (out.position() - Integer.BYTES - start)__                out.seek(start)__                out.writeInt(operationSize)__                out.seek(end)__                ReleasablePagedBytesReference bytes = out.bytes()__                bytes.writeTo(outStream)__            }_        } finally {_            Releasables.close(out)__        }__    };writes,all,operations,in,the,given,iterable,to,the,given,output,stream,including,the,size,of,the,array,use,link,read,operations,stream,input,string,to,read,it,back;public,static,void,write,operations,stream,output,out,stream,list,operation,to,write,throws,ioexception,final,releasable,bytes,stream,output,out,new,releasable,bytes,stream,output,big,arrays,try,out,stream,write,int,to,write,size,final,buffered,checksum,stream,output,checksum,stream,output,new,buffered,checksum,stream,output,out,for,operation,op,to,write,out,reset,final,long,start,out,position,out,skip,integer,bytes,write,operation,no,size,checksum,stream,output,op,long,end,out,position,int,operation,size,int,out,position,integer,bytes,start,out,seek,start,out,write,int,operation,size,out,seek,end,releasable,paged,bytes,reference,bytes,out,bytes,bytes,write,to,out,stream,finally,releasables,close,out
Translog -> public static void writeOperations(StreamOutput outStream, List<Operation> toWrite) throws IOException;1541592065;Writes all operations in the given iterable to the given output stream including the size of the array_use {@link #readOperations(StreamInput, String)} to read it back.;public static void writeOperations(StreamOutput outStream, List<Operation> toWrite) throws IOException {_        final ReleasableBytesStreamOutput out = new ReleasableBytesStreamOutput(BigArrays.NON_RECYCLING_INSTANCE)__        try {_            outStream.writeInt(toWrite.size())__            final BufferedChecksumStreamOutput checksumStreamOutput = new BufferedChecksumStreamOutput(out)__            for (Operation op : toWrite) {_                out.reset()__                final long start = out.position()__                out.skip(Integer.BYTES)__                writeOperationNoSize(checksumStreamOutput, op)__                long end = out.position()__                int operationSize = (int) (out.position() - Integer.BYTES - start)__                out.seek(start)__                out.writeInt(operationSize)__                out.seek(end)__                ReleasablePagedBytesReference bytes = out.bytes()__                bytes.writeTo(outStream)__            }_        } finally {_            Releasables.close(out)__        }__    };writes,all,operations,in,the,given,iterable,to,the,given,output,stream,including,the,size,of,the,array,use,link,read,operations,stream,input,string,to,read,it,back;public,static,void,write,operations,stream,output,out,stream,list,operation,to,write,throws,ioexception,final,releasable,bytes,stream,output,out,new,releasable,bytes,stream,output,big,arrays,try,out,stream,write,int,to,write,size,final,buffered,checksum,stream,output,checksum,stream,output,new,buffered,checksum,stream,output,out,for,operation,op,to,write,out,reset,final,long,start,out,position,out,skip,integer,bytes,write,operation,no,size,checksum,stream,output,op,long,end,out,position,int,operation,size,int,out,position,integer,bytes,start,out,seek,start,out,write,int,operation,size,out,seek,end,releasable,paged,bytes,reference,bytes,out,bytes,bytes,write,to,out,stream,finally,releasables,close,out
Translog -> public static void writeOperations(StreamOutput outStream, List<Operation> toWrite) throws IOException;1542697754;Writes all operations in the given iterable to the given output stream including the size of the array_use {@link #readOperations(StreamInput, String)} to read it back.;public static void writeOperations(StreamOutput outStream, List<Operation> toWrite) throws IOException {_        final ReleasableBytesStreamOutput out = new ReleasableBytesStreamOutput(BigArrays.NON_RECYCLING_INSTANCE)__        try {_            outStream.writeInt(toWrite.size())__            final BufferedChecksumStreamOutput checksumStreamOutput = new BufferedChecksumStreamOutput(out)__            for (Operation op : toWrite) {_                out.reset()__                final long start = out.position()__                out.skip(Integer.BYTES)__                writeOperationNoSize(checksumStreamOutput, op)__                long end = out.position()__                int operationSize = (int) (out.position() - Integer.BYTES - start)__                out.seek(start)__                out.writeInt(operationSize)__                out.seek(end)__                ReleasablePagedBytesReference bytes = out.bytes()__                bytes.writeTo(outStream)__            }_        } finally {_            Releasables.close(out)__        }__    };writes,all,operations,in,the,given,iterable,to,the,given,output,stream,including,the,size,of,the,array,use,link,read,operations,stream,input,string,to,read,it,back;public,static,void,write,operations,stream,output,out,stream,list,operation,to,write,throws,ioexception,final,releasable,bytes,stream,output,out,new,releasable,bytes,stream,output,big,arrays,try,out,stream,write,int,to,write,size,final,buffered,checksum,stream,output,checksum,stream,output,new,buffered,checksum,stream,output,out,for,operation,op,to,write,out,reset,final,long,start,out,position,out,skip,integer,bytes,write,operation,no,size,checksum,stream,output,op,long,end,out,position,int,operation,size,int,out,position,integer,bytes,start,out,seek,start,out,write,int,operation,size,out,seek,end,releasable,paged,bytes,reference,bytes,out,bytes,bytes,write,to,out,stream,finally,releasables,close,out
Translog -> public static void writeOperations(StreamOutput outStream, List<Operation> toWrite) throws IOException;1542962614;Writes all operations in the given iterable to the given output stream including the size of the array_use {@link #readOperations(StreamInput, String)} to read it back.;public static void writeOperations(StreamOutput outStream, List<Operation> toWrite) throws IOException {_        final ReleasableBytesStreamOutput out = new ReleasableBytesStreamOutput(BigArrays.NON_RECYCLING_INSTANCE)__        try {_            outStream.writeInt(toWrite.size())__            final BufferedChecksumStreamOutput checksumStreamOutput = new BufferedChecksumStreamOutput(out)__            for (Operation op : toWrite) {_                out.reset()__                final long start = out.position()__                out.skip(Integer.BYTES)__                writeOperationNoSize(checksumStreamOutput, op)__                long end = out.position()__                int operationSize = (int) (out.position() - Integer.BYTES - start)__                out.seek(start)__                out.writeInt(operationSize)__                out.seek(end)__                ReleasablePagedBytesReference bytes = out.bytes()__                bytes.writeTo(outStream)__            }_        } finally {_            Releasables.close(out)__        }__    };writes,all,operations,in,the,given,iterable,to,the,given,output,stream,including,the,size,of,the,array,use,link,read,operations,stream,input,string,to,read,it,back;public,static,void,write,operations,stream,output,out,stream,list,operation,to,write,throws,ioexception,final,releasable,bytes,stream,output,out,new,releasable,bytes,stream,output,big,arrays,try,out,stream,write,int,to,write,size,final,buffered,checksum,stream,output,checksum,stream,output,new,buffered,checksum,stream,output,out,for,operation,op,to,write,out,reset,final,long,start,out,position,out,skip,integer,bytes,write,operation,no,size,checksum,stream,output,op,long,end,out,position,int,operation,size,int,out,position,integer,bytes,start,out,seek,start,out,write,int,operation,size,out,seek,end,releasable,paged,bytes,reference,bytes,out,bytes,bytes,write,to,out,stream,finally,releasables,close,out
Translog -> public static void writeOperations(StreamOutput outStream, List<Operation> toWrite) throws IOException;1545236365;Writes all operations in the given iterable to the given output stream including the size of the array_use {@link #readOperations(StreamInput, String)} to read it back.;public static void writeOperations(StreamOutput outStream, List<Operation> toWrite) throws IOException {_        final ReleasableBytesStreamOutput out = new ReleasableBytesStreamOutput(BigArrays.NON_RECYCLING_INSTANCE)__        try {_            outStream.writeInt(toWrite.size())__            final BufferedChecksumStreamOutput checksumStreamOutput = new BufferedChecksumStreamOutput(out)__            for (Operation op : toWrite) {_                out.reset()__                final long start = out.position()__                out.skip(Integer.BYTES)__                writeOperationNoSize(checksumStreamOutput, op)__                long end = out.position()__                int operationSize = (int) (out.position() - Integer.BYTES - start)__                out.seek(start)__                out.writeInt(operationSize)__                out.seek(end)__                ReleasablePagedBytesReference bytes = out.bytes()__                bytes.writeTo(outStream)__            }_        } finally {_            Releasables.close(out)__        }__    };writes,all,operations,in,the,given,iterable,to,the,given,output,stream,including,the,size,of,the,array,use,link,read,operations,stream,input,string,to,read,it,back;public,static,void,write,operations,stream,output,out,stream,list,operation,to,write,throws,ioexception,final,releasable,bytes,stream,output,out,new,releasable,bytes,stream,output,big,arrays,try,out,stream,write,int,to,write,size,final,buffered,checksum,stream,output,checksum,stream,output,new,buffered,checksum,stream,output,out,for,operation,op,to,write,out,reset,final,long,start,out,position,out,skip,integer,bytes,write,operation,no,size,checksum,stream,output,op,long,end,out,position,int,operation,size,int,out,position,integer,bytes,start,out,seek,start,out,write,int,operation,size,out,seek,end,releasable,paged,bytes,reference,bytes,out,bytes,bytes,write,to,out,stream,finally,releasables,close,out
Translog -> public boolean ensureSynced(Location location) throws IOException;1524684173;Ensures that the given location has be synced / written to the underlying storage.__@return Returns <code>true</code> iff this call caused an actual sync operation otherwise <code>false</code>;public boolean ensureSynced(Location location) throws IOException {_        try (ReleasableLock lock = readLock.acquire()) {_            if (location.generation == current.getGeneration()) { _                ensureOpen()__                return current.syncUpTo(location.translogLocation + location.size)__            }_        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_        return false__    };ensures,that,the,given,location,has,be,synced,written,to,the,underlying,storage,return,returns,code,true,code,iff,this,call,caused,an,actual,sync,operation,otherwise,code,false,code;public,boolean,ensure,synced,location,location,throws,ioexception,try,releasable,lock,lock,read,lock,acquire,if,location,generation,current,get,generation,ensure,open,return,current,sync,up,to,location,translog,location,location,size,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex,return,false
Translog -> public boolean ensureSynced(Location location) throws IOException;1525334055;Ensures that the given location has be synced / written to the underlying storage.__@return Returns <code>true</code> iff this call caused an actual sync operation otherwise <code>false</code>;public boolean ensureSynced(Location location) throws IOException {_        try (ReleasableLock lock = readLock.acquire()) {_            if (location.generation == current.getGeneration()) { _                ensureOpen()__                return current.syncUpTo(location.translogLocation + location.size)__            }_        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_        return false__    };ensures,that,the,given,location,has,be,synced,written,to,the,underlying,storage,return,returns,code,true,code,iff,this,call,caused,an,actual,sync,operation,otherwise,code,false,code;public,boolean,ensure,synced,location,location,throws,ioexception,try,releasable,lock,lock,read,lock,acquire,if,location,generation,current,get,generation,ensure,open,return,current,sync,up,to,location,translog,location,location,size,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex,return,false
Translog -> public boolean ensureSynced(Location location) throws IOException;1528706846;Ensures that the given location has be synced / written to the underlying storage.__@return Returns <code>true</code> iff this call caused an actual sync operation otherwise <code>false</code>;public boolean ensureSynced(Location location) throws IOException {_        try (ReleasableLock lock = readLock.acquire()) {_            if (location.generation == current.getGeneration()) { _                ensureOpen()__                return current.syncUpTo(location.translogLocation + location.size)__            }_        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_        return false__    };ensures,that,the,given,location,has,be,synced,written,to,the,underlying,storage,return,returns,code,true,code,iff,this,call,caused,an,actual,sync,operation,otherwise,code,false,code;public,boolean,ensure,synced,location,location,throws,ioexception,try,releasable,lock,lock,read,lock,acquire,if,location,generation,current,get,generation,ensure,open,return,current,sync,up,to,location,translog,location,location,size,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex,return,false
Translog -> public boolean ensureSynced(Location location) throws IOException;1531910483;Ensures that the given location has be synced / written to the underlying storage.__@return Returns <code>true</code> iff this call caused an actual sync operation otherwise <code>false</code>;public boolean ensureSynced(Location location) throws IOException {_        try (ReleasableLock lock = readLock.acquire()) {_            if (location.generation == current.getGeneration()) { _                ensureOpen()__                return current.syncUpTo(location.translogLocation + location.size)__            }_        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_        return false__    };ensures,that,the,given,location,has,be,synced,written,to,the,underlying,storage,return,returns,code,true,code,iff,this,call,caused,an,actual,sync,operation,otherwise,code,false,code;public,boolean,ensure,synced,location,location,throws,ioexception,try,releasable,lock,lock,read,lock,acquire,if,location,generation,current,get,generation,ensure,open,return,current,sync,up,to,location,translog,location,location,size,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex,return,false
Translog -> public boolean ensureSynced(Location location) throws IOException;1533295538;Ensures that the given location has be synced / written to the underlying storage.__@return Returns <code>true</code> iff this call caused an actual sync operation otherwise <code>false</code>;public boolean ensureSynced(Location location) throws IOException {_        try (ReleasableLock lock = readLock.acquire()) {_            if (location.generation == current.getGeneration()) { _                ensureOpen()__                return current.syncUpTo(location.translogLocation + location.size)__            }_        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_        return false__    };ensures,that,the,given,location,has,be,synced,written,to,the,underlying,storage,return,returns,code,true,code,iff,this,call,caused,an,actual,sync,operation,otherwise,code,false,code;public,boolean,ensure,synced,location,location,throws,ioexception,try,releasable,lock,lock,read,lock,acquire,if,location,generation,current,get,generation,ensure,open,return,current,sync,up,to,location,translog,location,location,size,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex,return,false
Translog -> public boolean ensureSynced(Location location) throws IOException;1533641732;Ensures that the given location has be synced / written to the underlying storage.__@return Returns <code>true</code> iff this call caused an actual sync operation otherwise <code>false</code>;public boolean ensureSynced(Location location) throws IOException {_        try (ReleasableLock lock = readLock.acquire()) {_            if (location.generation == current.getGeneration()) { _                ensureOpen()__                return current.syncUpTo(location.translogLocation + location.size)__            }_        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_        return false__    };ensures,that,the,given,location,has,be,synced,written,to,the,underlying,storage,return,returns,code,true,code,iff,this,call,caused,an,actual,sync,operation,otherwise,code,false,code;public,boolean,ensure,synced,location,location,throws,ioexception,try,releasable,lock,lock,read,lock,acquire,if,location,generation,current,get,generation,ensure,open,return,current,sync,up,to,location,translog,location,location,size,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex,return,false
Translog -> public boolean ensureSynced(Location location) throws IOException;1534848846;Ensures that the given location has be synced / written to the underlying storage.__@return Returns <code>true</code> iff this call caused an actual sync operation otherwise <code>false</code>;public boolean ensureSynced(Location location) throws IOException {_        try (ReleasableLock lock = readLock.acquire()) {_            if (location.generation == current.getGeneration()) { _                ensureOpen()__                return current.syncUpTo(location.translogLocation + location.size)__            }_        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_        return false__    };ensures,that,the,given,location,has,be,synced,written,to,the,underlying,storage,return,returns,code,true,code,iff,this,call,caused,an,actual,sync,operation,otherwise,code,false,code;public,boolean,ensure,synced,location,location,throws,ioexception,try,releasable,lock,lock,read,lock,acquire,if,location,generation,current,get,generation,ensure,open,return,current,sync,up,to,location,translog,location,location,size,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex,return,false
Translog -> public boolean ensureSynced(Location location) throws IOException;1535046779;Ensures that the given location has be synced / written to the underlying storage.__@return Returns <code>true</code> iff this call caused an actual sync operation otherwise <code>false</code>;public boolean ensureSynced(Location location) throws IOException {_        try (ReleasableLock lock = readLock.acquire()) {_            if (location.generation == current.getGeneration()) { _                ensureOpen()__                return current.syncUpTo(location.translogLocation + location.size)__            }_        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_        return false__    };ensures,that,the,given,location,has,be,synced,written,to,the,underlying,storage,return,returns,code,true,code,iff,this,call,caused,an,actual,sync,operation,otherwise,code,false,code;public,boolean,ensure,synced,location,location,throws,ioexception,try,releasable,lock,lock,read,lock,acquire,if,location,generation,current,get,generation,ensure,open,return,current,sync,up,to,location,translog,location,location,size,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex,return,false
Translog -> public boolean ensureSynced(Location location) throws IOException;1535723122;Ensures that the given location has be synced / written to the underlying storage.__@return Returns <code>true</code> iff this call caused an actual sync operation otherwise <code>false</code>;public boolean ensureSynced(Location location) throws IOException {_        try (ReleasableLock lock = readLock.acquire()) {_            if (location.generation == current.getGeneration()) { _                ensureOpen()__                return current.syncUpTo(location.translogLocation + location.size)__            }_        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_        return false__    };ensures,that,the,given,location,has,be,synced,written,to,the,underlying,storage,return,returns,code,true,code,iff,this,call,caused,an,actual,sync,operation,otherwise,code,false,code;public,boolean,ensure,synced,location,location,throws,ioexception,try,releasable,lock,lock,read,lock,acquire,if,location,generation,current,get,generation,ensure,open,return,current,sync,up,to,location,translog,location,location,size,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex,return,false
Translog -> public boolean ensureSynced(Location location) throws IOException;1537806831;Ensures that the given location has be synced / written to the underlying storage.__@return Returns <code>true</code> iff this call caused an actual sync operation otherwise <code>false</code>;public boolean ensureSynced(Location location) throws IOException {_        try (ReleasableLock lock = readLock.acquire()) {_            if (location.generation == current.getGeneration()) { _                ensureOpen()__                return current.syncUpTo(location.translogLocation + location.size)__            }_        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_        return false__    };ensures,that,the,given,location,has,be,synced,written,to,the,underlying,storage,return,returns,code,true,code,iff,this,call,caused,an,actual,sync,operation,otherwise,code,false,code;public,boolean,ensure,synced,location,location,throws,ioexception,try,releasable,lock,lock,read,lock,acquire,if,location,generation,current,get,generation,ensure,open,return,current,sync,up,to,location,translog,location,location,size,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex,return,false
Translog -> public boolean ensureSynced(Location location) throws IOException;1541592065;Ensures that the given location has be synced / written to the underlying storage.__@return Returns <code>true</code> iff this call caused an actual sync operation otherwise <code>false</code>;public boolean ensureSynced(Location location) throws IOException {_        try (ReleasableLock lock = readLock.acquire()) {_            if (location.generation == current.getGeneration()) { _                ensureOpen()__                return current.syncUpTo(location.translogLocation + location.size)__            }_        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_        return false__    };ensures,that,the,given,location,has,be,synced,written,to,the,underlying,storage,return,returns,code,true,code,iff,this,call,caused,an,actual,sync,operation,otherwise,code,false,code;public,boolean,ensure,synced,location,location,throws,ioexception,try,releasable,lock,lock,read,lock,acquire,if,location,generation,current,get,generation,ensure,open,return,current,sync,up,to,location,translog,location,location,size,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex,return,false
Translog -> public boolean ensureSynced(Location location) throws IOException;1542697754;Ensures that the given location has be synced / written to the underlying storage.__@return Returns <code>true</code> iff this call caused an actual sync operation otherwise <code>false</code>;public boolean ensureSynced(Location location) throws IOException {_        try (ReleasableLock lock = readLock.acquire()) {_            if (location.generation == current.getGeneration()) { _                ensureOpen()__                return current.syncUpTo(location.translogLocation + location.size)__            }_        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_        return false__    };ensures,that,the,given,location,has,be,synced,written,to,the,underlying,storage,return,returns,code,true,code,iff,this,call,caused,an,actual,sync,operation,otherwise,code,false,code;public,boolean,ensure,synced,location,location,throws,ioexception,try,releasable,lock,lock,read,lock,acquire,if,location,generation,current,get,generation,ensure,open,return,current,sync,up,to,location,translog,location,location,size,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex,return,false
Translog -> public boolean ensureSynced(Location location) throws IOException;1542962614;Ensures that the given location has be synced / written to the underlying storage.__@return Returns <code>true</code> iff this call caused an actual sync operation otherwise <code>false</code>;public boolean ensureSynced(Location location) throws IOException {_        try (ReleasableLock lock = readLock.acquire()) {_            if (location.generation == current.getGeneration()) { _                ensureOpen()__                return current.syncUpTo(location.translogLocation + location.size)__            }_        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_        return false__    };ensures,that,the,given,location,has,be,synced,written,to,the,underlying,storage,return,returns,code,true,code,iff,this,call,caused,an,actual,sync,operation,otherwise,code,false,code;public,boolean,ensure,synced,location,location,throws,ioexception,try,releasable,lock,lock,read,lock,acquire,if,location,generation,current,get,generation,ensure,open,return,current,sync,up,to,location,translog,location,location,size,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex,return,false
Translog -> public boolean ensureSynced(Location location) throws IOException;1545236365;Ensures that the given location has be synced / written to the underlying storage.__@return Returns <code>true</code> iff this call caused an actual sync operation otherwise <code>false</code>;public boolean ensureSynced(Location location) throws IOException {_        try (ReleasableLock lock = readLock.acquire()) {_            if (location.generation == current.getGeneration()) { _                ensureOpen()__                return current.syncUpTo(location.translogLocation + location.size)__            }_        } catch (final Exception ex) {_            closeOnTragicEvent(ex)__            throw ex__        }_        return false__    };ensures,that,the,given,location,has,be,synced,written,to,the,underlying,storage,return,returns,code,true,code,iff,this,call,caused,an,actual,sync,operation,otherwise,code,false,code;public,boolean,ensure,synced,location,location,throws,ioexception,try,releasable,lock,lock,read,lock,acquire,if,location,generation,current,get,generation,ensure,open,return,current,sync,up,to,location,translog,location,location,size,catch,final,exception,ex,close,on,tragic,event,ex,throw,ex,return,false
Translog -> public boolean isCurrent(TranslogGeneration generation);1524684173;Returns <code>true</code> iff the given generation is the current generation of this translog;public boolean isCurrent(TranslogGeneration generation) {_        try (ReleasableLock lock = writeLock.acquire()) {_            if (generation != null) {_                if (generation.translogUUID.equals(translogUUID) == false) {_                    throw new IllegalArgumentException("commit belongs to a different translog: " + generation.translogUUID + " vs. " + translogUUID)__                }_                return generation.translogFileGeneration == currentFileGeneration()__            }_        }_        return false__    };returns,code,true,code,iff,the,given,generation,is,the,current,generation,of,this,translog;public,boolean,is,current,translog,generation,generation,try,releasable,lock,lock,write,lock,acquire,if,generation,null,if,generation,translog,uuid,equals,translog,uuid,false,throw,new,illegal,argument,exception,commit,belongs,to,a,different,translog,generation,translog,uuid,vs,translog,uuid,return,generation,translog,file,generation,current,file,generation,return,false
Translog -> public boolean isCurrent(TranslogGeneration generation);1525334055;Returns <code>true</code> iff the given generation is the current generation of this translog;public boolean isCurrent(TranslogGeneration generation) {_        try (ReleasableLock lock = writeLock.acquire()) {_            if (generation != null) {_                if (generation.translogUUID.equals(translogUUID) == false) {_                    throw new IllegalArgumentException("commit belongs to a different translog: " + generation.translogUUID + " vs. " + translogUUID)__                }_                return generation.translogFileGeneration == currentFileGeneration()__            }_        }_        return false__    };returns,code,true,code,iff,the,given,generation,is,the,current,generation,of,this,translog;public,boolean,is,current,translog,generation,generation,try,releasable,lock,lock,write,lock,acquire,if,generation,null,if,generation,translog,uuid,equals,translog,uuid,false,throw,new,illegal,argument,exception,commit,belongs,to,a,different,translog,generation,translog,uuid,vs,translog,uuid,return,generation,translog,file,generation,current,file,generation,return,false
Translog -> public boolean isCurrent(TranslogGeneration generation);1528706846;Returns <code>true</code> iff the given generation is the current generation of this translog;public boolean isCurrent(TranslogGeneration generation) {_        try (ReleasableLock lock = writeLock.acquire()) {_            if (generation != null) {_                if (generation.translogUUID.equals(translogUUID) == false) {_                    throw new IllegalArgumentException("commit belongs to a different translog: " + generation.translogUUID + " vs. " + translogUUID)__                }_                return generation.translogFileGeneration == currentFileGeneration()__            }_        }_        return false__    };returns,code,true,code,iff,the,given,generation,is,the,current,generation,of,this,translog;public,boolean,is,current,translog,generation,generation,try,releasable,lock,lock,write,lock,acquire,if,generation,null,if,generation,translog,uuid,equals,translog,uuid,false,throw,new,illegal,argument,exception,commit,belongs,to,a,different,translog,generation,translog,uuid,vs,translog,uuid,return,generation,translog,file,generation,current,file,generation,return,false
Translog -> public boolean isCurrent(TranslogGeneration generation);1531910483;Returns <code>true</code> iff the given generation is the current generation of this translog;public boolean isCurrent(TranslogGeneration generation) {_        try (ReleasableLock lock = writeLock.acquire()) {_            if (generation != null) {_                if (generation.translogUUID.equals(translogUUID) == false) {_                    throw new IllegalArgumentException("commit belongs to a different translog: " + generation.translogUUID + " vs. " + translogUUID)__                }_                return generation.translogFileGeneration == currentFileGeneration()__            }_        }_        return false__    };returns,code,true,code,iff,the,given,generation,is,the,current,generation,of,this,translog;public,boolean,is,current,translog,generation,generation,try,releasable,lock,lock,write,lock,acquire,if,generation,null,if,generation,translog,uuid,equals,translog,uuid,false,throw,new,illegal,argument,exception,commit,belongs,to,a,different,translog,generation,translog,uuid,vs,translog,uuid,return,generation,translog,file,generation,current,file,generation,return,false
Translog -> public boolean isCurrent(TranslogGeneration generation);1533295538;Returns <code>true</code> iff the given generation is the current generation of this translog;public boolean isCurrent(TranslogGeneration generation) {_        try (ReleasableLock lock = writeLock.acquire()) {_            if (generation != null) {_                if (generation.translogUUID.equals(translogUUID) == false) {_                    throw new IllegalArgumentException("commit belongs to a different translog: " + generation.translogUUID + " vs. " + translogUUID)__                }_                return generation.translogFileGeneration == currentFileGeneration()__            }_        }_        return false__    };returns,code,true,code,iff,the,given,generation,is,the,current,generation,of,this,translog;public,boolean,is,current,translog,generation,generation,try,releasable,lock,lock,write,lock,acquire,if,generation,null,if,generation,translog,uuid,equals,translog,uuid,false,throw,new,illegal,argument,exception,commit,belongs,to,a,different,translog,generation,translog,uuid,vs,translog,uuid,return,generation,translog,file,generation,current,file,generation,return,false
Translog -> public boolean isCurrent(TranslogGeneration generation);1533641732;Returns <code>true</code> iff the given generation is the current generation of this translog;public boolean isCurrent(TranslogGeneration generation) {_        try (ReleasableLock lock = writeLock.acquire()) {_            if (generation != null) {_                if (generation.translogUUID.equals(translogUUID) == false) {_                    throw new IllegalArgumentException("commit belongs to a different translog: " + generation.translogUUID + " vs. " + translogUUID)__                }_                return generation.translogFileGeneration == currentFileGeneration()__            }_        }_        return false__    };returns,code,true,code,iff,the,given,generation,is,the,current,generation,of,this,translog;public,boolean,is,current,translog,generation,generation,try,releasable,lock,lock,write,lock,acquire,if,generation,null,if,generation,translog,uuid,equals,translog,uuid,false,throw,new,illegal,argument,exception,commit,belongs,to,a,different,translog,generation,translog,uuid,vs,translog,uuid,return,generation,translog,file,generation,current,file,generation,return,false
Translog -> public boolean isCurrent(TranslogGeneration generation);1534848846;Returns <code>true</code> iff the given generation is the current generation of this translog;public boolean isCurrent(TranslogGeneration generation) {_        try (ReleasableLock lock = writeLock.acquire()) {_            if (generation != null) {_                if (generation.translogUUID.equals(translogUUID) == false) {_                    throw new IllegalArgumentException("commit belongs to a different translog: " + generation.translogUUID + " vs. " + translogUUID)__                }_                return generation.translogFileGeneration == currentFileGeneration()__            }_        }_        return false__    };returns,code,true,code,iff,the,given,generation,is,the,current,generation,of,this,translog;public,boolean,is,current,translog,generation,generation,try,releasable,lock,lock,write,lock,acquire,if,generation,null,if,generation,translog,uuid,equals,translog,uuid,false,throw,new,illegal,argument,exception,commit,belongs,to,a,different,translog,generation,translog,uuid,vs,translog,uuid,return,generation,translog,file,generation,current,file,generation,return,false
Translog -> public boolean isCurrent(TranslogGeneration generation);1535046779;Returns <code>true</code> iff the given generation is the current generation of this translog;public boolean isCurrent(TranslogGeneration generation) {_        try (ReleasableLock lock = writeLock.acquire()) {_            if (generation != null) {_                if (generation.translogUUID.equals(translogUUID) == false) {_                    throw new IllegalArgumentException("commit belongs to a different translog: " + generation.translogUUID + " vs. " + translogUUID)__                }_                return generation.translogFileGeneration == currentFileGeneration()__            }_        }_        return false__    };returns,code,true,code,iff,the,given,generation,is,the,current,generation,of,this,translog;public,boolean,is,current,translog,generation,generation,try,releasable,lock,lock,write,lock,acquire,if,generation,null,if,generation,translog,uuid,equals,translog,uuid,false,throw,new,illegal,argument,exception,commit,belongs,to,a,different,translog,generation,translog,uuid,vs,translog,uuid,return,generation,translog,file,generation,current,file,generation,return,false
Translog -> public boolean isCurrent(TranslogGeneration generation);1535723122;Returns <code>true</code> iff the given generation is the current generation of this translog;public boolean isCurrent(TranslogGeneration generation) {_        try (ReleasableLock lock = writeLock.acquire()) {_            if (generation != null) {_                if (generation.translogUUID.equals(translogUUID) == false) {_                    throw new IllegalArgumentException("commit belongs to a different translog: " + generation.translogUUID + " vs. " + translogUUID)__                }_                return generation.translogFileGeneration == currentFileGeneration()__            }_        }_        return false__    };returns,code,true,code,iff,the,given,generation,is,the,current,generation,of,this,translog;public,boolean,is,current,translog,generation,generation,try,releasable,lock,lock,write,lock,acquire,if,generation,null,if,generation,translog,uuid,equals,translog,uuid,false,throw,new,illegal,argument,exception,commit,belongs,to,a,different,translog,generation,translog,uuid,vs,translog,uuid,return,generation,translog,file,generation,current,file,generation,return,false
Translog -> public boolean isCurrent(TranslogGeneration generation);1537806831;Returns <code>true</code> iff the given generation is the current generation of this translog;public boolean isCurrent(TranslogGeneration generation) {_        try (ReleasableLock lock = writeLock.acquire()) {_            if (generation != null) {_                if (generation.translogUUID.equals(translogUUID) == false) {_                    throw new IllegalArgumentException("commit belongs to a different translog: " + generation.translogUUID + " vs. " + translogUUID)__                }_                return generation.translogFileGeneration == currentFileGeneration()__            }_        }_        return false__    };returns,code,true,code,iff,the,given,generation,is,the,current,generation,of,this,translog;public,boolean,is,current,translog,generation,generation,try,releasable,lock,lock,write,lock,acquire,if,generation,null,if,generation,translog,uuid,equals,translog,uuid,false,throw,new,illegal,argument,exception,commit,belongs,to,a,different,translog,generation,translog,uuid,vs,translog,uuid,return,generation,translog,file,generation,current,file,generation,return,false
Translog -> public boolean isCurrent(TranslogGeneration generation);1541592065;Returns <code>true</code> iff the given generation is the current generation of this translog;public boolean isCurrent(TranslogGeneration generation) {_        try (ReleasableLock lock = writeLock.acquire()) {_            if (generation != null) {_                if (generation.translogUUID.equals(translogUUID) == false) {_                    throw new IllegalArgumentException("commit belongs to a different translog: " + generation.translogUUID + " vs. " + translogUUID)__                }_                return generation.translogFileGeneration == currentFileGeneration()__            }_        }_        return false__    };returns,code,true,code,iff,the,given,generation,is,the,current,generation,of,this,translog;public,boolean,is,current,translog,generation,generation,try,releasable,lock,lock,write,lock,acquire,if,generation,null,if,generation,translog,uuid,equals,translog,uuid,false,throw,new,illegal,argument,exception,commit,belongs,to,a,different,translog,generation,translog,uuid,vs,translog,uuid,return,generation,translog,file,generation,current,file,generation,return,false
Translog -> public boolean isCurrent(TranslogGeneration generation);1542697754;Returns <code>true</code> iff the given generation is the current generation of this translog;public boolean isCurrent(TranslogGeneration generation) {_        try (ReleasableLock lock = writeLock.acquire()) {_            if (generation != null) {_                if (generation.translogUUID.equals(translogUUID) == false) {_                    throw new IllegalArgumentException("commit belongs to a different translog: " +_                        generation.translogUUID + " vs. " + translogUUID)__                }_                return generation.translogFileGeneration == currentFileGeneration()__            }_        }_        return false__    };returns,code,true,code,iff,the,given,generation,is,the,current,generation,of,this,translog;public,boolean,is,current,translog,generation,generation,try,releasable,lock,lock,write,lock,acquire,if,generation,null,if,generation,translog,uuid,equals,translog,uuid,false,throw,new,illegal,argument,exception,commit,belongs,to,a,different,translog,generation,translog,uuid,vs,translog,uuid,return,generation,translog,file,generation,current,file,generation,return,false
Translog -> public boolean isCurrent(TranslogGeneration generation);1542962614;Returns <code>true</code> iff the given generation is the current generation of this translog;public boolean isCurrent(TranslogGeneration generation) {_        try (ReleasableLock lock = writeLock.acquire()) {_            if (generation != null) {_                if (generation.translogUUID.equals(translogUUID) == false) {_                    throw new IllegalArgumentException("commit belongs to a different translog: " +_                        generation.translogUUID + " vs. " + translogUUID)__                }_                return generation.translogFileGeneration == currentFileGeneration()__            }_        }_        return false__    };returns,code,true,code,iff,the,given,generation,is,the,current,generation,of,this,translog;public,boolean,is,current,translog,generation,generation,try,releasable,lock,lock,write,lock,acquire,if,generation,null,if,generation,translog,uuid,equals,translog,uuid,false,throw,new,illegal,argument,exception,commit,belongs,to,a,different,translog,generation,translog,uuid,vs,translog,uuid,return,generation,translog,file,generation,current,file,generation,return,false
Translog -> public boolean isCurrent(TranslogGeneration generation);1545236365;Returns <code>true</code> iff the given generation is the current generation of this translog;public boolean isCurrent(TranslogGeneration generation) {_        try (ReleasableLock lock = writeLock.acquire()) {_            if (generation != null) {_                if (generation.translogUUID.equals(translogUUID) == false) {_                    throw new IllegalArgumentException("commit belongs to a different translog: " +_                        generation.translogUUID + " vs. " + translogUUID)__                }_                return generation.translogFileGeneration == currentFileGeneration()__            }_        }_        return false__    };returns,code,true,code,iff,the,given,generation,is,the,current,generation,of,this,translog;public,boolean,is,current,translog,generation,generation,try,releasable,lock,lock,write,lock,acquire,if,generation,null,if,generation,translog,uuid,equals,translog,uuid,false,throw,new,illegal,argument,exception,commit,belongs,to,a,different,translog,generation,translog,uuid,vs,translog,uuid,return,generation,translog,file,generation,current,file,generation,return,false
Translog -> protected void closeOnTragicEvent(final Exception ex);1534848846;Closes the translog if the current translog writer experienced a tragic exception.__Note that in case this thread closes the translog it must not already be holding a read lock on the translog as it will acquire a_write lock in the course of closing the translog__@param ex if an exception occurs closing the translog, it will be suppressed into the provided exception;protected void closeOnTragicEvent(final Exception ex) {_        _        assert readLock.isHeldByCurrentThread() == false : Thread.currentThread().getName()__        if (tragedy.get() != null) {_            try {_                close()__            } catch (final AlreadyClosedException inner) {_                _            } catch (final Exception inner) {_                assert ex != inner.getCause()__                ex.addSuppressed(inner)__            }_        }_    };closes,the,translog,if,the,current,translog,writer,experienced,a,tragic,exception,note,that,in,case,this,thread,closes,the,translog,it,must,not,already,be,holding,a,read,lock,on,the,translog,as,it,will,acquire,a,write,lock,in,the,course,of,closing,the,translog,param,ex,if,an,exception,occurs,closing,the,translog,it,will,be,suppressed,into,the,provided,exception;protected,void,close,on,tragic,event,final,exception,ex,assert,read,lock,is,held,by,current,thread,false,thread,current,thread,get,name,if,tragedy,get,null,try,close,catch,final,already,closed,exception,inner,catch,final,exception,inner,assert,ex,inner,get,cause,ex,add,suppressed,inner
Translog -> protected void closeOnTragicEvent(final Exception ex);1535046779;Closes the translog if the current translog writer experienced a tragic exception.__Note that in case this thread closes the translog it must not already be holding a read lock on the translog as it will acquire a_write lock in the course of closing the translog__@param ex if an exception occurs closing the translog, it will be suppressed into the provided exception;protected void closeOnTragicEvent(final Exception ex) {_        _        assert readLock.isHeldByCurrentThread() == false : Thread.currentThread().getName()__        if (tragedy.get() != null) {_            try {_                close()__            } catch (final AlreadyClosedException inner) {_                _            } catch (final Exception inner) {_                assert ex != inner.getCause()__                ex.addSuppressed(inner)__            }_        }_    };closes,the,translog,if,the,current,translog,writer,experienced,a,tragic,exception,note,that,in,case,this,thread,closes,the,translog,it,must,not,already,be,holding,a,read,lock,on,the,translog,as,it,will,acquire,a,write,lock,in,the,course,of,closing,the,translog,param,ex,if,an,exception,occurs,closing,the,translog,it,will,be,suppressed,into,the,provided,exception;protected,void,close,on,tragic,event,final,exception,ex,assert,read,lock,is,held,by,current,thread,false,thread,current,thread,get,name,if,tragedy,get,null,try,close,catch,final,already,closed,exception,inner,catch,final,exception,inner,assert,ex,inner,get,cause,ex,add,suppressed,inner
Translog -> protected void closeOnTragicEvent(final Exception ex);1535723122;Closes the translog if the current translog writer experienced a tragic exception.__Note that in case this thread closes the translog it must not already be holding a read lock on the translog as it will acquire a_write lock in the course of closing the translog__@param ex if an exception occurs closing the translog, it will be suppressed into the provided exception;protected void closeOnTragicEvent(final Exception ex) {_        _        assert readLock.isHeldByCurrentThread() == false : Thread.currentThread().getName()__        if (tragedy.get() != null) {_            try {_                close()__            } catch (final AlreadyClosedException inner) {_                _            } catch (final Exception inner) {_                assert ex != inner.getCause()__                ex.addSuppressed(inner)__            }_        }_    };closes,the,translog,if,the,current,translog,writer,experienced,a,tragic,exception,note,that,in,case,this,thread,closes,the,translog,it,must,not,already,be,holding,a,read,lock,on,the,translog,as,it,will,acquire,a,write,lock,in,the,course,of,closing,the,translog,param,ex,if,an,exception,occurs,closing,the,translog,it,will,be,suppressed,into,the,provided,exception;protected,void,close,on,tragic,event,final,exception,ex,assert,read,lock,is,held,by,current,thread,false,thread,current,thread,get,name,if,tragedy,get,null,try,close,catch,final,already,closed,exception,inner,catch,final,exception,inner,assert,ex,inner,get,cause,ex,add,suppressed,inner
Translog -> protected void closeOnTragicEvent(final Exception ex);1537806831;Closes the translog if the current translog writer experienced a tragic exception.__Note that in case this thread closes the translog it must not already be holding a read lock on the translog as it will acquire a_write lock in the course of closing the translog__@param ex if an exception occurs closing the translog, it will be suppressed into the provided exception;protected void closeOnTragicEvent(final Exception ex) {_        _        assert readLock.isHeldByCurrentThread() == false : Thread.currentThread().getName()__        if (tragedy.get() != null) {_            try {_                close()__            } catch (final AlreadyClosedException inner) {_                _            } catch (final Exception inner) {_                assert ex != inner.getCause()__                ex.addSuppressed(inner)__            }_        }_    };closes,the,translog,if,the,current,translog,writer,experienced,a,tragic,exception,note,that,in,case,this,thread,closes,the,translog,it,must,not,already,be,holding,a,read,lock,on,the,translog,as,it,will,acquire,a,write,lock,in,the,course,of,closing,the,translog,param,ex,if,an,exception,occurs,closing,the,translog,it,will,be,suppressed,into,the,provided,exception;protected,void,close,on,tragic,event,final,exception,ex,assert,read,lock,is,held,by,current,thread,false,thread,current,thread,get,name,if,tragedy,get,null,try,close,catch,final,already,closed,exception,inner,catch,final,exception,inner,assert,ex,inner,get,cause,ex,add,suppressed,inner
Translog -> protected void closeOnTragicEvent(final Exception ex);1541592065;Closes the translog if the current translog writer experienced a tragic exception.__Note that in case this thread closes the translog it must not already be holding a read lock on the translog as it will acquire a_write lock in the course of closing the translog__@param ex if an exception occurs closing the translog, it will be suppressed into the provided exception;protected void closeOnTragicEvent(final Exception ex) {_        _        assert readLock.isHeldByCurrentThread() == false : Thread.currentThread().getName()__        if (tragedy.get() != null) {_            try {_                close()__            } catch (final AlreadyClosedException inner) {_                _            } catch (final Exception inner) {_                assert ex != inner.getCause()__                ex.addSuppressed(inner)__            }_        }_    };closes,the,translog,if,the,current,translog,writer,experienced,a,tragic,exception,note,that,in,case,this,thread,closes,the,translog,it,must,not,already,be,holding,a,read,lock,on,the,translog,as,it,will,acquire,a,write,lock,in,the,course,of,closing,the,translog,param,ex,if,an,exception,occurs,closing,the,translog,it,will,be,suppressed,into,the,provided,exception;protected,void,close,on,tragic,event,final,exception,ex,assert,read,lock,is,held,by,current,thread,false,thread,current,thread,get,name,if,tragedy,get,null,try,close,catch,final,already,closed,exception,inner,catch,final,exception,inner,assert,ex,inner,get,cause,ex,add,suppressed,inner
Translog -> protected void closeOnTragicEvent(final Exception ex);1542697754;Closes the translog if the current translog writer experienced a tragic exception.__Note that in case this thread closes the translog it must not already be holding a read lock on the translog as it will acquire a_write lock in the course of closing the translog__@param ex if an exception occurs closing the translog, it will be suppressed into the provided exception;protected void closeOnTragicEvent(final Exception ex) {_        _        assert readLock.isHeldByCurrentThread() == false : Thread.currentThread().getName()__        if (tragedy.get() != null) {_            try {_                close()__            } catch (final AlreadyClosedException inner) {_                _            } catch (final Exception inner) {_                assert ex != inner.getCause()__                ex.addSuppressed(inner)__            }_        }_    };closes,the,translog,if,the,current,translog,writer,experienced,a,tragic,exception,note,that,in,case,this,thread,closes,the,translog,it,must,not,already,be,holding,a,read,lock,on,the,translog,as,it,will,acquire,a,write,lock,in,the,course,of,closing,the,translog,param,ex,if,an,exception,occurs,closing,the,translog,it,will,be,suppressed,into,the,provided,exception;protected,void,close,on,tragic,event,final,exception,ex,assert,read,lock,is,held,by,current,thread,false,thread,current,thread,get,name,if,tragedy,get,null,try,close,catch,final,already,closed,exception,inner,catch,final,exception,inner,assert,ex,inner,get,cause,ex,add,suppressed,inner
Translog -> protected void closeOnTragicEvent(final Exception ex);1542962614;Closes the translog if the current translog writer experienced a tragic exception.__Note that in case this thread closes the translog it must not already be holding a read lock on the translog as it will acquire a_write lock in the course of closing the translog__@param ex if an exception occurs closing the translog, it will be suppressed into the provided exception;protected void closeOnTragicEvent(final Exception ex) {_        _        assert readLock.isHeldByCurrentThread() == false : Thread.currentThread().getName()__        if (tragedy.get() != null) {_            try {_                close()__            } catch (final AlreadyClosedException inner) {_                _            } catch (final Exception inner) {_                assert ex != inner.getCause()__                ex.addSuppressed(inner)__            }_        }_    };closes,the,translog,if,the,current,translog,writer,experienced,a,tragic,exception,note,that,in,case,this,thread,closes,the,translog,it,must,not,already,be,holding,a,read,lock,on,the,translog,as,it,will,acquire,a,write,lock,in,the,course,of,closing,the,translog,param,ex,if,an,exception,occurs,closing,the,translog,it,will,be,suppressed,into,the,provided,exception;protected,void,close,on,tragic,event,final,exception,ex,assert,read,lock,is,held,by,current,thread,false,thread,current,thread,get,name,if,tragedy,get,null,try,close,catch,final,already,closed,exception,inner,catch,final,exception,inner,assert,ex,inner,get,cause,ex,add,suppressed,inner
Translog -> protected void closeOnTragicEvent(final Exception ex);1545236365;Closes the translog if the current translog writer experienced a tragic exception.__Note that in case this thread closes the translog it must not already be holding a read lock on the translog as it will acquire a_write lock in the course of closing the translog__@param ex if an exception occurs closing the translog, it will be suppressed into the provided exception;protected void closeOnTragicEvent(final Exception ex) {_        _        assert readLock.isHeldByCurrentThread() == false : Thread.currentThread().getName()__        if (tragedy.get() != null) {_            try {_                close()__            } catch (final AlreadyClosedException inner) {_                _            } catch (final Exception inner) {_                assert ex != inner.getCause()__                ex.addSuppressed(inner)__            }_        }_    };closes,the,translog,if,the,current,translog,writer,experienced,a,tragic,exception,note,that,in,case,this,thread,closes,the,translog,it,must,not,already,be,holding,a,read,lock,on,the,translog,as,it,will,acquire,a,write,lock,in,the,course,of,closing,the,translog,param,ex,if,an,exception,occurs,closing,the,translog,it,will,be,suppressed,into,the,provided,exception;protected,void,close,on,tragic,event,final,exception,ex,assert,read,lock,is,held,by,current,thread,false,thread,current,thread,get,name,if,tragedy,get,null,try,close,catch,final,already,closed,exception,inner,catch,final,exception,inner,assert,ex,inner,get,cause,ex,add,suppressed,inner
Translog -> public static long parseIdFromFileName(Path translogFile);1524684173;Extracts the translog generation from a file name.__@throws IllegalArgumentException if the path doesn't match the expected pattern.;public static long parseIdFromFileName(Path translogFile) {_        final String fileName = translogFile.getFileName().toString()__        final Matcher matcher = PARSE_STRICT_ID_PATTERN.matcher(fileName)__        if (matcher.matches()) {_            try {_                return Long.parseLong(matcher.group(1))__            } catch (NumberFormatException e) {_                throw new IllegalStateException("number formatting issue in a file that passed PARSE_STRICT_ID_PATTERN: " + fileName + "]", e)__            }_        }_        throw new IllegalArgumentException("can't parse id from file: " + fileName)__    };extracts,the,translog,generation,from,a,file,name,throws,illegal,argument,exception,if,the,path,doesn,t,match,the,expected,pattern;public,static,long,parse,id,from,file,name,path,translog,file,final,string,file,name,translog,file,get,file,name,to,string,final,matcher,matcher,matcher,file,name,if,matcher,matches,try,return,long,parse,long,matcher,group,1,catch,number,format,exception,e,throw,new,illegal,state,exception,number,formatting,issue,in,a,file,that,passed,file,name,e,throw,new,illegal,argument,exception,can,t,parse,id,from,file,file,name
Translog -> public static long parseIdFromFileName(Path translogFile);1525334055;Extracts the translog generation from a file name.__@throws IllegalArgumentException if the path doesn't match the expected pattern.;public static long parseIdFromFileName(Path translogFile) {_        final String fileName = translogFile.getFileName().toString()__        final Matcher matcher = PARSE_STRICT_ID_PATTERN.matcher(fileName)__        if (matcher.matches()) {_            try {_                return Long.parseLong(matcher.group(1))__            } catch (NumberFormatException e) {_                throw new IllegalStateException("number formatting issue in a file that passed PARSE_STRICT_ID_PATTERN: " + fileName + "]", e)__            }_        }_        throw new IllegalArgumentException("can't parse id from file: " + fileName)__    };extracts,the,translog,generation,from,a,file,name,throws,illegal,argument,exception,if,the,path,doesn,t,match,the,expected,pattern;public,static,long,parse,id,from,file,name,path,translog,file,final,string,file,name,translog,file,get,file,name,to,string,final,matcher,matcher,matcher,file,name,if,matcher,matches,try,return,long,parse,long,matcher,group,1,catch,number,format,exception,e,throw,new,illegal,state,exception,number,formatting,issue,in,a,file,that,passed,file,name,e,throw,new,illegal,argument,exception,can,t,parse,id,from,file,file,name
Translog -> public static long parseIdFromFileName(Path translogFile);1528706846;Extracts the translog generation from a file name.__@throws IllegalArgumentException if the path doesn't match the expected pattern.;public static long parseIdFromFileName(Path translogFile) {_        final String fileName = translogFile.getFileName().toString()__        final Matcher matcher = PARSE_STRICT_ID_PATTERN.matcher(fileName)__        if (matcher.matches()) {_            try {_                return Long.parseLong(matcher.group(1))__            } catch (NumberFormatException e) {_                throw new IllegalStateException("number formatting issue in a file that passed PARSE_STRICT_ID_PATTERN: " + fileName + "]", e)__            }_        }_        throw new IllegalArgumentException("can't parse id from file: " + fileName)__    };extracts,the,translog,generation,from,a,file,name,throws,illegal,argument,exception,if,the,path,doesn,t,match,the,expected,pattern;public,static,long,parse,id,from,file,name,path,translog,file,final,string,file,name,translog,file,get,file,name,to,string,final,matcher,matcher,matcher,file,name,if,matcher,matches,try,return,long,parse,long,matcher,group,1,catch,number,format,exception,e,throw,new,illegal,state,exception,number,formatting,issue,in,a,file,that,passed,file,name,e,throw,new,illegal,argument,exception,can,t,parse,id,from,file,file,name
Translog -> public static long parseIdFromFileName(Path translogFile);1531910483;Extracts the translog generation from a file name.__@throws IllegalArgumentException if the path doesn't match the expected pattern.;public static long parseIdFromFileName(Path translogFile) {_        final String fileName = translogFile.getFileName().toString()__        final Matcher matcher = PARSE_STRICT_ID_PATTERN.matcher(fileName)__        if (matcher.matches()) {_            try {_                return Long.parseLong(matcher.group(1))__            } catch (NumberFormatException e) {_                throw new IllegalStateException("number formatting issue in a file that passed PARSE_STRICT_ID_PATTERN: " + fileName + "]", e)__            }_        }_        throw new IllegalArgumentException("can't parse id from file: " + fileName)__    };extracts,the,translog,generation,from,a,file,name,throws,illegal,argument,exception,if,the,path,doesn,t,match,the,expected,pattern;public,static,long,parse,id,from,file,name,path,translog,file,final,string,file,name,translog,file,get,file,name,to,string,final,matcher,matcher,matcher,file,name,if,matcher,matches,try,return,long,parse,long,matcher,group,1,catch,number,format,exception,e,throw,new,illegal,state,exception,number,formatting,issue,in,a,file,that,passed,file,name,e,throw,new,illegal,argument,exception,can,t,parse,id,from,file,file,name
Translog -> public static long parseIdFromFileName(Path translogFile);1533295538;Extracts the translog generation from a file name.__@throws IllegalArgumentException if the path doesn't match the expected pattern.;public static long parseIdFromFileName(Path translogFile) {_        final String fileName = translogFile.getFileName().toString()__        final Matcher matcher = PARSE_STRICT_ID_PATTERN.matcher(fileName)__        if (matcher.matches()) {_            try {_                return Long.parseLong(matcher.group(1))__            } catch (NumberFormatException e) {_                throw new IllegalStateException("number formatting issue in a file that passed PARSE_STRICT_ID_PATTERN: " + fileName + "]", e)__            }_        }_        throw new IllegalArgumentException("can't parse id from file: " + fileName)__    };extracts,the,translog,generation,from,a,file,name,throws,illegal,argument,exception,if,the,path,doesn,t,match,the,expected,pattern;public,static,long,parse,id,from,file,name,path,translog,file,final,string,file,name,translog,file,get,file,name,to,string,final,matcher,matcher,matcher,file,name,if,matcher,matches,try,return,long,parse,long,matcher,group,1,catch,number,format,exception,e,throw,new,illegal,state,exception,number,formatting,issue,in,a,file,that,passed,file,name,e,throw,new,illegal,argument,exception,can,t,parse,id,from,file,file,name
Translog -> public static long parseIdFromFileName(Path translogFile);1533641732;Extracts the translog generation from a file name.__@throws IllegalArgumentException if the path doesn't match the expected pattern.;public static long parseIdFromFileName(Path translogFile) {_        final String fileName = translogFile.getFileName().toString()__        final Matcher matcher = PARSE_STRICT_ID_PATTERN.matcher(fileName)__        if (matcher.matches()) {_            try {_                return Long.parseLong(matcher.group(1))__            } catch (NumberFormatException e) {_                throw new IllegalStateException("number formatting issue in a file that passed PARSE_STRICT_ID_PATTERN: " + fileName + "]", e)__            }_        }_        throw new IllegalArgumentException("can't parse id from file: " + fileName)__    };extracts,the,translog,generation,from,a,file,name,throws,illegal,argument,exception,if,the,path,doesn,t,match,the,expected,pattern;public,static,long,parse,id,from,file,name,path,translog,file,final,string,file,name,translog,file,get,file,name,to,string,final,matcher,matcher,matcher,file,name,if,matcher,matches,try,return,long,parse,long,matcher,group,1,catch,number,format,exception,e,throw,new,illegal,state,exception,number,formatting,issue,in,a,file,that,passed,file,name,e,throw,new,illegal,argument,exception,can,t,parse,id,from,file,file,name
Translog -> public static long parseIdFromFileName(Path translogFile);1534848846;Extracts the translog generation from a file name.__@throws IllegalArgumentException if the path doesn't match the expected pattern.;public static long parseIdFromFileName(Path translogFile) {_        final String fileName = translogFile.getFileName().toString()__        final Matcher matcher = PARSE_STRICT_ID_PATTERN.matcher(fileName)__        if (matcher.matches()) {_            try {_                return Long.parseLong(matcher.group(1))__            } catch (NumberFormatException e) {_                throw new IllegalStateException("number formatting issue in a file that passed PARSE_STRICT_ID_PATTERN: " + fileName + "]", e)__            }_        }_        throw new IllegalArgumentException("can't parse id from file: " + fileName)__    };extracts,the,translog,generation,from,a,file,name,throws,illegal,argument,exception,if,the,path,doesn,t,match,the,expected,pattern;public,static,long,parse,id,from,file,name,path,translog,file,final,string,file,name,translog,file,get,file,name,to,string,final,matcher,matcher,matcher,file,name,if,matcher,matches,try,return,long,parse,long,matcher,group,1,catch,number,format,exception,e,throw,new,illegal,state,exception,number,formatting,issue,in,a,file,that,passed,file,name,e,throw,new,illegal,argument,exception,can,t,parse,id,from,file,file,name
Translog -> public static long parseIdFromFileName(Path translogFile);1535046779;Extracts the translog generation from a file name.__@throws IllegalArgumentException if the path doesn't match the expected pattern.;public static long parseIdFromFileName(Path translogFile) {_        final String fileName = translogFile.getFileName().toString()__        final Matcher matcher = PARSE_STRICT_ID_PATTERN.matcher(fileName)__        if (matcher.matches()) {_            try {_                return Long.parseLong(matcher.group(1))__            } catch (NumberFormatException e) {_                throw new IllegalStateException("number formatting issue in a file that passed PARSE_STRICT_ID_PATTERN: " + fileName + "]", e)__            }_        }_        throw new IllegalArgumentException("can't parse id from file: " + fileName)__    };extracts,the,translog,generation,from,a,file,name,throws,illegal,argument,exception,if,the,path,doesn,t,match,the,expected,pattern;public,static,long,parse,id,from,file,name,path,translog,file,final,string,file,name,translog,file,get,file,name,to,string,final,matcher,matcher,matcher,file,name,if,matcher,matches,try,return,long,parse,long,matcher,group,1,catch,number,format,exception,e,throw,new,illegal,state,exception,number,formatting,issue,in,a,file,that,passed,file,name,e,throw,new,illegal,argument,exception,can,t,parse,id,from,file,file,name
Translog -> public static long parseIdFromFileName(Path translogFile);1535723122;Extracts the translog generation from a file name.__@throws IllegalArgumentException if the path doesn't match the expected pattern.;public static long parseIdFromFileName(Path translogFile) {_        final String fileName = translogFile.getFileName().toString()__        final Matcher matcher = PARSE_STRICT_ID_PATTERN.matcher(fileName)__        if (matcher.matches()) {_            try {_                return Long.parseLong(matcher.group(1))__            } catch (NumberFormatException e) {_                throw new IllegalStateException("number formatting issue in a file that passed PARSE_STRICT_ID_PATTERN: " + fileName + "]", e)__            }_        }_        throw new IllegalArgumentException("can't parse id from file: " + fileName)__    };extracts,the,translog,generation,from,a,file,name,throws,illegal,argument,exception,if,the,path,doesn,t,match,the,expected,pattern;public,static,long,parse,id,from,file,name,path,translog,file,final,string,file,name,translog,file,get,file,name,to,string,final,matcher,matcher,matcher,file,name,if,matcher,matches,try,return,long,parse,long,matcher,group,1,catch,number,format,exception,e,throw,new,illegal,state,exception,number,formatting,issue,in,a,file,that,passed,file,name,e,throw,new,illegal,argument,exception,can,t,parse,id,from,file,file,name
Translog -> public static long parseIdFromFileName(Path translogFile);1537806831;Extracts the translog generation from a file name.__@throws IllegalArgumentException if the path doesn't match the expected pattern.;public static long parseIdFromFileName(Path translogFile) {_        final String fileName = translogFile.getFileName().toString()__        final Matcher matcher = PARSE_STRICT_ID_PATTERN.matcher(fileName)__        if (matcher.matches()) {_            try {_                return Long.parseLong(matcher.group(1))__            } catch (NumberFormatException e) {_                throw new IllegalStateException("number formatting issue in a file that passed PARSE_STRICT_ID_PATTERN: " + fileName + "]", e)__            }_        }_        throw new IllegalArgumentException("can't parse id from file: " + fileName)__    };extracts,the,translog,generation,from,a,file,name,throws,illegal,argument,exception,if,the,path,doesn,t,match,the,expected,pattern;public,static,long,parse,id,from,file,name,path,translog,file,final,string,file,name,translog,file,get,file,name,to,string,final,matcher,matcher,matcher,file,name,if,matcher,matches,try,return,long,parse,long,matcher,group,1,catch,number,format,exception,e,throw,new,illegal,state,exception,number,formatting,issue,in,a,file,that,passed,file,name,e,throw,new,illegal,argument,exception,can,t,parse,id,from,file,file,name
Translog -> public static long parseIdFromFileName(Path translogFile);1541592065;Extracts the translog generation from a file name.__@throws IllegalArgumentException if the path doesn't match the expected pattern.;public static long parseIdFromFileName(Path translogFile) {_        final String fileName = translogFile.getFileName().toString()__        final Matcher matcher = PARSE_STRICT_ID_PATTERN.matcher(fileName)__        if (matcher.matches()) {_            try {_                return Long.parseLong(matcher.group(1))__            } catch (NumberFormatException e) {_                throw new IllegalStateException("number formatting issue in a file that passed PARSE_STRICT_ID_PATTERN: " + fileName + "]", e)__            }_        }_        throw new IllegalArgumentException("can't parse id from file: " + fileName)__    };extracts,the,translog,generation,from,a,file,name,throws,illegal,argument,exception,if,the,path,doesn,t,match,the,expected,pattern;public,static,long,parse,id,from,file,name,path,translog,file,final,string,file,name,translog,file,get,file,name,to,string,final,matcher,matcher,matcher,file,name,if,matcher,matches,try,return,long,parse,long,matcher,group,1,catch,number,format,exception,e,throw,new,illegal,state,exception,number,formatting,issue,in,a,file,that,passed,file,name,e,throw,new,illegal,argument,exception,can,t,parse,id,from,file,file,name
Translog -> public static long parseIdFromFileName(Path translogFile);1542697754;Extracts the translog generation from a file name.__@throws IllegalArgumentException if the path doesn't match the expected pattern.;public static long parseIdFromFileName(Path translogFile) {_        final String fileName = translogFile.getFileName().toString()__        final Matcher matcher = PARSE_STRICT_ID_PATTERN.matcher(fileName)__        if (matcher.matches()) {_            try {_                return Long.parseLong(matcher.group(1))__            } catch (NumberFormatException e) {_                throw new IllegalStateException("number formatting issue in a file that passed PARSE_STRICT_ID_PATTERN: " +_                    fileName + "]", e)__            }_        }_        throw new IllegalArgumentException("can't parse id from file: " + fileName)__    };extracts,the,translog,generation,from,a,file,name,throws,illegal,argument,exception,if,the,path,doesn,t,match,the,expected,pattern;public,static,long,parse,id,from,file,name,path,translog,file,final,string,file,name,translog,file,get,file,name,to,string,final,matcher,matcher,matcher,file,name,if,matcher,matches,try,return,long,parse,long,matcher,group,1,catch,number,format,exception,e,throw,new,illegal,state,exception,number,formatting,issue,in,a,file,that,passed,file,name,e,throw,new,illegal,argument,exception,can,t,parse,id,from,file,file,name
Translog -> public static long parseIdFromFileName(Path translogFile);1542962614;Extracts the translog generation from a file name.__@throws IllegalArgumentException if the path doesn't match the expected pattern.;public static long parseIdFromFileName(Path translogFile) {_        final String fileName = translogFile.getFileName().toString()__        final Matcher matcher = PARSE_STRICT_ID_PATTERN.matcher(fileName)__        if (matcher.matches()) {_            try {_                return Long.parseLong(matcher.group(1))__            } catch (NumberFormatException e) {_                throw new IllegalStateException("number formatting issue in a file that passed PARSE_STRICT_ID_PATTERN: " +_                    fileName + "]", e)__            }_        }_        throw new IllegalArgumentException("can't parse id from file: " + fileName)__    };extracts,the,translog,generation,from,a,file,name,throws,illegal,argument,exception,if,the,path,doesn,t,match,the,expected,pattern;public,static,long,parse,id,from,file,name,path,translog,file,final,string,file,name,translog,file,get,file,name,to,string,final,matcher,matcher,matcher,file,name,if,matcher,matches,try,return,long,parse,long,matcher,group,1,catch,number,format,exception,e,throw,new,illegal,state,exception,number,formatting,issue,in,a,file,that,passed,file,name,e,throw,new,illegal,argument,exception,can,t,parse,id,from,file,file,name
Translog -> public static long parseIdFromFileName(Path translogFile);1545236365;Extracts the translog generation from a file name.__@throws IllegalArgumentException if the path doesn't match the expected pattern.;public static long parseIdFromFileName(Path translogFile) {_        final String fileName = translogFile.getFileName().toString()__        final Matcher matcher = PARSE_STRICT_ID_PATTERN.matcher(fileName)__        if (matcher.matches()) {_            try {_                return Long.parseLong(matcher.group(1))__            } catch (NumberFormatException e) {_                throw new IllegalStateException("number formatting issue in a file that passed PARSE_STRICT_ID_PATTERN: " +_                    fileName + "]", e)__            }_        }_        throw new IllegalArgumentException("can't parse id from file: " + fileName)__    };extracts,the,translog,generation,from,a,file,name,throws,illegal,argument,exception,if,the,path,doesn,t,match,the,expected,pattern;public,static,long,parse,id,from,file,name,path,translog,file,final,string,file,name,translog,file,get,file,name,to,string,final,matcher,matcher,matcher,file,name,if,matcher,matches,try,return,long,parse,long,matcher,group,1,catch,number,format,exception,e,throw,new,illegal,state,exception,number,formatting,issue,in,a,file,that,passed,file,name,e,throw,new,illegal,argument,exception,can,t,parse,id,from,file,file,name
Translog -> public Snapshot newSnapshot() throws IOException;1524684173;Snapshots the current transaction log allowing to safely iterate over the snapshot._Snapshots are fixed in time and will not be updated with future operations.;public Snapshot newSnapshot() throws IOException {_        try (ReleasableLock ignored = readLock.acquire()) {_            return newSnapshotFromGen(getMinFileGeneration())__        }_    };snapshots,the,current,transaction,log,allowing,to,safely,iterate,over,the,snapshot,snapshots,are,fixed,in,time,and,will,not,be,updated,with,future,operations;public,snapshot,new,snapshot,throws,ioexception,try,releasable,lock,ignored,read,lock,acquire,return,new,snapshot,from,gen,get,min,file,generation
Translog -> public Snapshot newSnapshot() throws IOException;1525334055;Snapshots the current transaction log allowing to safely iterate over the snapshot._Snapshots are fixed in time and will not be updated with future operations.;public Snapshot newSnapshot() throws IOException {_        try (ReleasableLock ignored = readLock.acquire()) {_            return newSnapshotFromGen(getMinFileGeneration())__        }_    };snapshots,the,current,transaction,log,allowing,to,safely,iterate,over,the,snapshot,snapshots,are,fixed,in,time,and,will,not,be,updated,with,future,operations;public,snapshot,new,snapshot,throws,ioexception,try,releasable,lock,ignored,read,lock,acquire,return,new,snapshot,from,gen,get,min,file,generation
Translog -> public Snapshot newSnapshot() throws IOException;1528706846;Snapshots the current transaction log allowing to safely iterate over the snapshot._Snapshots are fixed in time and will not be updated with future operations.;public Snapshot newSnapshot() throws IOException {_        try (ReleasableLock ignored = readLock.acquire()) {_            return newSnapshotFromGen(getMinFileGeneration())__        }_    };snapshots,the,current,transaction,log,allowing,to,safely,iterate,over,the,snapshot,snapshots,are,fixed,in,time,and,will,not,be,updated,with,future,operations;public,snapshot,new,snapshot,throws,ioexception,try,releasable,lock,ignored,read,lock,acquire,return,new,snapshot,from,gen,get,min,file,generation
Translog -> public Snapshot newSnapshot() throws IOException;1531910483;Snapshots the current transaction log allowing to safely iterate over the snapshot._Snapshots are fixed in time and will not be updated with future operations.;public Snapshot newSnapshot() throws IOException {_        try (ReleasableLock ignored = readLock.acquire()) {_            return newSnapshotFromGen(getMinFileGeneration())__        }_    };snapshots,the,current,transaction,log,allowing,to,safely,iterate,over,the,snapshot,snapshots,are,fixed,in,time,and,will,not,be,updated,with,future,operations;public,snapshot,new,snapshot,throws,ioexception,try,releasable,lock,ignored,read,lock,acquire,return,new,snapshot,from,gen,get,min,file,generation
Translog -> public Snapshot newSnapshot() throws IOException;1533295538;Snapshots the current transaction log allowing to safely iterate over the snapshot._Snapshots are fixed in time and will not be updated with future operations.;public Snapshot newSnapshot() throws IOException {_        try (ReleasableLock ignored = readLock.acquire()) {_            return newSnapshotFromGen(getMinFileGeneration())__        }_    };snapshots,the,current,transaction,log,allowing,to,safely,iterate,over,the,snapshot,snapshots,are,fixed,in,time,and,will,not,be,updated,with,future,operations;public,snapshot,new,snapshot,throws,ioexception,try,releasable,lock,ignored,read,lock,acquire,return,new,snapshot,from,gen,get,min,file,generation
Translog -> public Snapshot newSnapshot() throws IOException;1533641732;Snapshots the current transaction log allowing to safely iterate over the snapshot._Snapshots are fixed in time and will not be updated with future operations.;public Snapshot newSnapshot() throws IOException {_        try (ReleasableLock ignored = readLock.acquire()) {_            return newSnapshotFromGen(getMinFileGeneration())__        }_    };snapshots,the,current,transaction,log,allowing,to,safely,iterate,over,the,snapshot,snapshots,are,fixed,in,time,and,will,not,be,updated,with,future,operations;public,snapshot,new,snapshot,throws,ioexception,try,releasable,lock,ignored,read,lock,acquire,return,new,snapshot,from,gen,get,min,file,generation
Translog -> public Snapshot newSnapshot() throws IOException;1534848846;Snapshots the current transaction log allowing to safely iterate over the snapshot._Snapshots are fixed in time and will not be updated with future operations.;public Snapshot newSnapshot() throws IOException {_        try (ReleasableLock ignored = readLock.acquire()) {_            return newSnapshotFromGen(getMinFileGeneration())__        }_    };snapshots,the,current,transaction,log,allowing,to,safely,iterate,over,the,snapshot,snapshots,are,fixed,in,time,and,will,not,be,updated,with,future,operations;public,snapshot,new,snapshot,throws,ioexception,try,releasable,lock,ignored,read,lock,acquire,return,new,snapshot,from,gen,get,min,file,generation
Translog -> public Snapshot newSnapshot() throws IOException;1535046779;Snapshots the current transaction log allowing to safely iterate over the snapshot._Snapshots are fixed in time and will not be updated with future operations.;public Snapshot newSnapshot() throws IOException {_        try (ReleasableLock ignored = readLock.acquire()) {_            return newSnapshotFromGen(new TranslogGeneration(translogUUID, getMinFileGeneration()), Long.MAX_VALUE)__        }_    };snapshots,the,current,transaction,log,allowing,to,safely,iterate,over,the,snapshot,snapshots,are,fixed,in,time,and,will,not,be,updated,with,future,operations;public,snapshot,new,snapshot,throws,ioexception,try,releasable,lock,ignored,read,lock,acquire,return,new,snapshot,from,gen,new,translog,generation,translog,uuid,get,min,file,generation,long
Translog -> public Snapshot newSnapshot() throws IOException;1535723122;Snapshots the current transaction log allowing to safely iterate over the snapshot._Snapshots are fixed in time and will not be updated with future operations.;public Snapshot newSnapshot() throws IOException {_        try (ReleasableLock ignored = readLock.acquire()) {_            return newSnapshotFromGen(new TranslogGeneration(translogUUID, getMinFileGeneration()), Long.MAX_VALUE)__        }_    };snapshots,the,current,transaction,log,allowing,to,safely,iterate,over,the,snapshot,snapshots,are,fixed,in,time,and,will,not,be,updated,with,future,operations;public,snapshot,new,snapshot,throws,ioexception,try,releasable,lock,ignored,read,lock,acquire,return,new,snapshot,from,gen,new,translog,generation,translog,uuid,get,min,file,generation,long
Translog -> public Snapshot newSnapshot() throws IOException;1537806831;Snapshots the current transaction log allowing to safely iterate over the snapshot._Snapshots are fixed in time and will not be updated with future operations.;public Snapshot newSnapshot() throws IOException {_        try (ReleasableLock ignored = readLock.acquire()) {_            return newSnapshotFromGen(new TranslogGeneration(translogUUID, getMinFileGeneration()), Long.MAX_VALUE)__        }_    };snapshots,the,current,transaction,log,allowing,to,safely,iterate,over,the,snapshot,snapshots,are,fixed,in,time,and,will,not,be,updated,with,future,operations;public,snapshot,new,snapshot,throws,ioexception,try,releasable,lock,ignored,read,lock,acquire,return,new,snapshot,from,gen,new,translog,generation,translog,uuid,get,min,file,generation,long
Translog -> public Snapshot newSnapshot() throws IOException;1541592065;Snapshots the current transaction log allowing to safely iterate over the snapshot._Snapshots are fixed in time and will not be updated with future operations.;public Snapshot newSnapshot() throws IOException {_        try (ReleasableLock ignored = readLock.acquire()) {_            return newSnapshotFromGen(new TranslogGeneration(translogUUID, getMinFileGeneration()), Long.MAX_VALUE)__        }_    };snapshots,the,current,transaction,log,allowing,to,safely,iterate,over,the,snapshot,snapshots,are,fixed,in,time,and,will,not,be,updated,with,future,operations;public,snapshot,new,snapshot,throws,ioexception,try,releasable,lock,ignored,read,lock,acquire,return,new,snapshot,from,gen,new,translog,generation,translog,uuid,get,min,file,generation,long
Translog -> public Snapshot newSnapshot() throws IOException;1542697754;Snapshots the current transaction log allowing to safely iterate over the snapshot._Snapshots are fixed in time and will not be updated with future operations.;public Snapshot newSnapshot() throws IOException {_        try (ReleasableLock ignored = readLock.acquire()) {_            return newSnapshotFromGen(new TranslogGeneration(translogUUID, getMinFileGeneration()), Long.MAX_VALUE)__        }_    };snapshots,the,current,transaction,log,allowing,to,safely,iterate,over,the,snapshot,snapshots,are,fixed,in,time,and,will,not,be,updated,with,future,operations;public,snapshot,new,snapshot,throws,ioexception,try,releasable,lock,ignored,read,lock,acquire,return,new,snapshot,from,gen,new,translog,generation,translog,uuid,get,min,file,generation,long
Translog -> public Snapshot newSnapshot() throws IOException;1542962614;Snapshots the current transaction log allowing to safely iterate over the snapshot._Snapshots are fixed in time and will not be updated with future operations.;public Snapshot newSnapshot() throws IOException {_        try (ReleasableLock ignored = readLock.acquire()) {_            return newSnapshotFromGen(new TranslogGeneration(translogUUID, getMinFileGeneration()), Long.MAX_VALUE)__        }_    };snapshots,the,current,transaction,log,allowing,to,safely,iterate,over,the,snapshot,snapshots,are,fixed,in,time,and,will,not,be,updated,with,future,operations;public,snapshot,new,snapshot,throws,ioexception,try,releasable,lock,ignored,read,lock,acquire,return,new,snapshot,from,gen,new,translog,generation,translog,uuid,get,min,file,generation,long
Translog -> public Snapshot newSnapshot() throws IOException;1545236365;Snapshots the current transaction log allowing to safely iterate over the snapshot._Snapshots are fixed in time and will not be updated with future operations.;public Snapshot newSnapshot() throws IOException {_        try (ReleasableLock ignored = readLock.acquire()) {_            return newSnapshotFromGen(new TranslogGeneration(translogUUID, getMinFileGeneration()), Long.MAX_VALUE)__        }_    };snapshots,the,current,transaction,log,allowing,to,safely,iterate,over,the,snapshot,snapshots,are,fixed,in,time,and,will,not,be,updated,with,future,operations;public,snapshot,new,snapshot,throws,ioexception,try,releasable,lock,ignored,read,lock,acquire,return,new,snapshot,from,gen,new,translog,generation,translog,uuid,get,min,file,generation,long
Translog -> static long findEarliestLastModifiedAge(long currentTime, Iterable<TranslogReader> readers, TranslogWriter writer) throws IOException;1524684173;Returns the age of the oldest entry in the translog files in seconds;static long findEarliestLastModifiedAge(long currentTime, Iterable<TranslogReader> readers, TranslogWriter writer) throws IOException {_        long earliestTime = currentTime__        for (BaseTranslogReader r : readers) {_            earliestTime = Math.min(r.getLastModifiedTime(), earliestTime)__        }_        return Math.max(0, currentTime - Math.min(earliestTime, writer.getLastModifiedTime()))__    };returns,the,age,of,the,oldest,entry,in,the,translog,files,in,seconds;static,long,find,earliest,last,modified,age,long,current,time,iterable,translog,reader,readers,translog,writer,writer,throws,ioexception,long,earliest,time,current,time,for,base,translog,reader,r,readers,earliest,time,math,min,r,get,last,modified,time,earliest,time,return,math,max,0,current,time,math,min,earliest,time,writer,get,last,modified,time
Translog -> static long findEarliestLastModifiedAge(long currentTime, Iterable<TranslogReader> readers, TranslogWriter writer) throws IOException;1525334055;Returns the age of the oldest entry in the translog files in seconds;static long findEarliestLastModifiedAge(long currentTime, Iterable<TranslogReader> readers, TranslogWriter writer) throws IOException {_        long earliestTime = currentTime__        for (BaseTranslogReader r : readers) {_            earliestTime = Math.min(r.getLastModifiedTime(), earliestTime)__        }_        return Math.max(0, currentTime - Math.min(earliestTime, writer.getLastModifiedTime()))__    };returns,the,age,of,the,oldest,entry,in,the,translog,files,in,seconds;static,long,find,earliest,last,modified,age,long,current,time,iterable,translog,reader,readers,translog,writer,writer,throws,ioexception,long,earliest,time,current,time,for,base,translog,reader,r,readers,earliest,time,math,min,r,get,last,modified,time,earliest,time,return,math,max,0,current,time,math,min,earliest,time,writer,get,last,modified,time
Translog -> static long findEarliestLastModifiedAge(long currentTime, Iterable<TranslogReader> readers, TranslogWriter writer) throws IOException;1528706846;Returns the age of the oldest entry in the translog files in seconds;static long findEarliestLastModifiedAge(long currentTime, Iterable<TranslogReader> readers, TranslogWriter writer) throws IOException {_        long earliestTime = currentTime__        for (BaseTranslogReader r : readers) {_            earliestTime = Math.min(r.getLastModifiedTime(), earliestTime)__        }_        return Math.max(0, currentTime - Math.min(earliestTime, writer.getLastModifiedTime()))__    };returns,the,age,of,the,oldest,entry,in,the,translog,files,in,seconds;static,long,find,earliest,last,modified,age,long,current,time,iterable,translog,reader,readers,translog,writer,writer,throws,ioexception,long,earliest,time,current,time,for,base,translog,reader,r,readers,earliest,time,math,min,r,get,last,modified,time,earliest,time,return,math,max,0,current,time,math,min,earliest,time,writer,get,last,modified,time
Translog -> static long findEarliestLastModifiedAge(long currentTime, Iterable<TranslogReader> readers, TranslogWriter writer) throws IOException;1531910483;Returns the age of the oldest entry in the translog files in seconds;static long findEarliestLastModifiedAge(long currentTime, Iterable<TranslogReader> readers, TranslogWriter writer) throws IOException {_        long earliestTime = currentTime__        for (BaseTranslogReader r : readers) {_            earliestTime = Math.min(r.getLastModifiedTime(), earliestTime)__        }_        return Math.max(0, currentTime - Math.min(earliestTime, writer.getLastModifiedTime()))__    };returns,the,age,of,the,oldest,entry,in,the,translog,files,in,seconds;static,long,find,earliest,last,modified,age,long,current,time,iterable,translog,reader,readers,translog,writer,writer,throws,ioexception,long,earliest,time,current,time,for,base,translog,reader,r,readers,earliest,time,math,min,r,get,last,modified,time,earliest,time,return,math,max,0,current,time,math,min,earliest,time,writer,get,last,modified,time
Translog -> static long findEarliestLastModifiedAge(long currentTime, Iterable<TranslogReader> readers, TranslogWriter writer) throws IOException;1533295538;Returns the age of the oldest entry in the translog files in seconds;static long findEarliestLastModifiedAge(long currentTime, Iterable<TranslogReader> readers, TranslogWriter writer) throws IOException {_        long earliestTime = currentTime__        for (BaseTranslogReader r : readers) {_            earliestTime = Math.min(r.getLastModifiedTime(), earliestTime)__        }_        return Math.max(0, currentTime - Math.min(earliestTime, writer.getLastModifiedTime()))__    };returns,the,age,of,the,oldest,entry,in,the,translog,files,in,seconds;static,long,find,earliest,last,modified,age,long,current,time,iterable,translog,reader,readers,translog,writer,writer,throws,ioexception,long,earliest,time,current,time,for,base,translog,reader,r,readers,earliest,time,math,min,r,get,last,modified,time,earliest,time,return,math,max,0,current,time,math,min,earliest,time,writer,get,last,modified,time
Translog -> static long findEarliestLastModifiedAge(long currentTime, Iterable<TranslogReader> readers, TranslogWriter writer) throws IOException;1533641732;Returns the age of the oldest entry in the translog files in seconds;static long findEarliestLastModifiedAge(long currentTime, Iterable<TranslogReader> readers, TranslogWriter writer) throws IOException {_        long earliestTime = currentTime__        for (BaseTranslogReader r : readers) {_            earliestTime = Math.min(r.getLastModifiedTime(), earliestTime)__        }_        return Math.max(0, currentTime - Math.min(earliestTime, writer.getLastModifiedTime()))__    };returns,the,age,of,the,oldest,entry,in,the,translog,files,in,seconds;static,long,find,earliest,last,modified,age,long,current,time,iterable,translog,reader,readers,translog,writer,writer,throws,ioexception,long,earliest,time,current,time,for,base,translog,reader,r,readers,earliest,time,math,min,r,get,last,modified,time,earliest,time,return,math,max,0,current,time,math,min,earliest,time,writer,get,last,modified,time
Translog -> static long findEarliestLastModifiedAge(long currentTime, Iterable<TranslogReader> readers, TranslogWriter writer) throws IOException;1534848846;Returns the age of the oldest entry in the translog files in seconds;static long findEarliestLastModifiedAge(long currentTime, Iterable<TranslogReader> readers, TranslogWriter writer) throws IOException {_        long earliestTime = currentTime__        for (BaseTranslogReader r : readers) {_            earliestTime = Math.min(r.getLastModifiedTime(), earliestTime)__        }_        return Math.max(0, currentTime - Math.min(earliestTime, writer.getLastModifiedTime()))__    };returns,the,age,of,the,oldest,entry,in,the,translog,files,in,seconds;static,long,find,earliest,last,modified,age,long,current,time,iterable,translog,reader,readers,translog,writer,writer,throws,ioexception,long,earliest,time,current,time,for,base,translog,reader,r,readers,earliest,time,math,min,r,get,last,modified,time,earliest,time,return,math,max,0,current,time,math,min,earliest,time,writer,get,last,modified,time
Translog -> static long findEarliestLastModifiedAge(long currentTime, Iterable<TranslogReader> readers, TranslogWriter writer) throws IOException;1535046779;Returns the age of the oldest entry in the translog files in seconds;static long findEarliestLastModifiedAge(long currentTime, Iterable<TranslogReader> readers, TranslogWriter writer) throws IOException {_        long earliestTime = currentTime__        for (BaseTranslogReader r : readers) {_            earliestTime = Math.min(r.getLastModifiedTime(), earliestTime)__        }_        return Math.max(0, currentTime - Math.min(earliestTime, writer.getLastModifiedTime()))__    };returns,the,age,of,the,oldest,entry,in,the,translog,files,in,seconds;static,long,find,earliest,last,modified,age,long,current,time,iterable,translog,reader,readers,translog,writer,writer,throws,ioexception,long,earliest,time,current,time,for,base,translog,reader,r,readers,earliest,time,math,min,r,get,last,modified,time,earliest,time,return,math,max,0,current,time,math,min,earliest,time,writer,get,last,modified,time
Translog -> static long findEarliestLastModifiedAge(long currentTime, Iterable<TranslogReader> readers, TranslogWriter writer) throws IOException;1535723122;Returns the age of the oldest entry in the translog files in seconds;static long findEarliestLastModifiedAge(long currentTime, Iterable<TranslogReader> readers, TranslogWriter writer) throws IOException {_        long earliestTime = currentTime__        for (BaseTranslogReader r : readers) {_            earliestTime = Math.min(r.getLastModifiedTime(), earliestTime)__        }_        return Math.max(0, currentTime - Math.min(earliestTime, writer.getLastModifiedTime()))__    };returns,the,age,of,the,oldest,entry,in,the,translog,files,in,seconds;static,long,find,earliest,last,modified,age,long,current,time,iterable,translog,reader,readers,translog,writer,writer,throws,ioexception,long,earliest,time,current,time,for,base,translog,reader,r,readers,earliest,time,math,min,r,get,last,modified,time,earliest,time,return,math,max,0,current,time,math,min,earliest,time,writer,get,last,modified,time
Translog -> static long findEarliestLastModifiedAge(long currentTime, Iterable<TranslogReader> readers, TranslogWriter writer) throws IOException;1537806831;Returns the age of the oldest entry in the translog files in seconds;static long findEarliestLastModifiedAge(long currentTime, Iterable<TranslogReader> readers, TranslogWriter writer) throws IOException {_        long earliestTime = currentTime__        for (BaseTranslogReader r : readers) {_            earliestTime = Math.min(r.getLastModifiedTime(), earliestTime)__        }_        return Math.max(0, currentTime - Math.min(earliestTime, writer.getLastModifiedTime()))__    };returns,the,age,of,the,oldest,entry,in,the,translog,files,in,seconds;static,long,find,earliest,last,modified,age,long,current,time,iterable,translog,reader,readers,translog,writer,writer,throws,ioexception,long,earliest,time,current,time,for,base,translog,reader,r,readers,earliest,time,math,min,r,get,last,modified,time,earliest,time,return,math,max,0,current,time,math,min,earliest,time,writer,get,last,modified,time
Translog -> static long findEarliestLastModifiedAge(long currentTime, Iterable<TranslogReader> readers, TranslogWriter writer) throws IOException;1541592065;Returns the age of the oldest entry in the translog files in seconds;static long findEarliestLastModifiedAge(long currentTime, Iterable<TranslogReader> readers, TranslogWriter writer) throws IOException {_        long earliestTime = currentTime__        for (BaseTranslogReader r : readers) {_            earliestTime = Math.min(r.getLastModifiedTime(), earliestTime)__        }_        return Math.max(0, currentTime - Math.min(earliestTime, writer.getLastModifiedTime()))__    };returns,the,age,of,the,oldest,entry,in,the,translog,files,in,seconds;static,long,find,earliest,last,modified,age,long,current,time,iterable,translog,reader,readers,translog,writer,writer,throws,ioexception,long,earliest,time,current,time,for,base,translog,reader,r,readers,earliest,time,math,min,r,get,last,modified,time,earliest,time,return,math,max,0,current,time,math,min,earliest,time,writer,get,last,modified,time
Translog -> static long findEarliestLastModifiedAge(long currentTime, Iterable<TranslogReader> readers, TranslogWriter writer) throws IOException;1542697754;Returns the age of the oldest entry in the translog files in seconds;static long findEarliestLastModifiedAge(long currentTime, Iterable<TranslogReader> readers, TranslogWriter writer) throws IOException {_        long earliestTime = currentTime__        for (BaseTranslogReader r : readers) {_            earliestTime = Math.min(r.getLastModifiedTime(), earliestTime)__        }_        return Math.max(0, currentTime - Math.min(earliestTime, writer.getLastModifiedTime()))__    };returns,the,age,of,the,oldest,entry,in,the,translog,files,in,seconds;static,long,find,earliest,last,modified,age,long,current,time,iterable,translog,reader,readers,translog,writer,writer,throws,ioexception,long,earliest,time,current,time,for,base,translog,reader,r,readers,earliest,time,math,min,r,get,last,modified,time,earliest,time,return,math,max,0,current,time,math,min,earliest,time,writer,get,last,modified,time
Translog -> static long findEarliestLastModifiedAge(long currentTime, Iterable<TranslogReader> readers, TranslogWriter writer) throws IOException;1542962614;Returns the age of the oldest entry in the translog files in seconds;static long findEarliestLastModifiedAge(long currentTime, Iterable<TranslogReader> readers, TranslogWriter writer) throws IOException {_        long earliestTime = currentTime__        for (BaseTranslogReader r : readers) {_            earliestTime = Math.min(r.getLastModifiedTime(), earliestTime)__        }_        return Math.max(0, currentTime - Math.min(earliestTime, writer.getLastModifiedTime()))__    };returns,the,age,of,the,oldest,entry,in,the,translog,files,in,seconds;static,long,find,earliest,last,modified,age,long,current,time,iterable,translog,reader,readers,translog,writer,writer,throws,ioexception,long,earliest,time,current,time,for,base,translog,reader,r,readers,earliest,time,math,min,r,get,last,modified,time,earliest,time,return,math,max,0,current,time,math,min,earliest,time,writer,get,last,modified,time
Translog -> static long findEarliestLastModifiedAge(long currentTime, Iterable<TranslogReader> readers, TranslogWriter writer) throws IOException;1545236365;Returns the age of the oldest entry in the translog files in seconds;static long findEarliestLastModifiedAge(long currentTime, Iterable<TranslogReader> readers, TranslogWriter writer) throws IOException {_        long earliestTime = currentTime__        for (BaseTranslogReader r : readers) {_            earliestTime = Math.min(r.getLastModifiedTime(), earliestTime)__        }_        return Math.max(0, currentTime - Math.min(earliestTime, writer.getLastModifiedTime()))__    };returns,the,age,of,the,oldest,entry,in,the,translog,files,in,seconds;static,long,find,earliest,last,modified,age,long,current,time,iterable,translog,reader,readers,translog,writer,writer,throws,ioexception,long,earliest,time,current,time,for,base,translog,reader,r,readers,earliest,time,math,min,r,get,last,modified,time,earliest,time,return,math,max,0,current,time,math,min,earliest,time,writer,get,last,modified,time
Translog -> TranslogWriter createWriter(long fileGeneration, long initialMinTranslogGen, long initialGlobalCheckpoint) throws IOException;1524684173;creates a new writer__@param fileGeneration          the generation of the write to be written_@param initialMinTranslogGen   the minimum translog generation to be written in the first checkpoint. This is_needed to solve and initialization problem while constructing an empty translog._With no readers and no current, a call to  {@link #getMinFileGeneration()} would not work._@param initialGlobalCheckpoint the global checkpoint to be written in the first checkpoint.;TranslogWriter createWriter(long fileGeneration, long initialMinTranslogGen, long initialGlobalCheckpoint) throws IOException {_        final TranslogWriter newFile__        try {_            newFile = TranslogWriter.create(_                shardId,_                translogUUID,_                fileGeneration,_                location.resolve(getFilename(fileGeneration)),_                getChannelFactory(),_                config.getBufferSize(),_                initialMinTranslogGen, initialGlobalCheckpoint,_                globalCheckpointSupplier, this::getMinFileGeneration, primaryTermSupplier.getAsLong())__        } catch (final IOException e) {_            throw new TranslogException(shardId, "failed to create new translog file", e)__        }_        return newFile__    };creates,a,new,writer,param,file,generation,the,generation,of,the,write,to,be,written,param,initial,min,translog,gen,the,minimum,translog,generation,to,be,written,in,the,first,checkpoint,this,is,needed,to,solve,and,initialization,problem,while,constructing,an,empty,translog,with,no,readers,and,no,current,a,call,to,link,get,min,file,generation,would,not,work,param,initial,global,checkpoint,the,global,checkpoint,to,be,written,in,the,first,checkpoint;translog,writer,create,writer,long,file,generation,long,initial,min,translog,gen,long,initial,global,checkpoint,throws,ioexception,final,translog,writer,new,file,try,new,file,translog,writer,create,shard,id,translog,uuid,file,generation,location,resolve,get,filename,file,generation,get,channel,factory,config,get,buffer,size,initial,min,translog,gen,initial,global,checkpoint,global,checkpoint,supplier,this,get,min,file,generation,primary,term,supplier,get,as,long,catch,final,ioexception,e,throw,new,translog,exception,shard,id,failed,to,create,new,translog,file,e,return,new,file
Translog -> TranslogWriter createWriter(long fileGeneration, long initialMinTranslogGen, long initialGlobalCheckpoint) throws IOException;1525334055;creates a new writer__@param fileGeneration          the generation of the write to be written_@param initialMinTranslogGen   the minimum translog generation to be written in the first checkpoint. This is_needed to solve and initialization problem while constructing an empty translog._With no readers and no current, a call to  {@link #getMinFileGeneration()} would not work._@param initialGlobalCheckpoint the global checkpoint to be written in the first checkpoint.;TranslogWriter createWriter(long fileGeneration, long initialMinTranslogGen, long initialGlobalCheckpoint) throws IOException {_        final TranslogWriter newFile__        try {_            newFile = TranslogWriter.create(_                shardId,_                translogUUID,_                fileGeneration,_                location.resolve(getFilename(fileGeneration)),_                getChannelFactory(),_                config.getBufferSize(),_                initialMinTranslogGen, initialGlobalCheckpoint,_                globalCheckpointSupplier, this::getMinFileGeneration, primaryTermSupplier.getAsLong())__        } catch (final IOException e) {_            throw new TranslogException(shardId, "failed to create new translog file", e)__        }_        return newFile__    };creates,a,new,writer,param,file,generation,the,generation,of,the,write,to,be,written,param,initial,min,translog,gen,the,minimum,translog,generation,to,be,written,in,the,first,checkpoint,this,is,needed,to,solve,and,initialization,problem,while,constructing,an,empty,translog,with,no,readers,and,no,current,a,call,to,link,get,min,file,generation,would,not,work,param,initial,global,checkpoint,the,global,checkpoint,to,be,written,in,the,first,checkpoint;translog,writer,create,writer,long,file,generation,long,initial,min,translog,gen,long,initial,global,checkpoint,throws,ioexception,final,translog,writer,new,file,try,new,file,translog,writer,create,shard,id,translog,uuid,file,generation,location,resolve,get,filename,file,generation,get,channel,factory,config,get,buffer,size,initial,min,translog,gen,initial,global,checkpoint,global,checkpoint,supplier,this,get,min,file,generation,primary,term,supplier,get,as,long,catch,final,ioexception,e,throw,new,translog,exception,shard,id,failed,to,create,new,translog,file,e,return,new,file
Translog -> TranslogWriter createWriter(long fileGeneration, long initialMinTranslogGen, long initialGlobalCheckpoint) throws IOException;1528706846;creates a new writer__@param fileGeneration          the generation of the write to be written_@param initialMinTranslogGen   the minimum translog generation to be written in the first checkpoint. This is_needed to solve and initialization problem while constructing an empty translog._With no readers and no current, a call to  {@link #getMinFileGeneration()} would not work._@param initialGlobalCheckpoint the global checkpoint to be written in the first checkpoint.;TranslogWriter createWriter(long fileGeneration, long initialMinTranslogGen, long initialGlobalCheckpoint) throws IOException {_        final TranslogWriter newFile__        try {_            newFile = TranslogWriter.create(_                shardId,_                translogUUID,_                fileGeneration,_                location.resolve(getFilename(fileGeneration)),_                getChannelFactory(),_                config.getBufferSize(),_                initialMinTranslogGen, initialGlobalCheckpoint,_                globalCheckpointSupplier, this::getMinFileGeneration, primaryTermSupplier.getAsLong())__        } catch (final IOException e) {_            throw new TranslogException(shardId, "failed to create new translog file", e)__        }_        return newFile__    };creates,a,new,writer,param,file,generation,the,generation,of,the,write,to,be,written,param,initial,min,translog,gen,the,minimum,translog,generation,to,be,written,in,the,first,checkpoint,this,is,needed,to,solve,and,initialization,problem,while,constructing,an,empty,translog,with,no,readers,and,no,current,a,call,to,link,get,min,file,generation,would,not,work,param,initial,global,checkpoint,the,global,checkpoint,to,be,written,in,the,first,checkpoint;translog,writer,create,writer,long,file,generation,long,initial,min,translog,gen,long,initial,global,checkpoint,throws,ioexception,final,translog,writer,new,file,try,new,file,translog,writer,create,shard,id,translog,uuid,file,generation,location,resolve,get,filename,file,generation,get,channel,factory,config,get,buffer,size,initial,min,translog,gen,initial,global,checkpoint,global,checkpoint,supplier,this,get,min,file,generation,primary,term,supplier,get,as,long,catch,final,ioexception,e,throw,new,translog,exception,shard,id,failed,to,create,new,translog,file,e,return,new,file
Translog -> TranslogWriter createWriter(long fileGeneration, long initialMinTranslogGen, long initialGlobalCheckpoint) throws IOException;1531910483;creates a new writer__@param fileGeneration          the generation of the write to be written_@param initialMinTranslogGen   the minimum translog generation to be written in the first checkpoint. This is_needed to solve and initialization problem while constructing an empty translog._With no readers and no current, a call to  {@link #getMinFileGeneration()} would not work._@param initialGlobalCheckpoint the global checkpoint to be written in the first checkpoint.;TranslogWriter createWriter(long fileGeneration, long initialMinTranslogGen, long initialGlobalCheckpoint) throws IOException {_        final TranslogWriter newFile__        try {_            newFile = TranslogWriter.create(_                shardId,_                translogUUID,_                fileGeneration,_                location.resolve(getFilename(fileGeneration)),_                getChannelFactory(),_                config.getBufferSize(),_                initialMinTranslogGen, initialGlobalCheckpoint,_                globalCheckpointSupplier, this::getMinFileGeneration, primaryTermSupplier.getAsLong())__        } catch (final IOException e) {_            throw new TranslogException(shardId, "failed to create new translog file", e)__        }_        return newFile__    };creates,a,new,writer,param,file,generation,the,generation,of,the,write,to,be,written,param,initial,min,translog,gen,the,minimum,translog,generation,to,be,written,in,the,first,checkpoint,this,is,needed,to,solve,and,initialization,problem,while,constructing,an,empty,translog,with,no,readers,and,no,current,a,call,to,link,get,min,file,generation,would,not,work,param,initial,global,checkpoint,the,global,checkpoint,to,be,written,in,the,first,checkpoint;translog,writer,create,writer,long,file,generation,long,initial,min,translog,gen,long,initial,global,checkpoint,throws,ioexception,final,translog,writer,new,file,try,new,file,translog,writer,create,shard,id,translog,uuid,file,generation,location,resolve,get,filename,file,generation,get,channel,factory,config,get,buffer,size,initial,min,translog,gen,initial,global,checkpoint,global,checkpoint,supplier,this,get,min,file,generation,primary,term,supplier,get,as,long,catch,final,ioexception,e,throw,new,translog,exception,shard,id,failed,to,create,new,translog,file,e,return,new,file
Translog -> TranslogWriter createWriter(long fileGeneration, long initialMinTranslogGen, long initialGlobalCheckpoint) throws IOException;1533295538;creates a new writer__@param fileGeneration          the generation of the write to be written_@param initialMinTranslogGen   the minimum translog generation to be written in the first checkpoint. This is_needed to solve and initialization problem while constructing an empty translog._With no readers and no current, a call to  {@link #getMinFileGeneration()} would not work._@param initialGlobalCheckpoint the global checkpoint to be written in the first checkpoint.;TranslogWriter createWriter(long fileGeneration, long initialMinTranslogGen, long initialGlobalCheckpoint) throws IOException {_        final TranslogWriter newFile__        try {_            newFile = TranslogWriter.create(_                shardId,_                translogUUID,_                fileGeneration,_                location.resolve(getFilename(fileGeneration)),_                getChannelFactory(),_                config.getBufferSize(),_                initialMinTranslogGen, initialGlobalCheckpoint,_                globalCheckpointSupplier, this::getMinFileGeneration, primaryTermSupplier.getAsLong())__        } catch (final IOException e) {_            throw new TranslogException(shardId, "failed to create new translog file", e)__        }_        return newFile__    };creates,a,new,writer,param,file,generation,the,generation,of,the,write,to,be,written,param,initial,min,translog,gen,the,minimum,translog,generation,to,be,written,in,the,first,checkpoint,this,is,needed,to,solve,and,initialization,problem,while,constructing,an,empty,translog,with,no,readers,and,no,current,a,call,to,link,get,min,file,generation,would,not,work,param,initial,global,checkpoint,the,global,checkpoint,to,be,written,in,the,first,checkpoint;translog,writer,create,writer,long,file,generation,long,initial,min,translog,gen,long,initial,global,checkpoint,throws,ioexception,final,translog,writer,new,file,try,new,file,translog,writer,create,shard,id,translog,uuid,file,generation,location,resolve,get,filename,file,generation,get,channel,factory,config,get,buffer,size,initial,min,translog,gen,initial,global,checkpoint,global,checkpoint,supplier,this,get,min,file,generation,primary,term,supplier,get,as,long,catch,final,ioexception,e,throw,new,translog,exception,shard,id,failed,to,create,new,translog,file,e,return,new,file
Translog -> TranslogWriter createWriter(long fileGeneration, long initialMinTranslogGen, long initialGlobalCheckpoint) throws IOException;1533641732;creates a new writer__@param fileGeneration          the generation of the write to be written_@param initialMinTranslogGen   the minimum translog generation to be written in the first checkpoint. This is_needed to solve and initialization problem while constructing an empty translog._With no readers and no current, a call to  {@link #getMinFileGeneration()} would not work._@param initialGlobalCheckpoint the global checkpoint to be written in the first checkpoint.;TranslogWriter createWriter(long fileGeneration, long initialMinTranslogGen, long initialGlobalCheckpoint) throws IOException {_        final TranslogWriter newFile__        try {_            newFile = TranslogWriter.create(_                shardId,_                translogUUID,_                fileGeneration,_                location.resolve(getFilename(fileGeneration)),_                getChannelFactory(),_                config.getBufferSize(),_                initialMinTranslogGen, initialGlobalCheckpoint,_                globalCheckpointSupplier, this::getMinFileGeneration, primaryTermSupplier.getAsLong())__        } catch (final IOException e) {_            throw new TranslogException(shardId, "failed to create new translog file", e)__        }_        return newFile__    };creates,a,new,writer,param,file,generation,the,generation,of,the,write,to,be,written,param,initial,min,translog,gen,the,minimum,translog,generation,to,be,written,in,the,first,checkpoint,this,is,needed,to,solve,and,initialization,problem,while,constructing,an,empty,translog,with,no,readers,and,no,current,a,call,to,link,get,min,file,generation,would,not,work,param,initial,global,checkpoint,the,global,checkpoint,to,be,written,in,the,first,checkpoint;translog,writer,create,writer,long,file,generation,long,initial,min,translog,gen,long,initial,global,checkpoint,throws,ioexception,final,translog,writer,new,file,try,new,file,translog,writer,create,shard,id,translog,uuid,file,generation,location,resolve,get,filename,file,generation,get,channel,factory,config,get,buffer,size,initial,min,translog,gen,initial,global,checkpoint,global,checkpoint,supplier,this,get,min,file,generation,primary,term,supplier,get,as,long,catch,final,ioexception,e,throw,new,translog,exception,shard,id,failed,to,create,new,translog,file,e,return,new,file
Translog -> TranslogWriter createWriter(long fileGeneration, long initialMinTranslogGen, long initialGlobalCheckpoint) throws IOException;1534848846;creates a new writer__@param fileGeneration          the generation of the write to be written_@param initialMinTranslogGen   the minimum translog generation to be written in the first checkpoint. This is_needed to solve and initialization problem while constructing an empty translog._With no readers and no current, a call to  {@link #getMinFileGeneration()} would not work._@param initialGlobalCheckpoint the global checkpoint to be written in the first checkpoint.;TranslogWriter createWriter(long fileGeneration, long initialMinTranslogGen, long initialGlobalCheckpoint) throws IOException {_        final TranslogWriter newFile__        try {_            newFile = TranslogWriter.create(_                shardId,_                translogUUID,_                fileGeneration,_                location.resolve(getFilename(fileGeneration)),_                getChannelFactory(),_                config.getBufferSize(),_                initialMinTranslogGen, initialGlobalCheckpoint,_                globalCheckpointSupplier, this::getMinFileGeneration, primaryTermSupplier.getAsLong(), tragedy)__        } catch (final IOException e) {_            throw new TranslogException(shardId, "failed to create new translog file", e)__        }_        return newFile__    };creates,a,new,writer,param,file,generation,the,generation,of,the,write,to,be,written,param,initial,min,translog,gen,the,minimum,translog,generation,to,be,written,in,the,first,checkpoint,this,is,needed,to,solve,and,initialization,problem,while,constructing,an,empty,translog,with,no,readers,and,no,current,a,call,to,link,get,min,file,generation,would,not,work,param,initial,global,checkpoint,the,global,checkpoint,to,be,written,in,the,first,checkpoint;translog,writer,create,writer,long,file,generation,long,initial,min,translog,gen,long,initial,global,checkpoint,throws,ioexception,final,translog,writer,new,file,try,new,file,translog,writer,create,shard,id,translog,uuid,file,generation,location,resolve,get,filename,file,generation,get,channel,factory,config,get,buffer,size,initial,min,translog,gen,initial,global,checkpoint,global,checkpoint,supplier,this,get,min,file,generation,primary,term,supplier,get,as,long,tragedy,catch,final,ioexception,e,throw,new,translog,exception,shard,id,failed,to,create,new,translog,file,e,return,new,file
Translog -> TranslogWriter createWriter(long fileGeneration, long initialMinTranslogGen, long initialGlobalCheckpoint) throws IOException;1535046779;creates a new writer__@param fileGeneration          the generation of the write to be written_@param initialMinTranslogGen   the minimum translog generation to be written in the first checkpoint. This is_needed to solve and initialization problem while constructing an empty translog._With no readers and no current, a call to  {@link #getMinFileGeneration()} would not work._@param initialGlobalCheckpoint the global checkpoint to be written in the first checkpoint.;TranslogWriter createWriter(long fileGeneration, long initialMinTranslogGen, long initialGlobalCheckpoint) throws IOException {_        final TranslogWriter newFile__        try {_            newFile = TranslogWriter.create(_                shardId,_                translogUUID,_                fileGeneration,_                location.resolve(getFilename(fileGeneration)),_                getChannelFactory(),_                config.getBufferSize(),_                initialMinTranslogGen, initialGlobalCheckpoint,_                globalCheckpointSupplier, this::getMinFileGeneration, primaryTermSupplier.getAsLong(), tragedy)__        } catch (final IOException e) {_            throw new TranslogException(shardId, "failed to create new translog file", e)__        }_        return newFile__    };creates,a,new,writer,param,file,generation,the,generation,of,the,write,to,be,written,param,initial,min,translog,gen,the,minimum,translog,generation,to,be,written,in,the,first,checkpoint,this,is,needed,to,solve,and,initialization,problem,while,constructing,an,empty,translog,with,no,readers,and,no,current,a,call,to,link,get,min,file,generation,would,not,work,param,initial,global,checkpoint,the,global,checkpoint,to,be,written,in,the,first,checkpoint;translog,writer,create,writer,long,file,generation,long,initial,min,translog,gen,long,initial,global,checkpoint,throws,ioexception,final,translog,writer,new,file,try,new,file,translog,writer,create,shard,id,translog,uuid,file,generation,location,resolve,get,filename,file,generation,get,channel,factory,config,get,buffer,size,initial,min,translog,gen,initial,global,checkpoint,global,checkpoint,supplier,this,get,min,file,generation,primary,term,supplier,get,as,long,tragedy,catch,final,ioexception,e,throw,new,translog,exception,shard,id,failed,to,create,new,translog,file,e,return,new,file
Translog -> TranslogWriter createWriter(long fileGeneration, long initialMinTranslogGen, long initialGlobalCheckpoint) throws IOException;1535723122;creates a new writer__@param fileGeneration          the generation of the write to be written_@param initialMinTranslogGen   the minimum translog generation to be written in the first checkpoint. This is_needed to solve and initialization problem while constructing an empty translog._With no readers and no current, a call to  {@link #getMinFileGeneration()} would not work._@param initialGlobalCheckpoint the global checkpoint to be written in the first checkpoint.;TranslogWriter createWriter(long fileGeneration, long initialMinTranslogGen, long initialGlobalCheckpoint) throws IOException {_        final TranslogWriter newFile__        try {_            newFile = TranslogWriter.create(_                shardId,_                translogUUID,_                fileGeneration,_                location.resolve(getFilename(fileGeneration)),_                getChannelFactory(),_                config.getBufferSize(),_                initialMinTranslogGen, initialGlobalCheckpoint,_                globalCheckpointSupplier, this::getMinFileGeneration, primaryTermSupplier.getAsLong(), tragedy)__        } catch (final IOException e) {_            throw new TranslogException(shardId, "failed to create new translog file", e)__        }_        return newFile__    };creates,a,new,writer,param,file,generation,the,generation,of,the,write,to,be,written,param,initial,min,translog,gen,the,minimum,translog,generation,to,be,written,in,the,first,checkpoint,this,is,needed,to,solve,and,initialization,problem,while,constructing,an,empty,translog,with,no,readers,and,no,current,a,call,to,link,get,min,file,generation,would,not,work,param,initial,global,checkpoint,the,global,checkpoint,to,be,written,in,the,first,checkpoint;translog,writer,create,writer,long,file,generation,long,initial,min,translog,gen,long,initial,global,checkpoint,throws,ioexception,final,translog,writer,new,file,try,new,file,translog,writer,create,shard,id,translog,uuid,file,generation,location,resolve,get,filename,file,generation,get,channel,factory,config,get,buffer,size,initial,min,translog,gen,initial,global,checkpoint,global,checkpoint,supplier,this,get,min,file,generation,primary,term,supplier,get,as,long,tragedy,catch,final,ioexception,e,throw,new,translog,exception,shard,id,failed,to,create,new,translog,file,e,return,new,file
Translog -> TranslogWriter createWriter(long fileGeneration, long initialMinTranslogGen, long initialGlobalCheckpoint) throws IOException;1537806831;creates a new writer__@param fileGeneration          the generation of the write to be written_@param initialMinTranslogGen   the minimum translog generation to be written in the first checkpoint. This is_needed to solve and initialization problem while constructing an empty translog._With no readers and no current, a call to  {@link #getMinFileGeneration()} would not work._@param initialGlobalCheckpoint the global checkpoint to be written in the first checkpoint.;TranslogWriter createWriter(long fileGeneration, long initialMinTranslogGen, long initialGlobalCheckpoint) throws IOException {_        final TranslogWriter newFile__        try {_            newFile = TranslogWriter.create(_                shardId,_                translogUUID,_                fileGeneration,_                location.resolve(getFilename(fileGeneration)),_                getChannelFactory(),_                config.getBufferSize(),_                initialMinTranslogGen, initialGlobalCheckpoint,_                globalCheckpointSupplier, this::getMinFileGeneration, primaryTermSupplier.getAsLong(), tragedy)__        } catch (final IOException e) {_            throw new TranslogException(shardId, "failed to create new translog file", e)__        }_        return newFile__    };creates,a,new,writer,param,file,generation,the,generation,of,the,write,to,be,written,param,initial,min,translog,gen,the,minimum,translog,generation,to,be,written,in,the,first,checkpoint,this,is,needed,to,solve,and,initialization,problem,while,constructing,an,empty,translog,with,no,readers,and,no,current,a,call,to,link,get,min,file,generation,would,not,work,param,initial,global,checkpoint,the,global,checkpoint,to,be,written,in,the,first,checkpoint;translog,writer,create,writer,long,file,generation,long,initial,min,translog,gen,long,initial,global,checkpoint,throws,ioexception,final,translog,writer,new,file,try,new,file,translog,writer,create,shard,id,translog,uuid,file,generation,location,resolve,get,filename,file,generation,get,channel,factory,config,get,buffer,size,initial,min,translog,gen,initial,global,checkpoint,global,checkpoint,supplier,this,get,min,file,generation,primary,term,supplier,get,as,long,tragedy,catch,final,ioexception,e,throw,new,translog,exception,shard,id,failed,to,create,new,translog,file,e,return,new,file
Translog -> TranslogWriter createWriter(long fileGeneration, long initialMinTranslogGen, long initialGlobalCheckpoint) throws IOException;1541592065;creates a new writer__@param fileGeneration          the generation of the write to be written_@param initialMinTranslogGen   the minimum translog generation to be written in the first checkpoint. This is_needed to solve and initialization problem while constructing an empty translog._With no readers and no current, a call to  {@link #getMinFileGeneration()} would not work._@param initialGlobalCheckpoint the global checkpoint to be written in the first checkpoint.;TranslogWriter createWriter(long fileGeneration, long initialMinTranslogGen, long initialGlobalCheckpoint) throws IOException {_        final TranslogWriter newFile__        try {_            newFile = TranslogWriter.create(_                shardId,_                translogUUID,_                fileGeneration,_                location.resolve(getFilename(fileGeneration)),_                getChannelFactory(),_                config.getBufferSize(),_                initialMinTranslogGen, initialGlobalCheckpoint,_                globalCheckpointSupplier, this::getMinFileGeneration, primaryTermSupplier.getAsLong(), tragedy)__        } catch (final IOException e) {_            throw new TranslogException(shardId, "failed to create new translog file", e)__        }_        return newFile__    };creates,a,new,writer,param,file,generation,the,generation,of,the,write,to,be,written,param,initial,min,translog,gen,the,minimum,translog,generation,to,be,written,in,the,first,checkpoint,this,is,needed,to,solve,and,initialization,problem,while,constructing,an,empty,translog,with,no,readers,and,no,current,a,call,to,link,get,min,file,generation,would,not,work,param,initial,global,checkpoint,the,global,checkpoint,to,be,written,in,the,first,checkpoint;translog,writer,create,writer,long,file,generation,long,initial,min,translog,gen,long,initial,global,checkpoint,throws,ioexception,final,translog,writer,new,file,try,new,file,translog,writer,create,shard,id,translog,uuid,file,generation,location,resolve,get,filename,file,generation,get,channel,factory,config,get,buffer,size,initial,min,translog,gen,initial,global,checkpoint,global,checkpoint,supplier,this,get,min,file,generation,primary,term,supplier,get,as,long,tragedy,catch,final,ioexception,e,throw,new,translog,exception,shard,id,failed,to,create,new,translog,file,e,return,new,file
Translog -> TranslogWriter createWriter(long fileGeneration, long initialMinTranslogGen, long initialGlobalCheckpoint) throws IOException;1542697754;creates a new writer__@param fileGeneration          the generation of the write to be written_@param initialMinTranslogGen   the minimum translog generation to be written in the first checkpoint. This is_needed to solve and initialization problem while constructing an empty translog._With no readers and no current, a call to  {@link #getMinFileGeneration()} would not work._@param initialGlobalCheckpoint the global checkpoint to be written in the first checkpoint.;TranslogWriter createWriter(long fileGeneration, long initialMinTranslogGen, long initialGlobalCheckpoint) throws IOException {_        final TranslogWriter newFile__        try {_            newFile = TranslogWriter.create(_                shardId,_                translogUUID,_                fileGeneration,_                location.resolve(getFilename(fileGeneration)),_                getChannelFactory(),_                config.getBufferSize(),_                initialMinTranslogGen, initialGlobalCheckpoint,_                globalCheckpointSupplier, this::getMinFileGeneration, primaryTermSupplier.getAsLong(), tragedy)__        } catch (final IOException e) {_            throw new TranslogException(shardId, "failed to create new translog file", e)__        }_        return newFile__    };creates,a,new,writer,param,file,generation,the,generation,of,the,write,to,be,written,param,initial,min,translog,gen,the,minimum,translog,generation,to,be,written,in,the,first,checkpoint,this,is,needed,to,solve,and,initialization,problem,while,constructing,an,empty,translog,with,no,readers,and,no,current,a,call,to,link,get,min,file,generation,would,not,work,param,initial,global,checkpoint,the,global,checkpoint,to,be,written,in,the,first,checkpoint;translog,writer,create,writer,long,file,generation,long,initial,min,translog,gen,long,initial,global,checkpoint,throws,ioexception,final,translog,writer,new,file,try,new,file,translog,writer,create,shard,id,translog,uuid,file,generation,location,resolve,get,filename,file,generation,get,channel,factory,config,get,buffer,size,initial,min,translog,gen,initial,global,checkpoint,global,checkpoint,supplier,this,get,min,file,generation,primary,term,supplier,get,as,long,tragedy,catch,final,ioexception,e,throw,new,translog,exception,shard,id,failed,to,create,new,translog,file,e,return,new,file
Translog -> TranslogWriter createWriter(long fileGeneration, long initialMinTranslogGen, long initialGlobalCheckpoint) throws IOException;1542962614;creates a new writer__@param fileGeneration          the generation of the write to be written_@param initialMinTranslogGen   the minimum translog generation to be written in the first checkpoint. This is_needed to solve and initialization problem while constructing an empty translog._With no readers and no current, a call to  {@link #getMinFileGeneration()} would not work._@param initialGlobalCheckpoint the global checkpoint to be written in the first checkpoint.;TranslogWriter createWriter(long fileGeneration, long initialMinTranslogGen, long initialGlobalCheckpoint) throws IOException {_        final TranslogWriter newFile__        try {_            newFile = TranslogWriter.create(_                shardId,_                translogUUID,_                fileGeneration,_                location.resolve(getFilename(fileGeneration)),_                getChannelFactory(),_                config.getBufferSize(),_                initialMinTranslogGen, initialGlobalCheckpoint,_                globalCheckpointSupplier, this::getMinFileGeneration, primaryTermSupplier.getAsLong(), tragedy)__        } catch (final IOException e) {_            throw new TranslogException(shardId, "failed to create new translog file", e)__        }_        return newFile__    };creates,a,new,writer,param,file,generation,the,generation,of,the,write,to,be,written,param,initial,min,translog,gen,the,minimum,translog,generation,to,be,written,in,the,first,checkpoint,this,is,needed,to,solve,and,initialization,problem,while,constructing,an,empty,translog,with,no,readers,and,no,current,a,call,to,link,get,min,file,generation,would,not,work,param,initial,global,checkpoint,the,global,checkpoint,to,be,written,in,the,first,checkpoint;translog,writer,create,writer,long,file,generation,long,initial,min,translog,gen,long,initial,global,checkpoint,throws,ioexception,final,translog,writer,new,file,try,new,file,translog,writer,create,shard,id,translog,uuid,file,generation,location,resolve,get,filename,file,generation,get,channel,factory,config,get,buffer,size,initial,min,translog,gen,initial,global,checkpoint,global,checkpoint,supplier,this,get,min,file,generation,primary,term,supplier,get,as,long,tragedy,catch,final,ioexception,e,throw,new,translog,exception,shard,id,failed,to,create,new,translog,file,e,return,new,file
Translog -> TranslogWriter createWriter(long fileGeneration, long initialMinTranslogGen, long initialGlobalCheckpoint) throws IOException;1545236365;creates a new writer__@param fileGeneration          the generation of the write to be written_@param initialMinTranslogGen   the minimum translog generation to be written in the first checkpoint. This is_needed to solve and initialization problem while constructing an empty translog._With no readers and no current, a call to  {@link #getMinFileGeneration()} would not work._@param initialGlobalCheckpoint the global checkpoint to be written in the first checkpoint.;TranslogWriter createWriter(long fileGeneration, long initialMinTranslogGen, long initialGlobalCheckpoint) throws IOException {_        final TranslogWriter newFile__        try {_            newFile = TranslogWriter.create(_                shardId,_                translogUUID,_                fileGeneration,_                location.resolve(getFilename(fileGeneration)),_                getChannelFactory(),_                config.getBufferSize(),_                initialMinTranslogGen, initialGlobalCheckpoint,_                globalCheckpointSupplier, this::getMinFileGeneration, primaryTermSupplier.getAsLong(), tragedy)__        } catch (final IOException e) {_            throw new TranslogException(shardId, "failed to create new translog file", e)__        }_        return newFile__    };creates,a,new,writer,param,file,generation,the,generation,of,the,write,to,be,written,param,initial,min,translog,gen,the,minimum,translog,generation,to,be,written,in,the,first,checkpoint,this,is,needed,to,solve,and,initialization,problem,while,constructing,an,empty,translog,with,no,readers,and,no,current,a,call,to,link,get,min,file,generation,would,not,work,param,initial,global,checkpoint,the,global,checkpoint,to,be,written,in,the,first,checkpoint;translog,writer,create,writer,long,file,generation,long,initial,min,translog,gen,long,initial,global,checkpoint,throws,ioexception,final,translog,writer,new,file,try,new,file,translog,writer,create,shard,id,translog,uuid,file,generation,location,resolve,get,filename,file,generation,get,channel,factory,config,get,buffer,size,initial,min,translog,gen,initial,global,checkpoint,global,checkpoint,supplier,this,get,min,file,generation,primary,term,supplier,get,as,long,tragedy,catch,final,ioexception,e,throw,new,translog,exception,shard,id,failed,to,create,new,translog,file,e,return,new,file
Translog -> public boolean shouldRollGeneration();1524684173;Tests whether or not the translog generation should be rolled to a new generation. This test_is based on the size of the current generation compared to the configured generation_threshold size.__@return {@code true} if the current generation should be rolled to a new generation;public boolean shouldRollGeneration() {_        final long size = this.current.sizeInBytes()__        final long threshold = this.indexSettings.getGenerationThresholdSize().getBytes()__        return size > threshold__    };tests,whether,or,not,the,translog,generation,should,be,rolled,to,a,new,generation,this,test,is,based,on,the,size,of,the,current,generation,compared,to,the,configured,generation,threshold,size,return,code,true,if,the,current,generation,should,be,rolled,to,a,new,generation;public,boolean,should,roll,generation,final,long,size,this,current,size,in,bytes,final,long,threshold,this,index,settings,get,generation,threshold,size,get,bytes,return,size,threshold
Translog -> public boolean shouldRollGeneration();1525334055;Tests whether or not the translog generation should be rolled to a new generation. This test_is based on the size of the current generation compared to the configured generation_threshold size.__@return {@code true} if the current generation should be rolled to a new generation;public boolean shouldRollGeneration() {_        final long size = this.current.sizeInBytes()__        final long threshold = this.indexSettings.getGenerationThresholdSize().getBytes()__        return size > threshold__    };tests,whether,or,not,the,translog,generation,should,be,rolled,to,a,new,generation,this,test,is,based,on,the,size,of,the,current,generation,compared,to,the,configured,generation,threshold,size,return,code,true,if,the,current,generation,should,be,rolled,to,a,new,generation;public,boolean,should,roll,generation,final,long,size,this,current,size,in,bytes,final,long,threshold,this,index,settings,get,generation,threshold,size,get,bytes,return,size,threshold
Translog -> public boolean shouldRollGeneration();1528706846;Tests whether or not the translog generation should be rolled to a new generation. This test_is based on the size of the current generation compared to the configured generation_threshold size.__@return {@code true} if the current generation should be rolled to a new generation;public boolean shouldRollGeneration() {_        final long size = this.current.sizeInBytes()__        final long threshold = this.indexSettings.getGenerationThresholdSize().getBytes()__        return size > threshold__    };tests,whether,or,not,the,translog,generation,should,be,rolled,to,a,new,generation,this,test,is,based,on,the,size,of,the,current,generation,compared,to,the,configured,generation,threshold,size,return,code,true,if,the,current,generation,should,be,rolled,to,a,new,generation;public,boolean,should,roll,generation,final,long,size,this,current,size,in,bytes,final,long,threshold,this,index,settings,get,generation,threshold,size,get,bytes,return,size,threshold
Translog -> public boolean shouldRollGeneration();1531910483;Tests whether or not the translog generation should be rolled to a new generation. This test_is based on the size of the current generation compared to the configured generation_threshold size.__@return {@code true} if the current generation should be rolled to a new generation;public boolean shouldRollGeneration() {_        final long size = this.current.sizeInBytes()__        final long threshold = this.indexSettings.getGenerationThresholdSize().getBytes()__        return size > threshold__    };tests,whether,or,not,the,translog,generation,should,be,rolled,to,a,new,generation,this,test,is,based,on,the,size,of,the,current,generation,compared,to,the,configured,generation,threshold,size,return,code,true,if,the,current,generation,should,be,rolled,to,a,new,generation;public,boolean,should,roll,generation,final,long,size,this,current,size,in,bytes,final,long,threshold,this,index,settings,get,generation,threshold,size,get,bytes,return,size,threshold
Translog -> public boolean shouldRollGeneration();1533295538;Tests whether or not the translog generation should be rolled to a new generation. This test_is based on the size of the current generation compared to the configured generation_threshold size.__@return {@code true} if the current generation should be rolled to a new generation;public boolean shouldRollGeneration() {_        final long size = this.current.sizeInBytes()__        final long threshold = this.indexSettings.getGenerationThresholdSize().getBytes()__        return size > threshold__    };tests,whether,or,not,the,translog,generation,should,be,rolled,to,a,new,generation,this,test,is,based,on,the,size,of,the,current,generation,compared,to,the,configured,generation,threshold,size,return,code,true,if,the,current,generation,should,be,rolled,to,a,new,generation;public,boolean,should,roll,generation,final,long,size,this,current,size,in,bytes,final,long,threshold,this,index,settings,get,generation,threshold,size,get,bytes,return,size,threshold
Translog -> public boolean shouldRollGeneration();1533641732;Tests whether or not the translog generation should be rolled to a new generation. This test_is based on the size of the current generation compared to the configured generation_threshold size.__@return {@code true} if the current generation should be rolled to a new generation;public boolean shouldRollGeneration() {_        final long size = this.current.sizeInBytes()__        final long threshold = this.indexSettings.getGenerationThresholdSize().getBytes()__        return size > threshold__    };tests,whether,or,not,the,translog,generation,should,be,rolled,to,a,new,generation,this,test,is,based,on,the,size,of,the,current,generation,compared,to,the,configured,generation,threshold,size,return,code,true,if,the,current,generation,should,be,rolled,to,a,new,generation;public,boolean,should,roll,generation,final,long,size,this,current,size,in,bytes,final,long,threshold,this,index,settings,get,generation,threshold,size,get,bytes,return,size,threshold
Translog -> public boolean shouldRollGeneration();1534848846;Tests whether or not the translog generation should be rolled to a new generation. This test_is based on the size of the current generation compared to the configured generation_threshold size.__@return {@code true} if the current generation should be rolled to a new generation;public boolean shouldRollGeneration() {_        final long size = this.current.sizeInBytes()__        final long threshold = this.indexSettings.getGenerationThresholdSize().getBytes()__        return size > threshold__    };tests,whether,or,not,the,translog,generation,should,be,rolled,to,a,new,generation,this,test,is,based,on,the,size,of,the,current,generation,compared,to,the,configured,generation,threshold,size,return,code,true,if,the,current,generation,should,be,rolled,to,a,new,generation;public,boolean,should,roll,generation,final,long,size,this,current,size,in,bytes,final,long,threshold,this,index,settings,get,generation,threshold,size,get,bytes,return,size,threshold
Translog -> public boolean shouldRollGeneration();1535046779;Tests whether or not the translog generation should be rolled to a new generation. This test_is based on the size of the current generation compared to the configured generation_threshold size.__@return {@code true} if the current generation should be rolled to a new generation;public boolean shouldRollGeneration() {_        final long size = this.current.sizeInBytes()__        final long threshold = this.indexSettings.getGenerationThresholdSize().getBytes()__        return size > threshold__    };tests,whether,or,not,the,translog,generation,should,be,rolled,to,a,new,generation,this,test,is,based,on,the,size,of,the,current,generation,compared,to,the,configured,generation,threshold,size,return,code,true,if,the,current,generation,should,be,rolled,to,a,new,generation;public,boolean,should,roll,generation,final,long,size,this,current,size,in,bytes,final,long,threshold,this,index,settings,get,generation,threshold,size,get,bytes,return,size,threshold
Translog -> public boolean shouldRollGeneration();1535723122;Tests whether or not the translog generation should be rolled to a new generation. This test_is based on the size of the current generation compared to the configured generation_threshold size.__@return {@code true} if the current generation should be rolled to a new generation;public boolean shouldRollGeneration() {_        final long size = this.current.sizeInBytes()__        final long threshold = this.indexSettings.getGenerationThresholdSize().getBytes()__        return size > threshold__    };tests,whether,or,not,the,translog,generation,should,be,rolled,to,a,new,generation,this,test,is,based,on,the,size,of,the,current,generation,compared,to,the,configured,generation,threshold,size,return,code,true,if,the,current,generation,should,be,rolled,to,a,new,generation;public,boolean,should,roll,generation,final,long,size,this,current,size,in,bytes,final,long,threshold,this,index,settings,get,generation,threshold,size,get,bytes,return,size,threshold
Translog -> public boolean shouldRollGeneration();1537806831;Tests whether or not the translog generation should be rolled to a new generation. This test_is based on the size of the current generation compared to the configured generation_threshold size.__@return {@code true} if the current generation should be rolled to a new generation;public boolean shouldRollGeneration() {_        final long size = this.current.sizeInBytes()__        final long threshold = this.indexSettings.getGenerationThresholdSize().getBytes()__        return size > threshold__    };tests,whether,or,not,the,translog,generation,should,be,rolled,to,a,new,generation,this,test,is,based,on,the,size,of,the,current,generation,compared,to,the,configured,generation,threshold,size,return,code,true,if,the,current,generation,should,be,rolled,to,a,new,generation;public,boolean,should,roll,generation,final,long,size,this,current,size,in,bytes,final,long,threshold,this,index,settings,get,generation,threshold,size,get,bytes,return,size,threshold
Translog -> public boolean shouldRollGeneration();1541592065;Tests whether or not the translog generation should be rolled to a new generation. This test_is based on the size of the current generation compared to the configured generation_threshold size.__@return {@code true} if the current generation should be rolled to a new generation;public boolean shouldRollGeneration() {_        final long size = this.current.sizeInBytes()__        final long threshold = this.indexSettings.getGenerationThresholdSize().getBytes()__        return size > threshold__    };tests,whether,or,not,the,translog,generation,should,be,rolled,to,a,new,generation,this,test,is,based,on,the,size,of,the,current,generation,compared,to,the,configured,generation,threshold,size,return,code,true,if,the,current,generation,should,be,rolled,to,a,new,generation;public,boolean,should,roll,generation,final,long,size,this,current,size,in,bytes,final,long,threshold,this,index,settings,get,generation,threshold,size,get,bytes,return,size,threshold
Translog -> public boolean shouldRollGeneration();1542697754;Tests whether or not the translog generation should be rolled to a new generation. This test_is based on the size of the current generation compared to the configured generation_threshold size.__@return {@code true} if the current generation should be rolled to a new generation;public boolean shouldRollGeneration() {_        final long size = this.current.sizeInBytes()__        final long threshold = this.indexSettings.getGenerationThresholdSize().getBytes()__        return size > threshold__    };tests,whether,or,not,the,translog,generation,should,be,rolled,to,a,new,generation,this,test,is,based,on,the,size,of,the,current,generation,compared,to,the,configured,generation,threshold,size,return,code,true,if,the,current,generation,should,be,rolled,to,a,new,generation;public,boolean,should,roll,generation,final,long,size,this,current,size,in,bytes,final,long,threshold,this,index,settings,get,generation,threshold,size,get,bytes,return,size,threshold
Translog -> public boolean shouldRollGeneration();1542962614;Tests whether or not the translog generation should be rolled to a new generation. This test_is based on the size of the current generation compared to the configured generation_threshold size.__@return {@code true} if the current generation should be rolled to a new generation;public boolean shouldRollGeneration() {_        final long size = this.current.sizeInBytes()__        final long threshold = this.indexSettings.getGenerationThresholdSize().getBytes()__        return size > threshold__    };tests,whether,or,not,the,translog,generation,should,be,rolled,to,a,new,generation,this,test,is,based,on,the,size,of,the,current,generation,compared,to,the,configured,generation,threshold,size,return,code,true,if,the,current,generation,should,be,rolled,to,a,new,generation;public,boolean,should,roll,generation,final,long,size,this,current,size,in,bytes,final,long,threshold,this,index,settings,get,generation,threshold,size,get,bytes,return,size,threshold
Translog -> public boolean shouldRollGeneration();1545236365;Tests whether or not the translog generation should be rolled to a new generation. This test_is based on the size of the current generation compared to the configured generation_threshold size.__@return {@code true} if the current generation should be rolled to a new generation;public boolean shouldRollGeneration() {_        final long size = this.current.sizeInBytes()__        final long threshold = this.indexSettings.getGenerationThresholdSize().getBytes()__        return size > threshold__    };tests,whether,or,not,the,translog,generation,should,be,rolled,to,a,new,generation,this,test,is,based,on,the,size,of,the,current,generation,compared,to,the,configured,generation,threshold,size,return,code,true,if,the,current,generation,should,be,rolled,to,a,new,generation;public,boolean,should,roll,generation,final,long,size,this,current,size,in,bytes,final,long,threshold,this,index,settings,get,generation,threshold,size,get,bytes,return,size,threshold
