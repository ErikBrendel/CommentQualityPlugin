commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public void setDeferredCollector(Iterable<BucketCollector> deferredCollectors) {     this.collector = MultiBucketCollector.wrap(deferredCollectors). }
false;public;0;7;;@Override public ScoreMode scoreMode() {     if (collector == null) {         throw new IllegalStateException().     }     return collector.scoreMode(). }
false;public;0;4;;@Override public void preCollection() throws IOException {     collector.preCollection(). }
false;private;0;8;;private void finishLeaf() {     if (context != null) {         entries.add(new Entry(context, docDeltas.build(), buckets.build())).     }     context = null.     docDeltas = null.     buckets = null. }
false;public;2;7;;@Override public void collect(int doc, long bucket) {     docDeltas.add(doc - lastDoc).     buckets.add(bucket).     lastDoc = doc.     maxBucket = Math.max(maxBucket, bucket). }
false;public;1;20;;@Override public LeafBucketCollector getLeafCollector(LeafReaderContext ctx) throws IOException {     finishLeaf().     context = ctx.     docDeltas = PackedLongValues.packedBuilder(PackedInts.DEFAULT).     buckets = PackedLongValues.packedBuilder(PackedInts.DEFAULT).     return new LeafBucketCollector() {          int lastDoc = 0.          @Override         public void collect(int doc, long bucket) {             docDeltas.add(doc - lastDoc).             buckets.add(bucket).             lastDoc = doc.             maxBucket = Math.max(maxBucket, bucket).         }     }. }
false;public;1;25;;public void mergeBuckets(long[] mergeMap) {     List<Entry> newEntries = new ArrayList<>(entries.size()).     for (Entry sourceEntry : entries) {         PackedLongValues.Builder newBuckets = PackedLongValues.packedBuilder(PackedInts.DEFAULT).         for (PackedLongValues.Iterator itr = sourceEntry.buckets.iterator(). itr.hasNext(). ) {             long bucket = itr.next().             newBuckets.add(mergeMap[Math.toIntExact(bucket)]).         }         newEntries.add(new Entry(sourceEntry.context, sourceEntry.docDeltas, newBuckets.build())).     }     entries = newEntries.     // we need to update the bucket ordinals there too     if (buckets.size() > 0) {         PackedLongValues currentBuckets = buckets.build().         PackedLongValues.Builder newBuckets = PackedLongValues.packedBuilder(PackedInts.DEFAULT).         for (PackedLongValues.Iterator itr = currentBuckets.iterator(). itr.hasNext(). ) {             long bucket = itr.next().             newBuckets.add(mergeMap[Math.toIntExact(bucket)]).         }         buckets = newBuckets.     } }
false;public;0;5;;@Override public void postCollection() {     finishLeaf().     finished = true. }
true;public;1;56;/**  * Replay the wrapped collector, but only on a selection of buckets.  */ ;/**  * Replay the wrapped collector, but only on a selection of buckets.  */ @Override public void prepareSelectedBuckets(long... selectedBuckets) throws IOException {     if (finished == false) {         throw new IllegalStateException("Cannot replay yet, collection is not finished: postCollect() has not been called").     }     if (this.selectedBuckets != null) {         throw new IllegalStateException("Already been replayed").     }     final LongHash hash = new LongHash(selectedBuckets.length, BigArrays.NON_RECYCLING_INSTANCE).     for (long bucket : selectedBuckets) {         hash.add(bucket).     }     this.selectedBuckets = hash.     boolean needsScores = collector.scoreMode().needsScores().     Weight weight = null.     if (needsScores) {         weight = searchContext.searcher().createWeight(searchContext.searcher().rewrite(searchContext.query()), ScoreMode.COMPLETE, 1f).     }     for (Entry entry : entries) {         final LeafBucketCollector leafCollector = collector.getLeafCollector(entry.context).         DocIdSetIterator docIt = null.         if (needsScores && entry.docDeltas.size() > 0) {             Scorer scorer = weight.scorer(entry.context).             // We don't need to check if the scorer is null             // since we are sure that there are documents to replay             // (entry.docDeltas it not empty).             docIt = scorer.iterator().             leafCollector.setScorer(scorer).         }         final PackedLongValues.Iterator docDeltaIterator = entry.docDeltas.iterator().         final PackedLongValues.Iterator buckets = entry.buckets.iterator().         int doc = 0.         for (long i = 0, end = entry.docDeltas.size(). i < end. ++i) {             doc += docDeltaIterator.next().             final long bucket = buckets.next().             final long rebasedBucket = hash.find(bucket).             if (rebasedBucket != -1) {                 if (needsScores) {                     if (docIt.docID() < doc) {                         docIt.advance(doc).                     }                     // documents                     assert docIt.docID() == doc.                 }                 leafCollector.collect(doc, rebasedBucket).             }         }     }     collector.postCollection(). }
false;public;1;11;;@Override public InternalAggregation buildAggregation(long bucket) throws IOException {     if (selectedBuckets == null) {         throw new IllegalStateException("Collection has not been replayed yet.").     }     final long rebasedBucket = selectedBuckets.find(bucket).     if (rebasedBucket == -1) {         throw new IllegalStateException("Cannot build for a bucket which has not been collected [" + bucket + "]").     }     return in.buildAggregation(rebasedBucket). }
true;public;1;19;/**  * Wrap the provided aggregator so that it behaves (almost) as if it had  * been collected directly.  */ ;/**  * Wrap the provided aggregator so that it behaves (almost) as if it had  * been collected directly.  */ @Override public Aggregator wrap(final Aggregator in) {     return new WrappedAggregator(in) {          @Override         public InternalAggregation buildAggregation(long bucket) throws IOException {             if (selectedBuckets == null) {                 throw new IllegalStateException("Collection has not been replayed yet.").             }             final long rebasedBucket = selectedBuckets.find(bucket).             if (rebasedBucket == -1) {                 throw new IllegalStateException("Cannot build for a bucket which has not been collected [" + bucket + "]").             }             return in.buildAggregation(rebasedBucket).         }     }. }
