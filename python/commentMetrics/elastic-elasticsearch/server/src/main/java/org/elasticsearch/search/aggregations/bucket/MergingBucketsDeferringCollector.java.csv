# id;timestamp;commentText;codeText;commentWords;codeWords
MergingBucketsDeferringCollector -> @Override     public Aggregator wrap(final Aggregator in);1531729807;Wrap the provided aggregator so that it behaves (almost) as if it had_been collected directly.;@Override_    public Aggregator wrap(final Aggregator in) {__        return new WrappedAggregator(in) {__            @Override_            public InternalAggregation buildAggregation(long bucket) throws IOException {_                if (selectedBuckets == null) {_                    throw new IllegalStateException("Collection has not been replayed yet.")__                }_                final long rebasedBucket = selectedBuckets.find(bucket)__                if (rebasedBucket == -1) {_                    throw new IllegalStateException("Cannot build for a bucket which has not been collected [" + bucket + "]")__                }_                return in.buildAggregation(rebasedBucket)__            }__        }__    };wrap,the,provided,aggregator,so,that,it,behaves,almost,as,if,it,had,been,collected,directly;override,public,aggregator,wrap,final,aggregator,in,return,new,wrapped,aggregator,in,override,public,internal,aggregation,build,aggregation,long,bucket,throws,ioexception,if,selected,buckets,null,throw,new,illegal,state,exception,collection,has,not,been,replayed,yet,final,long,rebased,bucket,selected,buckets,find,bucket,if,rebased,bucket,1,throw,new,illegal,state,exception,cannot,build,for,a,bucket,which,has,not,been,collected,bucket,return,in,build,aggregation,rebased,bucket
MergingBucketsDeferringCollector -> @Override     public Aggregator wrap(final Aggregator in);1535965276;Wrap the provided aggregator so that it behaves (almost) as if it had_been collected directly.;@Override_    public Aggregator wrap(final Aggregator in) {__        return new WrappedAggregator(in) {__            @Override_            public InternalAggregation buildAggregation(long bucket) throws IOException {_                if (selectedBuckets == null) {_                    throw new IllegalStateException("Collection has not been replayed yet.")__                }_                final long rebasedBucket = selectedBuckets.find(bucket)__                if (rebasedBucket == -1) {_                    throw new IllegalStateException("Cannot build for a bucket which has not been collected [" + bucket + "]")__                }_                return in.buildAggregation(rebasedBucket)__            }__        }__    };wrap,the,provided,aggregator,so,that,it,behaves,almost,as,if,it,had,been,collected,directly;override,public,aggregator,wrap,final,aggregator,in,return,new,wrapped,aggregator,in,override,public,internal,aggregation,build,aggregation,long,bucket,throws,ioexception,if,selected,buckets,null,throw,new,illegal,state,exception,collection,has,not,been,replayed,yet,final,long,rebased,bucket,selected,buckets,find,bucket,if,rebased,bucket,1,throw,new,illegal,state,exception,cannot,build,for,a,bucket,which,has,not,been,collected,bucket,return,in,build,aggregation,rebased,bucket
MergingBucketsDeferringCollector -> @Override     public Aggregator wrap(final Aggregator in);1536314350;Wrap the provided aggregator so that it behaves (almost) as if it had_been collected directly.;@Override_    public Aggregator wrap(final Aggregator in) {__        return new WrappedAggregator(in) {__            @Override_            public InternalAggregation buildAggregation(long bucket) throws IOException {_                if (selectedBuckets == null) {_                    throw new IllegalStateException("Collection has not been replayed yet.")__                }_                final long rebasedBucket = selectedBuckets.find(bucket)__                if (rebasedBucket == -1) {_                    throw new IllegalStateException("Cannot build for a bucket which has not been collected [" + bucket + "]")__                }_                return in.buildAggregation(rebasedBucket)__            }__        }__    };wrap,the,provided,aggregator,so,that,it,behaves,almost,as,if,it,had,been,collected,directly;override,public,aggregator,wrap,final,aggregator,in,return,new,wrapped,aggregator,in,override,public,internal,aggregation,build,aggregation,long,bucket,throws,ioexception,if,selected,buckets,null,throw,new,illegal,state,exception,collection,has,not,been,replayed,yet,final,long,rebased,bucket,selected,buckets,find,bucket,if,rebased,bucket,1,throw,new,illegal,state,exception,cannot,build,for,a,bucket,which,has,not,been,collected,bucket,return,in,build,aggregation,rebased,bucket
MergingBucketsDeferringCollector -> @Override     public void prepareSelectedBuckets(long... selectedBuckets) throws IOException;1531729807;Replay the wrapped collector, but only on a selection of buckets.;@Override_    public void prepareSelectedBuckets(long... selectedBuckets) throws IOException {_        if (finished == false) {_            throw new IllegalStateException("Cannot replay yet, collection is not finished: postCollect() has not been called")__        }_        if (this.selectedBuckets != null) {_            throw new IllegalStateException("Already been replayed")__        }__        final LongHash hash = new LongHash(selectedBuckets.length, BigArrays.NON_RECYCLING_INSTANCE)__        for (long bucket : selectedBuckets) {_            hash.add(bucket)__        }_        this.selectedBuckets = hash___        boolean needsScores = collector.needsScores()__        Weight weight = null__        if (needsScores) {_            weight = searchContext.searcher().createNormalizedWeight(searchContext.query(), true)__        }_        for (Entry entry : entries) {_            final LeafBucketCollector leafCollector = collector.getLeafCollector(entry.context)__            DocIdSetIterator docIt = null__            if (needsScores && entry.docDeltas.size() > 0) {_                Scorer scorer = weight.scorer(entry.context)__                _                _                _                docIt = scorer.iterator()__                leafCollector.setScorer(scorer)__            }_            final PackedLongValues.Iterator docDeltaIterator = entry.docDeltas.iterator()__            final PackedLongValues.Iterator buckets = entry.buckets.iterator()__            int doc = 0__            for (long i = 0, end = entry.docDeltas.size()_ i < end_ ++i) {_                doc += docDeltaIterator.next()__                final long bucket = buckets.next()__                final long rebasedBucket = hash.find(bucket)__                if (rebasedBucket != -1) {_                    if (needsScores) {_                        if (docIt.docID() < doc) {_                            docIt.advance(doc)__                        }_                        _                        _                        assert docIt.docID() == doc__                    }_                    leafCollector.collect(doc, rebasedBucket)__                }_            }_        }__        collector.postCollection()__    };replay,the,wrapped,collector,but,only,on,a,selection,of,buckets;override,public,void,prepare,selected,buckets,long,selected,buckets,throws,ioexception,if,finished,false,throw,new,illegal,state,exception,cannot,replay,yet,collection,is,not,finished,post,collect,has,not,been,called,if,this,selected,buckets,null,throw,new,illegal,state,exception,already,been,replayed,final,long,hash,hash,new,long,hash,selected,buckets,length,big,arrays,for,long,bucket,selected,buckets,hash,add,bucket,this,selected,buckets,hash,boolean,needs,scores,collector,needs,scores,weight,weight,null,if,needs,scores,weight,search,context,searcher,create,normalized,weight,search,context,query,true,for,entry,entry,entries,final,leaf,bucket,collector,leaf,collector,collector,get,leaf,collector,entry,context,doc,id,set,iterator,doc,it,null,if,needs,scores,entry,doc,deltas,size,0,scorer,scorer,weight,scorer,entry,context,doc,it,scorer,iterator,leaf,collector,set,scorer,scorer,final,packed,long,values,iterator,doc,delta,iterator,entry,doc,deltas,iterator,final,packed,long,values,iterator,buckets,entry,buckets,iterator,int,doc,0,for,long,i,0,end,entry,doc,deltas,size,i,end,i,doc,doc,delta,iterator,next,final,long,bucket,buckets,next,final,long,rebased,bucket,hash,find,bucket,if,rebased,bucket,1,if,needs,scores,if,doc,it,doc,id,doc,doc,it,advance,doc,assert,doc,it,doc,id,doc,leaf,collector,collect,doc,rebased,bucket,collector,post,collection
MergingBucketsDeferringCollector -> @Override     public void prepareSelectedBuckets(long... selectedBuckets) throws IOException;1535965276;Replay the wrapped collector, but only on a selection of buckets.;@Override_    public void prepareSelectedBuckets(long... selectedBuckets) throws IOException {_        if (finished == false) {_            throw new IllegalStateException("Cannot replay yet, collection is not finished: postCollect() has not been called")__        }_        if (this.selectedBuckets != null) {_            throw new IllegalStateException("Already been replayed")__        }__        final LongHash hash = new LongHash(selectedBuckets.length, BigArrays.NON_RECYCLING_INSTANCE)__        for (long bucket : selectedBuckets) {_            hash.add(bucket)__        }_        this.selectedBuckets = hash___        boolean needsScores = collector.needsScores()__        Weight weight = null__        if (needsScores) {_            weight = searchContext.searcher().createNormalizedWeight(searchContext.query(), true)__        }_        for (Entry entry : entries) {_            final LeafBucketCollector leafCollector = collector.getLeafCollector(entry.context)__            DocIdSetIterator docIt = null__            if (needsScores && entry.docDeltas.size() > 0) {_                Scorer scorer = weight.scorer(entry.context)__                _                _                _                docIt = scorer.iterator()__                leafCollector.setScorer(scorer)__            }_            final PackedLongValues.Iterator docDeltaIterator = entry.docDeltas.iterator()__            final PackedLongValues.Iterator buckets = entry.buckets.iterator()__            int doc = 0__            for (long i = 0, end = entry.docDeltas.size()_ i < end_ ++i) {_                doc += docDeltaIterator.next()__                final long bucket = buckets.next()__                final long rebasedBucket = hash.find(bucket)__                if (rebasedBucket != -1) {_                    if (needsScores) {_                        if (docIt.docID() < doc) {_                            docIt.advance(doc)__                        }_                        _                        _                        assert docIt.docID() == doc__                    }_                    leafCollector.collect(doc, rebasedBucket)__                }_            }_        }__        collector.postCollection()__    };replay,the,wrapped,collector,but,only,on,a,selection,of,buckets;override,public,void,prepare,selected,buckets,long,selected,buckets,throws,ioexception,if,finished,false,throw,new,illegal,state,exception,cannot,replay,yet,collection,is,not,finished,post,collect,has,not,been,called,if,this,selected,buckets,null,throw,new,illegal,state,exception,already,been,replayed,final,long,hash,hash,new,long,hash,selected,buckets,length,big,arrays,for,long,bucket,selected,buckets,hash,add,bucket,this,selected,buckets,hash,boolean,needs,scores,collector,needs,scores,weight,weight,null,if,needs,scores,weight,search,context,searcher,create,normalized,weight,search,context,query,true,for,entry,entry,entries,final,leaf,bucket,collector,leaf,collector,collector,get,leaf,collector,entry,context,doc,id,set,iterator,doc,it,null,if,needs,scores,entry,doc,deltas,size,0,scorer,scorer,weight,scorer,entry,context,doc,it,scorer,iterator,leaf,collector,set,scorer,scorer,final,packed,long,values,iterator,doc,delta,iterator,entry,doc,deltas,iterator,final,packed,long,values,iterator,buckets,entry,buckets,iterator,int,doc,0,for,long,i,0,end,entry,doc,deltas,size,i,end,i,doc,doc,delta,iterator,next,final,long,bucket,buckets,next,final,long,rebased,bucket,hash,find,bucket,if,rebased,bucket,1,if,needs,scores,if,doc,it,doc,id,doc,doc,it,advance,doc,assert,doc,it,doc,id,doc,leaf,collector,collect,doc,rebased,bucket,collector,post,collection
MergingBucketsDeferringCollector -> @Override     public void prepareSelectedBuckets(long... selectedBuckets) throws IOException;1536314350;Replay the wrapped collector, but only on a selection of buckets.;@Override_    public void prepareSelectedBuckets(long... selectedBuckets) throws IOException {_        if (finished == false) {_            throw new IllegalStateException("Cannot replay yet, collection is not finished: postCollect() has not been called")__        }_        if (this.selectedBuckets != null) {_            throw new IllegalStateException("Already been replayed")__        }__        final LongHash hash = new LongHash(selectedBuckets.length, BigArrays.NON_RECYCLING_INSTANCE)__        for (long bucket : selectedBuckets) {_            hash.add(bucket)__        }_        this.selectedBuckets = hash___        boolean needsScores = collector.scoreMode().needsScores()__        Weight weight = null__        if (needsScores) {_            weight = searchContext.searcher().createWeight(_                    searchContext.searcher().rewrite(searchContext.query()),_                    ScoreMode.COMPLETE, 1f)__        }_        for (Entry entry : entries) {_            final LeafBucketCollector leafCollector = collector.getLeafCollector(entry.context)__            DocIdSetIterator docIt = null__            if (needsScores && entry.docDeltas.size() > 0) {_                Scorer scorer = weight.scorer(entry.context)__                _                _                _                docIt = scorer.iterator()__                leafCollector.setScorer(scorer)__            }_            final PackedLongValues.Iterator docDeltaIterator = entry.docDeltas.iterator()__            final PackedLongValues.Iterator buckets = entry.buckets.iterator()__            int doc = 0__            for (long i = 0, end = entry.docDeltas.size()_ i < end_ ++i) {_                doc += docDeltaIterator.next()__                final long bucket = buckets.next()__                final long rebasedBucket = hash.find(bucket)__                if (rebasedBucket != -1) {_                    if (needsScores) {_                        if (docIt.docID() < doc) {_                            docIt.advance(doc)__                        }_                        _                        _                        assert docIt.docID() == doc__                    }_                    leafCollector.collect(doc, rebasedBucket)__                }_            }_        }__        collector.postCollection()__    };replay,the,wrapped,collector,but,only,on,a,selection,of,buckets;override,public,void,prepare,selected,buckets,long,selected,buckets,throws,ioexception,if,finished,false,throw,new,illegal,state,exception,cannot,replay,yet,collection,is,not,finished,post,collect,has,not,been,called,if,this,selected,buckets,null,throw,new,illegal,state,exception,already,been,replayed,final,long,hash,hash,new,long,hash,selected,buckets,length,big,arrays,for,long,bucket,selected,buckets,hash,add,bucket,this,selected,buckets,hash,boolean,needs,scores,collector,score,mode,needs,scores,weight,weight,null,if,needs,scores,weight,search,context,searcher,create,weight,search,context,searcher,rewrite,search,context,query,score,mode,complete,1f,for,entry,entry,entries,final,leaf,bucket,collector,leaf,collector,collector,get,leaf,collector,entry,context,doc,id,set,iterator,doc,it,null,if,needs,scores,entry,doc,deltas,size,0,scorer,scorer,weight,scorer,entry,context,doc,it,scorer,iterator,leaf,collector,set,scorer,scorer,final,packed,long,values,iterator,doc,delta,iterator,entry,doc,deltas,iterator,final,packed,long,values,iterator,buckets,entry,buckets,iterator,int,doc,0,for,long,i,0,end,entry,doc,deltas,size,i,end,i,doc,doc,delta,iterator,next,final,long,bucket,buckets,next,final,long,rebased,bucket,hash,find,bucket,if,rebased,bucket,1,if,needs,scores,if,doc,it,doc,id,doc,doc,it,advance,doc,assert,doc,it,doc,id,doc,leaf,collector,collect,doc,rebased,bucket,collector,post,collection
