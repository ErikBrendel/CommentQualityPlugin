# id;timestamp;commentText;codeText;commentWords;codeWords
Version -> public static Version min(Version version1, Version version2);1524684173;Returns the minimum version between the 2.;public static Version min(Version version1, Version version2) {_        return version1.id < version2.id ? version1 : version2__    };returns,the,minimum,version,between,the,2;public,static,version,min,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version min(Version version1, Version version2);1525645056;Returns the minimum version between the 2.;public static Version min(Version version1, Version version2) {_        return version1.id < version2.id ? version1 : version2__    };returns,the,minimum,version,between,the,2;public,static,version,min,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version min(Version version1, Version version2);1526900724;Returns the minimum version between the 2.;public static Version min(Version version1, Version version2) {_        return version1.id < version2.id ? version1 : version2__    };returns,the,minimum,version,between,the,2;public,static,version,min,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version min(Version version1, Version version2);1528917185;Returns the minimum version between the 2.;public static Version min(Version version1, Version version2) {_        return version1.id < version2.id ? version1 : version2__    };returns,the,minimum,version,between,the,2;public,static,version,min,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version min(Version version1, Version version2);1528924528;Returns the minimum version between the 2.;public static Version min(Version version1, Version version2) {_        return version1.id < version2.id ? version1 : version2__    };returns,the,minimum,version,between,the,2;public,static,version,min,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version min(Version version1, Version version2);1531179852;Returns the minimum version between the 2.;public static Version min(Version version1, Version version2) {_        return version1.id < version2.id ? version1 : version2__    };returns,the,minimum,version,between,the,2;public,static,version,min,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version min(Version version1, Version version2);1532511554;Returns the minimum version between the 2.;public static Version min(Version version1, Version version2) {_        return version1.id < version2.id ? version1 : version2__    };returns,the,minimum,version,between,the,2;public,static,version,min,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version min(Version version1, Version version2);1532534495;Returns the minimum version between the 2.;public static Version min(Version version1, Version version2) {_        return version1.id < version2.id ? version1 : version2__    };returns,the,minimum,version,between,the,2;public,static,version,min,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version min(Version version1, Version version2);1532685069;Returns the minimum version between the 2.;public static Version min(Version version1, Version version2) {_        return version1.id < version2.id ? version1 : version2__    };returns,the,minimum,version,between,the,2;public,static,version,min,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version min(Version version1, Version version2);1535057785;Returns the minimum version between the 2.;public static Version min(Version version1, Version version2) {_        return version1.id < version2.id ? version1 : version2__    };returns,the,minimum,version,between,the,2;public,static,version,min,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version min(Version version1, Version version2);1535139672;Returns the minimum version between the 2.;public static Version min(Version version1, Version version2) {_        return version1.id < version2.id ? version1 : version2__    };returns,the,minimum,version,between,the,2;public,static,version,min,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version min(Version version1, Version version2);1536137328;Returns the minimum version between the 2.;public static Version min(Version version1, Version version2) {_        return version1.id < version2.id ? version1 : version2__    };returns,the,minimum,version,between,the,2;public,static,version,min,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version min(Version version1, Version version2);1536314350;Returns the minimum version between the 2.;public static Version min(Version version1, Version version2) {_        return version1.id < version2.id ? version1 : version2__    };returns,the,minimum,version,between,the,2;public,static,version,min,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version min(Version version1, Version version2);1537300661;Returns the minimum version between the 2.;public static Version min(Version version1, Version version2) {_        return version1.id < version2.id ? version1 : version2__    };returns,the,minimum,version,between,the,2;public,static,version,min,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version min(Version version1, Version version2);1538509426;Returns the minimum version between the 2.;public static Version min(Version version1, Version version2) {_        return version1.id < version2.id ? version1 : version2__    };returns,the,minimum,version,between,the,2;public,static,version,min,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version min(Version version1, Version version2);1540486836;Returns the minimum version between the 2.;public static Version min(Version version1, Version version2) {_        return version1.id < version2.id ? version1 : version2__    };returns,the,minimum,version,between,the,2;public,static,version,min,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version min(Version version1, Version version2);1541502933;Returns the minimum version between the 2.;public static Version min(Version version1, Version version2) {_        return version1.id < version2.id ? version1 : version2__    };returns,the,minimum,version,between,the,2;public,static,version,min,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version min(Version version1, Version version2);1541528420;Returns the minimum version between the 2.;public static Version min(Version version1, Version version2) {_        return version1.id < version2.id ? version1 : version2__    };returns,the,minimum,version,between,the,2;public,static,version,min,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version min(Version version1, Version version2);1541592065;Returns the minimum version between the 2.;public static Version min(Version version1, Version version2) {_        return version1.id < version2.id ? version1 : version2__    };returns,the,minimum,version,between,the,2;public,static,version,min,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version min(Version version1, Version version2);1542226101;Returns the minimum version between the 2.;public static Version min(Version version1, Version version2) {_        return version1.id < version2.id ? version1 : version2__    };returns,the,minimum,version,between,the,2;public,static,version,min,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version min(Version version1, Version version2);1542746006;Returns the minimum version between the 2.;public static Version min(Version version1, Version version2) {_        return version1.id < version2.id ? version1 : version2__    };returns,the,minimum,version,between,the,2;public,static,version,min,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version min(Version version1, Version version2);1543473699;Returns the minimum version between the 2.;public static Version min(Version version1, Version version2) {_        return version1.id < version2.id ? version1 : version2__    };returns,the,minimum,version,between,the,2;public,static,version,min,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version min(Version version1, Version version2);1543942400;Returns the minimum version between the 2.;public static Version min(Version version1, Version version2) {_        return version1.id < version2.id ? version1 : version2__    };returns,the,minimum,version,between,the,2;public,static,version,min,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version min(Version version1, Version version2);1544037309;Returns the minimum version between the 2.;public static Version min(Version version1, Version version2) {_        return version1.id < version2.id ? version1 : version2__    };returns,the,minimum,version,between,the,2;public,static,version,min,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version min(Version version1, Version version2);1544553539;Returns the minimum version between the 2.;public static Version min(Version version1, Version version2) {_        return version1.id < version2.id ? version1 : version2__    };returns,the,minimum,version,between,the,2;public,static,version,min,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version min(Version version1, Version version2);1545225850;Returns the minimum version between the 2.;public static Version min(Version version1, Version version2) {_        return version1.id < version2.id ? version1 : version2__    };returns,the,minimum,version,between,the,2;public,static,version,min,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version min(Version version1, Version version2);1545256934;Returns the minimum version between the 2.;public static Version min(Version version1, Version version2) {_        return version1.id < version2.id ? version1 : version2__    };returns,the,minimum,version,between,the,2;public,static,version,min,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version min(Version version1, Version version2);1546507247;Returns the minimum version between the 2.;public static Version min(Version version1, Version version2) {_        return version1.id < version2.id ? version1 : version2__    };returns,the,minimum,version,between,the,2;public,static,version,min,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version min(Version version1, Version version2);1546537951;Returns the minimum version between the 2.;public static Version min(Version version1, Version version2) {_        return version1.id < version2.id ? version1 : version2__    };returns,the,minimum,version,between,the,2;public,static,version,min,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version min(Version version1, Version version2);1548755041;Returns the minimum version between the 2.;public static Version min(Version version1, Version version2) {_        return version1.id < version2.id ? version1 : version2__    };returns,the,minimum,version,between,the,2;public,static,version,min,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version min(Version version1, Version version2);1548822781;Returns the minimum version between the 2.;public static Version min(Version version1, Version version2) {_        return version1.id < version2.id ? version1 : version2__    };returns,the,minimum,version,between,the,2;public,static,version,min,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version min(Version version1, Version version2);1549608646;Returns the minimum version between the 2.;public static Version min(Version version1, Version version2) {_        return version1.id < version2.id ? version1 : version2__    };returns,the,minimum,version,between,the,2;public,static,version,min,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version min(Version version1, Version version2);1550604529;Returns the minimum version between the 2.;public static Version min(Version version1, Version version2) {_        return version1.id < version2.id ? version1 : version2__    };returns,the,minimum,version,between,the,2;public,static,version,min,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public Version minimumIndexCompatibilityVersion();1524684173;Returns the minimum created index version that this version supports. Indices created with lower versions_can't be used with this version. This should also be used for file based serialization backwards compatibility ie. on serialization_code that is used to read / write file formats like transaction logs, cluster state, and index metadata.;public Version minimumIndexCompatibilityVersion() {_        final int bwcMajor__        if (major == 5) {_            bwcMajor = 2_ _        } else if (major == 7) {_            return V_6_0_0_beta1__        } else {_            bwcMajor = major - 1__        }_        final int bwcMinor = 0__        return Version.min(this, fromId(bwcMajor * 1000000 + bwcMinor * 10000 + 99))__    };returns,the,minimum,created,index,version,that,this,version,supports,indices,created,with,lower,versions,can,t,be,used,with,this,version,this,should,also,be,used,for,file,based,serialization,backwards,compatibility,ie,on,serialization,code,that,is,used,to,read,write,file,formats,like,transaction,logs,cluster,state,and,index,metadata;public,version,minimum,index,compatibility,version,final,int,bwc,major,if,major,5,bwc,major,2,else,if,major,7,return,else,bwc,major,major,1,final,int,bwc,minor,0,return,version,min,this,from,id,bwc,major,1000000,bwc,minor,10000,99
Version -> public Version minimumIndexCompatibilityVersion();1525645056;Returns the minimum created index version that this version supports. Indices created with lower versions_can't be used with this version. This should also be used for file based serialization backwards compatibility ie. on serialization_code that is used to read / write file formats like transaction logs, cluster state, and index metadata.;public Version minimumIndexCompatibilityVersion() {_        final int bwcMajor__        if (major == 5) {_            bwcMajor = 2_ _        } else if (major == 7) {_            return V_6_0_0_beta1__        } else {_            bwcMajor = major - 1__        }_        final int bwcMinor = 0__        return Version.min(this, fromId(bwcMajor * 1000000 + bwcMinor * 10000 + 99))__    };returns,the,minimum,created,index,version,that,this,version,supports,indices,created,with,lower,versions,can,t,be,used,with,this,version,this,should,also,be,used,for,file,based,serialization,backwards,compatibility,ie,on,serialization,code,that,is,used,to,read,write,file,formats,like,transaction,logs,cluster,state,and,index,metadata;public,version,minimum,index,compatibility,version,final,int,bwc,major,if,major,5,bwc,major,2,else,if,major,7,return,else,bwc,major,major,1,final,int,bwc,minor,0,return,version,min,this,from,id,bwc,major,1000000,bwc,minor,10000,99
Version -> public Version minimumIndexCompatibilityVersion();1526900724;Returns the minimum created index version that this version supports. Indices created with lower versions_can't be used with this version. This should also be used for file based serialization backwards compatibility ie. on serialization_code that is used to read / write file formats like transaction logs, cluster state, and index metadata.;public Version minimumIndexCompatibilityVersion() {_        final int bwcMajor__        if (major == 5) {_            bwcMajor = 2_ _        } else if (major == 7) {_            return V_6_0_0_beta1__        } else {_            bwcMajor = major - 1__        }_        final int bwcMinor = 0__        return Version.min(this, fromId(bwcMajor * 1000000 + bwcMinor * 10000 + 99))__    };returns,the,minimum,created,index,version,that,this,version,supports,indices,created,with,lower,versions,can,t,be,used,with,this,version,this,should,also,be,used,for,file,based,serialization,backwards,compatibility,ie,on,serialization,code,that,is,used,to,read,write,file,formats,like,transaction,logs,cluster,state,and,index,metadata;public,version,minimum,index,compatibility,version,final,int,bwc,major,if,major,5,bwc,major,2,else,if,major,7,return,else,bwc,major,major,1,final,int,bwc,minor,0,return,version,min,this,from,id,bwc,major,1000000,bwc,minor,10000,99
Version -> public Version minimumIndexCompatibilityVersion();1528917185;Returns the minimum created index version that this version supports. Indices created with lower versions_can't be used with this version. This should also be used for file based serialization backwards compatibility ie. on serialization_code that is used to read / write file formats like transaction logs, cluster state, and index metadata.;public Version minimumIndexCompatibilityVersion() {_        final int bwcMajor__        if (major == 5) {_            bwcMajor = 2_ _        } else if (major == 7) {_            return V_6_0_0_beta1__        } else {_            bwcMajor = major - 1__        }_        final int bwcMinor = 0__        return Version.min(this, fromId(bwcMajor * 1000000 + bwcMinor * 10000 + 99))__    };returns,the,minimum,created,index,version,that,this,version,supports,indices,created,with,lower,versions,can,t,be,used,with,this,version,this,should,also,be,used,for,file,based,serialization,backwards,compatibility,ie,on,serialization,code,that,is,used,to,read,write,file,formats,like,transaction,logs,cluster,state,and,index,metadata;public,version,minimum,index,compatibility,version,final,int,bwc,major,if,major,5,bwc,major,2,else,if,major,7,return,else,bwc,major,major,1,final,int,bwc,minor,0,return,version,min,this,from,id,bwc,major,1000000,bwc,minor,10000,99
Version -> public Version minimumIndexCompatibilityVersion();1528924528;Returns the minimum created index version that this version supports. Indices created with lower versions_can't be used with this version. This should also be used for file based serialization backwards compatibility ie. on serialization_code that is used to read / write file formats like transaction logs, cluster state, and index metadata.;public Version minimumIndexCompatibilityVersion() {_        final int bwcMajor__        if (major == 5) {_            bwcMajor = 2_ _        } else if (major == 7) {_            return V_6_0_0_beta1__        } else {_            bwcMajor = major - 1__        }_        final int bwcMinor = 0__        return Version.min(this, fromId(bwcMajor * 1000000 + bwcMinor * 10000 + 99))__    };returns,the,minimum,created,index,version,that,this,version,supports,indices,created,with,lower,versions,can,t,be,used,with,this,version,this,should,also,be,used,for,file,based,serialization,backwards,compatibility,ie,on,serialization,code,that,is,used,to,read,write,file,formats,like,transaction,logs,cluster,state,and,index,metadata;public,version,minimum,index,compatibility,version,final,int,bwc,major,if,major,5,bwc,major,2,else,if,major,7,return,else,bwc,major,major,1,final,int,bwc,minor,0,return,version,min,this,from,id,bwc,major,1000000,bwc,minor,10000,99
Version -> public Version minimumIndexCompatibilityVersion();1531179852;Returns the minimum created index version that this version supports. Indices created with lower versions_can't be used with this version. This should also be used for file based serialization backwards compatibility ie. on serialization_code that is used to read / write file formats like transaction logs, cluster state, and index metadata.;public Version minimumIndexCompatibilityVersion() {_        final int bwcMajor__        if (major == 5) {_            bwcMajor = 2_ _        } else if (major == 7) {_            return V_6_0_0_beta1__        } else {_            bwcMajor = major - 1__        }_        final int bwcMinor = 0__        return Version.min(this, fromId(bwcMajor * 1000000 + bwcMinor * 10000 + 99))__    };returns,the,minimum,created,index,version,that,this,version,supports,indices,created,with,lower,versions,can,t,be,used,with,this,version,this,should,also,be,used,for,file,based,serialization,backwards,compatibility,ie,on,serialization,code,that,is,used,to,read,write,file,formats,like,transaction,logs,cluster,state,and,index,metadata;public,version,minimum,index,compatibility,version,final,int,bwc,major,if,major,5,bwc,major,2,else,if,major,7,return,else,bwc,major,major,1,final,int,bwc,minor,0,return,version,min,this,from,id,bwc,major,1000000,bwc,minor,10000,99
Version -> public Version minimumIndexCompatibilityVersion();1532511554;Returns the minimum created index version that this version supports. Indices created with lower versions_can't be used with this version. This should also be used for file based serialization backwards compatibility ie. on serialization_code that is used to read / write file formats like transaction logs, cluster state, and index metadata.;public Version minimumIndexCompatibilityVersion() {_        final int bwcMajor__        if (major == 5) {_            bwcMajor = 2_ _        } else if (major == 7) {_            return V_6_0_0_beta1__        } else {_            bwcMajor = major - 1__        }_        final int bwcMinor = 0__        return Version.min(this, fromId(bwcMajor * 1000000 + bwcMinor * 10000 + 99))__    };returns,the,minimum,created,index,version,that,this,version,supports,indices,created,with,lower,versions,can,t,be,used,with,this,version,this,should,also,be,used,for,file,based,serialization,backwards,compatibility,ie,on,serialization,code,that,is,used,to,read,write,file,formats,like,transaction,logs,cluster,state,and,index,metadata;public,version,minimum,index,compatibility,version,final,int,bwc,major,if,major,5,bwc,major,2,else,if,major,7,return,else,bwc,major,major,1,final,int,bwc,minor,0,return,version,min,this,from,id,bwc,major,1000000,bwc,minor,10000,99
Version -> public Version minimumIndexCompatibilityVersion();1532534495;Returns the minimum created index version that this version supports. Indices created with lower versions_can't be used with this version. This should also be used for file based serialization backwards compatibility ie. on serialization_code that is used to read / write file formats like transaction logs, cluster state, and index metadata.;public Version minimumIndexCompatibilityVersion() {_        final int bwcMajor__        if (major == 5) {_            bwcMajor = 2_ _        } else if (major == 7) {_            return V_6_0_0_beta1__        } else {_            bwcMajor = major - 1__        }_        final int bwcMinor = 0__        return Version.min(this, fromId(bwcMajor * 1000000 + bwcMinor * 10000 + 99))__    };returns,the,minimum,created,index,version,that,this,version,supports,indices,created,with,lower,versions,can,t,be,used,with,this,version,this,should,also,be,used,for,file,based,serialization,backwards,compatibility,ie,on,serialization,code,that,is,used,to,read,write,file,formats,like,transaction,logs,cluster,state,and,index,metadata;public,version,minimum,index,compatibility,version,final,int,bwc,major,if,major,5,bwc,major,2,else,if,major,7,return,else,bwc,major,major,1,final,int,bwc,minor,0,return,version,min,this,from,id,bwc,major,1000000,bwc,minor,10000,99
Version -> public Version minimumIndexCompatibilityVersion();1532685069;Returns the minimum created index version that this version supports. Indices created with lower versions_can't be used with this version. This should also be used for file based serialization backwards compatibility ie. on serialization_code that is used to read / write file formats like transaction logs, cluster state, and index metadata.;public Version minimumIndexCompatibilityVersion() {_        final int bwcMajor__        if (major == 5) {_            bwcMajor = 2_ _        } else if (major == 7) {_            return V_6_0_0_beta1__        } else {_            bwcMajor = major - 1__        }_        final int bwcMinor = 0__        return Version.min(this, fromId(bwcMajor * 1000000 + bwcMinor * 10000 + 99))__    };returns,the,minimum,created,index,version,that,this,version,supports,indices,created,with,lower,versions,can,t,be,used,with,this,version,this,should,also,be,used,for,file,based,serialization,backwards,compatibility,ie,on,serialization,code,that,is,used,to,read,write,file,formats,like,transaction,logs,cluster,state,and,index,metadata;public,version,minimum,index,compatibility,version,final,int,bwc,major,if,major,5,bwc,major,2,else,if,major,7,return,else,bwc,major,major,1,final,int,bwc,minor,0,return,version,min,this,from,id,bwc,major,1000000,bwc,minor,10000,99
Version -> public Version minimumIndexCompatibilityVersion();1535057785;Returns the minimum created index version that this version supports. Indices created with lower versions_can't be used with this version. This should also be used for file based serialization backwards compatibility ie. on serialization_code that is used to read / write file formats like transaction logs, cluster state, and index metadata.;public Version minimumIndexCompatibilityVersion() {_        final int bwcMajor__        if (major == 5) {_            bwcMajor = 2_ _        } else if (major == 7) {_            return V_6_0_0_beta1__        } else {_            bwcMajor = major - 1__        }_        final int bwcMinor = 0__        return Version.min(this, fromId(bwcMajor * 1000000 + bwcMinor * 10000 + 99))__    };returns,the,minimum,created,index,version,that,this,version,supports,indices,created,with,lower,versions,can,t,be,used,with,this,version,this,should,also,be,used,for,file,based,serialization,backwards,compatibility,ie,on,serialization,code,that,is,used,to,read,write,file,formats,like,transaction,logs,cluster,state,and,index,metadata;public,version,minimum,index,compatibility,version,final,int,bwc,major,if,major,5,bwc,major,2,else,if,major,7,return,else,bwc,major,major,1,final,int,bwc,minor,0,return,version,min,this,from,id,bwc,major,1000000,bwc,minor,10000,99
Version -> public Version minimumIndexCompatibilityVersion();1535139672;Returns the minimum created index version that this version supports. Indices created with lower versions_can't be used with this version. This should also be used for file based serialization backwards compatibility ie. on serialization_code that is used to read / write file formats like transaction logs, cluster state, and index metadata.;public Version minimumIndexCompatibilityVersion() {_        final int bwcMajor__        if (major == 5) {_            bwcMajor = 2_ _        } else if (major == 7) {_            return V_6_0_0_beta1__        } else {_            bwcMajor = major - 1__        }_        final int bwcMinor = 0__        return Version.min(this, fromId(bwcMajor * 1000000 + bwcMinor * 10000 + 99))__    };returns,the,minimum,created,index,version,that,this,version,supports,indices,created,with,lower,versions,can,t,be,used,with,this,version,this,should,also,be,used,for,file,based,serialization,backwards,compatibility,ie,on,serialization,code,that,is,used,to,read,write,file,formats,like,transaction,logs,cluster,state,and,index,metadata;public,version,minimum,index,compatibility,version,final,int,bwc,major,if,major,5,bwc,major,2,else,if,major,7,return,else,bwc,major,major,1,final,int,bwc,minor,0,return,version,min,this,from,id,bwc,major,1000000,bwc,minor,10000,99
Version -> public Version minimumIndexCompatibilityVersion();1536137328;Returns the minimum created index version that this version supports. Indices created with lower versions_can't be used with this version. This should also be used for file based serialization backwards compatibility ie. on serialization_code that is used to read / write file formats like transaction logs, cluster state, and index metadata.;public Version minimumIndexCompatibilityVersion() {_        final int bwcMajor__        if (major == 5) {_            bwcMajor = 2_ _        } else if (major == 7) {_            return V_6_0_0_beta1__        } else {_            bwcMajor = major - 1__        }_        final int bwcMinor = 0__        return Version.min(this, fromId(bwcMajor * 1000000 + bwcMinor * 10000 + 99))__    };returns,the,minimum,created,index,version,that,this,version,supports,indices,created,with,lower,versions,can,t,be,used,with,this,version,this,should,also,be,used,for,file,based,serialization,backwards,compatibility,ie,on,serialization,code,that,is,used,to,read,write,file,formats,like,transaction,logs,cluster,state,and,index,metadata;public,version,minimum,index,compatibility,version,final,int,bwc,major,if,major,5,bwc,major,2,else,if,major,7,return,else,bwc,major,major,1,final,int,bwc,minor,0,return,version,min,this,from,id,bwc,major,1000000,bwc,minor,10000,99
Version -> public Version minimumIndexCompatibilityVersion();1536314350;Returns the minimum created index version that this version supports. Indices created with lower versions_can't be used with this version. This should also be used for file based serialization backwards compatibility ie. on serialization_code that is used to read / write file formats like transaction logs, cluster state, and index metadata.;public Version minimumIndexCompatibilityVersion() {_        final int bwcMajor__        if (major == 5) {_            bwcMajor = 2_ _        } else if (major == 7) {_            return V_6_0_0_beta1__        } else {_            bwcMajor = major - 1__        }_        final int bwcMinor = 0__        return Version.min(this, fromId(bwcMajor * 1000000 + bwcMinor * 10000 + 99))__    };returns,the,minimum,created,index,version,that,this,version,supports,indices,created,with,lower,versions,can,t,be,used,with,this,version,this,should,also,be,used,for,file,based,serialization,backwards,compatibility,ie,on,serialization,code,that,is,used,to,read,write,file,formats,like,transaction,logs,cluster,state,and,index,metadata;public,version,minimum,index,compatibility,version,final,int,bwc,major,if,major,5,bwc,major,2,else,if,major,7,return,else,bwc,major,major,1,final,int,bwc,minor,0,return,version,min,this,from,id,bwc,major,1000000,bwc,minor,10000,99
Version -> public Version minimumIndexCompatibilityVersion();1537300661;Returns the minimum created index version that this version supports. Indices created with lower versions_can't be used with this version. This should also be used for file based serialization backwards compatibility ie. on serialization_code that is used to read / write file formats like transaction logs, cluster state, and index metadata.;public Version minimumIndexCompatibilityVersion() {_        final int bwcMajor__        if (major == 5) {_            bwcMajor = 2_ _        } else if (major == 7) {_            return V_6_0_0_beta1__        } else {_            bwcMajor = major - 1__        }_        final int bwcMinor = 0__        return Version.min(this, fromId(bwcMajor * 1000000 + bwcMinor * 10000 + 99))__    };returns,the,minimum,created,index,version,that,this,version,supports,indices,created,with,lower,versions,can,t,be,used,with,this,version,this,should,also,be,used,for,file,based,serialization,backwards,compatibility,ie,on,serialization,code,that,is,used,to,read,write,file,formats,like,transaction,logs,cluster,state,and,index,metadata;public,version,minimum,index,compatibility,version,final,int,bwc,major,if,major,5,bwc,major,2,else,if,major,7,return,else,bwc,major,major,1,final,int,bwc,minor,0,return,version,min,this,from,id,bwc,major,1000000,bwc,minor,10000,99
Version -> public Version minimumIndexCompatibilityVersion();1538509426;Returns the minimum created index version that this version supports. Indices created with lower versions_can't be used with this version. This should also be used for file based serialization backwards compatibility ie. on serialization_code that is used to read / write file formats like transaction logs, cluster state, and index metadata.;public Version minimumIndexCompatibilityVersion() {_        final int bwcMajor__        if (major == 5) {_            bwcMajor = 2_ _        } else if (major == 7) {_            return V_6_0_0_beta1__        } else {_            bwcMajor = major - 1__        }_        final int bwcMinor = 0__        return Version.min(this, fromId(bwcMajor * 1000000 + bwcMinor * 10000 + 99))__    };returns,the,minimum,created,index,version,that,this,version,supports,indices,created,with,lower,versions,can,t,be,used,with,this,version,this,should,also,be,used,for,file,based,serialization,backwards,compatibility,ie,on,serialization,code,that,is,used,to,read,write,file,formats,like,transaction,logs,cluster,state,and,index,metadata;public,version,minimum,index,compatibility,version,final,int,bwc,major,if,major,5,bwc,major,2,else,if,major,7,return,else,bwc,major,major,1,final,int,bwc,minor,0,return,version,min,this,from,id,bwc,major,1000000,bwc,minor,10000,99
Version -> public Version minimumIndexCompatibilityVersion();1540486836;Returns the minimum created index version that this version supports. Indices created with lower versions_can't be used with this version. This should also be used for file based serialization backwards compatibility ie. on serialization_code that is used to read / write file formats like transaction logs, cluster state, and index metadata.;public Version minimumIndexCompatibilityVersion() {_        final int bwcMajor__        if (major == 5) {_            bwcMajor = 2_ _        } else if (major == 7) {_            return V_6_0_0_beta1__        } else {_            bwcMajor = major - 1__        }_        final int bwcMinor = 0__        return Version.min(this, fromId(bwcMajor * 1000000 + bwcMinor * 10000 + 99))__    };returns,the,minimum,created,index,version,that,this,version,supports,indices,created,with,lower,versions,can,t,be,used,with,this,version,this,should,also,be,used,for,file,based,serialization,backwards,compatibility,ie,on,serialization,code,that,is,used,to,read,write,file,formats,like,transaction,logs,cluster,state,and,index,metadata;public,version,minimum,index,compatibility,version,final,int,bwc,major,if,major,5,bwc,major,2,else,if,major,7,return,else,bwc,major,major,1,final,int,bwc,minor,0,return,version,min,this,from,id,bwc,major,1000000,bwc,minor,10000,99
Version -> public Version minimumIndexCompatibilityVersion();1541502933;Returns the minimum created index version that this version supports. Indices created with lower versions_can't be used with this version. This should also be used for file based serialization backwards compatibility ie. on serialization_code that is used to read / write file formats like transaction logs, cluster state, and index metadata.;public Version minimumIndexCompatibilityVersion() {_        final int bwcMajor__        if (major == 5) {_            bwcMajor = 2_ _        } else if (major == 7) {_            return V_6_0_0_beta1__        } else {_            bwcMajor = major - 1__        }_        final int bwcMinor = 0__        return Version.min(this, fromId(bwcMajor * 1000000 + bwcMinor * 10000 + 99))__    };returns,the,minimum,created,index,version,that,this,version,supports,indices,created,with,lower,versions,can,t,be,used,with,this,version,this,should,also,be,used,for,file,based,serialization,backwards,compatibility,ie,on,serialization,code,that,is,used,to,read,write,file,formats,like,transaction,logs,cluster,state,and,index,metadata;public,version,minimum,index,compatibility,version,final,int,bwc,major,if,major,5,bwc,major,2,else,if,major,7,return,else,bwc,major,major,1,final,int,bwc,minor,0,return,version,min,this,from,id,bwc,major,1000000,bwc,minor,10000,99
Version -> public Version minimumIndexCompatibilityVersion();1541528420;Returns the minimum created index version that this version supports. Indices created with lower versions_can't be used with this version. This should also be used for file based serialization backwards compatibility ie. on serialization_code that is used to read / write file formats like transaction logs, cluster state, and index metadata.;public Version minimumIndexCompatibilityVersion() {_        final int bwcMajor__        if (major == 5) {_            bwcMajor = 2_ _        } else if (major == 7) {_            return V_6_0_0_beta1__        } else {_            bwcMajor = major - 1__        }_        final int bwcMinor = 0__        return Version.min(this, fromId(bwcMajor * 1000000 + bwcMinor * 10000 + 99))__    };returns,the,minimum,created,index,version,that,this,version,supports,indices,created,with,lower,versions,can,t,be,used,with,this,version,this,should,also,be,used,for,file,based,serialization,backwards,compatibility,ie,on,serialization,code,that,is,used,to,read,write,file,formats,like,transaction,logs,cluster,state,and,index,metadata;public,version,minimum,index,compatibility,version,final,int,bwc,major,if,major,5,bwc,major,2,else,if,major,7,return,else,bwc,major,major,1,final,int,bwc,minor,0,return,version,min,this,from,id,bwc,major,1000000,bwc,minor,10000,99
Version -> public Version minimumIndexCompatibilityVersion();1541592065;Returns the minimum created index version that this version supports. Indices created with lower versions_can't be used with this version. This should also be used for file based serialization backwards compatibility ie. on serialization_code that is used to read / write file formats like transaction logs, cluster state, and index metadata.;public Version minimumIndexCompatibilityVersion() {_        final int bwcMajor__        if (major == 5) {_            bwcMajor = 2_ _        } else if (major == 7) {_            return V_6_0_0_beta1__        } else {_            bwcMajor = major - 1__        }_        final int bwcMinor = 0__        return Version.min(this, fromId(bwcMajor * 1000000 + bwcMinor * 10000 + 99))__    };returns,the,minimum,created,index,version,that,this,version,supports,indices,created,with,lower,versions,can,t,be,used,with,this,version,this,should,also,be,used,for,file,based,serialization,backwards,compatibility,ie,on,serialization,code,that,is,used,to,read,write,file,formats,like,transaction,logs,cluster,state,and,index,metadata;public,version,minimum,index,compatibility,version,final,int,bwc,major,if,major,5,bwc,major,2,else,if,major,7,return,else,bwc,major,major,1,final,int,bwc,minor,0,return,version,min,this,from,id,bwc,major,1000000,bwc,minor,10000,99
Version -> public Version minimumIndexCompatibilityVersion();1542226101;Returns the minimum created index version that this version supports. Indices created with lower versions_can't be used with this version. This should also be used for file based serialization backwards compatibility ie. on serialization_code that is used to read / write file formats like transaction logs, cluster state, and index metadata.;public Version minimumIndexCompatibilityVersion() {_        final int bwcMajor__        if (major == 5) {_            bwcMajor = 2_ _        } else if (major == 7) {_            return V_6_0_0_beta1__        } else {_            bwcMajor = major - 1__        }_        final int bwcMinor = 0__        return Version.min(this, fromId(bwcMajor * 1000000 + bwcMinor * 10000 + 99))__    };returns,the,minimum,created,index,version,that,this,version,supports,indices,created,with,lower,versions,can,t,be,used,with,this,version,this,should,also,be,used,for,file,based,serialization,backwards,compatibility,ie,on,serialization,code,that,is,used,to,read,write,file,formats,like,transaction,logs,cluster,state,and,index,metadata;public,version,minimum,index,compatibility,version,final,int,bwc,major,if,major,5,bwc,major,2,else,if,major,7,return,else,bwc,major,major,1,final,int,bwc,minor,0,return,version,min,this,from,id,bwc,major,1000000,bwc,minor,10000,99
Version -> public Version minimumIndexCompatibilityVersion();1542746006;Returns the minimum created index version that this version supports. Indices created with lower versions_can't be used with this version. This should also be used for file based serialization backwards compatibility ie. on serialization_code that is used to read / write file formats like transaction logs, cluster state, and index metadata.;public Version minimumIndexCompatibilityVersion() {_        final int bwcMajor__        if (major == 5) {_            bwcMajor = 2_ _        } else if (major == 7) {_            return V_6_0_0_beta1__        } else {_            bwcMajor = major - 1__        }_        final int bwcMinor = 0__        return Version.min(this, fromId(bwcMajor * 1000000 + bwcMinor * 10000 + 99))__    };returns,the,minimum,created,index,version,that,this,version,supports,indices,created,with,lower,versions,can,t,be,used,with,this,version,this,should,also,be,used,for,file,based,serialization,backwards,compatibility,ie,on,serialization,code,that,is,used,to,read,write,file,formats,like,transaction,logs,cluster,state,and,index,metadata;public,version,minimum,index,compatibility,version,final,int,bwc,major,if,major,5,bwc,major,2,else,if,major,7,return,else,bwc,major,major,1,final,int,bwc,minor,0,return,version,min,this,from,id,bwc,major,1000000,bwc,minor,10000,99
Version -> public Version minimumIndexCompatibilityVersion();1543473699;Returns the minimum created index version that this version supports. Indices created with lower versions_can't be used with this version. This should also be used for file based serialization backwards compatibility ie. on serialization_code that is used to read / write file formats like transaction logs, cluster state, and index metadata.;public Version minimumIndexCompatibilityVersion() {_        final int bwcMajor__        if (major == 5) {_            bwcMajor = 2_ _        } else if (major == 7) {_            return V_6_0_0_beta1__        } else {_            bwcMajor = major - 1__        }_        final int bwcMinor = 0__        return Version.min(this, fromId(bwcMajor * 1000000 + bwcMinor * 10000 + 99))__    };returns,the,minimum,created,index,version,that,this,version,supports,indices,created,with,lower,versions,can,t,be,used,with,this,version,this,should,also,be,used,for,file,based,serialization,backwards,compatibility,ie,on,serialization,code,that,is,used,to,read,write,file,formats,like,transaction,logs,cluster,state,and,index,metadata;public,version,minimum,index,compatibility,version,final,int,bwc,major,if,major,5,bwc,major,2,else,if,major,7,return,else,bwc,major,major,1,final,int,bwc,minor,0,return,version,min,this,from,id,bwc,major,1000000,bwc,minor,10000,99
Version -> public Version minimumIndexCompatibilityVersion();1543942400;Returns the minimum created index version that this version supports. Indices created with lower versions_can't be used with this version. This should also be used for file based serialization backwards compatibility ie. on serialization_code that is used to read / write file formats like transaction logs, cluster state, and index metadata.;public Version minimumIndexCompatibilityVersion() {_        final int bwcMajor__        if (major == 5) {_            bwcMajor = 2_ _        } else if (major == 7) {_            return V_6_0_0_beta1__        } else {_            bwcMajor = major - 1__        }_        final int bwcMinor = 0__        return Version.min(this, fromId(bwcMajor * 1000000 + bwcMinor * 10000 + 99))__    };returns,the,minimum,created,index,version,that,this,version,supports,indices,created,with,lower,versions,can,t,be,used,with,this,version,this,should,also,be,used,for,file,based,serialization,backwards,compatibility,ie,on,serialization,code,that,is,used,to,read,write,file,formats,like,transaction,logs,cluster,state,and,index,metadata;public,version,minimum,index,compatibility,version,final,int,bwc,major,if,major,5,bwc,major,2,else,if,major,7,return,else,bwc,major,major,1,final,int,bwc,minor,0,return,version,min,this,from,id,bwc,major,1000000,bwc,minor,10000,99
Version -> public Version minimumIndexCompatibilityVersion();1544037309;Returns the minimum created index version that this version supports. Indices created with lower versions_can't be used with this version. This should also be used for file based serialization backwards compatibility ie. on serialization_code that is used to read / write file formats like transaction logs, cluster state, and index metadata.;public Version minimumIndexCompatibilityVersion() {_        final int bwcMajor__        if (major == 5) {_            bwcMajor = 2_ _        } else if (major == 7) {_            return V_6_0_0_beta1__        } else {_            bwcMajor = major - 1__        }_        final int bwcMinor = 0__        return Version.min(this, fromId(bwcMajor * 1000000 + bwcMinor * 10000 + 99))__    };returns,the,minimum,created,index,version,that,this,version,supports,indices,created,with,lower,versions,can,t,be,used,with,this,version,this,should,also,be,used,for,file,based,serialization,backwards,compatibility,ie,on,serialization,code,that,is,used,to,read,write,file,formats,like,transaction,logs,cluster,state,and,index,metadata;public,version,minimum,index,compatibility,version,final,int,bwc,major,if,major,5,bwc,major,2,else,if,major,7,return,else,bwc,major,major,1,final,int,bwc,minor,0,return,version,min,this,from,id,bwc,major,1000000,bwc,minor,10000,99
Version -> public Version minimumIndexCompatibilityVersion();1544553539;Returns the minimum created index version that this version supports. Indices created with lower versions_can't be used with this version. This should also be used for file based serialization backwards compatibility ie. on serialization_code that is used to read / write file formats like transaction logs, cluster state, and index metadata.;public Version minimumIndexCompatibilityVersion() {_        final int bwcMajor__        if (major == 5) {_            bwcMajor = 2_ _        } else if (major == 7) {_            return V_6_0_0_beta1__        } else {_            bwcMajor = major - 1__        }_        final int bwcMinor = 0__        return Version.min(this, fromId(bwcMajor * 1000000 + bwcMinor * 10000 + 99))__    };returns,the,minimum,created,index,version,that,this,version,supports,indices,created,with,lower,versions,can,t,be,used,with,this,version,this,should,also,be,used,for,file,based,serialization,backwards,compatibility,ie,on,serialization,code,that,is,used,to,read,write,file,formats,like,transaction,logs,cluster,state,and,index,metadata;public,version,minimum,index,compatibility,version,final,int,bwc,major,if,major,5,bwc,major,2,else,if,major,7,return,else,bwc,major,major,1,final,int,bwc,minor,0,return,version,min,this,from,id,bwc,major,1000000,bwc,minor,10000,99
Version -> public Version minimumIndexCompatibilityVersion();1545225850;Returns the minimum created index version that this version supports. Indices created with lower versions_can't be used with this version. This should also be used for file based serialization backwards compatibility ie. on serialization_code that is used to read / write file formats like transaction logs, cluster state, and index metadata.;public Version minimumIndexCompatibilityVersion() {_        final int bwcMajor__        if (major == 5) {_            bwcMajor = 2_ _        } else if (major == 7) {_            return V_6_0_0_beta1__        } else {_            bwcMajor = major - 1__        }_        final int bwcMinor = 0__        return Version.min(this, fromId(bwcMajor * 1000000 + bwcMinor * 10000 + 99))__    };returns,the,minimum,created,index,version,that,this,version,supports,indices,created,with,lower,versions,can,t,be,used,with,this,version,this,should,also,be,used,for,file,based,serialization,backwards,compatibility,ie,on,serialization,code,that,is,used,to,read,write,file,formats,like,transaction,logs,cluster,state,and,index,metadata;public,version,minimum,index,compatibility,version,final,int,bwc,major,if,major,5,bwc,major,2,else,if,major,7,return,else,bwc,major,major,1,final,int,bwc,minor,0,return,version,min,this,from,id,bwc,major,1000000,bwc,minor,10000,99
Version -> public Version minimumIndexCompatibilityVersion();1545256934;Returns the minimum created index version that this version supports. Indices created with lower versions_can't be used with this version. This should also be used for file based serialization backwards compatibility ie. on serialization_code that is used to read / write file formats like transaction logs, cluster state, and index metadata.;public Version minimumIndexCompatibilityVersion() {_        final int bwcMajor__        if (major == 5) {_            bwcMajor = 2_ _        } else if (major == 7) {_            return V_6_0_0_beta1__        } else {_            bwcMajor = major - 1__        }_        final int bwcMinor = 0__        return Version.min(this, fromId(bwcMajor * 1000000 + bwcMinor * 10000 + 99))__    };returns,the,minimum,created,index,version,that,this,version,supports,indices,created,with,lower,versions,can,t,be,used,with,this,version,this,should,also,be,used,for,file,based,serialization,backwards,compatibility,ie,on,serialization,code,that,is,used,to,read,write,file,formats,like,transaction,logs,cluster,state,and,index,metadata;public,version,minimum,index,compatibility,version,final,int,bwc,major,if,major,5,bwc,major,2,else,if,major,7,return,else,bwc,major,major,1,final,int,bwc,minor,0,return,version,min,this,from,id,bwc,major,1000000,bwc,minor,10000,99
Version -> public Version minimumIndexCompatibilityVersion();1546507247;Returns the minimum created index version that this version supports. Indices created with lower versions_can't be used with this version. This should also be used for file based serialization backwards compatibility ie. on serialization_code that is used to read / write file formats like transaction logs, cluster state, and index metadata.;public Version minimumIndexCompatibilityVersion() {_        final int bwcMajor__        if (major == 5) {_            bwcMajor = 2_ _        } else if (major == 7) {_            return V_6_0_0_beta1__        } else {_            bwcMajor = major - 1__        }_        final int bwcMinor = 0__        return Version.min(this, fromId(bwcMajor * 1000000 + bwcMinor * 10000 + 99))__    };returns,the,minimum,created,index,version,that,this,version,supports,indices,created,with,lower,versions,can,t,be,used,with,this,version,this,should,also,be,used,for,file,based,serialization,backwards,compatibility,ie,on,serialization,code,that,is,used,to,read,write,file,formats,like,transaction,logs,cluster,state,and,index,metadata;public,version,minimum,index,compatibility,version,final,int,bwc,major,if,major,5,bwc,major,2,else,if,major,7,return,else,bwc,major,major,1,final,int,bwc,minor,0,return,version,min,this,from,id,bwc,major,1000000,bwc,minor,10000,99
Version -> public Version minimumIndexCompatibilityVersion();1546537951;Returns the minimum created index version that this version supports. Indices created with lower versions_can't be used with this version. This should also be used for file based serialization backwards compatibility ie. on serialization_code that is used to read / write file formats like transaction logs, cluster state, and index metadata.;public Version minimumIndexCompatibilityVersion() {_        final int bwcMajor__        if (major == 5) {_            bwcMajor = 2_ _        } else if (major == 7) {_            return V_6_0_0_beta1__        } else {_            bwcMajor = major - 1__        }_        final int bwcMinor = 0__        return Version.min(this, fromId(bwcMajor * 1000000 + bwcMinor * 10000 + 99))__    };returns,the,minimum,created,index,version,that,this,version,supports,indices,created,with,lower,versions,can,t,be,used,with,this,version,this,should,also,be,used,for,file,based,serialization,backwards,compatibility,ie,on,serialization,code,that,is,used,to,read,write,file,formats,like,transaction,logs,cluster,state,and,index,metadata;public,version,minimum,index,compatibility,version,final,int,bwc,major,if,major,5,bwc,major,2,else,if,major,7,return,else,bwc,major,major,1,final,int,bwc,minor,0,return,version,min,this,from,id,bwc,major,1000000,bwc,minor,10000,99
Version -> public Version minimumIndexCompatibilityVersion();1548755041;Returns the minimum created index version that this version supports. Indices created with lower versions_can't be used with this version. This should also be used for file based serialization backwards compatibility ie. on serialization_code that is used to read / write file formats like transaction logs, cluster state, and index metadata.;public Version minimumIndexCompatibilityVersion() {_        final int bwcMajor__        if (major == 5) {_            bwcMajor = 2_ _        } else if (major == 7) {_            return V_6_0_0_beta1__        } else {_            bwcMajor = major - 1__        }_        final int bwcMinor = 0__        return Version.min(this, fromId(bwcMajor * 1000000 + bwcMinor * 10000 + 99))__    };returns,the,minimum,created,index,version,that,this,version,supports,indices,created,with,lower,versions,can,t,be,used,with,this,version,this,should,also,be,used,for,file,based,serialization,backwards,compatibility,ie,on,serialization,code,that,is,used,to,read,write,file,formats,like,transaction,logs,cluster,state,and,index,metadata;public,version,minimum,index,compatibility,version,final,int,bwc,major,if,major,5,bwc,major,2,else,if,major,7,return,else,bwc,major,major,1,final,int,bwc,minor,0,return,version,min,this,from,id,bwc,major,1000000,bwc,minor,10000,99
Version -> public Version minimumIndexCompatibilityVersion();1548822781;Returns the minimum created index version that this version supports. Indices created with lower versions_can't be used with this version. This should also be used for file based serialization backwards compatibility ie. on serialization_code that is used to read / write file formats like transaction logs, cluster state, and index metadata.;public Version minimumIndexCompatibilityVersion() {_        final int bwcMajor__        if (major == 5) {_            bwcMajor = 2_ _        } else if (major == 7) {_            return V_6_0_0_beta1__        } else {_            bwcMajor = major - 1__        }_        final int bwcMinor = 0__        return Version.min(this, fromId(bwcMajor * 1000000 + bwcMinor * 10000 + 99))__    };returns,the,minimum,created,index,version,that,this,version,supports,indices,created,with,lower,versions,can,t,be,used,with,this,version,this,should,also,be,used,for,file,based,serialization,backwards,compatibility,ie,on,serialization,code,that,is,used,to,read,write,file,formats,like,transaction,logs,cluster,state,and,index,metadata;public,version,minimum,index,compatibility,version,final,int,bwc,major,if,major,5,bwc,major,2,else,if,major,7,return,else,bwc,major,major,1,final,int,bwc,minor,0,return,version,min,this,from,id,bwc,major,1000000,bwc,minor,10000,99
Version -> public Version minimumIndexCompatibilityVersion();1549608646;Returns the minimum created index version that this version supports. Indices created with lower versions_can't be used with this version. This should also be used for file based serialization backwards compatibility ie. on serialization_code that is used to read / write file formats like transaction logs, cluster state, and index metadata.;public Version minimumIndexCompatibilityVersion() {_        final int bwcMajor__        if (major == 5) {_            bwcMajor = 2_ _        } else if (major == 7) {_            return V_6_0_0_beta1__        } else {_            bwcMajor = major - 1__        }_        final int bwcMinor = 0__        return Version.min(this, fromId(bwcMajor * 1000000 + bwcMinor * 10000 + 99))__    };returns,the,minimum,created,index,version,that,this,version,supports,indices,created,with,lower,versions,can,t,be,used,with,this,version,this,should,also,be,used,for,file,based,serialization,backwards,compatibility,ie,on,serialization,code,that,is,used,to,read,write,file,formats,like,transaction,logs,cluster,state,and,index,metadata;public,version,minimum,index,compatibility,version,final,int,bwc,major,if,major,5,bwc,major,2,else,if,major,7,return,else,bwc,major,major,1,final,int,bwc,minor,0,return,version,min,this,from,id,bwc,major,1000000,bwc,minor,10000,99
Version -> public Version minimumIndexCompatibilityVersion();1550604529;Returns the minimum created index version that this version supports. Indices created with lower versions_can't be used with this version. This should also be used for file based serialization backwards compatibility ie. on serialization_code that is used to read / write file formats like transaction logs, cluster state, and index metadata.;public Version minimumIndexCompatibilityVersion() {_        final int bwcMajor__        if (major == 5) {_            bwcMajor = 2_ _        } else if (major == 7) {_            return V_6_0_0_beta1__        } else {_            bwcMajor = major - 1__        }_        final int bwcMinor = 0__        return Version.min(this, fromId(bwcMajor * 1000000 + bwcMinor * 10000 + 99))__    };returns,the,minimum,created,index,version,that,this,version,supports,indices,created,with,lower,versions,can,t,be,used,with,this,version,this,should,also,be,used,for,file,based,serialization,backwards,compatibility,ie,on,serialization,code,that,is,used,to,read,write,file,formats,like,transaction,logs,cluster,state,and,index,metadata;public,version,minimum,index,compatibility,version,final,int,bwc,major,if,major,5,bwc,major,2,else,if,major,7,return,else,bwc,major,major,1,final,int,bwc,minor,0,return,version,min,this,from,id,bwc,major,1000000,bwc,minor,10000,99
Version -> public static Version indexCreated(Settings indexSettings);1524684173;Return the {@link Version} of Elasticsearch that has been used to create an index given its settings.__@throws IllegalStateException if the given index settings doesn't contain a value for the key_{@value IndexMetaData#SETTING_VERSION_CREATED};public static Version indexCreated(Settings indexSettings) {_        final Version indexVersion = indexSettings.getAsVersion(IndexMetaData.SETTING_VERSION_CREATED, null)__        if (indexVersion == null) {_            throw new IllegalStateException(_                    "[" + IndexMetaData.SETTING_VERSION_CREATED + "] is not present in the index settings for index with uuid: ["_                            + indexSettings.get(IndexMetaData.SETTING_INDEX_UUID) + "]")__        }_        return indexVersion__    };return,the,link,version,of,elasticsearch,that,has,been,used,to,create,an,index,given,its,settings,throws,illegal,state,exception,if,the,given,index,settings,doesn,t,contain,a,value,for,the,key,value,index,meta,data;public,static,version,index,created,settings,index,settings,final,version,index,version,index,settings,get,as,version,index,meta,data,null,if,index,version,null,throw,new,illegal,state,exception,index,meta,data,is,not,present,in,the,index,settings,for,index,with,uuid,index,settings,get,index,meta,data,return,index,version
Version -> public static Version indexCreated(Settings indexSettings);1525645056;Return the {@link Version} of Elasticsearch that has been used to create an index given its settings.__@throws IllegalStateException if the given index settings doesn't contain a value for the key_{@value IndexMetaData#SETTING_VERSION_CREATED};public static Version indexCreated(Settings indexSettings) {_        final Version indexVersion = indexSettings.getAsVersion(IndexMetaData.SETTING_VERSION_CREATED, null)__        if (indexVersion == null) {_            throw new IllegalStateException(_                    "[" + IndexMetaData.SETTING_VERSION_CREATED + "] is not present in the index settings for index with uuid: ["_                            + indexSettings.get(IndexMetaData.SETTING_INDEX_UUID) + "]")__        }_        return indexVersion__    };return,the,link,version,of,elasticsearch,that,has,been,used,to,create,an,index,given,its,settings,throws,illegal,state,exception,if,the,given,index,settings,doesn,t,contain,a,value,for,the,key,value,index,meta,data;public,static,version,index,created,settings,index,settings,final,version,index,version,index,settings,get,as,version,index,meta,data,null,if,index,version,null,throw,new,illegal,state,exception,index,meta,data,is,not,present,in,the,index,settings,for,index,with,uuid,index,settings,get,index,meta,data,return,index,version
Version -> public static Version indexCreated(Settings indexSettings);1526900724;Return the {@link Version} of Elasticsearch that has been used to create an index given its settings.__@throws IllegalStateException if the given index settings doesn't contain a value for the key_{@value IndexMetaData#SETTING_VERSION_CREATED};public static Version indexCreated(Settings indexSettings) {_        final Version indexVersion = indexSettings.getAsVersion(IndexMetaData.SETTING_VERSION_CREATED, null)__        if (indexVersion == null) {_            throw new IllegalStateException(_                    "[" + IndexMetaData.SETTING_VERSION_CREATED + "] is not present in the index settings for index with uuid: ["_                            + indexSettings.get(IndexMetaData.SETTING_INDEX_UUID) + "]")__        }_        return indexVersion__    };return,the,link,version,of,elasticsearch,that,has,been,used,to,create,an,index,given,its,settings,throws,illegal,state,exception,if,the,given,index,settings,doesn,t,contain,a,value,for,the,key,value,index,meta,data;public,static,version,index,created,settings,index,settings,final,version,index,version,index,settings,get,as,version,index,meta,data,null,if,index,version,null,throw,new,illegal,state,exception,index,meta,data,is,not,present,in,the,index,settings,for,index,with,uuid,index,settings,get,index,meta,data,return,index,version
Version -> public static Version indexCreated(Settings indexSettings);1528917185;Return the {@link Version} of Elasticsearch that has been used to create an index given its settings.__@throws IllegalStateException if the given index settings doesn't contain a value for the key_{@value IndexMetaData#SETTING_VERSION_CREATED};public static Version indexCreated(Settings indexSettings) {_        final Version indexVersion = indexSettings.getAsVersion(IndexMetaData.SETTING_VERSION_CREATED, null)__        if (indexVersion == null) {_            throw new IllegalStateException(_                    "[" + IndexMetaData.SETTING_VERSION_CREATED + "] is not present in the index settings for index with uuid: ["_                            + indexSettings.get(IndexMetaData.SETTING_INDEX_UUID) + "]")__        }_        return indexVersion__    };return,the,link,version,of,elasticsearch,that,has,been,used,to,create,an,index,given,its,settings,throws,illegal,state,exception,if,the,given,index,settings,doesn,t,contain,a,value,for,the,key,value,index,meta,data;public,static,version,index,created,settings,index,settings,final,version,index,version,index,settings,get,as,version,index,meta,data,null,if,index,version,null,throw,new,illegal,state,exception,index,meta,data,is,not,present,in,the,index,settings,for,index,with,uuid,index,settings,get,index,meta,data,return,index,version
Version -> public static Version indexCreated(Settings indexSettings);1528924528;Return the {@link Version} of Elasticsearch that has been used to create an index given its settings.__@throws IllegalStateException if the given index settings doesn't contain a value for the key_{@value IndexMetaData#SETTING_VERSION_CREATED};public static Version indexCreated(Settings indexSettings) {_        final Version indexVersion = indexSettings.getAsVersion(IndexMetaData.SETTING_VERSION_CREATED, null)__        if (indexVersion == null) {_            throw new IllegalStateException(_                    "[" + IndexMetaData.SETTING_VERSION_CREATED + "] is not present in the index settings for index with uuid: ["_                            + indexSettings.get(IndexMetaData.SETTING_INDEX_UUID) + "]")__        }_        return indexVersion__    };return,the,link,version,of,elasticsearch,that,has,been,used,to,create,an,index,given,its,settings,throws,illegal,state,exception,if,the,given,index,settings,doesn,t,contain,a,value,for,the,key,value,index,meta,data;public,static,version,index,created,settings,index,settings,final,version,index,version,index,settings,get,as,version,index,meta,data,null,if,index,version,null,throw,new,illegal,state,exception,index,meta,data,is,not,present,in,the,index,settings,for,index,with,uuid,index,settings,get,index,meta,data,return,index,version
Version -> public static Version indexCreated(Settings indexSettings);1531179852;Return the {@link Version} of Elasticsearch that has been used to create an index given its settings.__@throws IllegalStateException if the given index settings doesn't contain a value for the key_{@value IndexMetaData#SETTING_VERSION_CREATED};public static Version indexCreated(Settings indexSettings) {_        final Version indexVersion = indexSettings.getAsVersion(IndexMetaData.SETTING_VERSION_CREATED, null)__        if (indexVersion == null) {_            throw new IllegalStateException(_                    "[" + IndexMetaData.SETTING_VERSION_CREATED + "] is not present in the index settings for index with uuid: ["_                            + indexSettings.get(IndexMetaData.SETTING_INDEX_UUID) + "]")__        }_        return indexVersion__    };return,the,link,version,of,elasticsearch,that,has,been,used,to,create,an,index,given,its,settings,throws,illegal,state,exception,if,the,given,index,settings,doesn,t,contain,a,value,for,the,key,value,index,meta,data;public,static,version,index,created,settings,index,settings,final,version,index,version,index,settings,get,as,version,index,meta,data,null,if,index,version,null,throw,new,illegal,state,exception,index,meta,data,is,not,present,in,the,index,settings,for,index,with,uuid,index,settings,get,index,meta,data,return,index,version
Version -> public static Version indexCreated(Settings indexSettings);1532511554;Return the {@link Version} of Elasticsearch that has been used to create an index given its settings.__@throws IllegalStateException if the given index settings doesn't contain a value for the key_{@value IndexMetaData#SETTING_VERSION_CREATED};public static Version indexCreated(Settings indexSettings) {_        final Version indexVersion = indexSettings.getAsVersion(IndexMetaData.SETTING_VERSION_CREATED, null)__        if (indexVersion == null) {_            throw new IllegalStateException(_                    "[" + IndexMetaData.SETTING_VERSION_CREATED + "] is not present in the index settings for index with uuid: ["_                            + indexSettings.get(IndexMetaData.SETTING_INDEX_UUID) + "]")__        }_        return indexVersion__    };return,the,link,version,of,elasticsearch,that,has,been,used,to,create,an,index,given,its,settings,throws,illegal,state,exception,if,the,given,index,settings,doesn,t,contain,a,value,for,the,key,value,index,meta,data;public,static,version,index,created,settings,index,settings,final,version,index,version,index,settings,get,as,version,index,meta,data,null,if,index,version,null,throw,new,illegal,state,exception,index,meta,data,is,not,present,in,the,index,settings,for,index,with,uuid,index,settings,get,index,meta,data,return,index,version
Version -> public static Version indexCreated(Settings indexSettings);1532534495;Return the {@link Version} of Elasticsearch that has been used to create an index given its settings.__@throws IllegalStateException if the given index settings doesn't contain a value for the key_{@value IndexMetaData#SETTING_VERSION_CREATED};public static Version indexCreated(Settings indexSettings) {_        final Version indexVersion = indexSettings.getAsVersion(IndexMetaData.SETTING_VERSION_CREATED, null)__        if (indexVersion == null) {_            throw new IllegalStateException(_                    "[" + IndexMetaData.SETTING_VERSION_CREATED + "] is not present in the index settings for index with uuid: ["_                            + indexSettings.get(IndexMetaData.SETTING_INDEX_UUID) + "]")__        }_        return indexVersion__    };return,the,link,version,of,elasticsearch,that,has,been,used,to,create,an,index,given,its,settings,throws,illegal,state,exception,if,the,given,index,settings,doesn,t,contain,a,value,for,the,key,value,index,meta,data;public,static,version,index,created,settings,index,settings,final,version,index,version,index,settings,get,as,version,index,meta,data,null,if,index,version,null,throw,new,illegal,state,exception,index,meta,data,is,not,present,in,the,index,settings,for,index,with,uuid,index,settings,get,index,meta,data,return,index,version
Version -> public static Version indexCreated(Settings indexSettings);1532685069;Return the {@link Version} of Elasticsearch that has been used to create an index given its settings.__@throws IllegalStateException if the given index settings doesn't contain a value for the key_{@value IndexMetaData#SETTING_VERSION_CREATED};public static Version indexCreated(Settings indexSettings) {_        final Version indexVersion = indexSettings.getAsVersion(IndexMetaData.SETTING_VERSION_CREATED, null)__        if (indexVersion == null) {_            throw new IllegalStateException(_                    "[" + IndexMetaData.SETTING_VERSION_CREATED + "] is not present in the index settings for index with uuid: ["_                            + indexSettings.get(IndexMetaData.SETTING_INDEX_UUID) + "]")__        }_        return indexVersion__    };return,the,link,version,of,elasticsearch,that,has,been,used,to,create,an,index,given,its,settings,throws,illegal,state,exception,if,the,given,index,settings,doesn,t,contain,a,value,for,the,key,value,index,meta,data;public,static,version,index,created,settings,index,settings,final,version,index,version,index,settings,get,as,version,index,meta,data,null,if,index,version,null,throw,new,illegal,state,exception,index,meta,data,is,not,present,in,the,index,settings,for,index,with,uuid,index,settings,get,index,meta,data,return,index,version
Version -> public static Version indexCreated(Settings indexSettings);1535057785;Return the {@link Version} of Elasticsearch that has been used to create an index given its settings.__@throws IllegalStateException if the given index settings doesn't contain a value for the key_{@value IndexMetaData#SETTING_VERSION_CREATED};public static Version indexCreated(Settings indexSettings) {_        final Version indexVersion = indexSettings.getAsVersion(IndexMetaData.SETTING_VERSION_CREATED, null)__        if (indexVersion == null) {_            throw new IllegalStateException(_                    "[" + IndexMetaData.SETTING_VERSION_CREATED + "] is not present in the index settings for index with uuid: ["_                            + indexSettings.get(IndexMetaData.SETTING_INDEX_UUID) + "]")__        }_        return indexVersion__    };return,the,link,version,of,elasticsearch,that,has,been,used,to,create,an,index,given,its,settings,throws,illegal,state,exception,if,the,given,index,settings,doesn,t,contain,a,value,for,the,key,value,index,meta,data;public,static,version,index,created,settings,index,settings,final,version,index,version,index,settings,get,as,version,index,meta,data,null,if,index,version,null,throw,new,illegal,state,exception,index,meta,data,is,not,present,in,the,index,settings,for,index,with,uuid,index,settings,get,index,meta,data,return,index,version
Version -> public static Version indexCreated(Settings indexSettings);1535139672;Return the {@link Version} of Elasticsearch that has been used to create an index given its settings.__@throws IllegalStateException if the given index settings doesn't contain a value for the key_{@value IndexMetaData#SETTING_VERSION_CREATED};public static Version indexCreated(Settings indexSettings) {_        final Version indexVersion = indexSettings.getAsVersion(IndexMetaData.SETTING_VERSION_CREATED, null)__        if (indexVersion == null) {_            throw new IllegalStateException(_                    "[" + IndexMetaData.SETTING_VERSION_CREATED + "] is not present in the index settings for index with uuid: ["_                            + indexSettings.get(IndexMetaData.SETTING_INDEX_UUID) + "]")__        }_        return indexVersion__    };return,the,link,version,of,elasticsearch,that,has,been,used,to,create,an,index,given,its,settings,throws,illegal,state,exception,if,the,given,index,settings,doesn,t,contain,a,value,for,the,key,value,index,meta,data;public,static,version,index,created,settings,index,settings,final,version,index,version,index,settings,get,as,version,index,meta,data,null,if,index,version,null,throw,new,illegal,state,exception,index,meta,data,is,not,present,in,the,index,settings,for,index,with,uuid,index,settings,get,index,meta,data,return,index,version
Version -> public static Version indexCreated(Settings indexSettings);1536137328;Return the {@link Version} of Elasticsearch that has been used to create an index given its settings.__@throws IllegalStateException if the given index settings doesn't contain a value for the key_{@value IndexMetaData#SETTING_VERSION_CREATED};public static Version indexCreated(Settings indexSettings) {_        final Version indexVersion = IndexMetaData.SETTING_INDEX_VERSION_CREATED.get(indexSettings)__        if (indexVersion == V_EMPTY) {_            final String message = String.format(_                    Locale.ROOT,_                    "[%s] is not present in the index settings for index with UUID [%s]",_                    IndexMetaData.SETTING_INDEX_VERSION_CREATED.getKey(),_                    indexSettings.get(IndexMetaData.SETTING_INDEX_UUID))__            throw new IllegalStateException(message)__        }_        return indexVersion__    };return,the,link,version,of,elasticsearch,that,has,been,used,to,create,an,index,given,its,settings,throws,illegal,state,exception,if,the,given,index,settings,doesn,t,contain,a,value,for,the,key,value,index,meta,data;public,static,version,index,created,settings,index,settings,final,version,index,version,index,meta,data,get,index,settings,if,index,version,final,string,message,string,format,locale,root,s,is,not,present,in,the,index,settings,for,index,with,uuid,s,index,meta,data,get,key,index,settings,get,index,meta,data,throw,new,illegal,state,exception,message,return,index,version
Version -> public static Version indexCreated(Settings indexSettings);1536314350;Return the {@link Version} of Elasticsearch that has been used to create an index given its settings.__@throws IllegalStateException if the given index settings doesn't contain a value for the key_{@value IndexMetaData#SETTING_VERSION_CREATED};public static Version indexCreated(Settings indexSettings) {_        final Version indexVersion = IndexMetaData.SETTING_INDEX_VERSION_CREATED.get(indexSettings)__        if (indexVersion == V_EMPTY) {_            final String message = String.format(_                    Locale.ROOT,_                    "[%s] is not present in the index settings for index with UUID [%s]",_                    IndexMetaData.SETTING_INDEX_VERSION_CREATED.getKey(),_                    indexSettings.get(IndexMetaData.SETTING_INDEX_UUID))__            throw new IllegalStateException(message)__        }_        return indexVersion__    };return,the,link,version,of,elasticsearch,that,has,been,used,to,create,an,index,given,its,settings,throws,illegal,state,exception,if,the,given,index,settings,doesn,t,contain,a,value,for,the,key,value,index,meta,data;public,static,version,index,created,settings,index,settings,final,version,index,version,index,meta,data,get,index,settings,if,index,version,final,string,message,string,format,locale,root,s,is,not,present,in,the,index,settings,for,index,with,uuid,s,index,meta,data,get,key,index,settings,get,index,meta,data,throw,new,illegal,state,exception,message,return,index,version
Version -> public static Version indexCreated(Settings indexSettings);1537300661;Return the {@link Version} of Elasticsearch that has been used to create an index given its settings.__@throws IllegalStateException if the given index settings doesn't contain a value for the key_{@value IndexMetaData#SETTING_VERSION_CREATED};public static Version indexCreated(Settings indexSettings) {_        final Version indexVersion = IndexMetaData.SETTING_INDEX_VERSION_CREATED.get(indexSettings)__        if (indexVersion == V_EMPTY) {_            final String message = String.format(_                    Locale.ROOT,_                    "[%s] is not present in the index settings for index with UUID [%s]",_                    IndexMetaData.SETTING_INDEX_VERSION_CREATED.getKey(),_                    indexSettings.get(IndexMetaData.SETTING_INDEX_UUID))__            throw new IllegalStateException(message)__        }_        return indexVersion__    };return,the,link,version,of,elasticsearch,that,has,been,used,to,create,an,index,given,its,settings,throws,illegal,state,exception,if,the,given,index,settings,doesn,t,contain,a,value,for,the,key,value,index,meta,data;public,static,version,index,created,settings,index,settings,final,version,index,version,index,meta,data,get,index,settings,if,index,version,final,string,message,string,format,locale,root,s,is,not,present,in,the,index,settings,for,index,with,uuid,s,index,meta,data,get,key,index,settings,get,index,meta,data,throw,new,illegal,state,exception,message,return,index,version
Version -> public static Version indexCreated(Settings indexSettings);1538509426;Return the {@link Version} of Elasticsearch that has been used to create an index given its settings.__@throws IllegalStateException if the given index settings doesn't contain a value for the key_{@value IndexMetaData#SETTING_VERSION_CREATED};public static Version indexCreated(Settings indexSettings) {_        final Version indexVersion = IndexMetaData.SETTING_INDEX_VERSION_CREATED.get(indexSettings)__        if (indexVersion == V_EMPTY) {_            final String message = String.format(_                    Locale.ROOT,_                    "[%s] is not present in the index settings for index with UUID [%s]",_                    IndexMetaData.SETTING_INDEX_VERSION_CREATED.getKey(),_                    indexSettings.get(IndexMetaData.SETTING_INDEX_UUID))__            throw new IllegalStateException(message)__        }_        return indexVersion__    };return,the,link,version,of,elasticsearch,that,has,been,used,to,create,an,index,given,its,settings,throws,illegal,state,exception,if,the,given,index,settings,doesn,t,contain,a,value,for,the,key,value,index,meta,data;public,static,version,index,created,settings,index,settings,final,version,index,version,index,meta,data,get,index,settings,if,index,version,final,string,message,string,format,locale,root,s,is,not,present,in,the,index,settings,for,index,with,uuid,s,index,meta,data,get,key,index,settings,get,index,meta,data,throw,new,illegal,state,exception,message,return,index,version
Version -> public static Version indexCreated(Settings indexSettings);1540486836;Return the {@link Version} of Elasticsearch that has been used to create an index given its settings.__@throws IllegalStateException if the given index settings doesn't contain a value for the key_{@value IndexMetaData#SETTING_VERSION_CREATED};public static Version indexCreated(Settings indexSettings) {_        final Version indexVersion = IndexMetaData.SETTING_INDEX_VERSION_CREATED.get(indexSettings)__        if (indexVersion == V_EMPTY) {_            final String message = String.format(_                    Locale.ROOT,_                    "[%s] is not present in the index settings for index with UUID [%s]",_                    IndexMetaData.SETTING_INDEX_VERSION_CREATED.getKey(),_                    indexSettings.get(IndexMetaData.SETTING_INDEX_UUID))__            throw new IllegalStateException(message)__        }_        return indexVersion__    };return,the,link,version,of,elasticsearch,that,has,been,used,to,create,an,index,given,its,settings,throws,illegal,state,exception,if,the,given,index,settings,doesn,t,contain,a,value,for,the,key,value,index,meta,data;public,static,version,index,created,settings,index,settings,final,version,index,version,index,meta,data,get,index,settings,if,index,version,final,string,message,string,format,locale,root,s,is,not,present,in,the,index,settings,for,index,with,uuid,s,index,meta,data,get,key,index,settings,get,index,meta,data,throw,new,illegal,state,exception,message,return,index,version
Version -> public static Version indexCreated(Settings indexSettings);1541502933;Return the {@link Version} of Elasticsearch that has been used to create an index given its settings.__@throws IllegalStateException if the given index settings doesn't contain a value for the key_{@value IndexMetaData#SETTING_VERSION_CREATED};public static Version indexCreated(Settings indexSettings) {_        final Version indexVersion = IndexMetaData.SETTING_INDEX_VERSION_CREATED.get(indexSettings)__        if (indexVersion == V_EMPTY) {_            final String message = String.format(_                    Locale.ROOT,_                    "[%s] is not present in the index settings for index with UUID [%s]",_                    IndexMetaData.SETTING_INDEX_VERSION_CREATED.getKey(),_                    indexSettings.get(IndexMetaData.SETTING_INDEX_UUID))__            throw new IllegalStateException(message)__        }_        return indexVersion__    };return,the,link,version,of,elasticsearch,that,has,been,used,to,create,an,index,given,its,settings,throws,illegal,state,exception,if,the,given,index,settings,doesn,t,contain,a,value,for,the,key,value,index,meta,data;public,static,version,index,created,settings,index,settings,final,version,index,version,index,meta,data,get,index,settings,if,index,version,final,string,message,string,format,locale,root,s,is,not,present,in,the,index,settings,for,index,with,uuid,s,index,meta,data,get,key,index,settings,get,index,meta,data,throw,new,illegal,state,exception,message,return,index,version
Version -> public static Version indexCreated(Settings indexSettings);1541528420;Return the {@link Version} of Elasticsearch that has been used to create an index given its settings.__@throws IllegalStateException if the given index settings doesn't contain a value for the key_{@value IndexMetaData#SETTING_VERSION_CREATED};public static Version indexCreated(Settings indexSettings) {_        final Version indexVersion = IndexMetaData.SETTING_INDEX_VERSION_CREATED.get(indexSettings)__        if (indexVersion == V_EMPTY) {_            final String message = String.format(_                    Locale.ROOT,_                    "[%s] is not present in the index settings for index with UUID [%s]",_                    IndexMetaData.SETTING_INDEX_VERSION_CREATED.getKey(),_                    indexSettings.get(IndexMetaData.SETTING_INDEX_UUID))__            throw new IllegalStateException(message)__        }_        return indexVersion__    };return,the,link,version,of,elasticsearch,that,has,been,used,to,create,an,index,given,its,settings,throws,illegal,state,exception,if,the,given,index,settings,doesn,t,contain,a,value,for,the,key,value,index,meta,data;public,static,version,index,created,settings,index,settings,final,version,index,version,index,meta,data,get,index,settings,if,index,version,final,string,message,string,format,locale,root,s,is,not,present,in,the,index,settings,for,index,with,uuid,s,index,meta,data,get,key,index,settings,get,index,meta,data,throw,new,illegal,state,exception,message,return,index,version
Version -> public static Version indexCreated(Settings indexSettings);1541592065;Return the {@link Version} of Elasticsearch that has been used to create an index given its settings.__@throws IllegalStateException if the given index settings doesn't contain a value for the key_{@value IndexMetaData#SETTING_VERSION_CREATED};public static Version indexCreated(Settings indexSettings) {_        final Version indexVersion = IndexMetaData.SETTING_INDEX_VERSION_CREATED.get(indexSettings)__        if (indexVersion == V_EMPTY) {_            final String message = String.format(_                    Locale.ROOT,_                    "[%s] is not present in the index settings for index with UUID [%s]",_                    IndexMetaData.SETTING_INDEX_VERSION_CREATED.getKey(),_                    indexSettings.get(IndexMetaData.SETTING_INDEX_UUID))__            throw new IllegalStateException(message)__        }_        return indexVersion__    };return,the,link,version,of,elasticsearch,that,has,been,used,to,create,an,index,given,its,settings,throws,illegal,state,exception,if,the,given,index,settings,doesn,t,contain,a,value,for,the,key,value,index,meta,data;public,static,version,index,created,settings,index,settings,final,version,index,version,index,meta,data,get,index,settings,if,index,version,final,string,message,string,format,locale,root,s,is,not,present,in,the,index,settings,for,index,with,uuid,s,index,meta,data,get,key,index,settings,get,index,meta,data,throw,new,illegal,state,exception,message,return,index,version
Version -> public static Version indexCreated(Settings indexSettings);1542226101;Return the {@link Version} of Elasticsearch that has been used to create an index given its settings.__@throws IllegalStateException if the given index settings doesn't contain a value for the key_{@value IndexMetaData#SETTING_VERSION_CREATED};public static Version indexCreated(Settings indexSettings) {_        final Version indexVersion = IndexMetaData.SETTING_INDEX_VERSION_CREATED.get(indexSettings)__        if (indexVersion == V_EMPTY) {_            final String message = String.format(_                    Locale.ROOT,_                    "[%s] is not present in the index settings for index with UUID [%s]",_                    IndexMetaData.SETTING_INDEX_VERSION_CREATED.getKey(),_                    indexSettings.get(IndexMetaData.SETTING_INDEX_UUID))__            throw new IllegalStateException(message)__        }_        return indexVersion__    };return,the,link,version,of,elasticsearch,that,has,been,used,to,create,an,index,given,its,settings,throws,illegal,state,exception,if,the,given,index,settings,doesn,t,contain,a,value,for,the,key,value,index,meta,data;public,static,version,index,created,settings,index,settings,final,version,index,version,index,meta,data,get,index,settings,if,index,version,final,string,message,string,format,locale,root,s,is,not,present,in,the,index,settings,for,index,with,uuid,s,index,meta,data,get,key,index,settings,get,index,meta,data,throw,new,illegal,state,exception,message,return,index,version
Version -> public static Version indexCreated(Settings indexSettings);1542746006;Return the {@link Version} of Elasticsearch that has been used to create an index given its settings.__@throws IllegalStateException if the given index settings doesn't contain a value for the key_{@value IndexMetaData#SETTING_VERSION_CREATED};public static Version indexCreated(Settings indexSettings) {_        final Version indexVersion = IndexMetaData.SETTING_INDEX_VERSION_CREATED.get(indexSettings)__        if (indexVersion == V_EMPTY) {_            final String message = String.format(_                    Locale.ROOT,_                    "[%s] is not present in the index settings for index with UUID [%s]",_                    IndexMetaData.SETTING_INDEX_VERSION_CREATED.getKey(),_                    indexSettings.get(IndexMetaData.SETTING_INDEX_UUID))__            throw new IllegalStateException(message)__        }_        return indexVersion__    };return,the,link,version,of,elasticsearch,that,has,been,used,to,create,an,index,given,its,settings,throws,illegal,state,exception,if,the,given,index,settings,doesn,t,contain,a,value,for,the,key,value,index,meta,data;public,static,version,index,created,settings,index,settings,final,version,index,version,index,meta,data,get,index,settings,if,index,version,final,string,message,string,format,locale,root,s,is,not,present,in,the,index,settings,for,index,with,uuid,s,index,meta,data,get,key,index,settings,get,index,meta,data,throw,new,illegal,state,exception,message,return,index,version
Version -> public static Version indexCreated(Settings indexSettings);1543473699;Return the {@link Version} of Elasticsearch that has been used to create an index given its settings.__@throws IllegalStateException if the given index settings doesn't contain a value for the key_{@value IndexMetaData#SETTING_VERSION_CREATED};public static Version indexCreated(Settings indexSettings) {_        final Version indexVersion = IndexMetaData.SETTING_INDEX_VERSION_CREATED.get(indexSettings)__        if (indexVersion == V_EMPTY) {_            final String message = String.format(_                    Locale.ROOT,_                    "[%s] is not present in the index settings for index with UUID [%s]",_                    IndexMetaData.SETTING_INDEX_VERSION_CREATED.getKey(),_                    indexSettings.get(IndexMetaData.SETTING_INDEX_UUID))__            throw new IllegalStateException(message)__        }_        return indexVersion__    };return,the,link,version,of,elasticsearch,that,has,been,used,to,create,an,index,given,its,settings,throws,illegal,state,exception,if,the,given,index,settings,doesn,t,contain,a,value,for,the,key,value,index,meta,data;public,static,version,index,created,settings,index,settings,final,version,index,version,index,meta,data,get,index,settings,if,index,version,final,string,message,string,format,locale,root,s,is,not,present,in,the,index,settings,for,index,with,uuid,s,index,meta,data,get,key,index,settings,get,index,meta,data,throw,new,illegal,state,exception,message,return,index,version
Version -> public static Version indexCreated(Settings indexSettings);1543942400;Return the {@link Version} of Elasticsearch that has been used to create an index given its settings.__@throws IllegalStateException if the given index settings doesn't contain a value for the key_{@value IndexMetaData#SETTING_VERSION_CREATED};public static Version indexCreated(Settings indexSettings) {_        final Version indexVersion = IndexMetaData.SETTING_INDEX_VERSION_CREATED.get(indexSettings)__        if (indexVersion == V_EMPTY) {_            final String message = String.format(_                    Locale.ROOT,_                    "[%s] is not present in the index settings for index with UUID [%s]",_                    IndexMetaData.SETTING_INDEX_VERSION_CREATED.getKey(),_                    indexSettings.get(IndexMetaData.SETTING_INDEX_UUID))__            throw new IllegalStateException(message)__        }_        return indexVersion__    };return,the,link,version,of,elasticsearch,that,has,been,used,to,create,an,index,given,its,settings,throws,illegal,state,exception,if,the,given,index,settings,doesn,t,contain,a,value,for,the,key,value,index,meta,data;public,static,version,index,created,settings,index,settings,final,version,index,version,index,meta,data,get,index,settings,if,index,version,final,string,message,string,format,locale,root,s,is,not,present,in,the,index,settings,for,index,with,uuid,s,index,meta,data,get,key,index,settings,get,index,meta,data,throw,new,illegal,state,exception,message,return,index,version
Version -> public static Version indexCreated(Settings indexSettings);1544037309;Return the {@link Version} of Elasticsearch that has been used to create an index given its settings.__@throws IllegalStateException if the given index settings doesn't contain a value for the key_{@value IndexMetaData#SETTING_VERSION_CREATED};public static Version indexCreated(Settings indexSettings) {_        final Version indexVersion = IndexMetaData.SETTING_INDEX_VERSION_CREATED.get(indexSettings)__        if (indexVersion == V_EMPTY) {_            final String message = String.format(_                    Locale.ROOT,_                    "[%s] is not present in the index settings for index with UUID [%s]",_                    IndexMetaData.SETTING_INDEX_VERSION_CREATED.getKey(),_                    indexSettings.get(IndexMetaData.SETTING_INDEX_UUID))__            throw new IllegalStateException(message)__        }_        return indexVersion__    };return,the,link,version,of,elasticsearch,that,has,been,used,to,create,an,index,given,its,settings,throws,illegal,state,exception,if,the,given,index,settings,doesn,t,contain,a,value,for,the,key,value,index,meta,data;public,static,version,index,created,settings,index,settings,final,version,index,version,index,meta,data,get,index,settings,if,index,version,final,string,message,string,format,locale,root,s,is,not,present,in,the,index,settings,for,index,with,uuid,s,index,meta,data,get,key,index,settings,get,index,meta,data,throw,new,illegal,state,exception,message,return,index,version
Version -> public static Version indexCreated(Settings indexSettings);1544553539;Return the {@link Version} of Elasticsearch that has been used to create an index given its settings.__@throws IllegalStateException if the given index settings doesn't contain a value for the key_{@value IndexMetaData#SETTING_VERSION_CREATED};public static Version indexCreated(Settings indexSettings) {_        final Version indexVersion = IndexMetaData.SETTING_INDEX_VERSION_CREATED.get(indexSettings)__        if (indexVersion == V_EMPTY) {_            final String message = String.format(_                    Locale.ROOT,_                    "[%s] is not present in the index settings for index with UUID [%s]",_                    IndexMetaData.SETTING_INDEX_VERSION_CREATED.getKey(),_                    indexSettings.get(IndexMetaData.SETTING_INDEX_UUID))__            throw new IllegalStateException(message)__        }_        return indexVersion__    };return,the,link,version,of,elasticsearch,that,has,been,used,to,create,an,index,given,its,settings,throws,illegal,state,exception,if,the,given,index,settings,doesn,t,contain,a,value,for,the,key,value,index,meta,data;public,static,version,index,created,settings,index,settings,final,version,index,version,index,meta,data,get,index,settings,if,index,version,final,string,message,string,format,locale,root,s,is,not,present,in,the,index,settings,for,index,with,uuid,s,index,meta,data,get,key,index,settings,get,index,meta,data,throw,new,illegal,state,exception,message,return,index,version
Version -> public static Version indexCreated(Settings indexSettings);1545225850;Return the {@link Version} of Elasticsearch that has been used to create an index given its settings.__@throws IllegalStateException if the given index settings doesn't contain a value for the key_{@value IndexMetaData#SETTING_VERSION_CREATED};public static Version indexCreated(Settings indexSettings) {_        final Version indexVersion = IndexMetaData.SETTING_INDEX_VERSION_CREATED.get(indexSettings)__        if (indexVersion == V_EMPTY) {_            final String message = String.format(_                    Locale.ROOT,_                    "[%s] is not present in the index settings for index with UUID [%s]",_                    IndexMetaData.SETTING_INDEX_VERSION_CREATED.getKey(),_                    indexSettings.get(IndexMetaData.SETTING_INDEX_UUID))__            throw new IllegalStateException(message)__        }_        return indexVersion__    };return,the,link,version,of,elasticsearch,that,has,been,used,to,create,an,index,given,its,settings,throws,illegal,state,exception,if,the,given,index,settings,doesn,t,contain,a,value,for,the,key,value,index,meta,data;public,static,version,index,created,settings,index,settings,final,version,index,version,index,meta,data,get,index,settings,if,index,version,final,string,message,string,format,locale,root,s,is,not,present,in,the,index,settings,for,index,with,uuid,s,index,meta,data,get,key,index,settings,get,index,meta,data,throw,new,illegal,state,exception,message,return,index,version
Version -> public static Version indexCreated(Settings indexSettings);1545256934;Return the {@link Version} of Elasticsearch that has been used to create an index given its settings.__@throws IllegalStateException if the given index settings doesn't contain a value for the key_{@value IndexMetaData#SETTING_VERSION_CREATED};public static Version indexCreated(Settings indexSettings) {_        final Version indexVersion = IndexMetaData.SETTING_INDEX_VERSION_CREATED.get(indexSettings)__        if (indexVersion == V_EMPTY) {_            final String message = String.format(_                    Locale.ROOT,_                    "[%s] is not present in the index settings for index with UUID [%s]",_                    IndexMetaData.SETTING_INDEX_VERSION_CREATED.getKey(),_                    indexSettings.get(IndexMetaData.SETTING_INDEX_UUID))__            throw new IllegalStateException(message)__        }_        return indexVersion__    };return,the,link,version,of,elasticsearch,that,has,been,used,to,create,an,index,given,its,settings,throws,illegal,state,exception,if,the,given,index,settings,doesn,t,contain,a,value,for,the,key,value,index,meta,data;public,static,version,index,created,settings,index,settings,final,version,index,version,index,meta,data,get,index,settings,if,index,version,final,string,message,string,format,locale,root,s,is,not,present,in,the,index,settings,for,index,with,uuid,s,index,meta,data,get,key,index,settings,get,index,meta,data,throw,new,illegal,state,exception,message,return,index,version
Version -> public static Version indexCreated(Settings indexSettings);1546507247;Return the {@link Version} of Elasticsearch that has been used to create an index given its settings.__@throws IllegalStateException if the given index settings doesn't contain a value for the key_{@value IndexMetaData#SETTING_VERSION_CREATED};public static Version indexCreated(Settings indexSettings) {_        final Version indexVersion = IndexMetaData.SETTING_INDEX_VERSION_CREATED.get(indexSettings)__        if (indexVersion == V_EMPTY) {_            final String message = String.format(_                    Locale.ROOT,_                    "[%s] is not present in the index settings for index with UUID [%s]",_                    IndexMetaData.SETTING_INDEX_VERSION_CREATED.getKey(),_                    indexSettings.get(IndexMetaData.SETTING_INDEX_UUID))__            throw new IllegalStateException(message)__        }_        return indexVersion__    };return,the,link,version,of,elasticsearch,that,has,been,used,to,create,an,index,given,its,settings,throws,illegal,state,exception,if,the,given,index,settings,doesn,t,contain,a,value,for,the,key,value,index,meta,data;public,static,version,index,created,settings,index,settings,final,version,index,version,index,meta,data,get,index,settings,if,index,version,final,string,message,string,format,locale,root,s,is,not,present,in,the,index,settings,for,index,with,uuid,s,index,meta,data,get,key,index,settings,get,index,meta,data,throw,new,illegal,state,exception,message,return,index,version
Version -> public static Version indexCreated(Settings indexSettings);1546537951;Return the {@link Version} of Elasticsearch that has been used to create an index given its settings.__@throws IllegalStateException if the given index settings doesn't contain a value for the key_{@value IndexMetaData#SETTING_VERSION_CREATED};public static Version indexCreated(Settings indexSettings) {_        final Version indexVersion = IndexMetaData.SETTING_INDEX_VERSION_CREATED.get(indexSettings)__        if (indexVersion == V_EMPTY) {_            final String message = String.format(_                    Locale.ROOT,_                    "[%s] is not present in the index settings for index with UUID [%s]",_                    IndexMetaData.SETTING_INDEX_VERSION_CREATED.getKey(),_                    indexSettings.get(IndexMetaData.SETTING_INDEX_UUID))__            throw new IllegalStateException(message)__        }_        return indexVersion__    };return,the,link,version,of,elasticsearch,that,has,been,used,to,create,an,index,given,its,settings,throws,illegal,state,exception,if,the,given,index,settings,doesn,t,contain,a,value,for,the,key,value,index,meta,data;public,static,version,index,created,settings,index,settings,final,version,index,version,index,meta,data,get,index,settings,if,index,version,final,string,message,string,format,locale,root,s,is,not,present,in,the,index,settings,for,index,with,uuid,s,index,meta,data,get,key,index,settings,get,index,meta,data,throw,new,illegal,state,exception,message,return,index,version
Version -> public static Version indexCreated(Settings indexSettings);1548755041;Return the {@link Version} of Elasticsearch that has been used to create an index given its settings.__@throws IllegalStateException if the given index settings doesn't contain a value for the key_{@value IndexMetaData#SETTING_VERSION_CREATED};public static Version indexCreated(Settings indexSettings) {_        final Version indexVersion = IndexMetaData.SETTING_INDEX_VERSION_CREATED.get(indexSettings)__        if (indexVersion == V_EMPTY) {_            final String message = String.format(_                    Locale.ROOT,_                    "[%s] is not present in the index settings for index with UUID [%s]",_                    IndexMetaData.SETTING_INDEX_VERSION_CREATED.getKey(),_                    indexSettings.get(IndexMetaData.SETTING_INDEX_UUID))__            throw new IllegalStateException(message)__        }_        return indexVersion__    };return,the,link,version,of,elasticsearch,that,has,been,used,to,create,an,index,given,its,settings,throws,illegal,state,exception,if,the,given,index,settings,doesn,t,contain,a,value,for,the,key,value,index,meta,data;public,static,version,index,created,settings,index,settings,final,version,index,version,index,meta,data,get,index,settings,if,index,version,final,string,message,string,format,locale,root,s,is,not,present,in,the,index,settings,for,index,with,uuid,s,index,meta,data,get,key,index,settings,get,index,meta,data,throw,new,illegal,state,exception,message,return,index,version
Version -> public static Version indexCreated(Settings indexSettings);1548822781;Return the {@link Version} of Elasticsearch that has been used to create an index given its settings.__@throws IllegalStateException if the given index settings doesn't contain a value for the key_{@value IndexMetaData#SETTING_VERSION_CREATED};public static Version indexCreated(Settings indexSettings) {_        final Version indexVersion = IndexMetaData.SETTING_INDEX_VERSION_CREATED.get(indexSettings)__        if (indexVersion == V_EMPTY) {_            final String message = String.format(_                    Locale.ROOT,_                    "[%s] is not present in the index settings for index with UUID [%s]",_                    IndexMetaData.SETTING_INDEX_VERSION_CREATED.getKey(),_                    indexSettings.get(IndexMetaData.SETTING_INDEX_UUID))__            throw new IllegalStateException(message)__        }_        return indexVersion__    };return,the,link,version,of,elasticsearch,that,has,been,used,to,create,an,index,given,its,settings,throws,illegal,state,exception,if,the,given,index,settings,doesn,t,contain,a,value,for,the,key,value,index,meta,data;public,static,version,index,created,settings,index,settings,final,version,index,version,index,meta,data,get,index,settings,if,index,version,final,string,message,string,format,locale,root,s,is,not,present,in,the,index,settings,for,index,with,uuid,s,index,meta,data,get,key,index,settings,get,index,meta,data,throw,new,illegal,state,exception,message,return,index,version
Version -> public static Version indexCreated(Settings indexSettings);1549608646;Return the {@link Version} of Elasticsearch that has been used to create an index given its settings.__@throws IllegalStateException if the given index settings doesn't contain a value for the key_{@value IndexMetaData#SETTING_VERSION_CREATED};public static Version indexCreated(Settings indexSettings) {_        final Version indexVersion = IndexMetaData.SETTING_INDEX_VERSION_CREATED.get(indexSettings)__        if (indexVersion == V_EMPTY) {_            final String message = String.format(_                    Locale.ROOT,_                    "[%s] is not present in the index settings for index with UUID [%s]",_                    IndexMetaData.SETTING_INDEX_VERSION_CREATED.getKey(),_                    indexSettings.get(IndexMetaData.SETTING_INDEX_UUID))__            throw new IllegalStateException(message)__        }_        return indexVersion__    };return,the,link,version,of,elasticsearch,that,has,been,used,to,create,an,index,given,its,settings,throws,illegal,state,exception,if,the,given,index,settings,doesn,t,contain,a,value,for,the,key,value,index,meta,data;public,static,version,index,created,settings,index,settings,final,version,index,version,index,meta,data,get,index,settings,if,index,version,final,string,message,string,format,locale,root,s,is,not,present,in,the,index,settings,for,index,with,uuid,s,index,meta,data,get,key,index,settings,get,index,meta,data,throw,new,illegal,state,exception,message,return,index,version
Version -> public static Version indexCreated(Settings indexSettings);1550604529;Return the {@link Version} of Elasticsearch that has been used to create an index given its settings.__@throws IllegalStateException if the given index settings doesn't contain a value for the key_{@value IndexMetaData#SETTING_VERSION_CREATED};public static Version indexCreated(Settings indexSettings) {_        final Version indexVersion = IndexMetaData.SETTING_INDEX_VERSION_CREATED.get(indexSettings)__        if (indexVersion == V_EMPTY) {_            final String message = String.format(_                    Locale.ROOT,_                    "[%s] is not present in the index settings for index with UUID [%s]",_                    IndexMetaData.SETTING_INDEX_VERSION_CREATED.getKey(),_                    indexSettings.get(IndexMetaData.SETTING_INDEX_UUID))__            throw new IllegalStateException(message)__        }_        return indexVersion__    };return,the,link,version,of,elasticsearch,that,has,been,used,to,create,an,index,given,its,settings,throws,illegal,state,exception,if,the,given,index,settings,doesn,t,contain,a,value,for,the,key,value,index,meta,data;public,static,version,index,created,settings,index,settings,final,version,index,version,index,meta,data,get,index,settings,if,index,version,final,string,message,string,format,locale,root,s,is,not,present,in,the,index,settings,for,index,with,uuid,s,index,meta,data,get,key,index,settings,get,index,meta,data,throw,new,illegal,state,exception,message,return,index,version
Version -> public static List<Version> getDeclaredVersions(final Class<?> versionClass);1524684173;Extracts a sorted list of declared version constants from a class._The argument would normally be Version.class but is exposed for_testing with other classes-containing-version-constants.;public static List<Version> getDeclaredVersions(final Class<?> versionClass) {_        final Field[] fields = versionClass.getFields()__        final List<Version> versions = new ArrayList<>(fields.length)__        for (final Field field : fields) {_            final int mod = field.getModifiers()__            if (false == Modifier.isStatic(mod) && Modifier.isFinal(mod) && Modifier.isPublic(mod)) {_                continue__            }_            if (field.getType() != Version.class) {_                continue__            }_            if ("CURRENT".equals(field.getName())) {_                continue__            }_            assert field.getName().matches("V(_\\d+)+(_(alpha|beta|rc)\\d+)?") : field.getName()__            try {_                versions.add(((Version) field.get(null)))__            } catch (final IllegalAccessException e) {_                throw new RuntimeException(e)__            }_        }_        Collections.sort(versions)__        return versions__    };extracts,a,sorted,list,of,declared,version,constants,from,a,class,the,argument,would,normally,be,version,class,but,is,exposed,for,testing,with,other,classes,containing,version,constants;public,static,list,version,get,declared,versions,final,class,version,class,final,field,fields,version,class,get,fields,final,list,version,versions,new,array,list,fields,length,for,final,field,field,fields,final,int,mod,field,get,modifiers,if,false,modifier,is,static,mod,modifier,is,final,mod,modifier,is,public,mod,continue,if,field,get,type,version,class,continue,if,current,equals,field,get,name,continue,assert,field,get,name,matches,v,d,alpha,beta,rc,d,field,get,name,try,versions,add,version,field,get,null,catch,final,illegal,access,exception,e,throw,new,runtime,exception,e,collections,sort,versions,return,versions
Version -> public static List<Version> getDeclaredVersions(final Class<?> versionClass);1525645056;Extracts a sorted list of declared version constants from a class._The argument would normally be Version.class but is exposed for_testing with other classes-containing-version-constants.;public static List<Version> getDeclaredVersions(final Class<?> versionClass) {_        final Field[] fields = versionClass.getFields()__        final List<Version> versions = new ArrayList<>(fields.length)__        for (final Field field : fields) {_            final int mod = field.getModifiers()__            if (false == Modifier.isStatic(mod) && Modifier.isFinal(mod) && Modifier.isPublic(mod)) {_                continue__            }_            if (field.getType() != Version.class) {_                continue__            }_            if ("CURRENT".equals(field.getName())) {_                continue__            }_            assert field.getName().matches("V(_\\d+)+(_(alpha|beta|rc)\\d+)?") : field.getName()__            try {_                versions.add(((Version) field.get(null)))__            } catch (final IllegalAccessException e) {_                throw new RuntimeException(e)__            }_        }_        Collections.sort(versions)__        return versions__    };extracts,a,sorted,list,of,declared,version,constants,from,a,class,the,argument,would,normally,be,version,class,but,is,exposed,for,testing,with,other,classes,containing,version,constants;public,static,list,version,get,declared,versions,final,class,version,class,final,field,fields,version,class,get,fields,final,list,version,versions,new,array,list,fields,length,for,final,field,field,fields,final,int,mod,field,get,modifiers,if,false,modifier,is,static,mod,modifier,is,final,mod,modifier,is,public,mod,continue,if,field,get,type,version,class,continue,if,current,equals,field,get,name,continue,assert,field,get,name,matches,v,d,alpha,beta,rc,d,field,get,name,try,versions,add,version,field,get,null,catch,final,illegal,access,exception,e,throw,new,runtime,exception,e,collections,sort,versions,return,versions
Version -> public static List<Version> getDeclaredVersions(final Class<?> versionClass);1526900724;Extracts a sorted list of declared version constants from a class._The argument would normally be Version.class but is exposed for_testing with other classes-containing-version-constants.;public static List<Version> getDeclaredVersions(final Class<?> versionClass) {_        final Field[] fields = versionClass.getFields()__        final List<Version> versions = new ArrayList<>(fields.length)__        for (final Field field : fields) {_            final int mod = field.getModifiers()__            if (false == Modifier.isStatic(mod) && Modifier.isFinal(mod) && Modifier.isPublic(mod)) {_                continue__            }_            if (field.getType() != Version.class) {_                continue__            }_            if ("CURRENT".equals(field.getName())) {_                continue__            }_            assert field.getName().matches("V(_\\d+)+(_(alpha|beta|rc)\\d+)?") : field.getName()__            try {_                versions.add(((Version) field.get(null)))__            } catch (final IllegalAccessException e) {_                throw new RuntimeException(e)__            }_        }_        Collections.sort(versions)__        return versions__    };extracts,a,sorted,list,of,declared,version,constants,from,a,class,the,argument,would,normally,be,version,class,but,is,exposed,for,testing,with,other,classes,containing,version,constants;public,static,list,version,get,declared,versions,final,class,version,class,final,field,fields,version,class,get,fields,final,list,version,versions,new,array,list,fields,length,for,final,field,field,fields,final,int,mod,field,get,modifiers,if,false,modifier,is,static,mod,modifier,is,final,mod,modifier,is,public,mod,continue,if,field,get,type,version,class,continue,if,current,equals,field,get,name,continue,assert,field,get,name,matches,v,d,alpha,beta,rc,d,field,get,name,try,versions,add,version,field,get,null,catch,final,illegal,access,exception,e,throw,new,runtime,exception,e,collections,sort,versions,return,versions
Version -> public static List<Version> getDeclaredVersions(final Class<?> versionClass);1528917185;Extracts a sorted list of declared version constants from a class._The argument would normally be Version.class but is exposed for_testing with other classes-containing-version-constants.;public static List<Version> getDeclaredVersions(final Class<?> versionClass) {_        final Field[] fields = versionClass.getFields()__        final List<Version> versions = new ArrayList<>(fields.length)__        for (final Field field : fields) {_            final int mod = field.getModifiers()__            if (false == Modifier.isStatic(mod) && Modifier.isFinal(mod) && Modifier.isPublic(mod)) {_                continue__            }_            if (field.getType() != Version.class) {_                continue__            }_            if ("CURRENT".equals(field.getName())) {_                continue__            }_            assert field.getName().matches("V(_\\d+)+(_(alpha|beta|rc)\\d+)?") : field.getName()__            try {_                versions.add(((Version) field.get(null)))__            } catch (final IllegalAccessException e) {_                throw new RuntimeException(e)__            }_        }_        Collections.sort(versions)__        return versions__    };extracts,a,sorted,list,of,declared,version,constants,from,a,class,the,argument,would,normally,be,version,class,but,is,exposed,for,testing,with,other,classes,containing,version,constants;public,static,list,version,get,declared,versions,final,class,version,class,final,field,fields,version,class,get,fields,final,list,version,versions,new,array,list,fields,length,for,final,field,field,fields,final,int,mod,field,get,modifiers,if,false,modifier,is,static,mod,modifier,is,final,mod,modifier,is,public,mod,continue,if,field,get,type,version,class,continue,if,current,equals,field,get,name,continue,assert,field,get,name,matches,v,d,alpha,beta,rc,d,field,get,name,try,versions,add,version,field,get,null,catch,final,illegal,access,exception,e,throw,new,runtime,exception,e,collections,sort,versions,return,versions
Version -> public static List<Version> getDeclaredVersions(final Class<?> versionClass);1528924528;Extracts a sorted list of declared version constants from a class._The argument would normally be Version.class but is exposed for_testing with other classes-containing-version-constants.;public static List<Version> getDeclaredVersions(final Class<?> versionClass) {_        final Field[] fields = versionClass.getFields()__        final List<Version> versions = new ArrayList<>(fields.length)__        for (final Field field : fields) {_            final int mod = field.getModifiers()__            if (false == Modifier.isStatic(mod) && Modifier.isFinal(mod) && Modifier.isPublic(mod)) {_                continue__            }_            if (field.getType() != Version.class) {_                continue__            }_            if ("CURRENT".equals(field.getName())) {_                continue__            }_            assert field.getName().matches("V(_\\d+)+(_(alpha|beta|rc)\\d+)?") : field.getName()__            try {_                versions.add(((Version) field.get(null)))__            } catch (final IllegalAccessException e) {_                throw new RuntimeException(e)__            }_        }_        Collections.sort(versions)__        return versions__    };extracts,a,sorted,list,of,declared,version,constants,from,a,class,the,argument,would,normally,be,version,class,but,is,exposed,for,testing,with,other,classes,containing,version,constants;public,static,list,version,get,declared,versions,final,class,version,class,final,field,fields,version,class,get,fields,final,list,version,versions,new,array,list,fields,length,for,final,field,field,fields,final,int,mod,field,get,modifiers,if,false,modifier,is,static,mod,modifier,is,final,mod,modifier,is,public,mod,continue,if,field,get,type,version,class,continue,if,current,equals,field,get,name,continue,assert,field,get,name,matches,v,d,alpha,beta,rc,d,field,get,name,try,versions,add,version,field,get,null,catch,final,illegal,access,exception,e,throw,new,runtime,exception,e,collections,sort,versions,return,versions
Version -> public static List<Version> getDeclaredVersions(final Class<?> versionClass);1531179852;Extracts a sorted list of declared version constants from a class._The argument would normally be Version.class but is exposed for_testing with other classes-containing-version-constants.;public static List<Version> getDeclaredVersions(final Class<?> versionClass) {_        final Field[] fields = versionClass.getFields()__        final List<Version> versions = new ArrayList<>(fields.length)__        for (final Field field : fields) {_            final int mod = field.getModifiers()__            if (false == Modifier.isStatic(mod) && Modifier.isFinal(mod) && Modifier.isPublic(mod)) {_                continue__            }_            if (field.getType() != Version.class) {_                continue__            }_            if ("CURRENT".equals(field.getName())) {_                continue__            }_            assert field.getName().matches("V(_\\d+)+(_(alpha|beta|rc)\\d+)?") : field.getName()__            try {_                versions.add(((Version) field.get(null)))__            } catch (final IllegalAccessException e) {_                throw new RuntimeException(e)__            }_        }_        Collections.sort(versions)__        return versions__    };extracts,a,sorted,list,of,declared,version,constants,from,a,class,the,argument,would,normally,be,version,class,but,is,exposed,for,testing,with,other,classes,containing,version,constants;public,static,list,version,get,declared,versions,final,class,version,class,final,field,fields,version,class,get,fields,final,list,version,versions,new,array,list,fields,length,for,final,field,field,fields,final,int,mod,field,get,modifiers,if,false,modifier,is,static,mod,modifier,is,final,mod,modifier,is,public,mod,continue,if,field,get,type,version,class,continue,if,current,equals,field,get,name,continue,assert,field,get,name,matches,v,d,alpha,beta,rc,d,field,get,name,try,versions,add,version,field,get,null,catch,final,illegal,access,exception,e,throw,new,runtime,exception,e,collections,sort,versions,return,versions
Version -> public static List<Version> getDeclaredVersions(final Class<?> versionClass);1532511554;Extracts a sorted list of declared version constants from a class._The argument would normally be Version.class but is exposed for_testing with other classes-containing-version-constants.;public static List<Version> getDeclaredVersions(final Class<?> versionClass) {_        final Field[] fields = versionClass.getFields()__        final List<Version> versions = new ArrayList<>(fields.length)__        for (final Field field : fields) {_            final int mod = field.getModifiers()__            if (false == Modifier.isStatic(mod) && Modifier.isFinal(mod) && Modifier.isPublic(mod)) {_                continue__            }_            if (field.getType() != Version.class) {_                continue__            }_            if ("CURRENT".equals(field.getName())) {_                continue__            }_            assert field.getName().matches("V(_\\d+)+(_(alpha|beta|rc)\\d+)?") : field.getName()__            try {_                versions.add(((Version) field.get(null)))__            } catch (final IllegalAccessException e) {_                throw new RuntimeException(e)__            }_        }_        Collections.sort(versions)__        return versions__    };extracts,a,sorted,list,of,declared,version,constants,from,a,class,the,argument,would,normally,be,version,class,but,is,exposed,for,testing,with,other,classes,containing,version,constants;public,static,list,version,get,declared,versions,final,class,version,class,final,field,fields,version,class,get,fields,final,list,version,versions,new,array,list,fields,length,for,final,field,field,fields,final,int,mod,field,get,modifiers,if,false,modifier,is,static,mod,modifier,is,final,mod,modifier,is,public,mod,continue,if,field,get,type,version,class,continue,if,current,equals,field,get,name,continue,assert,field,get,name,matches,v,d,alpha,beta,rc,d,field,get,name,try,versions,add,version,field,get,null,catch,final,illegal,access,exception,e,throw,new,runtime,exception,e,collections,sort,versions,return,versions
Version -> public static List<Version> getDeclaredVersions(final Class<?> versionClass);1532534495;Extracts a sorted list of declared version constants from a class._The argument would normally be Version.class but is exposed for_testing with other classes-containing-version-constants.;public static List<Version> getDeclaredVersions(final Class<?> versionClass) {_        final Field[] fields = versionClass.getFields()__        final List<Version> versions = new ArrayList<>(fields.length)__        for (final Field field : fields) {_            final int mod = field.getModifiers()__            if (false == Modifier.isStatic(mod) && Modifier.isFinal(mod) && Modifier.isPublic(mod)) {_                continue__            }_            if (field.getType() != Version.class) {_                continue__            }_            if ("CURRENT".equals(field.getName())) {_                continue__            }_            assert field.getName().matches("V(_\\d+)+(_(alpha|beta|rc)\\d+)?") : field.getName()__            try {_                versions.add(((Version) field.get(null)))__            } catch (final IllegalAccessException e) {_                throw new RuntimeException(e)__            }_        }_        Collections.sort(versions)__        return versions__    };extracts,a,sorted,list,of,declared,version,constants,from,a,class,the,argument,would,normally,be,version,class,but,is,exposed,for,testing,with,other,classes,containing,version,constants;public,static,list,version,get,declared,versions,final,class,version,class,final,field,fields,version,class,get,fields,final,list,version,versions,new,array,list,fields,length,for,final,field,field,fields,final,int,mod,field,get,modifiers,if,false,modifier,is,static,mod,modifier,is,final,mod,modifier,is,public,mod,continue,if,field,get,type,version,class,continue,if,current,equals,field,get,name,continue,assert,field,get,name,matches,v,d,alpha,beta,rc,d,field,get,name,try,versions,add,version,field,get,null,catch,final,illegal,access,exception,e,throw,new,runtime,exception,e,collections,sort,versions,return,versions
Version -> public static List<Version> getDeclaredVersions(final Class<?> versionClass);1532685069;Extracts a sorted list of declared version constants from a class._The argument would normally be Version.class but is exposed for_testing with other classes-containing-version-constants.;public static List<Version> getDeclaredVersions(final Class<?> versionClass) {_        final Field[] fields = versionClass.getFields()__        final List<Version> versions = new ArrayList<>(fields.length)__        for (final Field field : fields) {_            final int mod = field.getModifiers()__            if (false == Modifier.isStatic(mod) && Modifier.isFinal(mod) && Modifier.isPublic(mod)) {_                continue__            }_            if (field.getType() != Version.class) {_                continue__            }_            if ("CURRENT".equals(field.getName())) {_                continue__            }_            assert field.getName().matches("V(_\\d+)+(_(alpha|beta|rc)\\d+)?") : field.getName()__            try {_                versions.add(((Version) field.get(null)))__            } catch (final IllegalAccessException e) {_                throw new RuntimeException(e)__            }_        }_        Collections.sort(versions)__        return versions__    };extracts,a,sorted,list,of,declared,version,constants,from,a,class,the,argument,would,normally,be,version,class,but,is,exposed,for,testing,with,other,classes,containing,version,constants;public,static,list,version,get,declared,versions,final,class,version,class,final,field,fields,version,class,get,fields,final,list,version,versions,new,array,list,fields,length,for,final,field,field,fields,final,int,mod,field,get,modifiers,if,false,modifier,is,static,mod,modifier,is,final,mod,modifier,is,public,mod,continue,if,field,get,type,version,class,continue,if,current,equals,field,get,name,continue,assert,field,get,name,matches,v,d,alpha,beta,rc,d,field,get,name,try,versions,add,version,field,get,null,catch,final,illegal,access,exception,e,throw,new,runtime,exception,e,collections,sort,versions,return,versions
Version -> public static List<Version> getDeclaredVersions(final Class<?> versionClass);1535057785;Extracts a sorted list of declared version constants from a class._The argument would normally be Version.class but is exposed for_testing with other classes-containing-version-constants.;public static List<Version> getDeclaredVersions(final Class<?> versionClass) {_        final Field[] fields = versionClass.getFields()__        final List<Version> versions = new ArrayList<>(fields.length)__        for (final Field field : fields) {_            final int mod = field.getModifiers()__            if (false == Modifier.isStatic(mod) && Modifier.isFinal(mod) && Modifier.isPublic(mod)) {_                continue__            }_            if (field.getType() != Version.class) {_                continue__            }_            if ("CURRENT".equals(field.getName())) {_                continue__            }_            assert field.getName().matches("V(_\\d+)+(_(alpha|beta|rc)\\d+)?") : field.getName()__            try {_                versions.add(((Version) field.get(null)))__            } catch (final IllegalAccessException e) {_                throw new RuntimeException(e)__            }_        }_        Collections.sort(versions)__        return versions__    };extracts,a,sorted,list,of,declared,version,constants,from,a,class,the,argument,would,normally,be,version,class,but,is,exposed,for,testing,with,other,classes,containing,version,constants;public,static,list,version,get,declared,versions,final,class,version,class,final,field,fields,version,class,get,fields,final,list,version,versions,new,array,list,fields,length,for,final,field,field,fields,final,int,mod,field,get,modifiers,if,false,modifier,is,static,mod,modifier,is,final,mod,modifier,is,public,mod,continue,if,field,get,type,version,class,continue,if,current,equals,field,get,name,continue,assert,field,get,name,matches,v,d,alpha,beta,rc,d,field,get,name,try,versions,add,version,field,get,null,catch,final,illegal,access,exception,e,throw,new,runtime,exception,e,collections,sort,versions,return,versions
Version -> public static List<Version> getDeclaredVersions(final Class<?> versionClass);1535139672;Extracts a sorted list of declared version constants from a class._The argument would normally be Version.class but is exposed for_testing with other classes-containing-version-constants.;public static List<Version> getDeclaredVersions(final Class<?> versionClass) {_        final Field[] fields = versionClass.getFields()__        final List<Version> versions = new ArrayList<>(fields.length)__        for (final Field field : fields) {_            final int mod = field.getModifiers()__            if (false == Modifier.isStatic(mod) && Modifier.isFinal(mod) && Modifier.isPublic(mod)) {_                continue__            }_            if (field.getType() != Version.class) {_                continue__            }_            if ("CURRENT".equals(field.getName())) {_                continue__            }_            assert field.getName().matches("V(_\\d+)+(_(alpha|beta|rc)\\d+)?") : field.getName()__            try {_                versions.add(((Version) field.get(null)))__            } catch (final IllegalAccessException e) {_                throw new RuntimeException(e)__            }_        }_        Collections.sort(versions)__        return versions__    };extracts,a,sorted,list,of,declared,version,constants,from,a,class,the,argument,would,normally,be,version,class,but,is,exposed,for,testing,with,other,classes,containing,version,constants;public,static,list,version,get,declared,versions,final,class,version,class,final,field,fields,version,class,get,fields,final,list,version,versions,new,array,list,fields,length,for,final,field,field,fields,final,int,mod,field,get,modifiers,if,false,modifier,is,static,mod,modifier,is,final,mod,modifier,is,public,mod,continue,if,field,get,type,version,class,continue,if,current,equals,field,get,name,continue,assert,field,get,name,matches,v,d,alpha,beta,rc,d,field,get,name,try,versions,add,version,field,get,null,catch,final,illegal,access,exception,e,throw,new,runtime,exception,e,collections,sort,versions,return,versions
Version -> public static List<Version> getDeclaredVersions(final Class<?> versionClass);1536137328;Extracts a sorted list of declared version constants from a class._The argument would normally be Version.class but is exposed for_testing with other classes-containing-version-constants.;public static List<Version> getDeclaredVersions(final Class<?> versionClass) {_        final Field[] fields = versionClass.getFields()__        final List<Version> versions = new ArrayList<>(fields.length)__        for (final Field field : fields) {_            final int mod = field.getModifiers()__            if (false == Modifier.isStatic(mod) && Modifier.isFinal(mod) && Modifier.isPublic(mod)) {_                continue__            }_            if (field.getType() != Version.class) {_                continue__            }_            switch (field.getName()) {_                case "CURRENT":_                case "V_EMPTY":_                    continue__            }_            assert field.getName().matches("V(_\\d+)+(_(alpha|beta|rc)\\d+)?") : field.getName()__            try {_                versions.add(((Version) field.get(null)))__            } catch (final IllegalAccessException e) {_                throw new RuntimeException(e)__            }_        }_        Collections.sort(versions)__        return versions__    };extracts,a,sorted,list,of,declared,version,constants,from,a,class,the,argument,would,normally,be,version,class,but,is,exposed,for,testing,with,other,classes,containing,version,constants;public,static,list,version,get,declared,versions,final,class,version,class,final,field,fields,version,class,get,fields,final,list,version,versions,new,array,list,fields,length,for,final,field,field,fields,final,int,mod,field,get,modifiers,if,false,modifier,is,static,mod,modifier,is,final,mod,modifier,is,public,mod,continue,if,field,get,type,version,class,continue,switch,field,get,name,case,current,case,continue,assert,field,get,name,matches,v,d,alpha,beta,rc,d,field,get,name,try,versions,add,version,field,get,null,catch,final,illegal,access,exception,e,throw,new,runtime,exception,e,collections,sort,versions,return,versions
Version -> public static List<Version> getDeclaredVersions(final Class<?> versionClass);1536314350;Extracts a sorted list of declared version constants from a class._The argument would normally be Version.class but is exposed for_testing with other classes-containing-version-constants.;public static List<Version> getDeclaredVersions(final Class<?> versionClass) {_        final Field[] fields = versionClass.getFields()__        final List<Version> versions = new ArrayList<>(fields.length)__        for (final Field field : fields) {_            final int mod = field.getModifiers()__            if (false == Modifier.isStatic(mod) && Modifier.isFinal(mod) && Modifier.isPublic(mod)) {_                continue__            }_            if (field.getType() != Version.class) {_                continue__            }_            switch (field.getName()) {_                case "CURRENT":_                case "V_EMPTY":_                    continue__            }_            assert field.getName().matches("V(_\\d+)+(_(alpha|beta|rc)\\d+)?") : field.getName()__            try {_                versions.add(((Version) field.get(null)))__            } catch (final IllegalAccessException e) {_                throw new RuntimeException(e)__            }_        }_        Collections.sort(versions)__        return versions__    };extracts,a,sorted,list,of,declared,version,constants,from,a,class,the,argument,would,normally,be,version,class,but,is,exposed,for,testing,with,other,classes,containing,version,constants;public,static,list,version,get,declared,versions,final,class,version,class,final,field,fields,version,class,get,fields,final,list,version,versions,new,array,list,fields,length,for,final,field,field,fields,final,int,mod,field,get,modifiers,if,false,modifier,is,static,mod,modifier,is,final,mod,modifier,is,public,mod,continue,if,field,get,type,version,class,continue,switch,field,get,name,case,current,case,continue,assert,field,get,name,matches,v,d,alpha,beta,rc,d,field,get,name,try,versions,add,version,field,get,null,catch,final,illegal,access,exception,e,throw,new,runtime,exception,e,collections,sort,versions,return,versions
Version -> public static List<Version> getDeclaredVersions(final Class<?> versionClass);1537300661;Extracts a sorted list of declared version constants from a class._The argument would normally be Version.class but is exposed for_testing with other classes-containing-version-constants.;public static List<Version> getDeclaredVersions(final Class<?> versionClass) {_        final Field[] fields = versionClass.getFields()__        final List<Version> versions = new ArrayList<>(fields.length)__        for (final Field field : fields) {_            final int mod = field.getModifiers()__            if (false == Modifier.isStatic(mod) && Modifier.isFinal(mod) && Modifier.isPublic(mod)) {_                continue__            }_            if (field.getType() != Version.class) {_                continue__            }_            switch (field.getName()) {_                case "CURRENT":_                case "V_EMPTY":_                    continue__            }_            assert field.getName().matches("V(_\\d+)+(_(alpha|beta|rc)\\d+)?") : field.getName()__            try {_                versions.add(((Version) field.get(null)))__            } catch (final IllegalAccessException e) {_                throw new RuntimeException(e)__            }_        }_        Collections.sort(versions)__        return versions__    };extracts,a,sorted,list,of,declared,version,constants,from,a,class,the,argument,would,normally,be,version,class,but,is,exposed,for,testing,with,other,classes,containing,version,constants;public,static,list,version,get,declared,versions,final,class,version,class,final,field,fields,version,class,get,fields,final,list,version,versions,new,array,list,fields,length,for,final,field,field,fields,final,int,mod,field,get,modifiers,if,false,modifier,is,static,mod,modifier,is,final,mod,modifier,is,public,mod,continue,if,field,get,type,version,class,continue,switch,field,get,name,case,current,case,continue,assert,field,get,name,matches,v,d,alpha,beta,rc,d,field,get,name,try,versions,add,version,field,get,null,catch,final,illegal,access,exception,e,throw,new,runtime,exception,e,collections,sort,versions,return,versions
Version -> public static List<Version> getDeclaredVersions(final Class<?> versionClass);1538509426;Extracts a sorted list of declared version constants from a class._The argument would normally be Version.class but is exposed for_testing with other classes-containing-version-constants.;public static List<Version> getDeclaredVersions(final Class<?> versionClass) {_        final Field[] fields = versionClass.getFields()__        final List<Version> versions = new ArrayList<>(fields.length)__        for (final Field field : fields) {_            final int mod = field.getModifiers()__            if (false == Modifier.isStatic(mod) && Modifier.isFinal(mod) && Modifier.isPublic(mod)) {_                continue__            }_            if (field.getType() != Version.class) {_                continue__            }_            switch (field.getName()) {_                case "CURRENT":_                case "V_EMPTY":_                    continue__            }_            assert field.getName().matches("V(_\\d+)+(_(alpha|beta|rc)\\d+)?") : field.getName()__            try {_                versions.add(((Version) field.get(null)))__            } catch (final IllegalAccessException e) {_                throw new RuntimeException(e)__            }_        }_        Collections.sort(versions)__        return versions__    };extracts,a,sorted,list,of,declared,version,constants,from,a,class,the,argument,would,normally,be,version,class,but,is,exposed,for,testing,with,other,classes,containing,version,constants;public,static,list,version,get,declared,versions,final,class,version,class,final,field,fields,version,class,get,fields,final,list,version,versions,new,array,list,fields,length,for,final,field,field,fields,final,int,mod,field,get,modifiers,if,false,modifier,is,static,mod,modifier,is,final,mod,modifier,is,public,mod,continue,if,field,get,type,version,class,continue,switch,field,get,name,case,current,case,continue,assert,field,get,name,matches,v,d,alpha,beta,rc,d,field,get,name,try,versions,add,version,field,get,null,catch,final,illegal,access,exception,e,throw,new,runtime,exception,e,collections,sort,versions,return,versions
Version -> public static List<Version> getDeclaredVersions(final Class<?> versionClass);1540486836;Extracts a sorted list of declared version constants from a class._The argument would normally be Version.class but is exposed for_testing with other classes-containing-version-constants.;public static List<Version> getDeclaredVersions(final Class<?> versionClass) {_        final Field[] fields = versionClass.getFields()__        final List<Version> versions = new ArrayList<>(fields.length)__        for (final Field field : fields) {_            final int mod = field.getModifiers()__            if (false == Modifier.isStatic(mod) && Modifier.isFinal(mod) && Modifier.isPublic(mod)) {_                continue__            }_            if (field.getType() != Version.class) {_                continue__            }_            switch (field.getName()) {_                case "CURRENT":_                case "V_EMPTY":_                    continue__            }_            assert field.getName().matches("V(_\\d+)+(_(alpha|beta|rc)\\d+)?") : field.getName()__            try {_                versions.add(((Version) field.get(null)))__            } catch (final IllegalAccessException e) {_                throw new RuntimeException(e)__            }_        }_        Collections.sort(versions)__        return versions__    };extracts,a,sorted,list,of,declared,version,constants,from,a,class,the,argument,would,normally,be,version,class,but,is,exposed,for,testing,with,other,classes,containing,version,constants;public,static,list,version,get,declared,versions,final,class,version,class,final,field,fields,version,class,get,fields,final,list,version,versions,new,array,list,fields,length,for,final,field,field,fields,final,int,mod,field,get,modifiers,if,false,modifier,is,static,mod,modifier,is,final,mod,modifier,is,public,mod,continue,if,field,get,type,version,class,continue,switch,field,get,name,case,current,case,continue,assert,field,get,name,matches,v,d,alpha,beta,rc,d,field,get,name,try,versions,add,version,field,get,null,catch,final,illegal,access,exception,e,throw,new,runtime,exception,e,collections,sort,versions,return,versions
Version -> public static List<Version> getDeclaredVersions(final Class<?> versionClass);1541502933;Extracts a sorted list of declared version constants from a class._The argument would normally be Version.class but is exposed for_testing with other classes-containing-version-constants.;public static List<Version> getDeclaredVersions(final Class<?> versionClass) {_        final Field[] fields = versionClass.getFields()__        final List<Version> versions = new ArrayList<>(fields.length)__        for (final Field field : fields) {_            final int mod = field.getModifiers()__            if (false == Modifier.isStatic(mod) && Modifier.isFinal(mod) && Modifier.isPublic(mod)) {_                continue__            }_            if (field.getType() != Version.class) {_                continue__            }_            switch (field.getName()) {_                case "CURRENT":_                case "V_EMPTY":_                    continue__            }_            assert field.getName().matches("V(_\\d+)+(_(alpha|beta|rc)\\d+)?") : field.getName()__            try {_                versions.add(((Version) field.get(null)))__            } catch (final IllegalAccessException e) {_                throw new RuntimeException(e)__            }_        }_        Collections.sort(versions)__        return versions__    };extracts,a,sorted,list,of,declared,version,constants,from,a,class,the,argument,would,normally,be,version,class,but,is,exposed,for,testing,with,other,classes,containing,version,constants;public,static,list,version,get,declared,versions,final,class,version,class,final,field,fields,version,class,get,fields,final,list,version,versions,new,array,list,fields,length,for,final,field,field,fields,final,int,mod,field,get,modifiers,if,false,modifier,is,static,mod,modifier,is,final,mod,modifier,is,public,mod,continue,if,field,get,type,version,class,continue,switch,field,get,name,case,current,case,continue,assert,field,get,name,matches,v,d,alpha,beta,rc,d,field,get,name,try,versions,add,version,field,get,null,catch,final,illegal,access,exception,e,throw,new,runtime,exception,e,collections,sort,versions,return,versions
Version -> public static List<Version> getDeclaredVersions(final Class<?> versionClass);1541528420;Extracts a sorted list of declared version constants from a class._The argument would normally be Version.class but is exposed for_testing with other classes-containing-version-constants.;public static List<Version> getDeclaredVersions(final Class<?> versionClass) {_        final Field[] fields = versionClass.getFields()__        final List<Version> versions = new ArrayList<>(fields.length)__        for (final Field field : fields) {_            final int mod = field.getModifiers()__            if (false == Modifier.isStatic(mod) && Modifier.isFinal(mod) && Modifier.isPublic(mod)) {_                continue__            }_            if (field.getType() != Version.class) {_                continue__            }_            switch (field.getName()) {_                case "CURRENT":_                case "V_EMPTY":_                    continue__            }_            assert field.getName().matches("V(_\\d+)+(_(alpha|beta|rc)\\d+)?") : field.getName()__            try {_                versions.add(((Version) field.get(null)))__            } catch (final IllegalAccessException e) {_                throw new RuntimeException(e)__            }_        }_        Collections.sort(versions)__        return versions__    };extracts,a,sorted,list,of,declared,version,constants,from,a,class,the,argument,would,normally,be,version,class,but,is,exposed,for,testing,with,other,classes,containing,version,constants;public,static,list,version,get,declared,versions,final,class,version,class,final,field,fields,version,class,get,fields,final,list,version,versions,new,array,list,fields,length,for,final,field,field,fields,final,int,mod,field,get,modifiers,if,false,modifier,is,static,mod,modifier,is,final,mod,modifier,is,public,mod,continue,if,field,get,type,version,class,continue,switch,field,get,name,case,current,case,continue,assert,field,get,name,matches,v,d,alpha,beta,rc,d,field,get,name,try,versions,add,version,field,get,null,catch,final,illegal,access,exception,e,throw,new,runtime,exception,e,collections,sort,versions,return,versions
Version -> public static List<Version> getDeclaredVersions(final Class<?> versionClass);1541592065;Extracts a sorted list of declared version constants from a class._The argument would normally be Version.class but is exposed for_testing with other classes-containing-version-constants.;public static List<Version> getDeclaredVersions(final Class<?> versionClass) {_        final Field[] fields = versionClass.getFields()__        final List<Version> versions = new ArrayList<>(fields.length)__        for (final Field field : fields) {_            final int mod = field.getModifiers()__            if (false == Modifier.isStatic(mod) && Modifier.isFinal(mod) && Modifier.isPublic(mod)) {_                continue__            }_            if (field.getType() != Version.class) {_                continue__            }_            switch (field.getName()) {_                case "CURRENT":_                case "V_EMPTY":_                    continue__            }_            assert field.getName().matches("V(_\\d+)+(_(alpha|beta|rc)\\d+)?") : field.getName()__            try {_                versions.add(((Version) field.get(null)))__            } catch (final IllegalAccessException e) {_                throw new RuntimeException(e)__            }_        }_        Collections.sort(versions)__        return versions__    };extracts,a,sorted,list,of,declared,version,constants,from,a,class,the,argument,would,normally,be,version,class,but,is,exposed,for,testing,with,other,classes,containing,version,constants;public,static,list,version,get,declared,versions,final,class,version,class,final,field,fields,version,class,get,fields,final,list,version,versions,new,array,list,fields,length,for,final,field,field,fields,final,int,mod,field,get,modifiers,if,false,modifier,is,static,mod,modifier,is,final,mod,modifier,is,public,mod,continue,if,field,get,type,version,class,continue,switch,field,get,name,case,current,case,continue,assert,field,get,name,matches,v,d,alpha,beta,rc,d,field,get,name,try,versions,add,version,field,get,null,catch,final,illegal,access,exception,e,throw,new,runtime,exception,e,collections,sort,versions,return,versions
Version -> public static List<Version> getDeclaredVersions(final Class<?> versionClass);1542226101;Extracts a sorted list of declared version constants from a class._The argument would normally be Version.class but is exposed for_testing with other classes-containing-version-constants.;public static List<Version> getDeclaredVersions(final Class<?> versionClass) {_        final Field[] fields = versionClass.getFields()__        final List<Version> versions = new ArrayList<>(fields.length)__        for (final Field field : fields) {_            final int mod = field.getModifiers()__            if (false == Modifier.isStatic(mod) && Modifier.isFinal(mod) && Modifier.isPublic(mod)) {_                continue__            }_            if (field.getType() != Version.class) {_                continue__            }_            switch (field.getName()) {_                case "CURRENT":_                case "V_EMPTY":_                    continue__            }_            assert field.getName().matches("V(_\\d+)+(_(alpha|beta|rc)\\d+)?") : field.getName()__            try {_                versions.add(((Version) field.get(null)))__            } catch (final IllegalAccessException e) {_                throw new RuntimeException(e)__            }_        }_        Collections.sort(versions)__        return versions__    };extracts,a,sorted,list,of,declared,version,constants,from,a,class,the,argument,would,normally,be,version,class,but,is,exposed,for,testing,with,other,classes,containing,version,constants;public,static,list,version,get,declared,versions,final,class,version,class,final,field,fields,version,class,get,fields,final,list,version,versions,new,array,list,fields,length,for,final,field,field,fields,final,int,mod,field,get,modifiers,if,false,modifier,is,static,mod,modifier,is,final,mod,modifier,is,public,mod,continue,if,field,get,type,version,class,continue,switch,field,get,name,case,current,case,continue,assert,field,get,name,matches,v,d,alpha,beta,rc,d,field,get,name,try,versions,add,version,field,get,null,catch,final,illegal,access,exception,e,throw,new,runtime,exception,e,collections,sort,versions,return,versions
Version -> public static List<Version> getDeclaredVersions(final Class<?> versionClass);1542746006;Extracts a sorted list of declared version constants from a class._The argument would normally be Version.class but is exposed for_testing with other classes-containing-version-constants.;public static List<Version> getDeclaredVersions(final Class<?> versionClass) {_        final Field[] fields = versionClass.getFields()__        final List<Version> versions = new ArrayList<>(fields.length)__        for (final Field field : fields) {_            final int mod = field.getModifiers()__            if (false == Modifier.isStatic(mod) && Modifier.isFinal(mod) && Modifier.isPublic(mod)) {_                continue__            }_            if (field.getType() != Version.class) {_                continue__            }_            switch (field.getName()) {_                case "CURRENT":_                case "V_EMPTY":_                    continue__            }_            assert field.getName().matches("V(_\\d+)+(_(alpha|beta|rc)\\d+)?") : field.getName()__            try {_                versions.add(((Version) field.get(null)))__            } catch (final IllegalAccessException e) {_                throw new RuntimeException(e)__            }_        }_        Collections.sort(versions)__        return versions__    };extracts,a,sorted,list,of,declared,version,constants,from,a,class,the,argument,would,normally,be,version,class,but,is,exposed,for,testing,with,other,classes,containing,version,constants;public,static,list,version,get,declared,versions,final,class,version,class,final,field,fields,version,class,get,fields,final,list,version,versions,new,array,list,fields,length,for,final,field,field,fields,final,int,mod,field,get,modifiers,if,false,modifier,is,static,mod,modifier,is,final,mod,modifier,is,public,mod,continue,if,field,get,type,version,class,continue,switch,field,get,name,case,current,case,continue,assert,field,get,name,matches,v,d,alpha,beta,rc,d,field,get,name,try,versions,add,version,field,get,null,catch,final,illegal,access,exception,e,throw,new,runtime,exception,e,collections,sort,versions,return,versions
Version -> public static List<Version> getDeclaredVersions(final Class<?> versionClass);1543473699;Extracts a sorted list of declared version constants from a class._The argument would normally be Version.class but is exposed for_testing with other classes-containing-version-constants.;public static List<Version> getDeclaredVersions(final Class<?> versionClass) {_        final Field[] fields = versionClass.getFields()__        final List<Version> versions = new ArrayList<>(fields.length)__        for (final Field field : fields) {_            final int mod = field.getModifiers()__            if (false == Modifier.isStatic(mod) && Modifier.isFinal(mod) && Modifier.isPublic(mod)) {_                continue__            }_            if (field.getType() != Version.class) {_                continue__            }_            switch (field.getName()) {_                case "CURRENT":_                case "V_EMPTY":_                    continue__            }_            assert field.getName().matches("V(_\\d+)+(_(alpha|beta|rc)\\d+)?") : field.getName()__            try {_                versions.add(((Version) field.get(null)))__            } catch (final IllegalAccessException e) {_                throw new RuntimeException(e)__            }_        }_        Collections.sort(versions)__        return versions__    };extracts,a,sorted,list,of,declared,version,constants,from,a,class,the,argument,would,normally,be,version,class,but,is,exposed,for,testing,with,other,classes,containing,version,constants;public,static,list,version,get,declared,versions,final,class,version,class,final,field,fields,version,class,get,fields,final,list,version,versions,new,array,list,fields,length,for,final,field,field,fields,final,int,mod,field,get,modifiers,if,false,modifier,is,static,mod,modifier,is,final,mod,modifier,is,public,mod,continue,if,field,get,type,version,class,continue,switch,field,get,name,case,current,case,continue,assert,field,get,name,matches,v,d,alpha,beta,rc,d,field,get,name,try,versions,add,version,field,get,null,catch,final,illegal,access,exception,e,throw,new,runtime,exception,e,collections,sort,versions,return,versions
Version -> public static List<Version> getDeclaredVersions(final Class<?> versionClass);1543942400;Extracts a sorted list of declared version constants from a class._The argument would normally be Version.class but is exposed for_testing with other classes-containing-version-constants.;public static List<Version> getDeclaredVersions(final Class<?> versionClass) {_        final Field[] fields = versionClass.getFields()__        final List<Version> versions = new ArrayList<>(fields.length)__        for (final Field field : fields) {_            final int mod = field.getModifiers()__            if (false == Modifier.isStatic(mod) && Modifier.isFinal(mod) && Modifier.isPublic(mod)) {_                continue__            }_            if (field.getType() != Version.class) {_                continue__            }_            switch (field.getName()) {_                case "CURRENT":_                case "V_EMPTY":_                    continue__            }_            assert field.getName().matches("V(_\\d+)+(_(alpha|beta|rc)\\d+)?") : field.getName()__            try {_                versions.add(((Version) field.get(null)))__            } catch (final IllegalAccessException e) {_                throw new RuntimeException(e)__            }_        }_        Collections.sort(versions)__        return versions__    };extracts,a,sorted,list,of,declared,version,constants,from,a,class,the,argument,would,normally,be,version,class,but,is,exposed,for,testing,with,other,classes,containing,version,constants;public,static,list,version,get,declared,versions,final,class,version,class,final,field,fields,version,class,get,fields,final,list,version,versions,new,array,list,fields,length,for,final,field,field,fields,final,int,mod,field,get,modifiers,if,false,modifier,is,static,mod,modifier,is,final,mod,modifier,is,public,mod,continue,if,field,get,type,version,class,continue,switch,field,get,name,case,current,case,continue,assert,field,get,name,matches,v,d,alpha,beta,rc,d,field,get,name,try,versions,add,version,field,get,null,catch,final,illegal,access,exception,e,throw,new,runtime,exception,e,collections,sort,versions,return,versions
Version -> public static List<Version> getDeclaredVersions(final Class<?> versionClass);1544037309;Extracts a sorted list of declared version constants from a class._The argument would normally be Version.class but is exposed for_testing with other classes-containing-version-constants.;public static List<Version> getDeclaredVersions(final Class<?> versionClass) {_        final Field[] fields = versionClass.getFields()__        final List<Version> versions = new ArrayList<>(fields.length)__        for (final Field field : fields) {_            final int mod = field.getModifiers()__            if (false == Modifier.isStatic(mod) && Modifier.isFinal(mod) && Modifier.isPublic(mod)) {_                continue__            }_            if (field.getType() != Version.class) {_                continue__            }_            switch (field.getName()) {_                case "CURRENT":_                case "V_EMPTY":_                    continue__            }_            assert field.getName().matches("V(_\\d+)+(_(alpha|beta|rc)\\d+)?") : field.getName()__            try {_                versions.add(((Version) field.get(null)))__            } catch (final IllegalAccessException e) {_                throw new RuntimeException(e)__            }_        }_        Collections.sort(versions)__        return versions__    };extracts,a,sorted,list,of,declared,version,constants,from,a,class,the,argument,would,normally,be,version,class,but,is,exposed,for,testing,with,other,classes,containing,version,constants;public,static,list,version,get,declared,versions,final,class,version,class,final,field,fields,version,class,get,fields,final,list,version,versions,new,array,list,fields,length,for,final,field,field,fields,final,int,mod,field,get,modifiers,if,false,modifier,is,static,mod,modifier,is,final,mod,modifier,is,public,mod,continue,if,field,get,type,version,class,continue,switch,field,get,name,case,current,case,continue,assert,field,get,name,matches,v,d,alpha,beta,rc,d,field,get,name,try,versions,add,version,field,get,null,catch,final,illegal,access,exception,e,throw,new,runtime,exception,e,collections,sort,versions,return,versions
Version -> public static List<Version> getDeclaredVersions(final Class<?> versionClass);1544553539;Extracts a sorted list of declared version constants from a class._The argument would normally be Version.class but is exposed for_testing with other classes-containing-version-constants.;public static List<Version> getDeclaredVersions(final Class<?> versionClass) {_        final Field[] fields = versionClass.getFields()__        final List<Version> versions = new ArrayList<>(fields.length)__        for (final Field field : fields) {_            final int mod = field.getModifiers()__            if (false == Modifier.isStatic(mod) && Modifier.isFinal(mod) && Modifier.isPublic(mod)) {_                continue__            }_            if (field.getType() != Version.class) {_                continue__            }_            switch (field.getName()) {_                case "CURRENT":_                case "V_EMPTY":_                    continue__            }_            assert field.getName().matches("V(_\\d+)+(_(alpha|beta|rc)\\d+)?") : field.getName()__            try {_                versions.add(((Version) field.get(null)))__            } catch (final IllegalAccessException e) {_                throw new RuntimeException(e)__            }_        }_        Collections.sort(versions)__        return versions__    };extracts,a,sorted,list,of,declared,version,constants,from,a,class,the,argument,would,normally,be,version,class,but,is,exposed,for,testing,with,other,classes,containing,version,constants;public,static,list,version,get,declared,versions,final,class,version,class,final,field,fields,version,class,get,fields,final,list,version,versions,new,array,list,fields,length,for,final,field,field,fields,final,int,mod,field,get,modifiers,if,false,modifier,is,static,mod,modifier,is,final,mod,modifier,is,public,mod,continue,if,field,get,type,version,class,continue,switch,field,get,name,case,current,case,continue,assert,field,get,name,matches,v,d,alpha,beta,rc,d,field,get,name,try,versions,add,version,field,get,null,catch,final,illegal,access,exception,e,throw,new,runtime,exception,e,collections,sort,versions,return,versions
Version -> public static List<Version> getDeclaredVersions(final Class<?> versionClass);1545225850;Extracts a sorted list of declared version constants from a class._The argument would normally be Version.class but is exposed for_testing with other classes-containing-version-constants.;public static List<Version> getDeclaredVersions(final Class<?> versionClass) {_        final Field[] fields = versionClass.getFields()__        final List<Version> versions = new ArrayList<>(fields.length)__        for (final Field field : fields) {_            final int mod = field.getModifiers()__            if (false == Modifier.isStatic(mod) && Modifier.isFinal(mod) && Modifier.isPublic(mod)) {_                continue__            }_            if (field.getType() != Version.class) {_                continue__            }_            switch (field.getName()) {_                case "CURRENT":_                case "V_EMPTY":_                    continue__            }_            assert field.getName().matches("V(_\\d+)+(_(alpha|beta|rc)\\d+)?") : field.getName()__            try {_                versions.add(((Version) field.get(null)))__            } catch (final IllegalAccessException e) {_                throw new RuntimeException(e)__            }_        }_        Collections.sort(versions)__        return versions__    };extracts,a,sorted,list,of,declared,version,constants,from,a,class,the,argument,would,normally,be,version,class,but,is,exposed,for,testing,with,other,classes,containing,version,constants;public,static,list,version,get,declared,versions,final,class,version,class,final,field,fields,version,class,get,fields,final,list,version,versions,new,array,list,fields,length,for,final,field,field,fields,final,int,mod,field,get,modifiers,if,false,modifier,is,static,mod,modifier,is,final,mod,modifier,is,public,mod,continue,if,field,get,type,version,class,continue,switch,field,get,name,case,current,case,continue,assert,field,get,name,matches,v,d,alpha,beta,rc,d,field,get,name,try,versions,add,version,field,get,null,catch,final,illegal,access,exception,e,throw,new,runtime,exception,e,collections,sort,versions,return,versions
Version -> public static List<Version> getDeclaredVersions(final Class<?> versionClass);1545256934;Extracts a sorted list of declared version constants from a class._The argument would normally be Version.class but is exposed for_testing with other classes-containing-version-constants.;public static List<Version> getDeclaredVersions(final Class<?> versionClass) {_        final Field[] fields = versionClass.getFields()__        final List<Version> versions = new ArrayList<>(fields.length)__        for (final Field field : fields) {_            final int mod = field.getModifiers()__            if (false == Modifier.isStatic(mod) && Modifier.isFinal(mod) && Modifier.isPublic(mod)) {_                continue__            }_            if (field.getType() != Version.class) {_                continue__            }_            switch (field.getName()) {_                case "CURRENT":_                case "V_EMPTY":_                    continue__            }_            assert field.getName().matches("V(_\\d+)+(_(alpha|beta|rc)\\d+)?") : field.getName()__            try {_                versions.add(((Version) field.get(null)))__            } catch (final IllegalAccessException e) {_                throw new RuntimeException(e)__            }_        }_        Collections.sort(versions)__        return versions__    };extracts,a,sorted,list,of,declared,version,constants,from,a,class,the,argument,would,normally,be,version,class,but,is,exposed,for,testing,with,other,classes,containing,version,constants;public,static,list,version,get,declared,versions,final,class,version,class,final,field,fields,version,class,get,fields,final,list,version,versions,new,array,list,fields,length,for,final,field,field,fields,final,int,mod,field,get,modifiers,if,false,modifier,is,static,mod,modifier,is,final,mod,modifier,is,public,mod,continue,if,field,get,type,version,class,continue,switch,field,get,name,case,current,case,continue,assert,field,get,name,matches,v,d,alpha,beta,rc,d,field,get,name,try,versions,add,version,field,get,null,catch,final,illegal,access,exception,e,throw,new,runtime,exception,e,collections,sort,versions,return,versions
Version -> public static List<Version> getDeclaredVersions(final Class<?> versionClass);1546507247;Extracts a sorted list of declared version constants from a class._The argument would normally be Version.class but is exposed for_testing with other classes-containing-version-constants.;public static List<Version> getDeclaredVersions(final Class<?> versionClass) {_        final Field[] fields = versionClass.getFields()__        final List<Version> versions = new ArrayList<>(fields.length)__        for (final Field field : fields) {_            final int mod = field.getModifiers()__            if (false == Modifier.isStatic(mod) && Modifier.isFinal(mod) && Modifier.isPublic(mod)) {_                continue__            }_            if (field.getType() != Version.class) {_                continue__            }_            switch (field.getName()) {_                case "CURRENT":_                case "V_EMPTY":_                    continue__            }_            assert field.getName().matches("V(_\\d+)+(_(alpha|beta|rc)\\d+)?") : field.getName()__            try {_                versions.add(((Version) field.get(null)))__            } catch (final IllegalAccessException e) {_                throw new RuntimeException(e)__            }_        }_        Collections.sort(versions)__        return versions__    };extracts,a,sorted,list,of,declared,version,constants,from,a,class,the,argument,would,normally,be,version,class,but,is,exposed,for,testing,with,other,classes,containing,version,constants;public,static,list,version,get,declared,versions,final,class,version,class,final,field,fields,version,class,get,fields,final,list,version,versions,new,array,list,fields,length,for,final,field,field,fields,final,int,mod,field,get,modifiers,if,false,modifier,is,static,mod,modifier,is,final,mod,modifier,is,public,mod,continue,if,field,get,type,version,class,continue,switch,field,get,name,case,current,case,continue,assert,field,get,name,matches,v,d,alpha,beta,rc,d,field,get,name,try,versions,add,version,field,get,null,catch,final,illegal,access,exception,e,throw,new,runtime,exception,e,collections,sort,versions,return,versions
Version -> public static List<Version> getDeclaredVersions(final Class<?> versionClass);1546537951;Extracts a sorted list of declared version constants from a class._The argument would normally be Version.class but is exposed for_testing with other classes-containing-version-constants.;public static List<Version> getDeclaredVersions(final Class<?> versionClass) {_        final Field[] fields = versionClass.getFields()__        final List<Version> versions = new ArrayList<>(fields.length)__        for (final Field field : fields) {_            final int mod = field.getModifiers()__            if (false == Modifier.isStatic(mod) && Modifier.isFinal(mod) && Modifier.isPublic(mod)) {_                continue__            }_            if (field.getType() != Version.class) {_                continue__            }_            switch (field.getName()) {_                case "CURRENT":_                case "V_EMPTY":_                    continue__            }_            assert field.getName().matches("V(_\\d+)+(_(alpha|beta|rc)\\d+)?") : field.getName()__            try {_                versions.add(((Version) field.get(null)))__            } catch (final IllegalAccessException e) {_                throw new RuntimeException(e)__            }_        }_        Collections.sort(versions)__        return versions__    };extracts,a,sorted,list,of,declared,version,constants,from,a,class,the,argument,would,normally,be,version,class,but,is,exposed,for,testing,with,other,classes,containing,version,constants;public,static,list,version,get,declared,versions,final,class,version,class,final,field,fields,version,class,get,fields,final,list,version,versions,new,array,list,fields,length,for,final,field,field,fields,final,int,mod,field,get,modifiers,if,false,modifier,is,static,mod,modifier,is,final,mod,modifier,is,public,mod,continue,if,field,get,type,version,class,continue,switch,field,get,name,case,current,case,continue,assert,field,get,name,matches,v,d,alpha,beta,rc,d,field,get,name,try,versions,add,version,field,get,null,catch,final,illegal,access,exception,e,throw,new,runtime,exception,e,collections,sort,versions,return,versions
Version -> public static List<Version> getDeclaredVersions(final Class<?> versionClass);1548755041;Extracts a sorted list of declared version constants from a class._The argument would normally be Version.class but is exposed for_testing with other classes-containing-version-constants.;public static List<Version> getDeclaredVersions(final Class<?> versionClass) {_        final Field[] fields = versionClass.getFields()__        final List<Version> versions = new ArrayList<>(fields.length)__        for (final Field field : fields) {_            final int mod = field.getModifiers()__            if (false == Modifier.isStatic(mod) && Modifier.isFinal(mod) && Modifier.isPublic(mod)) {_                continue__            }_            if (field.getType() != Version.class) {_                continue__            }_            switch (field.getName()) {_                case "CURRENT":_                case "V_EMPTY":_                    continue__            }_            assert field.getName().matches("V(_\\d+)+(_(alpha|beta|rc)\\d+)?") : field.getName()__            try {_                versions.add(((Version) field.get(null)))__            } catch (final IllegalAccessException e) {_                throw new RuntimeException(e)__            }_        }_        Collections.sort(versions)__        return versions__    };extracts,a,sorted,list,of,declared,version,constants,from,a,class,the,argument,would,normally,be,version,class,but,is,exposed,for,testing,with,other,classes,containing,version,constants;public,static,list,version,get,declared,versions,final,class,version,class,final,field,fields,version,class,get,fields,final,list,version,versions,new,array,list,fields,length,for,final,field,field,fields,final,int,mod,field,get,modifiers,if,false,modifier,is,static,mod,modifier,is,final,mod,modifier,is,public,mod,continue,if,field,get,type,version,class,continue,switch,field,get,name,case,current,case,continue,assert,field,get,name,matches,v,d,alpha,beta,rc,d,field,get,name,try,versions,add,version,field,get,null,catch,final,illegal,access,exception,e,throw,new,runtime,exception,e,collections,sort,versions,return,versions
Version -> public static List<Version> getDeclaredVersions(final Class<?> versionClass);1548822781;Extracts a sorted list of declared version constants from a class._The argument would normally be Version.class but is exposed for_testing with other classes-containing-version-constants.;public static List<Version> getDeclaredVersions(final Class<?> versionClass) {_        final Field[] fields = versionClass.getFields()__        final List<Version> versions = new ArrayList<>(fields.length)__        for (final Field field : fields) {_            final int mod = field.getModifiers()__            if (false == Modifier.isStatic(mod) && Modifier.isFinal(mod) && Modifier.isPublic(mod)) {_                continue__            }_            if (field.getType() != Version.class) {_                continue__            }_            switch (field.getName()) {_                case "CURRENT":_                case "V_EMPTY":_                    continue__            }_            assert field.getName().matches("V(_\\d+)+(_(alpha|beta|rc)\\d+)?") : field.getName()__            try {_                versions.add(((Version) field.get(null)))__            } catch (final IllegalAccessException e) {_                throw new RuntimeException(e)__            }_        }_        Collections.sort(versions)__        return versions__    };extracts,a,sorted,list,of,declared,version,constants,from,a,class,the,argument,would,normally,be,version,class,but,is,exposed,for,testing,with,other,classes,containing,version,constants;public,static,list,version,get,declared,versions,final,class,version,class,final,field,fields,version,class,get,fields,final,list,version,versions,new,array,list,fields,length,for,final,field,field,fields,final,int,mod,field,get,modifiers,if,false,modifier,is,static,mod,modifier,is,final,mod,modifier,is,public,mod,continue,if,field,get,type,version,class,continue,switch,field,get,name,case,current,case,continue,assert,field,get,name,matches,v,d,alpha,beta,rc,d,field,get,name,try,versions,add,version,field,get,null,catch,final,illegal,access,exception,e,throw,new,runtime,exception,e,collections,sort,versions,return,versions
Version -> public static List<Version> getDeclaredVersions(final Class<?> versionClass);1549608646;Extracts a sorted list of declared version constants from a class._The argument would normally be Version.class but is exposed for_testing with other classes-containing-version-constants.;public static List<Version> getDeclaredVersions(final Class<?> versionClass) {_        final Field[] fields = versionClass.getFields()__        final List<Version> versions = new ArrayList<>(fields.length)__        for (final Field field : fields) {_            final int mod = field.getModifiers()__            if (false == Modifier.isStatic(mod) && Modifier.isFinal(mod) && Modifier.isPublic(mod)) {_                continue__            }_            if (field.getType() != Version.class) {_                continue__            }_            switch (field.getName()) {_                case "CURRENT":_                case "V_EMPTY":_                    continue__            }_            assert field.getName().matches("V(_\\d+)+(_(alpha|beta|rc)\\d+)?") : field.getName()__            try {_                versions.add(((Version) field.get(null)))__            } catch (final IllegalAccessException e) {_                throw new RuntimeException(e)__            }_        }_        Collections.sort(versions)__        return versions__    };extracts,a,sorted,list,of,declared,version,constants,from,a,class,the,argument,would,normally,be,version,class,but,is,exposed,for,testing,with,other,classes,containing,version,constants;public,static,list,version,get,declared,versions,final,class,version,class,final,field,fields,version,class,get,fields,final,list,version,versions,new,array,list,fields,length,for,final,field,field,fields,final,int,mod,field,get,modifiers,if,false,modifier,is,static,mod,modifier,is,final,mod,modifier,is,public,mod,continue,if,field,get,type,version,class,continue,switch,field,get,name,case,current,case,continue,assert,field,get,name,matches,v,d,alpha,beta,rc,d,field,get,name,try,versions,add,version,field,get,null,catch,final,illegal,access,exception,e,throw,new,runtime,exception,e,collections,sort,versions,return,versions
Version -> public static List<Version> getDeclaredVersions(final Class<?> versionClass);1550604529;Extracts a sorted list of declared version constants from a class._The argument would normally be Version.class but is exposed for_testing with other classes-containing-version-constants.;public static List<Version> getDeclaredVersions(final Class<?> versionClass) {_        final Field[] fields = versionClass.getFields()__        final List<Version> versions = new ArrayList<>(fields.length)__        for (final Field field : fields) {_            final int mod = field.getModifiers()__            if (false == Modifier.isStatic(mod) && Modifier.isFinal(mod) && Modifier.isPublic(mod)) {_                continue__            }_            if (field.getType() != Version.class) {_                continue__            }_            switch (field.getName()) {_                case "CURRENT":_                case "V_EMPTY":_                    continue__            }_            assert field.getName().matches("V(_\\d+)+(_(alpha|beta|rc)\\d+)?") : field.getName()__            try {_                versions.add(((Version) field.get(null)))__            } catch (final IllegalAccessException e) {_                throw new RuntimeException(e)__            }_        }_        Collections.sort(versions)__        return versions__    };extracts,a,sorted,list,of,declared,version,constants,from,a,class,the,argument,would,normally,be,version,class,but,is,exposed,for,testing,with,other,classes,containing,version,constants;public,static,list,version,get,declared,versions,final,class,version,class,final,field,fields,version,class,get,fields,final,list,version,versions,new,array,list,fields,length,for,final,field,field,fields,final,int,mod,field,get,modifiers,if,false,modifier,is,static,mod,modifier,is,final,mod,modifier,is,public,mod,continue,if,field,get,type,version,class,continue,switch,field,get,name,case,current,case,continue,assert,field,get,name,matches,v,d,alpha,beta,rc,d,field,get,name,try,versions,add,version,field,get,null,catch,final,illegal,access,exception,e,throw,new,runtime,exception,e,collections,sort,versions,return,versions
Version -> public static Version fromString(String version);1524684173;Returns the version given its string representation, current version if the argument is null or empty;public static Version fromString(String version) {_        if (!Strings.hasLength(version)) {_            return Version.CURRENT__        }_        final boolean snapshot_ _        if (snapshot = version.endsWith("-SNAPSHOT")) {_            version = version.substring(0, version.length() - 9)__        }_        String[] parts = version.split("[.-]")__        if (parts.length < 3 || parts.length > 4) {_            throw new IllegalArgumentException(_                    "the version needs to contain major, minor, and revision, and optionally the build: " + version)__        }__        try {_            final int rawMajor = Integer.parseInt(parts[0])__            if (rawMajor >= 5 && snapshot) { _                throw new IllegalArgumentException("illegal version format - snapshots are only supported until version 2.x")__            }_            final int betaOffset = rawMajor < 5 ? 0 : 25__            _            final int major = rawMajor * 1000000__            final int minor = Integer.parseInt(parts[1]) * 10000__            final int revision = Integer.parseInt(parts[2]) * 100____            int build = 99__            if (parts.length == 4) {_                String buildStr = parts[3]__                if (buildStr.startsWith("alpha")) {_                    assert rawMajor >= 5 : "major must be >= 5 but was " + major__                    build = Integer.parseInt(buildStr.substring(5))__                    assert build < 25 : "expected a beta build but " + build + " >= 25"__                } else if (buildStr.startsWith("Beta") || buildStr.startsWith("beta")) {_                    build = betaOffset + Integer.parseInt(buildStr.substring(4))__                    assert build < 50 : "expected a beta build but " + build + " >= 50"__                } else if (buildStr.startsWith("RC") || buildStr.startsWith("rc")) {_                    build = Integer.parseInt(buildStr.substring(2)) + 50__                } else {_                    throw new IllegalArgumentException("unable to parse version " + version)__                }_            }__            return fromId(major + minor + revision + build)___        } catch (NumberFormatException e) {_            throw new IllegalArgumentException("unable to parse version " + version, e)__        }_    };returns,the,version,given,its,string,representation,current,version,if,the,argument,is,null,or,empty;public,static,version,from,string,string,version,if,strings,has,length,version,return,version,current,final,boolean,snapshot,if,snapshot,version,ends,with,snapshot,version,version,substring,0,version,length,9,string,parts,version,split,if,parts,length,3,parts,length,4,throw,new,illegal,argument,exception,the,version,needs,to,contain,major,minor,and,revision,and,optionally,the,build,version,try,final,int,raw,major,integer,parse,int,parts,0,if,raw,major,5,snapshot,throw,new,illegal,argument,exception,illegal,version,format,snapshots,are,only,supported,until,version,2,x,final,int,beta,offset,raw,major,5,0,25,final,int,major,raw,major,1000000,final,int,minor,integer,parse,int,parts,1,10000,final,int,revision,integer,parse,int,parts,2,100,int,build,99,if,parts,length,4,string,build,str,parts,3,if,build,str,starts,with,alpha,assert,raw,major,5,major,must,be,5,but,was,major,build,integer,parse,int,build,str,substring,5,assert,build,25,expected,a,beta,build,but,build,25,else,if,build,str,starts,with,beta,build,str,starts,with,beta,build,beta,offset,integer,parse,int,build,str,substring,4,assert,build,50,expected,a,beta,build,but,build,50,else,if,build,str,starts,with,rc,build,str,starts,with,rc,build,integer,parse,int,build,str,substring,2,50,else,throw,new,illegal,argument,exception,unable,to,parse,version,version,return,from,id,major,minor,revision,build,catch,number,format,exception,e,throw,new,illegal,argument,exception,unable,to,parse,version,version,e
Version -> public static Version fromString(String version);1525645056;Returns the version given its string representation, current version if the argument is null or empty;public static Version fromString(String version) {_        if (!Strings.hasLength(version)) {_            return Version.CURRENT__        }_        final boolean snapshot_ _        if (snapshot = version.endsWith("-SNAPSHOT")) {_            version = version.substring(0, version.length() - 9)__        }_        String[] parts = version.split("[.-]")__        if (parts.length < 3 || parts.length > 4) {_            throw new IllegalArgumentException(_                    "the version needs to contain major, minor, and revision, and optionally the build: " + version)__        }__        try {_            final int rawMajor = Integer.parseInt(parts[0])__            if (rawMajor >= 5 && snapshot) { _                throw new IllegalArgumentException("illegal version format - snapshots are only supported until version 2.x")__            }_            final int betaOffset = rawMajor < 5 ? 0 : 25__            _            final int major = rawMajor * 1000000__            final int minor = Integer.parseInt(parts[1]) * 10000__            final int revision = Integer.parseInt(parts[2]) * 100____            int build = 99__            if (parts.length == 4) {_                String buildStr = parts[3]__                if (buildStr.startsWith("alpha")) {_                    assert rawMajor >= 5 : "major must be >= 5 but was " + major__                    build = Integer.parseInt(buildStr.substring(5))__                    assert build < 25 : "expected a beta build but " + build + " >= 25"__                } else if (buildStr.startsWith("Beta") || buildStr.startsWith("beta")) {_                    build = betaOffset + Integer.parseInt(buildStr.substring(4))__                    assert build < 50 : "expected a beta build but " + build + " >= 50"__                } else if (buildStr.startsWith("RC") || buildStr.startsWith("rc")) {_                    build = Integer.parseInt(buildStr.substring(2)) + 50__                } else {_                    throw new IllegalArgumentException("unable to parse version " + version)__                }_            }__            return fromId(major + minor + revision + build)___        } catch (NumberFormatException e) {_            throw new IllegalArgumentException("unable to parse version " + version, e)__        }_    };returns,the,version,given,its,string,representation,current,version,if,the,argument,is,null,or,empty;public,static,version,from,string,string,version,if,strings,has,length,version,return,version,current,final,boolean,snapshot,if,snapshot,version,ends,with,snapshot,version,version,substring,0,version,length,9,string,parts,version,split,if,parts,length,3,parts,length,4,throw,new,illegal,argument,exception,the,version,needs,to,contain,major,minor,and,revision,and,optionally,the,build,version,try,final,int,raw,major,integer,parse,int,parts,0,if,raw,major,5,snapshot,throw,new,illegal,argument,exception,illegal,version,format,snapshots,are,only,supported,until,version,2,x,final,int,beta,offset,raw,major,5,0,25,final,int,major,raw,major,1000000,final,int,minor,integer,parse,int,parts,1,10000,final,int,revision,integer,parse,int,parts,2,100,int,build,99,if,parts,length,4,string,build,str,parts,3,if,build,str,starts,with,alpha,assert,raw,major,5,major,must,be,5,but,was,major,build,integer,parse,int,build,str,substring,5,assert,build,25,expected,a,beta,build,but,build,25,else,if,build,str,starts,with,beta,build,str,starts,with,beta,build,beta,offset,integer,parse,int,build,str,substring,4,assert,build,50,expected,a,beta,build,but,build,50,else,if,build,str,starts,with,rc,build,str,starts,with,rc,build,integer,parse,int,build,str,substring,2,50,else,throw,new,illegal,argument,exception,unable,to,parse,version,version,return,from,id,major,minor,revision,build,catch,number,format,exception,e,throw,new,illegal,argument,exception,unable,to,parse,version,version,e
Version -> public static Version fromString(String version);1526900724;Returns the version given its string representation, current version if the argument is null or empty;public static Version fromString(String version) {_        if (!Strings.hasLength(version)) {_            return Version.CURRENT__        }_        final boolean snapshot_ _        if (snapshot = version.endsWith("-SNAPSHOT")) {_            version = version.substring(0, version.length() - 9)__        }_        String[] parts = version.split("[.-]")__        if (parts.length < 3 || parts.length > 4) {_            throw new IllegalArgumentException(_                    "the version needs to contain major, minor, and revision, and optionally the build: " + version)__        }__        try {_            final int rawMajor = Integer.parseInt(parts[0])__            if (rawMajor >= 5 && snapshot) { _                throw new IllegalArgumentException("illegal version format - snapshots are only supported until version 2.x")__            }_            final int betaOffset = rawMajor < 5 ? 0 : 25__            _            final int major = rawMajor * 1000000__            final int minor = Integer.parseInt(parts[1]) * 10000__            final int revision = Integer.parseInt(parts[2]) * 100____            int build = 99__            if (parts.length == 4) {_                String buildStr = parts[3]__                if (buildStr.startsWith("alpha")) {_                    assert rawMajor >= 5 : "major must be >= 5 but was " + major__                    build = Integer.parseInt(buildStr.substring(5))__                    assert build < 25 : "expected a beta build but " + build + " >= 25"__                } else if (buildStr.startsWith("Beta") || buildStr.startsWith("beta")) {_                    build = betaOffset + Integer.parseInt(buildStr.substring(4))__                    assert build < 50 : "expected a beta build but " + build + " >= 50"__                } else if (buildStr.startsWith("RC") || buildStr.startsWith("rc")) {_                    build = Integer.parseInt(buildStr.substring(2)) + 50__                } else {_                    throw new IllegalArgumentException("unable to parse version " + version)__                }_            }__            return fromId(major + minor + revision + build)___        } catch (NumberFormatException e) {_            throw new IllegalArgumentException("unable to parse version " + version, e)__        }_    };returns,the,version,given,its,string,representation,current,version,if,the,argument,is,null,or,empty;public,static,version,from,string,string,version,if,strings,has,length,version,return,version,current,final,boolean,snapshot,if,snapshot,version,ends,with,snapshot,version,version,substring,0,version,length,9,string,parts,version,split,if,parts,length,3,parts,length,4,throw,new,illegal,argument,exception,the,version,needs,to,contain,major,minor,and,revision,and,optionally,the,build,version,try,final,int,raw,major,integer,parse,int,parts,0,if,raw,major,5,snapshot,throw,new,illegal,argument,exception,illegal,version,format,snapshots,are,only,supported,until,version,2,x,final,int,beta,offset,raw,major,5,0,25,final,int,major,raw,major,1000000,final,int,minor,integer,parse,int,parts,1,10000,final,int,revision,integer,parse,int,parts,2,100,int,build,99,if,parts,length,4,string,build,str,parts,3,if,build,str,starts,with,alpha,assert,raw,major,5,major,must,be,5,but,was,major,build,integer,parse,int,build,str,substring,5,assert,build,25,expected,a,beta,build,but,build,25,else,if,build,str,starts,with,beta,build,str,starts,with,beta,build,beta,offset,integer,parse,int,build,str,substring,4,assert,build,50,expected,a,beta,build,but,build,50,else,if,build,str,starts,with,rc,build,str,starts,with,rc,build,integer,parse,int,build,str,substring,2,50,else,throw,new,illegal,argument,exception,unable,to,parse,version,version,return,from,id,major,minor,revision,build,catch,number,format,exception,e,throw,new,illegal,argument,exception,unable,to,parse,version,version,e
Version -> public static Version fromString(String version);1528917185;Returns the version given its string representation, current version if the argument is null or empty;public static Version fromString(String version) {_        if (!Strings.hasLength(version)) {_            return Version.CURRENT__        }_        final boolean snapshot_ _        if (snapshot = version.endsWith("-SNAPSHOT")) {_            version = version.substring(0, version.length() - 9)__        }_        String[] parts = version.split("[.-]")__        if (parts.length < 3 || parts.length > 4) {_            throw new IllegalArgumentException(_                    "the version needs to contain major, minor, and revision, and optionally the build: " + version)__        }__        try {_            final int rawMajor = Integer.parseInt(parts[0])__            if (rawMajor >= 5 && snapshot) { _                throw new IllegalArgumentException("illegal version format - snapshots are only supported until version 2.x")__            }_            final int betaOffset = rawMajor < 5 ? 0 : 25__            _            final int major = rawMajor * 1000000__            final int minor = Integer.parseInt(parts[1]) * 10000__            final int revision = Integer.parseInt(parts[2]) * 100____            int build = 99__            if (parts.length == 4) {_                String buildStr = parts[3]__                if (buildStr.startsWith("alpha")) {_                    assert rawMajor >= 5 : "major must be >= 5 but was " + major__                    build = Integer.parseInt(buildStr.substring(5))__                    assert build < 25 : "expected a beta build but " + build + " >= 25"__                } else if (buildStr.startsWith("Beta") || buildStr.startsWith("beta")) {_                    build = betaOffset + Integer.parseInt(buildStr.substring(4))__                    assert build < 50 : "expected a beta build but " + build + " >= 50"__                } else if (buildStr.startsWith("RC") || buildStr.startsWith("rc")) {_                    build = Integer.parseInt(buildStr.substring(2)) + 50__                } else {_                    throw new IllegalArgumentException("unable to parse version " + version)__                }_            }__            return fromId(major + minor + revision + build)___        } catch (NumberFormatException e) {_            throw new IllegalArgumentException("unable to parse version " + version, e)__        }_    };returns,the,version,given,its,string,representation,current,version,if,the,argument,is,null,or,empty;public,static,version,from,string,string,version,if,strings,has,length,version,return,version,current,final,boolean,snapshot,if,snapshot,version,ends,with,snapshot,version,version,substring,0,version,length,9,string,parts,version,split,if,parts,length,3,parts,length,4,throw,new,illegal,argument,exception,the,version,needs,to,contain,major,minor,and,revision,and,optionally,the,build,version,try,final,int,raw,major,integer,parse,int,parts,0,if,raw,major,5,snapshot,throw,new,illegal,argument,exception,illegal,version,format,snapshots,are,only,supported,until,version,2,x,final,int,beta,offset,raw,major,5,0,25,final,int,major,raw,major,1000000,final,int,minor,integer,parse,int,parts,1,10000,final,int,revision,integer,parse,int,parts,2,100,int,build,99,if,parts,length,4,string,build,str,parts,3,if,build,str,starts,with,alpha,assert,raw,major,5,major,must,be,5,but,was,major,build,integer,parse,int,build,str,substring,5,assert,build,25,expected,a,beta,build,but,build,25,else,if,build,str,starts,with,beta,build,str,starts,with,beta,build,beta,offset,integer,parse,int,build,str,substring,4,assert,build,50,expected,a,beta,build,but,build,50,else,if,build,str,starts,with,rc,build,str,starts,with,rc,build,integer,parse,int,build,str,substring,2,50,else,throw,new,illegal,argument,exception,unable,to,parse,version,version,return,from,id,major,minor,revision,build,catch,number,format,exception,e,throw,new,illegal,argument,exception,unable,to,parse,version,version,e
Version -> public static Version fromString(String version);1528924528;Returns the version given its string representation, current version if the argument is null or empty;public static Version fromString(String version) {_        if (!Strings.hasLength(version)) {_            return Version.CURRENT__        }_        final boolean snapshot_ _        if (snapshot = version.endsWith("-SNAPSHOT")) {_            version = version.substring(0, version.length() - 9)__        }_        String[] parts = version.split("[.-]")__        if (parts.length < 3 || parts.length > 4) {_            throw new IllegalArgumentException(_                    "the version needs to contain major, minor, and revision, and optionally the build: " + version)__        }__        try {_            final int rawMajor = Integer.parseInt(parts[0])__            if (rawMajor >= 5 && snapshot) { _                throw new IllegalArgumentException("illegal version format - snapshots are only supported until version 2.x")__            }_            final int betaOffset = rawMajor < 5 ? 0 : 25__            _            final int major = rawMajor * 1000000__            final int minor = Integer.parseInt(parts[1]) * 10000__            final int revision = Integer.parseInt(parts[2]) * 100____            int build = 99__            if (parts.length == 4) {_                String buildStr = parts[3]__                if (buildStr.startsWith("alpha")) {_                    assert rawMajor >= 5 : "major must be >= 5 but was " + major__                    build = Integer.parseInt(buildStr.substring(5))__                    assert build < 25 : "expected a beta build but " + build + " >= 25"__                } else if (buildStr.startsWith("Beta") || buildStr.startsWith("beta")) {_                    build = betaOffset + Integer.parseInt(buildStr.substring(4))__                    assert build < 50 : "expected a beta build but " + build + " >= 50"__                } else if (buildStr.startsWith("RC") || buildStr.startsWith("rc")) {_                    build = Integer.parseInt(buildStr.substring(2)) + 50__                } else {_                    throw new IllegalArgumentException("unable to parse version " + version)__                }_            }__            return fromId(major + minor + revision + build)___        } catch (NumberFormatException e) {_            throw new IllegalArgumentException("unable to parse version " + version, e)__        }_    };returns,the,version,given,its,string,representation,current,version,if,the,argument,is,null,or,empty;public,static,version,from,string,string,version,if,strings,has,length,version,return,version,current,final,boolean,snapshot,if,snapshot,version,ends,with,snapshot,version,version,substring,0,version,length,9,string,parts,version,split,if,parts,length,3,parts,length,4,throw,new,illegal,argument,exception,the,version,needs,to,contain,major,minor,and,revision,and,optionally,the,build,version,try,final,int,raw,major,integer,parse,int,parts,0,if,raw,major,5,snapshot,throw,new,illegal,argument,exception,illegal,version,format,snapshots,are,only,supported,until,version,2,x,final,int,beta,offset,raw,major,5,0,25,final,int,major,raw,major,1000000,final,int,minor,integer,parse,int,parts,1,10000,final,int,revision,integer,parse,int,parts,2,100,int,build,99,if,parts,length,4,string,build,str,parts,3,if,build,str,starts,with,alpha,assert,raw,major,5,major,must,be,5,but,was,major,build,integer,parse,int,build,str,substring,5,assert,build,25,expected,a,beta,build,but,build,25,else,if,build,str,starts,with,beta,build,str,starts,with,beta,build,beta,offset,integer,parse,int,build,str,substring,4,assert,build,50,expected,a,beta,build,but,build,50,else,if,build,str,starts,with,rc,build,str,starts,with,rc,build,integer,parse,int,build,str,substring,2,50,else,throw,new,illegal,argument,exception,unable,to,parse,version,version,return,from,id,major,minor,revision,build,catch,number,format,exception,e,throw,new,illegal,argument,exception,unable,to,parse,version,version,e
Version -> public static Version fromString(String version);1531179852;Returns the version given its string representation, current version if the argument is null or empty;public static Version fromString(String version) {_        if (!Strings.hasLength(version)) {_            return Version.CURRENT__        }_        final boolean snapshot_ _        if (snapshot = version.endsWith("-SNAPSHOT")) {_            version = version.substring(0, version.length() - 9)__        }_        String[] parts = version.split("[.-]")__        if (parts.length < 3 || parts.length > 4) {_            throw new IllegalArgumentException(_                    "the version needs to contain major, minor, and revision, and optionally the build: " + version)__        }__        try {_            final int rawMajor = Integer.parseInt(parts[0])__            if (rawMajor >= 5 && snapshot) { _                throw new IllegalArgumentException("illegal version format - snapshots are only supported until version 2.x")__            }_            final int betaOffset = rawMajor < 5 ? 0 : 25__            _            final int major = rawMajor * 1000000__            final int minor = Integer.parseInt(parts[1]) * 10000__            final int revision = Integer.parseInt(parts[2]) * 100____            int build = 99__            if (parts.length == 4) {_                String buildStr = parts[3]__                if (buildStr.startsWith("alpha")) {_                    assert rawMajor >= 5 : "major must be >= 5 but was " + major__                    build = Integer.parseInt(buildStr.substring(5))__                    assert build < 25 : "expected a beta build but " + build + " >= 25"__                } else if (buildStr.startsWith("Beta") || buildStr.startsWith("beta")) {_                    build = betaOffset + Integer.parseInt(buildStr.substring(4))__                    assert build < 50 : "expected a beta build but " + build + " >= 50"__                } else if (buildStr.startsWith("RC") || buildStr.startsWith("rc")) {_                    build = Integer.parseInt(buildStr.substring(2)) + 50__                } else {_                    throw new IllegalArgumentException("unable to parse version " + version)__                }_            }__            return fromId(major + minor + revision + build)___        } catch (NumberFormatException e) {_            throw new IllegalArgumentException("unable to parse version " + version, e)__        }_    };returns,the,version,given,its,string,representation,current,version,if,the,argument,is,null,or,empty;public,static,version,from,string,string,version,if,strings,has,length,version,return,version,current,final,boolean,snapshot,if,snapshot,version,ends,with,snapshot,version,version,substring,0,version,length,9,string,parts,version,split,if,parts,length,3,parts,length,4,throw,new,illegal,argument,exception,the,version,needs,to,contain,major,minor,and,revision,and,optionally,the,build,version,try,final,int,raw,major,integer,parse,int,parts,0,if,raw,major,5,snapshot,throw,new,illegal,argument,exception,illegal,version,format,snapshots,are,only,supported,until,version,2,x,final,int,beta,offset,raw,major,5,0,25,final,int,major,raw,major,1000000,final,int,minor,integer,parse,int,parts,1,10000,final,int,revision,integer,parse,int,parts,2,100,int,build,99,if,parts,length,4,string,build,str,parts,3,if,build,str,starts,with,alpha,assert,raw,major,5,major,must,be,5,but,was,major,build,integer,parse,int,build,str,substring,5,assert,build,25,expected,a,beta,build,but,build,25,else,if,build,str,starts,with,beta,build,str,starts,with,beta,build,beta,offset,integer,parse,int,build,str,substring,4,assert,build,50,expected,a,beta,build,but,build,50,else,if,build,str,starts,with,rc,build,str,starts,with,rc,build,integer,parse,int,build,str,substring,2,50,else,throw,new,illegal,argument,exception,unable,to,parse,version,version,return,from,id,major,minor,revision,build,catch,number,format,exception,e,throw,new,illegal,argument,exception,unable,to,parse,version,version,e
Version -> public static Version fromString(String version);1532511554;Returns the version given its string representation, current version if the argument is null or empty;public static Version fromString(String version) {_        if (!Strings.hasLength(version)) {_            return Version.CURRENT__        }_        final boolean snapshot_ _        if (snapshot = version.endsWith("-SNAPSHOT")) {_            version = version.substring(0, version.length() - 9)__        }_        String[] parts = version.split("[.-]")__        if (parts.length < 3 || parts.length > 4) {_            throw new IllegalArgumentException(_                    "the version needs to contain major, minor, and revision, and optionally the build: " + version)__        }__        try {_            final int rawMajor = Integer.parseInt(parts[0])__            if (rawMajor >= 5 && snapshot) { _                throw new IllegalArgumentException("illegal version format - snapshots are only supported until version 2.x")__            }_            final int betaOffset = rawMajor < 5 ? 0 : 25__            _            final int major = rawMajor * 1000000__            final int minor = Integer.parseInt(parts[1]) * 10000__            final int revision = Integer.parseInt(parts[2]) * 100____            int build = 99__            if (parts.length == 4) {_                String buildStr = parts[3]__                if (buildStr.startsWith("alpha")) {_                    assert rawMajor >= 5 : "major must be >= 5 but was " + major__                    build = Integer.parseInt(buildStr.substring(5))__                    assert build < 25 : "expected a beta build but " + build + " >= 25"__                } else if (buildStr.startsWith("Beta") || buildStr.startsWith("beta")) {_                    build = betaOffset + Integer.parseInt(buildStr.substring(4))__                    assert build < 50 : "expected a beta build but " + build + " >= 50"__                } else if (buildStr.startsWith("RC") || buildStr.startsWith("rc")) {_                    build = Integer.parseInt(buildStr.substring(2)) + 50__                } else {_                    throw new IllegalArgumentException("unable to parse version " + version)__                }_            }__            return fromId(major + minor + revision + build)___        } catch (NumberFormatException e) {_            throw new IllegalArgumentException("unable to parse version " + version, e)__        }_    };returns,the,version,given,its,string,representation,current,version,if,the,argument,is,null,or,empty;public,static,version,from,string,string,version,if,strings,has,length,version,return,version,current,final,boolean,snapshot,if,snapshot,version,ends,with,snapshot,version,version,substring,0,version,length,9,string,parts,version,split,if,parts,length,3,parts,length,4,throw,new,illegal,argument,exception,the,version,needs,to,contain,major,minor,and,revision,and,optionally,the,build,version,try,final,int,raw,major,integer,parse,int,parts,0,if,raw,major,5,snapshot,throw,new,illegal,argument,exception,illegal,version,format,snapshots,are,only,supported,until,version,2,x,final,int,beta,offset,raw,major,5,0,25,final,int,major,raw,major,1000000,final,int,minor,integer,parse,int,parts,1,10000,final,int,revision,integer,parse,int,parts,2,100,int,build,99,if,parts,length,4,string,build,str,parts,3,if,build,str,starts,with,alpha,assert,raw,major,5,major,must,be,5,but,was,major,build,integer,parse,int,build,str,substring,5,assert,build,25,expected,a,beta,build,but,build,25,else,if,build,str,starts,with,beta,build,str,starts,with,beta,build,beta,offset,integer,parse,int,build,str,substring,4,assert,build,50,expected,a,beta,build,but,build,50,else,if,build,str,starts,with,rc,build,str,starts,with,rc,build,integer,parse,int,build,str,substring,2,50,else,throw,new,illegal,argument,exception,unable,to,parse,version,version,return,from,id,major,minor,revision,build,catch,number,format,exception,e,throw,new,illegal,argument,exception,unable,to,parse,version,version,e
Version -> public static Version fromString(String version);1532534495;Returns the version given its string representation, current version if the argument is null or empty;public static Version fromString(String version) {_        if (!Strings.hasLength(version)) {_            return Version.CURRENT__        }_        final boolean snapshot_ _        if (snapshot = version.endsWith("-SNAPSHOT")) {_            version = version.substring(0, version.length() - 9)__        }_        String[] parts = version.split("[.-]")__        if (parts.length < 3 || parts.length > 4) {_            throw new IllegalArgumentException(_                    "the version needs to contain major, minor, and revision, and optionally the build: " + version)__        }__        try {_            final int rawMajor = Integer.parseInt(parts[0])__            if (rawMajor >= 5 && snapshot) { _                throw new IllegalArgumentException("illegal version format - snapshots are only supported until version 2.x")__            }_            final int betaOffset = rawMajor < 5 ? 0 : 25__            _            final int major = rawMajor * 1000000__            final int minor = Integer.parseInt(parts[1]) * 10000__            final int revision = Integer.parseInt(parts[2]) * 100____            int build = 99__            if (parts.length == 4) {_                String buildStr = parts[3]__                if (buildStr.startsWith("alpha")) {_                    assert rawMajor >= 5 : "major must be >= 5 but was " + major__                    build = Integer.parseInt(buildStr.substring(5))__                    assert build < 25 : "expected a beta build but " + build + " >= 25"__                } else if (buildStr.startsWith("Beta") || buildStr.startsWith("beta")) {_                    build = betaOffset + Integer.parseInt(buildStr.substring(4))__                    assert build < 50 : "expected a beta build but " + build + " >= 50"__                } else if (buildStr.startsWith("RC") || buildStr.startsWith("rc")) {_                    build = Integer.parseInt(buildStr.substring(2)) + 50__                } else {_                    throw new IllegalArgumentException("unable to parse version " + version)__                }_            }__            return fromId(major + minor + revision + build)___        } catch (NumberFormatException e) {_            throw new IllegalArgumentException("unable to parse version " + version, e)__        }_    };returns,the,version,given,its,string,representation,current,version,if,the,argument,is,null,or,empty;public,static,version,from,string,string,version,if,strings,has,length,version,return,version,current,final,boolean,snapshot,if,snapshot,version,ends,with,snapshot,version,version,substring,0,version,length,9,string,parts,version,split,if,parts,length,3,parts,length,4,throw,new,illegal,argument,exception,the,version,needs,to,contain,major,minor,and,revision,and,optionally,the,build,version,try,final,int,raw,major,integer,parse,int,parts,0,if,raw,major,5,snapshot,throw,new,illegal,argument,exception,illegal,version,format,snapshots,are,only,supported,until,version,2,x,final,int,beta,offset,raw,major,5,0,25,final,int,major,raw,major,1000000,final,int,minor,integer,parse,int,parts,1,10000,final,int,revision,integer,parse,int,parts,2,100,int,build,99,if,parts,length,4,string,build,str,parts,3,if,build,str,starts,with,alpha,assert,raw,major,5,major,must,be,5,but,was,major,build,integer,parse,int,build,str,substring,5,assert,build,25,expected,a,beta,build,but,build,25,else,if,build,str,starts,with,beta,build,str,starts,with,beta,build,beta,offset,integer,parse,int,build,str,substring,4,assert,build,50,expected,a,beta,build,but,build,50,else,if,build,str,starts,with,rc,build,str,starts,with,rc,build,integer,parse,int,build,str,substring,2,50,else,throw,new,illegal,argument,exception,unable,to,parse,version,version,return,from,id,major,minor,revision,build,catch,number,format,exception,e,throw,new,illegal,argument,exception,unable,to,parse,version,version,e
Version -> public static Version fromString(String version);1532685069;Returns the version given its string representation, current version if the argument is null or empty;public static Version fromString(String version) {_        if (!Strings.hasLength(version)) {_            return Version.CURRENT__        }_        final boolean snapshot_ _        if (snapshot = version.endsWith("-SNAPSHOT")) {_            version = version.substring(0, version.length() - 9)__        }_        String[] parts = version.split("[.-]")__        if (parts.length < 3 || parts.length > 4) {_            throw new IllegalArgumentException(_                    "the version needs to contain major, minor, and revision, and optionally the build: " + version)__        }__        try {_            final int rawMajor = Integer.parseInt(parts[0])__            if (rawMajor >= 5 && snapshot) { _                throw new IllegalArgumentException("illegal version format - snapshots are only supported until version 2.x")__            }_            final int betaOffset = rawMajor < 5 ? 0 : 25__            _            final int major = rawMajor * 1000000__            final int minor = Integer.parseInt(parts[1]) * 10000__            final int revision = Integer.parseInt(parts[2]) * 100____            int build = 99__            if (parts.length == 4) {_                String buildStr = parts[3]__                if (buildStr.startsWith("alpha")) {_                    assert rawMajor >= 5 : "major must be >= 5 but was " + major__                    build = Integer.parseInt(buildStr.substring(5))__                    assert build < 25 : "expected a beta build but " + build + " >= 25"__                } else if (buildStr.startsWith("Beta") || buildStr.startsWith("beta")) {_                    build = betaOffset + Integer.parseInt(buildStr.substring(4))__                    assert build < 50 : "expected a beta build but " + build + " >= 50"__                } else if (buildStr.startsWith("RC") || buildStr.startsWith("rc")) {_                    build = Integer.parseInt(buildStr.substring(2)) + 50__                } else {_                    throw new IllegalArgumentException("unable to parse version " + version)__                }_            }__            return fromId(major + minor + revision + build)___        } catch (NumberFormatException e) {_            throw new IllegalArgumentException("unable to parse version " + version, e)__        }_    };returns,the,version,given,its,string,representation,current,version,if,the,argument,is,null,or,empty;public,static,version,from,string,string,version,if,strings,has,length,version,return,version,current,final,boolean,snapshot,if,snapshot,version,ends,with,snapshot,version,version,substring,0,version,length,9,string,parts,version,split,if,parts,length,3,parts,length,4,throw,new,illegal,argument,exception,the,version,needs,to,contain,major,minor,and,revision,and,optionally,the,build,version,try,final,int,raw,major,integer,parse,int,parts,0,if,raw,major,5,snapshot,throw,new,illegal,argument,exception,illegal,version,format,snapshots,are,only,supported,until,version,2,x,final,int,beta,offset,raw,major,5,0,25,final,int,major,raw,major,1000000,final,int,minor,integer,parse,int,parts,1,10000,final,int,revision,integer,parse,int,parts,2,100,int,build,99,if,parts,length,4,string,build,str,parts,3,if,build,str,starts,with,alpha,assert,raw,major,5,major,must,be,5,but,was,major,build,integer,parse,int,build,str,substring,5,assert,build,25,expected,a,beta,build,but,build,25,else,if,build,str,starts,with,beta,build,str,starts,with,beta,build,beta,offset,integer,parse,int,build,str,substring,4,assert,build,50,expected,a,beta,build,but,build,50,else,if,build,str,starts,with,rc,build,str,starts,with,rc,build,integer,parse,int,build,str,substring,2,50,else,throw,new,illegal,argument,exception,unable,to,parse,version,version,return,from,id,major,minor,revision,build,catch,number,format,exception,e,throw,new,illegal,argument,exception,unable,to,parse,version,version,e
Version -> public static Version fromString(String version);1535057785;Returns the version given its string representation, current version if the argument is null or empty;public static Version fromString(String version) {_        if (!Strings.hasLength(version)) {_            return Version.CURRENT__        }_        final boolean snapshot_ _        if (snapshot = version.endsWith("-SNAPSHOT")) {_            version = version.substring(0, version.length() - 9)__        }_        String[] parts = version.split("[.-]")__        if (parts.length < 3 || parts.length > 4) {_            throw new IllegalArgumentException(_                    "the version needs to contain major, minor, and revision, and optionally the build: " + version)__        }__        try {_            final int rawMajor = Integer.parseInt(parts[0])__            if (rawMajor >= 5 && snapshot) { _                throw new IllegalArgumentException("illegal version format - snapshots are only supported until version 2.x")__            }_            final int betaOffset = rawMajor < 5 ? 0 : 25__            _            final int major = rawMajor * 1000000__            final int minor = Integer.parseInt(parts[1]) * 10000__            final int revision = Integer.parseInt(parts[2]) * 100____            int build = 99__            if (parts.length == 4) {_                String buildStr = parts[3]__                if (buildStr.startsWith("alpha")) {_                    assert rawMajor >= 5 : "major must be >= 5 but was " + major__                    build = Integer.parseInt(buildStr.substring(5))__                    assert build < 25 : "expected a beta build but " + build + " >= 25"__                } else if (buildStr.startsWith("Beta") || buildStr.startsWith("beta")) {_                    build = betaOffset + Integer.parseInt(buildStr.substring(4))__                    assert build < 50 : "expected a beta build but " + build + " >= 50"__                } else if (buildStr.startsWith("RC") || buildStr.startsWith("rc")) {_                    build = Integer.parseInt(buildStr.substring(2)) + 50__                } else {_                    throw new IllegalArgumentException("unable to parse version " + version)__                }_            }__            return fromId(major + minor + revision + build)___        } catch (NumberFormatException e) {_            throw new IllegalArgumentException("unable to parse version " + version, e)__        }_    };returns,the,version,given,its,string,representation,current,version,if,the,argument,is,null,or,empty;public,static,version,from,string,string,version,if,strings,has,length,version,return,version,current,final,boolean,snapshot,if,snapshot,version,ends,with,snapshot,version,version,substring,0,version,length,9,string,parts,version,split,if,parts,length,3,parts,length,4,throw,new,illegal,argument,exception,the,version,needs,to,contain,major,minor,and,revision,and,optionally,the,build,version,try,final,int,raw,major,integer,parse,int,parts,0,if,raw,major,5,snapshot,throw,new,illegal,argument,exception,illegal,version,format,snapshots,are,only,supported,until,version,2,x,final,int,beta,offset,raw,major,5,0,25,final,int,major,raw,major,1000000,final,int,minor,integer,parse,int,parts,1,10000,final,int,revision,integer,parse,int,parts,2,100,int,build,99,if,parts,length,4,string,build,str,parts,3,if,build,str,starts,with,alpha,assert,raw,major,5,major,must,be,5,but,was,major,build,integer,parse,int,build,str,substring,5,assert,build,25,expected,a,beta,build,but,build,25,else,if,build,str,starts,with,beta,build,str,starts,with,beta,build,beta,offset,integer,parse,int,build,str,substring,4,assert,build,50,expected,a,beta,build,but,build,50,else,if,build,str,starts,with,rc,build,str,starts,with,rc,build,integer,parse,int,build,str,substring,2,50,else,throw,new,illegal,argument,exception,unable,to,parse,version,version,return,from,id,major,minor,revision,build,catch,number,format,exception,e,throw,new,illegal,argument,exception,unable,to,parse,version,version,e
Version -> public static Version fromString(String version);1535139672;Returns the version given its string representation, current version if the argument is null or empty;public static Version fromString(String version) {_        if (!Strings.hasLength(version)) {_            return Version.CURRENT__        }_        final boolean snapshot_ _        if (snapshot = version.endsWith("-SNAPSHOT")) {_            version = version.substring(0, version.length() - 9)__        }_        String[] parts = version.split("[.-]")__        if (parts.length < 3 || parts.length > 4) {_            throw new IllegalArgumentException(_                    "the version needs to contain major, minor, and revision, and optionally the build: " + version)__        }__        try {_            final int rawMajor = Integer.parseInt(parts[0])__            if (rawMajor >= 5 && snapshot) { _                throw new IllegalArgumentException("illegal version format - snapshots are only supported until version 2.x")__            }_            final int betaOffset = rawMajor < 5 ? 0 : 25__            _            final int major = rawMajor * 1000000__            final int minor = Integer.parseInt(parts[1]) * 10000__            final int revision = Integer.parseInt(parts[2]) * 100____            int build = 99__            if (parts.length == 4) {_                String buildStr = parts[3]__                if (buildStr.startsWith("alpha")) {_                    assert rawMajor >= 5 : "major must be >= 5 but was " + major__                    build = Integer.parseInt(buildStr.substring(5))__                    assert build < 25 : "expected a beta build but " + build + " >= 25"__                } else if (buildStr.startsWith("Beta") || buildStr.startsWith("beta")) {_                    build = betaOffset + Integer.parseInt(buildStr.substring(4))__                    assert build < 50 : "expected a beta build but " + build + " >= 50"__                } else if (buildStr.startsWith("RC") || buildStr.startsWith("rc")) {_                    build = Integer.parseInt(buildStr.substring(2)) + 50__                } else {_                    throw new IllegalArgumentException("unable to parse version " + version)__                }_            }__            return fromId(major + minor + revision + build)___        } catch (NumberFormatException e) {_            throw new IllegalArgumentException("unable to parse version " + version, e)__        }_    };returns,the,version,given,its,string,representation,current,version,if,the,argument,is,null,or,empty;public,static,version,from,string,string,version,if,strings,has,length,version,return,version,current,final,boolean,snapshot,if,snapshot,version,ends,with,snapshot,version,version,substring,0,version,length,9,string,parts,version,split,if,parts,length,3,parts,length,4,throw,new,illegal,argument,exception,the,version,needs,to,contain,major,minor,and,revision,and,optionally,the,build,version,try,final,int,raw,major,integer,parse,int,parts,0,if,raw,major,5,snapshot,throw,new,illegal,argument,exception,illegal,version,format,snapshots,are,only,supported,until,version,2,x,final,int,beta,offset,raw,major,5,0,25,final,int,major,raw,major,1000000,final,int,minor,integer,parse,int,parts,1,10000,final,int,revision,integer,parse,int,parts,2,100,int,build,99,if,parts,length,4,string,build,str,parts,3,if,build,str,starts,with,alpha,assert,raw,major,5,major,must,be,5,but,was,major,build,integer,parse,int,build,str,substring,5,assert,build,25,expected,a,beta,build,but,build,25,else,if,build,str,starts,with,beta,build,str,starts,with,beta,build,beta,offset,integer,parse,int,build,str,substring,4,assert,build,50,expected,a,beta,build,but,build,50,else,if,build,str,starts,with,rc,build,str,starts,with,rc,build,integer,parse,int,build,str,substring,2,50,else,throw,new,illegal,argument,exception,unable,to,parse,version,version,return,from,id,major,minor,revision,build,catch,number,format,exception,e,throw,new,illegal,argument,exception,unable,to,parse,version,version,e
Version -> public static Version fromString(String version);1536137328;Returns the version given its string representation, current version if the argument is null or empty;public static Version fromString(String version) {_        if (!Strings.hasLength(version)) {_            return Version.CURRENT__        }_        final boolean snapshot_ _        if (snapshot = version.endsWith("-SNAPSHOT")) {_            version = version.substring(0, version.length() - 9)__        }_        String[] parts = version.split("[.-]")__        if (parts.length < 3 || parts.length > 4) {_            throw new IllegalArgumentException(_                    "the version needs to contain major, minor, and revision, and optionally the build: " + version)__        }__        try {_            final int rawMajor = Integer.parseInt(parts[0])__            if (rawMajor >= 5 && snapshot) { _                throw new IllegalArgumentException("illegal version format - snapshots are only supported until version 2.x")__            }_            final int betaOffset = rawMajor < 5 ? 0 : 25__            _            final int major = rawMajor * 1000000__            final int minor = Integer.parseInt(parts[1]) * 10000__            final int revision = Integer.parseInt(parts[2]) * 100____            int build = 99__            if (parts.length == 4) {_                String buildStr = parts[3]__                if (buildStr.startsWith("alpha")) {_                    assert rawMajor >= 5 : "major must be >= 5 but was " + major__                    build = Integer.parseInt(buildStr.substring(5))__                    assert build < 25 : "expected a beta build but " + build + " >= 25"__                } else if (buildStr.startsWith("Beta") || buildStr.startsWith("beta")) {_                    build = betaOffset + Integer.parseInt(buildStr.substring(4))__                    assert build < 50 : "expected a beta build but " + build + " >= 50"__                } else if (buildStr.startsWith("RC") || buildStr.startsWith("rc")) {_                    build = Integer.parseInt(buildStr.substring(2)) + 50__                } else {_                    throw new IllegalArgumentException("unable to parse version " + version)__                }_            }__            return fromId(major + minor + revision + build)___        } catch (NumberFormatException e) {_            throw new IllegalArgumentException("unable to parse version " + version, e)__        }_    };returns,the,version,given,its,string,representation,current,version,if,the,argument,is,null,or,empty;public,static,version,from,string,string,version,if,strings,has,length,version,return,version,current,final,boolean,snapshot,if,snapshot,version,ends,with,snapshot,version,version,substring,0,version,length,9,string,parts,version,split,if,parts,length,3,parts,length,4,throw,new,illegal,argument,exception,the,version,needs,to,contain,major,minor,and,revision,and,optionally,the,build,version,try,final,int,raw,major,integer,parse,int,parts,0,if,raw,major,5,snapshot,throw,new,illegal,argument,exception,illegal,version,format,snapshots,are,only,supported,until,version,2,x,final,int,beta,offset,raw,major,5,0,25,final,int,major,raw,major,1000000,final,int,minor,integer,parse,int,parts,1,10000,final,int,revision,integer,parse,int,parts,2,100,int,build,99,if,parts,length,4,string,build,str,parts,3,if,build,str,starts,with,alpha,assert,raw,major,5,major,must,be,5,but,was,major,build,integer,parse,int,build,str,substring,5,assert,build,25,expected,a,beta,build,but,build,25,else,if,build,str,starts,with,beta,build,str,starts,with,beta,build,beta,offset,integer,parse,int,build,str,substring,4,assert,build,50,expected,a,beta,build,but,build,50,else,if,build,str,starts,with,rc,build,str,starts,with,rc,build,integer,parse,int,build,str,substring,2,50,else,throw,new,illegal,argument,exception,unable,to,parse,version,version,return,from,id,major,minor,revision,build,catch,number,format,exception,e,throw,new,illegal,argument,exception,unable,to,parse,version,version,e
Version -> public static Version fromString(String version);1536314350;Returns the version given its string representation, current version if the argument is null or empty;public static Version fromString(String version) {_        if (!Strings.hasLength(version)) {_            return Version.CURRENT__        }_        final boolean snapshot_ _        if (snapshot = version.endsWith("-SNAPSHOT")) {_            version = version.substring(0, version.length() - 9)__        }_        String[] parts = version.split("[.-]")__        if (parts.length < 3 || parts.length > 4) {_            throw new IllegalArgumentException(_                    "the version needs to contain major, minor, and revision, and optionally the build: " + version)__        }__        try {_            final int rawMajor = Integer.parseInt(parts[0])__            if (rawMajor >= 5 && snapshot) { _                throw new IllegalArgumentException("illegal version format - snapshots are only supported until version 2.x")__            }_            final int betaOffset = rawMajor < 5 ? 0 : 25__            _            final int major = rawMajor * 1000000__            final int minor = Integer.parseInt(parts[1]) * 10000__            final int revision = Integer.parseInt(parts[2]) * 100____            int build = 99__            if (parts.length == 4) {_                String buildStr = parts[3]__                if (buildStr.startsWith("alpha")) {_                    assert rawMajor >= 5 : "major must be >= 5 but was " + major__                    build = Integer.parseInt(buildStr.substring(5))__                    assert build < 25 : "expected a beta build but " + build + " >= 25"__                } else if (buildStr.startsWith("Beta") || buildStr.startsWith("beta")) {_                    build = betaOffset + Integer.parseInt(buildStr.substring(4))__                    assert build < 50 : "expected a beta build but " + build + " >= 50"__                } else if (buildStr.startsWith("RC") || buildStr.startsWith("rc")) {_                    build = Integer.parseInt(buildStr.substring(2)) + 50__                } else {_                    throw new IllegalArgumentException("unable to parse version " + version)__                }_            }__            return fromId(major + minor + revision + build)___        } catch (NumberFormatException e) {_            throw new IllegalArgumentException("unable to parse version " + version, e)__        }_    };returns,the,version,given,its,string,representation,current,version,if,the,argument,is,null,or,empty;public,static,version,from,string,string,version,if,strings,has,length,version,return,version,current,final,boolean,snapshot,if,snapshot,version,ends,with,snapshot,version,version,substring,0,version,length,9,string,parts,version,split,if,parts,length,3,parts,length,4,throw,new,illegal,argument,exception,the,version,needs,to,contain,major,minor,and,revision,and,optionally,the,build,version,try,final,int,raw,major,integer,parse,int,parts,0,if,raw,major,5,snapshot,throw,new,illegal,argument,exception,illegal,version,format,snapshots,are,only,supported,until,version,2,x,final,int,beta,offset,raw,major,5,0,25,final,int,major,raw,major,1000000,final,int,minor,integer,parse,int,parts,1,10000,final,int,revision,integer,parse,int,parts,2,100,int,build,99,if,parts,length,4,string,build,str,parts,3,if,build,str,starts,with,alpha,assert,raw,major,5,major,must,be,5,but,was,major,build,integer,parse,int,build,str,substring,5,assert,build,25,expected,a,beta,build,but,build,25,else,if,build,str,starts,with,beta,build,str,starts,with,beta,build,beta,offset,integer,parse,int,build,str,substring,4,assert,build,50,expected,a,beta,build,but,build,50,else,if,build,str,starts,with,rc,build,str,starts,with,rc,build,integer,parse,int,build,str,substring,2,50,else,throw,new,illegal,argument,exception,unable,to,parse,version,version,return,from,id,major,minor,revision,build,catch,number,format,exception,e,throw,new,illegal,argument,exception,unable,to,parse,version,version,e
Version -> public static Version fromString(String version);1537300661;Returns the version given its string representation, current version if the argument is null or empty;public static Version fromString(String version) {_        if (!Strings.hasLength(version)) {_            return Version.CURRENT__        }_        final boolean snapshot_ _        if (snapshot = version.endsWith("-SNAPSHOT")) {_            version = version.substring(0, version.length() - 9)__        }_        String[] parts = version.split("[.-]")__        if (parts.length < 3 || parts.length > 4) {_            throw new IllegalArgumentException(_                    "the version needs to contain major, minor, and revision, and optionally the build: " + version)__        }__        try {_            final int rawMajor = Integer.parseInt(parts[0])__            if (rawMajor >= 5 && snapshot) { _                throw new IllegalArgumentException("illegal version format - snapshots are only supported until version 2.x")__            }_            final int betaOffset = rawMajor < 5 ? 0 : 25__            _            final int major = rawMajor * 1000000__            final int minor = Integer.parseInt(parts[1]) * 10000__            final int revision = Integer.parseInt(parts[2]) * 100____            int build = 99__            if (parts.length == 4) {_                String buildStr = parts[3]__                if (buildStr.startsWith("alpha")) {_                    assert rawMajor >= 5 : "major must be >= 5 but was " + major__                    build = Integer.parseInt(buildStr.substring(5))__                    assert build < 25 : "expected a beta build but " + build + " >= 25"__                } else if (buildStr.startsWith("Beta") || buildStr.startsWith("beta")) {_                    build = betaOffset + Integer.parseInt(buildStr.substring(4))__                    assert build < 50 : "expected a beta build but " + build + " >= 50"__                } else if (buildStr.startsWith("RC") || buildStr.startsWith("rc")) {_                    build = Integer.parseInt(buildStr.substring(2)) + 50__                } else {_                    throw new IllegalArgumentException("unable to parse version " + version)__                }_            }__            return fromId(major + minor + revision + build)___        } catch (NumberFormatException e) {_            throw new IllegalArgumentException("unable to parse version " + version, e)__        }_    };returns,the,version,given,its,string,representation,current,version,if,the,argument,is,null,or,empty;public,static,version,from,string,string,version,if,strings,has,length,version,return,version,current,final,boolean,snapshot,if,snapshot,version,ends,with,snapshot,version,version,substring,0,version,length,9,string,parts,version,split,if,parts,length,3,parts,length,4,throw,new,illegal,argument,exception,the,version,needs,to,contain,major,minor,and,revision,and,optionally,the,build,version,try,final,int,raw,major,integer,parse,int,parts,0,if,raw,major,5,snapshot,throw,new,illegal,argument,exception,illegal,version,format,snapshots,are,only,supported,until,version,2,x,final,int,beta,offset,raw,major,5,0,25,final,int,major,raw,major,1000000,final,int,minor,integer,parse,int,parts,1,10000,final,int,revision,integer,parse,int,parts,2,100,int,build,99,if,parts,length,4,string,build,str,parts,3,if,build,str,starts,with,alpha,assert,raw,major,5,major,must,be,5,but,was,major,build,integer,parse,int,build,str,substring,5,assert,build,25,expected,a,beta,build,but,build,25,else,if,build,str,starts,with,beta,build,str,starts,with,beta,build,beta,offset,integer,parse,int,build,str,substring,4,assert,build,50,expected,a,beta,build,but,build,50,else,if,build,str,starts,with,rc,build,str,starts,with,rc,build,integer,parse,int,build,str,substring,2,50,else,throw,new,illegal,argument,exception,unable,to,parse,version,version,return,from,id,major,minor,revision,build,catch,number,format,exception,e,throw,new,illegal,argument,exception,unable,to,parse,version,version,e
Version -> public static Version fromString(String version);1538509426;Returns the version given its string representation, current version if the argument is null or empty;public static Version fromString(String version) {_        if (!Strings.hasLength(version)) {_            return Version.CURRENT__        }_        final boolean snapshot_ _        if (snapshot = version.endsWith("-SNAPSHOT")) {_            version = version.substring(0, version.length() - 9)__        }_        String[] parts = version.split("[.-]")__        if (parts.length < 3 || parts.length > 4) {_            throw new IllegalArgumentException(_                    "the version needs to contain major, minor, and revision, and optionally the build: " + version)__        }__        try {_            final int rawMajor = Integer.parseInt(parts[0])__            if (rawMajor >= 5 && snapshot) { _                throw new IllegalArgumentException("illegal version format - snapshots are only supported until version 2.x")__            }_            final int betaOffset = rawMajor < 5 ? 0 : 25__            _            final int major = rawMajor * 1000000__            final int minor = Integer.parseInt(parts[1]) * 10000__            final int revision = Integer.parseInt(parts[2]) * 100____            int build = 99__            if (parts.length == 4) {_                String buildStr = parts[3]__                if (buildStr.startsWith("alpha")) {_                    assert rawMajor >= 5 : "major must be >= 5 but was " + major__                    build = Integer.parseInt(buildStr.substring(5))__                    assert build < 25 : "expected a beta build but " + build + " >= 25"__                } else if (buildStr.startsWith("Beta") || buildStr.startsWith("beta")) {_                    build = betaOffset + Integer.parseInt(buildStr.substring(4))__                    assert build < 50 : "expected a beta build but " + build + " >= 50"__                } else if (buildStr.startsWith("RC") || buildStr.startsWith("rc")) {_                    build = Integer.parseInt(buildStr.substring(2)) + 50__                } else {_                    throw new IllegalArgumentException("unable to parse version " + version)__                }_            }__            return fromId(major + minor + revision + build)___        } catch (NumberFormatException e) {_            throw new IllegalArgumentException("unable to parse version " + version, e)__        }_    };returns,the,version,given,its,string,representation,current,version,if,the,argument,is,null,or,empty;public,static,version,from,string,string,version,if,strings,has,length,version,return,version,current,final,boolean,snapshot,if,snapshot,version,ends,with,snapshot,version,version,substring,0,version,length,9,string,parts,version,split,if,parts,length,3,parts,length,4,throw,new,illegal,argument,exception,the,version,needs,to,contain,major,minor,and,revision,and,optionally,the,build,version,try,final,int,raw,major,integer,parse,int,parts,0,if,raw,major,5,snapshot,throw,new,illegal,argument,exception,illegal,version,format,snapshots,are,only,supported,until,version,2,x,final,int,beta,offset,raw,major,5,0,25,final,int,major,raw,major,1000000,final,int,minor,integer,parse,int,parts,1,10000,final,int,revision,integer,parse,int,parts,2,100,int,build,99,if,parts,length,4,string,build,str,parts,3,if,build,str,starts,with,alpha,assert,raw,major,5,major,must,be,5,but,was,major,build,integer,parse,int,build,str,substring,5,assert,build,25,expected,a,beta,build,but,build,25,else,if,build,str,starts,with,beta,build,str,starts,with,beta,build,beta,offset,integer,parse,int,build,str,substring,4,assert,build,50,expected,a,beta,build,but,build,50,else,if,build,str,starts,with,rc,build,str,starts,with,rc,build,integer,parse,int,build,str,substring,2,50,else,throw,new,illegal,argument,exception,unable,to,parse,version,version,return,from,id,major,minor,revision,build,catch,number,format,exception,e,throw,new,illegal,argument,exception,unable,to,parse,version,version,e
Version -> public static Version fromString(String version);1540486836;Returns the version given its string representation, current version if the argument is null or empty;public static Version fromString(String version) {_        if (!Strings.hasLength(version)) {_            return Version.CURRENT__        }_        final boolean snapshot_ _        if (snapshot = version.endsWith("-SNAPSHOT")) {_            version = version.substring(0, version.length() - 9)__        }_        String[] parts = version.split("[.-]")__        if (parts.length < 3 || parts.length > 4) {_            throw new IllegalArgumentException(_                    "the version needs to contain major, minor, and revision, and optionally the build: " + version)__        }__        try {_            final int rawMajor = Integer.parseInt(parts[0])__            if (rawMajor >= 5 && snapshot) { _                throw new IllegalArgumentException("illegal version format - snapshots are only supported until version 2.x")__            }_            final int betaOffset = rawMajor < 5 ? 0 : 25__            _            final int major = rawMajor * 1000000__            final int minor = Integer.parseInt(parts[1]) * 10000__            final int revision = Integer.parseInt(parts[2]) * 100____            int build = 99__            if (parts.length == 4) {_                String buildStr = parts[3]__                if (buildStr.startsWith("alpha")) {_                    assert rawMajor >= 5 : "major must be >= 5 but was " + major__                    build = Integer.parseInt(buildStr.substring(5))__                    assert build < 25 : "expected a beta build but " + build + " >= 25"__                } else if (buildStr.startsWith("Beta") || buildStr.startsWith("beta")) {_                    build = betaOffset + Integer.parseInt(buildStr.substring(4))__                    assert build < 50 : "expected a beta build but " + build + " >= 50"__                } else if (buildStr.startsWith("RC") || buildStr.startsWith("rc")) {_                    build = Integer.parseInt(buildStr.substring(2)) + 50__                } else {_                    throw new IllegalArgumentException("unable to parse version " + version)__                }_            }__            return fromId(major + minor + revision + build)___        } catch (NumberFormatException e) {_            throw new IllegalArgumentException("unable to parse version " + version, e)__        }_    };returns,the,version,given,its,string,representation,current,version,if,the,argument,is,null,or,empty;public,static,version,from,string,string,version,if,strings,has,length,version,return,version,current,final,boolean,snapshot,if,snapshot,version,ends,with,snapshot,version,version,substring,0,version,length,9,string,parts,version,split,if,parts,length,3,parts,length,4,throw,new,illegal,argument,exception,the,version,needs,to,contain,major,minor,and,revision,and,optionally,the,build,version,try,final,int,raw,major,integer,parse,int,parts,0,if,raw,major,5,snapshot,throw,new,illegal,argument,exception,illegal,version,format,snapshots,are,only,supported,until,version,2,x,final,int,beta,offset,raw,major,5,0,25,final,int,major,raw,major,1000000,final,int,minor,integer,parse,int,parts,1,10000,final,int,revision,integer,parse,int,parts,2,100,int,build,99,if,parts,length,4,string,build,str,parts,3,if,build,str,starts,with,alpha,assert,raw,major,5,major,must,be,5,but,was,major,build,integer,parse,int,build,str,substring,5,assert,build,25,expected,a,beta,build,but,build,25,else,if,build,str,starts,with,beta,build,str,starts,with,beta,build,beta,offset,integer,parse,int,build,str,substring,4,assert,build,50,expected,a,beta,build,but,build,50,else,if,build,str,starts,with,rc,build,str,starts,with,rc,build,integer,parse,int,build,str,substring,2,50,else,throw,new,illegal,argument,exception,unable,to,parse,version,version,return,from,id,major,minor,revision,build,catch,number,format,exception,e,throw,new,illegal,argument,exception,unable,to,parse,version,version,e
Version -> public static Version fromString(String version);1541502933;Returns the version given its string representation, current version if the argument is null or empty;public static Version fromString(String version) {_        if (!Strings.hasLength(version)) {_            return Version.CURRENT__        }_        final boolean snapshot_ _        if (snapshot = version.endsWith("-SNAPSHOT")) {_            version = version.substring(0, version.length() - 9)__        }_        String[] parts = version.split("[.-]")__        if (parts.length < 3 || parts.length > 4) {_            throw new IllegalArgumentException(_                    "the version needs to contain major, minor, and revision, and optionally the build: " + version)__        }__        try {_            final int rawMajor = Integer.parseInt(parts[0])__            if (rawMajor >= 5 && snapshot) { _                throw new IllegalArgumentException("illegal version format - snapshots are only supported until version 2.x")__            }_            final int betaOffset = rawMajor < 5 ? 0 : 25__            _            final int major = rawMajor * 1000000__            final int minor = Integer.parseInt(parts[1]) * 10000__            final int revision = Integer.parseInt(parts[2]) * 100____            int build = 99__            if (parts.length == 4) {_                String buildStr = parts[3]__                if (buildStr.startsWith("alpha")) {_                    assert rawMajor >= 5 : "major must be >= 5 but was " + major__                    build = Integer.parseInt(buildStr.substring(5))__                    assert build < 25 : "expected a beta build but " + build + " >= 25"__                } else if (buildStr.startsWith("Beta") || buildStr.startsWith("beta")) {_                    build = betaOffset + Integer.parseInt(buildStr.substring(4))__                    assert build < 50 : "expected a beta build but " + build + " >= 50"__                } else if (buildStr.startsWith("RC") || buildStr.startsWith("rc")) {_                    build = Integer.parseInt(buildStr.substring(2)) + 50__                } else {_                    throw new IllegalArgumentException("unable to parse version " + version)__                }_            }__            return fromId(major + minor + revision + build)___        } catch (NumberFormatException e) {_            throw new IllegalArgumentException("unable to parse version " + version, e)__        }_    };returns,the,version,given,its,string,representation,current,version,if,the,argument,is,null,or,empty;public,static,version,from,string,string,version,if,strings,has,length,version,return,version,current,final,boolean,snapshot,if,snapshot,version,ends,with,snapshot,version,version,substring,0,version,length,9,string,parts,version,split,if,parts,length,3,parts,length,4,throw,new,illegal,argument,exception,the,version,needs,to,contain,major,minor,and,revision,and,optionally,the,build,version,try,final,int,raw,major,integer,parse,int,parts,0,if,raw,major,5,snapshot,throw,new,illegal,argument,exception,illegal,version,format,snapshots,are,only,supported,until,version,2,x,final,int,beta,offset,raw,major,5,0,25,final,int,major,raw,major,1000000,final,int,minor,integer,parse,int,parts,1,10000,final,int,revision,integer,parse,int,parts,2,100,int,build,99,if,parts,length,4,string,build,str,parts,3,if,build,str,starts,with,alpha,assert,raw,major,5,major,must,be,5,but,was,major,build,integer,parse,int,build,str,substring,5,assert,build,25,expected,a,beta,build,but,build,25,else,if,build,str,starts,with,beta,build,str,starts,with,beta,build,beta,offset,integer,parse,int,build,str,substring,4,assert,build,50,expected,a,beta,build,but,build,50,else,if,build,str,starts,with,rc,build,str,starts,with,rc,build,integer,parse,int,build,str,substring,2,50,else,throw,new,illegal,argument,exception,unable,to,parse,version,version,return,from,id,major,minor,revision,build,catch,number,format,exception,e,throw,new,illegal,argument,exception,unable,to,parse,version,version,e
Version -> public static Version fromString(String version);1541528420;Returns the version given its string representation, current version if the argument is null or empty;public static Version fromString(String version) {_        if (!Strings.hasLength(version)) {_            return Version.CURRENT__        }_        final boolean snapshot_ _        if (snapshot = version.endsWith("-SNAPSHOT")) {_            version = version.substring(0, version.length() - 9)__        }_        String[] parts = version.split("[.-]")__        if (parts.length < 3 || parts.length > 4) {_            throw new IllegalArgumentException(_                    "the version needs to contain major, minor, and revision, and optionally the build: " + version)__        }__        try {_            final int rawMajor = Integer.parseInt(parts[0])__            if (rawMajor >= 5 && snapshot) { _                throw new IllegalArgumentException("illegal version format - snapshots are only supported until version 2.x")__            }_            final int betaOffset = rawMajor < 5 ? 0 : 25__            _            final int major = rawMajor * 1000000__            final int minor = Integer.parseInt(parts[1]) * 10000__            final int revision = Integer.parseInt(parts[2]) * 100____            int build = 99__            if (parts.length == 4) {_                String buildStr = parts[3]__                if (buildStr.startsWith("alpha")) {_                    assert rawMajor >= 5 : "major must be >= 5 but was " + major__                    build = Integer.parseInt(buildStr.substring(5))__                    assert build < 25 : "expected a beta build but " + build + " >= 25"__                } else if (buildStr.startsWith("Beta") || buildStr.startsWith("beta")) {_                    build = betaOffset + Integer.parseInt(buildStr.substring(4))__                    assert build < 50 : "expected a beta build but " + build + " >= 50"__                } else if (buildStr.startsWith("RC") || buildStr.startsWith("rc")) {_                    build = Integer.parseInt(buildStr.substring(2)) + 50__                } else {_                    throw new IllegalArgumentException("unable to parse version " + version)__                }_            }__            return fromId(major + minor + revision + build)___        } catch (NumberFormatException e) {_            throw new IllegalArgumentException("unable to parse version " + version, e)__        }_    };returns,the,version,given,its,string,representation,current,version,if,the,argument,is,null,or,empty;public,static,version,from,string,string,version,if,strings,has,length,version,return,version,current,final,boolean,snapshot,if,snapshot,version,ends,with,snapshot,version,version,substring,0,version,length,9,string,parts,version,split,if,parts,length,3,parts,length,4,throw,new,illegal,argument,exception,the,version,needs,to,contain,major,minor,and,revision,and,optionally,the,build,version,try,final,int,raw,major,integer,parse,int,parts,0,if,raw,major,5,snapshot,throw,new,illegal,argument,exception,illegal,version,format,snapshots,are,only,supported,until,version,2,x,final,int,beta,offset,raw,major,5,0,25,final,int,major,raw,major,1000000,final,int,minor,integer,parse,int,parts,1,10000,final,int,revision,integer,parse,int,parts,2,100,int,build,99,if,parts,length,4,string,build,str,parts,3,if,build,str,starts,with,alpha,assert,raw,major,5,major,must,be,5,but,was,major,build,integer,parse,int,build,str,substring,5,assert,build,25,expected,a,beta,build,but,build,25,else,if,build,str,starts,with,beta,build,str,starts,with,beta,build,beta,offset,integer,parse,int,build,str,substring,4,assert,build,50,expected,a,beta,build,but,build,50,else,if,build,str,starts,with,rc,build,str,starts,with,rc,build,integer,parse,int,build,str,substring,2,50,else,throw,new,illegal,argument,exception,unable,to,parse,version,version,return,from,id,major,minor,revision,build,catch,number,format,exception,e,throw,new,illegal,argument,exception,unable,to,parse,version,version,e
Version -> public static Version fromString(String version);1541592065;Returns the version given its string representation, current version if the argument is null or empty;public static Version fromString(String version) {_        if (!Strings.hasLength(version)) {_            return Version.CURRENT__        }_        final boolean snapshot_ _        if (snapshot = version.endsWith("-SNAPSHOT")) {_            version = version.substring(0, version.length() - 9)__        }_        String[] parts = version.split("[.-]")__        if (parts.length < 3 || parts.length > 4) {_            throw new IllegalArgumentException(_                    "the version needs to contain major, minor, and revision, and optionally the build: " + version)__        }__        try {_            final int rawMajor = Integer.parseInt(parts[0])__            if (rawMajor >= 5 && snapshot) { _                throw new IllegalArgumentException("illegal version format - snapshots are only supported until version 2.x")__            }_            final int betaOffset = rawMajor < 5 ? 0 : 25__            _            final int major = rawMajor * 1000000__            final int minor = Integer.parseInt(parts[1]) * 10000__            final int revision = Integer.parseInt(parts[2]) * 100____            int build = 99__            if (parts.length == 4) {_                String buildStr = parts[3]__                if (buildStr.startsWith("alpha")) {_                    assert rawMajor >= 5 : "major must be >= 5 but was " + major__                    build = Integer.parseInt(buildStr.substring(5))__                    assert build < 25 : "expected a beta build but " + build + " >= 25"__                } else if (buildStr.startsWith("Beta") || buildStr.startsWith("beta")) {_                    build = betaOffset + Integer.parseInt(buildStr.substring(4))__                    assert build < 50 : "expected a beta build but " + build + " >= 50"__                } else if (buildStr.startsWith("RC") || buildStr.startsWith("rc")) {_                    build = Integer.parseInt(buildStr.substring(2)) + 50__                } else {_                    throw new IllegalArgumentException("unable to parse version " + version)__                }_            }__            return fromId(major + minor + revision + build)___        } catch (NumberFormatException e) {_            throw new IllegalArgumentException("unable to parse version " + version, e)__        }_    };returns,the,version,given,its,string,representation,current,version,if,the,argument,is,null,or,empty;public,static,version,from,string,string,version,if,strings,has,length,version,return,version,current,final,boolean,snapshot,if,snapshot,version,ends,with,snapshot,version,version,substring,0,version,length,9,string,parts,version,split,if,parts,length,3,parts,length,4,throw,new,illegal,argument,exception,the,version,needs,to,contain,major,minor,and,revision,and,optionally,the,build,version,try,final,int,raw,major,integer,parse,int,parts,0,if,raw,major,5,snapshot,throw,new,illegal,argument,exception,illegal,version,format,snapshots,are,only,supported,until,version,2,x,final,int,beta,offset,raw,major,5,0,25,final,int,major,raw,major,1000000,final,int,minor,integer,parse,int,parts,1,10000,final,int,revision,integer,parse,int,parts,2,100,int,build,99,if,parts,length,4,string,build,str,parts,3,if,build,str,starts,with,alpha,assert,raw,major,5,major,must,be,5,but,was,major,build,integer,parse,int,build,str,substring,5,assert,build,25,expected,a,beta,build,but,build,25,else,if,build,str,starts,with,beta,build,str,starts,with,beta,build,beta,offset,integer,parse,int,build,str,substring,4,assert,build,50,expected,a,beta,build,but,build,50,else,if,build,str,starts,with,rc,build,str,starts,with,rc,build,integer,parse,int,build,str,substring,2,50,else,throw,new,illegal,argument,exception,unable,to,parse,version,version,return,from,id,major,minor,revision,build,catch,number,format,exception,e,throw,new,illegal,argument,exception,unable,to,parse,version,version,e
Version -> public static Version fromString(String version);1542226101;Returns the version given its string representation, current version if the argument is null or empty;public static Version fromString(String version) {_        if (!Strings.hasLength(version)) {_            return Version.CURRENT__        }_        final boolean snapshot_ _        if (snapshot = version.endsWith("-SNAPSHOT")) {_            version = version.substring(0, version.length() - 9)__        }_        String[] parts = version.split("[.-]")__        if (parts.length < 3 || parts.length > 4) {_            throw new IllegalArgumentException(_                    "the version needs to contain major, minor, and revision, and optionally the build: " + version)__        }__        try {_            final int rawMajor = Integer.parseInt(parts[0])__            if (rawMajor >= 5 && snapshot) { _                throw new IllegalArgumentException("illegal version format - snapshots are only supported until version 2.x")__            }_            final int betaOffset = rawMajor < 5 ? 0 : 25__            _            final int major = rawMajor * 1000000__            final int minor = Integer.parseInt(parts[1]) * 10000__            final int revision = Integer.parseInt(parts[2]) * 100____            int build = 99__            if (parts.length == 4) {_                String buildStr = parts[3]__                if (buildStr.startsWith("alpha")) {_                    assert rawMajor >= 5 : "major must be >= 5 but was " + major__                    build = Integer.parseInt(buildStr.substring(5))__                    assert build < 25 : "expected a beta build but " + build + " >= 25"__                } else if (buildStr.startsWith("Beta") || buildStr.startsWith("beta")) {_                    build = betaOffset + Integer.parseInt(buildStr.substring(4))__                    assert build < 50 : "expected a beta build but " + build + " >= 50"__                } else if (buildStr.startsWith("RC") || buildStr.startsWith("rc")) {_                    build = Integer.parseInt(buildStr.substring(2)) + 50__                } else {_                    throw new IllegalArgumentException("unable to parse version " + version)__                }_            }__            return fromId(major + minor + revision + build)___        } catch (NumberFormatException e) {_            throw new IllegalArgumentException("unable to parse version " + version, e)__        }_    };returns,the,version,given,its,string,representation,current,version,if,the,argument,is,null,or,empty;public,static,version,from,string,string,version,if,strings,has,length,version,return,version,current,final,boolean,snapshot,if,snapshot,version,ends,with,snapshot,version,version,substring,0,version,length,9,string,parts,version,split,if,parts,length,3,parts,length,4,throw,new,illegal,argument,exception,the,version,needs,to,contain,major,minor,and,revision,and,optionally,the,build,version,try,final,int,raw,major,integer,parse,int,parts,0,if,raw,major,5,snapshot,throw,new,illegal,argument,exception,illegal,version,format,snapshots,are,only,supported,until,version,2,x,final,int,beta,offset,raw,major,5,0,25,final,int,major,raw,major,1000000,final,int,minor,integer,parse,int,parts,1,10000,final,int,revision,integer,parse,int,parts,2,100,int,build,99,if,parts,length,4,string,build,str,parts,3,if,build,str,starts,with,alpha,assert,raw,major,5,major,must,be,5,but,was,major,build,integer,parse,int,build,str,substring,5,assert,build,25,expected,a,beta,build,but,build,25,else,if,build,str,starts,with,beta,build,str,starts,with,beta,build,beta,offset,integer,parse,int,build,str,substring,4,assert,build,50,expected,a,beta,build,but,build,50,else,if,build,str,starts,with,rc,build,str,starts,with,rc,build,integer,parse,int,build,str,substring,2,50,else,throw,new,illegal,argument,exception,unable,to,parse,version,version,return,from,id,major,minor,revision,build,catch,number,format,exception,e,throw,new,illegal,argument,exception,unable,to,parse,version,version,e
Version -> public static Version fromString(String version);1542746006;Returns the version given its string representation, current version if the argument is null or empty;public static Version fromString(String version) {_        if (!Strings.hasLength(version)) {_            return Version.CURRENT__        }_        final boolean snapshot_ _        if (snapshot = version.endsWith("-SNAPSHOT")) {_            version = version.substring(0, version.length() - 9)__        }_        String[] parts = version.split("[.-]")__        if (parts.length < 3 || parts.length > 4) {_            throw new IllegalArgumentException(_                    "the version needs to contain major, minor, and revision, and optionally the build: " + version)__        }__        try {_            final int rawMajor = Integer.parseInt(parts[0])__            if (rawMajor >= 5 && snapshot) { _                throw new IllegalArgumentException("illegal version format - snapshots are only supported until version 2.x")__            }_            final int betaOffset = rawMajor < 5 ? 0 : 25__            _            final int major = rawMajor * 1000000__            final int minor = Integer.parseInt(parts[1]) * 10000__            final int revision = Integer.parseInt(parts[2]) * 100____            int build = 99__            if (parts.length == 4) {_                String buildStr = parts[3]__                if (buildStr.startsWith("alpha")) {_                    assert rawMajor >= 5 : "major must be >= 5 but was " + major__                    build = Integer.parseInt(buildStr.substring(5))__                    assert build < 25 : "expected a beta build but " + build + " >= 25"__                } else if (buildStr.startsWith("Beta") || buildStr.startsWith("beta")) {_                    build = betaOffset + Integer.parseInt(buildStr.substring(4))__                    assert build < 50 : "expected a beta build but " + build + " >= 50"__                } else if (buildStr.startsWith("RC") || buildStr.startsWith("rc")) {_                    build = Integer.parseInt(buildStr.substring(2)) + 50__                } else {_                    throw new IllegalArgumentException("unable to parse version " + version)__                }_            }__            return fromId(major + minor + revision + build)___        } catch (NumberFormatException e) {_            throw new IllegalArgumentException("unable to parse version " + version, e)__        }_    };returns,the,version,given,its,string,representation,current,version,if,the,argument,is,null,or,empty;public,static,version,from,string,string,version,if,strings,has,length,version,return,version,current,final,boolean,snapshot,if,snapshot,version,ends,with,snapshot,version,version,substring,0,version,length,9,string,parts,version,split,if,parts,length,3,parts,length,4,throw,new,illegal,argument,exception,the,version,needs,to,contain,major,minor,and,revision,and,optionally,the,build,version,try,final,int,raw,major,integer,parse,int,parts,0,if,raw,major,5,snapshot,throw,new,illegal,argument,exception,illegal,version,format,snapshots,are,only,supported,until,version,2,x,final,int,beta,offset,raw,major,5,0,25,final,int,major,raw,major,1000000,final,int,minor,integer,parse,int,parts,1,10000,final,int,revision,integer,parse,int,parts,2,100,int,build,99,if,parts,length,4,string,build,str,parts,3,if,build,str,starts,with,alpha,assert,raw,major,5,major,must,be,5,but,was,major,build,integer,parse,int,build,str,substring,5,assert,build,25,expected,a,beta,build,but,build,25,else,if,build,str,starts,with,beta,build,str,starts,with,beta,build,beta,offset,integer,parse,int,build,str,substring,4,assert,build,50,expected,a,beta,build,but,build,50,else,if,build,str,starts,with,rc,build,str,starts,with,rc,build,integer,parse,int,build,str,substring,2,50,else,throw,new,illegal,argument,exception,unable,to,parse,version,version,return,from,id,major,minor,revision,build,catch,number,format,exception,e,throw,new,illegal,argument,exception,unable,to,parse,version,version,e
Version -> public static Version fromString(String version);1543473699;Returns the version given its string representation, current version if the argument is null or empty;public static Version fromString(String version) {_        if (!Strings.hasLength(version)) {_            return Version.CURRENT__        }_        final boolean snapshot_ _        if (snapshot = version.endsWith("-SNAPSHOT")) {_            version = version.substring(0, version.length() - 9)__        }_        String[] parts = version.split("[.-]")__        if (parts.length < 3 || parts.length > 4) {_            throw new IllegalArgumentException(_                    "the version needs to contain major, minor, and revision, and optionally the build: " + version)__        }__        try {_            final int rawMajor = Integer.parseInt(parts[0])__            if (rawMajor >= 5 && snapshot) { _                throw new IllegalArgumentException("illegal version format - snapshots are only supported until version 2.x")__            }_            if (rawMajor >=7 && parts.length == 4) { _                throw new IllegalArgumentException("illegal version format - qualifiers are only supported until version 6.x")__            }_            final int betaOffset = rawMajor < 5 ? 0 : 25__            _            final int major = rawMajor * 1000000__            final int minor = Integer.parseInt(parts[1]) * 10000__            final int revision = Integer.parseInt(parts[2]) * 100____            int build = 99__            if (parts.length == 4) {_                String buildStr = parts[3]__                if (buildStr.startsWith("alpha")) {_                    assert rawMajor >= 5 : "major must be >= 5 but was " + major__                    build = Integer.parseInt(buildStr.substring(5))__                    assert build < 25 : "expected a beta build but " + build + " >= 25"__                } else if (buildStr.startsWith("Beta") || buildStr.startsWith("beta")) {_                    build = betaOffset + Integer.parseInt(buildStr.substring(4))__                    assert build < 50 : "expected a beta build but " + build + " >= 50"__                } else if (buildStr.startsWith("RC") || buildStr.startsWith("rc")) {_                    build = Integer.parseInt(buildStr.substring(2)) + 50__                } else {_                    throw new IllegalArgumentException("unable to parse version " + version)__                }_            }__            return fromId(major + minor + revision + build)___        } catch (NumberFormatException e) {_            throw new IllegalArgumentException("unable to parse version " + version, e)__        }_    };returns,the,version,given,its,string,representation,current,version,if,the,argument,is,null,or,empty;public,static,version,from,string,string,version,if,strings,has,length,version,return,version,current,final,boolean,snapshot,if,snapshot,version,ends,with,snapshot,version,version,substring,0,version,length,9,string,parts,version,split,if,parts,length,3,parts,length,4,throw,new,illegal,argument,exception,the,version,needs,to,contain,major,minor,and,revision,and,optionally,the,build,version,try,final,int,raw,major,integer,parse,int,parts,0,if,raw,major,5,snapshot,throw,new,illegal,argument,exception,illegal,version,format,snapshots,are,only,supported,until,version,2,x,if,raw,major,7,parts,length,4,throw,new,illegal,argument,exception,illegal,version,format,qualifiers,are,only,supported,until,version,6,x,final,int,beta,offset,raw,major,5,0,25,final,int,major,raw,major,1000000,final,int,minor,integer,parse,int,parts,1,10000,final,int,revision,integer,parse,int,parts,2,100,int,build,99,if,parts,length,4,string,build,str,parts,3,if,build,str,starts,with,alpha,assert,raw,major,5,major,must,be,5,but,was,major,build,integer,parse,int,build,str,substring,5,assert,build,25,expected,a,beta,build,but,build,25,else,if,build,str,starts,with,beta,build,str,starts,with,beta,build,beta,offset,integer,parse,int,build,str,substring,4,assert,build,50,expected,a,beta,build,but,build,50,else,if,build,str,starts,with,rc,build,str,starts,with,rc,build,integer,parse,int,build,str,substring,2,50,else,throw,new,illegal,argument,exception,unable,to,parse,version,version,return,from,id,major,minor,revision,build,catch,number,format,exception,e,throw,new,illegal,argument,exception,unable,to,parse,version,version,e
Version -> public static Version fromString(String version);1543942400;Returns the version given its string representation, current version if the argument is null or empty;public static Version fromString(String version) {_        if (!Strings.hasLength(version)) {_            return Version.CURRENT__        }_        final boolean snapshot_ _        if (snapshot = version.endsWith("-SNAPSHOT")) {_            version = version.substring(0, version.length() - 9)__        }_        String[] parts = version.split("[.-]")__        if (parts.length < 3 || parts.length > 4) {_            throw new IllegalArgumentException(_                    "the version needs to contain major, minor, and revision, and optionally the build: " + version)__        }__        try {_            final int rawMajor = Integer.parseInt(parts[0])__            if (rawMajor >= 5 && snapshot) { _                throw new IllegalArgumentException("illegal version format - snapshots are only supported until version 2.x")__            }_            if (rawMajor >=7 && parts.length == 4) { _                throw new IllegalArgumentException("illegal version format - qualifiers are only supported until version 6.x")__            }_            final int betaOffset = rawMajor < 5 ? 0 : 25__            _            final int major = rawMajor * 1000000__            final int minor = Integer.parseInt(parts[1]) * 10000__            final int revision = Integer.parseInt(parts[2]) * 100____            int build = 99__            if (parts.length == 4) {_                String buildStr = parts[3]__                if (buildStr.startsWith("alpha")) {_                    assert rawMajor >= 5 : "major must be >= 5 but was " + major__                    build = Integer.parseInt(buildStr.substring(5))__                    assert build < 25 : "expected a beta build but " + build + " >= 25"__                } else if (buildStr.startsWith("Beta") || buildStr.startsWith("beta")) {_                    build = betaOffset + Integer.parseInt(buildStr.substring(4))__                    assert build < 50 : "expected a beta build but " + build + " >= 50"__                } else if (buildStr.startsWith("RC") || buildStr.startsWith("rc")) {_                    build = Integer.parseInt(buildStr.substring(2)) + 50__                } else {_                    throw new IllegalArgumentException("unable to parse version " + version)__                }_            }__            return fromId(major + minor + revision + build)___        } catch (NumberFormatException e) {_            throw new IllegalArgumentException("unable to parse version " + version, e)__        }_    };returns,the,version,given,its,string,representation,current,version,if,the,argument,is,null,or,empty;public,static,version,from,string,string,version,if,strings,has,length,version,return,version,current,final,boolean,snapshot,if,snapshot,version,ends,with,snapshot,version,version,substring,0,version,length,9,string,parts,version,split,if,parts,length,3,parts,length,4,throw,new,illegal,argument,exception,the,version,needs,to,contain,major,minor,and,revision,and,optionally,the,build,version,try,final,int,raw,major,integer,parse,int,parts,0,if,raw,major,5,snapshot,throw,new,illegal,argument,exception,illegal,version,format,snapshots,are,only,supported,until,version,2,x,if,raw,major,7,parts,length,4,throw,new,illegal,argument,exception,illegal,version,format,qualifiers,are,only,supported,until,version,6,x,final,int,beta,offset,raw,major,5,0,25,final,int,major,raw,major,1000000,final,int,minor,integer,parse,int,parts,1,10000,final,int,revision,integer,parse,int,parts,2,100,int,build,99,if,parts,length,4,string,build,str,parts,3,if,build,str,starts,with,alpha,assert,raw,major,5,major,must,be,5,but,was,major,build,integer,parse,int,build,str,substring,5,assert,build,25,expected,a,beta,build,but,build,25,else,if,build,str,starts,with,beta,build,str,starts,with,beta,build,beta,offset,integer,parse,int,build,str,substring,4,assert,build,50,expected,a,beta,build,but,build,50,else,if,build,str,starts,with,rc,build,str,starts,with,rc,build,integer,parse,int,build,str,substring,2,50,else,throw,new,illegal,argument,exception,unable,to,parse,version,version,return,from,id,major,minor,revision,build,catch,number,format,exception,e,throw,new,illegal,argument,exception,unable,to,parse,version,version,e
Version -> public static Version fromString(String version);1544037309;Returns the version given its string representation, current version if the argument is null or empty;public static Version fromString(String version) {_        if (!Strings.hasLength(version)) {_            return Version.CURRENT__        }_        final boolean snapshot_ _        if (snapshot = version.endsWith("-SNAPSHOT")) {_            version = version.substring(0, version.length() - 9)__        }_        String[] parts = version.split("[.-]")__        if (parts.length < 3 || parts.length > 4) {_            throw new IllegalArgumentException(_                    "the version needs to contain major, minor, and revision, and optionally the build: " + version)__        }__        try {_            final int rawMajor = Integer.parseInt(parts[0])__            if (rawMajor >= 5 && snapshot) { _                throw new IllegalArgumentException("illegal version format - snapshots are only supported until version 2.x")__            }_            if (rawMajor >=7 && parts.length == 4) { _                throw new IllegalArgumentException("illegal version format - qualifiers are only supported until version 6.x")__            }_            final int betaOffset = rawMajor < 5 ? 0 : 25__            _            final int major = rawMajor * 1000000__            final int minor = Integer.parseInt(parts[1]) * 10000__            final int revision = Integer.parseInt(parts[2]) * 100____            int build = 99__            if (parts.length == 4) {_                String buildStr = parts[3]__                if (buildStr.startsWith("alpha")) {_                    assert rawMajor >= 5 : "major must be >= 5 but was " + major__                    build = Integer.parseInt(buildStr.substring(5))__                    assert build < 25 : "expected a beta build but " + build + " >= 25"__                } else if (buildStr.startsWith("Beta") || buildStr.startsWith("beta")) {_                    build = betaOffset + Integer.parseInt(buildStr.substring(4))__                    assert build < 50 : "expected a beta build but " + build + " >= 50"__                } else if (buildStr.startsWith("RC") || buildStr.startsWith("rc")) {_                    build = Integer.parseInt(buildStr.substring(2)) + 50__                } else {_                    throw new IllegalArgumentException("unable to parse version " + version)__                }_            }__            return fromId(major + minor + revision + build)___        } catch (NumberFormatException e) {_            throw new IllegalArgumentException("unable to parse version " + version, e)__        }_    };returns,the,version,given,its,string,representation,current,version,if,the,argument,is,null,or,empty;public,static,version,from,string,string,version,if,strings,has,length,version,return,version,current,final,boolean,snapshot,if,snapshot,version,ends,with,snapshot,version,version,substring,0,version,length,9,string,parts,version,split,if,parts,length,3,parts,length,4,throw,new,illegal,argument,exception,the,version,needs,to,contain,major,minor,and,revision,and,optionally,the,build,version,try,final,int,raw,major,integer,parse,int,parts,0,if,raw,major,5,snapshot,throw,new,illegal,argument,exception,illegal,version,format,snapshots,are,only,supported,until,version,2,x,if,raw,major,7,parts,length,4,throw,new,illegal,argument,exception,illegal,version,format,qualifiers,are,only,supported,until,version,6,x,final,int,beta,offset,raw,major,5,0,25,final,int,major,raw,major,1000000,final,int,minor,integer,parse,int,parts,1,10000,final,int,revision,integer,parse,int,parts,2,100,int,build,99,if,parts,length,4,string,build,str,parts,3,if,build,str,starts,with,alpha,assert,raw,major,5,major,must,be,5,but,was,major,build,integer,parse,int,build,str,substring,5,assert,build,25,expected,a,beta,build,but,build,25,else,if,build,str,starts,with,beta,build,str,starts,with,beta,build,beta,offset,integer,parse,int,build,str,substring,4,assert,build,50,expected,a,beta,build,but,build,50,else,if,build,str,starts,with,rc,build,str,starts,with,rc,build,integer,parse,int,build,str,substring,2,50,else,throw,new,illegal,argument,exception,unable,to,parse,version,version,return,from,id,major,minor,revision,build,catch,number,format,exception,e,throw,new,illegal,argument,exception,unable,to,parse,version,version,e
Version -> public static Version fromString(String version);1544553539;Returns the version given its string representation, current version if the argument is null or empty;public static Version fromString(String version) {_        if (!Strings.hasLength(version)) {_            return Version.CURRENT__        }_        final boolean snapshot_ _        if (snapshot = version.endsWith("-SNAPSHOT")) {_            version = version.substring(0, version.length() - 9)__        }_        String[] parts = version.split("[.-]")__        if (parts.length < 3 || parts.length > 4) {_            throw new IllegalArgumentException(_                    "the version needs to contain major, minor, and revision, and optionally the build: " + version)__        }__        try {_            final int rawMajor = Integer.parseInt(parts[0])__            if (rawMajor >= 5 && snapshot) { _                throw new IllegalArgumentException("illegal version format - snapshots are only supported until version 2.x")__            }_            if (rawMajor >=7 && parts.length == 4) { _                throw new IllegalArgumentException("illegal version format - qualifiers are only supported until version 6.x")__            }_            final int betaOffset = rawMajor < 5 ? 0 : 25__            _            final int major = rawMajor * 1000000__            final int minor = Integer.parseInt(parts[1]) * 10000__            final int revision = Integer.parseInt(parts[2]) * 100____            int build = 99__            if (parts.length == 4) {_                String buildStr = parts[3]__                if (buildStr.startsWith("alpha")) {_                    assert rawMajor >= 5 : "major must be >= 5 but was " + major__                    build = Integer.parseInt(buildStr.substring(5))__                    assert build < 25 : "expected a beta build but " + build + " >= 25"__                } else if (buildStr.startsWith("Beta") || buildStr.startsWith("beta")) {_                    build = betaOffset + Integer.parseInt(buildStr.substring(4))__                    assert build < 50 : "expected a beta build but " + build + " >= 50"__                } else if (buildStr.startsWith("RC") || buildStr.startsWith("rc")) {_                    build = Integer.parseInt(buildStr.substring(2)) + 50__                } else {_                    throw new IllegalArgumentException("unable to parse version " + version)__                }_            }__            return fromId(major + minor + revision + build)___        } catch (NumberFormatException e) {_            throw new IllegalArgumentException("unable to parse version " + version, e)__        }_    };returns,the,version,given,its,string,representation,current,version,if,the,argument,is,null,or,empty;public,static,version,from,string,string,version,if,strings,has,length,version,return,version,current,final,boolean,snapshot,if,snapshot,version,ends,with,snapshot,version,version,substring,0,version,length,9,string,parts,version,split,if,parts,length,3,parts,length,4,throw,new,illegal,argument,exception,the,version,needs,to,contain,major,minor,and,revision,and,optionally,the,build,version,try,final,int,raw,major,integer,parse,int,parts,0,if,raw,major,5,snapshot,throw,new,illegal,argument,exception,illegal,version,format,snapshots,are,only,supported,until,version,2,x,if,raw,major,7,parts,length,4,throw,new,illegal,argument,exception,illegal,version,format,qualifiers,are,only,supported,until,version,6,x,final,int,beta,offset,raw,major,5,0,25,final,int,major,raw,major,1000000,final,int,minor,integer,parse,int,parts,1,10000,final,int,revision,integer,parse,int,parts,2,100,int,build,99,if,parts,length,4,string,build,str,parts,3,if,build,str,starts,with,alpha,assert,raw,major,5,major,must,be,5,but,was,major,build,integer,parse,int,build,str,substring,5,assert,build,25,expected,a,beta,build,but,build,25,else,if,build,str,starts,with,beta,build,str,starts,with,beta,build,beta,offset,integer,parse,int,build,str,substring,4,assert,build,50,expected,a,beta,build,but,build,50,else,if,build,str,starts,with,rc,build,str,starts,with,rc,build,integer,parse,int,build,str,substring,2,50,else,throw,new,illegal,argument,exception,unable,to,parse,version,version,return,from,id,major,minor,revision,build,catch,number,format,exception,e,throw,new,illegal,argument,exception,unable,to,parse,version,version,e
Version -> public static Version fromString(String version);1545225850;Returns the version given its string representation, current version if the argument is null or empty;public static Version fromString(String version) {_        if (!Strings.hasLength(version)) {_            return Version.CURRENT__        }_        final boolean snapshot_ _        if (snapshot = version.endsWith("-SNAPSHOT")) {_            version = version.substring(0, version.length() - 9)__        }_        String[] parts = version.split("[.-]")__        if (parts.length < 3 || parts.length > 4) {_            throw new IllegalArgumentException(_                    "the version needs to contain major, minor, and revision, and optionally the build: " + version)__        }__        try {_            final int rawMajor = Integer.parseInt(parts[0])__            if (rawMajor >= 5 && snapshot) { _                throw new IllegalArgumentException("illegal version format - snapshots are only supported until version 2.x")__            }_            if (rawMajor >=7 && parts.length == 4) { _                throw new IllegalArgumentException("illegal version format - qualifiers are only supported until version 6.x")__            }_            final int betaOffset = rawMajor < 5 ? 0 : 25__            _            final int major = rawMajor * 1000000__            final int minor = Integer.parseInt(parts[1]) * 10000__            final int revision = Integer.parseInt(parts[2]) * 100____            int build = 99__            if (parts.length == 4) {_                String buildStr = parts[3]__                if (buildStr.startsWith("alpha")) {_                    assert rawMajor >= 5 : "major must be >= 5 but was " + major__                    build = Integer.parseInt(buildStr.substring(5))__                    assert build < 25 : "expected a beta build but " + build + " >= 25"__                } else if (buildStr.startsWith("Beta") || buildStr.startsWith("beta")) {_                    build = betaOffset + Integer.parseInt(buildStr.substring(4))__                    assert build < 50 : "expected a beta build but " + build + " >= 50"__                } else if (buildStr.startsWith("RC") || buildStr.startsWith("rc")) {_                    build = Integer.parseInt(buildStr.substring(2)) + 50__                } else {_                    throw new IllegalArgumentException("unable to parse version " + version)__                }_            }__            return fromId(major + minor + revision + build)___        } catch (NumberFormatException e) {_            throw new IllegalArgumentException("unable to parse version " + version, e)__        }_    };returns,the,version,given,its,string,representation,current,version,if,the,argument,is,null,or,empty;public,static,version,from,string,string,version,if,strings,has,length,version,return,version,current,final,boolean,snapshot,if,snapshot,version,ends,with,snapshot,version,version,substring,0,version,length,9,string,parts,version,split,if,parts,length,3,parts,length,4,throw,new,illegal,argument,exception,the,version,needs,to,contain,major,minor,and,revision,and,optionally,the,build,version,try,final,int,raw,major,integer,parse,int,parts,0,if,raw,major,5,snapshot,throw,new,illegal,argument,exception,illegal,version,format,snapshots,are,only,supported,until,version,2,x,if,raw,major,7,parts,length,4,throw,new,illegal,argument,exception,illegal,version,format,qualifiers,are,only,supported,until,version,6,x,final,int,beta,offset,raw,major,5,0,25,final,int,major,raw,major,1000000,final,int,minor,integer,parse,int,parts,1,10000,final,int,revision,integer,parse,int,parts,2,100,int,build,99,if,parts,length,4,string,build,str,parts,3,if,build,str,starts,with,alpha,assert,raw,major,5,major,must,be,5,but,was,major,build,integer,parse,int,build,str,substring,5,assert,build,25,expected,a,beta,build,but,build,25,else,if,build,str,starts,with,beta,build,str,starts,with,beta,build,beta,offset,integer,parse,int,build,str,substring,4,assert,build,50,expected,a,beta,build,but,build,50,else,if,build,str,starts,with,rc,build,str,starts,with,rc,build,integer,parse,int,build,str,substring,2,50,else,throw,new,illegal,argument,exception,unable,to,parse,version,version,return,from,id,major,minor,revision,build,catch,number,format,exception,e,throw,new,illegal,argument,exception,unable,to,parse,version,version,e
Version -> public static Version fromString(String version);1545256934;Returns the version given its string representation, current version if the argument is null or empty;public static Version fromString(String version) {_        if (!Strings.hasLength(version)) {_            return Version.CURRENT__        }_        final boolean snapshot_ _        if (snapshot = version.endsWith("-SNAPSHOT")) {_            version = version.substring(0, version.length() - 9)__        }_        String[] parts = version.split("[.-]")__        if (parts.length < 3 || parts.length > 4) {_            throw new IllegalArgumentException(_                    "the version needs to contain major, minor, and revision, and optionally the build: " + version)__        }__        try {_            final int rawMajor = Integer.parseInt(parts[0])__            if (rawMajor >= 5 && snapshot) { _                throw new IllegalArgumentException("illegal version format - snapshots are only supported until version 2.x")__            }_            if (rawMajor >=7 && parts.length == 4) { _                throw new IllegalArgumentException("illegal version format - qualifiers are only supported until version 6.x")__            }_            final int betaOffset = rawMajor < 5 ? 0 : 25__            _            final int major = rawMajor * 1000000__            final int minor = Integer.parseInt(parts[1]) * 10000__            final int revision = Integer.parseInt(parts[2]) * 100____            int build = 99__            if (parts.length == 4) {_                String buildStr = parts[3]__                if (buildStr.startsWith("alpha")) {_                    assert rawMajor >= 5 : "major must be >= 5 but was " + major__                    build = Integer.parseInt(buildStr.substring(5))__                    assert build < 25 : "expected a beta build but " + build + " >= 25"__                } else if (buildStr.startsWith("Beta") || buildStr.startsWith("beta")) {_                    build = betaOffset + Integer.parseInt(buildStr.substring(4))__                    assert build < 50 : "expected a beta build but " + build + " >= 50"__                } else if (buildStr.startsWith("RC") || buildStr.startsWith("rc")) {_                    build = Integer.parseInt(buildStr.substring(2)) + 50__                } else {_                    throw new IllegalArgumentException("unable to parse version " + version)__                }_            }__            return fromId(major + minor + revision + build)___        } catch (NumberFormatException e) {_            throw new IllegalArgumentException("unable to parse version " + version, e)__        }_    };returns,the,version,given,its,string,representation,current,version,if,the,argument,is,null,or,empty;public,static,version,from,string,string,version,if,strings,has,length,version,return,version,current,final,boolean,snapshot,if,snapshot,version,ends,with,snapshot,version,version,substring,0,version,length,9,string,parts,version,split,if,parts,length,3,parts,length,4,throw,new,illegal,argument,exception,the,version,needs,to,contain,major,minor,and,revision,and,optionally,the,build,version,try,final,int,raw,major,integer,parse,int,parts,0,if,raw,major,5,snapshot,throw,new,illegal,argument,exception,illegal,version,format,snapshots,are,only,supported,until,version,2,x,if,raw,major,7,parts,length,4,throw,new,illegal,argument,exception,illegal,version,format,qualifiers,are,only,supported,until,version,6,x,final,int,beta,offset,raw,major,5,0,25,final,int,major,raw,major,1000000,final,int,minor,integer,parse,int,parts,1,10000,final,int,revision,integer,parse,int,parts,2,100,int,build,99,if,parts,length,4,string,build,str,parts,3,if,build,str,starts,with,alpha,assert,raw,major,5,major,must,be,5,but,was,major,build,integer,parse,int,build,str,substring,5,assert,build,25,expected,a,beta,build,but,build,25,else,if,build,str,starts,with,beta,build,str,starts,with,beta,build,beta,offset,integer,parse,int,build,str,substring,4,assert,build,50,expected,a,beta,build,but,build,50,else,if,build,str,starts,with,rc,build,str,starts,with,rc,build,integer,parse,int,build,str,substring,2,50,else,throw,new,illegal,argument,exception,unable,to,parse,version,version,return,from,id,major,minor,revision,build,catch,number,format,exception,e,throw,new,illegal,argument,exception,unable,to,parse,version,version,e
Version -> public static Version fromString(String version);1546507247;Returns the version given its string representation, current version if the argument is null or empty;public static Version fromString(String version) {_        if (!Strings.hasLength(version)) {_            return Version.CURRENT__        }_        final boolean snapshot_ _        if (snapshot = version.endsWith("-SNAPSHOT")) {_            version = version.substring(0, version.length() - 9)__        }_        String[] parts = version.split("[.-]")__        if (parts.length < 3 || parts.length > 4) {_            throw new IllegalArgumentException(_                    "the version needs to contain major, minor, and revision, and optionally the build: " + version)__        }__        try {_            final int rawMajor = Integer.parseInt(parts[0])__            if (rawMajor >= 5 && snapshot) { _                throw new IllegalArgumentException("illegal version format - snapshots are only supported until version 2.x")__            }_            if (rawMajor >=7 && parts.length == 4) { _                throw new IllegalArgumentException("illegal version format - qualifiers are only supported until version 6.x")__            }_            final int betaOffset = rawMajor < 5 ? 0 : 25__            _            final int major = rawMajor * 1000000__            final int minor = Integer.parseInt(parts[1]) * 10000__            final int revision = Integer.parseInt(parts[2]) * 100____            int build = 99__            if (parts.length == 4) {_                String buildStr = parts[3]__                if (buildStr.startsWith("alpha")) {_                    assert rawMajor >= 5 : "major must be >= 5 but was " + major__                    build = Integer.parseInt(buildStr.substring(5))__                    assert build < 25 : "expected a beta build but " + build + " >= 25"__                } else if (buildStr.startsWith("Beta") || buildStr.startsWith("beta")) {_                    build = betaOffset + Integer.parseInt(buildStr.substring(4))__                    assert build < 50 : "expected a beta build but " + build + " >= 50"__                } else if (buildStr.startsWith("RC") || buildStr.startsWith("rc")) {_                    build = Integer.parseInt(buildStr.substring(2)) + 50__                } else {_                    throw new IllegalArgumentException("unable to parse version " + version)__                }_            }__            return fromId(major + minor + revision + build)___        } catch (NumberFormatException e) {_            throw new IllegalArgumentException("unable to parse version " + version, e)__        }_    };returns,the,version,given,its,string,representation,current,version,if,the,argument,is,null,or,empty;public,static,version,from,string,string,version,if,strings,has,length,version,return,version,current,final,boolean,snapshot,if,snapshot,version,ends,with,snapshot,version,version,substring,0,version,length,9,string,parts,version,split,if,parts,length,3,parts,length,4,throw,new,illegal,argument,exception,the,version,needs,to,contain,major,minor,and,revision,and,optionally,the,build,version,try,final,int,raw,major,integer,parse,int,parts,0,if,raw,major,5,snapshot,throw,new,illegal,argument,exception,illegal,version,format,snapshots,are,only,supported,until,version,2,x,if,raw,major,7,parts,length,4,throw,new,illegal,argument,exception,illegal,version,format,qualifiers,are,only,supported,until,version,6,x,final,int,beta,offset,raw,major,5,0,25,final,int,major,raw,major,1000000,final,int,minor,integer,parse,int,parts,1,10000,final,int,revision,integer,parse,int,parts,2,100,int,build,99,if,parts,length,4,string,build,str,parts,3,if,build,str,starts,with,alpha,assert,raw,major,5,major,must,be,5,but,was,major,build,integer,parse,int,build,str,substring,5,assert,build,25,expected,a,beta,build,but,build,25,else,if,build,str,starts,with,beta,build,str,starts,with,beta,build,beta,offset,integer,parse,int,build,str,substring,4,assert,build,50,expected,a,beta,build,but,build,50,else,if,build,str,starts,with,rc,build,str,starts,with,rc,build,integer,parse,int,build,str,substring,2,50,else,throw,new,illegal,argument,exception,unable,to,parse,version,version,return,from,id,major,minor,revision,build,catch,number,format,exception,e,throw,new,illegal,argument,exception,unable,to,parse,version,version,e
Version -> public static Version fromString(String version);1546537951;Returns the version given its string representation, current version if the argument is null or empty;public static Version fromString(String version) {_        if (!Strings.hasLength(version)) {_            return Version.CURRENT__        }_        final boolean snapshot_ _        if (snapshot = version.endsWith("-SNAPSHOT")) {_            version = version.substring(0, version.length() - 9)__        }_        String[] parts = version.split("[.-]")__        if (parts.length < 3 || parts.length > 4) {_            throw new IllegalArgumentException(_                    "the version needs to contain major, minor, and revision, and optionally the build: " + version)__        }__        try {_            final int rawMajor = Integer.parseInt(parts[0])__            if (rawMajor >= 5 && snapshot) { _                throw new IllegalArgumentException("illegal version format - snapshots are only supported until version 2.x")__            }_            if (rawMajor >=7 && parts.length == 4) { _                throw new IllegalArgumentException("illegal version format - qualifiers are only supported until version 6.x")__            }_            final int betaOffset = rawMajor < 5 ? 0 : 25__            _            final int major = rawMajor * 1000000__            final int minor = Integer.parseInt(parts[1]) * 10000__            final int revision = Integer.parseInt(parts[2]) * 100____            int build = 99__            if (parts.length == 4) {_                String buildStr = parts[3]__                if (buildStr.startsWith("alpha")) {_                    assert rawMajor >= 5 : "major must be >= 5 but was " + major__                    build = Integer.parseInt(buildStr.substring(5))__                    assert build < 25 : "expected a beta build but " + build + " >= 25"__                } else if (buildStr.startsWith("Beta") || buildStr.startsWith("beta")) {_                    build = betaOffset + Integer.parseInt(buildStr.substring(4))__                    assert build < 50 : "expected a beta build but " + build + " >= 50"__                } else if (buildStr.startsWith("RC") || buildStr.startsWith("rc")) {_                    build = Integer.parseInt(buildStr.substring(2)) + 50__                } else {_                    throw new IllegalArgumentException("unable to parse version " + version)__                }_            }__            return fromId(major + minor + revision + build)___        } catch (NumberFormatException e) {_            throw new IllegalArgumentException("unable to parse version " + version, e)__        }_    };returns,the,version,given,its,string,representation,current,version,if,the,argument,is,null,or,empty;public,static,version,from,string,string,version,if,strings,has,length,version,return,version,current,final,boolean,snapshot,if,snapshot,version,ends,with,snapshot,version,version,substring,0,version,length,9,string,parts,version,split,if,parts,length,3,parts,length,4,throw,new,illegal,argument,exception,the,version,needs,to,contain,major,minor,and,revision,and,optionally,the,build,version,try,final,int,raw,major,integer,parse,int,parts,0,if,raw,major,5,snapshot,throw,new,illegal,argument,exception,illegal,version,format,snapshots,are,only,supported,until,version,2,x,if,raw,major,7,parts,length,4,throw,new,illegal,argument,exception,illegal,version,format,qualifiers,are,only,supported,until,version,6,x,final,int,beta,offset,raw,major,5,0,25,final,int,major,raw,major,1000000,final,int,minor,integer,parse,int,parts,1,10000,final,int,revision,integer,parse,int,parts,2,100,int,build,99,if,parts,length,4,string,build,str,parts,3,if,build,str,starts,with,alpha,assert,raw,major,5,major,must,be,5,but,was,major,build,integer,parse,int,build,str,substring,5,assert,build,25,expected,a,beta,build,but,build,25,else,if,build,str,starts,with,beta,build,str,starts,with,beta,build,beta,offset,integer,parse,int,build,str,substring,4,assert,build,50,expected,a,beta,build,but,build,50,else,if,build,str,starts,with,rc,build,str,starts,with,rc,build,integer,parse,int,build,str,substring,2,50,else,throw,new,illegal,argument,exception,unable,to,parse,version,version,return,from,id,major,minor,revision,build,catch,number,format,exception,e,throw,new,illegal,argument,exception,unable,to,parse,version,version,e
Version -> public static Version fromString(String version);1548755041;Returns the version given its string representation, current version if the argument is null or empty;public static Version fromString(String version) {_        if (!Strings.hasLength(version)) {_            return Version.CURRENT__        }_        final boolean snapshot_ _        if (snapshot = version.endsWith("-SNAPSHOT")) {_            version = version.substring(0, version.length() - 9)__        }_        String[] parts = version.split("[.-]")__        if (parts.length < 3 || parts.length > 4) {_            throw new IllegalArgumentException(_                    "the version needs to contain major, minor, and revision, and optionally the build: " + version)__        }__        try {_            final int rawMajor = Integer.parseInt(parts[0])__            if (rawMajor >= 5 && snapshot) { _                throw new IllegalArgumentException("illegal version format - snapshots are only supported until version 2.x")__            }_            if (rawMajor >=7 && parts.length == 4) { _                throw new IllegalArgumentException("illegal version format - qualifiers are only supported until version 6.x")__            }_            final int betaOffset = rawMajor < 5 ? 0 : 25__            _            final int major = rawMajor * 1000000__            final int minor = Integer.parseInt(parts[1]) * 10000__            final int revision = Integer.parseInt(parts[2]) * 100____            int build = 99__            if (parts.length == 4) {_                String buildStr = parts[3]__                if (buildStr.startsWith("alpha")) {_                    assert rawMajor >= 5 : "major must be >= 5 but was " + major__                    build = Integer.parseInt(buildStr.substring(5))__                    assert build < 25 : "expected a beta build but " + build + " >= 25"__                } else if (buildStr.startsWith("Beta") || buildStr.startsWith("beta")) {_                    build = betaOffset + Integer.parseInt(buildStr.substring(4))__                    assert build < 50 : "expected a beta build but " + build + " >= 50"__                } else if (buildStr.startsWith("RC") || buildStr.startsWith("rc")) {_                    build = Integer.parseInt(buildStr.substring(2)) + 50__                } else {_                    throw new IllegalArgumentException("unable to parse version " + version)__                }_            }__            return fromId(major + minor + revision + build)___        } catch (NumberFormatException e) {_            throw new IllegalArgumentException("unable to parse version " + version, e)__        }_    };returns,the,version,given,its,string,representation,current,version,if,the,argument,is,null,or,empty;public,static,version,from,string,string,version,if,strings,has,length,version,return,version,current,final,boolean,snapshot,if,snapshot,version,ends,with,snapshot,version,version,substring,0,version,length,9,string,parts,version,split,if,parts,length,3,parts,length,4,throw,new,illegal,argument,exception,the,version,needs,to,contain,major,minor,and,revision,and,optionally,the,build,version,try,final,int,raw,major,integer,parse,int,parts,0,if,raw,major,5,snapshot,throw,new,illegal,argument,exception,illegal,version,format,snapshots,are,only,supported,until,version,2,x,if,raw,major,7,parts,length,4,throw,new,illegal,argument,exception,illegal,version,format,qualifiers,are,only,supported,until,version,6,x,final,int,beta,offset,raw,major,5,0,25,final,int,major,raw,major,1000000,final,int,minor,integer,parse,int,parts,1,10000,final,int,revision,integer,parse,int,parts,2,100,int,build,99,if,parts,length,4,string,build,str,parts,3,if,build,str,starts,with,alpha,assert,raw,major,5,major,must,be,5,but,was,major,build,integer,parse,int,build,str,substring,5,assert,build,25,expected,a,beta,build,but,build,25,else,if,build,str,starts,with,beta,build,str,starts,with,beta,build,beta,offset,integer,parse,int,build,str,substring,4,assert,build,50,expected,a,beta,build,but,build,50,else,if,build,str,starts,with,rc,build,str,starts,with,rc,build,integer,parse,int,build,str,substring,2,50,else,throw,new,illegal,argument,exception,unable,to,parse,version,version,return,from,id,major,minor,revision,build,catch,number,format,exception,e,throw,new,illegal,argument,exception,unable,to,parse,version,version,e
Version -> public static Version fromString(String version);1548822781;Returns the version given its string representation, current version if the argument is null or empty;public static Version fromString(String version) {_        if (!Strings.hasLength(version)) {_            return Version.CURRENT__        }_        final boolean snapshot_ _        if (snapshot = version.endsWith("-SNAPSHOT")) {_            version = version.substring(0, version.length() - 9)__        }_        String[] parts = version.split("[.-]")__        if (parts.length < 3 || parts.length > 4) {_            throw new IllegalArgumentException(_                    "the version needs to contain major, minor, and revision, and optionally the build: " + version)__        }__        try {_            final int rawMajor = Integer.parseInt(parts[0])__            if (rawMajor >= 5 && snapshot) { _                throw new IllegalArgumentException("illegal version format - snapshots are only supported until version 2.x")__            }_            if (rawMajor >=7 && parts.length == 4) { _                throw new IllegalArgumentException("illegal version format - qualifiers are only supported until version 6.x")__            }_            final int betaOffset = rawMajor < 5 ? 0 : 25__            _            final int major = rawMajor * 1000000__            final int minor = Integer.parseInt(parts[1]) * 10000__            final int revision = Integer.parseInt(parts[2]) * 100____            int build = 99__            if (parts.length == 4) {_                String buildStr = parts[3]__                if (buildStr.startsWith("alpha")) {_                    assert rawMajor >= 5 : "major must be >= 5 but was " + major__                    build = Integer.parseInt(buildStr.substring(5))__                    assert build < 25 : "expected a beta build but " + build + " >= 25"__                } else if (buildStr.startsWith("Beta") || buildStr.startsWith("beta")) {_                    build = betaOffset + Integer.parseInt(buildStr.substring(4))__                    assert build < 50 : "expected a beta build but " + build + " >= 50"__                } else if (buildStr.startsWith("RC") || buildStr.startsWith("rc")) {_                    build = Integer.parseInt(buildStr.substring(2)) + 50__                } else {_                    throw new IllegalArgumentException("unable to parse version " + version)__                }_            }__            return fromId(major + minor + revision + build)___        } catch (NumberFormatException e) {_            throw new IllegalArgumentException("unable to parse version " + version, e)__        }_    };returns,the,version,given,its,string,representation,current,version,if,the,argument,is,null,or,empty;public,static,version,from,string,string,version,if,strings,has,length,version,return,version,current,final,boolean,snapshot,if,snapshot,version,ends,with,snapshot,version,version,substring,0,version,length,9,string,parts,version,split,if,parts,length,3,parts,length,4,throw,new,illegal,argument,exception,the,version,needs,to,contain,major,minor,and,revision,and,optionally,the,build,version,try,final,int,raw,major,integer,parse,int,parts,0,if,raw,major,5,snapshot,throw,new,illegal,argument,exception,illegal,version,format,snapshots,are,only,supported,until,version,2,x,if,raw,major,7,parts,length,4,throw,new,illegal,argument,exception,illegal,version,format,qualifiers,are,only,supported,until,version,6,x,final,int,beta,offset,raw,major,5,0,25,final,int,major,raw,major,1000000,final,int,minor,integer,parse,int,parts,1,10000,final,int,revision,integer,parse,int,parts,2,100,int,build,99,if,parts,length,4,string,build,str,parts,3,if,build,str,starts,with,alpha,assert,raw,major,5,major,must,be,5,but,was,major,build,integer,parse,int,build,str,substring,5,assert,build,25,expected,a,beta,build,but,build,25,else,if,build,str,starts,with,beta,build,str,starts,with,beta,build,beta,offset,integer,parse,int,build,str,substring,4,assert,build,50,expected,a,beta,build,but,build,50,else,if,build,str,starts,with,rc,build,str,starts,with,rc,build,integer,parse,int,build,str,substring,2,50,else,throw,new,illegal,argument,exception,unable,to,parse,version,version,return,from,id,major,minor,revision,build,catch,number,format,exception,e,throw,new,illegal,argument,exception,unable,to,parse,version,version,e
Version -> public static Version fromString(String version);1549608646;Returns the version given its string representation, current version if the argument is null or empty;public static Version fromString(String version) {_        if (!Strings.hasLength(version)) {_            return Version.CURRENT__        }_        final boolean snapshot_ _        if (snapshot = version.endsWith("-SNAPSHOT")) {_            version = version.substring(0, version.length() - 9)__        }_        String[] parts = version.split("[.-]")__        if (parts.length < 3 || parts.length > 4) {_            throw new IllegalArgumentException(_                    "the version needs to contain major, minor, and revision, and optionally the build: " + version)__        }__        try {_            final int rawMajor = Integer.parseInt(parts[0])__            if (rawMajor >= 5 && snapshot) { _                throw new IllegalArgumentException("illegal version format - snapshots are only supported until version 2.x")__            }_            if (rawMajor >=7 && parts.length == 4) { _                throw new IllegalArgumentException("illegal version format - qualifiers are only supported until version 6.x")__            }_            final int betaOffset = rawMajor < 5 ? 0 : 25__            _            final int major = rawMajor * 1000000__            final int minor = Integer.parseInt(parts[1]) * 10000__            final int revision = Integer.parseInt(parts[2]) * 100____            int build = 99__            if (parts.length == 4) {_                String buildStr = parts[3]__                if (buildStr.startsWith("alpha")) {_                    assert rawMajor >= 5 : "major must be >= 5 but was " + major__                    build = Integer.parseInt(buildStr.substring(5))__                    assert build < 25 : "expected a beta build but " + build + " >= 25"__                } else if (buildStr.startsWith("Beta") || buildStr.startsWith("beta")) {_                    build = betaOffset + Integer.parseInt(buildStr.substring(4))__                    assert build < 50 : "expected a beta build but " + build + " >= 50"__                } else if (buildStr.startsWith("RC") || buildStr.startsWith("rc")) {_                    build = Integer.parseInt(buildStr.substring(2)) + 50__                } else {_                    throw new IllegalArgumentException("unable to parse version " + version)__                }_            }__            return fromId(major + minor + revision + build)___        } catch (NumberFormatException e) {_            throw new IllegalArgumentException("unable to parse version " + version, e)__        }_    };returns,the,version,given,its,string,representation,current,version,if,the,argument,is,null,or,empty;public,static,version,from,string,string,version,if,strings,has,length,version,return,version,current,final,boolean,snapshot,if,snapshot,version,ends,with,snapshot,version,version,substring,0,version,length,9,string,parts,version,split,if,parts,length,3,parts,length,4,throw,new,illegal,argument,exception,the,version,needs,to,contain,major,minor,and,revision,and,optionally,the,build,version,try,final,int,raw,major,integer,parse,int,parts,0,if,raw,major,5,snapshot,throw,new,illegal,argument,exception,illegal,version,format,snapshots,are,only,supported,until,version,2,x,if,raw,major,7,parts,length,4,throw,new,illegal,argument,exception,illegal,version,format,qualifiers,are,only,supported,until,version,6,x,final,int,beta,offset,raw,major,5,0,25,final,int,major,raw,major,1000000,final,int,minor,integer,parse,int,parts,1,10000,final,int,revision,integer,parse,int,parts,2,100,int,build,99,if,parts,length,4,string,build,str,parts,3,if,build,str,starts,with,alpha,assert,raw,major,5,major,must,be,5,but,was,major,build,integer,parse,int,build,str,substring,5,assert,build,25,expected,a,beta,build,but,build,25,else,if,build,str,starts,with,beta,build,str,starts,with,beta,build,beta,offset,integer,parse,int,build,str,substring,4,assert,build,50,expected,a,beta,build,but,build,50,else,if,build,str,starts,with,rc,build,str,starts,with,rc,build,integer,parse,int,build,str,substring,2,50,else,throw,new,illegal,argument,exception,unable,to,parse,version,version,return,from,id,major,minor,revision,build,catch,number,format,exception,e,throw,new,illegal,argument,exception,unable,to,parse,version,version,e
Version -> public static Version fromString(String version);1550604529;Returns the version given its string representation, current version if the argument is null or empty;public static Version fromString(String version) {_        if (!Strings.hasLength(version)) {_            return Version.CURRENT__        }_        final boolean snapshot_ _        if (snapshot = version.endsWith("-SNAPSHOT")) {_            version = version.substring(0, version.length() - 9)__        }_        String[] parts = version.split("[.-]")__        if (parts.length < 3 || parts.length > 4) {_            throw new IllegalArgumentException(_                    "the version needs to contain major, minor, and revision, and optionally the build: " + version)__        }__        try {_            final int rawMajor = Integer.parseInt(parts[0])__            if (rawMajor >= 5 && snapshot) { _                throw new IllegalArgumentException("illegal version format - snapshots are only supported until version 2.x")__            }_            if (rawMajor >=7 && parts.length == 4) { _                throw new IllegalArgumentException("illegal version format - qualifiers are only supported until version 6.x")__            }_            final int betaOffset = rawMajor < 5 ? 0 : 25__            _            final int major = rawMajor * 1000000__            final int minor = Integer.parseInt(parts[1]) * 10000__            final int revision = Integer.parseInt(parts[2]) * 100____            int build = 99__            if (parts.length == 4) {_                String buildStr = parts[3]__                if (buildStr.startsWith("alpha")) {_                    assert rawMajor >= 5 : "major must be >= 5 but was " + major__                    build = Integer.parseInt(buildStr.substring(5))__                    assert build < 25 : "expected a beta build but " + build + " >= 25"__                } else if (buildStr.startsWith("Beta") || buildStr.startsWith("beta")) {_                    build = betaOffset + Integer.parseInt(buildStr.substring(4))__                    assert build < 50 : "expected a beta build but " + build + " >= 50"__                } else if (buildStr.startsWith("RC") || buildStr.startsWith("rc")) {_                    build = Integer.parseInt(buildStr.substring(2)) + 50__                } else {_                    throw new IllegalArgumentException("unable to parse version " + version)__                }_            }__            return fromId(major + minor + revision + build)___        } catch (NumberFormatException e) {_            throw new IllegalArgumentException("unable to parse version " + version, e)__        }_    };returns,the,version,given,its,string,representation,current,version,if,the,argument,is,null,or,empty;public,static,version,from,string,string,version,if,strings,has,length,version,return,version,current,final,boolean,snapshot,if,snapshot,version,ends,with,snapshot,version,version,substring,0,version,length,9,string,parts,version,split,if,parts,length,3,parts,length,4,throw,new,illegal,argument,exception,the,version,needs,to,contain,major,minor,and,revision,and,optionally,the,build,version,try,final,int,raw,major,integer,parse,int,parts,0,if,raw,major,5,snapshot,throw,new,illegal,argument,exception,illegal,version,format,snapshots,are,only,supported,until,version,2,x,if,raw,major,7,parts,length,4,throw,new,illegal,argument,exception,illegal,version,format,qualifiers,are,only,supported,until,version,6,x,final,int,beta,offset,raw,major,5,0,25,final,int,major,raw,major,1000000,final,int,minor,integer,parse,int,parts,1,10000,final,int,revision,integer,parse,int,parts,2,100,int,build,99,if,parts,length,4,string,build,str,parts,3,if,build,str,starts,with,alpha,assert,raw,major,5,major,must,be,5,but,was,major,build,integer,parse,int,build,str,substring,5,assert,build,25,expected,a,beta,build,but,build,25,else,if,build,str,starts,with,beta,build,str,starts,with,beta,build,beta,offset,integer,parse,int,build,str,substring,4,assert,build,50,expected,a,beta,build,but,build,50,else,if,build,str,starts,with,rc,build,str,starts,with,rc,build,integer,parse,int,build,str,substring,2,50,else,throw,new,illegal,argument,exception,unable,to,parse,version,version,return,from,id,major,minor,revision,build,catch,number,format,exception,e,throw,new,illegal,argument,exception,unable,to,parse,version,version,e
Version -> public boolean isCompatible(Version version);1524684173;Returns <code>true</code> iff both version are compatible. Otherwise <code>false</code>;public boolean isCompatible(Version version) {_        boolean compatible = onOrAfter(version.minimumCompatibilityVersion())_            && version.onOrAfter(minimumCompatibilityVersion())___        assert compatible == false || Math.max(major, version.major) - Math.min(major, version.major) <= 1__        return compatible__    };returns,code,true,code,iff,both,version,are,compatible,otherwise,code,false,code;public,boolean,is,compatible,version,version,boolean,compatible,on,or,after,version,minimum,compatibility,version,version,on,or,after,minimum,compatibility,version,assert,compatible,false,math,max,major,version,major,math,min,major,version,major,1,return,compatible
Version -> public boolean isCompatible(Version version);1525645056;Returns <code>true</code> iff both version are compatible. Otherwise <code>false</code>;public boolean isCompatible(Version version) {_        boolean compatible = onOrAfter(version.minimumCompatibilityVersion())_            && version.onOrAfter(minimumCompatibilityVersion())___        assert compatible == false || Math.max(major, version.major) - Math.min(major, version.major) <= 1__        return compatible__    };returns,code,true,code,iff,both,version,are,compatible,otherwise,code,false,code;public,boolean,is,compatible,version,version,boolean,compatible,on,or,after,version,minimum,compatibility,version,version,on,or,after,minimum,compatibility,version,assert,compatible,false,math,max,major,version,major,math,min,major,version,major,1,return,compatible
Version -> public boolean isCompatible(Version version);1526900724;Returns <code>true</code> iff both version are compatible. Otherwise <code>false</code>;public boolean isCompatible(Version version) {_        boolean compatible = onOrAfter(version.minimumCompatibilityVersion())_            && version.onOrAfter(minimumCompatibilityVersion())___        assert compatible == false || Math.max(major, version.major) - Math.min(major, version.major) <= 1__        return compatible__    };returns,code,true,code,iff,both,version,are,compatible,otherwise,code,false,code;public,boolean,is,compatible,version,version,boolean,compatible,on,or,after,version,minimum,compatibility,version,version,on,or,after,minimum,compatibility,version,assert,compatible,false,math,max,major,version,major,math,min,major,version,major,1,return,compatible
Version -> public boolean isCompatible(Version version);1528917185;Returns <code>true</code> iff both version are compatible. Otherwise <code>false</code>;public boolean isCompatible(Version version) {_        boolean compatible = onOrAfter(version.minimumCompatibilityVersion())_            && version.onOrAfter(minimumCompatibilityVersion())___        assert compatible == false || Math.max(major, version.major) - Math.min(major, version.major) <= 1__        return compatible__    };returns,code,true,code,iff,both,version,are,compatible,otherwise,code,false,code;public,boolean,is,compatible,version,version,boolean,compatible,on,or,after,version,minimum,compatibility,version,version,on,or,after,minimum,compatibility,version,assert,compatible,false,math,max,major,version,major,math,min,major,version,major,1,return,compatible
Version -> public boolean isCompatible(Version version);1528924528;Returns <code>true</code> iff both version are compatible. Otherwise <code>false</code>;public boolean isCompatible(Version version) {_        boolean compatible = onOrAfter(version.minimumCompatibilityVersion())_            && version.onOrAfter(minimumCompatibilityVersion())___        assert compatible == false || Math.max(major, version.major) - Math.min(major, version.major) <= 1__        return compatible__    };returns,code,true,code,iff,both,version,are,compatible,otherwise,code,false,code;public,boolean,is,compatible,version,version,boolean,compatible,on,or,after,version,minimum,compatibility,version,version,on,or,after,minimum,compatibility,version,assert,compatible,false,math,max,major,version,major,math,min,major,version,major,1,return,compatible
Version -> public boolean isCompatible(Version version);1531179852;Returns <code>true</code> iff both version are compatible. Otherwise <code>false</code>;public boolean isCompatible(Version version) {_        boolean compatible = onOrAfter(version.minimumCompatibilityVersion())_            && version.onOrAfter(minimumCompatibilityVersion())___        assert compatible == false || Math.max(major, version.major) - Math.min(major, version.major) <= 1__        return compatible__    };returns,code,true,code,iff,both,version,are,compatible,otherwise,code,false,code;public,boolean,is,compatible,version,version,boolean,compatible,on,or,after,version,minimum,compatibility,version,version,on,or,after,minimum,compatibility,version,assert,compatible,false,math,max,major,version,major,math,min,major,version,major,1,return,compatible
Version -> public boolean isCompatible(Version version);1532511554;Returns <code>true</code> iff both version are compatible. Otherwise <code>false</code>;public boolean isCompatible(Version version) {_        boolean compatible = onOrAfter(version.minimumCompatibilityVersion())_            && version.onOrAfter(minimumCompatibilityVersion())___        assert compatible == false || Math.max(major, version.major) - Math.min(major, version.major) <= 1__        return compatible__    };returns,code,true,code,iff,both,version,are,compatible,otherwise,code,false,code;public,boolean,is,compatible,version,version,boolean,compatible,on,or,after,version,minimum,compatibility,version,version,on,or,after,minimum,compatibility,version,assert,compatible,false,math,max,major,version,major,math,min,major,version,major,1,return,compatible
Version -> public boolean isCompatible(Version version);1532534495;Returns <code>true</code> iff both version are compatible. Otherwise <code>false</code>;public boolean isCompatible(Version version) {_        boolean compatible = onOrAfter(version.minimumCompatibilityVersion())_            && version.onOrAfter(minimumCompatibilityVersion())___        assert compatible == false || Math.max(major, version.major) - Math.min(major, version.major) <= 1__        return compatible__    };returns,code,true,code,iff,both,version,are,compatible,otherwise,code,false,code;public,boolean,is,compatible,version,version,boolean,compatible,on,or,after,version,minimum,compatibility,version,version,on,or,after,minimum,compatibility,version,assert,compatible,false,math,max,major,version,major,math,min,major,version,major,1,return,compatible
Version -> public boolean isCompatible(Version version);1532685069;Returns <code>true</code> iff both version are compatible. Otherwise <code>false</code>;public boolean isCompatible(Version version) {_        boolean compatible = onOrAfter(version.minimumCompatibilityVersion())_            && version.onOrAfter(minimumCompatibilityVersion())___        assert compatible == false || Math.max(major, version.major) - Math.min(major, version.major) <= 1__        return compatible__    };returns,code,true,code,iff,both,version,are,compatible,otherwise,code,false,code;public,boolean,is,compatible,version,version,boolean,compatible,on,or,after,version,minimum,compatibility,version,version,on,or,after,minimum,compatibility,version,assert,compatible,false,math,max,major,version,major,math,min,major,version,major,1,return,compatible
Version -> public boolean isCompatible(Version version);1535057785;Returns <code>true</code> iff both version are compatible. Otherwise <code>false</code>;public boolean isCompatible(Version version) {_        boolean compatible = onOrAfter(version.minimumCompatibilityVersion())_            && version.onOrAfter(minimumCompatibilityVersion())___        assert compatible == false || Math.max(major, version.major) - Math.min(major, version.major) <= 1__        return compatible__    };returns,code,true,code,iff,both,version,are,compatible,otherwise,code,false,code;public,boolean,is,compatible,version,version,boolean,compatible,on,or,after,version,minimum,compatibility,version,version,on,or,after,minimum,compatibility,version,assert,compatible,false,math,max,major,version,major,math,min,major,version,major,1,return,compatible
Version -> public boolean isCompatible(Version version);1535139672;Returns <code>true</code> iff both version are compatible. Otherwise <code>false</code>;public boolean isCompatible(Version version) {_        boolean compatible = onOrAfter(version.minimumCompatibilityVersion())_            && version.onOrAfter(minimumCompatibilityVersion())___        assert compatible == false || Math.max(major, version.major) - Math.min(major, version.major) <= 1__        return compatible__    };returns,code,true,code,iff,both,version,are,compatible,otherwise,code,false,code;public,boolean,is,compatible,version,version,boolean,compatible,on,or,after,version,minimum,compatibility,version,version,on,or,after,minimum,compatibility,version,assert,compatible,false,math,max,major,version,major,math,min,major,version,major,1,return,compatible
Version -> public boolean isCompatible(Version version);1536137328;Returns <code>true</code> iff both version are compatible. Otherwise <code>false</code>;public boolean isCompatible(Version version) {_        boolean compatible = onOrAfter(version.minimumCompatibilityVersion())_            && version.onOrAfter(minimumCompatibilityVersion())___        assert compatible == false || Math.max(major, version.major) - Math.min(major, version.major) <= 1__        return compatible__    };returns,code,true,code,iff,both,version,are,compatible,otherwise,code,false,code;public,boolean,is,compatible,version,version,boolean,compatible,on,or,after,version,minimum,compatibility,version,version,on,or,after,minimum,compatibility,version,assert,compatible,false,math,max,major,version,major,math,min,major,version,major,1,return,compatible
Version -> public boolean isCompatible(Version version);1536314350;Returns <code>true</code> iff both version are compatible. Otherwise <code>false</code>;public boolean isCompatible(Version version) {_        boolean compatible = onOrAfter(version.minimumCompatibilityVersion())_            && version.onOrAfter(minimumCompatibilityVersion())___        assert compatible == false || Math.max(major, version.major) - Math.min(major, version.major) <= 1__        return compatible__    };returns,code,true,code,iff,both,version,are,compatible,otherwise,code,false,code;public,boolean,is,compatible,version,version,boolean,compatible,on,or,after,version,minimum,compatibility,version,version,on,or,after,minimum,compatibility,version,assert,compatible,false,math,max,major,version,major,math,min,major,version,major,1,return,compatible
Version -> public boolean isCompatible(Version version);1537300661;Returns <code>true</code> iff both version are compatible. Otherwise <code>false</code>;public boolean isCompatible(Version version) {_        boolean compatible = onOrAfter(version.minimumCompatibilityVersion())_            && version.onOrAfter(minimumCompatibilityVersion())___        assert compatible == false || Math.max(major, version.major) - Math.min(major, version.major) <= 1__        return compatible__    };returns,code,true,code,iff,both,version,are,compatible,otherwise,code,false,code;public,boolean,is,compatible,version,version,boolean,compatible,on,or,after,version,minimum,compatibility,version,version,on,or,after,minimum,compatibility,version,assert,compatible,false,math,max,major,version,major,math,min,major,version,major,1,return,compatible
Version -> public boolean isCompatible(Version version);1538509426;Returns <code>true</code> iff both version are compatible. Otherwise <code>false</code>;public boolean isCompatible(Version version) {_        boolean compatible = onOrAfter(version.minimumCompatibilityVersion())_            && version.onOrAfter(minimumCompatibilityVersion())___        assert compatible == false || Math.max(major, version.major) - Math.min(major, version.major) <= 1__        return compatible__    };returns,code,true,code,iff,both,version,are,compatible,otherwise,code,false,code;public,boolean,is,compatible,version,version,boolean,compatible,on,or,after,version,minimum,compatibility,version,version,on,or,after,minimum,compatibility,version,assert,compatible,false,math,max,major,version,major,math,min,major,version,major,1,return,compatible
Version -> public boolean isCompatible(Version version);1540486836;Returns <code>true</code> iff both version are compatible. Otherwise <code>false</code>;public boolean isCompatible(Version version) {_        boolean compatible = onOrAfter(version.minimumCompatibilityVersion())_            && version.onOrAfter(minimumCompatibilityVersion())___        assert compatible == false || Math.max(major, version.major) - Math.min(major, version.major) <= 1__        return compatible__    };returns,code,true,code,iff,both,version,are,compatible,otherwise,code,false,code;public,boolean,is,compatible,version,version,boolean,compatible,on,or,after,version,minimum,compatibility,version,version,on,or,after,minimum,compatibility,version,assert,compatible,false,math,max,major,version,major,math,min,major,version,major,1,return,compatible
Version -> public boolean isCompatible(Version version);1541502933;Returns <code>true</code> iff both version are compatible. Otherwise <code>false</code>;public boolean isCompatible(Version version) {_        boolean compatible = onOrAfter(version.minimumCompatibilityVersion())_            && version.onOrAfter(minimumCompatibilityVersion())___        assert compatible == false || Math.max(major, version.major) - Math.min(major, version.major) <= 1__        return compatible__    };returns,code,true,code,iff,both,version,are,compatible,otherwise,code,false,code;public,boolean,is,compatible,version,version,boolean,compatible,on,or,after,version,minimum,compatibility,version,version,on,or,after,minimum,compatibility,version,assert,compatible,false,math,max,major,version,major,math,min,major,version,major,1,return,compatible
Version -> public boolean isCompatible(Version version);1541528420;Returns <code>true</code> iff both version are compatible. Otherwise <code>false</code>;public boolean isCompatible(Version version) {_        boolean compatible = onOrAfter(version.minimumCompatibilityVersion())_            && version.onOrAfter(minimumCompatibilityVersion())___        assert compatible == false || Math.max(major, version.major) - Math.min(major, version.major) <= 1__        return compatible__    };returns,code,true,code,iff,both,version,are,compatible,otherwise,code,false,code;public,boolean,is,compatible,version,version,boolean,compatible,on,or,after,version,minimum,compatibility,version,version,on,or,after,minimum,compatibility,version,assert,compatible,false,math,max,major,version,major,math,min,major,version,major,1,return,compatible
Version -> public boolean isCompatible(Version version);1541592065;Returns <code>true</code> iff both version are compatible. Otherwise <code>false</code>;public boolean isCompatible(Version version) {_        boolean compatible = onOrAfter(version.minimumCompatibilityVersion())_            && version.onOrAfter(minimumCompatibilityVersion())___        assert compatible == false || Math.max(major, version.major) - Math.min(major, version.major) <= 1__        return compatible__    };returns,code,true,code,iff,both,version,are,compatible,otherwise,code,false,code;public,boolean,is,compatible,version,version,boolean,compatible,on,or,after,version,minimum,compatibility,version,version,on,or,after,minimum,compatibility,version,assert,compatible,false,math,max,major,version,major,math,min,major,version,major,1,return,compatible
Version -> public boolean isCompatible(Version version);1542226101;Returns <code>true</code> iff both version are compatible. Otherwise <code>false</code>;public boolean isCompatible(Version version) {_        boolean compatible = onOrAfter(version.minimumCompatibilityVersion())_            && version.onOrAfter(minimumCompatibilityVersion())___        assert compatible == false || Math.max(major, version.major) - Math.min(major, version.major) <= 1__        return compatible__    };returns,code,true,code,iff,both,version,are,compatible,otherwise,code,false,code;public,boolean,is,compatible,version,version,boolean,compatible,on,or,after,version,minimum,compatibility,version,version,on,or,after,minimum,compatibility,version,assert,compatible,false,math,max,major,version,major,math,min,major,version,major,1,return,compatible
Version -> public boolean isCompatible(Version version);1542746006;Returns <code>true</code> iff both version are compatible. Otherwise <code>false</code>;public boolean isCompatible(Version version) {_        boolean compatible = onOrAfter(version.minimumCompatibilityVersion())_            && version.onOrAfter(minimumCompatibilityVersion())___        assert compatible == false || Math.max(major, version.major) - Math.min(major, version.major) <= 1__        return compatible__    };returns,code,true,code,iff,both,version,are,compatible,otherwise,code,false,code;public,boolean,is,compatible,version,version,boolean,compatible,on,or,after,version,minimum,compatibility,version,version,on,or,after,minimum,compatibility,version,assert,compatible,false,math,max,major,version,major,math,min,major,version,major,1,return,compatible
Version -> public boolean isCompatible(Version version);1543473699;Returns <code>true</code> iff both version are compatible. Otherwise <code>false</code>;public boolean isCompatible(Version version) {_        boolean compatible = onOrAfter(version.minimumCompatibilityVersion())_            && version.onOrAfter(minimumCompatibilityVersion())___        assert compatible == false || Math.max(major, version.major) - Math.min(major, version.major) <= 1__        return compatible__    };returns,code,true,code,iff,both,version,are,compatible,otherwise,code,false,code;public,boolean,is,compatible,version,version,boolean,compatible,on,or,after,version,minimum,compatibility,version,version,on,or,after,minimum,compatibility,version,assert,compatible,false,math,max,major,version,major,math,min,major,version,major,1,return,compatible
Version -> public boolean isCompatible(Version version);1543942400;Returns <code>true</code> iff both version are compatible. Otherwise <code>false</code>;public boolean isCompatible(Version version) {_        boolean compatible = onOrAfter(version.minimumCompatibilityVersion())_            && version.onOrAfter(minimumCompatibilityVersion())___        assert compatible == false || Math.max(major, version.major) - Math.min(major, version.major) <= 1__        return compatible__    };returns,code,true,code,iff,both,version,are,compatible,otherwise,code,false,code;public,boolean,is,compatible,version,version,boolean,compatible,on,or,after,version,minimum,compatibility,version,version,on,or,after,minimum,compatibility,version,assert,compatible,false,math,max,major,version,major,math,min,major,version,major,1,return,compatible
Version -> public boolean isCompatible(Version version);1544037309;Returns <code>true</code> iff both version are compatible. Otherwise <code>false</code>;public boolean isCompatible(Version version) {_        boolean compatible = onOrAfter(version.minimumCompatibilityVersion())_            && version.onOrAfter(minimumCompatibilityVersion())___        assert compatible == false || Math.max(major, version.major) - Math.min(major, version.major) <= 1__        return compatible__    };returns,code,true,code,iff,both,version,are,compatible,otherwise,code,false,code;public,boolean,is,compatible,version,version,boolean,compatible,on,or,after,version,minimum,compatibility,version,version,on,or,after,minimum,compatibility,version,assert,compatible,false,math,max,major,version,major,math,min,major,version,major,1,return,compatible
Version -> public boolean isCompatible(Version version);1544553539;Returns <code>true</code> iff both version are compatible. Otherwise <code>false</code>;public boolean isCompatible(Version version) {_        boolean compatible = onOrAfter(version.minimumCompatibilityVersion())_            && version.onOrAfter(minimumCompatibilityVersion())___        assert compatible == false || Math.max(major, version.major) - Math.min(major, version.major) <= 1__        return compatible__    };returns,code,true,code,iff,both,version,are,compatible,otherwise,code,false,code;public,boolean,is,compatible,version,version,boolean,compatible,on,or,after,version,minimum,compatibility,version,version,on,or,after,minimum,compatibility,version,assert,compatible,false,math,max,major,version,major,math,min,major,version,major,1,return,compatible
Version -> public boolean isCompatible(Version version);1545225850;Returns <code>true</code> iff both version are compatible. Otherwise <code>false</code>;public boolean isCompatible(Version version) {_        boolean compatible = onOrAfter(version.minimumCompatibilityVersion())_            && version.onOrAfter(minimumCompatibilityVersion())___        assert compatible == false || Math.max(major, version.major) - Math.min(major, version.major) <= 1__        return compatible__    };returns,code,true,code,iff,both,version,are,compatible,otherwise,code,false,code;public,boolean,is,compatible,version,version,boolean,compatible,on,or,after,version,minimum,compatibility,version,version,on,or,after,minimum,compatibility,version,assert,compatible,false,math,max,major,version,major,math,min,major,version,major,1,return,compatible
Version -> public boolean isCompatible(Version version);1545256934;Returns <code>true</code> iff both version are compatible. Otherwise <code>false</code>;public boolean isCompatible(Version version) {_        boolean compatible = onOrAfter(version.minimumCompatibilityVersion())_            && version.onOrAfter(minimumCompatibilityVersion())___        assert compatible == false || Math.max(major, version.major) - Math.min(major, version.major) <= 1__        return compatible__    };returns,code,true,code,iff,both,version,are,compatible,otherwise,code,false,code;public,boolean,is,compatible,version,version,boolean,compatible,on,or,after,version,minimum,compatibility,version,version,on,or,after,minimum,compatibility,version,assert,compatible,false,math,max,major,version,major,math,min,major,version,major,1,return,compatible
Version -> public boolean isCompatible(Version version);1546507247;Returns <code>true</code> iff both version are compatible. Otherwise <code>false</code>;public boolean isCompatible(Version version) {_        boolean compatible = onOrAfter(version.minimumCompatibilityVersion())_            && version.onOrAfter(minimumCompatibilityVersion())___        assert compatible == false || Math.max(major, version.major) - Math.min(major, version.major) <= 1__        return compatible__    };returns,code,true,code,iff,both,version,are,compatible,otherwise,code,false,code;public,boolean,is,compatible,version,version,boolean,compatible,on,or,after,version,minimum,compatibility,version,version,on,or,after,minimum,compatibility,version,assert,compatible,false,math,max,major,version,major,math,min,major,version,major,1,return,compatible
Version -> public boolean isCompatible(Version version);1546537951;Returns <code>true</code> iff both version are compatible. Otherwise <code>false</code>;public boolean isCompatible(Version version) {_        boolean compatible = onOrAfter(version.minimumCompatibilityVersion())_            && version.onOrAfter(minimumCompatibilityVersion())___        assert compatible == false || Math.max(major, version.major) - Math.min(major, version.major) <= 1__        return compatible__    };returns,code,true,code,iff,both,version,are,compatible,otherwise,code,false,code;public,boolean,is,compatible,version,version,boolean,compatible,on,or,after,version,minimum,compatibility,version,version,on,or,after,minimum,compatibility,version,assert,compatible,false,math,max,major,version,major,math,min,major,version,major,1,return,compatible
Version -> public boolean isCompatible(Version version);1548755041;Returns <code>true</code> iff both version are compatible. Otherwise <code>false</code>;public boolean isCompatible(Version version) {_        boolean compatible = onOrAfter(version.minimumCompatibilityVersion())_            && version.onOrAfter(minimumCompatibilityVersion())___        assert compatible == false || Math.max(major, version.major) - Math.min(major, version.major) <= 1__        return compatible__    };returns,code,true,code,iff,both,version,are,compatible,otherwise,code,false,code;public,boolean,is,compatible,version,version,boolean,compatible,on,or,after,version,minimum,compatibility,version,version,on,or,after,minimum,compatibility,version,assert,compatible,false,math,max,major,version,major,math,min,major,version,major,1,return,compatible
Version -> public boolean isCompatible(Version version);1548822781;Returns <code>true</code> iff both version are compatible. Otherwise <code>false</code>;public boolean isCompatible(Version version) {_        boolean compatible = onOrAfter(version.minimumCompatibilityVersion())_            && version.onOrAfter(minimumCompatibilityVersion())___        assert compatible == false || Math.max(major, version.major) - Math.min(major, version.major) <= 1__        return compatible__    };returns,code,true,code,iff,both,version,are,compatible,otherwise,code,false,code;public,boolean,is,compatible,version,version,boolean,compatible,on,or,after,version,minimum,compatibility,version,version,on,or,after,minimum,compatibility,version,assert,compatible,false,math,max,major,version,major,math,min,major,version,major,1,return,compatible
Version -> public boolean isCompatible(Version version);1549608646;Returns <code>true</code> iff both version are compatible. Otherwise <code>false</code>;public boolean isCompatible(Version version) {_        boolean compatible = onOrAfter(version.minimumCompatibilityVersion())_            && version.onOrAfter(minimumCompatibilityVersion())___        assert compatible == false || Math.max(major, version.major) - Math.min(major, version.major) <= 1__        return compatible__    };returns,code,true,code,iff,both,version,are,compatible,otherwise,code,false,code;public,boolean,is,compatible,version,version,boolean,compatible,on,or,after,version,minimum,compatibility,version,version,on,or,after,minimum,compatibility,version,assert,compatible,false,math,max,major,version,major,math,min,major,version,major,1,return,compatible
Version -> public boolean isCompatible(Version version);1550604529;Returns <code>true</code> iff both version are compatible. Otherwise <code>false</code>;public boolean isCompatible(Version version) {_        boolean compatible = onOrAfter(version.minimumCompatibilityVersion())_            && version.onOrAfter(minimumCompatibilityVersion())___        assert compatible == false || Math.max(major, version.major) - Math.min(major, version.major) <= 1__        return compatible__    };returns,code,true,code,iff,both,version,are,compatible,otherwise,code,false,code;public,boolean,is,compatible,version,version,boolean,compatible,on,or,after,version,minimum,compatibility,version,version,on,or,after,minimum,compatibility,version,assert,compatible,false,math,max,major,version,major,math,min,major,version,major,1,return,compatible
Version -> public boolean isAlpha();1524684173;Returns true iff this version is an alpha version_Note: This has been introduced in elasticsearch version 5. Previous versions will never_have an alpha version.;public boolean isAlpha() {_        return major < 5 ? false :  build < 25__    };returns,true,iff,this,version,is,an,alpha,version,note,this,has,been,introduced,in,elasticsearch,version,5,previous,versions,will,never,have,an,alpha,version;public,boolean,is,alpha,return,major,5,false,build,25
Version -> public boolean isAlpha();1525645056;Returns true iff this version is an alpha version_Note: This has been introduced in elasticsearch version 5. Previous versions will never_have an alpha version.;public boolean isAlpha() {_        return major < 5 ? false :  build < 25__    };returns,true,iff,this,version,is,an,alpha,version,note,this,has,been,introduced,in,elasticsearch,version,5,previous,versions,will,never,have,an,alpha,version;public,boolean,is,alpha,return,major,5,false,build,25
Version -> public boolean isAlpha();1526900724;Returns true iff this version is an alpha version_Note: This has been introduced in elasticsearch version 5. Previous versions will never_have an alpha version.;public boolean isAlpha() {_        return major < 5 ? false :  build < 25__    };returns,true,iff,this,version,is,an,alpha,version,note,this,has,been,introduced,in,elasticsearch,version,5,previous,versions,will,never,have,an,alpha,version;public,boolean,is,alpha,return,major,5,false,build,25
Version -> public boolean isAlpha();1528917185;Returns true iff this version is an alpha version_Note: This has been introduced in elasticsearch version 5. Previous versions will never_have an alpha version.;public boolean isAlpha() {_        return major < 5 ? false :  build < 25__    };returns,true,iff,this,version,is,an,alpha,version,note,this,has,been,introduced,in,elasticsearch,version,5,previous,versions,will,never,have,an,alpha,version;public,boolean,is,alpha,return,major,5,false,build,25
Version -> public boolean isAlpha();1528924528;Returns true iff this version is an alpha version_Note: This has been introduced in elasticsearch version 5. Previous versions will never_have an alpha version.;public boolean isAlpha() {_        return major < 5 ? false :  build < 25__    };returns,true,iff,this,version,is,an,alpha,version,note,this,has,been,introduced,in,elasticsearch,version,5,previous,versions,will,never,have,an,alpha,version;public,boolean,is,alpha,return,major,5,false,build,25
Version -> public boolean isAlpha();1531179852;Returns true iff this version is an alpha version_Note: This has been introduced in elasticsearch version 5. Previous versions will never_have an alpha version.;public boolean isAlpha() {_        return major < 5 ? false :  build < 25__    };returns,true,iff,this,version,is,an,alpha,version,note,this,has,been,introduced,in,elasticsearch,version,5,previous,versions,will,never,have,an,alpha,version;public,boolean,is,alpha,return,major,5,false,build,25
Version -> public boolean isAlpha();1532511554;Returns true iff this version is an alpha version_Note: This has been introduced in elasticsearch version 5. Previous versions will never_have an alpha version.;public boolean isAlpha() {_        return major < 5 ? false :  build < 25__    };returns,true,iff,this,version,is,an,alpha,version,note,this,has,been,introduced,in,elasticsearch,version,5,previous,versions,will,never,have,an,alpha,version;public,boolean,is,alpha,return,major,5,false,build,25
Version -> public boolean isAlpha();1532534495;Returns true iff this version is an alpha version_Note: This has been introduced in elasticsearch version 5. Previous versions will never_have an alpha version.;public boolean isAlpha() {_        return major < 5 ? false :  build < 25__    };returns,true,iff,this,version,is,an,alpha,version,note,this,has,been,introduced,in,elasticsearch,version,5,previous,versions,will,never,have,an,alpha,version;public,boolean,is,alpha,return,major,5,false,build,25
Version -> public boolean isAlpha();1532685069;Returns true iff this version is an alpha version_Note: This has been introduced in elasticsearch version 5. Previous versions will never_have an alpha version.;public boolean isAlpha() {_        return major < 5 ? false :  build < 25__    };returns,true,iff,this,version,is,an,alpha,version,note,this,has,been,introduced,in,elasticsearch,version,5,previous,versions,will,never,have,an,alpha,version;public,boolean,is,alpha,return,major,5,false,build,25
Version -> public boolean isAlpha();1535057785;Returns true iff this version is an alpha version_Note: This has been introduced in elasticsearch version 5. Previous versions will never_have an alpha version.;public boolean isAlpha() {_        return major < 5 ? false :  build < 25__    };returns,true,iff,this,version,is,an,alpha,version,note,this,has,been,introduced,in,elasticsearch,version,5,previous,versions,will,never,have,an,alpha,version;public,boolean,is,alpha,return,major,5,false,build,25
Version -> public boolean isAlpha();1535139672;Returns true iff this version is an alpha version_Note: This has been introduced in elasticsearch version 5. Previous versions will never_have an alpha version.;public boolean isAlpha() {_        return major < 5 ? false :  build < 25__    };returns,true,iff,this,version,is,an,alpha,version,note,this,has,been,introduced,in,elasticsearch,version,5,previous,versions,will,never,have,an,alpha,version;public,boolean,is,alpha,return,major,5,false,build,25
Version -> public boolean isAlpha();1536137328;Returns true iff this version is an alpha version_Note: This has been introduced in elasticsearch version 5. Previous versions will never_have an alpha version.;public boolean isAlpha() {_        return major < 5 ? false :  build < 25__    };returns,true,iff,this,version,is,an,alpha,version,note,this,has,been,introduced,in,elasticsearch,version,5,previous,versions,will,never,have,an,alpha,version;public,boolean,is,alpha,return,major,5,false,build,25
Version -> public boolean isAlpha();1536314350;Returns true iff this version is an alpha version_Note: This has been introduced in elasticsearch version 5. Previous versions will never_have an alpha version.;public boolean isAlpha() {_        return major < 5 ? false :  build < 25__    };returns,true,iff,this,version,is,an,alpha,version,note,this,has,been,introduced,in,elasticsearch,version,5,previous,versions,will,never,have,an,alpha,version;public,boolean,is,alpha,return,major,5,false,build,25
Version -> public boolean isAlpha();1537300661;Returns true iff this version is an alpha version_Note: This has been introduced in elasticsearch version 5. Previous versions will never_have an alpha version.;public boolean isAlpha() {_        return major < 5 ? false :  build < 25__    };returns,true,iff,this,version,is,an,alpha,version,note,this,has,been,introduced,in,elasticsearch,version,5,previous,versions,will,never,have,an,alpha,version;public,boolean,is,alpha,return,major,5,false,build,25
Version -> public boolean isAlpha();1538509426;Returns true iff this version is an alpha version_Note: This has been introduced in elasticsearch version 5. Previous versions will never_have an alpha version.;public boolean isAlpha() {_        return major < 5 ? false :  build < 25__    };returns,true,iff,this,version,is,an,alpha,version,note,this,has,been,introduced,in,elasticsearch,version,5,previous,versions,will,never,have,an,alpha,version;public,boolean,is,alpha,return,major,5,false,build,25
Version -> public boolean isAlpha();1540486836;Returns true iff this version is an alpha version_Note: This has been introduced in elasticsearch version 5. Previous versions will never_have an alpha version.;public boolean isAlpha() {_        return major < 5 ? false :  build < 25__    };returns,true,iff,this,version,is,an,alpha,version,note,this,has,been,introduced,in,elasticsearch,version,5,previous,versions,will,never,have,an,alpha,version;public,boolean,is,alpha,return,major,5,false,build,25
Version -> public boolean isAlpha();1541502933;Returns true iff this version is an alpha version_Note: This has been introduced in elasticsearch version 5. Previous versions will never_have an alpha version.;public boolean isAlpha() {_        return major < 5 ? false :  build < 25__    };returns,true,iff,this,version,is,an,alpha,version,note,this,has,been,introduced,in,elasticsearch,version,5,previous,versions,will,never,have,an,alpha,version;public,boolean,is,alpha,return,major,5,false,build,25
Version -> public boolean isAlpha();1541528420;Returns true iff this version is an alpha version_Note: This has been introduced in elasticsearch version 5. Previous versions will never_have an alpha version.;public boolean isAlpha() {_        return major < 5 ? false :  build < 25__    };returns,true,iff,this,version,is,an,alpha,version,note,this,has,been,introduced,in,elasticsearch,version,5,previous,versions,will,never,have,an,alpha,version;public,boolean,is,alpha,return,major,5,false,build,25
Version -> public boolean isAlpha();1541592065;Returns true iff this version is an alpha version_Note: This has been introduced in elasticsearch version 5. Previous versions will never_have an alpha version.;public boolean isAlpha() {_        return major < 5 ? false :  build < 25__    };returns,true,iff,this,version,is,an,alpha,version,note,this,has,been,introduced,in,elasticsearch,version,5,previous,versions,will,never,have,an,alpha,version;public,boolean,is,alpha,return,major,5,false,build,25
Version -> public boolean isAlpha();1542226101;Returns true iff this version is an alpha version_Note: This has been introduced in elasticsearch version 5. Previous versions will never_have an alpha version.;public boolean isAlpha() {_        return major < 5 ? false :  build < 25__    };returns,true,iff,this,version,is,an,alpha,version,note,this,has,been,introduced,in,elasticsearch,version,5,previous,versions,will,never,have,an,alpha,version;public,boolean,is,alpha,return,major,5,false,build,25
Version -> public boolean isAlpha();1542746006;Returns true iff this version is an alpha version_Note: This has been introduced in elasticsearch version 5. Previous versions will never_have an alpha version.;public boolean isAlpha() {_        return major < 5 ? false :  build < 25__    };returns,true,iff,this,version,is,an,alpha,version,note,this,has,been,introduced,in,elasticsearch,version,5,previous,versions,will,never,have,an,alpha,version;public,boolean,is,alpha,return,major,5,false,build,25
Version -> public boolean isAlpha();1543473699;Returns true iff this version is an alpha version_Note: This has been introduced in elasticsearch version 5. Previous versions will never_have an alpha version.;public boolean isAlpha() {_        return major < 5 ? false :  build < 25__    };returns,true,iff,this,version,is,an,alpha,version,note,this,has,been,introduced,in,elasticsearch,version,5,previous,versions,will,never,have,an,alpha,version;public,boolean,is,alpha,return,major,5,false,build,25
Version -> public boolean isAlpha();1543942400;Returns true iff this version is an alpha version_Note: This has been introduced in elasticsearch version 5. Previous versions will never_have an alpha version.;public boolean isAlpha() {_        return major < 5 ? false :  build < 25__    };returns,true,iff,this,version,is,an,alpha,version,note,this,has,been,introduced,in,elasticsearch,version,5,previous,versions,will,never,have,an,alpha,version;public,boolean,is,alpha,return,major,5,false,build,25
Version -> public boolean isAlpha();1544037309;Returns true iff this version is an alpha version_Note: This has been introduced in elasticsearch version 5. Previous versions will never_have an alpha version.;public boolean isAlpha() {_        return major < 5 ? false :  build < 25__    };returns,true,iff,this,version,is,an,alpha,version,note,this,has,been,introduced,in,elasticsearch,version,5,previous,versions,will,never,have,an,alpha,version;public,boolean,is,alpha,return,major,5,false,build,25
Version -> public boolean isAlpha();1544553539;Returns true iff this version is an alpha version_Note: This has been introduced in elasticsearch version 5. Previous versions will never_have an alpha version.;public boolean isAlpha() {_        return major < 5 ? false :  build < 25__    };returns,true,iff,this,version,is,an,alpha,version,note,this,has,been,introduced,in,elasticsearch,version,5,previous,versions,will,never,have,an,alpha,version;public,boolean,is,alpha,return,major,5,false,build,25
Version -> public boolean isAlpha();1545225850;Returns true iff this version is an alpha version_Note: This has been introduced in elasticsearch version 5. Previous versions will never_have an alpha version.;public boolean isAlpha() {_        return major < 5 ? false :  build < 25__    };returns,true,iff,this,version,is,an,alpha,version,note,this,has,been,introduced,in,elasticsearch,version,5,previous,versions,will,never,have,an,alpha,version;public,boolean,is,alpha,return,major,5,false,build,25
Version -> public boolean isAlpha();1545256934;Returns true iff this version is an alpha version_Note: This has been introduced in elasticsearch version 5. Previous versions will never_have an alpha version.;public boolean isAlpha() {_        return major < 5 ? false :  build < 25__    };returns,true,iff,this,version,is,an,alpha,version,note,this,has,been,introduced,in,elasticsearch,version,5,previous,versions,will,never,have,an,alpha,version;public,boolean,is,alpha,return,major,5,false,build,25
Version -> public boolean isAlpha();1546507247;Returns true iff this version is an alpha version_Note: This has been introduced in elasticsearch version 5. Previous versions will never_have an alpha version.;public boolean isAlpha() {_        return major < 5 ? false :  build < 25__    };returns,true,iff,this,version,is,an,alpha,version,note,this,has,been,introduced,in,elasticsearch,version,5,previous,versions,will,never,have,an,alpha,version;public,boolean,is,alpha,return,major,5,false,build,25
Version -> public boolean isAlpha();1546537951;Returns true iff this version is an alpha version_Note: This has been introduced in elasticsearch version 5. Previous versions will never_have an alpha version.;public boolean isAlpha() {_        return major < 5 ? false :  build < 25__    };returns,true,iff,this,version,is,an,alpha,version,note,this,has,been,introduced,in,elasticsearch,version,5,previous,versions,will,never,have,an,alpha,version;public,boolean,is,alpha,return,major,5,false,build,25
Version -> public boolean isAlpha();1548755041;Returns true iff this version is an alpha version_Note: This has been introduced in elasticsearch version 5. Previous versions will never_have an alpha version.;public boolean isAlpha() {_        return major < 5 ? false :  build < 25__    };returns,true,iff,this,version,is,an,alpha,version,note,this,has,been,introduced,in,elasticsearch,version,5,previous,versions,will,never,have,an,alpha,version;public,boolean,is,alpha,return,major,5,false,build,25
Version -> public boolean isAlpha();1548822781;Returns true iff this version is an alpha version_Note: This has been introduced in elasticsearch version 5. Previous versions will never_have an alpha version.;public boolean isAlpha() {_        return major < 5 ? false :  build < 25__    };returns,true,iff,this,version,is,an,alpha,version,note,this,has,been,introduced,in,elasticsearch,version,5,previous,versions,will,never,have,an,alpha,version;public,boolean,is,alpha,return,major,5,false,build,25
Version -> public boolean isAlpha();1549608646;Returns true iff this version is an alpha version_Note: This has been introduced in elasticsearch version 5. Previous versions will never_have an alpha version.;public boolean isAlpha() {_        return major < 5 ? false :  build < 25__    };returns,true,iff,this,version,is,an,alpha,version,note,this,has,been,introduced,in,elasticsearch,version,5,previous,versions,will,never,have,an,alpha,version;public,boolean,is,alpha,return,major,5,false,build,25
Version -> public boolean isAlpha();1550604529;Returns true iff this version is an alpha version_Note: This has been introduced in elasticsearch version 5. Previous versions will never_have an alpha version.;public boolean isAlpha() {_        return major < 5 ? false :  build < 25__    };returns,true,iff,this,version,is,an,alpha,version,note,this,has,been,introduced,in,elasticsearch,version,5,previous,versions,will,never,have,an,alpha,version;public,boolean,is,alpha,return,major,5,false,build,25
Version -> public Version minimumCompatibilityVersion();1524684173;Returns the minimum compatible version based on the current_version. Ie a node needs to have at least the return version in order_to communicate with a node running the current version. The returned version_is in most of the cases the smallest major version release unless the current version_is a beta or RC release then the version itself is returned.;public Version minimumCompatibilityVersion() {_        if (major >= 6) {_            _            Version bwcVersion = null___            for (int i = DeclaredVersionsHolder.DECLARED_VERSIONS.size() - 1_ i >= 0_ i--) {_                final Version candidateVersion = DeclaredVersionsHolder.DECLARED_VERSIONS.get(i)__                if (candidateVersion.major == major - 1 && candidateVersion.isRelease() && after(candidateVersion)) {_                    if (bwcVersion != null && candidateVersion.minor < bwcVersion.minor) {_                        break__                    }_                    bwcVersion = candidateVersion__                }_            }_            return bwcVersion == null ? this : bwcVersion__        }__        return Version.min(this, fromId((int) major * 1000000 + 0 * 10000 + 99))__    };returns,the,minimum,compatible,version,based,on,the,current,version,ie,a,node,needs,to,have,at,least,the,return,version,in,order,to,communicate,with,a,node,running,the,current,version,the,returned,version,is,in,most,of,the,cases,the,smallest,major,version,release,unless,the,current,version,is,a,beta,or,rc,release,then,the,version,itself,is,returned;public,version,minimum,compatibility,version,if,major,6,version,bwc,version,null,for,int,i,declared,versions,holder,size,1,i,0,i,final,version,candidate,version,declared,versions,holder,get,i,if,candidate,version,major,major,1,candidate,version,is,release,after,candidate,version,if,bwc,version,null,candidate,version,minor,bwc,version,minor,break,bwc,version,candidate,version,return,bwc,version,null,this,bwc,version,return,version,min,this,from,id,int,major,1000000,0,10000,99
Version -> public Version minimumCompatibilityVersion();1525645056;Returns the minimum compatible version based on the current_version. Ie a node needs to have at least the return version in order_to communicate with a node running the current version. The returned version_is in most of the cases the smallest major version release unless the current version_is a beta or RC release then the version itself is returned.;public Version minimumCompatibilityVersion() {_        if (major >= 6) {_            _            Version bwcVersion = null___            for (int i = DeclaredVersionsHolder.DECLARED_VERSIONS.size() - 1_ i >= 0_ i--) {_                final Version candidateVersion = DeclaredVersionsHolder.DECLARED_VERSIONS.get(i)__                if (candidateVersion.major == major - 1 && candidateVersion.isRelease() && after(candidateVersion)) {_                    if (bwcVersion != null && candidateVersion.minor < bwcVersion.minor) {_                        break__                    }_                    bwcVersion = candidateVersion__                }_            }_            return bwcVersion == null ? this : bwcVersion__        }__        return Version.min(this, fromId((int) major * 1000000 + 0 * 10000 + 99))__    };returns,the,minimum,compatible,version,based,on,the,current,version,ie,a,node,needs,to,have,at,least,the,return,version,in,order,to,communicate,with,a,node,running,the,current,version,the,returned,version,is,in,most,of,the,cases,the,smallest,major,version,release,unless,the,current,version,is,a,beta,or,rc,release,then,the,version,itself,is,returned;public,version,minimum,compatibility,version,if,major,6,version,bwc,version,null,for,int,i,declared,versions,holder,size,1,i,0,i,final,version,candidate,version,declared,versions,holder,get,i,if,candidate,version,major,major,1,candidate,version,is,release,after,candidate,version,if,bwc,version,null,candidate,version,minor,bwc,version,minor,break,bwc,version,candidate,version,return,bwc,version,null,this,bwc,version,return,version,min,this,from,id,int,major,1000000,0,10000,99
Version -> public Version minimumCompatibilityVersion();1526900724;Returns the minimum compatible version based on the current_version. Ie a node needs to have at least the return version in order_to communicate with a node running the current version. The returned version_is in most of the cases the smallest major version release unless the current version_is a beta or RC release then the version itself is returned.;public Version minimumCompatibilityVersion() {_        if (major >= 6) {_            _            Version bwcVersion = null___            for (int i = DeclaredVersionsHolder.DECLARED_VERSIONS.size() - 1_ i >= 0_ i--) {_                final Version candidateVersion = DeclaredVersionsHolder.DECLARED_VERSIONS.get(i)__                if (candidateVersion.major == major - 1 && candidateVersion.isRelease() && after(candidateVersion)) {_                    if (bwcVersion != null && candidateVersion.minor < bwcVersion.minor) {_                        break__                    }_                    bwcVersion = candidateVersion__                }_            }_            return bwcVersion == null ? this : bwcVersion__        }__        return Version.min(this, fromId((int) major * 1000000 + 0 * 10000 + 99))__    };returns,the,minimum,compatible,version,based,on,the,current,version,ie,a,node,needs,to,have,at,least,the,return,version,in,order,to,communicate,with,a,node,running,the,current,version,the,returned,version,is,in,most,of,the,cases,the,smallest,major,version,release,unless,the,current,version,is,a,beta,or,rc,release,then,the,version,itself,is,returned;public,version,minimum,compatibility,version,if,major,6,version,bwc,version,null,for,int,i,declared,versions,holder,size,1,i,0,i,final,version,candidate,version,declared,versions,holder,get,i,if,candidate,version,major,major,1,candidate,version,is,release,after,candidate,version,if,bwc,version,null,candidate,version,minor,bwc,version,minor,break,bwc,version,candidate,version,return,bwc,version,null,this,bwc,version,return,version,min,this,from,id,int,major,1000000,0,10000,99
Version -> public Version minimumCompatibilityVersion();1528917185;Returns the minimum compatible version based on the current_version. Ie a node needs to have at least the return version in order_to communicate with a node running the current version. The returned version_is in most of the cases the smallest major version release unless the current version_is a beta or RC release then the version itself is returned.;public Version minimumCompatibilityVersion() {_        if (major >= 6) {_            _            Version bwcVersion = null___            for (int i = DeclaredVersionsHolder.DECLARED_VERSIONS.size() - 1_ i >= 0_ i--) {_                final Version candidateVersion = DeclaredVersionsHolder.DECLARED_VERSIONS.get(i)__                if (candidateVersion.major == major - 1 && candidateVersion.isRelease() && after(candidateVersion)) {_                    if (bwcVersion != null && candidateVersion.minor < bwcVersion.minor) {_                        break__                    }_                    bwcVersion = candidateVersion__                }_            }_            return bwcVersion == null ? this : bwcVersion__        }__        return Version.min(this, fromId((int) major * 1000000 + 0 * 10000 + 99))__    };returns,the,minimum,compatible,version,based,on,the,current,version,ie,a,node,needs,to,have,at,least,the,return,version,in,order,to,communicate,with,a,node,running,the,current,version,the,returned,version,is,in,most,of,the,cases,the,smallest,major,version,release,unless,the,current,version,is,a,beta,or,rc,release,then,the,version,itself,is,returned;public,version,minimum,compatibility,version,if,major,6,version,bwc,version,null,for,int,i,declared,versions,holder,size,1,i,0,i,final,version,candidate,version,declared,versions,holder,get,i,if,candidate,version,major,major,1,candidate,version,is,release,after,candidate,version,if,bwc,version,null,candidate,version,minor,bwc,version,minor,break,bwc,version,candidate,version,return,bwc,version,null,this,bwc,version,return,version,min,this,from,id,int,major,1000000,0,10000,99
Version -> public Version minimumCompatibilityVersion();1528924528;Returns the minimum compatible version based on the current_version. Ie a node needs to have at least the return version in order_to communicate with a node running the current version. The returned version_is in most of the cases the smallest major version release unless the current version_is a beta or RC release then the version itself is returned.;public Version minimumCompatibilityVersion() {_        if (major >= 6) {_            _            Version bwcVersion = null___            for (int i = DeclaredVersionsHolder.DECLARED_VERSIONS.size() - 1_ i >= 0_ i--) {_                final Version candidateVersion = DeclaredVersionsHolder.DECLARED_VERSIONS.get(i)__                if (candidateVersion.major == major - 1 && candidateVersion.isRelease() && after(candidateVersion)) {_                    if (bwcVersion != null && candidateVersion.minor < bwcVersion.minor) {_                        break__                    }_                    bwcVersion = candidateVersion__                }_            }_            return bwcVersion == null ? this : bwcVersion__        }__        return Version.min(this, fromId((int) major * 1000000 + 0 * 10000 + 99))__    };returns,the,minimum,compatible,version,based,on,the,current,version,ie,a,node,needs,to,have,at,least,the,return,version,in,order,to,communicate,with,a,node,running,the,current,version,the,returned,version,is,in,most,of,the,cases,the,smallest,major,version,release,unless,the,current,version,is,a,beta,or,rc,release,then,the,version,itself,is,returned;public,version,minimum,compatibility,version,if,major,6,version,bwc,version,null,for,int,i,declared,versions,holder,size,1,i,0,i,final,version,candidate,version,declared,versions,holder,get,i,if,candidate,version,major,major,1,candidate,version,is,release,after,candidate,version,if,bwc,version,null,candidate,version,minor,bwc,version,minor,break,bwc,version,candidate,version,return,bwc,version,null,this,bwc,version,return,version,min,this,from,id,int,major,1000000,0,10000,99
Version -> public Version minimumCompatibilityVersion();1531179852;Returns the minimum compatible version based on the current_version. Ie a node needs to have at least the return version in order_to communicate with a node running the current version. The returned version_is in most of the cases the smallest major version release unless the current version_is a beta or RC release then the version itself is returned.;public Version minimumCompatibilityVersion() {_        if (major >= 6) {_            _            Version bwcVersion = null___            for (int i = DeclaredVersionsHolder.DECLARED_VERSIONS.size() - 1_ i >= 0_ i--) {_                final Version candidateVersion = DeclaredVersionsHolder.DECLARED_VERSIONS.get(i)__                if (candidateVersion.major == major - 1 && candidateVersion.isRelease() && after(candidateVersion)) {_                    if (bwcVersion != null && candidateVersion.minor < bwcVersion.minor) {_                        break__                    }_                    bwcVersion = candidateVersion__                }_            }_            return bwcVersion == null ? this : bwcVersion__        }__        return Version.min(this, fromId((int) major * 1000000 + 0 * 10000 + 99))__    };returns,the,minimum,compatible,version,based,on,the,current,version,ie,a,node,needs,to,have,at,least,the,return,version,in,order,to,communicate,with,a,node,running,the,current,version,the,returned,version,is,in,most,of,the,cases,the,smallest,major,version,release,unless,the,current,version,is,a,beta,or,rc,release,then,the,version,itself,is,returned;public,version,minimum,compatibility,version,if,major,6,version,bwc,version,null,for,int,i,declared,versions,holder,size,1,i,0,i,final,version,candidate,version,declared,versions,holder,get,i,if,candidate,version,major,major,1,candidate,version,is,release,after,candidate,version,if,bwc,version,null,candidate,version,minor,bwc,version,minor,break,bwc,version,candidate,version,return,bwc,version,null,this,bwc,version,return,version,min,this,from,id,int,major,1000000,0,10000,99
Version -> public Version minimumCompatibilityVersion();1532511554;Returns the minimum compatible version based on the current_version. Ie a node needs to have at least the return version in order_to communicate with a node running the current version. The returned version_is in most of the cases the smallest major version release unless the current version_is a beta or RC release then the version itself is returned.;public Version minimumCompatibilityVersion() {_        if (major >= 6) {_            _            Version bwcVersion = null___            for (int i = DeclaredVersionsHolder.DECLARED_VERSIONS.size() - 1_ i >= 0_ i--) {_                final Version candidateVersion = DeclaredVersionsHolder.DECLARED_VERSIONS.get(i)__                if (candidateVersion.major == major - 1 && candidateVersion.isRelease() && after(candidateVersion)) {_                    if (bwcVersion != null && candidateVersion.minor < bwcVersion.minor) {_                        break__                    }_                    bwcVersion = candidateVersion__                }_            }_            return bwcVersion == null ? this : bwcVersion__        }__        return Version.min(this, fromId((int) major * 1000000 + 0 * 10000 + 99))__    };returns,the,minimum,compatible,version,based,on,the,current,version,ie,a,node,needs,to,have,at,least,the,return,version,in,order,to,communicate,with,a,node,running,the,current,version,the,returned,version,is,in,most,of,the,cases,the,smallest,major,version,release,unless,the,current,version,is,a,beta,or,rc,release,then,the,version,itself,is,returned;public,version,minimum,compatibility,version,if,major,6,version,bwc,version,null,for,int,i,declared,versions,holder,size,1,i,0,i,final,version,candidate,version,declared,versions,holder,get,i,if,candidate,version,major,major,1,candidate,version,is,release,after,candidate,version,if,bwc,version,null,candidate,version,minor,bwc,version,minor,break,bwc,version,candidate,version,return,bwc,version,null,this,bwc,version,return,version,min,this,from,id,int,major,1000000,0,10000,99
Version -> public Version minimumCompatibilityVersion();1532534495;Returns the minimum compatible version based on the current_version. Ie a node needs to have at least the return version in order_to communicate with a node running the current version. The returned version_is in most of the cases the smallest major version release unless the current version_is a beta or RC release then the version itself is returned.;public Version minimumCompatibilityVersion() {_        if (major >= 6) {_            _            Version bwcVersion = null___            for (int i = DeclaredVersionsHolder.DECLARED_VERSIONS.size() - 1_ i >= 0_ i--) {_                final Version candidateVersion = DeclaredVersionsHolder.DECLARED_VERSIONS.get(i)__                if (candidateVersion.major == major - 1 && candidateVersion.isRelease() && after(candidateVersion)) {_                    if (bwcVersion != null && candidateVersion.minor < bwcVersion.minor) {_                        break__                    }_                    bwcVersion = candidateVersion__                }_            }_            return bwcVersion == null ? this : bwcVersion__        }__        return Version.min(this, fromId((int) major * 1000000 + 0 * 10000 + 99))__    };returns,the,minimum,compatible,version,based,on,the,current,version,ie,a,node,needs,to,have,at,least,the,return,version,in,order,to,communicate,with,a,node,running,the,current,version,the,returned,version,is,in,most,of,the,cases,the,smallest,major,version,release,unless,the,current,version,is,a,beta,or,rc,release,then,the,version,itself,is,returned;public,version,minimum,compatibility,version,if,major,6,version,bwc,version,null,for,int,i,declared,versions,holder,size,1,i,0,i,final,version,candidate,version,declared,versions,holder,get,i,if,candidate,version,major,major,1,candidate,version,is,release,after,candidate,version,if,bwc,version,null,candidate,version,minor,bwc,version,minor,break,bwc,version,candidate,version,return,bwc,version,null,this,bwc,version,return,version,min,this,from,id,int,major,1000000,0,10000,99
Version -> public Version minimumCompatibilityVersion();1532685069;Returns the minimum compatible version based on the current_version. Ie a node needs to have at least the return version in order_to communicate with a node running the current version. The returned version_is in most of the cases the smallest major version release unless the current version_is a beta or RC release then the version itself is returned.;public Version minimumCompatibilityVersion() {_        if (major >= 6) {_            _            Version bwcVersion = null___            for (int i = DeclaredVersionsHolder.DECLARED_VERSIONS.size() - 1_ i >= 0_ i--) {_                final Version candidateVersion = DeclaredVersionsHolder.DECLARED_VERSIONS.get(i)__                if (candidateVersion.major == major - 1 && candidateVersion.isRelease() && after(candidateVersion)) {_                    if (bwcVersion != null && candidateVersion.minor < bwcVersion.minor) {_                        break__                    }_                    bwcVersion = candidateVersion__                }_            }_            return bwcVersion == null ? this : bwcVersion__        }__        return Version.min(this, fromId((int) major * 1000000 + 0 * 10000 + 99))__    };returns,the,minimum,compatible,version,based,on,the,current,version,ie,a,node,needs,to,have,at,least,the,return,version,in,order,to,communicate,with,a,node,running,the,current,version,the,returned,version,is,in,most,of,the,cases,the,smallest,major,version,release,unless,the,current,version,is,a,beta,or,rc,release,then,the,version,itself,is,returned;public,version,minimum,compatibility,version,if,major,6,version,bwc,version,null,for,int,i,declared,versions,holder,size,1,i,0,i,final,version,candidate,version,declared,versions,holder,get,i,if,candidate,version,major,major,1,candidate,version,is,release,after,candidate,version,if,bwc,version,null,candidate,version,minor,bwc,version,minor,break,bwc,version,candidate,version,return,bwc,version,null,this,bwc,version,return,version,min,this,from,id,int,major,1000000,0,10000,99
Version -> public Version minimumCompatibilityVersion();1535057785;Returns the minimum compatible version based on the current_version. Ie a node needs to have at least the return version in order_to communicate with a node running the current version. The returned version_is in most of the cases the smallest major version release unless the current version_is a beta or RC release then the version itself is returned.;public Version minimumCompatibilityVersion() {_        if (major >= 6) {_            _            Version bwcVersion = null___            for (int i = DeclaredVersionsHolder.DECLARED_VERSIONS.size() - 1_ i >= 0_ i--) {_                final Version candidateVersion = DeclaredVersionsHolder.DECLARED_VERSIONS.get(i)__                if (candidateVersion.major == major - 1 && candidateVersion.isRelease() && after(candidateVersion)) {_                    if (bwcVersion != null && candidateVersion.minor < bwcVersion.minor) {_                        break__                    }_                    bwcVersion = candidateVersion__                }_            }_            return bwcVersion == null ? this : bwcVersion__        }__        return Version.min(this, fromId((int) major * 1000000 + 0 * 10000 + 99))__    };returns,the,minimum,compatible,version,based,on,the,current,version,ie,a,node,needs,to,have,at,least,the,return,version,in,order,to,communicate,with,a,node,running,the,current,version,the,returned,version,is,in,most,of,the,cases,the,smallest,major,version,release,unless,the,current,version,is,a,beta,or,rc,release,then,the,version,itself,is,returned;public,version,minimum,compatibility,version,if,major,6,version,bwc,version,null,for,int,i,declared,versions,holder,size,1,i,0,i,final,version,candidate,version,declared,versions,holder,get,i,if,candidate,version,major,major,1,candidate,version,is,release,after,candidate,version,if,bwc,version,null,candidate,version,minor,bwc,version,minor,break,bwc,version,candidate,version,return,bwc,version,null,this,bwc,version,return,version,min,this,from,id,int,major,1000000,0,10000,99
Version -> public Version minimumCompatibilityVersion();1535139672;Returns the minimum compatible version based on the current_version. Ie a node needs to have at least the return version in order_to communicate with a node running the current version. The returned version_is in most of the cases the smallest major version release unless the current version_is a beta or RC release then the version itself is returned.;public Version minimumCompatibilityVersion() {_        if (major == 6) {_            _            return Version.fromId(5060099)__        } else if (major >= 7) {_            _            Version bwcVersion = null___            for (int i = DeclaredVersionsHolder.DECLARED_VERSIONS.size() - 1_ i >= 0_ i--) {_                final Version candidateVersion = DeclaredVersionsHolder.DECLARED_VERSIONS.get(i)__                if (candidateVersion.major == major - 1 && candidateVersion.isRelease() && after(candidateVersion)) {_                    if (bwcVersion != null && candidateVersion.minor < bwcVersion.minor) {_                        break__                    }_                    bwcVersion = candidateVersion__                }_            }_            return bwcVersion == null ? this : bwcVersion__        }__        return Version.min(this, fromId((int) major * 1000000 + 0 * 10000 + 99))__    };returns,the,minimum,compatible,version,based,on,the,current,version,ie,a,node,needs,to,have,at,least,the,return,version,in,order,to,communicate,with,a,node,running,the,current,version,the,returned,version,is,in,most,of,the,cases,the,smallest,major,version,release,unless,the,current,version,is,a,beta,or,rc,release,then,the,version,itself,is,returned;public,version,minimum,compatibility,version,if,major,6,return,version,from,id,5060099,else,if,major,7,version,bwc,version,null,for,int,i,declared,versions,holder,size,1,i,0,i,final,version,candidate,version,declared,versions,holder,get,i,if,candidate,version,major,major,1,candidate,version,is,release,after,candidate,version,if,bwc,version,null,candidate,version,minor,bwc,version,minor,break,bwc,version,candidate,version,return,bwc,version,null,this,bwc,version,return,version,min,this,from,id,int,major,1000000,0,10000,99
Version -> public Version minimumCompatibilityVersion();1536137328;Returns the minimum compatible version based on the current_version. Ie a node needs to have at least the return version in order_to communicate with a node running the current version. The returned version_is in most of the cases the smallest major version release unless the current version_is a beta or RC release then the version itself is returned.;public Version minimumCompatibilityVersion() {_        if (major == 6) {_            _            return Version.fromId(5060099)__        } else if (major >= 7) {_            _            Version bwcVersion = null___            for (int i = DeclaredVersionsHolder.DECLARED_VERSIONS.size() - 1_ i >= 0_ i--) {_                final Version candidateVersion = DeclaredVersionsHolder.DECLARED_VERSIONS.get(i)__                if (candidateVersion.major == major - 1 && candidateVersion.isRelease() && after(candidateVersion)) {_                    if (bwcVersion != null && candidateVersion.minor < bwcVersion.minor) {_                        break__                    }_                    bwcVersion = candidateVersion__                }_            }_            return bwcVersion == null ? this : bwcVersion__        }__        return Version.min(this, fromId((int) major * 1000000 + 0 * 10000 + 99))__    };returns,the,minimum,compatible,version,based,on,the,current,version,ie,a,node,needs,to,have,at,least,the,return,version,in,order,to,communicate,with,a,node,running,the,current,version,the,returned,version,is,in,most,of,the,cases,the,smallest,major,version,release,unless,the,current,version,is,a,beta,or,rc,release,then,the,version,itself,is,returned;public,version,minimum,compatibility,version,if,major,6,return,version,from,id,5060099,else,if,major,7,version,bwc,version,null,for,int,i,declared,versions,holder,size,1,i,0,i,final,version,candidate,version,declared,versions,holder,get,i,if,candidate,version,major,major,1,candidate,version,is,release,after,candidate,version,if,bwc,version,null,candidate,version,minor,bwc,version,minor,break,bwc,version,candidate,version,return,bwc,version,null,this,bwc,version,return,version,min,this,from,id,int,major,1000000,0,10000,99
Version -> public Version minimumCompatibilityVersion();1536314350;Returns the minimum compatible version based on the current_version. Ie a node needs to have at least the return version in order_to communicate with a node running the current version. The returned version_is in most of the cases the smallest major version release unless the current version_is a beta or RC release then the version itself is returned.;public Version minimumCompatibilityVersion() {_        if (major == 6) {_            _            return Version.fromId(5060099)__        } else if (major >= 7) {_            _            Version bwcVersion = null___            for (int i = DeclaredVersionsHolder.DECLARED_VERSIONS.size() - 1_ i >= 0_ i--) {_                final Version candidateVersion = DeclaredVersionsHolder.DECLARED_VERSIONS.get(i)__                if (candidateVersion.major == major - 1 && candidateVersion.isRelease() && after(candidateVersion)) {_                    if (bwcVersion != null && candidateVersion.minor < bwcVersion.minor) {_                        break__                    }_                    bwcVersion = candidateVersion__                }_            }_            return bwcVersion == null ? this : bwcVersion__        }__        return Version.min(this, fromId((int) major * 1000000 + 0 * 10000 + 99))__    };returns,the,minimum,compatible,version,based,on,the,current,version,ie,a,node,needs,to,have,at,least,the,return,version,in,order,to,communicate,with,a,node,running,the,current,version,the,returned,version,is,in,most,of,the,cases,the,smallest,major,version,release,unless,the,current,version,is,a,beta,or,rc,release,then,the,version,itself,is,returned;public,version,minimum,compatibility,version,if,major,6,return,version,from,id,5060099,else,if,major,7,version,bwc,version,null,for,int,i,declared,versions,holder,size,1,i,0,i,final,version,candidate,version,declared,versions,holder,get,i,if,candidate,version,major,major,1,candidate,version,is,release,after,candidate,version,if,bwc,version,null,candidate,version,minor,bwc,version,minor,break,bwc,version,candidate,version,return,bwc,version,null,this,bwc,version,return,version,min,this,from,id,int,major,1000000,0,10000,99
Version -> public Version minimumCompatibilityVersion();1537300661;Returns the minimum compatible version based on the current_version. Ie a node needs to have at least the return version in order_to communicate with a node running the current version. The returned version_is in most of the cases the smallest major version release unless the current version_is a beta or RC release then the version itself is returned.;public Version minimumCompatibilityVersion() {_        if (major == 6) {_            _            return Version.fromId(5060099)__        } else if (major >= 7) {_            _            Version bwcVersion = null___            for (int i = DeclaredVersionsHolder.DECLARED_VERSIONS.size() - 1_ i >= 0_ i--) {_                final Version candidateVersion = DeclaredVersionsHolder.DECLARED_VERSIONS.get(i)__                if (candidateVersion.major == major - 1 && candidateVersion.isRelease() && after(candidateVersion)) {_                    if (bwcVersion != null && candidateVersion.minor < bwcVersion.minor) {_                        break__                    }_                    bwcVersion = candidateVersion__                }_            }_            return bwcVersion == null ? this : bwcVersion__        }__        return Version.min(this, fromId((int) major * 1000000 + 0 * 10000 + 99))__    };returns,the,minimum,compatible,version,based,on,the,current,version,ie,a,node,needs,to,have,at,least,the,return,version,in,order,to,communicate,with,a,node,running,the,current,version,the,returned,version,is,in,most,of,the,cases,the,smallest,major,version,release,unless,the,current,version,is,a,beta,or,rc,release,then,the,version,itself,is,returned;public,version,minimum,compatibility,version,if,major,6,return,version,from,id,5060099,else,if,major,7,version,bwc,version,null,for,int,i,declared,versions,holder,size,1,i,0,i,final,version,candidate,version,declared,versions,holder,get,i,if,candidate,version,major,major,1,candidate,version,is,release,after,candidate,version,if,bwc,version,null,candidate,version,minor,bwc,version,minor,break,bwc,version,candidate,version,return,bwc,version,null,this,bwc,version,return,version,min,this,from,id,int,major,1000000,0,10000,99
Version -> public Version minimumCompatibilityVersion();1538509426;Returns the minimum compatible version based on the current_version. Ie a node needs to have at least the return version in order_to communicate with a node running the current version. The returned version_is in most of the cases the smallest major version release unless the current version_is a beta or RC release then the version itself is returned.;public Version minimumCompatibilityVersion() {_        if (major == 6) {_            _            return Version.fromId(5060099)__        } else if (major >= 7) {_            _            Version bwcVersion = null___            for (int i = DeclaredVersionsHolder.DECLARED_VERSIONS.size() - 1_ i >= 0_ i--) {_                final Version candidateVersion = DeclaredVersionsHolder.DECLARED_VERSIONS.get(i)__                if (candidateVersion.major == major - 1 && candidateVersion.isRelease() && after(candidateVersion)) {_                    if (bwcVersion != null && candidateVersion.minor < bwcVersion.minor) {_                        break__                    }_                    bwcVersion = candidateVersion__                }_            }_            return bwcVersion == null ? this : bwcVersion__        }__        return Version.min(this, fromId((int) major * 1000000 + 0 * 10000 + 99))__    };returns,the,minimum,compatible,version,based,on,the,current,version,ie,a,node,needs,to,have,at,least,the,return,version,in,order,to,communicate,with,a,node,running,the,current,version,the,returned,version,is,in,most,of,the,cases,the,smallest,major,version,release,unless,the,current,version,is,a,beta,or,rc,release,then,the,version,itself,is,returned;public,version,minimum,compatibility,version,if,major,6,return,version,from,id,5060099,else,if,major,7,version,bwc,version,null,for,int,i,declared,versions,holder,size,1,i,0,i,final,version,candidate,version,declared,versions,holder,get,i,if,candidate,version,major,major,1,candidate,version,is,release,after,candidate,version,if,bwc,version,null,candidate,version,minor,bwc,version,minor,break,bwc,version,candidate,version,return,bwc,version,null,this,bwc,version,return,version,min,this,from,id,int,major,1000000,0,10000,99
Version -> public Version minimumCompatibilityVersion();1540486836;Returns the minimum compatible version based on the current_version. Ie a node needs to have at least the return version in order_to communicate with a node running the current version. The returned version_is in most of the cases the smallest major version release unless the current version_is a beta or RC release then the version itself is returned.;public Version minimumCompatibilityVersion() {_        if (major == 6) {_            _            return Version.fromId(5060099)__        } else if (major >= 7) {_            _            Version bwcVersion = null___            for (int i = DeclaredVersionsHolder.DECLARED_VERSIONS.size() - 1_ i >= 0_ i--) {_                final Version candidateVersion = DeclaredVersionsHolder.DECLARED_VERSIONS.get(i)__                if (candidateVersion.major == major - 1 && candidateVersion.isRelease() && after(candidateVersion)) {_                    if (bwcVersion != null && candidateVersion.minor < bwcVersion.minor) {_                        break__                    }_                    bwcVersion = candidateVersion__                }_            }_            return bwcVersion == null ? this : bwcVersion__        }__        return Version.min(this, fromId((int) major * 1000000 + 0 * 10000 + 99))__    };returns,the,minimum,compatible,version,based,on,the,current,version,ie,a,node,needs,to,have,at,least,the,return,version,in,order,to,communicate,with,a,node,running,the,current,version,the,returned,version,is,in,most,of,the,cases,the,smallest,major,version,release,unless,the,current,version,is,a,beta,or,rc,release,then,the,version,itself,is,returned;public,version,minimum,compatibility,version,if,major,6,return,version,from,id,5060099,else,if,major,7,version,bwc,version,null,for,int,i,declared,versions,holder,size,1,i,0,i,final,version,candidate,version,declared,versions,holder,get,i,if,candidate,version,major,major,1,candidate,version,is,release,after,candidate,version,if,bwc,version,null,candidate,version,minor,bwc,version,minor,break,bwc,version,candidate,version,return,bwc,version,null,this,bwc,version,return,version,min,this,from,id,int,major,1000000,0,10000,99
Version -> public Version minimumCompatibilityVersion();1541502933;Returns the minimum compatible version based on the current_version. Ie a node needs to have at least the return version in order_to communicate with a node running the current version. The returned version_is in most of the cases the smallest major version release unless the current version_is a beta or RC release then the version itself is returned.;public Version minimumCompatibilityVersion() {_        if (major == 6) {_            _            return Version.fromId(5060099)__        } else if (major >= 7) {_            _            Version bwcVersion = null___            for (int i = DeclaredVersionsHolder.DECLARED_VERSIONS.size() - 1_ i >= 0_ i--) {_                final Version candidateVersion = DeclaredVersionsHolder.DECLARED_VERSIONS.get(i)__                if (candidateVersion.major == major - 1 && candidateVersion.isRelease() && after(candidateVersion)) {_                    if (bwcVersion != null && candidateVersion.minor < bwcVersion.minor) {_                        break__                    }_                    bwcVersion = candidateVersion__                }_            }_            return bwcVersion == null ? this : bwcVersion__        }__        return Version.min(this, fromId((int) major * 1000000 + 0 * 10000 + 99))__    };returns,the,minimum,compatible,version,based,on,the,current,version,ie,a,node,needs,to,have,at,least,the,return,version,in,order,to,communicate,with,a,node,running,the,current,version,the,returned,version,is,in,most,of,the,cases,the,smallest,major,version,release,unless,the,current,version,is,a,beta,or,rc,release,then,the,version,itself,is,returned;public,version,minimum,compatibility,version,if,major,6,return,version,from,id,5060099,else,if,major,7,version,bwc,version,null,for,int,i,declared,versions,holder,size,1,i,0,i,final,version,candidate,version,declared,versions,holder,get,i,if,candidate,version,major,major,1,candidate,version,is,release,after,candidate,version,if,bwc,version,null,candidate,version,minor,bwc,version,minor,break,bwc,version,candidate,version,return,bwc,version,null,this,bwc,version,return,version,min,this,from,id,int,major,1000000,0,10000,99
Version -> public Version minimumCompatibilityVersion();1541528420;Returns the minimum compatible version based on the current_version. Ie a node needs to have at least the return version in order_to communicate with a node running the current version. The returned version_is in most of the cases the smallest major version release unless the current version_is a beta or RC release then the version itself is returned.;public Version minimumCompatibilityVersion() {_        if (major == 6) {_            _            return Version.fromId(5060099)__        } else if (major >= 7) {_            _            Version bwcVersion = null___            for (int i = DeclaredVersionsHolder.DECLARED_VERSIONS.size() - 1_ i >= 0_ i--) {_                final Version candidateVersion = DeclaredVersionsHolder.DECLARED_VERSIONS.get(i)__                if (candidateVersion.major == major - 1 && candidateVersion.isRelease() && after(candidateVersion)) {_                    if (bwcVersion != null && candidateVersion.minor < bwcVersion.minor) {_                        break__                    }_                    bwcVersion = candidateVersion__                }_            }_            return bwcVersion == null ? this : bwcVersion__        }__        return Version.min(this, fromId((int) major * 1000000 + 0 * 10000 + 99))__    };returns,the,minimum,compatible,version,based,on,the,current,version,ie,a,node,needs,to,have,at,least,the,return,version,in,order,to,communicate,with,a,node,running,the,current,version,the,returned,version,is,in,most,of,the,cases,the,smallest,major,version,release,unless,the,current,version,is,a,beta,or,rc,release,then,the,version,itself,is,returned;public,version,minimum,compatibility,version,if,major,6,return,version,from,id,5060099,else,if,major,7,version,bwc,version,null,for,int,i,declared,versions,holder,size,1,i,0,i,final,version,candidate,version,declared,versions,holder,get,i,if,candidate,version,major,major,1,candidate,version,is,release,after,candidate,version,if,bwc,version,null,candidate,version,minor,bwc,version,minor,break,bwc,version,candidate,version,return,bwc,version,null,this,bwc,version,return,version,min,this,from,id,int,major,1000000,0,10000,99
Version -> public Version minimumCompatibilityVersion();1541592065;Returns the minimum compatible version based on the current_version. Ie a node needs to have at least the return version in order_to communicate with a node running the current version. The returned version_is in most of the cases the smallest major version release unless the current version_is a beta or RC release then the version itself is returned.;public Version minimumCompatibilityVersion() {_        if (major == 6) {_            _            return Version.fromId(5060099)__        } else if (major >= 7) {_            _            Version bwcVersion = null___            for (int i = DeclaredVersionsHolder.DECLARED_VERSIONS.size() - 1_ i >= 0_ i--) {_                final Version candidateVersion = DeclaredVersionsHolder.DECLARED_VERSIONS.get(i)__                if (candidateVersion.major == major - 1 && candidateVersion.isRelease() && after(candidateVersion)) {_                    if (bwcVersion != null && candidateVersion.minor < bwcVersion.minor) {_                        break__                    }_                    bwcVersion = candidateVersion__                }_            }_            return bwcVersion == null ? this : bwcVersion__        }__        return Version.min(this, fromId((int) major * 1000000 + 0 * 10000 + 99))__    };returns,the,minimum,compatible,version,based,on,the,current,version,ie,a,node,needs,to,have,at,least,the,return,version,in,order,to,communicate,with,a,node,running,the,current,version,the,returned,version,is,in,most,of,the,cases,the,smallest,major,version,release,unless,the,current,version,is,a,beta,or,rc,release,then,the,version,itself,is,returned;public,version,minimum,compatibility,version,if,major,6,return,version,from,id,5060099,else,if,major,7,version,bwc,version,null,for,int,i,declared,versions,holder,size,1,i,0,i,final,version,candidate,version,declared,versions,holder,get,i,if,candidate,version,major,major,1,candidate,version,is,release,after,candidate,version,if,bwc,version,null,candidate,version,minor,bwc,version,minor,break,bwc,version,candidate,version,return,bwc,version,null,this,bwc,version,return,version,min,this,from,id,int,major,1000000,0,10000,99
Version -> public Version minimumCompatibilityVersion();1542226101;Returns the minimum compatible version based on the current_version. Ie a node needs to have at least the return version in order_to communicate with a node running the current version. The returned version_is in most of the cases the smallest major version release unless the current version_is a beta or RC release then the version itself is returned.;public Version minimumCompatibilityVersion() {_        if (major == 6) {_            _            return Version.fromId(5060099)__        } else if (major >= 7) {_            _            Version bwcVersion = null___            for (int i = DeclaredVersionsHolder.DECLARED_VERSIONS.size() - 1_ i >= 0_ i--) {_                final Version candidateVersion = DeclaredVersionsHolder.DECLARED_VERSIONS.get(i)__                if (candidateVersion.major == major - 1 && candidateVersion.isRelease() && after(candidateVersion)) {_                    if (bwcVersion != null && candidateVersion.minor < bwcVersion.minor) {_                        break__                    }_                    bwcVersion = candidateVersion__                }_            }_            return bwcVersion == null ? this : bwcVersion__        }__        return Version.min(this, fromId((int) major * 1000000 + 0 * 10000 + 99))__    };returns,the,minimum,compatible,version,based,on,the,current,version,ie,a,node,needs,to,have,at,least,the,return,version,in,order,to,communicate,with,a,node,running,the,current,version,the,returned,version,is,in,most,of,the,cases,the,smallest,major,version,release,unless,the,current,version,is,a,beta,or,rc,release,then,the,version,itself,is,returned;public,version,minimum,compatibility,version,if,major,6,return,version,from,id,5060099,else,if,major,7,version,bwc,version,null,for,int,i,declared,versions,holder,size,1,i,0,i,final,version,candidate,version,declared,versions,holder,get,i,if,candidate,version,major,major,1,candidate,version,is,release,after,candidate,version,if,bwc,version,null,candidate,version,minor,bwc,version,minor,break,bwc,version,candidate,version,return,bwc,version,null,this,bwc,version,return,version,min,this,from,id,int,major,1000000,0,10000,99
Version -> public Version minimumCompatibilityVersion();1542746006;Returns the minimum compatible version based on the current_version. Ie a node needs to have at least the return version in order_to communicate with a node running the current version. The returned version_is in most of the cases the smallest major version release unless the current version_is a beta or RC release then the version itself is returned.;public Version minimumCompatibilityVersion() {_        if (major == 6) {_            _            return Version.fromId(5060099)__        } else if (major >= 7) {_            _            Version bwcVersion = null___            for (int i = DeclaredVersionsHolder.DECLARED_VERSIONS.size() - 1_ i >= 0_ i--) {_                final Version candidateVersion = DeclaredVersionsHolder.DECLARED_VERSIONS.get(i)__                if (candidateVersion.major == major - 1 && candidateVersion.isRelease() && after(candidateVersion)) {_                    if (bwcVersion != null && candidateVersion.minor < bwcVersion.minor) {_                        break__                    }_                    bwcVersion = candidateVersion__                }_            }_            return bwcVersion == null ? this : bwcVersion__        }__        return Version.min(this, fromId((int) major * 1000000 + 0 * 10000 + 99))__    };returns,the,minimum,compatible,version,based,on,the,current,version,ie,a,node,needs,to,have,at,least,the,return,version,in,order,to,communicate,with,a,node,running,the,current,version,the,returned,version,is,in,most,of,the,cases,the,smallest,major,version,release,unless,the,current,version,is,a,beta,or,rc,release,then,the,version,itself,is,returned;public,version,minimum,compatibility,version,if,major,6,return,version,from,id,5060099,else,if,major,7,version,bwc,version,null,for,int,i,declared,versions,holder,size,1,i,0,i,final,version,candidate,version,declared,versions,holder,get,i,if,candidate,version,major,major,1,candidate,version,is,release,after,candidate,version,if,bwc,version,null,candidate,version,minor,bwc,version,minor,break,bwc,version,candidate,version,return,bwc,version,null,this,bwc,version,return,version,min,this,from,id,int,major,1000000,0,10000,99
Version -> public Version minimumCompatibilityVersion();1543473699;Returns the minimum compatible version based on the current_version. Ie a node needs to have at least the return version in order_to communicate with a node running the current version. The returned version_is in most of the cases the smallest major version release unless the current version_is a beta or RC release then the version itself is returned.;public Version minimumCompatibilityVersion() {_        if (major == 6) {_            _            return Version.fromId(5060099)__        } else if (major >= 7) {_            _            Version bwcVersion = null___            for (int i = DeclaredVersionsHolder.DECLARED_VERSIONS.size() - 1_ i >= 0_ i--) {_                final Version candidateVersion = DeclaredVersionsHolder.DECLARED_VERSIONS.get(i)__                if (candidateVersion.major == major - 1 && candidateVersion.isRelease() && after(candidateVersion)) {_                    if (bwcVersion != null && candidateVersion.minor < bwcVersion.minor) {_                        break__                    }_                    bwcVersion = candidateVersion__                }_            }_            return bwcVersion == null ? this : bwcVersion__        }__        return Version.min(this, fromId((int) major * 1000000 + 0 * 10000 + 99))__    };returns,the,minimum,compatible,version,based,on,the,current,version,ie,a,node,needs,to,have,at,least,the,return,version,in,order,to,communicate,with,a,node,running,the,current,version,the,returned,version,is,in,most,of,the,cases,the,smallest,major,version,release,unless,the,current,version,is,a,beta,or,rc,release,then,the,version,itself,is,returned;public,version,minimum,compatibility,version,if,major,6,return,version,from,id,5060099,else,if,major,7,version,bwc,version,null,for,int,i,declared,versions,holder,size,1,i,0,i,final,version,candidate,version,declared,versions,holder,get,i,if,candidate,version,major,major,1,candidate,version,is,release,after,candidate,version,if,bwc,version,null,candidate,version,minor,bwc,version,minor,break,bwc,version,candidate,version,return,bwc,version,null,this,bwc,version,return,version,min,this,from,id,int,major,1000000,0,10000,99
Version -> public Version minimumCompatibilityVersion();1543942400;Returns the minimum compatible version based on the current_version. Ie a node needs to have at least the return version in order_to communicate with a node running the current version. The returned version_is in most of the cases the smallest major version release unless the current version_is a beta or RC release then the version itself is returned.;public Version minimumCompatibilityVersion() {_        if (major == 6) {_            _            return Version.fromId(5060099)__        } else if (major >= 7) {_            _            Version bwcVersion = null___            for (int i = DeclaredVersionsHolder.DECLARED_VERSIONS.size() - 1_ i >= 0_ i--) {_                final Version candidateVersion = DeclaredVersionsHolder.DECLARED_VERSIONS.get(i)__                if (candidateVersion.major == major - 1 && candidateVersion.isRelease() && after(candidateVersion)) {_                    if (bwcVersion != null && candidateVersion.minor < bwcVersion.minor) {_                        break__                    }_                    bwcVersion = candidateVersion__                }_            }_            return bwcVersion == null ? this : bwcVersion__        }__        return Version.min(this, fromId((int) major * 1000000 + 0 * 10000 + 99))__    };returns,the,minimum,compatible,version,based,on,the,current,version,ie,a,node,needs,to,have,at,least,the,return,version,in,order,to,communicate,with,a,node,running,the,current,version,the,returned,version,is,in,most,of,the,cases,the,smallest,major,version,release,unless,the,current,version,is,a,beta,or,rc,release,then,the,version,itself,is,returned;public,version,minimum,compatibility,version,if,major,6,return,version,from,id,5060099,else,if,major,7,version,bwc,version,null,for,int,i,declared,versions,holder,size,1,i,0,i,final,version,candidate,version,declared,versions,holder,get,i,if,candidate,version,major,major,1,candidate,version,is,release,after,candidate,version,if,bwc,version,null,candidate,version,minor,bwc,version,minor,break,bwc,version,candidate,version,return,bwc,version,null,this,bwc,version,return,version,min,this,from,id,int,major,1000000,0,10000,99
Version -> public Version minimumCompatibilityVersion();1544037309;Returns the minimum compatible version based on the current_version. Ie a node needs to have at least the return version in order_to communicate with a node running the current version. The returned version_is in most of the cases the smallest major version release unless the current version_is a beta or RC release then the version itself is returned.;public Version minimumCompatibilityVersion() {_        if (major == 6) {_            _            return Version.fromId(5060099)__        } else if (major >= 7) {_            _            Version bwcVersion = null___            for (int i = DeclaredVersionsHolder.DECLARED_VERSIONS.size() - 1_ i >= 0_ i--) {_                final Version candidateVersion = DeclaredVersionsHolder.DECLARED_VERSIONS.get(i)__                if (candidateVersion.major == major - 1 && candidateVersion.isRelease() && after(candidateVersion)) {_                    if (bwcVersion != null && candidateVersion.minor < bwcVersion.minor) {_                        break__                    }_                    bwcVersion = candidateVersion__                }_            }_            return bwcVersion == null ? this : bwcVersion__        }__        return Version.min(this, fromId((int) major * 1000000 + 0 * 10000 + 99))__    };returns,the,minimum,compatible,version,based,on,the,current,version,ie,a,node,needs,to,have,at,least,the,return,version,in,order,to,communicate,with,a,node,running,the,current,version,the,returned,version,is,in,most,of,the,cases,the,smallest,major,version,release,unless,the,current,version,is,a,beta,or,rc,release,then,the,version,itself,is,returned;public,version,minimum,compatibility,version,if,major,6,return,version,from,id,5060099,else,if,major,7,version,bwc,version,null,for,int,i,declared,versions,holder,size,1,i,0,i,final,version,candidate,version,declared,versions,holder,get,i,if,candidate,version,major,major,1,candidate,version,is,release,after,candidate,version,if,bwc,version,null,candidate,version,minor,bwc,version,minor,break,bwc,version,candidate,version,return,bwc,version,null,this,bwc,version,return,version,min,this,from,id,int,major,1000000,0,10000,99
Version -> public Version minimumCompatibilityVersion();1544553539;Returns the minimum compatible version based on the current_version. Ie a node needs to have at least the return version in order_to communicate with a node running the current version. The returned version_is in most of the cases the smallest major version release unless the current version_is a beta or RC release then the version itself is returned.;public Version minimumCompatibilityVersion() {_        if (major == 6) {_            _            return Version.fromId(5060099)__        } else if (major >= 7) {_            _            Version bwcVersion = null___            for (int i = DeclaredVersionsHolder.DECLARED_VERSIONS.size() - 1_ i >= 0_ i--) {_                final Version candidateVersion = DeclaredVersionsHolder.DECLARED_VERSIONS.get(i)__                if (candidateVersion.major == major - 1 && candidateVersion.isRelease() && after(candidateVersion)) {_                    if (bwcVersion != null && candidateVersion.minor < bwcVersion.minor) {_                        break__                    }_                    bwcVersion = candidateVersion__                }_            }_            return bwcVersion == null ? this : bwcVersion__        }__        return Version.min(this, fromId((int) major * 1000000 + 0 * 10000 + 99))__    };returns,the,minimum,compatible,version,based,on,the,current,version,ie,a,node,needs,to,have,at,least,the,return,version,in,order,to,communicate,with,a,node,running,the,current,version,the,returned,version,is,in,most,of,the,cases,the,smallest,major,version,release,unless,the,current,version,is,a,beta,or,rc,release,then,the,version,itself,is,returned;public,version,minimum,compatibility,version,if,major,6,return,version,from,id,5060099,else,if,major,7,version,bwc,version,null,for,int,i,declared,versions,holder,size,1,i,0,i,final,version,candidate,version,declared,versions,holder,get,i,if,candidate,version,major,major,1,candidate,version,is,release,after,candidate,version,if,bwc,version,null,candidate,version,minor,bwc,version,minor,break,bwc,version,candidate,version,return,bwc,version,null,this,bwc,version,return,version,min,this,from,id,int,major,1000000,0,10000,99
Version -> public Version minimumCompatibilityVersion();1545225850;Returns the minimum compatible version based on the current_version. Ie a node needs to have at least the return version in order_to communicate with a node running the current version. The returned version_is in most of the cases the smallest major version release unless the current version_is a beta or RC release then the version itself is returned.;public Version minimumCompatibilityVersion() {_        if (major == 6) {_            _            return Version.fromId(5060099)__        } else if (major >= 7) {_            _            Version bwcVersion = null___            for (int i = DeclaredVersionsHolder.DECLARED_VERSIONS.size() - 1_ i >= 0_ i--) {_                final Version candidateVersion = DeclaredVersionsHolder.DECLARED_VERSIONS.get(i)__                if (candidateVersion.major == major - 1 && candidateVersion.isRelease() && after(candidateVersion)) {_                    if (bwcVersion != null && candidateVersion.minor < bwcVersion.minor) {_                        break__                    }_                    bwcVersion = candidateVersion__                }_            }_            return bwcVersion == null ? this : bwcVersion__        }__        return Version.min(this, fromId((int) major * 1000000 + 0 * 10000 + 99))__    };returns,the,minimum,compatible,version,based,on,the,current,version,ie,a,node,needs,to,have,at,least,the,return,version,in,order,to,communicate,with,a,node,running,the,current,version,the,returned,version,is,in,most,of,the,cases,the,smallest,major,version,release,unless,the,current,version,is,a,beta,or,rc,release,then,the,version,itself,is,returned;public,version,minimum,compatibility,version,if,major,6,return,version,from,id,5060099,else,if,major,7,version,bwc,version,null,for,int,i,declared,versions,holder,size,1,i,0,i,final,version,candidate,version,declared,versions,holder,get,i,if,candidate,version,major,major,1,candidate,version,is,release,after,candidate,version,if,bwc,version,null,candidate,version,minor,bwc,version,minor,break,bwc,version,candidate,version,return,bwc,version,null,this,bwc,version,return,version,min,this,from,id,int,major,1000000,0,10000,99
Version -> public Version minimumCompatibilityVersion();1545256934;Returns the minimum compatible version based on the current_version. Ie a node needs to have at least the return version in order_to communicate with a node running the current version. The returned version_is in most of the cases the smallest major version release unless the current version_is a beta or RC release then the version itself is returned.;public Version minimumCompatibilityVersion() {_        if (major == 6) {_            _            return Version.fromId(5060099)__        } else if (major >= 7) {_            _            Version bwcVersion = null___            for (int i = DeclaredVersionsHolder.DECLARED_VERSIONS.size() - 1_ i >= 0_ i--) {_                final Version candidateVersion = DeclaredVersionsHolder.DECLARED_VERSIONS.get(i)__                if (candidateVersion.major == major - 1 && candidateVersion.isRelease() && after(candidateVersion)) {_                    if (bwcVersion != null && candidateVersion.minor < bwcVersion.minor) {_                        break__                    }_                    bwcVersion = candidateVersion__                }_            }_            return bwcVersion == null ? this : bwcVersion__        }__        return Version.min(this, fromId((int) major * 1000000 + 0 * 10000 + 99))__    };returns,the,minimum,compatible,version,based,on,the,current,version,ie,a,node,needs,to,have,at,least,the,return,version,in,order,to,communicate,with,a,node,running,the,current,version,the,returned,version,is,in,most,of,the,cases,the,smallest,major,version,release,unless,the,current,version,is,a,beta,or,rc,release,then,the,version,itself,is,returned;public,version,minimum,compatibility,version,if,major,6,return,version,from,id,5060099,else,if,major,7,version,bwc,version,null,for,int,i,declared,versions,holder,size,1,i,0,i,final,version,candidate,version,declared,versions,holder,get,i,if,candidate,version,major,major,1,candidate,version,is,release,after,candidate,version,if,bwc,version,null,candidate,version,minor,bwc,version,minor,break,bwc,version,candidate,version,return,bwc,version,null,this,bwc,version,return,version,min,this,from,id,int,major,1000000,0,10000,99
Version -> public Version minimumCompatibilityVersion();1546507247;Returns the minimum compatible version based on the current_version. Ie a node needs to have at least the return version in order_to communicate with a node running the current version. The returned version_is in most of the cases the smallest major version release unless the current version_is a beta or RC release then the version itself is returned.;public Version minimumCompatibilityVersion() {_        if (major == 6) {_            _            return Version.fromId(5060099)__        } else if (major >= 7) {_            _            Version bwcVersion = null___            for (int i = DeclaredVersionsHolder.DECLARED_VERSIONS.size() - 1_ i >= 0_ i--) {_                final Version candidateVersion = DeclaredVersionsHolder.DECLARED_VERSIONS.get(i)__                if (candidateVersion.major == major - 1 && candidateVersion.isRelease() && after(candidateVersion)) {_                    if (bwcVersion != null && candidateVersion.minor < bwcVersion.minor) {_                        break__                    }_                    bwcVersion = candidateVersion__                }_            }_            return bwcVersion == null ? this : bwcVersion__        }__        return Version.min(this, fromId((int) major * 1000000 + 0 * 10000 + 99))__    };returns,the,minimum,compatible,version,based,on,the,current,version,ie,a,node,needs,to,have,at,least,the,return,version,in,order,to,communicate,with,a,node,running,the,current,version,the,returned,version,is,in,most,of,the,cases,the,smallest,major,version,release,unless,the,current,version,is,a,beta,or,rc,release,then,the,version,itself,is,returned;public,version,minimum,compatibility,version,if,major,6,return,version,from,id,5060099,else,if,major,7,version,bwc,version,null,for,int,i,declared,versions,holder,size,1,i,0,i,final,version,candidate,version,declared,versions,holder,get,i,if,candidate,version,major,major,1,candidate,version,is,release,after,candidate,version,if,bwc,version,null,candidate,version,minor,bwc,version,minor,break,bwc,version,candidate,version,return,bwc,version,null,this,bwc,version,return,version,min,this,from,id,int,major,1000000,0,10000,99
Version -> public Version minimumCompatibilityVersion();1546537951;Returns the minimum compatible version based on the current_version. Ie a node needs to have at least the return version in order_to communicate with a node running the current version. The returned version_is in most of the cases the smallest major version release unless the current version_is a beta or RC release then the version itself is returned.;public Version minimumCompatibilityVersion() {_        if (major == 6) {_            _            return Version.fromId(5060099)__        } else if (major >= 7) {_            _            Version bwcVersion = null___            for (int i = DeclaredVersionsHolder.DECLARED_VERSIONS.size() - 1_ i >= 0_ i--) {_                final Version candidateVersion = DeclaredVersionsHolder.DECLARED_VERSIONS.get(i)__                if (candidateVersion.major == major - 1 && candidateVersion.isRelease() && after(candidateVersion)) {_                    if (bwcVersion != null && candidateVersion.minor < bwcVersion.minor) {_                        break__                    }_                    bwcVersion = candidateVersion__                }_            }_            return bwcVersion == null ? this : bwcVersion__        }__        return Version.min(this, fromId((int) major * 1000000 + 0 * 10000 + 99))__    };returns,the,minimum,compatible,version,based,on,the,current,version,ie,a,node,needs,to,have,at,least,the,return,version,in,order,to,communicate,with,a,node,running,the,current,version,the,returned,version,is,in,most,of,the,cases,the,smallest,major,version,release,unless,the,current,version,is,a,beta,or,rc,release,then,the,version,itself,is,returned;public,version,minimum,compatibility,version,if,major,6,return,version,from,id,5060099,else,if,major,7,version,bwc,version,null,for,int,i,declared,versions,holder,size,1,i,0,i,final,version,candidate,version,declared,versions,holder,get,i,if,candidate,version,major,major,1,candidate,version,is,release,after,candidate,version,if,bwc,version,null,candidate,version,minor,bwc,version,minor,break,bwc,version,candidate,version,return,bwc,version,null,this,bwc,version,return,version,min,this,from,id,int,major,1000000,0,10000,99
Version -> public Version minimumCompatibilityVersion();1548755041;Returns the minimum compatible version based on the current_version. Ie a node needs to have at least the return version in order_to communicate with a node running the current version. The returned version_is in most of the cases the smallest major version release unless the current version_is a beta or RC release then the version itself is returned.;public Version minimumCompatibilityVersion() {_        if (major == 6) {_            _            return Version.fromId(5060099)__        } else if (major >= 7) {_            _            Version bwcVersion = null___            for (int i = DeclaredVersionsHolder.DECLARED_VERSIONS.size() - 1_ i >= 0_ i--) {_                final Version candidateVersion = DeclaredVersionsHolder.DECLARED_VERSIONS.get(i)__                if (candidateVersion.major == major - 1 && candidateVersion.isRelease() && after(candidateVersion)) {_                    if (bwcVersion != null && candidateVersion.minor < bwcVersion.minor) {_                        break__                    }_                    bwcVersion = candidateVersion__                }_            }_            return bwcVersion == null ? this : bwcVersion__        }__        return Version.min(this, fromId((int) major * 1000000 + 0 * 10000 + 99))__    };returns,the,minimum,compatible,version,based,on,the,current,version,ie,a,node,needs,to,have,at,least,the,return,version,in,order,to,communicate,with,a,node,running,the,current,version,the,returned,version,is,in,most,of,the,cases,the,smallest,major,version,release,unless,the,current,version,is,a,beta,or,rc,release,then,the,version,itself,is,returned;public,version,minimum,compatibility,version,if,major,6,return,version,from,id,5060099,else,if,major,7,version,bwc,version,null,for,int,i,declared,versions,holder,size,1,i,0,i,final,version,candidate,version,declared,versions,holder,get,i,if,candidate,version,major,major,1,candidate,version,is,release,after,candidate,version,if,bwc,version,null,candidate,version,minor,bwc,version,minor,break,bwc,version,candidate,version,return,bwc,version,null,this,bwc,version,return,version,min,this,from,id,int,major,1000000,0,10000,99
Version -> public Version minimumCompatibilityVersion();1548822781;Returns the minimum compatible version based on the current_version. Ie a node needs to have at least the return version in order_to communicate with a node running the current version. The returned version_is in most of the cases the smallest major version release unless the current version_is a beta or RC release then the version itself is returned.;public Version minimumCompatibilityVersion() {_        if (major == 6) {_            _            return Version.fromId(5060099)__        } else if (major >= 7) {_            _            Version bwcVersion = null___            for (int i = DeclaredVersionsHolder.DECLARED_VERSIONS.size() - 1_ i >= 0_ i--) {_                final Version candidateVersion = DeclaredVersionsHolder.DECLARED_VERSIONS.get(i)__                if (candidateVersion.major == major - 1 && candidateVersion.isRelease() && after(candidateVersion)) {_                    if (bwcVersion != null && candidateVersion.minor < bwcVersion.minor) {_                        break__                    }_                    bwcVersion = candidateVersion__                }_            }_            return bwcVersion == null ? this : bwcVersion__        }__        return Version.min(this, fromId((int) major * 1000000 + 0 * 10000 + 99))__    };returns,the,minimum,compatible,version,based,on,the,current,version,ie,a,node,needs,to,have,at,least,the,return,version,in,order,to,communicate,with,a,node,running,the,current,version,the,returned,version,is,in,most,of,the,cases,the,smallest,major,version,release,unless,the,current,version,is,a,beta,or,rc,release,then,the,version,itself,is,returned;public,version,minimum,compatibility,version,if,major,6,return,version,from,id,5060099,else,if,major,7,version,bwc,version,null,for,int,i,declared,versions,holder,size,1,i,0,i,final,version,candidate,version,declared,versions,holder,get,i,if,candidate,version,major,major,1,candidate,version,is,release,after,candidate,version,if,bwc,version,null,candidate,version,minor,bwc,version,minor,break,bwc,version,candidate,version,return,bwc,version,null,this,bwc,version,return,version,min,this,from,id,int,major,1000000,0,10000,99
Version -> public Version minimumCompatibilityVersion();1549608646;Returns the minimum compatible version based on the current_version. Ie a node needs to have at least the return version in order_to communicate with a node running the current version. The returned version_is in most of the cases the smallest major version release unless the current version_is a beta or RC release then the version itself is returned.;public Version minimumCompatibilityVersion() {_        if (major == 6) {_            _            return Version.fromId(5060099)__        } else if (major >= 7) {_            _            Version bwcVersion = null___            for (int i = DeclaredVersionsHolder.DECLARED_VERSIONS.size() - 1_ i >= 0_ i--) {_                final Version candidateVersion = DeclaredVersionsHolder.DECLARED_VERSIONS.get(i)__                if (candidateVersion.major == major - 1 && candidateVersion.isRelease() && after(candidateVersion)) {_                    if (bwcVersion != null && candidateVersion.minor < bwcVersion.minor) {_                        break__                    }_                    bwcVersion = candidateVersion__                }_            }_            return bwcVersion == null ? this : bwcVersion__        }__        return Version.min(this, fromId((int) major * 1000000 + 0 * 10000 + 99))__    };returns,the,minimum,compatible,version,based,on,the,current,version,ie,a,node,needs,to,have,at,least,the,return,version,in,order,to,communicate,with,a,node,running,the,current,version,the,returned,version,is,in,most,of,the,cases,the,smallest,major,version,release,unless,the,current,version,is,a,beta,or,rc,release,then,the,version,itself,is,returned;public,version,minimum,compatibility,version,if,major,6,return,version,from,id,5060099,else,if,major,7,version,bwc,version,null,for,int,i,declared,versions,holder,size,1,i,0,i,final,version,candidate,version,declared,versions,holder,get,i,if,candidate,version,major,major,1,candidate,version,is,release,after,candidate,version,if,bwc,version,null,candidate,version,minor,bwc,version,minor,break,bwc,version,candidate,version,return,bwc,version,null,this,bwc,version,return,version,min,this,from,id,int,major,1000000,0,10000,99
Version -> public Version minimumCompatibilityVersion();1550604529;Returns the minimum compatible version based on the current_version. Ie a node needs to have at least the return version in order_to communicate with a node running the current version. The returned version_is in most of the cases the smallest major version release unless the current version_is a beta or RC release then the version itself is returned.;public Version minimumCompatibilityVersion() {_        if (major == 6) {_            _            return Version.fromId(5060099)__        } else if (major >= 7) {_            _            Version bwcVersion = null___            for (int i = DeclaredVersionsHolder.DECLARED_VERSIONS.size() - 1_ i >= 0_ i--) {_                final Version candidateVersion = DeclaredVersionsHolder.DECLARED_VERSIONS.get(i)__                if (candidateVersion.major == major - 1 && candidateVersion.isRelease() && after(candidateVersion)) {_                    if (bwcVersion != null && candidateVersion.minor < bwcVersion.minor) {_                        break__                    }_                    bwcVersion = candidateVersion__                }_            }_            return bwcVersion == null ? this : bwcVersion__        }__        return Version.min(this, fromId((int) major * 1000000 + 0 * 10000 + 99))__    };returns,the,minimum,compatible,version,based,on,the,current,version,ie,a,node,needs,to,have,at,least,the,return,version,in,order,to,communicate,with,a,node,running,the,current,version,the,returned,version,is,in,most,of,the,cases,the,smallest,major,version,release,unless,the,current,version,is,a,beta,or,rc,release,then,the,version,itself,is,returned;public,version,minimum,compatibility,version,if,major,6,return,version,from,id,5060099,else,if,major,7,version,bwc,version,null,for,int,i,declared,versions,holder,size,1,i,0,i,final,version,candidate,version,declared,versions,holder,get,i,if,candidate,version,major,major,1,candidate,version,is,release,after,candidate,version,if,bwc,version,null,candidate,version,minor,bwc,version,minor,break,bwc,version,candidate,version,return,bwc,version,null,this,bwc,version,return,version,min,this,from,id,int,major,1000000,0,10000,99
Version -> public static Version max(Version version1, Version version2);1524684173;Returns the maximum version between the 2;public static Version max(Version version1, Version version2) { return version1.id > version2.id ? version1 : version2_ };returns,the,maximum,version,between,the,2;public,static,version,max,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version max(Version version1, Version version2);1525645056;Returns the maximum version between the 2;public static Version max(Version version1, Version version2) { return version1.id > version2.id ? version1 : version2_ };returns,the,maximum,version,between,the,2;public,static,version,max,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version max(Version version1, Version version2);1526900724;Returns the maximum version between the 2;public static Version max(Version version1, Version version2) { return version1.id > version2.id ? version1 : version2_ };returns,the,maximum,version,between,the,2;public,static,version,max,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version max(Version version1, Version version2);1528917185;Returns the maximum version between the 2;public static Version max(Version version1, Version version2) { return version1.id > version2.id ? version1 : version2_ };returns,the,maximum,version,between,the,2;public,static,version,max,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version max(Version version1, Version version2);1528924528;Returns the maximum version between the 2;public static Version max(Version version1, Version version2) { return version1.id > version2.id ? version1 : version2_ };returns,the,maximum,version,between,the,2;public,static,version,max,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version max(Version version1, Version version2);1531179852;Returns the maximum version between the 2;public static Version max(Version version1, Version version2) { return version1.id > version2.id ? version1 : version2_ };returns,the,maximum,version,between,the,2;public,static,version,max,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version max(Version version1, Version version2);1532511554;Returns the maximum version between the 2;public static Version max(Version version1, Version version2) { return version1.id > version2.id ? version1 : version2_ };returns,the,maximum,version,between,the,2;public,static,version,max,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version max(Version version1, Version version2);1532534495;Returns the maximum version between the 2;public static Version max(Version version1, Version version2) { return version1.id > version2.id ? version1 : version2_ };returns,the,maximum,version,between,the,2;public,static,version,max,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version max(Version version1, Version version2);1532685069;Returns the maximum version between the 2;public static Version max(Version version1, Version version2) { return version1.id > version2.id ? version1 : version2_ };returns,the,maximum,version,between,the,2;public,static,version,max,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version max(Version version1, Version version2);1535057785;Returns the maximum version between the 2;public static Version max(Version version1, Version version2) { return version1.id > version2.id ? version1 : version2_ };returns,the,maximum,version,between,the,2;public,static,version,max,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version max(Version version1, Version version2);1535139672;Returns the maximum version between the 2;public static Version max(Version version1, Version version2) { return version1.id > version2.id ? version1 : version2_ };returns,the,maximum,version,between,the,2;public,static,version,max,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version max(Version version1, Version version2);1536137328;Returns the maximum version between the 2;public static Version max(Version version1, Version version2) { return version1.id > version2.id ? version1 : version2_ };returns,the,maximum,version,between,the,2;public,static,version,max,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version max(Version version1, Version version2);1536314350;Returns the maximum version between the 2;public static Version max(Version version1, Version version2) { return version1.id > version2.id ? version1 : version2_ };returns,the,maximum,version,between,the,2;public,static,version,max,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version max(Version version1, Version version2);1537300661;Returns the maximum version between the 2;public static Version max(Version version1, Version version2) { return version1.id > version2.id ? version1 : version2_ };returns,the,maximum,version,between,the,2;public,static,version,max,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version max(Version version1, Version version2);1538509426;Returns the maximum version between the 2;public static Version max(Version version1, Version version2) { return version1.id > version2.id ? version1 : version2_ };returns,the,maximum,version,between,the,2;public,static,version,max,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version max(Version version1, Version version2);1540486836;Returns the maximum version between the 2;public static Version max(Version version1, Version version2) { return version1.id > version2.id ? version1 : version2_ };returns,the,maximum,version,between,the,2;public,static,version,max,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version max(Version version1, Version version2);1541502933;Returns the maximum version between the 2;public static Version max(Version version1, Version version2) { return version1.id > version2.id ? version1 : version2_ };returns,the,maximum,version,between,the,2;public,static,version,max,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version max(Version version1, Version version2);1541528420;Returns the maximum version between the 2;public static Version max(Version version1, Version version2) { return version1.id > version2.id ? version1 : version2_ };returns,the,maximum,version,between,the,2;public,static,version,max,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version max(Version version1, Version version2);1541592065;Returns the maximum version between the 2;public static Version max(Version version1, Version version2) { return version1.id > version2.id ? version1 : version2_ };returns,the,maximum,version,between,the,2;public,static,version,max,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version max(Version version1, Version version2);1542226101;Returns the maximum version between the 2;public static Version max(Version version1, Version version2) { return version1.id > version2.id ? version1 : version2_ };returns,the,maximum,version,between,the,2;public,static,version,max,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version max(Version version1, Version version2);1542746006;Returns the maximum version between the 2;public static Version max(Version version1, Version version2) { return version1.id > version2.id ? version1 : version2_ };returns,the,maximum,version,between,the,2;public,static,version,max,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version max(Version version1, Version version2);1543473699;Returns the maximum version between the 2;public static Version max(Version version1, Version version2) { return version1.id > version2.id ? version1 : version2_ };returns,the,maximum,version,between,the,2;public,static,version,max,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version max(Version version1, Version version2);1543942400;Returns the maximum version between the 2;public static Version max(Version version1, Version version2) { return version1.id > version2.id ? version1 : version2_ };returns,the,maximum,version,between,the,2;public,static,version,max,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version max(Version version1, Version version2);1544037309;Returns the maximum version between the 2;public static Version max(Version version1, Version version2) { return version1.id > version2.id ? version1 : version2_ };returns,the,maximum,version,between,the,2;public,static,version,max,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version max(Version version1, Version version2);1544553539;Returns the maximum version between the 2;public static Version max(Version version1, Version version2) { return version1.id > version2.id ? version1 : version2_ };returns,the,maximum,version,between,the,2;public,static,version,max,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version max(Version version1, Version version2);1545225850;Returns the maximum version between the 2;public static Version max(Version version1, Version version2) { return version1.id > version2.id ? version1 : version2_ };returns,the,maximum,version,between,the,2;public,static,version,max,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version max(Version version1, Version version2);1545256934;Returns the maximum version between the 2;public static Version max(Version version1, Version version2) { return version1.id > version2.id ? version1 : version2_ };returns,the,maximum,version,between,the,2;public,static,version,max,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version max(Version version1, Version version2);1546507247;Returns the maximum version between the 2;public static Version max(Version version1, Version version2) { return version1.id > version2.id ? version1 : version2_ };returns,the,maximum,version,between,the,2;public,static,version,max,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version max(Version version1, Version version2);1546537951;Returns the maximum version between the 2;public static Version max(Version version1, Version version2) { return version1.id > version2.id ? version1 : version2_ };returns,the,maximum,version,between,the,2;public,static,version,max,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version max(Version version1, Version version2);1548755041;Returns the maximum version between the 2;public static Version max(Version version1, Version version2) { return version1.id > version2.id ? version1 : version2_ };returns,the,maximum,version,between,the,2;public,static,version,max,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version max(Version version1, Version version2);1548822781;Returns the maximum version between the 2;public static Version max(Version version1, Version version2) { return version1.id > version2.id ? version1 : version2_ };returns,the,maximum,version,between,the,2;public,static,version,max,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version max(Version version1, Version version2);1549608646;Returns the maximum version between the 2;public static Version max(Version version1, Version version2) { return version1.id > version2.id ? version1 : version2_ };returns,the,maximum,version,between,the,2;public,static,version,max,version,version1,version,version2,return,version1,id,version2,id,version1,version2
Version -> public static Version max(Version version1, Version version2);1550604529;Returns the maximum version between the 2;public static Version max(Version version1, Version version2) { return version1.id > version2.id ? version1 : version2_ };returns,the,maximum,version,between,the,2;public,static,version,max,version,version1,version,version2,return,version1,id,version2,id,version1,version2
