commented;modifiers;parameterAmount;loc;comment;code
false;public,static;3;14;;public static Version parseAnalysisVersion(Settings indexSettings, Settings settings, Logger logger) {     // check for explicit version on the specific analyzer component     String sVersion = settings.get("version").     if (sVersion != null) {         return Lucene.parseVersion(sVersion, Version.LATEST, logger).     }     // check for explicit version on the index itself as default for all analysis components     sVersion = indexSettings.get("index.analysis.version").     if (sVersion != null) {         return Lucene.parseVersion(sVersion, Version.LATEST, logger).     }     // resolve the analysis version based on the version the index was created with     return org.elasticsearch.Version.indexCreated(indexSettings).luceneVersion. }
false;public,static;1;4;;public static boolean isNoStopwords(Settings settings) {     String value = settings.get("stopwords").     return value != null && "_none_".equals(value). }
false;public,static;2;13;;public static CharArraySet parseStemExclusion(Settings settings, CharArraySet defaultStemExclusion) {     String value = settings.get("stem_exclusion").     if ("_none_".equals(value)) {         return CharArraySet.EMPTY_SET.     }     List<String> stemExclusion = settings.getAsList("stem_exclusion", null).     if (stemExclusion != null) {         // LUCENE 4 UPGRADE: Should be settings.getAsBoolean("stem_exclusion_case", false)?         return new CharArraySet(stemExclusion, false).     } else {         return defaultStemExclusion.     } }
false;public,static;6;16;;public static CharArraySet parseWords(Environment env, Settings settings, String name, CharArraySet defaultWords, Map<String, Set<?>> namedWords, boolean ignoreCase) {     String value = settings.get(name).     if (value != null) {         if ("_none_".equals(value)) {             return CharArraySet.EMPTY_SET.         } else {             return resolveNamedWords(settings.getAsList(name), namedWords, ignoreCase).         }     }     List<String> pathLoadedWords = getWordList(env, settings, name).     if (pathLoadedWords != null) {         return resolveNamedWords(pathLoadedWords, namedWords, ignoreCase).     }     return defaultWords. }
false;public,static;4;3;;public static CharArraySet parseCommonWords(Environment env, Settings settings, CharArraySet defaultCommonWords, boolean ignoreCase) {     return parseWords(env, settings, "common_words", defaultCommonWords, NAMED_STOP_WORDS, ignoreCase). }
false;public,static;2;4;;public static CharArraySet parseArticles(Environment env, Settings settings) {     boolean articlesCase = settings.getAsBoolean("articles_case", false).     return parseWords(env, settings, "articles", null, null, articlesCase). }
false;public,static;3;5;;public static CharArraySet parseStopWords(Environment env, Settings settings, CharArraySet defaultStopWords) {     boolean stopwordsCase = settings.getAsBoolean("stopwords_case", false).     return parseStopWords(env, settings, defaultStopWords, stopwordsCase). }
false;public,static;4;3;;public static CharArraySet parseStopWords(Environment env, Settings settings, CharArraySet defaultStopWords, boolean ignoreCase) {     return parseWords(env, settings, "stopwords", defaultStopWords, NAMED_STOP_WORDS, ignoreCase). }
false;private,static;3;14;;private static CharArraySet resolveNamedWords(Collection<String> words, Map<String, Set<?>> namedWords, boolean ignoreCase) {     if (namedWords == null) {         return new CharArraySet(words, ignoreCase).     }     CharArraySet setWords = new CharArraySet(words.size(), ignoreCase).     for (String word : words) {         if (namedWords.containsKey(word)) {             setWords.addAll(namedWords.get(word)).         } else {             setWords.add(word).         }     }     return setWords. }
false;public,static;3;8;;public static CharArraySet getWordSet(Environment env, Settings settings, String settingsPrefix) {     List<String> wordList = getWordList(env, settings, settingsPrefix).     if (wordList == null) {         return null.     }     boolean ignoreCase = settings.getAsBoolean(settingsPrefix + "_case", false).     return new CharArraySet(wordList, ignoreCase). }
true;public,static;3;3;/**  * Fetches a list of words from the specified settings file. The list should either be available at the key  * specified by settingsPrefix or in a file specified by settingsPrefix + _path.  *  * @throws IllegalArgumentException  *          If the word list cannot be found at either key.  */ ;/**  * Fetches a list of words from the specified settings file. The list should either be available at the key  * specified by settingsPrefix or in a file specified by settingsPrefix + _path.  *  * @throws IllegalArgumentException  *          If the word list cannot be found at either key.  */ public static List<String> getWordList(Environment env, Settings settings, String settingPrefix) {     return getWordList(env, settings, settingPrefix + "_path", settingPrefix). }
true;public,static;4;26;/**  * Fetches a list of words from the specified settings file. The list should either be available at the key  * specified by <code>settingList</code> or in a file specified by <code>settingPath</code>.  *  * @throws IllegalArgumentException  *          If the word list cannot be found at either key.  */ ;/**  * Fetches a list of words from the specified settings file. The list should either be available at the key  * specified by <code>settingList</code> or in a file specified by <code>settingPath</code>.  *  * @throws IllegalArgumentException  *          If the word list cannot be found at either key.  */ public static List<String> getWordList(Environment env, Settings settings, String settingPath, String settingList) {     String wordListPath = settings.get(settingPath, null).     if (wordListPath == null) {         List<String> explicitWordList = settings.getAsList(settingList, null).         if (explicitWordList == null) {             return null.         } else {             return explicitWordList.         }     }     final Path path = env.configFile().resolve(wordListPath).     try {         return loadWordList(path, "#").     } catch (CharacterCodingException ex) {         String message = String.format(Locale.ROOT, "Unsupported character encoding detected while reading %s: %s - files must be UTF-8 encoded", settingPath, path.toString()).         throw new IllegalArgumentException(message, ex).     } catch (IOException ioe) {         String message = String.format(Locale.ROOT, "IOException while reading %s: %s", settingPath, path.toString()).         throw new IllegalArgumentException(message, ioe).     } }
false;private,static;2;15;;private static List<String> loadWordList(Path path, String comment) throws IOException {     final List<String> result = new ArrayList<>().     try (BufferedReader br = Files.newBufferedReader(path, StandardCharsets.UTF_8)) {         String word.         while ((word = br.readLine()) != null) {             if (!Strings.hasText(word)) {                 continue.             }             if (!word.startsWith(comment)) {                 result.add(word.trim()).             }         }     }     return result. }
true;public,static;3;19;/**  * @return null If no settings set for "settingsPrefix" then return <code>null</code>.  * @throws IllegalArgumentException  *          If the Reader can not be instantiated.  */ ;/**  * @return null If no settings set for "settingsPrefix" then return <code>null</code>.  * @throws IllegalArgumentException  *          If the Reader can not be instantiated.  */ public static Reader getReaderFromFile(Environment env, Settings settings, String settingPrefix) {     String filePath = settings.get(settingPrefix, null).     if (filePath == null) {         return null.     }     final Path path = env.configFile().resolve(filePath).     try {         return Files.newBufferedReader(path, StandardCharsets.UTF_8).     } catch (CharacterCodingException ex) {         String message = String.format(Locale.ROOT, "Unsupported character encoding detected while reading %s_path: %s files must be UTF-8 encoded", settingPrefix, path.toString()).         throw new IllegalArgumentException(message, ex).     } catch (IOException ioe) {         String message = String.format(Locale.ROOT, "IOException while reading %s_path: %s", settingPrefix, path.toString()).         throw new IllegalArgumentException(message, ioe).     } }
