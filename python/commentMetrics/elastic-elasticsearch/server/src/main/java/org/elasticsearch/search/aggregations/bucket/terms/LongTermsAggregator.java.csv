commented;modifiers;parameterAmount;loc;comment;code
false;public;0;7;;@Override public ScoreMode scoreMode() {     if (valuesSource != null && valuesSource.needsScores()) {         return ScoreMode.COMPLETE.     }     return super.scoreMode(). }
false;protected;2;3;;protected SortedNumericDocValues getValues(ValuesSource.Numeric valuesSource, LeafReaderContext ctx) throws IOException {     return valuesSource.longValues(ctx). }
false;public;2;25;;@Override public void collect(int doc, long owningBucketOrdinal) throws IOException {     assert owningBucketOrdinal == 0.     if (values.advanceExact(doc)) {         final int valuesCount = values.docValueCount().         long previous = Long.MAX_VALUE.         for (int i = 0. i < valuesCount. ++i) {             final long val = values.nextValue().             if (previous != val || i == 0) {                 if ((longFilter == null) || (longFilter.accept(val))) {                     long bucketOrdinal = bucketOrds.add(val).                     if (bucketOrdinal < 0) {                         // already seen                         bucketOrdinal = -1 - bucketOrdinal.                         collectExistingBucket(sub, doc, bucketOrdinal).                     } else {                         collectBucket(sub, doc, bucketOrdinal).                     }                 }                 previous = val.             }         }     } }
false;public;2;32;;@Override public LeafBucketCollector getLeafCollector(LeafReaderContext ctx, final LeafBucketCollector sub) throws IOException {     final SortedNumericDocValues values = getValues(valuesSource, ctx).     return new LeafBucketCollectorBase(sub, values) {          @Override         public void collect(int doc, long owningBucketOrdinal) throws IOException {             assert owningBucketOrdinal == 0.             if (values.advanceExact(doc)) {                 final int valuesCount = values.docValueCount().                 long previous = Long.MAX_VALUE.                 for (int i = 0. i < valuesCount. ++i) {                     final long val = values.nextValue().                     if (previous != val || i == 0) {                         if ((longFilter == null) || (longFilter.accept(val))) {                             long bucketOrdinal = bucketOrds.add(val).                             if (bucketOrdinal < 0) {                                 // already seen                                 bucketOrdinal = -1 - bucketOrdinal.                                 collectExistingBucket(sub, doc, bucketOrdinal).                             } else {                                 collectBucket(sub, doc, bucketOrdinal).                             }                         }                         previous = val.                     }                 }             }         }     }. }
false;public;1;65;;@Override public InternalAggregation buildAggregation(long owningBucketOrdinal) throws IOException {     assert owningBucketOrdinal == 0.     if (bucketCountThresholds.getMinDocCount() == 0 && (InternalOrder.isCountDesc(order) == false || bucketOrds.size() < bucketCountThresholds.getRequiredSize())) {         // we need to fill-in the blanks         for (LeafReaderContext ctx : context.searcher().getTopReaderContext().leaves()) {             final SortedNumericDocValues values = getValues(valuesSource, ctx).             for (int docId = 0. docId < ctx.reader().maxDoc(). ++docId) {                 if (values.advanceExact(docId)) {                     final int valueCount = values.docValueCount().                     for (int i = 0. i < valueCount. ++i) {                         long value = values.nextValue().                         if (longFilter == null || longFilter.accept(value)) {                             bucketOrds.add(value).                         }                     }                 }             }         }     }     final int size = (int) Math.min(bucketOrds.size(), bucketCountThresholds.getShardSize()).     long otherDocCount = 0.     BucketPriorityQueue<LongTerms.Bucket> ordered = new BucketPriorityQueue<>(size, order.comparator(this)).     LongTerms.Bucket spare = null.     for (long i = 0. i < bucketOrds.size(). i++) {         if (spare == null) {             spare = new LongTerms.Bucket(0, 0, null, showTermDocCountError, 0, format).         }         spare.term = bucketOrds.get(i).         spare.docCount = bucketDocCount(i).         otherDocCount += spare.docCount.         spare.bucketOrd = i.         if (bucketCountThresholds.getShardMinDocCount() <= spare.docCount) {             spare = ordered.insertWithOverflow(spare).             if (spare == null) {                 consumeBucketsAndMaybeBreak(1).             }         }     }     // Get the top buckets     final LongTerms.Bucket[] list = new LongTerms.Bucket[ordered.size()].     long[] survivingBucketOrds = new long[ordered.size()].     for (int i = ordered.size() - 1. i >= 0. --i) {         final LongTerms.Bucket bucket = (LongTerms.Bucket) ordered.pop().         survivingBucketOrds[i] = bucket.bucketOrd.         list[i] = bucket.         otherDocCount -= bucket.docCount.     }     runDeferredCollections(survivingBucketOrds).     // Now build the aggs     for (int i = 0. i < list.length. i++) {         list[i].aggregations = bucketAggregations(list[i].bucketOrd).         list[i].docCountError = 0.     }     return new LongTerms(name, order, bucketCountThresholds.getRequiredSize(), bucketCountThresholds.getMinDocCount(), pipelineAggregators(), metaData(), format, bucketCountThresholds.getShardSize(), showTermDocCountError, otherDocCount, Arrays.asList(list), 0). }
false;public;0;5;;@Override public InternalAggregation buildEmptyAggregation() {     return new LongTerms(name, order, bucketCountThresholds.getRequiredSize(), bucketCountThresholds.getMinDocCount(), pipelineAggregators(), metaData(), format, bucketCountThresholds.getShardSize(), showTermDocCountError, 0, emptyList(), 0). }
false;public;0;4;;@Override public void doClose() {     Releasables.close(bucketOrds). }
