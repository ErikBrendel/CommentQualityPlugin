commented;modifiers;parameterAmount;loc;comment;code
false;protected;3;5;;@Override protected void doExecute(Task task, ExplainRequest request, ActionListener<ExplainResponse> listener) {     request.nowInMillis = System.currentTimeMillis().     super.doExecute(task, request, listener). }
false;protected;1;4;;@Override protected boolean resolveIndex(ExplainRequest request) {     return true. }
false;protected;2;10;;@Override protected void resolveRequest(ClusterState state, InternalRequest request) {     final AliasFilter aliasFilter = searchService.buildAliasFilter(state, request.concreteIndex(), request.request().index()).     request.request().filteringAlias(aliasFilter).     // Fail fast on the node that received the request.     if (request.request().routing() == null && state.getMetaData().routingRequired(request.concreteIndex())) {         throw new RoutingMissingException(request.concreteIndex(), request.request().type(), request.request().id()).     } }
false;protected;3;13;;@Override protected void asyncShardOperation(ExplainRequest request, ShardId shardId, ActionListener<ExplainResponse> listener) throws IOException {     IndexService indexService = searchService.getIndicesService().indexServiceSafe(shardId.getIndex()).     IndexShard indexShard = indexService.getShard(shardId.id()).     indexShard.awaitShardSearchActive(b -> {         try {             super.asyncShardOperation(request, shardId, listener).         } catch (Exception ex) {             listener.onFailure(ex).         }     }). }
false;protected;2;43;;@Override protected ExplainResponse shardOperation(ExplainRequest request, ShardId shardId) throws IOException {     String[] types.     if (MapperService.SINGLE_MAPPING_NAME.equals(request.type())) {         // typeless explain call         types = Strings.EMPTY_ARRAY.     } else {         types = new String[] { request.type() }.     }     ShardSearchLocalRequest shardSearchLocalRequest = new ShardSearchLocalRequest(shardId, types, request.nowInMillis, request.filteringAlias()).     SearchContext context = searchService.createSearchContext(shardSearchLocalRequest, SearchService.NO_TIMEOUT).     Engine.GetResult result = null.     try {         // No need to check the type, IndexShard#get does it for us         Term uidTerm = new Term(IdFieldMapper.NAME, Uid.encodeId(request.id())).         result = context.indexShard().get(new Engine.Get(false, false, request.type(), request.id(), uidTerm)).         if (!result.exists()) {             return new ExplainResponse(shardId.getIndexName(), request.type(), request.id(), false).         }         context.parsedQuery(context.getQueryShardContext().toQuery(request.query())).         context.preProcess(true).         int topLevelDocId = result.docIdAndVersion().docId + result.docIdAndVersion().docBase.         Explanation explanation = context.searcher().explain(context.query(), topLevelDocId).         for (RescoreContext ctx : context.rescore()) {             Rescorer rescorer = ctx.rescorer().             explanation = rescorer.explain(topLevelDocId, context.searcher(), ctx, explanation).         }         if (request.storedFields() != null || (request.fetchSourceContext() != null && request.fetchSourceContext().fetchSource())) {             // Advantage is that we're not opening a second searcher to retrieve the _source. Also             // because we are working in the same searcher in engineGetResult we can be sure that a             // doc isn't deleted between the initial get and this call.             GetResult getResult = context.indexShard().getService().get(result, request.id(), request.type(), request.storedFields(), request.fetchSourceContext()).             return new ExplainResponse(shardId.getIndexName(), request.type(), request.id(), true, explanation, getResult).         } else {             return new ExplainResponse(shardId.getIndexName(), request.type(), request.id(), true, explanation).         }     } catch (IOException e) {         throw new ElasticsearchException("Could not explain", e).     } finally {         Releasables.close(result, context).     } }
false;protected;0;4;;@Override protected ExplainResponse newResponse() {     return new ExplainResponse(). }
false;protected;2;7;;@Override protected ShardIterator shards(ClusterState state, InternalRequest request) {     return clusterService.operationRouting().getShards(clusterService.state(), request.concreteIndex(), request.request().id(), request.request().routing(), request.request().preference()). }
false;protected;2;6;;@Override protected String getExecutor(ExplainRequest request, ShardId shardId) {     IndexService indexService = searchService.getIndicesService().indexServiceSafe(shardId.getIndex()).     return indexService.getIndexSettings().isSearchThrottled() ? ThreadPool.Names.SEARCH_THROTTLED : super.getExecutor(request, shardId). }
