commented;modifiers;parameterAmount;loc;comment;code
false;protected;2;12;;@Override protected ShardIterator shards(ClusterState state, InternalRequest request) {     if (request.request().doc() != null && request.request().routing() == null) {         // artificial document without routing specified, ignore its "id" and use either random shard or according to preference         GroupShardsIterator<ShardIterator> groupShardsIter = clusterService.operationRouting().searchShards(state, new String[] { request.concreteIndex() }, null, request.request().preference()).         return groupShardsIter.iterator().next().     }     return clusterService.operationRouting().getShards(state, request.concreteIndex(), request.request().id(), request.request().routing(), request.request().preference()). }
false;protected;1;4;;@Override protected boolean resolveIndex(TermVectorsRequest request) {     return true. }
false;protected;2;9;;@Override protected void resolveRequest(ClusterState state, InternalRequest request) {     // update the routing (request#index here is possibly an alias or a parent)     request.request().routing(state.metaData().resolveIndexRouting(request.request().routing(), request.request().index())).     // Fail fast on the node that received the request.     if (request.request().routing() == null && state.getMetaData().routingRequired(request.concreteIndex())) {         throw new RoutingMissingException(request.concreteIndex(), request.request().type(), request.request().id()).     } }
false;protected;3;17;;@Override protected void asyncShardOperation(TermVectorsRequest request, ShardId shardId, ActionListener<TermVectorsResponse> listener) throws IOException {     IndexService indexService = indicesService.indexServiceSafe(shardId.getIndex()).     IndexShard indexShard = indexService.getShard(shardId.id()).     if (request.realtime()) {         // it's a realtime request which is not subject to refresh cycles         super.asyncShardOperation(request, shardId, listener).     } else {         indexShard.awaitShardSearchActive(b -> {             try {                 super.asyncShardOperation(request, shardId, listener).             } catch (Exception ex) {                 listener.onFailure(ex).             }         }).     } }
false;protected;2;6;;@Override protected TermVectorsResponse shardOperation(TermVectorsRequest request, ShardId shardId) {     IndexService indexService = indicesService.indexServiceSafe(shardId.getIndex()).     IndexShard indexShard = indexService.getShard(shardId.id()).     return TermVectorsService.getTermVectors(indexShard, request). }
false;protected;0;4;;@Override protected TermVectorsResponse newResponse() {     return new TermVectorsResponse(). }
false;protected;2;6;;@Override protected String getExecutor(TermVectorsRequest request, ShardId shardId) {     IndexService indexService = indicesService.indexServiceSafe(shardId.getIndex()).     return indexService.getIndexSettings().isSearchThrottled() ? ThreadPool.Names.SEARCH_THROTTLED : super.getExecutor(request, shardId). }
