commented;modifiers;parameterAmount;loc;comment;code
false;public;1;9;;@Override public void doStart(Consumer<? super Response> onResponse) {     if (logger.isDebugEnabled()) {         logger.debug("executing initial scroll against {}{}", isEmpty(firstSearchRequest.indices()) ? "all indices" : firstSearchRequest.indices(), isEmpty(firstSearchRequest.types()) ? "" : firstSearchRequest.types()).     }     searchWithRetry(listener -> client.search(firstSearchRequest, listener), r -> consume(r, onResponse)). }
false;protected;3;9;;@Override protected void doStartNextScroll(String scrollId, TimeValue extraKeepAlive, Consumer<? super Response> onResponse) {     searchWithRetry(listener -> {         SearchScrollRequest request = new SearchScrollRequest().         // Add the wait time into the scroll timeout so it won't timeout while we wait for throttling         request.scrollId(scrollId).scroll(timeValueNanos(firstSearchRequest.scroll().keepAlive().nanos() + extraKeepAlive.nanos())).         client.searchScroll(request, listener).     }, r -> consume(r, onResponse)). }
false;public;1;5;;@Override public void onResponse(ClearScrollResponse response) {     logger.debug("Freed [{}] contexts", response.getNumFreed()).     onCompletion.run(). }
false;public;1;5;;@Override public void onFailure(Exception e) {     logger.warn(() -> new ParameterizedMessage("Failed to clear scroll [{}]", scrollId), e).     onCompletion.run(). }
false;public;2;22;;@Override public void clearScroll(String scrollId, Runnable onCompletion) {     ClearScrollRequest clearScrollRequest = new ClearScrollRequest().     clearScrollRequest.addScrollId(scrollId).     /*          * Unwrap the client so we don't set our task as the parent. If we *did* set our ID then the clear scroll would be cancelled as          * if this task is cancelled. But we want to clear the scroll regardless of whether or not the main request was cancelled.          */     client.unwrap().clearScroll(clearScrollRequest, new ActionListener<ClearScrollResponse>() {          @Override         public void onResponse(ClearScrollResponse response) {             logger.debug("Freed [{}] contexts", response.getNumFreed()).             onCompletion.run().         }          @Override         public void onFailure(Exception e) {             logger.warn(() -> new ParameterizedMessage("Failed to clear scroll [{}]", scrollId), e).             onCompletion.run().         }     }). }
false;protected;1;4;;@Override protected void cleanup(Runnable onCompletion) {     onCompletion.run(). }
false;protected;0;4;;@Override protected void doRun() throws Exception {     action.accept(this). }
false;public;1;4;;@Override public void onResponse(SearchResponse response) {     onResponse.accept(response). }
false;public;1;19;;@Override public void onFailure(Exception e) {     if (ExceptionsHelper.unwrap(e, EsRejectedExecutionException.class) != null) {         if (retries.hasNext()) {             retryCount += 1.             TimeValue delay = retries.next().             logger.trace(() -> new ParameterizedMessage("retrying rejected search after [{}]", delay), e).             countSearchRetry.run().             threadPool.schedule(retryWithContext, delay, ThreadPool.Names.SAME).         } else {             logger.warn(() -> new ParameterizedMessage("giving up on search because we retried [{}] times without success", retryCount), e).             fail.accept(e).         }     } else {         logger.warn("giving up on search because it failed with a non-retryable exception", e).         fail.accept(e).     } }
true;private;2;50;/**  * Run a search action and call onResponse when a the response comes in, retrying if the action fails with an exception caused by  * rejected execution.  *  * @param action consumes a listener and starts the action. The listener it consumes is rigged to retry on failure.  * @param onResponse consumes the response from the action  */ ;/**  * Run a search action and call onResponse when a the response comes in, retrying if the action fails with an exception caused by  * rejected execution.  *  * @param action consumes a listener and starts the action. The listener it consumes is rigged to retry on failure.  * @param onResponse consumes the response from the action  */ private void searchWithRetry(Consumer<ActionListener<SearchResponse>> action, Consumer<SearchResponse> onResponse) {     /*          * RetryHelper is both an AbstractRunnable and an ActionListener<SearchResponse> - meaning that it both starts the search and          * handles reacts to the results. The complexity is all in onFailure which either adapts the failure to the "fail" listener or          * retries the search. Since both AbstractRunnable and ActionListener define the onFailure method it is called for either failure          * to run the action (either while running or before starting) and for failure on the response from the action.          */     class RetryHelper extends AbstractRunnable implements ActionListener<SearchResponse> {          private final Iterator<TimeValue> retries = backoffPolicy.iterator().          /**          * The runnable to run that retries in the same context as the original call.          */         private Runnable retryWithContext.          private volatile int retryCount = 0.          @Override         protected void doRun() throws Exception {             action.accept(this).         }          @Override         public void onResponse(SearchResponse response) {             onResponse.accept(response).         }          @Override         public void onFailure(Exception e) {             if (ExceptionsHelper.unwrap(e, EsRejectedExecutionException.class) != null) {                 if (retries.hasNext()) {                     retryCount += 1.                     TimeValue delay = retries.next().                     logger.trace(() -> new ParameterizedMessage("retrying rejected search after [{}]", delay), e).                     countSearchRetry.run().                     threadPool.schedule(retryWithContext, delay, ThreadPool.Names.SAME).                 } else {                     logger.warn(() -> new ParameterizedMessage("giving up on search because we retried [{}] times without success", retryCount), e).                     fail.accept(e).                 }             } else {                 logger.warn("giving up on search because it failed with a non-retryable exception", e).                 fail.accept(e).             }         }     }     RetryHelper helper = new RetryHelper().     // Wrap the helper in a runnable that preserves the current context so we keep it on retry.     helper.retryWithContext = threadPool.getThreadContext().preserveContext(helper).     helper.run(). }
false;private;2;3;;private void consume(SearchResponse response, Consumer<? super Response> onResponse) {     onResponse.accept(wrap(response)). }
false;private;1;25;;private Response wrap(SearchResponse response) {     List<SearchFailure> failures.     if (response.getShardFailures() == null) {         failures = emptyList().     } else {         failures = new ArrayList<>(response.getShardFailures().length).         for (ShardSearchFailure failure : response.getShardFailures()) {             String nodeId = failure.shard() == null ? null : failure.shard().getNodeId().             failures.add(new SearchFailure(failure.getCause(), failure.index(), failure.shardId(), nodeId)).         }     }     List<Hit> hits.     if (response.getHits().getHits() == null || response.getHits().getHits().length == 0) {         hits = emptyList().     } else {         hits = new ArrayList<>(response.getHits().getHits().length).         for (SearchHit hit : response.getHits().getHits()) {             hits.add(new ClientHit(hit)).         }         hits = unmodifiableList(hits).     }     long total = response.getHits().getTotalHits().value.     return new Response(response.isTimedOut(), failures, total, hits, response.getScrollId()). }
false;public;0;4;;@Override public String getIndex() {     return delegate.getIndex(). }
false;public;0;4;;@Override public String getType() {     return delegate.getType(). }
false;public;0;4;;@Override public String getId() {     return delegate.getId(). }
false;public;0;4;;@Override public BytesReference getSource() {     return source. }
false;public;0;4;;@Override public XContentType getXContentType() {     return XContentHelper.xContentType(source). }
false;public;0;4;;@Override public long getVersion() {     return delegate.getVersion(). }
false;public;0;4;;@Override public long getSeqNo() {     return delegate.getSeqNo(). }
false;public;0;4;;@Override public long getPrimaryTerm() {     return delegate.getPrimaryTerm(). }
false;public;0;4;;@Override public String getRouting() {     return fieldValue(RoutingFieldMapper.NAME). }
false;private;1;4;;private <T> T fieldValue(String fieldName) {     DocumentField field = delegate.field(fieldName).     return field == null ? null : field.getValue(). }
