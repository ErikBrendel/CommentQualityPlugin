# id;timestamp;commentText;codeText;commentWords;codeWords
ClientScrollableHitSource -> private void searchWithRetry(Consumer<ActionListener<SearchResponse>> action, Consumer<SearchResponse> onResponse);1524684173;Run a search action and call onResponse when a the response comes in, retrying if the action fails with an exception caused by_rejected execution.__@param action consumes a listener and starts the action. The listener it consumes is rigged to retry on failure._@param onResponse consumes the response from the action;private void searchWithRetry(Consumer<ActionListener<SearchResponse>> action, Consumer<SearchResponse> onResponse) {_        _        class RetryHelper extends AbstractRunnable implements ActionListener<SearchResponse> {_            private final Iterator<TimeValue> retries = backoffPolicy.iterator()__            _            private Runnable retryWithContext__            private volatile int retryCount = 0___            @Override_            protected void doRun() throws Exception {_                action.accept(this)__            }__            @Override_            public void onResponse(SearchResponse response) {_                onResponse.accept(response)__            }__            @Override_            public void onFailure(Exception e) {_                if (ExceptionsHelper.unwrap(e, EsRejectedExecutionException.class) != null) {_                    if (retries.hasNext()) {_                        retryCount += 1__                        TimeValue delay = retries.next()__                        logger.trace(() -> new ParameterizedMessage("retrying rejected search after [{}]", delay), e)__                        countSearchRetry.run()__                        threadPool.schedule(delay, ThreadPool.Names.SAME, retryWithContext)__                    } else {_                        logger.warn(() -> new ParameterizedMessage(_                                "giving up on search because we retried [{}] times without success", retryCount), e)__                        fail.accept(e)__                    }_                } else {_                    logger.warn("giving up on search because it failed with a non-retryable exception", e)__                    fail.accept(e)__                }_            }_        }_        RetryHelper helper = new RetryHelper()__        _        helper.retryWithContext = threadPool.getThreadContext().preserveContext(helper)__        helper.run()__    };run,a,search,action,and,call,on,response,when,a,the,response,comes,in,retrying,if,the,action,fails,with,an,exception,caused,by,rejected,execution,param,action,consumes,a,listener,and,starts,the,action,the,listener,it,consumes,is,rigged,to,retry,on,failure,param,on,response,consumes,the,response,from,the,action;private,void,search,with,retry,consumer,action,listener,search,response,action,consumer,search,response,on,response,class,retry,helper,extends,abstract,runnable,implements,action,listener,search,response,private,final,iterator,time,value,retries,backoff,policy,iterator,private,runnable,retry,with,context,private,volatile,int,retry,count,0,override,protected,void,do,run,throws,exception,action,accept,this,override,public,void,on,response,search,response,response,on,response,accept,response,override,public,void,on,failure,exception,e,if,exceptions,helper,unwrap,e,es,rejected,execution,exception,class,null,if,retries,has,next,retry,count,1,time,value,delay,retries,next,logger,trace,new,parameterized,message,retrying,rejected,search,after,delay,e,count,search,retry,run,thread,pool,schedule,delay,thread,pool,names,same,retry,with,context,else,logger,warn,new,parameterized,message,giving,up,on,search,because,we,retried,times,without,success,retry,count,e,fail,accept,e,else,logger,warn,giving,up,on,search,because,it,failed,with,a,non,retryable,exception,e,fail,accept,e,retry,helper,helper,new,retry,helper,helper,retry,with,context,thread,pool,get,thread,context,preserve,context,helper,helper,run
ClientScrollableHitSource -> private void searchWithRetry(Consumer<ActionListener<SearchResponse>> action, Consumer<SearchResponse> onResponse);1544035746;Run a search action and call onResponse when a the response comes in, retrying if the action fails with an exception caused by_rejected execution.__@param action consumes a listener and starts the action. The listener it consumes is rigged to retry on failure._@param onResponse consumes the response from the action;private void searchWithRetry(Consumer<ActionListener<SearchResponse>> action, Consumer<SearchResponse> onResponse) {_        _        class RetryHelper extends AbstractRunnable implements ActionListener<SearchResponse> {_            private final Iterator<TimeValue> retries = backoffPolicy.iterator()__            _            private Runnable retryWithContext__            private volatile int retryCount = 0___            @Override_            protected void doRun() throws Exception {_                action.accept(this)__            }__            @Override_            public void onResponse(SearchResponse response) {_                onResponse.accept(response)__            }__            @Override_            public void onFailure(Exception e) {_                if (ExceptionsHelper.unwrap(e, EsRejectedExecutionException.class) != null) {_                    if (retries.hasNext()) {_                        retryCount += 1__                        TimeValue delay = retries.next()__                        logger.trace(() -> new ParameterizedMessage("retrying rejected search after [{}]", delay), e)__                        countSearchRetry.run()__                        threadPool.schedule(delay, ThreadPool.Names.SAME, retryWithContext)__                    } else {_                        logger.warn(() -> new ParameterizedMessage(_                                "giving up on search because we retried [{}] times without success", retryCount), e)__                        fail.accept(e)__                    }_                } else {_                    logger.warn("giving up on search because it failed with a non-retryable exception", e)__                    fail.accept(e)__                }_            }_        }_        RetryHelper helper = new RetryHelper()__        _        helper.retryWithContext = threadPool.getThreadContext().preserveContext(helper)__        helper.run()__    };run,a,search,action,and,call,on,response,when,a,the,response,comes,in,retrying,if,the,action,fails,with,an,exception,caused,by,rejected,execution,param,action,consumes,a,listener,and,starts,the,action,the,listener,it,consumes,is,rigged,to,retry,on,failure,param,on,response,consumes,the,response,from,the,action;private,void,search,with,retry,consumer,action,listener,search,response,action,consumer,search,response,on,response,class,retry,helper,extends,abstract,runnable,implements,action,listener,search,response,private,final,iterator,time,value,retries,backoff,policy,iterator,private,runnable,retry,with,context,private,volatile,int,retry,count,0,override,protected,void,do,run,throws,exception,action,accept,this,override,public,void,on,response,search,response,response,on,response,accept,response,override,public,void,on,failure,exception,e,if,exceptions,helper,unwrap,e,es,rejected,execution,exception,class,null,if,retries,has,next,retry,count,1,time,value,delay,retries,next,logger,trace,new,parameterized,message,retrying,rejected,search,after,delay,e,count,search,retry,run,thread,pool,schedule,delay,thread,pool,names,same,retry,with,context,else,logger,warn,new,parameterized,message,giving,up,on,search,because,we,retried,times,without,success,retry,count,e,fail,accept,e,else,logger,warn,giving,up,on,search,because,it,failed,with,a,non,retryable,exception,e,fail,accept,e,retry,helper,helper,new,retry,helper,helper,retry,with,context,thread,pool,get,thread,context,preserve,context,helper,helper,run
ClientScrollableHitSource -> private void searchWithRetry(Consumer<ActionListener<SearchResponse>> action, Consumer<SearchResponse> onResponse);1548775385;Run a search action and call onResponse when a the response comes in, retrying if the action fails with an exception caused by_rejected execution.__@param action consumes a listener and starts the action. The listener it consumes is rigged to retry on failure._@param onResponse consumes the response from the action;private void searchWithRetry(Consumer<ActionListener<SearchResponse>> action, Consumer<SearchResponse> onResponse) {_        _        class RetryHelper extends AbstractRunnable implements ActionListener<SearchResponse> {_            private final Iterator<TimeValue> retries = backoffPolicy.iterator()__            _            private Runnable retryWithContext__            private volatile int retryCount = 0___            @Override_            protected void doRun() throws Exception {_                action.accept(this)__            }__            @Override_            public void onResponse(SearchResponse response) {_                onResponse.accept(response)__            }__            @Override_            public void onFailure(Exception e) {_                if (ExceptionsHelper.unwrap(e, EsRejectedExecutionException.class) != null) {_                    if (retries.hasNext()) {_                        retryCount += 1__                        TimeValue delay = retries.next()__                        logger.trace(() -> new ParameterizedMessage("retrying rejected search after [{}]", delay), e)__                        countSearchRetry.run()__                        threadPool.schedule(delay, ThreadPool.Names.SAME, retryWithContext)__                    } else {_                        logger.warn(() -> new ParameterizedMessage(_                                "giving up on search because we retried [{}] times without success", retryCount), e)__                        fail.accept(e)__                    }_                } else {_                    logger.warn("giving up on search because it failed with a non-retryable exception", e)__                    fail.accept(e)__                }_            }_        }_        RetryHelper helper = new RetryHelper()__        _        helper.retryWithContext = threadPool.getThreadContext().preserveContext(helper)__        helper.run()__    };run,a,search,action,and,call,on,response,when,a,the,response,comes,in,retrying,if,the,action,fails,with,an,exception,caused,by,rejected,execution,param,action,consumes,a,listener,and,starts,the,action,the,listener,it,consumes,is,rigged,to,retry,on,failure,param,on,response,consumes,the,response,from,the,action;private,void,search,with,retry,consumer,action,listener,search,response,action,consumer,search,response,on,response,class,retry,helper,extends,abstract,runnable,implements,action,listener,search,response,private,final,iterator,time,value,retries,backoff,policy,iterator,private,runnable,retry,with,context,private,volatile,int,retry,count,0,override,protected,void,do,run,throws,exception,action,accept,this,override,public,void,on,response,search,response,response,on,response,accept,response,override,public,void,on,failure,exception,e,if,exceptions,helper,unwrap,e,es,rejected,execution,exception,class,null,if,retries,has,next,retry,count,1,time,value,delay,retries,next,logger,trace,new,parameterized,message,retrying,rejected,search,after,delay,e,count,search,retry,run,thread,pool,schedule,delay,thread,pool,names,same,retry,with,context,else,logger,warn,new,parameterized,message,giving,up,on,search,because,we,retried,times,without,success,retry,count,e,fail,accept,e,else,logger,warn,giving,up,on,search,because,it,failed,with,a,non,retryable,exception,e,fail,accept,e,retry,helper,helper,new,retry,helper,helper,retry,with,context,thread,pool,get,thread,context,preserve,context,helper,helper,run
ClientScrollableHitSource -> private void searchWithRetry(Consumer<ActionListener<SearchResponse>> action, Consumer<SearchResponse> onResponse);1548953505;Run a search action and call onResponse when a the response comes in, retrying if the action fails with an exception caused by_rejected execution.__@param action consumes a listener and starts the action. The listener it consumes is rigged to retry on failure._@param onResponse consumes the response from the action;private void searchWithRetry(Consumer<ActionListener<SearchResponse>> action, Consumer<SearchResponse> onResponse) {_        _        class RetryHelper extends AbstractRunnable implements ActionListener<SearchResponse> {_            private final Iterator<TimeValue> retries = backoffPolicy.iterator()__            _            private Runnable retryWithContext__            private volatile int retryCount = 0___            @Override_            protected void doRun() throws Exception {_                action.accept(this)__            }__            @Override_            public void onResponse(SearchResponse response) {_                onResponse.accept(response)__            }__            @Override_            public void onFailure(Exception e) {_                if (ExceptionsHelper.unwrap(e, EsRejectedExecutionException.class) != null) {_                    if (retries.hasNext()) {_                        retryCount += 1__                        TimeValue delay = retries.next()__                        logger.trace(() -> new ParameterizedMessage("retrying rejected search after [{}]", delay), e)__                        countSearchRetry.run()__                        threadPool.schedule(retryWithContext, delay, ThreadPool.Names.SAME)__                    } else {_                        logger.warn(() -> new ParameterizedMessage(_                                "giving up on search because we retried [{}] times without success", retryCount), e)__                        fail.accept(e)__                    }_                } else {_                    logger.warn("giving up on search because it failed with a non-retryable exception", e)__                    fail.accept(e)__                }_            }_        }_        RetryHelper helper = new RetryHelper()__        _        helper.retryWithContext = threadPool.getThreadContext().preserveContext(helper)__        helper.run()__    };run,a,search,action,and,call,on,response,when,a,the,response,comes,in,retrying,if,the,action,fails,with,an,exception,caused,by,rejected,execution,param,action,consumes,a,listener,and,starts,the,action,the,listener,it,consumes,is,rigged,to,retry,on,failure,param,on,response,consumes,the,response,from,the,action;private,void,search,with,retry,consumer,action,listener,search,response,action,consumer,search,response,on,response,class,retry,helper,extends,abstract,runnable,implements,action,listener,search,response,private,final,iterator,time,value,retries,backoff,policy,iterator,private,runnable,retry,with,context,private,volatile,int,retry,count,0,override,protected,void,do,run,throws,exception,action,accept,this,override,public,void,on,response,search,response,response,on,response,accept,response,override,public,void,on,failure,exception,e,if,exceptions,helper,unwrap,e,es,rejected,execution,exception,class,null,if,retries,has,next,retry,count,1,time,value,delay,retries,next,logger,trace,new,parameterized,message,retrying,rejected,search,after,delay,e,count,search,retry,run,thread,pool,schedule,retry,with,context,delay,thread,pool,names,same,else,logger,warn,new,parameterized,message,giving,up,on,search,because,we,retried,times,without,success,retry,count,e,fail,accept,e,else,logger,warn,giving,up,on,search,because,it,failed,with,a,non,retryable,exception,e,fail,accept,e,retry,helper,helper,new,retry,helper,helper,retry,with,context,thread,pool,get,thread,context,preserve,context,helper,helper,run
