commented;modifiers;parameterAmount;loc;comment;code
false;final;1;7;;final int numPages(long capacity) {     final long numPages = (capacity + pageMask) >>> pageShift.     if (numPages > Integer.MAX_VALUE) {         throw new IllegalArgumentException("pageSize=" + (pageMask + 1) + " is too small for such as capacity: " + capacity).     }     return (int) numPages. }
false;final;0;3;;final int pageSize() {     return pageMask + 1. }
false;final;1;3;;final int pageIndex(long index) {     return (int) (index >>> pageShift). }
false;final;1;3;;final int indexInPage(long index) {     return (int) (index & pageMask). }
false;public,final;0;4;;@Override public final long size() {     return size. }
false;public,abstract;1;1;;public abstract void resize(long newSize).
false;protected,abstract;0;1;;protected abstract int numBytesPerElement().
false;public,final;0;4;;@Override public final long ramBytesUsed() {     return ramBytesEstimated(size). }
true;public,final;1;4;/**  * Given the size of the array, estimate the number of bytes it will use.  */ ;/**  * Given the size of the array, estimate the number of bytes it will use.  */ public final long ramBytesEstimated(final long size) {     // rough approximate, we only take into account the size of the values, not the overhead of the array objects     return ((long) pageIndex(size - 1) + 1) * pageSize() * numBytesPerElement(). }
false;private,static;2;7;;private static <T> T[] grow(T[] array, int minSize) {     if (array.length < minSize) {         final int newLen = ArrayUtil.oversize(minSize, RamUsageEstimator.NUM_BYTES_OBJECT_REF).         array = Arrays.copyOf(array, newLen).     }     return array. }
false;private;3;7;;private <T> T registerNewPage(Recycler.V<T> v, int page, int expectedSize) {     cache = grow(cache, page + 1).     assert cache[page] == null.     cache[page] = v.     assert Array.getLength(v.v()) == expectedSize.     return v.v(). }
false;protected,final;1;8;;protected final byte[] newBytePage(int page) {     if (recycler != null) {         final Recycler.V<byte[]> v = recycler.bytePage(clearOnResize).         return registerNewPage(v, page, PageCacheRecycler.BYTE_PAGE_SIZE).     } else {         return new byte[PageCacheRecycler.BYTE_PAGE_SIZE].     } }
false;protected,final;1;8;;protected final int[] newIntPage(int page) {     if (recycler != null) {         final Recycler.V<int[]> v = recycler.intPage(clearOnResize).         return registerNewPage(v, page, PageCacheRecycler.INT_PAGE_SIZE).     } else {         return new int[PageCacheRecycler.INT_PAGE_SIZE].     } }
false;protected,final;1;8;;protected final long[] newLongPage(int page) {     if (recycler != null) {         final Recycler.V<long[]> v = recycler.longPage(clearOnResize).         return registerNewPage(v, page, PageCacheRecycler.LONG_PAGE_SIZE).     } else {         return new long[PageCacheRecycler.LONG_PAGE_SIZE].     } }
false;protected,final;1;8;;protected final Object[] newObjectPage(int page) {     if (recycler != null) {         final Recycler.V<Object[]> v = recycler.objectPage().         return registerNewPage(v, page, PageCacheRecycler.OBJECT_PAGE_SIZE).     } else {         return new Object[PageCacheRecycler.OBJECT_PAGE_SIZE].     } }
false;protected,final;1;6;;protected final void releasePage(int page) {     if (recycler != null) {         cache[page].close().         cache[page] = null.     } }
false;protected,final;0;7;;@Override protected final void doClose() {     if (recycler != null) {         Releasables.close(cache).         cache = null.     } }
