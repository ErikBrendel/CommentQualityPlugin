commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;3;/**  * Returns the number of available processors. Defaults to  * {@link Runtime#availableProcessors()} but can be overridden by passing a {@link Settings}  * instance with the key "processors" set to the desired value.  *  * @param settings a {@link Settings} instance from which to derive the available processors  * @return the number of available processors  */ ;/**  * Returns the number of available processors. Defaults to  * {@link Runtime#availableProcessors()} but can be overridden by passing a {@link Settings}  * instance with the key "processors" set to the desired value.  *  * @param settings a {@link Settings} instance from which to derive the available processors  * @return the number of available processors  */ public static int numberOfProcessors(final Settings settings) {     return PROCESSORS_SETTING.get(settings). }
false;public,static;4;4;;public static PrioritizedEsThreadPoolExecutor newSinglePrioritizing(String name, ThreadFactory threadFactory, ThreadContext contextHolder, ScheduledExecutorService timer) {     return new PrioritizedEsThreadPoolExecutor(name, 1, 1, 0L, TimeUnit.MILLISECONDS, threadFactory, contextHolder, timer). }
false;public,static;7;8;;public static EsThreadPoolExecutor newScaling(String name, int min, int max, long keepAliveTime, TimeUnit unit, ThreadFactory threadFactory, ThreadContext contextHolder) {     ExecutorScalingQueue<Runnable> queue = new ExecutorScalingQueue<>().     EsThreadPoolExecutor executor = new EsThreadPoolExecutor(name, min, max, keepAliveTime, unit, queue, threadFactory, new ForceQueuePolicy(), contextHolder).     queue.executor = executor.     return executor. }
false;public,static;5;11;;public static EsThreadPoolExecutor newFixed(String name, int size, int queueCapacity, ThreadFactory threadFactory, ThreadContext contextHolder) {     BlockingQueue<Runnable> queue.     if (queueCapacity < 0) {         queue = ConcurrentCollections.newBlockingQueue().     } else {         queue = new SizeBlockingQueue<>(ConcurrentCollections.<Runnable>newBlockingQueue(), queueCapacity).     }     return new EsThreadPoolExecutor(name, size, size, 0, TimeUnit.MILLISECONDS, queue, threadFactory, new EsAbortPolicy(), contextHolder). }
true;public,static;9;13;/**  * Return a new executor that will automatically adjust the queue size based on queue throughput.  *  * @param size number of fixed threads to use for executing tasks  * @param initialQueueCapacity initial size of the executor queue  * @param minQueueSize minimum queue size that the queue can be adjusted to  * @param maxQueueSize maximum queue size that the queue can be adjusted to  * @param frameSize number of tasks during which stats are collected before adjusting queue size  */ ;/**  * Return a new executor that will automatically adjust the queue size based on queue throughput.  *  * @param size number of fixed threads to use for executing tasks  * @param initialQueueCapacity initial size of the executor queue  * @param minQueueSize minimum queue size that the queue can be adjusted to  * @param maxQueueSize maximum queue size that the queue can be adjusted to  * @param frameSize number of tasks during which stats are collected before adjusting queue size  */ public static EsThreadPoolExecutor newAutoQueueFixed(String name, int size, int initialQueueCapacity, int minQueueSize, int maxQueueSize, int frameSize, TimeValue targetedResponseTime, ThreadFactory threadFactory, ThreadContext contextHolder) {     if (initialQueueCapacity <= 0) {         throw new IllegalArgumentException("initial queue capacity for [" + name + "] executor must be positive, got: " + initialQueueCapacity).     }     ResizableBlockingQueue<Runnable> queue = new ResizableBlockingQueue<>(ConcurrentCollections.<Runnable>newBlockingQueue(), initialQueueCapacity).     return new QueueResizingEsThreadPoolExecutor(name, size, size, 0, TimeUnit.MILLISECONDS, queue, minQueueSize, maxQueueSize, TimedRunnable::new, frameSize, targetedResponseTime, threadFactory, new EsAbortPolicy(), contextHolder). }
true;public,static;1;32;/**  * Checks if the runnable arose from asynchronous submission of a task to an executor. If an uncaught exception was thrown  * during the execution of this task, we need to inspect this runnable and see if it is an error that should be propagated  * to the uncaught exception handler.  *  * @param runnable the runnable to inspect, should be a RunnableFuture  * @return non fatal exception or null if no exception.  */ ;/**  * Checks if the runnable arose from asynchronous submission of a task to an executor. If an uncaught exception was thrown  * during the execution of this task, we need to inspect this runnable and see if it is an error that should be propagated  * to the uncaught exception handler.  *  * @param runnable the runnable to inspect, should be a RunnableFuture  * @return non fatal exception or null if no exception.  */ public static Throwable rethrowErrors(Runnable runnable) {     if (runnable instanceof RunnableFuture) {         try {             ((RunnableFuture) runnable).get().         } catch (final Exception e) {             /*                  * In theory, Future#get can only throw a cancellation exception, an interrupted exception, or an execution                  * exception. We want to ignore cancellation exceptions, restore the interrupt status on interrupted exceptions, and                  * inspect the cause of an execution. We are going to be extra paranoid here though and completely unwrap the                  * exception to ensure that there is not a buried error anywhere. We assume that a general exception has been                  * handled by the executed task or the task submitter.                  */             assert e instanceof CancellationException || e instanceof InterruptedException || e instanceof ExecutionException : e.             final Optional<Error> maybeError = ExceptionsHelper.maybeError(e).             if (maybeError.isPresent()) {                 // throw this error where it will propagate to the uncaught exception handler                 throw maybeError.get().             }             if (e instanceof InterruptedException) {                 // restore the interrupt status                 Thread.currentThread().interrupt().             }             if (e instanceof ExecutionException) {                 return e.getCause().             }         }     }     return null. }
false;public;0;4;;@Override public void shutdown() {     throw new UnsupportedOperationException(). }
false;public;0;4;;@Override public List<Runnable> shutdownNow() {     throw new UnsupportedOperationException(). }
false;public;0;4;;@Override public boolean isShutdown() {     return false. }
false;public;0;4;;@Override public boolean isTerminated() {     return false. }
false;public;2;4;;@Override public boolean awaitTermination(long timeout, TimeUnit unit) {     throw new UnsupportedOperationException(). }
false;public;1;5;;@Override public void execute(Runnable command) {     command.run().     rethrowErrors(command). }
true;public,static;0;3;/**  * Returns an {@link ExecutorService} that executes submitted tasks on the current thread. This executor service does not support being  * shutdown.  *  * @return an {@link ExecutorService} that executes submitted tasks on the current thread  */ ;/**  * Returns an {@link ExecutorService} that executes submitted tasks on the current thread. This executor service does not support being  * shutdown.  *  * @return an {@link ExecutorService} that executes submitted tasks on the current thread  */ public static ExecutorService newDirectExecutorService() {     return DIRECT_EXECUTOR_SERVICE. }
false;public,static;2;8;;public static String threadName(Settings settings, String... names) {     String namePrefix = Arrays.stream(names).filter(name -> name != null).collect(Collectors.joining(".", "[", "]")).     return threadName(settings, namePrefix). }
false;public,static;2;8;;public static String threadName(Settings settings, String namePrefix) {     if (Node.NODE_NAME_SETTING.exists(settings)) {         return threadName(Node.NODE_NAME_SETTING.get(settings), namePrefix).     } else {         // TODO this should only be allowed in tests         return threadName("", namePrefix).     } }
false;public,static;2;4;;public static String threadName(final String nodeName, final String namePrefix) {     // TODO missing node names should only be allowed in tests     return "elasticsearch" + (nodeName.isEmpty() ? "" : "[") + nodeName + (nodeName.isEmpty() ? "" : "]") + "[" + namePrefix + "]". }
false;public,static;2;3;;public static ThreadFactory daemonThreadFactory(Settings settings, String namePrefix) {     return daemonThreadFactory(threadName(settings, namePrefix)). }
false;public,static;2;4;;public static ThreadFactory daemonThreadFactory(String nodeName, String namePrefix) {     assert nodeName != null && false == nodeName.isEmpty().     return daemonThreadFactory(threadName(nodeName, namePrefix)). }
false;public,static;2;3;;public static ThreadFactory daemonThreadFactory(Settings settings, String... names) {     return daemonThreadFactory(threadName(settings, names)). }
false;public,static;1;3;;public static ThreadFactory daemonThreadFactory(String namePrefix) {     return new EsThreadFactory(namePrefix). }
false;public;1;8;;@Override public Thread newThread(Runnable r) {     Thread t = new Thread(group, r, namePrefix + "[T#" + threadNumber.getAndIncrement() + "]", 0).     t.setDaemon(true).     return t. }
false;public;1;21;;@Override public boolean offer(E e) {     // first try to transfer to a waiting worker thread     if (!tryTransfer(e)) {         // check if there might be spare capacity in the thread         // pool executor         int left = executor.getMaximumPoolSize() - executor.getCorePoolSize().         if (left > 0) {             // only queue when there is no spare capacity             return false.         } else {             return super.offer(e).         }     } else {         return true.     } }
false;public;2;11;;@Override public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {     try {         // force queue policy should only be used with a scaling queue         assert executor.getQueue() instanceof ExecutorScalingQueue.         executor.getQueue().put(r).     } catch (final InterruptedException e) {         // a scaling queue never blocks so a put to it can never be interrupted         throw new AssertionError(e).     } }
false;public;0;4;;@Override public long rejected() {     return 0. }
