commented;modifiers;parameterAmount;loc;comment;code
false;public,final;8;12;;@Override public final Query rangeQuery(Object lowerTerm, Object upperTerm, boolean includeLower, boolean includeUpper, ShapeRelation relation, ZoneId timeZone, DateMathParser parser, QueryShardContext context) {     if (relation == ShapeRelation.DISJOINT) {         throw new IllegalArgumentException("Field [" + name() + "] of type [" + typeName() + "] does not support DISJOINT ranges").     }     // but then the API has no way to know which fields are dates and which fields are not dates     return rangeQuery(lowerTerm, upperTerm, includeLower, includeUpper, context). }
true;protected;5;4;/**  * Same as {@link #rangeQuery(Object, Object, boolean, boolean, ShapeRelation, ZoneId, DateMathParser, QueryShardContext)}  * but without the trouble of relations or date-specific options.  */ ;/**  * Same as {@link #rangeQuery(Object, Object, boolean, boolean, ShapeRelation, ZoneId, DateMathParser, QueryShardContext)}  * but without the trouble of relations or date-specific options.  */ protected Query rangeQuery(Object lowerTerm, Object upperTerm, boolean includeLower, boolean includeUpper, QueryShardContext context) {     throw new IllegalArgumentException("Field [" + name() + "] of type [" + typeName() + "] does not support range queries"). }
