commented;modifiers;parameterAmount;loc;comment;code
false;private;1;3;;private void setLang(String lang) {     this.lang = lang. }
true;private;1;14;/**  * Since stored scripts can accept templates rather than just scripts, they must also be able  * to handle template parsing, hence the need for custom parsing source.  Templates can  * consist of either an {@link String} or a JSON object.  If a JSON object is discovered  * then the content type option must also be saved as a compiler option.  */ ;/**  * Since stored scripts can accept templates rather than just scripts, they must also be able  * to handle template parsing, hence the need for custom parsing source.  Templates can  * consist of either an {@link String} or a JSON object.  If a JSON object is discovered  * then the content type option must also be saved as a compiler option.  */ private void setSource(XContentParser parser) {     try {         if (parser.currentToken() == Token.START_OBJECT) {             // this is really for search templates, that need to be converted to json format             XContentBuilder builder = XContentFactory.jsonBuilder().             source = Strings.toString(builder.copyCurrentStructure(parser)).             options.put(Script.CONTENT_TYPE_OPTION, XContentType.JSON.mediaType()).         } else {             source = parser.text().         }     } catch (IOException exception) {         throw new UncheckedIOException(exception).     } }
true;private;1;3;/**  * Options may have already been added if a template was specified.  * Appends the user-defined compiler options with the internal compiler options.  */ ;/**  * Options may have already been added if a template was specified.  * Appends the user-defined compiler options with the internal compiler options.  */ private void setOptions(Map<String, String> options) {     this.options.putAll(options). }
true;private;1;35;/**  * Validates the parameters and creates an {@link StoredScriptSource}.  *  * @param ignoreEmpty Specify as {@code true} to ignoreEmpty the empty source check.  *                    This allow empty templates to be loaded for backwards compatibility.  *                    This allow empty templates to be loaded for backwards compatibility.  */ ;/**  * Validates the parameters and creates an {@link StoredScriptSource}.  *  * @param ignoreEmpty Specify as {@code true} to ignoreEmpty the empty source check.  *                    This allow empty templates to be loaded for backwards compatibility.  *                    This allow empty templates to be loaded for backwards compatibility.  */ private StoredScriptSource build(boolean ignoreEmpty) {     if (lang == null) {         throw new IllegalArgumentException("must specify lang for stored script").     } else if (lang.isEmpty()) {         throw new IllegalArgumentException("lang cannot be empty").     }     if (source == null) {         if (ignoreEmpty || Script.DEFAULT_TEMPLATE_LANG.equals(lang)) {             if (Script.DEFAULT_TEMPLATE_LANG.equals(lang)) {                 deprecationLogger.deprecated("empty templates should no longer be used").             } else {                 deprecationLogger.deprecated("empty scripts should no longer be used").             }         } else {             throw new IllegalArgumentException("must specify source for stored script").         }     } else if (source.isEmpty()) {         if (ignoreEmpty || Script.DEFAULT_TEMPLATE_LANG.equals(lang)) {             if (Script.DEFAULT_TEMPLATE_LANG.equals(lang)) {                 deprecationLogger.deprecated("empty templates should no longer be used").             } else {                 deprecationLogger.deprecated("empty scripts should no longer be used").             }         } else {             throw new IllegalArgumentException("source cannot be empty").         }     }     if (options.size() > 1 || options.size() == 1 && options.get(Script.CONTENT_TYPE_OPTION) == null) {         throw new IllegalArgumentException("illegal compiler options [" + options + "] specified").     }     return new StoredScriptSource(lang, source, options). }
true;public,static;2;41;/**  * This will parse XContent into a {@link StoredScriptSource}.  The following formats can be parsed:  *  * The simple script format with no compiler options or user-defined params:  *  * Example:  * {@code  * {"script": "return Math.log(doc.popularity) * 100."}  * }  *  * The above format requires the lang to be specified using the deprecated stored script namespace  * (as a url parameter during a put request).  See {@link ScriptMetaData} for more information about  * the stored script namespaces.  *  * The complex script format using the new stored script namespace  * where lang and source are required but options is optional:  *  * {@code  * {  *     "script" : {  *         "lang" : "<lang>",  *         "source" : "<source>",  *         "options" : {  *             "option0" : "<option0>",  *             "option1" : "<option1>",  *             ...  *         }  *     }  * }  * }  *  * Example:  * {@code  * {  *     "script": {  *         "lang" : "painless",  *         "source" : "return Math.log(doc.popularity) * params.multiplier"  *     }  * }  * }  *  * The use of "source" may also be substituted with "code" for backcompat with 5.3 to 5.5 format. For example:  *  * {@code  * {  *     "script" : {  *         "lang" : "<lang>",  *         "code" : "<source>",  *         "options" : {  *             "option0" : "<option0>",  *             "option1" : "<option1>",  *             ...  *         }  *     }  * }  * }  *  * Note that the "source" parameter can also handle template parsing including from  * a complex JSON object.  *  * @param content The content from the request to be parsed as described above.  * @return        The parsed {@link StoredScriptSource}.  */ ;/**  * This will parse XContent into a {@link StoredScriptSource}.  The following formats can be parsed:  *  * The simple script format with no compiler options or user-defined params:  *  * Example:  * {@code  * {"script": "return Math.log(doc.popularity) * 100."}  * }  *  * The above format requires the lang to be specified using the deprecated stored script namespace  * (as a url parameter during a put request).  See {@link ScriptMetaData} for more information about  * the stored script namespaces.  *  * The complex script format using the new stored script namespace  * where lang and source are required but options is optional:  *  * {@code  * {  *     "script" : {  *         "lang" : "<lang>",  *         "source" : "<source>",  *         "options" : {  *             "option0" : "<option0>",  *             "option1" : "<option1>",  *             ...  *         }  *     }  * }  * }  *  * Example:  * {@code  * {  *     "script": {  *         "lang" : "painless",  *         "source" : "return Math.log(doc.popularity) * params.multiplier"  *     }  * }  * }  *  * The use of "source" may also be substituted with "code" for backcompat with 5.3 to 5.5 format. For example:  *  * {@code  * {  *     "script" : {  *         "lang" : "<lang>",  *         "code" : "<source>",  *         "options" : {  *             "option0" : "<option0>",  *             "option1" : "<option1>",  *             ...  *         }  *     }  * }  * }  *  * Note that the "source" parameter can also handle template parsing including from  * a complex JSON object.  *  * @param content The content from the request to be parsed as described above.  * @return        The parsed {@link StoredScriptSource}.  */ public static StoredScriptSource parse(BytesReference content, XContentType xContentType) {     try (InputStream stream = content.streamInput().         XContentParser parser = xContentType.xContent().createParser(NamedXContentRegistry.EMPTY, LoggingDeprecationHandler.INSTANCE, stream)) {         Token token = parser.nextToken().         if (token != Token.START_OBJECT) {             throw new ParsingException(parser.getTokenLocation(), "unexpected token [" + token + "], expected [{]").         }         token = parser.nextToken().         if (token == Token.END_OBJECT) {             deprecationLogger.deprecated("empty templates should no longer be used").             return new StoredScriptSource(Script.DEFAULT_TEMPLATE_LANG, "", Collections.emptyMap()).         }         if (token != Token.FIELD_NAME) {             throw new ParsingException(parser.getTokenLocation(), "unexpected token [" + token + ", expected [" + SCRIPT_PARSE_FIELD.getPreferredName() + "]").         }         String name = parser.currentName().         if (SCRIPT_PARSE_FIELD.getPreferredName().equals(name)) {             token = parser.nextToken().             if (token == Token.START_OBJECT) {                 return PARSER.apply(parser, null).build(false).             } else {                 throw new ParsingException(parser.getTokenLocation(), "unexpected token [" + token + "], expected [{, <source>]").             }         } else {             throw new ParsingException(parser.getTokenLocation(), "unexpected field [" + name + "], expected [" + SCRIPT_PARSE_FIELD.getPreferredName() + "]").         }     } catch (IOException ioe) {         throw new UncheckedIOException(ioe).     } }
true;public,static;2;3;/**  * This will parse XContent into a {@link StoredScriptSource}. The following format is what will be parsed:  *  * {@code  * {  *     "script" : {  *         "lang" : "<lang>",  *         "source" : "<source>",  *         "options" : {  *             "option0" : "<option0>",  *             "option1" : "<option1>",  *             ...  *         }  *     }  * }  * }  *  * Note that the "source" parameter can also handle template parsing including from  * a complex JSON object.  *  * @param ignoreEmpty Specify as {@code true} to ignoreEmpty the empty source check.  *                    This allows empty templates to be loaded for backwards compatibility.  */ ;/**  * This will parse XContent into a {@link StoredScriptSource}. The following format is what will be parsed:  *  * {@code  * {  *     "script" : {  *         "lang" : "<lang>",  *         "source" : "<source>",  *         "options" : {  *             "option0" : "<option0>",  *             "option1" : "<option1>",  *             ...  *         }  *     }  * }  * }  *  * Note that the "source" parameter can also handle template parsing including from  * a complex JSON object.  *  * @param ignoreEmpty Specify as {@code true} to ignoreEmpty the empty source check.  *                    This allows empty templates to be loaded for backwards compatibility.  */ public static StoredScriptSource fromXContent(XContentParser parser, boolean ignoreEmpty) {     return PARSER.apply(parser, null).build(ignoreEmpty). }
true;public,static;1;3;/**  * Required for {@link ScriptMetaData.ScriptMetadataDiff}.  Uses  * the {@link StoredScriptSource#StoredScriptSource(StreamInput)}  * constructor.  */ ;/**  * Required for {@link ScriptMetaData.ScriptMetadataDiff}.  Uses  * the {@link StoredScriptSource#StoredScriptSource(StreamInput)}  * constructor.  */ public static Diff<StoredScriptSource> readDiffFrom(StreamInput in) throws IOException {     return readDiffFrom(StoredScriptSource::new, in). }
true;public;1;8;/**  * Writes a {@link StoredScriptSource} to a stream. Will write  * all of the lang, source, and options parameters.  */ ;/**  * Writes a {@link StoredScriptSource} to a stream. Will write  * all of the lang, source, and options parameters.  */ @Override public void writeTo(StreamOutput out) throws IOException {     out.writeString(lang).     out.writeString(source).     @SuppressWarnings("unchecked")     Map<String, Object> options = (Map<String, Object>) (Map) this.options.     out.writeMap(options). }
true;public;2;12;/**  * This will write XContent from a {@link StoredScriptSource}. The following format will be written:  *  * {@code  * {  *     "script" : {  *         "lang" : "<lang>",  *         "source" : "<source>",  *         "options" : {  *             "option0" : "<option0>",  *             "option1" : "<option1>",  *             ...  *         }  *     }  * }  * }  *  * Note that the 'source' parameter can also handle templates written as complex JSON.  */ ;/**  * This will write XContent from a {@link StoredScriptSource}. The following format will be written:  *  * {@code  * {  *     "script" : {  *         "lang" : "<lang>",  *         "source" : "<source>",  *         "options" : {  *             "option0" : "<option0>",  *             "option1" : "<option1>",  *             ...  *         }  *     }  * }  * }  *  * Note that the 'source' parameter can also handle templates written as complex JSON.  */ @Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.field(LANG_PARSE_FIELD.getPreferredName(), lang).     builder.field(SOURCE_PARSE_FIELD.getPreferredName(), source).     if (options.isEmpty() == false) {         builder.field(OPTIONS_PARSE_FIELD.getPreferredName(), options).     }     builder.endObject().     return builder. }
true;public;0;3;/**  * @return The language used for compiling this script.  */ ;/**  * @return The language used for compiling this script.  */ public String getLang() {     return lang. }
true;public;0;3;/**  * @return The source used for compiling this script.  */ ;/**  * @return The source used for compiling this script.  */ public String getSource() {     return source. }
true;public;0;3;/**  * @return The compiler options used for this script.  */ ;/**  * @return The compiler options used for this script.  */ public Map<String, String> getOptions() {     return options. }
false;public;1;12;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     StoredScriptSource that = (StoredScriptSource) o.     if (lang != null ? !lang.equals(that.lang) : that.lang != null)         return false.     if (source != null ? !source.equals(that.source) : that.source != null)         return false.     return options != null ? options.equals(that.options) : that.options == null. }
false;public;0;7;;@Override public int hashCode() {     int result = lang != null ? lang.hashCode() : 0.     result = 31 * result + (source != null ? source.hashCode() : 0).     result = 31 * result + (options != null ? options.hashCode() : 0).     return result. }
false;public;0;8;;@Override public String toString() {     return "StoredScriptSource{" + "lang='" + lang + '\'' + ", source='" + source + '\'' + ", options=" + options + '}'. }
