commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public String getType() {     return type. }
false;public,static;1;7;;public static ThreadPoolType fromType(String type) {     ThreadPoolType threadPoolType = TYPE_MAP.get(type).     if (threadPoolType == null) {         throw new IllegalArgumentException("no ThreadPoolType for " + type).     }     return threadPoolType. }
false;public;0;3;;public Collection<ExecutorBuilder> builders() {     return Collections.unmodifiableCollection(builders.values()). }
true;public;0;3;/**  * Returns a value of milliseconds that may be used for relative time calculations.  *  * This method should only be used for calculating time deltas. For an epoch based  * timestamp, see {@link #absoluteTimeInMillis()}.  */ ;/**  * Returns a value of milliseconds that may be used for relative time calculations.  *  * This method should only be used for calculating time deltas. For an epoch based  * timestamp, see {@link #absoluteTimeInMillis()}.  */ public long relativeTimeInMillis() {     return cachedTimeThread.relativeTimeInMillis(). }
true;public;0;3;/**  * Returns the value of milliseconds since UNIX epoch.  *  * This method should only be used for exact date/time formatting. For calculating  * time deltas that should not suffer from negative deltas, which are possible with  * this method, see {@link #relativeTimeInMillis()}.  */ ;/**  * Returns the value of milliseconds since UNIX epoch.  *  * This method should only be used for exact date/time formatting. For calculating  * time deltas that should not suffer from negative deltas, which are possible with  * this method, see {@link #relativeTimeInMillis()}.  */ public long absoluteTimeInMillis() {     return cachedTimeThread.absoluteTimeInMillis(). }
false;public;0;3;;public ThreadPoolInfo info() {     return threadPoolInfo. }
false;public;1;7;;public Info info(String name) {     ExecutorHolder holder = executors.get(name).     if (holder == null) {         return null.     }     return holder.info. }
false;public;0;30;;public ThreadPoolStats stats() {     List<ThreadPoolStats.Stats> stats = new ArrayList<>().     for (ExecutorHolder holder : executors.values()) {         final String name = holder.info.getName().         // no need to have info on "same" thread pool         if ("same".equals(name)) {             continue.         }         int threads = -1.         int queue = -1.         int active = -1.         long rejected = -1.         int largest = -1.         long completed = -1.         if (holder.executor() instanceof ThreadPoolExecutor) {             ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor) holder.executor().             threads = threadPoolExecutor.getPoolSize().             queue = threadPoolExecutor.getQueue().size().             active = threadPoolExecutor.getActiveCount().             largest = threadPoolExecutor.getLargestPoolSize().             completed = threadPoolExecutor.getCompletedTaskCount().             RejectedExecutionHandler rejectedExecutionHandler = threadPoolExecutor.getRejectedExecutionHandler().             if (rejectedExecutionHandler instanceof XRejectedExecutionHandler) {                 rejected = ((XRejectedExecutionHandler) rejectedExecutionHandler).rejected().             }         }         stats.add(new ThreadPoolStats.Stats(name, threads, queue, active, rejected, largest, completed)).     }     return new ThreadPoolStats(stats). }
true;public;0;3;/**  * Get the generic {@link ExecutorService}. This executor service  * {@link Executor#execute(Runnable)} method will run the {@link Runnable} it is given in the  * {@link ThreadContext} of the thread that queues it.  * <p>  * Warning: this {@linkplain ExecutorService} will not throw {@link RejectedExecutionException}  * if you submit a task while it shutdown. It will instead silently queue it and not run it.  */ ;/**  * Get the generic {@link ExecutorService}. This executor service  * {@link Executor#execute(Runnable)} method will run the {@link Runnable} it is given in the  * {@link ThreadContext} of the thread that queues it.  * <p>  * Warning: this {@linkplain ExecutorService} will not throw {@link RejectedExecutionException}  * if you submit a task while it shutdown. It will instead silently queue it and not run it.  */ public ExecutorService generic() {     return executor(Names.GENERIC). }
true;public;1;7;/**  * Get the {@link ExecutorService} with the given name. This executor service's  * {@link Executor#execute(Runnable)} method will run the {@link Runnable} it is given in the  * {@link ThreadContext} of the thread that queues it.  * <p>  * Warning: this {@linkplain ExecutorService} might not throw {@link RejectedExecutionException}  * if you submit a task while it shutdown. It will instead silently queue it and not run it.  *  * @param name the name of the executor service to obtain  * @throws IllegalArgumentException if no executor service with the specified name exists  */ ;/**  * Get the {@link ExecutorService} with the given name. This executor service's  * {@link Executor#execute(Runnable)} method will run the {@link Runnable} it is given in the  * {@link ThreadContext} of the thread that queues it.  * <p>  * Warning: this {@linkplain ExecutorService} might not throw {@link RejectedExecutionException}  * if you submit a task while it shutdown. It will instead silently queue it and not run it.  *  * @param name the name of the executor service to obtain  * @throws IllegalArgumentException if no executor service with the specified name exists  */ public ExecutorService executor(String name) {     final ExecutorHolder holder = executors.get(name).     if (holder == null) {         throw new IllegalArgumentException("no executor service found for [" + name + "]").     }     return holder.executor(). }
true;public;3;7;/**  * Schedules a one-shot command to run after a given delay. The command is not run in the context of the calling thread. To preserve the  * context of the calling thread you may call <code>threadPool.getThreadContext().preserveContext</code> on the runnable before passing  * it to this method.  *  * @param command the command to run  * @param delay delay before the task executes  * @param executor the name of the thread pool on which to execute this task. SAME means "execute on the scheduler thread" which changes  *        the meaning of the ScheduledFuture returned by this method. In that case the ScheduledFuture will complete only when the  *        command completes.  * @return a ScheduledFuture who's get will return when the task is has been added to its target thread pool and throw an exception if  *         the task is canceled before it was added to its target thread pool. Once the task has been added to its target thread pool  *         the ScheduledFuture will cannot interact with it.  * @throws org.elasticsearch.common.util.concurrent.EsRejectedExecutionException if the task cannot be scheduled for execution  */ ;/**  * Schedules a one-shot command to run after a given delay. The command is not run in the context of the calling thread. To preserve the  * context of the calling thread you may call <code>threadPool.getThreadContext().preserveContext</code> on the runnable before passing  * it to this method.  *  * @param command the command to run  * @param delay delay before the task executes  * @param executor the name of the thread pool on which to execute this task. SAME means "execute on the scheduler thread" which changes  *        the meaning of the ScheduledFuture returned by this method. In that case the ScheduledFuture will complete only when the  *        command completes.  * @return a ScheduledFuture who's get will return when the task is has been added to its target thread pool and throw an exception if  *         the task is canceled before it was added to its target thread pool. Once the task has been added to its target thread pool  *         the ScheduledFuture will cannot interact with it.  * @throws org.elasticsearch.common.util.concurrent.EsRejectedExecutionException if the task cannot be scheduled for execution  */ @Override public ScheduledCancellable schedule(Runnable command, TimeValue delay, String executor) {     if (!Names.SAME.equals(executor)) {         command = new ThreadedRunnable(command, executor(executor)).     }     return new ScheduledCancellableAdapter(scheduler.schedule(command, delay.millis(), TimeUnit.MILLISECONDS)). }
false;public;3;12;;public void scheduleUnlessShuttingDown(TimeValue delay, String executor, Runnable command) {     try {         schedule(command, delay, executor).     } catch (EsRejectedExecutionException e) {         if (e.isExecutorShutdown()) {             logger.debug(new ParameterizedMessage("could not schedule execution of [{}] after [{}] on [{}] as executor is shut down", command, delay, executor), e).         } else {             throw e.         }     } }
false;public;3;12;;@Override public Cancellable scheduleWithFixedDelay(Runnable command, TimeValue interval, String executor) {     return new ReschedulingRunnable(command, interval, executor, this, (e) -> {         if (logger.isDebugEnabled()) {             logger.debug(() -> new ParameterizedMessage("scheduled task [{}] was rejected on thread pool [{}]", command, executor), e).         }     }, (e) -> logger.warn(() -> new ParameterizedMessage("failed to run scheduled task [{}] on thread pool [{}]", command, executor), e)). }
false;public;1;4;;@Override public Runnable preserveContext(Runnable command) {     return getThreadContext().preserveContext(command). }
false;protected,final;0;4;;protected final void stopCachedTimeThread() {     cachedTimeThread.running = false.     cachedTimeThread.interrupt(). }
false;public;0;9;;public void shutdown() {     stopCachedTimeThread().     scheduler.shutdown().     for (ExecutorHolder executor : executors.values()) {         if (executor.executor() instanceof ThreadPoolExecutor) {             executor.executor().shutdown().         }     } }
false;public;0;9;;public void shutdownNow() {     stopCachedTimeThread().     scheduler.shutdownNow().     for (ExecutorHolder executor : executors.values()) {         if (executor.executor() instanceof ThreadPoolExecutor) {             executor.executor().shutdownNow().         }     } }
false;public;2;10;;public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {     boolean result = scheduler.awaitTermination(timeout, unit).     for (ExecutorHolder executor : executors.values()) {         if (executor.executor() instanceof ThreadPoolExecutor) {             result &= executor.executor().awaitTermination(timeout, unit).         }     }     cachedTimeThread.join(unit.toMillis(timeout)).     return result. }
false;public;0;3;;public ScheduledExecutorService scheduler() {     return this.scheduler. }
true;static;3;3;/**  * Constrains a value between minimum and maximum values  * (inclusive).  *  * @param value the value to constrain  * @param min   the minimum acceptable value  * @param max   the maximum acceptable value  * @return min if value is less than min, max if value is greater  * than value, otherwise value  */ ;/**  * Constrains a value between minimum and maximum values  * (inclusive).  *  * @param value the value to constrain  * @param min   the minimum acceptable value  * @param max   the maximum acceptable value  * @return min if value is less than min, max if value is greater  * than value, otherwise value  */ static int boundedBy(int value, int min, int max) {     return Math.min(max, Math.max(min, value)). }
false;static;1;3;;static int halfNumberOfProcessorsMaxFive(int numberOfProcessors) {     return boundedBy((numberOfProcessors + 1) / 2, 1, 5). }
false;static;1;3;;static int halfNumberOfProcessorsMaxTen(int numberOfProcessors) {     return boundedBy((numberOfProcessors + 1) / 2, 1, 10). }
false;static;1;3;;static int twiceNumberOfProcessors(int numberOfProcessors) {     return boundedBy(2 * numberOfProcessors, 2, Integer.MAX_VALUE). }
false;public,static;1;3;;public static int searchThreadPoolSize(int availableProcessors) {     return ((availableProcessors * 3) / 2) + 1. }
false;public;0;9;;@Override public void run() {     try {         runnable.run().     } catch (Exception e) {         logger.warn(() -> new ParameterizedMessage("failed to run {}", runnable.toString()), e).         throw e.     } }
false;public;0;4;;@Override public int hashCode() {     return runnable.hashCode(). }
false;public;1;4;;@Override public boolean equals(Object obj) {     return runnable.equals(obj). }
false;public;0;4;;@Override public String toString() {     return "[threaded] " + runnable.toString(). }
false;public;0;13;;@Override public void run() {     try {         executor.execute(runnable).     } catch (EsRejectedExecutionException e) {         if (e.isExecutorShutdown()) {             logger.debug(new ParameterizedMessage("could not schedule execution of [{}] on [{}] as executor is shut down", runnable, executor), e).         } else {             throw e.         }     } }
false;public;0;4;;@Override public int hashCode() {     return runnable.hashCode(). }
false;public;1;4;;@Override public boolean equals(Object obj) {     return runnable.equals(obj). }
false;public;0;4;;@Override public String toString() {     return "[threaded] " + runnable.toString(). }
true;;0;6;/**  * Return the current time used for relative calculations. This is  * {@link System#nanoTime()} truncated to milliseconds.  * <p>  * If {@link ThreadPool#ESTIMATED_TIME_INTERVAL_SETTING} is set to 0  * then the cache is disabled and the method calls {@link System#nanoTime()}  * whenever called. Typically used for testing.  */ ;/**  * Return the current time used for relative calculations. This is  * {@link System#nanoTime()} truncated to milliseconds.  * <p>  * If {@link ThreadPool#ESTIMATED_TIME_INTERVAL_SETTING} is set to 0  * then the cache is disabled and the method calls {@link System#nanoTime()}  * whenever called. Typically used for testing.  */ long relativeTimeInMillis() {     if (0 < interval) {         return relativeMillis.     }     return TimeValue.nsecToMSec(System.nanoTime()). }
true;;0;6;/**  * Return the current epoch time, used to find absolute time. This is  * a cached version of {@link System#currentTimeMillis()}.  * <p>  * If {@link ThreadPool#ESTIMATED_TIME_INTERVAL_SETTING} is set to 0  * then the cache is disabled and the method calls {@link System#currentTimeMillis()}  * whenever called. Typically used for testing.  */ ;/**  * Return the current epoch time, used to find absolute time. This is  * a cached version of {@link System#currentTimeMillis()}.  * <p>  * If {@link ThreadPool#ESTIMATED_TIME_INTERVAL_SETTING} is set to 0  * then the cache is disabled and the method calls {@link System#currentTimeMillis()}  * whenever called. Typically used for testing.  */ long absoluteTimeInMillis() {     if (0 < interval) {         return absoluteMillis.     }     return System.currentTimeMillis(). }
false;public;0;13;;@Override public void run() {     while (running && 0 < interval) {         relativeMillis = TimeValue.nsecToMSec(System.nanoTime()).         absoluteMillis = System.currentTimeMillis().         try {             Thread.sleep(interval).         } catch (InterruptedException e) {             running = false.             return.         }     } }
false;;0;3;;ExecutorService executor() {     return executor. }
false;public;1;15;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeString(name).     if (type == ThreadPoolType.FIXED_AUTO_QUEUE_SIZE && out.getVersion().before(Version.V_6_0_0_alpha1)) {         // 5.x doesn't know about the "fixed_auto_queue_size" thread pool type, just write fixed.         out.writeString(ThreadPoolType.FIXED.getType()).     } else {         out.writeString(type.getType()).     }     out.writeInt(min).     out.writeInt(max).     out.writeOptionalTimeValue(keepAlive).     out.writeOptionalWriteable(queueSize). }
false;public;0;3;;public String getName() {     return this.name. }
false;public;0;3;;public ThreadPoolType getThreadPoolType() {     return this.type. }
false;public;0;3;;public int getMin() {     return this.min. }
false;public;0;3;;public int getMax() {     return this.max. }
false;public;0;4;;@Nullable public TimeValue getKeepAlive() {     return this.keepAlive. }
false;public;0;4;;@Nullable public SizeValue getQueueSize() {     return this.queueSize. }
false;public;2;25;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject(name).     builder.field("type", type.getType()).     if (type == ThreadPoolType.SCALING) {         assert min != -1.         builder.field("core", min).         assert max != -1.         builder.field("max", max).     } else {         assert max != -1.         builder.field("size", max).     }     if (keepAlive != null) {         builder.field("keep_alive", keepAlive.toString()).     }     if (queueSize == null) {         builder.field("queue_size", -1).     } else {         builder.field("queue_size", queueSize.singles()).     }     builder.endObject().     return builder. }
true;public,static;3;9;/**  * Returns <code>true</code> if the given service was terminated successfully. If the termination timed out,  * the service is <code>null</code> this method will return <code>false</code>.  */ ;/**  * Returns <code>true</code> if the given service was terminated successfully. If the termination timed out,  * the service is <code>null</code> this method will return <code>false</code>.  */ public static boolean terminate(ExecutorService service, long timeout, TimeUnit timeUnit) {     if (service != null) {         service.shutdown().         if (awaitTermination(service, timeout, timeUnit))             return true.         service.shutdownNow().         return awaitTermination(service, timeout, timeUnit).     }     return false. }
false;private,static;3;13;;private static boolean awaitTermination(final ExecutorService service, final long timeout, final TimeUnit timeUnit) {     try {         if (service.awaitTermination(timeout, timeUnit)) {             return true.         }     } catch (final InterruptedException e) {         Thread.currentThread().interrupt().     }     return false. }
true;public,static;3;16;/**  * Returns <code>true</code> if the given pool was terminated successfully. If the termination timed out,  * the service is <code>null</code> this method will return <code>false</code>.  */ ;/**  * Returns <code>true</code> if the given pool was terminated successfully. If the termination timed out,  * the service is <code>null</code> this method will return <code>false</code>.  */ public static boolean terminate(ThreadPool pool, long timeout, TimeUnit timeUnit) {     if (pool != null) {         try {             pool.shutdown().             if (awaitTermination(pool, timeout, timeUnit)) {                 return true.             }             // last resort             pool.shutdownNow().             return awaitTermination(pool, timeout, timeUnit).         } finally {             IOUtils.closeWhileHandlingException(pool).         }     }     return false. }
false;private,static;3;13;;private static boolean awaitTermination(final ThreadPool threadPool, final long timeout, final TimeUnit timeUnit) {     try {         if (threadPool.awaitTermination(timeout, timeUnit)) {             return true.         }     } catch (InterruptedException e) {         Thread.currentThread().interrupt().     }     return false. }
false;public;0;4;;@Override public void close() throws IOException {     threadContext.close(). }
false;public;0;3;;public ThreadContext getThreadContext() {     return threadContext. }
false;public,static;1;5;;public static boolean assertNotScheduleThread(String reason) {     assert Thread.currentThread().getName().contains("scheduler") == false : "Expected current thread [" + Thread.currentThread() + "] to not be the scheduler thread. Reason: [" + reason + "]".     return true. }
