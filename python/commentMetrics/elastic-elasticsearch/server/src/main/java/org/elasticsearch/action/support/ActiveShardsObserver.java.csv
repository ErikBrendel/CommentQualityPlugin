commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public void onNewClusterState(ClusterState state) {     onResult.accept(true). }
false;public;0;5;;@Override public void onClusterServiceClose() {     logger.debug("[{}] cluster service closed while waiting for enough shards to be started.", Arrays.toString(indexNames)).     onFailure.accept(new NodeClosedException(clusterService.localNode())). }
false;public;1;4;;@Override public void onTimeout(TimeValue timeout) {     onResult.accept(false). }
true;public;5;41;/**  * Waits on the specified number of active shards to be started before executing the  *  * @param indexNames the indices to wait for active shards on  * @param activeShardCount the number of active shards to wait on before returning  * @param timeout the timeout value  * @param onResult a function that is executed in response to the requisite shards becoming active or a timeout (whichever comes first)  * @param onFailure a function that is executed in response to an error occurring during waiting for the active shards  */ ;/**  * Waits on the specified number of active shards to be started before executing the  *  * @param indexNames the indices to wait for active shards on  * @param activeShardCount the number of active shards to wait on before returning  * @param timeout the timeout value  * @param onResult a function that is executed in response to the requisite shards becoming active or a timeout (whichever comes first)  * @param onFailure a function that is executed in response to an error occurring during waiting for the active shards  */ public void waitForActiveShards(final String[] indexNames, final ActiveShardCount activeShardCount, final TimeValue timeout, final Consumer<Boolean> onResult, final Consumer<Exception> onFailure) {     // wait for the configured number of active shards to be allocated before executing the result consumer     if (activeShardCount == ActiveShardCount.NONE) {         // not waiting, so just run whatever we were to run when the waiting is         onResult.accept(true).         return.     }     final ClusterState state = clusterService.state().     final ClusterStateObserver observer = new ClusterStateObserver(state, clusterService, null, logger, threadPool.getThreadContext()).     if (activeShardCount.enoughShardsActive(state, indexNames)) {         onResult.accept(true).     } else {         final Predicate<ClusterState> shardsAllocatedPredicate = newState -> activeShardCount.enoughShardsActive(newState, indexNames).         final ClusterStateObserver.Listener observerListener = new ClusterStateObserver.Listener() {              @Override             public void onNewClusterState(ClusterState state) {                 onResult.accept(true).             }              @Override             public void onClusterServiceClose() {                 logger.debug("[{}] cluster service closed while waiting for enough shards to be started.", Arrays.toString(indexNames)).                 onFailure.accept(new NodeClosedException(clusterService.localNode())).             }              @Override             public void onTimeout(TimeValue timeout) {                 onResult.accept(false).             }         }.         observer.waitForNextChange(observerListener, shardsAllocatedPredicate, timeout).     } }
