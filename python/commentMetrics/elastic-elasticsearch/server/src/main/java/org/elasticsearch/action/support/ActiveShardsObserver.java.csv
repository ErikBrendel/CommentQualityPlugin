# id;timestamp;commentText;codeText;commentWords;codeWords
ActiveShardsObserver -> public void waitForActiveShards(final String[] indexNames,                                     final ActiveShardCount activeShardCount,                                     final TimeValue timeout,                                     final Consumer<Boolean> onResult,                                     final Consumer<Exception> onFailure);1524684173;Waits on the specified number of active shards to be started before executing the__@param indexNames the indices to wait for active shards on_@param activeShardCount the number of active shards to wait on before returning_@param timeout the timeout value_@param onResult a function that is executed in response to the requisite shards becoming active or a timeout (whichever comes first)_@param onFailure a function that is executed in response to an error occurring during waiting for the active shards;public void waitForActiveShards(final String[] indexNames,_                                    final ActiveShardCount activeShardCount,_                                    final TimeValue timeout,_                                    final Consumer<Boolean> onResult,_                                    final Consumer<Exception> onFailure) {__        _        if (activeShardCount == ActiveShardCount.NONE) {_            _            onResult.accept(true)__            return__        }__        final ClusterState state = clusterService.state()__        final ClusterStateObserver observer = new ClusterStateObserver(state, clusterService, null, logger, threadPool.getThreadContext())__        if (activeShardCount.enoughShardsActive(state, indexNames)) {_            onResult.accept(true)__        } else {_            final Predicate<ClusterState> shardsAllocatedPredicate = newState -> activeShardCount.enoughShardsActive(newState, indexNames)___            final ClusterStateObserver.Listener observerListener = new ClusterStateObserver.Listener() {_                @Override_                public void onNewClusterState(ClusterState state) {_                    onResult.accept(true)__                }__                @Override_                public void onClusterServiceClose() {_                    logger.debug("[{}] cluster service closed while waiting for enough shards to be started.", Arrays.toString(indexNames))__                    onFailure.accept(new NodeClosedException(clusterService.localNode()))__                }__                @Override_                public void onTimeout(TimeValue timeout) {_                    onResult.accept(false)__                }_            }___            observer.waitForNextChange(observerListener, shardsAllocatedPredicate, timeout)__        }_    };waits,on,the,specified,number,of,active,shards,to,be,started,before,executing,the,param,index,names,the,indices,to,wait,for,active,shards,on,param,active,shard,count,the,number,of,active,shards,to,wait,on,before,returning,param,timeout,the,timeout,value,param,on,result,a,function,that,is,executed,in,response,to,the,requisite,shards,becoming,active,or,a,timeout,whichever,comes,first,param,on,failure,a,function,that,is,executed,in,response,to,an,error,occurring,during,waiting,for,the,active,shards;public,void,wait,for,active,shards,final,string,index,names,final,active,shard,count,active,shard,count,final,time,value,timeout,final,consumer,boolean,on,result,final,consumer,exception,on,failure,if,active,shard,count,active,shard,count,none,on,result,accept,true,return,final,cluster,state,state,cluster,service,state,final,cluster,state,observer,observer,new,cluster,state,observer,state,cluster,service,null,logger,thread,pool,get,thread,context,if,active,shard,count,enough,shards,active,state,index,names,on,result,accept,true,else,final,predicate,cluster,state,shards,allocated,predicate,new,state,active,shard,count,enough,shards,active,new,state,index,names,final,cluster,state,observer,listener,observer,listener,new,cluster,state,observer,listener,override,public,void,on,new,cluster,state,cluster,state,state,on,result,accept,true,override,public,void,on,cluster,service,close,logger,debug,cluster,service,closed,while,waiting,for,enough,shards,to,be,started,arrays,to,string,index,names,on,failure,accept,new,node,closed,exception,cluster,service,local,node,override,public,void,on,timeout,time,value,timeout,on,result,accept,false,observer,wait,for,next,change,observer,listener,shards,allocated,predicate,timeout
ActiveShardsObserver -> public void waitForActiveShards(final String[] indexNames,                                     final ActiveShardCount activeShardCount,                                     final TimeValue timeout,                                     final Consumer<Boolean> onResult,                                     final Consumer<Exception> onFailure);1541092382;Waits on the specified number of active shards to be started before executing the__@param indexNames the indices to wait for active shards on_@param activeShardCount the number of active shards to wait on before returning_@param timeout the timeout value_@param onResult a function that is executed in response to the requisite shards becoming active or a timeout (whichever comes first)_@param onFailure a function that is executed in response to an error occurring during waiting for the active shards;public void waitForActiveShards(final String[] indexNames,_                                    final ActiveShardCount activeShardCount,_                                    final TimeValue timeout,_                                    final Consumer<Boolean> onResult,_                                    final Consumer<Exception> onFailure) {__        _        if (activeShardCount == ActiveShardCount.NONE) {_            _            onResult.accept(true)__            return__        }__        final ClusterState state = clusterService.state()__        final ClusterStateObserver observer = new ClusterStateObserver(state, clusterService, null, logger, threadPool.getThreadContext())__        if (activeShardCount.enoughShardsActive(state, indexNames)) {_            onResult.accept(true)__        } else {_            final Predicate<ClusterState> shardsAllocatedPredicate = newState -> activeShardCount.enoughShardsActive(newState, indexNames)___            final ClusterStateObserver.Listener observerListener = new ClusterStateObserver.Listener() {_                @Override_                public void onNewClusterState(ClusterState state) {_                    onResult.accept(true)__                }__                @Override_                public void onClusterServiceClose() {_                    logger.debug("[{}] cluster service closed while waiting for enough shards to be started.", Arrays.toString(indexNames))__                    onFailure.accept(new NodeClosedException(clusterService.localNode()))__                }__                @Override_                public void onTimeout(TimeValue timeout) {_                    onResult.accept(false)__                }_            }___            observer.waitForNextChange(observerListener, shardsAllocatedPredicate, timeout)__        }_    };waits,on,the,specified,number,of,active,shards,to,be,started,before,executing,the,param,index,names,the,indices,to,wait,for,active,shards,on,param,active,shard,count,the,number,of,active,shards,to,wait,on,before,returning,param,timeout,the,timeout,value,param,on,result,a,function,that,is,executed,in,response,to,the,requisite,shards,becoming,active,or,a,timeout,whichever,comes,first,param,on,failure,a,function,that,is,executed,in,response,to,an,error,occurring,during,waiting,for,the,active,shards;public,void,wait,for,active,shards,final,string,index,names,final,active,shard,count,active,shard,count,final,time,value,timeout,final,consumer,boolean,on,result,final,consumer,exception,on,failure,if,active,shard,count,active,shard,count,none,on,result,accept,true,return,final,cluster,state,state,cluster,service,state,final,cluster,state,observer,observer,new,cluster,state,observer,state,cluster,service,null,logger,thread,pool,get,thread,context,if,active,shard,count,enough,shards,active,state,index,names,on,result,accept,true,else,final,predicate,cluster,state,shards,allocated,predicate,new,state,active,shard,count,enough,shards,active,new,state,index,names,final,cluster,state,observer,listener,observer,listener,new,cluster,state,observer,listener,override,public,void,on,new,cluster,state,cluster,state,state,on,result,accept,true,override,public,void,on,cluster,service,close,logger,debug,cluster,service,closed,while,waiting,for,enough,shards,to,be,started,arrays,to,string,index,names,on,failure,accept,new,node,closed,exception,cluster,service,local,node,override,public,void,on,timeout,time,value,timeout,on,result,accept,false,observer,wait,for,next,change,observer,listener,shards,allocated,predicate,timeout
ActiveShardsObserver -> public void waitForActiveShards(final String[] indexNames,                                     final ActiveShardCount activeShardCount,                                     final TimeValue timeout,                                     final Consumer<Boolean> onResult,                                     final Consumer<Exception> onFailure);1542402632;Waits on the specified number of active shards to be started before executing the__@param indexNames the indices to wait for active shards on_@param activeShardCount the number of active shards to wait on before returning_@param timeout the timeout value_@param onResult a function that is executed in response to the requisite shards becoming active or a timeout (whichever comes first)_@param onFailure a function that is executed in response to an error occurring during waiting for the active shards;public void waitForActiveShards(final String[] indexNames,_                                    final ActiveShardCount activeShardCount,_                                    final TimeValue timeout,_                                    final Consumer<Boolean> onResult,_                                    final Consumer<Exception> onFailure) {__        _        if (activeShardCount == ActiveShardCount.NONE) {_            _            onResult.accept(true)__            return__        }__        final ClusterState state = clusterService.state()__        final ClusterStateObserver observer = new ClusterStateObserver(state, clusterService, null, logger, threadPool.getThreadContext())__        if (activeShardCount.enoughShardsActive(state, indexNames)) {_            onResult.accept(true)__        } else {_            final Predicate<ClusterState> shardsAllocatedPredicate = newState -> activeShardCount.enoughShardsActive(newState, indexNames)___            final ClusterStateObserver.Listener observerListener = new ClusterStateObserver.Listener() {_                @Override_                public void onNewClusterState(ClusterState state) {_                    onResult.accept(true)__                }__                @Override_                public void onClusterServiceClose() {_                    logger.debug("[{}] cluster service closed while waiting for enough shards to be started.", Arrays.toString(indexNames))__                    onFailure.accept(new NodeClosedException(clusterService.localNode()))__                }__                @Override_                public void onTimeout(TimeValue timeout) {_                    onResult.accept(false)__                }_            }___            observer.waitForNextChange(observerListener, shardsAllocatedPredicate, timeout)__        }_    };waits,on,the,specified,number,of,active,shards,to,be,started,before,executing,the,param,index,names,the,indices,to,wait,for,active,shards,on,param,active,shard,count,the,number,of,active,shards,to,wait,on,before,returning,param,timeout,the,timeout,value,param,on,result,a,function,that,is,executed,in,response,to,the,requisite,shards,becoming,active,or,a,timeout,whichever,comes,first,param,on,failure,a,function,that,is,executed,in,response,to,an,error,occurring,during,waiting,for,the,active,shards;public,void,wait,for,active,shards,final,string,index,names,final,active,shard,count,active,shard,count,final,time,value,timeout,final,consumer,boolean,on,result,final,consumer,exception,on,failure,if,active,shard,count,active,shard,count,none,on,result,accept,true,return,final,cluster,state,state,cluster,service,state,final,cluster,state,observer,observer,new,cluster,state,observer,state,cluster,service,null,logger,thread,pool,get,thread,context,if,active,shard,count,enough,shards,active,state,index,names,on,result,accept,true,else,final,predicate,cluster,state,shards,allocated,predicate,new,state,active,shard,count,enough,shards,active,new,state,index,names,final,cluster,state,observer,listener,observer,listener,new,cluster,state,observer,listener,override,public,void,on,new,cluster,state,cluster,state,state,on,result,accept,true,override,public,void,on,cluster,service,close,logger,debug,cluster,service,closed,while,waiting,for,enough,shards,to,be,started,arrays,to,string,index,names,on,failure,accept,new,node,closed,exception,cluster,service,local,node,override,public,void,on,timeout,time,value,timeout,on,result,accept,false,observer,wait,for,next,change,observer,listener,shards,allocated,predicate,timeout
