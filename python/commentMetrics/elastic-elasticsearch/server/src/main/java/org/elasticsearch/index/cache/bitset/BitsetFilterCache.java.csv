commented;modifiers;parameterAmount;loc;comment;code
false;public;1;3;;public IndexWarmer.Listener createListener(ThreadPool threadPool) {     return new BitSetProducerWarmer(threadPool). }
false;public;1;3;;public BitSetProducer getBitSetProducer(Query query) {     return new QueryWrapperBitSetProducer(query). }
false;public;1;4;;@Override public void onClose(IndexReader.CacheKey ownerCoreCacheKey) {     loadedFilters.invalidate(ownerCoreCacheKey). }
false;public;0;4;;@Override public void close() {     clear("close"). }
false;public;1;4;;public void clear(String reason) {     logger.debug("clearing all bitsets because [{}]", reason).     loadedFilters.invalidateAll(). }
false;private;2;35;;private BitSet getAndLoadIfNotPresent(final Query query, final LeafReaderContext context) throws IOException, ExecutionException {     final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper().     if (cacheHelper == null) {         throw new IllegalArgumentException("Reader " + context.reader() + " does not support caching").     }     final IndexReader.CacheKey coreCacheReader = cacheHelper.getKey().     final ShardId shardId = ShardUtils.extractShardId(context.reader()).     if (indexSettings.getIndex().equals(shardId.getIndex()) == false) {         // insanity         throw new IllegalStateException("Trying to load bit set for index " + shardId.getIndex() + " with cache of index " + indexSettings.getIndex()).     }     Cache<Query, Value> filterToFbs = loadedFilters.computeIfAbsent(coreCacheReader, key -> {         cacheHelper.addClosedListener(BitsetFilterCache.this).         return CacheBuilder.<Query, Value>builder().build().     }).     return filterToFbs.computeIfAbsent(query, key -> {         final IndexReaderContext topLevelContext = ReaderUtil.getTopLevelContext(context).         final IndexSearcher searcher = new IndexSearcher(topLevelContext).         searcher.setQueryCache(null).         final Weight weight = searcher.createWeight(searcher.rewrite(query), ScoreMode.COMPLETE_NO_SCORES, 1f).         Scorer s = weight.scorer(context).         final BitSet bitSet.         if (s == null) {             bitSet = null.         } else {             bitSet = BitSet.of(s.iterator(), context.reader().maxDoc()).         }         Value value = new Value(bitSet, shardId).         listener.onCache(shardId, value.bitset).         return value.     }).bitset. }
false;public;1;16;;@Override public void onRemoval(RemovalNotification<IndexReader.CacheKey, Cache<Query, Value>> notification) {     if (notification.getKey() == null) {         return.     }     Cache<Query, Value> valueCache = notification.getValue().     if (valueCache == null) {         return.     }     for (Value value : valueCache.values()) {         listener.onRemoval(value.shardId, value.bitset).     // if null then this means the shard has already been removed and the stats are 0 anyway for the shard this key belongs to     } }
false;public;1;8;;@Override public BitSet getBitSet(LeafReaderContext context) throws IOException {     try {         return getAndLoadIfNotPresent(query, context).     } catch (ExecutionException e) {         throw ExceptionsHelper.convertToElastic(e).     } }
false;public;0;4;;@Override public String toString() {     return "random_access(" + query + ")". }
false;public;1;5;;@Override public boolean equals(Object o) {     if (!(o instanceof QueryWrapperBitSetProducer))         return false.     return this.query.equals(((QueryWrapperBitSetProducer) o).query). }
false;public;0;4;;@Override public int hashCode() {     return 31 * getClass().hashCode() + query.hashCode(). }
false;public;2;55;;@Override public IndexWarmer.TerminationHandle warmReader(final IndexShard indexShard, final Engine.Searcher searcher) {     if (indexSettings.getIndex().equals(indexShard.indexSettings().getIndex()) == false) {         // this is from a different index         return TerminationHandle.NO_WAIT.     }     if (!loadRandomAccessFiltersEagerly) {         return TerminationHandle.NO_WAIT.     }     boolean hasNested = false.     final Set<Query> warmUp = new HashSet<>().     final MapperService mapperService = indexShard.mapperService().     DocumentMapper docMapper = mapperService.documentMapper().     if (docMapper != null) {         if (docMapper.hasNestedObjects()) {             hasNested = true.             for (ObjectMapper objectMapper : docMapper.objectMappers().values()) {                 if (objectMapper.nested().isNested()) {                     ObjectMapper parentObjectMapper = objectMapper.getParentObjectMapper(mapperService).                     if (parentObjectMapper != null && parentObjectMapper.nested().isNested()) {                         warmUp.add(parentObjectMapper.nestedTypeFilter()).                     }                 }             }         }     }     if (hasNested) {         warmUp.add(Queries.newNonNestedFilter(indexSettings.getIndexVersionCreated())).     }     final CountDownLatch latch = new CountDownLatch(searcher.reader().leaves().size() * warmUp.size()).     for (final LeafReaderContext ctx : searcher.reader().leaves()) {         for (final Query filterToWarm : warmUp) {             executor.execute(() -> {                 try {                     final long start = System.nanoTime().                     getAndLoadIfNotPresent(filterToWarm, ctx).                     if (indexShard.warmerService().logger().isTraceEnabled()) {                         indexShard.warmerService().logger().trace("warmed bitset for [{}], took [{}]", filterToWarm, TimeValue.timeValueNanos(System.nanoTime() - start)).                     }                 } catch (Exception e) {                     indexShard.warmerService().logger().warn(() -> new ParameterizedMessage("failed to load " + "bitset for [{}]", filterToWarm), e).                 } finally {                     latch.countDown().                 }             }).         }     }     return () -> latch.await(). }
false;;0;3;;Cache<IndexReader.CacheKey, Cache<Query, Value>> getLoadedFilters() {     return loadedFilters. }
true;;2;1;/**  * Called for each cached bitset on the cache event.  * @param shardId the shard id the bitset was cached for. This can be <code>null</code>  * @param accountable the bitsets ram representation  */ ;/**  * Called for each cached bitset on the cache event.  * @param shardId the shard id the bitset was cached for. This can be <code>null</code>  * @param accountable the bitsets ram representation  */ void onCache(ShardId shardId, Accountable accountable).
true;;2;1;/**  * Called for each cached bitset on the removal event.  * @param shardId the shard id the bitset was cached for. This can be <code>null</code>  * @param accountable the bitsets ram representation  */ ;/**  * Called for each cached bitset on the removal event.  * @param shardId the shard id the bitset was cached for. This can be <code>null</code>  * @param accountable the bitsets ram representation  */ void onRemoval(ShardId shardId, Accountable accountable).
