commented;modifiers;parameterAmount;loc;comment;code
true;;1;1;/**  * Registers a new request handler  */ ;/**  * Registers a new request handler  */ <Request extends TransportRequest> void registerRequestHandler(RequestHandlerRegistry<Request> reg).
true;;1;1;/**  * Returns the registered request handler registry for the given action or <code>null</code> if it's not registered  * @param action the action to look up  */ ;/**  * Returns the registered request handler registry for the given action or <code>null</code> if it's not registered  * @param action the action to look up  */ RequestHandlerRegistry<? extends TransportRequest> getRequestHandler(String action).
false;;1;1;;void addMessageListener(TransportMessageListener listener).
false;;1;1;;boolean removeMessageListener(TransportMessageListener listener).
true;;0;1;/**  * The address the transport is bound on.  */ ;/**  * The address the transport is bound on.  */ BoundTransportAddress boundAddress().
true;;0;1;/**  * Further profile bound addresses  * @return <code>null</code> iff profiles are unsupported, otherwise a map with name of profile and its bound transport address  */ ;/**  * Further profile bound addresses  * @return <code>null</code> iff profiles are unsupported, otherwise a map with name of profile and its bound transport address  */ Map<String, BoundTransportAddress> profileBoundAddresses().
true;;2;1;/**  * Returns an address from its string representation.  */ ;/**  * Returns an address from its string representation.  */ TransportAddress[] addressesFromString(String address, int perAddressLimit) throws UnknownHostException.
true;;0;1;/**  * Returns a list of all local adresses for this transport  */ ;/**  * Returns a list of all local adresses for this transport  */ List<String> getLocalAddresses().
false;default;0;3;;default CircuitBreaker getInFlightRequestBreaker() {     return new NoopCircuitBreaker("in-flight-noop"). }
true;;3;1;/**  * Opens a new connection to the given node. When the connection is fully connected, the listener is  * called. A {@link Releasable} is returned representing the pending connection. If the caller of this  * method decides to move on before the listener is called with the completed connection, they should  * release the pending connection to prevent hanging connections.  */ ;/**  * Opens a new connection to the given node. When the connection is fully connected, the listener is  * called. A {@link Releasable} is returned representing the pending connection. If the caller of this  * method decides to move on before the listener is called with the completed connection, they should  * release the pending connection to prevent hanging connections.  */ Releasable openConnection(DiscoveryNode node, ConnectionProfile profile, ActionListener<Transport.Connection> listener).
false;;0;1;;TransportStats getStats().
false;;0;1;;ResponseHandlers getResponseHandlers().
true;;0;1;/**  * The node this connection is associated with  */ ;/**  * The node this connection is associated with  */ DiscoveryNode getNode().
true;;4;2;/**  * Sends the request to the node this connection is associated with  * @param requestId see {@link ResponseHandlers#add(ResponseContext)} for details  * @param action the action to execute  * @param request the request to send  * @param options request options to apply  * @throws NodeNotConnectedException if the given node is not connected  */ ;/**  * Sends the request to the node this connection is associated with  * @param requestId see {@link ResponseHandlers#add(ResponseContext)} for details  * @param action the action to execute  * @param request the request to send  * @param options request options to apply  * @throws NodeNotConnectedException if the given node is not connected  */ void sendRequest(long requestId, String action, TransportRequest request, TransportRequestOptions options) throws IOException, TransportException.
true;;1;1;/**  * The listener's {@link ActionListener#onResponse(Object)} method will be called when this  * connection is closed. No implementations currently throw an exception during close, so  * {@link ActionListener#onFailure(Exception)} will not be called.  *  * @param listener to be called  */ ;/**  * The listener's {@link ActionListener#onResponse(Object)} method will be called when this  * connection is closed. No implementations currently throw an exception during close, so  * {@link ActionListener#onFailure(Exception)} will not be called.  *  * @param listener to be called  */ void addCloseListener(ActionListener<Void> listener).
false;;0;1;;boolean isClosed().
true;default;0;3;/**  * Returns the version of the node this connection was established with.  */ ;/**  * Returns the version of the node this connection was established with.  */ default Version getVersion() {     return getNode().getVersion(). }
true;default;0;3;/**  * Returns a key that this connection can be cached on. Delegating subclasses must delegate method call to  * the original connection.  */ ;/**  * Returns a key that this connection can be cached on. Delegating subclasses must delegate method call to  * the original connection.  */ default Object getCacheKey() {     return this. }
false;;0;2;;@Override void close().
false;public;0;3;;public TransportResponseHandler<T> handler() {     return handler. }
false;public;0;3;;public Connection connection() {     return this.connection. }
false;public;0;3;;public String action() {     return this.action. }
true;public;1;3;/**  * Returns <code>true</code> if the give request ID has a context associated with it.  */ ;/**  * Returns <code>true</code> if the give request ID has a context associated with it.  */ public boolean contains(long requestId) {     return handlers.containsKey(requestId). }
true;public;1;3;/**  * Removes and return the {@link ResponseContext} for the given request ID or returns  * <code>null</code> if no context is associated with this request ID.  */ ;/**  * Removes and return the {@link ResponseContext} for the given request ID or returns  * <code>null</code> if no context is associated with this request ID.  */ public ResponseContext remove(long requestId) {     return handlers.remove(requestId). }
true;public;1;6;/**  * Adds a new response context and associates it with a new request ID.  * @return the new request ID  * @see Connection#sendRequest(long, String, TransportRequest, TransportRequestOptions)  */ ;/**  * Adds a new response context and associates it with a new request ID.  * @return the new request ID  * @see Connection#sendRequest(long, String, TransportRequest, TransportRequestOptions)  */ public long add(ResponseContext<? extends TransportResponse> holder) {     long requestId = newRequestId().     ResponseContext existing = handlers.put(requestId, holder).     assert existing == null : "request ID already in use: " + requestId.     return requestId. }
true;;0;3;/**  * Returns a new request ID to use when sending a message via {@link Connection#sendRequest(long, String,  * TransportRequest, TransportRequestOptions)}  */ ;/**  * Returns a new request ID to use when sending a message via {@link Connection#sendRequest(long, String,  * TransportRequest, TransportRequestOptions)}  */ long newRequestId() {     return requestIdGenerator.incrementAndGet(). }
true;public;1;13;/**  * Removes and returns all {@link ResponseContext} instances that match the predicate  */ ;/**  * Removes and returns all {@link ResponseContext} instances that match the predicate  */ public List<ResponseContext<? extends TransportResponse>> prune(Predicate<ResponseContext> predicate) {     final List<ResponseContext<? extends TransportResponse>> holders = new ArrayList<>().     for (Map.Entry<Long, ResponseContext<? extends TransportResponse>> entry : handlers.entrySet()) {         ResponseContext<? extends TransportResponse> holder = entry.getValue().         if (predicate.test(holder)) {             ResponseContext remove = handlers.remove(entry.getKey()).             if (remove != null) {                 holders.add(holder).             }         }     }     return holders. }
true;public;2;10;/**  * called by the {@link Transport} implementation when a response or an exception has been received for a previously  * sent request (before any processing or deserialization was done). Returns the appropriate response handler or null if not  * found.  */ ;/**  * called by the {@link Transport} implementation when a response or an exception has been received for a previously  * sent request (before any processing or deserialization was done). Returns the appropriate response handler or null if not  * found.  */ public TransportResponseHandler<? extends TransportResponse> onResponseReceived(final long requestId, final TransportMessageListener listener) {     ResponseContext<? extends TransportResponse> context = handlers.remove(requestId).     listener.onResponseReceived(requestId, context).     if (context == null) {         return null.     } else {         return context.handler().     } }
