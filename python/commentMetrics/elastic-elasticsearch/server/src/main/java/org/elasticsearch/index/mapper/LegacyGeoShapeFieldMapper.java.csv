commented;modifiers;parameterAmount;loc;comment;code
false;public;1;3;;public void setSpatialStrategy(SpatialStrategy strategy) {     this.strategy = strategy. }
false;public;1;3;;public void setTree(String prefixTree) {     this.tree = prefixTree. }
false;public;1;3;;public void setTreeLevels(int treeLevels) {     this.treeLevels = treeLevels. }
false;public;1;3;;public void setPrecision(String precision) {     this.precision = precision. }
false;public;1;6;;public void setPointsOnly(boolean pointsOnly) {     if (this.strategy == SpatialStrategy.TERM && pointsOnly == false) {         throw new ElasticsearchParseException("points_only cannot be set to false for term strategy").     }     this.pointsOnly = pointsOnly. }
false;public;1;3;;public void setDistanceErrorPct(double distanceErrorPct) {     this.distanceErrorPct = distanceErrorPct. }
false;public,static;4;25;;public static boolean parse(String name, String fieldName, Object fieldNode, DeprecatedParameters deprecatedParameters) {     if (Names.STRATEGY.match(fieldName, LoggingDeprecationHandler.INSTANCE)) {         checkPrefixTreeSupport(fieldName).         deprecatedParameters.setSpatialStrategy(SpatialStrategy.fromString(fieldNode.toString())).     } else if (Names.TREE.match(fieldName, LoggingDeprecationHandler.INSTANCE)) {         checkPrefixTreeSupport(fieldName).         deprecatedParameters.setTree(fieldNode.toString()).     } else if (Names.TREE_LEVELS.match(fieldName, LoggingDeprecationHandler.INSTANCE)) {         checkPrefixTreeSupport(fieldName).         deprecatedParameters.setTreeLevels(Integer.parseInt(fieldNode.toString())).     } else if (Names.PRECISION.match(fieldName, LoggingDeprecationHandler.INSTANCE)) {         checkPrefixTreeSupport(fieldName).         deprecatedParameters.setPrecision(fieldNode.toString()).     } else if (Names.DISTANCE_ERROR_PCT.match(fieldName, LoggingDeprecationHandler.INSTANCE)) {         checkPrefixTreeSupport(fieldName).         deprecatedParameters.setDistanceErrorPct(Double.parseDouble(fieldNode.toString())).     } else if (Names.POINTS_ONLY.match(fieldName, LoggingDeprecationHandler.INSTANCE)) {         checkPrefixTreeSupport(fieldName).         deprecatedParameters.setPointsOnly(XContentMapValues.nodeBooleanValue(fieldNode, name + "." + DeprecatedParameters.Names.POINTS_ONLY)).     } else {         return false.     }     return true. }
false;private,static;1;8;;private static void checkPrefixTreeSupport(String fieldName) {     if (ShapesAvailability.JTS_AVAILABLE == false || ShapesAvailability.SPATIAL4J_AVAILABLE == false) {         throw new ElasticsearchParseException("Field parameter [{}] is not supported for [{}] field type", fieldName, CONTENT_TYPE).     }     DEPRECATION_LOGGER.deprecated("Field parameter [{}] is deprecated and will be removed in a future version.", fieldName). }
false;public;0;4;;@Override public GeoShapeFieldType fieldType() {     return (GeoShapeFieldType) fieldType. }
false;private;1;31;;private void setupFieldTypeDeprecatedParameters(BuilderContext context) {     GeoShapeFieldType ft = fieldType().     if (deprecatedParameters.strategy != null) {         ft.setStrategy(deprecatedParameters.strategy).     }     if (deprecatedParameters.tree != null) {         ft.setTree(deprecatedParameters.tree).     } else if (context.indexCreatedVersion().before(Version.V_6_6_0)) {         ft.setTree(DeprecatedParameters.PrefixTrees.GEOHASH).     }     if (deprecatedParameters.treeLevels != null) {         ft.setTreeLevels(deprecatedParameters.treeLevels).     }     if (deprecatedParameters.precision != null) {         // precision is only set iff: a. treeLevel is not explicitly set, b. its explicitly set         ft.setPrecisionInMeters(DistanceUnit.parse(deprecatedParameters.precision, DistanceUnit.DEFAULT, DistanceUnit.DEFAULT)).     }     if (deprecatedParameters.distanceErrorPct != null) {         ft.setDistanceErrorPct(deprecatedParameters.distanceErrorPct).     }     if (deprecatedParameters.pointsOnly != null) {         ft.setPointsOnly(deprecatedParameters.pointsOnly).     }     GeoShapeFieldType geoShapeFieldType = (GeoShapeFieldType) fieldType.     if (geoShapeFieldType.treeLevels() == 0 && geoShapeFieldType.precisionInMeters() < 0) {         geoShapeFieldType.setDefaultDistanceErrorPct(DeprecatedParameters.Defaults.DISTANCE_ERROR_PCT).     } }
false;private;0;32;;private void setupPrefixTrees() {     GeoShapeFieldType ft = fieldType().     SpatialPrefixTree prefixTree.     if (ft.tree().equals(DeprecatedParameters.PrefixTrees.GEOHASH)) {         prefixTree = new GeohashPrefixTree(ShapeBuilder.SPATIAL_CONTEXT, getLevels(ft.treeLevels(), ft.precisionInMeters(), DeprecatedParameters.Defaults.GEOHASH_TREE_LEVELS, true)).     } else if (ft.tree().equals(DeprecatedParameters.PrefixTrees.LEGACY_QUADTREE)) {         prefixTree = new QuadPrefixTree(ShapeBuilder.SPATIAL_CONTEXT, getLevels(ft.treeLevels(), ft.precisionInMeters(), DeprecatedParameters.Defaults.QUADTREE_LEVELS, false)).     } else if (ft.tree().equals(DeprecatedParameters.PrefixTrees.QUADTREE)) {         prefixTree = new PackedQuadPrefixTree(ShapeBuilder.SPATIAL_CONTEXT, getLevels(ft.treeLevels(), ft.precisionInMeters(), DeprecatedParameters.Defaults.QUADTREE_LEVELS, false)).     } else {         throw new IllegalArgumentException("Unknown prefix tree type [" + ft.tree() + "]").     }     // setup prefix trees regardless of strategy (this is used for the QueryBuilder)     // recursive:     RecursivePrefixTreeStrategy rpts = new RecursivePrefixTreeStrategy(prefixTree, ft.name()).     rpts.setDistErrPct(ft.distanceErrorPct()).     rpts.setPruneLeafyBranches(false).     ft.recursiveStrategy = rpts.     // term:     TermQueryPrefixTreeStrategy termStrategy = new TermQueryPrefixTreeStrategy(prefixTree, ft.name()).     termStrategy.setDistErrPct(ft.distanceErrorPct()).     ft.termStrategy = termStrategy.     // set default (based on strategy):     ft.defaultPrefixTreeStrategy = ft.resolvePrefixTreeStrategy(ft.strategy()).     ft.defaultPrefixTreeStrategy.setPointsOnly(ft.pointsOnly()). }
false;protected;1;14;;@Override protected void setupFieldType(BuilderContext context) {     super.setupFieldType(context).     // but prefix tree strategies require a name, so throw a similar exception     if (fieldType().name().isEmpty()) {         throw new IllegalArgumentException("name cannot be empty string").     }     // setup the deprecated parameters and the prefix tree configuration     setupFieldTypeDeprecatedParameters(context).     setupPrefixTrees(). }
false;private,static;4;7;;private static int getLevels(int treeLevels, double precisionInMeters, int defaultLevels, boolean geoHash) {     if (treeLevels > 0 || precisionInMeters >= 0) {         return Math.max(treeLevels, precisionInMeters >= 0 ? (geoHash ? GeoUtils.geoHashLevelsForPrecision(precisionInMeters) : GeoUtils.quadTreeLevelsForPrecision(precisionInMeters)) : 0).     }     return defaultLevels. }
false;public;1;8;;@Override public LegacyGeoShapeFieldMapper build(BuilderContext context) {     setupFieldType(context).     return new LegacyGeoShapeFieldMapper(name, fieldType, defaultFieldType, ignoreMalformed(context), coerce(context), orientation(), ignoreZValue(), context.indexSettings(), multiFieldsBuilder.build(this, context), copyTo). }
false;public;0;4;;@Override public GeoShapeFieldType clone() {     return new GeoShapeFieldType(this). }
false;public;1;12;;@Override public boolean equals(Object o) {     if (!super.equals(o))         return false.     GeoShapeFieldType that = (GeoShapeFieldType) o.     return treeLevels == that.treeLevels && precisionInMeters == that.precisionInMeters && defaultDistanceErrorPct == that.defaultDistanceErrorPct && Objects.equals(tree, that.tree) && Objects.equals(strategy, that.strategy) && pointsOnly == that.pointsOnly && Objects.equals(distanceErrorPct, that.distanceErrorPct). }
false;public;0;5;;@Override public int hashCode() {     return Objects.hash(super.hashCode(), tree, strategy, pointsOnly, treeLevels, precisionInMeters, distanceErrorPct, defaultDistanceErrorPct). }
false;public;2;27;;@Override public void checkCompatibility(MappedFieldType fieldType, List<String> conflicts) {     super.checkCompatibility(fieldType, conflicts).     GeoShapeFieldType other = (GeoShapeFieldType) fieldType.     // prevent user from changing strategies     if (strategy() != other.strategy()) {         conflicts.add("mapper [" + name() + "] has different [strategy]").     }     // prevent user from changing trees (changes encoding)     if (tree().equals(other.tree()) == false) {         conflicts.add("mapper [" + name() + "] has different [tree]").     }     if ((pointsOnly() != other.pointsOnly())) {         conflicts.add("mapper [" + name() + "] has different points_only").     }     // in lucene's SpatialPrefixTree implementations, need a patch to correct that first     if (treeLevels() != other.treeLevels()) {         conflicts.add("mapper [" + name() + "] has different [tree_levels]").     }     if (precisionInMeters() != other.precisionInMeters()) {         conflicts.add("mapper [" + name() + "] has different [precision]").     } }
false;public;0;3;;public String tree() {     return tree. }
false;public;1;4;;public void setTree(String tree) {     checkIfFrozen().     this.tree = tree. }
false;public;0;3;;public SpatialStrategy strategy() {     return strategy. }
false;public;1;7;;public void setStrategy(SpatialStrategy strategy) {     checkIfFrozen().     this.strategy = strategy.     if (this.strategy.equals(SpatialStrategy.TERM)) {         this.pointsOnly = true.     } }
false;public;0;3;;public boolean pointsOnly() {     return pointsOnly. }
false;public;1;4;;public void setPointsOnly(boolean pointsOnly) {     checkIfFrozen().     this.pointsOnly = pointsOnly. }
false;public;0;3;;public int treeLevels() {     return treeLevels. }
false;public;1;4;;public void setTreeLevels(int treeLevels) {     checkIfFrozen().     this.treeLevels = treeLevels. }
false;public;0;3;;public double precisionInMeters() {     return precisionInMeters. }
false;public;1;4;;public void setPrecisionInMeters(double precisionInMeters) {     checkIfFrozen().     this.precisionInMeters = precisionInMeters. }
false;public;0;3;;public double distanceErrorPct() {     return distanceErrorPct == null ? defaultDistanceErrorPct : distanceErrorPct. }
false;public;1;4;;public void setDistanceErrorPct(double distanceErrorPct) {     checkIfFrozen().     this.distanceErrorPct = distanceErrorPct. }
false;public;1;4;;public void setDefaultDistanceErrorPct(double defaultDistanceErrorPct) {     checkIfFrozen().     this.defaultDistanceErrorPct = defaultDistanceErrorPct. }
false;public;0;3;;public PrefixTreeStrategy defaultPrefixTreeStrategy() {     return this.defaultPrefixTreeStrategy. }
false;public;1;3;;public PrefixTreeStrategy resolvePrefixTreeStrategy(SpatialStrategy strategy) {     return resolvePrefixTreeStrategy(strategy.getStrategyName()). }
false;public;1;9;;public PrefixTreeStrategy resolvePrefixTreeStrategy(String strategyName) {     if (SpatialStrategy.RECURSIVE.getStrategyName().equals(strategyName)) {         return recursiveStrategy.     }     if (SpatialStrategy.TERM.getStrategyName().equals(strategyName)) {         return termStrategy.     }     throw new IllegalArgumentException("Unknown prefix tree strategy [" + strategyName + "]"). }
false;public;0;4;;@Override public GeoShapeFieldType fieldType() {     return (GeoShapeFieldType) super.fieldType(). }
false;public;1;35;;@Override public void parse(ParseContext context) throws IOException {     try {         Shape shape = context.parseExternalValue(Shape.class).         if (shape == null) {             ShapeBuilder shapeBuilder = ShapeParser.parse(context.parser(), this).             if (shapeBuilder == null) {                 return.             }             shape = shapeBuilder.buildS4J().         }         if (fieldType().pointsOnly() == true) {             // index configured for pointsOnly             if (shape instanceof XShapeCollection && XShapeCollection.class.cast(shape).pointsOnly()) {                 // MULTIPOINT data: index each point separately                 List<Shape> shapes = ((XShapeCollection) shape).getShapes().                 for (Shape s : shapes) {                     indexShape(context, s).                 }                 return.             } else if (shape instanceof Point == false) {                 throw new MapperParsingException("[{" + fieldType().name() + "}] is configured for points only but a " + ((shape instanceof JtsGeometry) ? ((JtsGeometry) shape).getGeom().getGeometryType() : shape.getClass()) + " was found").             }         }         indexShape(context, shape).     } catch (Exception e) {         if (ignoreMalformed.value() == false) {             throw new MapperParsingException("failed to parse field [{}] of type [{}]", e, fieldType().name(), fieldType().typeName()).         }         context.addIgnoredField(fieldType.name()).     } }
false;private;2;7;;private void indexShape(ParseContext context, Shape shape) {     List<IndexableField> fields = new ArrayList<>(Arrays.asList(fieldType().defaultPrefixTreeStrategy().createIndexableFields(shape))).     createFieldNamesField(context, fields).     for (IndexableField field : fields) {         context.doc().add(field).     } }
false;protected;3;52;;@Override protected void doXContentBody(XContentBuilder builder, boolean includeDefaults, Params params) throws IOException {     super.doXContentBody(builder, includeDefaults, params).     if (includeDefaults || (fieldType().tree().equals(indexCreatedVersion.onOrAfter(Version.V_6_6_0) ? DeprecatedParameters.Defaults.TREE : DeprecatedParameters.PrefixTrees.GEOHASH)) == false) {         builder.field(DeprecatedParameters.Names.TREE.getPreferredName(), fieldType().tree()).     }     if (fieldType().treeLevels() != 0) {         builder.field(DeprecatedParameters.Names.TREE_LEVELS.getPreferredName(), fieldType().treeLevels()).     } else if (includeDefaults && fieldType().precisionInMeters() == -1) {         // defaults only make sense if precision is not specified         if (DeprecatedParameters.PrefixTrees.GEOHASH.equals(fieldType().tree())) {             builder.field(DeprecatedParameters.Names.TREE_LEVELS.getPreferredName(), DeprecatedParameters.Defaults.GEOHASH_TREE_LEVELS).         } else if (DeprecatedParameters.PrefixTrees.LEGACY_QUADTREE.equals(fieldType().tree())) {             builder.field(DeprecatedParameters.Names.TREE_LEVELS.getPreferredName(), DeprecatedParameters.Defaults.QUADTREE_LEVELS).         } else if (DeprecatedParameters.PrefixTrees.QUADTREE.equals(fieldType().tree())) {             builder.field(DeprecatedParameters.Names.TREE_LEVELS.getPreferredName(), DeprecatedParameters.Defaults.QUADTREE_LEVELS).         } else {             throw new IllegalArgumentException("Unknown prefix tree type [" + fieldType().tree() + "]").         }     }     if (fieldType().precisionInMeters() != -1) {         builder.field(DeprecatedParameters.Names.PRECISION.getPreferredName(), DistanceUnit.METERS.toString(fieldType().precisionInMeters())).     } else if (includeDefaults && fieldType().treeLevels() == 0) {         // defaults only make sense if tree levels are not specified         builder.field(DeprecatedParameters.Names.PRECISION.getPreferredName(), DistanceUnit.METERS.toString(50)).     }     if (indexCreatedVersion.onOrAfter(Version.V_7_0_0)) {         builder.field(DeprecatedParameters.Names.STRATEGY.getPreferredName(), fieldType().strategy().getStrategyName()).     }     if (includeDefaults || fieldType().distanceErrorPct() != fieldType().defaultDistanceErrorPct) {         builder.field(DeprecatedParameters.Names.DISTANCE_ERROR_PCT.getPreferredName(), fieldType().distanceErrorPct()).     }     if (fieldType().strategy() == SpatialStrategy.TERM) {         // For TERMs strategy the defaults for points only change to true         if (includeDefaults || fieldType().pointsOnly() != true) {             builder.field(DeprecatedParameters.Names.POINTS_ONLY.getPreferredName(), fieldType().pointsOnly()).         }     } else {         if (includeDefaults || fieldType().pointsOnly() != DeprecatedParameters.Defaults.POINTS_ONLY) {             builder.field(DeprecatedParameters.Names.POINTS_ONLY.getPreferredName(), fieldType().pointsOnly()).         }     } }
