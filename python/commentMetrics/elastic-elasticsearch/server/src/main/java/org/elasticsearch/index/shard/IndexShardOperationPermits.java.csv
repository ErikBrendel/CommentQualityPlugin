commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public void close() {     closed = true. }
true;;3;11;/**  * Wait for in-flight operations to finish and executes {@code onBlocked} under the guarantee that no new operations are started. Queues  * operations that are occurring in the meanwhile and runs them once {@code onBlocked} has executed.  *  * @param timeout   the maximum time to wait for the in-flight operations block  * @param timeUnit  the time unit of the {@code timeout} argument  * @param onBlocked the action to run once the block has been acquired  * @param <E>       the type of checked exception thrown by {@code onBlocked}  * @throws InterruptedException      if calling thread is interrupted  * @throws TimeoutException          if timed out waiting for in-flight operations to finish  * @throws IndexShardClosedException if operation permit has been closed  */ ;/**  * Wait for in-flight operations to finish and executes {@code onBlocked} under the guarantee that no new operations are started. Queues  * operations that are occurring in the meanwhile and runs them once {@code onBlocked} has executed.  *  * @param timeout   the maximum time to wait for the in-flight operations block  * @param timeUnit  the time unit of the {@code timeout} argument  * @param onBlocked the action to run once the block has been acquired  * @param <E>       the type of checked exception thrown by {@code onBlocked}  * @throws InterruptedException      if calling thread is interrupted  * @throws TimeoutException          if timed out waiting for in-flight operations to finish  * @throws IndexShardClosedException if operation permit has been closed  */ <E extends Exception> void blockOperations(final long timeout, final TimeUnit timeUnit, final CheckedRunnable<E> onBlocked) throws InterruptedException, TimeoutException, E {     delayOperations().     try (Releasable ignored = acquireAll(timeout, timeUnit)) {         onBlocked.run().     } finally {         releaseDelayedOperations().     } }
false;public;1;8;;@Override public void onFailure(final Exception e) {     try {         // resume delayed operations as soon as possible         released.run().     } finally {         onAcquired.onFailure(e).     } }
false;protected;0;11;;@Override protected void doRun() throws Exception {     final Releasable releasable = acquireAll(timeout, timeUnit).     onAcquired.onResponse(() -> {         try {             releasable.close().         } finally {             released.run().         }     }). }
true;public;3;28;/**  * Immediately delays operations and on another thread waits for in-flight operations to finish and then acquires all permits. When all  * permits are acquired, the provided {@link ActionListener} is called under the guarantee that no new operations are started. Delayed  * operations are run once the {@link Releasable} is released or if a failure occurs while acquiring all permits. in this case the  * {@code onFailure} handler will be invoked after delayed operations are released.  *  * @param onAcquired {@link ActionListener} that is invoked once acquisition is successful or failed  * @param timeout    the maximum time to wait for the in-flight operations block  * @param timeUnit   the time unit of the {@code timeout} argument  */ ;/**  * Immediately delays operations and on another thread waits for in-flight operations to finish and then acquires all permits. When all  * permits are acquired, the provided {@link ActionListener} is called under the guarantee that no new operations are started. Delayed  * operations are run once the {@link Releasable} is released or if a failure occurs while acquiring all permits. in this case the  * {@code onFailure} handler will be invoked after delayed operations are released.  *  * @param onAcquired {@link ActionListener} that is invoked once acquisition is successful or failed  * @param timeout    the maximum time to wait for the in-flight operations block  * @param timeUnit   the time unit of the {@code timeout} argument  */ public void asyncBlockOperations(final ActionListener<Releasable> onAcquired, final long timeout, final TimeUnit timeUnit) {     delayOperations().     threadPool.executor(ThreadPool.Names.GENERIC).execute(new AbstractRunnable() {          final RunOnce released = new RunOnce(() -> releaseDelayedOperations()).          @Override         public void onFailure(final Exception e) {             try {                 // resume delayed operations as soon as possible                 released.run().             } finally {                 onAcquired.onFailure(e).             }         }          @Override         protected void doRun() throws Exception {             final Releasable releasable = acquireAll(timeout, timeUnit).             onAcquired.onResponse(() -> {                 try {                     releasable.close().                 } finally {                     released.run().                 }             }).         }     }). }
false;private;0;9;;private void delayOperations() {     if (closed) {         throw new IndexShardClosedException(shardId).     }     synchronized (this) {         assert queuedBlockOperations > 0 || delayedOperations.isEmpty().         queuedBlockOperations++.     } }
false;private;2;17;;private Releasable acquireAll(final long timeout, final TimeUnit timeUnit) throws InterruptedException, TimeoutException {     if (Assertions.ENABLED) {         // since delayed is not volatile, we have to synchronize even here for visibility         synchronized (this) {             assert queuedBlockOperations > 0.         }     }     if (semaphore.tryAcquire(TOTAL_PERMITS, timeout, timeUnit)) {         final RunOnce release = new RunOnce(() -> {             assert semaphore.availablePermits() == 0.             semaphore.release(TOTAL_PERMITS).         }).         return release::run.     } else {         throw new TimeoutException("timeout while blocking operations").     } }
false;private;0;29;;private void releaseDelayedOperations() {     final List<DelayedOperation> queuedActions.     synchronized (this) {         assert queuedBlockOperations > 0.         queuedBlockOperations--.         if (queuedBlockOperations == 0) {             queuedActions = new ArrayList<>(delayedOperations).             delayedOperations.clear().         } else {             queuedActions = Collections.emptyList().         }     }     if (!queuedActions.isEmpty()) {         /*              * Try acquiring permits on fresh thread (for two reasons):              *   - blockOperations can be called on a recovery thread which can be expected to be interrupted when recovery is cancelled.              *     interruptions are bad here as permit acquisition will throw an interrupted exception which will be swallowed by              *     the threaded action listener if the queue of the thread pool on which it submits is full              *   - if a permit is acquired and the queue of the thread pool which the threaded action listener uses is full, the              *     onFailure handler is executed on the calling thread. this should not be the recovery thread as it would delay the              *     recovery              */         threadPool.executor(ThreadPool.Names.GENERIC).execute(() -> {             for (DelayedOperation queuedAction : queuedActions) {                 acquire(queuedAction.listener, null, false, queuedAction.debugInfo, queuedAction.stackTrace).             }         }).     } }
true;public;4;10;/**  * Acquires a permit whenever permit acquisition is not blocked. If the permit is directly available, the provided  * {@link ActionListener} will be called on the calling thread. During calls of  * {@link #blockOperations(long, TimeUnit, CheckedRunnable)}, permit acquisition can be delayed.  * The {@link ActionListener#onResponse(Object)} method will then be called using the provided executor once operations are no  * longer blocked. Note that the executor will not be used for {@link ActionListener#onFailure(Exception)} calls. Those will run  * directly on the calling thread, which in case of delays, will be a generic thread. Callers should thus make sure  * that the {@link ActionListener#onFailure(Exception)} method provided here only contains lightweight operations.  *  * @param onAcquired      {@link ActionListener} that is invoked once acquisition is successful or failed  * @param executorOnDelay executor to use for the possibly delayed {@link ActionListener#onResponse(Object)} call  * @param forceExecution  whether the runnable should force its execution in case it gets rejected  * @param debugInfo       an extra information that can be useful when tracing an unreleased permit. When assertions are enabled  *                        the tracing will capture the supplied object's {@link Object#toString()} value. Otherwise the object  *                        isn't used  */ ;/**  * Acquires a permit whenever permit acquisition is not blocked. If the permit is directly available, the provided  * {@link ActionListener} will be called on the calling thread. During calls of  * {@link #blockOperations(long, TimeUnit, CheckedRunnable)}, permit acquisition can be delayed.  * The {@link ActionListener#onResponse(Object)} method will then be called using the provided executor once operations are no  * longer blocked. Note that the executor will not be used for {@link ActionListener#onFailure(Exception)} calls. Those will run  * directly on the calling thread, which in case of delays, will be a generic thread. Callers should thus make sure  * that the {@link ActionListener#onFailure(Exception)} method provided here only contains lightweight operations.  *  * @param onAcquired      {@link ActionListener} that is invoked once acquisition is successful or failed  * @param executorOnDelay executor to use for the possibly delayed {@link ActionListener#onResponse(Object)} call  * @param forceExecution  whether the runnable should force its execution in case it gets rejected  * @param debugInfo       an extra information that can be useful when tracing an unreleased permit. When assertions are enabled  *                        the tracing will capture the supplied object's {@link Object#toString()} value. Otherwise the object  *                        isn't used  */ public void acquire(final ActionListener<Releasable> onAcquired, final String executorOnDelay, final boolean forceExecution, final Object debugInfo) {     final StackTraceElement[] stackTrace.     if (Assertions.ENABLED) {         stackTrace = Thread.currentThread().getStackTrace().     } else {         stackTrace = null.     }     acquire(onAcquired, executorOnDelay, forceExecution, debugInfo, stackTrace). }
false;private;5;32;;private void acquire(final ActionListener<Releasable> onAcquired, final String executorOnDelay, final boolean forceExecution, final Object debugInfo, final StackTraceElement[] stackTrace) {     if (closed) {         onAcquired.onFailure(new IndexShardClosedException(shardId)).         return.     }     final Releasable releasable.     try {         synchronized (this) {             if (queuedBlockOperations > 0) {                 final Supplier<StoredContext> contextSupplier = threadPool.getThreadContext().newRestorableContext(false).                 final ActionListener<Releasable> wrappedListener.                 if (executorOnDelay != null) {                     wrappedListener = new PermitAwareThreadedActionListener(threadPool, executorOnDelay, new ContextPreservingActionListener<>(contextSupplier, onAcquired), forceExecution).                 } else {                     wrappedListener = new ContextPreservingActionListener<>(contextSupplier, onAcquired).                 }                 delayedOperations.add(new DelayedOperation(wrappedListener, debugInfo, stackTrace)).                 return.             } else {                 releasable = acquire(debugInfo, stackTrace).             }         }     } catch (final InterruptedException e) {         onAcquired.onFailure(e).         return.     }     // execute this outside the synchronized block!     onAcquired.onResponse(releasable). }
false;private;2;22;;private Releasable acquire(Object debugInfo, StackTraceElement[] stackTrace) throws InterruptedException {     assert Thread.holdsLock(this).     if (semaphore.tryAcquire(1, 0, TimeUnit.SECONDS)) {         // the un-timed tryAcquire methods do not honor the fairness setting         final AtomicBoolean closed = new AtomicBoolean().         final Releasable releasable = () -> {             if (closed.compareAndSet(false, true)) {                 if (Assertions.ENABLED) {                     Tuple<String, StackTraceElement[]> existing = issuedPermits.remove(closed).                     assert existing != null.                 }                 semaphore.release(1).             }         }.         if (Assertions.ENABLED) {             issuedPermits.put(closed, new Tuple<>(debugInfo.toString(), stackTrace)).         }         return releasable.     } else {         // this should never happen, if it does something is deeply wrong         throw new IllegalStateException("failed to obtain permit but operations are not delayed").     } }
true;;0;13;/**  * Obtain the active operation count, or zero if all permits are held (even if there are outstanding operations in flight).  *  * @return the active operation count, or zero when all permits are held  */ ;/**  * Obtain the active operation count, or zero if all permits are held (even if there are outstanding operations in flight).  *  * @return the active operation count, or zero when all permits are held  */ int getActiveOperationsCount() {     int availablePermits = semaphore.availablePermits().     if (availablePermits == 0) {         /*              * This occurs when either doBlockOperations is holding all the permits or there are outstanding operations in flight and the              * remainder of the permits are held by doBlockOperations. We do not distinguish between these two cases and simply say that              * the active operations count is zero.              */         return 0.     } else {         return TOTAL_PERMITS - availablePermits.     } }
false;synchronized;0;3;;synchronized boolean isBlocked() {     return queuedBlockOperations > 0. }
true;;0;5;/**  * @return a list of describing each permit that wasn't released yet. The description consist of the debugInfo supplied  *         when the permit was acquired plus a stack traces that was captured when the permit was request.  */ ;/**  * @return a list of describing each permit that wasn't released yet. The description consist of the debugInfo supplied  *         when the permit was acquired plus a stack traces that was captured when the permit was request.  */ List<String> getActiveOperations() {     return issuedPermits.values().stream().map(t -> t.v1() + "\n" + ExceptionsHelper.formatStackTrace(t.v2())).collect(Collectors.toList()). }
false;public;0;4;;@Override public boolean isForceExecution() {     return forceExecution. }
false;protected;0;4;;@Override protected void doRun() throws Exception {     listener.onResponse(releasable). }
false;public;1;5;;@Override public void onRejection(Exception e) {     IOUtils.closeWhileHandlingException(releasable).     super.onRejection(e). }
false;public;1;4;;@Override public void onFailure(Exception e) {     // will possibly execute on the caller thread     listener.onFailure(e). }
false;public;1;25;;@Override public void onResponse(final Releasable releasable) {     threadPool.executor(executor).execute(new AbstractRunnable() {          @Override         public boolean isForceExecution() {             return forceExecution.         }          @Override         protected void doRun() throws Exception {             listener.onResponse(releasable).         }          @Override         public void onRejection(Exception e) {             IOUtils.closeWhileHandlingException(releasable).             super.onRejection(e).         }          @Override         public void onFailure(Exception e) {             // will possibly execute on the caller thread             listener.onFailure(e).         }     }). }
false;public;1;4;;@Override public void onFailure(final Exception e) {     listener.onFailure(e). }
