commented;modifiers;parameterAmount;loc;comment;code
true;public;1;6;/**  * Adds a list of requests to be executed. Either index or delete requests.  */ ;/**  * Adds a list of requests to be executed. Either index or delete requests.  */ public BulkRequest add(DocWriteRequest<?>... requests) {     for (DocWriteRequest<?> request : requests) {         add(request, null).     }     return this. }
false;public;1;3;;public BulkRequest add(DocWriteRequest<?> request) {     return add(request, null). }
true;public;2;13;/**  * Add a request to the current BulkRequest.  * @param request Request to add  * @param payload Optional payload  * @return the current bulk request  */ ;/**  * Add a request to the current BulkRequest.  * @param request Request to add  * @param payload Optional payload  * @return the current bulk request  */ public BulkRequest add(DocWriteRequest<?> request, @Nullable Object payload) {     if (request instanceof IndexRequest) {         add((IndexRequest) request, payload).     } else if (request instanceof DeleteRequest) {         add((DeleteRequest) request, payload).     } else if (request instanceof UpdateRequest) {         add((UpdateRequest) request, payload).     } else {         throw new IllegalArgumentException("No support for request [" + request + "]").     }     indices.add(request.index()).     return this. }
true;public;1;6;/**  * Adds a list of requests to be executed. Either index or delete requests.  */ ;/**  * Adds a list of requests to be executed. Either index or delete requests.  */ public BulkRequest add(Iterable<DocWriteRequest<?>> requests) {     for (DocWriteRequest<?> request : requests) {         add(request).     }     return this. }
true;public;1;3;/**  * Adds an {@link IndexRequest} to the list of actions to execute. Follows the same behavior of {@link IndexRequest}  * (for example, if no id is provided, one will be generated, or usage of the create flag).  */ ;/**  * Adds an {@link IndexRequest} to the list of actions to execute. Follows the same behavior of {@link IndexRequest}  * (for example, if no id is provided, one will be generated, or usage of the create flag).  */ public BulkRequest add(IndexRequest request) {     return internalAdd(request, null). }
false;public;2;3;;public BulkRequest add(IndexRequest request, @Nullable Object payload) {     return internalAdd(request, payload). }
false;;2;11;;BulkRequest internalAdd(IndexRequest request, @Nullable Object payload) {     Objects.requireNonNull(request, "'request' must not be null").     applyGlobalMandatoryParameters(request).     requests.add(request).     addPayload(payload).     // lack of source is validated in validate() method     sizeInBytes += (request.source() != null ? request.source().length() : 0) + REQUEST_OVERHEAD.     indices.add(request.index()).     return this. }
true;public;1;3;/**  * Adds an {@link UpdateRequest} to the list of actions to execute.  */ ;/**  * Adds an {@link UpdateRequest} to the list of actions to execute.  */ public BulkRequest add(UpdateRequest request) {     return internalAdd(request, null). }
false;public;2;3;;public BulkRequest add(UpdateRequest request, @Nullable Object payload) {     return internalAdd(request, payload). }
false;;2;18;;BulkRequest internalAdd(UpdateRequest request, @Nullable Object payload) {     Objects.requireNonNull(request, "'request' must not be null").     applyGlobalMandatoryParameters(request).     requests.add(request).     addPayload(payload).     if (request.doc() != null) {         sizeInBytes += request.doc().source().length().     }     if (request.upsertRequest() != null) {         sizeInBytes += request.upsertRequest().source().length().     }     if (request.script() != null) {         sizeInBytes += request.script().getIdOrCode().length() * 2.     }     indices.add(request.index()).     return this. }
true;public;1;3;/**  * Adds an {@link DeleteRequest} to the list of actions to execute.  */ ;/**  * Adds an {@link DeleteRequest} to the list of actions to execute.  */ public BulkRequest add(DeleteRequest request) {     return add(request, null). }
false;public;2;10;;public BulkRequest add(DeleteRequest request, @Nullable Object payload) {     Objects.requireNonNull(request, "'request' must not be null").     applyGlobalMandatoryParameters(request).     requests.add(request).     addPayload(payload).     sizeInBytes += REQUEST_OVERHEAD.     indices.add(request.index()).     return this. }
false;private;1;13;;private void addPayload(Object payload) {     if (payloads == null) {         if (payload == null) {             return.         }         payloads = new ArrayList<>(requests.size() + 10).         // add requests#size-1 elements to the payloads if it null (we add for an *existing* request)         for (int i = 1. i < requests.size(). i++) {             payloads.add(null).         }     }     payloads.add(payload). }
true;public;0;3;/**  * The list of requests in this bulk request.  */ ;/**  * The list of requests in this bulk request.  */ public List<DocWriteRequest<?>> requests() {     return this.requests. }
true;public;0;4;/**  * The list of optional payloads associated with requests in the same order as the requests. Note, elements within  * it might be null if no payload has been provided.  * <p>  * Note, if no payloads have been provided, this method will return null (as to conserve memory overhead).  */ ;/**  * The list of optional payloads associated with requests in the same order as the requests. Note, elements within  * it might be null if no payload has been provided.  * <p>  * Note, if no payloads have been provided, this method will return null (as to conserve memory overhead).  */ @Nullable public List<Object> payloads() {     return this.payloads. }
true;public;0;3;/**  * The number of actions in the bulk request.  */ ;/**  * The number of actions in the bulk request.  */ public int numberOfActions() {     return requests.size(). }
true;public;0;3;/**  * The estimated size in bytes of the bulk request.  */ ;/**  * The estimated size in bytes of the bulk request.  */ public long estimatedSizeInBytes() {     return sizeInBytes. }
true;public;4;3;/**  * Adds a framed data in binary format  */ ;/**  * Adds a framed data in binary format  */ public BulkRequest add(byte[] data, int from, int length, XContentType xContentType) throws IOException {     return add(data, from, length, null, null, xContentType). }
true;public;6;5;/**  * Adds a framed data in binary format  * @deprecated use {@link #add(byte[], int, int, String, XContentType)} instead  */ ;/**  * Adds a framed data in binary format  * @deprecated use {@link #add(byte[], int, int, String, XContentType)} instead  */ @Deprecated public BulkRequest add(byte[] data, int from, int length, @Nullable String defaultIndex, @Nullable String defaultType, XContentType xContentType) throws IOException {     return add(new BytesArray(data, from, length), defaultIndex, defaultType, xContentType). }
true;public;5;4;/**  * Adds a framed data in binary format  */ ;/**  * Adds a framed data in binary format  */ public BulkRequest add(byte[] data, int from, int length, @Nullable String defaultIndex, XContentType xContentType) throws IOException {     return add(new BytesArray(data, from, length), defaultIndex, MapperService.SINGLE_MAPPING_NAME, xContentType). }
true;public;4;5;/**  * Adds a framed data in binary format  * @deprecated use {@link #add(BytesReference, String, XContentType)} instead  */ ;/**  * Adds a framed data in binary format  * @deprecated use {@link #add(BytesReference, String, XContentType)} instead  */ @Deprecated public BulkRequest add(BytesReference data, @Nullable String defaultIndex, @Nullable String defaultType, XContentType xContentType) throws IOException {     return add(data, defaultIndex, defaultType, null, null, null, null, true, xContentType). }
true;public;3;4;/**  * Adds a framed data in binary format  */ ;/**  * Adds a framed data in binary format  */ public BulkRequest add(BytesReference data, @Nullable String defaultIndex, XContentType xContentType) throws IOException {     return add(data, defaultIndex, MapperService.SINGLE_MAPPING_NAME, null, null, null, null, true, xContentType). }
true;public;5;5;/**  * Adds a framed data in binary format  * @deprecated use {@link #add(BytesReference, String, boolean, XContentType)} instead  */ ;/**  * Adds a framed data in binary format  * @deprecated use {@link #add(BytesReference, String, boolean, XContentType)} instead  */ @Deprecated public BulkRequest add(BytesReference data, @Nullable String defaultIndex, @Nullable String defaultType, boolean allowExplicitIndex, XContentType xContentType) throws IOException {     return add(data, defaultIndex, defaultType, null, null, null, null, allowExplicitIndex, xContentType). }
true;public;4;4;/**  * Adds a framed data in binary format  */ ;/**  * Adds a framed data in binary format  */ public BulkRequest add(BytesReference data, @Nullable String defaultIndex, boolean allowExplicitIndex, XContentType xContentType) throws IOException {     return add(data, defaultIndex, MapperService.SINGLE_MAPPING_NAME, null, null, null, null, allowExplicitIndex, xContentType). }
false;public;8;7;;public BulkRequest add(BytesReference data, @Nullable String defaultIndex, @Nullable String defaultRouting, @Nullable FetchSourceContext defaultFetchSourceContext, @Nullable String defaultPipeline, @Nullable Object payload, boolean allowExplicitIndex, XContentType xContentType) throws IOException {     return add(data, defaultIndex, MapperService.SINGLE_MAPPING_NAME, defaultRouting, defaultFetchSourceContext, defaultPipeline, payload, allowExplicitIndex, xContentType). }
true;public;9;175;/**  * @deprecated use {@link #add(BytesReference, String, String, FetchSourceContext, String, Object, boolean, XContentType)} instead  */ ;/**  * @deprecated use {@link #add(BytesReference, String, String, FetchSourceContext, String, Object, boolean, XContentType)} instead  */ @Deprecated public BulkRequest add(BytesReference data, @Nullable String defaultIndex, @Nullable String defaultType, @Nullable String defaultRouting, @Nullable FetchSourceContext defaultFetchSourceContext, @Nullable String defaultPipeline, @Nullable Object payload, boolean allowExplicitIndex, XContentType xContentType) throws IOException {     XContent xContent = xContentType.xContent().     int line = 0.     int from = 0.     int length = data.length().     byte marker = xContent.streamSeparator().     boolean typesDeprecationLogged = false.     while (true) {         int nextMarker = findNextMarker(marker, from, data, length).         if (nextMarker == -1) {             break.         }         line++.         // EMPTY is safe here because we never call namedObject         try (InputStream stream = data.slice(from, nextMarker - from).streamInput().             XContentParser parser = xContent.createParser(NamedXContentRegistry.EMPTY, LoggingDeprecationHandler.INSTANCE, stream)) {             // move pointers             from = nextMarker + 1.             // Move to START_OBJECT             XContentParser.Token token = parser.nextToken().             if (token == null) {                 continue.             }             if (token != XContentParser.Token.START_OBJECT) {                 throw new IllegalArgumentException("Malformed action/metadata line [" + line + "], expected " + XContentParser.Token.START_OBJECT + " but found [" + token + "]").             }             // Move to FIELD_NAME, that's the action             token = parser.nextToken().             if (token != XContentParser.Token.FIELD_NAME) {                 throw new IllegalArgumentException("Malformed action/metadata line [" + line + "], expected " + XContentParser.Token.FIELD_NAME + " but found [" + token + "]").             }             String action = parser.currentName().             String index = defaultIndex.             String type = defaultType.             String id = null.             String routing = valueOrDefault(defaultRouting, globalRouting).             FetchSourceContext fetchSourceContext = defaultFetchSourceContext.             String opType = null.             long version = Versions.MATCH_ANY.             VersionType versionType = VersionType.INTERNAL.             long ifSeqNo = SequenceNumbers.UNASSIGNED_SEQ_NO.             long ifPrimaryTerm = UNASSIGNED_PRIMARY_TERM.             int retryOnConflict = 0.             String pipeline = valueOrDefault(defaultPipeline, globalPipeline).             // at this stage, next token can either be END_OBJECT (and use default index and type, with auto generated id)             // or START_OBJECT which will have another set of parameters             token = parser.nextToken().             if (token == XContentParser.Token.START_OBJECT) {                 String currentFieldName = null.                 while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {                     if (token == XContentParser.Token.FIELD_NAME) {                         currentFieldName = parser.currentName().                     } else if (token.isValue()) {                         if (INDEX.match(currentFieldName, parser.getDeprecationHandler())) {                             if (!allowExplicitIndex) {                                 throw new IllegalArgumentException("explicit index in bulk is not allowed").                             }                             index = parser.text().                         } else if (TYPE.match(currentFieldName, parser.getDeprecationHandler())) {                             if (typesDeprecationLogged == false) {                                 deprecationLogger.deprecatedAndMaybeLog("bulk_with_types", RestBulkAction.TYPES_DEPRECATION_MESSAGE).                                 typesDeprecationLogged = true.                             }                             type = parser.text().                         } else if (ID.match(currentFieldName, parser.getDeprecationHandler())) {                             id = parser.text().                         } else if (ROUTING.match(currentFieldName, parser.getDeprecationHandler())) {                             routing = parser.text().                         } else if (OP_TYPE.match(currentFieldName, parser.getDeprecationHandler())) {                             opType = parser.text().                         } else if (VERSION.match(currentFieldName, parser.getDeprecationHandler())) {                             version = parser.longValue().                         } else if (VERSION_TYPE.match(currentFieldName, parser.getDeprecationHandler())) {                             versionType = VersionType.fromString(parser.text()).                         } else if (IF_SEQ_NO.match(currentFieldName, parser.getDeprecationHandler())) {                             ifSeqNo = parser.longValue().                         } else if (IF_PRIMARY_TERM.match(currentFieldName, parser.getDeprecationHandler())) {                             ifPrimaryTerm = parser.longValue().                         } else if (RETRY_ON_CONFLICT.match(currentFieldName, parser.getDeprecationHandler())) {                             retryOnConflict = parser.intValue().                         } else if (PIPELINE.match(currentFieldName, parser.getDeprecationHandler())) {                             pipeline = parser.text().                         } else if (SOURCE.match(currentFieldName, parser.getDeprecationHandler())) {                             fetchSourceContext = FetchSourceContext.fromXContent(parser).                         } else {                             throw new IllegalArgumentException("Action/metadata line [" + line + "] contains an unknown parameter [" + currentFieldName + "]").                         }                     } else if (token == XContentParser.Token.START_ARRAY) {                         throw new IllegalArgumentException("Malformed action/metadata line [" + line + "], expected a simple value for field [" + currentFieldName + "] but found [" + token + "]").                     } else if (token == XContentParser.Token.START_OBJECT && SOURCE.match(currentFieldName, parser.getDeprecationHandler())) {                         fetchSourceContext = FetchSourceContext.fromXContent(parser).                     } else if (token != XContentParser.Token.VALUE_NULL) {                         throw new IllegalArgumentException("Malformed action/metadata line [" + line + "], expected a simple value for field [" + currentFieldName + "] but found [" + token + "]").                     }                 }             } else if (token != XContentParser.Token.END_OBJECT) {                 throw new IllegalArgumentException("Malformed action/metadata line [" + line + "], expected " + XContentParser.Token.START_OBJECT + " or " + XContentParser.Token.END_OBJECT + " but found [" + token + "]").             }             if ("delete".equals(action)) {                 add(new DeleteRequest(index, type, id).routing(routing).version(version).versionType(versionType).setIfSeqNo(ifSeqNo).setIfPrimaryTerm(ifPrimaryTerm), payload).             } else {                 nextMarker = findNextMarker(marker, from, data, length).                 if (nextMarker == -1) {                     break.                 }                 line++.                 // of index request.                 if ("index".equals(action)) {                     if (opType == null) {                         internalAdd(new IndexRequest(index, type, id).routing(routing).version(version).versionType(versionType).setPipeline(pipeline).setIfSeqNo(ifSeqNo).setIfPrimaryTerm(ifPrimaryTerm).source(sliceTrimmingCarriageReturn(data, from, nextMarker, xContentType), xContentType), payload).                     } else {                         internalAdd(new IndexRequest(index, type, id).routing(routing).version(version).versionType(versionType).create("create".equals(opType)).setPipeline(pipeline).setIfSeqNo(ifSeqNo).setIfPrimaryTerm(ifPrimaryTerm).source(sliceTrimmingCarriageReturn(data, from, nextMarker, xContentType), xContentType), payload).                     }                 } else if ("create".equals(action)) {                     internalAdd(new IndexRequest(index, type, id).routing(routing).version(version).versionType(versionType).create(true).setPipeline(pipeline).setIfSeqNo(ifSeqNo).setIfPrimaryTerm(ifPrimaryTerm).source(sliceTrimmingCarriageReturn(data, from, nextMarker, xContentType), xContentType), payload).                 } else if ("update".equals(action)) {                     if (version != Versions.MATCH_ANY || versionType != VersionType.INTERNAL) {                         throw new IllegalArgumentException("Update requests do not support versioning. " + "Please use `if_seq_no` and `if_primary_term` instead").                     }                     UpdateRequest updateRequest = new UpdateRequest(index, type, id).routing(routing).retryOnConflict(retryOnConflict).setIfSeqNo(ifSeqNo).setIfPrimaryTerm(ifPrimaryTerm).routing(routing).                     // EMPTY is safe here because we never call namedObject                     try (InputStream dataStream = sliceTrimmingCarriageReturn(data, from, nextMarker, xContentType).streamInput().                         XContentParser sliceParser = xContent.createParser(NamedXContentRegistry.EMPTY, LoggingDeprecationHandler.INSTANCE, dataStream)) {                         updateRequest.fromXContent(sliceParser).                     }                     if (fetchSourceContext != null) {                         updateRequest.fetchSource(fetchSourceContext).                     }                     IndexRequest upsertRequest = updateRequest.upsertRequest().                     if (upsertRequest != null) {                         upsertRequest.setPipeline(defaultPipeline).                     }                     internalAdd(updateRequest, payload).                 }                 // move pointers                 from = nextMarker + 1.             }         }     }     return this. }
true;private;4;9;/**  * Returns the sliced {@link BytesReference}. If the {@link XContentType} is JSON, the byte preceding the marker is checked to see  * if it is a carriage return and if so, the BytesReference is sliced so that the carriage return is ignored  */ ;/**  * Returns the sliced {@link BytesReference}. If the {@link XContentType} is JSON, the byte preceding the marker is checked to see  * if it is a carriage return and if so, the BytesReference is sliced so that the carriage return is ignored  */ private BytesReference sliceTrimmingCarriageReturn(BytesReference bytesReference, int from, int nextMarker, XContentType xContentType) {     final int length.     if (XContentType.JSON == xContentType && bytesReference.get(nextMarker - 1) == (byte) '\r') {         length = nextMarker - from - 1.     } else {         length = nextMarker - from.     }     return bytesReference.slice(from, length). }
true;public;1;4;/**  * Sets the number of shard copies that must be active before proceeding with the write.  * See {@link ReplicationRequest#waitForActiveShards(ActiveShardCount)} for details.  */ ;/**  * Sets the number of shard copies that must be active before proceeding with the write.  * See {@link ReplicationRequest#waitForActiveShards(ActiveShardCount)} for details.  */ public BulkRequest waitForActiveShards(ActiveShardCount waitForActiveShards) {     this.waitForActiveShards = waitForActiveShards.     return this. }
true;public;1;3;/**  * A shortcut for {@link #waitForActiveShards(ActiveShardCount)} where the numerical  * shard count is passed in, instead of having to first call {@link ActiveShardCount#from(int)}  * to get the ActiveShardCount.  */ ;/**  * A shortcut for {@link #waitForActiveShards(ActiveShardCount)} where the numerical  * shard count is passed in, instead of having to first call {@link ActiveShardCount#from(int)}  * to get the ActiveShardCount.  */ public BulkRequest waitForActiveShards(final int waitForActiveShards) {     return waitForActiveShards(ActiveShardCount.from(waitForActiveShards)). }
false;public;0;3;;public ActiveShardCount waitForActiveShards() {     return this.waitForActiveShards. }
false;public;1;5;;@Override public BulkRequest setRefreshPolicy(RefreshPolicy refreshPolicy) {     this.refreshPolicy = refreshPolicy.     return this. }
false;public;0;4;;@Override public RefreshPolicy getRefreshPolicy() {     return refreshPolicy. }
true;public,final;1;4;/**  * A timeout to wait if the index operation can't be performed immediately. Defaults to {@code 1m}.  */ ;/**  * A timeout to wait if the index operation can't be performed immediately. Defaults to {@code 1m}.  */ public final BulkRequest timeout(TimeValue timeout) {     this.timeout = timeout.     return this. }
false;public,final;1;4;;public final BulkRequest pipeline(String globalPipeline) {     this.globalPipeline = globalPipeline.     return this. }
false;public,final;1;4;;public final BulkRequest routing(String globalRouting) {     this.globalRouting = globalRouting.     return this. }
true;public,final;1;3;/**  * A timeout to wait if the index operation can't be performed immediately. Defaults to {@code 1m}.  */ ;/**  * A timeout to wait if the index operation can't be performed immediately. Defaults to {@code 1m}.  */ public final BulkRequest timeout(String timeout) {     return timeout(TimeValue.parseTimeValue(timeout, null, getClass().getSimpleName() + ".timeout")). }
false;public;0;3;;public TimeValue timeout() {     return timeout. }
false;public;0;3;;public String pipeline() {     return globalPipeline. }
false;public;0;3;;public String routing() {     return globalRouting. }
false;private;4;11;;private int findNextMarker(byte marker, int from, BytesReference data, int length) {     for (int i = from. i < length. i++) {         if (data.get(i) == marker) {             return i.         }     }     if (from != length) {         throw new IllegalArgumentException("The bulk request must be terminated by a newline [\n]").     }     return -1. }
false;public;0;23;;@Override public ActionRequestValidationException validate() {     ActionRequestValidationException validationException = null.     if (requests.isEmpty()) {         validationException = addValidationError("no requests added", validationException).     }     for (DocWriteRequest<?> request : requests) {         // We first check if refresh has been set         if (((WriteRequest<?>) request).getRefreshPolicy() != RefreshPolicy.NONE) {             validationException = addValidationError("RefreshPolicy is not supported on an item request. Set it on the BulkRequest instead.", validationException).         }         ActionRequestValidationException ex = ((WriteRequest<?>) request).validate().         if (ex != null) {             if (validationException == null) {                 validationException = new ActionRequestValidationException().             }             validationException.addValidationErrors(ex.validationErrors()).         }     }     return validationException. }
false;public;1;11;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     waitForActiveShards = ActiveShardCount.readFrom(in).     int size = in.readVInt().     for (int i = 0. i < size. i++) {         requests.add(DocWriteRequest.readDocumentRequest(in)).     }     refreshPolicy = RefreshPolicy.readFrom(in).     timeout = in.readTimeValue(). }
false;public;1;11;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     waitForActiveShards.writeTo(out).     out.writeVInt(requests.size()).     for (DocWriteRequest<?> request : requests) {         DocWriteRequest.writeDocumentRequest(out, request).     }     refreshPolicy.writeTo(out).     out.writeTimeValue(timeout). }
false;public;0;4;;@Override public String getDescription() {     return "requests[" + requests.size() + "], indices[" + Strings.collectionToDelimitedString(indices, ", ") + "]". }
false;private;1;6;;private void applyGlobalMandatoryParameters(DocWriteRequest<?> request) {     request.index(valueOrDefault(request.index(), globalIndex)).     if (Strings.isNullOrEmpty(globalType) == false && MapperService.SINGLE_MAPPING_NAME.equals(globalType) == false) {         request.defaultTypeIfNull(globalType).     } }
false;private,static;2;6;;private static String valueOrDefault(String value, String globalDefault) {     if (Strings.isNullOrEmpty(value) && !Strings.isNullOrEmpty(globalDefault)) {         return globalDefault.     }     return value. }
