commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;5;;public static SequenceIDFields emptySeqID() {     return new SequenceIDFields(new LongPoint(NAME, SequenceNumbers.UNASSIGNED_SEQ_NO), new NumericDocValuesField(NAME, SequenceNumbers.UNASSIGNED_SEQ_NO), new NumericDocValuesField(PRIMARY_TERM_NAME, 0), new NumericDocValuesField(TOMBSTONE_NAME, 0)). }
false;public;1;4;;@Override public SeqNoFieldMapper build(BuilderContext context) {     return new SeqNoFieldMapper(context.indexSettings()). }
false;public;3;5;;@Override public MetadataFieldMapper.Builder<?, ?> parse(String name, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {     throw new MapperParsingException(NAME + " is not configurable"). }
false;public;2;5;;@Override public MetadataFieldMapper getDefault(MappedFieldType fieldType, ParserContext context) {     final Settings indexSettings = context.mapperService().getIndexSettings().getSettings().     return new SeqNoFieldMapper(indexSettings). }
false;public;0;4;;@Override public MappedFieldType clone() {     return new SeqNoFieldType(this). }
false;public;0;4;;@Override public String typeName() {     return CONTENT_TYPE. }
false;private;1;16;;private long parse(Object value) {     if (value instanceof Number) {         double doubleValue = ((Number) value).doubleValue().         if (doubleValue < Long.MIN_VALUE || doubleValue > Long.MAX_VALUE) {             throw new IllegalArgumentException("Value [" + value + "] is out of range for a long").         }         if (doubleValue % 1 != 0) {             throw new IllegalArgumentException("Value [" + value + "] has a decimal part").         }         return ((Number) value).longValue().     }     if (value instanceof BytesRef) {         value = ((BytesRef) value).utf8ToString().     }     return Long.parseLong(value.toString()). }
false;public;1;4;;@Override public Query existsQuery(QueryShardContext context) {     return new DocValuesFieldExistsQuery(name()). }
false;public;2;5;;@Override public Query termQuery(Object value, @Nullable QueryShardContext context) {     long v = parse(value).     return LongPoint.newExactQuery(name(), v). }
false;public;2;8;;@Override public Query termsQuery(List<?> values, @Nullable QueryShardContext context) {     long[] v = new long[values.size()].     for (int i = 0. i < values.size(). ++i) {         v[i] = parse(values.get(i)).     }     return LongPoint.newSetQuery(name(), v). }
false;public;5;25;;@Override public Query rangeQuery(Object lowerTerm, Object upperTerm, boolean includeLower, boolean includeUpper, QueryShardContext context) {     long l = Long.MIN_VALUE.     long u = Long.MAX_VALUE.     if (lowerTerm != null) {         l = parse(lowerTerm).         if (includeLower == false) {             if (l == Long.MAX_VALUE) {                 return new MatchNoDocsQuery().             }             ++l.         }     }     if (upperTerm != null) {         u = parse(upperTerm).         if (includeUpper == false) {             if (u == Long.MIN_VALUE) {                 return new MatchNoDocsQuery().             }             --u.         }     }     return LongPoint.newRangeQuery(name(), l, u). }
false;public;1;5;;@Override public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {     failIfNoDocValues().     return new DocValuesIndexFieldData.Builder().numericType(NumericType.LONG). }
false;public;1;4;;@Override public void preParse(ParseContext context) throws IOException {     super.parse(context). }
false;protected;2;10;;@Override protected void parseCreateField(ParseContext context, List<IndexableField> fields) throws IOException {     // see InternalEngine.innerIndex to see where the real version value is set     // also see ParsedDocument.updateSeqID (called by innerIndex)     SequenceIDFields seqID = SequenceIDFields.emptySeqID().     context.seqID(seqID).     fields.add(seqID.seqNo).     fields.add(seqID.seqNoDocValue).     fields.add(seqID.primaryTerm). }
false;public;1;4;;@Override public void parse(ParseContext context) throws IOException { // fields are added in parseCreateField }
false;public;1;20;;@Override public void postParse(ParseContext context) throws IOException {     // In the case of nested docs, let's fill nested docs with the original     // so that Lucene doesn't write a Bitset for documents that     // don't have the field. This is consistent with the default value     // for efficiency.     // we share the parent docs fields to ensure good compression     SequenceIDFields seqID = context.seqID().     assert seqID != null.     final Version versionCreated = context.mapperService().getIndexSettings().getIndexVersionCreated().     final boolean includePrimaryTerm = versionCreated.before(Version.V_6_1_0).     for (Document doc : context.nonRootDocuments()) {         doc.add(seqID.seqNo).         doc.add(seqID.seqNoDocValue).         if (includePrimaryTerm) {             // primary terms are used to distinguish between parent and nested docs since 6.1.0             doc.add(seqID.primaryTerm).         }     } }
false;protected;0;4;;@Override protected String contentType() {     return CONTENT_TYPE. }
false;public;2;4;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     return builder. }
false;protected;1;4;;@Override protected void doMerge(Mapper mergeWith) { // nothing to do }
