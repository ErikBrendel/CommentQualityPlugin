commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;9;;public static Type fromString(String type) {     if (type.equalsIgnoreCase("category")) {         return CATEGORY.     } else if (type.equalsIgnoreCase("geo")) {         return GEO.     } else {         throw new IllegalArgumentException("No context type for [" + type + "]").     } }
true;public;0;3;/**  * @return the type name of the context  */ ;/**  * @return the type name of the context  */ public Type type() {     return type. }
true;public;0;3;/**  * @return the name/id of the context  */ ;/**  * @return the name/id of the context  */ public String name() {     return name. }
true;public,abstract;2;2;/**  * Parses a set of index-time contexts.  */ ;/**  * Parses a set of index-time contexts.  */ public abstract Set<String> parseContext(ParseContext parseContext, XContentParser parser) throws IOException, ElasticsearchParseException.
true;protected,abstract;1;1;/**  * Retrieves a set of context from a <code>document</code> at index-time.  */ ;/**  * Retrieves a set of context from a <code>document</code> at index-time.  */ protected abstract Set<String> parseContext(ParseContext.Document document).
true;protected,abstract;1;1;/**  * Prototype for the query context  */ ;/**  * Prototype for the query context  */ protected abstract T fromXContent(XContentParser context) throws IOException.
true;public,final;1;13;/**  * Parses query contexts for this mapper  */ ;/**  * Parses query contexts for this mapper  */ public final List<InternalQueryContext> parseQueryContext(XContentParser parser) throws IOException, ElasticsearchParseException {     List<T> queryContexts = new ArrayList<>().     Token token = parser.nextToken().     if (token == Token.START_ARRAY) {         while (parser.nextToken() != Token.END_ARRAY) {             queryContexts.add(fromXContent(parser)).         }     } else {         queryContexts.add(fromXContent(parser)).     }     return toInternalQueryContexts(queryContexts). }
true;protected,abstract;1;1;/**  * Convert query contexts to common representation  */ ;/**  * Convert query contexts to common representation  */ protected abstract List<InternalQueryContext> toInternalQueryContexts(List<T> queryContexts).
true;protected,abstract;2;1;/**  * Implementations should add specific configurations  * that need to be persisted  */ ;/**  * Implementations should add specific configurations  * that need to be persisted  */ protected abstract XContentBuilder toInnerXContent(XContentBuilder builder, Params params) throws IOException.
true;protected;2;3;/**  * Checks if the current context is consistent with the rest of the fields. For example, the GeoContext  * should check that the field that it points to has the correct type.  */ ;/**  * Checks if the current context is consistent with the rest of the fields. For example, the GeoContext  * should check that the field that it points to has the correct type.  */ protected void validateReferences(Version indexVersionCreated, Function<String, MappedFieldType> fieldResolver) { // No validation is required by default }
true;public,static;3;13;/**  * Verifies that all field paths specified in contexts point to the fields with correct mappings  */ ;/**  * Verifies that all field paths specified in contexts point to the fields with correct mappings  */ public static void validateContextPaths(Version indexVersionCreated, List<FieldMapper> fieldMappers, Function<String, MappedFieldType> fieldResolver) {     for (FieldMapper fieldMapper : fieldMappers) {         if (CompletionFieldMapper.CONTENT_TYPE.equals(fieldMapper.typeName())) {             CompletionFieldMapper.CompletionFieldType fieldType = ((CompletionFieldMapper) fieldMapper).fieldType().             if (fieldType.hasContextMappings()) {                 for (ContextMapping context : fieldType.getContextMappings()) {                     context.validateReferences(indexVersionCreated, fieldResolver).                 }             }         }     } }
false;public,final;2;7;;@Override public final XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.field(FIELD_NAME, name).     builder.field(FIELD_TYPE, type.name()).     toInnerXContent(builder, params).     return builder. }
false;public;1;8;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     ContextMapping<?> that = (ContextMapping<?>) o.     if (type != that.type)         return false.     return name.equals(that.name). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(type, name). }
false;public;0;8;;@Override public String toString() {     try {         return Strings.toString(toXContent(JsonXContent.contentBuilder(), ToXContent.EMPTY_PARAMS)).     } catch (IOException e) {         return super.toString().     } }
false;public;1;12;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     InternalQueryContext that = (InternalQueryContext) o.     if (boost != that.boost)         return false.     if (isPrefix != that.isPrefix)         return false.     return context != null ? context.equals(that.context) : that.context == null. }
false;public;0;7;;@Override public int hashCode() {     int result = context != null ? context.hashCode() : 0.     result = 31 * result + boost.     result = 31 * result + (isPrefix ? 1 : 0).     return result. }
false;public;0;8;;@Override public String toString() {     return "QueryContext{" + "context='" + context + '\'' + ", boost=" + boost + ", isPrefix=" + isPrefix + '}'. }
