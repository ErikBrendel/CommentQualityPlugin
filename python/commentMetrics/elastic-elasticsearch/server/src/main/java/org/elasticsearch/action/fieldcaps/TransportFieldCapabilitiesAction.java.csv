commented;modifiers;parameterAmount;loc;comment;code
false;public;1;5;;@Override public void onResponse(FieldCapabilitiesIndexResponse result) {     indexResponses.add(result).     onResponse.run(). }
false;public;1;5;;@Override public void onFailure(Exception e) {     // TODO we should somehow inform the user that we failed     onResponse.run(). }
false;protected;3;66;;@Override protected void doExecute(Task task, FieldCapabilitiesRequest request, final ActionListener<FieldCapabilitiesResponse> listener) {     final ClusterState clusterState = clusterService.state().     final Map<String, OriginalIndices> remoteClusterIndices = remoteClusterService.groupIndices(request.indicesOptions(), request.indices(), idx -> indexNameExpressionResolver.hasIndexOrAlias(idx, clusterState)).     final OriginalIndices localIndices = remoteClusterIndices.remove(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY).     final String[] concreteIndices.     if (localIndices == null) {         // in the case we have one or more remote indices but no local we don't expand to all local indices and just do remote indices         concreteIndices = Strings.EMPTY_ARRAY.     } else {         concreteIndices = indexNameExpressionResolver.concreteIndexNames(clusterState, localIndices).     }     final int totalNumRequest = concreteIndices.length + remoteClusterIndices.size().     final CountDown completionCounter = new CountDown(totalNumRequest).     final List<FieldCapabilitiesIndexResponse> indexResponses = Collections.synchronizedList(new ArrayList<>()).     final Runnable onResponse = () -> {         if (completionCounter.countDown()) {             if (request.isMergeResults()) {                 listener.onResponse(merge(indexResponses)).             } else {                 listener.onResponse(new FieldCapabilitiesResponse(indexResponses)).             }         }     }.     if (totalNumRequest == 0) {         listener.onResponse(new FieldCapabilitiesResponse(Collections.emptyMap())).     } else {         ActionListener<FieldCapabilitiesIndexResponse> innerListener = new ActionListener<FieldCapabilitiesIndexResponse>() {              @Override             public void onResponse(FieldCapabilitiesIndexResponse result) {                 indexResponses.add(result).                 onResponse.run().             }              @Override             public void onFailure(Exception e) {                 // TODO we should somehow inform the user that we failed                 onResponse.run().             }         }.         for (String index : concreteIndices) {             shardAction.execute(new FieldCapabilitiesIndexRequest(request.fields(), index, localIndices), innerListener).         }         // send us back all individual index results.         for (Map.Entry<String, OriginalIndices> remoteIndices : remoteClusterIndices.entrySet()) {             String clusterAlias = remoteIndices.getKey().             OriginalIndices originalIndices = remoteIndices.getValue().             Client remoteClusterClient = remoteClusterService.getRemoteClusterClient(threadPool, clusterAlias).             FieldCapabilitiesRequest remoteRequest = new FieldCapabilitiesRequest().             // we need to merge on this node             remoteRequest.setMergeResults(false).             remoteRequest.indicesOptions(originalIndices.indicesOptions()).             remoteRequest.indices(originalIndices.indices()).             remoteRequest.fields(request.fields()).             remoteClusterClient.fieldCaps(remoteRequest, ActionListener.wrap(response -> {                 for (FieldCapabilitiesIndexResponse res : response.getIndexResponses()) {                     indexResponses.add(new FieldCapabilitiesIndexResponse(RemoteClusterAware.buildRemoteIndexName(clusterAlias, res.getIndexName()), res.get())).                 }                 onResponse.run().             }, failure -> onResponse.run())).         }     } }
false;private;1;20;;private FieldCapabilitiesResponse merge(List<FieldCapabilitiesIndexResponse> indexResponses) {     Map<String, Map<String, FieldCapabilities.Builder>> responseMapBuilder = new HashMap<>().     for (FieldCapabilitiesIndexResponse response : indexResponses) {         innerMerge(responseMapBuilder, response.getIndexName(), response.get()).     }     Map<String, Map<String, FieldCapabilities>> responseMap = new HashMap<>().     for (Map.Entry<String, Map<String, FieldCapabilities.Builder>> entry : responseMapBuilder.entrySet()) {         Map<String, FieldCapabilities> typeMap = new HashMap<>().         boolean multiTypes = entry.getValue().size() > 1.         for (Map.Entry<String, FieldCapabilities.Builder> fieldEntry : entry.getValue().entrySet()) {             typeMap.put(fieldEntry.getKey(), fieldEntry.getValue().build(multiTypes)).         }         responseMap.put(entry.getKey(), typeMap).     }     return new FieldCapabilitiesResponse(responseMap). }
false;private;3;11;;private void innerMerge(Map<String, Map<String, FieldCapabilities.Builder>> responseMapBuilder, String indexName, Map<String, FieldCapabilities> map) {     for (Map.Entry<String, FieldCapabilities> entry : map.entrySet()) {         final String field = entry.getKey().         final FieldCapabilities fieldCap = entry.getValue().         Map<String, FieldCapabilities.Builder> typeMap = responseMapBuilder.computeIfAbsent(field, f -> new HashMap<>()).         FieldCapabilities.Builder builder = typeMap.computeIfAbsent(fieldCap.getType(), key -> new FieldCapabilities.Builder(field, key)).         builder.add(indexName, fieldCap.isSearchable(), fieldCap.isAggregatable()).     } }
