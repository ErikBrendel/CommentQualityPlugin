commented;modifiers;parameterAmount;loc;comment;code
false;private;0;3;;private int computeHashCode() {     return typeLiteral.hashCode() * 31 + annotationStrategy.hashCode(). }
true;public,final;0;3;/**  * Gets the key type.  */ ;/**  * Gets the key type.  */ public final TypeLiteral<T> getTypeLiteral() {     return typeLiteral. }
true;public,final;0;3;/**  * Gets the annotation type.  */ ;/**  * Gets the annotation type.  */ public final Class<? extends Annotation> getAnnotationType() {     return annotationStrategy.getAnnotationType(). }
true;public,final;0;3;/**  * Gets the annotation.  */ ;/**  * Gets the annotation.  */ public final Annotation getAnnotation() {     return annotationStrategy.getAnnotation(). }
false;;0;3;;boolean hasAnnotationType() {     return annotationStrategy.getAnnotationType() != null. }
false;;0;9;;String getAnnotationName() {     Annotation annotation = annotationStrategy.getAnnotation().     if (annotation != null) {         return annotation.toString().     }     // not test-covered     return annotationStrategy.getAnnotationType().toString(). }
false;;0;3;;Class<? super T> getRawType() {     return typeLiteral.getRawType(). }
true;;0;3;/**  * Gets the key of this key's provider.  */ ;/**  * Gets the key of this key's provider.  */ Key<Provider<T>> providerKey() {     return ofType(typeLiteral.providerType()). }
false;public,final;1;12;;@Override public final boolean equals(Object o) {     if (o == this) {         return true.     }     if (!(o instanceof Key<?>)) {         return false.     }     Key<?> other = (Key<?>) o.     return annotationStrategy.equals(other.annotationStrategy) && typeLiteral.equals(other.typeLiteral). }
false;public,final;0;4;;@Override public final int hashCode() {     return this.hashCode. }
false;public,final;0;7;;@Override public final String toString() {     return new ToStringBuilder(Key.class).add("type", typeLiteral).add("annotation", annotationStrategy).toString(). }
true;static;2;4;/**  * Gets a key for an injection type and an annotation strategy.  */ ;/**  * Gets a key for an injection type and an annotation strategy.  */ static <T> Key<T> get(Class<T> type, AnnotationStrategy annotationStrategy) {     return new Key<>(type, annotationStrategy). }
true;public,static;1;3;/**  * Gets a key for an injection type.  */ ;/**  * Gets a key for an injection type.  */ public static <T> Key<T> get(Class<T> type) {     return new Key<>(type, NullAnnotationStrategy.INSTANCE). }
true;public,static;2;4;/**  * Gets a key for an injection type and an annotation type.  */ ;/**  * Gets a key for an injection type and an annotation type.  */ public static <T> Key<T> get(Class<T> type, Class<? extends Annotation> annotationType) {     return new Key<>(type, strategyFor(annotationType)). }
true;public,static;2;3;/**  * Gets a key for an injection type and an annotation.  */ ;/**  * Gets a key for an injection type and an annotation.  */ public static <T> Key<T> get(Class<T> type, Annotation annotation) {     return new Key<>(type, strategyFor(annotation)). }
true;public,static;1;3;/**  * Gets a key for an injection type.  */ ;/**  * Gets a key for an injection type.  */ public static Key<?> get(Type type) {     return new Key<Object>(type, NullAnnotationStrategy.INSTANCE). }
true;public,static;2;4;/**  * Gets a key for an injection type and an annotation type.  */ ;/**  * Gets a key for an injection type and an annotation type.  */ public static Key<?> get(Type type, Class<? extends Annotation> annotationType) {     return new Key<Object>(type, strategyFor(annotationType)). }
true;public,static;2;3;/**  * Gets a key for an injection type and an annotation.  */ ;/**  * Gets a key for an injection type and an annotation.  */ public static Key<?> get(Type type, Annotation annotation) {     return new Key<Object>(type, strategyFor(annotation)). }
true;public,static;1;3;/**  * Gets a key for an injection type.  */ ;/**  * Gets a key for an injection type.  */ public static <T> Key<T> get(TypeLiteral<T> typeLiteral) {     return new Key<>(typeLiteral, NullAnnotationStrategy.INSTANCE). }
true;public,static;2;4;/**  * Gets a key for an injection type and an annotation type.  */ ;/**  * Gets a key for an injection type and an annotation type.  */ public static <T> Key<T> get(TypeLiteral<T> typeLiteral, Class<? extends Annotation> annotationType) {     return new Key<>(typeLiteral, strategyFor(annotationType)). }
true;public,static;2;4;/**  * Gets a key for an injection type and an annotation.  */ ;/**  * Gets a key for an injection type and an annotation.  */ public static <T> Key<T> get(TypeLiteral<T> typeLiteral, Annotation annotation) {     return new Key<>(typeLiteral, strategyFor(annotation)). }
true;;1;3;/**  * Returns a new key of the specified type with the same annotation as this  * key.  */ ;/**  * Returns a new key of the specified type with the same annotation as this  * key.  */ <T> Key<T> ofType(Class<T> type) {     return new Key<>(type, annotationStrategy). }
true;;1;3;/**  * Returns a new key of the specified type with the same annotation as this  * key.  */ ;/**  * Returns a new key of the specified type with the same annotation as this  * key.  */ Key<?> ofType(Type type) {     return new Key<Object>(type, annotationStrategy). }
true;;1;3;/**  * Returns a new key of the specified type with the same annotation as this  * key.  */ ;/**  * Returns a new key of the specified type with the same annotation as this  * key.  */ <T> Key<T> ofType(TypeLiteral<T> type) {     return new Key<>(type, annotationStrategy). }
true;;0;3;/**  * Returns true if this key has annotation attributes.  */ ;/**  * Returns true if this key has annotation attributes.  */ boolean hasAttributes() {     return annotationStrategy.hasAttributes(). }
true;;0;3;/**  * Returns this key without annotation attributes, i.e. with only the  * annotation type.  */ ;/**  * Returns this key without annotation attributes, i.e. with only the  * annotation type.  */ Key<T> withoutAttributes() {     return new Key<>(typeLiteral, annotationStrategy.withoutAttributes()). }
false;;0;1;;Annotation getAnnotation().
false;;0;1;;Class<? extends Annotation> getAnnotationType().
false;;0;1;;boolean hasAttributes().
false;;0;1;;AnnotationStrategy withoutAttributes().
true;static;1;3;/**  * Returns {@code true} if the given annotation type has no attributes.  */ ;/**  * Returns {@code true} if the given annotation type has no attributes.  */ static boolean isMarker(Class<? extends Annotation> annotationType) {     return annotationType.getMethods().length == 0. }
true;static;1;12;/**  * Gets the strategy for an annotation.  */ ;/**  * Gets the strategy for an annotation.  */ static AnnotationStrategy strategyFor(Annotation annotation) {     Objects.requireNonNull(annotation, "annotation").     Class<? extends Annotation> annotationType = annotation.annotationType().     ensureRetainedAtRuntime(annotationType).     ensureIsBindingAnnotation(annotationType).     if (annotationType.getMethods().length == 0) {         return new AnnotationTypeStrategy(annotationType, annotation).     }     return new AnnotationInstanceStrategy(annotation). }
true;static;1;6;/**  * Gets the strategy for an annotation type.  */ ;/**  * Gets the strategy for an annotation type.  */ static AnnotationStrategy strategyFor(Class<? extends Annotation> annotationType) {     Objects.requireNonNull(annotationType, "annotation type").     ensureRetainedAtRuntime(annotationType).     ensureIsBindingAnnotation(annotationType).     return new AnnotationTypeStrategy(annotationType, null). }
false;private,static;1;8;;private static void ensureRetainedAtRuntime(Class<? extends Annotation> annotationType) {     if (!Annotations.isRetainedAtRuntime(annotationType)) {         throw new IllegalArgumentException(annotationType.getName() + " is not retained at runtime. Please annotate it with @Retention(RUNTIME).").     } }
false;private,static;1;8;;private static void ensureIsBindingAnnotation(Class<? extends Annotation> annotationType) {     if (!isBindingAnnotation(annotationType)) {         throw new IllegalArgumentException(annotationType.getName() + " is not a binding annotation. Please annotate it with @BindingAnnotation.").     } }
false;public;0;4;;@Override public boolean hasAttributes() {     return false. }
false;public;0;4;;@Override public AnnotationStrategy withoutAttributes() {     throw new UnsupportedOperationException("Key already has no attributes."). }
false;public;0;4;;@Override public Annotation getAnnotation() {     return null. }
false;public;0;4;;@Override public Class<? extends Annotation> getAnnotationType() {     return null. }
false;public;0;4;;@Override public String toString() {     return "[none]". }
false;public;0;4;;@Override public boolean hasAttributes() {     return true. }
false;public;0;4;;@Override public AnnotationStrategy withoutAttributes() {     return new AnnotationTypeStrategy(getAnnotationType(), annotation). }
false;public;0;4;;@Override public Annotation getAnnotation() {     return annotation. }
false;public;0;4;;@Override public Class<? extends Annotation> getAnnotationType() {     return annotation.annotationType(). }
false;public;1;9;;@Override public boolean equals(Object o) {     if (!(o instanceof AnnotationInstanceStrategy)) {         return false.     }     AnnotationInstanceStrategy other = (AnnotationInstanceStrategy) o.     return annotation.equals(other.annotation). }
false;public;0;4;;@Override public int hashCode() {     return annotation.hashCode(). }
false;public;0;4;;@Override public String toString() {     return annotation.toString(). }
false;public;0;4;;@Override public boolean hasAttributes() {     return false. }
false;public;0;4;;@Override public AnnotationStrategy withoutAttributes() {     throw new UnsupportedOperationException("Key already has no attributes."). }
false;public;0;4;;@Override public Annotation getAnnotation() {     return annotation. }
false;public;0;4;;@Override public Class<? extends Annotation> getAnnotationType() {     return annotationType. }
false;public;1;9;;@Override public boolean equals(Object o) {     if (!(o instanceof AnnotationTypeStrategy)) {         return false.     }     AnnotationTypeStrategy other = (AnnotationTypeStrategy) o.     return annotationType.equals(other.annotationType). }
false;public;0;4;;@Override public int hashCode() {     return annotationType.hashCode(). }
false;public;0;4;;@Override public String toString() {     return "@" + annotationType.getName(). }
false;static;1;3;;static boolean isBindingAnnotation(Annotation annotation) {     return isBindingAnnotation(annotation.annotationType()). }
false;static;1;4;;static boolean isBindingAnnotation(Class<? extends Annotation> annotationType) {     return annotationType.getAnnotation(BindingAnnotation.class) != null. }
