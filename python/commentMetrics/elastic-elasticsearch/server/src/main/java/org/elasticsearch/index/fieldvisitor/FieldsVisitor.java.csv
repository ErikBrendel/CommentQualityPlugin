commented;modifiers;parameterAmount;loc;comment;code
false;public;1;17;;@Override public Status needsField(FieldInfo fieldInfo) throws IOException {     if (requiredFields.remove(fieldInfo.name)) {         return Status.YES.     }     // so its stored fields always appear first in the list.     if (IgnoredFieldMapper.NAME.equals(fieldInfo.name)) {         return Status.YES.     }     // empty     return requiredFields.isEmpty() ? Status.STOP : Status.NO. }
false;public;1;17;;public void postProcess(MapperService mapperService) {     final DocumentMapper mapper = mapperService.documentMapper().     if (mapper != null) {         type = mapper.type().     }     for (Map.Entry<String, List<Object>> entry : fields().entrySet()) {         MappedFieldType fieldType = mapperService.fullName(entry.getKey()).         if (fieldType == null) {             throw new IllegalStateException("Field [" + entry.getKey() + "] exists in the index but not in mappings").         }         List<Object> fieldValues = entry.getValue().         for (int i = 0. i < fieldValues.size(). i++) {             fieldValues.set(i, fieldType.valueForDisplay(fieldValues.get(i))).         }     } }
false;public;2;10;;@Override public void binaryField(FieldInfo fieldInfo, byte[] value) throws IOException {     if (sourceFieldName.equals(fieldInfo.name)) {         source = new BytesArray(value).     } else if (IdFieldMapper.NAME.equals(fieldInfo.name)) {         id = Uid.decodeId(value).     } else {         addValue(fieldInfo.name, new BytesRef(value)).     } }
false;public;2;5;;@Override public void stringField(FieldInfo fieldInfo, byte[] bytes) throws IOException {     final String value = new String(bytes, StandardCharsets.UTF_8).     addValue(fieldInfo.name, value). }
false;public;2;4;;@Override public void intField(FieldInfo fieldInfo, int value) throws IOException {     addValue(fieldInfo.name, value). }
false;public;2;4;;@Override public void longField(FieldInfo fieldInfo, long value) throws IOException {     addValue(fieldInfo.name, value). }
false;public;2;4;;@Override public void floatField(FieldInfo fieldInfo, float value) throws IOException {     addValue(fieldInfo.name, value). }
false;public;2;4;;@Override public void doubleField(FieldInfo fieldInfo, double value) throws IOException {     addValue(fieldInfo.name, value). }
false;public;0;3;;public BytesReference source() {     return source. }
false;public;0;8;;public Uid uid() {     if (id == null) {         return null.     } else if (type == null) {         throw new IllegalStateException("Call postProcess before getting the uid").     }     return new Uid(type, id). }
false;public;0;11;;public String routing() {     if (fieldsValues == null) {         return null.     }     List<Object> values = fieldsValues.get(RoutingFieldMapper.NAME).     if (values == null || values.isEmpty()) {         return null.     }     assert values.size() == 1.     return values.get(0).toString(). }
false;public;0;3;;public Map<String, List<Object>> fields() {     return fieldsValues != null ? fieldsValues : emptyMap(). }
false;public;0;11;;public void reset() {     if (fieldsValues != null)         fieldsValues.clear().     source = null.     type = null.     id = null.     requiredFields.addAll(BASE_REQUIRED_FIELDS).     if (loadSource) {         requiredFields.add(sourceFieldName).     } }
false;;2;12;;void addValue(String name, Object value) {     if (fieldsValues == null) {         fieldsValues = new HashMap<>().     }     List<Object> values = fieldsValues.get(name).     if (values == null) {         values = new ArrayList<>(2).         fieldsValues.put(name, values).     }     values.add(value). }
