commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public String getName() {     return this.name. }
false;public;0;3;;public long getGeneration() {     return this.generation. }
false;public;0;3;;public boolean isCommitted() {     return this.committed. }
false;public;0;3;;public boolean isSearch() {     return this.search. }
false;public;0;3;;public int getNumDocs() {     return this.docCount. }
false;public;0;3;;public int getDeletedDocs() {     return this.delDocCount. }
false;public;0;3;;public ByteSizeValue getSize() {     return new ByteSizeValue(sizeInBytes). }
false;public;0;3;;public long getSizeInBytes() {     return this.sizeInBytes. }
false;public;0;3;;public org.apache.lucene.util.Version getVersion() {     return version. }
false;public;0;4;;@Nullable public Boolean isCompound() {     return compound. }
true;public;0;4;/**  * If set, a string representing that the segment is part of a merge, with the value representing the  * group of segments that represent this merge.  */ ;/**  * If set, a string representing that the segment is part of a merge, with the value representing the  * group of segments that represent this merge.  */ @Nullable public String getMergeId() {     return this.mergeId. }
true;public;0;3;/**  * Estimation of the memory usage used by a segment.  */ ;/**  * Estimation of the memory usage used by a segment.  */ public long getMemoryInBytes() {     return this.memoryInBytes. }
true;public;0;3;/**  * Return the sort order of this segment, or null if the segment has no sort.  */ ;/**  * Return the sort order of this segment, or null if the segment has no sort.  */ public Sort getSegmentSort() {     return segmentSort. }
true;public;0;3;/**  * Return segment attributes.  * @see org.apache.lucene.index.SegmentInfo#getAttributes()  */ ;/**  * Return segment attributes.  * @see org.apache.lucene.index.SegmentInfo#getAttributes()  */ public Map<String, String> getAttributes() {     return attributes. }
false;public;1;11;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     Segment segment = (Segment) o.     if (name != null ? !name.equals(segment.name) : segment.name != null)         return false.     return true. }
false;public;0;4;;@Override public int hashCode() {     return name != null ? name.hashCode() : 0. }
false;public,static;1;5;;public static Segment readSegment(StreamInput in) throws IOException {     Segment segment = new Segment().     segment.readFrom(in).     return segment. }
false;public;1;28;;@Override public void readFrom(StreamInput in) throws IOException {     name = in.readString().     generation = Long.parseLong(name.substring(1), Character.MAX_RADIX).     committed = in.readBoolean().     search = in.readBoolean().     docCount = in.readInt().     delDocCount = in.readInt().     sizeInBytes = in.readLong().     version = Lucene.parseVersionLenient(in.readOptionalString(), null).     compound = in.readOptionalBoolean().     mergeId = in.readOptionalString().     memoryInBytes = in.readLong().     if (in.readBoolean()) {         // verbose mode         ramTree = readRamTree(in).     }     if (in.getVersion().onOrAfter(Version.V_6_0_0_alpha1)) {         segmentSort = readSegmentSort(in).     } else {         segmentSort = null.     }     if (in.getVersion().onOrAfter(Version.V_6_1_0) && in.readBoolean()) {         attributes = in.readMap(StreamInput::readString, StreamInput::readString).     } else {         attributes = null.     } }
false;public;1;29;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeString(name).     out.writeBoolean(committed).     out.writeBoolean(search).     out.writeInt(docCount).     out.writeInt(delDocCount).     out.writeLong(sizeInBytes).     out.writeOptionalString(version.toString()).     out.writeOptionalBoolean(compound).     out.writeOptionalString(mergeId).     out.writeLong(memoryInBytes).     boolean verbose = ramTree != null.     out.writeBoolean(verbose).     if (verbose) {         writeRamTree(out, ramTree).     }     if (out.getVersion().onOrAfter(Version.V_6_0_0_alpha1)) {         writeSegmentSort(out, segmentSort).     }     if (out.getVersion().onOrAfter(Version.V_6_1_0)) {         boolean hasAttributes = attributes != null.         out.writeBoolean(hasAttributes).         if (hasAttributes) {             out.writeMap(attributes, StreamOutput::writeString, StreamOutput::writeString).         }     } }
false;;1;50;;Sort readSegmentSort(StreamInput in) throws IOException {     int size = in.readVInt().     if (size == 0) {         return null.     }     SortField[] fields = new SortField[size].     for (int i = 0. i < size. i++) {         String field = in.readString().         byte type = in.readByte().         if (type == 0) {             Boolean missingFirst = in.readOptionalBoolean().             boolean max = in.readBoolean().             boolean reverse = in.readBoolean().             fields[i] = new SortedSetSortField(field, reverse, max ? SortedSetSelector.Type.MAX : SortedSetSelector.Type.MIN).             if (missingFirst != null) {                 fields[i].setMissingValue(missingFirst ? SortedSetSortField.STRING_FIRST : SortedSetSortField.STRING_LAST).             }         } else {             Object missing = in.readGenericValue().             boolean max = in.readBoolean().             boolean reverse = in.readBoolean().             final SortField.Type numericType.             switch(type) {                 case 1:                     numericType = SortField.Type.INT.                     break.                 case 2:                     numericType = SortField.Type.FLOAT.                     break.                 case 3:                     numericType = SortField.Type.DOUBLE.                     break.                 case 4:                     numericType = SortField.Type.LONG.                     break.                 default:                     throw new IOException("invalid index sort type:[" + type + "] for numeric field:[" + field + "]").             }             fields[i] = new SortedNumericSortField(field, numericType, reverse, max ? SortedNumericSelector.Type.MAX : SortedNumericSelector.Type.MIN).             if (missing != null) {                 fields[i].setMissingValue(missing).             }         }     }     return new Sort(fields). }
false;;2;39;;void writeSegmentSort(StreamOutput out, Sort sort) throws IOException {     if (sort == null) {         out.writeVInt(0).         return.     }     out.writeVInt(sort.getSort().length).     for (SortField field : sort.getSort()) {         out.writeString(field.getField()).         if (field instanceof SortedSetSortField) {             out.writeByte((byte) 0).             out.writeOptionalBoolean(field.getMissingValue() == null ? null : field.getMissingValue() == SortField.STRING_FIRST).             out.writeBoolean(((SortedSetSortField) field).getSelector() == SortedSetSelector.Type.MAX).             out.writeBoolean(field.getReverse()).         } else if (field instanceof SortedNumericSortField) {             switch(((SortedNumericSortField) field).getNumericType()) {                 case INT:                     out.writeByte((byte) 1).                     break.                 case FLOAT:                     out.writeByte((byte) 2).                     break.                 case DOUBLE:                     out.writeByte((byte) 3).                     break.                 case LONG:                     out.writeByte((byte) 4).                     break.                 default:                     throw new IOException("invalid index sort field:" + field).             }             out.writeGenericValue(field.getMissingValue()).             out.writeBoolean(((SortedNumericSortField) field).getSelector() == SortedNumericSelector.Type.MAX).             out.writeBoolean(field.getReverse()).         } else {             throw new IOException("invalid index sort field:" + field).         }     } }
false;;1;13;;Accountable readRamTree(StreamInput in) throws IOException {     final String name = in.readString().     final long bytes = in.readVLong().     int numChildren = in.readVInt().     if (numChildren == 0) {         return Accountables.namedAccountable(name, bytes).     }     List<Accountable> children = new ArrayList(numChildren).     while (numChildren-- > 0) {         children.add(readRamTree(in)).     }     return Accountables.namedAccountable(name, children, bytes). }
true;;2;9;// the ram tree is written recursively since the depth is fairly low (5 or 6) ;// the ram tree is written recursively since the depth is fairly low (5 or 6) void writeRamTree(StreamOutput out, Accountable tree) throws IOException {     out.writeString(tree.toString()).     out.writeVLong(tree.ramBytesUsed()).     Collection<Accountable> children = tree.getChildResources().     out.writeVInt(children.size()).     for (Accountable child : children) {         writeRamTree(out, child).     } }
false;public;0;18;;@Override public String toString() {     return "Segment{" + "name='" + name + '\'' + ", generation=" + generation + ", committed=" + committed + ", search=" + search + ", sizeInBytes=" + sizeInBytes + ", docCount=" + docCount + ", delDocCount=" + delDocCount + ", version='" + version + '\'' + ", compound=" + compound + ", mergeId='" + mergeId + '\'' + ", memoryInBytes=" + memoryInBytes + (segmentSort != null ? ", sort=" + segmentSort : "") + ", attributes=" + attributes + '}'. }
