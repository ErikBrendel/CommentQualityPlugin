commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public void onResponse(AcknowledgedResponse putMappingResponse) {     doStoreResult(taskResult, listener). }
false;public;1;4;;@Override public void onFailure(Exception e) {     listener.onFailure(e). }
false;public;1;4;;@Override public void onResponse(CreateIndexResponse result) {     doStoreResult(taskResult, listener). }
false;public;1;14;;@Override public void onFailure(Exception e) {     if (ExceptionsHelper.unwrapCause(e) instanceof ResourceAlreadyExistsException) {         // we have the index, do it         try {             doStoreResult(taskResult, listener).         } catch (Exception inner) {             inner.addSuppressed(e).             listener.onFailure(inner).         }     } else {         listener.onFailure(e).     } }
false;public;2;55;;public void storeResult(TaskResult taskResult, ActionListener<Void> listener) {     ClusterState state = clusterService.state().     if (state.routingTable().hasIndex(TASK_INDEX) == false) {         CreateIndexRequest createIndexRequest = new CreateIndexRequest().         createIndexRequest.settings(taskResultIndexSettings()).         createIndexRequest.index(TASK_INDEX).         createIndexRequest.mapping(TASK_TYPE, taskResultIndexMapping(), XContentType.JSON).         createIndexRequest.cause("auto(task api)").         client.admin().indices().create(createIndexRequest, new ActionListener<CreateIndexResponse>() {              @Override             public void onResponse(CreateIndexResponse result) {                 doStoreResult(taskResult, listener).             }              @Override             public void onFailure(Exception e) {                 if (ExceptionsHelper.unwrapCause(e) instanceof ResourceAlreadyExistsException) {                     // we have the index, do it                     try {                         doStoreResult(taskResult, listener).                     } catch (Exception inner) {                         inner.addSuppressed(e).                         listener.onFailure(inner).                     }                 } else {                     listener.onFailure(e).                 }             }         }).     } else {         IndexMetaData metaData = state.getMetaData().index(TASK_INDEX).         if (getTaskResultMappingVersion(metaData) < TASK_RESULT_MAPPING_VERSION) {             // The index already exists but doesn't have our mapping             client.admin().indices().preparePutMapping(TASK_INDEX).setType(TASK_TYPE).setSource(taskResultIndexMapping(), XContentType.JSON).execute(new ActionListener<AcknowledgedResponse>() {                  @Override                 public void onResponse(AcknowledgedResponse putMappingResponse) {                     doStoreResult(taskResult, listener).                 }                  @Override                 public void onFailure(Exception e) {                     listener.onFailure(e).                 }             }).         } else {             doStoreResult(taskResult, listener).         }     } }
false;private;1;11;;private int getTaskResultMappingVersion(IndexMetaData metaData) {     MappingMetaData mappingMetaData = metaData.getMappings().get(TASK_TYPE).     if (mappingMetaData == null) {         return 0.     }     @SuppressWarnings("unchecked")     Map<String, Object> meta = (Map<String, Object>) mappingMetaData.sourceAsMap().get("_meta").     if (meta == null || meta.containsKey(TASK_RESULT_MAPPING_VERSION_META_FIELD) == false) {         // The mapping was created before meta field was introduced         return 1.     }     return (int) meta.get(TASK_RESULT_MAPPING_VERSION_META_FIELD). }
false;private;2;10;;private void doStoreResult(TaskResult taskResult, ActionListener<Void> listener) {     IndexRequestBuilder index = client.prepareIndex(TASK_INDEX, TASK_TYPE, taskResult.getTask().getTaskId().toString()).     try (XContentBuilder builder = XContentFactory.contentBuilder(Requests.INDEX_CONTENT_TYPE)) {         taskResult.toXContent(builder, ToXContent.EMPTY_PARAMS).         index.setSource(builder).     } catch (IOException e) {         throw new ElasticsearchException("Couldn't convert task result to XContent for [{}]", e, taskResult.getTask()).     }     doStoreResult(STORE_BACKOFF_POLICY.iterator(), index, listener). }
false;public;1;4;;@Override public void onResponse(IndexResponse indexResponse) {     listener.onResponse(null). }
false;public;1;11;;@Override public void onFailure(Exception e) {     if (false == (e instanceof EsRejectedExecutionException) || false == backoff.hasNext()) {         listener.onFailure(e).     } else {         TimeValue wait = backoff.next().         logger.warn(() -> new ParameterizedMessage("failed to store task result, retrying in [{}]", wait), e).         threadPool.schedule(() -> doStoreResult(backoff, index, listener), wait, ThreadPool.Names.SAME).     } }
false;private;3;20;;private void doStoreResult(Iterator<TimeValue> backoff, IndexRequestBuilder index, ActionListener<Void> listener) {     index.execute(new ActionListener<IndexResponse>() {          @Override         public void onResponse(IndexResponse indexResponse) {             listener.onResponse(null).         }          @Override         public void onFailure(Exception e) {             if (false == (e instanceof EsRejectedExecutionException) || false == backoff.hasNext()) {                 listener.onFailure(e).             } else {                 TimeValue wait = backoff.next().                 logger.warn(() -> new ParameterizedMessage("failed to store task result, retrying in [{}]", wait), e).                 threadPool.schedule(() -> doStoreResult(backoff, index, listener), wait, ThreadPool.Names.SAME).             }         }     }). }
false;private;0;7;;private Settings taskResultIndexSettings() {     return Settings.builder().put(IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.getKey(), 1).put(IndexMetaData.INDEX_AUTO_EXPAND_REPLICAS_SETTING.getKey(), "0-1").put(IndexMetaData.SETTING_PRIORITY, Integer.MAX_VALUE).build(). }
false;public;0;12;;public String taskResultIndexMapping() {     try (InputStream is = getClass().getResourceAsStream(TASK_RESULT_INDEX_MAPPING_FILE)) {         ByteArrayOutputStream out = new ByteArrayOutputStream().         Streams.copy(is, out).         return out.toString(StandardCharsets.UTF_8.name()).     } catch (Exception e) {         logger.error(() -> new ParameterizedMessage("failed to create tasks results index template [{}]", TASK_RESULT_INDEX_MAPPING_FILE), e).         throw new IllegalStateException("failed to create tasks results index template [" + TASK_RESULT_INDEX_MAPPING_FILE + "]", e).     } }
