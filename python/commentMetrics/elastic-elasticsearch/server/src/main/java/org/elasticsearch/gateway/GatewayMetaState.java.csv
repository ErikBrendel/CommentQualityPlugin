commented;modifiers;parameterAmount;loc;comment;code
false;public;2;10;;public PersistedState getPersistedState(Settings settings, ClusterApplierService clusterApplierService) {     applyClusterStateUpdaters().     if (DiscoveryNode.isMasterNode(settings) == false) {         // use Zen1 way of writing cluster state for non-master-eligible nodes         // this avoids concurrent manipulating of IndexMetadata with IndicesStore         clusterApplierService.addLowPriorityApplier(this).         return new InMemoryPersistedState(getCurrentTerm(), getLastAcceptedState()).     }     return this. }
false;private;1;13;;private void initializeClusterState(ClusterName clusterName) throws IOException {     long startNS = System.nanoTime().     Tuple<Manifest, MetaData> manifestAndMetaData = metaStateService.loadFullState().     previousManifest = manifestAndMetaData.v1().     final MetaData metaData = manifestAndMetaData.v2().     previousClusterState = ClusterState.builder(clusterName).version(previousManifest.getClusterStateVersion()).metaData(metaData).build().     logger.debug("took {} to load state", TimeValue.timeValueMillis(TimeValue.nsecToMSec(System.nanoTime() - startNS))). }
false;public;0;11;;public void applyClusterStateUpdaters() {     assert previousClusterState.nodes().getLocalNode() == null : "applyClusterStateUpdaters must only be called once".     assert transportService.getLocalNode() != null : "transport service is not yet started".     previousClusterState = Function.<ClusterState>identity().andThen(ClusterStateUpdaters::addStateNotRecoveredBlock).andThen(state -> ClusterStateUpdaters.setLocalNode(state, transportService.getLocalNode())).andThen(state -> ClusterStateUpdaters.upgradeAndArchiveUnknownOrInvalidSettings(state, clusterService.getClusterSettings())).andThen(ClusterStateUpdaters::recoverClusterBlocks).apply(previousClusterState). }
false;protected;2;42;;protected void upgradeMetaData(MetaDataIndexUpgradeService metaDataIndexUpgradeService, MetaDataUpgrader metaDataUpgrader) throws IOException {     if (isMasterOrDataNode()) {         try {             final Tuple<Manifest, MetaData> metaStateAndData = metaStateService.loadFullState().             final Manifest manifest = metaStateAndData.v1().             final MetaData metaData = metaStateAndData.v2().             // We finished global state validation and successfully checked all indices for backward compatibility             // and found no non-upgradable indices, which means the upgrade can continue.             // Now it's safe to overwrite global and index metadata.             // We don't re-write metadata if it's not upgraded by upgrade plugins, because             // if there is manifest file, it means metadata is properly persisted to all data paths             // if there is no manifest file (upgrade from 6.x to 7.x) metadata might be missing on some data paths,             // but anyway we will re-write it as soon as we receive first ClusterState             final AtomicClusterStateWriter writer = new AtomicClusterStateWriter(metaStateService, manifest).             final MetaData upgradedMetaData = upgradeMetaData(metaData, metaDataIndexUpgradeService, metaDataUpgrader).             final long globalStateGeneration.             if (MetaData.isGlobalStateEquals(metaData, upgradedMetaData) == false) {                 globalStateGeneration = writer.writeGlobalState("upgrade", upgradedMetaData).             } else {                 globalStateGeneration = manifest.getGlobalGeneration().             }             Map<Index, Long> indices = new HashMap<>(manifest.getIndexGenerations()).             for (IndexMetaData indexMetaData : upgradedMetaData) {                 if (metaData.hasIndexMetaData(indexMetaData) == false) {                     final long generation = writer.writeIndex("upgrade", indexMetaData).                     indices.put(indexMetaData.getIndex(), generation).                 }             }             final Manifest newManifest = new Manifest(manifest.getCurrentTerm(), manifest.getClusterStateVersion(), globalStateGeneration, indices).             writer.writeManifestAndCleanup("startup", newManifest).         } catch (Exception e) {             logger.error("failed to read or upgrade local state, exiting...", e).             throw e.         }     } }
false;protected;0;3;;protected boolean isMasterOrDataNode() {     return DiscoveryNode.isMasterNode(settings) || DiscoveryNode.isDataNode(settings). }
false;public;0;3;;public MetaData getMetaData() {     return previousClusterState.metaData(). }
false;public;1;25;;@Override public void applyClusterState(ClusterChangedEvent event) {     if (isMasterOrDataNode() == false) {         return.     }     if (event.state().blocks().disableStatePersistence()) {         incrementalWrite = false.         return.     }     try {         // TODO: can we get rid of this hack?         if (event.state().term() > getCurrentTerm()) {             innerSetCurrentTerm(event.state().term()).         }         updateClusterState(event.state(), event.previousState()).         incrementalWrite = true.     } catch (WriteStateException e) {         logger.warn("Exception occurred when storing new meta data", e).     } }
false;public;0;4;;@Override public long getCurrentTerm() {     return previousManifest.getCurrentTerm(). }
false;public;0;5;;@Override public ClusterState getLastAcceptedState() {     assert previousClusterState.nodes().getLocalNode() != null : "Cluster state is not fully built yet".     return previousClusterState. }
false;public;1;9;;@Override public void setCurrentTerm(long currentTerm) {     try {         innerSetCurrentTerm(currentTerm).     } catch (WriteStateException e) {         logger.error(new ParameterizedMessage("Failed to set current term to {}", currentTerm), e).         e.rethrowAsErrorOrUncheckedException().     } }
false;private;1;6;;private void innerSetCurrentTerm(long currentTerm) throws WriteStateException {     Manifest manifest = new Manifest(currentTerm, previousManifest.getClusterStateVersion(), previousManifest.getGlobalGeneration(), new HashMap<>(previousManifest.getIndexGenerations())).     metaStateService.writeManifestAndCleanup("current term changed", manifest).     previousManifest = manifest. }
false;public;1;10;;@Override public void setLastAcceptedState(ClusterState clusterState) {     try {         incrementalWrite = previousClusterState.term() == clusterState.term().         updateClusterState(clusterState, previousClusterState).     } catch (WriteStateException e) {         logger.error(new ParameterizedMessage("Failed to set last accepted state with version {}", clusterState.version()), e).         e.rethrowAsErrorOrUncheckedException().     } }
false;;2;12;;long writeGlobalState(String reason, MetaData metaData) throws WriteStateException {     assert finished == false : FINISHED_MSG.     try {         rollbackCleanupActions.add(() -> metaStateService.cleanupGlobalState(previousManifest.getGlobalGeneration())).         long generation = metaStateService.writeGlobalState(reason, metaData).         commitCleanupActions.add(() -> metaStateService.cleanupGlobalState(generation)).         return generation.     } catch (WriteStateException e) {         rollback().         throw e.     } }
false;;2;19;;long writeIndex(String reason, IndexMetaData metaData) throws WriteStateException {     assert finished == false : FINISHED_MSG.     try {         Index index = metaData.getIndex().         Long previousGeneration = previousManifest.getIndexGenerations().get(index).         if (previousGeneration != null) {             // we prefer not to clean-up index metadata in case of rollback,             // if it's not referenced by previous manifest file             // not to break dangling indices functionality             rollbackCleanupActions.add(() -> metaStateService.cleanupIndex(index, previousGeneration)).         }         long generation = metaStateService.writeIndex(reason, metaData).         commitCleanupActions.add(() -> metaStateService.cleanupIndex(index, generation)).         return generation.     } catch (WriteStateException e) {         rollback().         throw e.     } }
false;;2;12;;long writeManifestAndCleanup(String reason, Manifest manifest) throws WriteStateException {     assert finished == false : FINISHED_MSG.     try {         long generation = metaStateService.writeManifestAndCleanup(reason, manifest).         commitCleanupActions.forEach(Runnable::run).         finished = true.         return generation.     } catch (WriteStateException e) {         rollback().         throw e.     } }
false;;0;4;;void rollback() {     rollbackCleanupActions.forEach(Runnable::run).     finished = true. }
true;protected;2;13;/**  * Updates manifest and meta data on disk.  *  * @param newState new {@link ClusterState}  * @param previousState previous {@link ClusterState}  *  * @throws WriteStateException if exception occurs. See also {@link WriteStateException#isDirty()}.  */ ;/**  * Updates manifest and meta data on disk.  *  * @param newState new {@link ClusterState}  * @param previousState previous {@link ClusterState}  *  * @throws WriteStateException if exception occurs. See also {@link WriteStateException#isDirty()}.  */ protected void updateClusterState(ClusterState newState, ClusterState previousState) throws WriteStateException {     MetaData newMetaData = newState.metaData().     final AtomicClusterStateWriter writer = new AtomicClusterStateWriter(metaStateService, previousManifest).     long globalStateGeneration = writeGlobalState(writer, newMetaData).     Map<Index, Long> indexGenerations = writeIndicesMetadata(writer, newState, previousState).     Manifest manifest = new Manifest(previousManifest.getCurrentTerm(), newState.version(), globalStateGeneration, indexGenerations).     writeManifest(writer, manifest).     previousManifest = manifest.     previousClusterState = newState. }
false;private;2;5;;private void writeManifest(AtomicClusterStateWriter writer, Manifest manifest) throws WriteStateException {     if (manifest.equals(previousManifest) == false) {         writer.writeManifestAndCleanup("changed", manifest).     } }
false;private;3;18;;private Map<Index, Long> writeIndicesMetadata(AtomicClusterStateWriter writer, ClusterState newState, ClusterState previousState) throws WriteStateException {     Map<Index, Long> previouslyWrittenIndices = previousManifest.getIndexGenerations().     Set<Index> relevantIndices = getRelevantIndices(newState, previousState, previouslyWrittenIndices.keySet()).     Map<Index, Long> newIndices = new HashMap<>().     MetaData previousMetaData = incrementalWrite ? previousState.metaData() : null.     Iterable<IndexMetaDataAction> actions = resolveIndexMetaDataActions(previouslyWrittenIndices, relevantIndices, previousMetaData, newState.metaData()).     for (IndexMetaDataAction action : actions) {         long generation = action.execute(writer).         newIndices.put(action.getIndex(), generation).     }     return newIndices. }
false;private;2;7;;private long writeGlobalState(AtomicClusterStateWriter writer, MetaData newMetaData) throws WriteStateException {     if (incrementalWrite == false || MetaData.isGlobalStateEquals(previousClusterState.metaData(), newMetaData) == false) {         return writer.writeGlobalState("changed", newMetaData).     }     return previousManifest.getGlobalGeneration(). }
false;public,static;3;11;;public static Set<Index> getRelevantIndices(ClusterState state, ClusterState previousState, Set<Index> previouslyWrittenIndices) {     Set<Index> relevantIndices.     if (isDataOnlyNode(state)) {         relevantIndices = getRelevantIndicesOnDataOnlyNode(state, previousState, previouslyWrittenIndices).     } else if (state.nodes().getLocalNode().isMasterNode()) {         relevantIndices = getRelevantIndicesForMasterEligibleNode(state).     } else {         relevantIndices = Collections.emptySet().     }     return relevantIndices. }
false;private,static;1;3;;private static boolean isDataOnlyNode(ClusterState state) {     return ((state.nodes().getLocalNode().isMasterNode() == false) && state.nodes().getLocalNode().isDataNode()). }
true;static;3;24;/**  * Elasticsearch 2.0 removed several deprecated features and as well as support for Lucene 3.x. This method calls  * {@link MetaDataIndexUpgradeService} to makes sure that indices are compatible with the current version. The  * MetaDataIndexUpgradeService might also update obsolete settings if needed.  * Allows upgrading global custom meta data via {@link MetaDataUpgrader#customMetaDataUpgraders}  *  * @return input <code>metaData</code> if no upgrade is needed or an upgraded metaData  */ ;/**  * Elasticsearch 2.0 removed several deprecated features and as well as support for Lucene 3.x. This method calls  * {@link MetaDataIndexUpgradeService} to makes sure that indices are compatible with the current version. The  * MetaDataIndexUpgradeService might also update obsolete settings if needed.  * Allows upgrading global custom meta data via {@link MetaDataUpgrader#customMetaDataUpgraders}  *  * @return input <code>metaData</code> if no upgrade is needed or an upgraded metaData  */ static MetaData upgradeMetaData(MetaData metaData, MetaDataIndexUpgradeService metaDataIndexUpgradeService, MetaDataUpgrader metaDataUpgrader) {     // upgrade index meta data     boolean changed = false.     final MetaData.Builder upgradedMetaData = MetaData.builder(metaData).     for (IndexMetaData indexMetaData : metaData) {         IndexMetaData newMetaData = metaDataIndexUpgradeService.upgradeIndexMetaData(indexMetaData, Version.CURRENT.minimumIndexCompatibilityVersion()).         changed |= indexMetaData != newMetaData.         upgradedMetaData.put(newMetaData, false).     }     // upgrade global custom meta data     if (applyPluginUpgraders(metaData.getCustoms(), metaDataUpgrader.customMetaDataUpgraders, upgradedMetaData::removeCustom, upgradedMetaData::putCustom)) {         changed = true.     }     // upgrade current templates     if (applyPluginUpgraders(metaData.getTemplates(), metaDataUpgrader.indexTemplateMetaDataUpgraders, upgradedMetaData::removeTemplate, (s, indexTemplateMetaData) -> upgradedMetaData.put(indexTemplateMetaData))) {         changed = true.     }     return changed ? upgradedMetaData.build() : metaData. }
false;private,static;4;21;;private static <Data> boolean applyPluginUpgraders(ImmutableOpenMap<String, Data> existingData, UnaryOperator<Map<String, Data>> upgrader, Consumer<String> removeData, BiConsumer<String, Data> putData) {     // collect current data     Map<String, Data> existingMap = new HashMap<>().     for (ObjectObjectCursor<String, Data> customCursor : existingData) {         existingMap.put(customCursor.key, customCursor.value).     }     // upgrade global custom meta data     Map<String, Data> upgradedCustoms = upgrader.apply(existingMap).     if (upgradedCustoms.equals(existingMap) == false) {         // remove all data first so a plugin can remove custom metadata or templates if needed         existingMap.keySet().forEach(removeData).         for (Map.Entry<String, Data> upgradedCustomEntry : upgradedCustoms.entrySet()) {             putData.accept(upgradedCustomEntry.getKey(), upgradedCustomEntry.getValue()).         }         return true.     }     return false. }
true;public,static;4;19;/**  * Returns list of {@link IndexMetaDataAction} for each relevant index.  * For each relevant index there are 3 options:  * <ol>  * <li>  * {@link KeepPreviousGeneration} - index metadata is already stored to disk and index metadata version is not changed, no  * action is required.  * </li>  * <li>  * {@link WriteNewIndexMetaData} - there is no index metadata on disk and index metadata for this index should be written.  * </li>  * <li>  * {@link WriteChangedIndexMetaData} - index metadata is already on disk, but index metadata version has changed. Updated  * index metadata should be written to disk.  * </li>  * </ol>  *  * @param previouslyWrittenIndices A list of indices for which the state was already written before  * @param relevantIndices          The list of indices for which state should potentially be written  * @param previousMetaData         The last meta data we know of  * @param newMetaData              The new metadata  * @return list of {@link IndexMetaDataAction} for each relevant index.  */ ;/**  * Returns list of {@link IndexMetaDataAction} for each relevant index.  * For each relevant index there are 3 options:  * <ol>  * <li>  * {@link KeepPreviousGeneration} - index metadata is already stored to disk and index metadata version is not changed, no  * action is required.  * </li>  * <li>  * {@link WriteNewIndexMetaData} - there is no index metadata on disk and index metadata for this index should be written.  * </li>  * <li>  * {@link WriteChangedIndexMetaData} - index metadata is already on disk, but index metadata version has changed. Updated  * index metadata should be written to disk.  * </li>  * </ol>  *  * @param previouslyWrittenIndices A list of indices for which the state was already written before  * @param relevantIndices          The list of indices for which state should potentially be written  * @param previousMetaData         The last meta data we know of  * @param newMetaData              The new metadata  * @return list of {@link IndexMetaDataAction} for each relevant index.  */ public static List<IndexMetaDataAction> resolveIndexMetaDataActions(Map<Index, Long> previouslyWrittenIndices, Set<Index> relevantIndices, MetaData previousMetaData, MetaData newMetaData) {     List<IndexMetaDataAction> actions = new ArrayList<>().     for (Index index : relevantIndices) {         IndexMetaData newIndexMetaData = newMetaData.getIndexSafe(index).         IndexMetaData previousIndexMetaData = previousMetaData == null ? null : previousMetaData.index(index).         if (previouslyWrittenIndices.containsKey(index) == false || previousIndexMetaData == null) {             actions.add(new WriteNewIndexMetaData(newIndexMetaData)).         } else if (previousIndexMetaData.getVersion() != newIndexMetaData.getVersion()) {             actions.add(new WriteChangedIndexMetaData(previousIndexMetaData, newIndexMetaData)).         } else {             actions.add(new KeepPreviousGeneration(index, previouslyWrittenIndices.get(index))).         }     }     return actions. }
false;private,static;3;26;;private static Set<Index> getRelevantIndicesOnDataOnlyNode(ClusterState state, ClusterState previousState, Set<Index> previouslyWrittenIndices) {     RoutingNode newRoutingNode = state.getRoutingNodes().node(state.nodes().getLocalNodeId()).     if (newRoutingNode == null) {         throw new IllegalStateException("cluster state does not contain this node - cannot write index meta state").     }     Set<Index> indices = new HashSet<>().     for (ShardRouting routing : newRoutingNode) {         indices.add(routing.index()).     }     // we have it written on disk previously     for (IndexMetaData indexMetaData : state.metaData()) {         boolean isOrWasClosed = indexMetaData.getState().equals(IndexMetaData.State.CLOSE).         // if the index is open we might still have to write the state if it just transitioned from closed to open         // so we have to check for that as well.         IndexMetaData previousMetaData = previousState.metaData().index(indexMetaData.getIndex()).         if (previousMetaData != null) {             isOrWasClosed = isOrWasClosed || previousMetaData.getState().equals(IndexMetaData.State.CLOSE).         }         if (previouslyWrittenIndices.contains(indexMetaData.getIndex()) && isOrWasClosed) {             indices.add(indexMetaData.getIndex()).         }     }     return indices. }
false;private,static;1;9;;private static Set<Index> getRelevantIndicesForMasterEligibleNode(ClusterState state) {     Set<Index> relevantIndices.     relevantIndices = new HashSet<>().     // we have to iterate over the metadata to make sure we also capture closed indices     for (IndexMetaData indexMetaData : state.metaData()) {         relevantIndices.add(indexMetaData.getIndex()).     }     return relevantIndices. }
true;;0;1;/**  * @return index for index metadata.  */ ;/**  * @return index for index metadata.  */ Index getIndex().
true;;1;1;/**  * Executes this action using provided {@link AtomicClusterStateWriter}.  *  * @return new index metadata state generation, to be used in manifest file.  * @throws WriteStateException if exception occurs.  */ ;/**  * Executes this action using provided {@link AtomicClusterStateWriter}.  *  * @return new index metadata state generation, to be used in manifest file.  * @throws WriteStateException if exception occurs.  */ long execute(AtomicClusterStateWriter writer) throws WriteStateException.
false;public;0;4;;@Override public Index getIndex() {     return index. }
false;public;1;4;;@Override public long execute(AtomicClusterStateWriter writer) {     return generation. }
false;public;0;4;;@Override public Index getIndex() {     return indexMetaData.getIndex(). }
false;public;1;4;;@Override public long execute(AtomicClusterStateWriter writer) throws WriteStateException {     return writer.writeIndex("freshly created", indexMetaData). }
false;public;0;4;;@Override public Index getIndex() {     return newIndexMetaData.getIndex(). }
false;public;1;6;;@Override public long execute(AtomicClusterStateWriter writer) throws WriteStateException {     return writer.writeIndex("version changed from [" + oldIndexMetaData.getVersion() + "] to [" + newIndexMetaData.getVersion() + "]", newIndexMetaData). }
