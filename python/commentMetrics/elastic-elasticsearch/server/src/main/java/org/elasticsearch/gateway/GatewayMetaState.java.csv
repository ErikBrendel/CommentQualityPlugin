# id;timestamp;commentText;codeText;commentWords;codeWords
GatewayMetaState -> private void ensureNoPre019State() throws IOException;1524684173;Throws an IAE if a pre 0.19 state is detected;private void ensureNoPre019State() throws IOException {_        for (Path dataLocation : nodeEnv.nodeDataPaths()) {_            final Path stateLocation = dataLocation.resolve(MetaDataStateFormat.STATE_DIR_NAME)__            if (!Files.exists(stateLocation)) {_                continue__            }_            try (DirectoryStream<Path> stream = Files.newDirectoryStream(stateLocation)) {_                for (Path stateFile : stream) {_                    if (logger.isTraceEnabled()) {_                        logger.trace("[upgrade]: processing [{}]", stateFile.getFileName())__                    }_                    final String name = stateFile.getFileName().toString()__                    if (name.startsWith("metadata-")) {_                        throw new IllegalStateException("Detected pre 0.19 metadata file please upgrade to a version before "_                            + Version.CURRENT.minimumIndexCompatibilityVersion()_                            + " first to upgrade state structures - metadata found: [" + stateFile.getParent().toAbsolutePath())__                    }_                }_            }_        }_    };throws,an,iae,if,a,pre,0,19,state,is,detected;private,void,ensure,no,pre019state,throws,ioexception,for,path,data,location,node,env,node,data,paths,final,path,state,location,data,location,resolve,meta,data,state,format,if,files,exists,state,location,continue,try,directory,stream,path,stream,files,new,directory,stream,state,location,for,path,state,file,stream,if,logger,is,trace,enabled,logger,trace,upgrade,processing,state,file,get,file,name,final,string,name,state,file,get,file,name,to,string,if,name,starts,with,metadata,throw,new,illegal,state,exception,detected,pre,0,19,metadata,file,please,upgrade,to,a,version,before,version,current,minimum,index,compatibility,version,first,to,upgrade,state,structures,metadata,found,state,file,get,parent,to,absolute,path
GatewayMetaState -> private void ensureNoPre019State() throws IOException;1536314350;Throws an IAE if a pre 0.19 state is detected;private void ensureNoPre019State() throws IOException {_        for (Path dataLocation : nodeEnv.nodeDataPaths()) {_            final Path stateLocation = dataLocation.resolve(MetaDataStateFormat.STATE_DIR_NAME)__            if (!Files.exists(stateLocation)) {_                continue__            }_            try (DirectoryStream<Path> stream = Files.newDirectoryStream(stateLocation)) {_                for (Path stateFile : stream) {_                    if (logger.isTraceEnabled()) {_                        logger.trace("[upgrade]: processing [{}]", stateFile.getFileName())__                    }_                    final String name = stateFile.getFileName().toString()__                    if (name.startsWith("metadata-")) {_                        throw new IllegalStateException("Detected pre 0.19 metadata file please upgrade to a version before "_                            + Version.CURRENT.minimumIndexCompatibilityVersion()_                            + " first to upgrade state structures - metadata found: [" + stateFile.getParent().toAbsolutePath())__                    }_                }_            }_        }_    };throws,an,iae,if,a,pre,0,19,state,is,detected;private,void,ensure,no,pre019state,throws,ioexception,for,path,data,location,node,env,node,data,paths,final,path,state,location,data,location,resolve,meta,data,state,format,if,files,exists,state,location,continue,try,directory,stream,path,stream,files,new,directory,stream,state,location,for,path,state,file,stream,if,logger,is,trace,enabled,logger,trace,upgrade,processing,state,file,get,file,name,final,string,name,state,file,get,file,name,to,string,if,name,starts,with,metadata,throw,new,illegal,state,exception,detected,pre,0,19,metadata,file,please,upgrade,to,a,version,before,version,current,minimum,index,compatibility,version,first,to,upgrade,state,structures,metadata,found,state,file,get,parent,to,absolute,path
GatewayMetaState -> private void ensureNoPre019State() throws IOException;1540847035;Throws an IAE if a pre 0.19 state is detected;private void ensureNoPre019State() throws IOException {_        for (Path dataLocation : nodeEnv.nodeDataPaths()) {_            final Path stateLocation = dataLocation.resolve(MetaDataStateFormat.STATE_DIR_NAME)__            if (!Files.exists(stateLocation)) {_                continue__            }_            try (DirectoryStream<Path> stream = Files.newDirectoryStream(stateLocation)) {_                for (Path stateFile : stream) {_                    if (logger.isTraceEnabled()) {_                        logger.trace("[upgrade]: processing [{}]", stateFile.getFileName())__                    }_                    final String name = stateFile.getFileName().toString()__                    if (name.startsWith("metadata-")) {_                        throw new IllegalStateException("Detected pre 0.19 metadata file please upgrade to a version before "_                            + Version.CURRENT.minimumIndexCompatibilityVersion()_                            + " first to upgrade state structures - metadata found: [" + stateFile.getParent().toAbsolutePath())__                    }_                }_            }_        }_    };throws,an,iae,if,a,pre,0,19,state,is,detected;private,void,ensure,no,pre019state,throws,ioexception,for,path,data,location,node,env,node,data,paths,final,path,state,location,data,location,resolve,meta,data,state,format,if,files,exists,state,location,continue,try,directory,stream,path,stream,files,new,directory,stream,state,location,for,path,state,file,stream,if,logger,is,trace,enabled,logger,trace,upgrade,processing,state,file,get,file,name,final,string,name,state,file,get,file,name,to,string,if,name,starts,with,metadata,throw,new,illegal,state,exception,detected,pre,0,19,metadata,file,please,upgrade,to,a,version,before,version,current,minimum,index,compatibility,version,first,to,upgrade,state,structures,metadata,found,state,file,get,parent,to,absolute,path
GatewayMetaState -> private void ensureNoPre019State() throws IOException;1541092382;Throws an IAE if a pre 0.19 state is detected;private void ensureNoPre019State() throws IOException {_        for (Path dataLocation : nodeEnv.nodeDataPaths()) {_            final Path stateLocation = dataLocation.resolve(MetaDataStateFormat.STATE_DIR_NAME)__            if (!Files.exists(stateLocation)) {_                continue__            }_            try (DirectoryStream<Path> stream = Files.newDirectoryStream(stateLocation)) {_                for (Path stateFile : stream) {_                    if (logger.isTraceEnabled()) {_                        logger.trace("[upgrade]: processing [{}]", stateFile.getFileName())__                    }_                    final String name = stateFile.getFileName().toString()__                    if (name.startsWith("metadata-")) {_                        throw new IllegalStateException("Detected pre 0.19 metadata file please upgrade to a version before "_                            + Version.CURRENT.minimumIndexCompatibilityVersion()_                            + " first to upgrade state structures - metadata found: [" + stateFile.getParent().toAbsolutePath())__                    }_                }_            }_        }_    };throws,an,iae,if,a,pre,0,19,state,is,detected;private,void,ensure,no,pre019state,throws,ioexception,for,path,data,location,node,env,node,data,paths,final,path,state,location,data,location,resolve,meta,data,state,format,if,files,exists,state,location,continue,try,directory,stream,path,stream,files,new,directory,stream,state,location,for,path,state,file,stream,if,logger,is,trace,enabled,logger,trace,upgrade,processing,state,file,get,file,name,final,string,name,state,file,get,file,name,to,string,if,name,starts,with,metadata,throw,new,illegal,state,exception,detected,pre,0,19,metadata,file,please,upgrade,to,a,version,before,version,current,minimum,index,compatibility,version,first,to,upgrade,state,structures,metadata,found,state,file,get,parent,to,absolute,path
GatewayMetaState -> private void ensureNoPre019State() throws IOException;1542402632;Throws an IAE if a pre 0.19 state is detected;private void ensureNoPre019State() throws IOException {_        for (Path dataLocation : nodeEnv.nodeDataPaths()) {_            final Path stateLocation = dataLocation.resolve(MetaDataStateFormat.STATE_DIR_NAME)__            if (!Files.exists(stateLocation)) {_                continue__            }_            try (DirectoryStream<Path> stream = Files.newDirectoryStream(stateLocation)) {_                for (Path stateFile : stream) {_                    if (logger.isTraceEnabled()) {_                        logger.trace("[upgrade]: processing [{}]", stateFile.getFileName())__                    }_                    final String name = stateFile.getFileName().toString()__                    if (name.startsWith("metadata-")) {_                        throw new IllegalStateException("Detected pre 0.19 metadata file please upgrade to a version before "_                            + Version.CURRENT.minimumIndexCompatibilityVersion()_                            + " first to upgrade state structures - metadata found: [" + stateFile.getParent().toAbsolutePath())__                    }_                }_            }_        }_    };throws,an,iae,if,a,pre,0,19,state,is,detected;private,void,ensure,no,pre019state,throws,ioexception,for,path,data,location,node,env,node,data,paths,final,path,state,location,data,location,resolve,meta,data,state,format,if,files,exists,state,location,continue,try,directory,stream,path,stream,files,new,directory,stream,state,location,for,path,state,file,stream,if,logger,is,trace,enabled,logger,trace,upgrade,processing,state,file,get,file,name,final,string,name,state,file,get,file,name,to,string,if,name,starts,with,metadata,throw,new,illegal,state,exception,detected,pre,0,19,metadata,file,please,upgrade,to,a,version,before,version,current,minimum,index,compatibility,version,first,to,upgrade,state,structures,metadata,found,state,file,get,parent,to,absolute,path
GatewayMetaState -> static MetaData upgradeMetaData(MetaData metaData,                                     MetaDataIndexUpgradeService metaDataIndexUpgradeService,                                     MetaDataUpgrader metaDataUpgrader) throws IOException;1524684173;Elasticsearch 2.0 removed several deprecated features and as well as support for Lucene 3.x. This method calls_{@link MetaDataIndexUpgradeService} to makes sure that indices are compatible with the current version. The_MetaDataIndexUpgradeService might also update obsolete settings if needed._Allows upgrading global custom meta data via {@link MetaDataUpgrader#customMetaDataUpgraders}__@return input <code>metaData</code> if no upgrade is needed or an upgraded metaData;static MetaData upgradeMetaData(MetaData metaData,_                                    MetaDataIndexUpgradeService metaDataIndexUpgradeService,_                                    MetaDataUpgrader metaDataUpgrader) throws IOException {_        _        boolean changed = false__        final MetaData.Builder upgradedMetaData = MetaData.builder(metaData)__        for (IndexMetaData indexMetaData : metaData) {_            IndexMetaData newMetaData = metaDataIndexUpgradeService.upgradeIndexMetaData(indexMetaData,_                Version.CURRENT.minimumIndexCompatibilityVersion())__            changed |= indexMetaData != newMetaData__            upgradedMetaData.put(newMetaData, false)__        }_        _        if (applyPluginUpgraders(metaData.getCustoms(), metaDataUpgrader.customMetaDataUpgraders,_            upgradedMetaData::removeCustom,upgradedMetaData::putCustom)) {_            changed = true__        }_        _        if (applyPluginUpgraders(metaData.getTemplates(), metaDataUpgrader.indexTemplateMetaDataUpgraders,_            upgradedMetaData::removeTemplate, (s, indexTemplateMetaData) -> upgradedMetaData.put(indexTemplateMetaData))) {_            changed = true__        }_        return changed ? upgradedMetaData.build() : metaData__    };elasticsearch,2,0,removed,several,deprecated,features,and,as,well,as,support,for,lucene,3,x,this,method,calls,link,meta,data,index,upgrade,service,to,makes,sure,that,indices,are,compatible,with,the,current,version,the,meta,data,index,upgrade,service,might,also,update,obsolete,settings,if,needed,allows,upgrading,global,custom,meta,data,via,link,meta,data,upgrader,custom,meta,data,upgraders,return,input,code,meta,data,code,if,no,upgrade,is,needed,or,an,upgraded,meta,data;static,meta,data,upgrade,meta,data,meta,data,meta,data,meta,data,index,upgrade,service,meta,data,index,upgrade,service,meta,data,upgrader,meta,data,upgrader,throws,ioexception,boolean,changed,false,final,meta,data,builder,upgraded,meta,data,meta,data,builder,meta,data,for,index,meta,data,index,meta,data,meta,data,index,meta,data,new,meta,data,meta,data,index,upgrade,service,upgrade,index,meta,data,index,meta,data,version,current,minimum,index,compatibility,version,changed,index,meta,data,new,meta,data,upgraded,meta,data,put,new,meta,data,false,if,apply,plugin,upgraders,meta,data,get,customs,meta,data,upgrader,custom,meta,data,upgraders,upgraded,meta,data,remove,custom,upgraded,meta,data,put,custom,changed,true,if,apply,plugin,upgraders,meta,data,get,templates,meta,data,upgrader,index,template,meta,data,upgraders,upgraded,meta,data,remove,template,s,index,template,meta,data,upgraded,meta,data,put,index,template,meta,data,changed,true,return,changed,upgraded,meta,data,build,meta,data
GatewayMetaState -> static MetaData upgradeMetaData(MetaData metaData,                                     MetaDataIndexUpgradeService metaDataIndexUpgradeService,                                     MetaDataUpgrader metaDataUpgrader) throws IOException;1536314350;Elasticsearch 2.0 removed several deprecated features and as well as support for Lucene 3.x. This method calls_{@link MetaDataIndexUpgradeService} to makes sure that indices are compatible with the current version. The_MetaDataIndexUpgradeService might also update obsolete settings if needed._Allows upgrading global custom meta data via {@link MetaDataUpgrader#customMetaDataUpgraders}__@return input <code>metaData</code> if no upgrade is needed or an upgraded metaData;static MetaData upgradeMetaData(MetaData metaData,_                                    MetaDataIndexUpgradeService metaDataIndexUpgradeService,_                                    MetaDataUpgrader metaDataUpgrader) throws IOException {_        _        boolean changed = false__        final MetaData.Builder upgradedMetaData = MetaData.builder(metaData)__        for (IndexMetaData indexMetaData : metaData) {_            IndexMetaData newMetaData = metaDataIndexUpgradeService.upgradeIndexMetaData(indexMetaData,_                Version.CURRENT.minimumIndexCompatibilityVersion())__            changed |= indexMetaData != newMetaData__            upgradedMetaData.put(newMetaData, false)__        }_        _        if (applyPluginUpgraders(metaData.getCustoms(), metaDataUpgrader.customMetaDataUpgraders,_            upgradedMetaData::removeCustom,upgradedMetaData::putCustom)) {_            changed = true__        }_        _        if (applyPluginUpgraders(metaData.getTemplates(), metaDataUpgrader.indexTemplateMetaDataUpgraders,_            upgradedMetaData::removeTemplate, (s, indexTemplateMetaData) -> upgradedMetaData.put(indexTemplateMetaData))) {_            changed = true__        }_        return changed ? upgradedMetaData.build() : metaData__    };elasticsearch,2,0,removed,several,deprecated,features,and,as,well,as,support,for,lucene,3,x,this,method,calls,link,meta,data,index,upgrade,service,to,makes,sure,that,indices,are,compatible,with,the,current,version,the,meta,data,index,upgrade,service,might,also,update,obsolete,settings,if,needed,allows,upgrading,global,custom,meta,data,via,link,meta,data,upgrader,custom,meta,data,upgraders,return,input,code,meta,data,code,if,no,upgrade,is,needed,or,an,upgraded,meta,data;static,meta,data,upgrade,meta,data,meta,data,meta,data,meta,data,index,upgrade,service,meta,data,index,upgrade,service,meta,data,upgrader,meta,data,upgrader,throws,ioexception,boolean,changed,false,final,meta,data,builder,upgraded,meta,data,meta,data,builder,meta,data,for,index,meta,data,index,meta,data,meta,data,index,meta,data,new,meta,data,meta,data,index,upgrade,service,upgrade,index,meta,data,index,meta,data,version,current,minimum,index,compatibility,version,changed,index,meta,data,new,meta,data,upgraded,meta,data,put,new,meta,data,false,if,apply,plugin,upgraders,meta,data,get,customs,meta,data,upgrader,custom,meta,data,upgraders,upgraded,meta,data,remove,custom,upgraded,meta,data,put,custom,changed,true,if,apply,plugin,upgraders,meta,data,get,templates,meta,data,upgrader,index,template,meta,data,upgraders,upgraded,meta,data,remove,template,s,index,template,meta,data,upgraded,meta,data,put,index,template,meta,data,changed,true,return,changed,upgraded,meta,data,build,meta,data
GatewayMetaState -> static MetaData upgradeMetaData(MetaData metaData,                                     MetaDataIndexUpgradeService metaDataIndexUpgradeService,                                     MetaDataUpgrader metaDataUpgrader) throws IOException;1540847035;Elasticsearch 2.0 removed several deprecated features and as well as support for Lucene 3.x. This method calls_{@link MetaDataIndexUpgradeService} to makes sure that indices are compatible with the current version. The_MetaDataIndexUpgradeService might also update obsolete settings if needed._Allows upgrading global custom meta data via {@link MetaDataUpgrader#customMetaDataUpgraders}__@return input <code>metaData</code> if no upgrade is needed or an upgraded metaData;static MetaData upgradeMetaData(MetaData metaData,_                                    MetaDataIndexUpgradeService metaDataIndexUpgradeService,_                                    MetaDataUpgrader metaDataUpgrader) throws IOException {_        _        boolean changed = false__        final MetaData.Builder upgradedMetaData = MetaData.builder(metaData)__        for (IndexMetaData indexMetaData : metaData) {_            IndexMetaData newMetaData = metaDataIndexUpgradeService.upgradeIndexMetaData(indexMetaData,_                Version.CURRENT.minimumIndexCompatibilityVersion())__            changed |= indexMetaData != newMetaData__            upgradedMetaData.put(newMetaData, false)__        }_        _        if (applyPluginUpgraders(metaData.getCustoms(), metaDataUpgrader.customMetaDataUpgraders,_            upgradedMetaData::removeCustom,upgradedMetaData::putCustom)) {_            changed = true__        }_        _        if (applyPluginUpgraders(metaData.getTemplates(), metaDataUpgrader.indexTemplateMetaDataUpgraders,_            upgradedMetaData::removeTemplate, (s, indexTemplateMetaData) -> upgradedMetaData.put(indexTemplateMetaData))) {_            changed = true__        }_        return changed ? upgradedMetaData.build() : metaData__    };elasticsearch,2,0,removed,several,deprecated,features,and,as,well,as,support,for,lucene,3,x,this,method,calls,link,meta,data,index,upgrade,service,to,makes,sure,that,indices,are,compatible,with,the,current,version,the,meta,data,index,upgrade,service,might,also,update,obsolete,settings,if,needed,allows,upgrading,global,custom,meta,data,via,link,meta,data,upgrader,custom,meta,data,upgraders,return,input,code,meta,data,code,if,no,upgrade,is,needed,or,an,upgraded,meta,data;static,meta,data,upgrade,meta,data,meta,data,meta,data,meta,data,index,upgrade,service,meta,data,index,upgrade,service,meta,data,upgrader,meta,data,upgrader,throws,ioexception,boolean,changed,false,final,meta,data,builder,upgraded,meta,data,meta,data,builder,meta,data,for,index,meta,data,index,meta,data,meta,data,index,meta,data,new,meta,data,meta,data,index,upgrade,service,upgrade,index,meta,data,index,meta,data,version,current,minimum,index,compatibility,version,changed,index,meta,data,new,meta,data,upgraded,meta,data,put,new,meta,data,false,if,apply,plugin,upgraders,meta,data,get,customs,meta,data,upgrader,custom,meta,data,upgraders,upgraded,meta,data,remove,custom,upgraded,meta,data,put,custom,changed,true,if,apply,plugin,upgraders,meta,data,get,templates,meta,data,upgrader,index,template,meta,data,upgraders,upgraded,meta,data,remove,template,s,index,template,meta,data,upgraded,meta,data,put,index,template,meta,data,changed,true,return,changed,upgraded,meta,data,build,meta,data
GatewayMetaState -> static MetaData upgradeMetaData(MetaData metaData,                                     MetaDataIndexUpgradeService metaDataIndexUpgradeService,                                     MetaDataUpgrader metaDataUpgrader) throws IOException;1541092382;Elasticsearch 2.0 removed several deprecated features and as well as support for Lucene 3.x. This method calls_{@link MetaDataIndexUpgradeService} to makes sure that indices are compatible with the current version. The_MetaDataIndexUpgradeService might also update obsolete settings if needed._Allows upgrading global custom meta data via {@link MetaDataUpgrader#customMetaDataUpgraders}__@return input <code>metaData</code> if no upgrade is needed or an upgraded metaData;static MetaData upgradeMetaData(MetaData metaData,_                                    MetaDataIndexUpgradeService metaDataIndexUpgradeService,_                                    MetaDataUpgrader metaDataUpgrader) throws IOException {_        _        boolean changed = false__        final MetaData.Builder upgradedMetaData = MetaData.builder(metaData)__        for (IndexMetaData indexMetaData : metaData) {_            IndexMetaData newMetaData = metaDataIndexUpgradeService.upgradeIndexMetaData(indexMetaData,_                Version.CURRENT.minimumIndexCompatibilityVersion())__            changed |= indexMetaData != newMetaData__            upgradedMetaData.put(newMetaData, false)__        }_        _        if (applyPluginUpgraders(metaData.getCustoms(), metaDataUpgrader.customMetaDataUpgraders,_            upgradedMetaData::removeCustom,upgradedMetaData::putCustom)) {_            changed = true__        }_        _        if (applyPluginUpgraders(metaData.getTemplates(), metaDataUpgrader.indexTemplateMetaDataUpgraders,_            upgradedMetaData::removeTemplate, (s, indexTemplateMetaData) -> upgradedMetaData.put(indexTemplateMetaData))) {_            changed = true__        }_        return changed ? upgradedMetaData.build() : metaData__    };elasticsearch,2,0,removed,several,deprecated,features,and,as,well,as,support,for,lucene,3,x,this,method,calls,link,meta,data,index,upgrade,service,to,makes,sure,that,indices,are,compatible,with,the,current,version,the,meta,data,index,upgrade,service,might,also,update,obsolete,settings,if,needed,allows,upgrading,global,custom,meta,data,via,link,meta,data,upgrader,custom,meta,data,upgraders,return,input,code,meta,data,code,if,no,upgrade,is,needed,or,an,upgraded,meta,data;static,meta,data,upgrade,meta,data,meta,data,meta,data,meta,data,index,upgrade,service,meta,data,index,upgrade,service,meta,data,upgrader,meta,data,upgrader,throws,ioexception,boolean,changed,false,final,meta,data,builder,upgraded,meta,data,meta,data,builder,meta,data,for,index,meta,data,index,meta,data,meta,data,index,meta,data,new,meta,data,meta,data,index,upgrade,service,upgrade,index,meta,data,index,meta,data,version,current,minimum,index,compatibility,version,changed,index,meta,data,new,meta,data,upgraded,meta,data,put,new,meta,data,false,if,apply,plugin,upgraders,meta,data,get,customs,meta,data,upgrader,custom,meta,data,upgraders,upgraded,meta,data,remove,custom,upgraded,meta,data,put,custom,changed,true,if,apply,plugin,upgraders,meta,data,get,templates,meta,data,upgrader,index,template,meta,data,upgraders,upgraded,meta,data,remove,template,s,index,template,meta,data,upgraded,meta,data,put,index,template,meta,data,changed,true,return,changed,upgraded,meta,data,build,meta,data
GatewayMetaState -> static MetaData upgradeMetaData(MetaData metaData,                                     MetaDataIndexUpgradeService metaDataIndexUpgradeService,                                     MetaDataUpgrader metaDataUpgrader) throws IOException;1542402632;Elasticsearch 2.0 removed several deprecated features and as well as support for Lucene 3.x. This method calls_{@link MetaDataIndexUpgradeService} to makes sure that indices are compatible with the current version. The_MetaDataIndexUpgradeService might also update obsolete settings if needed._Allows upgrading global custom meta data via {@link MetaDataUpgrader#customMetaDataUpgraders}__@return input <code>metaData</code> if no upgrade is needed or an upgraded metaData;static MetaData upgradeMetaData(MetaData metaData,_                                    MetaDataIndexUpgradeService metaDataIndexUpgradeService,_                                    MetaDataUpgrader metaDataUpgrader) throws IOException {_        _        boolean changed = false__        final MetaData.Builder upgradedMetaData = MetaData.builder(metaData)__        for (IndexMetaData indexMetaData : metaData) {_            IndexMetaData newMetaData = metaDataIndexUpgradeService.upgradeIndexMetaData(indexMetaData,_                Version.CURRENT.minimumIndexCompatibilityVersion())__            changed |= indexMetaData != newMetaData__            upgradedMetaData.put(newMetaData, false)__        }_        _        if (applyPluginUpgraders(metaData.getCustoms(), metaDataUpgrader.customMetaDataUpgraders,_            upgradedMetaData::removeCustom,upgradedMetaData::putCustom)) {_            changed = true__        }_        _        if (applyPluginUpgraders(metaData.getTemplates(), metaDataUpgrader.indexTemplateMetaDataUpgraders,_            upgradedMetaData::removeTemplate, (s, indexTemplateMetaData) -> upgradedMetaData.put(indexTemplateMetaData))) {_            changed = true__        }_        return changed ? upgradedMetaData.build() : metaData__    };elasticsearch,2,0,removed,several,deprecated,features,and,as,well,as,support,for,lucene,3,x,this,method,calls,link,meta,data,index,upgrade,service,to,makes,sure,that,indices,are,compatible,with,the,current,version,the,meta,data,index,upgrade,service,might,also,update,obsolete,settings,if,needed,allows,upgrading,global,custom,meta,data,via,link,meta,data,upgrader,custom,meta,data,upgraders,return,input,code,meta,data,code,if,no,upgrade,is,needed,or,an,upgraded,meta,data;static,meta,data,upgrade,meta,data,meta,data,meta,data,meta,data,index,upgrade,service,meta,data,index,upgrade,service,meta,data,upgrader,meta,data,upgrader,throws,ioexception,boolean,changed,false,final,meta,data,builder,upgraded,meta,data,meta,data,builder,meta,data,for,index,meta,data,index,meta,data,meta,data,index,meta,data,new,meta,data,meta,data,index,upgrade,service,upgrade,index,meta,data,index,meta,data,version,current,minimum,index,compatibility,version,changed,index,meta,data,new,meta,data,upgraded,meta,data,put,new,meta,data,false,if,apply,plugin,upgraders,meta,data,get,customs,meta,data,upgrader,custom,meta,data,upgraders,upgraded,meta,data,remove,custom,upgraded,meta,data,put,custom,changed,true,if,apply,plugin,upgraders,meta,data,get,templates,meta,data,upgrader,index,template,meta,data,upgraders,upgraded,meta,data,remove,template,s,index,template,meta,data,upgraded,meta,data,put,index,template,meta,data,changed,true,return,changed,upgraded,meta,data,build,meta,data
GatewayMetaState -> private void ensureNoPre019MetadataFiles() throws IOException;1544081506;Throws an IAE if a pre 0.19 state is detected;private void ensureNoPre019MetadataFiles() throws IOException {_        for (Path dataLocation : nodeEnv.nodeDataPaths()) {_            final Path stateLocation = dataLocation.resolve(MetaDataStateFormat.STATE_DIR_NAME)__            if (!Files.exists(stateLocation)) {_                continue__            }_            try (DirectoryStream<Path> stream = Files.newDirectoryStream(stateLocation)) {_                for (Path stateFile : stream) {_                    if (logger.isTraceEnabled()) {_                        logger.trace("[upgrade]: processing [{}]", stateFile.getFileName())__                    }_                    final String name = stateFile.getFileName().toString()__                    if (name.startsWith("metadata-")) {_                        throw new IllegalStateException("Detected pre 0.19 metadata file please upgrade to a version before "_                                + Version.CURRENT.minimumIndexCompatibilityVersion()_                                + " first to upgrade state structures - metadata found: [" + stateFile.getParent().toAbsolutePath())__                    }_                }_            }_        }_    };throws,an,iae,if,a,pre,0,19,state,is,detected;private,void,ensure,no,pre019metadata,files,throws,ioexception,for,path,data,location,node,env,node,data,paths,final,path,state,location,data,location,resolve,meta,data,state,format,if,files,exists,state,location,continue,try,directory,stream,path,stream,files,new,directory,stream,state,location,for,path,state,file,stream,if,logger,is,trace,enabled,logger,trace,upgrade,processing,state,file,get,file,name,final,string,name,state,file,get,file,name,to,string,if,name,starts,with,metadata,throw,new,illegal,state,exception,detected,pre,0,19,metadata,file,please,upgrade,to,a,version,before,version,current,minimum,index,compatibility,version,first,to,upgrade,state,structures,metadata,found,state,file,get,parent,to,absolute,path
GatewayMetaState -> private void ensureNoPre019MetadataFiles() throws IOException;1544112122;Throws an IAE if a pre 0.19 state is detected;private void ensureNoPre019MetadataFiles() throws IOException {_        for (Path dataLocation : nodeEnv.nodeDataPaths()) {_            final Path stateLocation = dataLocation.resolve(MetaDataStateFormat.STATE_DIR_NAME)__            if (!Files.exists(stateLocation)) {_                continue__            }_            try (DirectoryStream<Path> stream = Files.newDirectoryStream(stateLocation)) {_                for (Path stateFile : stream) {_                    if (logger.isTraceEnabled()) {_                        logger.trace("[upgrade]: processing [{}]", stateFile.getFileName())__                    }_                    final String name = stateFile.getFileName().toString()__                    if (name.startsWith("metadata-")) {_                        throw new IllegalStateException("Detected pre 0.19 metadata file please upgrade to a version before "_                                + Version.CURRENT.minimumIndexCompatibilityVersion()_                                + " first to upgrade state structures - metadata found: [" + stateFile.getParent().toAbsolutePath())__                    }_                }_            }_        }_    };throws,an,iae,if,a,pre,0,19,state,is,detected;private,void,ensure,no,pre019metadata,files,throws,ioexception,for,path,data,location,node,env,node,data,paths,final,path,state,location,data,location,resolve,meta,data,state,format,if,files,exists,state,location,continue,try,directory,stream,path,stream,files,new,directory,stream,state,location,for,path,state,file,stream,if,logger,is,trace,enabled,logger,trace,upgrade,processing,state,file,get,file,name,final,string,name,state,file,get,file,name,to,string,if,name,starts,with,metadata,throw,new,illegal,state,exception,detected,pre,0,19,metadata,file,please,upgrade,to,a,version,before,version,current,minimum,index,compatibility,version,first,to,upgrade,state,structures,metadata,found,state,file,get,parent,to,absolute,path
GatewayMetaState -> private void ensureNoPre019MetadataFiles() throws IOException;1544113208;Throws an IAE if a pre 0.19 state is detected;private void ensureNoPre019MetadataFiles() throws IOException {_        for (Path dataLocation : nodeEnv.nodeDataPaths()) {_            final Path stateLocation = dataLocation.resolve(MetaDataStateFormat.STATE_DIR_NAME)__            if (!Files.exists(stateLocation)) {_                continue__            }_            try (DirectoryStream<Path> stream = Files.newDirectoryStream(stateLocation)) {_                for (Path stateFile : stream) {_                    if (logger.isTraceEnabled()) {_                        logger.trace("[upgrade]: processing [{}]", stateFile.getFileName())__                    }_                    final String name = stateFile.getFileName().toString()__                    if (name.startsWith("metadata-")) {_                        throw new IllegalStateException("Detected pre 0.19 metadata file please upgrade to a version before "_                                + Version.CURRENT.minimumIndexCompatibilityVersion()_                                + " first to upgrade state structures - metadata found: [" + stateFile.getParent().toAbsolutePath())__                    }_                }_            }_        }_    };throws,an,iae,if,a,pre,0,19,state,is,detected;private,void,ensure,no,pre019metadata,files,throws,ioexception,for,path,data,location,node,env,node,data,paths,final,path,state,location,data,location,resolve,meta,data,state,format,if,files,exists,state,location,continue,try,directory,stream,path,stream,files,new,directory,stream,state,location,for,path,state,file,stream,if,logger,is,trace,enabled,logger,trace,upgrade,processing,state,file,get,file,name,final,string,name,state,file,get,file,name,to,string,if,name,starts,with,metadata,throw,new,illegal,state,exception,detected,pre,0,19,metadata,file,please,upgrade,to,a,version,before,version,current,minimum,index,compatibility,version,first,to,upgrade,state,structures,metadata,found,state,file,get,parent,to,absolute,path
GatewayMetaState -> public static Iterable<GatewayMetaState.IndexMetaWriteInfo> resolveStatesToBeWritten(Set<Index> previouslyWrittenIndices, Set<Index> potentiallyUnwrittenIndices, MetaData previousMetaData, MetaData newMetaData);1524684173;Loads the current meta state for each index in the new cluster state and checks if it has to be persisted._Each index state that should be written to disk will be returned. This is only run for data only nodes._It will return only the states for indices that actually have a shard allocated on the current node.__@param previouslyWrittenIndices    A list of indices for which the state was already written before_@param potentiallyUnwrittenIndices The list of indices for which state should potentially be written_@param previousMetaData            The last meta data we know of. meta data for all indices in previouslyWrittenIndices list is persisted now_@param newMetaData                 The new metadata_@return iterable over all indices states that should be written to disk;public static Iterable<GatewayMetaState.IndexMetaWriteInfo> resolveStatesToBeWritten(Set<Index> previouslyWrittenIndices, Set<Index> potentiallyUnwrittenIndices, MetaData previousMetaData, MetaData newMetaData) {_        List<GatewayMetaState.IndexMetaWriteInfo> indicesToWrite = new ArrayList<>()__        for (Index index : potentiallyUnwrittenIndices) {_            IndexMetaData newIndexMetaData = newMetaData.getIndexSafe(index)__            IndexMetaData previousIndexMetaData = previousMetaData == null ? null : previousMetaData.index(index)__            String writeReason = null__            if (previouslyWrittenIndices.contains(index) == false || previousIndexMetaData == null) {_                writeReason = "freshly created"__            } else if (previousIndexMetaData.getVersion() != newIndexMetaData.getVersion()) {_                writeReason = "version changed from [" + previousIndexMetaData.getVersion() + "] to [" + newIndexMetaData.getVersion() + "]"__            }_            if (writeReason != null) {_                indicesToWrite.add(new GatewayMetaState.IndexMetaWriteInfo(newIndexMetaData, previousIndexMetaData, writeReason))__            }_        }_        return indicesToWrite__    };loads,the,current,meta,state,for,each,index,in,the,new,cluster,state,and,checks,if,it,has,to,be,persisted,each,index,state,that,should,be,written,to,disk,will,be,returned,this,is,only,run,for,data,only,nodes,it,will,return,only,the,states,for,indices,that,actually,have,a,shard,allocated,on,the,current,node,param,previously,written,indices,a,list,of,indices,for,which,the,state,was,already,written,before,param,potentially,unwritten,indices,the,list,of,indices,for,which,state,should,potentially,be,written,param,previous,meta,data,the,last,meta,data,we,know,of,meta,data,for,all,indices,in,previously,written,indices,list,is,persisted,now,param,new,meta,data,the,new,metadata,return,iterable,over,all,indices,states,that,should,be,written,to,disk;public,static,iterable,gateway,meta,state,index,meta,write,info,resolve,states,to,be,written,set,index,previously,written,indices,set,index,potentially,unwritten,indices,meta,data,previous,meta,data,meta,data,new,meta,data,list,gateway,meta,state,index,meta,write,info,indices,to,write,new,array,list,for,index,index,potentially,unwritten,indices,index,meta,data,new,index,meta,data,new,meta,data,get,index,safe,index,index,meta,data,previous,index,meta,data,previous,meta,data,null,null,previous,meta,data,index,index,string,write,reason,null,if,previously,written,indices,contains,index,false,previous,index,meta,data,null,write,reason,freshly,created,else,if,previous,index,meta,data,get,version,new,index,meta,data,get,version,write,reason,version,changed,from,previous,index,meta,data,get,version,to,new,index,meta,data,get,version,if,write,reason,null,indices,to,write,add,new,gateway,meta,state,index,meta,write,info,new,index,meta,data,previous,index,meta,data,write,reason,return,indices,to,write
GatewayMetaState -> public static Iterable<GatewayMetaState.IndexMetaWriteInfo> resolveStatesToBeWritten(Set<Index> previouslyWrittenIndices, Set<Index> potentiallyUnwrittenIndices, MetaData previousMetaData, MetaData newMetaData);1536314350;Loads the current meta state for each index in the new cluster state and checks if it has to be persisted._Each index state that should be written to disk will be returned. This is only run for data only nodes._It will return only the states for indices that actually have a shard allocated on the current node.__@param previouslyWrittenIndices    A list of indices for which the state was already written before_@param potentiallyUnwrittenIndices The list of indices for which state should potentially be written_@param previousMetaData            The last meta data we know of. meta data for all indices in previouslyWrittenIndices list is persisted now_@param newMetaData                 The new metadata_@return iterable over all indices states that should be written to disk;public static Iterable<GatewayMetaState.IndexMetaWriteInfo> resolveStatesToBeWritten(Set<Index> previouslyWrittenIndices, Set<Index> potentiallyUnwrittenIndices, MetaData previousMetaData, MetaData newMetaData) {_        List<GatewayMetaState.IndexMetaWriteInfo> indicesToWrite = new ArrayList<>()__        for (Index index : potentiallyUnwrittenIndices) {_            IndexMetaData newIndexMetaData = newMetaData.getIndexSafe(index)__            IndexMetaData previousIndexMetaData = previousMetaData == null ? null : previousMetaData.index(index)__            String writeReason = null__            if (previouslyWrittenIndices.contains(index) == false || previousIndexMetaData == null) {_                writeReason = "freshly created"__            } else if (previousIndexMetaData.getVersion() != newIndexMetaData.getVersion()) {_                writeReason = "version changed from [" + previousIndexMetaData.getVersion() + "] to [" + newIndexMetaData.getVersion() + "]"__            }_            if (writeReason != null) {_                indicesToWrite.add(new GatewayMetaState.IndexMetaWriteInfo(newIndexMetaData, previousIndexMetaData, writeReason))__            }_        }_        return indicesToWrite__    };loads,the,current,meta,state,for,each,index,in,the,new,cluster,state,and,checks,if,it,has,to,be,persisted,each,index,state,that,should,be,written,to,disk,will,be,returned,this,is,only,run,for,data,only,nodes,it,will,return,only,the,states,for,indices,that,actually,have,a,shard,allocated,on,the,current,node,param,previously,written,indices,a,list,of,indices,for,which,the,state,was,already,written,before,param,potentially,unwritten,indices,the,list,of,indices,for,which,state,should,potentially,be,written,param,previous,meta,data,the,last,meta,data,we,know,of,meta,data,for,all,indices,in,previously,written,indices,list,is,persisted,now,param,new,meta,data,the,new,metadata,return,iterable,over,all,indices,states,that,should,be,written,to,disk;public,static,iterable,gateway,meta,state,index,meta,write,info,resolve,states,to,be,written,set,index,previously,written,indices,set,index,potentially,unwritten,indices,meta,data,previous,meta,data,meta,data,new,meta,data,list,gateway,meta,state,index,meta,write,info,indices,to,write,new,array,list,for,index,index,potentially,unwritten,indices,index,meta,data,new,index,meta,data,new,meta,data,get,index,safe,index,index,meta,data,previous,index,meta,data,previous,meta,data,null,null,previous,meta,data,index,index,string,write,reason,null,if,previously,written,indices,contains,index,false,previous,index,meta,data,null,write,reason,freshly,created,else,if,previous,index,meta,data,get,version,new,index,meta,data,get,version,write,reason,version,changed,from,previous,index,meta,data,get,version,to,new,index,meta,data,get,version,if,write,reason,null,indices,to,write,add,new,gateway,meta,state,index,meta,write,info,new,index,meta,data,previous,index,meta,data,write,reason,return,indices,to,write
GatewayMetaState -> protected void updateClusterState(ClusterState newState, ClusterState previousState)             throws WriteStateException;1544081506;Updates manifest and meta data on disk.__@param newState new {@link ClusterState}_@param previousState previous {@link ClusterState}__@throws WriteStateException if exception occurs. See also {@link WriteStateException#isDirty()}.;protected void updateClusterState(ClusterState newState, ClusterState previousState)_            throws WriteStateException {_        MetaData newMetaData = newState.metaData()___        final AtomicClusterStateWriter writer = new AtomicClusterStateWriter(metaStateService, previousManifest)__        long globalStateGeneration = writeGlobalState(writer, newMetaData)__        Map<Index, Long> indexGenerations = writeIndicesMetadata(writer, newState, previousState)__        Manifest manifest = new Manifest(previousManifest.getCurrentTerm(), newState.version(), globalStateGeneration, indexGenerations)__        writeManifest(writer, manifest)___        previousManifest = manifest__        previousClusterState = newState__    };updates,manifest,and,meta,data,on,disk,param,new,state,new,link,cluster,state,param,previous,state,previous,link,cluster,state,throws,write,state,exception,if,exception,occurs,see,also,link,write,state,exception,is,dirty;protected,void,update,cluster,state,cluster,state,new,state,cluster,state,previous,state,throws,write,state,exception,meta,data,new,meta,data,new,state,meta,data,final,atomic,cluster,state,writer,writer,new,atomic,cluster,state,writer,meta,state,service,previous,manifest,long,global,state,generation,write,global,state,writer,new,meta,data,map,index,long,index,generations,write,indices,metadata,writer,new,state,previous,state,manifest,manifest,new,manifest,previous,manifest,get,current,term,new,state,version,global,state,generation,index,generations,write,manifest,writer,manifest,previous,manifest,manifest,previous,cluster,state,new,state
GatewayMetaState -> protected void updateClusterState(ClusterState newState, ClusterState previousState)             throws WriteStateException;1544112122;Updates manifest and meta data on disk.__@param newState new {@link ClusterState}_@param previousState previous {@link ClusterState}__@throws WriteStateException if exception occurs. See also {@link WriteStateException#isDirty()}.;protected void updateClusterState(ClusterState newState, ClusterState previousState)_            throws WriteStateException {_        MetaData newMetaData = newState.metaData()___        final AtomicClusterStateWriter writer = new AtomicClusterStateWriter(metaStateService, previousManifest)__        long globalStateGeneration = writeGlobalState(writer, newMetaData)__        Map<Index, Long> indexGenerations = writeIndicesMetadata(writer, newState, previousState)__        Manifest manifest = new Manifest(previousManifest.getCurrentTerm(), newState.version(), globalStateGeneration, indexGenerations)__        writeManifest(writer, manifest)___        previousManifest = manifest__        previousClusterState = newState__    };updates,manifest,and,meta,data,on,disk,param,new,state,new,link,cluster,state,param,previous,state,previous,link,cluster,state,throws,write,state,exception,if,exception,occurs,see,also,link,write,state,exception,is,dirty;protected,void,update,cluster,state,cluster,state,new,state,cluster,state,previous,state,throws,write,state,exception,meta,data,new,meta,data,new,state,meta,data,final,atomic,cluster,state,writer,writer,new,atomic,cluster,state,writer,meta,state,service,previous,manifest,long,global,state,generation,write,global,state,writer,new,meta,data,map,index,long,index,generations,write,indices,metadata,writer,new,state,previous,state,manifest,manifest,new,manifest,previous,manifest,get,current,term,new,state,version,global,state,generation,index,generations,write,manifest,writer,manifest,previous,manifest,manifest,previous,cluster,state,new,state
GatewayMetaState -> protected void updateClusterState(ClusterState newState, ClusterState previousState)             throws WriteStateException;1544113208;Updates manifest and meta data on disk.__@param newState new {@link ClusterState}_@param previousState previous {@link ClusterState}__@throws WriteStateException if exception occurs. See also {@link WriteStateException#isDirty()}.;protected void updateClusterState(ClusterState newState, ClusterState previousState)_            throws WriteStateException {_        MetaData newMetaData = newState.metaData()___        final AtomicClusterStateWriter writer = new AtomicClusterStateWriter(metaStateService, previousManifest)__        long globalStateGeneration = writeGlobalState(writer, newMetaData)__        Map<Index, Long> indexGenerations = writeIndicesMetadata(writer, newState, previousState)__        Manifest manifest = new Manifest(previousManifest.getCurrentTerm(), newState.version(), globalStateGeneration, indexGenerations)__        writeManifest(writer, manifest)___        previousManifest = manifest__        previousClusterState = newState__    };updates,manifest,and,meta,data,on,disk,param,new,state,new,link,cluster,state,param,previous,state,previous,link,cluster,state,throws,write,state,exception,if,exception,occurs,see,also,link,write,state,exception,is,dirty;protected,void,update,cluster,state,cluster,state,new,state,cluster,state,previous,state,throws,write,state,exception,meta,data,new,meta,data,new,state,meta,data,final,atomic,cluster,state,writer,writer,new,atomic,cluster,state,writer,meta,state,service,previous,manifest,long,global,state,generation,write,global,state,writer,new,meta,data,map,index,long,index,generations,write,indices,metadata,writer,new,state,previous,state,manifest,manifest,new,manifest,previous,manifest,get,current,term,new,state,version,global,state,generation,index,generations,write,manifest,writer,manifest,previous,manifest,manifest,previous,cluster,state,new,state
GatewayMetaState -> protected void updateClusterState(ClusterState newState, ClusterState previousState)             throws WriteStateException;1545665168;Updates manifest and meta data on disk.__@param newState new {@link ClusterState}_@param previousState previous {@link ClusterState}__@throws WriteStateException if exception occurs. See also {@link WriteStateException#isDirty()}.;protected void updateClusterState(ClusterState newState, ClusterState previousState)_            throws WriteStateException {_        MetaData newMetaData = newState.metaData()___        final AtomicClusterStateWriter writer = new AtomicClusterStateWriter(metaStateService, previousManifest)__        long globalStateGeneration = writeGlobalState(writer, newMetaData)__        Map<Index, Long> indexGenerations = writeIndicesMetadata(writer, newState, previousState)__        Manifest manifest = new Manifest(previousManifest.getCurrentTerm(), newState.version(), globalStateGeneration, indexGenerations)__        writeManifest(writer, manifest)___        previousManifest = manifest__        previousClusterState = newState__    };updates,manifest,and,meta,data,on,disk,param,new,state,new,link,cluster,state,param,previous,state,previous,link,cluster,state,throws,write,state,exception,if,exception,occurs,see,also,link,write,state,exception,is,dirty;protected,void,update,cluster,state,cluster,state,new,state,cluster,state,previous,state,throws,write,state,exception,meta,data,new,meta,data,new,state,meta,data,final,atomic,cluster,state,writer,writer,new,atomic,cluster,state,writer,meta,state,service,previous,manifest,long,global,state,generation,write,global,state,writer,new,meta,data,map,index,long,index,generations,write,indices,metadata,writer,new,state,previous,state,manifest,manifest,new,manifest,previous,manifest,get,current,term,new,state,version,global,state,generation,index,generations,write,manifest,writer,manifest,previous,manifest,manifest,previous,cluster,state,new,state
GatewayMetaState -> protected void updateClusterState(ClusterState newState, ClusterState previousState)             throws WriteStateException;1545945527;Updates manifest and meta data on disk.__@param newState new {@link ClusterState}_@param previousState previous {@link ClusterState}__@throws WriteStateException if exception occurs. See also {@link WriteStateException#isDirty()}.;protected void updateClusterState(ClusterState newState, ClusterState previousState)_            throws WriteStateException {_        MetaData newMetaData = newState.metaData()___        final AtomicClusterStateWriter writer = new AtomicClusterStateWriter(metaStateService, previousManifest)__        long globalStateGeneration = writeGlobalState(writer, newMetaData)__        Map<Index, Long> indexGenerations = writeIndicesMetadata(writer, newState, previousState)__        Manifest manifest = new Manifest(previousManifest.getCurrentTerm(), newState.version(), globalStateGeneration, indexGenerations)__        writeManifest(writer, manifest)___        previousManifest = manifest__        previousClusterState = newState__    };updates,manifest,and,meta,data,on,disk,param,new,state,new,link,cluster,state,param,previous,state,previous,link,cluster,state,throws,write,state,exception,if,exception,occurs,see,also,link,write,state,exception,is,dirty;protected,void,update,cluster,state,cluster,state,new,state,cluster,state,previous,state,throws,write,state,exception,meta,data,new,meta,data,new,state,meta,data,final,atomic,cluster,state,writer,writer,new,atomic,cluster,state,writer,meta,state,service,previous,manifest,long,global,state,generation,write,global,state,writer,new,meta,data,map,index,long,index,generations,write,indices,metadata,writer,new,state,previous,state,manifest,manifest,new,manifest,previous,manifest,get,current,term,new,state,version,global,state,generation,index,generations,write,manifest,writer,manifest,previous,manifest,manifest,previous,cluster,state,new,state
GatewayMetaState -> protected void updateClusterState(ClusterState newState, ClusterState previousState)             throws WriteStateException;1547577205;Updates manifest and meta data on disk.__@param newState new {@link ClusterState}_@param previousState previous {@link ClusterState}__@throws WriteStateException if exception occurs. See also {@link WriteStateException#isDirty()}.;protected void updateClusterState(ClusterState newState, ClusterState previousState)_            throws WriteStateException {_        MetaData newMetaData = newState.metaData()___        final AtomicClusterStateWriter writer = new AtomicClusterStateWriter(metaStateService, previousManifest)__        long globalStateGeneration = writeGlobalState(writer, newMetaData)__        Map<Index, Long> indexGenerations = writeIndicesMetadata(writer, newState, previousState)__        Manifest manifest = new Manifest(previousManifest.getCurrentTerm(), newState.version(), globalStateGeneration, indexGenerations)__        writeManifest(writer, manifest)___        previousManifest = manifest__        previousClusterState = newState__    };updates,manifest,and,meta,data,on,disk,param,new,state,new,link,cluster,state,param,previous,state,previous,link,cluster,state,throws,write,state,exception,if,exception,occurs,see,also,link,write,state,exception,is,dirty;protected,void,update,cluster,state,cluster,state,new,state,cluster,state,previous,state,throws,write,state,exception,meta,data,new,meta,data,new,state,meta,data,final,atomic,cluster,state,writer,writer,new,atomic,cluster,state,writer,meta,state,service,previous,manifest,long,global,state,generation,write,global,state,writer,new,meta,data,map,index,long,index,generations,write,indices,metadata,writer,new,state,previous,state,manifest,manifest,new,manifest,previous,manifest,get,current,term,new,state,version,global,state,generation,index,generations,write,manifest,writer,manifest,previous,manifest,manifest,previous,cluster,state,new,state
GatewayMetaState -> static MetaData upgradeMetaData(MetaData metaData,                                     MetaDataIndexUpgradeService metaDataIndexUpgradeService,                                     MetaDataUpgrader metaDataUpgrader);1544081506;Elasticsearch 2.0 removed several deprecated features and as well as support for Lucene 3.x. This method calls_{@link MetaDataIndexUpgradeService} to makes sure that indices are compatible with the current version. The_MetaDataIndexUpgradeService might also update obsolete settings if needed._Allows upgrading global custom meta data via {@link MetaDataUpgrader#customMetaDataUpgraders}__@return input <code>metaData</code> if no upgrade is needed or an upgraded metaData;static MetaData upgradeMetaData(MetaData metaData,_                                    MetaDataIndexUpgradeService metaDataIndexUpgradeService,_                                    MetaDataUpgrader metaDataUpgrader) {_        _        boolean changed = false__        final MetaData.Builder upgradedMetaData = MetaData.builder(metaData)__        for (IndexMetaData indexMetaData : metaData) {_            IndexMetaData newMetaData = metaDataIndexUpgradeService.upgradeIndexMetaData(indexMetaData,_                    Version.CURRENT.minimumIndexCompatibilityVersion())__            changed |= indexMetaData != newMetaData__            upgradedMetaData.put(newMetaData, false)__        }_        _        if (applyPluginUpgraders(metaData.getCustoms(), metaDataUpgrader.customMetaDataUpgraders,_                upgradedMetaData::removeCustom, upgradedMetaData::putCustom)) {_            changed = true__        }_        _        if (applyPluginUpgraders(metaData.getTemplates(), metaDataUpgrader.indexTemplateMetaDataUpgraders,_                upgradedMetaData::removeTemplate, (s, indexTemplateMetaData) -> upgradedMetaData.put(indexTemplateMetaData))) {_            changed = true__        }_        return changed ? upgradedMetaData.build() : metaData__    };elasticsearch,2,0,removed,several,deprecated,features,and,as,well,as,support,for,lucene,3,x,this,method,calls,link,meta,data,index,upgrade,service,to,makes,sure,that,indices,are,compatible,with,the,current,version,the,meta,data,index,upgrade,service,might,also,update,obsolete,settings,if,needed,allows,upgrading,global,custom,meta,data,via,link,meta,data,upgrader,custom,meta,data,upgraders,return,input,code,meta,data,code,if,no,upgrade,is,needed,or,an,upgraded,meta,data;static,meta,data,upgrade,meta,data,meta,data,meta,data,meta,data,index,upgrade,service,meta,data,index,upgrade,service,meta,data,upgrader,meta,data,upgrader,boolean,changed,false,final,meta,data,builder,upgraded,meta,data,meta,data,builder,meta,data,for,index,meta,data,index,meta,data,meta,data,index,meta,data,new,meta,data,meta,data,index,upgrade,service,upgrade,index,meta,data,index,meta,data,version,current,minimum,index,compatibility,version,changed,index,meta,data,new,meta,data,upgraded,meta,data,put,new,meta,data,false,if,apply,plugin,upgraders,meta,data,get,customs,meta,data,upgrader,custom,meta,data,upgraders,upgraded,meta,data,remove,custom,upgraded,meta,data,put,custom,changed,true,if,apply,plugin,upgraders,meta,data,get,templates,meta,data,upgrader,index,template,meta,data,upgraders,upgraded,meta,data,remove,template,s,index,template,meta,data,upgraded,meta,data,put,index,template,meta,data,changed,true,return,changed,upgraded,meta,data,build,meta,data
GatewayMetaState -> static MetaData upgradeMetaData(MetaData metaData,                                     MetaDataIndexUpgradeService metaDataIndexUpgradeService,                                     MetaDataUpgrader metaDataUpgrader);1544112122;Elasticsearch 2.0 removed several deprecated features and as well as support for Lucene 3.x. This method calls_{@link MetaDataIndexUpgradeService} to makes sure that indices are compatible with the current version. The_MetaDataIndexUpgradeService might also update obsolete settings if needed._Allows upgrading global custom meta data via {@link MetaDataUpgrader#customMetaDataUpgraders}__@return input <code>metaData</code> if no upgrade is needed or an upgraded metaData;static MetaData upgradeMetaData(MetaData metaData,_                                    MetaDataIndexUpgradeService metaDataIndexUpgradeService,_                                    MetaDataUpgrader metaDataUpgrader) {_        _        boolean changed = false__        final MetaData.Builder upgradedMetaData = MetaData.builder(metaData)__        for (IndexMetaData indexMetaData : metaData) {_            IndexMetaData newMetaData = metaDataIndexUpgradeService.upgradeIndexMetaData(indexMetaData,_                    Version.CURRENT.minimumIndexCompatibilityVersion())__            changed |= indexMetaData != newMetaData__            upgradedMetaData.put(newMetaData, false)__        }_        _        if (applyPluginUpgraders(metaData.getCustoms(), metaDataUpgrader.customMetaDataUpgraders,_                upgradedMetaData::removeCustom, upgradedMetaData::putCustom)) {_            changed = true__        }_        _        if (applyPluginUpgraders(metaData.getTemplates(), metaDataUpgrader.indexTemplateMetaDataUpgraders,_                upgradedMetaData::removeTemplate, (s, indexTemplateMetaData) -> upgradedMetaData.put(indexTemplateMetaData))) {_            changed = true__        }_        return changed ? upgradedMetaData.build() : metaData__    };elasticsearch,2,0,removed,several,deprecated,features,and,as,well,as,support,for,lucene,3,x,this,method,calls,link,meta,data,index,upgrade,service,to,makes,sure,that,indices,are,compatible,with,the,current,version,the,meta,data,index,upgrade,service,might,also,update,obsolete,settings,if,needed,allows,upgrading,global,custom,meta,data,via,link,meta,data,upgrader,custom,meta,data,upgraders,return,input,code,meta,data,code,if,no,upgrade,is,needed,or,an,upgraded,meta,data;static,meta,data,upgrade,meta,data,meta,data,meta,data,meta,data,index,upgrade,service,meta,data,index,upgrade,service,meta,data,upgrader,meta,data,upgrader,boolean,changed,false,final,meta,data,builder,upgraded,meta,data,meta,data,builder,meta,data,for,index,meta,data,index,meta,data,meta,data,index,meta,data,new,meta,data,meta,data,index,upgrade,service,upgrade,index,meta,data,index,meta,data,version,current,minimum,index,compatibility,version,changed,index,meta,data,new,meta,data,upgraded,meta,data,put,new,meta,data,false,if,apply,plugin,upgraders,meta,data,get,customs,meta,data,upgrader,custom,meta,data,upgraders,upgraded,meta,data,remove,custom,upgraded,meta,data,put,custom,changed,true,if,apply,plugin,upgraders,meta,data,get,templates,meta,data,upgrader,index,template,meta,data,upgraders,upgraded,meta,data,remove,template,s,index,template,meta,data,upgraded,meta,data,put,index,template,meta,data,changed,true,return,changed,upgraded,meta,data,build,meta,data
GatewayMetaState -> static MetaData upgradeMetaData(MetaData metaData,                                     MetaDataIndexUpgradeService metaDataIndexUpgradeService,                                     MetaDataUpgrader metaDataUpgrader);1544113208;Elasticsearch 2.0 removed several deprecated features and as well as support for Lucene 3.x. This method calls_{@link MetaDataIndexUpgradeService} to makes sure that indices are compatible with the current version. The_MetaDataIndexUpgradeService might also update obsolete settings if needed._Allows upgrading global custom meta data via {@link MetaDataUpgrader#customMetaDataUpgraders}__@return input <code>metaData</code> if no upgrade is needed or an upgraded metaData;static MetaData upgradeMetaData(MetaData metaData,_                                    MetaDataIndexUpgradeService metaDataIndexUpgradeService,_                                    MetaDataUpgrader metaDataUpgrader) {_        _        boolean changed = false__        final MetaData.Builder upgradedMetaData = MetaData.builder(metaData)__        for (IndexMetaData indexMetaData : metaData) {_            IndexMetaData newMetaData = metaDataIndexUpgradeService.upgradeIndexMetaData(indexMetaData,_                    Version.CURRENT.minimumIndexCompatibilityVersion())__            changed |= indexMetaData != newMetaData__            upgradedMetaData.put(newMetaData, false)__        }_        _        if (applyPluginUpgraders(metaData.getCustoms(), metaDataUpgrader.customMetaDataUpgraders,_                upgradedMetaData::removeCustom, upgradedMetaData::putCustom)) {_            changed = true__        }_        _        if (applyPluginUpgraders(metaData.getTemplates(), metaDataUpgrader.indexTemplateMetaDataUpgraders,_                upgradedMetaData::removeTemplate, (s, indexTemplateMetaData) -> upgradedMetaData.put(indexTemplateMetaData))) {_            changed = true__        }_        return changed ? upgradedMetaData.build() : metaData__    };elasticsearch,2,0,removed,several,deprecated,features,and,as,well,as,support,for,lucene,3,x,this,method,calls,link,meta,data,index,upgrade,service,to,makes,sure,that,indices,are,compatible,with,the,current,version,the,meta,data,index,upgrade,service,might,also,update,obsolete,settings,if,needed,allows,upgrading,global,custom,meta,data,via,link,meta,data,upgrader,custom,meta,data,upgraders,return,input,code,meta,data,code,if,no,upgrade,is,needed,or,an,upgraded,meta,data;static,meta,data,upgrade,meta,data,meta,data,meta,data,meta,data,index,upgrade,service,meta,data,index,upgrade,service,meta,data,upgrader,meta,data,upgrader,boolean,changed,false,final,meta,data,builder,upgraded,meta,data,meta,data,builder,meta,data,for,index,meta,data,index,meta,data,meta,data,index,meta,data,new,meta,data,meta,data,index,upgrade,service,upgrade,index,meta,data,index,meta,data,version,current,minimum,index,compatibility,version,changed,index,meta,data,new,meta,data,upgraded,meta,data,put,new,meta,data,false,if,apply,plugin,upgraders,meta,data,get,customs,meta,data,upgrader,custom,meta,data,upgraders,upgraded,meta,data,remove,custom,upgraded,meta,data,put,custom,changed,true,if,apply,plugin,upgraders,meta,data,get,templates,meta,data,upgrader,index,template,meta,data,upgraders,upgraded,meta,data,remove,template,s,index,template,meta,data,upgraded,meta,data,put,index,template,meta,data,changed,true,return,changed,upgraded,meta,data,build,meta,data
GatewayMetaState -> static MetaData upgradeMetaData(MetaData metaData,                                     MetaDataIndexUpgradeService metaDataIndexUpgradeService,                                     MetaDataUpgrader metaDataUpgrader);1545665168;Elasticsearch 2.0 removed several deprecated features and as well as support for Lucene 3.x. This method calls_{@link MetaDataIndexUpgradeService} to makes sure that indices are compatible with the current version. The_MetaDataIndexUpgradeService might also update obsolete settings if needed._Allows upgrading global custom meta data via {@link MetaDataUpgrader#customMetaDataUpgraders}__@return input <code>metaData</code> if no upgrade is needed or an upgraded metaData;static MetaData upgradeMetaData(MetaData metaData,_                                    MetaDataIndexUpgradeService metaDataIndexUpgradeService,_                                    MetaDataUpgrader metaDataUpgrader) {_        _        boolean changed = false__        final MetaData.Builder upgradedMetaData = MetaData.builder(metaData)__        for (IndexMetaData indexMetaData : metaData) {_            IndexMetaData newMetaData = metaDataIndexUpgradeService.upgradeIndexMetaData(indexMetaData,_                    Version.CURRENT.minimumIndexCompatibilityVersion())__            changed |= indexMetaData != newMetaData__            upgradedMetaData.put(newMetaData, false)__        }_        _        if (applyPluginUpgraders(metaData.getCustoms(), metaDataUpgrader.customMetaDataUpgraders,_                upgradedMetaData::removeCustom, upgradedMetaData::putCustom)) {_            changed = true__        }_        _        if (applyPluginUpgraders(metaData.getTemplates(), metaDataUpgrader.indexTemplateMetaDataUpgraders,_                upgradedMetaData::removeTemplate, (s, indexTemplateMetaData) -> upgradedMetaData.put(indexTemplateMetaData))) {_            changed = true__        }_        return changed ? upgradedMetaData.build() : metaData__    };elasticsearch,2,0,removed,several,deprecated,features,and,as,well,as,support,for,lucene,3,x,this,method,calls,link,meta,data,index,upgrade,service,to,makes,sure,that,indices,are,compatible,with,the,current,version,the,meta,data,index,upgrade,service,might,also,update,obsolete,settings,if,needed,allows,upgrading,global,custom,meta,data,via,link,meta,data,upgrader,custom,meta,data,upgraders,return,input,code,meta,data,code,if,no,upgrade,is,needed,or,an,upgraded,meta,data;static,meta,data,upgrade,meta,data,meta,data,meta,data,meta,data,index,upgrade,service,meta,data,index,upgrade,service,meta,data,upgrader,meta,data,upgrader,boolean,changed,false,final,meta,data,builder,upgraded,meta,data,meta,data,builder,meta,data,for,index,meta,data,index,meta,data,meta,data,index,meta,data,new,meta,data,meta,data,index,upgrade,service,upgrade,index,meta,data,index,meta,data,version,current,minimum,index,compatibility,version,changed,index,meta,data,new,meta,data,upgraded,meta,data,put,new,meta,data,false,if,apply,plugin,upgraders,meta,data,get,customs,meta,data,upgrader,custom,meta,data,upgraders,upgraded,meta,data,remove,custom,upgraded,meta,data,put,custom,changed,true,if,apply,plugin,upgraders,meta,data,get,templates,meta,data,upgrader,index,template,meta,data,upgraders,upgraded,meta,data,remove,template,s,index,template,meta,data,upgraded,meta,data,put,index,template,meta,data,changed,true,return,changed,upgraded,meta,data,build,meta,data
GatewayMetaState -> static MetaData upgradeMetaData(MetaData metaData,                                     MetaDataIndexUpgradeService metaDataIndexUpgradeService,                                     MetaDataUpgrader metaDataUpgrader);1545945527;Elasticsearch 2.0 removed several deprecated features and as well as support for Lucene 3.x. This method calls_{@link MetaDataIndexUpgradeService} to makes sure that indices are compatible with the current version. The_MetaDataIndexUpgradeService might also update obsolete settings if needed._Allows upgrading global custom meta data via {@link MetaDataUpgrader#customMetaDataUpgraders}__@return input <code>metaData</code> if no upgrade is needed or an upgraded metaData;static MetaData upgradeMetaData(MetaData metaData,_                                    MetaDataIndexUpgradeService metaDataIndexUpgradeService,_                                    MetaDataUpgrader metaDataUpgrader) {_        _        boolean changed = false__        final MetaData.Builder upgradedMetaData = MetaData.builder(metaData)__        for (IndexMetaData indexMetaData : metaData) {_            IndexMetaData newMetaData = metaDataIndexUpgradeService.upgradeIndexMetaData(indexMetaData,_                    Version.CURRENT.minimumIndexCompatibilityVersion())__            changed |= indexMetaData != newMetaData__            upgradedMetaData.put(newMetaData, false)__        }_        _        if (applyPluginUpgraders(metaData.getCustoms(), metaDataUpgrader.customMetaDataUpgraders,_                upgradedMetaData::removeCustom, upgradedMetaData::putCustom)) {_            changed = true__        }_        _        if (applyPluginUpgraders(metaData.getTemplates(), metaDataUpgrader.indexTemplateMetaDataUpgraders,_                upgradedMetaData::removeTemplate, (s, indexTemplateMetaData) -> upgradedMetaData.put(indexTemplateMetaData))) {_            changed = true__        }_        return changed ? upgradedMetaData.build() : metaData__    };elasticsearch,2,0,removed,several,deprecated,features,and,as,well,as,support,for,lucene,3,x,this,method,calls,link,meta,data,index,upgrade,service,to,makes,sure,that,indices,are,compatible,with,the,current,version,the,meta,data,index,upgrade,service,might,also,update,obsolete,settings,if,needed,allows,upgrading,global,custom,meta,data,via,link,meta,data,upgrader,custom,meta,data,upgraders,return,input,code,meta,data,code,if,no,upgrade,is,needed,or,an,upgraded,meta,data;static,meta,data,upgrade,meta,data,meta,data,meta,data,meta,data,index,upgrade,service,meta,data,index,upgrade,service,meta,data,upgrader,meta,data,upgrader,boolean,changed,false,final,meta,data,builder,upgraded,meta,data,meta,data,builder,meta,data,for,index,meta,data,index,meta,data,meta,data,index,meta,data,new,meta,data,meta,data,index,upgrade,service,upgrade,index,meta,data,index,meta,data,version,current,minimum,index,compatibility,version,changed,index,meta,data,new,meta,data,upgraded,meta,data,put,new,meta,data,false,if,apply,plugin,upgraders,meta,data,get,customs,meta,data,upgrader,custom,meta,data,upgraders,upgraded,meta,data,remove,custom,upgraded,meta,data,put,custom,changed,true,if,apply,plugin,upgraders,meta,data,get,templates,meta,data,upgrader,index,template,meta,data,upgraders,upgraded,meta,data,remove,template,s,index,template,meta,data,upgraded,meta,data,put,index,template,meta,data,changed,true,return,changed,upgraded,meta,data,build,meta,data
GatewayMetaState -> static MetaData upgradeMetaData(MetaData metaData,                                     MetaDataIndexUpgradeService metaDataIndexUpgradeService,                                     MetaDataUpgrader metaDataUpgrader);1547577205;Elasticsearch 2.0 removed several deprecated features and as well as support for Lucene 3.x. This method calls_{@link MetaDataIndexUpgradeService} to makes sure that indices are compatible with the current version. The_MetaDataIndexUpgradeService might also update obsolete settings if needed._Allows upgrading global custom meta data via {@link MetaDataUpgrader#customMetaDataUpgraders}__@return input <code>metaData</code> if no upgrade is needed or an upgraded metaData;static MetaData upgradeMetaData(MetaData metaData,_                                    MetaDataIndexUpgradeService metaDataIndexUpgradeService,_                                    MetaDataUpgrader metaDataUpgrader) {_        _        boolean changed = false__        final MetaData.Builder upgradedMetaData = MetaData.builder(metaData)__        for (IndexMetaData indexMetaData : metaData) {_            IndexMetaData newMetaData = metaDataIndexUpgradeService.upgradeIndexMetaData(indexMetaData,_                    Version.CURRENT.minimumIndexCompatibilityVersion())__            changed |= indexMetaData != newMetaData__            upgradedMetaData.put(newMetaData, false)__        }_        _        if (applyPluginUpgraders(metaData.getCustoms(), metaDataUpgrader.customMetaDataUpgraders,_                upgradedMetaData::removeCustom, upgradedMetaData::putCustom)) {_            changed = true__        }_        _        if (applyPluginUpgraders(metaData.getTemplates(), metaDataUpgrader.indexTemplateMetaDataUpgraders,_                upgradedMetaData::removeTemplate, (s, indexTemplateMetaData) -> upgradedMetaData.put(indexTemplateMetaData))) {_            changed = true__        }_        return changed ? upgradedMetaData.build() : metaData__    };elasticsearch,2,0,removed,several,deprecated,features,and,as,well,as,support,for,lucene,3,x,this,method,calls,link,meta,data,index,upgrade,service,to,makes,sure,that,indices,are,compatible,with,the,current,version,the,meta,data,index,upgrade,service,might,also,update,obsolete,settings,if,needed,allows,upgrading,global,custom,meta,data,via,link,meta,data,upgrader,custom,meta,data,upgraders,return,input,code,meta,data,code,if,no,upgrade,is,needed,or,an,upgraded,meta,data;static,meta,data,upgrade,meta,data,meta,data,meta,data,meta,data,index,upgrade,service,meta,data,index,upgrade,service,meta,data,upgrader,meta,data,upgrader,boolean,changed,false,final,meta,data,builder,upgraded,meta,data,meta,data,builder,meta,data,for,index,meta,data,index,meta,data,meta,data,index,meta,data,new,meta,data,meta,data,index,upgrade,service,upgrade,index,meta,data,index,meta,data,version,current,minimum,index,compatibility,version,changed,index,meta,data,new,meta,data,upgraded,meta,data,put,new,meta,data,false,if,apply,plugin,upgraders,meta,data,get,customs,meta,data,upgrader,custom,meta,data,upgraders,upgraded,meta,data,remove,custom,upgraded,meta,data,put,custom,changed,true,if,apply,plugin,upgraders,meta,data,get,templates,meta,data,upgrader,index,template,meta,data,upgraders,upgraded,meta,data,remove,template,s,index,template,meta,data,upgraded,meta,data,put,index,template,meta,data,changed,true,return,changed,upgraded,meta,data,build,meta,data
GatewayMetaState -> public static Iterable<GatewayMetaState.IndexMetaWriteInfo> resolveStatesToBeWritten(Set<Index> previouslyWrittenIndices,                                                                                          Set<Index> potentiallyUnwrittenIndices,                                                                                          MetaData previousMetaData, MetaData newMetaData);1540847035;Loads the current meta state for each index in the new cluster state and checks if it has to be persisted._Each index state that should be written to disk will be returned. This is only run for data only nodes._It will return only the states for indices that actually have a shard allocated on the current node.__@param previouslyWrittenIndices    A list of indices for which the state was already written before_@param potentiallyUnwrittenIndices The list of indices for which state should potentially be written_@param previousMetaData            The last meta data we know of. meta data for all indices in previouslyWrittenIndices list is_persisted now_@param newMetaData                 The new metadata_@return iterable over all indices states that should be written to disk;public static Iterable<GatewayMetaState.IndexMetaWriteInfo> resolveStatesToBeWritten(Set<Index> previouslyWrittenIndices,_                                                                                         Set<Index> potentiallyUnwrittenIndices,_                                                                                         MetaData previousMetaData, MetaData newMetaData) {_        List<GatewayMetaState.IndexMetaWriteInfo> indicesToWrite = new ArrayList<>()__        for (Index index : potentiallyUnwrittenIndices) {_            IndexMetaData newIndexMetaData = newMetaData.getIndexSafe(index)__            IndexMetaData previousIndexMetaData = previousMetaData == null ? null : previousMetaData.index(index)__            String writeReason = null__            if (previouslyWrittenIndices.contains(index) == false || previousIndexMetaData == null) {_                writeReason = "freshly created"__            } else if (previousIndexMetaData.getVersion() != newIndexMetaData.getVersion()) {_                writeReason = "version changed from [" + previousIndexMetaData.getVersion() + "] to [" +_                    newIndexMetaData.getVersion() + "]"__            }_            if (writeReason != null) {_                indicesToWrite.add(new GatewayMetaState.IndexMetaWriteInfo(newIndexMetaData, previousIndexMetaData, writeReason))__            }_        }_        return indicesToWrite__    };loads,the,current,meta,state,for,each,index,in,the,new,cluster,state,and,checks,if,it,has,to,be,persisted,each,index,state,that,should,be,written,to,disk,will,be,returned,this,is,only,run,for,data,only,nodes,it,will,return,only,the,states,for,indices,that,actually,have,a,shard,allocated,on,the,current,node,param,previously,written,indices,a,list,of,indices,for,which,the,state,was,already,written,before,param,potentially,unwritten,indices,the,list,of,indices,for,which,state,should,potentially,be,written,param,previous,meta,data,the,last,meta,data,we,know,of,meta,data,for,all,indices,in,previously,written,indices,list,is,persisted,now,param,new,meta,data,the,new,metadata,return,iterable,over,all,indices,states,that,should,be,written,to,disk;public,static,iterable,gateway,meta,state,index,meta,write,info,resolve,states,to,be,written,set,index,previously,written,indices,set,index,potentially,unwritten,indices,meta,data,previous,meta,data,meta,data,new,meta,data,list,gateway,meta,state,index,meta,write,info,indices,to,write,new,array,list,for,index,index,potentially,unwritten,indices,index,meta,data,new,index,meta,data,new,meta,data,get,index,safe,index,index,meta,data,previous,index,meta,data,previous,meta,data,null,null,previous,meta,data,index,index,string,write,reason,null,if,previously,written,indices,contains,index,false,previous,index,meta,data,null,write,reason,freshly,created,else,if,previous,index,meta,data,get,version,new,index,meta,data,get,version,write,reason,version,changed,from,previous,index,meta,data,get,version,to,new,index,meta,data,get,version,if,write,reason,null,indices,to,write,add,new,gateway,meta,state,index,meta,write,info,new,index,meta,data,previous,index,meta,data,write,reason,return,indices,to,write
GatewayMetaState -> public static Iterable<GatewayMetaState.IndexMetaWriteInfo> resolveStatesToBeWritten(Set<Index> previouslyWrittenIndices,                                                                                          Set<Index> potentiallyUnwrittenIndices,                                                                                          MetaData previousMetaData, MetaData newMetaData);1541092382;Loads the current meta state for each index in the new cluster state and checks if it has to be persisted._Each index state that should be written to disk will be returned. This is only run for data only nodes._It will return only the states for indices that actually have a shard allocated on the current node.__@param previouslyWrittenIndices    A list of indices for which the state was already written before_@param potentiallyUnwrittenIndices The list of indices for which state should potentially be written_@param previousMetaData            The last meta data we know of. meta data for all indices in previouslyWrittenIndices list is_persisted now_@param newMetaData                 The new metadata_@return iterable over all indices states that should be written to disk;public static Iterable<GatewayMetaState.IndexMetaWriteInfo> resolveStatesToBeWritten(Set<Index> previouslyWrittenIndices,_                                                                                         Set<Index> potentiallyUnwrittenIndices,_                                                                                         MetaData previousMetaData, MetaData newMetaData) {_        List<GatewayMetaState.IndexMetaWriteInfo> indicesToWrite = new ArrayList<>()__        for (Index index : potentiallyUnwrittenIndices) {_            IndexMetaData newIndexMetaData = newMetaData.getIndexSafe(index)__            IndexMetaData previousIndexMetaData = previousMetaData == null ? null : previousMetaData.index(index)__            String writeReason = null__            if (previouslyWrittenIndices.contains(index) == false || previousIndexMetaData == null) {_                writeReason = "freshly created"__            } else if (previousIndexMetaData.getVersion() != newIndexMetaData.getVersion()) {_                writeReason = "version changed from [" + previousIndexMetaData.getVersion() + "] to [" +_                    newIndexMetaData.getVersion() + "]"__            }_            if (writeReason != null) {_                indicesToWrite.add(new GatewayMetaState.IndexMetaWriteInfo(newIndexMetaData, previousIndexMetaData, writeReason))__            }_        }_        return indicesToWrite__    };loads,the,current,meta,state,for,each,index,in,the,new,cluster,state,and,checks,if,it,has,to,be,persisted,each,index,state,that,should,be,written,to,disk,will,be,returned,this,is,only,run,for,data,only,nodes,it,will,return,only,the,states,for,indices,that,actually,have,a,shard,allocated,on,the,current,node,param,previously,written,indices,a,list,of,indices,for,which,the,state,was,already,written,before,param,potentially,unwritten,indices,the,list,of,indices,for,which,state,should,potentially,be,written,param,previous,meta,data,the,last,meta,data,we,know,of,meta,data,for,all,indices,in,previously,written,indices,list,is,persisted,now,param,new,meta,data,the,new,metadata,return,iterable,over,all,indices,states,that,should,be,written,to,disk;public,static,iterable,gateway,meta,state,index,meta,write,info,resolve,states,to,be,written,set,index,previously,written,indices,set,index,potentially,unwritten,indices,meta,data,previous,meta,data,meta,data,new,meta,data,list,gateway,meta,state,index,meta,write,info,indices,to,write,new,array,list,for,index,index,potentially,unwritten,indices,index,meta,data,new,index,meta,data,new,meta,data,get,index,safe,index,index,meta,data,previous,index,meta,data,previous,meta,data,null,null,previous,meta,data,index,index,string,write,reason,null,if,previously,written,indices,contains,index,false,previous,index,meta,data,null,write,reason,freshly,created,else,if,previous,index,meta,data,get,version,new,index,meta,data,get,version,write,reason,version,changed,from,previous,index,meta,data,get,version,to,new,index,meta,data,get,version,if,write,reason,null,indices,to,write,add,new,gateway,meta,state,index,meta,write,info,new,index,meta,data,previous,index,meta,data,write,reason,return,indices,to,write
GatewayMetaState -> public static Iterable<GatewayMetaState.IndexMetaWriteInfo> resolveStatesToBeWritten(Set<Index> previouslyWrittenIndices,                                                                                          Set<Index> potentiallyUnwrittenIndices,                                                                                          MetaData previousMetaData, MetaData newMetaData);1542402632;Loads the current meta state for each index in the new cluster state and checks if it has to be persisted._Each index state that should be written to disk will be returned. This is only run for data only nodes._It will return only the states for indices that actually have a shard allocated on the current node.__@param previouslyWrittenIndices    A list of indices for which the state was already written before_@param potentiallyUnwrittenIndices The list of indices for which state should potentially be written_@param previousMetaData            The last meta data we know of. meta data for all indices in previouslyWrittenIndices list is_persisted now_@param newMetaData                 The new metadata_@return iterable over all indices states that should be written to disk;public static Iterable<GatewayMetaState.IndexMetaWriteInfo> resolveStatesToBeWritten(Set<Index> previouslyWrittenIndices,_                                                                                         Set<Index> potentiallyUnwrittenIndices,_                                                                                         MetaData previousMetaData, MetaData newMetaData) {_        List<GatewayMetaState.IndexMetaWriteInfo> indicesToWrite = new ArrayList<>()__        for (Index index : potentiallyUnwrittenIndices) {_            IndexMetaData newIndexMetaData = newMetaData.getIndexSafe(index)__            IndexMetaData previousIndexMetaData = previousMetaData == null ? null : previousMetaData.index(index)__            String writeReason = null__            if (previouslyWrittenIndices.contains(index) == false || previousIndexMetaData == null) {_                writeReason = "freshly created"__            } else if (previousIndexMetaData.getVersion() != newIndexMetaData.getVersion()) {_                writeReason = "version changed from [" + previousIndexMetaData.getVersion() + "] to [" +_                    newIndexMetaData.getVersion() + "]"__            }_            if (writeReason != null) {_                indicesToWrite.add(new GatewayMetaState.IndexMetaWriteInfo(newIndexMetaData, previousIndexMetaData, writeReason))__            }_        }_        return indicesToWrite__    };loads,the,current,meta,state,for,each,index,in,the,new,cluster,state,and,checks,if,it,has,to,be,persisted,each,index,state,that,should,be,written,to,disk,will,be,returned,this,is,only,run,for,data,only,nodes,it,will,return,only,the,states,for,indices,that,actually,have,a,shard,allocated,on,the,current,node,param,previously,written,indices,a,list,of,indices,for,which,the,state,was,already,written,before,param,potentially,unwritten,indices,the,list,of,indices,for,which,state,should,potentially,be,written,param,previous,meta,data,the,last,meta,data,we,know,of,meta,data,for,all,indices,in,previously,written,indices,list,is,persisted,now,param,new,meta,data,the,new,metadata,return,iterable,over,all,indices,states,that,should,be,written,to,disk;public,static,iterable,gateway,meta,state,index,meta,write,info,resolve,states,to,be,written,set,index,previously,written,indices,set,index,potentially,unwritten,indices,meta,data,previous,meta,data,meta,data,new,meta,data,list,gateway,meta,state,index,meta,write,info,indices,to,write,new,array,list,for,index,index,potentially,unwritten,indices,index,meta,data,new,index,meta,data,new,meta,data,get,index,safe,index,index,meta,data,previous,index,meta,data,previous,meta,data,null,null,previous,meta,data,index,index,string,write,reason,null,if,previously,written,indices,contains,index,false,previous,index,meta,data,null,write,reason,freshly,created,else,if,previous,index,meta,data,get,version,new,index,meta,data,get,version,write,reason,version,changed,from,previous,index,meta,data,get,version,to,new,index,meta,data,get,version,if,write,reason,null,indices,to,write,add,new,gateway,meta,state,index,meta,write,info,new,index,meta,data,previous,index,meta,data,write,reason,return,indices,to,write
GatewayMetaState -> public static List<IndexMetaDataAction> resolveIndexMetaDataActions(Map<Index, Long> previouslyWrittenIndices,                                                                         Set<Index> relevantIndices,                                                                         MetaData previousMetaData,                                                                         MetaData newMetaData);1544081506;Returns list of {@link IndexMetaDataAction} for each relevant index._For each relevant index there are 3 options:_<ol>_<li>_{@link KeepPreviousGeneration} - index metadata is already stored to disk and index metadata version is not changed, no_action is required._</li>_<li>_{@link WriteNewIndexMetaData} - there is no index metadata on disk and index metadata for this index should be written._</li>_<li>_{@link WriteChangedIndexMetaData} - index metadata is already on disk, but index metadata version has changed. Updated_index metadata should be written to disk._</li>_</ol>__@param previouslyWrittenIndices A list of indices for which the state was already written before_@param relevantIndices          The list of indices for which state should potentially be written_@param previousMetaData         The last meta data we know of_@param newMetaData              The new metadata_@return list of {@link IndexMetaDataAction} for each relevant index.;public static List<IndexMetaDataAction> resolveIndexMetaDataActions(Map<Index, Long> previouslyWrittenIndices,_                                                                        Set<Index> relevantIndices,_                                                                        MetaData previousMetaData,_                                                                        MetaData newMetaData) {_        List<IndexMetaDataAction> actions = new ArrayList<>()__        for (Index index : relevantIndices) {_            IndexMetaData newIndexMetaData = newMetaData.getIndexSafe(index)__            IndexMetaData previousIndexMetaData = previousMetaData == null ? null : previousMetaData.index(index)___            if (previouslyWrittenIndices.containsKey(index) == false || previousIndexMetaData == null) {_                actions.add(new WriteNewIndexMetaData(newIndexMetaData))__            } else if (previousIndexMetaData.getVersion() != newIndexMetaData.getVersion()) {_                actions.add(new WriteChangedIndexMetaData(previousIndexMetaData, newIndexMetaData))__            } else {_                actions.add(new KeepPreviousGeneration(index, previouslyWrittenIndices.get(index)))__            }_        }_        return actions__    };returns,list,of,link,index,meta,data,action,for,each,relevant,index,for,each,relevant,index,there,are,3,options,ol,li,link,keep,previous,generation,index,metadata,is,already,stored,to,disk,and,index,metadata,version,is,not,changed,no,action,is,required,li,li,link,write,new,index,meta,data,there,is,no,index,metadata,on,disk,and,index,metadata,for,this,index,should,be,written,li,li,link,write,changed,index,meta,data,index,metadata,is,already,on,disk,but,index,metadata,version,has,changed,updated,index,metadata,should,be,written,to,disk,li,ol,param,previously,written,indices,a,list,of,indices,for,which,the,state,was,already,written,before,param,relevant,indices,the,list,of,indices,for,which,state,should,potentially,be,written,param,previous,meta,data,the,last,meta,data,we,know,of,param,new,meta,data,the,new,metadata,return,list,of,link,index,meta,data,action,for,each,relevant,index;public,static,list,index,meta,data,action,resolve,index,meta,data,actions,map,index,long,previously,written,indices,set,index,relevant,indices,meta,data,previous,meta,data,meta,data,new,meta,data,list,index,meta,data,action,actions,new,array,list,for,index,index,relevant,indices,index,meta,data,new,index,meta,data,new,meta,data,get,index,safe,index,index,meta,data,previous,index,meta,data,previous,meta,data,null,null,previous,meta,data,index,index,if,previously,written,indices,contains,key,index,false,previous,index,meta,data,null,actions,add,new,write,new,index,meta,data,new,index,meta,data,else,if,previous,index,meta,data,get,version,new,index,meta,data,get,version,actions,add,new,write,changed,index,meta,data,previous,index,meta,data,new,index,meta,data,else,actions,add,new,keep,previous,generation,index,previously,written,indices,get,index,return,actions
GatewayMetaState -> public static List<IndexMetaDataAction> resolveIndexMetaDataActions(Map<Index, Long> previouslyWrittenIndices,                                                                         Set<Index> relevantIndices,                                                                         MetaData previousMetaData,                                                                         MetaData newMetaData);1544112122;Returns list of {@link IndexMetaDataAction} for each relevant index._For each relevant index there are 3 options:_<ol>_<li>_{@link KeepPreviousGeneration} - index metadata is already stored to disk and index metadata version is not changed, no_action is required._</li>_<li>_{@link WriteNewIndexMetaData} - there is no index metadata on disk and index metadata for this index should be written._</li>_<li>_{@link WriteChangedIndexMetaData} - index metadata is already on disk, but index metadata version has changed. Updated_index metadata should be written to disk._</li>_</ol>__@param previouslyWrittenIndices A list of indices for which the state was already written before_@param relevantIndices          The list of indices for which state should potentially be written_@param previousMetaData         The last meta data we know of_@param newMetaData              The new metadata_@return list of {@link IndexMetaDataAction} for each relevant index.;public static List<IndexMetaDataAction> resolveIndexMetaDataActions(Map<Index, Long> previouslyWrittenIndices,_                                                                        Set<Index> relevantIndices,_                                                                        MetaData previousMetaData,_                                                                        MetaData newMetaData) {_        List<IndexMetaDataAction> actions = new ArrayList<>()__        for (Index index : relevantIndices) {_            IndexMetaData newIndexMetaData = newMetaData.getIndexSafe(index)__            IndexMetaData previousIndexMetaData = previousMetaData == null ? null : previousMetaData.index(index)___            if (previouslyWrittenIndices.containsKey(index) == false || previousIndexMetaData == null) {_                actions.add(new WriteNewIndexMetaData(newIndexMetaData))__            } else if (previousIndexMetaData.getVersion() != newIndexMetaData.getVersion()) {_                actions.add(new WriteChangedIndexMetaData(previousIndexMetaData, newIndexMetaData))__            } else {_                actions.add(new KeepPreviousGeneration(index, previouslyWrittenIndices.get(index)))__            }_        }_        return actions__    };returns,list,of,link,index,meta,data,action,for,each,relevant,index,for,each,relevant,index,there,are,3,options,ol,li,link,keep,previous,generation,index,metadata,is,already,stored,to,disk,and,index,metadata,version,is,not,changed,no,action,is,required,li,li,link,write,new,index,meta,data,there,is,no,index,metadata,on,disk,and,index,metadata,for,this,index,should,be,written,li,li,link,write,changed,index,meta,data,index,metadata,is,already,on,disk,but,index,metadata,version,has,changed,updated,index,metadata,should,be,written,to,disk,li,ol,param,previously,written,indices,a,list,of,indices,for,which,the,state,was,already,written,before,param,relevant,indices,the,list,of,indices,for,which,state,should,potentially,be,written,param,previous,meta,data,the,last,meta,data,we,know,of,param,new,meta,data,the,new,metadata,return,list,of,link,index,meta,data,action,for,each,relevant,index;public,static,list,index,meta,data,action,resolve,index,meta,data,actions,map,index,long,previously,written,indices,set,index,relevant,indices,meta,data,previous,meta,data,meta,data,new,meta,data,list,index,meta,data,action,actions,new,array,list,for,index,index,relevant,indices,index,meta,data,new,index,meta,data,new,meta,data,get,index,safe,index,index,meta,data,previous,index,meta,data,previous,meta,data,null,null,previous,meta,data,index,index,if,previously,written,indices,contains,key,index,false,previous,index,meta,data,null,actions,add,new,write,new,index,meta,data,new,index,meta,data,else,if,previous,index,meta,data,get,version,new,index,meta,data,get,version,actions,add,new,write,changed,index,meta,data,previous,index,meta,data,new,index,meta,data,else,actions,add,new,keep,previous,generation,index,previously,written,indices,get,index,return,actions
GatewayMetaState -> public static List<IndexMetaDataAction> resolveIndexMetaDataActions(Map<Index, Long> previouslyWrittenIndices,                                                                         Set<Index> relevantIndices,                                                                         MetaData previousMetaData,                                                                         MetaData newMetaData);1544113208;Returns list of {@link IndexMetaDataAction} for each relevant index._For each relevant index there are 3 options:_<ol>_<li>_{@link KeepPreviousGeneration} - index metadata is already stored to disk and index metadata version is not changed, no_action is required._</li>_<li>_{@link WriteNewIndexMetaData} - there is no index metadata on disk and index metadata for this index should be written._</li>_<li>_{@link WriteChangedIndexMetaData} - index metadata is already on disk, but index metadata version has changed. Updated_index metadata should be written to disk._</li>_</ol>__@param previouslyWrittenIndices A list of indices for which the state was already written before_@param relevantIndices          The list of indices for which state should potentially be written_@param previousMetaData         The last meta data we know of_@param newMetaData              The new metadata_@return list of {@link IndexMetaDataAction} for each relevant index.;public static List<IndexMetaDataAction> resolveIndexMetaDataActions(Map<Index, Long> previouslyWrittenIndices,_                                                                        Set<Index> relevantIndices,_                                                                        MetaData previousMetaData,_                                                                        MetaData newMetaData) {_        List<IndexMetaDataAction> actions = new ArrayList<>()__        for (Index index : relevantIndices) {_            IndexMetaData newIndexMetaData = newMetaData.getIndexSafe(index)__            IndexMetaData previousIndexMetaData = previousMetaData == null ? null : previousMetaData.index(index)___            if (previouslyWrittenIndices.containsKey(index) == false || previousIndexMetaData == null) {_                actions.add(new WriteNewIndexMetaData(newIndexMetaData))__            } else if (previousIndexMetaData.getVersion() != newIndexMetaData.getVersion()) {_                actions.add(new WriteChangedIndexMetaData(previousIndexMetaData, newIndexMetaData))__            } else {_                actions.add(new KeepPreviousGeneration(index, previouslyWrittenIndices.get(index)))__            }_        }_        return actions__    };returns,list,of,link,index,meta,data,action,for,each,relevant,index,for,each,relevant,index,there,are,3,options,ol,li,link,keep,previous,generation,index,metadata,is,already,stored,to,disk,and,index,metadata,version,is,not,changed,no,action,is,required,li,li,link,write,new,index,meta,data,there,is,no,index,metadata,on,disk,and,index,metadata,for,this,index,should,be,written,li,li,link,write,changed,index,meta,data,index,metadata,is,already,on,disk,but,index,metadata,version,has,changed,updated,index,metadata,should,be,written,to,disk,li,ol,param,previously,written,indices,a,list,of,indices,for,which,the,state,was,already,written,before,param,relevant,indices,the,list,of,indices,for,which,state,should,potentially,be,written,param,previous,meta,data,the,last,meta,data,we,know,of,param,new,meta,data,the,new,metadata,return,list,of,link,index,meta,data,action,for,each,relevant,index;public,static,list,index,meta,data,action,resolve,index,meta,data,actions,map,index,long,previously,written,indices,set,index,relevant,indices,meta,data,previous,meta,data,meta,data,new,meta,data,list,index,meta,data,action,actions,new,array,list,for,index,index,relevant,indices,index,meta,data,new,index,meta,data,new,meta,data,get,index,safe,index,index,meta,data,previous,index,meta,data,previous,meta,data,null,null,previous,meta,data,index,index,if,previously,written,indices,contains,key,index,false,previous,index,meta,data,null,actions,add,new,write,new,index,meta,data,new,index,meta,data,else,if,previous,index,meta,data,get,version,new,index,meta,data,get,version,actions,add,new,write,changed,index,meta,data,previous,index,meta,data,new,index,meta,data,else,actions,add,new,keep,previous,generation,index,previously,written,indices,get,index,return,actions
GatewayMetaState -> public static List<IndexMetaDataAction> resolveIndexMetaDataActions(Map<Index, Long> previouslyWrittenIndices,                                                                         Set<Index> relevantIndices,                                                                         MetaData previousMetaData,                                                                         MetaData newMetaData);1545665168;Returns list of {@link IndexMetaDataAction} for each relevant index._For each relevant index there are 3 options:_<ol>_<li>_{@link KeepPreviousGeneration} - index metadata is already stored to disk and index metadata version is not changed, no_action is required._</li>_<li>_{@link WriteNewIndexMetaData} - there is no index metadata on disk and index metadata for this index should be written._</li>_<li>_{@link WriteChangedIndexMetaData} - index metadata is already on disk, but index metadata version has changed. Updated_index metadata should be written to disk._</li>_</ol>__@param previouslyWrittenIndices A list of indices for which the state was already written before_@param relevantIndices          The list of indices for which state should potentially be written_@param previousMetaData         The last meta data we know of_@param newMetaData              The new metadata_@return list of {@link IndexMetaDataAction} for each relevant index.;public static List<IndexMetaDataAction> resolveIndexMetaDataActions(Map<Index, Long> previouslyWrittenIndices,_                                                                        Set<Index> relevantIndices,_                                                                        MetaData previousMetaData,_                                                                        MetaData newMetaData) {_        List<IndexMetaDataAction> actions = new ArrayList<>()__        for (Index index : relevantIndices) {_            IndexMetaData newIndexMetaData = newMetaData.getIndexSafe(index)__            IndexMetaData previousIndexMetaData = previousMetaData == null ? null : previousMetaData.index(index)___            if (previouslyWrittenIndices.containsKey(index) == false || previousIndexMetaData == null) {_                actions.add(new WriteNewIndexMetaData(newIndexMetaData))__            } else if (previousIndexMetaData.getVersion() != newIndexMetaData.getVersion()) {_                actions.add(new WriteChangedIndexMetaData(previousIndexMetaData, newIndexMetaData))__            } else {_                actions.add(new KeepPreviousGeneration(index, previouslyWrittenIndices.get(index)))__            }_        }_        return actions__    };returns,list,of,link,index,meta,data,action,for,each,relevant,index,for,each,relevant,index,there,are,3,options,ol,li,link,keep,previous,generation,index,metadata,is,already,stored,to,disk,and,index,metadata,version,is,not,changed,no,action,is,required,li,li,link,write,new,index,meta,data,there,is,no,index,metadata,on,disk,and,index,metadata,for,this,index,should,be,written,li,li,link,write,changed,index,meta,data,index,metadata,is,already,on,disk,but,index,metadata,version,has,changed,updated,index,metadata,should,be,written,to,disk,li,ol,param,previously,written,indices,a,list,of,indices,for,which,the,state,was,already,written,before,param,relevant,indices,the,list,of,indices,for,which,state,should,potentially,be,written,param,previous,meta,data,the,last,meta,data,we,know,of,param,new,meta,data,the,new,metadata,return,list,of,link,index,meta,data,action,for,each,relevant,index;public,static,list,index,meta,data,action,resolve,index,meta,data,actions,map,index,long,previously,written,indices,set,index,relevant,indices,meta,data,previous,meta,data,meta,data,new,meta,data,list,index,meta,data,action,actions,new,array,list,for,index,index,relevant,indices,index,meta,data,new,index,meta,data,new,meta,data,get,index,safe,index,index,meta,data,previous,index,meta,data,previous,meta,data,null,null,previous,meta,data,index,index,if,previously,written,indices,contains,key,index,false,previous,index,meta,data,null,actions,add,new,write,new,index,meta,data,new,index,meta,data,else,if,previous,index,meta,data,get,version,new,index,meta,data,get,version,actions,add,new,write,changed,index,meta,data,previous,index,meta,data,new,index,meta,data,else,actions,add,new,keep,previous,generation,index,previously,written,indices,get,index,return,actions
GatewayMetaState -> public static List<IndexMetaDataAction> resolveIndexMetaDataActions(Map<Index, Long> previouslyWrittenIndices,                                                                         Set<Index> relevantIndices,                                                                         MetaData previousMetaData,                                                                         MetaData newMetaData);1545945527;Returns list of {@link IndexMetaDataAction} for each relevant index._For each relevant index there are 3 options:_<ol>_<li>_{@link KeepPreviousGeneration} - index metadata is already stored to disk and index metadata version is not changed, no_action is required._</li>_<li>_{@link WriteNewIndexMetaData} - there is no index metadata on disk and index metadata for this index should be written._</li>_<li>_{@link WriteChangedIndexMetaData} - index metadata is already on disk, but index metadata version has changed. Updated_index metadata should be written to disk._</li>_</ol>__@param previouslyWrittenIndices A list of indices for which the state was already written before_@param relevantIndices          The list of indices for which state should potentially be written_@param previousMetaData         The last meta data we know of_@param newMetaData              The new metadata_@return list of {@link IndexMetaDataAction} for each relevant index.;public static List<IndexMetaDataAction> resolveIndexMetaDataActions(Map<Index, Long> previouslyWrittenIndices,_                                                                        Set<Index> relevantIndices,_                                                                        MetaData previousMetaData,_                                                                        MetaData newMetaData) {_        List<IndexMetaDataAction> actions = new ArrayList<>()__        for (Index index : relevantIndices) {_            IndexMetaData newIndexMetaData = newMetaData.getIndexSafe(index)__            IndexMetaData previousIndexMetaData = previousMetaData == null ? null : previousMetaData.index(index)___            if (previouslyWrittenIndices.containsKey(index) == false || previousIndexMetaData == null) {_                actions.add(new WriteNewIndexMetaData(newIndexMetaData))__            } else if (previousIndexMetaData.getVersion() != newIndexMetaData.getVersion()) {_                actions.add(new WriteChangedIndexMetaData(previousIndexMetaData, newIndexMetaData))__            } else {_                actions.add(new KeepPreviousGeneration(index, previouslyWrittenIndices.get(index)))__            }_        }_        return actions__    };returns,list,of,link,index,meta,data,action,for,each,relevant,index,for,each,relevant,index,there,are,3,options,ol,li,link,keep,previous,generation,index,metadata,is,already,stored,to,disk,and,index,metadata,version,is,not,changed,no,action,is,required,li,li,link,write,new,index,meta,data,there,is,no,index,metadata,on,disk,and,index,metadata,for,this,index,should,be,written,li,li,link,write,changed,index,meta,data,index,metadata,is,already,on,disk,but,index,metadata,version,has,changed,updated,index,metadata,should,be,written,to,disk,li,ol,param,previously,written,indices,a,list,of,indices,for,which,the,state,was,already,written,before,param,relevant,indices,the,list,of,indices,for,which,state,should,potentially,be,written,param,previous,meta,data,the,last,meta,data,we,know,of,param,new,meta,data,the,new,metadata,return,list,of,link,index,meta,data,action,for,each,relevant,index;public,static,list,index,meta,data,action,resolve,index,meta,data,actions,map,index,long,previously,written,indices,set,index,relevant,indices,meta,data,previous,meta,data,meta,data,new,meta,data,list,index,meta,data,action,actions,new,array,list,for,index,index,relevant,indices,index,meta,data,new,index,meta,data,new,meta,data,get,index,safe,index,index,meta,data,previous,index,meta,data,previous,meta,data,null,null,previous,meta,data,index,index,if,previously,written,indices,contains,key,index,false,previous,index,meta,data,null,actions,add,new,write,new,index,meta,data,new,index,meta,data,else,if,previous,index,meta,data,get,version,new,index,meta,data,get,version,actions,add,new,write,changed,index,meta,data,previous,index,meta,data,new,index,meta,data,else,actions,add,new,keep,previous,generation,index,previously,written,indices,get,index,return,actions
GatewayMetaState -> public static List<IndexMetaDataAction> resolveIndexMetaDataActions(Map<Index, Long> previouslyWrittenIndices,                                                                         Set<Index> relevantIndices,                                                                         MetaData previousMetaData,                                                                         MetaData newMetaData);1547577205;Returns list of {@link IndexMetaDataAction} for each relevant index._For each relevant index there are 3 options:_<ol>_<li>_{@link KeepPreviousGeneration} - index metadata is already stored to disk and index metadata version is not changed, no_action is required._</li>_<li>_{@link WriteNewIndexMetaData} - there is no index metadata on disk and index metadata for this index should be written._</li>_<li>_{@link WriteChangedIndexMetaData} - index metadata is already on disk, but index metadata version has changed. Updated_index metadata should be written to disk._</li>_</ol>__@param previouslyWrittenIndices A list of indices for which the state was already written before_@param relevantIndices          The list of indices for which state should potentially be written_@param previousMetaData         The last meta data we know of_@param newMetaData              The new metadata_@return list of {@link IndexMetaDataAction} for each relevant index.;public static List<IndexMetaDataAction> resolveIndexMetaDataActions(Map<Index, Long> previouslyWrittenIndices,_                                                                        Set<Index> relevantIndices,_                                                                        MetaData previousMetaData,_                                                                        MetaData newMetaData) {_        List<IndexMetaDataAction> actions = new ArrayList<>()__        for (Index index : relevantIndices) {_            IndexMetaData newIndexMetaData = newMetaData.getIndexSafe(index)__            IndexMetaData previousIndexMetaData = previousMetaData == null ? null : previousMetaData.index(index)___            if (previouslyWrittenIndices.containsKey(index) == false || previousIndexMetaData == null) {_                actions.add(new WriteNewIndexMetaData(newIndexMetaData))__            } else if (previousIndexMetaData.getVersion() != newIndexMetaData.getVersion()) {_                actions.add(new WriteChangedIndexMetaData(previousIndexMetaData, newIndexMetaData))__            } else {_                actions.add(new KeepPreviousGeneration(index, previouslyWrittenIndices.get(index)))__            }_        }_        return actions__    };returns,list,of,link,index,meta,data,action,for,each,relevant,index,for,each,relevant,index,there,are,3,options,ol,li,link,keep,previous,generation,index,metadata,is,already,stored,to,disk,and,index,metadata,version,is,not,changed,no,action,is,required,li,li,link,write,new,index,meta,data,there,is,no,index,metadata,on,disk,and,index,metadata,for,this,index,should,be,written,li,li,link,write,changed,index,meta,data,index,metadata,is,already,on,disk,but,index,metadata,version,has,changed,updated,index,metadata,should,be,written,to,disk,li,ol,param,previously,written,indices,a,list,of,indices,for,which,the,state,was,already,written,before,param,relevant,indices,the,list,of,indices,for,which,state,should,potentially,be,written,param,previous,meta,data,the,last,meta,data,we,know,of,param,new,meta,data,the,new,metadata,return,list,of,link,index,meta,data,action,for,each,relevant,index;public,static,list,index,meta,data,action,resolve,index,meta,data,actions,map,index,long,previously,written,indices,set,index,relevant,indices,meta,data,previous,meta,data,meta,data,new,meta,data,list,index,meta,data,action,actions,new,array,list,for,index,index,relevant,indices,index,meta,data,new,index,meta,data,new,meta,data,get,index,safe,index,index,meta,data,previous,index,meta,data,previous,meta,data,null,null,previous,meta,data,index,index,if,previously,written,indices,contains,key,index,false,previous,index,meta,data,null,actions,add,new,write,new,index,meta,data,new,index,meta,data,else,if,previous,index,meta,data,get,version,new,index,meta,data,get,version,actions,add,new,write,changed,index,meta,data,previous,index,meta,data,new,index,meta,data,else,actions,add,new,keep,previous,generation,index,previously,written,indices,get,index,return,actions
GatewayMetaState -> IndexMetaDataAction -> Index getIndex()_;1544081506;@return index for index metadata.;Index getIndex()_;return,index,for,index,metadata;index,get,index
GatewayMetaState -> IndexMetaDataAction -> Index getIndex()_;1544112122;@return index for index metadata.;Index getIndex()_;return,index,for,index,metadata;index,get,index
GatewayMetaState -> IndexMetaDataAction -> Index getIndex()_;1544113208;@return index for index metadata.;Index getIndex()_;return,index,for,index,metadata;index,get,index
GatewayMetaState -> IndexMetaDataAction -> Index getIndex()_;1545665168;@return index for index metadata.;Index getIndex()_;return,index,for,index,metadata;index,get,index
GatewayMetaState -> IndexMetaDataAction -> Index getIndex()_;1545945527;@return index for index metadata.;Index getIndex()_;return,index,for,index,metadata;index,get,index
GatewayMetaState -> IndexMetaDataAction -> Index getIndex()_;1547577205;@return index for index metadata.;Index getIndex()_;return,index,for,index,metadata;index,get,index
GatewayMetaState -> IndexMetaDataAction -> long execute(AtomicClusterStateWriter writer) throws WriteStateException_;1544081506;Executes this action using provided {@link AtomicClusterStateWriter}.__@return new index metadata state generation, to be used in manifest file._@throws WriteStateException if exception occurs.;long execute(AtomicClusterStateWriter writer) throws WriteStateException_;executes,this,action,using,provided,link,atomic,cluster,state,writer,return,new,index,metadata,state,generation,to,be,used,in,manifest,file,throws,write,state,exception,if,exception,occurs;long,execute,atomic,cluster,state,writer,writer,throws,write,state,exception
GatewayMetaState -> IndexMetaDataAction -> long execute(AtomicClusterStateWriter writer) throws WriteStateException_;1544112122;Executes this action using provided {@link AtomicClusterStateWriter}.__@return new index metadata state generation, to be used in manifest file._@throws WriteStateException if exception occurs.;long execute(AtomicClusterStateWriter writer) throws WriteStateException_;executes,this,action,using,provided,link,atomic,cluster,state,writer,return,new,index,metadata,state,generation,to,be,used,in,manifest,file,throws,write,state,exception,if,exception,occurs;long,execute,atomic,cluster,state,writer,writer,throws,write,state,exception
GatewayMetaState -> IndexMetaDataAction -> long execute(AtomicClusterStateWriter writer) throws WriteStateException_;1544113208;Executes this action using provided {@link AtomicClusterStateWriter}.__@return new index metadata state generation, to be used in manifest file._@throws WriteStateException if exception occurs.;long execute(AtomicClusterStateWriter writer) throws WriteStateException_;executes,this,action,using,provided,link,atomic,cluster,state,writer,return,new,index,metadata,state,generation,to,be,used,in,manifest,file,throws,write,state,exception,if,exception,occurs;long,execute,atomic,cluster,state,writer,writer,throws,write,state,exception
GatewayMetaState -> IndexMetaDataAction -> long execute(AtomicClusterStateWriter writer) throws WriteStateException_;1545665168;Executes this action using provided {@link AtomicClusterStateWriter}.__@return new index metadata state generation, to be used in manifest file._@throws WriteStateException if exception occurs.;long execute(AtomicClusterStateWriter writer) throws WriteStateException_;executes,this,action,using,provided,link,atomic,cluster,state,writer,return,new,index,metadata,state,generation,to,be,used,in,manifest,file,throws,write,state,exception,if,exception,occurs;long,execute,atomic,cluster,state,writer,writer,throws,write,state,exception
GatewayMetaState -> IndexMetaDataAction -> long execute(AtomicClusterStateWriter writer) throws WriteStateException_;1545945527;Executes this action using provided {@link AtomicClusterStateWriter}.__@return new index metadata state generation, to be used in manifest file._@throws WriteStateException if exception occurs.;long execute(AtomicClusterStateWriter writer) throws WriteStateException_;executes,this,action,using,provided,link,atomic,cluster,state,writer,return,new,index,metadata,state,generation,to,be,used,in,manifest,file,throws,write,state,exception,if,exception,occurs;long,execute,atomic,cluster,state,writer,writer,throws,write,state,exception
GatewayMetaState -> IndexMetaDataAction -> long execute(AtomicClusterStateWriter writer) throws WriteStateException_;1547577205;Executes this action using provided {@link AtomicClusterStateWriter}.__@return new index metadata state generation, to be used in manifest file._@throws WriteStateException if exception occurs.;long execute(AtomicClusterStateWriter writer) throws WriteStateException_;executes,this,action,using,provided,link,atomic,cluster,state,writer,return,new,index,metadata,state,generation,to,be,used,in,manifest,file,throws,write,state,exception,if,exception,occurs;long,execute,atomic,cluster,state,writer,writer,throws,write,state,exception
