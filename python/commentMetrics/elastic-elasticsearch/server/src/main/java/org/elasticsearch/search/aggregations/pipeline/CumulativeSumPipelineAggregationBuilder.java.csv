commented;modifiers;parameterAmount;loc;comment;code
false;protected,final;1;4;;@Override protected final void doWriteTo(StreamOutput out) throws IOException {     out.writeOptionalString(format). }
true;public;1;7;/**  * Sets the format to use on the output of this aggregation.  */ ;/**  * Sets the format to use on the output of this aggregation.  */ public CumulativeSumPipelineAggregationBuilder format(String format) {     if (format == null) {         throw new IllegalArgumentException("[format] must not be null: [" + name + "]").     }     this.format = format.     return this. }
true;public;0;3;/**  * Gets the format to use on the output of this aggregation.  */ ;/**  * Gets the format to use on the output of this aggregation.  */ public String format() {     return format. }
false;protected;0;7;;protected DocValueFormat formatter() {     if (format != null) {         return new DocValueFormat.Decimal(format).     } else {         return DocValueFormat.RAW.     } }
false;protected;1;4;;@Override protected PipelineAggregator createInternal(Map<String, Object> metaData) throws IOException {     return new CumulativeSumPipelineAggregator(name, bucketsPaths, formatter(), metaData). }
false;public;3;10;;@Override public void doValidate(AggregatorFactory<?> parent, Collection<AggregationBuilder> aggFactories, Collection<PipelineAggregationBuilder> pipelineAggregatorFactories) {     if (bucketsPaths.length != 1) {         throw new IllegalStateException(BUCKETS_PATH.getPreferredName() + " must contain a single entry for aggregation [" + name + "]").     }     validateSequentiallyOrderedParentAggs(parent, NAME, name). }
false;protected,final;2;7;;@Override protected final XContentBuilder internalXContent(XContentBuilder builder, Params params) throws IOException {     if (format != null) {         builder.field(BucketMetricsParser.FORMAT.getPreferredName(), format).     }     return builder. }
false;public,static;2;49;;public static CumulativeSumPipelineAggregationBuilder parse(String pipelineAggregatorName, XContentParser parser) throws IOException {     XContentParser.Token token.     String currentFieldName = null.     String[] bucketsPaths = null.     String format = null.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token == XContentParser.Token.VALUE_STRING) {             if (FORMAT.match(currentFieldName, parser.getDeprecationHandler())) {                 format = parser.text().             } else if (BUCKETS_PATH.match(currentFieldName, parser.getDeprecationHandler())) {                 bucketsPaths = new String[] { parser.text() }.             } else {                 throw new ParsingException(parser.getTokenLocation(), "Unknown key for a " + token + " in [" + pipelineAggregatorName + "]: [" + currentFieldName + "].").             }         } else if (token == XContentParser.Token.START_ARRAY) {             if (BUCKETS_PATH.match(currentFieldName, parser.getDeprecationHandler())) {                 List<String> paths = new ArrayList<>().                 while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {                     String path = parser.text().                     paths.add(path).                 }                 bucketsPaths = paths.toArray(new String[paths.size()]).             } else {                 throw new ParsingException(parser.getTokenLocation(), "Unknown key for a " + token + " in [" + pipelineAggregatorName + "]: [" + currentFieldName + "].").             }         } else {             throw new ParsingException(parser.getTokenLocation(), "Unexpected token " + token + " in [" + pipelineAggregatorName + "].").         }     }     if (bucketsPaths == null) {         throw new ParsingException(parser.getTokenLocation(), "Missing required field [" + BUCKETS_PATH.getPreferredName() + "] for derivative aggregation [" + pipelineAggregatorName + "]").     }     CumulativeSumPipelineAggregationBuilder factory = new CumulativeSumPipelineAggregationBuilder(pipelineAggregatorName, bucketsPaths[0]).     if (format != null) {         factory.format(format).     }     return factory. }
false;protected;0;4;;@Override protected int doHashCode() {     return Objects.hash(format). }
false;protected;1;5;;@Override protected boolean doEquals(Object obj) {     CumulativeSumPipelineAggregationBuilder other = (CumulativeSumPipelineAggregationBuilder) obj.     return Objects.equals(format, other.format). }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
