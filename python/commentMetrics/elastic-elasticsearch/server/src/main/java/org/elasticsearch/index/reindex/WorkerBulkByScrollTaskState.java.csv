commented;modifiers;parameterAmount;loc;comment;code
false;public;0;17;;public BulkByScrollTask.Status getStatus() {     return new BulkByScrollTask.Status(sliceId, total.get(), updated.get(), created.get(), deleted.get(), batch.get(), versionConflicts.get(), noops.get(), bulkRetries.get(), searchRetries.get(), timeValueNanos(throttledNanos.get()), getRequestsPerSecond(), task.getReasonCancelled(), throttledUntil()). }
false;public;0;4;;public void handleCancel() {     // Drop the throttle to 0, immediately rescheduling any throttle operation so it will wake up and cancel itself.     rethrottle(Float.POSITIVE_INFINITY). }
false;public;1;3;;public void setTotal(long totalHits) {     total.set(totalHits). }
false;public;0;3;;public void countBatch() {     batch.incrementAndGet(). }
false;public;0;3;;public void countNoop() {     noops.incrementAndGet(). }
false;public;0;4;;@Override public long getCreated() {     return created.get(). }
false;public;0;3;;public void countCreated() {     created.incrementAndGet(). }
false;public;0;4;;@Override public long getUpdated() {     return updated.get(). }
false;public;0;3;;public void countUpdated() {     updated.incrementAndGet(). }
false;public;0;4;;@Override public long getDeleted() {     return deleted.get(). }
false;public;0;3;;public void countDeleted() {     deleted.incrementAndGet(). }
false;public;0;3;;public void countVersionConflict() {     versionConflicts.incrementAndGet(). }
false;public;0;3;;public void countBulkRetry() {     bulkRetries.incrementAndGet(). }
false;public;0;3;;public void countSearchRetry() {     searchRetries.incrementAndGet(). }
false;;0;3;;float getRequestsPerSecond() {     return requestsPerSecond. }
false;;0;10;;TimeValue throttledUntil() {     DelayedPrepareBulkRequest delayed = delayedPrepareBulkRequestReference.get().     if (delayed == null) {         return timeValueNanos(0).     }     if (delayed.scheduled == null) {         return timeValueNanos(0).     }     return timeValueNanos(max(0, delayed.scheduled.getDelay(TimeUnit.NANOSECONDS))). }
true;public;4;14;/**  * Schedule prepareBulkRequestRunnable to run after some delay. This is where throttling plugs into reindexing so the request can be  * rescheduled over and over again.  */ ;/**  * Schedule prepareBulkRequestRunnable to run after some delay. This is where throttling plugs into reindexing so the request can be  * rescheduled over and over again.  */ public void delayPrepareBulkRequest(ThreadPool threadPool, TimeValue lastBatchStartTime, int lastBatchSize, AbstractRunnable prepareBulkRequestRunnable) {     // Synchronize so we are less likely to schedule the same request twice.     synchronized (delayedPrepareBulkRequestReference) {         TimeValue delay = throttleWaitTime(lastBatchStartTime, timeValueNanos(System.nanoTime()), lastBatchSize).         logger.debug("[{}]: preparing bulk request for [{}]", task.getId(), delay).         try {             delayedPrepareBulkRequestReference.set(new DelayedPrepareBulkRequest(threadPool, getRequestsPerSecond(), delay, new RunOnce(prepareBulkRequestRunnable))).         } catch (EsRejectedExecutionException e) {             prepareBulkRequestRunnable.onRejection(e).         }     } }
false;public;3;5;;public TimeValue throttleWaitTime(TimeValue lastBatchStartTime, TimeValue now, int lastBatchSize) {     long earliestNextBatchStartTime = now.nanos() + (long) perfectlyThrottledBatchTime(lastBatchSize).     long waitTime = min(MAX_THROTTLE_WAIT_TIME.nanos(), max(0, earliestNextBatchStartTime - System.nanoTime())).     return timeValueNanos(waitTime). }
true;;1;11;/**  * How many nanoseconds should a batch of lastBatchSize have taken if it were perfectly throttled? Package private for testing.  */ ;/**  * How many nanoseconds should a batch of lastBatchSize have taken if it were perfectly throttled? Package private for testing.  */ float perfectlyThrottledBatchTime(int lastBatchSize) {     if (requestsPerSecond == Float.POSITIVE_INFINITY) {         return 0.     }     // requests     // ------------------- == seconds     // request per seconds     float targetBatchTimeInSeconds = lastBatchSize / requestsPerSecond.     // nanoseconds per seconds * seconds == nanoseconds     return TimeUnit.SECONDS.toNanos(1) * targetBatchTimeInSeconds. }
false;private;1;6;;private void setRequestsPerSecond(float requestsPerSecond) {     if (requestsPerSecond <= 0) {         throw new IllegalArgumentException("requests per second must be more than 0 but was [" + requestsPerSecond + "]").     }     this.requestsPerSecond = requestsPerSecond. }
true;public;1;15;/**  * Apply {@code newRequestsPerSecond} as the new rate limit for this task's search requests  */ ;/**  * Apply {@code newRequestsPerSecond} as the new rate limit for this task's search requests  */ public void rethrottle(float newRequestsPerSecond) {     synchronized (delayedPrepareBulkRequestReference) {         logger.debug("[{}]: rethrottling to [{}] requests per second", task.getId(), newRequestsPerSecond).         setRequestsPerSecond(newRequestsPerSecond).         DelayedPrepareBulkRequest delayedPrepareBulkRequest = this.delayedPrepareBulkRequestReference.get().         if (delayedPrepareBulkRequest == null) {             // No request has been queued so nothing to reschedule.             logger.debug("[{}]: skipping rescheduling because there is no scheduled task", task.getId()).             return.         }         this.delayedPrepareBulkRequestReference.set(delayedPrepareBulkRequest.rethrottle(newRequestsPerSecond)).     } }
false;;1;27;;DelayedPrepareBulkRequest rethrottle(float newRequestsPerSecond) {     if (newRequestsPerSecond < requestsPerSecond) {         /* The user is attempting to slow the request down. We'll let the                  * change in throttle take effect the next time we delay                  * prepareBulkRequest. We can't just reschedule the request further                  * out in the future because the bulk context might time out. */         logger.debug("[{}]: skipping rescheduling because the new throttle [{}] is slower than the old one [{}]", task.getId(), newRequestsPerSecond, requestsPerSecond).         return this.     }     long remainingDelay = scheduled.getDelay(TimeUnit.NANOSECONDS).     // Actually reschedule the task     if (scheduled == null || false == scheduled.cancel()) {         // Couldn't cancel, probably because the task has finished or been scheduled. Either way we have nothing to do here.         logger.debug("[{}]: skipping rescheduling because we couldn't cancel the task", task.getId()).         return this.     }     /* Strangely enough getting here doesn't mean that you actually              * cancelled the request, just that you probably did. If you stress              * test it you'll find that requests sneak through. So each request              * is given a runOnce boolean to prevent that. */     TimeValue newDelay = newDelay(remainingDelay, newRequestsPerSecond).     logger.debug("[{}]: rescheduling for [{}] in the future", task.getId(), newDelay).     return new DelayedPrepareBulkRequest(threadPool, requestsPerSecond, newDelay, command). }
true;;2;6;/**  * Scale back remaining delay to fit the new delay.  */ ;/**  * Scale back remaining delay to fit the new delay.  */ TimeValue newDelay(long remainingDelay, float newRequestsPerSecond) {     if (remainingDelay < 0) {         return timeValueNanos(0).     }     return timeValueNanos(round(remainingDelay * requestsPerSecond / newRequestsPerSecond)). }
