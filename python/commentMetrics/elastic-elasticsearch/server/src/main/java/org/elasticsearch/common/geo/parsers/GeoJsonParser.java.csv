commented;modifiers;parameterAmount;loc;comment;code
false;protected,static;2;94;;protected static ShapeBuilder parse(XContentParser parser, BaseGeoShapeFieldMapper shapeMapper) throws IOException {     GeoShapeType shapeType = null.     DistanceUnit.Distance radius = null.     CoordinateNode coordinateNode = null.     GeometryCollectionBuilder geometryCollections = null.     Orientation orientation = (shapeMapper == null) ? BaseGeoShapeFieldMapper.Defaults.ORIENTATION.value() : shapeMapper.orientation().     Explicit<Boolean> coerce = (shapeMapper == null) ? BaseGeoShapeFieldMapper.Defaults.COERCE : shapeMapper.coerce().     Explicit<Boolean> ignoreZValue = (shapeMapper == null) ? BaseGeoShapeFieldMapper.Defaults.IGNORE_Z_VALUE : shapeMapper.ignoreZValue().     String malformedException = null.     XContentParser.Token token.     try (XContentParser subParser = new XContentSubParser(parser)) {         while ((token = subParser.nextToken()) != XContentParser.Token.END_OBJECT) {             if (token == XContentParser.Token.FIELD_NAME) {                 String fieldName = subParser.currentName().                 if (ShapeParser.FIELD_TYPE.match(fieldName, subParser.getDeprecationHandler())) {                     subParser.nextToken().                     final GeoShapeType type = GeoShapeType.forName(subParser.text()).                     if (shapeType != null && shapeType.equals(type) == false) {                         malformedException = ShapeParser.FIELD_TYPE + " already parsed as [" + shapeType + "] cannot redefine as [" + type + "]".                     } else {                         shapeType = type.                     }                 } else if (ShapeParser.FIELD_COORDINATES.match(fieldName, subParser.getDeprecationHandler())) {                     subParser.nextToken().                     CoordinateNode tempNode = parseCoordinates(subParser, ignoreZValue.value()).                     if (coordinateNode != null && tempNode.numDimensions() != coordinateNode.numDimensions()) {                         throw new ElasticsearchParseException("Exception parsing coordinates: " + "number of dimensions do not match").                     }                     coordinateNode = tempNode.                 } else if (ShapeParser.FIELD_GEOMETRIES.match(fieldName, subParser.getDeprecationHandler())) {                     if (shapeType == null) {                         shapeType = GeoShapeType.GEOMETRYCOLLECTION.                     } else if (shapeType.equals(GeoShapeType.GEOMETRYCOLLECTION) == false) {                         malformedException = "cannot have [" + ShapeParser.FIELD_GEOMETRIES + "] with type set to [" + shapeType + "]".                     }                     subParser.nextToken().                     geometryCollections = parseGeometries(subParser, shapeMapper).                 } else if (CircleBuilder.FIELD_RADIUS.match(fieldName, subParser.getDeprecationHandler())) {                     if (shapeType == null) {                         shapeType = GeoShapeType.CIRCLE.                     } else if (shapeType != null && shapeType.equals(GeoShapeType.CIRCLE) == false) {                         malformedException = "cannot have [" + CircleBuilder.FIELD_RADIUS + "] with type set to [" + shapeType + "]".                     }                     subParser.nextToken().                     radius = DistanceUnit.Distance.parseDistance(subParser.text()).                 } else if (ShapeParser.FIELD_ORIENTATION.match(fieldName, subParser.getDeprecationHandler())) {                     if (shapeType != null && (shapeType.equals(GeoShapeType.POLYGON) || shapeType.equals(GeoShapeType.MULTIPOLYGON)) == false) {                         malformedException = "cannot have [" + ShapeParser.FIELD_ORIENTATION + "] with type set to [" + shapeType + "]".                     }                     subParser.nextToken().                     orientation = ShapeBuilder.Orientation.fromString(subParser.text()).                 } else {                     subParser.nextToken().                     subParser.skipChildren().                 }             }         }     }     if (malformedException != null) {         throw new ElasticsearchParseException(malformedException).     } else if (shapeType == null) {         throw new ElasticsearchParseException("shape type not included").     } else if (coordinateNode == null && GeoShapeType.GEOMETRYCOLLECTION != shapeType) {         throw new ElasticsearchParseException("coordinates not included").     } else if (geometryCollections == null && GeoShapeType.GEOMETRYCOLLECTION == shapeType) {         throw new ElasticsearchParseException("geometries not included").     } else if (radius != null && GeoShapeType.CIRCLE != shapeType) {         throw new ElasticsearchParseException("field [{}] is supported for [{}] only", CircleBuilder.FIELD_RADIUS, CircleBuilder.TYPE).     }     if (shapeType.equals(GeoShapeType.GEOMETRYCOLLECTION)) {         return geometryCollections.     }     return shapeType.getBuilder(coordinateNode, radius, orientation, coerce.value()). }
true;private,static;2;29;/**  * Recursive method which parses the arrays of coordinates used to define  * Shapes  *  * @param parser  *            Parser that will be read from  * @return CoordinateNode representing the start of the coordinate tree  * @throws IOException  *             Thrown if an error occurs while reading from the  *             XContentParser  */ ;/**  * Recursive method which parses the arrays of coordinates used to define  * Shapes  *  * @param parser  *            Parser that will be read from  * @return CoordinateNode representing the start of the coordinate tree  * @throws IOException  *             Thrown if an error occurs while reading from the  *             XContentParser  */ private static CoordinateNode parseCoordinates(XContentParser parser, boolean ignoreZValue) throws IOException {     if (parser.currentToken() == XContentParser.Token.START_OBJECT) {         parser.skipChildren().         parser.nextToken().         throw new ElasticsearchParseException("coordinates cannot be specified as objects").     }     XContentParser.Token token = parser.nextToken().     // Base cases     if (token != XContentParser.Token.START_ARRAY && token != XContentParser.Token.END_ARRAY && token != XContentParser.Token.VALUE_NULL) {         return new CoordinateNode(parseCoordinate(parser, ignoreZValue)).     } else if (token == XContentParser.Token.VALUE_NULL) {         throw new IllegalArgumentException("coordinates cannot contain NULL values)").     }     List<CoordinateNode> nodes = new ArrayList<>().     while (token != XContentParser.Token.END_ARRAY) {         CoordinateNode node = parseCoordinates(parser, ignoreZValue).         if (nodes.isEmpty() == false && nodes.get(0).numDimensions() != node.numDimensions()) {             throw new ElasticsearchParseException("Exception parsing coordinates: number of dimensions do not match").         }         nodes.add(node).         token = parser.nextToken().     }     return new CoordinateNode(nodes). }
false;private,static;2;22;;private static Coordinate parseCoordinate(XContentParser parser, boolean ignoreZValue) throws IOException {     if (parser.currentToken() != XContentParser.Token.VALUE_NUMBER) {         throw new ElasticsearchParseException("geo coordinates must be numbers").     }     double lon = parser.doubleValue().     if (parser.nextToken() != XContentParser.Token.VALUE_NUMBER) {         throw new ElasticsearchParseException("geo coordinates must be numbers").     }     double lat = parser.doubleValue().     XContentParser.Token token = parser.nextToken().     // alt (for storing purposes only - future use includes 3d shapes)     double alt = Double.NaN.     if (token == XContentParser.Token.VALUE_NUMBER) {         alt = GeoPoint.assertZValue(ignoreZValue, parser.doubleValue()).         parser.nextToken().     }     // do not support > 3 dimensions     if (parser.currentToken() == XContentParser.Token.VALUE_NUMBER) {         throw new ElasticsearchParseException("geo coordinates greater than 3 dimensions are not supported").     }     return new Coordinate(lon, lat, alt). }
true;static;2;16;/**  * Parse the geometries array of a GeometryCollection  *  * @param parser Parser that will be read from  * @return Geometry[] geometries of the GeometryCollection  * @throws IOException Thrown if an error occurs while reading from the XContentParser  */ ;/**  * Parse the geometries array of a GeometryCollection  *  * @param parser Parser that will be read from  * @return Geometry[] geometries of the GeometryCollection  * @throws IOException Thrown if an error occurs while reading from the XContentParser  */ static GeometryCollectionBuilder parseGeometries(XContentParser parser, BaseGeoShapeFieldMapper mapper) throws IOException {     if (parser.currentToken() != XContentParser.Token.START_ARRAY) {         throw new ElasticsearchParseException("geometries must be an array of geojson objects").     }     XContentParser.Token token = parser.nextToken().     GeometryCollectionBuilder geometryCollection = new GeometryCollectionBuilder().     while (token != XContentParser.Token.END_ARRAY) {         ShapeBuilder shapeBuilder = ShapeParser.parse(parser).         geometryCollection.shape(shapeBuilder).         token = parser.nextToken().     }     return geometryCollection. }
