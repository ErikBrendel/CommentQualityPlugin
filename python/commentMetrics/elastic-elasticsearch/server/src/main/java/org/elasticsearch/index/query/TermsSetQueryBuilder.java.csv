commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;7;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     out.writeString(fieldName).     out.writeGenericValue(values).     out.writeOptionalString(minimumShouldMatchField).     out.writeOptionalWriteable(minimumShouldMatchScript). }
true;;0;3;// package protected for testing purpose ;// package protected for testing purpose String getFieldName() {     return fieldName. }
false;public;0;3;;public List<?> getValues() {     return values. }
false;public;0;3;;public String getMinimumShouldMatchField() {     return minimumShouldMatchField. }
false;public;1;7;;public TermsSetQueryBuilder setMinimumShouldMatchField(String minimumShouldMatchField) {     if (minimumShouldMatchScript != null) {         throw new IllegalArgumentException("A script has already been specified. Cannot specify both a field and script").     }     this.minimumShouldMatchField = minimumShouldMatchField.     return this. }
false;public;0;3;;public Script getMinimumShouldMatchScript() {     return minimumShouldMatchScript. }
false;public;1;7;;public TermsSetQueryBuilder setMinimumShouldMatchScript(Script minimumShouldMatchScript) {     if (minimumShouldMatchField != null) {         throw new IllegalArgumentException("A field has already been specified. Cannot specify both a field and script").     }     this.minimumShouldMatchScript = minimumShouldMatchScript.     return this. }
false;protected;1;7;;@Override protected boolean doEquals(TermsSetQueryBuilder other) {     return Objects.equals(fieldName, other.fieldName) && Objects.equals(values, other.values) && Objects.equals(minimumShouldMatchField, other.minimumShouldMatchField) && Objects.equals(minimumShouldMatchScript, other.minimumShouldMatchScript). }
false;protected;0;4;;@Override protected int doHashCode() {     return Objects.hash(fieldName, values, minimumShouldMatchField, minimumShouldMatchScript). }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
false;protected;2;15;;@Override protected void doXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject(NAME).     builder.startObject(fieldName).     builder.field(TERMS_FIELD.getPreferredName(), TermsQueryBuilder.convertBack(values)).     if (minimumShouldMatchField != null) {         builder.field(MINIMUM_SHOULD_MATCH_FIELD.getPreferredName(), minimumShouldMatchField).     }     if (minimumShouldMatchScript != null) {         builder.field(MINIMUM_SHOULD_MATCH_SCRIPT.getPreferredName(), minimumShouldMatchScript).     }     printBoostAndQueryName(builder).     builder.endObject().     builder.endObject(). }
false;public,static;1;68;;public static TermsSetQueryBuilder fromXContent(XContentParser parser) throws IOException {     XContentParser.Token token = parser.nextToken().     if (token != XContentParser.Token.FIELD_NAME) {         throw new ParsingException(parser.getTokenLocation(), "[" + NAME + "] unknown token [" + token + "]").     }     String currentFieldName = parser.currentName().     String fieldName = currentFieldName.     token = parser.nextToken().     if (token != XContentParser.Token.START_OBJECT) {         throw new ParsingException(parser.getTokenLocation(), "[" + NAME + "] unknown token [" + token + "]").     }     List<Object> values = new ArrayList<>().     String minimumShouldMatchField = null.     Script minimumShouldMatchScript = null.     String queryName = null.     float boost = AbstractQueryBuilder.DEFAULT_BOOST.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token == XContentParser.Token.START_ARRAY) {             if (TERMS_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 values = TermsQueryBuilder.parseValues(parser).             } else {                 throw new ParsingException(parser.getTokenLocation(), "[" + NAME + "] query does not support [" + currentFieldName + "]").             }         } else if (token == XContentParser.Token.START_OBJECT) {             if (MINIMUM_SHOULD_MATCH_SCRIPT.match(currentFieldName, parser.getDeprecationHandler())) {                 minimumShouldMatchScript = Script.parse(parser).             } else {                 throw new ParsingException(parser.getTokenLocation(), "[" + NAME + "] query does not support [" + currentFieldName + "]").             }         } else if (token.isValue()) {             if (MINIMUM_SHOULD_MATCH_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 minimumShouldMatchField = parser.text().             } else if (AbstractQueryBuilder.BOOST_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 boost = parser.floatValue().             } else if (AbstractQueryBuilder.NAME_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 queryName = parser.text().             } else {                 throw new ParsingException(parser.getTokenLocation(), "[" + NAME + "] query does not support [" + currentFieldName + "]").             }         } else {             throw new ParsingException(parser.getTokenLocation(), "[" + NAME + "] unknown token [" + token + "] after [" + currentFieldName + "]").         }     }     token = parser.nextToken().     if (token != XContentParser.Token.END_OBJECT) {         throw new ParsingException(parser.getTokenLocation(), "[" + NAME + "] unknown token [" + token + "]").     }     TermsSetQueryBuilder queryBuilder = new TermsSetQueryBuilder(fieldName, values).queryName(queryName).boost(boost).     if (minimumShouldMatchField != null) {         queryBuilder.setMinimumShouldMatchField(minimumShouldMatchField).     }     if (minimumShouldMatchScript != null) {         queryBuilder.setMinimumShouldMatchScript(minimumShouldMatchScript).     }     return queryBuilder. }
false;protected;1;14;;@Override protected Query doToQuery(QueryShardContext context) {     if (values.isEmpty()) {         return Queries.newMatchNoDocsQuery("No terms supplied for \"" + getName() + "\" query.").     }     // Fail before we attempt to create the term queries:     if (values.size() > BooleanQuery.getMaxClauseCount()) {         throw new BooleanQuery.TooManyClauses().     }     List<Query> queries = createTermQueries(context).     LongValuesSource longValuesSource = createValuesSource(context).     return new CoveringQuery(queries, longValuesSource). }
true;;1;12;/**  * Visible only for testing purposes.  */ ;/**  * Visible only for testing purposes.  */ List<Query> createTermQueries(QueryShardContext context) {     final MappedFieldType fieldType = context.fieldMapper(fieldName).     final List<Query> queries = new ArrayList<>(values.size()).     for (Object value : values) {         if (fieldType != null) {             queries.add(fieldType.termQuery(value, context)).         } else {             queries.add(new TermQuery(new Term(fieldName, BytesRefs.toBytesRef(value)))).         }     }     return queries. }
false;private;1;22;;private LongValuesSource createValuesSource(QueryShardContext context) {     LongValuesSource longValuesSource.     if (minimumShouldMatchField != null) {         MappedFieldType msmFieldType = context.fieldMapper(minimumShouldMatchField).         if (msmFieldType == null) {             throw new QueryShardException(context, "failed to find minimum_should_match field [" + minimumShouldMatchField + "]").         }         IndexNumericFieldData fieldData = context.getForField(msmFieldType).         longValuesSource = new FieldValuesSource(fieldData).     } else if (minimumShouldMatchScript != null) {         TermsSetQueryScript.Factory factory = context.getScriptService().compile(minimumShouldMatchScript, TermsSetQueryScript.CONTEXT).         Map<String, Object> params = new HashMap<>().         params.putAll(minimumShouldMatchScript.getParams()).         params.put("num_terms", values.size()).         longValuesSource = new ScriptLongValueSource(minimumShouldMatchScript, factory.newFactory(params, context.lookup())).     } else {         throw new IllegalStateException("No minimum should match has been specified").     }     return longValuesSource. }
false;public;0;4;;@Override public long longValue() throws IOException {     return script.runAsLong(). }
false;public;1;5;;@Override public boolean advanceExact(int doc) throws IOException {     script.setDocument(doc).     return script.execute() != null. }
false;public;2;16;;@Override public LongValues getValues(LeafReaderContext ctx, DoubleValues scores) throws IOException {     TermsSetQueryScript script = leafFactory.newInstance(ctx).     return new LongValues() {          @Override         public long longValue() throws IOException {             return script.runAsLong().         }          @Override         public boolean advanceExact(int doc) throws IOException {             script.setDocument(doc).             return script.execute() != null.         }     }. }
false;public;0;4;;@Override public boolean needsScores() {     return false. }
false;public;0;6;;@Override public int hashCode() {     int h = getClass().hashCode().     h = 31 * h + script.hashCode().     return h. }
false;public;1;8;;@Override public boolean equals(Object obj) {     if (obj == null || getClass() != obj.getClass()) {         return false.     }     ScriptLongValueSource that = (ScriptLongValueSource) obj.     return Objects.equals(script, that.script). }
false;public;0;4;;@Override public String toString() {     return "script(" + script.toString() + ")". }
false;public;1;7;;@Override public boolean isCacheable(LeafReaderContext ctx) {     // depend on the current timestamp, other documents, etc.     return false. }
false;public;1;4;;@Override public LongValuesSource rewrite(IndexSearcher searcher) throws IOException {     return this. }
false;public;1;7;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     FieldValuesSource that = (FieldValuesSource) o.     return Objects.equals(field, that.field). }
false;public;0;4;;@Override public String toString() {     return "long(" + field + ")". }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(field). }
false;public;0;4;;@Override public long longValue() throws IOException {     return current. }
false;public;1;11;;@Override public boolean advanceExact(int doc) throws IOException {     boolean hasValue = values.advanceExact(doc).     if (hasValue) {         assert values.docValueCount() == 1.         current = values.nextValue().         return true.     } else {         return false.     } }
false;public;2;25;;@Override public LongValues getValues(LeafReaderContext ctx, DoubleValues scores) throws IOException {     SortedNumericDocValues values = field.load(ctx).getLongValues().     return new LongValues() {          long current = -1.          @Override         public long longValue() throws IOException {             return current.         }          @Override         public boolean advanceExact(int doc) throws IOException {             boolean hasValue = values.advanceExact(doc).             if (hasValue) {                 assert values.docValueCount() == 1.                 current = values.nextValue().                 return true.             } else {                 return false.             }         }     }. }
false;public;0;4;;@Override public boolean needsScores() {     return false. }
false;public;1;4;;@Override public boolean isCacheable(LeafReaderContext ctx) {     return true. }
false;public;1;4;;@Override public LongValuesSource rewrite(IndexSearcher searcher) throws IOException {     return this. }
