commented;modifiers;parameterAmount;loc;comment;code
true;private,static;1;3;/**  * Number of slots at <code>level</code>  */ ;/**  * Number of slots at <code>level</code>  */ private static int numSlots(int level) {     return 1 << level. }
false;private,static;1;3;;private static int slotsMask(int level) {     return numSlots(level) - 1. }
true;private,static;2;4;/**  * Encode the position for the given level and offset. The idea is to encode the level using unary coding in the lower bits and  * then the offset in the higher bits.  */ ;/**  * Encode the position for the given level and offset. The idea is to encode the level using unary coding in the lower bits and  * then the offset in the higher bits.  */ private static long position(int level, long offset) {     assert level >= 1.     return (1 << (level - 1)) | (offset << level). }
true;private,static;1;3;/**  * Decode the level from an encoded position.  */ ;/**  * Decode the level from an encoded position.  */ private static int level(long position) {     return 1 + Long.numberOfTrailingZeros(position). }
true;private,static;2;3;/**  * Decode the offset from the position.  */ ;/**  * Decode the offset from the position.  */ private static long offset(long position, int level) {     return position >>> level. }
true;private,static;2;3;/**  * Get the ID of the slice given an offset.  */ ;/**  * Get the ID of the slice given an offset.  */ private static long sliceID(int level, long offset) {     return offset >>> level. }
true;private,static;2;3;/**  * Compute the first offset of the given slice.  */ ;/**  * Compute the first offset of the given slice.  */ private static long startOffset(int level, long slice) {     return slice << level. }
true;private,static;2;3;/**  * Compute the number of ordinals stored for a value given its current position.  */ ;/**  * Compute the number of ordinals stored for a value given its current position.  */ private static int numOrdinals(int level, long offset) {     return (1 << level) + (int) (offset & slotsMask(level)). }
true;private;1;13;/**  * Allocate a new slice and return its ID.  */ ;/**  * Allocate a new slice and return its ID.  */ private long newSlice(int level) {     final long newSlice = sizes[level]++.     // Lazily allocate ordinals     if (ordinals[level] == null) {         ordinals[level] = new PagedGrowableWriter(8L * numSlots(level), PAGE_SIZE, startBitsPerValue, acceptableOverheadRatio).     } else {         ordinals[level] = ordinals[level].grow(sizes[level] * numSlots(level)).         if (nextLevelSlices[level] != null) {             nextLevelSlices[level] = nextLevelSlices[level].grow(sizes[level]).         }     }     return newSlice. }
false;public;2;8;;public int addOrdinal(int docID, long ordinal) {     final long position = positions.get(docID).     if (position == 0L) {         // on the first level         return firstLevel(docID, ordinal).     } else {         return nonFirstLevel(docID, ordinal, position).     } }
false;private;2;18;;private int firstLevel(int docID, long ordinal) {     // 0 or 1 ordinal     if (firstOrdinals.get(docID) == 0L) {         firstOrdinals.set(docID, ordinal + 1).         return 1.     } else {         final long newSlice = newSlice(1).         if (firstNextLevelSlices == null) {             firstNextLevelSlices = new PagedGrowableWriter(firstOrdinals.size(), PAGE_SIZE, 3, acceptableOverheadRatio).         }         firstNextLevelSlices.set(docID, newSlice).         final long offset = startOffset(1, newSlice).         ordinals[1].set(offset, ordinal + 1).         // current position is on the 1st level and not allocated yet         positions.set(docID, position(1, offset)).         return 2.     } }
false;private;3;23;;private int nonFirstLevel(int docID, long ordinal, long position) {     int level = level(position).     long offset = offset(position, level).     assert offset != 0L.     if (((offset + 1) & slotsMask(level)) == 0L) {         // reached the end of the slice, allocate a new one on the next level         final long newSlice = newSlice(level + 1).         if (nextLevelSlices[level] == null) {             nextLevelSlices[level] = new PagedGrowableWriter(sizes[level], PAGE_SIZE, 1, acceptableOverheadRatio).         }         nextLevelSlices[level].set(sliceID(level, offset), newSlice).         ++level.         offset = startOffset(level, newSlice).         assert (offset & slotsMask(level)) == 0L.     } else {         // just go to the next slot         ++offset.     }     ordinals[level].set(offset, ordinal + 1).     final long newPosition = position(level, offset).     positions.set(docID, newPosition).     return numOrdinals(level, offset). }
false;public;2;36;;public void appendOrdinals(int docID, LongsRef ords) {     // First level     final long firstOrd = firstOrdinals.get(docID).     if (firstOrd == 0L) {         return.     }     ords.longs = ArrayUtil.grow(ords.longs, ords.offset + ords.length + 1).     ords.longs[ords.offset + ords.length++] = firstOrd - 1.     if (firstNextLevelSlices == null) {         return.     }     long sliceID = firstNextLevelSlices.get(docID).     if (sliceID == 0L) {         return.     }     // Other levels     for (int level = 1. . ++level) {         final int numSlots = numSlots(level).         ords.longs = ArrayUtil.grow(ords.longs, ords.offset + ords.length + numSlots).         final long offset = startOffset(level, sliceID).         for (int j = 0. j < numSlots. ++j) {             final long ord = ordinals[level].get(offset + j).             if (ord == 0L) {                 return.             }             ords.longs[ords.offset + ords.length++] = ord - 1.         }         if (nextLevelSlices[level] == null) {             return.         }         sliceID = nextLevelSlices[level].get(sliceID).         if (sliceID == 0L) {             return.         }     } }
true;public;1;5;/**  * Returns a shared {@link LongsRef} instance for the given doc ID holding all ordinals associated with it.  */ ;/**  * Returns a shared {@link LongsRef} instance for the given doc ID holding all ordinals associated with it.  */ public LongsRef docOrds(int docID) {     spare.offset = spare.length = 0.     ordinals.appendOrdinals(docID, spare).     return spare. }
true;public;0;3;/**  * Return a {@link PackedInts.Reader} instance mapping every doc ID to its first ordinal + 1 if it exists and 0 otherwise.  */ ;/**  * Return a {@link PackedInts.Reader} instance mapping every doc ID to its first ordinal + 1 if it exists and 0 otherwise.  */ public PackedInts.Reader getFirstOrdinals() {     return ordinals.firstOrdinals. }
true;public;0;3;/**  * Advances the {@link OrdinalsBuilder} to the next ordinal and  * return the current ordinal.  */ ;/**  * Advances the {@link OrdinalsBuilder} to the next ordinal and  * return the current ordinal.  */ public long nextOrdinal() {     return ++currentOrd. }
true;public;0;3;/**  * Returns the current ordinal or {@code 0} if this build has not been advanced via  * {@link #nextOrdinal()}.  */ ;/**  * Returns the current ordinal or {@code 0} if this build has not been advanced via  * {@link #nextOrdinal()}.  */ public long currentOrdinal() {     return currentOrd. }
true;public;1;10;/**  * Associates the given document id with the current ordinal.  */ ;/**  * Associates the given document id with the current ordinal.  */ public OrdinalsBuilder addDoc(int doc) {     totalNumOrds++.     final int numValues = ordinals.addOrdinal(doc, currentOrd).     if (numValues == 1) {         ++numDocsWithValue.     } else if (numValues == 2) {         ++numMultiValuedDocs.     }     return this. }
true;public;0;3;/**  * Returns the number distinct of document IDs associated with two or more values.  */ ;/**  * Returns the number distinct of document IDs associated with two or more values.  */ public int getNumMultiValuesDocs() {     return numMultiValuedDocs. }
true;public;0;3;/**  * Returns the number of document ID to ordinal pairs in this builder.  */ ;/**  * Returns the number of document ID to ordinal pairs in this builder.  */ public int getTotalNumOrds() {     return totalNumOrds. }
true;public;0;3;/**  * Returns the number of distinct ordinals in this builder.  */ ;/**  * Returns the number of distinct ordinals in this builder.  */ public long getValueCount() {     return currentOrd + 1. }
true;public;0;12;/**  * Builds an {@link Ordinals} instance from the builders current state.  */ ;/**  * Builds an {@link Ordinals} instance from the builders current state.  */ public Ordinals build() {     final float acceptableOverheadRatio = PackedInts.DEFAULT.     if (numMultiValuedDocs > 0 || MultiOrdinals.significantlySmallerThanSinglePackedOrdinals(maxDoc, numDocsWithValue, getValueCount(), acceptableOverheadRatio)) {         // MultiOrdinals can be smaller than SinglePackedOrdinals for sparse fields         return new MultiOrdinals(this, acceptableOverheadRatio).     } else {         return new SinglePackedOrdinals(this, acceptableOverheadRatio).     } }
true;public;0;3;/**  * Returns the maximum document ID this builder can associate with an ordinal  */ ;/**  * Returns the maximum document ID this builder can associate with an ordinal  */ public int maxDoc() {     return maxDoc. }
true;public;0;4;/**  * Closes this builder and release all resources.  */ ;/**  * Closes this builder and release all resources.  */ @Override public void close() throws IOException {     ordinals = null. }
