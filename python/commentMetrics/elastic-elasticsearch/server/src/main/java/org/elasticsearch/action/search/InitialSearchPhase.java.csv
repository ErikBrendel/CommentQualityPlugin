commented;modifiers;parameterAmount;loc;comment;code
false;private;5;38;;private void onShardFailure(final int shardIndex, @Nullable ShardRouting shard, @Nullable String nodeId, final SearchShardIterator shardIt, Exception e) {     // we always add the shard failure for a specific shard instance     // we do make sure to clean it on a successful response from a shard     SearchShardTarget shardTarget = shardIt.newSearchShardTarget(nodeId).     onShardFailure(shardIndex, shardTarget, e).     if (totalOps.incrementAndGet() == expectedTotalOps) {         if (logger.isDebugEnabled()) {             if (e != null && !TransportActions.isShardNotAvailableException(e)) {                 logger.debug(new ParameterizedMessage("{}: Failed to execute [{}]", shard != null ? shard.shortSummary() : shardIt.shardId(), request), e).             } else if (logger.isTraceEnabled()) {                 logger.trace(new ParameterizedMessage("{}: Failed to execute [{}]", shard, request), e).             }         }         onPhaseDone().     } else {         final ShardRouting nextShard = shardIt.nextOrNull().         final boolean lastShard = nextShard == null.         // trace log this exception         logger.trace(() -> new ParameterizedMessage("{}: Failed to execute [{}] lastShard [{}]", shard != null ? shard.shortSummary() : shardIt.shardId(), request, lastShard), e).         if (!lastShard) {             performPhaseOnShard(shardIndex, shardIt, nextShard).         } else {             // no more shards active, add a failure             if (logger.isDebugEnabled() && !logger.isTraceEnabled()) {                 // do not double log this exception                 if (e != null && !TransportActions.isShardNotAvailableException(e)) {                     logger.debug(new ParameterizedMessage("{}: Failed to execute [{}] lastShard [{}]", shard != null ? shard.shortSummary() : shardIt.shardId(), request, lastShard), e).                 }             }         }     } }
false;public,final;0;34;;@Override public final void run() {     for (final SearchShardIterator iterator : toSkipShardsIts) {         assert iterator.skip().         skipShard(iterator).     }     if (shardsIts.size() > 0) {         assert request.allowPartialSearchResults() != null : "SearchRequest missing setting for allowPartialSearchResults".         if (request.allowPartialSearchResults() == false) {             final StringBuilder missingShards = new StringBuilder().             // Fail-fast verification of all shards being available             for (int index = 0. index < shardsIts.size(). index++) {                 final SearchShardIterator shardRoutings = shardsIts.get(index).                 if (shardRoutings.size() == 0) {                     if (missingShards.length() > 0) {                         missingShards.append(", ").                     }                     missingShards.append(shardRoutings.shardId()).                 }             }             if (missingShards.length() > 0) {                 // Status red - shard is missing all copies and would produce partial results for an index search                 final String msg = "Search rejected due to missing shards [" + missingShards + "]. Consider using `allow_partial_search_results` setting to bypass this error.".                 throw new SearchPhaseExecutionException(getName(), msg, null, ShardSearchFailure.EMPTY_ARRAY).             }         }         for (int index = 0. index < shardsIts.size(). index++) {             final SearchShardIterator shardRoutings = shardsIts.get(index).             assert shardRoutings.skip() == false.             performPhaseOnShard(index, shardRoutings, shardRoutings.nextOrNull()).         }     } }
false;public;1;4;;@Override public void onFailure(Exception e) { }
false;protected;0;4;;@Override protected void doRun() {     runnable.run(). }
false;public;0;5;;@Override public boolean isForceExecution() {     // we can not allow a stuffed queue to reject execution here     return true. }
false;private;1;19;;private void fork(final Runnable runnable) {     executor.execute(new AbstractRunnable() {          @Override         public void onFailure(Exception e) {         }          @Override         protected void doRun() {             runnable.run().         }          @Override         public boolean isForceExecution() {             // we can not allow a stuffed queue to reject execution here             return true.         }     }). }
false;;0;7;;void finishAndRunNext() {     synchronized (this) {         permitsTaken--.         assert permitsTaken >= 0 : "illegal taken permits: " + permitsTaken.     }     tryRun(null). }
false;;1;6;;void tryRun(Runnable runnable) {     Runnable r = tryQueue(runnable).     if (r != null) {         r.run().     } }
false;private,synchronized;1;16;;private synchronized Runnable tryQueue(Runnable runnable) {     Runnable toExecute = null.     if (permitsTaken < permits) {         permitsTaken++.         toExecute = runnable.         if (toExecute == null) {             // only poll if we don't have anything to execute             toExecute = queue.poll().         }         if (toExecute == null) {             permitsTaken--.         }     } else if (runnable != null) {         queue.add(runnable).     }     return toExecute. }
false;private;2;3;;private void executeNext(PendingExecutions pendingExecutions, Thread originalThread) {     executeNext(pendingExecutions == null ? null : pendingExecutions::finishAndRunNext, originalThread). }
false;protected;2;11;;protected void executeNext(Runnable runnable, Thread originalThread) {     if (throttleConcurrentRequests) {         if (originalThread == Thread.currentThread()) {             fork(runnable).         } else {             runnable.run().         }     } else {         assert runnable == null.     } }
false;public;1;8;;@Override public void innerOnResponse(FirstResult result) {     try {         onShardResult(result, shardIt).     } finally {         executeNext(pendingExecutions, thread).     } }
false;public;1;8;;@Override public void onFailure(Exception t) {     try {         onShardFailure(shardIndex, shard, shard.currentNodeId(), shardIt, t).     } finally {         executeNext(pendingExecutions, thread).     } }
false;private;3;56;;private void performPhaseOnShard(final int shardIndex, final SearchShardIterator shardIt, final ShardRouting shard) {     /*          * We capture the thread that this phase is starting on. When we are called back after executing the phase, we are either on the          * same thread (because we never went async, or the same thread was selected from the thread pool) or a different thread. If we          * continue on the same thread in the case that we never went async and this happens repeatedly we will end up recursing deeply and          * could stack overflow. To prevent this, we fork if we are called back on the same thread that execution started on and otherwise          * we can continue (cf. InitialSearchPhase#maybeFork).          */     if (shard == null) {         fork(() -> onShardFailure(shardIndex, null, null, shardIt, new NoShardAvailableActionException(shardIt.shardId()))).     } else {         final PendingExecutions pendingExecutions = throttleConcurrentRequests ? pendingExecutionsPerNode.computeIfAbsent(shard.currentNodeId(), n -> new PendingExecutions(maxConcurrentRequestsPerNode)) : null.         Runnable r = () -> {             final Thread thread = Thread.currentThread().             try {                 executePhaseOnShard(shardIt, shard, new SearchActionListener<FirstResult>(shardIt.newSearchShardTarget(shard.currentNodeId()), shardIndex) {                      @Override                     public void innerOnResponse(FirstResult result) {                         try {                             onShardResult(result, shardIt).                         } finally {                             executeNext(pendingExecutions, thread).                         }                     }                      @Override                     public void onFailure(Exception t) {                         try {                             onShardFailure(shardIndex, shard, shard.currentNodeId(), shardIt, t).                         } finally {                             executeNext(pendingExecutions, thread).                         }                     }                 }).             } catch (final Exception e) {                 try {                     /*                          * It is possible to run into connection exceptions here because we are getting the connection early and might                          * run into nodes that are not connected. In this case, on shard failure will move us to the next shard copy.                          */                     fork(() -> onShardFailure(shardIndex, shard, shard.currentNodeId(), shardIt, e)).                 } finally {                     executeNext(pendingExecutions, thread).                 }             }         }.         if (throttleConcurrentRequests) {             pendingExecutions.tryRun(r).         } else {             r.run().         }     } }
false;private;2;11;;private void onShardResult(FirstResult result, SearchShardIterator shardIt) {     assert result.getShardIndex() != -1 : "shard index is not set".     assert result.getSearchShardTarget() != null : "search shard target must not be null".     onShardSuccess(result).     // we need to increment successful ops first before we compare the exit condition otherwise if we     // are fast we could concurrently update totalOps but then preempt one of the threads which can     // cause the successor to read a wrong value from successfulOps if second phase is very fast ie. count etc.     // increment all the "future" shards to update the total ops since we some may work and some may not...     // and when that happens, we break on total ops, so we must maintain them     successfulShardExecution(shardIt). }
false;private;1;15;;private void successfulShardExecution(SearchShardIterator shardsIt) {     final int remainingOpsOnIterator.     if (shardsIt.skip()) {         remainingOpsOnIterator = shardsIt.remaining().     } else {         remainingOpsOnIterator = shardsIt.remaining() + 1.     }     final int xTotalOps = totalOps.addAndGet(remainingOpsOnIterator).     if (xTotalOps == expectedTotalOps) {         onPhaseDone().     } else if (xTotalOps > expectedTotalOps) {         throw new AssertionError("unexpected higher total ops [" + xTotalOps + "] compared to expected [" + expectedTotalOps + "]").     } }
true;abstract;0;1;// as a tribute to @kimchy aka. finishHim() ;/**  * Executed once all shard results have been received and processed  * @see #onShardFailure(int, SearchShardTarget, Exception)  * @see #onShardSuccess(SearchPhaseResult)  */ // as a tribute to @kimchy aka. finishHim() abstract void onPhaseDone().
true;abstract;3;1;/**  * Executed once for every failed shard level request. This method is invoked before the next replica is tried for the given  * shard target.  * @param shardIndex the internal index for this shard. Each shard has an index / ordinal assigned that is used to reference  *                   it's results  * @param shardTarget the shard target for this failure  * @param ex the failure reason  */ ;/**  * Executed once for every failed shard level request. This method is invoked before the next replica is tried for the given  * shard target.  * @param shardIndex the internal index for this shard. Each shard has an index / ordinal assigned that is used to reference  *                   it's results  * @param shardTarget the shard target for this failure  * @param ex the failure reason  */ abstract void onShardFailure(int shardIndex, SearchShardTarget shardTarget, Exception ex).
true;abstract;1;1;/**  * Executed once for every successful shard level request.  * @param result the result returned form the shard  */ ;/**  * Executed once for every successful shard level request.  * @param result the result returned form the shard  */ abstract void onShardSuccess(FirstResult result).
true;protected,abstract;3;2;/**  * Sends the request to the actual shard.  * @param shardIt the shards iterator  * @param shard the shard routing to send the request for  * @param listener the listener to notify on response  */ ;/**  * Sends the request to the actual shard.  * @param shardIt the shards iterator  * @param shard the shard routing to send the request for  * @param listener the listener to notify on response  */ protected abstract void executePhaseOnShard(SearchShardIterator shardIt, ShardRouting shard, SearchActionListener<FirstResult> listener).
true;final;0;3;/**  * Returns the number of expected results this class should collect  */ ;/**  * Returns the number of expected results this class should collect  */ final int getNumShards() {     return numShards. }
true;abstract;0;1;/**  * A stream of all non-null (successful) shard results  */ ;/**  * A stream of all non-null (successful) shard results  */ abstract Stream<Result> getSuccessfulResults().
true;abstract;1;1;/**  * Consumes a single shard result  * @param result the shards result  */ ;/**  * Consumes a single shard result  * @param result the shards result  */ abstract void consumeResult(Result result).
true;abstract;1;1;/**  * Returns <code>true</code> iff a result if present for the given shard ID.  */ ;/**  * Returns <code>true</code> iff a result if present for the given shard ID.  */ abstract boolean hasResult(int shardIndex).
false;;1;1;;void consumeShardFailure(int shardIndex) { }
false;;0;3;;AtomicArray<Result> getAtomicArray() {     throw new UnsupportedOperationException(). }
true;;0;3;/**  * Reduces the collected results  */ ;/**  * Reduces the collected results  */ SearchPhaseController.ReducedQueryPhase reduce() {     throw new UnsupportedOperationException("reduce is not supported"). }
false;;0;3;;Stream<Result> getSuccessfulResults() {     return results.asList().stream(). }
false;;1;4;;void consumeResult(Result result) {     assert results.get(result.getShardIndex()) == null : "shardIndex: " + result.getShardIndex() + " is already set".     results.set(result.getShardIndex(), result). }
false;;1;3;;boolean hasResult(int shardIndex) {     return results.get(shardIndex) != null. }
false;;0;4;;@Override AtomicArray<Result> getAtomicArray() {     return results. }
false;protected;1;4;;protected void skipShard(SearchShardIterator iterator) {     assert iterator.skip().     successfulShardExecution(iterator). }
