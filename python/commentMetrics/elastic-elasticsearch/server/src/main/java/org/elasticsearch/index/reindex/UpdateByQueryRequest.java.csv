commented;modifiers;parameterAmount;loc;comment;code
true;public;1;4;/**  * Set the ingest pipeline to set on index requests made by this action.  */ ;/**  * Set the ingest pipeline to set on index requests made by this action.  */ public UpdateByQueryRequest setPipeline(String pipeline) {     this.pipeline = pipeline.     return this. }
true;public;1;6;/**  * Set the query for selective update  */ ;/**  * Set the query for selective update  */ public UpdateByQueryRequest setQuery(QueryBuilder query) {     if (query != null) {         getSearchRequest().source().query(query).     }     return this. }
true;public;1;7;/**  * Set the document types for the update  * @deprecated Types are in the process of being removed. Instead of  * using a type, prefer to filter on a field of the document.  */ ;/**  * Set the document types for the update  * @deprecated Types are in the process of being removed. Instead of  * using a type, prefer to filter on a field of the document.  */ @Deprecated public UpdateByQueryRequest setDocTypes(String... types) {     if (types != null) {         getSearchRequest().types(types).     }     return this. }
true;public;1;6;/**  * Set routing limiting the process to the shards that match that routing value  */ ;/**  * Set routing limiting the process to the shards that match that routing value  */ public UpdateByQueryRequest setRouting(String routing) {     if (routing != null) {         getSearchRequest().routing(routing).     }     return this. }
true;public;1;4;/**  * The scroll size to control number of documents processed per batch  */ ;/**  * The scroll size to control number of documents processed per batch  */ public UpdateByQueryRequest setBatchSize(int size) {     getSearchRequest().source().size(size).     return this. }
true;public;1;4;/**  * Set the IndicesOptions for controlling unavailable indices  */ ;/**  * Set the IndicesOptions for controlling unavailable indices  */ public UpdateByQueryRequest setIndicesOptions(IndicesOptions indicesOptions) {     getSearchRequest().indicesOptions(indicesOptions).     return this. }
true;public;0;3;/**  * Gets the batch size for this request  */ ;/**  * Gets the batch size for this request  */ public int getBatchSize() {     return getSearchRequest().source().size(). }
true;public;0;3;/**  * Gets the routing value used for this request  */ ;/**  * Gets the routing value used for this request  */ public String getRouting() {     return getSearchRequest().routing(). }
true;public;0;8;/**  * Gets the document types on which this request would be executed. Returns an empty array if all  * types are to be processed.  * @deprecated Types are in the process of being removed. Instead of  * using a type, prefer to filter on a field of the document.  */ ;/**  * Gets the document types on which this request would be executed. Returns an empty array if all  * types are to be processed.  * @deprecated Types are in the process of being removed. Instead of  * using a type, prefer to filter on a field of the document.  */ @Deprecated public String[] getDocTypes() {     if (getSearchRequest().types() != null) {         return getSearchRequest().types().     } else {         return new String[0].     } }
true;public;0;3;/**  * Ingest pipeline to set on index requests made by this action.  */ ;/**  * Ingest pipeline to set on index requests made by this action.  */ public String getPipeline() {     return pipeline. }
false;protected;0;4;;@Override protected UpdateByQueryRequest self() {     return this. }
false;public;3;6;;@Override public UpdateByQueryRequest forSlice(TaskId slicingTask, SearchRequest slice, int totalSlices) {     UpdateByQueryRequest request = doForSlice(new UpdateByQueryRequest(slice, false), slicingTask, totalSlices).     request.setPipeline(pipeline).     return request. }
false;public;0;7;;@Override public String toString() {     StringBuilder b = new StringBuilder().     b.append("update-by-query ").     searchToString(b).     return b.toString(). }
true;public;1;6;// indices are resolved depend entirely on the inner search request. That's why the following methods delegate to it. ;// update by query updates all documents that match a query. The indices and indices options that affect how // indices are resolved depend entirely on the inner search request. That's why the following methods delegate to it. @Override public IndicesRequest indices(String... indices) {     assert getSearchRequest() != null.     getSearchRequest().indices(indices).     return this. }
false;public;0;5;;@Override public String[] indices() {     assert getSearchRequest() != null.     return getSearchRequest().indices(). }
false;public;0;5;;@Override public IndicesOptions indicesOptions() {     assert getSearchRequest() != null.     return getSearchRequest().indicesOptions(). }
false;public;1;4;;@Override public void readFrom(StreamInput in) throws IOException {     throw new UnsupportedOperationException("usage of Streamable is to be replaced by Writeable"). }
false;public;1;5;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeOptionalString(pipeline). }
false;public;2;11;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     if (getScript() != null) {         builder.field("script").         getScript().toXContent(builder, params).     }     getSearchRequest().source().innerToXContent(builder, params).     builder.endObject().     return builder. }
