commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String contentType() {     return this.contentType. }
false;public;0;4;;@Override public BytesReference content() {     return this.content. }
false;public;0;4;;@Override public RestStatus status() {     return this.status. }
false;private,static;3;21;;private static XContentBuilder build(RestChannel channel, RestStatus status, Exception e) throws IOException {     ToXContent.Params params = channel.request().     if (params.paramAsBoolean("error_trace", !REST_EXCEPTION_SKIP_STACK_TRACE_DEFAULT)) {         params = new ToXContent.DelegatingMapParams(singletonMap(REST_EXCEPTION_SKIP_STACK_TRACE, "false"), params).     } else if (e != null) {         Supplier<?> messageSupplier = () -> new ParameterizedMessage("path: {}, params: {}", channel.request().rawPath(), channel.request().params()).         if (status.getStatus() < 500) {             SUPPRESSED_ERROR_LOGGER.debug(messageSupplier, e).         } else {             SUPPRESSED_ERROR_LOGGER.warn(messageSupplier, e).         }     }     XContentBuilder builder = channel.newErrorBuilder().startObject().     ElasticsearchException.generateFailureXContent(builder, params, e, channel.detailedErrorsEnabled()).     builder.field(STATUS, status.getStatus()).     builder.endObject().     return builder. }
false;static;3;6;;static BytesRestResponse createSimpleErrorResponse(RestChannel channel, RestStatus status, String errorMessage) throws IOException {     return new BytesRestResponse(status, channel.newErrorBuilder().startObject().field("error", errorMessage).field("status", status.getStatus()).endObject()). }
false;public,static;1;35;;public static ElasticsearchStatusException errorFromXContent(XContentParser parser) throws IOException {     XContentParser.Token token = parser.nextToken().     ensureExpectedToken(XContentParser.Token.START_OBJECT, token, parser::getTokenLocation).     ElasticsearchException exception = null.     RestStatus status = null.     String currentFieldName = null.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         }         if (STATUS.equals(currentFieldName)) {             if (token != XContentParser.Token.FIELD_NAME) {                 ensureExpectedToken(XContentParser.Token.VALUE_NUMBER, token, parser::getTokenLocation).                 status = RestStatus.fromCode(parser.intValue()).             }         } else {             exception = ElasticsearchException.failureFromXContent(parser).         }     }     if (exception == null) {         throw new IllegalStateException("Failed to parse elasticsearch status exception: no exception was found").     }     ElasticsearchStatusException result = new ElasticsearchStatusException(exception.getMessage(), status, exception.getCause()).     for (String header : exception.getHeaderKeys()) {         result.addHeader(header, exception.getHeader(header)).     }     for (String metadata : exception.getMetadataKeys()) {         result.addMetadata(metadata, exception.getMetadata(metadata)).     }     return result. }
