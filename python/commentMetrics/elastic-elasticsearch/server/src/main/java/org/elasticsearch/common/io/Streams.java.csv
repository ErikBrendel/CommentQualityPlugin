commented;modifiers;parameterAmount;loc;comment;code
false;public,static;2;3;;// --------------------------------------------------------------------- // Copy methods for java.io.InputStream / java.io.OutputStream // --------------------------------------------------------------------- public static long copy(InputStream in, OutputStream out) throws IOException {     return copy(in, out, new byte[BUFFER_SIZE]). }
true;public,static;3;22;/**  * Copy the contents of the given InputStream to the given OutputStream.  * Closes both streams when done.  *  * @param in  the stream to copy from  * @param out the stream to copy to  * @return the number of bytes copied  * @throws IOException in case of I/O errors  */ ;/**  * Copy the contents of the given InputStream to the given OutputStream.  * Closes both streams when done.  *  * @param in  the stream to copy from  * @param out the stream to copy to  * @return the number of bytes copied  * @throws IOException in case of I/O errors  */ public static long copy(InputStream in, OutputStream out, byte[] buffer) throws IOException {     Objects.requireNonNull(in, "No InputStream specified").     Objects.requireNonNull(out, "No OutputStream specified").     boolean success = false.     try {         long byteCount = 0.         int bytesRead.         while ((bytesRead = in.read(buffer)) != -1) {             out.write(buffer, 0, bytesRead).             byteCount += bytesRead.         }         out.flush().         success = true.         return byteCount.     } finally {         if (success) {             IOUtils.close(in, out).         } else {             IOUtils.closeWhileHandlingException(in, out).         }     } }
true;public,static;2;13;/**  * Copy the contents of the given byte array to the given OutputStream.  * Closes the stream when done.  *  * @param in  the byte array to copy from  * @param out the OutputStream to copy to  * @throws IOException in case of I/O errors  */ ;/**  * Copy the contents of the given byte array to the given OutputStream.  * Closes the stream when done.  *  * @param in  the byte array to copy from  * @param out the OutputStream to copy to  * @throws IOException in case of I/O errors  */ public static void copy(byte[] in, OutputStream out) throws IOException {     Objects.requireNonNull(in, "No input byte array specified").     Objects.requireNonNull(out, "No OutputStream specified").     try {         out.write(in).     } finally {         try {             out.close().         } catch (IOException ex) {         // do nothing         }     } }
true;public,static;2;23;/**  * Copy the contents of the given Reader to the given Writer.  * Closes both when done.  *  * @param in  the Reader to copy from  * @param out the Writer to copy to  * @return the number of characters copied  * @throws IOException in case of I/O errors  */ ;// --------------------------------------------------------------------- // Copy methods for java.io.Reader / java.io.Writer // --------------------------------------------------------------------- /**  * Copy the contents of the given Reader to the given Writer.  * Closes both when done.  *  * @param in  the Reader to copy from  * @param out the Writer to copy to  * @return the number of characters copied  * @throws IOException in case of I/O errors  */ public static int copy(Reader in, Writer out) throws IOException {     Objects.requireNonNull(in, "No Reader specified").     Objects.requireNonNull(out, "No Writer specified").     boolean success = false.     try {         int byteCount = 0.         char[] buffer = new char[BUFFER_SIZE].         int bytesRead.         while ((bytesRead = in.read(buffer)) != -1) {             out.write(buffer, 0, bytesRead).             byteCount += bytesRead.         }         out.flush().         success = true.         return byteCount.     } finally {         if (success) {             IOUtils.close(in, out).         } else {             IOUtils.closeWhileHandlingException(in, out).         }     } }
true;public,static;2;13;/**  * Copy the contents of the given String to the given output Writer.  * Closes the write when done.  *  * @param in  the String to copy from  * @param out the Writer to copy to  * @throws IOException in case of I/O errors  */ ;/**  * Copy the contents of the given String to the given output Writer.  * Closes the write when done.  *  * @param in  the String to copy from  * @param out the Writer to copy to  * @throws IOException in case of I/O errors  */ public static void copy(String in, Writer out) throws IOException {     Objects.requireNonNull(in, "No input String specified").     Objects.requireNonNull(out, "No Writer specified").     try {         out.write(in).     } finally {         try {             out.close().         } catch (IOException ex) {         // do nothing         }     } }
true;public,static;1;5;/**  * Copy the contents of the given Reader into a String.  * Closes the reader when done.  *  * @param in the reader to copy from  * @return the String that has been copied to  * @throws IOException in case of I/O errors  */ ;/**  * Copy the contents of the given Reader into a String.  * Closes the reader when done.  *  * @param in the reader to copy from  * @return the String that has been copied to  * @throws IOException in case of I/O errors  */ public static String copyToString(Reader in) throws IOException {     StringWriter out = new StringWriter().     copy(in, out).     return out.toString(). }
false;public,static;2;3;;public static int readFully(Reader reader, char[] dest) throws IOException {     return readFully(reader, dest, 0, dest.length). }
false;public,static;4;11;;public static int readFully(Reader reader, char[] dest, int offset, int len) throws IOException {     int read = 0.     while (read < len) {         final int r = reader.read(dest, offset + read, len - read).         if (r == -1) {             break.         }         read += r.     }     return read. }
false;public,static;2;3;;public static int readFully(InputStream reader, byte[] dest) throws IOException {     return readFully(reader, dest, 0, dest.length). }
false;public,static;4;11;;public static int readFully(InputStream reader, byte[] dest, int offset, int len) throws IOException {     int read = 0.     while (read < len) {         final int r = reader.read(dest, offset + read, len - read).         if (r == -1) {             break.         }         read += r.     }     return read. }
false;public,static;1;5;;public static List<String> readAllLines(InputStream input) throws IOException {     final List<String> lines = new ArrayList<>().     readAllLines(input, lines::add).     return lines. }
false;public,static;2;8;;public static void readAllLines(InputStream input, Consumer<String> consumer) throws IOException {     try (BufferedReader reader = new BufferedReader(new InputStreamReader(input, StandardCharsets.UTF_8))) {         String line.         while ((line = reader.readLine()) != null) {             consumer.accept(line).         }     } }
true;public,static;1;3;/**  * Wraps the given {@link BytesStream} in a {@link StreamOutput} that simply flushes when  * close is called.  */ ;/**  * Wraps the given {@link BytesStream} in a {@link StreamOutput} that simply flushes when  * close is called.  */ public static BytesStream flushOnCloseStream(BytesStream os) {     return new FlushOnCloseOutputStream(os). }
false;public;1;4;;@Override public void writeByte(byte b) throws IOException {     delegate.writeByte(b). }
false;public;3;4;;@Override public void writeBytes(byte[] b, int offset, int length) throws IOException {     delegate.writeBytes(b, offset, length). }
false;public;0;4;;@Override public void flush() throws IOException {     delegate.flush(). }
false;public;0;4;;@Override public void close() throws IOException {     flush(). }
false;public;0;4;;@Override public void reset() throws IOException {     delegate.reset(). }
false;public;0;4;;@Override public BytesReference bytes() {     return delegate.bytes(). }
