commented;modifiers;parameterAmount;loc;comment;code
false;public;2;117;;@Override public void hitsExecute(SearchContext context, SearchHit[] hits) throws IOException {     if (context.collapse() != null) {         // retrieve the `doc_value` associated with the collapse field         String name = context.collapse().getFieldName().         if (context.docValueFieldsContext() == null) {             context.docValueFieldsContext(new DocValueFieldsContext(Collections.singletonList(new FieldAndFormat(name, null)))).         } else if (context.docValueFieldsContext().fields().stream().map(ff -> ff.field).anyMatch(name::equals) == false) {             context.docValueFieldsContext().fields().add(new FieldAndFormat(name, null)).         }     }     if (context.docValueFieldsContext() == null) {         return.     }     // don't modify the incoming hits     hits = hits.clone().     Arrays.sort(hits, Comparator.comparingInt(SearchHit::docId)).     if (context.docValueFieldsContext().fields().stream().map(f -> f.format).filter(USE_DEFAULT_FORMAT::equals).findAny().isPresent()) {         DEPRECATION_LOGGER.deprecated("[" + USE_DEFAULT_FORMAT + "] is a special format that was only used to " + "ease the transition to 7.x. It has become the default and shouldn't be set explicitly anymore.").     }     for (FieldAndFormat fieldAndFormat : context.docValueFieldsContext().fields()) {         String field = fieldAndFormat.field.         MappedFieldType fieldType = context.mapperService().fullName(field).         if (fieldType != null) {             final IndexFieldData<?> indexFieldData = context.getForField(fieldType).             final boolean isNanosecond.             if (indexFieldData instanceof IndexNumericFieldData) {                 isNanosecond = ((IndexNumericFieldData) indexFieldData).getNumericType() == NumericType.DATE_NANOSECONDS.             } else {                 isNanosecond = false.             }             final DocValueFormat format.             String formatDesc = fieldAndFormat.format.             if (Objects.equals(formatDesc, USE_DEFAULT_FORMAT)) {                 // TODO: Remove in 8.x                 formatDesc = null.             }             if (isNanosecond) {                 format = withNanosecondResolution(fieldType.docValueFormat(formatDesc, null)).             } else {                 format = fieldType.docValueFormat(formatDesc, null).             }             LeafReaderContext subReaderContext = null.             AtomicFieldData data = null.             // binary / string / ip fields             SortedBinaryDocValues binaryValues = null.             // int / date fields             SortedNumericDocValues longValues = null.             // floating-point fields             SortedNumericDoubleValues doubleValues = null.             for (SearchHit hit : hits) {                 // if the reader index has changed we need to get a new doc values reader instance                 if (subReaderContext == null || hit.docId() >= subReaderContext.docBase + subReaderContext.reader().maxDoc()) {                     int readerIndex = ReaderUtil.subIndex(hit.docId(), context.searcher().getIndexReader().leaves()).                     subReaderContext = context.searcher().getIndexReader().leaves().get(readerIndex).                     data = indexFieldData.load(subReaderContext).                     if (indexFieldData instanceof IndexNumericFieldData) {                         NumericType numericType = ((IndexNumericFieldData) indexFieldData).getNumericType().                         if (numericType.isFloatingPoint()) {                             doubleValues = ((AtomicNumericFieldData) data).getDoubleValues().                         } else {                             // however for doc value fields we need the original nanosecond longs                             if (isNanosecond) {                                 longValues = ((SortedNumericDVIndexFieldData.NanoSecondFieldData) data).getLongValuesAsNanos().                             } else {                                 longValues = ((AtomicNumericFieldData) data).getLongValues().                             }                         }                     } else {                         data = indexFieldData.load(subReaderContext).                         binaryValues = data.getBytesValues().                     }                 }                 if (hit.fieldsOrNull() == null) {                     hit.fields(new HashMap<>(2)).                 }                 DocumentField hitField = hit.getFields().get(field).                 if (hitField == null) {                     hitField = new DocumentField(field, new ArrayList<>(2)).                     hit.getFields().put(field, hitField).                 }                 final List<Object> values = hitField.getValues().                 int subDocId = hit.docId() - subReaderContext.docBase.                 if (binaryValues != null) {                     if (binaryValues.advanceExact(subDocId)) {                         for (int i = 0, count = binaryValues.docValueCount(). i < count. ++i) {                             values.add(format.format(binaryValues.nextValue())).                         }                     }                 } else if (longValues != null) {                     if (longValues.advanceExact(subDocId)) {                         for (int i = 0, count = longValues.docValueCount(). i < count. ++i) {                             values.add(format.format(longValues.nextValue())).                         }                     }                 } else if (doubleValues != null) {                     if (doubleValues.advanceExact(subDocId)) {                         for (int i = 0, count = doubleValues.docValueCount(). i < count. ++i) {                             values.add(format.format(doubleValues.nextValue())).                         }                     }                 } else {                     throw new AssertionError("Unreachable code").                 }             }         }     } }
