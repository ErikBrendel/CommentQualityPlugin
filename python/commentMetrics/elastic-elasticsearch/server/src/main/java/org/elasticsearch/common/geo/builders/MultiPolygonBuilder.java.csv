commented;modifiers;parameterAmount;loc;comment;code
false;public;1;8;;@Override public void writeTo(StreamOutput out) throws IOException {     orientation.writeTo(out).     out.writeVInt(polygons.size()).     for (PolygonBuilder polygon : polygons) {         polygon.writeTo(out).     } }
false;public;0;3;;public Orientation orientation() {     return this.orientation. }
true;public;1;8;/**  * Add a shallow copy of the polygon to the multipolygon. This will apply the orientation of the  * {@link MultiPolygonBuilder} to the polygon if polygon has different orientation.  */ ;/**  * Add a shallow copy of the polygon to the multipolygon. This will apply the orientation of the  * {@link MultiPolygonBuilder} to the polygon if polygon has different orientation.  */ public MultiPolygonBuilder polygon(PolygonBuilder polygon) {     PolygonBuilder pb = new PolygonBuilder(new CoordinatesBuilder().coordinates(polygon.shell().coordinates(false)), this.orientation).     for (LineStringBuilder hole : polygon.holes()) {         pb.hole(hole).     }     this.polygons.add(pb).     return this. }
true;public;0;3;/**  * get the list of polygons  */ ;/**  * get the list of polygons  */ public List<PolygonBuilder> polygons() {     return polygons. }
false;private,static;1;11;;private static String polygonCoordinatesToWKT(PolygonBuilder polygon) {     StringBuilder sb = new StringBuilder().     sb.append(GeoWKTParser.LPAREN).     sb.append(ShapeBuilder.coordinateListToWKT(polygon.shell().coordinates)).     for (LineStringBuilder hole : polygon.holes()) {         sb.append(GeoWKTParser.COMMA).         sb.append(ShapeBuilder.coordinateListToWKT(hole.coordinates)).     }     sb.append(GeoWKTParser.RPAREN).     return sb.toString(). }
false;protected;0;18;;@Override protected StringBuilder contentToWKT() {     final StringBuilder sb = new StringBuilder().     if (polygons.isEmpty()) {         sb.append(GeoWKTParser.EMPTY).     } else {         sb.append(GeoWKTParser.LPAREN).         if (polygons.size() > 0) {             sb.append(polygonCoordinatesToWKT(polygons.get(0))).         }         for (int i = 1. i < polygons.size(). ++i) {             sb.append(GeoWKTParser.COMMA).             sb.append(polygonCoordinatesToWKT(polygons.get(i))).         }         sb.append(GeoWKTParser.RPAREN).     }     return sb. }
false;public;2;14;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.field(ShapeParser.FIELD_TYPE.getPreferredName(), TYPE.shapeName()).     builder.field(ShapeParser.FIELD_ORIENTATION.getPreferredName(), orientation.name().toLowerCase(Locale.ROOT)).     builder.startArray(ShapeParser.FIELD_COORDINATES.getPreferredName()).     for (PolygonBuilder polygon : polygons) {         builder.startArray().         polygon.coordinatesArray(builder, params).         builder.endArray().     }     builder.endArray().     return builder.endObject(). }
false;public;0;4;;@Override public GeoShapeType type() {     return TYPE. }
false;public;0;8;;@Override public int numDimensions() {     if (polygons == null || polygons.isEmpty()) {         throw new IllegalStateException("unable to get number of dimensions, " + "Polygons have not yet been initialized").     }     return polygons.get(0).numDimensions(). }
false;public;0;22;;@Override public Shape buildS4J() {     List<Shape> shapes = new ArrayList<>(this.polygons.size()).     if (wrapdateline) {         for (PolygonBuilder polygon : this.polygons) {             for (Coordinate[][] part : polygon.coordinates()) {                 shapes.add(jtsGeometry(PolygonBuilder.polygonS4J(FACTORY, part))).             }         }     } else {         for (PolygonBuilder polygon : this.polygons) {             shapes.add(jtsGeometry(polygon.toPolygonS4J(FACTORY))).         }     }     if (shapes.size() == 1)         return shapes.get(0).     else         return new XShapeCollection<>(shapes, SPATIAL_CONTEXT). // note: ShapeCollection is probably faster than a Multi* geom. }
false;public;0;18;;@SuppressWarnings({ "unchecked" }) @Override public MultiPolygon buildGeometry() {     List<org.elasticsearch.geo.geometry.Polygon> shapes = new ArrayList<>(this.polygons.size()).     Object poly.     for (PolygonBuilder polygon : this.polygons) {         poly = polygon.buildGeometry().         if (poly instanceof List) {             shapes.addAll((List<org.elasticsearch.geo.geometry.Polygon>) poly).         } else {             shapes.add((org.elasticsearch.geo.geometry.Polygon) poly).         }     }     if (shapes.isEmpty()) {         return MultiPolygon.EMPTY.     }     return new MultiPolygon(shapes). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(polygons, orientation). }
false;public;1;12;;@Override public boolean equals(Object obj) {     if (this == obj) {         return true.     }     if (obj == null || getClass() != obj.getClass()) {         return false.     }     MultiPolygonBuilder other = (MultiPolygonBuilder) obj.     return Objects.equals(polygons, other.polygons) && Objects.equals(orientation, other.orientation). }
