commented;modifiers;parameterAmount;loc;comment;code
true;public,static;2;27;/**  * Reduces the given lists of addAggregation.  *  * @param aggregationsList  A list of aggregation to reduce  * @return                  The reduced addAggregation  */ ;/**  * Reduces the given lists of addAggregation.  *  * @param aggregationsList  A list of aggregation to reduce  * @return                  The reduced addAggregation  */ public static InternalAggregations reduce(List<InternalAggregations> aggregationsList, ReduceContext context) {     if (aggregationsList.isEmpty()) {         return null.     }     // first we collect all aggregations of the same type and list them together     Map<String, List<InternalAggregation>> aggByName = new HashMap<>().     for (InternalAggregations aggregations : aggregationsList) {         for (Aggregation aggregation : aggregations.aggregations) {             List<InternalAggregation> aggs = aggByName.computeIfAbsent(aggregation.getName(), k -> new ArrayList<>(aggregationsList.size())).             aggs.add((InternalAggregation) aggregation).         }     }     // now we can use the first aggregation of each list to handle the reduce of its list     List<InternalAggregation> reducedAggregations = new ArrayList<>().     for (Map.Entry<String, List<InternalAggregation>> entry : aggByName.entrySet()) {         List<InternalAggregation> aggregations = entry.getValue().         // Sort aggregations so that unmapped aggs come last in the list         // If all aggs are unmapped, the agg that leads the reduction will just return itself         aggregations.sort(INTERNAL_AGG_COMPARATOR).         // the list can't be empty as it's created on demand         InternalAggregation first = aggregations.get(0).         reducedAggregations.add(first.reduce(aggregations, context)).     }     return new InternalAggregations(reducedAggregations). }
false;public,static;1;5;;public static InternalAggregations readAggregations(StreamInput in) throws IOException {     InternalAggregations result = new InternalAggregations().     result.readFrom(in).     return result. }
false;public;1;7;;@Override public void readFrom(StreamInput in) throws IOException {     aggregations = in.readList(stream -> in.readNamedWriteable(InternalAggregation.class)).     if (aggregations.isEmpty()) {         aggregationsAsMap = emptyMap().     } }
false;public;1;5;;@Override @SuppressWarnings("unchecked") public void writeTo(StreamOutput out) throws IOException {     out.writeNamedWriteableList((List<InternalAggregation>) aggregations). }
