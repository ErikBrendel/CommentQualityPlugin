commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;6;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     out.writeString(fieldName).     out.writeBytesReference(functionBytes).     multiValueMode.writeTo(out). }
false;public;0;3;;public String getFieldName() {     return this.fieldName. }
false;public;0;3;;public BytesReference getFunctionBytes() {     return this.functionBytes. }
false;public;2;9;;@Override public void doXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject(getName()).     try (InputStream stream = functionBytes.streamInput()) {         builder.rawField(fieldName, stream).     }     builder.field(DecayFunctionParser.MULTI_VALUE_MODE.getPreferredName(), multiValueMode.name()).     builder.endObject(). }
false;public;1;8;;@SuppressWarnings("unchecked") public DFB setMultiValueMode(MultiValueMode multiValueMode) {     if (multiValueMode == null) {         throw new IllegalArgumentException("decay function: multi_value_mode must not be null").     }     this.multiValueMode = multiValueMode.     return (DFB) this. }
false;public;0;3;;public MultiValueMode getMultiValueMode() {     return this.multiValueMode. }
false;protected;1;6;;@Override protected boolean doEquals(DFB functionBuilder) {     return Objects.equals(this.fieldName, functionBuilder.getFieldName()) && Objects.equals(this.functionBytes, functionBuilder.getFunctionBytes()) && Objects.equals(this.multiValueMode, functionBuilder.getMultiValueMode()). }
false;protected;0;4;;@Override protected int doHashCode() {     return Objects.hash(this.fieldName, this.functionBytes, this.multiValueMode). }
false;protected;1;11;;@Override protected ScoreFunction doToFunction(QueryShardContext context) throws IOException {     AbstractDistanceScoreFunction scoreFunction.     // EMPTY is safe because parseVariable doesn't use namedObject     try (InputStream stream = functionBytes.streamInput().         XContentParser parser = XContentFactory.xContent(XContentHelper.xContentType(functionBytes)).createParser(NamedXContentRegistry.EMPTY, LoggingDeprecationHandler.INSTANCE, stream)) {         scoreFunction = parseVariable(fieldName, parser, context, multiValueMode).     }     return scoreFunction. }
true;protected,abstract;0;1;/**  * Override this function if you want to produce your own scorer.  */ ;/**  * Override this function if you want to produce your own scorer.  */ protected abstract DecayFunction getDecayFunction().
false;private;4;21;;private AbstractDistanceScoreFunction parseVariable(String fieldName, XContentParser parser, QueryShardContext context, MultiValueMode mode) throws IOException {     // the field must exist, else we cannot read the value for the doc later     MappedFieldType fieldType = context.fieldMapper(fieldName).     if (fieldType == null) {         throw new ParsingException(parser.getTokenLocation(), "unknown field [{}]", fieldName).     }     // dates and time and geo need special handling     parser.nextToken().     if (fieldType instanceof DateFieldMapper.DateFieldType) {         return parseDateVariable(parser, context, fieldType, mode).     } else if (fieldType instanceof GeoPointFieldType) {         return parseGeoVariable(parser, context, fieldType, mode).     } else if (fieldType instanceof NumberFieldMapper.NumberFieldType) {         return parseNumberVariable(parser, context, fieldType, mode).     } else {         throw new ParsingException(parser.getTokenLocation(), "field [{}] is of type [{}], but only numeric types are supported.", fieldName, fieldType).     } }
false;private;4;34;;private AbstractDistanceScoreFunction parseNumberVariable(XContentParser parser, QueryShardContext context, MappedFieldType fieldType, MultiValueMode mode) throws IOException {     XContentParser.Token token.     String parameterName = null.     double scale = 0.     double origin = 0.     double decay = 0.5.     double offset = 0.0d.     boolean scaleFound = false.     boolean refFound = false.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             parameterName = parser.currentName().         } else if (DecayFunctionBuilder.SCALE.equals(parameterName)) {             scale = parser.doubleValue().             scaleFound = true.         } else if (DecayFunctionBuilder.DECAY.equals(parameterName)) {             decay = parser.doubleValue().         } else if (DecayFunctionBuilder.ORIGIN.equals(parameterName)) {             origin = parser.doubleValue().             refFound = true.         } else if (DecayFunctionBuilder.OFFSET.equals(parameterName)) {             offset = parser.doubleValue().         } else {             throw new ElasticsearchParseException("parameter [{}] not supported!", parameterName).         }     }     if (!scaleFound || !refFound) {         throw new ElasticsearchParseException("both [{}] and [{}] must be set for numeric fields.", DecayFunctionBuilder.SCALE, DecayFunctionBuilder.ORIGIN).     }     IndexNumericFieldData numericFieldData = context.getForField(fieldType).     return new NumericFieldDataScoreFunction(origin, scale, decay, offset, getDecayFunction(), numericFieldData, mode). }
false;private;4;33;;private AbstractDistanceScoreFunction parseGeoVariable(XContentParser parser, QueryShardContext context, MappedFieldType fieldType, MultiValueMode mode) throws IOException {     XContentParser.Token token.     String parameterName = null.     GeoPoint origin = new GeoPoint().     String scaleString = null.     String offsetString = "0km".     double decay = 0.5.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             parameterName = parser.currentName().         } else if (DecayFunctionBuilder.SCALE.equals(parameterName)) {             scaleString = parser.text().         } else if (DecayFunctionBuilder.ORIGIN.equals(parameterName)) {             origin = GeoUtils.parseGeoPoint(parser).         } else if (DecayFunctionBuilder.DECAY.equals(parameterName)) {             decay = parser.doubleValue().         } else if (DecayFunctionBuilder.OFFSET.equals(parameterName)) {             offsetString = parser.text().         } else {             throw new ElasticsearchParseException("parameter [{}] not supported!", parameterName).         }     }     if (origin == null || scaleString == null) {         throw new ElasticsearchParseException("[{}] and [{}] must be set for geo fields.", DecayFunctionBuilder.ORIGIN, DecayFunctionBuilder.SCALE).     }     double scale = DistanceUnit.DEFAULT.parse(scaleString, DistanceUnit.DEFAULT).     double offset = DistanceUnit.DEFAULT.parse(offsetString, DistanceUnit.DEFAULT).     IndexGeoPointFieldData indexFieldData = context.getForField(fieldType).     return new GeoFieldDataScoreFunction(origin, scale, decay, offset, getDecayFunction(), indexFieldData, mode). }
false;private;4;41;;private AbstractDistanceScoreFunction parseDateVariable(XContentParser parser, QueryShardContext context, MappedFieldType dateFieldType, MultiValueMode mode) throws IOException {     XContentParser.Token token.     String parameterName = null.     String scaleString = null.     String originString = null.     String offsetString = "0d".     double decay = 0.5.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             parameterName = parser.currentName().         } else if (DecayFunctionBuilder.SCALE.equals(parameterName)) {             scaleString = parser.text().         } else if (DecayFunctionBuilder.ORIGIN.equals(parameterName)) {             originString = parser.text().         } else if (DecayFunctionBuilder.DECAY.equals(parameterName)) {             decay = parser.doubleValue().         } else if (DecayFunctionBuilder.OFFSET.equals(parameterName)) {             offsetString = parser.text().         } else {             throw new ElasticsearchParseException("parameter [{}] not supported!", parameterName).         }     }     long origin.     if (originString == null) {         origin = context.nowInMillis().     } else {         origin = ((DateFieldMapper.DateFieldType) dateFieldType).parseToLong(originString, false, null, null, context).     }     if (scaleString == null) {         throw new ElasticsearchParseException("[{}] must be set for date fields.", DecayFunctionBuilder.SCALE).     }     TimeValue val = TimeValue.parseTimeValue(scaleString, TimeValue.timeValueHours(24), DecayFunctionParser.class.getSimpleName() + ".scale").     double scale = val.getMillis().     val = TimeValue.parseTimeValue(offsetString, TimeValue.timeValueHours(24), DecayFunctionParser.class.getSimpleName() + ".offset").     double offset = val.getMillis().     IndexNumericFieldData numericFieldData = context.getForField(dateFieldType).     return new NumericFieldDataScoreFunction(origin, scale, decay, offset, getDecayFunction(), numericFieldData, mode). }
false;public;0;4;;@Override public boolean needsScores() {     return false. }
false;public;1;17;;@Override public boolean advanceExact(int docId) throws IOException {     if (geoPointValues.advanceExact(docId)) {         int n = geoPointValues.docValueCount().         resize(n).         for (int i = 0. i < n. i++) {             GeoPoint other = geoPointValues.nextValue().             double distance = distFunction.calculate(origin.lat(), origin.lon(), other.lat(), other.lon(), DistanceUnit.METERS).             values[i] = Math.max(0.0d, distance - offset).         }         sort().         return true.     } else {         return false.     } }
false;protected;1;23;;@Override protected NumericDoubleValues distance(LeafReaderContext context) {     final MultiGeoPointValues geoPointValues = fieldData.load(context).getGeoPointValues().     return FieldData.replaceMissing(mode.select(new SortingNumericDoubleValues() {          @Override         public boolean advanceExact(int docId) throws IOException {             if (geoPointValues.advanceExact(docId)) {                 int n = geoPointValues.docValueCount().                 resize(n).                 for (int i = 0. i < n. i++) {                     GeoPoint other = geoPointValues.nextValue().                     double distance = distFunction.calculate(origin.lat(), origin.lon(), other.lat(), other.lon(), DistanceUnit.METERS).                     values[i] = Math.max(0.0d, distance - offset).                 }                 sort().                 return true.             } else {                 return false.             }         }     }), 0). }
false;protected;2;22;;@Override protected String getDistanceString(LeafReaderContext ctx, int docId) throws IOException {     StringBuilder values = new StringBuilder(mode.name()).     values.append(" of: [").     final MultiGeoPointValues geoPointValues = fieldData.load(ctx).getGeoPointValues().     if (geoPointValues.advanceExact(docId)) {         final int num = geoPointValues.docValueCount().         for (int i = 0. i < num. i++) {             GeoPoint value = geoPointValues.nextValue().             values.append("Math.max(arcDistance(").             values.append(value).append("(=doc value),").             values.append(origin).append("(=origin)) - ").append(offset).append("(=offset), 0)").             if (i != num - 1) {                 values.append(", ").             }         }     } else {         values.append("0.0").     }     values.append("]").     return values.toString(). }
false;protected;0;4;;@Override protected String getFieldName() {     return fieldData.getFieldName(). }
false;protected;1;6;;@Override protected boolean doEquals(ScoreFunction other) {     GeoFieldDataScoreFunction geoFieldDataScoreFunction = (GeoFieldDataScoreFunction) other.     return super.doEquals(other) && Objects.equals(this.origin, geoFieldDataScoreFunction.origin). }
false;protected;0;4;;@Override protected int doHashCode() {     return Objects.hash(super.doHashCode(), origin). }
false;public;0;4;;@Override public boolean needsScores() {     return false. }
false;public;1;14;;@Override public boolean advanceExact(int docId) throws IOException {     if (doubleValues.advanceExact(docId)) {         int n = doubleValues.docValueCount().         resize(n).         for (int i = 0. i < n. i++) {             values[i] = Math.max(0.0d, Math.abs(doubleValues.nextValue() - origin) - offset).         }         sort().         return true.     } else {         return false.     } }
false;protected;1;20;;@Override protected NumericDoubleValues distance(LeafReaderContext context) {     final SortedNumericDoubleValues doubleValues = fieldData.load(context).getDoubleValues().     return FieldData.replaceMissing(mode.select(new SortingNumericDoubleValues() {          @Override         public boolean advanceExact(int docId) throws IOException {             if (doubleValues.advanceExact(docId)) {                 int n = doubleValues.docValueCount().                 resize(n).                 for (int i = 0. i < n. i++) {                     values[i] = Math.max(0.0d, Math.abs(doubleValues.nextValue() - origin) - offset).                 }                 sort().                 return true.             } else {                 return false.             }         }     }), 0). }
false;protected;2;25;;@Override protected String getDistanceString(LeafReaderContext ctx, int docId) throws IOException {     StringBuilder values = new StringBuilder(mode.name()).     values.append("[").     final SortedNumericDoubleValues doubleValues = fieldData.load(ctx).getDoubleValues().     if (doubleValues.advanceExact(docId)) {         final int num = doubleValues.docValueCount().         for (int i = 0. i < num. i++) {             double value = doubleValues.nextValue().             values.append("Math.max(Math.abs(").             values.append(value).append("(=doc value) - ").             values.append(origin).append("(=origin))) - ").             values.append(offset).append("(=offset), 0)").             if (i != num - 1) {                 values.append(", ").             }         }     } else {         values.append("0.0").     }     values.append("]").     return values.toString(). }
false;protected;0;4;;@Override protected String getFieldName() {     return fieldData.getFieldName(). }
false;protected;1;8;;@Override protected boolean doEquals(ScoreFunction other) {     NumericFieldDataScoreFunction numericFieldDataScoreFunction = (NumericFieldDataScoreFunction) other.     if (super.doEquals(other) == false) {         return false.     }     return Objects.equals(this.origin, numericFieldDataScoreFunction.origin). }
true;protected,abstract;1;1;/**  * This function computes the distance from a defined origin. Since  * the value of the document is read from the index, it cannot be  * guaranteed that the value actually exists. If it does not, we assume  * the user handles this case in the query and return 0.  */ ;/**  * This function computes the distance from a defined origin. Since  * the value of the document is read from the index, it cannot be  * guaranteed that the value actually exists. If it does not, we assume  * the user handles this case in the query and return 0.  */ protected abstract NumericDoubleValues distance(LeafReaderContext context).
false;public;2;8;;@Override public double score(int docId, float subQueryScore) throws IOException {     if (distance.advanceExact(docId)) {         return func.evaluate(distance.doubleValue(), scale).     } else {         return 0.     } }
false;public;2;11;;@Override public Explanation explainScore(int docId, Explanation subQueryScore) throws IOException {     if (distance.advanceExact(docId) == false) {         return Explanation.noMatch("No value for the distance").     }     double value = distance.doubleValue().     return Explanation.match((float) score(docId, subQueryScore.getValue().floatValue()), "Function for field " + getFieldName() + ":", func.explainFunction(getDistanceString(ctx, docId), value, scale)). }
false;public,final;1;27;;@Override public final LeafScoreFunction getLeafScoreFunction(final LeafReaderContext ctx) {     final NumericDoubleValues distance = distance(ctx).     return new LeafScoreFunction() {          @Override         public double score(int docId, float subQueryScore) throws IOException {             if (distance.advanceExact(docId)) {                 return func.evaluate(distance.doubleValue(), scale).             } else {                 return 0.             }         }          @Override         public Explanation explainScore(int docId, Explanation subQueryScore) throws IOException {             if (distance.advanceExact(docId) == false) {                 return Explanation.noMatch("No value for the distance").             }             double value = distance.doubleValue().             return Explanation.match((float) score(docId, subQueryScore.getValue().floatValue()), "Function for field " + getFieldName() + ":", func.explainFunction(getDistanceString(ctx, docId), value, scale)).         }     }. }
false;protected,abstract;2;1;;protected abstract String getDistanceString(LeafReaderContext ctx, int docId) throws IOException.
false;protected,abstract;0;1;;protected abstract String getFieldName().
false;protected;1;9;;@Override protected boolean doEquals(ScoreFunction other) {     AbstractDistanceScoreFunction distanceScoreFunction = (AbstractDistanceScoreFunction) other.     return Objects.equals(this.scale, distanceScoreFunction.scale) && Objects.equals(this.offset, distanceScoreFunction.offset) && Objects.equals(this.mode, distanceScoreFunction.mode) && Objects.equals(this.func, distanceScoreFunction.func) && Objects.equals(this.getFieldName(), distanceScoreFunction.getFieldName()). }
false;protected;0;4;;@Override protected int doHashCode() {     return Objects.hash(scale, offset, mode, func, getFieldName()). }
