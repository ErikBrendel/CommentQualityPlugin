commented;modifiers;parameterAmount;loc;comment;code
false;public;3;4;;@Override public void list(ShardId shardId, DiscoveryNode[] nodes, ActionListener<NodesStoreFilesMetaData> listener) {     execute(new Request(shardId, nodes), listener). }
false;protected;2;4;;@Override protected NodeRequest newNodeRequest(String nodeId, Request request) {     return new NodeRequest(nodeId, request). }
false;protected;0;4;;@Override protected NodeStoreFilesMetaData newNodeResponse() {     return new NodeStoreFilesMetaData(). }
false;protected;3;5;;@Override protected NodesStoreFilesMetaData newResponse(Request request, List<NodeStoreFilesMetaData> responses, List<FailedNodeException> failures) {     return new NodesStoreFilesMetaData(clusterService.getClusterName(), responses, failures). }
false;protected;1;8;;@Override protected NodeStoreFilesMetaData nodeOperation(NodeRequest request) {     try {         return new NodeStoreFilesMetaData(clusterService.localNode(), listStoreMetaData(request.shardId)).     } catch (IOException e) {         throw new ElasticsearchException("Failed to list store metadata for shard [" + request.shardId + "]", e).     } }
false;private;1;47;;private StoreFilesMetaData listStoreMetaData(ShardId shardId) throws IOException {     logger.trace("listing store meta data for {}", shardId).     long startTimeNS = System.nanoTime().     boolean exists = false.     try {         IndexService indexService = indicesService.indexService(shardId.getIndex()).         if (indexService != null) {             IndexShard indexShard = indexService.getShardOrNull(shardId.id()).             if (indexShard != null) {                 exists = true.                 return new StoreFilesMetaData(shardId, indexShard.snapshotStoreMetadata()).             }         }         // try and see if we an list unallocated         IndexMetaData metaData = clusterService.state().metaData().index(shardId.getIndex()).         if (metaData == null) {             // we may send this requests while processing the cluster state that recovered the index             // sometimes the request comes in before the local node processed that cluster state             // in such cases we can load it from disk             metaData = IndexMetaData.FORMAT.loadLatestState(logger, namedXContentRegistry, nodeEnv.indexPaths(shardId.getIndex())).         }         if (metaData == null) {             logger.trace("{} node doesn't have meta data for the requests index, responding with empty", shardId).             return new StoreFilesMetaData(shardId, Store.MetadataSnapshot.EMPTY).         }         final IndexSettings indexSettings = indexService != null ? indexService.getIndexSettings() : new IndexSettings(metaData, settings).         final ShardPath shardPath = ShardPath.loadShardPath(logger, nodeEnv, shardId, indexSettings).         if (shardPath == null) {             return new StoreFilesMetaData(shardId, Store.MetadataSnapshot.EMPTY).         }         // reuse local resources.         return new StoreFilesMetaData(shardId, Store.readMetadataSnapshot(shardPath.resolveIndex(), shardId, nodeEnv::shardLock, logger)).     } finally {         TimeValue took = new TimeValue(System.nanoTime() - startTimeNS, TimeUnit.NANOSECONDS).         if (exists) {             logger.debug("{} loaded store meta data (took [{}])", shardId, took).         } else {             logger.trace("{} didn't find any store meta data to load (took [{}])", shardId, took).         }     } }
false;public;0;3;;public ShardId shardId() {     return this.shardId. }
false;public;0;3;;public boolean isEmpty() {     return metadataSnapshot.size() == 0. }
false;public;0;4;;@Override public Iterator<StoreFileMetaData> iterator() {     return metadataSnapshot.iterator(). }
false;public;1;3;;public boolean fileExists(String name) {     return metadataSnapshot.asMap().containsKey(name). }
false;public;1;3;;public StoreFileMetaData file(String name) {     return metadataSnapshot.asMap().get(name). }
false;public,static;1;5;;public static StoreFilesMetaData readStoreFilesMetaData(StreamInput in) throws IOException {     StoreFilesMetaData md = new StoreFilesMetaData().     md.readFrom(in).     return md. }
false;public;1;5;;@Override public void readFrom(StreamInput in) throws IOException {     shardId = ShardId.readShardId(in).     this.metadataSnapshot = new Store.MetadataSnapshot(in). }
false;public;1;5;;@Override public void writeTo(StreamOutput out) throws IOException {     shardId.writeTo(out).     metadataSnapshot.writeTo(out). }
true;public;0;3;/**  * @return commit sync id if exists, else null  */ ;/**  * @return commit sync id if exists, else null  */ public String syncId() {     return metadataSnapshot.getSyncId(). }
false;public;0;7;;@Override public String toString() {     return "StoreFilesMetaData{" + ", shardId=" + shardId + ", metadataSnapshot{size=" + metadataSnapshot.size() + ", syncId=" + metadataSnapshot.getSyncId() + "}" + '}'. }
false;public;1;5;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     shardId = ShardId.readShardId(in). }
false;public;1;5;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     shardId.writeTo(out). }
false;protected;1;4;;@Override protected List<NodeStoreFilesMetaData> readNodesFrom(StreamInput in) throws IOException {     return in.readList(NodeStoreFilesMetaData::readListShardStoreNodeOperationResponse). }
false;protected;2;4;;@Override protected void writeNodesTo(StreamOutput out, List<NodeStoreFilesMetaData> nodes) throws IOException {     out.writeStreamableList(nodes). }
false;public;1;5;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     shardId = ShardId.readShardId(in). }
false;public;1;5;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     shardId.writeTo(out). }
false;public;0;3;;public StoreFilesMetaData storeFilesMetaData() {     return storeFilesMetaData. }
false;public,static;1;5;;public static NodeStoreFilesMetaData readListShardStoreNodeOperationResponse(StreamInput in) throws IOException {     NodeStoreFilesMetaData resp = new NodeStoreFilesMetaData().     resp.readFrom(in).     return resp. }
false;public;1;5;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     storeFilesMetaData = StoreFilesMetaData.readStoreFilesMetaData(in). }
false;public;1;5;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     storeFilesMetaData.writeTo(out). }
false;public;0;4;;@Override public String toString() {     return "[[" + getNode() + "][" + storeFilesMetaData + "]]". }
