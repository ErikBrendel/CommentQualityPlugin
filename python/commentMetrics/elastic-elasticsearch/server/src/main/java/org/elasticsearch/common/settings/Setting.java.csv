commented;modifiers;parameterAmount;loc;comment;code
false;private;2;5;;private void checkPropertyRequiresIndexScope(final EnumSet<Property> properties, final Property property) {     if (properties.contains(property) && properties.contains(Property.IndexScope) == false) {         throw new IllegalArgumentException("non-index-scoped setting [" + key + "] can not have property [" + property + "]").     } }
true;public,final;0;3;/**  * Returns the settings key or a prefix if this setting is a group setting.  * <b>Note: this method should not be used to retrieve a value from a {@link Settings} object.  * Use {@link #get(Settings)} instead</b>  *  * @see #isGroupSetting()  */ ;/**  * Returns the settings key or a prefix if this setting is a group setting.  * <b>Note: this method should not be used to retrieve a value from a {@link Settings} object.  * Use {@link #get(Settings)} instead</b>  *  * @see #isGroupSetting()  */ public final String getKey() {     return key.toString(). }
true;public,final;0;3;/**  * Returns the original representation of a setting key.  */ ;/**  * Returns the original representation of a setting key.  */ public final Key getRawKey() {     return key. }
true;public,final;0;3;/**  * Returns <code>true</code> if this setting is dynamically updateable, otherwise <code>false</code>  */ ;/**  * Returns <code>true</code> if this setting is dynamically updateable, otherwise <code>false</code>  */ public final boolean isDynamic() {     return properties.contains(Property.Dynamic). }
true;public,final;0;3;/**  * Returns <code>true</code> if this setting is final, otherwise <code>false</code>  */ ;/**  * Returns <code>true</code> if this setting is final, otherwise <code>false</code>  */ public final boolean isFinal() {     return properties.contains(Property.Final). }
false;public,final;0;3;;public final boolean isInternalIndex() {     return properties.contains(Property.InternalIndex). }
false;public,final;0;3;;public final boolean isPrivateIndex() {     return properties.contains(Property.PrivateIndex). }
true;public;0;3;/**  * Returns the setting properties  * @see Property  */ ;/**  * Returns the setting properties  * @see Property  */ public EnumSet<Property> getProperties() {     return properties. }
true;public;0;3;/**  * Returns <code>true</code> if this setting must be filtered, otherwise <code>false</code>  */ ;/**  * Returns <code>true</code> if this setting must be filtered, otherwise <code>false</code>  */ public boolean isFiltered() {     return properties.contains(Property.Filtered). }
true;public;0;3;/**  * Returns <code>true</code> if this setting has a node scope, otherwise <code>false</code>  */ ;/**  * Returns <code>true</code> if this setting has a node scope, otherwise <code>false</code>  */ public boolean hasNodeScope() {     return properties.contains(Property.NodeScope). }
true;public;0;3;/**  * Returns <code>true</code> if this setting has an index scope, otherwise <code>false</code>  */ ;/**  * Returns <code>true</code> if this setting has an index scope, otherwise <code>false</code>  */ public boolean hasIndexScope() {     return properties.contains(Property.IndexScope). }
true;public;0;3;/**  * Returns <code>true</code> if this setting is deprecated, otherwise <code>false</code>  */ ;/**  * Returns <code>true</code> if this setting is deprecated, otherwise <code>false</code>  */ public boolean isDeprecated() {     return properties.contains(Property.Deprecated). }
true;;0;3;/**  * Returns <code>true</code> iff this setting is a group setting. Group settings represent a set of settings rather than a single value.  * The key, see {@link #getKey()}, in contrast to non-group settings is a prefix like {@code cluster.store.} that matches all settings  * with this prefix.  */ ;/**  * Returns <code>true</code> iff this setting is a group setting. Group settings represent a set of settings rather than a single value.  * The key, see {@link #getKey()}, in contrast to non-group settings is a prefix like {@code cluster.store.} that matches all settings  * with this prefix.  */ boolean isGroupSetting() {     return false. }
false;final;0;3;;final boolean isListSetting() {     return this instanceof ListSetting. }
false;;0;3;;boolean hasComplexMatcher() {     return isGroupSetting(). }
true;;1;3;/**  * Validate the current setting value only without dependencies with {@link Setting.Validator#validate(Object)}.  * @param settings a settings object for settings that has a default value depending on another setting if available  */ ;/**  * Validate the current setting value only without dependencies with {@link Setting.Validator#validate(Object)}.  * @param settings a settings object for settings that has a default value depending on another setting if available  */ void validateWithoutDependencies(Settings settings) {     validator.validate(get(settings, false)). }
true;public;1;3;/**  * Returns the default value string representation for this setting.  * @param settings a settings object for settings that has a default value depending on another setting if available  */ ;/**  * Returns the default value string representation for this setting.  * @param settings a settings object for settings that has a default value depending on another setting if available  */ public String getDefaultRaw(Settings settings) {     return defaultValue.apply(settings). }
true;public;1;3;/**  * Returns the default value for this setting.  * @param settings a settings object for settings that has a default value depending on another setting if available  */ ;/**  * Returns the default value for this setting.  * @param settings a settings object for settings that has a default value depending on another setting if available  */ public T getDefault(Settings settings) {     return parser.apply(getDefaultRaw(settings)). }
true;public;1;3;/**  * Returns true if and only if this setting is present in the given settings instance. Note that fallback settings are excluded.  *  * @param settings the settings  * @return true if the setting is present in the given settings instance, otherwise false  */ ;/**  * Returns true if and only if this setting is present in the given settings instance. Note that fallback settings are excluded.  *  * @param settings the settings  * @return true if the setting is present in the given settings instance, otherwise false  */ public boolean exists(final Settings settings) {     return settings.keySet().contains(getKey()). }
true;public;1;3;/**  * Returns true if and only if this setting including fallback settings is present in the given settings instance.  *  * @param settings the settings  * @return true if the setting including fallback settings is present in the given settings instance, otherwise false  */ ;/**  * Returns true if and only if this setting including fallback settings is present in the given settings instance.  *  * @param settings the settings  * @return true if the setting including fallback settings is present in the given settings instance, otherwise false  */ public boolean existsOrFallbackExists(final Settings settings) {     return settings.keySet().contains(getKey()) || (fallbackSetting != null && fallbackSetting.existsOrFallbackExists(settings)). }
true;public;1;3;/**  * Returns the settings value. If the setting is not present in the given settings object the default value is returned  * instead.  */ ;/**  * Returns the settings value. If the setting is not present in the given settings object the default value is returned  * instead.  */ public T get(Settings settings) {     return get(settings, true). }
false;private;2;30;;private T get(Settings settings, boolean validate) {     String value = getRaw(settings).     try {         T parsed = parser.apply(value).         if (validate) {             final Iterator<Setting<T>> it = validator.settings().             final Map<Setting<T>, T> map.             if (it.hasNext()) {                 map = new HashMap<>().                 while (it.hasNext()) {                     final Setting<T> setting = it.next().                     // we have to disable validation or we will stack overflow                     map.put(setting, setting.get(settings, false)).                 }             } else {                 map = Collections.emptyMap().             }             validator.validate(parsed).             validator.validate(parsed, map).         }         return parsed.     } catch (ElasticsearchParseException ex) {         throw new IllegalArgumentException(ex.getMessage(), ex).     } catch (NumberFormatException ex) {         throw new IllegalArgumentException("Failed to parse value [" + value + "] for setting [" + getKey() + "]", ex).     } catch (IllegalArgumentException ex) {         throw ex.     } catch (Exception t) {         throw new IllegalArgumentException("Failed to parse value [" + value + "] for setting [" + getKey() + "]", t).     } }
true;public;3;5;/**  * Add this setting to the builder if it doesn't exists in the source settings.  * The value added to the builder is taken from the given default settings object.  * @param builder the settings builder to fill the diff into  * @param source the source settings object to diff  * @param defaultSettings the default settings object to diff against  */ ;/**  * Add this setting to the builder if it doesn't exists in the source settings.  * The value added to the builder is taken from the given default settings object.  * @param builder the settings builder to fill the diff into  * @param source the source settings object to diff  * @param defaultSettings the default settings object to diff against  */ public void diff(Settings.Builder builder, Settings source, Settings defaultSettings) {     if (exists(source) == false) {         builder.put(getKey(), getRaw(defaultSettings)).     } }
true;public,final;1;4;/**  * Returns the raw (string) settings value. If the setting is not present in the given settings object the default value is returned  * instead. This is useful if the value can't be parsed due to an invalid value to access the actual value.  */ ;/**  * Returns the raw (string) settings value. If the setting is not present in the given settings object the default value is returned  * instead. This is useful if the value can't be parsed due to an invalid value to access the actual value.  */ public final String getRaw(final Settings settings) {     checkDeprecation(settings).     return innerGetRaw(settings). }
true;;1;3;/**  * The underlying implementation for {@link #getRaw(Settings)}. Setting specializations can override this as needed to convert the  * actual settings value to raw strings.  *  * @param settings the settings instance  * @return the raw string representation of the setting value  */ ;/**  * The underlying implementation for {@link #getRaw(Settings)}. Setting specializations can override this as needed to convert the  * actual settings value to raw strings.  *  * @param settings the settings instance  * @return the raw string representation of the setting value  */ String innerGetRaw(final Settings settings) {     return settings.get(getKey(), defaultValue.apply(settings)). }
true;;1;12;/**  * Logs a deprecation warning if the setting is deprecated and used.  */ ;/**  * Logs a deprecation warning if the setting is deprecated and used.  */ void checkDeprecation(Settings settings) {     // They're using the setting, so we need to tell them to stop     if (this.isDeprecated() && this.exists(settings)) {         // It would be convenient to show its replacement key, but replacement is often not so simple         final String key = getKey().         Settings.DeprecationLoggerHolder.deprecationLogger.deprecatedAndMaybeLog(key, "[{}] setting was deprecated in Elasticsearch and will be removed in a future release! " + "See the breaking changes documentation for the next major version.", key).     } }
true;public,final;1;3;/**  * Returns <code>true</code> iff the given key matches the settings key or if this setting is a group setting if the  * given key is part of the settings group.  * @see #isGroupSetting()  */ ;/**  * Returns <code>true</code> iff the given key matches the settings key or if this setting is a group setting if the  * given key is part of the settings group.  * @see #isGroupSetting()  */ public final boolean match(String toTest) {     return key.match(toTest). }
false;public,final;2;10;;@Override public final XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.field("key", key.toString()).     builder.field("properties", properties).     builder.field("is_group_setting", isGroupSetting()).     builder.field("default", defaultValue.apply(Settings.EMPTY)).     builder.endObject().     return builder. }
false;public;0;4;;@Override public String toString() {     return Strings.toString(this, true, true). }
true;public,final;2;15;/**  * Returns the value for this setting but falls back to the second provided settings object  */ ;/**  * Returns the value for this setting but falls back to the second provided settings object  */ public final T get(Settings primary, Settings secondary) {     if (exists(primary)) {         return get(primary).     }     if (exists(secondary)) {         return get(secondary).     }     if (fallbackSetting == null) {         return get(primary).     }     if (fallbackSetting.exists(primary)) {         return fallbackSetting.get(primary).     }     return fallbackSetting.get(secondary). }
false;public;1;5;;public Setting<T> getConcreteSetting(String key) {     // we use startsWith here since the key might be foo.bar.0 if it's an array     assert key.startsWith(this.getKey()) : "was " + key + " expected: " + getKey().     return this. }
true;public;1;3;/**  * Returns a set of settings that are required at validation time. Unless all of the dependencies are present in the settings  * object validation of setting must fail.  */ ;/**  * Returns a set of settings that are required at validation time. Unless all of the dependencies are present in the settings  * object validation of setting must fail.  */ public Set<Setting<?>> getSettingsDependencies(String key) {     return Collections.emptySet(). }
true;final;2;3;/**  * Build a new updater with a noop validator.  */ ;/**  * Build a new updater with a noop validator.  */ final AbstractScopedSettings.SettingUpdater<T> newUpdater(Consumer<T> consumer, Logger logger) {     return newUpdater(consumer, logger, (s) -> {     }). }
true;;3;7;/**  * Build the updater responsible for validating new values, logging the new  * value, and eventually setting the value where it belongs.  */ ;/**  * Build the updater responsible for validating new values, logging the new  * value, and eventually setting the value where it belongs.  */ AbstractScopedSettings.SettingUpdater<T> newUpdater(Consumer<T> consumer, Logger logger, Consumer<T> validator) {     if (isDynamic()) {         return new Updater(consumer, logger, validator).     } else {         throw new IllegalStateException("setting [" + getKey() + "] is not dynamic").     } }
false;public;2;4;;@Override public boolean hasChanged(Settings current, Settings previous) {     return aSettingUpdater.hasChanged(current, previous) || bSettingUpdater.hasChanged(current, previous). }
false;public;2;7;;@Override public Tuple<A, B> getValue(Settings current, Settings previous) {     A valueA = aSettingUpdater.getValue(current, previous).     B valueB = bSettingUpdater.getValue(current, previous).     validator.accept(valueA, valueB).     return new Tuple<>(valueA, valueB). }
false;public;3;10;;@Override public void apply(Tuple<A, B> value, Settings current, Settings previous) {     if (aSettingUpdater.hasChanged(current, previous)) {         logSettingUpdate(aSetting, current, previous, logger).     }     if (bSettingUpdater.hasChanged(current, previous)) {         logSettingUpdate(bSetting, current, previous, logger).     }     consumer.accept(value.v1(), value.v2()). }
false;public;0;4;;@Override public String toString() {     return "CompoundUpdater for: " + aSettingUpdater + " and " + bSettingUpdater. }
true;static;5;35;/**  * Updates settings that depend on each other.  * See {@link AbstractScopedSettings#addSettingsUpdateConsumer(Setting, Setting, BiConsumer)} and its usage for details.  */ ;/**  * Updates settings that depend on each other.  * See {@link AbstractScopedSettings#addSettingsUpdateConsumer(Setting, Setting, BiConsumer)} and its usage for details.  */ static <A, B> AbstractScopedSettings.SettingUpdater<Tuple<A, B>> compoundUpdater(final BiConsumer<A, B> consumer, final BiConsumer<A, B> validator, final Setting<A> aSetting, final Setting<B> bSetting, Logger logger) {     final AbstractScopedSettings.SettingUpdater<A> aSettingUpdater = aSetting.newUpdater(null, logger).     final AbstractScopedSettings.SettingUpdater<B> bSettingUpdater = bSetting.newUpdater(null, logger).     return new AbstractScopedSettings.SettingUpdater<Tuple<A, B>>() {          @Override         public boolean hasChanged(Settings current, Settings previous) {             return aSettingUpdater.hasChanged(current, previous) || bSettingUpdater.hasChanged(current, previous).         }          @Override         public Tuple<A, B> getValue(Settings current, Settings previous) {             A valueA = aSettingUpdater.getValue(current, previous).             B valueB = bSettingUpdater.getValue(current, previous).             validator.accept(valueA, valueB).             return new Tuple<>(valueA, valueB).         }          @Override         public void apply(Tuple<A, B> value, Settings current, Settings previous) {             if (aSettingUpdater.hasChanged(current, previous)) {                 logSettingUpdate(aSetting, current, previous, logger).             }             if (bSettingUpdater.hasChanged(current, previous)) {                 logSettingUpdate(bSetting, current, previous, logger).             }             consumer.accept(value.v1(), value.v2()).         }          @Override         public String toString() {             return "CompoundUpdater for: " + aSettingUpdater + " and " + bSettingUpdater.         }     }. }
false;private;1;10;;private Settings get(Settings settings) {     return settings.filter(s -> {         for (Setting<?> setting : configuredSettings) {             if (setting.key.match(s)) {                 return true.             }         }         return false.     }). }
false;public;2;6;;@Override public boolean hasChanged(Settings current, Settings previous) {     Settings currentSettings = get(current).     Settings previousSettings = get(previous).     return currentSettings.equals(previousSettings) == false. }
false;public;2;4;;@Override public Settings getValue(Settings current, Settings previous) {     return get(current). }
false;public;3;4;;@Override public void apply(Settings value, Settings current, Settings previous) {     consumer.accept(value). }
false;public;0;4;;@Override public String toString() {     return "Updater grouped: " + configuredSettings.stream().map(Setting::getKey).collect(Collectors.joining(", ")). }
false;static;2;39;;static AbstractScopedSettings.SettingUpdater<Settings> groupedSettingsUpdater(Consumer<Settings> consumer, final List<? extends Setting<?>> configuredSettings) {     return new AbstractScopedSettings.SettingUpdater<Settings>() {          private Settings get(Settings settings) {             return settings.filter(s -> {                 for (Setting<?> setting : configuredSettings) {                     if (setting.key.match(s)) {                         return true.                     }                 }                 return false.             }).         }          @Override         public boolean hasChanged(Settings current, Settings previous) {             Settings currentSettings = get(current).             Settings previousSettings = get(previous).             return currentSettings.equals(previousSettings) == false.         }          @Override         public Settings getValue(Settings current, Settings previous) {             return get(current).         }          @Override         public void apply(Settings value, Settings current, Settings previous) {             consumer.accept(value).         }          @Override         public String toString() {             return "Updater grouped: " + configuredSettings.stream().map(Setting::getKey).collect(Collectors.joining(", ")).         }     }. }
false;;0;3;;boolean isGroupSetting() {     return true. }
false;private;1;3;;private Stream<String> matchStream(Settings settings) {     return settings.keySet().stream().filter(this::match).map(key::getConcreteString). }
false;public;1;8;;public Set<Setting<?>> getSettingsDependencies(String settingsKey) {     if (dependencies.isEmpty()) {         return Collections.emptySet().     } else {         String namespace = key.getNamespace(settingsKey).         return dependencies.stream().map(s -> (Setting<?>) s.getConcreteSettingForNamespace(namespace)).collect(Collectors.toSet()).     } }
false;public;2;4;;@Override public boolean hasChanged(Settings current, Settings previous) {     return Stream.concat(matchStream(current), matchStream(previous)).findAny().isPresent(). }
false;public;2;19;;@Override public Map<AbstractScopedSettings.SettingUpdater<T>, T> getValue(Settings current, Settings previous) {     // we collect all concrete keys and then delegate to the actual setting for validation and settings extraction     final Map<AbstractScopedSettings.SettingUpdater<T>, T> result = new IdentityHashMap<>().     Stream.concat(matchStream(current), matchStream(previous)).distinct().forEach(aKey -> {         String namespace = key.getNamespace(aKey).         Setting<T> concreteSetting = getConcreteSetting(aKey).         AbstractScopedSettings.SettingUpdater<T> updater = concreteSetting.newUpdater((v) -> consumer.accept(namespace, v), logger, (v) -> validator.accept(namespace, v)).         if (updater.hasChanged(current, previous)) {             // only the ones that have changed otherwise we might get too many updates             // the hasChanged above checks only if there are any changes             T value = updater.getValue(current, previous).             result.put(updater, value).         }     }).     return result. }
false;public;3;6;;@Override public void apply(Map<AbstractScopedSettings.SettingUpdater<T>, T> value, Settings current, Settings previous) {     for (Map.Entry<AbstractScopedSettings.SettingUpdater<T>, T> entry : value.entrySet()) {         entry.getKey().apply(entry.getValue(), current, previous).     } }
false;;3;37;;AbstractScopedSettings.SettingUpdater<Map<AbstractScopedSettings.SettingUpdater<T>, T>> newAffixUpdater(BiConsumer<String, T> consumer, Logger logger, BiConsumer<String, T> validator) {     return new AbstractScopedSettings.SettingUpdater<Map<AbstractScopedSettings.SettingUpdater<T>, T>>() {          @Override         public boolean hasChanged(Settings current, Settings previous) {             return Stream.concat(matchStream(current), matchStream(previous)).findAny().isPresent().         }          @Override         public Map<AbstractScopedSettings.SettingUpdater<T>, T> getValue(Settings current, Settings previous) {             // we collect all concrete keys and then delegate to the actual setting for validation and settings extraction             final Map<AbstractScopedSettings.SettingUpdater<T>, T> result = new IdentityHashMap<>().             Stream.concat(matchStream(current), matchStream(previous)).distinct().forEach(aKey -> {                 String namespace = key.getNamespace(aKey).                 Setting<T> concreteSetting = getConcreteSetting(aKey).                 AbstractScopedSettings.SettingUpdater<T> updater = concreteSetting.newUpdater((v) -> consumer.accept(namespace, v), logger, (v) -> validator.accept(namespace, v)).                 if (updater.hasChanged(current, previous)) {                     // only the ones that have changed otherwise we might get too many updates                     // the hasChanged above checks only if there are any changes                     T value = updater.getValue(current, previous).                     result.put(updater, value).                 }             }).             return result.         }          @Override         public void apply(Map<AbstractScopedSettings.SettingUpdater<T>, T> value, Settings current, Settings previous) {             for (Map.Entry<AbstractScopedSettings.SettingUpdater<T>, T> entry : value.entrySet()) {                 entry.getKey().apply(entry.getValue(), current, previous).             }         }     }. }
false;public;2;4;;@Override public boolean hasChanged(Settings current, Settings previous) {     return current.filter(k -> match(k)).equals(previous.filter(k -> match(k))) == false. }
false;public;2;18;;@Override public Map<String, T> getValue(Settings current, Settings previous) {     // we collect all concrete keys and then delegate to the actual setting for validation and settings extraction     final Map<String, T> result = new IdentityHashMap<>().     Stream.concat(matchStream(current), matchStream(previous)).distinct().forEach(aKey -> {         String namespace = key.getNamespace(aKey).         Setting<T> concreteSetting = getConcreteSetting(aKey).         AbstractScopedSettings.SettingUpdater<T> updater = concreteSetting.newUpdater((v) -> {         }, logger, (v) -> validator.accept(namespace, v)).         if (updater.hasChanged(current, previous)) {             // only the ones that have changed otherwise we might get too many updates             // the hasChanged above checks only if there are any changes             T value = updater.getValue(current, previous).             result.put(namespace, value).         }     }).     return result. }
false;public;3;4;;@Override public void apply(Map<String, T> value, Settings current, Settings previous) {     consumer.accept(value). }
false;;3;34;;AbstractScopedSettings.SettingUpdater<Map<String, T>> newAffixMapUpdater(Consumer<Map<String, T>> consumer, Logger logger, BiConsumer<String, T> validator) {     return new AbstractScopedSettings.SettingUpdater<Map<String, T>>() {          @Override         public boolean hasChanged(Settings current, Settings previous) {             return current.filter(k -> match(k)).equals(previous.filter(k -> match(k))) == false.         }          @Override         public Map<String, T> getValue(Settings current, Settings previous) {             // we collect all concrete keys and then delegate to the actual setting for validation and settings extraction             final Map<String, T> result = new IdentityHashMap<>().             Stream.concat(matchStream(current), matchStream(previous)).distinct().forEach(aKey -> {                 String namespace = key.getNamespace(aKey).                 Setting<T> concreteSetting = getConcreteSetting(aKey).                 AbstractScopedSettings.SettingUpdater<T> updater = concreteSetting.newUpdater((v) -> {                 }, logger, (v) -> validator.accept(namespace, v)).                 if (updater.hasChanged(current, previous)) {                     // only the ones that have changed otherwise we might get too many updates                     // the hasChanged above checks only if there are any changes                     T value = updater.getValue(current, previous).                     result.put(namespace, value).                 }             }).             return result.         }          @Override         public void apply(Map<String, T> value, Settings current, Settings previous) {             consumer.accept(value).         }     }. }
false;public;1;5;;@Override public T get(Settings settings) {     throw new UnsupportedOperationException("affix settings can't return values" + " use #getConcreteSetting to obtain a concrete setting"). }
false;public;1;5;;@Override public String innerGetRaw(final Settings settings) {     throw new UnsupportedOperationException("affix settings can't return values" + " use #getConcreteSetting to obtain a concrete setting"). }
false;public;1;8;;@Override public Setting<T> getConcreteSetting(String key) {     if (match(key)) {         return delegateFactory.apply(key).     } else {         throw new IllegalArgumentException("key [" + key + "] must match [" + getKey() + "] but didn't.").     } }
true;public;1;4;/**  * Get a setting with the given namespace filled in for prefix and suffix.  */ ;/**  * Get a setting with the given namespace filled in for prefix and suffix.  */ public Setting<T> getConcreteSettingForNamespace(String namespace) {     String fullKey = key.toConcreteKey(namespace).toString().     return getConcreteSetting(fullKey). }
false;public;3;4;;@Override public void diff(Settings.Builder builder, Settings source, Settings defaultSettings) {     matchStream(defaultSettings).forEach((key) -> getConcreteSetting(key).diff(builder, source, defaultSettings)). }
true;public;1;3;/**  * Returns the namespace for a concrete setting. Ie. an affix setting with prefix: {@code search.} and suffix: {@code username}  * will return {@code remote} as a namespace for the setting {@code cluster.remote.username}  */ ;/**  * Returns the namespace for a concrete setting. Ie. an affix setting with prefix: {@code search.} and suffix: {@code username}  * will return {@code remote} as a namespace for the setting {@code cluster.remote.username}  */ public String getNamespace(Setting<T> concreteSetting) {     return key.getNamespace(concreteSetting.getKey()). }
true;public;1;3;/**  * Returns a stream of all concrete setting instances for the given settings. AffixSetting is only a specification, concrete  * settings depend on an actual set of setting keys.  */ ;/**  * Returns a stream of all concrete setting instances for the given settings. AffixSetting is only a specification, concrete  * settings depend on an actual set of setting keys.  */ public Stream<Setting<T>> getAllConcreteSettings(Settings settings) {     return matchStream(settings).distinct().map(this::getConcreteSetting). }
true;public;1;3;/**  * Returns distinct namespaces for the given settings  */ ;/**  * Returns distinct namespaces for the given settings  */ public Set<String> getNamespaces(Settings settings) {     return settings.keySet().stream().filter(this::match).map(key::getNamespace).collect(Collectors.toSet()). }
true;public;1;8;/**  * Returns a map of all namespaces to it's values give the provided settings  */ ;/**  * Returns a map of all namespaces to it's values give the provided settings  */ public Map<String, T> getAsMap(Settings settings) {     Map<String, T> map = new HashMap<>().     matchStream(settings).distinct().forEach(key -> {         Setting<T> concreteSetting = getConcreteSetting(key).         map.put(getNamespace(concreteSetting), concreteSetting.get(settings)).     }).     return Collections.unmodifiableMap(map). }
true;;1;1;/**  * Validate this setting's value in isolation.  *  * @param value the value of this setting  */ ;/**  * Validate this setting's value in isolation.  *  * @param value the value of this setting  */ void validate(T value).
true;default;2;2;/**  * Validate this setting against its dependencies, specified by {@link #settings()}. The default implementation does nothing,  * accepting any value as valid as long as it passes the validation in {@link #validate(Object)}.  *  * @param value    the value of this setting  * @param settings a map from the settings specified by {@link #settings()}} to their values  */ ;/**  * Validate this setting against its dependencies, specified by {@link #settings()}. The default implementation does nothing,  * accepting any value as valid as long as it passes the validation in {@link #validate(Object)}.  *  * @param value    the value of this setting  * @param settings a map from the settings specified by {@link #settings()}} to their values  */ default void validate(T value, Map<Setting<T>, T> settings) { }
true;default;0;3;/**  * The settings on which the validity of this setting depends. The values of the specified settings are passed to  * {@link #validate(Object, Map)}. By default this returns an empty iterator, indicating that this setting does not depend on any  * other settings.  *  * @return the settings on which the validity of this setting depends.  */ ;/**  * The settings on which the validity of this setting depends. The values of the specified settings are passed to  * {@link #validate(Object, Map)}. By default this returns an empty iterator, indicating that this setting does not depend on any  * other settings.  *  * @return the settings on which the validity of this setting depends.  */ default Iterator<Setting<T>> settings() {     return Collections.emptyIterator(). }
false;public;0;4;;@Override public boolean isGroupSetting() {     return true. }
false;public;1;13;;@Override public String innerGetRaw(final Settings settings) {     Settings subSettings = get(settings).     try {         XContentBuilder builder = XContentFactory.jsonBuilder().         builder.startObject().         subSettings.toXContent(builder, EMPTY_PARAMS).         builder.endObject().         return Strings.toString(builder).     } catch (IOException e) {         throw new RuntimeException(e).     } }
false;public;1;6;;@Override public Settings get(Settings settings) {     Settings byPrefix = settings.getByPrefix(getKey()).     validator.accept(byPrefix).     return byPrefix. }
false;public;1;9;;@Override public boolean exists(Settings settings) {     for (String settingsKey : settings.keySet()) {         if (settingsKey.startsWith(key)) {             return true.         }     }     return false. }
false;public;3;8;;@Override public void diff(Settings.Builder builder, Settings source, Settings defaultSettings) {     Set<String> leftGroup = get(source).keySet().     Settings defaultGroup = get(defaultSettings).     builder.put(Settings.builder().put(defaultGroup.filter(k -> leftGroup.contains(k) == false), false).normalizePrefix(getKey()).build(), false). }
false;public;2;6;;@Override public boolean hasChanged(Settings current, Settings previous) {     Settings currentSettings = get(current).     Settings previousSettings = get(previous).     return currentSettings.equals(previousSettings) == false. }
false;public;2;12;;@Override public Settings getValue(Settings current, Settings previous) {     Settings currentSettings = get(current).     Settings previousSettings = get(previous).     try {         validator.accept(currentSettings).     } catch (Exception | AssertionError e) {         throw new IllegalArgumentException("illegal value can't update [" + key + "] from [" + previousSettings + "] to [" + currentSettings + "]", e).     }     return currentSettings. }
false;public;3;5;;@Override public void apply(Settings value, Settings current, Settings previous) {     Setting.logSettingUpdate(GroupSetting.this, current, previous, logger).     consumer.accept(value). }
false;public;0;4;;@Override public String toString() {     return "Updater for: " + setting.toString(). }
false;public;3;41;;@Override public AbstractScopedSettings.SettingUpdater<Settings> newUpdater(Consumer<Settings> consumer, Logger logger, Consumer<Settings> validator) {     if (isDynamic() == false) {         throw new IllegalStateException("setting [" + getKey() + "] is not dynamic").     }     final Setting<?> setting = this.     return new AbstractScopedSettings.SettingUpdater<Settings>() {          @Override         public boolean hasChanged(Settings current, Settings previous) {             Settings currentSettings = get(current).             Settings previousSettings = get(previous).             return currentSettings.equals(previousSettings) == false.         }          @Override         public Settings getValue(Settings current, Settings previous) {             Settings currentSettings = get(current).             Settings previousSettings = get(previous).             try {                 validator.accept(currentSettings).             } catch (Exception | AssertionError e) {                 throw new IllegalArgumentException("illegal value can't update [" + key + "] from [" + previousSettings + "] to [" + currentSettings + "]", e).             }             return currentSettings.         }          @Override         public void apply(Settings value, Settings current, Settings previous) {             Setting.logSettingUpdate(GroupSetting.this, current, previous, logger).             consumer.accept(value).         }          @Override         public String toString() {             return "Updater for: " + setting.toString().         }     }. }
false;public;0;4;;@Override public String toString() {     return "Updater for: " + Setting.this.toString(). }
false;public;2;9;;@Override public boolean hasChanged(Settings current, Settings previous) {     final String newValue = getRaw(current).     final String value = getRaw(previous).     assert isGroupSetting() == false : "group settings must override this method".     assert value != null : "value was null but can't be unless default is null which is invalid".     return value.equals(newValue) == false. }
false;public;2;13;;@Override public T getValue(Settings current, Settings previous) {     final String newValue = getRaw(current).     final String value = getRaw(previous).     try {         T inst = get(current).         accept.accept(inst).         return inst.     } catch (Exception | AssertionError e) {         throw new IllegalArgumentException("illegal value can't update [" + key + "] from [" + value + "] to [" + newValue + "]", e).     } }
false;public;3;5;;@Override public void apply(T value, Settings current, Settings previous) {     logSettingUpdate(Setting.this, current, previous, logger).     consumer.accept(value). }
false;public,static;3;3;;public static Setting<Version> versionSetting(final String key, final Version defaultValue, Property... properties) {     return new Setting<>(key, s -> Integer.toString(defaultValue.id), s -> Version.fromId(Integer.parseInt(s)), properties). }
false;public,static;3;3;;public static Setting<Float> floatSetting(String key, float defaultValue, Property... properties) {     return new Setting<>(key, (s) -> Float.toString(defaultValue), Float::parseFloat, properties). }
false;public,static;4;9;;public static Setting<Float> floatSetting(String key, float defaultValue, float minValue, Property... properties) {     return new Setting<>(key, (s) -> Float.toString(defaultValue), (s) -> {         float value = Float.parseFloat(s).         if (value < minValue) {             throw new IllegalArgumentException("Failed to parse value [" + s + "] for setting [" + key + "] must be >= " + minValue).         }         return value.     }, properties). }
false;public,static;5;3;;public static Setting<Integer> intSetting(String key, int defaultValue, int minValue, int maxValue, Property... properties) {     return new Setting<>(key, (s) -> Integer.toString(defaultValue), (s) -> parseInt(s, minValue, maxValue, key), properties). }
false;public,static;4;3;;public static Setting<Integer> intSetting(String key, int defaultValue, int minValue, Property... properties) {     return new Setting<>(key, (s) -> Integer.toString(defaultValue), (s) -> parseInt(s, minValue, key), properties). }
false;public,static;4;3;;public static Setting<Integer> intSetting(String key, Setting<Integer> fallbackSetting, int minValue, Property... properties) {     return new Setting<>(key, fallbackSetting, (s) -> parseInt(s, minValue, key), properties). }
false;public,static;5;5;;public static Setting<Integer> intSetting(String key, Setting<Integer> fallbackSetting, int minValue, Validator<Integer> validator, Property... properties) {     return new Setting<>(new SimpleKey(key), fallbackSetting, fallbackSetting::getRaw, (s) -> parseInt(s, minValue, key), validator, properties). }
false;public,static;4;3;;public static Setting<Long> longSetting(String key, long defaultValue, long minValue, Property... properties) {     return new Setting<>(key, (s) -> Long.toString(defaultValue), (s) -> parseLong(s, minValue, key), properties). }
false;public,static;2;3;;public static Setting<String> simpleString(String key, Property... properties) {     return new Setting<>(key, s -> "", Function.identity(), properties). }
false;public,static;3;3;;public static Setting<String> simpleString(String key, Validator<String> validator, Property... properties) {     return new Setting<>(new SimpleKey(key), null, s -> "", Function.identity(), validator, properties). }
false;public,static;3;3;;public static Setting<String> simpleString(String key, Setting<String> fallback, Property... properties) {     return simpleString(key, fallback, Function.identity(), properties). }
false;public,static;4;7;;public static Setting<String> simpleString(final String key, final Setting<String> fallback, final Function<String, String> parser, final Property... properties) {     return new Setting<>(key, fallback, parser, properties). }
true;public,static;3;3;/**  * Creates a new Setting instance with a String value  *  * @param key          the settings key for this setting.  * @param defaultValue the default String value.  * @param properties   properties for this setting like scope, filtering...  * @return the Setting Object  */ ;/**  * Creates a new Setting instance with a String value  *  * @param key          the settings key for this setting.  * @param defaultValue the default String value.  * @param properties   properties for this setting like scope, filtering...  * @return the Setting Object  */ public static Setting<String> simpleString(String key, String defaultValue, Property... properties) {     return new Setting<>(key, s -> defaultValue, Function.identity(), properties). }
false;public,static;3;3;;public static int parseInt(String s, int minValue, String key) {     return parseInt(s, minValue, Integer.MAX_VALUE, key). }
false;public,static;4;10;;public static int parseInt(String s, int minValue, int maxValue, String key) {     int value = Integer.parseInt(s).     if (value < minValue) {         throw new IllegalArgumentException("Failed to parse value [" + s + "] for setting [" + key + "] must be >= " + minValue).     }     if (value > maxValue) {         throw new IllegalArgumentException("Failed to parse value [" + s + "] for setting [" + key + "] must be <= " + maxValue).     }     return value. }
false;public,static;3;7;;public static long parseLong(String s, long minValue, String key) {     long value = Long.parseLong(s).     if (value < minValue) {         throw new IllegalArgumentException("Failed to parse value [" + s + "] for setting [" + key + "] must be >= " + minValue).     }     return value. }
false;public,static;3;7;;public static TimeValue parseTimeValue(String s, TimeValue minValue, String key) {     TimeValue timeValue = TimeValue.parseTimeValue(s, null, key).     if (timeValue.millis() < minValue.millis()) {         throw new IllegalArgumentException("Failed to parse value [" + s + "] for setting [" + key + "] must be >= " + minValue).     }     return timeValue. }
false;public,static;3;3;;public static Setting<Integer> intSetting(String key, int defaultValue, Property... properties) {     return intSetting(key, defaultValue, Integer.MIN_VALUE, properties). }
false;public,static;3;3;;public static Setting<Boolean> boolSetting(String key, boolean defaultValue, Property... properties) {     return new Setting<>(key, (s) -> Boolean.toString(defaultValue), Booleans::parseBoolean, properties). }
false;public,static;3;3;;public static Setting<Boolean> boolSetting(String key, Setting<Boolean> fallbackSetting, Property... properties) {     return new Setting<>(key, fallbackSetting, Booleans::parseBoolean, properties). }
false;public,static;3;3;;public static Setting<Boolean> boolSetting(String key, Function<Settings, String> defaultValueFn, Property... properties) {     return new Setting<>(key, defaultValueFn, Booleans::parseBoolean, properties). }
false;public,static;3;3;;public static Setting<ByteSizeValue> byteSizeSetting(String key, ByteSizeValue value, Property... properties) {     return byteSizeSetting(key, (s) -> value.toString(), properties). }
false;public,static;3;4;;public static Setting<ByteSizeValue> byteSizeSetting(String key, Setting<ByteSizeValue> fallbackSetting, Property... properties) {     return new Setting<>(key, fallbackSetting, (s) -> ByteSizeValue.parseBytesSizeValue(s, key), properties). }
false;public,static;3;4;;public static Setting<ByteSizeValue> byteSizeSetting(String key, Function<Settings, String> defaultValue, Property... properties) {     return new Setting<>(key, defaultValue, (s) -> ByteSizeValue.parseBytesSizeValue(s, key), properties). }
false;public,static;5;4;;public static Setting<ByteSizeValue> byteSizeSetting(String key, ByteSizeValue defaultValue, ByteSizeValue minValue, ByteSizeValue maxValue, Property... properties) {     return byteSizeSetting(key, (s) -> defaultValue.getStringRep(), minValue, maxValue, properties). }
false;public,static;5;5;;public static Setting<ByteSizeValue> byteSizeSetting(String key, Function<Settings, String> defaultValue, ByteSizeValue minValue, ByteSizeValue maxValue, Property... properties) {     return new Setting<>(key, defaultValue, (s) -> parseByteSize(s, minValue, maxValue, key), properties). }
false;public,static;4;22;;public static ByteSizeValue parseByteSize(String s, ByteSizeValue minValue, ByteSizeValue maxValue, String key) {     ByteSizeValue value = ByteSizeValue.parseBytesSizeValue(s, key).     if (value.getBytes() < minValue.getBytes()) {         final String message = String.format(Locale.ROOT, "failed to parse value [%s] for setting [%s], must be >= [%s]", s, key, minValue.getStringRep()).         throw new IllegalArgumentException(message).     }     if (value.getBytes() > maxValue.getBytes()) {         final String message = String.format(Locale.ROOT, "failed to parse value [%s] for setting [%s], must be <= [%s]", s, key, maxValue.getStringRep()).         throw new IllegalArgumentException(message).     }     return value. }
true;public,static;3;3;/**  * Creates a setting which specifies a memory size. This can either be  * specified as an absolute bytes value or as a percentage of the heap  * memory.  *  * @param key the key for the setting  * @param defaultValue the default value for this setting  * @param properties properties properties for this setting like scope, filtering...  * @return the setting object  */ ;/**  * Creates a setting which specifies a memory size. This can either be  * specified as an absolute bytes value or as a percentage of the heap  * memory.  *  * @param key the key for the setting  * @param defaultValue the default value for this setting  * @param properties properties properties for this setting like scope, filtering...  * @return the setting object  */ public static Setting<ByteSizeValue> memorySizeSetting(String key, ByteSizeValue defaultValue, Property... properties) {     return memorySizeSetting(key, (s) -> defaultValue.toString(), properties). }
true;public,static;3;3;/**  * Creates a setting which specifies a memory size. This can either be  * specified as an absolute bytes value or as a percentage of the heap  * memory.  *  * @param key the key for the setting  * @param defaultValue a function that supplies the default value for this setting  * @param properties properties properties for this setting like scope, filtering...  * @return the setting object  */ ;/**  * Creates a setting which specifies a memory size. This can either be  * specified as an absolute bytes value or as a percentage of the heap  * memory.  *  * @param key the key for the setting  * @param defaultValue a function that supplies the default value for this setting  * @param properties properties properties for this setting like scope, filtering...  * @return the setting object  */ public static Setting<ByteSizeValue> memorySizeSetting(String key, Function<Settings, String> defaultValue, Property... properties) {     return new Setting<>(key, defaultValue, (s) -> MemorySizeValue.parseBytesSizeValueOrHeapRatio(s, key), properties). }
true;public,static;3;3;/**  * Creates a setting which specifies a memory size. This can either be  * specified as an absolute bytes value or as a percentage of the heap  * memory.  *  * @param key the key for the setting  * @param defaultPercentage the default value of this setting as a percentage of the heap memory  * @param properties properties properties for this setting like scope, filtering...  * @return the setting object  */ ;/**  * Creates a setting which specifies a memory size. This can either be  * specified as an absolute bytes value or as a percentage of the heap  * memory.  *  * @param key the key for the setting  * @param defaultPercentage the default value of this setting as a percentage of the heap memory  * @param properties properties properties for this setting like scope, filtering...  * @return the setting object  */ public static Setting<ByteSizeValue> memorySizeSetting(String key, String defaultPercentage, Property... properties) {     return new Setting<>(key, (s) -> defaultPercentage, (s) -> MemorySizeValue.parseBytesSizeValueOrHeapRatio(s, key), properties). }
false;public,static;4;7;;public static <T> Setting<List<T>> listSetting(final String key, final List<String> defaultStringValue, final Function<String, T> singleValueParser, final Property... properties) {     return listSetting(key, null, singleValueParser, (s) -> defaultStringValue, properties). }
true;public,static;4;7;// TODO this one's two argument get is still broken ;// TODO this one's two argument get is still broken public static <T> Setting<List<T>> listSetting(final String key, final Setting<List<T>> fallbackSetting, final Function<String, T> singleValueParser, final Property... properties) {     return listSetting(key, fallbackSetting, singleValueParser, (s) -> parseableStringToList(fallbackSetting.getRaw(s)), properties). }
false;public,static;4;7;;public static <T> Setting<List<T>> listSetting(final String key, final Function<String, T> singleValueParser, final Function<Settings, List<String>> defaultStringValue, final Property... properties) {     return listSetting(key, null, singleValueParser, defaultStringValue, properties). }
false;public,static;5;14;;public static <T> Setting<List<T>> listSetting(final String key, @Nullable final Setting<List<T>> fallbackSetting, final Function<String, T> singleValueParser, final Function<Settings, List<String>> defaultStringValue, final Property... properties) {     if (defaultStringValue.apply(Settings.EMPTY) == null) {         throw new IllegalArgumentException("default value function must not return null").     }     Function<String, List<T>> parser = (s) -> parseableStringToList(s).stream().map(singleValueParser).collect(Collectors.toList()).     return new ListSetting<>(key, fallbackSetting, defaultStringValue, parser, properties). }
false;private,static;1;20;;private static List<String> parseableStringToList(String parsableString) {     // fromXContent doesn't use named xcontent or deprecation.     try (XContentParser xContentParser = XContentType.JSON.xContent().createParser(NamedXContentRegistry.EMPTY, DeprecationHandler.THROW_UNSUPPORTED_OPERATION, parsableString)) {         XContentParser.Token token = xContentParser.nextToken().         if (token != XContentParser.Token.START_ARRAY) {             throw new IllegalArgumentException("expected START_ARRAY but got " + token).         }         ArrayList<String> list = new ArrayList<>().         while ((token = xContentParser.nextToken()) != XContentParser.Token.END_ARRAY) {             if (token != XContentParser.Token.VALUE_STRING) {                 throw new IllegalArgumentException("expected VALUE_STRING but got " + token).             }             list.add(xContentParser.text()).         }         return list.     } catch (IOException e) {         throw new IllegalArgumentException("failed to parse array", e).     } }
false;private,static;1;13;;private static String arrayToParsableString(List<String> array) {     try {         XContentBuilder builder = XContentBuilder.builder(XContentType.JSON.xContent()).         builder.startArray().         for (String element : array) {             builder.value(element).         }         builder.endArray().         return Strings.toString(builder).     } catch (IOException ex) {         throw new ElasticsearchException(ex).     } }
false;;1;5;;@Override String innerGetRaw(final Settings settings) {     List<String> array = settings.getAsList(getKey(), null).     return array == null ? defaultValue.apply(settings) : arrayToParsableString(array). }
false;;0;4;;@Override boolean hasComplexMatcher() {     return true. }
false;public;3;11;;@Override public void diff(Settings.Builder builder, Settings source, Settings defaultSettings) {     if (exists(source) == false) {         List<String> asList = defaultSettings.getAsList(getKey(), null).         if (asList == null) {             builder.putList(getKey(), defaultStringValue.apply(defaultSettings)).         } else {             builder.putList(getKey(), asList).         }     } }
false;static;4;9;;static void logSettingUpdate(Setting setting, Settings current, Settings previous, Logger logger) {     if (logger.isInfoEnabled()) {         if (setting.isFiltered()) {             logger.info("updating [{}]", setting.key).         } else {             logger.info("updating [{}] from [{}] to [{}]", setting.key, setting.getRaw(previous), setting.getRaw(current)).         }     } }
false;public,static;2;3;;public static Setting<Settings> groupSetting(String key, Property... properties) {     return groupSetting(key, (s) -> {     }, properties). }
false;public,static;3;3;;public static Setting<Settings> groupSetting(String key, Consumer<Settings> validator, Property... properties) {     return new GroupSetting(key, validator, properties). }
false;public,static;4;14;;public static Setting<TimeValue> timeSetting(final String key, final Setting<TimeValue> fallbackSetting, final TimeValue minValue, final Property... properties) {     final SimpleKey simpleKey = new SimpleKey(key).     return new Setting<>(simpleKey, fallbackSetting, fallbackSetting::getRaw, minTimeValueParser(key, minValue), v -> {     }, properties). }
false;public,static;4;5;;public static Setting<TimeValue> timeSetting(final String key, Function<Settings, TimeValue> defaultValue, final TimeValue minValue, final Property... properties) {     final SimpleKey simpleKey = new SimpleKey(key).     return new Setting<>(simpleKey, s -> defaultValue.apply(s).getStringRep(), minTimeValueParser(key, minValue), properties). }
false;public,static;5;5;;public static Setting<TimeValue> timeSetting(final String key, TimeValue defaultValue, final TimeValue minValue, final TimeValue maxValue, final Property... properties) {     final SimpleKey simpleKey = new SimpleKey(key).     return new Setting<>(simpleKey, s -> defaultValue.getStringRep(), minMaxTimeValueParser(key, minValue, maxValue), properties). }
false;private,static;2;15;;private static Function<String, TimeValue> minTimeValueParser(final String key, final TimeValue minValue) {     return s -> {         final TimeValue value = TimeValue.parseTimeValue(s, null, key).         if (value.millis() < minValue.millis()) {             final String message = String.format(Locale.ROOT, "failed to parse value [%s] for setting [%s], must be >= [%s]", s, key, minValue.getStringRep()).             throw new IllegalArgumentException(message).         }         return value.     }. }
false;private,static;3;16;;private static Function<String, TimeValue> minMaxTimeValueParser(final String key, final TimeValue minValue, final TimeValue maxValue) {     return s -> {         final TimeValue value = minTimeValueParser(key, minValue).apply(s).         if (value.millis() > maxValue.millis()) {             final String message = String.format(Locale.ROOT, "failed to parse value [%s] for setting [%s], must be <= [%s]", s, key, maxValue.getStringRep()).             throw new IllegalArgumentException(message).         }         return value.     }. }
false;public,static;4;3;;public static Setting<TimeValue> timeSetting(String key, TimeValue defaultValue, TimeValue minValue, Property... properties) {     return timeSetting(key, (s) -> defaultValue, minValue, properties). }
false;public,static;3;3;;public static Setting<TimeValue> timeSetting(String key, TimeValue defaultValue, Property... properties) {     return new Setting<>(key, (s) -> defaultValue.getStringRep(), (s) -> TimeValue.parseTimeValue(s, key), properties). }
false;public,static;3;3;;public static Setting<TimeValue> timeSetting(String key, Setting<TimeValue> fallbackSetting, Property... properties) {     return new Setting<>(key, fallbackSetting, (s) -> TimeValue.parseTimeValue(s, key), properties). }
false;public,static;3;3;;public static Setting<TimeValue> positiveTimeSetting(String key, TimeValue defaultValue, Property... properties) {     return timeSetting(key, defaultValue, TimeValue.timeValueMillis(0), properties). }
false;public,static;4;7;;public static Setting<TimeValue> positiveTimeSetting(final String key, final Setting<TimeValue> fallbackSetting, final TimeValue minValue, final Property... properties) {     return timeSetting(key, fallbackSetting, minValue, properties). }
false;public,static;4;3;;public static Setting<Double> doubleSetting(String key, double defaultValue, double minValue, Property... properties) {     return doubleSetting(key, defaultValue, minValue, Double.POSITIVE_INFINITY, properties). }
false;public,static;5;12;;public static Setting<Double> doubleSetting(String key, double defaultValue, double minValue, double maxValue, Property... properties) {     return new Setting<>(key, (s) -> Double.toString(defaultValue), (s) -> {         final double d = Double.parseDouble(s).         if (d < minValue) {             throw new IllegalArgumentException("Failed to parse value [" + s + "] for setting [" + key + "] must be >= " + minValue).         }         if (d > maxValue) {             throw new IllegalArgumentException("Failed to parse value [" + s + "] for setting [" + key + "] must be <= " + maxValue).         }         return d.     }, properties). }
false;public;1;7;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     Setting<?> setting = (Setting<?>) o.     return Objects.equals(key, setting.key). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(key). }
true;public,static;2;3;/**  * This setting type allows to validate settings that have the same type and a common prefix. For instance feature.${type}=[true|false]  * can easily be added with this setting. Yet, prefix key settings don't support updaters out of the box unless  * {@link #getConcreteSetting(String)} is used to pull the updater.  */ ;/**  * This setting type allows to validate settings that have the same type and a common prefix. For instance feature.${type}=[true|false]  * can easily be added with this setting. Yet, prefix key settings don't support updaters out of the box unless  * {@link #getConcreteSetting(String)} is used to pull the updater.  */ public static <T> AffixSetting<T> prefixKeySetting(String prefix, Function<String, Setting<T>> delegateFactory) {     return affixKeySetting(new AffixKey(prefix), delegateFactory). }
true;public,static;4;4;/**  * This setting type allows to validate settings that have the same type and a common prefix and suffix. For instance  * storage.${backend}.enable=[true|false] can easily be added with this setting. Yet, affix key settings don't support updaters  * out of the box unless {@link #getConcreteSetting(String)} is used to pull the updater.  */ ;/**  * This setting type allows to validate settings that have the same type and a common prefix and suffix. For instance  * storage.${backend}.enable=[true|false] can easily be added with this setting. Yet, affix key settings don't support updaters  * out of the box unless {@link #getConcreteSetting(String)} is used to pull the updater.  */ public static <T> AffixSetting<T> affixKeySetting(String prefix, String suffix, Function<String, Setting<T>> delegateFactory, AffixSetting... dependencies) {     return affixKeySetting(new AffixKey(prefix, suffix), delegateFactory, dependencies). }
false;private,static;3;5;;private static <T> AffixSetting<T> affixKeySetting(AffixKey key, Function<String, Setting<T>> delegateFactory, AffixSetting... dependencies) {     Setting<T> delegate = delegateFactory.apply("_na_").     return new AffixSetting<>(key, delegate, delegateFactory, dependencies). }
false;;1;1;;boolean match(String key).
false;public;1;4;;@Override public boolean match(String key) {     return this.key.equals(key). }
false;public;0;4;;@Override public String toString() {     return key. }
false;public;1;7;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     SimpleKey simpleKey = (SimpleKey) o.     return Objects.equals(key, simpleKey.key). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(key). }
false;public;1;4;;@Override public boolean match(String toTest) {     return Regex.simpleMatch(key + "*", toTest). }
false;public;1;4;;@Override public boolean match(String toTest) {     return pattern.matcher(toTest).matches(). }
false;public;1;4;;@Override public boolean match(String key) {     return pattern.matcher(key).matches(). }
true;;1;7;/**  * Returns a string representation of the concrete setting key  */ ;/**  * Returns a string representation of the concrete setting key  */ String getConcreteString(String key) {     Matcher matcher = pattern.matcher(key).     if (matcher.matches() == false) {         throw new IllegalStateException("can't get concrete string for key " + key + " key doesn't match").     }     return matcher.group(1). }
true;;1;7;/**  * Returns a string representation of the concrete setting key  */ ;/**  * Returns a string representation of the concrete setting key  */ String getNamespace(String key) {     Matcher matcher = pattern.matcher(key).     if (matcher.matches() == false) {         throw new IllegalStateException("can't get concrete string for key " + key + " key doesn't match").     }     return matcher.group(2). }
false;public;1;12;;public SimpleKey toConcreteKey(String missingPart) {     StringBuilder key = new StringBuilder().     if (prefix != null) {         key.append(prefix).     }     key.append(missingPart).     if (suffix != null) {         key.append(".").         key.append(suffix).     }     return new SimpleKey(key.toString()). }
false;public;0;13;;@Override public String toString() {     StringBuilder sb = new StringBuilder().     if (prefix != null) {         sb.append(prefix).     }     if (suffix != null) {         sb.append('*').         sb.append('.').         sb.append(suffix).     }     return sb.toString(). }
false;public;1;8;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     AffixKey that = (AffixKey) o.     return Objects.equals(prefix, that.prefix) && Objects.equals(suffix, that.suffix). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(prefix, suffix). }
