# id;timestamp;commentText;codeText;commentWords;codeWords
JoinTaskExecutor -> public static Task newFinishElectionTask();1544081506;a task that is used to signal the election is stopped and we should process pending joins._it may be used in combination with {@link JoinTaskExecutor#newBecomeMasterTask()};public static Task newFinishElectionTask() {_        return new Task(null, Task.FINISH_ELECTION_TASK_REASON)__    };a,task,that,is,used,to,signal,the,election,is,stopped,and,we,should,process,pending,joins,it,may,be,used,in,combination,with,link,join,task,executor,new,become,master,task;public,static,task,new,finish,election,task,return,new,task,null,task
JoinTaskExecutor -> public static Task newFinishElectionTask();1544254415;a task that is used to signal the election is stopped and we should process pending joins._it may be used in combination with {@link JoinTaskExecutor#newBecomeMasterTask()};public static Task newFinishElectionTask() {_        return new Task(null, Task.FINISH_ELECTION_TASK_REASON)__    };a,task,that,is,used,to,signal,the,election,is,stopped,and,we,should,process,pending,joins,it,may,be,used,in,combination,with,link,join,task,executor,new,become,master,task;public,static,task,new,finish,election,task,return,new,task,null,task
JoinTaskExecutor -> public static Task newFinishElectionTask();1547121470;a task that is used to signal the election is stopped and we should process pending joins._it may be used in combination with {@link JoinTaskExecutor#newBecomeMasterTask()};public static Task newFinishElectionTask() {_        return new Task(null, Task.FINISH_ELECTION_TASK_REASON)__    };a,task,that,is,used,to,signal,the,election,is,stopped,and,we,should,process,pending,joins,it,may,be,used,in,combination,with,link,join,task,executor,new,become,master,task;public,static,task,new,finish,election,task,return,new,task,null,task
JoinTaskExecutor -> public static Task newFinishElectionTask();1548161085;a task that is used to signal the election is stopped and we should process pending joins._it may be used in combination with {@link JoinTaskExecutor#newBecomeMasterTask()};public static Task newFinishElectionTask() {_        return new Task(null, Task.FINISH_ELECTION_TASK_REASON)__    };a,task,that,is,used,to,signal,the,election,is,stopped,and,we,should,process,pending,joins,it,may,be,used,in,combination,with,link,join,task,executor,new,become,master,task;public,static,task,new,finish,election,task,return,new,task,null,task
JoinTaskExecutor -> public static Task newFinishElectionTask();1548259585;a task that is used to signal the election is stopped and we should process pending joins._it may be used in combination with {@link JoinTaskExecutor#newBecomeMasterTask()};public static Task newFinishElectionTask() {_        return new Task(null, Task.FINISH_ELECTION_TASK_REASON)__    };a,task,that,is,used,to,signal,the,election,is,stopped,and,we,should,process,pending,joins,it,may,be,used,in,combination,with,link,join,task,executor,new,become,master,task;public,static,task,new,finish,election,task,return,new,task,null,task
JoinTaskExecutor -> public static Task newFinishElectionTask();1548320260;a task that is used to signal the election is stopped and we should process pending joins._it may be used in combination with {@link JoinTaskExecutor#newBecomeMasterTask()};public static Task newFinishElectionTask() {_        return new Task(null, Task.FINISH_ELECTION_TASK_REASON)__    };a,task,that,is,used,to,signal,the,election,is,stopped,and,we,should,process,pending,joins,it,may,be,used,in,combination,with,link,join,task,executor,new,become,master,task;public,static,task,new,finish,election,task,return,new,task,null,task
JoinTaskExecutor -> public static Task newFinishElectionTask();1549356476;a task that is used to signal the election is stopped and we should process pending joins._it may be used in combination with {@link JoinTaskExecutor#newBecomeMasterTask()};public static Task newFinishElectionTask() {_        return new Task(null, Task.FINISH_ELECTION_TASK_REASON)__    };a,task,that,is,used,to,signal,the,election,is,stopped,and,we,should,process,pending,joins,it,may,be,used,in,combination,with,link,join,task,executor,new,become,master,task;public,static,task,new,finish,election,task,return,new,task,null,task
JoinTaskExecutor -> public static Task newFinishElectionTask();1551086646;a task that is used to signal the election is stopped and we should process pending joins._it may be used in combination with {@link JoinTaskExecutor#newBecomeMasterTask()};public static Task newFinishElectionTask() {_        return new Task(null, Task.FINISH_ELECTION_TASK_REASON)__    };a,task,that,is,used,to,signal,the,election,is,stopped,and,we,should,process,pending,joins,it,may,be,used,in,combination,with,link,join,task,executor,new,become,master,task;public,static,task,new,finish,election,task,return,new,task,null,task
JoinTaskExecutor -> public static void ensureNodesCompatibility(final Version joiningNodeVersion, DiscoveryNodes currentNodes);1544081506;ensures that the joining node has a version that's compatible with all current nodes;public static void ensureNodesCompatibility(final Version joiningNodeVersion, DiscoveryNodes currentNodes) {_        final Version minNodeVersion = currentNodes.getMinNodeVersion()__        final Version maxNodeVersion = currentNodes.getMaxNodeVersion()__        ensureNodesCompatibility(joiningNodeVersion, minNodeVersion, maxNodeVersion)__    };ensures,that,the,joining,node,has,a,version,that,s,compatible,with,all,current,nodes;public,static,void,ensure,nodes,compatibility,final,version,joining,node,version,discovery,nodes,current,nodes,final,version,min,node,version,current,nodes,get,min,node,version,final,version,max,node,version,current,nodes,get,max,node,version,ensure,nodes,compatibility,joining,node,version,min,node,version,max,node,version
JoinTaskExecutor -> public static void ensureNodesCompatibility(final Version joiningNodeVersion, DiscoveryNodes currentNodes);1544254415;ensures that the joining node has a version that's compatible with all current nodes;public static void ensureNodesCompatibility(final Version joiningNodeVersion, DiscoveryNodes currentNodes) {_        final Version minNodeVersion = currentNodes.getMinNodeVersion()__        final Version maxNodeVersion = currentNodes.getMaxNodeVersion()__        ensureNodesCompatibility(joiningNodeVersion, minNodeVersion, maxNodeVersion)__    };ensures,that,the,joining,node,has,a,version,that,s,compatible,with,all,current,nodes;public,static,void,ensure,nodes,compatibility,final,version,joining,node,version,discovery,nodes,current,nodes,final,version,min,node,version,current,nodes,get,min,node,version,final,version,max,node,version,current,nodes,get,max,node,version,ensure,nodes,compatibility,joining,node,version,min,node,version,max,node,version
JoinTaskExecutor -> public static void ensureNodesCompatibility(final Version joiningNodeVersion, DiscoveryNodes currentNodes);1547121470;ensures that the joining node has a version that's compatible with all current nodes;public static void ensureNodesCompatibility(final Version joiningNodeVersion, DiscoveryNodes currentNodes) {_        final Version minNodeVersion = currentNodes.getMinNodeVersion()__        final Version maxNodeVersion = currentNodes.getMaxNodeVersion()__        ensureNodesCompatibility(joiningNodeVersion, minNodeVersion, maxNodeVersion)__    };ensures,that,the,joining,node,has,a,version,that,s,compatible,with,all,current,nodes;public,static,void,ensure,nodes,compatibility,final,version,joining,node,version,discovery,nodes,current,nodes,final,version,min,node,version,current,nodes,get,min,node,version,final,version,max,node,version,current,nodes,get,max,node,version,ensure,nodes,compatibility,joining,node,version,min,node,version,max,node,version
JoinTaskExecutor -> public static void ensureNodesCompatibility(final Version joiningNodeVersion, DiscoveryNodes currentNodes);1548161085;ensures that the joining node has a version that's compatible with all current nodes;public static void ensureNodesCompatibility(final Version joiningNodeVersion, DiscoveryNodes currentNodes) {_        final Version minNodeVersion = currentNodes.getMinNodeVersion()__        final Version maxNodeVersion = currentNodes.getMaxNodeVersion()__        ensureNodesCompatibility(joiningNodeVersion, minNodeVersion, maxNodeVersion)__    };ensures,that,the,joining,node,has,a,version,that,s,compatible,with,all,current,nodes;public,static,void,ensure,nodes,compatibility,final,version,joining,node,version,discovery,nodes,current,nodes,final,version,min,node,version,current,nodes,get,min,node,version,final,version,max,node,version,current,nodes,get,max,node,version,ensure,nodes,compatibility,joining,node,version,min,node,version,max,node,version
JoinTaskExecutor -> public static void ensureNodesCompatibility(final Version joiningNodeVersion, DiscoveryNodes currentNodes);1548259585;ensures that the joining node has a version that's compatible with all current nodes;public static void ensureNodesCompatibility(final Version joiningNodeVersion, DiscoveryNodes currentNodes) {_        final Version minNodeVersion = currentNodes.getMinNodeVersion()__        final Version maxNodeVersion = currentNodes.getMaxNodeVersion()__        ensureNodesCompatibility(joiningNodeVersion, minNodeVersion, maxNodeVersion)__    };ensures,that,the,joining,node,has,a,version,that,s,compatible,with,all,current,nodes;public,static,void,ensure,nodes,compatibility,final,version,joining,node,version,discovery,nodes,current,nodes,final,version,min,node,version,current,nodes,get,min,node,version,final,version,max,node,version,current,nodes,get,max,node,version,ensure,nodes,compatibility,joining,node,version,min,node,version,max,node,version
JoinTaskExecutor -> public static void ensureNodesCompatibility(final Version joiningNodeVersion, DiscoveryNodes currentNodes);1548320260;ensures that the joining node has a version that's compatible with all current nodes;public static void ensureNodesCompatibility(final Version joiningNodeVersion, DiscoveryNodes currentNodes) {_        final Version minNodeVersion = currentNodes.getMinNodeVersion()__        final Version maxNodeVersion = currentNodes.getMaxNodeVersion()__        ensureNodesCompatibility(joiningNodeVersion, minNodeVersion, maxNodeVersion)__    };ensures,that,the,joining,node,has,a,version,that,s,compatible,with,all,current,nodes;public,static,void,ensure,nodes,compatibility,final,version,joining,node,version,discovery,nodes,current,nodes,final,version,min,node,version,current,nodes,get,min,node,version,final,version,max,node,version,current,nodes,get,max,node,version,ensure,nodes,compatibility,joining,node,version,min,node,version,max,node,version
JoinTaskExecutor -> public static void ensureNodesCompatibility(final Version joiningNodeVersion, DiscoveryNodes currentNodes);1549356476;ensures that the joining node has a version that's compatible with all current nodes;public static void ensureNodesCompatibility(final Version joiningNodeVersion, DiscoveryNodes currentNodes) {_        final Version minNodeVersion = currentNodes.getMinNodeVersion()__        final Version maxNodeVersion = currentNodes.getMaxNodeVersion()__        ensureNodesCompatibility(joiningNodeVersion, minNodeVersion, maxNodeVersion)__    };ensures,that,the,joining,node,has,a,version,that,s,compatible,with,all,current,nodes;public,static,void,ensure,nodes,compatibility,final,version,joining,node,version,discovery,nodes,current,nodes,final,version,min,node,version,current,nodes,get,min,node,version,final,version,max,node,version,current,nodes,get,max,node,version,ensure,nodes,compatibility,joining,node,version,min,node,version,max,node,version
JoinTaskExecutor -> public static void ensureNodesCompatibility(final Version joiningNodeVersion, DiscoveryNodes currentNodes);1551086646;ensures that the joining node has a version that's compatible with all current nodes;public static void ensureNodesCompatibility(final Version joiningNodeVersion, DiscoveryNodes currentNodes) {_        final Version minNodeVersion = currentNodes.getMinNodeVersion()__        final Version maxNodeVersion = currentNodes.getMaxNodeVersion()__        ensureNodesCompatibility(joiningNodeVersion, minNodeVersion, maxNodeVersion)__    };ensures,that,the,joining,node,has,a,version,that,s,compatible,with,all,current,nodes;public,static,void,ensure,nodes,compatibility,final,version,joining,node,version,discovery,nodes,current,nodes,final,version,min,node,version,current,nodes,get,min,node,version,final,version,max,node,version,current,nodes,get,max,node,version,ensure,nodes,compatibility,joining,node,version,min,node,version,max,node,version
JoinTaskExecutor -> public static void ensureMajorVersionBarrier(Version joiningNodeVersion, Version minClusterNodeVersion);1544081506;ensures that the joining node's major version is equal or higher to the minClusterNodeVersion. This is needed_to ensure that if the master is already fully operating under the new major version, it doesn't go back to mixed_version mode;public static void ensureMajorVersionBarrier(Version joiningNodeVersion, Version minClusterNodeVersion) {_        final byte clusterMajor = minClusterNodeVersion.major__        if (joiningNodeVersion.major < clusterMajor) {_            throw new IllegalStateException("node version [" + joiningNodeVersion + "] is not supported. " +_                "All nodes in the cluster are of a higher major [" + clusterMajor + "].")__        }_    };ensures,that,the,joining,node,s,major,version,is,equal,or,higher,to,the,min,cluster,node,version,this,is,needed,to,ensure,that,if,the,master,is,already,fully,operating,under,the,new,major,version,it,doesn,t,go,back,to,mixed,version,mode;public,static,void,ensure,major,version,barrier,version,joining,node,version,version,min,cluster,node,version,final,byte,cluster,major,min,cluster,node,version,major,if,joining,node,version,major,cluster,major,throw,new,illegal,state,exception,node,version,joining,node,version,is,not,supported,all,nodes,in,the,cluster,are,of,a,higher,major,cluster,major
JoinTaskExecutor -> public static void ensureMajorVersionBarrier(Version joiningNodeVersion, Version minClusterNodeVersion);1544254415;ensures that the joining node's major version is equal or higher to the minClusterNodeVersion. This is needed_to ensure that if the master is already fully operating under the new major version, it doesn't go back to mixed_version mode;public static void ensureMajorVersionBarrier(Version joiningNodeVersion, Version minClusterNodeVersion) {_        final byte clusterMajor = minClusterNodeVersion.major__        if (joiningNodeVersion.major < clusterMajor) {_            throw new IllegalStateException("node version [" + joiningNodeVersion + "] is not supported. " +_                "All nodes in the cluster are of a higher major [" + clusterMajor + "].")__        }_    };ensures,that,the,joining,node,s,major,version,is,equal,or,higher,to,the,min,cluster,node,version,this,is,needed,to,ensure,that,if,the,master,is,already,fully,operating,under,the,new,major,version,it,doesn,t,go,back,to,mixed,version,mode;public,static,void,ensure,major,version,barrier,version,joining,node,version,version,min,cluster,node,version,final,byte,cluster,major,min,cluster,node,version,major,if,joining,node,version,major,cluster,major,throw,new,illegal,state,exception,node,version,joining,node,version,is,not,supported,all,nodes,in,the,cluster,are,of,a,higher,major,cluster,major
JoinTaskExecutor -> public static void ensureMajorVersionBarrier(Version joiningNodeVersion, Version minClusterNodeVersion);1547121470;ensures that the joining node's major version is equal or higher to the minClusterNodeVersion. This is needed_to ensure that if the master is already fully operating under the new major version, it doesn't go back to mixed_version mode;public static void ensureMajorVersionBarrier(Version joiningNodeVersion, Version minClusterNodeVersion) {_        final byte clusterMajor = minClusterNodeVersion.major__        if (joiningNodeVersion.major < clusterMajor) {_            throw new IllegalStateException("node version [" + joiningNodeVersion + "] is not supported. " +_                "All nodes in the cluster are of a higher major [" + clusterMajor + "].")__        }_    };ensures,that,the,joining,node,s,major,version,is,equal,or,higher,to,the,min,cluster,node,version,this,is,needed,to,ensure,that,if,the,master,is,already,fully,operating,under,the,new,major,version,it,doesn,t,go,back,to,mixed,version,mode;public,static,void,ensure,major,version,barrier,version,joining,node,version,version,min,cluster,node,version,final,byte,cluster,major,min,cluster,node,version,major,if,joining,node,version,major,cluster,major,throw,new,illegal,state,exception,node,version,joining,node,version,is,not,supported,all,nodes,in,the,cluster,are,of,a,higher,major,cluster,major
JoinTaskExecutor -> public static void ensureMajorVersionBarrier(Version joiningNodeVersion, Version minClusterNodeVersion);1548161085;ensures that the joining node's major version is equal or higher to the minClusterNodeVersion. This is needed_to ensure that if the master is already fully operating under the new major version, it doesn't go back to mixed_version mode;public static void ensureMajorVersionBarrier(Version joiningNodeVersion, Version minClusterNodeVersion) {_        final byte clusterMajor = minClusterNodeVersion.major__        if (joiningNodeVersion.major < clusterMajor) {_            throw new IllegalStateException("node version [" + joiningNodeVersion + "] is not supported. " +_                "All nodes in the cluster are of a higher major [" + clusterMajor + "].")__        }_    };ensures,that,the,joining,node,s,major,version,is,equal,or,higher,to,the,min,cluster,node,version,this,is,needed,to,ensure,that,if,the,master,is,already,fully,operating,under,the,new,major,version,it,doesn,t,go,back,to,mixed,version,mode;public,static,void,ensure,major,version,barrier,version,joining,node,version,version,min,cluster,node,version,final,byte,cluster,major,min,cluster,node,version,major,if,joining,node,version,major,cluster,major,throw,new,illegal,state,exception,node,version,joining,node,version,is,not,supported,all,nodes,in,the,cluster,are,of,a,higher,major,cluster,major
JoinTaskExecutor -> public static void ensureMajorVersionBarrier(Version joiningNodeVersion, Version minClusterNodeVersion);1548259585;ensures that the joining node's major version is equal or higher to the minClusterNodeVersion. This is needed_to ensure that if the master is already fully operating under the new major version, it doesn't go back to mixed_version mode;public static void ensureMajorVersionBarrier(Version joiningNodeVersion, Version minClusterNodeVersion) {_        final byte clusterMajor = minClusterNodeVersion.major__        if (joiningNodeVersion.major < clusterMajor) {_            throw new IllegalStateException("node version [" + joiningNodeVersion + "] is not supported. " +_                "All nodes in the cluster are of a higher major [" + clusterMajor + "].")__        }_    };ensures,that,the,joining,node,s,major,version,is,equal,or,higher,to,the,min,cluster,node,version,this,is,needed,to,ensure,that,if,the,master,is,already,fully,operating,under,the,new,major,version,it,doesn,t,go,back,to,mixed,version,mode;public,static,void,ensure,major,version,barrier,version,joining,node,version,version,min,cluster,node,version,final,byte,cluster,major,min,cluster,node,version,major,if,joining,node,version,major,cluster,major,throw,new,illegal,state,exception,node,version,joining,node,version,is,not,supported,all,nodes,in,the,cluster,are,of,a,higher,major,cluster,major
JoinTaskExecutor -> public static void ensureMajorVersionBarrier(Version joiningNodeVersion, Version minClusterNodeVersion);1548320260;ensures that the joining node's major version is equal or higher to the minClusterNodeVersion. This is needed_to ensure that if the master is already fully operating under the new major version, it doesn't go back to mixed_version mode;public static void ensureMajorVersionBarrier(Version joiningNodeVersion, Version minClusterNodeVersion) {_        final byte clusterMajor = minClusterNodeVersion.major__        if (joiningNodeVersion.major < clusterMajor) {_            throw new IllegalStateException("node version [" + joiningNodeVersion + "] is not supported. " +_                "All nodes in the cluster are of a higher major [" + clusterMajor + "].")__        }_    };ensures,that,the,joining,node,s,major,version,is,equal,or,higher,to,the,min,cluster,node,version,this,is,needed,to,ensure,that,if,the,master,is,already,fully,operating,under,the,new,major,version,it,doesn,t,go,back,to,mixed,version,mode;public,static,void,ensure,major,version,barrier,version,joining,node,version,version,min,cluster,node,version,final,byte,cluster,major,min,cluster,node,version,major,if,joining,node,version,major,cluster,major,throw,new,illegal,state,exception,node,version,joining,node,version,is,not,supported,all,nodes,in,the,cluster,are,of,a,higher,major,cluster,major
JoinTaskExecutor -> public static void ensureMajorVersionBarrier(Version joiningNodeVersion, Version minClusterNodeVersion);1549356476;ensures that the joining node's major version is equal or higher to the minClusterNodeVersion. This is needed_to ensure that if the master is already fully operating under the new major version, it doesn't go back to mixed_version mode;public static void ensureMajorVersionBarrier(Version joiningNodeVersion, Version minClusterNodeVersion) {_        final byte clusterMajor = minClusterNodeVersion.major__        if (joiningNodeVersion.major < clusterMajor) {_            throw new IllegalStateException("node version [" + joiningNodeVersion + "] is not supported. " +_                "All nodes in the cluster are of a higher major [" + clusterMajor + "].")__        }_    };ensures,that,the,joining,node,s,major,version,is,equal,or,higher,to,the,min,cluster,node,version,this,is,needed,to,ensure,that,if,the,master,is,already,fully,operating,under,the,new,major,version,it,doesn,t,go,back,to,mixed,version,mode;public,static,void,ensure,major,version,barrier,version,joining,node,version,version,min,cluster,node,version,final,byte,cluster,major,min,cluster,node,version,major,if,joining,node,version,major,cluster,major,throw,new,illegal,state,exception,node,version,joining,node,version,is,not,supported,all,nodes,in,the,cluster,are,of,a,higher,major,cluster,major
JoinTaskExecutor -> public static void ensureMajorVersionBarrier(Version joiningNodeVersion, Version minClusterNodeVersion);1551086646;ensures that the joining node's major version is equal or higher to the minClusterNodeVersion. This is needed_to ensure that if the master is already fully operating under the new major version, it doesn't go back to mixed_version mode;public static void ensureMajorVersionBarrier(Version joiningNodeVersion, Version minClusterNodeVersion) {_        final byte clusterMajor = minClusterNodeVersion.major__        if (joiningNodeVersion.major < clusterMajor) {_            throw new IllegalStateException("node version [" + joiningNodeVersion + "] is not supported. " +_                "All nodes in the cluster are of a higher major [" + clusterMajor + "].")__        }_    };ensures,that,the,joining,node,s,major,version,is,equal,or,higher,to,the,min,cluster,node,version,this,is,needed,to,ensure,that,if,the,master,is,already,fully,operating,under,the,new,major,version,it,doesn,t,go,back,to,mixed,version,mode;public,static,void,ensure,major,version,barrier,version,joining,node,version,version,min,cluster,node,version,final,byte,cluster,major,min,cluster,node,version,major,if,joining,node,version,major,cluster,major,throw,new,illegal,state,exception,node,version,joining,node,version,is,not,supported,all,nodes,in,the,cluster,are,of,a,higher,major,cluster,major
JoinTaskExecutor -> public static void ensureIndexCompatibility(final Version nodeVersion, MetaData metaData);1544081506;Ensures that all indices are compatible with the given node version. This will ensure that all indices in the given metadata_will not be created with a newer version of elasticsearch as well as that all indices are newer or equal to the minimum index_compatibility version._@see Version#minimumIndexCompatibilityVersion()_@throws IllegalStateException if any index is incompatible with the given version;public static void ensureIndexCompatibility(final Version nodeVersion, MetaData metaData) {_        Version supportedIndexVersion = nodeVersion.minimumIndexCompatibilityVersion()__        _        _        for (IndexMetaData idxMetaData : metaData) {_            if (idxMetaData.getCreationVersion().after(nodeVersion)) {_                throw new IllegalStateException("index " + idxMetaData.getIndex() + " version not supported: "_                    + idxMetaData.getCreationVersion() + " the node version is: " + nodeVersion)__            }_            if (idxMetaData.getCreationVersion().before(supportedIndexVersion)) {_                throw new IllegalStateException("index " + idxMetaData.getIndex() + " version not supported: "_                    + idxMetaData.getCreationVersion() + " minimum compatible index version is: " + supportedIndexVersion)__            }_        }_    };ensures,that,all,indices,are,compatible,with,the,given,node,version,this,will,ensure,that,all,indices,in,the,given,metadata,will,not,be,created,with,a,newer,version,of,elasticsearch,as,well,as,that,all,indices,are,newer,or,equal,to,the,minimum,index,compatibility,version,see,version,minimum,index,compatibility,version,throws,illegal,state,exception,if,any,index,is,incompatible,with,the,given,version;public,static,void,ensure,index,compatibility,final,version,node,version,meta,data,meta,data,version,supported,index,version,node,version,minimum,index,compatibility,version,for,index,meta,data,idx,meta,data,meta,data,if,idx,meta,data,get,creation,version,after,node,version,throw,new,illegal,state,exception,index,idx,meta,data,get,index,version,not,supported,idx,meta,data,get,creation,version,the,node,version,is,node,version,if,idx,meta,data,get,creation,version,before,supported,index,version,throw,new,illegal,state,exception,index,idx,meta,data,get,index,version,not,supported,idx,meta,data,get,creation,version,minimum,compatible,index,version,is,supported,index,version
JoinTaskExecutor -> public static void ensureIndexCompatibility(final Version nodeVersion, MetaData metaData);1544254415;Ensures that all indices are compatible with the given node version. This will ensure that all indices in the given metadata_will not be created with a newer version of elasticsearch as well as that all indices are newer or equal to the minimum index_compatibility version._@see Version#minimumIndexCompatibilityVersion()_@throws IllegalStateException if any index is incompatible with the given version;public static void ensureIndexCompatibility(final Version nodeVersion, MetaData metaData) {_        Version supportedIndexVersion = nodeVersion.minimumIndexCompatibilityVersion()__        _        _        for (IndexMetaData idxMetaData : metaData) {_            if (idxMetaData.getCreationVersion().after(nodeVersion)) {_                throw new IllegalStateException("index " + idxMetaData.getIndex() + " version not supported: "_                    + idxMetaData.getCreationVersion() + " the node version is: " + nodeVersion)__            }_            if (idxMetaData.getCreationVersion().before(supportedIndexVersion)) {_                throw new IllegalStateException("index " + idxMetaData.getIndex() + " version not supported: "_                    + idxMetaData.getCreationVersion() + " minimum compatible index version is: " + supportedIndexVersion)__            }_        }_    };ensures,that,all,indices,are,compatible,with,the,given,node,version,this,will,ensure,that,all,indices,in,the,given,metadata,will,not,be,created,with,a,newer,version,of,elasticsearch,as,well,as,that,all,indices,are,newer,or,equal,to,the,minimum,index,compatibility,version,see,version,minimum,index,compatibility,version,throws,illegal,state,exception,if,any,index,is,incompatible,with,the,given,version;public,static,void,ensure,index,compatibility,final,version,node,version,meta,data,meta,data,version,supported,index,version,node,version,minimum,index,compatibility,version,for,index,meta,data,idx,meta,data,meta,data,if,idx,meta,data,get,creation,version,after,node,version,throw,new,illegal,state,exception,index,idx,meta,data,get,index,version,not,supported,idx,meta,data,get,creation,version,the,node,version,is,node,version,if,idx,meta,data,get,creation,version,before,supported,index,version,throw,new,illegal,state,exception,index,idx,meta,data,get,index,version,not,supported,idx,meta,data,get,creation,version,minimum,compatible,index,version,is,supported,index,version
JoinTaskExecutor -> public static void ensureIndexCompatibility(final Version nodeVersion, MetaData metaData);1547121470;Ensures that all indices are compatible with the given node version. This will ensure that all indices in the given metadata_will not be created with a newer version of elasticsearch as well as that all indices are newer or equal to the minimum index_compatibility version._@see Version#minimumIndexCompatibilityVersion()_@throws IllegalStateException if any index is incompatible with the given version;public static void ensureIndexCompatibility(final Version nodeVersion, MetaData metaData) {_        Version supportedIndexVersion = nodeVersion.minimumIndexCompatibilityVersion()__        _        _        for (IndexMetaData idxMetaData : metaData) {_            if (idxMetaData.getCreationVersion().after(nodeVersion)) {_                throw new IllegalStateException("index " + idxMetaData.getIndex() + " version not supported: "_                    + idxMetaData.getCreationVersion() + " the node version is: " + nodeVersion)__            }_            if (idxMetaData.getCreationVersion().before(supportedIndexVersion)) {_                throw new IllegalStateException("index " + idxMetaData.getIndex() + " version not supported: "_                    + idxMetaData.getCreationVersion() + " minimum compatible index version is: " + supportedIndexVersion)__            }_        }_    };ensures,that,all,indices,are,compatible,with,the,given,node,version,this,will,ensure,that,all,indices,in,the,given,metadata,will,not,be,created,with,a,newer,version,of,elasticsearch,as,well,as,that,all,indices,are,newer,or,equal,to,the,minimum,index,compatibility,version,see,version,minimum,index,compatibility,version,throws,illegal,state,exception,if,any,index,is,incompatible,with,the,given,version;public,static,void,ensure,index,compatibility,final,version,node,version,meta,data,meta,data,version,supported,index,version,node,version,minimum,index,compatibility,version,for,index,meta,data,idx,meta,data,meta,data,if,idx,meta,data,get,creation,version,after,node,version,throw,new,illegal,state,exception,index,idx,meta,data,get,index,version,not,supported,idx,meta,data,get,creation,version,the,node,version,is,node,version,if,idx,meta,data,get,creation,version,before,supported,index,version,throw,new,illegal,state,exception,index,idx,meta,data,get,index,version,not,supported,idx,meta,data,get,creation,version,minimum,compatible,index,version,is,supported,index,version
JoinTaskExecutor -> public static void ensureIndexCompatibility(final Version nodeVersion, MetaData metaData);1548161085;Ensures that all indices are compatible with the given node version. This will ensure that all indices in the given metadata_will not be created with a newer version of elasticsearch as well as that all indices are newer or equal to the minimum index_compatibility version._@see Version#minimumIndexCompatibilityVersion()_@throws IllegalStateException if any index is incompatible with the given version;public static void ensureIndexCompatibility(final Version nodeVersion, MetaData metaData) {_        Version supportedIndexVersion = nodeVersion.minimumIndexCompatibilityVersion()__        _        _        for (IndexMetaData idxMetaData : metaData) {_            if (idxMetaData.getCreationVersion().after(nodeVersion)) {_                throw new IllegalStateException("index " + idxMetaData.getIndex() + " version not supported: "_                    + idxMetaData.getCreationVersion() + " the node version is: " + nodeVersion)__            }_            if (idxMetaData.getCreationVersion().before(supportedIndexVersion)) {_                throw new IllegalStateException("index " + idxMetaData.getIndex() + " version not supported: "_                    + idxMetaData.getCreationVersion() + " minimum compatible index version is: " + supportedIndexVersion)__            }_        }_    };ensures,that,all,indices,are,compatible,with,the,given,node,version,this,will,ensure,that,all,indices,in,the,given,metadata,will,not,be,created,with,a,newer,version,of,elasticsearch,as,well,as,that,all,indices,are,newer,or,equal,to,the,minimum,index,compatibility,version,see,version,minimum,index,compatibility,version,throws,illegal,state,exception,if,any,index,is,incompatible,with,the,given,version;public,static,void,ensure,index,compatibility,final,version,node,version,meta,data,meta,data,version,supported,index,version,node,version,minimum,index,compatibility,version,for,index,meta,data,idx,meta,data,meta,data,if,idx,meta,data,get,creation,version,after,node,version,throw,new,illegal,state,exception,index,idx,meta,data,get,index,version,not,supported,idx,meta,data,get,creation,version,the,node,version,is,node,version,if,idx,meta,data,get,creation,version,before,supported,index,version,throw,new,illegal,state,exception,index,idx,meta,data,get,index,version,not,supported,idx,meta,data,get,creation,version,minimum,compatible,index,version,is,supported,index,version
JoinTaskExecutor -> public static void ensureIndexCompatibility(final Version nodeVersion, MetaData metaData);1548259585;Ensures that all indices are compatible with the given node version. This will ensure that all indices in the given metadata_will not be created with a newer version of elasticsearch as well as that all indices are newer or equal to the minimum index_compatibility version._@see Version#minimumIndexCompatibilityVersion()_@throws IllegalStateException if any index is incompatible with the given version;public static void ensureIndexCompatibility(final Version nodeVersion, MetaData metaData) {_        Version supportedIndexVersion = nodeVersion.minimumIndexCompatibilityVersion()__        _        _        for (IndexMetaData idxMetaData : metaData) {_            if (idxMetaData.getCreationVersion().after(nodeVersion)) {_                throw new IllegalStateException("index " + idxMetaData.getIndex() + " version not supported: "_                    + idxMetaData.getCreationVersion() + " the node version is: " + nodeVersion)__            }_            if (idxMetaData.getCreationVersion().before(supportedIndexVersion)) {_                throw new IllegalStateException("index " + idxMetaData.getIndex() + " version not supported: "_                    + idxMetaData.getCreationVersion() + " minimum compatible index version is: " + supportedIndexVersion)__            }_        }_    };ensures,that,all,indices,are,compatible,with,the,given,node,version,this,will,ensure,that,all,indices,in,the,given,metadata,will,not,be,created,with,a,newer,version,of,elasticsearch,as,well,as,that,all,indices,are,newer,or,equal,to,the,minimum,index,compatibility,version,see,version,minimum,index,compatibility,version,throws,illegal,state,exception,if,any,index,is,incompatible,with,the,given,version;public,static,void,ensure,index,compatibility,final,version,node,version,meta,data,meta,data,version,supported,index,version,node,version,minimum,index,compatibility,version,for,index,meta,data,idx,meta,data,meta,data,if,idx,meta,data,get,creation,version,after,node,version,throw,new,illegal,state,exception,index,idx,meta,data,get,index,version,not,supported,idx,meta,data,get,creation,version,the,node,version,is,node,version,if,idx,meta,data,get,creation,version,before,supported,index,version,throw,new,illegal,state,exception,index,idx,meta,data,get,index,version,not,supported,idx,meta,data,get,creation,version,minimum,compatible,index,version,is,supported,index,version
JoinTaskExecutor -> public static void ensureIndexCompatibility(final Version nodeVersion, MetaData metaData);1548320260;Ensures that all indices are compatible with the given node version. This will ensure that all indices in the given metadata_will not be created with a newer version of elasticsearch as well as that all indices are newer or equal to the minimum index_compatibility version._@see Version#minimumIndexCompatibilityVersion()_@throws IllegalStateException if any index is incompatible with the given version;public static void ensureIndexCompatibility(final Version nodeVersion, MetaData metaData) {_        Version supportedIndexVersion = nodeVersion.minimumIndexCompatibilityVersion()__        _        _        for (IndexMetaData idxMetaData : metaData) {_            if (idxMetaData.getCreationVersion().after(nodeVersion)) {_                throw new IllegalStateException("index " + idxMetaData.getIndex() + " version not supported: "_                    + idxMetaData.getCreationVersion() + " the node version is: " + nodeVersion)__            }_            if (idxMetaData.getCreationVersion().before(supportedIndexVersion)) {_                throw new IllegalStateException("index " + idxMetaData.getIndex() + " version not supported: "_                    + idxMetaData.getCreationVersion() + " minimum compatible index version is: " + supportedIndexVersion)__            }_        }_    };ensures,that,all,indices,are,compatible,with,the,given,node,version,this,will,ensure,that,all,indices,in,the,given,metadata,will,not,be,created,with,a,newer,version,of,elasticsearch,as,well,as,that,all,indices,are,newer,or,equal,to,the,minimum,index,compatibility,version,see,version,minimum,index,compatibility,version,throws,illegal,state,exception,if,any,index,is,incompatible,with,the,given,version;public,static,void,ensure,index,compatibility,final,version,node,version,meta,data,meta,data,version,supported,index,version,node,version,minimum,index,compatibility,version,for,index,meta,data,idx,meta,data,meta,data,if,idx,meta,data,get,creation,version,after,node,version,throw,new,illegal,state,exception,index,idx,meta,data,get,index,version,not,supported,idx,meta,data,get,creation,version,the,node,version,is,node,version,if,idx,meta,data,get,creation,version,before,supported,index,version,throw,new,illegal,state,exception,index,idx,meta,data,get,index,version,not,supported,idx,meta,data,get,creation,version,minimum,compatible,index,version,is,supported,index,version
JoinTaskExecutor -> public static void ensureIndexCompatibility(final Version nodeVersion, MetaData metaData);1549356476;Ensures that all indices are compatible with the given node version. This will ensure that all indices in the given metadata_will not be created with a newer version of elasticsearch as well as that all indices are newer or equal to the minimum index_compatibility version._@see Version#minimumIndexCompatibilityVersion()_@throws IllegalStateException if any index is incompatible with the given version;public static void ensureIndexCompatibility(final Version nodeVersion, MetaData metaData) {_        Version supportedIndexVersion = nodeVersion.minimumIndexCompatibilityVersion()__        _        _        for (IndexMetaData idxMetaData : metaData) {_            if (idxMetaData.getCreationVersion().after(nodeVersion)) {_                throw new IllegalStateException("index " + idxMetaData.getIndex() + " version not supported: "_                    + idxMetaData.getCreationVersion() + " the node version is: " + nodeVersion)__            }_            if (idxMetaData.getCreationVersion().before(supportedIndexVersion)) {_                throw new IllegalStateException("index " + idxMetaData.getIndex() + " version not supported: "_                    + idxMetaData.getCreationVersion() + " minimum compatible index version is: " + supportedIndexVersion)__            }_        }_    };ensures,that,all,indices,are,compatible,with,the,given,node,version,this,will,ensure,that,all,indices,in,the,given,metadata,will,not,be,created,with,a,newer,version,of,elasticsearch,as,well,as,that,all,indices,are,newer,or,equal,to,the,minimum,index,compatibility,version,see,version,minimum,index,compatibility,version,throws,illegal,state,exception,if,any,index,is,incompatible,with,the,given,version;public,static,void,ensure,index,compatibility,final,version,node,version,meta,data,meta,data,version,supported,index,version,node,version,minimum,index,compatibility,version,for,index,meta,data,idx,meta,data,meta,data,if,idx,meta,data,get,creation,version,after,node,version,throw,new,illegal,state,exception,index,idx,meta,data,get,index,version,not,supported,idx,meta,data,get,creation,version,the,node,version,is,node,version,if,idx,meta,data,get,creation,version,before,supported,index,version,throw,new,illegal,state,exception,index,idx,meta,data,get,index,version,not,supported,idx,meta,data,get,creation,version,minimum,compatible,index,version,is,supported,index,version
JoinTaskExecutor -> public static void ensureIndexCompatibility(final Version nodeVersion, MetaData metaData);1551086646;Ensures that all indices are compatible with the given node version. This will ensure that all indices in the given metadata_will not be created with a newer version of elasticsearch as well as that all indices are newer or equal to the minimum index_compatibility version._@see Version#minimumIndexCompatibilityVersion()_@throws IllegalStateException if any index is incompatible with the given version;public static void ensureIndexCompatibility(final Version nodeVersion, MetaData metaData) {_        Version supportedIndexVersion = nodeVersion.minimumIndexCompatibilityVersion()__        _        _        for (IndexMetaData idxMetaData : metaData) {_            if (idxMetaData.getCreationVersion().after(nodeVersion)) {_                throw new IllegalStateException("index " + idxMetaData.getIndex() + " version not supported: "_                    + idxMetaData.getCreationVersion() + " the node version is: " + nodeVersion)__            }_            if (idxMetaData.getCreationVersion().before(supportedIndexVersion)) {_                throw new IllegalStateException("index " + idxMetaData.getIndex() + " version not supported: "_                    + idxMetaData.getCreationVersion() + " minimum compatible index version is: " + supportedIndexVersion)__            }_        }_    };ensures,that,all,indices,are,compatible,with,the,given,node,version,this,will,ensure,that,all,indices,in,the,given,metadata,will,not,be,created,with,a,newer,version,of,elasticsearch,as,well,as,that,all,indices,are,newer,or,equal,to,the,minimum,index,compatibility,version,see,version,minimum,index,compatibility,version,throws,illegal,state,exception,if,any,index,is,incompatible,with,the,given,version;public,static,void,ensure,index,compatibility,final,version,node,version,meta,data,meta,data,version,supported,index,version,node,version,minimum,index,compatibility,version,for,index,meta,data,idx,meta,data,meta,data,if,idx,meta,data,get,creation,version,after,node,version,throw,new,illegal,state,exception,index,idx,meta,data,get,index,version,not,supported,idx,meta,data,get,creation,version,the,node,version,is,node,version,if,idx,meta,data,get,creation,version,before,supported,index,version,throw,new,illegal,state,exception,index,idx,meta,data,get,index,version,not,supported,idx,meta,data,get,creation,version,minimum,compatible,index,version,is,supported,index,version
JoinTaskExecutor -> public static void ensureNodesCompatibility(Version joiningNodeVersion, Version minClusterNodeVersion, Version maxClusterNodeVersion);1544081506;ensures that the joining node has a version that's compatible with a given version range;public static void ensureNodesCompatibility(Version joiningNodeVersion, Version minClusterNodeVersion, Version maxClusterNodeVersion) {_        assert minClusterNodeVersion.onOrBefore(maxClusterNodeVersion) : minClusterNodeVersion + " > " + maxClusterNodeVersion__        if (joiningNodeVersion.isCompatible(maxClusterNodeVersion) == false) {_            throw new IllegalStateException("node version [" + joiningNodeVersion + "] is not supported. " +_                "The cluster contains nodes with version [" + maxClusterNodeVersion + "], which is incompatible.")__        }_        if (joiningNodeVersion.isCompatible(minClusterNodeVersion) == false) {_            throw new IllegalStateException("node version [" + joiningNodeVersion + "] is not supported." +_                "The cluster contains nodes with version [" + minClusterNodeVersion + "], which is incompatible.")__        }_    };ensures,that,the,joining,node,has,a,version,that,s,compatible,with,a,given,version,range;public,static,void,ensure,nodes,compatibility,version,joining,node,version,version,min,cluster,node,version,version,max,cluster,node,version,assert,min,cluster,node,version,on,or,before,max,cluster,node,version,min,cluster,node,version,max,cluster,node,version,if,joining,node,version,is,compatible,max,cluster,node,version,false,throw,new,illegal,state,exception,node,version,joining,node,version,is,not,supported,the,cluster,contains,nodes,with,version,max,cluster,node,version,which,is,incompatible,if,joining,node,version,is,compatible,min,cluster,node,version,false,throw,new,illegal,state,exception,node,version,joining,node,version,is,not,supported,the,cluster,contains,nodes,with,version,min,cluster,node,version,which,is,incompatible
JoinTaskExecutor -> public static void ensureNodesCompatibility(Version joiningNodeVersion, Version minClusterNodeVersion, Version maxClusterNodeVersion);1544254415;ensures that the joining node has a version that's compatible with a given version range;public static void ensureNodesCompatibility(Version joiningNodeVersion, Version minClusterNodeVersion, Version maxClusterNodeVersion) {_        assert minClusterNodeVersion.onOrBefore(maxClusterNodeVersion) : minClusterNodeVersion + " > " + maxClusterNodeVersion__        if (joiningNodeVersion.isCompatible(maxClusterNodeVersion) == false) {_            throw new IllegalStateException("node version [" + joiningNodeVersion + "] is not supported. " +_                "The cluster contains nodes with version [" + maxClusterNodeVersion + "], which is incompatible.")__        }_        if (joiningNodeVersion.isCompatible(minClusterNodeVersion) == false) {_            throw new IllegalStateException("node version [" + joiningNodeVersion + "] is not supported." +_                "The cluster contains nodes with version [" + minClusterNodeVersion + "], which is incompatible.")__        }_    };ensures,that,the,joining,node,has,a,version,that,s,compatible,with,a,given,version,range;public,static,void,ensure,nodes,compatibility,version,joining,node,version,version,min,cluster,node,version,version,max,cluster,node,version,assert,min,cluster,node,version,on,or,before,max,cluster,node,version,min,cluster,node,version,max,cluster,node,version,if,joining,node,version,is,compatible,max,cluster,node,version,false,throw,new,illegal,state,exception,node,version,joining,node,version,is,not,supported,the,cluster,contains,nodes,with,version,max,cluster,node,version,which,is,incompatible,if,joining,node,version,is,compatible,min,cluster,node,version,false,throw,new,illegal,state,exception,node,version,joining,node,version,is,not,supported,the,cluster,contains,nodes,with,version,min,cluster,node,version,which,is,incompatible
JoinTaskExecutor -> public static void ensureNodesCompatibility(Version joiningNodeVersion, Version minClusterNodeVersion, Version maxClusterNodeVersion);1547121470;ensures that the joining node has a version that's compatible with a given version range;public static void ensureNodesCompatibility(Version joiningNodeVersion, Version minClusterNodeVersion, Version maxClusterNodeVersion) {_        assert minClusterNodeVersion.onOrBefore(maxClusterNodeVersion) : minClusterNodeVersion + " > " + maxClusterNodeVersion__        if (joiningNodeVersion.isCompatible(maxClusterNodeVersion) == false) {_            throw new IllegalStateException("node version [" + joiningNodeVersion + "] is not supported. " +_                "The cluster contains nodes with version [" + maxClusterNodeVersion + "], which is incompatible.")__        }_        if (joiningNodeVersion.isCompatible(minClusterNodeVersion) == false) {_            throw new IllegalStateException("node version [" + joiningNodeVersion + "] is not supported." +_                "The cluster contains nodes with version [" + minClusterNodeVersion + "], which is incompatible.")__        }_    };ensures,that,the,joining,node,has,a,version,that,s,compatible,with,a,given,version,range;public,static,void,ensure,nodes,compatibility,version,joining,node,version,version,min,cluster,node,version,version,max,cluster,node,version,assert,min,cluster,node,version,on,or,before,max,cluster,node,version,min,cluster,node,version,max,cluster,node,version,if,joining,node,version,is,compatible,max,cluster,node,version,false,throw,new,illegal,state,exception,node,version,joining,node,version,is,not,supported,the,cluster,contains,nodes,with,version,max,cluster,node,version,which,is,incompatible,if,joining,node,version,is,compatible,min,cluster,node,version,false,throw,new,illegal,state,exception,node,version,joining,node,version,is,not,supported,the,cluster,contains,nodes,with,version,min,cluster,node,version,which,is,incompatible
JoinTaskExecutor -> public static void ensureNodesCompatibility(Version joiningNodeVersion, Version minClusterNodeVersion, Version maxClusterNodeVersion);1548161085;ensures that the joining node has a version that's compatible with a given version range;public static void ensureNodesCompatibility(Version joiningNodeVersion, Version minClusterNodeVersion, Version maxClusterNodeVersion) {_        assert minClusterNodeVersion.onOrBefore(maxClusterNodeVersion) : minClusterNodeVersion + " > " + maxClusterNodeVersion__        if (joiningNodeVersion.isCompatible(maxClusterNodeVersion) == false) {_            throw new IllegalStateException("node version [" + joiningNodeVersion + "] is not supported. " +_                "The cluster contains nodes with version [" + maxClusterNodeVersion + "], which is incompatible.")__        }_        if (joiningNodeVersion.isCompatible(minClusterNodeVersion) == false) {_            throw new IllegalStateException("node version [" + joiningNodeVersion + "] is not supported." +_                "The cluster contains nodes with version [" + minClusterNodeVersion + "], which is incompatible.")__        }_    };ensures,that,the,joining,node,has,a,version,that,s,compatible,with,a,given,version,range;public,static,void,ensure,nodes,compatibility,version,joining,node,version,version,min,cluster,node,version,version,max,cluster,node,version,assert,min,cluster,node,version,on,or,before,max,cluster,node,version,min,cluster,node,version,max,cluster,node,version,if,joining,node,version,is,compatible,max,cluster,node,version,false,throw,new,illegal,state,exception,node,version,joining,node,version,is,not,supported,the,cluster,contains,nodes,with,version,max,cluster,node,version,which,is,incompatible,if,joining,node,version,is,compatible,min,cluster,node,version,false,throw,new,illegal,state,exception,node,version,joining,node,version,is,not,supported,the,cluster,contains,nodes,with,version,min,cluster,node,version,which,is,incompatible
JoinTaskExecutor -> public static void ensureNodesCompatibility(Version joiningNodeVersion, Version minClusterNodeVersion, Version maxClusterNodeVersion);1548259585;ensures that the joining node has a version that's compatible with a given version range;public static void ensureNodesCompatibility(Version joiningNodeVersion, Version minClusterNodeVersion, Version maxClusterNodeVersion) {_        assert minClusterNodeVersion.onOrBefore(maxClusterNodeVersion) : minClusterNodeVersion + " > " + maxClusterNodeVersion__        if (joiningNodeVersion.isCompatible(maxClusterNodeVersion) == false) {_            throw new IllegalStateException("node version [" + joiningNodeVersion + "] is not supported. " +_                "The cluster contains nodes with version [" + maxClusterNodeVersion + "], which is incompatible.")__        }_        if (joiningNodeVersion.isCompatible(minClusterNodeVersion) == false) {_            throw new IllegalStateException("node version [" + joiningNodeVersion + "] is not supported." +_                "The cluster contains nodes with version [" + minClusterNodeVersion + "], which is incompatible.")__        }_    };ensures,that,the,joining,node,has,a,version,that,s,compatible,with,a,given,version,range;public,static,void,ensure,nodes,compatibility,version,joining,node,version,version,min,cluster,node,version,version,max,cluster,node,version,assert,min,cluster,node,version,on,or,before,max,cluster,node,version,min,cluster,node,version,max,cluster,node,version,if,joining,node,version,is,compatible,max,cluster,node,version,false,throw,new,illegal,state,exception,node,version,joining,node,version,is,not,supported,the,cluster,contains,nodes,with,version,max,cluster,node,version,which,is,incompatible,if,joining,node,version,is,compatible,min,cluster,node,version,false,throw,new,illegal,state,exception,node,version,joining,node,version,is,not,supported,the,cluster,contains,nodes,with,version,min,cluster,node,version,which,is,incompatible
JoinTaskExecutor -> public static void ensureNodesCompatibility(Version joiningNodeVersion, Version minClusterNodeVersion, Version maxClusterNodeVersion);1548320260;ensures that the joining node has a version that's compatible with a given version range;public static void ensureNodesCompatibility(Version joiningNodeVersion, Version minClusterNodeVersion, Version maxClusterNodeVersion) {_        assert minClusterNodeVersion.onOrBefore(maxClusterNodeVersion) : minClusterNodeVersion + " > " + maxClusterNodeVersion__        if (joiningNodeVersion.isCompatible(maxClusterNodeVersion) == false) {_            throw new IllegalStateException("node version [" + joiningNodeVersion + "] is not supported. " +_                "The cluster contains nodes with version [" + maxClusterNodeVersion + "], which is incompatible.")__        }_        if (joiningNodeVersion.isCompatible(minClusterNodeVersion) == false) {_            throw new IllegalStateException("node version [" + joiningNodeVersion + "] is not supported." +_                "The cluster contains nodes with version [" + minClusterNodeVersion + "], which is incompatible.")__        }_    };ensures,that,the,joining,node,has,a,version,that,s,compatible,with,a,given,version,range;public,static,void,ensure,nodes,compatibility,version,joining,node,version,version,min,cluster,node,version,version,max,cluster,node,version,assert,min,cluster,node,version,on,or,before,max,cluster,node,version,min,cluster,node,version,max,cluster,node,version,if,joining,node,version,is,compatible,max,cluster,node,version,false,throw,new,illegal,state,exception,node,version,joining,node,version,is,not,supported,the,cluster,contains,nodes,with,version,max,cluster,node,version,which,is,incompatible,if,joining,node,version,is,compatible,min,cluster,node,version,false,throw,new,illegal,state,exception,node,version,joining,node,version,is,not,supported,the,cluster,contains,nodes,with,version,min,cluster,node,version,which,is,incompatible
JoinTaskExecutor -> public static void ensureNodesCompatibility(Version joiningNodeVersion, Version minClusterNodeVersion, Version maxClusterNodeVersion);1549356476;ensures that the joining node has a version that's compatible with a given version range;public static void ensureNodesCompatibility(Version joiningNodeVersion, Version minClusterNodeVersion, Version maxClusterNodeVersion) {_        assert minClusterNodeVersion.onOrBefore(maxClusterNodeVersion) : minClusterNodeVersion + " > " + maxClusterNodeVersion__        if (joiningNodeVersion.isCompatible(maxClusterNodeVersion) == false) {_            throw new IllegalStateException("node version [" + joiningNodeVersion + "] is not supported. " +_                "The cluster contains nodes with version [" + maxClusterNodeVersion + "], which is incompatible.")__        }_        if (joiningNodeVersion.isCompatible(minClusterNodeVersion) == false) {_            throw new IllegalStateException("node version [" + joiningNodeVersion + "] is not supported." +_                "The cluster contains nodes with version [" + minClusterNodeVersion + "], which is incompatible.")__        }_    };ensures,that,the,joining,node,has,a,version,that,s,compatible,with,a,given,version,range;public,static,void,ensure,nodes,compatibility,version,joining,node,version,version,min,cluster,node,version,version,max,cluster,node,version,assert,min,cluster,node,version,on,or,before,max,cluster,node,version,min,cluster,node,version,max,cluster,node,version,if,joining,node,version,is,compatible,max,cluster,node,version,false,throw,new,illegal,state,exception,node,version,joining,node,version,is,not,supported,the,cluster,contains,nodes,with,version,max,cluster,node,version,which,is,incompatible,if,joining,node,version,is,compatible,min,cluster,node,version,false,throw,new,illegal,state,exception,node,version,joining,node,version,is,not,supported,the,cluster,contains,nodes,with,version,min,cluster,node,version,which,is,incompatible
JoinTaskExecutor -> public static void ensureNodesCompatibility(Version joiningNodeVersion, Version minClusterNodeVersion, Version maxClusterNodeVersion);1551086646;ensures that the joining node has a version that's compatible with a given version range;public static void ensureNodesCompatibility(Version joiningNodeVersion, Version minClusterNodeVersion, Version maxClusterNodeVersion) {_        assert minClusterNodeVersion.onOrBefore(maxClusterNodeVersion) : minClusterNodeVersion + " > " + maxClusterNodeVersion__        if (joiningNodeVersion.isCompatible(maxClusterNodeVersion) == false) {_            throw new IllegalStateException("node version [" + joiningNodeVersion + "] is not supported. " +_                "The cluster contains nodes with version [" + maxClusterNodeVersion + "], which is incompatible.")__        }_        if (joiningNodeVersion.isCompatible(minClusterNodeVersion) == false) {_            throw new IllegalStateException("node version [" + joiningNodeVersion + "] is not supported." +_                "The cluster contains nodes with version [" + minClusterNodeVersion + "], which is incompatible.")__        }_    };ensures,that,the,joining,node,has,a,version,that,s,compatible,with,a,given,version,range;public,static,void,ensure,nodes,compatibility,version,joining,node,version,version,min,cluster,node,version,version,max,cluster,node,version,assert,min,cluster,node,version,on,or,before,max,cluster,node,version,min,cluster,node,version,max,cluster,node,version,if,joining,node,version,is,compatible,max,cluster,node,version,false,throw,new,illegal,state,exception,node,version,joining,node,version,is,not,supported,the,cluster,contains,nodes,with,version,max,cluster,node,version,which,is,incompatible,if,joining,node,version,is,compatible,min,cluster,node,version,false,throw,new,illegal,state,exception,node,version,joining,node,version,is,not,supported,the,cluster,contains,nodes,with,version,min,cluster,node,version,which,is,incompatible
