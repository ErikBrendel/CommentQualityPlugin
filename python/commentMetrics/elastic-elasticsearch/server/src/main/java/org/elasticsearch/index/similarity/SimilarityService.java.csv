commented;modifiers;parameterAmount;loc;comment;code
false;public;1;5;;public Similarity similarity(MapperService mapperService) {     // TODO we can maybe factor out MapperService here entirely by introducing an interface for the lookup?     return (mapperService != null) ? new PerFieldSimilarity(defaultSimilarity, mapperService) : defaultSimilarity. }
false;public;1;7;;public SimilarityProvider getSimilarity(String name) {     Supplier<Similarity> sim = similarities.get(name).     if (sim == null) {         return null.     }     return new SimilarityProvider(name, sim.get()). }
true;;0;3;// for testing ;// for testing Similarity getDefaultSimilarity() {     return defaultSimilarity. }
false;public;1;5;;@Override public Similarity get(String name) {     MappedFieldType fieldType = mapperService.fullName(name).     return (fieldType != null && fieldType.similarity() != null) ? fieldType.similarity().get() : defaultSimilarity. }
false;static;2;5;;static void validateSimilarity(Version indexCreatedVersion, Similarity similarity) {     validateScoresArePositive(indexCreatedVersion, similarity).     validateScoresDoNotDecreaseWithFreq(indexCreatedVersion, similarity).     validateScoresDoNotIncreaseWithNorm(indexCreatedVersion, similarity). }
false;private,static;2;16;;private static void validateScoresArePositive(Version indexCreatedVersion, Similarity similarity) {     CollectionStatistics collectionStats = new CollectionStatistics("some_field", 1200, 1100, 3000, 2000).     TermStatistics termStats = new TermStatistics(new BytesRef("some_value"), 100, 130).     SimScorer scorer = similarity.scorer(2f, collectionStats, termStats).     FieldInvertState state = new FieldInvertState(indexCreatedVersion.luceneVersion.major, "some_field", IndexOptions.DOCS_AND_FREQS, 20, 20, 0, 50, 10, // length = 20, no overlap     3).     final long norm = similarity.computeNorm(state).     for (int freq = 1. freq <= 10. ++freq) {         float score = scorer.score(freq, norm).         if (score < 0) {             fail(indexCreatedVersion, "Similarities should not return negative scores:\n" + scorer.explain(Explanation.match(freq, "term freq"), norm)).             break.         }     } }
false;private,static;2;19;;private static void validateScoresDoNotDecreaseWithFreq(Version indexCreatedVersion, Similarity similarity) {     CollectionStatistics collectionStats = new CollectionStatistics("some_field", 1200, 1100, 3000, 2000).     TermStatistics termStats = new TermStatistics(new BytesRef("some_value"), 100, 130).     SimScorer scorer = similarity.scorer(2f, collectionStats, termStats).     FieldInvertState state = new FieldInvertState(indexCreatedVersion.luceneVersion.major, "some_field", IndexOptions.DOCS_AND_FREQS, 20, 20, 0, 50, 10, // length = 20, no overlap     3).     final long norm = similarity.computeNorm(state).     float previousScore = 0.     for (int freq = 1. freq <= 10. ++freq) {         float score = scorer.score(freq, norm).         if (score < previousScore) {             fail(indexCreatedVersion, "Similarity scores should not decrease when term frequency increases:\n" + scorer.explain(Explanation.match(freq - 1, "term freq"), norm) + "\n" + scorer.explain(Explanation.match(freq, "term freq"), norm)).             break.         }         previousScore = score.     } }
false;private,static;2;26;;private static void validateScoresDoNotIncreaseWithNorm(Version indexCreatedVersion, Similarity similarity) {     CollectionStatistics collectionStats = new CollectionStatistics("some_field", 1200, 1100, 3000, 2000).     TermStatistics termStats = new TermStatistics(new BytesRef("some_value"), 100, 130).     SimScorer scorer = similarity.scorer(2f, collectionStats, termStats).     long previousNorm = 0.     float previousScore = Float.MAX_VALUE.     for (int length = 1. length <= 10. ++length) {         FieldInvertState state = new FieldInvertState(indexCreatedVersion.luceneVersion.major, "some_field", IndexOptions.DOCS_AND_FREQS, length, length, 0, 50, 10, // length = 20, no overlap         3).         final long norm = similarity.computeNorm(state).         if (Long.compareUnsigned(previousNorm, norm) > 0) {             // esoteric similarity, skip this check             break.         }         float score = scorer.score(1, norm).         if (score > previousScore) {             fail(indexCreatedVersion, "Similarity scores should not increase when norm increases:\n" + scorer.explain(Explanation.match(1, "term freq"), norm - 1) + "\n" + scorer.explain(Explanation.match(1, "term freq"), norm)).             break.         }         previousScore = score.         previousNorm = norm.     } }
false;private,static;2;7;;private static void fail(Version indexCreatedVersion, String message) {     if (indexCreatedVersion.onOrAfter(Version.V_7_0_0)) {         throw new IllegalArgumentException(message).     } else if (indexCreatedVersion.onOrAfter(Version.V_6_5_0)) {         deprecationLogger.deprecated(message).     } }
