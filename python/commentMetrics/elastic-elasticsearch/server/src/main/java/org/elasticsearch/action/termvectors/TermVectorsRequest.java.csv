commented;modifiers;parameterAmount;loc;comment;code
false;public;1;9;;public void readFrom(StreamInput in) throws IOException {     maxNumTerms = in.readOptionalVInt().     minTermFreq = in.readOptionalVInt().     maxTermFreq = in.readOptionalVInt().     minDocFreq = in.readOptionalVInt().     maxDocFreq = in.readOptionalVInt().     minWordLength = in.readOptionalVInt().     maxWordLength = in.readOptionalVInt(). }
false;public;1;9;;public void writeTo(StreamOutput out) throws IOException {     out.writeOptionalVInt(maxNumTerms).     out.writeOptionalVInt(minTermFreq).     out.writeOptionalVInt(maxTermFreq).     out.writeOptionalVInt(minDocFreq).     out.writeOptionalVInt(maxDocFreq).     out.writeOptionalVInt(minWordLength).     out.writeOptionalVInt(maxWordLength). }
false;public;0;3;;public EnumSet<Flag> getFlags() {     return flagsEnum. }
true;public;1;4;/**  * Sets the type of document to get the term vector for.  */ ;/**  * Sets the type of document to get the term vector for.  */ public TermVectorsRequest type(String type) {     this.type = type.     return this. }
true;public;0;3;/**  * Returns the type of document to get the term vector for.  */ ;/**  * Returns the type of document to get the term vector for.  */ public String type() {     return type. }
true;public;0;3;/**  * Returns the id of document the term vector is requested for.  */ ;/**  * Returns the id of document the term vector is requested for.  */ public String id() {     return id. }
true;public;1;4;/**  * Sets the id of document the term vector is requested for.  */ ;/**  * Sets the id of document the term vector is requested for.  */ public TermVectorsRequest id(String id) {     this.id = id.     return this. }
true;public;0;3;/**  * Returns the artificial document from which term vectors are requested for.  */ ;/**  * Returns the artificial document from which term vectors are requested for.  */ public BytesReference doc() {     return doc. }
false;public;0;3;;public XContentType xContentType() {     return xContentType. }
true;public;1;3;/**  * Sets an artificial document from which term vectors are requested for.  */ ;/**  * Sets an artificial document from which term vectors are requested for.  */ public TermVectorsRequest doc(XContentBuilder documentBuilder) {     return this.doc(BytesReference.bytes(documentBuilder), true, documentBuilder.contentType()). }
true;public;2;4;/**  * Sets an artificial document from which term vectors are requested for.  * @deprecated use {@link #doc(BytesReference, boolean, XContentType)} to avoid content auto detection  */ ;/**  * Sets an artificial document from which term vectors are requested for.  * @deprecated use {@link #doc(BytesReference, boolean, XContentType)} to avoid content auto detection  */ @Deprecated public TermVectorsRequest doc(BytesReference doc, boolean generateRandomId) {     return this.doc(doc, generateRandomId, XContentHelper.xContentType(doc)). }
true;public;3;9;/**  * Sets an artificial document from which term vectors are requested for.  */ ;/**  * Sets an artificial document from which term vectors are requested for.  */ public TermVectorsRequest doc(BytesReference doc, boolean generateRandomId, XContentType xContentType) {     // assign a random id to this artificial document, for routing     if (generateRandomId) {         this.id(String.valueOf(randomInt.getAndAdd(1))).     }     this.doc = doc.     this.xContentType = xContentType.     return this. }
true;public;0;3;/**  * @return The routing for this request.  */ ;/**  * @return The routing for this request.  */ public String routing() {     return routing. }
false;public;1;4;;public TermVectorsRequest routing(String routing) {     this.routing = routing.     return this. }
false;public;0;3;;public String preference() {     return this.preference. }
true;public;1;4;/**  * Sets the preference to execute the search. Defaults to randomize across  * shards. Can be set to {@code _local} to prefer local shards or a custom value,  * which guarantees that the same order will be used across different  * requests.  */ ;/**  * Sets the preference to execute the search. Defaults to randomize across  * shards. Can be set to {@code _local} to prefer local shards or a custom value,  * which guarantees that the same order will be used across different  * requests.  */ public TermVectorsRequest preference(String preference) {     this.preference = preference.     return this. }
true;public;1;4;/**  * Return the start and stop offsets for each term if they were stored or  * skip offsets.  */ ;/**  * Return the start and stop offsets for each term if they were stored or  * skip offsets.  */ public TermVectorsRequest offsets(boolean offsets) {     setFlag(Flag.Offsets, offsets).     return this. }
true;public;0;3;/**  * @return <code>true</code> if term offsets should be returned. Otherwise  * <code>false</code>  */ ;/**  * @return <code>true</code> if term offsets should be returned. Otherwise  * <code>false</code>  */ public boolean offsets() {     return flagsEnum.contains(Flag.Offsets). }
true;public;1;4;/**  * Return the positions for each term if stored or skip.  */ ;/**  * Return the positions for each term if stored or skip.  */ public TermVectorsRequest positions(boolean positions) {     setFlag(Flag.Positions, positions).     return this. }
true;public;0;3;/**  * @return Returns if the positions for each term should be returned if  *         stored or skip.  */ ;/**  * @return Returns if the positions for each term should be returned if  *         stored or skip.  */ public boolean positions() {     return flagsEnum.contains(Flag.Positions). }
true;public;0;3;/**  * @return <code>true</code> if term payloads should be returned. Otherwise  * <code>false</code>  */ ;/**  * @return <code>true</code> if term payloads should be returned. Otherwise  * <code>false</code>  */ public boolean payloads() {     return flagsEnum.contains(Flag.Payloads). }
true;public;1;4;/**  * Return the payloads for each term or skip.  */ ;/**  * Return the payloads for each term or skip.  */ public TermVectorsRequest payloads(boolean payloads) {     setFlag(Flag.Payloads, payloads).     return this. }
true;public;0;3;/**  * @return <code>true</code> if term statistics should be returned.  * Otherwise <code>false</code>  */ ;/**  * @return <code>true</code> if term statistics should be returned.  * Otherwise <code>false</code>  */ public boolean termStatistics() {     return flagsEnum.contains(Flag.TermStatistics). }
true;public;1;4;/**  * Return the term statistics for each term in the shard or skip.  */ ;/**  * Return the term statistics for each term in the shard or skip.  */ public TermVectorsRequest termStatistics(boolean termStatistics) {     setFlag(Flag.TermStatistics, termStatistics).     return this. }
true;public;0;3;/**  * @return <code>true</code> if field statistics should be returned.  * Otherwise <code>false</code>  */ ;/**  * @return <code>true</code> if field statistics should be returned.  * Otherwise <code>false</code>  */ public boolean fieldStatistics() {     return flagsEnum.contains(Flag.FieldStatistics). }
true;public;1;4;/**  * Return the field statistics for each term in the shard or skip.  */ ;/**  * Return the field statistics for each term in the shard or skip.  */ public TermVectorsRequest fieldStatistics(boolean fieldStatistics) {     setFlag(Flag.FieldStatistics, fieldStatistics).     return this. }
true;public;0;3;/**  * Return only term vectors for special selected fields. Returns for term  * vectors for all fields if selectedFields == null  */ ;/**  * Return only term vectors for special selected fields. Returns for term  * vectors for all fields if selectedFields == null  */ public Set<String> selectedFields() {     return selectedFields. }
true;public;1;4;/**  * Return only term vectors for special selected fields. Returns the term  * vectors for all fields if selectedFields == null  */ ;/**  * Return only term vectors for special selected fields. Returns the term  * vectors for all fields if selectedFields == null  */ public TermVectorsRequest selectedFields(String... fields) {     selectedFields = fields != null && fields.length != 0 ? Sets.newHashSet(fields) : null.     return this. }
true;public;0;3;/**  * Return whether term vectors should be generated real-time (default to true).  */ ;/**  * Return whether term vectors should be generated real-time (default to true).  */ public boolean realtime() {     return this.realtime. }
false;public;1;5;;@Override public TermVectorsRequest realtime(boolean realtime) {     this.realtime = realtime.     return this. }
true;public;0;3;/**  * Return the overridden analyzers at each field.  */ ;/**  * Return the overridden analyzers at each field.  */ public Map<String, String> perFieldAnalyzer() {     return perFieldAnalyzer. }
true;public;1;4;/**  * Override the analyzer used at each field when generating term vectors.  */ ;/**  * Override the analyzer used at each field when generating term vectors.  */ public TermVectorsRequest perFieldAnalyzer(Map<String, String> perFieldAnalyzer) {     this.perFieldAnalyzer = perFieldAnalyzer != null && perFieldAnalyzer.size() != 0 ? new HashMap<>(perFieldAnalyzer) : null.     return this. }
true;public;0;3;/**  * Return the settings for filtering out terms.  */ ;/**  * Return the settings for filtering out terms.  */ public FilterSettings filterSettings() {     return this.filterSettings. }
true;public;1;4;/**  * Sets the settings for filtering out terms.  */ ;/**  * Sets the settings for filtering out terms.  */ public TermVectorsRequest filterSettings(FilterSettings settings) {     this.filterSettings = settings != null ? settings : null.     return this. }
false;public;0;3;;public long version() {     return version. }
false;public;1;4;;public TermVectorsRequest version(long version) {     this.version = version.     return this. }
false;public;0;3;;public VersionType versionType() {     return versionType. }
false;public;1;4;;public TermVectorsRequest versionType(VersionType versionType) {     this.versionType = versionType.     return this. }
false;private;2;8;;private void setFlag(Flag flag, boolean set) {     if (set && !flagsEnum.contains(flag)) {         flagsEnum.add(flag).     } else if (!set) {         flagsEnum.remove(flag).         assert (!flagsEnum.contains(flag)).     } }
false;public;0;11;;@Override public ActionRequestValidationException validate() {     ActionRequestValidationException validationException = super.validateNonNullIndex().     if (type == null) {         validationException = ValidateActions.addValidationError("type is missing", validationException).     }     if (id == null && doc == null) {         validationException = ValidateActions.addValidationError("id or doc is missing", validationException).     }     return validationException. }
false;public,static;1;5;;public static TermVectorsRequest readTermVectorsRequest(StreamInput in) throws IOException {     TermVectorsRequest termVectorsRequest = new TermVectorsRequest().     termVectorsRequest.readFrom(in).     return termVectorsRequest. }
false;public;1;42;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     type = in.readString().     id = in.readString().     if (in.readBoolean()) {         doc = in.readBytesReference().         xContentType = in.readEnum(XContentType.class).     }     routing = in.readOptionalString().     if (in.getVersion().before(Version.V_7_0_0)) {         // _parent         in.readOptionalString().     }     preference = in.readOptionalString().     long flags = in.readVLong().     flagsEnum.clear().     for (Flag flag : Flag.values()) {         if ((flags & (1 << flag.ordinal())) != 0) {             flagsEnum.add(flag).         }     }     int numSelectedFields = in.readVInt().     if (numSelectedFields > 0) {         selectedFields = new HashSet<>().         for (int i = 0. i < numSelectedFields. i++) {             selectedFields.add(in.readString()).         }     }     if (in.readBoolean()) {         perFieldAnalyzer = readPerFieldAnalyzer(in.readMap()).     }     if (in.readBoolean()) {         filterSettings = new FilterSettings().         filterSettings.readFrom(in).     }     realtime = in.readBoolean().     versionType = VersionType.fromValue(in.readByte()).     version = in.readLong(). }
false;public;1;41;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeString(type).     out.writeString(id).     out.writeBoolean(doc != null).     if (doc != null) {         out.writeBytesReference(doc).         out.writeEnum(xContentType).     }     out.writeOptionalString(routing).     if (out.getVersion().before(Version.V_7_0_0)) {         // _parent         out.writeOptionalString(null).     }     out.writeOptionalString(preference).     long longFlags = 0.     for (Flag flag : flagsEnum) {         longFlags |= (1 << flag.ordinal()).     }     out.writeVLong(longFlags).     if (selectedFields != null) {         out.writeVInt(selectedFields.size()).         for (String selectedField : selectedFields) {             out.writeString(selectedField).         }     } else {         out.writeVInt(0).     }     out.writeBoolean(perFieldAnalyzer != null).     if (perFieldAnalyzer != null) {         out.writeGenericValue(perFieldAnalyzer).     }     out.writeBoolean(filterSettings != null).     if (filterSettings != null) {         filterSettings.writeTo(out).     }     out.writeBoolean(realtime).     out.writeByte(versionType.getValue()).     out.writeLong(version). }
true;public,static;2;67;/**  * populates a request object (pre-populated with defaults) based on a parser.  */ ;/**  * populates a request object (pre-populated with defaults) based on a parser.  */ public static void parseRequest(TermVectorsRequest termVectorsRequest, XContentParser parser) throws IOException {     XContentParser.Token token.     String currentFieldName = null.     List<String> fields = new ArrayList<>().     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (currentFieldName != null) {             if (FIELDS.match(currentFieldName, parser.getDeprecationHandler())) {                 if (token == XContentParser.Token.START_ARRAY) {                     while (parser.nextToken() != XContentParser.Token.END_ARRAY) {                         fields.add(parser.text()).                     }                 } else {                     throw new ElasticsearchParseException("failed to parse term vectors request. field [fields] must be an array").                 }             } else if (OFFSETS.match(currentFieldName, parser.getDeprecationHandler())) {                 termVectorsRequest.offsets(parser.booleanValue()).             } else if (POSITIONS.match(currentFieldName, parser.getDeprecationHandler())) {                 termVectorsRequest.positions(parser.booleanValue()).             } else if (PAYLOADS.match(currentFieldName, parser.getDeprecationHandler())) {                 termVectorsRequest.payloads(parser.booleanValue()).             } else if (currentFieldName.equals("term_statistics") || currentFieldName.equals("termStatistics")) {                 termVectorsRequest.termStatistics(parser.booleanValue()).             } else if (currentFieldName.equals("field_statistics") || currentFieldName.equals("fieldStatistics")) {                 termVectorsRequest.fieldStatistics(parser.booleanValue()).             } else if (DFS.match(currentFieldName, parser.getDeprecationHandler())) {                 throw new IllegalArgumentException("distributed frequencies is not supported anymore for term vectors").             } else if (currentFieldName.equals("per_field_analyzer") || currentFieldName.equals("perFieldAnalyzer")) {                 termVectorsRequest.perFieldAnalyzer(readPerFieldAnalyzer(parser.map())).             } else if (FILTER.match(currentFieldName, parser.getDeprecationHandler())) {                 termVectorsRequest.filterSettings(readFilterSettings(parser)).             } else if (INDEX.match(currentFieldName, parser.getDeprecationHandler())) {                 // the following is important for multi request parsing.                 termVectorsRequest.index = parser.text().             } else if (TYPE.match(currentFieldName, parser.getDeprecationHandler())) {                 termVectorsRequest.type = parser.text().                 deprecationLogger.deprecatedAndMaybeLog("termvectors_with_types", RestTermVectorsAction.TYPES_DEPRECATION_MESSAGE).             } else if (ID.match(currentFieldName, parser.getDeprecationHandler())) {                 if (termVectorsRequest.doc != null) {                     throw new ElasticsearchParseException("failed to parse term vectors request. " + "either [id] or [doc] can be specified, but not both!").                 }                 termVectorsRequest.id = parser.text().             } else if (DOC.match(currentFieldName, parser.getDeprecationHandler())) {                 if (termVectorsRequest.id != null) {                     throw new ElasticsearchParseException("failed to parse term vectors request. " + "either [id] or [doc] can be specified, but not both!").                 }                 termVectorsRequest.doc(jsonBuilder().copyCurrentStructure(parser)).             } else if (ROUTING.match(currentFieldName, parser.getDeprecationHandler())) {                 termVectorsRequest.routing = parser.text().             } else if (VERSION.match(currentFieldName, parser.getDeprecationHandler())) {                 termVectorsRequest.version = parser.longValue().             } else if (VERSION_TYPE.match(currentFieldName, parser.getDeprecationHandler())) {                 termVectorsRequest.versionType = VersionType.fromString(parser.text()).             } else {                 throw new ElasticsearchParseException("failed to parse term vectors request. unknown field [{}]", currentFieldName).             }         }     }     if (fields.size() > 0) {         String[] fieldsAsArray = new String[fields.size()].         termVectorsRequest.selectedFields(fields.toArray(fieldsAsArray)).     } }
false;public,static;1;12;;public static Map<String, String> readPerFieldAnalyzer(Map<String, Object> map) {     Map<String, String> mapStrStr = new HashMap<>().     for (Map.Entry<String, Object> e : map.entrySet()) {         if (e.getValue() instanceof String) {             mapStrStr.put(e.getKey(), (String) e.getValue()).         } else {             throw new ElasticsearchParseException("expecting the analyzer at [{}] to be a String, but found [{}] instead", e.getKey(), e.getValue().getClass()).         }     }     return mapStrStr. }
false;private,static;1;30;;private static FilterSettings readFilterSettings(XContentParser parser) throws IOException {     FilterSettings settings = new FilterSettings().     XContentParser.Token token.     String currentFieldName = null.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (currentFieldName != null) {             if (currentFieldName.equals("max_num_terms")) {                 settings.maxNumTerms = parser.intValue().             } else if (currentFieldName.equals("min_term_freq")) {                 settings.minTermFreq = parser.intValue().             } else if (currentFieldName.equals("max_term_freq")) {                 settings.maxTermFreq = parser.intValue().             } else if (currentFieldName.equals("min_doc_freq")) {                 settings.minDocFreq = parser.intValue().             } else if (currentFieldName.equals("max_doc_freq")) {                 settings.maxDocFreq = parser.intValue().             } else if (currentFieldName.equals("min_word_length")) {                 settings.minWordLength = parser.intValue().             } else if (currentFieldName.equals("max_word_length")) {                 settings.maxWordLength = parser.intValue().             } else {                 throw new ElasticsearchParseException("failed to parse term vectors request. " + "the field [{}] is not valid for filter parameter for term vector request", currentFieldName).             }         }     }     return settings. }
