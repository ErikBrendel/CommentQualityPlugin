commented;modifiers;parameterAmount;loc;comment;code
false;static;2;5;;static ClusterState setLocalNode(final ClusterState clusterState, DiscoveryNode localNode) {     return ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder().add(localNode).localNodeId(localNode.getId()).build()).build(). }
false;static;2;16;;static ClusterState upgradeAndArchiveUnknownOrInvalidSettings(final ClusterState clusterState, final ClusterSettings clusterSettings) {     final MetaData.Builder metaDataBuilder = MetaData.builder(clusterState.metaData()).     metaDataBuilder.persistentSettings(clusterSettings.archiveUnknownOrInvalidSettings(clusterSettings.upgradeSettings(metaDataBuilder.persistentSettings()), e -> logUnknownSetting("persistent", e), (e, ex) -> logInvalidSetting("persistent", e, ex))).     metaDataBuilder.transientSettings(clusterSettings.archiveUnknownOrInvalidSettings(clusterSettings.upgradeSettings(metaDataBuilder.transientSettings()), e -> logUnknownSetting("transient", e), (e, ex) -> logInvalidSetting("transient", e, ex))).     return ClusterState.builder(clusterState).metaData(metaDataBuilder).build(). }
false;private,static;2;3;;private static void logUnknownSetting(final String settingType, final Map.Entry<String, String> e) {     logger.warn("ignoring unknown {} setting: [{}] with value [{}]. archiving", settingType, e.getKey(), e.getValue()). }
false;private,static;3;5;;private static void logInvalidSetting(final String settingType, final Map.Entry<String, String> e, final IllegalArgumentException ex) {     logger.warn(() -> new ParameterizedMessage("ignoring invalid {} setting: [{}] with value [{}]. archiving", settingType, e.getKey(), e.getValue()), ex). }
false;static;1;17;;static ClusterState recoverClusterBlocks(final ClusterState state) {     final ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(state.blocks()).     if (MetaData.SETTING_READ_ONLY_SETTING.get(state.metaData().settings())) {         blocks.addGlobalBlock(MetaData.CLUSTER_READ_ONLY_BLOCK).     }     if (MetaData.SETTING_READ_ONLY_ALLOW_DELETE_SETTING.get(state.metaData().settings())) {         blocks.addGlobalBlock(MetaData.CLUSTER_READ_ONLY_ALLOW_DELETE_BLOCK).     }     for (final IndexMetaData indexMetaData : state.metaData()) {         blocks.addBlocks(indexMetaData).     }     return ClusterState.builder(state).blocks(blocks).build(). }
false;static;1;10;;static ClusterState updateRoutingTable(final ClusterState state) {     // initialize all index routing tables as empty     final RoutingTable.Builder routingTableBuilder = RoutingTable.builder(state.routingTable()).     for (final ObjectCursor<IndexMetaData> cursor : state.metaData().indices().values()) {         routingTableBuilder.addAsRecovery(cursor.value).     }     // start with 0 based versions for routing table     routingTableBuilder.version(0).     return ClusterState.builder(state).routingTable(routingTableBuilder.build()).build(). }
false;static;1;6;;static ClusterState removeStateNotRecoveredBlock(final ClusterState state) {     return ClusterState.builder(state).blocks(ClusterBlocks.builder().blocks(state.blocks()).removeGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK).build()).build(). }
false;public,static;1;6;;public static ClusterState addStateNotRecoveredBlock(ClusterState state) {     return ClusterState.builder(state).blocks(ClusterBlocks.builder().blocks(state.blocks()).addGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK).build()).build(). }
false;static;2;20;;static ClusterState mixCurrentStateAndRecoveredState(final ClusterState currentState, final ClusterState recoveredState) {     assert currentState.metaData().indices().isEmpty().     final ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(currentState.blocks()).blocks(recoveredState.blocks()).     final MetaData.Builder metaDataBuilder = MetaData.builder(recoveredState.metaData()).     // automatically generate a UID for the metadata if we need to     metaDataBuilder.generateClusterUuidIfNeeded().     for (final IndexMetaData indexMetaData : recoveredState.metaData()) {         metaDataBuilder.put(indexMetaData, false).     }     return ClusterState.builder(currentState).blocks(blocks).metaData(metaDataBuilder).build(). }
false;public,static;1;20;;public static ClusterState hideStateIfNotRecovered(ClusterState state) {     if (state.blocks().hasGlobalBlock(STATE_NOT_RECOVERED_BLOCK)) {         final ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(state.blocks()).         blocks.removeGlobalBlock(MetaData.CLUSTER_READ_ONLY_BLOCK).         blocks.removeGlobalBlock(MetaData.CLUSTER_READ_ONLY_ALLOW_DELETE_BLOCK).         for (IndexMetaData indexMetaData : state.metaData()) {             blocks.removeIndexBlocks(indexMetaData.getIndex().getName()).         }         final MetaData metaData = MetaData.builder().clusterUUID(state.metaData().clusterUUID()).coordinationMetaData(state.metaData().coordinationMetaData()).build().         return ClusterState.builder(state).metaData(metaData).blocks(blocks.build()).build().     }     return state. }
