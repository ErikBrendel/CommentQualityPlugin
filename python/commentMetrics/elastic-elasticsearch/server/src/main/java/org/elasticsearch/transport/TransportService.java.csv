commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;4;;@Override protected boolean removeEldestEntry(Map.Entry eldest) {     return size() > 100. }
false;public;0;4;;@Override public DiscoveryNode getNode() {     return localNode. }
false;public;4;5;;@Override public void sendRequest(long requestId, String action, TransportRequest request, TransportRequestOptions options) throws TransportException {     sendLocalRequest(requestId, action, request, options). }
false;public;1;3;;@Override public void addCloseListener(ActionListener<Void> listener) { }
false;public;0;4;;@Override public boolean isClosed() {     return false. }
false;public;0;3;;@Override public void close() { }
false;public;0;3;;public RemoteClusterService getRemoteClusterService() {     return remoteClusterService. }
false;public;0;3;;public DiscoveryNode getLocalNode() {     return localNode. }
false;public;0;3;;public TaskManager getTaskManager() {     return taskManager. }
false;protected;3;3;;protected TaskManager createTaskManager(Settings settings, ThreadPool threadPool, Set<String> taskHeaders) {     return new TaskManager(settings, threadPool, taskHeaders). }
true;private;0;3;/**  * The executor service for this transport service.  *  * @return the executor service  */ ;/**  * The executor service for this transport service.  *  * @return the executor service  */ private ExecutorService getExecutorService() {     return threadPool.generic(). }
false;;1;3;;void setTracerLogInclude(List<String> tracerLogInclude) {     this.tracerLogInclude = tracerLogInclude.toArray(Strings.EMPTY_ARRAY). }
false;;1;3;;void setTracerLogExclude(List<String> tracerLogExclude) {     this.tracerLogExclude = tracerLogExclude.toArray(Strings.EMPTY_ARRAY). }
false;protected;0;18;;@Override protected void doStart() {     transport.addMessageListener(this).     connectionManager.addListener(this).     transport.start().     if (transport.boundAddress() != null && logger.isInfoEnabled()) {         logger.info("{}", transport.boundAddress()).         for (Map.Entry<String, BoundTransportAddress> entry : transport.profileBoundAddresses().entrySet()) {             logger.info("profile [{}]: {}", entry.getKey(), entry.getValue()).         }     }     localNode = localNodeFactory.apply(transport.boundAddress()).     if (connectToRemoteCluster) {         // here we start to connect to the remote clusters         remoteClusterService.initializeRemoteClusters().     } }
false;public;1;9;;@Override public void onRejection(Exception e) {     // if we get rejected during node shutdown we don't wanna bubble it up     logger.debug(() -> new ParameterizedMessage("failed to notify response handler on rejection, action: {}", holderToNotify.action()), e). }
false;public;1;8;;@Override public void onFailure(Exception e) {     logger.warn(() -> new ParameterizedMessage("failed to notify response handler on exception, action: {}", holderToNotify.action()), e). }
false;public;0;5;;@Override public void doRun() {     TransportException ex = new TransportException("transport stopped, action: " + holderToNotify.action()).     holderToNotify.handler().handleException(ex). }
false;protected;0;39;;@Override protected void doStop() {     try {         IOUtils.close(connectionManager, remoteClusterService, transport::stop).     } catch (IOException e) {         throw new UncheckedIOException(e).     } finally {         // make sure to clean any leftover on going handles         for (final Transport.ResponseContext holderToNotify : responseHandlers.prune(h -> true)) {             // callback that an exception happened, but on a different thread since we don't             // want handlers to worry about stack overflows             getExecutorService().execute(new AbstractRunnable() {                  @Override                 public void onRejection(Exception e) {                     // if we get rejected during node shutdown we don't wanna bubble it up                     logger.debug(() -> new ParameterizedMessage("failed to notify response handler on rejection, action: {}", holderToNotify.action()), e).                 }                  @Override                 public void onFailure(Exception e) {                     logger.warn(() -> new ParameterizedMessage("failed to notify response handler on exception, action: {}", holderToNotify.action()), e).                 }                  @Override                 public void doRun() {                     TransportException ex = new TransportException("transport stopped, action: " + holderToNotify.action()).                     holderToNotify.handler().handleException(ex).                 }             }).         }     } }
false;protected;0;4;;@Override protected void doClose() throws IOException {     transport.close(). }
true;public,final;0;3;/**  * start accepting incoming requests.  * when the transport layer starts up it will block any incoming requests until  * this method is called  */ ;/**  * start accepting incoming requests.  * when the transport layer starts up it will block any incoming requests until  * this method is called  */ public final void acceptIncomingRequests() {     blockIncomingRequestsLatch.countDown(). }
false;public;0;7;;public TransportInfo info() {     BoundTransportAddress boundTransportAddress = boundAddress().     if (boundTransportAddress == null) {         return null.     }     return new TransportInfo(boundTransportAddress, transport.profileBoundAddresses()). }
false;public;0;3;;public TransportStats stats() {     return transport.getStats(). }
false;public;0;3;;public BoundTransportAddress boundAddress() {     return transport.boundAddress(). }
false;public;0;3;;public List<String> getLocalAddresses() {     return transport.getLocalAddresses(). }
true;public;1;3;/**  * Returns <code>true</code> iff the given node is already connected.  */ ;/**  * Returns <code>true</code> iff the given node is already connected.  */ public boolean nodeConnected(DiscoveryNode node) {     return isLocalNode(node) || connectionManager.nodeConnected(node). }
true;public;1;3;/**  * Connect to the specified node with the default connection profile  *  * @param node the node to connect to  */ ;/**  * Connect to the specified node with the default connection profile  *  * @param node the node to connect to  */ public void connectToNode(DiscoveryNode node) throws ConnectTransportException {     connectToNode(node, null). }
true;public;2;6;/**  * Connect to the specified node with the given connection profile  *  * @param node the node to connect to  * @param connectionProfile the connection profile to use when connecting to this node  */ ;/**  * Connect to the specified node with the given connection profile  *  * @param node the node to connect to  * @param connectionProfile the connection profile to use when connecting to this node  */ public void connectToNode(final DiscoveryNode node, ConnectionProfile connectionProfile) {     if (isLocalNode(node)) {         return.     }     connectionManager.connectToNode(node, connectionProfile, connectionValidator(node)). }
false;public;1;10;;public CheckedBiConsumer<Transport.Connection, ConnectionProfile, IOException> connectionValidator(DiscoveryNode node) {     return (newConnection, actualProfile) -> {         // We don't validate cluster names to allow for CCS connections.         final DiscoveryNode remote = handshake(newConnection, actualProfile.getHandshakeTimeout().millis(), cn -> true).discoveryNode.         if (validateConnections && node.equals(remote) == false) {             throw new ConnectTransportException(node, "handshake failed. unexpected remote node " + remote).         }     }. }
true;public;2;7;/**  * Establishes and returns a new connection to the given node. The connection is NOT maintained by this service, it's the callers  * responsibility to close the connection once it goes out of scope.  * @param node the node to connect to  * @param connectionProfile the connection profile to use  */ ;/**  * Establishes and returns a new connection to the given node. The connection is NOT maintained by this service, it's the callers  * responsibility to close the connection once it goes out of scope.  * @param node the node to connect to  * @param connectionProfile the connection profile to use  */ public Transport.Connection openConnection(final DiscoveryNode node, ConnectionProfile connectionProfile) throws IOException {     if (isLocalNode(node)) {         return localNodeConnection.     } else {         return connectionManager.openConnection(node, connectionProfile).     } }
true;public;2;5;/**  * Executes a high-level handshake using the given connection  * and returns the discovery node of the node the connection  * was established with. The handshake will fail if the cluster  * name on the target node mismatches the local cluster name.  *  * @param connection       the connection to a specific node  * @param handshakeTimeout handshake timeout  * @return the connected node  * @throws ConnectTransportException if the connection failed  * @throws IllegalStateException if the handshake failed  */ ;/**  * Executes a high-level handshake using the given connection  * and returns the discovery node of the node the connection  * was established with. The handshake will fail if the cluster  * name on the target node mismatches the local cluster name.  *  * @param connection       the connection to a specific node  * @param handshakeTimeout handshake timeout  * @return the connected node  * @throws ConnectTransportException if the connection failed  * @throws IllegalStateException if the handshake failed  */ public DiscoveryNode handshake(final Transport.Connection connection, final long handshakeTimeout) throws ConnectTransportException {     return handshake(connection, handshakeTimeout, clusterName::equals).discoveryNode. }
false;public;1;4;;@Override public HandshakeResponse read(StreamInput in) throws IOException {     return new HandshakeResponse(in). }
true;public;3;28;/**  * Executes a high-level handshake using the given connection  * and returns the discovery node of the node the connection  * was established with. The handshake will fail if the cluster  * name on the target node doesn't match the local cluster name.  *  * @param connection       the connection to a specific node  * @param handshakeTimeout handshake timeout  * @param clusterNamePredicate cluster name validation predicate  * @return the handshake response  * @throws IllegalStateException if the handshake failed  */ ;/**  * Executes a high-level handshake using the given connection  * and returns the discovery node of the node the connection  * was established with. The handshake will fail if the cluster  * name on the target node doesn't match the local cluster name.  *  * @param connection       the connection to a specific node  * @param handshakeTimeout handshake timeout  * @param clusterNamePredicate cluster name validation predicate  * @return the handshake response  * @throws IllegalStateException if the handshake failed  */ public HandshakeResponse handshake(final Transport.Connection connection, final long handshakeTimeout, Predicate<ClusterName> clusterNamePredicate) {     final HandshakeResponse response.     final DiscoveryNode node = connection.getNode().     try {         PlainTransportFuture<HandshakeResponse> futureHandler = new PlainTransportFuture<>(new FutureTransportResponseHandler<HandshakeResponse>() {              @Override             public HandshakeResponse read(StreamInput in) throws IOException {                 return new HandshakeResponse(in).             }         }).         sendRequest(connection, HANDSHAKE_ACTION_NAME, HandshakeRequest.INSTANCE, TransportRequestOptions.builder().withTimeout(handshakeTimeout).build(), futureHandler).         response = futureHandler.txGet().     } catch (Exception e) {         throw new IllegalStateException("handshake failed with " + node, e).     }     if (!clusterNamePredicate.test(response.clusterName)) {         throw new IllegalStateException("handshake failed, mismatched cluster name [" + response.clusterName + "] - " + node).     } else if (response.version.isCompatible(localNode.getVersion()) == false) {         throw new IllegalStateException("handshake failed, incompatible version [" + response.version + "] - " + node).     }     return response. }
false;public;0;3;;public ConnectionManager getConnectionManager() {     return connectionManager. }
false;public;1;7;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeOptionalWriteable(discoveryNode).     clusterName.writeTo(out).     Version.writeVersion(version, out). }
false;public;0;3;;public DiscoveryNode getDiscoveryNode() {     return discoveryNode. }
false;public;0;3;;public ClusterName getClusterName() {     return clusterName. }
false;public;1;6;;public void disconnectFromNode(DiscoveryNode node) {     if (isLocalNode(node)) {         return.     }     connectionManager.disconnectFromNode(node). }
false;public;1;3;;public void addConnectionListener(TransportConnectionListener listener) {     connectionManager.addListener(listener). }
false;public;1;3;;public void removeConnectionListener(TransportConnectionListener listener) {     connectionManager.removeListener(listener). }
false;public;4;4;;public <T extends TransportResponse> TransportFuture<T> submitRequest(DiscoveryNode node, String action, TransportRequest request, TransportResponseHandler<T> handler) throws TransportException {     return submitRequest(node, action, request, TransportRequestOptions.EMPTY, handler). }
false;public;5;13;;public <T extends TransportResponse> TransportFuture<T> submitRequest(DiscoveryNode node, String action, TransportRequest request, TransportRequestOptions options, TransportResponseHandler<T> handler) throws TransportException {     PlainTransportFuture<T> futureHandler = new PlainTransportFuture<>(handler).     try {         Transport.Connection connection = getConnection(node).         sendRequest(connection, action, request, options, futureHandler).     } catch (NodeNotConnectedException ex) {         // the caller might not handle this so we invoke the handler         futureHandler.handleException(ex).     }     return futureHandler. }
false;public;4;11;;public <T extends TransportResponse> void sendRequest(final DiscoveryNode node, final String action, final TransportRequest request, final TransportResponseHandler<T> handler) {     try {         Transport.Connection connection = getConnection(node).         sendRequest(connection, action, request, TransportRequestOptions.EMPTY, handler).     } catch (NodeNotConnectedException ex) {         // the caller might not handle this so we invoke the handler         handler.handleException(ex).     } }
false;public,final;5;12;;public final <T extends TransportResponse> void sendRequest(final DiscoveryNode node, final String action, final TransportRequest request, final TransportRequestOptions options, TransportResponseHandler<T> handler) {     try {         Transport.Connection connection = getConnection(node).         sendRequest(connection, action, request, options, handler).     } catch (NodeNotConnectedException ex) {         // the caller might not handle this so we invoke the handler         handler.handleException(ex).     } }
false;public,final;5;11;;public final <T extends TransportResponse> void sendRequest(final Transport.Connection connection, final String action, final TransportRequest request, final TransportRequestOptions options, TransportResponseHandler<T> handler) {     try {         asyncSender.sendRequest(connection, action, request, options, handler).     } catch (NodeNotConnectedException ex) {         // the caller might not handle this so we invoke the handler         handler.handleException(ex).     } }
true;public;1;7;/**  * Returns either a real transport connection or a local node connection if we are using the local node optimization.  * @throws NodeNotConnectedException if the given node is not connected  */ ;/**  * Returns either a real transport connection or a local node connection if we are using the local node optimization.  * @throws NodeNotConnectedException if the given node is not connected  */ public Transport.Connection getConnection(DiscoveryNode node) {     if (isLocalNode(node)) {         return localNodeConnection.     } else {         return connectionManager.getConnection(node).     } }
false;public,final;6;12;;public final <T extends TransportResponse> void sendChildRequest(final DiscoveryNode node, final String action, final TransportRequest request, final Task parentTask, final TransportRequestOptions options, final TransportResponseHandler<T> handler) {     try {         Transport.Connection connection = getConnection(node).         sendChildRequest(connection, action, request, parentTask, options, handler).     } catch (NodeNotConnectedException ex) {         // the caller might not handle this so we invoke the handler         handler.handleException(ex).     } }
false;public;5;5;;public <T extends TransportResponse> void sendChildRequest(final Transport.Connection connection, final String action, final TransportRequest request, final Task parentTask, final TransportResponseHandler<T> handler) {     sendChildRequest(connection, action, request, parentTask, TransportRequestOptions.EMPTY, handler). }
false;public;6;16;;public <T extends TransportResponse> void sendChildRequest(final Transport.Connection connection, final String action, final TransportRequest request, final Task parentTask, final TransportRequestOptions options, final TransportResponseHandler<T> handler) {     request.setParentTask(localNode.getId(), parentTask.getId()).     try {         sendRequest(connection, action, request, options, handler).     } catch (TaskCancelledException ex) {         // The parent task is already cancelled - just fail the request         handler.handleException(new TransportException(ex)).     } catch (NodeNotConnectedException ex) {         // the caller might not handle this so we invoke the handler         handler.handleException(ex).     } }
false;public;1;9;;@Override public void onRejection(Exception e) {     // if we get rejected during node shutdown we don't wanna bubble it up     logger.debug(() -> new ParameterizedMessage("failed to notify response handler on rejection, action: {}", contextToNotify.action()), e). }
false;public;1;8;;@Override public void onFailure(Exception e) {     logger.warn(() -> new ParameterizedMessage("failed to notify response handler on exception, action: {}", contextToNotify.action()), e). }
false;protected;0;4;;@Override protected void doRun() throws Exception {     contextToNotify.handler().handleException(sendRequestException). }
false;private;5;71;;private <T extends TransportResponse> void sendRequestInternal(final Transport.Connection connection, final String action, final TransportRequest request, final TransportRequestOptions options, TransportResponseHandler<T> handler) {     if (connection == null) {         throw new IllegalStateException("can't send request to a null connection").     }     DiscoveryNode node = connection.getNode().     Supplier<ThreadContext.StoredContext> storedContextSupplier = threadPool.getThreadContext().newRestorableContext(true).     ContextRestoreResponseHandler<T> responseHandler = new ContextRestoreResponseHandler<>(storedContextSupplier, handler).     // TODO we can probably fold this entire request ID dance into connection.sendReqeust but it will be a bigger refactoring     final long requestId = responseHandlers.add(new Transport.ResponseContext<>(responseHandler, connection, action)).     final TimeoutHandler timeoutHandler.     if (options.timeout() != null) {         timeoutHandler = new TimeoutHandler(requestId, connection.getNode(), action).         responseHandler.setTimeoutHandler(timeoutHandler).     } else {         timeoutHandler = null.     }     try {         if (lifecycle.stoppedOrClosed()) {             // the caller. It will only notify if the toStop code hasn't done the work yet.             throw new TransportException("TransportService is closed stopped can't send request").         }         if (timeoutHandler != null) {             assert options.timeout() != null.             timeoutHandler.scheduleTimeout(options.timeout()).         }         // local node optimization happens upstream         connection.sendRequest(requestId, action, request, options).     } catch (final Exception e) {         // usually happen either because we failed to connect to the node         // or because we failed serializing the message         final Transport.ResponseContext contextToNotify = responseHandlers.remove(requestId).         // If holderToNotify == null then handler has already been taken care of.         if (contextToNotify != null) {             if (timeoutHandler != null) {                 timeoutHandler.cancel().             }             // callback that an exception happened, but on a different thread since we don't             // want handlers to worry about stack overflows             final SendRequestTransportException sendRequestException = new SendRequestTransportException(node, action, e).             threadPool.executor(ThreadPool.Names.GENERIC).execute(new AbstractRunnable() {                  @Override                 public void onRejection(Exception e) {                     // if we get rejected during node shutdown we don't wanna bubble it up                     logger.debug(() -> new ParameterizedMessage("failed to notify response handler on rejection, action: {}", contextToNotify.action()), e).                 }                  @Override                 public void onFailure(Exception e) {                     logger.warn(() -> new ParameterizedMessage("failed to notify response handler on exception, action: {}", contextToNotify.action()), e).                 }                  @Override                 protected void doRun() throws Exception {                     contextToNotify.handler().handleException(sendRequestException).                 }             }).         } else {             logger.debug("Exception while sending request, handler likely already notified due to timeout", e).         }     } }
false;protected;0;5;;@Override protected void doRun() throws Exception {     // noinspection unchecked     reg.processMessageReceived(request, channel). }
false;public;0;4;;@Override public boolean isForceExecution() {     return reg.isForceExecution(). }
false;public;1;10;;@Override public void onFailure(Exception e) {     try {         channel.sendResponse(e).     } catch (Exception inner) {         inner.addSuppressed(e).         logger.warn(() -> new ParameterizedMessage("failed to notify channel of error message for action [{}]", action), inner).     } }
false;public;0;4;;@Override public String toString() {     return "processing of [" + requestId + "][" + action + "]: " + request. }
false;private;4;55;;private void sendLocalRequest(long requestId, final String action, final TransportRequest request, TransportRequestOptions options) {     final DirectResponseChannel channel = new DirectResponseChannel(logger, localNode, action, requestId, this, threadPool).     try {         onRequestSent(localNode, requestId, action, request, options).         onRequestReceived(requestId, action).         final RequestHandlerRegistry reg = getRequestHandler(action).         if (reg == null) {             throw new ActionNotFoundTransportException("Action [" + action + "] not found").         }         final String executor = reg.getExecutor().         if (ThreadPool.Names.SAME.equals(executor)) {             // noinspection unchecked             reg.processMessageReceived(request, channel).         } else {             threadPool.executor(executor).execute(new AbstractRunnable() {                  @Override                 protected void doRun() throws Exception {                     // noinspection unchecked                     reg.processMessageReceived(request, channel).                 }                  @Override                 public boolean isForceExecution() {                     return reg.isForceExecution().                 }                  @Override                 public void onFailure(Exception e) {                     try {                         channel.sendResponse(e).                     } catch (Exception inner) {                         inner.addSuppressed(e).                         logger.warn(() -> new ParameterizedMessage("failed to notify channel of error message for action [{}]", action), inner).                     }                 }                  @Override                 public String toString() {                     return "processing of [" + requestId + "][" + action + "]: " + request.                 }             }).         }     } catch (Exception e) {         try {             channel.sendResponse(e).         } catch (Exception inner) {             inner.addSuppressed(e).             logger.warn(() -> new ParameterizedMessage("failed to notify channel of error message for action [{}]", action), inner).         }     } }
false;private;1;11;;private boolean shouldTraceAction(String action) {     if (tracerLogInclude.length > 0) {         if (Regex.simpleMatch(tracerLogInclude, action) == false) {             return false.         }     }     if (tracerLogExclude.length > 0) {         return !Regex.simpleMatch(tracerLogExclude, action).     }     return true. }
false;public;2;3;;public TransportAddress[] addressesFromString(String address, int perAddressLimit) throws UnknownHostException {     return transport.addressesFromString(address, perAddressLimit). }
false;private;1;8;;private void validateActionName(String actionName) {     // for it. Maybe start with a deprecation layer     if (isValidActionName(actionName) == false) {         logger.warn("invalid action name [" + actionName + "] must start with one of: " + TransportService.VALID_ACTION_PREFIXES).     } }
true;public,static;1;8;/**  * Returns <code>true</code> iff the action name starts with a valid prefix.  *  * @see #VALID_ACTION_PREFIXES  */ ;/**  * Returns <code>true</code> iff the action name starts with a valid prefix.  *  * @see #VALID_ACTION_PREFIXES  */ public static boolean isValidActionName(String actionName) {     for (String prefix : VALID_ACTION_PREFIXES) {         if (actionName.startsWith(prefix)) {             return true.         }     }     return false. }
true;public;4;8;/**  * Registers a new request handler  *  * @param action         The action the request handler is associated with  * @param requestFactory a callable to be used construct new instances for streaming  * @param executor       The executor the request handling will be executed on  * @param handler        The handler itself that implements the request handling  */ ;/**  * Registers a new request handler  *  * @param action         The action the request handler is associated with  * @param requestFactory a callable to be used construct new instances for streaming  * @param executor       The executor the request handling will be executed on  * @param handler        The handler itself that implements the request handling  */ public <Request extends TransportRequest> void registerRequestHandler(String action, Supplier<Request> requestFactory, String executor, TransportRequestHandler<Request> handler) {     validateActionName(action).     handler = interceptor.interceptHandler(action, executor, false, handler).     RequestHandlerRegistry<Request> reg = new RequestHandlerRegistry<>(action, Streamable.newWriteableReader(requestFactory), taskManager, handler, executor, false, true).     transport.registerRequestHandler(reg). }
true;public;4;9;/**  * Registers a new request handler  *  * @param action         The action the request handler is associated with  * @param requestReader  a callable to be used construct new instances for streaming  * @param executor       The executor the request handling will be executed on  * @param handler        The handler itself that implements the request handling  */ ;/**  * Registers a new request handler  *  * @param action         The action the request handler is associated with  * @param requestReader  a callable to be used construct new instances for streaming  * @param executor       The executor the request handling will be executed on  * @param handler        The handler itself that implements the request handling  */ public <Request extends TransportRequest> void registerRequestHandler(String action, String executor, Writeable.Reader<Request> requestReader, TransportRequestHandler<Request> handler) {     validateActionName(action).     handler = interceptor.interceptHandler(action, executor, false, handler).     RequestHandlerRegistry<Request> reg = new RequestHandlerRegistry<>(action, requestReader, taskManager, handler, executor, false, true).     transport.registerRequestHandler(reg). }
true;public;6;10;/**  * Registers a new request handler  *  * @param action                The action the request handler is associated with  * @param request               The request class that will be used to construct new instances for streaming  * @param executor              The executor the request handling will be executed on  * @param forceExecution        Force execution on the executor queue and never reject it  * @param canTripCircuitBreaker Check the request size and raise an exception in case the limit is breached.  * @param handler               The handler itself that implements the request handling  */ ;/**  * Registers a new request handler  *  * @param action                The action the request handler is associated with  * @param request               The request class that will be used to construct new instances for streaming  * @param executor              The executor the request handling will be executed on  * @param forceExecution        Force execution on the executor queue and never reject it  * @param canTripCircuitBreaker Check the request size and raise an exception in case the limit is breached.  * @param handler               The handler itself that implements the request handling  */ public <Request extends TransportRequest> void registerRequestHandler(String action, Supplier<Request> request, String executor, boolean forceExecution, boolean canTripCircuitBreaker, TransportRequestHandler<Request> handler) {     validateActionName(action).     handler = interceptor.interceptHandler(action, executor, forceExecution, handler).     RequestHandlerRegistry<Request> reg = new RequestHandlerRegistry<>(action, Streamable.newWriteableReader(request), taskManager, handler, executor, forceExecution, canTripCircuitBreaker).     transport.registerRequestHandler(reg). }
true;public;6;11;/**  * Registers a new request handler  *  * @param action                The action the request handler is associated with  * @param requestReader               The request class that will be used to construct new instances for streaming  * @param executor              The executor the request handling will be executed on  * @param forceExecution        Force execution on the executor queue and never reject it  * @param canTripCircuitBreaker Check the request size and raise an exception in case the limit is breached.  * @param handler               The handler itself that implements the request handling  */ ;/**  * Registers a new request handler  *  * @param action                The action the request handler is associated with  * @param requestReader               The request class that will be used to construct new instances for streaming  * @param executor              The executor the request handling will be executed on  * @param forceExecution        Force execution on the executor queue and never reject it  * @param canTripCircuitBreaker Check the request size and raise an exception in case the limit is breached.  * @param handler               The handler itself that implements the request handling  */ public <Request extends TransportRequest> void registerRequestHandler(String action, String executor, boolean forceExecution, boolean canTripCircuitBreaker, Writeable.Reader<Request> requestReader, TransportRequestHandler<Request> handler) {     validateActionName(action).     handler = interceptor.interceptHandler(action, executor, forceExecution, handler).     RequestHandlerRegistry<Request> reg = new RequestHandlerRegistry<>(action, requestReader, taskManager, handler, executor, forceExecution, canTripCircuitBreaker).     transport.registerRequestHandler(reg). }
true;public;5;6;/**  * called by the {@link Transport} implementation once a request has been sent  */ ;/**  * called by the {@link Transport} implementation once a request has been sent  */ public void onRequestSent(DiscoveryNode node, long requestId, String action, TransportRequest request, TransportRequestOptions options) {     if (traceEnabled() && shouldTraceAction(action)) {         traceRequestSent(node, requestId, action, options).     } }
false;protected;0;3;;protected boolean traceEnabled() {     return tracerLog.isTraceEnabled(). }
true;public;3;6;/**  * called by the {@link Transport} implementation once a response was sent to calling node  */ ;/**  * called by the {@link Transport} implementation once a response was sent to calling node  */ @Override public void onResponseSent(long requestId, String action, TransportResponse response) {     if (traceEnabled() && shouldTraceAction(action)) {         traceResponseSent(requestId, action).     } }
true;public;3;6;/**  * called by the {@link Transport} implementation after an exception was sent as a response to an incoming request  */ ;/**  * called by the {@link Transport} implementation after an exception was sent as a response to an incoming request  */ @Override public void onResponseSent(long requestId, String action, Exception e) {     if (traceEnabled() && shouldTraceAction(action)) {         traceResponseSent(requestId, action, e).     } }
false;protected;3;3;;protected void traceResponseSent(long requestId, String action, Exception e) {     tracerLog.trace(() -> new ParameterizedMessage("[{}][{}] sent error response", requestId, action), e). }
true;public;2;11;/**  * called by the {@link Transport} implementation when an incoming request arrives but before  * any parsing of it has happened (with the exception of the requestId and action)  */ ;/**  * called by the {@link Transport} implementation when an incoming request arrives but before  * any parsing of it has happened (with the exception of the requestId and action)  */ @Override public void onRequestReceived(long requestId, String action) {     try {         blockIncomingRequestsLatch.await().     } catch (InterruptedException e) {         logger.trace("interrupted while waiting for incoming requests block to be removed").     }     if (traceEnabled() && shouldTraceAction(action)) {         traceReceivedRequest(requestId, action).     } }
false;public;1;3;;public RequestHandlerRegistry<? extends TransportRequest> getRequestHandler(String action) {     return transport.getRequestHandler(action). }
false;public;2;8;;@Override public void onResponseReceived(long requestId, Transport.ResponseContext holder) {     if (holder == null) {         checkForTimeout(requestId).     } else if (traceEnabled() && shouldTraceAction(holder.action())) {         traceReceivedResponse(requestId, holder.connection().getNode(), holder.action()).     } }
false;private;1;29;;private void checkForTimeout(long requestId) {     // lets see if its in the timeout holder, but sync on mutex to make sure any ongoing timeout handling has finished     final DiscoveryNode sourceNode.     final String action.     assert responseHandlers.contains(requestId) == false.     TimeoutInfoHolder timeoutInfoHolder = timeoutInfoHandlers.remove(requestId).     if (timeoutInfoHolder != null) {         long time = threadPool.relativeTimeInMillis().         logger.warn("Received response for a request that has timed out, sent [{}ms] ago, timed out [{}ms] ago, " + "action [{}], node [{}], id [{}]", time - timeoutInfoHolder.sentTime(), time - timeoutInfoHolder.timeoutTime(), timeoutInfoHolder.action(), timeoutInfoHolder.node(), requestId).         action = timeoutInfoHolder.action().         sourceNode = timeoutInfoHolder.node().     } else {         logger.warn("Transport response handler not found of id [{}]", requestId).         action = null.         sourceNode = null.     }     // call tracer out of lock     if (traceEnabled() == false) {         return.     }     if (action == null) {         assert sourceNode == null.         traceUnresolvedResponse(requestId).     } else if (shouldTraceAction(action)) {         traceReceivedResponse(requestId, sourceNode, action).     } }
false;public;0;7;;@Override public void run() {     for (Transport.ResponseContext holderToNotify : pruned) {         holderToNotify.handler().handleException(new NodeDisconnectedException(connection.getNode(), holderToNotify.action())).     } }
false;public;0;4;;@Override public String toString() {     return "onConnectionClosed(" + connection.getNode() + ")". }
false;public;1;25;;@Override public void onConnectionClosed(Transport.Connection connection) {     try {         List<Transport.ResponseContext<? extends TransportResponse>> pruned = responseHandlers.prune(h -> h.connection().getCacheKey().equals(connection.getCacheKey())).         // callback that an exception happened, but on a different thread since we don't         // want handlers to worry about stack overflows         getExecutorService().execute(new Runnable() {              @Override             public void run() {                 for (Transport.ResponseContext holderToNotify : pruned) {                     holderToNotify.handler().handleException(new NodeDisconnectedException(connection.getNode(), holderToNotify.action())).                 }             }              @Override             public String toString() {                 return "onConnectionClosed(" + connection.getNode() + ")".             }         }).     } catch (EsRejectedExecutionException ex) {         logger.debug("Rejected execution on onConnectionClosed", ex).     } }
false;protected;2;3;;protected void traceReceivedRequest(long requestId, String action) {     tracerLog.trace("[{}][{}] received request", requestId, action). }
false;protected;2;3;;protected void traceResponseSent(long requestId, String action) {     tracerLog.trace("[{}][{}] sent response", requestId, action). }
false;protected;3;3;;protected void traceReceivedResponse(long requestId, DiscoveryNode sourceNode, String action) {     tracerLog.trace("[{}][{}] received response from [{}]", requestId, action, sourceNode). }
false;protected;1;3;;protected void traceUnresolvedResponse(long requestId) {     tracerLog.trace("[{}] received response but can't resolve it to a request", requestId). }
false;protected;4;3;;protected void traceRequestSent(DiscoveryNode node, long requestId, String action, TransportRequestOptions options) {     tracerLog.trace("[{}][{}] sent to [{}] (timeout: [{}])", requestId, action, node, options.timeout()). }
false;public;0;19;;@Override public void run() {     if (responseHandlers.contains(requestId)) {         long timeoutTime = threadPool.relativeTimeInMillis().         timeoutInfoHandlers.put(requestId, new TimeoutInfoHolder(node, action, sentTime, timeoutTime)).         // now that we have the information visible via timeoutInfoHandlers, we try to remove the request id         final Transport.ResponseContext holder = responseHandlers.remove(requestId).         if (holder != null) {             assert holder.action().equals(action).             assert holder.connection().getNode().equals(node).             holder.handler().handleException(new ReceiveTimeoutTransportException(holder.connection().getNode(), holder.action(), "request_id [" + requestId + "] timed out after [" + (timeoutTime - sentTime) + "ms]")).         } else {             // response was processed, remove timeout info.             timeoutInfoHandlers.remove(requestId).         }     } }
true;public;0;7;/**  * cancels timeout handling. this is a best effort only to avoid running it. remove the requestId from {@link #responseHandlers}  * to make sure this doesn't run.  */ ;/**  * cancels timeout handling. this is a best effort only to avoid running it. remove the requestId from {@link #responseHandlers}  * to make sure this doesn't run.  */ public void cancel() {     assert responseHandlers.contains(requestId) == false : "cancel must be called after the requestId [" + requestId + "] has been removed from clientHandlers".     if (cancellable != null) {         cancellable.cancel().     } }
false;public;0;4;;@Override public String toString() {     return "timeout handler for [" + requestId + "][" + action + "]". }
false;private;1;3;;private void scheduleTimeout(TimeValue timeout) {     this.cancellable = threadPool.schedule(this, timeout, ThreadPool.Names.GENERIC). }
false;public;0;3;;public DiscoveryNode node() {     return node. }
false;public;0;3;;public String action() {     return action. }
false;public;0;3;;public long sentTime() {     return sentTime. }
false;public;0;3;;public long timeoutTime() {     return timeoutTime. }
false;public;1;4;;@Override public T read(StreamInput in) throws IOException {     return delegate.read(in). }
false;public;1;9;;@Override public void handleResponse(T response) {     if (handler != null) {         handler.cancel().     }     try (ThreadContext.StoredContext ignore = contextSupplier.get()) {         delegate.handleResponse(response).     } }
false;public;1;9;;@Override public void handleException(TransportException exp) {     if (handler != null) {         handler.cancel().     }     try (ThreadContext.StoredContext ignore = contextSupplier.get()) {         delegate.handleException(exp).     } }
false;public;0;4;;@Override public String executor() {     return delegate.executor(). }
false;public;0;4;;@Override public String toString() {     return getClass().getName() + "/" + delegate.toString(). }
false;;1;3;;void setTimeoutHandler(TimeoutHandler handler) {     this.handler = handler. }
false;public;0;4;;@Override public String getProfileName() {     return DIRECT_RESPONSE_PROFILE. }
false;public;0;4;;@Override public void run() {     processResponse(handler, response). }
false;public;0;4;;@Override public String toString() {     return "delivery of response to [" + requestId + "][" + action + "]: " + response. }
false;public;1;24;;@Override public void sendResponse(TransportResponse response) throws IOException {     service.onResponseSent(requestId, action, response).     final TransportResponseHandler handler = service.responseHandlers.onResponseReceived(requestId, service).     // ignore if its null, the service logs it     if (handler != null) {         final String executor = handler.executor().         if (ThreadPool.Names.SAME.equals(executor)) {             processResponse(handler, response).         } else {             threadPool.executor(executor).execute(new Runnable() {                  @Override                 public void run() {                     processResponse(handler, response).                 }                  @Override                 public String toString() {                     return "delivery of response to [" + requestId + "][" + action + "]: " + response.                 }             }).         }     } }
false;protected;2;8;;@SuppressWarnings("unchecked") protected void processResponse(TransportResponseHandler handler, TransportResponse response) {     try {         handler.handleResponse(response).     } catch (Exception e) {         processException(handler, wrapInRemote(new ResponseHandlerFailureTransportException(e))).     } }
false;public;0;4;;@Override public void run() {     processException(handler, rtx). }
false;public;0;4;;@Override public String toString() {     return "delivery of failure response to [" + requestId + "][" + action + "]: " + exception. }
false;public;1;25;;@Override public void sendResponse(Exception exception) throws IOException {     service.onResponseSent(requestId, action, exception).     final TransportResponseHandler handler = service.responseHandlers.onResponseReceived(requestId, service).     // ignore if its null, the service logs it     if (handler != null) {         final RemoteTransportException rtx = wrapInRemote(exception).         final String executor = handler.executor().         if (ThreadPool.Names.SAME.equals(executor)) {             processException(handler, rtx).         } else {             threadPool.executor(handler.executor()).execute(new Runnable() {                  @Override                 public void run() {                     processException(handler, rtx).                 }                  @Override                 public String toString() {                     return "delivery of failure response to [" + requestId + "][" + action + "]: " + exception.                 }             }).         }     } }
false;protected;1;6;;protected RemoteTransportException wrapInRemote(Exception e) {     if (e instanceof RemoteTransportException) {         return (RemoteTransportException) e.     }     return new RemoteTransportException(localNode.getName(), localNode.getAddress(), action, e). }
false;protected;2;9;;protected void processException(final TransportResponseHandler handler, final RemoteTransportException rtx) {     try {         handler.handleException(rtx).     } catch (Exception e) {         logger.error(() -> new ParameterizedMessage("failed to handle exception for action [{}], handler [{}]", action, handler), e).     } }
false;public;0;4;;@Override public String getChannelType() {     return "direct". }
false;public;0;4;;@Override public Version getVersion() {     return localNode.getVersion(). }
true;public;0;3;/**  * Returns the internal thread pool  */ ;/**  * Returns the internal thread pool  */ public ThreadPool getThreadPool() {     return threadPool. }
false;private;1;3;;private boolean isLocalNode(DiscoveryNode discoveryNode) {     return Objects.requireNonNull(discoveryNode, "discovery node must not be null").equals(localNode). }
