commented;modifiers;parameterAmount;loc;comment;code
false;;1;17;;BytesReference serialize(BytesStreamOutput bytesStream) throws IOException {     storedContext.restore().     bytesStream.setVersion(version).     bytesStream.skip(TcpHeader.HEADER_SIZE).     // The compressible bytes stream will not close the underlying bytes stream     BytesReference reference.     try (CompressibleBytesOutputStream stream = new CompressibleBytesOutputStream(bytesStream, TransportStatus.isCompress(status))) {         stream.setVersion(version).         threadContext.writeTo(stream).         writeTo(stream).         reference = writeMessage(stream).     }     bytesStream.seek(0).     TcpHeader.writeHeader(bytesStream, requestId, status, version, reference.length() - TcpHeader.HEADER_SIZE).     return reference. }
false;private;1;25;;private BytesReference writeMessage(CompressibleBytesOutputStream stream) throws IOException {     final BytesReference zeroCopyBuffer.     if (message instanceof BytesTransportRequest) {         BytesTransportRequest bRequest = (BytesTransportRequest) message.         bRequest.writeThin(stream).         zeroCopyBuffer = bRequest.bytes.     } else if (message instanceof RemoteTransportException) {         stream.writeException((RemoteTransportException) message).         zeroCopyBuffer = BytesArray.EMPTY.     } else {         message.writeTo(stream).         zeroCopyBuffer = BytesArray.EMPTY.     }     // we have to call materializeBytes() here before accessing the bytes. A CompressibleBytesOutputStream     // might be implementing compression. And materializeBytes() ensures that some marker bytes (EOS marker)     // are written. Otherwise we barf on the decompressing end when we read past EOF on purpose in the     // #validateRequest method. this might be a problem in deflate after all but it's important to write     // the marker bytes.     final BytesReference message = stream.materializeBytes().     if (zeroCopyBuffer.length() == 0) {         return message.     } else {         return new CompositeBytesReference(message, zeroCopyBuffer).     } }
false;public;1;7;;@Override public void writeTo(StreamOutput out) throws IOException {     if (version.onOrAfter(Version.V_6_3_0)) {         out.writeStringArray(features).     }     out.writeString(action). }
false;private,static;3;12;;private static byte setStatus(boolean compress, boolean isHandshake, Writeable message) {     byte status = 0.     status = TransportStatus.setRequest(status).     if (compress && OutboundMessage.canCompress(message)) {         status = TransportStatus.setCompress(status).     }     if (isHandshake) {         status = TransportStatus.setHandshake(status).     }     return status. }
false;public;1;4;;@Override public void writeTo(StreamOutput out) throws IOException {     out.setFeatures(features). }
false;private,static;3;15;;private static byte setStatus(boolean compress, boolean isHandshake, Writeable message) {     byte status = 0.     status = TransportStatus.setResponse(status).     if (message instanceof RemoteTransportException) {         status = TransportStatus.setError(status).     }     if (compress) {         status = TransportStatus.setCompress(status).     }     if (isHandshake) {         status = TransportStatus.setHandshake(status).     }     return status. }
false;private,static;1;3;;private static boolean canCompress(Writeable message) {     return message instanceof BytesTransportRequest == false. }
