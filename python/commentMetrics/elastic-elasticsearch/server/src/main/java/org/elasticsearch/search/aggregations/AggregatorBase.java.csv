commented;modifiers;parameterAmount;loc;comment;code
false;;0;4;;void badState() {     throw new QueryPhaseExecutionException(AggregatorBase.this.context, "preCollection not called on new Aggregator before use", null). }
false;public;1;6;;@Override public LeafBucketCollector getLeafCollector(LeafReaderContext reader) {     badState().     assert false.     // unreachable but compiler does not agree     return null. }
false;public;0;4;;@Override public void preCollection() throws IOException {     badState(). }
false;public;0;4;;@Override public void postCollection() throws IOException {     badState(). }
false;public;0;5;;@Override public ScoreMode scoreMode() {     badState().     // unreachable     return ScoreMode.COMPLETE. }
true;protected;1;14;/**  * Increment or decrement the number of bytes that have been allocated to service  * this request and potentially trigger a {@link CircuitBreakingException}. The  * number of bytes allocated is automatically decremented with the circuit breaker  * service on closure of this aggregator.  * If memory has been returned, decrement it without tripping the breaker.  * For performance reasons subclasses should not call this millions of times  * each with small increments and instead batch up into larger allocations.  *  * @param bytes the number of bytes to register or negative to deregister the bytes  * @return the cumulative size in bytes allocated by this aggregator to service this request  */ ;/**  * Increment or decrement the number of bytes that have been allocated to service  * this request and potentially trigger a {@link CircuitBreakingException}. The  * number of bytes allocated is automatically decremented with the circuit breaker  * service on closure of this aggregator.  * If memory has been returned, decrement it without tripping the breaker.  * For performance reasons subclasses should not call this millions of times  * each with small increments and instead batch up into larger allocations.  *  * @param bytes the number of bytes to register or negative to deregister the bytes  * @return the cumulative size in bytes allocated by this aggregator to service this request  */ protected long addRequestCircuitBreakerBytes(long bytes) {     // Only use the potential to circuit break if bytes are being incremented     if (bytes > 0) {         this.breakerService.getBreaker(CircuitBreaker.REQUEST).addEstimateBytesAndMaybeBreak(bytes, "<agg [" + name + "]>").     } else {         this.breakerService.getBreaker(CircuitBreaker.REQUEST).addWithoutBreaking(bytes).     }     this.requestBytesUsed += bytes.     return requestBytesUsed. }
true;public;0;9;/**  * Most aggregators don't need scores, make sure to extend this method if  * your aggregator needs them.  */ ;/**  * Most aggregators don't need scores, make sure to extend this method if  * your aggregator needs them.  */ @Override public ScoreMode scoreMode() {     for (Aggregator agg : subAggregators) {         if (agg.scoreMode().needsScores()) {             return ScoreMode.COMPLETE.         }     }     return ScoreMode.COMPLETE_NO_SCORES. }
false;public;0;3;;public Map<String, Object> metaData() {     return this.metaData. }
false;public;0;3;;public List<PipelineAggregator> pipelineAggregators() {     return this.pipelineAggregators. }
true;protected,abstract;2;1;/**  * Get a {@link LeafBucketCollector} for the given ctx, which should  * delegate to the given collector.  */ ;/**  * Get a {@link LeafBucketCollector} for the given ctx, which should  * delegate to the given collector.  */ protected abstract LeafBucketCollector getLeafCollector(LeafReaderContext ctx, LeafBucketCollector sub) throws IOException.
false;public,final;1;6;;@Override public final LeafBucketCollector getLeafCollector(LeafReaderContext ctx) throws IOException {     preGetSubLeafCollectors().     final LeafBucketCollector sub = collectableSubAggregators.getLeafCollector(ctx).     return getLeafCollector(ctx, sub). }
true;protected;0;2;/**  * Can be overridden by aggregator implementations that like the perform an operation before the leaf collectors  * of children aggregators are instantiated for the next segment.  */ ;/**  * Can be overridden by aggregator implementations that like the perform an operation before the leaf collectors  * of children aggregators are instantiated for the next segment.  */ protected void preGetSubLeafCollectors() throws IOException { }
true;protected;0;2;/**  * Can be overridden by aggregator implementation to be called back when the collection phase starts.  */ ;/**  * Can be overridden by aggregator implementation to be called back when the collection phase starts.  */ protected void doPreCollection() throws IOException { }
false;public,final;0;7;;@Override public final void preCollection() throws IOException {     List<BucketCollector> collectors = Arrays.asList(subAggregators).     collectableSubAggregators = MultiBucketCollector.wrap(collectors).     doPreCollection().     collectableSubAggregators.preCollection(). }
true;public;0;4;/**  * @return  The name of the aggregation.  */ ;/**  * @return  The name of the aggregation.  */ @Override public String name() {     return name. }
true;public;0;4;/**  * @return  The parent aggregator of this aggregator. The addAggregation are hierarchical in the sense that some can  *          be composed out of others (more specifically, bucket addAggregation can define other addAggregation that will  *          be aggregated per bucket). This method returns the direct parent aggregator that contains this aggregator, or  *          {@code null} if there is none (meaning, this aggregator is a top level one)  */ ;/**  * @return  The parent aggregator of this aggregator. The addAggregation are hierarchical in the sense that some can  *          be composed out of others (more specifically, bucket addAggregation can define other addAggregation that will  *          be aggregated per bucket). This method returns the direct parent aggregator that contains this aggregator, or  *          {@code null} if there is none (meaning, this aggregator is a top level one)  */ @Override public Aggregator parent() {     return parent. }
false;public;0;3;;public Aggregator[] subAggregators() {     return subAggregators. }
false;public;1;10;;@Override public Aggregator subAggregator(String aggName) {     if (subAggregatorbyName == null) {         subAggregatorbyName = new HashMap<>(subAggregators.length).         for (int i = 0. i < subAggregators.length. i++) {             subAggregatorbyName.put(subAggregators[i].name(), subAggregators[i]).         }     }     return subAggregatorbyName.get(aggName). }
true;public;0;4;/**  * @return  The current aggregation context.  */ ;/**  * @return  The current aggregation context.  */ @Override public SearchContext context() {     return context. }
true;public,final;0;6;/**  * Called after collection of all document is done.  */ ;/**  * Called after collection of all document is done.  */ @Override public final void postCollection() throws IOException {     // post-collect this agg before subs to make it possible to buffer and then replay in postCollection()     doPostCollection().     collectableSubAggregators.postCollection(). }
true;public;0;8;/**  * Called upon release of the aggregator.  */ ;/**  * Called upon release of the aggregator.  */ @Override public void close() {     try {         doClose().     } finally {         this.breakerService.getBreaker(CircuitBreaker.REQUEST).addWithoutBreaking(-this.requestBytesUsed).     } }
true;protected;0;1;/**  * Release instance-specific data.  */ ;/**  * Release instance-specific data.  */ protected void doClose() { }
true;protected;0;2;/**  * Can be overridden by aggregator implementation to be called back when the collection phase ends.  */ ;/**  * Can be overridden by aggregator implementation to be called back when the collection phase ends.  */ protected void doPostCollection() throws IOException { }
false;protected,final;0;7;;protected final InternalAggregations buildEmptySubAggregations() {     List<InternalAggregation> aggs = new ArrayList<>().     for (Aggregator aggregator : subAggregators) {         aggs.add(aggregator.buildEmptyAggregation()).     }     return new InternalAggregations(aggs). }
false;public;0;4;;@Override public String toString() {     return name. }
