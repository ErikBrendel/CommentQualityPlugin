commented;modifiers;parameterAmount;loc;comment;code
false;private,static;1;31;;private static AutoExpandReplicas parse(String value) {     final int min.     final int max.     if (Booleans.isFalse(value)) {         return FALSE_INSTANCE.     }     final int dash = value.indexOf('-').     if (-1 == dash) {         throw new IllegalArgumentException("failed to parse [" + IndexMetaData.SETTING_AUTO_EXPAND_REPLICAS + "] from value: [" + value + "] at index " + dash).     }     final String sMin = value.substring(0, dash).     try {         min = Integer.parseInt(sMin).     } catch (NumberFormatException e) {         throw new IllegalArgumentException("failed to parse [" + IndexMetaData.SETTING_AUTO_EXPAND_REPLICAS + "] from value: [" + value + "] at index " + dash, e).     }     String sMax = value.substring(dash + 1).     if (sMax.equals(ALL_NODES_VALUE)) {         max = Integer.MAX_VALUE.     } else {         try {             max = Integer.parseInt(sMax).         } catch (NumberFormatException e) {             throw new IllegalArgumentException("failed to parse [" + IndexMetaData.SETTING_AUTO_EXPAND_REPLICAS + "] from value: [" + value + "] at index " + dash, e).         }     }     return new AutoExpandReplicas(min, max, true). }
false;;0;3;;int getMinReplicas() {     return minReplicas. }
false;;1;3;;int getMaxReplicas(int numDataNodes) {     return Math.min(maxReplicas, numDataNodes - 1). }
false;private;1;17;;private OptionalInt getDesiredNumberOfReplicas(int numDataNodes) {     if (enabled) {         final int min = getMinReplicas().         final int max = getMaxReplicas(numDataNodes).         int numberOfReplicas = numDataNodes - 1.         if (numberOfReplicas < min) {             numberOfReplicas = min.         } else if (numberOfReplicas > max) {             numberOfReplicas = max.         }         if (numberOfReplicas >= min && numberOfReplicas <= max) {             return OptionalInt.of(numberOfReplicas).         }     }     return OptionalInt.empty(). }
false;public;0;4;;@Override public String toString() {     return enabled ? minReplicas + "-" + maxReplicas : "false". }
true;public,static;2;18;/**  * Checks if the are replicas with the auto-expand feature that need to be adapted.  * Returns a map of updates, which maps the indices to be updated to the desired number of replicas.  * The map has the desired number of replicas as key and the indices to update as value, as this allows the result  * of this method to be directly applied to RoutingTable.Builder#updateNumberOfReplicas.  */ ;/**  * Checks if the are replicas with the auto-expand feature that need to be adapted.  * Returns a map of updates, which maps the indices to be updated to the desired number of replicas.  * The map has the desired number of replicas as key and the indices to update as value, as this allows the result  * of this method to be directly applied to RoutingTable.Builder#updateNumberOfReplicas.  */ public static Map<Integer, List<String>> getAutoExpandReplicaChanges(MetaData metaData, DiscoveryNodes discoveryNodes) {     // used for translating "all" to a number     final int dataNodeCount = discoveryNodes.getDataNodes().size().     Map<Integer, List<String>> nrReplicasChanged = new HashMap<>().     for (final IndexMetaData indexMetaData : metaData) {         if (indexMetaData.getState() != IndexMetaData.State.CLOSE) {             AutoExpandReplicas autoExpandReplicas = SETTING.get(indexMetaData.getSettings()).             autoExpandReplicas.getDesiredNumberOfReplicas(dataNodeCount).ifPresent(numberOfReplicas -> {                 if (numberOfReplicas != indexMetaData.getNumberOfReplicas()) {                     nrReplicasChanged.computeIfAbsent(numberOfReplicas, ArrayList::new).add(indexMetaData.getIndex().getName()).                 }             }).         }     }     return nrReplicasChanged. }
