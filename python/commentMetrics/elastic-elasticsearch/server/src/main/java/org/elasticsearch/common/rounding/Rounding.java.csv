# id;timestamp;commentText;codeText;commentWords;codeWords
Rounding -> TimeIntervalRounding -> private boolean isInDSTGap(long instantLocal);1524684173;Determine whether the local instant is a valid instant in the given_time zone. The logic for this is taken from_{@link DateTimeZone#convertLocalToUTC(long, boolean)} for the_`strict` mode case, but instead of throwing an_{@link IllegalInstantException}, which is costly, we want to return a_flag indicating that the value is illegal in that time zone.;private boolean isInDSTGap(long instantLocal) {_            if (timeZone.isFixed()) {_                return false__            }_            _            int offsetLocal = timeZone.getOffset(instantLocal)__            _            int offset = timeZone.getOffset(instantLocal - offsetLocal)__            _            if (offsetLocal != offset) {_                _                long nextLocal = timeZone.nextTransition(instantLocal - offsetLocal)__                if (nextLocal == (instantLocal - offsetLocal)) {_                    nextLocal = Long.MAX_VALUE__                }_                long nextAdjusted = timeZone.nextTransition(instantLocal - offset)__                if (nextAdjusted == (instantLocal - offset)) {_                    nextAdjusted = Long.MAX_VALUE__                }_                if (nextLocal != nextAdjusted) {_                    _                    return true__                }_            }_            return false__        };determine,whether,the,local,instant,is,a,valid,instant,in,the,given,time,zone,the,logic,for,this,is,taken,from,link,date,time,zone,convert,local,to,utc,long,boolean,for,the,strict,mode,case,but,instead,of,throwing,an,link,illegal,instant,exception,which,is,costly,we,want,to,return,a,flag,indicating,that,the,value,is,illegal,in,that,time,zone;private,boolean,is,in,dstgap,long,instant,local,if,time,zone,is,fixed,return,false,int,offset,local,time,zone,get,offset,instant,local,int,offset,time,zone,get,offset,instant,local,offset,local,if,offset,local,offset,long,next,local,time,zone,next,transition,instant,local,offset,local,if,next,local,instant,local,offset,local,next,local,long,long,next,adjusted,time,zone,next,transition,instant,local,offset,if,next,adjusted,instant,local,offset,next,adjusted,long,if,next,local,next,adjusted,return,true,return,false
Rounding -> TimeIntervalRounding -> private boolean isInDSTGap(long instantLocal);1534248446;Determine whether the local instant is a valid instant in the given_time zone. The logic for this is taken from_{@link DateTimeZone#convertLocalToUTC(long, boolean)} for the_`strict` mode case, but instead of throwing an_{@link IllegalInstantException}, which is costly, we want to return a_flag indicating that the value is illegal in that time zone.;private boolean isInDSTGap(long instantLocal) {_            if (timeZone.isFixed()) {_                return false__            }_            _            int offsetLocal = timeZone.getOffset(instantLocal)__            _            int offset = timeZone.getOffset(instantLocal - offsetLocal)__            _            if (offsetLocal != offset) {_                _                long nextLocal = timeZone.nextTransition(instantLocal - offsetLocal)__                if (nextLocal == (instantLocal - offsetLocal)) {_                    nextLocal = Long.MAX_VALUE__                }_                long nextAdjusted = timeZone.nextTransition(instantLocal - offset)__                if (nextAdjusted == (instantLocal - offset)) {_                    nextAdjusted = Long.MAX_VALUE__                }_                if (nextLocal != nextAdjusted) {_                    _                    return true__                }_            }_            return false__        };determine,whether,the,local,instant,is,a,valid,instant,in,the,given,time,zone,the,logic,for,this,is,taken,from,link,date,time,zone,convert,local,to,utc,long,boolean,for,the,strict,mode,case,but,instead,of,throwing,an,link,illegal,instant,exception,which,is,costly,we,want,to,return,a,flag,indicating,that,the,value,is,illegal,in,that,time,zone;private,boolean,is,in,dstgap,long,instant,local,if,time,zone,is,fixed,return,false,int,offset,local,time,zone,get,offset,instant,local,int,offset,time,zone,get,offset,instant,local,offset,local,if,offset,local,offset,long,next,local,time,zone,next,transition,instant,local,offset,local,if,next,local,instant,local,offset,local,next,local,long,long,next,adjusted,time,zone,next,transition,instant,local,offset,if,next,adjusted,instant,local,offset,next,adjusted,long,if,next,local,next,adjusted,return,true,return,false
Rounding -> TimeIntervalRounding -> private boolean isInDSTGap(long instantLocal);1537806831;Determine whether the local instant is a valid instant in the given_time zone. The logic for this is taken from_{@link DateTimeZone#convertLocalToUTC(long, boolean)} for the_`strict` mode case, but instead of throwing an_{@link IllegalInstantException}, which is costly, we want to return a_flag indicating that the value is illegal in that time zone.;private boolean isInDSTGap(long instantLocal) {_            if (timeZone.isFixed()) {_                return false__            }_            _            int offsetLocal = timeZone.getOffset(instantLocal)__            _            int offset = timeZone.getOffset(instantLocal - offsetLocal)__            _            if (offsetLocal != offset) {_                _                long nextLocal = timeZone.nextTransition(instantLocal - offsetLocal)__                if (nextLocal == (instantLocal - offsetLocal)) {_                    nextLocal = Long.MAX_VALUE__                }_                long nextAdjusted = timeZone.nextTransition(instantLocal - offset)__                if (nextAdjusted == (instantLocal - offset)) {_                    nextAdjusted = Long.MAX_VALUE__                }_                if (nextLocal != nextAdjusted) {_                    _                    return true__                }_            }_            return false__        };determine,whether,the,local,instant,is,a,valid,instant,in,the,given,time,zone,the,logic,for,this,is,taken,from,link,date,time,zone,convert,local,to,utc,long,boolean,for,the,strict,mode,case,but,instead,of,throwing,an,link,illegal,instant,exception,which,is,costly,we,want,to,return,a,flag,indicating,that,the,value,is,illegal,in,that,time,zone;private,boolean,is,in,dstgap,long,instant,local,if,time,zone,is,fixed,return,false,int,offset,local,time,zone,get,offset,instant,local,int,offset,time,zone,get,offset,instant,local,offset,local,if,offset,local,offset,long,next,local,time,zone,next,transition,instant,local,offset,local,if,next,local,instant,local,offset,local,next,local,long,long,next,adjusted,time,zone,next,transition,instant,local,offset,if,next,adjusted,instant,local,offset,next,adjusted,long,if,next,local,next,adjusted,return,true,return,false
Rounding -> TimeUnitRounding -> private long previousTransition(long utcMillis);1524684173;@return The latest timestamp T which is strictly before utcMillis_and such that timeZone.getOffset(T) != timeZone.getOffset(utcMillis)._If there is no such T, returns Long.MAX_VALUE.;private long previousTransition(long utcMillis) {_            final int offsetAtInputTime = timeZone.getOffset(utcMillis)__            do {_                _                __                long previousTransition = timeZone.previousTransition(utcMillis)__                if (previousTransition == utcMillis) {_                    _                    return Long.MAX_VALUE__                }_                assert previousTransition < utcMillis_ _                utcMillis = previousTransition__            } while (timeZone.getOffset(utcMillis) == offsetAtInputTime)___            return utcMillis__        };return,the,latest,timestamp,t,which,is,strictly,before,utc,millis,and,such,that,time,zone,get,offset,t,time,zone,get,offset,utc,millis,if,there,is,no,such,t,returns,long;private,long,previous,transition,long,utc,millis,final,int,offset,at,input,time,time,zone,get,offset,utc,millis,do,long,previous,transition,time,zone,previous,transition,utc,millis,if,previous,transition,utc,millis,return,long,assert,previous,transition,utc,millis,utc,millis,previous,transition,while,time,zone,get,offset,utc,millis,offset,at,input,time,return,utc,millis
Rounding -> TimeUnitRounding -> private long previousTransition(long utcMillis);1534248446;@return The latest timestamp T which is strictly before utcMillis_and such that timeZone.getOffset(T) != timeZone.getOffset(utcMillis)._If there is no such T, returns Long.MAX_VALUE.;private long previousTransition(long utcMillis) {_            final int offsetAtInputTime = timeZone.getOffset(utcMillis)__            do {_                _                __                long previousTransition = timeZone.previousTransition(utcMillis)__                if (previousTransition == utcMillis) {_                    _                    return Long.MAX_VALUE__                }_                assert previousTransition < utcMillis_ _                utcMillis = previousTransition__            } while (timeZone.getOffset(utcMillis) == offsetAtInputTime)___            return utcMillis__        };return,the,latest,timestamp,t,which,is,strictly,before,utc,millis,and,such,that,time,zone,get,offset,t,time,zone,get,offset,utc,millis,if,there,is,no,such,t,returns,long;private,long,previous,transition,long,utc,millis,final,int,offset,at,input,time,time,zone,get,offset,utc,millis,do,long,previous,transition,time,zone,previous,transition,utc,millis,if,previous,transition,utc,millis,return,long,assert,previous,transition,utc,millis,utc,millis,previous,transition,while,time,zone,get,offset,utc,millis,offset,at,input,time,return,utc,millis
Rounding -> TimeUnitRounding -> private long previousTransition(long utcMillis);1537806831;@return The latest timestamp T which is strictly before utcMillis_and such that timeZone.getOffset(T) != timeZone.getOffset(utcMillis)._If there is no such T, returns Long.MAX_VALUE.;private long previousTransition(long utcMillis) {_            final int offsetAtInputTime = timeZone.getOffset(utcMillis)__            do {_                _                __                long previousTransition = timeZone.previousTransition(utcMillis)__                if (previousTransition == utcMillis) {_                    _                    return Long.MAX_VALUE__                }_                assert previousTransition < utcMillis_ _                utcMillis = previousTransition__            } while (timeZone.getOffset(utcMillis) == offsetAtInputTime)___            return utcMillis__        };return,the,latest,timestamp,t,which,is,strictly,before,utc,millis,and,such,that,time,zone,get,offset,t,time,zone,get,offset,utc,millis,if,there,is,no,such,t,returns,long;private,long,previous,transition,long,utc,millis,final,int,offset,at,input,time,time,zone,get,offset,utc,millis,do,long,previous,transition,time,zone,previous,transition,utc,millis,if,previous,transition,utc,millis,return,long,assert,previous,transition,utc,millis,utc,millis,previous,transition,while,time,zone,get,offset,utc,millis,offset,at,input,time,return,utc,millis
Rounding -> public abstract long nextRoundingValue(long value)_;1524684173;Given the rounded value (which was potentially generated by {@link #round(long)}, returns the next rounding value. For example, with_interval based rounding, if the interval is 3, {@code nextRoundValue(6) = 9 }.__@param value The current rounding value_@return      The next rounding value_;public abstract long nextRoundingValue(long value)_;given,the,rounded,value,which,was,potentially,generated,by,link,round,long,returns,the,next,rounding,value,for,example,with,interval,based,rounding,if,the,interval,is,3,code,next,round,value,6,9,param,value,the,current,rounding,value,return,the,next,rounding,value;public,abstract,long,next,rounding,value,long,value
Rounding -> public abstract long nextRoundingValue(long value)_;1534248446;Given the rounded value (which was potentially generated by {@link #round(long)}, returns the next rounding value. For example, with_interval based rounding, if the interval is 3, {@code nextRoundValue(6) = 9 }.__@param value The current rounding value_@return      The next rounding value_;public abstract long nextRoundingValue(long value)_;given,the,rounded,value,which,was,potentially,generated,by,link,round,long,returns,the,next,rounding,value,for,example,with,interval,based,rounding,if,the,interval,is,3,code,next,round,value,6,9,param,value,the,current,rounding,value,return,the,next,rounding,value;public,abstract,long,next,rounding,value,long,value
Rounding -> public abstract long nextRoundingValue(long value)_;1537806831;Given the rounded value (which was potentially generated by {@link #round(long)}, returns the next rounding value. For example, with_interval based rounding, if the interval is 3, {@code nextRoundValue(6) = 9 }.__@param value The current rounding value_@return      The next rounding value_;public abstract long nextRoundingValue(long value)_;given,the,rounded,value,which,was,potentially,generated,by,link,round,long,returns,the,next,rounding,value,for,example,with,interval,based,rounding,if,the,interval,is,3,code,next,round,value,6,9,param,value,the,current,rounding,value,return,the,next,rounding,value;public,abstract,long,next,rounding,value,long,value
Rounding -> public abstract long round(long value)_;1524684173;Rounds the given value.;public abstract long round(long value)_;rounds,the,given,value;public,abstract,long,round,long,value
Rounding -> public abstract long round(long value)_;1534248446;Rounds the given value.;public abstract long round(long value)_;rounds,the,given,value;public,abstract,long,round,long,value
Rounding -> public abstract long round(long value)_;1537806831;Rounds the given value.;public abstract long round(long value)_;rounds,the,given,value;public,abstract,long,round,long,value
