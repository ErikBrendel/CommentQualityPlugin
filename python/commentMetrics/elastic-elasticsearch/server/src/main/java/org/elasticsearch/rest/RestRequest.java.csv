commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public boolean isContentConsumed() {     return contentConsumed. }
true;public,static;3;5;/**  * Creates a new REST request. This method will throw {@link BadParameterException} if the path cannot be  * decoded  *  * @param xContentRegistry the content registry  * @param httpRequest      the http request  * @param httpChannel      the http channel  * @throws BadParameterException      if the parameters can not be decoded  * @throws ContentTypeHeaderException if the Content-Type header can not be parsed  */ ;/**  * Creates a new REST request. This method will throw {@link BadParameterException} if the path cannot be  * decoded  *  * @param xContentRegistry the content registry  * @param httpRequest      the http request  * @param httpChannel      the http channel  * @throws BadParameterException      if the parameters can not be decoded  * @throws ContentTypeHeaderException if the Content-Type header can not be parsed  */ public static RestRequest request(NamedXContentRegistry xContentRegistry, HttpRequest httpRequest, HttpChannel httpChannel) {     Map<String, String> params = params(httpRequest.uri()).     String path = path(httpRequest.uri()).     return new RestRequest(xContentRegistry, params, path, httpRequest.getHeaders(), httpRequest, httpChannel). }
false;private,static;1;12;;private static Map<String, String> params(final String uri) {     final Map<String, String> params = new HashMap<>().     int index = uri.indexOf('?').     if (index >= 0) {         try {             RestUtils.decodeQueryString(uri, index + 1, params).         } catch (final IllegalArgumentException e) {             throw new BadParameterException(e).         }     }     return params. }
false;private,static;1;8;;private static String path(final String uri) {     final int index = uri.indexOf('?').     if (index >= 0) {         return uri.substring(0, index).     } else {         return uri.     } }
true;public,static;3;5;/**  * Creates a new REST request. The path is not decoded so this constructor will not throw a  * {@link BadParameterException}.  *  * @param xContentRegistry the content registry  * @param httpRequest      the http request  * @param httpChannel      the http channel  * @throws ContentTypeHeaderException if the Content-Type header can not be parsed  */ ;/**  * Creates a new REST request. The path is not decoded so this constructor will not throw a  * {@link BadParameterException}.  *  * @param xContentRegistry the content registry  * @param httpRequest      the http request  * @param httpChannel      the http channel  * @throws ContentTypeHeaderException if the Content-Type header can not be parsed  */ public static RestRequest requestWithoutParameters(NamedXContentRegistry xContentRegistry, HttpRequest httpRequest, HttpChannel httpChannel) {     Map<String, String> params = Collections.emptyMap().     return new RestRequest(xContentRegistry, params, httpRequest.uri(), httpRequest.getHeaders(), httpRequest, httpChannel). }
false;public;0;3;;public Method method() {     return httpRequest.method(). }
true;public;0;3;/**  * The uri of the rest request, with the query string.  */ ;/**  * The uri of the rest request, with the query string.  */ public String uri() {     return httpRequest.uri(). }
true;public;0;3;/**  * The non decoded, raw path provided.  */ ;/**  * The non decoded, raw path provided.  */ public String rawPath() {     return rawPath. }
true;public,final;0;3;/**  * The path part of the URI (without the query string), decoded.  */ ;/**  * The path part of the URI (without the query string), decoded.  */ public final String path() {     return RestUtils.decodeComponent(rawPath()). }
false;public;0;3;;public boolean hasContent() {     return content(false).length() > 0. }
false;public;0;3;;public BytesReference content() {     return content(true). }
false;protected;1;4;;protected BytesReference content(final boolean contentConsumed) {     this.contentConsumed = this.contentConsumed | contentConsumed.     return httpRequest.content(). }
true;public,final;0;8;/**  * @return content of the request body or throw an exception if the body or content type is missing  */ ;/**  * @return content of the request body or throw an exception if the body or content type is missing  */ public final BytesReference requiredContent() {     if (hasContent() == false) {         throw new ElasticsearchParseException("request body is required").     } else if (xContentType.get() == null) {         throw new IllegalStateException("unknown content type").     }     return content(). }
true;public,final;1;7;/**  * Get the value of the header or {@code null} if not found. This method only retrieves the first header value if multiple values are  * sent. Use of {@link #getAllHeaderValues(String)} should be preferred  */ ;/**  * Get the value of the header or {@code null} if not found. This method only retrieves the first header value if multiple values are  * sent. Use of {@link #getAllHeaderValues(String)} should be preferred  */ public final String header(String name) {     List<String> values = headers.get(name).     if (values != null && values.isEmpty() == false) {         return values.get(0).     }     return null. }
true;public,final;1;7;/**  * Get all values for the header or {@code null} if the header was not found  */ ;/**  * Get all values for the header or {@code null} if the header was not found  */ public final List<String> getAllHeaderValues(String name) {     List<String> values = headers.get(name).     if (values != null) {         return Collections.unmodifiableList(values).     }     return null. }
true;public,final;0;3;/**  * Get all of the headers and values associated with the headers. Modifications of this map are not supported.  */ ;/**  * Get all of the headers and values associated with the headers. Modifications of this map are not supported.  */ public final Map<String, List<String>> getHeaders() {     return headers. }
true;public,final;0;4;/**  * The {@link XContentType} that was parsed from the {@code Content-Type} header. This value will be {@code null} in the case of  * a request without a valid {@code Content-Type} header, a request without content ({@link #hasContent()}, or a plain text request  */ ;/**  * The {@link XContentType} that was parsed from the {@code Content-Type} header. This value will be {@code null} in the case of  * a request without a valid {@code Content-Type} header, a request without content ({@link #hasContent()}, or a plain text request  */ @Nullable public final XContentType getXContentType() {     return xContentType.get(). }
true;final;1;3;/**  * Sets the {@link XContentType}  */ ;/**  * Sets the {@link XContentType}  */ final void setXContentType(XContentType xContentType) {     this.xContentType.set(xContentType). }
false;public;0;3;;public HttpChannel getHttpChannel() {     return httpChannel. }
false;public;0;3;;public HttpRequest getHttpRequest() {     return httpRequest. }
false;public,final;1;3;;public final boolean hasParam(String key) {     return params.containsKey(key). }
false;public,final;1;5;;@Override public final String param(String key) {     consumedParams.add(key).     return params.get(key). }
false;public,final;2;9;;@Override public final String param(String key, String defaultValue) {     consumedParams.add(key).     String value = params.get(key).     if (value == null) {         return defaultValue.     }     return value. }
false;public;0;3;;public Map<String, String> params() {     return params. }
true;;0;3;/**  * Returns a list of parameters that have been consumed. This method returns a copy, callers  * are free to modify the returned list.  *  * @return the list of currently consumed parameters.  */ ;/**  * Returns a list of parameters that have been consumed. This method returns a copy, callers  * are free to modify the returned list.  *  * @return the list of currently consumed parameters.  */ List<String> consumedParams() {     return consumedParams.stream().collect(Collectors.toList()). }
true;;0;7;/**  * Returns a list of parameters that have not yet been consumed. This method returns a copy,  * callers are free to modify the returned list.  *  * @return the list of currently unconsumed parameters.  */ ;/**  * Returns a list of parameters that have not yet been consumed. This method returns a copy,  * callers are free to modify the returned list.  *  * @return the list of currently unconsumed parameters.  */ List<String> unconsumedParams() {     return params.keySet().stream().filter(p -> !consumedParams.contains(p)).collect(Collectors.toList()). }
false;public;2;11;;public float paramAsFloat(String key, float defaultValue) {     String sValue = param(key).     if (sValue == null) {         return defaultValue.     }     try {         return Float.parseFloat(sValue).     } catch (NumberFormatException e) {         throw new IllegalArgumentException("Failed to parse float parameter [" + key + "] with value [" + sValue + "]", e).     } }
false;public;2;11;;public int paramAsInt(String key, int defaultValue) {     String sValue = param(key).     if (sValue == null) {         return defaultValue.     }     try {         return Integer.parseInt(sValue).     } catch (NumberFormatException e) {         throw new IllegalArgumentException("Failed to parse int parameter [" + key + "] with value [" + sValue + "]", e).     } }
false;public;2;11;;public long paramAsLong(String key, long defaultValue) {     String sValue = param(key).     if (sValue == null) {         return defaultValue.     }     try {         return Long.parseLong(sValue).     } catch (NumberFormatException e) {         throw new IllegalArgumentException("Failed to parse long parameter [" + key + "] with value [" + sValue + "]", e).     } }
false;public;2;10;;@Override public boolean paramAsBoolean(String key, boolean defaultValue) {     String rawParam = param(key).     // Treat empty string as true because that allows the presence of the url parameter to mean "turn this on"     if (rawParam != null && rawParam.length() == 0) {         return true.     } else {         return Booleans.parseBoolean(rawParam, defaultValue).     } }
false;public;2;4;;@Override public Boolean paramAsBoolean(String key, Boolean defaultValue) {     return Booleans.parseBoolean(param(key), defaultValue). }
false;public;2;3;;public TimeValue paramAsTime(String key, TimeValue defaultValue) {     return parseTimeValue(param(key), defaultValue, key). }
false;public;2;3;;public ByteSizeValue paramAsSize(String key, ByteSizeValue defaultValue) {     return parseBytesSizeValue(param(key), defaultValue, key). }
false;public;2;7;;public String[] paramAsStringArray(String key, String[] defaultValue) {     String value = param(key).     if (value == null) {         return defaultValue.     }     return Strings.splitStringByCommaToArray(value). }
false;public;1;7;;public String[] paramAsStringArrayOrEmptyIfAll(String key) {     String[] params = paramAsStringArray(key, Strings.EMPTY_ARRAY).     if (Strings.isAllOrWildcard(params)) {         return Strings.EMPTY_ARRAY.     }     return params. }
true;public;0;3;/**  * Get the {@link NamedXContentRegistry} that should be used to create parsers from this request.  */ ;/**  * Get the {@link NamedXContentRegistry} that should be used to create parsers from this request.  */ public NamedXContentRegistry getXContentRegistry() {     return xContentRegistry. }
true;public,final;0;4;/**  * A parser for the contents of this request if there is a body, otherwise throws an {@link ElasticsearchParseException}. Use  * {@link #applyContentParser(CheckedConsumer)} if you want to gracefully handle when the request doesn't have any contents. Use  * {@link #contentOrSourceParamParser()} for requests that support specifying the request body in the {@code source} param.  */ ;/**  * A parser for the contents of this request if there is a body, otherwise throws an {@link ElasticsearchParseException}. Use  * {@link #applyContentParser(CheckedConsumer)} if you want to gracefully handle when the request doesn't have any contents. Use  * {@link #contentOrSourceParamParser()} for requests that support specifying the request body in the {@code source} param.  */ public final XContentParser contentParser() throws IOException {     // will throw exception if body or content type missing     BytesReference content = requiredContent().     return xContentType.get().xContent().createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, content.streamInput()). }
true;public,final;1;7;/**  * If there is any content then call {@code applyParser} with the parser, otherwise do nothing.  */ ;/**  * If there is any content then call {@code applyParser} with the parser, otherwise do nothing.  */ public final void applyContentParser(CheckedConsumer<XContentParser, IOException> applyParser) throws IOException {     if (hasContent()) {         try (XContentParser parser = contentParser()) {             applyParser.accept(parser).         }     } }
true;public,final;0;3;/**  * Does this request have content or a {@code source} parameter? Use this instead of {@link #hasContent()} if this  * {@linkplain RestHandler} treats the {@code source} parameter like the body content.  */ ;/**  * Does this request have content or a {@code source} parameter? Use this instead of {@link #hasContent()} if this  * {@linkplain RestHandler} treats the {@code source} parameter like the body content.  */ public final boolean hasContentOrSourceParam() {     return hasContent() || hasParam("source"). }
true;public,final;0;4;/**  * A parser for the contents of this request if it has contents, otherwise a parser for the {@code source} parameter if there is one,  * otherwise throws an {@link ElasticsearchParseException}. Use {@link #withContentOrSourceParamParserOrNull(CheckedConsumer)} instead  * if you need to handle the absence request content gracefully.  */ ;/**  * A parser for the contents of this request if it has contents, otherwise a parser for the {@code source} parameter if there is one,  * otherwise throws an {@link ElasticsearchParseException}. Use {@link #withContentOrSourceParamParserOrNull(CheckedConsumer)} instead  * if you need to handle the absence request content gracefully.  */ public final XContentParser contentOrSourceParamParser() throws IOException {     Tuple<XContentType, BytesReference> tuple = contentOrSourceParam().     return tuple.v1().xContent().createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, tuple.v2().streamInput()). }
true;public,final;1;14;/**  * Call a consumer with the parser for the contents of this request if it has contents, otherwise with a parser for the {@code source}  * parameter if there is one, otherwise with {@code null}. Use {@link #contentOrSourceParamParser()} if you should throw an exception  * back to the user when there isn't request content.  */ ;/**  * Call a consumer with the parser for the contents of this request if it has contents, otherwise with a parser for the {@code source}  * parameter if there is one, otherwise with {@code null}. Use {@link #contentOrSourceParamParser()} if you should throw an exception  * back to the user when there isn't request content.  */ public final void withContentOrSourceParamParserOrNull(CheckedConsumer<XContentParser, IOException> withParser) throws IOException {     if (hasContentOrSourceParam()) {         Tuple<XContentType, BytesReference> tuple = contentOrSourceParam().         BytesReference content = tuple.v2().         XContentType xContentType = tuple.v1().         try (InputStream stream = content.streamInput().             XContentParser parser = xContentType.xContent().createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, stream)) {             withParser.accept(parser).         }     } else {         withParser.accept(null).     } }
true;public,final;0;18;/**  * Get the content of the request or the contents of the {@code source} param or throw an exception if both are missing.  * Prefer {@link #contentOrSourceParamParser()} or {@link #withContentOrSourceParamParserOrNull(CheckedConsumer)} if you need a parser.  */ ;/**  * Get the content of the request or the contents of the {@code source} param or throw an exception if both are missing.  * Prefer {@link #contentOrSourceParamParser()} or {@link #withContentOrSourceParamParserOrNull(CheckedConsumer)} if you need a parser.  */ public final Tuple<XContentType, BytesReference> contentOrSourceParam() {     if (hasContentOrSourceParam() == false) {         throw new ElasticsearchParseException("request body or source parameter is required").     } else if (hasContent()) {         return new Tuple<>(xContentType.get(), requiredContent()).     }     String source = param("source").     String typeParam = param("source_content_type").     if (source == null || typeParam == null) {         throw new IllegalStateException("source and source_content_type parameters are required").     }     BytesArray bytes = new BytesArray(source).     final XContentType xContentType = parseContentType(Collections.singletonList(typeParam)).     if (xContentType == null) {         throw new IllegalStateException("Unknown value for source_content_type [" + typeParam + "]").     }     return new Tuple<>(xContentType, bytes). }
true;public,static;1;20;// TODO stop ignoring parameters such as charset... ;/**  * Parses the given content type string for the media type. This method currently ignores parameters.  */ // TODO stop ignoring parameters such as charset... public static XContentType parseContentType(List<String> header) {     if (header == null || header.isEmpty()) {         return null.     } else if (header.size() > 1) {         throw new IllegalArgumentException("only one Content-Type header should be provided").     }     String rawContentType = header.get(0).     final String[] elements = rawContentType.split("[ \t]*.").     if (elements.length > 0) {         final String[] splitMediaType = elements[0].split("/").         if (splitMediaType.length == 2 && TCHAR_PATTERN.matcher(splitMediaType[0]).matches() && TCHAR_PATTERN.matcher(splitMediaType[1].trim()).matches()) {             return XContentType.fromMediaType(elements[0]).         } else {             throw new IllegalArgumentException("invalid Content-Type header [" + rawContentType + "]").         }     }     throw new IllegalArgumentException("empty Content-Type header"). }
