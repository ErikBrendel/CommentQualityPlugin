# id;timestamp;commentText;codeText;commentWords;codeWords
RoutingNodes -> UnassignedShards -> public int ignoredSize();1524684173;Returns the size of the temporarily marked as ignored unassigned shards;public int ignoredSize() { return ignored.size()_ };returns,the,size,of,the,temporarily,marked,as,ignored,unassigned,shards;public,int,ignored,size,return,ignored,size
RoutingNodes -> UnassignedShards -> public int ignoredSize();1540847035;Returns the size of the temporarily marked as ignored unassigned shards;public int ignoredSize() { return ignored.size()_ };returns,the,size,of,the,temporarily,marked,as,ignored,unassigned,shards;public,int,ignored,size,return,ignored,size
RoutingNodes -> public boolean allReplicasActive(ShardId shardId, MetaData metaData);1524684173;Returns <code>true</code> iff all replicas are active for the given shard routing. Otherwise <code>false</code>;public boolean allReplicasActive(ShardId shardId, MetaData metaData) {_        final List<ShardRouting> shards = assignedShards(shardId)__        if (shards.isEmpty() || shards.size() < metaData.getIndexSafe(shardId.getIndex()).getNumberOfReplicas() + 1) {_            return false_ _        }_        for (ShardRouting shard : shards) {_            if (!shard.active()) {_                return false__            }_        }_        return true__    };returns,code,true,code,iff,all,replicas,are,active,for,the,given,shard,routing,otherwise,code,false,code;public,boolean,all,replicas,active,shard,id,shard,id,meta,data,meta,data,final,list,shard,routing,shards,assigned,shards,shard,id,if,shards,is,empty,shards,size,meta,data,get,index,safe,shard,id,get,index,get,number,of,replicas,1,return,false,for,shard,routing,shard,shards,if,shard,active,return,false,return,true
RoutingNodes -> public boolean allReplicasActive(ShardId shardId, MetaData metaData);1540847035;Returns <code>true</code> iff all replicas are active for the given shard routing. Otherwise <code>false</code>;public boolean allReplicasActive(ShardId shardId, MetaData metaData) {_        final List<ShardRouting> shards = assignedShards(shardId)__        if (shards.isEmpty() || shards.size() < metaData.getIndexSafe(shardId.getIndex()).getNumberOfReplicas() + 1) {_            return false_ _        }_        for (ShardRouting shard : shards) {_            if (!shard.active()) {_                return false__            }_        }_        return true__    };returns,code,true,code,iff,all,replicas,are,active,for,the,given,shard,routing,otherwise,code,false,code;public,boolean,all,replicas,active,shard,id,shard,id,meta,data,meta,data,final,list,shard,routing,shards,assigned,shards,shard,id,if,shards,is,empty,shards,size,meta,data,get,index,safe,shard,id,get,index,get,number,of,replicas,1,return,false,for,shard,routing,shard,shards,if,shard,active,return,false,return,true
RoutingNodes -> public boolean allReplicasActive(ShardId shardId, MetaData metaData);1541446827;Returns <code>true</code> iff all replicas are active for the given shard routing. Otherwise <code>false</code>;public boolean allReplicasActive(ShardId shardId, MetaData metaData) {_        final List<ShardRouting> shards = assignedShards(shardId)__        if (shards.isEmpty() || shards.size() < metaData.getIndexSafe(shardId.getIndex()).getNumberOfReplicas() + 1) {_            return false_ _        }_        for (ShardRouting shard : shards) {_            if (!shard.active()) {_                return false__            }_        }_        return true__    };returns,code,true,code,iff,all,replicas,are,active,for,the,given,shard,routing,otherwise,code,false,code;public,boolean,all,replicas,active,shard,id,shard,id,meta,data,meta,data,final,list,shard,routing,shards,assigned,shards,shard,id,if,shards,is,empty,shards,size,meta,data,get,index,safe,shard,id,get,index,get,number,of,replicas,1,return,false,for,shard,routing,shard,shards,if,shard,active,return,false,return,true
RoutingNodes -> public boolean allReplicasActive(ShardId shardId, MetaData metaData);1548259585;Returns <code>true</code> iff all replicas are active for the given shard routing. Otherwise <code>false</code>;public boolean allReplicasActive(ShardId shardId, MetaData metaData) {_        final List<ShardRouting> shards = assignedShards(shardId)__        if (shards.isEmpty() || shards.size() < metaData.getIndexSafe(shardId.getIndex()).getNumberOfReplicas() + 1) {_            return false_ _        }_        for (ShardRouting shard : shards) {_            if (!shard.active()) {_                return false__            }_        }_        return true__    };returns,code,true,code,iff,all,replicas,are,active,for,the,given,shard,routing,otherwise,code,false,code;public,boolean,all,replicas,active,shard,id,shard,id,meta,data,meta,data,final,list,shard,routing,shards,assigned,shards,shard,id,if,shards,is,empty,shards,size,meta,data,get,index,safe,shard,id,get,index,get,number,of,replicas,1,return,false,for,shard,routing,shard,shards,if,shard,active,return,false,return,true
RoutingNodes -> public boolean allReplicasActive(ShardId shardId, MetaData metaData);1549912434;Returns <code>true</code> iff all replicas are active for the given shard routing. Otherwise <code>false</code>;public boolean allReplicasActive(ShardId shardId, MetaData metaData) {_        final List<ShardRouting> shards = assignedShards(shardId)__        if (shards.isEmpty() || shards.size() < metaData.getIndexSafe(shardId.getIndex()).getNumberOfReplicas() + 1) {_            return false_ _        }_        for (ShardRouting shard : shards) {_            if (!shard.active()) {_                return false__            }_        }_        return true__    };returns,code,true,code,iff,all,replicas,are,active,for,the,given,shard,routing,otherwise,code,false,code;public,boolean,all,replicas,active,shard,id,shard,id,meta,data,meta,data,final,list,shard,routing,shards,assigned,shards,shard,id,if,shards,is,empty,shards,size,meta,data,get,index,safe,shard,id,get,index,get,number,of,replicas,1,return,false,for,shard,routing,shard,shards,if,shard,active,return,false,return,true
RoutingNodes -> private ShardRouting removeRelocationSource(ShardRouting shard);1524684173;Removes relocation source of an initializing non-primary shard. This allows the replica shard to continue recovery from_the primary even though its non-primary relocation source has failed.;private ShardRouting removeRelocationSource(ShardRouting shard) {_        assert shard.isRelocationTarget() : "only relocation target shards can have their relocation source removed (" + shard + ")"__        ShardRouting relocationMarkerRemoved = shard.removeRelocationSource()__        updateAssigned(shard, relocationMarkerRemoved)__        inactiveShardCount++_ _        return relocationMarkerRemoved__    };removes,relocation,source,of,an,initializing,non,primary,shard,this,allows,the,replica,shard,to,continue,recovery,from,the,primary,even,though,its,non,primary,relocation,source,has,failed;private,shard,routing,remove,relocation,source,shard,routing,shard,assert,shard,is,relocation,target,only,relocation,target,shards,can,have,their,relocation,source,removed,shard,shard,routing,relocation,marker,removed,shard,remove,relocation,source,update,assigned,shard,relocation,marker,removed,inactive,shard,count,return,relocation,marker,removed
RoutingNodes -> private ShardRouting removeRelocationSource(ShardRouting shard);1540847035;Removes relocation source of an initializing non-primary shard. This allows the replica shard to continue recovery from_the primary even though its non-primary relocation source has failed.;private ShardRouting removeRelocationSource(ShardRouting shard) {_        assert shard.isRelocationTarget() : "only relocation target shards can have their relocation source removed (" + shard + ")"__        ShardRouting relocationMarkerRemoved = shard.removeRelocationSource()__        updateAssigned(shard, relocationMarkerRemoved)__        inactiveShardCount++_ _        return relocationMarkerRemoved__    };removes,relocation,source,of,an,initializing,non,primary,shard,this,allows,the,replica,shard,to,continue,recovery,from,the,primary,even,though,its,non,primary,relocation,source,has,failed;private,shard,routing,remove,relocation,source,shard,routing,shard,assert,shard,is,relocation,target,only,relocation,target,shards,can,have,their,relocation,source,removed,shard,shard,routing,relocation,marker,removed,shard,remove,relocation,source,update,assigned,shard,relocation,marker,removed,inactive,shard,count,return,relocation,marker,removed
RoutingNodes -> private ShardRouting removeRelocationSource(ShardRouting shard);1541446827;Removes relocation source of an initializing non-primary shard. This allows the replica shard to continue recovery from_the primary even though its non-primary relocation source has failed.;private ShardRouting removeRelocationSource(ShardRouting shard) {_        assert shard.isRelocationTarget() : "only relocation target shards can have their relocation source removed (" + shard + ")"__        ShardRouting relocationMarkerRemoved = shard.removeRelocationSource()__        updateAssigned(shard, relocationMarkerRemoved)__        inactiveShardCount++_ _        return relocationMarkerRemoved__    };removes,relocation,source,of,an,initializing,non,primary,shard,this,allows,the,replica,shard,to,continue,recovery,from,the,primary,even,though,its,non,primary,relocation,source,has,failed;private,shard,routing,remove,relocation,source,shard,routing,shard,assert,shard,is,relocation,target,only,relocation,target,shards,can,have,their,relocation,source,removed,shard,shard,routing,relocation,marker,removed,shard,remove,relocation,source,update,assigned,shard,relocation,marker,removed,inactive,shard,count,return,relocation,marker,removed
RoutingNodes -> private ShardRouting removeRelocationSource(ShardRouting shard);1548259585;Removes relocation source of an initializing non-primary shard. This allows the replica shard to continue recovery from_the primary even though its non-primary relocation source has failed.;private ShardRouting removeRelocationSource(ShardRouting shard) {_        assert shard.isRelocationTarget() : "only relocation target shards can have their relocation source removed (" + shard + ")"__        ShardRouting relocationMarkerRemoved = shard.removeRelocationSource()__        updateAssigned(shard, relocationMarkerRemoved)__        inactiveShardCount++_ _        return relocationMarkerRemoved__    };removes,relocation,source,of,an,initializing,non,primary,shard,this,allows,the,replica,shard,to,continue,recovery,from,the,primary,even,though,its,non,primary,relocation,source,has,failed;private,shard,routing,remove,relocation,source,shard,routing,shard,assert,shard,is,relocation,target,only,relocation,target,shards,can,have,their,relocation,source,removed,shard,shard,routing,relocation,marker,removed,shard,remove,relocation,source,update,assigned,shard,relocation,marker,removed,inactive,shard,count,return,relocation,marker,removed
RoutingNodes -> private ShardRouting removeRelocationSource(ShardRouting shard);1549912434;Removes relocation source of an initializing non-primary shard. This allows the replica shard to continue recovery from_the primary even though its non-primary relocation source has failed.;private ShardRouting removeRelocationSource(ShardRouting shard) {_        assert shard.isRelocationTarget() : "only relocation target shards can have their relocation source removed (" + shard + ")"__        ShardRouting relocationMarkerRemoved = shard.removeRelocationSource()__        updateAssigned(shard, relocationMarkerRemoved)__        inactiveShardCount++_ _        return relocationMarkerRemoved__    };removes,relocation,source,of,an,initializing,non,primary,shard,this,allows,the,replica,shard,to,continue,recovery,from,the,primary,even,though,its,non,primary,relocation,source,has,failed;private,shard,routing,remove,relocation,source,shard,routing,shard,assert,shard,is,relocation,target,only,relocation,target,shards,can,have,their,relocation,source,removed,shard,shard,routing,relocation,marker,removed,shard,remove,relocation,source,update,assigned,shard,relocation,marker,removed,inactive,shard,count,return,relocation,marker,removed
RoutingNodes -> UnassignedShards -> public boolean isIgnoredEmpty();1524684173;Returns <code>true</code> iff any unassigned shards are marked as temporarily ignored._@see UnassignedShards#ignoreShard(ShardRouting, AllocationStatus, RoutingChangesObserver)_@see UnassignedIterator#removeAndIgnore(AllocationStatus, RoutingChangesObserver);public boolean isIgnoredEmpty() {_            return ignored.isEmpty()__        };returns,code,true,code,iff,any,unassigned,shards,are,marked,as,temporarily,ignored,see,unassigned,shards,ignore,shard,shard,routing,allocation,status,routing,changes,observer,see,unassigned,iterator,remove,and,ignore,allocation,status,routing,changes,observer;public,boolean,is,ignored,empty,return,ignored,is,empty
RoutingNodes -> UnassignedShards -> public boolean isIgnoredEmpty();1540847035;Returns <code>true</code> iff any unassigned shards are marked as temporarily ignored._@see UnassignedShards#ignoreShard(ShardRouting, AllocationStatus, RoutingChangesObserver)_@see UnassignedIterator#removeAndIgnore(AllocationStatus, RoutingChangesObserver);public boolean isIgnoredEmpty() {_            return ignored.isEmpty()__        };returns,code,true,code,iff,any,unassigned,shards,are,marked,as,temporarily,ignored,see,unassigned,shards,ignore,shard,shard,routing,allocation,status,routing,changes,observer,see,unassigned,iterator,remove,and,ignore,allocation,status,routing,changes,observer;public,boolean,is,ignored,empty,return,ignored,is,empty
RoutingNodes -> UnassignedShards -> public boolean isIgnoredEmpty();1541446827;Returns <code>true</code> iff any unassigned shards are marked as temporarily ignored._@see UnassignedShards#ignoreShard(ShardRouting, AllocationStatus, RoutingChangesObserver)_@see UnassignedIterator#removeAndIgnore(AllocationStatus, RoutingChangesObserver);public boolean isIgnoredEmpty() {_            return ignored.isEmpty()__        };returns,code,true,code,iff,any,unassigned,shards,are,marked,as,temporarily,ignored,see,unassigned,shards,ignore,shard,shard,routing,allocation,status,routing,changes,observer,see,unassigned,iterator,remove,and,ignore,allocation,status,routing,changes,observer;public,boolean,is,ignored,empty,return,ignored,is,empty
RoutingNodes -> UnassignedShards -> public boolean isIgnoredEmpty();1548259585;Returns <code>true</code> iff any unassigned shards are marked as temporarily ignored._@see UnassignedShards#ignoreShard(ShardRouting, AllocationStatus, RoutingChangesObserver)_@see UnassignedIterator#removeAndIgnore(AllocationStatus, RoutingChangesObserver);public boolean isIgnoredEmpty() {_            return ignored.isEmpty()__        };returns,code,true,code,iff,any,unassigned,shards,are,marked,as,temporarily,ignored,see,unassigned,shards,ignore,shard,shard,routing,allocation,status,routing,changes,observer,see,unassigned,iterator,remove,and,ignore,allocation,status,routing,changes,observer;public,boolean,is,ignored,empty,return,ignored,is,empty
RoutingNodes -> UnassignedShards -> public boolean isIgnoredEmpty();1549912434;Returns <code>true</code> iff any unassigned shards are marked as temporarily ignored._@see UnassignedShards#ignoreShard(ShardRouting, AllocationStatus, RoutingChangesObserver)_@see UnassignedIterator#removeAndIgnore(AllocationStatus, RoutingChangesObserver);public boolean isIgnoredEmpty() {_            return ignored.isEmpty()__        };returns,code,true,code,iff,any,unassigned,shards,are,marked,as,temporarily,ignored,see,unassigned,shards,ignore,shard,shard,routing,allocation,status,routing,changes,observer,see,unassigned,iterator,remove,and,ignore,allocation,status,routing,changes,observer;public,boolean,is,ignored,empty,return,ignored,is,empty
RoutingNodes -> UnassignedShards -> public List<ShardRouting> ignored();1524684173;The list of ignored unassigned shards (read only). The ignored unassigned shards_are not part of the formal unassigned list, but are kept around and used to build_back the list of unassigned shards as part of the routing table.;public List<ShardRouting> ignored() {_            return Collections.unmodifiableList(ignored)__        };the,list,of,ignored,unassigned,shards,read,only,the,ignored,unassigned,shards,are,not,part,of,the,formal,unassigned,list,but,are,kept,around,and,used,to,build,back,the,list,of,unassigned,shards,as,part,of,the,routing,table;public,list,shard,routing,ignored,return,collections,unmodifiable,list,ignored
RoutingNodes -> UnassignedShards -> public List<ShardRouting> ignored();1540847035;The list of ignored unassigned shards (read only). The ignored unassigned shards_are not part of the formal unassigned list, but are kept around and used to build_back the list of unassigned shards as part of the routing table.;public List<ShardRouting> ignored() {_            return Collections.unmodifiableList(ignored)__        };the,list,of,ignored,unassigned,shards,read,only,the,ignored,unassigned,shards,are,not,part,of,the,formal,unassigned,list,but,are,kept,around,and,used,to,build,back,the,list,of,unassigned,shards,as,part,of,the,routing,table;public,list,shard,routing,ignored,return,collections,unmodifiable,list,ignored
RoutingNodes -> UnassignedShards -> public List<ShardRouting> ignored();1541446827;The list of ignored unassigned shards (read only). The ignored unassigned shards_are not part of the formal unassigned list, but are kept around and used to build_back the list of unassigned shards as part of the routing table.;public List<ShardRouting> ignored() {_            return Collections.unmodifiableList(ignored)__        };the,list,of,ignored,unassigned,shards,read,only,the,ignored,unassigned,shards,are,not,part,of,the,formal,unassigned,list,but,are,kept,around,and,used,to,build,back,the,list,of,unassigned,shards,as,part,of,the,routing,table;public,list,shard,routing,ignored,return,collections,unmodifiable,list,ignored
RoutingNodes -> UnassignedShards -> public List<ShardRouting> ignored();1548259585;The list of ignored unassigned shards (read only). The ignored unassigned shards_are not part of the formal unassigned list, but are kept around and used to build_back the list of unassigned shards as part of the routing table.;public List<ShardRouting> ignored() {_            return Collections.unmodifiableList(ignored)__        };the,list,of,ignored,unassigned,shards,read,only,the,ignored,unassigned,shards,are,not,part,of,the,formal,unassigned,list,but,are,kept,around,and,used,to,build,back,the,list,of,unassigned,shards,as,part,of,the,routing,table;public,list,shard,routing,ignored,return,collections,unmodifiable,list,ignored
RoutingNodes -> UnassignedShards -> public List<ShardRouting> ignored();1549912434;The list of ignored unassigned shards (read only). The ignored unassigned shards_are not part of the formal unassigned list, but are kept around and used to build_back the list of unassigned shards as part of the routing table.;public List<ShardRouting> ignored() {_            return Collections.unmodifiableList(ignored)__        };the,list,of,ignored,unassigned,shards,read,only,the,ignored,unassigned,shards,are,not,part,of,the,formal,unassigned,list,but,are,kept,around,and,used,to,build,back,the,list,of,unassigned,shards,as,part,of,the,routing,table;public,list,shard,routing,ignored,return,collections,unmodifiable,list,ignored
RoutingNodes -> public ShardRouting activePrimary(ShardId shardId);1524684173;Returns the active primary shard for the given shard id or <code>null</code> if_no primary is found or the primary is not active.;public ShardRouting activePrimary(ShardId shardId) {_        for (ShardRouting shardRouting : assignedShards(shardId)) {_            if (shardRouting.primary() && shardRouting.active()) {_                return shardRouting__            }_        }_        return null__    };returns,the,active,primary,shard,for,the,given,shard,id,or,code,null,code,if,no,primary,is,found,or,the,primary,is,not,active;public,shard,routing,active,primary,shard,id,shard,id,for,shard,routing,shard,routing,assigned,shards,shard,id,if,shard,routing,primary,shard,routing,active,return,shard,routing,return,null
RoutingNodes -> public ShardRouting activePrimary(ShardId shardId);1540847035;Returns the active primary shard for the given shard id or <code>null</code> if_no primary is found or the primary is not active.;public ShardRouting activePrimary(ShardId shardId) {_        for (ShardRouting shardRouting : assignedShards(shardId)) {_            if (shardRouting.primary() && shardRouting.active()) {_                return shardRouting__            }_        }_        return null__    };returns,the,active,primary,shard,for,the,given,shard,id,or,code,null,code,if,no,primary,is,found,or,the,primary,is,not,active;public,shard,routing,active,primary,shard,id,shard,id,for,shard,routing,shard,routing,assigned,shards,shard,id,if,shard,routing,primary,shard,routing,active,return,shard,routing,return,null
RoutingNodes -> public ShardRouting activePrimary(ShardId shardId);1541446827;Returns the active primary shard for the given shard id or <code>null</code> if_no primary is found or the primary is not active.;public ShardRouting activePrimary(ShardId shardId) {_        for (ShardRouting shardRouting : assignedShards(shardId)) {_            if (shardRouting.primary() && shardRouting.active()) {_                return shardRouting__            }_        }_        return null__    };returns,the,active,primary,shard,for,the,given,shard,id,or,code,null,code,if,no,primary,is,found,or,the,primary,is,not,active;public,shard,routing,active,primary,shard,id,shard,id,for,shard,routing,shard,routing,assigned,shards,shard,id,if,shard,routing,primary,shard,routing,active,return,shard,routing,return,null
RoutingNodes -> public ShardRouting activePrimary(ShardId shardId);1548259585;Returns the active primary shard for the given shard id or <code>null</code> if_no primary is found or the primary is not active.;public ShardRouting activePrimary(ShardId shardId) {_        for (ShardRouting shardRouting : assignedShards(shardId)) {_            if (shardRouting.primary() && shardRouting.active()) {_                return shardRouting__            }_        }_        return null__    };returns,the,active,primary,shard,for,the,given,shard,id,or,code,null,code,if,no,primary,is,found,or,the,primary,is,not,active;public,shard,routing,active,primary,shard,id,shard,id,for,shard,routing,shard,routing,assigned,shards,shard,id,if,shard,routing,primary,shard,routing,active,return,shard,routing,return,null
RoutingNodes -> public ShardRouting activePrimary(ShardId shardId);1549912434;Returns the active primary shard for the given shard id or <code>null</code> if_no primary is found or the primary is not active.;public ShardRouting activePrimary(ShardId shardId) {_        for (ShardRouting shardRouting : assignedShards(shardId)) {_            if (shardRouting.primary() && shardRouting.active()) {_                return shardRouting__            }_        }_        return null__    };returns,the,active,primary,shard,for,the,given,shard,id,or,code,null,code,if,no,primary,is,found,or,the,primary,is,not,active;public,shard,routing,active,primary,shard,id,shard,id,for,shard,routing,shard,routing,assigned,shards,shard,id,if,shard,routing,primary,shard,routing,active,return,shard,routing,return,null
RoutingNodes -> UnassignedShards -> public ShardRouting[] drain();1524684173;Drains all unassigned shards and returns it._This method will not drain ignored shards.;public ShardRouting[] drain() {_            nodes.ensureMutable()__            ShardRouting[] mutableShardRoutings = unassigned.toArray(new ShardRouting[unassigned.size()])__            unassigned.clear()__            primaries = 0__            return mutableShardRoutings__        };drains,all,unassigned,shards,and,returns,it,this,method,will,not,drain,ignored,shards;public,shard,routing,drain,nodes,ensure,mutable,shard,routing,mutable,shard,routings,unassigned,to,array,new,shard,routing,unassigned,size,unassigned,clear,primaries,0,return,mutable,shard,routings
RoutingNodes -> UnassignedShards -> public ShardRouting[] drain();1540847035;Drains all unassigned shards and returns it._This method will not drain ignored shards.;public ShardRouting[] drain() {_            nodes.ensureMutable()__            ShardRouting[] mutableShardRoutings = unassigned.toArray(new ShardRouting[unassigned.size()])__            unassigned.clear()__            primaries = 0__            return mutableShardRoutings__        };drains,all,unassigned,shards,and,returns,it,this,method,will,not,drain,ignored,shards;public,shard,routing,drain,nodes,ensure,mutable,shard,routing,mutable,shard,routings,unassigned,to,array,new,shard,routing,unassigned,size,unassigned,clear,primaries,0,return,mutable,shard,routings
RoutingNodes -> UnassignedShards -> public ShardRouting[] drain();1541446827;Drains all unassigned shards and returns it._This method will not drain ignored shards.;public ShardRouting[] drain() {_            nodes.ensureMutable()__            ShardRouting[] mutableShardRoutings = unassigned.toArray(new ShardRouting[unassigned.size()])__            unassigned.clear()__            primaries = 0__            return mutableShardRoutings__        };drains,all,unassigned,shards,and,returns,it,this,method,will,not,drain,ignored,shards;public,shard,routing,drain,nodes,ensure,mutable,shard,routing,mutable,shard,routings,unassigned,to,array,new,shard,routing,unassigned,size,unassigned,clear,primaries,0,return,mutable,shard,routings
RoutingNodes -> UnassignedShards -> public ShardRouting[] drain();1548259585;Drains all unassigned shards and returns it._This method will not drain ignored shards.;public ShardRouting[] drain() {_            nodes.ensureMutable()__            ShardRouting[] mutableShardRoutings = unassigned.toArray(new ShardRouting[unassigned.size()])__            unassigned.clear()__            primaries = 0__            return mutableShardRoutings__        };drains,all,unassigned,shards,and,returns,it,this,method,will,not,drain,ignored,shards;public,shard,routing,drain,nodes,ensure,mutable,shard,routing,mutable,shard,routings,unassigned,to,array,new,shard,routing,unassigned,size,unassigned,clear,primaries,0,return,mutable,shard,routings
RoutingNodes -> UnassignedShards -> public ShardRouting[] drain();1549912434;Drains all unassigned shards and returns it._This method will not drain ignored shards.;public ShardRouting[] drain() {_            nodes.ensureMutable()__            ShardRouting[] mutableShardRoutings = unassigned.toArray(new ShardRouting[unassigned.size()])__            unassigned.clear()__            primaries = 0__            return mutableShardRoutings__        };drains,all,unassigned,shards,and,returns,it,this,method,will,not,drain,ignored,shards;public,shard,routing,drain,nodes,ensure,mutable,shard,routing,mutable,shard,routings,unassigned,to,array,new,shard,routing,unassigned,size,unassigned,clear,primaries,0,return,mutable,shard,routings
RoutingNodes -> public ShardRouting startShard(Logger logger, ShardRouting initializingShard, RoutingChangesObserver routingChangesObserver);1524684173;Applies the relevant logic to start an initializing shard.__Moves the initializing shard to started. If the shard is a relocation target, also removes the relocation source.__If the started shard is a primary relocation target, this also reinitializes currently initializing replicas as their_recovery source changes__@return the started shard;public ShardRouting startShard(Logger logger, ShardRouting initializingShard, RoutingChangesObserver routingChangesObserver) {_        ensureMutable()__        ShardRouting startedShard = started(initializingShard)__        logger.trace("{} marked shard as started (routing: {})", initializingShard.shardId(), initializingShard)__        routingChangesObserver.shardStarted(initializingShard, startedShard)___        if (initializingShard.relocatingNodeId() != null) {_            _            RoutingNode relocationSourceNode = node(initializingShard.relocatingNodeId())__            ShardRouting relocationSourceShard = relocationSourceNode.getByShardId(initializingShard.shardId())__            assert relocationSourceShard.isRelocationSourceOf(initializingShard)__            assert relocationSourceShard.getTargetRelocatingShard() == initializingShard : "relocation target mismatch, expected: "_                + initializingShard + " but was: " + relocationSourceShard.getTargetRelocatingShard()__            remove(relocationSourceShard)__            routingChangesObserver.relocationCompleted(relocationSourceShard)___            _            if (startedShard.primary()) {_                List<ShardRouting> assignedShards = assignedShards(startedShard.shardId())__                _                for (ShardRouting routing : new ArrayList<>(assignedShards)) {_                    if (routing.initializing() && routing.primary() == false) {_                        if (routing.isRelocationTarget()) {_                            _                            ShardRouting sourceShard = getByAllocationId(routing.shardId(), routing.allocationId().getRelocationId())__                            _                            ShardRouting startedReplica = cancelRelocation(sourceShard)__                            remove(routing)__                            routingChangesObserver.shardFailed(routing,_                                new UnassignedInfo(UnassignedInfo.Reason.REINITIALIZED, "primary changed"))__                            relocateShard(startedReplica, sourceShard.relocatingNodeId(),_                                sourceShard.getExpectedShardSize(), routingChangesObserver)__                        } else {_                            ShardRouting reinitializedReplica = reinitReplica(routing)__                            routingChangesObserver.initializedReplicaReinitialized(routing, reinitializedReplica)__                        }_                    }_                }_            }_        }_        return startedShard__    };applies,the,relevant,logic,to,start,an,initializing,shard,moves,the,initializing,shard,to,started,if,the,shard,is,a,relocation,target,also,removes,the,relocation,source,if,the,started,shard,is,a,primary,relocation,target,this,also,reinitializes,currently,initializing,replicas,as,their,recovery,source,changes,return,the,started,shard;public,shard,routing,start,shard,logger,logger,shard,routing,initializing,shard,routing,changes,observer,routing,changes,observer,ensure,mutable,shard,routing,started,shard,started,initializing,shard,logger,trace,marked,shard,as,started,routing,initializing,shard,shard,id,initializing,shard,routing,changes,observer,shard,started,initializing,shard,started,shard,if,initializing,shard,relocating,node,id,null,routing,node,relocation,source,node,node,initializing,shard,relocating,node,id,shard,routing,relocation,source,shard,relocation,source,node,get,by,shard,id,initializing,shard,shard,id,assert,relocation,source,shard,is,relocation,source,of,initializing,shard,assert,relocation,source,shard,get,target,relocating,shard,initializing,shard,relocation,target,mismatch,expected,initializing,shard,but,was,relocation,source,shard,get,target,relocating,shard,remove,relocation,source,shard,routing,changes,observer,relocation,completed,relocation,source,shard,if,started,shard,primary,list,shard,routing,assigned,shards,assigned,shards,started,shard,shard,id,for,shard,routing,routing,new,array,list,assigned,shards,if,routing,initializing,routing,primary,false,if,routing,is,relocation,target,shard,routing,source,shard,get,by,allocation,id,routing,shard,id,routing,allocation,id,get,relocation,id,shard,routing,started,replica,cancel,relocation,source,shard,remove,routing,routing,changes,observer,shard,failed,routing,new,unassigned,info,unassigned,info,reason,reinitialized,primary,changed,relocate,shard,started,replica,source,shard,relocating,node,id,source,shard,get,expected,shard,size,routing,changes,observer,else,shard,routing,reinitialized,replica,reinit,replica,routing,routing,changes,observer,initialized,replica,reinitialized,routing,reinitialized,replica,return,started,shard
RoutingNodes -> public ShardRouting startShard(Logger logger, ShardRouting initializingShard, RoutingChangesObserver routingChangesObserver);1540847035;Applies the relevant logic to start an initializing shard.__Moves the initializing shard to started. If the shard is a relocation target, also removes the relocation source.__If the started shard is a primary relocation target, this also reinitializes currently initializing replicas as their_recovery source changes__@return the started shard;public ShardRouting startShard(Logger logger, ShardRouting initializingShard, RoutingChangesObserver routingChangesObserver) {_        ensureMutable()__        ShardRouting startedShard = started(initializingShard)__        logger.trace("{} marked shard as started (routing: {})", initializingShard.shardId(), initializingShard)__        routingChangesObserver.shardStarted(initializingShard, startedShard)___        if (initializingShard.relocatingNodeId() != null) {_            _            RoutingNode relocationSourceNode = node(initializingShard.relocatingNodeId())__            ShardRouting relocationSourceShard = relocationSourceNode.getByShardId(initializingShard.shardId())__            assert relocationSourceShard.isRelocationSourceOf(initializingShard)__            assert relocationSourceShard.getTargetRelocatingShard() == initializingShard : "relocation target mismatch, expected: "_                + initializingShard + " but was: " + relocationSourceShard.getTargetRelocatingShard()__            remove(relocationSourceShard)__            routingChangesObserver.relocationCompleted(relocationSourceShard)___            _            if (startedShard.primary()) {_                List<ShardRouting> assignedShards = assignedShards(startedShard.shardId())__                _                for (ShardRouting routing : new ArrayList<>(assignedShards)) {_                    if (routing.initializing() && routing.primary() == false) {_                        if (routing.isRelocationTarget()) {_                            _                            ShardRouting sourceShard = getByAllocationId(routing.shardId(), routing.allocationId().getRelocationId())__                            _                            ShardRouting startedReplica = cancelRelocation(sourceShard)__                            remove(routing)__                            routingChangesObserver.shardFailed(routing,_                                new UnassignedInfo(UnassignedInfo.Reason.REINITIALIZED, "primary changed"))__                            relocateShard(startedReplica, sourceShard.relocatingNodeId(),_                                sourceShard.getExpectedShardSize(), routingChangesObserver)__                        } else {_                            ShardRouting reinitializedReplica = reinitReplica(routing)__                            routingChangesObserver.initializedReplicaReinitialized(routing, reinitializedReplica)__                        }_                    }_                }_            }_        }_        return startedShard__    };applies,the,relevant,logic,to,start,an,initializing,shard,moves,the,initializing,shard,to,started,if,the,shard,is,a,relocation,target,also,removes,the,relocation,source,if,the,started,shard,is,a,primary,relocation,target,this,also,reinitializes,currently,initializing,replicas,as,their,recovery,source,changes,return,the,started,shard;public,shard,routing,start,shard,logger,logger,shard,routing,initializing,shard,routing,changes,observer,routing,changes,observer,ensure,mutable,shard,routing,started,shard,started,initializing,shard,logger,trace,marked,shard,as,started,routing,initializing,shard,shard,id,initializing,shard,routing,changes,observer,shard,started,initializing,shard,started,shard,if,initializing,shard,relocating,node,id,null,routing,node,relocation,source,node,node,initializing,shard,relocating,node,id,shard,routing,relocation,source,shard,relocation,source,node,get,by,shard,id,initializing,shard,shard,id,assert,relocation,source,shard,is,relocation,source,of,initializing,shard,assert,relocation,source,shard,get,target,relocating,shard,initializing,shard,relocation,target,mismatch,expected,initializing,shard,but,was,relocation,source,shard,get,target,relocating,shard,remove,relocation,source,shard,routing,changes,observer,relocation,completed,relocation,source,shard,if,started,shard,primary,list,shard,routing,assigned,shards,assigned,shards,started,shard,shard,id,for,shard,routing,routing,new,array,list,assigned,shards,if,routing,initializing,routing,primary,false,if,routing,is,relocation,target,shard,routing,source,shard,get,by,allocation,id,routing,shard,id,routing,allocation,id,get,relocation,id,shard,routing,started,replica,cancel,relocation,source,shard,remove,routing,routing,changes,observer,shard,failed,routing,new,unassigned,info,unassigned,info,reason,reinitialized,primary,changed,relocate,shard,started,replica,source,shard,relocating,node,id,source,shard,get,expected,shard,size,routing,changes,observer,else,shard,routing,reinitialized,replica,reinit,replica,routing,routing,changes,observer,initialized,replica,reinitialized,routing,reinitialized,replica,return,started,shard
RoutingNodes -> public ShardRouting startShard(Logger logger, ShardRouting initializingShard, RoutingChangesObserver routingChangesObserver);1541446827;Applies the relevant logic to start an initializing shard.__Moves the initializing shard to started. If the shard is a relocation target, also removes the relocation source.__If the started shard is a primary relocation target, this also reinitializes currently initializing replicas as their_recovery source changes__@return the started shard;public ShardRouting startShard(Logger logger, ShardRouting initializingShard, RoutingChangesObserver routingChangesObserver) {_        ensureMutable()__        ShardRouting startedShard = started(initializingShard)__        logger.trace("{} marked shard as started (routing: {})", initializingShard.shardId(), initializingShard)__        routingChangesObserver.shardStarted(initializingShard, startedShard)___        if (initializingShard.relocatingNodeId() != null) {_            _            RoutingNode relocationSourceNode = node(initializingShard.relocatingNodeId())__            ShardRouting relocationSourceShard = relocationSourceNode.getByShardId(initializingShard.shardId())__            assert relocationSourceShard.isRelocationSourceOf(initializingShard)__            assert relocationSourceShard.getTargetRelocatingShard() == initializingShard : "relocation target mismatch, expected: "_                + initializingShard + " but was: " + relocationSourceShard.getTargetRelocatingShard()__            remove(relocationSourceShard)__            routingChangesObserver.relocationCompleted(relocationSourceShard)___            _            if (startedShard.primary()) {_                List<ShardRouting> assignedShards = assignedShards(startedShard.shardId())__                _                for (ShardRouting routing : new ArrayList<>(assignedShards)) {_                    if (routing.initializing() && routing.primary() == false) {_                        if (routing.isRelocationTarget()) {_                            _                            ShardRouting sourceShard = getByAllocationId(routing.shardId(), routing.allocationId().getRelocationId())__                            _                            ShardRouting startedReplica = cancelRelocation(sourceShard)__                            remove(routing)__                            routingChangesObserver.shardFailed(routing,_                                new UnassignedInfo(UnassignedInfo.Reason.REINITIALIZED, "primary changed"))__                            relocateShard(startedReplica, sourceShard.relocatingNodeId(),_                                sourceShard.getExpectedShardSize(), routingChangesObserver)__                        } else {_                            ShardRouting reinitializedReplica = reinitReplica(routing)__                            routingChangesObserver.initializedReplicaReinitialized(routing, reinitializedReplica)__                        }_                    }_                }_            }_        }_        return startedShard__    };applies,the,relevant,logic,to,start,an,initializing,shard,moves,the,initializing,shard,to,started,if,the,shard,is,a,relocation,target,also,removes,the,relocation,source,if,the,started,shard,is,a,primary,relocation,target,this,also,reinitializes,currently,initializing,replicas,as,their,recovery,source,changes,return,the,started,shard;public,shard,routing,start,shard,logger,logger,shard,routing,initializing,shard,routing,changes,observer,routing,changes,observer,ensure,mutable,shard,routing,started,shard,started,initializing,shard,logger,trace,marked,shard,as,started,routing,initializing,shard,shard,id,initializing,shard,routing,changes,observer,shard,started,initializing,shard,started,shard,if,initializing,shard,relocating,node,id,null,routing,node,relocation,source,node,node,initializing,shard,relocating,node,id,shard,routing,relocation,source,shard,relocation,source,node,get,by,shard,id,initializing,shard,shard,id,assert,relocation,source,shard,is,relocation,source,of,initializing,shard,assert,relocation,source,shard,get,target,relocating,shard,initializing,shard,relocation,target,mismatch,expected,initializing,shard,but,was,relocation,source,shard,get,target,relocating,shard,remove,relocation,source,shard,routing,changes,observer,relocation,completed,relocation,source,shard,if,started,shard,primary,list,shard,routing,assigned,shards,assigned,shards,started,shard,shard,id,for,shard,routing,routing,new,array,list,assigned,shards,if,routing,initializing,routing,primary,false,if,routing,is,relocation,target,shard,routing,source,shard,get,by,allocation,id,routing,shard,id,routing,allocation,id,get,relocation,id,shard,routing,started,replica,cancel,relocation,source,shard,remove,routing,routing,changes,observer,shard,failed,routing,new,unassigned,info,unassigned,info,reason,reinitialized,primary,changed,relocate,shard,started,replica,source,shard,relocating,node,id,source,shard,get,expected,shard,size,routing,changes,observer,else,shard,routing,reinitialized,replica,reinit,replica,routing,routing,changes,observer,initialized,replica,reinitialized,routing,reinitialized,replica,return,started,shard
RoutingNodes -> public ShardRouting startShard(Logger logger, ShardRouting initializingShard, RoutingChangesObserver routingChangesObserver);1548259585;Applies the relevant logic to start an initializing shard.__Moves the initializing shard to started. If the shard is a relocation target, also removes the relocation source.__If the started shard is a primary relocation target, this also reinitializes currently initializing replicas as their_recovery source changes__@return the started shard;public ShardRouting startShard(Logger logger, ShardRouting initializingShard, RoutingChangesObserver routingChangesObserver) {_        ensureMutable()__        ShardRouting startedShard = started(initializingShard)__        logger.trace("{} marked shard as started (routing: {})", initializingShard.shardId(), initializingShard)__        routingChangesObserver.shardStarted(initializingShard, startedShard)___        if (initializingShard.relocatingNodeId() != null) {_            _            RoutingNode relocationSourceNode = node(initializingShard.relocatingNodeId())__            ShardRouting relocationSourceShard = relocationSourceNode.getByShardId(initializingShard.shardId())__            assert relocationSourceShard.isRelocationSourceOf(initializingShard)__            assert relocationSourceShard.getTargetRelocatingShard() == initializingShard : "relocation target mismatch, expected: "_                + initializingShard + " but was: " + relocationSourceShard.getTargetRelocatingShard()__            remove(relocationSourceShard)__            routingChangesObserver.relocationCompleted(relocationSourceShard)___            _            if (startedShard.primary()) {_                List<ShardRouting> assignedShards = assignedShards(startedShard.shardId())__                _                for (ShardRouting routing : new ArrayList<>(assignedShards)) {_                    if (routing.initializing() && routing.primary() == false) {_                        if (routing.isRelocationTarget()) {_                            _                            ShardRouting sourceShard = getByAllocationId(routing.shardId(), routing.allocationId().getRelocationId())__                            _                            ShardRouting startedReplica = cancelRelocation(sourceShard)__                            remove(routing)__                            routingChangesObserver.shardFailed(routing,_                                new UnassignedInfo(UnassignedInfo.Reason.REINITIALIZED, "primary changed"))__                            relocateShard(startedReplica, sourceShard.relocatingNodeId(),_                                sourceShard.getExpectedShardSize(), routingChangesObserver)__                        } else {_                            ShardRouting reinitializedReplica = reinitReplica(routing)__                            routingChangesObserver.initializedReplicaReinitialized(routing, reinitializedReplica)__                        }_                    }_                }_            }_        }_        return startedShard__    };applies,the,relevant,logic,to,start,an,initializing,shard,moves,the,initializing,shard,to,started,if,the,shard,is,a,relocation,target,also,removes,the,relocation,source,if,the,started,shard,is,a,primary,relocation,target,this,also,reinitializes,currently,initializing,replicas,as,their,recovery,source,changes,return,the,started,shard;public,shard,routing,start,shard,logger,logger,shard,routing,initializing,shard,routing,changes,observer,routing,changes,observer,ensure,mutable,shard,routing,started,shard,started,initializing,shard,logger,trace,marked,shard,as,started,routing,initializing,shard,shard,id,initializing,shard,routing,changes,observer,shard,started,initializing,shard,started,shard,if,initializing,shard,relocating,node,id,null,routing,node,relocation,source,node,node,initializing,shard,relocating,node,id,shard,routing,relocation,source,shard,relocation,source,node,get,by,shard,id,initializing,shard,shard,id,assert,relocation,source,shard,is,relocation,source,of,initializing,shard,assert,relocation,source,shard,get,target,relocating,shard,initializing,shard,relocation,target,mismatch,expected,initializing,shard,but,was,relocation,source,shard,get,target,relocating,shard,remove,relocation,source,shard,routing,changes,observer,relocation,completed,relocation,source,shard,if,started,shard,primary,list,shard,routing,assigned,shards,assigned,shards,started,shard,shard,id,for,shard,routing,routing,new,array,list,assigned,shards,if,routing,initializing,routing,primary,false,if,routing,is,relocation,target,shard,routing,source,shard,get,by,allocation,id,routing,shard,id,routing,allocation,id,get,relocation,id,shard,routing,started,replica,cancel,relocation,source,shard,remove,routing,routing,changes,observer,shard,failed,routing,new,unassigned,info,unassigned,info,reason,reinitialized,primary,changed,relocate,shard,started,replica,source,shard,relocating,node,id,source,shard,get,expected,shard,size,routing,changes,observer,else,shard,routing,reinitialized,replica,reinit,replica,routing,routing,changes,observer,initialized,replica,reinitialized,routing,reinitialized,replica,return,started,shard
RoutingNodes -> public ShardRouting startShard(Logger logger, ShardRouting initializingShard, RoutingChangesObserver routingChangesObserver);1549912434;Applies the relevant logic to start an initializing shard.__Moves the initializing shard to started. If the shard is a relocation target, also removes the relocation source.__If the started shard is a primary relocation target, this also reinitializes currently initializing replicas as their_recovery source changes__@return the started shard;public ShardRouting startShard(Logger logger, ShardRouting initializingShard, RoutingChangesObserver routingChangesObserver) {_        ensureMutable()__        ShardRouting startedShard = started(initializingShard)__        logger.trace("{} marked shard as started (routing: {})", initializingShard.shardId(), initializingShard)__        routingChangesObserver.shardStarted(initializingShard, startedShard)___        if (initializingShard.relocatingNodeId() != null) {_            _            RoutingNode relocationSourceNode = node(initializingShard.relocatingNodeId())__            ShardRouting relocationSourceShard = relocationSourceNode.getByShardId(initializingShard.shardId())__            assert relocationSourceShard.isRelocationSourceOf(initializingShard)__            assert relocationSourceShard.getTargetRelocatingShard() == initializingShard : "relocation target mismatch, expected: "_                + initializingShard + " but was: " + relocationSourceShard.getTargetRelocatingShard()__            remove(relocationSourceShard)__            routingChangesObserver.relocationCompleted(relocationSourceShard)___            _            if (startedShard.primary()) {_                List<ShardRouting> assignedShards = assignedShards(startedShard.shardId())__                _                for (ShardRouting routing : new ArrayList<>(assignedShards)) {_                    if (routing.initializing() && routing.primary() == false) {_                        if (routing.isRelocationTarget()) {_                            _                            ShardRouting sourceShard = getByAllocationId(routing.shardId(), routing.allocationId().getRelocationId())__                            _                            ShardRouting startedReplica = cancelRelocation(sourceShard)__                            remove(routing)__                            routingChangesObserver.shardFailed(routing,_                                new UnassignedInfo(UnassignedInfo.Reason.REINITIALIZED, "primary changed"))__                            relocateShard(startedReplica, sourceShard.relocatingNodeId(),_                                sourceShard.getExpectedShardSize(), routingChangesObserver)__                        } else {_                            ShardRouting reinitializedReplica = reinitReplica(routing)__                            routingChangesObserver.initializedReplicaReinitialized(routing, reinitializedReplica)__                        }_                    }_                }_            }_        }_        return startedShard__    };applies,the,relevant,logic,to,start,an,initializing,shard,moves,the,initializing,shard,to,started,if,the,shard,is,a,relocation,target,also,removes,the,relocation,source,if,the,started,shard,is,a,primary,relocation,target,this,also,reinitializes,currently,initializing,replicas,as,their,recovery,source,changes,return,the,started,shard;public,shard,routing,start,shard,logger,logger,shard,routing,initializing,shard,routing,changes,observer,routing,changes,observer,ensure,mutable,shard,routing,started,shard,started,initializing,shard,logger,trace,marked,shard,as,started,routing,initializing,shard,shard,id,initializing,shard,routing,changes,observer,shard,started,initializing,shard,started,shard,if,initializing,shard,relocating,node,id,null,routing,node,relocation,source,node,node,initializing,shard,relocating,node,id,shard,routing,relocation,source,shard,relocation,source,node,get,by,shard,id,initializing,shard,shard,id,assert,relocation,source,shard,is,relocation,source,of,initializing,shard,assert,relocation,source,shard,get,target,relocating,shard,initializing,shard,relocation,target,mismatch,expected,initializing,shard,but,was,relocation,source,shard,get,target,relocating,shard,remove,relocation,source,shard,routing,changes,observer,relocation,completed,relocation,source,shard,if,started,shard,primary,list,shard,routing,assigned,shards,assigned,shards,started,shard,shard,id,for,shard,routing,routing,new,array,list,assigned,shards,if,routing,initializing,routing,primary,false,if,routing,is,relocation,target,shard,routing,source,shard,get,by,allocation,id,routing,shard,id,routing,allocation,id,get,relocation,id,shard,routing,started,replica,cancel,relocation,source,shard,remove,routing,routing,changes,observer,shard,failed,routing,new,unassigned,info,unassigned,info,reason,reinitialized,primary,changed,relocate,shard,started,replica,source,shard,relocating,node,id,source,shard,get,expected,shard,size,routing,changes,observer,else,shard,routing,reinitialized,replica,reinit,replica,routing,routing,changes,observer,initialized,replica,reinitialized,routing,reinitialized,replica,return,started,shard
RoutingNodes -> public List<ShardRouting> assignedShards(ShardId shardId);1524684173;Returns all shards that are not in the state UNASSIGNED with the same shard_ID as the given shard.;public List<ShardRouting> assignedShards(ShardId shardId) {_        final List<ShardRouting> replicaSet = assignedShards.get(shardId)__        return replicaSet == null ? EMPTY : Collections.unmodifiableList(replicaSet)__    };returns,all,shards,that,are,not,in,the,state,unassigned,with,the,same,shard,id,as,the,given,shard;public,list,shard,routing,assigned,shards,shard,id,shard,id,final,list,shard,routing,replica,set,assigned,shards,get,shard,id,return,replica,set,null,empty,collections,unmodifiable,list,replica,set
RoutingNodes -> public List<ShardRouting> assignedShards(ShardId shardId);1540847035;Returns all shards that are not in the state UNASSIGNED with the same shard_ID as the given shard.;public List<ShardRouting> assignedShards(ShardId shardId) {_        final List<ShardRouting> replicaSet = assignedShards.get(shardId)__        return replicaSet == null ? EMPTY : Collections.unmodifiableList(replicaSet)__    };returns,all,shards,that,are,not,in,the,state,unassigned,with,the,same,shard,id,as,the,given,shard;public,list,shard,routing,assigned,shards,shard,id,shard,id,final,list,shard,routing,replica,set,assigned,shards,get,shard,id,return,replica,set,null,empty,collections,unmodifiable,list,replica,set
RoutingNodes -> public List<ShardRouting> assignedShards(ShardId shardId);1541446827;Returns all shards that are not in the state UNASSIGNED with the same shard_ID as the given shard.;public List<ShardRouting> assignedShards(ShardId shardId) {_        final List<ShardRouting> replicaSet = assignedShards.get(shardId)__        return replicaSet == null ? EMPTY : Collections.unmodifiableList(replicaSet)__    };returns,all,shards,that,are,not,in,the,state,unassigned,with,the,same,shard,id,as,the,given,shard;public,list,shard,routing,assigned,shards,shard,id,shard,id,final,list,shard,routing,replica,set,assigned,shards,get,shard,id,return,replica,set,null,empty,collections,unmodifiable,list,replica,set
RoutingNodes -> public List<ShardRouting> assignedShards(ShardId shardId);1548259585;Returns all shards that are not in the state UNASSIGNED with the same shard_ID as the given shard.;public List<ShardRouting> assignedShards(ShardId shardId) {_        final List<ShardRouting> replicaSet = assignedShards.get(shardId)__        return replicaSet == null ? EMPTY : Collections.unmodifiableList(replicaSet)__    };returns,all,shards,that,are,not,in,the,state,unassigned,with,the,same,shard,id,as,the,given,shard;public,list,shard,routing,assigned,shards,shard,id,shard,id,final,list,shard,routing,replica,set,assigned,shards,get,shard,id,return,replica,set,null,empty,collections,unmodifiable,list,replica,set
RoutingNodes -> public List<ShardRouting> assignedShards(ShardId shardId);1549912434;Returns all shards that are not in the state UNASSIGNED with the same shard_ID as the given shard.;public List<ShardRouting> assignedShards(ShardId shardId) {_        final List<ShardRouting> replicaSet = assignedShards.get(shardId)__        return replicaSet == null ? EMPTY : Collections.unmodifiableList(replicaSet)__    };returns,all,shards,that,are,not,in,the,state,unassigned,with,the,same,shard,id,as,the,given,shard;public,list,shard,routing,assigned,shards,shard,id,shard,id,final,list,shard,routing,replica,set,assigned,shards,get,shard,id,return,replica,set,null,empty,collections,unmodifiable,list,replica,set
RoutingNodes -> UnassignedShards -> UnassignedIterator -> public ShardRouting initialize(String nodeId, @Nullable String existingAllocationId, long expectedShardSize,                                            RoutingChangesObserver routingChangesObserver);1524684173;Initializes the current unassigned shard and moves it from the unassigned list.__@param existingAllocationId allocation id to use. If null, a fresh allocation id is generated.;public ShardRouting initialize(String nodeId, @Nullable String existingAllocationId, long expectedShardSize,_                                           RoutingChangesObserver routingChangesObserver) {_                nodes.ensureMutable()__                innerRemove()__                return nodes.initializeShard(current, nodeId, existingAllocationId, expectedShardSize, routingChangesObserver)__            };initializes,the,current,unassigned,shard,and,moves,it,from,the,unassigned,list,param,existing,allocation,id,allocation,id,to,use,if,null,a,fresh,allocation,id,is,generated;public,shard,routing,initialize,string,node,id,nullable,string,existing,allocation,id,long,expected,shard,size,routing,changes,observer,routing,changes,observer,nodes,ensure,mutable,inner,remove,return,nodes,initialize,shard,current,node,id,existing,allocation,id,expected,shard,size,routing,changes,observer
RoutingNodes -> UnassignedShards -> UnassignedIterator -> public ShardRouting initialize(String nodeId, @Nullable String existingAllocationId, long expectedShardSize,                                            RoutingChangesObserver routingChangesObserver);1540847035;Initializes the current unassigned shard and moves it from the unassigned list.__@param existingAllocationId allocation id to use. If null, a fresh allocation id is generated.;public ShardRouting initialize(String nodeId, @Nullable String existingAllocationId, long expectedShardSize,_                                           RoutingChangesObserver routingChangesObserver) {_                nodes.ensureMutable()__                innerRemove()__                return nodes.initializeShard(current, nodeId, existingAllocationId, expectedShardSize, routingChangesObserver)__            };initializes,the,current,unassigned,shard,and,moves,it,from,the,unassigned,list,param,existing,allocation,id,allocation,id,to,use,if,null,a,fresh,allocation,id,is,generated;public,shard,routing,initialize,string,node,id,nullable,string,existing,allocation,id,long,expected,shard,size,routing,changes,observer,routing,changes,observer,nodes,ensure,mutable,inner,remove,return,nodes,initialize,shard,current,node,id,existing,allocation,id,expected,shard,size,routing,changes,observer
RoutingNodes -> UnassignedShards -> UnassignedIterator -> public ShardRouting initialize(String nodeId, @Nullable String existingAllocationId, long expectedShardSize,                                            RoutingChangesObserver routingChangesObserver);1541446827;Initializes the current unassigned shard and moves it from the unassigned list.__@param existingAllocationId allocation id to use. If null, a fresh allocation id is generated.;public ShardRouting initialize(String nodeId, @Nullable String existingAllocationId, long expectedShardSize,_                                           RoutingChangesObserver routingChangesObserver) {_                nodes.ensureMutable()__                innerRemove()__                return nodes.initializeShard(current, nodeId, existingAllocationId, expectedShardSize, routingChangesObserver)__            };initializes,the,current,unassigned,shard,and,moves,it,from,the,unassigned,list,param,existing,allocation,id,allocation,id,to,use,if,null,a,fresh,allocation,id,is,generated;public,shard,routing,initialize,string,node,id,nullable,string,existing,allocation,id,long,expected,shard,size,routing,changes,observer,routing,changes,observer,nodes,ensure,mutable,inner,remove,return,nodes,initialize,shard,current,node,id,existing,allocation,id,expected,shard,size,routing,changes,observer
RoutingNodes -> UnassignedShards -> UnassignedIterator -> public ShardRouting initialize(String nodeId, @Nullable String existingAllocationId, long expectedShardSize,                                            RoutingChangesObserver routingChangesObserver);1548259585;Initializes the current unassigned shard and moves it from the unassigned list.__@param existingAllocationId allocation id to use. If null, a fresh allocation id is generated.;public ShardRouting initialize(String nodeId, @Nullable String existingAllocationId, long expectedShardSize,_                                           RoutingChangesObserver routingChangesObserver) {_                nodes.ensureMutable()__                innerRemove()__                return nodes.initializeShard(current, nodeId, existingAllocationId, expectedShardSize, routingChangesObserver)__            };initializes,the,current,unassigned,shard,and,moves,it,from,the,unassigned,list,param,existing,allocation,id,allocation,id,to,use,if,null,a,fresh,allocation,id,is,generated;public,shard,routing,initialize,string,node,id,nullable,string,existing,allocation,id,long,expected,shard,size,routing,changes,observer,routing,changes,observer,nodes,ensure,mutable,inner,remove,return,nodes,initialize,shard,current,node,id,existing,allocation,id,expected,shard,size,routing,changes,observer
RoutingNodes -> UnassignedShards -> UnassignedIterator -> public ShardRouting initialize(String nodeId, @Nullable String existingAllocationId, long expectedShardSize,                                            RoutingChangesObserver routingChangesObserver);1549912434;Initializes the current unassigned shard and moves it from the unassigned list.__@param existingAllocationId allocation id to use. If null, a fresh allocation id is generated.;public ShardRouting initialize(String nodeId, @Nullable String existingAllocationId, long expectedShardSize,_                                           RoutingChangesObserver routingChangesObserver) {_                nodes.ensureMutable()__                innerRemove()__                return nodes.initializeShard(current, nodeId, existingAllocationId, expectedShardSize, routingChangesObserver)__            };initializes,the,current,unassigned,shard,and,moves,it,from,the,unassigned,list,param,existing,allocation,id,allocation,id,to,use,if,null,a,fresh,allocation,id,is,generated;public,shard,routing,initialize,string,node,id,nullable,string,existing,allocation,id,long,expected,shard,size,routing,changes,observer,routing,changes,observer,nodes,ensure,mutable,inner,remove,return,nodes,initialize,shard,current,node,id,existing,allocation,id,expected,shard,size,routing,changes,observer
RoutingNodes -> public static boolean assertShardStats(RoutingNodes routingNodes);1524684173;Calculates RoutingNodes statistics by iterating over all {@link ShardRouting}s_in the cluster to ensure the book-keeping is correct._For performance reasons, this should only be called from asserts__@return this method always returns <code>true</code> or throws an assertion error. If assertion are not enabled_this method does nothing.;public static boolean assertShardStats(RoutingNodes routingNodes) {_        if (!Assertions.ENABLED) {_            return true__        }_        int unassignedPrimaryCount = 0__        int unassignedIgnoredPrimaryCount = 0__        int inactivePrimaryCount = 0__        int inactiveShardCount = 0__        int relocating = 0__        Map<Index, Integer> indicesAndShards = new HashMap<>()__        for (RoutingNode node : routingNodes) {_            for (ShardRouting shard : node) {_                if (shard.initializing() && shard.relocatingNodeId() == null) {_                    inactiveShardCount++__                    if (shard.primary()) {_                        inactivePrimaryCount++__                    }_                }_                if (shard.relocating()) {_                    relocating++__                }_                Integer i = indicesAndShards.get(shard.index())__                if (i == null) {_                    i = shard.id()__                }_                indicesAndShards.put(shard.index(), Math.max(i, shard.id()))__            }_        }__        _        Set<Map.Entry<Index, Integer>> entries = indicesAndShards.entrySet()___        final Map<ShardId, HashSet<ShardRouting>> shardsByShardId = new HashMap<>()__        for (final RoutingNode routingNode: routingNodes) {_            for (final ShardRouting shardRouting : routingNode) {_                final HashSet<ShardRouting> shards =_                        shardsByShardId.computeIfAbsent(new ShardId(shardRouting.index(), shardRouting.id()), k -> new HashSet<>())__                shards.add(shardRouting)__            }_        }__        for (final Map.Entry<Index, Integer> e : entries) {_            final Index index = e.getKey()__            for (int i = 0_ i < e.getValue()_ i++) {_                final ShardId shardId = new ShardId(index, i)__                final HashSet<ShardRouting> shards = shardsByShardId.get(shardId)__                final List<ShardRouting> mutableShardRoutings = routingNodes.assignedShards(shardId)__                assert (shards == null && mutableShardRoutings.size() == 0)_                        || (shards != null && shards.size() == mutableShardRoutings.size() && shards.containsAll(mutableShardRoutings))__            }_        }__        for (ShardRouting shard : routingNodes.unassigned()) {_            if (shard.primary()) {_                unassignedPrimaryCount++__            }_        }__        for (ShardRouting shard : routingNodes.unassigned().ignored()) {_            if (shard.primary()) {_                unassignedIgnoredPrimaryCount++__            }_        }__        for (Map.Entry<String, Recoveries> recoveries : routingNodes.recoveriesPerNode.entrySet()) {_            String node = recoveries.getKey()__            final Recoveries value = recoveries.getValue()__            int incoming = 0__            int outgoing = 0__            RoutingNode routingNode = routingNodes.nodesToShards.get(node)__            if (routingNode != null) { _                for (ShardRouting routing : routingNode) {_                    if (routing.initializing()) {_                        incoming++__                    }_                    if (routing.primary() && routing.isRelocationTarget() == false) {_                        for (ShardRouting assigned : routingNodes.assignedShards.get(routing.shardId())) {_                            if (assigned.initializing() && assigned.recoverySource().getType() == RecoverySource.Type.PEER) {_                                outgoing++__                            }_                        }_                    }_                }_            }_            assert incoming == value.incoming : incoming + " != " + value.incoming + " node: " + routingNode__            assert outgoing == value.outgoing : outgoing + " != " + value.outgoing + " node: " + routingNode__        }___        assert unassignedPrimaryCount == routingNodes.unassignedShards.getNumPrimaries() :_                "Unassigned primaries is [" + unassignedPrimaryCount + "] but RoutingNodes returned unassigned primaries [" + routingNodes.unassigned().getNumPrimaries() + "]"__        assert unassignedIgnoredPrimaryCount == routingNodes.unassignedShards.getNumIgnoredPrimaries() :_                "Unassigned ignored primaries is [" + unassignedIgnoredPrimaryCount + "] but RoutingNodes returned unassigned ignored primaries [" + routingNodes.unassigned().getNumIgnoredPrimaries() + "]"__        assert inactivePrimaryCount == routingNodes.inactivePrimaryCount :_                "Inactive Primary count [" + inactivePrimaryCount + "] but RoutingNodes returned inactive primaries [" + routingNodes.inactivePrimaryCount + "]"__        assert inactiveShardCount == routingNodes.inactiveShardCount :_                "Inactive Shard count [" + inactiveShardCount + "] but RoutingNodes returned inactive shards [" + routingNodes.inactiveShardCount + "]"__        assert routingNodes.getRelocatingShardCount() == relocating : "Relocating shards mismatch [" + routingNodes.getRelocatingShardCount() + "] but expected [" + relocating + "]"___        return true__    };calculates,routing,nodes,statistics,by,iterating,over,all,link,shard,routing,s,in,the,cluster,to,ensure,the,book,keeping,is,correct,for,performance,reasons,this,should,only,be,called,from,asserts,return,this,method,always,returns,code,true,code,or,throws,an,assertion,error,if,assertion,are,not,enabled,this,method,does,nothing;public,static,boolean,assert,shard,stats,routing,nodes,routing,nodes,if,assertions,enabled,return,true,int,unassigned,primary,count,0,int,unassigned,ignored,primary,count,0,int,inactive,primary,count,0,int,inactive,shard,count,0,int,relocating,0,map,index,integer,indices,and,shards,new,hash,map,for,routing,node,node,routing,nodes,for,shard,routing,shard,node,if,shard,initializing,shard,relocating,node,id,null,inactive,shard,count,if,shard,primary,inactive,primary,count,if,shard,relocating,relocating,integer,i,indices,and,shards,get,shard,index,if,i,null,i,shard,id,indices,and,shards,put,shard,index,math,max,i,shard,id,set,map,entry,index,integer,entries,indices,and,shards,entry,set,final,map,shard,id,hash,set,shard,routing,shards,by,shard,id,new,hash,map,for,final,routing,node,routing,node,routing,nodes,for,final,shard,routing,shard,routing,routing,node,final,hash,set,shard,routing,shards,shards,by,shard,id,compute,if,absent,new,shard,id,shard,routing,index,shard,routing,id,k,new,hash,set,shards,add,shard,routing,for,final,map,entry,index,integer,e,entries,final,index,index,e,get,key,for,int,i,0,i,e,get,value,i,final,shard,id,shard,id,new,shard,id,index,i,final,hash,set,shard,routing,shards,shards,by,shard,id,get,shard,id,final,list,shard,routing,mutable,shard,routings,routing,nodes,assigned,shards,shard,id,assert,shards,null,mutable,shard,routings,size,0,shards,null,shards,size,mutable,shard,routings,size,shards,contains,all,mutable,shard,routings,for,shard,routing,shard,routing,nodes,unassigned,if,shard,primary,unassigned,primary,count,for,shard,routing,shard,routing,nodes,unassigned,ignored,if,shard,primary,unassigned,ignored,primary,count,for,map,entry,string,recoveries,recoveries,routing,nodes,recoveries,per,node,entry,set,string,node,recoveries,get,key,final,recoveries,value,recoveries,get,value,int,incoming,0,int,outgoing,0,routing,node,routing,node,routing,nodes,nodes,to,shards,get,node,if,routing,node,null,for,shard,routing,routing,routing,node,if,routing,initializing,incoming,if,routing,primary,routing,is,relocation,target,false,for,shard,routing,assigned,routing,nodes,assigned,shards,get,routing,shard,id,if,assigned,initializing,assigned,recovery,source,get,type,recovery,source,type,peer,outgoing,assert,incoming,value,incoming,incoming,value,incoming,node,routing,node,assert,outgoing,value,outgoing,outgoing,value,outgoing,node,routing,node,assert,unassigned,primary,count,routing,nodes,unassigned,shards,get,num,primaries,unassigned,primaries,is,unassigned,primary,count,but,routing,nodes,returned,unassigned,primaries,routing,nodes,unassigned,get,num,primaries,assert,unassigned,ignored,primary,count,routing,nodes,unassigned,shards,get,num,ignored,primaries,unassigned,ignored,primaries,is,unassigned,ignored,primary,count,but,routing,nodes,returned,unassigned,ignored,primaries,routing,nodes,unassigned,get,num,ignored,primaries,assert,inactive,primary,count,routing,nodes,inactive,primary,count,inactive,primary,count,inactive,primary,count,but,routing,nodes,returned,inactive,primaries,routing,nodes,inactive,primary,count,assert,inactive,shard,count,routing,nodes,inactive,shard,count,inactive,shard,count,inactive,shard,count,but,routing,nodes,returned,inactive,shards,routing,nodes,inactive,shard,count,assert,routing,nodes,get,relocating,shard,count,relocating,relocating,shards,mismatch,routing,nodes,get,relocating,shard,count,but,expected,relocating,return,true
RoutingNodes -> public static boolean assertShardStats(RoutingNodes routingNodes);1540847035;Calculates RoutingNodes statistics by iterating over all {@link ShardRouting}s_in the cluster to ensure the book-keeping is correct._For performance reasons, this should only be called from asserts__@return this method always returns <code>true</code> or throws an assertion error. If assertion are not enabled_this method does nothing.;public static boolean assertShardStats(RoutingNodes routingNodes) {_        if (!Assertions.ENABLED) {_            return true__        }_        int unassignedPrimaryCount = 0__        int unassignedIgnoredPrimaryCount = 0__        int inactivePrimaryCount = 0__        int inactiveShardCount = 0__        int relocating = 0__        Map<Index, Integer> indicesAndShards = new HashMap<>()__        for (RoutingNode node : routingNodes) {_            for (ShardRouting shard : node) {_                if (shard.initializing() && shard.relocatingNodeId() == null) {_                    inactiveShardCount++__                    if (shard.primary()) {_                        inactivePrimaryCount++__                    }_                }_                if (shard.relocating()) {_                    relocating++__                }_                Integer i = indicesAndShards.get(shard.index())__                if (i == null) {_                    i = shard.id()__                }_                indicesAndShards.put(shard.index(), Math.max(i, shard.id()))__            }_        }__        _        Set<Map.Entry<Index, Integer>> entries = indicesAndShards.entrySet()___        final Map<ShardId, HashSet<ShardRouting>> shardsByShardId = new HashMap<>()__        for (final RoutingNode routingNode: routingNodes) {_            for (final ShardRouting shardRouting : routingNode) {_                final HashSet<ShardRouting> shards =_                        shardsByShardId.computeIfAbsent(new ShardId(shardRouting.index(), shardRouting.id()), k -> new HashSet<>())__                shards.add(shardRouting)__            }_        }__        for (final Map.Entry<Index, Integer> e : entries) {_            final Index index = e.getKey()__            for (int i = 0_ i < e.getValue()_ i++) {_                final ShardId shardId = new ShardId(index, i)__                final HashSet<ShardRouting> shards = shardsByShardId.get(shardId)__                final List<ShardRouting> mutableShardRoutings = routingNodes.assignedShards(shardId)__                assert (shards == null && mutableShardRoutings.size() == 0)_                        || (shards != null && shards.size() == mutableShardRoutings.size() && shards.containsAll(mutableShardRoutings))__            }_        }__        for (ShardRouting shard : routingNodes.unassigned()) {_            if (shard.primary()) {_                unassignedPrimaryCount++__            }_        }__        for (ShardRouting shard : routingNodes.unassigned().ignored()) {_            if (shard.primary()) {_                unassignedIgnoredPrimaryCount++__            }_        }__        for (Map.Entry<String, Recoveries> recoveries : routingNodes.recoveriesPerNode.entrySet()) {_            String node = recoveries.getKey()__            final Recoveries value = recoveries.getValue()__            int incoming = 0__            int outgoing = 0__            RoutingNode routingNode = routingNodes.nodesToShards.get(node)__            if (routingNode != null) { _                for (ShardRouting routing : routingNode) {_                    if (routing.initializing()) {_                        incoming++__                    }_                    if (routing.primary() && routing.isRelocationTarget() == false) {_                        for (ShardRouting assigned : routingNodes.assignedShards.get(routing.shardId())) {_                            if (assigned.initializing() && assigned.recoverySource().getType() == RecoverySource.Type.PEER) {_                                outgoing++__                            }_                        }_                    }_                }_            }_            assert incoming == value.incoming : incoming + " != " + value.incoming + " node: " + routingNode__            assert outgoing == value.outgoing : outgoing + " != " + value.outgoing + " node: " + routingNode__        }___        assert unassignedPrimaryCount == routingNodes.unassignedShards.getNumPrimaries() :_                "Unassigned primaries is [" + unassignedPrimaryCount + "] but RoutingNodes returned unassigned primaries [" +_                    routingNodes.unassigned().getNumPrimaries() + "]"__        assert unassignedIgnoredPrimaryCount == routingNodes.unassignedShards.getNumIgnoredPrimaries() :_                "Unassigned ignored primaries is [" + unassignedIgnoredPrimaryCount +_                    "] but RoutingNodes returned unassigned ignored primaries [" + routingNodes.unassigned().getNumIgnoredPrimaries() + "]"__        assert inactivePrimaryCount == routingNodes.inactivePrimaryCount :_                "Inactive Primary count [" + inactivePrimaryCount + "] but RoutingNodes returned inactive primaries [" +_                    routingNodes.inactivePrimaryCount + "]"__        assert inactiveShardCount == routingNodes.inactiveShardCount :_                "Inactive Shard count [" + inactiveShardCount + "] but RoutingNodes returned inactive shards [" +_                    routingNodes.inactiveShardCount + "]"__        assert routingNodes.getRelocatingShardCount() == relocating : "Relocating shards mismatch [" +_            routingNodes.getRelocatingShardCount() + "] but expected [" + relocating + "]"___        return true__    };calculates,routing,nodes,statistics,by,iterating,over,all,link,shard,routing,s,in,the,cluster,to,ensure,the,book,keeping,is,correct,for,performance,reasons,this,should,only,be,called,from,asserts,return,this,method,always,returns,code,true,code,or,throws,an,assertion,error,if,assertion,are,not,enabled,this,method,does,nothing;public,static,boolean,assert,shard,stats,routing,nodes,routing,nodes,if,assertions,enabled,return,true,int,unassigned,primary,count,0,int,unassigned,ignored,primary,count,0,int,inactive,primary,count,0,int,inactive,shard,count,0,int,relocating,0,map,index,integer,indices,and,shards,new,hash,map,for,routing,node,node,routing,nodes,for,shard,routing,shard,node,if,shard,initializing,shard,relocating,node,id,null,inactive,shard,count,if,shard,primary,inactive,primary,count,if,shard,relocating,relocating,integer,i,indices,and,shards,get,shard,index,if,i,null,i,shard,id,indices,and,shards,put,shard,index,math,max,i,shard,id,set,map,entry,index,integer,entries,indices,and,shards,entry,set,final,map,shard,id,hash,set,shard,routing,shards,by,shard,id,new,hash,map,for,final,routing,node,routing,node,routing,nodes,for,final,shard,routing,shard,routing,routing,node,final,hash,set,shard,routing,shards,shards,by,shard,id,compute,if,absent,new,shard,id,shard,routing,index,shard,routing,id,k,new,hash,set,shards,add,shard,routing,for,final,map,entry,index,integer,e,entries,final,index,index,e,get,key,for,int,i,0,i,e,get,value,i,final,shard,id,shard,id,new,shard,id,index,i,final,hash,set,shard,routing,shards,shards,by,shard,id,get,shard,id,final,list,shard,routing,mutable,shard,routings,routing,nodes,assigned,shards,shard,id,assert,shards,null,mutable,shard,routings,size,0,shards,null,shards,size,mutable,shard,routings,size,shards,contains,all,mutable,shard,routings,for,shard,routing,shard,routing,nodes,unassigned,if,shard,primary,unassigned,primary,count,for,shard,routing,shard,routing,nodes,unassigned,ignored,if,shard,primary,unassigned,ignored,primary,count,for,map,entry,string,recoveries,recoveries,routing,nodes,recoveries,per,node,entry,set,string,node,recoveries,get,key,final,recoveries,value,recoveries,get,value,int,incoming,0,int,outgoing,0,routing,node,routing,node,routing,nodes,nodes,to,shards,get,node,if,routing,node,null,for,shard,routing,routing,routing,node,if,routing,initializing,incoming,if,routing,primary,routing,is,relocation,target,false,for,shard,routing,assigned,routing,nodes,assigned,shards,get,routing,shard,id,if,assigned,initializing,assigned,recovery,source,get,type,recovery,source,type,peer,outgoing,assert,incoming,value,incoming,incoming,value,incoming,node,routing,node,assert,outgoing,value,outgoing,outgoing,value,outgoing,node,routing,node,assert,unassigned,primary,count,routing,nodes,unassigned,shards,get,num,primaries,unassigned,primaries,is,unassigned,primary,count,but,routing,nodes,returned,unassigned,primaries,routing,nodes,unassigned,get,num,primaries,assert,unassigned,ignored,primary,count,routing,nodes,unassigned,shards,get,num,ignored,primaries,unassigned,ignored,primaries,is,unassigned,ignored,primary,count,but,routing,nodes,returned,unassigned,ignored,primaries,routing,nodes,unassigned,get,num,ignored,primaries,assert,inactive,primary,count,routing,nodes,inactive,primary,count,inactive,primary,count,inactive,primary,count,but,routing,nodes,returned,inactive,primaries,routing,nodes,inactive,primary,count,assert,inactive,shard,count,routing,nodes,inactive,shard,count,inactive,shard,count,inactive,shard,count,but,routing,nodes,returned,inactive,shards,routing,nodes,inactive,shard,count,assert,routing,nodes,get,relocating,shard,count,relocating,relocating,shards,mismatch,routing,nodes,get,relocating,shard,count,but,expected,relocating,return,true
RoutingNodes -> public static boolean assertShardStats(RoutingNodes routingNodes);1541446827;Calculates RoutingNodes statistics by iterating over all {@link ShardRouting}s_in the cluster to ensure the book-keeping is correct._For performance reasons, this should only be called from asserts__@return this method always returns <code>true</code> or throws an assertion error. If assertion are not enabled_this method does nothing.;public static boolean assertShardStats(RoutingNodes routingNodes) {_        if (!Assertions.ENABLED) {_            return true__        }_        int unassignedPrimaryCount = 0__        int unassignedIgnoredPrimaryCount = 0__        int inactivePrimaryCount = 0__        int inactiveShardCount = 0__        int relocating = 0__        Map<Index, Integer> indicesAndShards = new HashMap<>()__        for (RoutingNode node : routingNodes) {_            for (ShardRouting shard : node) {_                if (shard.initializing() && shard.relocatingNodeId() == null) {_                    inactiveShardCount++__                    if (shard.primary()) {_                        inactivePrimaryCount++__                    }_                }_                if (shard.relocating()) {_                    relocating++__                }_                Integer i = indicesAndShards.get(shard.index())__                if (i == null) {_                    i = shard.id()__                }_                indicesAndShards.put(shard.index(), Math.max(i, shard.id()))__            }_        }__        _        Set<Map.Entry<Index, Integer>> entries = indicesAndShards.entrySet()___        final Map<ShardId, HashSet<ShardRouting>> shardsByShardId = new HashMap<>()__        for (final RoutingNode routingNode: routingNodes) {_            for (final ShardRouting shardRouting : routingNode) {_                final HashSet<ShardRouting> shards =_                        shardsByShardId.computeIfAbsent(new ShardId(shardRouting.index(), shardRouting.id()), k -> new HashSet<>())__                shards.add(shardRouting)__            }_        }__        for (final Map.Entry<Index, Integer> e : entries) {_            final Index index = e.getKey()__            for (int i = 0_ i < e.getValue()_ i++) {_                final ShardId shardId = new ShardId(index, i)__                final HashSet<ShardRouting> shards = shardsByShardId.get(shardId)__                final List<ShardRouting> mutableShardRoutings = routingNodes.assignedShards(shardId)__                assert (shards == null && mutableShardRoutings.size() == 0)_                        || (shards != null && shards.size() == mutableShardRoutings.size() && shards.containsAll(mutableShardRoutings))__            }_        }__        for (ShardRouting shard : routingNodes.unassigned()) {_            if (shard.primary()) {_                unassignedPrimaryCount++__            }_        }__        for (ShardRouting shard : routingNodes.unassigned().ignored()) {_            if (shard.primary()) {_                unassignedIgnoredPrimaryCount++__            }_        }__        for (Map.Entry<String, Recoveries> recoveries : routingNodes.recoveriesPerNode.entrySet()) {_            String node = recoveries.getKey()__            final Recoveries value = recoveries.getValue()__            int incoming = 0__            int outgoing = 0__            RoutingNode routingNode = routingNodes.nodesToShards.get(node)__            if (routingNode != null) { _                for (ShardRouting routing : routingNode) {_                    if (routing.initializing()) {_                        incoming++__                    }_                    if (routing.primary() && routing.isRelocationTarget() == false) {_                        for (ShardRouting assigned : routingNodes.assignedShards.get(routing.shardId())) {_                            if (assigned.initializing() && assigned.recoverySource().getType() == RecoverySource.Type.PEER) {_                                outgoing++__                            }_                        }_                    }_                }_            }_            assert incoming == value.incoming : incoming + " != " + value.incoming + " node: " + routingNode__            assert outgoing == value.outgoing : outgoing + " != " + value.outgoing + " node: " + routingNode__        }___        assert unassignedPrimaryCount == routingNodes.unassignedShards.getNumPrimaries() :_                "Unassigned primaries is [" + unassignedPrimaryCount + "] but RoutingNodes returned unassigned primaries [" +_                    routingNodes.unassigned().getNumPrimaries() + "]"__        assert unassignedIgnoredPrimaryCount == routingNodes.unassignedShards.getNumIgnoredPrimaries() :_                "Unassigned ignored primaries is [" + unassignedIgnoredPrimaryCount +_                    "] but RoutingNodes returned unassigned ignored primaries [" + routingNodes.unassigned().getNumIgnoredPrimaries() + "]"__        assert inactivePrimaryCount == routingNodes.inactivePrimaryCount :_                "Inactive Primary count [" + inactivePrimaryCount + "] but RoutingNodes returned inactive primaries [" +_                    routingNodes.inactivePrimaryCount + "]"__        assert inactiveShardCount == routingNodes.inactiveShardCount :_                "Inactive Shard count [" + inactiveShardCount + "] but RoutingNodes returned inactive shards [" +_                    routingNodes.inactiveShardCount + "]"__        assert routingNodes.getRelocatingShardCount() == relocating : "Relocating shards mismatch [" +_            routingNodes.getRelocatingShardCount() + "] but expected [" + relocating + "]"___        return true__    };calculates,routing,nodes,statistics,by,iterating,over,all,link,shard,routing,s,in,the,cluster,to,ensure,the,book,keeping,is,correct,for,performance,reasons,this,should,only,be,called,from,asserts,return,this,method,always,returns,code,true,code,or,throws,an,assertion,error,if,assertion,are,not,enabled,this,method,does,nothing;public,static,boolean,assert,shard,stats,routing,nodes,routing,nodes,if,assertions,enabled,return,true,int,unassigned,primary,count,0,int,unassigned,ignored,primary,count,0,int,inactive,primary,count,0,int,inactive,shard,count,0,int,relocating,0,map,index,integer,indices,and,shards,new,hash,map,for,routing,node,node,routing,nodes,for,shard,routing,shard,node,if,shard,initializing,shard,relocating,node,id,null,inactive,shard,count,if,shard,primary,inactive,primary,count,if,shard,relocating,relocating,integer,i,indices,and,shards,get,shard,index,if,i,null,i,shard,id,indices,and,shards,put,shard,index,math,max,i,shard,id,set,map,entry,index,integer,entries,indices,and,shards,entry,set,final,map,shard,id,hash,set,shard,routing,shards,by,shard,id,new,hash,map,for,final,routing,node,routing,node,routing,nodes,for,final,shard,routing,shard,routing,routing,node,final,hash,set,shard,routing,shards,shards,by,shard,id,compute,if,absent,new,shard,id,shard,routing,index,shard,routing,id,k,new,hash,set,shards,add,shard,routing,for,final,map,entry,index,integer,e,entries,final,index,index,e,get,key,for,int,i,0,i,e,get,value,i,final,shard,id,shard,id,new,shard,id,index,i,final,hash,set,shard,routing,shards,shards,by,shard,id,get,shard,id,final,list,shard,routing,mutable,shard,routings,routing,nodes,assigned,shards,shard,id,assert,shards,null,mutable,shard,routings,size,0,shards,null,shards,size,mutable,shard,routings,size,shards,contains,all,mutable,shard,routings,for,shard,routing,shard,routing,nodes,unassigned,if,shard,primary,unassigned,primary,count,for,shard,routing,shard,routing,nodes,unassigned,ignored,if,shard,primary,unassigned,ignored,primary,count,for,map,entry,string,recoveries,recoveries,routing,nodes,recoveries,per,node,entry,set,string,node,recoveries,get,key,final,recoveries,value,recoveries,get,value,int,incoming,0,int,outgoing,0,routing,node,routing,node,routing,nodes,nodes,to,shards,get,node,if,routing,node,null,for,shard,routing,routing,routing,node,if,routing,initializing,incoming,if,routing,primary,routing,is,relocation,target,false,for,shard,routing,assigned,routing,nodes,assigned,shards,get,routing,shard,id,if,assigned,initializing,assigned,recovery,source,get,type,recovery,source,type,peer,outgoing,assert,incoming,value,incoming,incoming,value,incoming,node,routing,node,assert,outgoing,value,outgoing,outgoing,value,outgoing,node,routing,node,assert,unassigned,primary,count,routing,nodes,unassigned,shards,get,num,primaries,unassigned,primaries,is,unassigned,primary,count,but,routing,nodes,returned,unassigned,primaries,routing,nodes,unassigned,get,num,primaries,assert,unassigned,ignored,primary,count,routing,nodes,unassigned,shards,get,num,ignored,primaries,unassigned,ignored,primaries,is,unassigned,ignored,primary,count,but,routing,nodes,returned,unassigned,ignored,primaries,routing,nodes,unassigned,get,num,ignored,primaries,assert,inactive,primary,count,routing,nodes,inactive,primary,count,inactive,primary,count,inactive,primary,count,but,routing,nodes,returned,inactive,primaries,routing,nodes,inactive,primary,count,assert,inactive,shard,count,routing,nodes,inactive,shard,count,inactive,shard,count,inactive,shard,count,but,routing,nodes,returned,inactive,shards,routing,nodes,inactive,shard,count,assert,routing,nodes,get,relocating,shard,count,relocating,relocating,shards,mismatch,routing,nodes,get,relocating,shard,count,but,expected,relocating,return,true
RoutingNodes -> public static boolean assertShardStats(RoutingNodes routingNodes);1548259585;Calculates RoutingNodes statistics by iterating over all {@link ShardRouting}s_in the cluster to ensure the book-keeping is correct._For performance reasons, this should only be called from asserts__@return this method always returns <code>true</code> or throws an assertion error. If assertion are not enabled_this method does nothing.;public static boolean assertShardStats(RoutingNodes routingNodes) {_        if (!Assertions.ENABLED) {_            return true__        }_        int unassignedPrimaryCount = 0__        int unassignedIgnoredPrimaryCount = 0__        int inactivePrimaryCount = 0__        int inactiveShardCount = 0__        int relocating = 0__        Map<Index, Integer> indicesAndShards = new HashMap<>()__        for (RoutingNode node : routingNodes) {_            for (ShardRouting shard : node) {_                if (shard.initializing() && shard.relocatingNodeId() == null) {_                    inactiveShardCount++__                    if (shard.primary()) {_                        inactivePrimaryCount++__                    }_                }_                if (shard.relocating()) {_                    relocating++__                }_                Integer i = indicesAndShards.get(shard.index())__                if (i == null) {_                    i = shard.id()__                }_                indicesAndShards.put(shard.index(), Math.max(i, shard.id()))__            }_        }__        _        Set<Map.Entry<Index, Integer>> entries = indicesAndShards.entrySet()___        final Map<ShardId, HashSet<ShardRouting>> shardsByShardId = new HashMap<>()__        for (final RoutingNode routingNode: routingNodes) {_            for (final ShardRouting shardRouting : routingNode) {_                final HashSet<ShardRouting> shards =_                        shardsByShardId.computeIfAbsent(new ShardId(shardRouting.index(), shardRouting.id()), k -> new HashSet<>())__                shards.add(shardRouting)__            }_        }__        for (final Map.Entry<Index, Integer> e : entries) {_            final Index index = e.getKey()__            for (int i = 0_ i < e.getValue()_ i++) {_                final ShardId shardId = new ShardId(index, i)__                final HashSet<ShardRouting> shards = shardsByShardId.get(shardId)__                final List<ShardRouting> mutableShardRoutings = routingNodes.assignedShards(shardId)__                assert (shards == null && mutableShardRoutings.size() == 0)_                        || (shards != null && shards.size() == mutableShardRoutings.size() && shards.containsAll(mutableShardRoutings))__            }_        }__        for (ShardRouting shard : routingNodes.unassigned()) {_            if (shard.primary()) {_                unassignedPrimaryCount++__            }_        }__        for (ShardRouting shard : routingNodes.unassigned().ignored()) {_            if (shard.primary()) {_                unassignedIgnoredPrimaryCount++__            }_        }__        for (Map.Entry<String, Recoveries> recoveries : routingNodes.recoveriesPerNode.entrySet()) {_            String node = recoveries.getKey()__            final Recoveries value = recoveries.getValue()__            int incoming = 0__            int outgoing = 0__            RoutingNode routingNode = routingNodes.nodesToShards.get(node)__            if (routingNode != null) { _                for (ShardRouting routing : routingNode) {_                    if (routing.initializing()) {_                        incoming++__                    }_                    if (routing.primary() && routing.isRelocationTarget() == false) {_                        for (ShardRouting assigned : routingNodes.assignedShards.get(routing.shardId())) {_                            if (assigned.initializing() && assigned.recoverySource().getType() == RecoverySource.Type.PEER) {_                                outgoing++__                            }_                        }_                    }_                }_            }_            assert incoming == value.incoming : incoming + " != " + value.incoming + " node: " + routingNode__            assert outgoing == value.outgoing : outgoing + " != " + value.outgoing + " node: " + routingNode__        }___        assert unassignedPrimaryCount == routingNodes.unassignedShards.getNumPrimaries() :_                "Unassigned primaries is [" + unassignedPrimaryCount + "] but RoutingNodes returned unassigned primaries [" +_                    routingNodes.unassigned().getNumPrimaries() + "]"__        assert unassignedIgnoredPrimaryCount == routingNodes.unassignedShards.getNumIgnoredPrimaries() :_                "Unassigned ignored primaries is [" + unassignedIgnoredPrimaryCount +_                    "] but RoutingNodes returned unassigned ignored primaries [" + routingNodes.unassigned().getNumIgnoredPrimaries() + "]"__        assert inactivePrimaryCount == routingNodes.inactivePrimaryCount :_                "Inactive Primary count [" + inactivePrimaryCount + "] but RoutingNodes returned inactive primaries [" +_                    routingNodes.inactivePrimaryCount + "]"__        assert inactiveShardCount == routingNodes.inactiveShardCount :_                "Inactive Shard count [" + inactiveShardCount + "] but RoutingNodes returned inactive shards [" +_                    routingNodes.inactiveShardCount + "]"__        assert routingNodes.getRelocatingShardCount() == relocating : "Relocating shards mismatch [" +_            routingNodes.getRelocatingShardCount() + "] but expected [" + relocating + "]"___        return true__    };calculates,routing,nodes,statistics,by,iterating,over,all,link,shard,routing,s,in,the,cluster,to,ensure,the,book,keeping,is,correct,for,performance,reasons,this,should,only,be,called,from,asserts,return,this,method,always,returns,code,true,code,or,throws,an,assertion,error,if,assertion,are,not,enabled,this,method,does,nothing;public,static,boolean,assert,shard,stats,routing,nodes,routing,nodes,if,assertions,enabled,return,true,int,unassigned,primary,count,0,int,unassigned,ignored,primary,count,0,int,inactive,primary,count,0,int,inactive,shard,count,0,int,relocating,0,map,index,integer,indices,and,shards,new,hash,map,for,routing,node,node,routing,nodes,for,shard,routing,shard,node,if,shard,initializing,shard,relocating,node,id,null,inactive,shard,count,if,shard,primary,inactive,primary,count,if,shard,relocating,relocating,integer,i,indices,and,shards,get,shard,index,if,i,null,i,shard,id,indices,and,shards,put,shard,index,math,max,i,shard,id,set,map,entry,index,integer,entries,indices,and,shards,entry,set,final,map,shard,id,hash,set,shard,routing,shards,by,shard,id,new,hash,map,for,final,routing,node,routing,node,routing,nodes,for,final,shard,routing,shard,routing,routing,node,final,hash,set,shard,routing,shards,shards,by,shard,id,compute,if,absent,new,shard,id,shard,routing,index,shard,routing,id,k,new,hash,set,shards,add,shard,routing,for,final,map,entry,index,integer,e,entries,final,index,index,e,get,key,for,int,i,0,i,e,get,value,i,final,shard,id,shard,id,new,shard,id,index,i,final,hash,set,shard,routing,shards,shards,by,shard,id,get,shard,id,final,list,shard,routing,mutable,shard,routings,routing,nodes,assigned,shards,shard,id,assert,shards,null,mutable,shard,routings,size,0,shards,null,shards,size,mutable,shard,routings,size,shards,contains,all,mutable,shard,routings,for,shard,routing,shard,routing,nodes,unassigned,if,shard,primary,unassigned,primary,count,for,shard,routing,shard,routing,nodes,unassigned,ignored,if,shard,primary,unassigned,ignored,primary,count,for,map,entry,string,recoveries,recoveries,routing,nodes,recoveries,per,node,entry,set,string,node,recoveries,get,key,final,recoveries,value,recoveries,get,value,int,incoming,0,int,outgoing,0,routing,node,routing,node,routing,nodes,nodes,to,shards,get,node,if,routing,node,null,for,shard,routing,routing,routing,node,if,routing,initializing,incoming,if,routing,primary,routing,is,relocation,target,false,for,shard,routing,assigned,routing,nodes,assigned,shards,get,routing,shard,id,if,assigned,initializing,assigned,recovery,source,get,type,recovery,source,type,peer,outgoing,assert,incoming,value,incoming,incoming,value,incoming,node,routing,node,assert,outgoing,value,outgoing,outgoing,value,outgoing,node,routing,node,assert,unassigned,primary,count,routing,nodes,unassigned,shards,get,num,primaries,unassigned,primaries,is,unassigned,primary,count,but,routing,nodes,returned,unassigned,primaries,routing,nodes,unassigned,get,num,primaries,assert,unassigned,ignored,primary,count,routing,nodes,unassigned,shards,get,num,ignored,primaries,unassigned,ignored,primaries,is,unassigned,ignored,primary,count,but,routing,nodes,returned,unassigned,ignored,primaries,routing,nodes,unassigned,get,num,ignored,primaries,assert,inactive,primary,count,routing,nodes,inactive,primary,count,inactive,primary,count,inactive,primary,count,but,routing,nodes,returned,inactive,primaries,routing,nodes,inactive,primary,count,assert,inactive,shard,count,routing,nodes,inactive,shard,count,inactive,shard,count,inactive,shard,count,but,routing,nodes,returned,inactive,shards,routing,nodes,inactive,shard,count,assert,routing,nodes,get,relocating,shard,count,relocating,relocating,shards,mismatch,routing,nodes,get,relocating,shard,count,but,expected,relocating,return,true
RoutingNodes -> public static boolean assertShardStats(RoutingNodes routingNodes);1549912434;Calculates RoutingNodes statistics by iterating over all {@link ShardRouting}s_in the cluster to ensure the book-keeping is correct._For performance reasons, this should only be called from asserts__@return this method always returns <code>true</code> or throws an assertion error. If assertion are not enabled_this method does nothing.;public static boolean assertShardStats(RoutingNodes routingNodes) {_        if (!Assertions.ENABLED) {_            return true__        }_        int unassignedPrimaryCount = 0__        int unassignedIgnoredPrimaryCount = 0__        int inactivePrimaryCount = 0__        int inactiveShardCount = 0__        int relocating = 0__        Map<Index, Integer> indicesAndShards = new HashMap<>()__        for (RoutingNode node : routingNodes) {_            for (ShardRouting shard : node) {_                if (shard.initializing() && shard.relocatingNodeId() == null) {_                    inactiveShardCount++__                    if (shard.primary()) {_                        inactivePrimaryCount++__                    }_                }_                if (shard.relocating()) {_                    relocating++__                }_                Integer i = indicesAndShards.get(shard.index())__                if (i == null) {_                    i = shard.id()__                }_                indicesAndShards.put(shard.index(), Math.max(i, shard.id()))__            }_        }__        _        Set<Map.Entry<Index, Integer>> entries = indicesAndShards.entrySet()___        final Map<ShardId, HashSet<ShardRouting>> shardsByShardId = new HashMap<>()__        for (final RoutingNode routingNode: routingNodes) {_            for (final ShardRouting shardRouting : routingNode) {_                final HashSet<ShardRouting> shards =_                        shardsByShardId.computeIfAbsent(new ShardId(shardRouting.index(), shardRouting.id()), k -> new HashSet<>())__                shards.add(shardRouting)__            }_        }__        for (final Map.Entry<Index, Integer> e : entries) {_            final Index index = e.getKey()__            for (int i = 0_ i < e.getValue()_ i++) {_                final ShardId shardId = new ShardId(index, i)__                final HashSet<ShardRouting> shards = shardsByShardId.get(shardId)__                final List<ShardRouting> mutableShardRoutings = routingNodes.assignedShards(shardId)__                assert (shards == null && mutableShardRoutings.size() == 0)_                        || (shards != null && shards.size() == mutableShardRoutings.size() && shards.containsAll(mutableShardRoutings))__            }_        }__        for (ShardRouting shard : routingNodes.unassigned()) {_            if (shard.primary()) {_                unassignedPrimaryCount++__            }_        }__        for (ShardRouting shard : routingNodes.unassigned().ignored()) {_            if (shard.primary()) {_                unassignedIgnoredPrimaryCount++__            }_        }__        for (Map.Entry<String, Recoveries> recoveries : routingNodes.recoveriesPerNode.entrySet()) {_            String node = recoveries.getKey()__            final Recoveries value = recoveries.getValue()__            int incoming = 0__            int outgoing = 0__            RoutingNode routingNode = routingNodes.nodesToShards.get(node)__            if (routingNode != null) { _                for (ShardRouting routing : routingNode) {_                    if (routing.initializing()) {_                        incoming++__                    }_                    if (routing.primary() && routing.isRelocationTarget() == false) {_                        for (ShardRouting assigned : routingNodes.assignedShards.get(routing.shardId())) {_                            if (assigned.initializing() && assigned.recoverySource().getType() == RecoverySource.Type.PEER) {_                                outgoing++__                            }_                        }_                    }_                }_            }_            assert incoming == value.incoming : incoming + " != " + value.incoming + " node: " + routingNode__            assert outgoing == value.outgoing : outgoing + " != " + value.outgoing + " node: " + routingNode__        }___        assert unassignedPrimaryCount == routingNodes.unassignedShards.getNumPrimaries() :_                "Unassigned primaries is [" + unassignedPrimaryCount + "] but RoutingNodes returned unassigned primaries [" +_                    routingNodes.unassigned().getNumPrimaries() + "]"__        assert unassignedIgnoredPrimaryCount == routingNodes.unassignedShards.getNumIgnoredPrimaries() :_                "Unassigned ignored primaries is [" + unassignedIgnoredPrimaryCount +_                    "] but RoutingNodes returned unassigned ignored primaries [" + routingNodes.unassigned().getNumIgnoredPrimaries() + "]"__        assert inactivePrimaryCount == routingNodes.inactivePrimaryCount :_                "Inactive Primary count [" + inactivePrimaryCount + "] but RoutingNodes returned inactive primaries [" +_                    routingNodes.inactivePrimaryCount + "]"__        assert inactiveShardCount == routingNodes.inactiveShardCount :_                "Inactive Shard count [" + inactiveShardCount + "] but RoutingNodes returned inactive shards [" +_                    routingNodes.inactiveShardCount + "]"__        assert routingNodes.getRelocatingShardCount() == relocating : "Relocating shards mismatch [" +_            routingNodes.getRelocatingShardCount() + "] but expected [" + relocating + "]"___        return true__    };calculates,routing,nodes,statistics,by,iterating,over,all,link,shard,routing,s,in,the,cluster,to,ensure,the,book,keeping,is,correct,for,performance,reasons,this,should,only,be,called,from,asserts,return,this,method,always,returns,code,true,code,or,throws,an,assertion,error,if,assertion,are,not,enabled,this,method,does,nothing;public,static,boolean,assert,shard,stats,routing,nodes,routing,nodes,if,assertions,enabled,return,true,int,unassigned,primary,count,0,int,unassigned,ignored,primary,count,0,int,inactive,primary,count,0,int,inactive,shard,count,0,int,relocating,0,map,index,integer,indices,and,shards,new,hash,map,for,routing,node,node,routing,nodes,for,shard,routing,shard,node,if,shard,initializing,shard,relocating,node,id,null,inactive,shard,count,if,shard,primary,inactive,primary,count,if,shard,relocating,relocating,integer,i,indices,and,shards,get,shard,index,if,i,null,i,shard,id,indices,and,shards,put,shard,index,math,max,i,shard,id,set,map,entry,index,integer,entries,indices,and,shards,entry,set,final,map,shard,id,hash,set,shard,routing,shards,by,shard,id,new,hash,map,for,final,routing,node,routing,node,routing,nodes,for,final,shard,routing,shard,routing,routing,node,final,hash,set,shard,routing,shards,shards,by,shard,id,compute,if,absent,new,shard,id,shard,routing,index,shard,routing,id,k,new,hash,set,shards,add,shard,routing,for,final,map,entry,index,integer,e,entries,final,index,index,e,get,key,for,int,i,0,i,e,get,value,i,final,shard,id,shard,id,new,shard,id,index,i,final,hash,set,shard,routing,shards,shards,by,shard,id,get,shard,id,final,list,shard,routing,mutable,shard,routings,routing,nodes,assigned,shards,shard,id,assert,shards,null,mutable,shard,routings,size,0,shards,null,shards,size,mutable,shard,routings,size,shards,contains,all,mutable,shard,routings,for,shard,routing,shard,routing,nodes,unassigned,if,shard,primary,unassigned,primary,count,for,shard,routing,shard,routing,nodes,unassigned,ignored,if,shard,primary,unassigned,ignored,primary,count,for,map,entry,string,recoveries,recoveries,routing,nodes,recoveries,per,node,entry,set,string,node,recoveries,get,key,final,recoveries,value,recoveries,get,value,int,incoming,0,int,outgoing,0,routing,node,routing,node,routing,nodes,nodes,to,shards,get,node,if,routing,node,null,for,shard,routing,routing,routing,node,if,routing,initializing,incoming,if,routing,primary,routing,is,relocation,target,false,for,shard,routing,assigned,routing,nodes,assigned,shards,get,routing,shard,id,if,assigned,initializing,assigned,recovery,source,get,type,recovery,source,type,peer,outgoing,assert,incoming,value,incoming,incoming,value,incoming,node,routing,node,assert,outgoing,value,outgoing,outgoing,value,outgoing,node,routing,node,assert,unassigned,primary,count,routing,nodes,unassigned,shards,get,num,primaries,unassigned,primaries,is,unassigned,primary,count,but,routing,nodes,returned,unassigned,primaries,routing,nodes,unassigned,get,num,primaries,assert,unassigned,ignored,primary,count,routing,nodes,unassigned,shards,get,num,ignored,primaries,unassigned,ignored,primaries,is,unassigned,ignored,primary,count,but,routing,nodes,returned,unassigned,ignored,primaries,routing,nodes,unassigned,get,num,ignored,primaries,assert,inactive,primary,count,routing,nodes,inactive,primary,count,inactive,primary,count,inactive,primary,count,but,routing,nodes,returned,inactive,primaries,routing,nodes,inactive,primary,count,assert,inactive,shard,count,routing,nodes,inactive,shard,count,inactive,shard,count,inactive,shard,count,but,routing,nodes,returned,inactive,shards,routing,nodes,inactive,shard,count,assert,routing,nodes,get,relocating,shard,count,relocating,relocating,shards,mismatch,routing,nodes,get,relocating,shard,count,but,expected,relocating,return,true
RoutingNodes -> public Iterator<ShardRouting> nodeInterleavedShardIterator();1524684173;Creates an iterator over shards interleaving between nodes: The iterator returns the first shard from_the first node, then the first shard of the second node, etc. until one shard from each node has been returned._The iterator then resumes on the first node by returning the second shard and continues until all shards from_all the nodes have been returned.;public Iterator<ShardRouting> nodeInterleavedShardIterator() {_        final Queue<Iterator<ShardRouting>> queue = new ArrayDeque<>()__        for (Map.Entry<String, RoutingNode> entry : nodesToShards.entrySet()) {_            queue.add(entry.getValue().copyShards().iterator())__        }_        return new Iterator<ShardRouting>() {_            public boolean hasNext() {_                while (!queue.isEmpty()) {_                    if (queue.peek().hasNext()) {_                        return true__                    }_                    queue.poll()__                }_                return false__            }__            public ShardRouting next() {_                if (hasNext() == false) {_                    throw new NoSuchElementException()__                }_                Iterator<ShardRouting> iter = queue.poll()__                ShardRouting result = iter.next()__                queue.offer(iter)__                return result__            }__            public void remove() {_                throw new UnsupportedOperationException()__            }_        }__    };creates,an,iterator,over,shards,interleaving,between,nodes,the,iterator,returns,the,first,shard,from,the,first,node,then,the,first,shard,of,the,second,node,etc,until,one,shard,from,each,node,has,been,returned,the,iterator,then,resumes,on,the,first,node,by,returning,the,second,shard,and,continues,until,all,shards,from,all,the,nodes,have,been,returned;public,iterator,shard,routing,node,interleaved,shard,iterator,final,queue,iterator,shard,routing,queue,new,array,deque,for,map,entry,string,routing,node,entry,nodes,to,shards,entry,set,queue,add,entry,get,value,copy,shards,iterator,return,new,iterator,shard,routing,public,boolean,has,next,while,queue,is,empty,if,queue,peek,has,next,return,true,queue,poll,return,false,public,shard,routing,next,if,has,next,false,throw,new,no,such,element,exception,iterator,shard,routing,iter,queue,poll,shard,routing,result,iter,next,queue,offer,iter,return,result,public,void,remove,throw,new,unsupported,operation,exception
RoutingNodes -> public Iterator<ShardRouting> nodeInterleavedShardIterator();1540847035;Creates an iterator over shards interleaving between nodes: The iterator returns the first shard from_the first node, then the first shard of the second node, etc. until one shard from each node has been returned._The iterator then resumes on the first node by returning the second shard and continues until all shards from_all the nodes have been returned.;public Iterator<ShardRouting> nodeInterleavedShardIterator() {_        final Queue<Iterator<ShardRouting>> queue = new ArrayDeque<>()__        for (Map.Entry<String, RoutingNode> entry : nodesToShards.entrySet()) {_            queue.add(entry.getValue().copyShards().iterator())__        }_        return new Iterator<ShardRouting>() {_            public boolean hasNext() {_                while (!queue.isEmpty()) {_                    if (queue.peek().hasNext()) {_                        return true__                    }_                    queue.poll()__                }_                return false__            }__            public ShardRouting next() {_                if (hasNext() == false) {_                    throw new NoSuchElementException()__                }_                Iterator<ShardRouting> iter = queue.poll()__                ShardRouting result = iter.next()__                queue.offer(iter)__                return result__            }__            public void remove() {_                throw new UnsupportedOperationException()__            }_        }__    };creates,an,iterator,over,shards,interleaving,between,nodes,the,iterator,returns,the,first,shard,from,the,first,node,then,the,first,shard,of,the,second,node,etc,until,one,shard,from,each,node,has,been,returned,the,iterator,then,resumes,on,the,first,node,by,returning,the,second,shard,and,continues,until,all,shards,from,all,the,nodes,have,been,returned;public,iterator,shard,routing,node,interleaved,shard,iterator,final,queue,iterator,shard,routing,queue,new,array,deque,for,map,entry,string,routing,node,entry,nodes,to,shards,entry,set,queue,add,entry,get,value,copy,shards,iterator,return,new,iterator,shard,routing,public,boolean,has,next,while,queue,is,empty,if,queue,peek,has,next,return,true,queue,poll,return,false,public,shard,routing,next,if,has,next,false,throw,new,no,such,element,exception,iterator,shard,routing,iter,queue,poll,shard,routing,result,iter,next,queue,offer,iter,return,result,public,void,remove,throw,new,unsupported,operation,exception
RoutingNodes -> public Iterator<ShardRouting> nodeInterleavedShardIterator();1541446827;Creates an iterator over shards interleaving between nodes: The iterator returns the first shard from_the first node, then the first shard of the second node, etc. until one shard from each node has been returned._The iterator then resumes on the first node by returning the second shard and continues until all shards from_all the nodes have been returned.;public Iterator<ShardRouting> nodeInterleavedShardIterator() {_        final Queue<Iterator<ShardRouting>> queue = new ArrayDeque<>()__        for (Map.Entry<String, RoutingNode> entry : nodesToShards.entrySet()) {_            queue.add(entry.getValue().copyShards().iterator())__        }_        return new Iterator<ShardRouting>() {_            public boolean hasNext() {_                while (!queue.isEmpty()) {_                    if (queue.peek().hasNext()) {_                        return true__                    }_                    queue.poll()__                }_                return false__            }__            public ShardRouting next() {_                if (hasNext() == false) {_                    throw new NoSuchElementException()__                }_                Iterator<ShardRouting> iter = queue.poll()__                ShardRouting result = iter.next()__                queue.offer(iter)__                return result__            }__            public void remove() {_                throw new UnsupportedOperationException()__            }_        }__    };creates,an,iterator,over,shards,interleaving,between,nodes,the,iterator,returns,the,first,shard,from,the,first,node,then,the,first,shard,of,the,second,node,etc,until,one,shard,from,each,node,has,been,returned,the,iterator,then,resumes,on,the,first,node,by,returning,the,second,shard,and,continues,until,all,shards,from,all,the,nodes,have,been,returned;public,iterator,shard,routing,node,interleaved,shard,iterator,final,queue,iterator,shard,routing,queue,new,array,deque,for,map,entry,string,routing,node,entry,nodes,to,shards,entry,set,queue,add,entry,get,value,copy,shards,iterator,return,new,iterator,shard,routing,public,boolean,has,next,while,queue,is,empty,if,queue,peek,has,next,return,true,queue,poll,return,false,public,shard,routing,next,if,has,next,false,throw,new,no,such,element,exception,iterator,shard,routing,iter,queue,poll,shard,routing,result,iter,next,queue,offer,iter,return,result,public,void,remove,throw,new,unsupported,operation,exception
RoutingNodes -> public Iterator<ShardRouting> nodeInterleavedShardIterator();1548259585;Creates an iterator over shards interleaving between nodes: The iterator returns the first shard from_the first node, then the first shard of the second node, etc. until one shard from each node has been returned._The iterator then resumes on the first node by returning the second shard and continues until all shards from_all the nodes have been returned.;public Iterator<ShardRouting> nodeInterleavedShardIterator() {_        final Queue<Iterator<ShardRouting>> queue = new ArrayDeque<>()__        for (Map.Entry<String, RoutingNode> entry : nodesToShards.entrySet()) {_            queue.add(entry.getValue().copyShards().iterator())__        }_        return new Iterator<ShardRouting>() {_            public boolean hasNext() {_                while (!queue.isEmpty()) {_                    if (queue.peek().hasNext()) {_                        return true__                    }_                    queue.poll()__                }_                return false__            }__            public ShardRouting next() {_                if (hasNext() == false) {_                    throw new NoSuchElementException()__                }_                Iterator<ShardRouting> iter = queue.poll()__                ShardRouting result = iter.next()__                queue.offer(iter)__                return result__            }__            public void remove() {_                throw new UnsupportedOperationException()__            }_        }__    };creates,an,iterator,over,shards,interleaving,between,nodes,the,iterator,returns,the,first,shard,from,the,first,node,then,the,first,shard,of,the,second,node,etc,until,one,shard,from,each,node,has,been,returned,the,iterator,then,resumes,on,the,first,node,by,returning,the,second,shard,and,continues,until,all,shards,from,all,the,nodes,have,been,returned;public,iterator,shard,routing,node,interleaved,shard,iterator,final,queue,iterator,shard,routing,queue,new,array,deque,for,map,entry,string,routing,node,entry,nodes,to,shards,entry,set,queue,add,entry,get,value,copy,shards,iterator,return,new,iterator,shard,routing,public,boolean,has,next,while,queue,is,empty,if,queue,peek,has,next,return,true,queue,poll,return,false,public,shard,routing,next,if,has,next,false,throw,new,no,such,element,exception,iterator,shard,routing,iter,queue,poll,shard,routing,result,iter,next,queue,offer,iter,return,result,public,void,remove,throw,new,unsupported,operation,exception
RoutingNodes -> public Iterator<ShardRouting> nodeInterleavedShardIterator();1549912434;Creates an iterator over shards interleaving between nodes: The iterator returns the first shard from_the first node, then the first shard of the second node, etc. until one shard from each node has been returned._The iterator then resumes on the first node by returning the second shard and continues until all shards from_all the nodes have been returned.;public Iterator<ShardRouting> nodeInterleavedShardIterator() {_        final Queue<Iterator<ShardRouting>> queue = new ArrayDeque<>()__        for (Map.Entry<String, RoutingNode> entry : nodesToShards.entrySet()) {_            queue.add(entry.getValue().copyShards().iterator())__        }_        return new Iterator<ShardRouting>() {_            public boolean hasNext() {_                while (!queue.isEmpty()) {_                    if (queue.peek().hasNext()) {_                        return true__                    }_                    queue.poll()__                }_                return false__            }__            public ShardRouting next() {_                if (hasNext() == false) {_                    throw new NoSuchElementException()__                }_                Iterator<ShardRouting> iter = queue.poll()__                ShardRouting result = iter.next()__                queue.offer(iter)__                return result__            }__            public void remove() {_                throw new UnsupportedOperationException()__            }_        }__    };creates,an,iterator,over,shards,interleaving,between,nodes,the,iterator,returns,the,first,shard,from,the,first,node,then,the,first,shard,of,the,second,node,etc,until,one,shard,from,each,node,has,been,returned,the,iterator,then,resumes,on,the,first,node,by,returning,the,second,shard,and,continues,until,all,shards,from,all,the,nodes,have,been,returned;public,iterator,shard,routing,node,interleaved,shard,iterator,final,queue,iterator,shard,routing,queue,new,array,deque,for,map,entry,string,routing,node,entry,nodes,to,shards,entry,set,queue,add,entry,get,value,copy,shards,iterator,return,new,iterator,shard,routing,public,boolean,has,next,while,queue,is,empty,if,queue,peek,has,next,return,true,queue,poll,return,false,public,shard,routing,next,if,has,next,false,throw,new,no,such,element,exception,iterator,shard,routing,iter,queue,poll,shard,routing,result,iter,next,queue,offer,iter,return,result,public,void,remove,throw,new,unsupported,operation,exception
RoutingNodes -> UnassignedShards -> UnassignedIterator -> @Override             public void remove();1524684173;Unsupported operation, just there for the interface. Use {@link #removeAndIgnore(AllocationStatus, RoutingChangesObserver)} or_{@link #initialize(String, String, long, RoutingChangesObserver)}.;@Override_            public void remove() {_                throw new UnsupportedOperationException("remove is not supported in unassigned iterator, use removeAndIgnore or initialize")__            };unsupported,operation,just,there,for,the,interface,use,link,remove,and,ignore,allocation,status,routing,changes,observer,or,link,initialize,string,string,long,routing,changes,observer;override,public,void,remove,throw,new,unsupported,operation,exception,remove,is,not,supported,in,unassigned,iterator,use,remove,and,ignore,or,initialize
RoutingNodes -> UnassignedShards -> UnassignedIterator -> @Override             public void remove();1540847035;Unsupported operation, just there for the interface. Use_{@link #removeAndIgnore(AllocationStatus, RoutingChangesObserver)} or_{@link #initialize(String, String, long, RoutingChangesObserver)}.;@Override_            public void remove() {_                throw new UnsupportedOperationException("remove is not supported in unassigned iterator," +_                    " use removeAndIgnore or initialize")__            };unsupported,operation,just,there,for,the,interface,use,link,remove,and,ignore,allocation,status,routing,changes,observer,or,link,initialize,string,string,long,routing,changes,observer;override,public,void,remove,throw,new,unsupported,operation,exception,remove,is,not,supported,in,unassigned,iterator,use,remove,and,ignore,or,initialize
RoutingNodes -> UnassignedShards -> UnassignedIterator -> @Override             public void remove();1541446827;Unsupported operation, just there for the interface. Use_{@link #removeAndIgnore(AllocationStatus, RoutingChangesObserver)} or_{@link #initialize(String, String, long, RoutingChangesObserver)}.;@Override_            public void remove() {_                throw new UnsupportedOperationException("remove is not supported in unassigned iterator," +_                    " use removeAndIgnore or initialize")__            };unsupported,operation,just,there,for,the,interface,use,link,remove,and,ignore,allocation,status,routing,changes,observer,or,link,initialize,string,string,long,routing,changes,observer;override,public,void,remove,throw,new,unsupported,operation,exception,remove,is,not,supported,in,unassigned,iterator,use,remove,and,ignore,or,initialize
RoutingNodes -> UnassignedShards -> UnassignedIterator -> @Override             public void remove();1548259585;Unsupported operation, just there for the interface. Use_{@link #removeAndIgnore(AllocationStatus, RoutingChangesObserver)} or_{@link #initialize(String, String, long, RoutingChangesObserver)}.;@Override_            public void remove() {_                throw new UnsupportedOperationException("remove is not supported in unassigned iterator," +_                    " use removeAndIgnore or initialize")__            };unsupported,operation,just,there,for,the,interface,use,link,remove,and,ignore,allocation,status,routing,changes,observer,or,link,initialize,string,string,long,routing,changes,observer;override,public,void,remove,throw,new,unsupported,operation,exception,remove,is,not,supported,in,unassigned,iterator,use,remove,and,ignore,or,initialize
RoutingNodes -> UnassignedShards -> UnassignedIterator -> @Override             public void remove();1549912434;Unsupported operation, just there for the interface. Use_{@link #removeAndIgnore(AllocationStatus, RoutingChangesObserver)} or_{@link #initialize(String, String, long, RoutingChangesObserver)}.;@Override_            public void remove() {_                throw new UnsupportedOperationException("remove is not supported in unassigned iterator," +_                    " use removeAndIgnore or initialize")__            };unsupported,operation,just,there,for,the,interface,use,link,remove,and,ignore,allocation,status,routing,changes,observer,or,link,initialize,string,string,long,routing,changes,observer;override,public,void,remove,throw,new,unsupported,operation,exception,remove,is,not,supported,in,unassigned,iterator,use,remove,and,ignore,or,initialize
RoutingNodes -> public ShardRouting activeReplicaWithHighestVersion(ShardId shardId);1524684173;Returns one active replica shard for the given shard id or <code>null</code> if_no active replica is found.__Since replicas could possibly be on nodes with a older version of ES than_the primary is, this will return replicas on the highest version of ES.;public ShardRouting activeReplicaWithHighestVersion(ShardId shardId) {_        _        _        _        _        _        return assignedShards(shardId).stream()_                .filter(shr -> !shr.primary() && shr.active())_                .filter(shr -> node(shr.currentNodeId()) != null)_                .max(Comparator.comparing(shr -> node(shr.currentNodeId()).node(),_                                Comparator.nullsFirst(Comparator.comparing(DiscoveryNode::getVersion))))_                .orElse(null)__    };returns,one,active,replica,shard,for,the,given,shard,id,or,code,null,code,if,no,active,replica,is,found,since,replicas,could,possibly,be,on,nodes,with,a,older,version,of,es,than,the,primary,is,this,will,return,replicas,on,the,highest,version,of,es;public,shard,routing,active,replica,with,highest,version,shard,id,shard,id,return,assigned,shards,shard,id,stream,filter,shr,shr,primary,shr,active,filter,shr,node,shr,current,node,id,null,max,comparator,comparing,shr,node,shr,current,node,id,node,comparator,nulls,first,comparator,comparing,discovery,node,get,version,or,else,null
RoutingNodes -> public ShardRouting activeReplicaWithHighestVersion(ShardId shardId);1540847035;Returns one active replica shard for the given shard id or <code>null</code> if_no active replica is found.__Since replicas could possibly be on nodes with a older version of ES than_the primary is, this will return replicas on the highest version of ES.;public ShardRouting activeReplicaWithHighestVersion(ShardId shardId) {_        _        _        _        _        _        return assignedShards(shardId).stream()_                .filter(shr -> !shr.primary() && shr.active())_                .filter(shr -> node(shr.currentNodeId()) != null)_                .max(Comparator.comparing(shr -> node(shr.currentNodeId()).node(),_                                Comparator.nullsFirst(Comparator.comparing(DiscoveryNode::getVersion))))_                .orElse(null)__    };returns,one,active,replica,shard,for,the,given,shard,id,or,code,null,code,if,no,active,replica,is,found,since,replicas,could,possibly,be,on,nodes,with,a,older,version,of,es,than,the,primary,is,this,will,return,replicas,on,the,highest,version,of,es;public,shard,routing,active,replica,with,highest,version,shard,id,shard,id,return,assigned,shards,shard,id,stream,filter,shr,shr,primary,shr,active,filter,shr,node,shr,current,node,id,null,max,comparator,comparing,shr,node,shr,current,node,id,node,comparator,nulls,first,comparator,comparing,discovery,node,get,version,or,else,null
RoutingNodes -> public ShardRouting activeReplicaWithHighestVersion(ShardId shardId);1541446827;Returns one active replica shard for the given shard id or <code>null</code> if_no active replica is found.__Since replicas could possibly be on nodes with a older version of ES than_the primary is, this will return replicas on the highest version of ES.;public ShardRouting activeReplicaWithHighestVersion(ShardId shardId) {_        _        _        _        _        _        return assignedShards(shardId).stream()_                .filter(shr -> !shr.primary() && shr.active())_                .filter(shr -> node(shr.currentNodeId()) != null)_                .max(Comparator.comparing(shr -> node(shr.currentNodeId()).node(),_                                Comparator.nullsFirst(Comparator.comparing(DiscoveryNode::getVersion))))_                .orElse(null)__    };returns,one,active,replica,shard,for,the,given,shard,id,or,code,null,code,if,no,active,replica,is,found,since,replicas,could,possibly,be,on,nodes,with,a,older,version,of,es,than,the,primary,is,this,will,return,replicas,on,the,highest,version,of,es;public,shard,routing,active,replica,with,highest,version,shard,id,shard,id,return,assigned,shards,shard,id,stream,filter,shr,shr,primary,shr,active,filter,shr,node,shr,current,node,id,null,max,comparator,comparing,shr,node,shr,current,node,id,node,comparator,nulls,first,comparator,comparing,discovery,node,get,version,or,else,null
RoutingNodes -> public ShardRouting activeReplicaWithHighestVersion(ShardId shardId);1548259585;Returns one active replica shard for the given shard id or <code>null</code> if_no active replica is found.__Since replicas could possibly be on nodes with a older version of ES than_the primary is, this will return replicas on the highest version of ES.;public ShardRouting activeReplicaWithHighestVersion(ShardId shardId) {_        _        _        _        _        _        return assignedShards(shardId).stream()_                .filter(shr -> !shr.primary() && shr.active())_                .filter(shr -> node(shr.currentNodeId()) != null)_                .max(Comparator.comparing(shr -> node(shr.currentNodeId()).node(),_                                Comparator.nullsFirst(Comparator.comparing(DiscoveryNode::getVersion))))_                .orElse(null)__    };returns,one,active,replica,shard,for,the,given,shard,id,or,code,null,code,if,no,active,replica,is,found,since,replicas,could,possibly,be,on,nodes,with,a,older,version,of,es,than,the,primary,is,this,will,return,replicas,on,the,highest,version,of,es;public,shard,routing,active,replica,with,highest,version,shard,id,shard,id,return,assigned,shards,shard,id,stream,filter,shr,shr,primary,shr,active,filter,shr,node,shr,current,node,id,null,max,comparator,comparing,shr,node,shr,current,node,id,node,comparator,nulls,first,comparator,comparing,discovery,node,get,version,or,else,null
RoutingNodes -> public ShardRouting activeReplicaWithHighestVersion(ShardId shardId);1549912434;Returns one active replica shard for the given shard id or <code>null</code> if_no active replica is found.__Since replicas could possibly be on nodes with a older version of ES than_the primary is, this will return replicas on the highest version of ES.;public ShardRouting activeReplicaWithHighestVersion(ShardId shardId) {_        _        _        _        _        _        return assignedShards(shardId).stream()_                .filter(shr -> !shr.primary() && shr.active())_                .filter(shr -> node(shr.currentNodeId()) != null)_                .max(Comparator.comparing(shr -> node(shr.currentNodeId()).node(),_                                Comparator.nullsFirst(Comparator.comparing(DiscoveryNode::getVersion))))_                .orElse(null)__    };returns,one,active,replica,shard,for,the,given,shard,id,or,code,null,code,if,no,active,replica,is,found,since,replicas,could,possibly,be,on,nodes,with,a,older,version,of,es,than,the,primary,is,this,will,return,replicas,on,the,highest,version,of,es;public,shard,routing,active,replica,with,highest,version,shard,id,shard,id,return,assigned,shards,shard,id,stream,filter,shr,shr,primary,shr,active,filter,shr,node,shr,current,node,id,null,max,comparator,comparing,shr,node,shr,current,node,id,node,comparator,nulls,first,comparator,comparing,discovery,node,get,version,or,else,null
RoutingNodes -> UnassignedShards -> public void ignoreShard(ShardRouting shard, AllocationStatus allocationStatus, RoutingChangesObserver changes);1524684173;Marks a shard as temporarily ignored and adds it to the ignore unassigned list._Should be used with caution, typically,_the correct usage is to removeAndIgnore from the iterator._@see #ignored()_@see UnassignedIterator#removeAndIgnore(AllocationStatus, RoutingChangesObserver)_@see #isIgnoredEmpty();public void ignoreShard(ShardRouting shard, AllocationStatus allocationStatus, RoutingChangesObserver changes) {_            nodes.ensureMutable()__            if (shard.primary()) {_                ignoredPrimaries++__                UnassignedInfo currInfo = shard.unassignedInfo()__                assert currInfo != null__                if (allocationStatus.equals(currInfo.getLastAllocationStatus()) == false) {_                    UnassignedInfo newInfo = new UnassignedInfo(currInfo.getReason(), currInfo.getMessage(), currInfo.getFailure(),_                                                                currInfo.getNumFailedAllocations(), currInfo.getUnassignedTimeInNanos(),_                                                                currInfo.getUnassignedTimeInMillis(), currInfo.isDelayed(),_                                                                allocationStatus)__                    ShardRouting updatedShard = shard.updateUnassigned(newInfo, shard.recoverySource())__                    changes.unassignedInfoUpdated(shard, newInfo)__                    shard = updatedShard__                }_            }_            ignored.add(shard)__        };marks,a,shard,as,temporarily,ignored,and,adds,it,to,the,ignore,unassigned,list,should,be,used,with,caution,typically,the,correct,usage,is,to,remove,and,ignore,from,the,iterator,see,ignored,see,unassigned,iterator,remove,and,ignore,allocation,status,routing,changes,observer,see,is,ignored,empty;public,void,ignore,shard,shard,routing,shard,allocation,status,allocation,status,routing,changes,observer,changes,nodes,ensure,mutable,if,shard,primary,ignored,primaries,unassigned,info,curr,info,shard,unassigned,info,assert,curr,info,null,if,allocation,status,equals,curr,info,get,last,allocation,status,false,unassigned,info,new,info,new,unassigned,info,curr,info,get,reason,curr,info,get,message,curr,info,get,failure,curr,info,get,num,failed,allocations,curr,info,get,unassigned,time,in,nanos,curr,info,get,unassigned,time,in,millis,curr,info,is,delayed,allocation,status,shard,routing,updated,shard,shard,update,unassigned,new,info,shard,recovery,source,changes,unassigned,info,updated,shard,new,info,shard,updated,shard,ignored,add,shard
RoutingNodes -> UnassignedShards -> public void ignoreShard(ShardRouting shard, AllocationStatus allocationStatus, RoutingChangesObserver changes);1540847035;Marks a shard as temporarily ignored and adds it to the ignore unassigned list._Should be used with caution, typically,_the correct usage is to removeAndIgnore from the iterator._@see #ignored()_@see UnassignedIterator#removeAndIgnore(AllocationStatus, RoutingChangesObserver)_@see #isIgnoredEmpty();public void ignoreShard(ShardRouting shard, AllocationStatus allocationStatus, RoutingChangesObserver changes) {_            nodes.ensureMutable()__            if (shard.primary()) {_                ignoredPrimaries++__                UnassignedInfo currInfo = shard.unassignedInfo()__                assert currInfo != null__                if (allocationStatus.equals(currInfo.getLastAllocationStatus()) == false) {_                    UnassignedInfo newInfo = new UnassignedInfo(currInfo.getReason(), currInfo.getMessage(), currInfo.getFailure(),_                                                                currInfo.getNumFailedAllocations(), currInfo.getUnassignedTimeInNanos(),_                                                                currInfo.getUnassignedTimeInMillis(), currInfo.isDelayed(),_                                                                allocationStatus)__                    ShardRouting updatedShard = shard.updateUnassigned(newInfo, shard.recoverySource())__                    changes.unassignedInfoUpdated(shard, newInfo)__                    shard = updatedShard__                }_            }_            ignored.add(shard)__        };marks,a,shard,as,temporarily,ignored,and,adds,it,to,the,ignore,unassigned,list,should,be,used,with,caution,typically,the,correct,usage,is,to,remove,and,ignore,from,the,iterator,see,ignored,see,unassigned,iterator,remove,and,ignore,allocation,status,routing,changes,observer,see,is,ignored,empty;public,void,ignore,shard,shard,routing,shard,allocation,status,allocation,status,routing,changes,observer,changes,nodes,ensure,mutable,if,shard,primary,ignored,primaries,unassigned,info,curr,info,shard,unassigned,info,assert,curr,info,null,if,allocation,status,equals,curr,info,get,last,allocation,status,false,unassigned,info,new,info,new,unassigned,info,curr,info,get,reason,curr,info,get,message,curr,info,get,failure,curr,info,get,num,failed,allocations,curr,info,get,unassigned,time,in,nanos,curr,info,get,unassigned,time,in,millis,curr,info,is,delayed,allocation,status,shard,routing,updated,shard,shard,update,unassigned,new,info,shard,recovery,source,changes,unassigned,info,updated,shard,new,info,shard,updated,shard,ignored,add,shard
RoutingNodes -> UnassignedShards -> public void ignoreShard(ShardRouting shard, AllocationStatus allocationStatus, RoutingChangesObserver changes);1541446827;Marks a shard as temporarily ignored and adds it to the ignore unassigned list._Should be used with caution, typically,_the correct usage is to removeAndIgnore from the iterator._@see #ignored()_@see UnassignedIterator#removeAndIgnore(AllocationStatus, RoutingChangesObserver)_@see #isIgnoredEmpty();public void ignoreShard(ShardRouting shard, AllocationStatus allocationStatus, RoutingChangesObserver changes) {_            nodes.ensureMutable()__            if (shard.primary()) {_                ignoredPrimaries++__                UnassignedInfo currInfo = shard.unassignedInfo()__                assert currInfo != null__                if (allocationStatus.equals(currInfo.getLastAllocationStatus()) == false) {_                    UnassignedInfo newInfo = new UnassignedInfo(currInfo.getReason(), currInfo.getMessage(), currInfo.getFailure(),_                                                                currInfo.getNumFailedAllocations(), currInfo.getUnassignedTimeInNanos(),_                                                                currInfo.getUnassignedTimeInMillis(), currInfo.isDelayed(),_                                                                allocationStatus)__                    ShardRouting updatedShard = shard.updateUnassigned(newInfo, shard.recoverySource())__                    changes.unassignedInfoUpdated(shard, newInfo)__                    shard = updatedShard__                }_            }_            ignored.add(shard)__        };marks,a,shard,as,temporarily,ignored,and,adds,it,to,the,ignore,unassigned,list,should,be,used,with,caution,typically,the,correct,usage,is,to,remove,and,ignore,from,the,iterator,see,ignored,see,unassigned,iterator,remove,and,ignore,allocation,status,routing,changes,observer,see,is,ignored,empty;public,void,ignore,shard,shard,routing,shard,allocation,status,allocation,status,routing,changes,observer,changes,nodes,ensure,mutable,if,shard,primary,ignored,primaries,unassigned,info,curr,info,shard,unassigned,info,assert,curr,info,null,if,allocation,status,equals,curr,info,get,last,allocation,status,false,unassigned,info,new,info,new,unassigned,info,curr,info,get,reason,curr,info,get,message,curr,info,get,failure,curr,info,get,num,failed,allocations,curr,info,get,unassigned,time,in,nanos,curr,info,get,unassigned,time,in,millis,curr,info,is,delayed,allocation,status,shard,routing,updated,shard,shard,update,unassigned,new,info,shard,recovery,source,changes,unassigned,info,updated,shard,new,info,shard,updated,shard,ignored,add,shard
RoutingNodes -> UnassignedShards -> public void ignoreShard(ShardRouting shard, AllocationStatus allocationStatus, RoutingChangesObserver changes);1548259585;Marks a shard as temporarily ignored and adds it to the ignore unassigned list._Should be used with caution, typically,_the correct usage is to removeAndIgnore from the iterator._@see #ignored()_@see UnassignedIterator#removeAndIgnore(AllocationStatus, RoutingChangesObserver)_@see #isIgnoredEmpty();public void ignoreShard(ShardRouting shard, AllocationStatus allocationStatus, RoutingChangesObserver changes) {_            nodes.ensureMutable()__            if (shard.primary()) {_                ignoredPrimaries++__                UnassignedInfo currInfo = shard.unassignedInfo()__                assert currInfo != null__                if (allocationStatus.equals(currInfo.getLastAllocationStatus()) == false) {_                    UnassignedInfo newInfo = new UnassignedInfo(currInfo.getReason(), currInfo.getMessage(), currInfo.getFailure(),_                                                                currInfo.getNumFailedAllocations(), currInfo.getUnassignedTimeInNanos(),_                                                                currInfo.getUnassignedTimeInMillis(), currInfo.isDelayed(),_                                                                allocationStatus)__                    ShardRouting updatedShard = shard.updateUnassigned(newInfo, shard.recoverySource())__                    changes.unassignedInfoUpdated(shard, newInfo)__                    shard = updatedShard__                }_            }_            ignored.add(shard)__        };marks,a,shard,as,temporarily,ignored,and,adds,it,to,the,ignore,unassigned,list,should,be,used,with,caution,typically,the,correct,usage,is,to,remove,and,ignore,from,the,iterator,see,ignored,see,unassigned,iterator,remove,and,ignore,allocation,status,routing,changes,observer,see,is,ignored,empty;public,void,ignore,shard,shard,routing,shard,allocation,status,allocation,status,routing,changes,observer,changes,nodes,ensure,mutable,if,shard,primary,ignored,primaries,unassigned,info,curr,info,shard,unassigned,info,assert,curr,info,null,if,allocation,status,equals,curr,info,get,last,allocation,status,false,unassigned,info,new,info,new,unassigned,info,curr,info,get,reason,curr,info,get,message,curr,info,get,failure,curr,info,get,num,failed,allocations,curr,info,get,unassigned,time,in,nanos,curr,info,get,unassigned,time,in,millis,curr,info,is,delayed,allocation,status,shard,routing,updated,shard,shard,update,unassigned,new,info,shard,recovery,source,changes,unassigned,info,updated,shard,new,info,shard,updated,shard,ignored,add,shard
RoutingNodes -> UnassignedShards -> public void ignoreShard(ShardRouting shard, AllocationStatus allocationStatus, RoutingChangesObserver changes);1549912434;Marks a shard as temporarily ignored and adds it to the ignore unassigned list._Should be used with caution, typically,_the correct usage is to removeAndIgnore from the iterator._@see #ignored()_@see UnassignedIterator#removeAndIgnore(AllocationStatus, RoutingChangesObserver)_@see #isIgnoredEmpty();public void ignoreShard(ShardRouting shard, AllocationStatus allocationStatus, RoutingChangesObserver changes) {_            nodes.ensureMutable()__            if (shard.primary()) {_                ignoredPrimaries++__                UnassignedInfo currInfo = shard.unassignedInfo()__                assert currInfo != null__                if (allocationStatus.equals(currInfo.getLastAllocationStatus()) == false) {_                    UnassignedInfo newInfo = new UnassignedInfo(currInfo.getReason(), currInfo.getMessage(), currInfo.getFailure(),_                                                                currInfo.getNumFailedAllocations(), currInfo.getUnassignedTimeInNanos(),_                                                                currInfo.getUnassignedTimeInMillis(), currInfo.isDelayed(),_                                                                allocationStatus)__                    ShardRouting updatedShard = shard.updateUnassigned(newInfo, shard.recoverySource())__                    changes.unassignedInfoUpdated(shard, newInfo)__                    shard = updatedShard__                }_            }_            ignored.add(shard)__        };marks,a,shard,as,temporarily,ignored,and,adds,it,to,the,ignore,unassigned,list,should,be,used,with,caution,typically,the,correct,usage,is,to,remove,and,ignore,from,the,iterator,see,ignored,see,unassigned,iterator,remove,and,ignore,allocation,status,routing,changes,observer,see,is,ignored,empty;public,void,ignore,shard,shard,routing,shard,allocation,status,allocation,status,routing,changes,observer,changes,nodes,ensure,mutable,if,shard,primary,ignored,primaries,unassigned,info,curr,info,shard,unassigned,info,assert,curr,info,null,if,allocation,status,equals,curr,info,get,last,allocation,status,false,unassigned,info,new,info,new,unassigned,info,curr,info,get,reason,curr,info,get,message,curr,info,get,failure,curr,info,get,num,failed,allocations,curr,info,get,unassigned,time,in,nanos,curr,info,get,unassigned,time,in,millis,curr,info,is,delayed,allocation,status,shard,routing,updated,shard,shard,update,unassigned,new,info,shard,recovery,source,changes,unassigned,info,updated,shard,new,info,shard,updated,shard,ignored,add,shard
RoutingNodes -> public boolean hasUnassignedPrimaries();1524684173;Returns <code>true</code> iff this {@link RoutingNodes} instance has any unassigned primaries even if the_primaries are marked as temporarily ignored.;public boolean hasUnassignedPrimaries() {_        return unassignedShards.getNumPrimaries() + unassignedShards.getNumIgnoredPrimaries() > 0__    };returns,code,true,code,iff,this,link,routing,nodes,instance,has,any,unassigned,primaries,even,if,the,primaries,are,marked,as,temporarily,ignored;public,boolean,has,unassigned,primaries,return,unassigned,shards,get,num,primaries,unassigned,shards,get,num,ignored,primaries,0
RoutingNodes -> public boolean hasUnassignedPrimaries();1540847035;Returns <code>true</code> iff this {@link RoutingNodes} instance has any unassigned primaries even if the_primaries are marked as temporarily ignored.;public boolean hasUnassignedPrimaries() {_        return unassignedShards.getNumPrimaries() + unassignedShards.getNumIgnoredPrimaries() > 0__    };returns,code,true,code,iff,this,link,routing,nodes,instance,has,any,unassigned,primaries,even,if,the,primaries,are,marked,as,temporarily,ignored;public,boolean,has,unassigned,primaries,return,unassigned,shards,get,num,primaries,unassigned,shards,get,num,ignored,primaries,0
RoutingNodes -> public boolean hasUnassignedPrimaries();1541446827;Returns <code>true</code> iff this {@link RoutingNodes} instance has any unassigned primaries even if the_primaries are marked as temporarily ignored.;public boolean hasUnassignedPrimaries() {_        return unassignedShards.getNumPrimaries() + unassignedShards.getNumIgnoredPrimaries() > 0__    };returns,code,true,code,iff,this,link,routing,nodes,instance,has,any,unassigned,primaries,even,if,the,primaries,are,marked,as,temporarily,ignored;public,boolean,has,unassigned,primaries,return,unassigned,shards,get,num,primaries,unassigned,shards,get,num,ignored,primaries,0
RoutingNodes -> public boolean hasUnassignedPrimaries();1548259585;Returns <code>true</code> iff this {@link RoutingNodes} instance has any unassigned primaries even if the_primaries are marked as temporarily ignored.;public boolean hasUnassignedPrimaries() {_        return unassignedShards.getNumPrimaries() + unassignedShards.getNumIgnoredPrimaries() > 0__    };returns,code,true,code,iff,this,link,routing,nodes,instance,has,any,unassigned,primaries,even,if,the,primaries,are,marked,as,temporarily,ignored;public,boolean,has,unassigned,primaries,return,unassigned,shards,get,num,primaries,unassigned,shards,get,num,ignored,primaries,0
RoutingNodes -> public boolean hasUnassignedPrimaries();1549912434;Returns <code>true</code> iff this {@link RoutingNodes} instance has any unassigned primaries even if the_primaries are marked as temporarily ignored.;public boolean hasUnassignedPrimaries() {_        return unassignedShards.getNumPrimaries() + unassignedShards.getNumIgnoredPrimaries() > 0__    };returns,code,true,code,iff,this,link,routing,nodes,instance,has,any,unassigned,primaries,even,if,the,primaries,are,marked,as,temporarily,ignored;public,boolean,has,unassigned,primaries,return,unassigned,shards,get,num,primaries,unassigned,shards,get,num,ignored,primaries,0
RoutingNodes -> private ShardRouting cancelRelocation(ShardRouting shard);1524684173;Cancels a relocation of a shard that shard must relocating.__@return the shard after cancelling relocation;private ShardRouting cancelRelocation(ShardRouting shard) {_        relocatingShards--__        ShardRouting cancelledShard = shard.cancelRelocation()__        updateAssigned(shard, cancelledShard)__        return cancelledShard__    };cancels,a,relocation,of,a,shard,that,shard,must,relocating,return,the,shard,after,cancelling,relocation;private,shard,routing,cancel,relocation,shard,routing,shard,relocating,shards,shard,routing,cancelled,shard,shard,cancel,relocation,update,assigned,shard,cancelled,shard,return,cancelled,shard
RoutingNodes -> private ShardRouting cancelRelocation(ShardRouting shard);1540847035;Cancels a relocation of a shard that shard must relocating.__@return the shard after cancelling relocation;private ShardRouting cancelRelocation(ShardRouting shard) {_        relocatingShards--__        ShardRouting cancelledShard = shard.cancelRelocation()__        updateAssigned(shard, cancelledShard)__        return cancelledShard__    };cancels,a,relocation,of,a,shard,that,shard,must,relocating,return,the,shard,after,cancelling,relocation;private,shard,routing,cancel,relocation,shard,routing,shard,relocating,shards,shard,routing,cancelled,shard,shard,cancel,relocation,update,assigned,shard,cancelled,shard,return,cancelled,shard
RoutingNodes -> private ShardRouting cancelRelocation(ShardRouting shard);1541446827;Cancels a relocation of a shard that shard must relocating.__@return the shard after cancelling relocation;private ShardRouting cancelRelocation(ShardRouting shard) {_        relocatingShards--__        ShardRouting cancelledShard = shard.cancelRelocation()__        updateAssigned(shard, cancelledShard)__        return cancelledShard__    };cancels,a,relocation,of,a,shard,that,shard,must,relocating,return,the,shard,after,cancelling,relocation;private,shard,routing,cancel,relocation,shard,routing,shard,relocating,shards,shard,routing,cancelled,shard,shard,cancel,relocation,update,assigned,shard,cancelled,shard,return,cancelled,shard
RoutingNodes -> private ShardRouting cancelRelocation(ShardRouting shard);1548259585;Cancels a relocation of a shard that shard must relocating.__@return the shard after cancelling relocation;private ShardRouting cancelRelocation(ShardRouting shard) {_        relocatingShards--__        ShardRouting cancelledShard = shard.cancelRelocation()__        updateAssigned(shard, cancelledShard)__        return cancelledShard__    };cancels,a,relocation,of,a,shard,that,shard,must,relocating,return,the,shard,after,cancelling,relocation;private,shard,routing,cancel,relocation,shard,routing,shard,relocating,shards,shard,routing,cancelled,shard,shard,cancel,relocation,update,assigned,shard,cancelled,shard,return,cancelled,shard
RoutingNodes -> private ShardRouting cancelRelocation(ShardRouting shard);1549912434;Cancels a relocation of a shard that shard must relocating.__@return the shard after cancelling relocation;private ShardRouting cancelRelocation(ShardRouting shard) {_        relocatingShards--__        ShardRouting cancelledShard = shard.cancelRelocation()__        updateAssigned(shard, cancelledShard)__        return cancelledShard__    };cancels,a,relocation,of,a,shard,that,shard,must,relocating,return,the,shard,after,cancelling,relocation;private,shard,routing,cancel,relocation,shard,routing,shard,relocating,shards,shard,routing,cancelled,shard,shard,cancel,relocation,update,assigned,shard,cancelled,shard,return,cancelled,shard
RoutingNodes -> UnassignedShards -> public int getNumIgnoredPrimaries();1524684173;Returns the number of temporarily marked as ignored unassigned primaries;public int getNumIgnoredPrimaries() { return ignoredPrimaries_ };returns,the,number,of,temporarily,marked,as,ignored,unassigned,primaries;public,int,get,num,ignored,primaries,return,ignored,primaries
RoutingNodes -> UnassignedShards -> public int getNumIgnoredPrimaries();1540847035;Returns the number of temporarily marked as ignored unassigned primaries;public int getNumIgnoredPrimaries() { return ignoredPrimaries_ };returns,the,number,of,temporarily,marked,as,ignored,unassigned,primaries;public,int,get,num,ignored,primaries,return,ignored,primaries
RoutingNodes -> UnassignedShards -> public int getNumIgnoredPrimaries();1541446827;Returns the number of temporarily marked as ignored unassigned primaries;public int getNumIgnoredPrimaries() { return ignoredPrimaries_ };returns,the,number,of,temporarily,marked,as,ignored,unassigned,primaries;public,int,get,num,ignored,primaries,return,ignored,primaries
RoutingNodes -> UnassignedShards -> public int getNumIgnoredPrimaries();1548259585;Returns the number of temporarily marked as ignored unassigned primaries;public int getNumIgnoredPrimaries() { return ignoredPrimaries_ };returns,the,number,of,temporarily,marked,as,ignored,unassigned,primaries;public,int,get,num,ignored,primaries,return,ignored,primaries
RoutingNodes -> UnassignedShards -> public int getNumIgnoredPrimaries();1549912434;Returns the number of temporarily marked as ignored unassigned primaries;public int getNumIgnoredPrimaries() { return ignoredPrimaries_ };returns,the,number,of,temporarily,marked,as,ignored,unassigned,primaries;public,int,get,num,ignored,primaries,return,ignored,primaries
RoutingNodes -> private ShardRouting movePrimaryToUnassignedAndDemoteToReplica(ShardRouting shard, UnassignedInfo unassignedInfo);1524684173;Moves assigned primary to unassigned and demotes it to a replica._Used in conjunction with {@link #promoteActiveReplicaShardToPrimary} when an active replica is promoted to primary.;private ShardRouting movePrimaryToUnassignedAndDemoteToReplica(ShardRouting shard, UnassignedInfo unassignedInfo) {_        assert shard.unassigned() == false : "only assigned shards can be moved to unassigned (" + shard + ")"__        assert shard.primary() : "only primary can be demoted to replica (" + shard + ")"__        remove(shard)__        ShardRouting unassigned = shard.moveToUnassigned(unassignedInfo).moveUnassignedFromPrimary()__        unassignedShards.add(unassigned)__        return unassigned__    };moves,assigned,primary,to,unassigned,and,demotes,it,to,a,replica,used,in,conjunction,with,link,promote,active,replica,shard,to,primary,when,an,active,replica,is,promoted,to,primary;private,shard,routing,move,primary,to,unassigned,and,demote,to,replica,shard,routing,shard,unassigned,info,unassigned,info,assert,shard,unassigned,false,only,assigned,shards,can,be,moved,to,unassigned,shard,assert,shard,primary,only,primary,can,be,demoted,to,replica,shard,remove,shard,shard,routing,unassigned,shard,move,to,unassigned,unassigned,info,move,unassigned,from,primary,unassigned,shards,add,unassigned,return,unassigned
RoutingNodes -> private ShardRouting movePrimaryToUnassignedAndDemoteToReplica(ShardRouting shard, UnassignedInfo unassignedInfo);1540847035;Moves assigned primary to unassigned and demotes it to a replica._Used in conjunction with {@link #promoteActiveReplicaShardToPrimary} when an active replica is promoted to primary.;private ShardRouting movePrimaryToUnassignedAndDemoteToReplica(ShardRouting shard, UnassignedInfo unassignedInfo) {_        assert shard.unassigned() == false : "only assigned shards can be moved to unassigned (" + shard + ")"__        assert shard.primary() : "only primary can be demoted to replica (" + shard + ")"__        remove(shard)__        ShardRouting unassigned = shard.moveToUnassigned(unassignedInfo).moveUnassignedFromPrimary()__        unassignedShards.add(unassigned)__        return unassigned__    };moves,assigned,primary,to,unassigned,and,demotes,it,to,a,replica,used,in,conjunction,with,link,promote,active,replica,shard,to,primary,when,an,active,replica,is,promoted,to,primary;private,shard,routing,move,primary,to,unassigned,and,demote,to,replica,shard,routing,shard,unassigned,info,unassigned,info,assert,shard,unassigned,false,only,assigned,shards,can,be,moved,to,unassigned,shard,assert,shard,primary,only,primary,can,be,demoted,to,replica,shard,remove,shard,shard,routing,unassigned,shard,move,to,unassigned,unassigned,info,move,unassigned,from,primary,unassigned,shards,add,unassigned,return,unassigned
RoutingNodes -> private ShardRouting movePrimaryToUnassignedAndDemoteToReplica(ShardRouting shard, UnassignedInfo unassignedInfo);1541446827;Moves assigned primary to unassigned and demotes it to a replica._Used in conjunction with {@link #promoteActiveReplicaShardToPrimary} when an active replica is promoted to primary.;private ShardRouting movePrimaryToUnassignedAndDemoteToReplica(ShardRouting shard, UnassignedInfo unassignedInfo) {_        assert shard.unassigned() == false : "only assigned shards can be moved to unassigned (" + shard + ")"__        assert shard.primary() : "only primary can be demoted to replica (" + shard + ")"__        remove(shard)__        ShardRouting unassigned = shard.moveToUnassigned(unassignedInfo).moveUnassignedFromPrimary()__        unassignedShards.add(unassigned)__        return unassigned__    };moves,assigned,primary,to,unassigned,and,demotes,it,to,a,replica,used,in,conjunction,with,link,promote,active,replica,shard,to,primary,when,an,active,replica,is,promoted,to,primary;private,shard,routing,move,primary,to,unassigned,and,demote,to,replica,shard,routing,shard,unassigned,info,unassigned,info,assert,shard,unassigned,false,only,assigned,shards,can,be,moved,to,unassigned,shard,assert,shard,primary,only,primary,can,be,demoted,to,replica,shard,remove,shard,shard,routing,unassigned,shard,move,to,unassigned,unassigned,info,move,unassigned,from,primary,unassigned,shards,add,unassigned,return,unassigned
RoutingNodes -> private ShardRouting movePrimaryToUnassignedAndDemoteToReplica(ShardRouting shard, UnassignedInfo unassignedInfo);1548259585;Moves assigned primary to unassigned and demotes it to a replica._Used in conjunction with {@link #promoteActiveReplicaShardToPrimary} when an active replica is promoted to primary.;private ShardRouting movePrimaryToUnassignedAndDemoteToReplica(ShardRouting shard, UnassignedInfo unassignedInfo) {_        assert shard.unassigned() == false : "only assigned shards can be moved to unassigned (" + shard + ")"__        assert shard.primary() : "only primary can be demoted to replica (" + shard + ")"__        remove(shard)__        ShardRouting unassigned = shard.moveToUnassigned(unassignedInfo).moveUnassignedFromPrimary()__        unassignedShards.add(unassigned)__        return unassigned__    };moves,assigned,primary,to,unassigned,and,demotes,it,to,a,replica,used,in,conjunction,with,link,promote,active,replica,shard,to,primary,when,an,active,replica,is,promoted,to,primary;private,shard,routing,move,primary,to,unassigned,and,demote,to,replica,shard,routing,shard,unassigned,info,unassigned,info,assert,shard,unassigned,false,only,assigned,shards,can,be,moved,to,unassigned,shard,assert,shard,primary,only,primary,can,be,demoted,to,replica,shard,remove,shard,shard,routing,unassigned,shard,move,to,unassigned,unassigned,info,move,unassigned,from,primary,unassigned,shards,add,unassigned,return,unassigned
RoutingNodes -> private ShardRouting movePrimaryToUnassignedAndDemoteToReplica(ShardRouting shard, UnassignedInfo unassignedInfo);1549912434;Moves assigned primary to unassigned and demotes it to a replica._Used in conjunction with {@link #promoteActiveReplicaShardToPrimary} when an active replica is promoted to primary.;private ShardRouting movePrimaryToUnassignedAndDemoteToReplica(ShardRouting shard, UnassignedInfo unassignedInfo) {_        assert shard.unassigned() == false : "only assigned shards can be moved to unassigned (" + shard + ")"__        assert shard.primary() : "only primary can be demoted to replica (" + shard + ")"__        remove(shard)__        ShardRouting unassigned = shard.moveToUnassigned(unassignedInfo).moveUnassignedFromPrimary()__        unassignedShards.add(unassigned)__        return unassigned__    };moves,assigned,primary,to,unassigned,and,demotes,it,to,a,replica,used,in,conjunction,with,link,promote,active,replica,shard,to,primary,when,an,active,replica,is,promoted,to,primary;private,shard,routing,move,primary,to,unassigned,and,demote,to,replica,shard,routing,shard,unassigned,info,unassigned,info,assert,shard,unassigned,false,only,assigned,shards,can,be,moved,to,unassigned,shard,assert,shard,primary,only,primary,can,be,demoted,to,replica,shard,remove,shard,shard,routing,unassigned,shard,move,to,unassigned,unassigned,info,move,unassigned,from,primary,unassigned,shards,add,unassigned,return,unassigned
RoutingNodes -> UnassignedShards -> UnassignedIterator -> public void removeAndIgnore(AllocationStatus attempt, RoutingChangesObserver changes);1524684173;Removes and ignores the unassigned shard (will be ignored for this run, but_will be added back to unassigned once the metadata is constructed again)._Typically this is used when an allocation decision prevents a shard from being allocated such_that subsequent consumers of this API won't try to allocate this shard again.__@param attempt the result of the allocation attempt;public void removeAndIgnore(AllocationStatus attempt, RoutingChangesObserver changes) {_                nodes.ensureMutable()__                innerRemove()__                ignoreShard(current, attempt, changes)__            };removes,and,ignores,the,unassigned,shard,will,be,ignored,for,this,run,but,will,be,added,back,to,unassigned,once,the,metadata,is,constructed,again,typically,this,is,used,when,an,allocation,decision,prevents,a,shard,from,being,allocated,such,that,subsequent,consumers,of,this,api,won,t,try,to,allocate,this,shard,again,param,attempt,the,result,of,the,allocation,attempt;public,void,remove,and,ignore,allocation,status,attempt,routing,changes,observer,changes,nodes,ensure,mutable,inner,remove,ignore,shard,current,attempt,changes
RoutingNodes -> UnassignedShards -> UnassignedIterator -> public void removeAndIgnore(AllocationStatus attempt, RoutingChangesObserver changes);1540847035;Removes and ignores the unassigned shard (will be ignored for this run, but_will be added back to unassigned once the metadata is constructed again)._Typically this is used when an allocation decision prevents a shard from being allocated such_that subsequent consumers of this API won't try to allocate this shard again.__@param attempt the result of the allocation attempt;public void removeAndIgnore(AllocationStatus attempt, RoutingChangesObserver changes) {_                nodes.ensureMutable()__                innerRemove()__                ignoreShard(current, attempt, changes)__            };removes,and,ignores,the,unassigned,shard,will,be,ignored,for,this,run,but,will,be,added,back,to,unassigned,once,the,metadata,is,constructed,again,typically,this,is,used,when,an,allocation,decision,prevents,a,shard,from,being,allocated,such,that,subsequent,consumers,of,this,api,won,t,try,to,allocate,this,shard,again,param,attempt,the,result,of,the,allocation,attempt;public,void,remove,and,ignore,allocation,status,attempt,routing,changes,observer,changes,nodes,ensure,mutable,inner,remove,ignore,shard,current,attempt,changes
RoutingNodes -> UnassignedShards -> UnassignedIterator -> public void removeAndIgnore(AllocationStatus attempt, RoutingChangesObserver changes);1541446827;Removes and ignores the unassigned shard (will be ignored for this run, but_will be added back to unassigned once the metadata is constructed again)._Typically this is used when an allocation decision prevents a shard from being allocated such_that subsequent consumers of this API won't try to allocate this shard again.__@param attempt the result of the allocation attempt;public void removeAndIgnore(AllocationStatus attempt, RoutingChangesObserver changes) {_                nodes.ensureMutable()__                innerRemove()__                ignoreShard(current, attempt, changes)__            };removes,and,ignores,the,unassigned,shard,will,be,ignored,for,this,run,but,will,be,added,back,to,unassigned,once,the,metadata,is,constructed,again,typically,this,is,used,when,an,allocation,decision,prevents,a,shard,from,being,allocated,such,that,subsequent,consumers,of,this,api,won,t,try,to,allocate,this,shard,again,param,attempt,the,result,of,the,allocation,attempt;public,void,remove,and,ignore,allocation,status,attempt,routing,changes,observer,changes,nodes,ensure,mutable,inner,remove,ignore,shard,current,attempt,changes
RoutingNodes -> UnassignedShards -> UnassignedIterator -> public void removeAndIgnore(AllocationStatus attempt, RoutingChangesObserver changes);1548259585;Removes and ignores the unassigned shard (will be ignored for this run, but_will be added back to unassigned once the metadata is constructed again)._Typically this is used when an allocation decision prevents a shard from being allocated such_that subsequent consumers of this API won't try to allocate this shard again.__@param attempt the result of the allocation attempt;public void removeAndIgnore(AllocationStatus attempt, RoutingChangesObserver changes) {_                nodes.ensureMutable()__                innerRemove()__                ignoreShard(current, attempt, changes)__            };removes,and,ignores,the,unassigned,shard,will,be,ignored,for,this,run,but,will,be,added,back,to,unassigned,once,the,metadata,is,constructed,again,typically,this,is,used,when,an,allocation,decision,prevents,a,shard,from,being,allocated,such,that,subsequent,consumers,of,this,api,won,t,try,to,allocate,this,shard,again,param,attempt,the,result,of,the,allocation,attempt;public,void,remove,and,ignore,allocation,status,attempt,routing,changes,observer,changes,nodes,ensure,mutable,inner,remove,ignore,shard,current,attempt,changes
RoutingNodes -> UnassignedShards -> UnassignedIterator -> public void removeAndIgnore(AllocationStatus attempt, RoutingChangesObserver changes);1549912434;Removes and ignores the unassigned shard (will be ignored for this run, but_will be added back to unassigned once the metadata is constructed again)._Typically this is used when an allocation decision prevents a shard from being allocated such_that subsequent consumers of this API won't try to allocate this shard again.__@param attempt the result of the allocation attempt;public void removeAndIgnore(AllocationStatus attempt, RoutingChangesObserver changes) {_                nodes.ensureMutable()__                innerRemove()__                ignoreShard(current, attempt, changes)__            };removes,and,ignores,the,unassigned,shard,will,be,ignored,for,this,run,but,will,be,added,back,to,unassigned,once,the,metadata,is,constructed,again,typically,this,is,used,when,an,allocation,decision,prevents,a,shard,from,being,allocated,such,that,subsequent,consumers,of,this,api,won,t,try,to,allocate,this,shard,again,param,attempt,the,result,of,the,allocation,attempt;public,void,remove,and,ignore,allocation,status,attempt,routing,changes,observer,changes,nodes,ensure,mutable,inner,remove,ignore,shard,current,attempt,changes
RoutingNodes -> UnassignedShards -> UnassignedIterator -> public ShardRouting updateUnassigned(UnassignedInfo unassignedInfo, RecoverySource recoverySource,                                                  RoutingChangesObserver changes);1524684173;updates the unassigned info and recovery source on the current unassigned shard__@param  unassignedInfo the new unassigned info to use_@param  recoverySource the new recovery source to use_@return the shard with unassigned info updated;public ShardRouting updateUnassigned(UnassignedInfo unassignedInfo, RecoverySource recoverySource,_                                                 RoutingChangesObserver changes) {_                nodes.ensureMutable()__                ShardRouting updatedShardRouting = current.updateUnassigned(unassignedInfo, recoverySource)__                changes.unassignedInfoUpdated(current, unassignedInfo)__                updateShardRouting(updatedShardRouting)__                return updatedShardRouting__            };updates,the,unassigned,info,and,recovery,source,on,the,current,unassigned,shard,param,unassigned,info,the,new,unassigned,info,to,use,param,recovery,source,the,new,recovery,source,to,use,return,the,shard,with,unassigned,info,updated;public,shard,routing,update,unassigned,unassigned,info,unassigned,info,recovery,source,recovery,source,routing,changes,observer,changes,nodes,ensure,mutable,shard,routing,updated,shard,routing,current,update,unassigned,unassigned,info,recovery,source,changes,unassigned,info,updated,current,unassigned,info,update,shard,routing,updated,shard,routing,return,updated,shard,routing
RoutingNodes -> UnassignedShards -> UnassignedIterator -> public ShardRouting updateUnassigned(UnassignedInfo unassignedInfo, RecoverySource recoverySource,                                                  RoutingChangesObserver changes);1540847035;updates the unassigned info and recovery source on the current unassigned shard__@param  unassignedInfo the new unassigned info to use_@param  recoverySource the new recovery source to use_@return the shard with unassigned info updated;public ShardRouting updateUnassigned(UnassignedInfo unassignedInfo, RecoverySource recoverySource,_                                                 RoutingChangesObserver changes) {_                nodes.ensureMutable()__                ShardRouting updatedShardRouting = current.updateUnassigned(unassignedInfo, recoverySource)__                changes.unassignedInfoUpdated(current, unassignedInfo)__                updateShardRouting(updatedShardRouting)__                return updatedShardRouting__            };updates,the,unassigned,info,and,recovery,source,on,the,current,unassigned,shard,param,unassigned,info,the,new,unassigned,info,to,use,param,recovery,source,the,new,recovery,source,to,use,return,the,shard,with,unassigned,info,updated;public,shard,routing,update,unassigned,unassigned,info,unassigned,info,recovery,source,recovery,source,routing,changes,observer,changes,nodes,ensure,mutable,shard,routing,updated,shard,routing,current,update,unassigned,unassigned,info,recovery,source,changes,unassigned,info,updated,current,unassigned,info,update,shard,routing,updated,shard,routing,return,updated,shard,routing
RoutingNodes -> UnassignedShards -> UnassignedIterator -> public ShardRouting updateUnassigned(UnassignedInfo unassignedInfo, RecoverySource recoverySource,                                                  RoutingChangesObserver changes);1541446827;updates the unassigned info and recovery source on the current unassigned shard__@param  unassignedInfo the new unassigned info to use_@param  recoverySource the new recovery source to use_@return the shard with unassigned info updated;public ShardRouting updateUnassigned(UnassignedInfo unassignedInfo, RecoverySource recoverySource,_                                                 RoutingChangesObserver changes) {_                nodes.ensureMutable()__                ShardRouting updatedShardRouting = current.updateUnassigned(unassignedInfo, recoverySource)__                changes.unassignedInfoUpdated(current, unassignedInfo)__                updateShardRouting(updatedShardRouting)__                return updatedShardRouting__            };updates,the,unassigned,info,and,recovery,source,on,the,current,unassigned,shard,param,unassigned,info,the,new,unassigned,info,to,use,param,recovery,source,the,new,recovery,source,to,use,return,the,shard,with,unassigned,info,updated;public,shard,routing,update,unassigned,unassigned,info,unassigned,info,recovery,source,recovery,source,routing,changes,observer,changes,nodes,ensure,mutable,shard,routing,updated,shard,routing,current,update,unassigned,unassigned,info,recovery,source,changes,unassigned,info,updated,current,unassigned,info,update,shard,routing,updated,shard,routing,return,updated,shard,routing
RoutingNodes -> UnassignedShards -> UnassignedIterator -> public ShardRouting updateUnassigned(UnassignedInfo unassignedInfo, RecoverySource recoverySource,                                                  RoutingChangesObserver changes);1548259585;updates the unassigned info and recovery source on the current unassigned shard__@param  unassignedInfo the new unassigned info to use_@param  recoverySource the new recovery source to use_@return the shard with unassigned info updated;public ShardRouting updateUnassigned(UnassignedInfo unassignedInfo, RecoverySource recoverySource,_                                                 RoutingChangesObserver changes) {_                nodes.ensureMutable()__                ShardRouting updatedShardRouting = current.updateUnassigned(unassignedInfo, recoverySource)__                changes.unassignedInfoUpdated(current, unassignedInfo)__                updateShardRouting(updatedShardRouting)__                return updatedShardRouting__            };updates,the,unassigned,info,and,recovery,source,on,the,current,unassigned,shard,param,unassigned,info,the,new,unassigned,info,to,use,param,recovery,source,the,new,recovery,source,to,use,return,the,shard,with,unassigned,info,updated;public,shard,routing,update,unassigned,unassigned,info,unassigned,info,recovery,source,recovery,source,routing,changes,observer,changes,nodes,ensure,mutable,shard,routing,updated,shard,routing,current,update,unassigned,unassigned,info,recovery,source,changes,unassigned,info,updated,current,unassigned,info,update,shard,routing,updated,shard,routing,return,updated,shard,routing
RoutingNodes -> UnassignedShards -> UnassignedIterator -> public ShardRouting updateUnassigned(UnassignedInfo unassignedInfo, RecoverySource recoverySource,                                                  RoutingChangesObserver changes);1549912434;updates the unassigned info and recovery source on the current unassigned shard__@param  unassignedInfo the new unassigned info to use_@param  recoverySource the new recovery source to use_@return the shard with unassigned info updated;public ShardRouting updateUnassigned(UnassignedInfo unassignedInfo, RecoverySource recoverySource,_                                                 RoutingChangesObserver changes) {_                nodes.ensureMutable()__                ShardRouting updatedShardRouting = current.updateUnassigned(unassignedInfo, recoverySource)__                changes.unassignedInfoUpdated(current, unassignedInfo)__                updateShardRouting(updatedShardRouting)__                return updatedShardRouting__            };updates,the,unassigned,info,and,recovery,source,on,the,current,unassigned,shard,param,unassigned,info,the,new,unassigned,info,to,use,param,recovery,source,the,new,recovery,source,to,use,return,the,shard,with,unassigned,info,updated;public,shard,routing,update,unassigned,unassigned,info,unassigned,info,recovery,source,recovery,source,routing,changes,observer,changes,nodes,ensure,mutable,shard,routing,updated,shard,routing,current,update,unassigned,unassigned,info,recovery,source,changes,unassigned,info,updated,current,unassigned,info,update,shard,routing,updated,shard,routing,return,updated,shard,routing
RoutingNodes -> private void remove(ShardRouting shard);1524684173;Cancels the give shard from the Routing nodes internal statistics and cancels_the relocation if the shard is relocating.;private void remove(ShardRouting shard) {_        assert shard.unassigned() == false : "only assigned shards can be removed here (" + shard + ")"__        node(shard.currentNodeId()).remove(shard)__        if (shard.initializing() && shard.relocatingNodeId() == null) {_            inactiveShardCount--__            assert inactiveShardCount >= 0__            if (shard.primary()) {_                inactivePrimaryCount--__            }_        } else if (shard.relocating()) {_            shard = cancelRelocation(shard)__        }_        assignedShardsRemove(shard)__        if (shard.initializing()) {_            removeRecovery(shard)__        }_    };cancels,the,give,shard,from,the,routing,nodes,internal,statistics,and,cancels,the,relocation,if,the,shard,is,relocating;private,void,remove,shard,routing,shard,assert,shard,unassigned,false,only,assigned,shards,can,be,removed,here,shard,node,shard,current,node,id,remove,shard,if,shard,initializing,shard,relocating,node,id,null,inactive,shard,count,assert,inactive,shard,count,0,if,shard,primary,inactive,primary,count,else,if,shard,relocating,shard,cancel,relocation,shard,assigned,shards,remove,shard,if,shard,initializing,remove,recovery,shard
RoutingNodes -> private void remove(ShardRouting shard);1540847035;Cancels the give shard from the Routing nodes internal statistics and cancels_the relocation if the shard is relocating.;private void remove(ShardRouting shard) {_        assert shard.unassigned() == false : "only assigned shards can be removed here (" + shard + ")"__        node(shard.currentNodeId()).remove(shard)__        if (shard.initializing() && shard.relocatingNodeId() == null) {_            inactiveShardCount--__            assert inactiveShardCount >= 0__            if (shard.primary()) {_                inactivePrimaryCount--__            }_        } else if (shard.relocating()) {_            shard = cancelRelocation(shard)__        }_        assignedShardsRemove(shard)__        if (shard.initializing()) {_            removeRecovery(shard)__        }_    };cancels,the,give,shard,from,the,routing,nodes,internal,statistics,and,cancels,the,relocation,if,the,shard,is,relocating;private,void,remove,shard,routing,shard,assert,shard,unassigned,false,only,assigned,shards,can,be,removed,here,shard,node,shard,current,node,id,remove,shard,if,shard,initializing,shard,relocating,node,id,null,inactive,shard,count,assert,inactive,shard,count,0,if,shard,primary,inactive,primary,count,else,if,shard,relocating,shard,cancel,relocation,shard,assigned,shards,remove,shard,if,shard,initializing,remove,recovery,shard
RoutingNodes -> private void remove(ShardRouting shard);1541446827;Cancels the give shard from the Routing nodes internal statistics and cancels_the relocation if the shard is relocating.;private void remove(ShardRouting shard) {_        assert shard.unassigned() == false : "only assigned shards can be removed here (" + shard + ")"__        node(shard.currentNodeId()).remove(shard)__        if (shard.initializing() && shard.relocatingNodeId() == null) {_            inactiveShardCount--__            assert inactiveShardCount >= 0__            if (shard.primary()) {_                inactivePrimaryCount--__            }_        } else if (shard.relocating()) {_            shard = cancelRelocation(shard)__        }_        assignedShardsRemove(shard)__        if (shard.initializing()) {_            removeRecovery(shard)__        }_    };cancels,the,give,shard,from,the,routing,nodes,internal,statistics,and,cancels,the,relocation,if,the,shard,is,relocating;private,void,remove,shard,routing,shard,assert,shard,unassigned,false,only,assigned,shards,can,be,removed,here,shard,node,shard,current,node,id,remove,shard,if,shard,initializing,shard,relocating,node,id,null,inactive,shard,count,assert,inactive,shard,count,0,if,shard,primary,inactive,primary,count,else,if,shard,relocating,shard,cancel,relocation,shard,assigned,shards,remove,shard,if,shard,initializing,remove,recovery,shard
RoutingNodes -> private void remove(ShardRouting shard);1548259585;Cancels the give shard from the Routing nodes internal statistics and cancels_the relocation if the shard is relocating.;private void remove(ShardRouting shard) {_        assert shard.unassigned() == false : "only assigned shards can be removed here (" + shard + ")"__        node(shard.currentNodeId()).remove(shard)__        if (shard.initializing() && shard.relocatingNodeId() == null) {_            inactiveShardCount--__            assert inactiveShardCount >= 0__            if (shard.primary()) {_                inactivePrimaryCount--__            }_        } else if (shard.relocating()) {_            shard = cancelRelocation(shard)__        }_        assignedShardsRemove(shard)__        if (shard.initializing()) {_            removeRecovery(shard)__        }_    };cancels,the,give,shard,from,the,routing,nodes,internal,statistics,and,cancels,the,relocation,if,the,shard,is,relocating;private,void,remove,shard,routing,shard,assert,shard,unassigned,false,only,assigned,shards,can,be,removed,here,shard,node,shard,current,node,id,remove,shard,if,shard,initializing,shard,relocating,node,id,null,inactive,shard,count,assert,inactive,shard,count,0,if,shard,primary,inactive,primary,count,else,if,shard,relocating,shard,cancel,relocation,shard,assigned,shards,remove,shard,if,shard,initializing,remove,recovery,shard
RoutingNodes -> private void remove(ShardRouting shard);1549912434;Cancels the give shard from the Routing nodes internal statistics and cancels_the relocation if the shard is relocating.;private void remove(ShardRouting shard) {_        assert shard.unassigned() == false : "only assigned shards can be removed here (" + shard + ")"__        node(shard.currentNodeId()).remove(shard)__        if (shard.initializing() && shard.relocatingNodeId() == null) {_            inactiveShardCount--__            assert inactiveShardCount >= 0__            if (shard.primary()) {_                inactivePrimaryCount--__            }_        } else if (shard.relocating()) {_            shard = cancelRelocation(shard)__        }_        assignedShardsRemove(shard)__        if (shard.initializing()) {_            removeRecovery(shard)__        }_    };cancels,the,give,shard,from,the,routing,nodes,internal,statistics,and,cancels,the,relocation,if,the,shard,is,relocating;private,void,remove,shard,routing,shard,assert,shard,unassigned,false,only,assigned,shards,can,be,removed,here,shard,node,shard,current,node,id,remove,shard,if,shard,initializing,shard,relocating,node,id,null,inactive,shard,count,assert,inactive,shard,count,0,if,shard,primary,inactive,primary,count,else,if,shard,relocating,shard,cancel,relocation,shard,assigned,shards,remove,shard,if,shard,initializing,remove,recovery,shard
RoutingNodes -> UnassignedShards -> public int size();1524684173;Returns the size of the non-ignored unassigned shards;public int size() { return unassigned.size()_ };returns,the,size,of,the,non,ignored,unassigned,shards;public,int,size,return,unassigned,size
RoutingNodes -> UnassignedShards -> public int size();1540847035;Returns the size of the non-ignored unassigned shards;public int size() { return unassigned.size()_ };returns,the,size,of,the,non,ignored,unassigned,shards;public,int,size,return,unassigned,size
RoutingNodes -> UnassignedShards -> public int size();1541446827;Returns the size of the non-ignored unassigned shards;public int size() { return unassigned.size()_ };returns,the,size,of,the,non,ignored,unassigned,shards;public,int,size,return,unassigned,size
RoutingNodes -> UnassignedShards -> public int size();1548259585;Returns the size of the non-ignored unassigned shards;public int size() { return unassigned.size()_ };returns,the,size,of,the,non,ignored,unassigned,shards;public,int,size,return,unassigned,size
RoutingNodes -> UnassignedShards -> public int size();1549912434;Returns the size of the non-ignored unassigned shards;public int size() { return unassigned.size()_ };returns,the,size,of,the,non,ignored,unassigned,shards;public,int,size,return,unassigned,size
RoutingNodes -> UnassignedShards -> public boolean isEmpty();1524684173;Returns <code>true</code> iff this collection contains one or more non-ignored unassigned shards.;public boolean isEmpty() {_            return unassigned.isEmpty()__        };returns,code,true,code,iff,this,collection,contains,one,or,more,non,ignored,unassigned,shards;public,boolean,is,empty,return,unassigned,is,empty
RoutingNodes -> UnassignedShards -> public boolean isEmpty();1540847035;Returns <code>true</code> iff this collection contains one or more non-ignored unassigned shards.;public boolean isEmpty() {_            return unassigned.isEmpty()__        };returns,code,true,code,iff,this,collection,contains,one,or,more,non,ignored,unassigned,shards;public,boolean,is,empty,return,unassigned,is,empty
RoutingNodes -> UnassignedShards -> public boolean isEmpty();1541446827;Returns <code>true</code> iff this collection contains one or more non-ignored unassigned shards.;public boolean isEmpty() {_            return unassigned.isEmpty()__        };returns,code,true,code,iff,this,collection,contains,one,or,more,non,ignored,unassigned,shards;public,boolean,is,empty,return,unassigned,is,empty
RoutingNodes -> UnassignedShards -> public boolean isEmpty();1548259585;Returns <code>true</code> iff this collection contains one or more non-ignored unassigned shards.;public boolean isEmpty() {_            return unassigned.isEmpty()__        };returns,code,true,code,iff,this,collection,contains,one,or,more,non,ignored,unassigned,shards;public,boolean,is,empty,return,unassigned,is,empty
RoutingNodes -> UnassignedShards -> public boolean isEmpty();1549912434;Returns <code>true</code> iff this collection contains one or more non-ignored unassigned shards.;public boolean isEmpty() {_            return unassigned.isEmpty()__        };returns,code,true,code,iff,this,collection,contains,one,or,more,non,ignored,unassigned,shards;public,boolean,is,empty,return,unassigned,is,empty
RoutingNodes -> public int size();1524684173;Returns the number of routing nodes;public int size() {_        return nodesToShards.size()__    };returns,the,number,of,routing,nodes;public,int,size,return,nodes,to,shards,size
RoutingNodes -> public int size();1540847035;Returns the number of routing nodes;public int size() {_        return nodesToShards.size()__    };returns,the,number,of,routing,nodes;public,int,size,return,nodes,to,shards,size
RoutingNodes -> public int size();1541446827;Returns the number of routing nodes;public int size() {_        return nodesToShards.size()__    };returns,the,number,of,routing,nodes;public,int,size,return,nodes,to,shards,size
RoutingNodes -> public int size();1548259585;Returns the number of routing nodes;public int size() {_        return nodesToShards.size()__    };returns,the,number,of,routing,nodes;public,int,size,return,nodes,to,shards,size
RoutingNodes -> public int size();1549912434;Returns the number of routing nodes;public int size() {_        return nodesToShards.size()__    };returns,the,number,of,routing,nodes;public,int,size,return,nodes,to,shards,size
RoutingNodes -> private ShardRouting started(ShardRouting shard);1524684173;Mark a shard as started and adjusts internal statistics.__@return the started shard;private ShardRouting started(ShardRouting shard) {_        assert shard.initializing() : "expected an initializing shard " + shard__        if (shard.relocatingNodeId() == null) {_            _            inactiveShardCount--__            if (shard.primary()) {_                inactivePrimaryCount--__            }_        }_        removeRecovery(shard)__        ShardRouting startedShard = shard.moveToStarted()__        updateAssigned(shard, startedShard)__        return startedShard__    };mark,a,shard,as,started,and,adjusts,internal,statistics,return,the,started,shard;private,shard,routing,started,shard,routing,shard,assert,shard,initializing,expected,an,initializing,shard,shard,if,shard,relocating,node,id,null,inactive,shard,count,if,shard,primary,inactive,primary,count,remove,recovery,shard,shard,routing,started,shard,shard,move,to,started,update,assigned,shard,started,shard,return,started,shard
RoutingNodes -> private ShardRouting started(ShardRouting shard);1540847035;Mark a shard as started and adjusts internal statistics.__@return the started shard;private ShardRouting started(ShardRouting shard) {_        assert shard.initializing() : "expected an initializing shard " + shard__        if (shard.relocatingNodeId() == null) {_            _            inactiveShardCount--__            if (shard.primary()) {_                inactivePrimaryCount--__            }_        }_        removeRecovery(shard)__        ShardRouting startedShard = shard.moveToStarted()__        updateAssigned(shard, startedShard)__        return startedShard__    };mark,a,shard,as,started,and,adjusts,internal,statistics,return,the,started,shard;private,shard,routing,started,shard,routing,shard,assert,shard,initializing,expected,an,initializing,shard,shard,if,shard,relocating,node,id,null,inactive,shard,count,if,shard,primary,inactive,primary,count,remove,recovery,shard,shard,routing,started,shard,shard,move,to,started,update,assigned,shard,started,shard,return,started,shard
RoutingNodes -> private ShardRouting started(ShardRouting shard);1541446827;Mark a shard as started and adjusts internal statistics.__@return the started shard;private ShardRouting started(ShardRouting shard) {_        assert shard.initializing() : "expected an initializing shard " + shard__        if (shard.relocatingNodeId() == null) {_            _            inactiveShardCount--__            if (shard.primary()) {_                inactivePrimaryCount--__            }_        }_        removeRecovery(shard)__        ShardRouting startedShard = shard.moveToStarted()__        updateAssigned(shard, startedShard)__        return startedShard__    };mark,a,shard,as,started,and,adjusts,internal,statistics,return,the,started,shard;private,shard,routing,started,shard,routing,shard,assert,shard,initializing,expected,an,initializing,shard,shard,if,shard,relocating,node,id,null,inactive,shard,count,if,shard,primary,inactive,primary,count,remove,recovery,shard,shard,routing,started,shard,shard,move,to,started,update,assigned,shard,started,shard,return,started,shard
RoutingNodes -> private ShardRouting started(ShardRouting shard);1548259585;Mark a shard as started and adjusts internal statistics.__@return the started shard;private ShardRouting started(ShardRouting shard) {_        assert shard.initializing() : "expected an initializing shard " + shard__        if (shard.relocatingNodeId() == null) {_            _            inactiveShardCount--__            if (shard.primary()) {_                inactivePrimaryCount--__            }_        }_        removeRecovery(shard)__        ShardRouting startedShard = shard.moveToStarted()__        updateAssigned(shard, startedShard)__        return startedShard__    };mark,a,shard,as,started,and,adjusts,internal,statistics,return,the,started,shard;private,shard,routing,started,shard,routing,shard,assert,shard,initializing,expected,an,initializing,shard,shard,if,shard,relocating,node,id,null,inactive,shard,count,if,shard,primary,inactive,primary,count,remove,recovery,shard,shard,routing,started,shard,shard,move,to,started,update,assigned,shard,started,shard,return,started,shard
RoutingNodes -> private ShardRouting started(ShardRouting shard);1549912434;Mark a shard as started and adjusts internal statistics.__@return the started shard;private ShardRouting started(ShardRouting shard) {_        assert shard.initializing() : "expected an initializing shard " + shard__        if (shard.relocatingNodeId() == null) {_            _            inactiveShardCount--__            if (shard.primary()) {_                inactivePrimaryCount--__            }_        }_        removeRecovery(shard)__        ShardRouting startedShard = shard.moveToStarted()__        updateAssigned(shard, startedShard)__        return startedShard__    };mark,a,shard,as,started,and,adjusts,internal,statistics,return,the,started,shard;private,shard,routing,started,shard,routing,shard,assert,shard,initializing,expected,an,initializing,shard,shard,if,shard,relocating,node,id,null,inactive,shard,count,if,shard,primary,inactive,primary,count,remove,recovery,shard,shard,routing,started,shard,shard,move,to,started,update,assigned,shard,started,shard,return,started,shard
RoutingNodes -> private ShardRouting promoteActiveReplicaShardToPrimary(ShardRouting replicaShard);1524684173;moves the assigned replica shard to primary.__@param replicaShard the replica shard to be promoted to primary_@return             the resulting primary shard;private ShardRouting promoteActiveReplicaShardToPrimary(ShardRouting replicaShard) {_        assert replicaShard.active() : "non-active shard cannot be promoted to primary: " + replicaShard__        assert replicaShard.primary() == false : "primary shard cannot be promoted to primary: " + replicaShard__        ShardRouting primaryShard = replicaShard.moveActiveReplicaToPrimary()__        updateAssigned(replicaShard, primaryShard)__        return primaryShard__    };moves,the,assigned,replica,shard,to,primary,param,replica,shard,the,replica,shard,to,be,promoted,to,primary,return,the,resulting,primary,shard;private,shard,routing,promote,active,replica,shard,to,primary,shard,routing,replica,shard,assert,replica,shard,active,non,active,shard,cannot,be,promoted,to,primary,replica,shard,assert,replica,shard,primary,false,primary,shard,cannot,be,promoted,to,primary,replica,shard,shard,routing,primary,shard,replica,shard,move,active,replica,to,primary,update,assigned,replica,shard,primary,shard,return,primary,shard
RoutingNodes -> private ShardRouting promoteActiveReplicaShardToPrimary(ShardRouting replicaShard);1540847035;moves the assigned replica shard to primary.__@param replicaShard the replica shard to be promoted to primary_@return             the resulting primary shard;private ShardRouting promoteActiveReplicaShardToPrimary(ShardRouting replicaShard) {_        assert replicaShard.active() : "non-active shard cannot be promoted to primary: " + replicaShard__        assert replicaShard.primary() == false : "primary shard cannot be promoted to primary: " + replicaShard__        ShardRouting primaryShard = replicaShard.moveActiveReplicaToPrimary()__        updateAssigned(replicaShard, primaryShard)__        return primaryShard__    };moves,the,assigned,replica,shard,to,primary,param,replica,shard,the,replica,shard,to,be,promoted,to,primary,return,the,resulting,primary,shard;private,shard,routing,promote,active,replica,shard,to,primary,shard,routing,replica,shard,assert,replica,shard,active,non,active,shard,cannot,be,promoted,to,primary,replica,shard,assert,replica,shard,primary,false,primary,shard,cannot,be,promoted,to,primary,replica,shard,shard,routing,primary,shard,replica,shard,move,active,replica,to,primary,update,assigned,replica,shard,primary,shard,return,primary,shard
RoutingNodes -> private ShardRouting promoteActiveReplicaShardToPrimary(ShardRouting replicaShard);1541446827;moves the assigned replica shard to primary.__@param replicaShard the replica shard to be promoted to primary_@return             the resulting primary shard;private ShardRouting promoteActiveReplicaShardToPrimary(ShardRouting replicaShard) {_        assert replicaShard.active() : "non-active shard cannot be promoted to primary: " + replicaShard__        assert replicaShard.primary() == false : "primary shard cannot be promoted to primary: " + replicaShard__        ShardRouting primaryShard = replicaShard.moveActiveReplicaToPrimary()__        updateAssigned(replicaShard, primaryShard)__        return primaryShard__    };moves,the,assigned,replica,shard,to,primary,param,replica,shard,the,replica,shard,to,be,promoted,to,primary,return,the,resulting,primary,shard;private,shard,routing,promote,active,replica,shard,to,primary,shard,routing,replica,shard,assert,replica,shard,active,non,active,shard,cannot,be,promoted,to,primary,replica,shard,assert,replica,shard,primary,false,primary,shard,cannot,be,promoted,to,primary,replica,shard,shard,routing,primary,shard,replica,shard,move,active,replica,to,primary,update,assigned,replica,shard,primary,shard,return,primary,shard
RoutingNodes -> private ShardRouting promoteActiveReplicaShardToPrimary(ShardRouting replicaShard);1548259585;moves the assigned replica shard to primary.__@param replicaShard the replica shard to be promoted to primary_@return             the resulting primary shard;private ShardRouting promoteActiveReplicaShardToPrimary(ShardRouting replicaShard) {_        assert replicaShard.active() : "non-active shard cannot be promoted to primary: " + replicaShard__        assert replicaShard.primary() == false : "primary shard cannot be promoted to primary: " + replicaShard__        ShardRouting primaryShard = replicaShard.moveActiveReplicaToPrimary()__        updateAssigned(replicaShard, primaryShard)__        return primaryShard__    };moves,the,assigned,replica,shard,to,primary,param,replica,shard,the,replica,shard,to,be,promoted,to,primary,return,the,resulting,primary,shard;private,shard,routing,promote,active,replica,shard,to,primary,shard,routing,replica,shard,assert,replica,shard,active,non,active,shard,cannot,be,promoted,to,primary,replica,shard,assert,replica,shard,primary,false,primary,shard,cannot,be,promoted,to,primary,replica,shard,shard,routing,primary,shard,replica,shard,move,active,replica,to,primary,update,assigned,replica,shard,primary,shard,return,primary,shard
RoutingNodes -> private ShardRouting promoteActiveReplicaShardToPrimary(ShardRouting replicaShard);1549912434;moves the assigned replica shard to primary.__@param replicaShard the replica shard to be promoted to primary_@return             the resulting primary shard;private ShardRouting promoteActiveReplicaShardToPrimary(ShardRouting replicaShard) {_        assert replicaShard.active() : "non-active shard cannot be promoted to primary: " + replicaShard__        assert replicaShard.primary() == false : "primary shard cannot be promoted to primary: " + replicaShard__        ShardRouting primaryShard = replicaShard.moveActiveReplicaToPrimary()__        updateAssigned(replicaShard, primaryShard)__        return primaryShard__    };moves,the,assigned,replica,shard,to,primary,param,replica,shard,the,replica,shard,to,be,promoted,to,primary,return,the,resulting,primary,shard;private,shard,routing,promote,active,replica,shard,to,primary,shard,routing,replica,shard,assert,replica,shard,active,non,active,shard,cannot,be,promoted,to,primary,replica,shard,assert,replica,shard,primary,false,primary,shard,cannot,be,promoted,to,primary,replica,shard,shard,routing,primary,shard,replica,shard,move,active,replica,to,primary,update,assigned,replica,shard,primary,shard,return,primary,shard
RoutingNodes -> public void failShard(Logger logger, ShardRouting failedShard, UnassignedInfo unassignedInfo, IndexMetaData indexMetaData,                           RoutingChangesObserver routingChangesObserver);1524684173;Applies the relevant logic to handle a cancelled or failed shard.__Moves the shard to unassigned or completely removes the shard (if relocation target).__- If shard is a primary, this also fails initializing replicas._- If shard is an active primary, this also promotes an active replica to primary (if such a replica exists)._- If shard is a relocating primary, this also removes the primary relocation target shard._- If shard is a relocating replica, this promotes the replica relocation target to a full initializing replica, removing the_relocation source information. This is possible as peer recovery is always done from the primary._- If shard is a (primary or replica) relocation target, this also clears the relocation information on the source shard.;public void failShard(Logger logger, ShardRouting failedShard, UnassignedInfo unassignedInfo, IndexMetaData indexMetaData,_                          RoutingChangesObserver routingChangesObserver) {_        ensureMutable()__        assert failedShard.assignedToNode() : "only assigned shards can be failed"__        assert indexMetaData.getIndex().equals(failedShard.index()) :_            "shard failed for unknown index (shard entry: " + failedShard + ")"__        assert getByAllocationId(failedShard.shardId(), failedShard.allocationId().getId()) == failedShard :_            "shard routing to fail does not exist in routing table, expected: " + failedShard + " but was: " +_                getByAllocationId(failedShard.shardId(), failedShard.allocationId().getId())___        logger.debug("{} failing shard {} with unassigned info ({})", failedShard.shardId(), failedShard, unassignedInfo.shortSummary())___        _        if (failedShard.primary()) {_            List<ShardRouting> assignedShards = assignedShards(failedShard.shardId())__            if (assignedShards.isEmpty() == false) {_                _                for (ShardRouting routing : new ArrayList<>(assignedShards)) {_                    if (!routing.primary() && routing.initializing()) {_                        _                        ShardRouting replicaShard = getByAllocationId(routing.shardId(), routing.allocationId().getId())__                        assert replicaShard != null : "failed to re-resolve " + routing + " when failing replicas"__                        UnassignedInfo primaryFailedUnassignedInfo = new UnassignedInfo(UnassignedInfo.Reason.PRIMARY_FAILED,_                            "primary failed while replica initializing", null, 0, unassignedInfo.getUnassignedTimeInNanos(),_                            unassignedInfo.getUnassignedTimeInMillis(), false, AllocationStatus.NO_ATTEMPT)__                        failShard(logger, replicaShard, primaryFailedUnassignedInfo, indexMetaData, routingChangesObserver)__                    }_                }_            }_        }__        if (failedShard.relocating()) {_            _            ShardRouting targetShard = getByAllocationId(failedShard.shardId(), failedShard.allocationId().getRelocationId())__            assert targetShard.isRelocationTargetOf(failedShard)__            if (failedShard.primary()) {_                logger.trace("{} is removed due to the failure/cancellation of the source shard", targetShard)__                _                remove(targetShard)__                routingChangesObserver.shardFailed(targetShard, unassignedInfo)__            } else {_                logger.trace("{}, relocation source failed / cancelled, mark as initializing without relocation source", targetShard)__                _                _                removeRelocationSource(targetShard)__                routingChangesObserver.relocationSourceRemoved(targetShard)__            }_        }__        _        if (failedShard.initializing()) {_            if (failedShard.relocatingNodeId() == null) {_                if (failedShard.primary()) {_                    _                    ShardRouting activeReplica = activeReplicaWithHighestVersion(failedShard.shardId())__                    if (activeReplica == null) {_                        moveToUnassigned(failedShard, unassignedInfo)__                    } else {_                        movePrimaryToUnassignedAndDemoteToReplica(failedShard, unassignedInfo)__                        promoteReplicaToPrimary(activeReplica, indexMetaData, routingChangesObserver)__                    }_                } else {_                    _                    moveToUnassigned(failedShard, unassignedInfo)__                }_            } else {_                _                _                logger.trace("{} is a relocation target, resolving source to cancel relocation ({})", failedShard,_                    unassignedInfo.shortSummary())__                ShardRouting sourceShard = getByAllocationId(failedShard.shardId(),_                    failedShard.allocationId().getRelocationId())__                assert sourceShard.isRelocationSourceOf(failedShard)__                logger.trace("{}, resolved source to [{}]. canceling relocation ... ({})", failedShard.shardId(), sourceShard,_                    unassignedInfo.shortSummary())__                cancelRelocation(sourceShard)__                remove(failedShard)__            }_            routingChangesObserver.shardFailed(failedShard, unassignedInfo)__        } else {_            assert failedShard.active()__            if (failedShard.primary()) {_                _                ShardRouting activeReplica = activeReplicaWithHighestVersion(failedShard.shardId())__                if (activeReplica == null) {_                    moveToUnassigned(failedShard, unassignedInfo)__                } else {_                    movePrimaryToUnassignedAndDemoteToReplica(failedShard, unassignedInfo)__                    promoteReplicaToPrimary(activeReplica, indexMetaData, routingChangesObserver)__                }_            } else {_                assert failedShard.primary() == false__                if (failedShard.relocating()) {_                    remove(failedShard)__                } else {_                    moveToUnassigned(failedShard, unassignedInfo)__                }_            }_            routingChangesObserver.shardFailed(failedShard, unassignedInfo)__        }_        assert node(failedShard.currentNodeId()).getByShardId(failedShard.shardId()) == null : "failedShard " + failedShard +_            " was matched but wasn't removed"__    };applies,the,relevant,logic,to,handle,a,cancelled,or,failed,shard,moves,the,shard,to,unassigned,or,completely,removes,the,shard,if,relocation,target,if,shard,is,a,primary,this,also,fails,initializing,replicas,if,shard,is,an,active,primary,this,also,promotes,an,active,replica,to,primary,if,such,a,replica,exists,if,shard,is,a,relocating,primary,this,also,removes,the,primary,relocation,target,shard,if,shard,is,a,relocating,replica,this,promotes,the,replica,relocation,target,to,a,full,initializing,replica,removing,the,relocation,source,information,this,is,possible,as,peer,recovery,is,always,done,from,the,primary,if,shard,is,a,primary,or,replica,relocation,target,this,also,clears,the,relocation,information,on,the,source,shard;public,void,fail,shard,logger,logger,shard,routing,failed,shard,unassigned,info,unassigned,info,index,meta,data,index,meta,data,routing,changes,observer,routing,changes,observer,ensure,mutable,assert,failed,shard,assigned,to,node,only,assigned,shards,can,be,failed,assert,index,meta,data,get,index,equals,failed,shard,index,shard,failed,for,unknown,index,shard,entry,failed,shard,assert,get,by,allocation,id,failed,shard,shard,id,failed,shard,allocation,id,get,id,failed,shard,shard,routing,to,fail,does,not,exist,in,routing,table,expected,failed,shard,but,was,get,by,allocation,id,failed,shard,shard,id,failed,shard,allocation,id,get,id,logger,debug,failing,shard,with,unassigned,info,failed,shard,shard,id,failed,shard,unassigned,info,short,summary,if,failed,shard,primary,list,shard,routing,assigned,shards,assigned,shards,failed,shard,shard,id,if,assigned,shards,is,empty,false,for,shard,routing,routing,new,array,list,assigned,shards,if,routing,primary,routing,initializing,shard,routing,replica,shard,get,by,allocation,id,routing,shard,id,routing,allocation,id,get,id,assert,replica,shard,null,failed,to,re,resolve,routing,when,failing,replicas,unassigned,info,primary,failed,unassigned,info,new,unassigned,info,unassigned,info,reason,primary,failed,while,replica,initializing,null,0,unassigned,info,get,unassigned,time,in,nanos,unassigned,info,get,unassigned,time,in,millis,false,allocation,status,fail,shard,logger,replica,shard,primary,failed,unassigned,info,index,meta,data,routing,changes,observer,if,failed,shard,relocating,shard,routing,target,shard,get,by,allocation,id,failed,shard,shard,id,failed,shard,allocation,id,get,relocation,id,assert,target,shard,is,relocation,target,of,failed,shard,if,failed,shard,primary,logger,trace,is,removed,due,to,the,failure,cancellation,of,the,source,shard,target,shard,remove,target,shard,routing,changes,observer,shard,failed,target,shard,unassigned,info,else,logger,trace,relocation,source,failed,cancelled,mark,as,initializing,without,relocation,source,target,shard,remove,relocation,source,target,shard,routing,changes,observer,relocation,source,removed,target,shard,if,failed,shard,initializing,if,failed,shard,relocating,node,id,null,if,failed,shard,primary,shard,routing,active,replica,active,replica,with,highest,version,failed,shard,shard,id,if,active,replica,null,move,to,unassigned,failed,shard,unassigned,info,else,move,primary,to,unassigned,and,demote,to,replica,failed,shard,unassigned,info,promote,replica,to,primary,active,replica,index,meta,data,routing,changes,observer,else,move,to,unassigned,failed,shard,unassigned,info,else,logger,trace,is,a,relocation,target,resolving,source,to,cancel,relocation,failed,shard,unassigned,info,short,summary,shard,routing,source,shard,get,by,allocation,id,failed,shard,shard,id,failed,shard,allocation,id,get,relocation,id,assert,source,shard,is,relocation,source,of,failed,shard,logger,trace,resolved,source,to,canceling,relocation,failed,shard,shard,id,source,shard,unassigned,info,short,summary,cancel,relocation,source,shard,remove,failed,shard,routing,changes,observer,shard,failed,failed,shard,unassigned,info,else,assert,failed,shard,active,if,failed,shard,primary,shard,routing,active,replica,active,replica,with,highest,version,failed,shard,shard,id,if,active,replica,null,move,to,unassigned,failed,shard,unassigned,info,else,move,primary,to,unassigned,and,demote,to,replica,failed,shard,unassigned,info,promote,replica,to,primary,active,replica,index,meta,data,routing,changes,observer,else,assert,failed,shard,primary,false,if,failed,shard,relocating,remove,failed,shard,else,move,to,unassigned,failed,shard,unassigned,info,routing,changes,observer,shard,failed,failed,shard,unassigned,info,assert,node,failed,shard,current,node,id,get,by,shard,id,failed,shard,shard,id,null,failed,shard,failed,shard,was,matched,but,wasn,t,removed
RoutingNodes -> public void failShard(Logger logger, ShardRouting failedShard, UnassignedInfo unassignedInfo, IndexMetaData indexMetaData,                           RoutingChangesObserver routingChangesObserver);1540847035;Applies the relevant logic to handle a cancelled or failed shard.__Moves the shard to unassigned or completely removes the shard (if relocation target).__- If shard is a primary, this also fails initializing replicas._- If shard is an active primary, this also promotes an active replica to primary (if such a replica exists)._- If shard is a relocating primary, this also removes the primary relocation target shard._- If shard is a relocating replica, this promotes the replica relocation target to a full initializing replica, removing the_relocation source information. This is possible as peer recovery is always done from the primary._- If shard is a (primary or replica) relocation target, this also clears the relocation information on the source shard.;public void failShard(Logger logger, ShardRouting failedShard, UnassignedInfo unassignedInfo, IndexMetaData indexMetaData,_                          RoutingChangesObserver routingChangesObserver) {_        ensureMutable()__        assert failedShard.assignedToNode() : "only assigned shards can be failed"__        assert indexMetaData.getIndex().equals(failedShard.index()) :_            "shard failed for unknown index (shard entry: " + failedShard + ")"__        assert getByAllocationId(failedShard.shardId(), failedShard.allocationId().getId()) == failedShard :_            "shard routing to fail does not exist in routing table, expected: " + failedShard + " but was: " +_                getByAllocationId(failedShard.shardId(), failedShard.allocationId().getId())___        logger.debug("{} failing shard {} with unassigned info ({})", failedShard.shardId(), failedShard, unassignedInfo.shortSummary())___        _        if (failedShard.primary()) {_            List<ShardRouting> assignedShards = assignedShards(failedShard.shardId())__            if (assignedShards.isEmpty() == false) {_                _                for (ShardRouting routing : new ArrayList<>(assignedShards)) {_                    if (!routing.primary() && routing.initializing()) {_                        _                        ShardRouting replicaShard = getByAllocationId(routing.shardId(), routing.allocationId().getId())__                        assert replicaShard != null : "failed to re-resolve " + routing + " when failing replicas"__                        UnassignedInfo primaryFailedUnassignedInfo = new UnassignedInfo(UnassignedInfo.Reason.PRIMARY_FAILED,_                            "primary failed while replica initializing", null, 0, unassignedInfo.getUnassignedTimeInNanos(),_                            unassignedInfo.getUnassignedTimeInMillis(), false, AllocationStatus.NO_ATTEMPT)__                        failShard(logger, replicaShard, primaryFailedUnassignedInfo, indexMetaData, routingChangesObserver)__                    }_                }_            }_        }__        if (failedShard.relocating()) {_            _            ShardRouting targetShard = getByAllocationId(failedShard.shardId(), failedShard.allocationId().getRelocationId())__            assert targetShard.isRelocationTargetOf(failedShard)__            if (failedShard.primary()) {_                logger.trace("{} is removed due to the failure/cancellation of the source shard", targetShard)__                _                remove(targetShard)__                routingChangesObserver.shardFailed(targetShard, unassignedInfo)__            } else {_                logger.trace("{}, relocation source failed / cancelled, mark as initializing without relocation source", targetShard)__                _                _                removeRelocationSource(targetShard)__                routingChangesObserver.relocationSourceRemoved(targetShard)__            }_        }__        _        if (failedShard.initializing()) {_            if (failedShard.relocatingNodeId() == null) {_                if (failedShard.primary()) {_                    _                    ShardRouting activeReplica = activeReplicaWithHighestVersion(failedShard.shardId())__                    if (activeReplica == null) {_                        moveToUnassigned(failedShard, unassignedInfo)__                    } else {_                        movePrimaryToUnassignedAndDemoteToReplica(failedShard, unassignedInfo)__                        promoteReplicaToPrimary(activeReplica, indexMetaData, routingChangesObserver)__                    }_                } else {_                    _                    moveToUnassigned(failedShard, unassignedInfo)__                }_            } else {_                _                _                logger.trace("{} is a relocation target, resolving source to cancel relocation ({})", failedShard,_                    unassignedInfo.shortSummary())__                ShardRouting sourceShard = getByAllocationId(failedShard.shardId(),_                    failedShard.allocationId().getRelocationId())__                assert sourceShard.isRelocationSourceOf(failedShard)__                logger.trace("{}, resolved source to [{}]. canceling relocation ... ({})", failedShard.shardId(), sourceShard,_                    unassignedInfo.shortSummary())__                cancelRelocation(sourceShard)__                remove(failedShard)__            }_            routingChangesObserver.shardFailed(failedShard, unassignedInfo)__        } else {_            assert failedShard.active()__            if (failedShard.primary()) {_                _                ShardRouting activeReplica = activeReplicaWithHighestVersion(failedShard.shardId())__                if (activeReplica == null) {_                    moveToUnassigned(failedShard, unassignedInfo)__                } else {_                    movePrimaryToUnassignedAndDemoteToReplica(failedShard, unassignedInfo)__                    promoteReplicaToPrimary(activeReplica, indexMetaData, routingChangesObserver)__                }_            } else {_                assert failedShard.primary() == false__                if (failedShard.relocating()) {_                    remove(failedShard)__                } else {_                    moveToUnassigned(failedShard, unassignedInfo)__                }_            }_            routingChangesObserver.shardFailed(failedShard, unassignedInfo)__        }_        assert node(failedShard.currentNodeId()).getByShardId(failedShard.shardId()) == null : "failedShard " + failedShard +_            " was matched but wasn't removed"__    };applies,the,relevant,logic,to,handle,a,cancelled,or,failed,shard,moves,the,shard,to,unassigned,or,completely,removes,the,shard,if,relocation,target,if,shard,is,a,primary,this,also,fails,initializing,replicas,if,shard,is,an,active,primary,this,also,promotes,an,active,replica,to,primary,if,such,a,replica,exists,if,shard,is,a,relocating,primary,this,also,removes,the,primary,relocation,target,shard,if,shard,is,a,relocating,replica,this,promotes,the,replica,relocation,target,to,a,full,initializing,replica,removing,the,relocation,source,information,this,is,possible,as,peer,recovery,is,always,done,from,the,primary,if,shard,is,a,primary,or,replica,relocation,target,this,also,clears,the,relocation,information,on,the,source,shard;public,void,fail,shard,logger,logger,shard,routing,failed,shard,unassigned,info,unassigned,info,index,meta,data,index,meta,data,routing,changes,observer,routing,changes,observer,ensure,mutable,assert,failed,shard,assigned,to,node,only,assigned,shards,can,be,failed,assert,index,meta,data,get,index,equals,failed,shard,index,shard,failed,for,unknown,index,shard,entry,failed,shard,assert,get,by,allocation,id,failed,shard,shard,id,failed,shard,allocation,id,get,id,failed,shard,shard,routing,to,fail,does,not,exist,in,routing,table,expected,failed,shard,but,was,get,by,allocation,id,failed,shard,shard,id,failed,shard,allocation,id,get,id,logger,debug,failing,shard,with,unassigned,info,failed,shard,shard,id,failed,shard,unassigned,info,short,summary,if,failed,shard,primary,list,shard,routing,assigned,shards,assigned,shards,failed,shard,shard,id,if,assigned,shards,is,empty,false,for,shard,routing,routing,new,array,list,assigned,shards,if,routing,primary,routing,initializing,shard,routing,replica,shard,get,by,allocation,id,routing,shard,id,routing,allocation,id,get,id,assert,replica,shard,null,failed,to,re,resolve,routing,when,failing,replicas,unassigned,info,primary,failed,unassigned,info,new,unassigned,info,unassigned,info,reason,primary,failed,while,replica,initializing,null,0,unassigned,info,get,unassigned,time,in,nanos,unassigned,info,get,unassigned,time,in,millis,false,allocation,status,fail,shard,logger,replica,shard,primary,failed,unassigned,info,index,meta,data,routing,changes,observer,if,failed,shard,relocating,shard,routing,target,shard,get,by,allocation,id,failed,shard,shard,id,failed,shard,allocation,id,get,relocation,id,assert,target,shard,is,relocation,target,of,failed,shard,if,failed,shard,primary,logger,trace,is,removed,due,to,the,failure,cancellation,of,the,source,shard,target,shard,remove,target,shard,routing,changes,observer,shard,failed,target,shard,unassigned,info,else,logger,trace,relocation,source,failed,cancelled,mark,as,initializing,without,relocation,source,target,shard,remove,relocation,source,target,shard,routing,changes,observer,relocation,source,removed,target,shard,if,failed,shard,initializing,if,failed,shard,relocating,node,id,null,if,failed,shard,primary,shard,routing,active,replica,active,replica,with,highest,version,failed,shard,shard,id,if,active,replica,null,move,to,unassigned,failed,shard,unassigned,info,else,move,primary,to,unassigned,and,demote,to,replica,failed,shard,unassigned,info,promote,replica,to,primary,active,replica,index,meta,data,routing,changes,observer,else,move,to,unassigned,failed,shard,unassigned,info,else,logger,trace,is,a,relocation,target,resolving,source,to,cancel,relocation,failed,shard,unassigned,info,short,summary,shard,routing,source,shard,get,by,allocation,id,failed,shard,shard,id,failed,shard,allocation,id,get,relocation,id,assert,source,shard,is,relocation,source,of,failed,shard,logger,trace,resolved,source,to,canceling,relocation,failed,shard,shard,id,source,shard,unassigned,info,short,summary,cancel,relocation,source,shard,remove,failed,shard,routing,changes,observer,shard,failed,failed,shard,unassigned,info,else,assert,failed,shard,active,if,failed,shard,primary,shard,routing,active,replica,active,replica,with,highest,version,failed,shard,shard,id,if,active,replica,null,move,to,unassigned,failed,shard,unassigned,info,else,move,primary,to,unassigned,and,demote,to,replica,failed,shard,unassigned,info,promote,replica,to,primary,active,replica,index,meta,data,routing,changes,observer,else,assert,failed,shard,primary,false,if,failed,shard,relocating,remove,failed,shard,else,move,to,unassigned,failed,shard,unassigned,info,routing,changes,observer,shard,failed,failed,shard,unassigned,info,assert,node,failed,shard,current,node,id,get,by,shard,id,failed,shard,shard,id,null,failed,shard,failed,shard,was,matched,but,wasn,t,removed
RoutingNodes -> public void failShard(Logger logger, ShardRouting failedShard, UnassignedInfo unassignedInfo, IndexMetaData indexMetaData,                           RoutingChangesObserver routingChangesObserver);1541446827;Applies the relevant logic to handle a cancelled or failed shard.__Moves the shard to unassigned or completely removes the shard (if relocation target).__- If shard is a primary, this also fails initializing replicas._- If shard is an active primary, this also promotes an active replica to primary (if such a replica exists)._- If shard is a relocating primary, this also removes the primary relocation target shard._- If shard is a relocating replica, this promotes the replica relocation target to a full initializing replica, removing the_relocation source information. This is possible as peer recovery is always done from the primary._- If shard is a (primary or replica) relocation target, this also clears the relocation information on the source shard.;public void failShard(Logger logger, ShardRouting failedShard, UnassignedInfo unassignedInfo, IndexMetaData indexMetaData,_                          RoutingChangesObserver routingChangesObserver) {_        ensureMutable()__        assert failedShard.assignedToNode() : "only assigned shards can be failed"__        assert indexMetaData.getIndex().equals(failedShard.index()) :_            "shard failed for unknown index (shard entry: " + failedShard + ")"__        assert getByAllocationId(failedShard.shardId(), failedShard.allocationId().getId()) == failedShard :_            "shard routing to fail does not exist in routing table, expected: " + failedShard + " but was: " +_                getByAllocationId(failedShard.shardId(), failedShard.allocationId().getId())___        logger.debug("{} failing shard {} with unassigned info ({})", failedShard.shardId(), failedShard, unassignedInfo.shortSummary())___        _        if (failedShard.primary()) {_            List<ShardRouting> assignedShards = assignedShards(failedShard.shardId())__            if (assignedShards.isEmpty() == false) {_                _                for (ShardRouting routing : new ArrayList<>(assignedShards)) {_                    if (!routing.primary() && routing.initializing()) {_                        _                        ShardRouting replicaShard = getByAllocationId(routing.shardId(), routing.allocationId().getId())__                        assert replicaShard != null : "failed to re-resolve " + routing + " when failing replicas"__                        UnassignedInfo primaryFailedUnassignedInfo = new UnassignedInfo(UnassignedInfo.Reason.PRIMARY_FAILED,_                            "primary failed while replica initializing", null, 0, unassignedInfo.getUnassignedTimeInNanos(),_                            unassignedInfo.getUnassignedTimeInMillis(), false, AllocationStatus.NO_ATTEMPT)__                        failShard(logger, replicaShard, primaryFailedUnassignedInfo, indexMetaData, routingChangesObserver)__                    }_                }_            }_        }__        if (failedShard.relocating()) {_            _            ShardRouting targetShard = getByAllocationId(failedShard.shardId(), failedShard.allocationId().getRelocationId())__            assert targetShard.isRelocationTargetOf(failedShard)__            if (failedShard.primary()) {_                logger.trace("{} is removed due to the failure/cancellation of the source shard", targetShard)__                _                remove(targetShard)__                routingChangesObserver.shardFailed(targetShard, unassignedInfo)__            } else {_                logger.trace("{}, relocation source failed / cancelled, mark as initializing without relocation source", targetShard)__                _                _                removeRelocationSource(targetShard)__                routingChangesObserver.relocationSourceRemoved(targetShard)__            }_        }__        _        if (failedShard.initializing()) {_            if (failedShard.relocatingNodeId() == null) {_                if (failedShard.primary()) {_                    _                    ShardRouting activeReplica = activeReplicaWithHighestVersion(failedShard.shardId())__                    if (activeReplica == null) {_                        moveToUnassigned(failedShard, unassignedInfo)__                    } else {_                        movePrimaryToUnassignedAndDemoteToReplica(failedShard, unassignedInfo)__                        promoteReplicaToPrimary(activeReplica, routingChangesObserver)__                    }_                } else {_                    _                    moveToUnassigned(failedShard, unassignedInfo)__                }_            } else {_                _                _                logger.trace("{} is a relocation target, resolving source to cancel relocation ({})", failedShard,_                    unassignedInfo.shortSummary())__                ShardRouting sourceShard = getByAllocationId(failedShard.shardId(),_                    failedShard.allocationId().getRelocationId())__                assert sourceShard.isRelocationSourceOf(failedShard)__                logger.trace("{}, resolved source to [{}]. canceling relocation ... ({})", failedShard.shardId(), sourceShard,_                    unassignedInfo.shortSummary())__                cancelRelocation(sourceShard)__                remove(failedShard)__            }_            routingChangesObserver.shardFailed(failedShard, unassignedInfo)__        } else {_            assert failedShard.active()__            if (failedShard.primary()) {_                _                ShardRouting activeReplica = activeReplicaWithHighestVersion(failedShard.shardId())__                if (activeReplica == null) {_                    moveToUnassigned(failedShard, unassignedInfo)__                } else {_                    movePrimaryToUnassignedAndDemoteToReplica(failedShard, unassignedInfo)__                    promoteReplicaToPrimary(activeReplica, routingChangesObserver)__                }_            } else {_                assert failedShard.primary() == false__                if (failedShard.relocating()) {_                    remove(failedShard)__                } else {_                    moveToUnassigned(failedShard, unassignedInfo)__                }_            }_            routingChangesObserver.shardFailed(failedShard, unassignedInfo)__        }_        assert node(failedShard.currentNodeId()).getByShardId(failedShard.shardId()) == null : "failedShard " + failedShard +_            " was matched but wasn't removed"__    };applies,the,relevant,logic,to,handle,a,cancelled,or,failed,shard,moves,the,shard,to,unassigned,or,completely,removes,the,shard,if,relocation,target,if,shard,is,a,primary,this,also,fails,initializing,replicas,if,shard,is,an,active,primary,this,also,promotes,an,active,replica,to,primary,if,such,a,replica,exists,if,shard,is,a,relocating,primary,this,also,removes,the,primary,relocation,target,shard,if,shard,is,a,relocating,replica,this,promotes,the,replica,relocation,target,to,a,full,initializing,replica,removing,the,relocation,source,information,this,is,possible,as,peer,recovery,is,always,done,from,the,primary,if,shard,is,a,primary,or,replica,relocation,target,this,also,clears,the,relocation,information,on,the,source,shard;public,void,fail,shard,logger,logger,shard,routing,failed,shard,unassigned,info,unassigned,info,index,meta,data,index,meta,data,routing,changes,observer,routing,changes,observer,ensure,mutable,assert,failed,shard,assigned,to,node,only,assigned,shards,can,be,failed,assert,index,meta,data,get,index,equals,failed,shard,index,shard,failed,for,unknown,index,shard,entry,failed,shard,assert,get,by,allocation,id,failed,shard,shard,id,failed,shard,allocation,id,get,id,failed,shard,shard,routing,to,fail,does,not,exist,in,routing,table,expected,failed,shard,but,was,get,by,allocation,id,failed,shard,shard,id,failed,shard,allocation,id,get,id,logger,debug,failing,shard,with,unassigned,info,failed,shard,shard,id,failed,shard,unassigned,info,short,summary,if,failed,shard,primary,list,shard,routing,assigned,shards,assigned,shards,failed,shard,shard,id,if,assigned,shards,is,empty,false,for,shard,routing,routing,new,array,list,assigned,shards,if,routing,primary,routing,initializing,shard,routing,replica,shard,get,by,allocation,id,routing,shard,id,routing,allocation,id,get,id,assert,replica,shard,null,failed,to,re,resolve,routing,when,failing,replicas,unassigned,info,primary,failed,unassigned,info,new,unassigned,info,unassigned,info,reason,primary,failed,while,replica,initializing,null,0,unassigned,info,get,unassigned,time,in,nanos,unassigned,info,get,unassigned,time,in,millis,false,allocation,status,fail,shard,logger,replica,shard,primary,failed,unassigned,info,index,meta,data,routing,changes,observer,if,failed,shard,relocating,shard,routing,target,shard,get,by,allocation,id,failed,shard,shard,id,failed,shard,allocation,id,get,relocation,id,assert,target,shard,is,relocation,target,of,failed,shard,if,failed,shard,primary,logger,trace,is,removed,due,to,the,failure,cancellation,of,the,source,shard,target,shard,remove,target,shard,routing,changes,observer,shard,failed,target,shard,unassigned,info,else,logger,trace,relocation,source,failed,cancelled,mark,as,initializing,without,relocation,source,target,shard,remove,relocation,source,target,shard,routing,changes,observer,relocation,source,removed,target,shard,if,failed,shard,initializing,if,failed,shard,relocating,node,id,null,if,failed,shard,primary,shard,routing,active,replica,active,replica,with,highest,version,failed,shard,shard,id,if,active,replica,null,move,to,unassigned,failed,shard,unassigned,info,else,move,primary,to,unassigned,and,demote,to,replica,failed,shard,unassigned,info,promote,replica,to,primary,active,replica,routing,changes,observer,else,move,to,unassigned,failed,shard,unassigned,info,else,logger,trace,is,a,relocation,target,resolving,source,to,cancel,relocation,failed,shard,unassigned,info,short,summary,shard,routing,source,shard,get,by,allocation,id,failed,shard,shard,id,failed,shard,allocation,id,get,relocation,id,assert,source,shard,is,relocation,source,of,failed,shard,logger,trace,resolved,source,to,canceling,relocation,failed,shard,shard,id,source,shard,unassigned,info,short,summary,cancel,relocation,source,shard,remove,failed,shard,routing,changes,observer,shard,failed,failed,shard,unassigned,info,else,assert,failed,shard,active,if,failed,shard,primary,shard,routing,active,replica,active,replica,with,highest,version,failed,shard,shard,id,if,active,replica,null,move,to,unassigned,failed,shard,unassigned,info,else,move,primary,to,unassigned,and,demote,to,replica,failed,shard,unassigned,info,promote,replica,to,primary,active,replica,routing,changes,observer,else,assert,failed,shard,primary,false,if,failed,shard,relocating,remove,failed,shard,else,move,to,unassigned,failed,shard,unassigned,info,routing,changes,observer,shard,failed,failed,shard,unassigned,info,assert,node,failed,shard,current,node,id,get,by,shard,id,failed,shard,shard,id,null,failed,shard,failed,shard,was,matched,but,wasn,t,removed
RoutingNodes -> public void failShard(Logger logger, ShardRouting failedShard, UnassignedInfo unassignedInfo, IndexMetaData indexMetaData,                           RoutingChangesObserver routingChangesObserver);1548259585;Applies the relevant logic to handle a cancelled or failed shard.__Moves the shard to unassigned or completely removes the shard (if relocation target).__- If shard is a primary, this also fails initializing replicas._- If shard is an active primary, this also promotes an active replica to primary (if such a replica exists)._- If shard is a relocating primary, this also removes the primary relocation target shard._- If shard is a relocating replica, this promotes the replica relocation target to a full initializing replica, removing the_relocation source information. This is possible as peer recovery is always done from the primary._- If shard is a (primary or replica) relocation target, this also clears the relocation information on the source shard.;public void failShard(Logger logger, ShardRouting failedShard, UnassignedInfo unassignedInfo, IndexMetaData indexMetaData,_                          RoutingChangesObserver routingChangesObserver) {_        ensureMutable()__        assert failedShard.assignedToNode() : "only assigned shards can be failed"__        assert indexMetaData.getIndex().equals(failedShard.index()) :_            "shard failed for unknown index (shard entry: " + failedShard + ")"__        assert getByAllocationId(failedShard.shardId(), failedShard.allocationId().getId()) == failedShard :_            "shard routing to fail does not exist in routing table, expected: " + failedShard + " but was: " +_                getByAllocationId(failedShard.shardId(), failedShard.allocationId().getId())___        logger.debug("{} failing shard {} with unassigned info ({})", failedShard.shardId(), failedShard, unassignedInfo.shortSummary())___        _        if (failedShard.primary()) {_            List<ShardRouting> assignedShards = assignedShards(failedShard.shardId())__            if (assignedShards.isEmpty() == false) {_                _                for (ShardRouting routing : new ArrayList<>(assignedShards)) {_                    if (!routing.primary() && routing.initializing()) {_                        _                        ShardRouting replicaShard = getByAllocationId(routing.shardId(), routing.allocationId().getId())__                        assert replicaShard != null : "failed to re-resolve " + routing + " when failing replicas"__                        UnassignedInfo primaryFailedUnassignedInfo = new UnassignedInfo(UnassignedInfo.Reason.PRIMARY_FAILED,_                            "primary failed while replica initializing", null, 0, unassignedInfo.getUnassignedTimeInNanos(),_                            unassignedInfo.getUnassignedTimeInMillis(), false, AllocationStatus.NO_ATTEMPT)__                        failShard(logger, replicaShard, primaryFailedUnassignedInfo, indexMetaData, routingChangesObserver)__                    }_                }_            }_        }__        if (failedShard.relocating()) {_            _            ShardRouting targetShard = getByAllocationId(failedShard.shardId(), failedShard.allocationId().getRelocationId())__            assert targetShard.isRelocationTargetOf(failedShard)__            if (failedShard.primary()) {_                logger.trace("{} is removed due to the failure/cancellation of the source shard", targetShard)__                _                remove(targetShard)__                routingChangesObserver.shardFailed(targetShard, unassignedInfo)__            } else {_                logger.trace("{}, relocation source failed / cancelled, mark as initializing without relocation source", targetShard)__                _                _                removeRelocationSource(targetShard)__                routingChangesObserver.relocationSourceRemoved(targetShard)__            }_        }__        _        if (failedShard.initializing()) {_            if (failedShard.relocatingNodeId() == null) {_                if (failedShard.primary()) {_                    _                    ShardRouting activeReplica = activeReplicaWithHighestVersion(failedShard.shardId())__                    if (activeReplica == null) {_                        moveToUnassigned(failedShard, unassignedInfo)__                    } else {_                        movePrimaryToUnassignedAndDemoteToReplica(failedShard, unassignedInfo)__                        promoteReplicaToPrimary(activeReplica, routingChangesObserver)__                    }_                } else {_                    _                    moveToUnassigned(failedShard, unassignedInfo)__                }_            } else {_                _                _                logger.trace("{} is a relocation target, resolving source to cancel relocation ({})", failedShard,_                    unassignedInfo.shortSummary())__                ShardRouting sourceShard = getByAllocationId(failedShard.shardId(),_                    failedShard.allocationId().getRelocationId())__                assert sourceShard.isRelocationSourceOf(failedShard)__                logger.trace("{}, resolved source to [{}]. canceling relocation ... ({})", failedShard.shardId(), sourceShard,_                    unassignedInfo.shortSummary())__                cancelRelocation(sourceShard)__                remove(failedShard)__            }_            routingChangesObserver.shardFailed(failedShard, unassignedInfo)__        } else {_            assert failedShard.active()__            if (failedShard.primary()) {_                _                ShardRouting activeReplica = activeReplicaWithHighestVersion(failedShard.shardId())__                if (activeReplica == null) {_                    moveToUnassigned(failedShard, unassignedInfo)__                } else {_                    movePrimaryToUnassignedAndDemoteToReplica(failedShard, unassignedInfo)__                    promoteReplicaToPrimary(activeReplica, routingChangesObserver)__                }_            } else {_                assert failedShard.primary() == false__                if (failedShard.relocating()) {_                    remove(failedShard)__                } else {_                    moveToUnassigned(failedShard, unassignedInfo)__                }_            }_            routingChangesObserver.shardFailed(failedShard, unassignedInfo)__        }_        assert node(failedShard.currentNodeId()).getByShardId(failedShard.shardId()) == null : "failedShard " + failedShard +_            " was matched but wasn't removed"__    };applies,the,relevant,logic,to,handle,a,cancelled,or,failed,shard,moves,the,shard,to,unassigned,or,completely,removes,the,shard,if,relocation,target,if,shard,is,a,primary,this,also,fails,initializing,replicas,if,shard,is,an,active,primary,this,also,promotes,an,active,replica,to,primary,if,such,a,replica,exists,if,shard,is,a,relocating,primary,this,also,removes,the,primary,relocation,target,shard,if,shard,is,a,relocating,replica,this,promotes,the,replica,relocation,target,to,a,full,initializing,replica,removing,the,relocation,source,information,this,is,possible,as,peer,recovery,is,always,done,from,the,primary,if,shard,is,a,primary,or,replica,relocation,target,this,also,clears,the,relocation,information,on,the,source,shard;public,void,fail,shard,logger,logger,shard,routing,failed,shard,unassigned,info,unassigned,info,index,meta,data,index,meta,data,routing,changes,observer,routing,changes,observer,ensure,mutable,assert,failed,shard,assigned,to,node,only,assigned,shards,can,be,failed,assert,index,meta,data,get,index,equals,failed,shard,index,shard,failed,for,unknown,index,shard,entry,failed,shard,assert,get,by,allocation,id,failed,shard,shard,id,failed,shard,allocation,id,get,id,failed,shard,shard,routing,to,fail,does,not,exist,in,routing,table,expected,failed,shard,but,was,get,by,allocation,id,failed,shard,shard,id,failed,shard,allocation,id,get,id,logger,debug,failing,shard,with,unassigned,info,failed,shard,shard,id,failed,shard,unassigned,info,short,summary,if,failed,shard,primary,list,shard,routing,assigned,shards,assigned,shards,failed,shard,shard,id,if,assigned,shards,is,empty,false,for,shard,routing,routing,new,array,list,assigned,shards,if,routing,primary,routing,initializing,shard,routing,replica,shard,get,by,allocation,id,routing,shard,id,routing,allocation,id,get,id,assert,replica,shard,null,failed,to,re,resolve,routing,when,failing,replicas,unassigned,info,primary,failed,unassigned,info,new,unassigned,info,unassigned,info,reason,primary,failed,while,replica,initializing,null,0,unassigned,info,get,unassigned,time,in,nanos,unassigned,info,get,unassigned,time,in,millis,false,allocation,status,fail,shard,logger,replica,shard,primary,failed,unassigned,info,index,meta,data,routing,changes,observer,if,failed,shard,relocating,shard,routing,target,shard,get,by,allocation,id,failed,shard,shard,id,failed,shard,allocation,id,get,relocation,id,assert,target,shard,is,relocation,target,of,failed,shard,if,failed,shard,primary,logger,trace,is,removed,due,to,the,failure,cancellation,of,the,source,shard,target,shard,remove,target,shard,routing,changes,observer,shard,failed,target,shard,unassigned,info,else,logger,trace,relocation,source,failed,cancelled,mark,as,initializing,without,relocation,source,target,shard,remove,relocation,source,target,shard,routing,changes,observer,relocation,source,removed,target,shard,if,failed,shard,initializing,if,failed,shard,relocating,node,id,null,if,failed,shard,primary,shard,routing,active,replica,active,replica,with,highest,version,failed,shard,shard,id,if,active,replica,null,move,to,unassigned,failed,shard,unassigned,info,else,move,primary,to,unassigned,and,demote,to,replica,failed,shard,unassigned,info,promote,replica,to,primary,active,replica,routing,changes,observer,else,move,to,unassigned,failed,shard,unassigned,info,else,logger,trace,is,a,relocation,target,resolving,source,to,cancel,relocation,failed,shard,unassigned,info,short,summary,shard,routing,source,shard,get,by,allocation,id,failed,shard,shard,id,failed,shard,allocation,id,get,relocation,id,assert,source,shard,is,relocation,source,of,failed,shard,logger,trace,resolved,source,to,canceling,relocation,failed,shard,shard,id,source,shard,unassigned,info,short,summary,cancel,relocation,source,shard,remove,failed,shard,routing,changes,observer,shard,failed,failed,shard,unassigned,info,else,assert,failed,shard,active,if,failed,shard,primary,shard,routing,active,replica,active,replica,with,highest,version,failed,shard,shard,id,if,active,replica,null,move,to,unassigned,failed,shard,unassigned,info,else,move,primary,to,unassigned,and,demote,to,replica,failed,shard,unassigned,info,promote,replica,to,primary,active,replica,routing,changes,observer,else,assert,failed,shard,primary,false,if,failed,shard,relocating,remove,failed,shard,else,move,to,unassigned,failed,shard,unassigned,info,routing,changes,observer,shard,failed,failed,shard,unassigned,info,assert,node,failed,shard,current,node,id,get,by,shard,id,failed,shard,shard,id,null,failed,shard,failed,shard,was,matched,but,wasn,t,removed
RoutingNodes -> public void failShard(Logger logger, ShardRouting failedShard, UnassignedInfo unassignedInfo, IndexMetaData indexMetaData,                           RoutingChangesObserver routingChangesObserver);1549912434;Applies the relevant logic to handle a cancelled or failed shard.__Moves the shard to unassigned or completely removes the shard (if relocation target).__- If shard is a primary, this also fails initializing replicas._- If shard is an active primary, this also promotes an active replica to primary (if such a replica exists)._- If shard is a relocating primary, this also removes the primary relocation target shard._- If shard is a relocating replica, this promotes the replica relocation target to a full initializing replica, removing the_relocation source information. This is possible as peer recovery is always done from the primary._- If shard is a (primary or replica) relocation target, this also clears the relocation information on the source shard.;public void failShard(Logger logger, ShardRouting failedShard, UnassignedInfo unassignedInfo, IndexMetaData indexMetaData,_                          RoutingChangesObserver routingChangesObserver) {_        ensureMutable()__        assert failedShard.assignedToNode() : "only assigned shards can be failed"__        assert indexMetaData.getIndex().equals(failedShard.index()) :_            "shard failed for unknown index (shard entry: " + failedShard + ")"__        assert getByAllocationId(failedShard.shardId(), failedShard.allocationId().getId()) == failedShard :_            "shard routing to fail does not exist in routing table, expected: " + failedShard + " but was: " +_                getByAllocationId(failedShard.shardId(), failedShard.allocationId().getId())___        logger.debug("{} failing shard {} with unassigned info ({})", failedShard.shardId(), failedShard, unassignedInfo.shortSummary())___        _        if (failedShard.primary()) {_            List<ShardRouting> assignedShards = assignedShards(failedShard.shardId())__            if (assignedShards.isEmpty() == false) {_                _                for (ShardRouting routing : new ArrayList<>(assignedShards)) {_                    if (!routing.primary() && routing.initializing()) {_                        _                        ShardRouting replicaShard = getByAllocationId(routing.shardId(), routing.allocationId().getId())__                        assert replicaShard != null : "failed to re-resolve " + routing + " when failing replicas"__                        UnassignedInfo primaryFailedUnassignedInfo = new UnassignedInfo(UnassignedInfo.Reason.PRIMARY_FAILED,_                            "primary failed while replica initializing", null, 0, unassignedInfo.getUnassignedTimeInNanos(),_                            unassignedInfo.getUnassignedTimeInMillis(), false, AllocationStatus.NO_ATTEMPT)__                        failShard(logger, replicaShard, primaryFailedUnassignedInfo, indexMetaData, routingChangesObserver)__                    }_                }_            }_        }__        if (failedShard.relocating()) {_            _            ShardRouting targetShard = getByAllocationId(failedShard.shardId(), failedShard.allocationId().getRelocationId())__            assert targetShard.isRelocationTargetOf(failedShard)__            if (failedShard.primary()) {_                logger.trace("{} is removed due to the failure/cancellation of the source shard", targetShard)__                _                remove(targetShard)__                routingChangesObserver.shardFailed(targetShard, unassignedInfo)__            } else {_                logger.trace("{}, relocation source failed / cancelled, mark as initializing without relocation source", targetShard)__                _                _                removeRelocationSource(targetShard)__                routingChangesObserver.relocationSourceRemoved(targetShard)__            }_        }__        _        if (failedShard.initializing()) {_            if (failedShard.relocatingNodeId() == null) {_                if (failedShard.primary()) {_                    _                    unassignPrimaryAndPromoteActiveReplicaIfExists(failedShard, unassignedInfo, routingChangesObserver)__                } else {_                    _                    moveToUnassigned(failedShard, unassignedInfo)__                }_            } else {_                _                _                logger.trace("{} is a relocation target, resolving source to cancel relocation ({})", failedShard,_                    unassignedInfo.shortSummary())__                ShardRouting sourceShard = getByAllocationId(failedShard.shardId(),_                    failedShard.allocationId().getRelocationId())__                assert sourceShard.isRelocationSourceOf(failedShard)__                logger.trace("{}, resolved source to [{}]. canceling relocation ... ({})", failedShard.shardId(), sourceShard,_                    unassignedInfo.shortSummary())__                cancelRelocation(sourceShard)__                remove(failedShard)__            }_        } else {_            assert failedShard.active()__            if (failedShard.primary()) {_                _                unassignPrimaryAndPromoteActiveReplicaIfExists(failedShard, unassignedInfo, routingChangesObserver)__            } else {_                if (failedShard.relocating()) {_                    remove(failedShard)__                } else {_                    moveToUnassigned(failedShard, unassignedInfo)__                }_            }_        }_        routingChangesObserver.shardFailed(failedShard, unassignedInfo)__        assert node(failedShard.currentNodeId()).getByShardId(failedShard.shardId()) == null : "failedShard " + failedShard +_            " was matched but wasn't removed"__    };applies,the,relevant,logic,to,handle,a,cancelled,or,failed,shard,moves,the,shard,to,unassigned,or,completely,removes,the,shard,if,relocation,target,if,shard,is,a,primary,this,also,fails,initializing,replicas,if,shard,is,an,active,primary,this,also,promotes,an,active,replica,to,primary,if,such,a,replica,exists,if,shard,is,a,relocating,primary,this,also,removes,the,primary,relocation,target,shard,if,shard,is,a,relocating,replica,this,promotes,the,replica,relocation,target,to,a,full,initializing,replica,removing,the,relocation,source,information,this,is,possible,as,peer,recovery,is,always,done,from,the,primary,if,shard,is,a,primary,or,replica,relocation,target,this,also,clears,the,relocation,information,on,the,source,shard;public,void,fail,shard,logger,logger,shard,routing,failed,shard,unassigned,info,unassigned,info,index,meta,data,index,meta,data,routing,changes,observer,routing,changes,observer,ensure,mutable,assert,failed,shard,assigned,to,node,only,assigned,shards,can,be,failed,assert,index,meta,data,get,index,equals,failed,shard,index,shard,failed,for,unknown,index,shard,entry,failed,shard,assert,get,by,allocation,id,failed,shard,shard,id,failed,shard,allocation,id,get,id,failed,shard,shard,routing,to,fail,does,not,exist,in,routing,table,expected,failed,shard,but,was,get,by,allocation,id,failed,shard,shard,id,failed,shard,allocation,id,get,id,logger,debug,failing,shard,with,unassigned,info,failed,shard,shard,id,failed,shard,unassigned,info,short,summary,if,failed,shard,primary,list,shard,routing,assigned,shards,assigned,shards,failed,shard,shard,id,if,assigned,shards,is,empty,false,for,shard,routing,routing,new,array,list,assigned,shards,if,routing,primary,routing,initializing,shard,routing,replica,shard,get,by,allocation,id,routing,shard,id,routing,allocation,id,get,id,assert,replica,shard,null,failed,to,re,resolve,routing,when,failing,replicas,unassigned,info,primary,failed,unassigned,info,new,unassigned,info,unassigned,info,reason,primary,failed,while,replica,initializing,null,0,unassigned,info,get,unassigned,time,in,nanos,unassigned,info,get,unassigned,time,in,millis,false,allocation,status,fail,shard,logger,replica,shard,primary,failed,unassigned,info,index,meta,data,routing,changes,observer,if,failed,shard,relocating,shard,routing,target,shard,get,by,allocation,id,failed,shard,shard,id,failed,shard,allocation,id,get,relocation,id,assert,target,shard,is,relocation,target,of,failed,shard,if,failed,shard,primary,logger,trace,is,removed,due,to,the,failure,cancellation,of,the,source,shard,target,shard,remove,target,shard,routing,changes,observer,shard,failed,target,shard,unassigned,info,else,logger,trace,relocation,source,failed,cancelled,mark,as,initializing,without,relocation,source,target,shard,remove,relocation,source,target,shard,routing,changes,observer,relocation,source,removed,target,shard,if,failed,shard,initializing,if,failed,shard,relocating,node,id,null,if,failed,shard,primary,unassign,primary,and,promote,active,replica,if,exists,failed,shard,unassigned,info,routing,changes,observer,else,move,to,unassigned,failed,shard,unassigned,info,else,logger,trace,is,a,relocation,target,resolving,source,to,cancel,relocation,failed,shard,unassigned,info,short,summary,shard,routing,source,shard,get,by,allocation,id,failed,shard,shard,id,failed,shard,allocation,id,get,relocation,id,assert,source,shard,is,relocation,source,of,failed,shard,logger,trace,resolved,source,to,canceling,relocation,failed,shard,shard,id,source,shard,unassigned,info,short,summary,cancel,relocation,source,shard,remove,failed,shard,else,assert,failed,shard,active,if,failed,shard,primary,unassign,primary,and,promote,active,replica,if,exists,failed,shard,unassigned,info,routing,changes,observer,else,if,failed,shard,relocating,remove,failed,shard,else,move,to,unassigned,failed,shard,unassigned,info,routing,changes,observer,shard,failed,failed,shard,unassigned,info,assert,node,failed,shard,current,node,id,get,by,shard,id,failed,shard,shard,id,null,failed,shard,failed,shard,was,matched,but,wasn,t,removed
RoutingNodes -> UnassignedShards -> public int getNumPrimaries();1524684173;Returns the number of non-ignored unassigned primaries;public int getNumPrimaries() {_            return primaries__        };returns,the,number,of,non,ignored,unassigned,primaries;public,int,get,num,primaries,return,primaries
RoutingNodes -> UnassignedShards -> public int getNumPrimaries();1540847035;Returns the number of non-ignored unassigned primaries;public int getNumPrimaries() {_            return primaries__        };returns,the,number,of,non,ignored,unassigned,primaries;public,int,get,num,primaries,return,primaries
RoutingNodes -> UnassignedShards -> public int getNumPrimaries();1541446827;Returns the number of non-ignored unassigned primaries;public int getNumPrimaries() {_            return primaries__        };returns,the,number,of,non,ignored,unassigned,primaries;public,int,get,num,primaries,return,primaries
RoutingNodes -> UnassignedShards -> public int getNumPrimaries();1548259585;Returns the number of non-ignored unassigned primaries;public int getNumPrimaries() {_            return primaries__        };returns,the,number,of,non,ignored,unassigned,primaries;public,int,get,num,primaries,return,primaries
RoutingNodes -> UnassignedShards -> public int getNumPrimaries();1549912434;Returns the number of non-ignored unassigned primaries;public int getNumPrimaries() {_            return primaries__        };returns,the,number,of,non,ignored,unassigned,primaries;public,int,get,num,primaries,return,primaries
RoutingNodes -> public Tuple<ShardRouting,ShardRouting> relocateShard(ShardRouting startedShard, String nodeId, long expectedShardSize,                                                           RoutingChangesObserver changes);1524684173;Relocate a shard to another node, adding the target initializing_shard as well as assigning it.__@return pair of source relocating and target initializing shards.;public Tuple<ShardRouting,ShardRouting> relocateShard(ShardRouting startedShard, String nodeId, long expectedShardSize,_                                                          RoutingChangesObserver changes) {_        ensureMutable()__        relocatingShards++__        ShardRouting source = startedShard.relocate(nodeId, expectedShardSize)__        ShardRouting target = source.getTargetRelocatingShard()__        updateAssigned(startedShard, source)__        node(target.currentNodeId()).add(target)__        assignedShardsAdd(target)__        addRecovery(target)__        changes.relocationStarted(startedShard, target)__        return Tuple.tuple(source, target)__    };relocate,a,shard,to,another,node,adding,the,target,initializing,shard,as,well,as,assigning,it,return,pair,of,source,relocating,and,target,initializing,shards;public,tuple,shard,routing,shard,routing,relocate,shard,shard,routing,started,shard,string,node,id,long,expected,shard,size,routing,changes,observer,changes,ensure,mutable,relocating,shards,shard,routing,source,started,shard,relocate,node,id,expected,shard,size,shard,routing,target,source,get,target,relocating,shard,update,assigned,started,shard,source,node,target,current,node,id,add,target,assigned,shards,add,target,add,recovery,target,changes,relocation,started,started,shard,target,return,tuple,tuple,source,target
RoutingNodes -> public Tuple<ShardRouting,ShardRouting> relocateShard(ShardRouting startedShard, String nodeId, long expectedShardSize,                                                           RoutingChangesObserver changes);1540847035;Relocate a shard to another node, adding the target initializing_shard as well as assigning it.__@return pair of source relocating and target initializing shards.;public Tuple<ShardRouting,ShardRouting> relocateShard(ShardRouting startedShard, String nodeId, long expectedShardSize,_                                                          RoutingChangesObserver changes) {_        ensureMutable()__        relocatingShards++__        ShardRouting source = startedShard.relocate(nodeId, expectedShardSize)__        ShardRouting target = source.getTargetRelocatingShard()__        updateAssigned(startedShard, source)__        node(target.currentNodeId()).add(target)__        assignedShardsAdd(target)__        addRecovery(target)__        changes.relocationStarted(startedShard, target)__        return Tuple.tuple(source, target)__    };relocate,a,shard,to,another,node,adding,the,target,initializing,shard,as,well,as,assigning,it,return,pair,of,source,relocating,and,target,initializing,shards;public,tuple,shard,routing,shard,routing,relocate,shard,shard,routing,started,shard,string,node,id,long,expected,shard,size,routing,changes,observer,changes,ensure,mutable,relocating,shards,shard,routing,source,started,shard,relocate,node,id,expected,shard,size,shard,routing,target,source,get,target,relocating,shard,update,assigned,started,shard,source,node,target,current,node,id,add,target,assigned,shards,add,target,add,recovery,target,changes,relocation,started,started,shard,target,return,tuple,tuple,source,target
RoutingNodes -> public Tuple<ShardRouting,ShardRouting> relocateShard(ShardRouting startedShard, String nodeId, long expectedShardSize,                                                           RoutingChangesObserver changes);1541446827;Relocate a shard to another node, adding the target initializing_shard as well as assigning it.__@return pair of source relocating and target initializing shards.;public Tuple<ShardRouting,ShardRouting> relocateShard(ShardRouting startedShard, String nodeId, long expectedShardSize,_                                                          RoutingChangesObserver changes) {_        ensureMutable()__        relocatingShards++__        ShardRouting source = startedShard.relocate(nodeId, expectedShardSize)__        ShardRouting target = source.getTargetRelocatingShard()__        updateAssigned(startedShard, source)__        node(target.currentNodeId()).add(target)__        assignedShardsAdd(target)__        addRecovery(target)__        changes.relocationStarted(startedShard, target)__        return Tuple.tuple(source, target)__    };relocate,a,shard,to,another,node,adding,the,target,initializing,shard,as,well,as,assigning,it,return,pair,of,source,relocating,and,target,initializing,shards;public,tuple,shard,routing,shard,routing,relocate,shard,shard,routing,started,shard,string,node,id,long,expected,shard,size,routing,changes,observer,changes,ensure,mutable,relocating,shards,shard,routing,source,started,shard,relocate,node,id,expected,shard,size,shard,routing,target,source,get,target,relocating,shard,update,assigned,started,shard,source,node,target,current,node,id,add,target,assigned,shards,add,target,add,recovery,target,changes,relocation,started,started,shard,target,return,tuple,tuple,source,target
RoutingNodes -> public Tuple<ShardRouting,ShardRouting> relocateShard(ShardRouting startedShard, String nodeId, long expectedShardSize,                                                           RoutingChangesObserver changes);1548259585;Relocate a shard to another node, adding the target initializing_shard as well as assigning it.__@return pair of source relocating and target initializing shards.;public Tuple<ShardRouting,ShardRouting> relocateShard(ShardRouting startedShard, String nodeId, long expectedShardSize,_                                                          RoutingChangesObserver changes) {_        ensureMutable()__        relocatingShards++__        ShardRouting source = startedShard.relocate(nodeId, expectedShardSize)__        ShardRouting target = source.getTargetRelocatingShard()__        updateAssigned(startedShard, source)__        node(target.currentNodeId()).add(target)__        assignedShardsAdd(target)__        addRecovery(target)__        changes.relocationStarted(startedShard, target)__        return Tuple.tuple(source, target)__    };relocate,a,shard,to,another,node,adding,the,target,initializing,shard,as,well,as,assigning,it,return,pair,of,source,relocating,and,target,initializing,shards;public,tuple,shard,routing,shard,routing,relocate,shard,shard,routing,started,shard,string,node,id,long,expected,shard,size,routing,changes,observer,changes,ensure,mutable,relocating,shards,shard,routing,source,started,shard,relocate,node,id,expected,shard,size,shard,routing,target,source,get,target,relocating,shard,update,assigned,started,shard,source,node,target,current,node,id,add,target,assigned,shards,add,target,add,recovery,target,changes,relocation,started,started,shard,target,return,tuple,tuple,source,target
RoutingNodes -> public Tuple<ShardRouting,ShardRouting> relocateShard(ShardRouting startedShard, String nodeId, long expectedShardSize,                                                           RoutingChangesObserver changes);1549912434;Relocate a shard to another node, adding the target initializing_shard as well as assigning it.__@return pair of source relocating and target initializing shards.;public Tuple<ShardRouting,ShardRouting> relocateShard(ShardRouting startedShard, String nodeId, long expectedShardSize,_                                                          RoutingChangesObserver changes) {_        ensureMutable()__        relocatingShards++__        ShardRouting source = startedShard.relocate(nodeId, expectedShardSize)__        ShardRouting target = source.getTargetRelocatingShard()__        updateAssigned(startedShard, source)__        node(target.currentNodeId()).add(target)__        assignedShardsAdd(target)__        addRecovery(target)__        changes.relocationStarted(startedShard, target)__        return Tuple.tuple(source, target)__    };relocate,a,shard,to,another,node,adding,the,target,initializing,shard,as,well,as,assigning,it,return,pair,of,source,relocating,and,target,initializing,shards;public,tuple,shard,routing,shard,routing,relocate,shard,shard,routing,started,shard,string,node,id,long,expected,shard,size,routing,changes,observer,changes,ensure,mutable,relocating,shards,shard,routing,source,started,shard,relocate,node,id,expected,shard,size,shard,routing,target,source,get,target,relocating,shard,update,assigned,started,shard,source,node,target,current,node,id,add,target,assigned,shards,add,target,add,recovery,target,changes,relocation,started,started,shard,target,return,tuple,tuple,source,target
RoutingNodes -> public boolean hasUnassignedShards();1524684173;Returns <code>true</code> iff this {@link RoutingNodes} instance has any unassigned shards even if the_shards are marked as temporarily ignored._@see UnassignedShards#isEmpty()_@see UnassignedShards#isIgnoredEmpty();public boolean hasUnassignedShards() {_        return unassignedShards.isEmpty() == false || unassignedShards.isIgnoredEmpty() == false__    };returns,code,true,code,iff,this,link,routing,nodes,instance,has,any,unassigned,shards,even,if,the,shards,are,marked,as,temporarily,ignored,see,unassigned,shards,is,empty,see,unassigned,shards,is,ignored,empty;public,boolean,has,unassigned,shards,return,unassigned,shards,is,empty,false,unassigned,shards,is,ignored,empty,false
RoutingNodes -> public boolean hasUnassignedShards();1540847035;Returns <code>true</code> iff this {@link RoutingNodes} instance has any unassigned shards even if the_shards are marked as temporarily ignored._@see UnassignedShards#isEmpty()_@see UnassignedShards#isIgnoredEmpty();public boolean hasUnassignedShards() {_        return unassignedShards.isEmpty() == false || unassignedShards.isIgnoredEmpty() == false__    };returns,code,true,code,iff,this,link,routing,nodes,instance,has,any,unassigned,shards,even,if,the,shards,are,marked,as,temporarily,ignored,see,unassigned,shards,is,empty,see,unassigned,shards,is,ignored,empty;public,boolean,has,unassigned,shards,return,unassigned,shards,is,empty,false,unassigned,shards,is,ignored,empty,false
RoutingNodes -> public boolean hasUnassignedShards();1541446827;Returns <code>true</code> iff this {@link RoutingNodes} instance has any unassigned shards even if the_shards are marked as temporarily ignored._@see UnassignedShards#isEmpty()_@see UnassignedShards#isIgnoredEmpty();public boolean hasUnassignedShards() {_        return unassignedShards.isEmpty() == false || unassignedShards.isIgnoredEmpty() == false__    };returns,code,true,code,iff,this,link,routing,nodes,instance,has,any,unassigned,shards,even,if,the,shards,are,marked,as,temporarily,ignored,see,unassigned,shards,is,empty,see,unassigned,shards,is,ignored,empty;public,boolean,has,unassigned,shards,return,unassigned,shards,is,empty,false,unassigned,shards,is,ignored,empty,false
RoutingNodes -> public boolean hasUnassignedShards();1548259585;Returns <code>true</code> iff this {@link RoutingNodes} instance has any unassigned shards even if the_shards are marked as temporarily ignored._@see UnassignedShards#isEmpty()_@see UnassignedShards#isIgnoredEmpty();public boolean hasUnassignedShards() {_        return unassignedShards.isEmpty() == false || unassignedShards.isIgnoredEmpty() == false__    };returns,code,true,code,iff,this,link,routing,nodes,instance,has,any,unassigned,shards,even,if,the,shards,are,marked,as,temporarily,ignored,see,unassigned,shards,is,empty,see,unassigned,shards,is,ignored,empty;public,boolean,has,unassigned,shards,return,unassigned,shards,is,empty,false,unassigned,shards,is,ignored,empty,false
RoutingNodes -> public boolean hasUnassignedShards();1549912434;Returns <code>true</code> iff this {@link RoutingNodes} instance has any unassigned shards even if the_shards are marked as temporarily ignored._@see UnassignedShards#isEmpty()_@see UnassignedShards#isIgnoredEmpty();public boolean hasUnassignedShards() {_        return unassignedShards.isEmpty() == false || unassignedShards.isIgnoredEmpty() == false__    };returns,code,true,code,iff,this,link,routing,nodes,instance,has,any,unassigned,shards,even,if,the,shards,are,marked,as,temporarily,ignored,see,unassigned,shards,is,empty,see,unassigned,shards,is,ignored,empty;public,boolean,has,unassigned,shards,return,unassigned,shards,is,empty,false,unassigned,shards,is,ignored,empty,false
RoutingNodes -> public ShardRouting initializeShard(ShardRouting unassignedShard, String nodeId, @Nullable String existingAllocationId,                                         long expectedSize, RoutingChangesObserver routingChangesObserver);1524684173;Moves a shard from unassigned to initialize state__@param existingAllocationId allocation id to use. If null, a fresh allocation id is generated._@return                     the initialized shard;public ShardRouting initializeShard(ShardRouting unassignedShard, String nodeId, @Nullable String existingAllocationId,_                                        long expectedSize, RoutingChangesObserver routingChangesObserver) {_        ensureMutable()__        assert unassignedShard.unassigned() : "expected an unassigned shard " + unassignedShard__        ShardRouting initializedShard = unassignedShard.initialize(nodeId, existingAllocationId, expectedSize)__        node(nodeId).add(initializedShard)__        inactiveShardCount++__        if (initializedShard.primary()) {_            inactivePrimaryCount++__        }_        addRecovery(initializedShard)__        assignedShardsAdd(initializedShard)__        routingChangesObserver.shardInitialized(unassignedShard, initializedShard)__        return initializedShard__    };moves,a,shard,from,unassigned,to,initialize,state,param,existing,allocation,id,allocation,id,to,use,if,null,a,fresh,allocation,id,is,generated,return,the,initialized,shard;public,shard,routing,initialize,shard,shard,routing,unassigned,shard,string,node,id,nullable,string,existing,allocation,id,long,expected,size,routing,changes,observer,routing,changes,observer,ensure,mutable,assert,unassigned,shard,unassigned,expected,an,unassigned,shard,unassigned,shard,shard,routing,initialized,shard,unassigned,shard,initialize,node,id,existing,allocation,id,expected,size,node,node,id,add,initialized,shard,inactive,shard,count,if,initialized,shard,primary,inactive,primary,count,add,recovery,initialized,shard,assigned,shards,add,initialized,shard,routing,changes,observer,shard,initialized,unassigned,shard,initialized,shard,return,initialized,shard
RoutingNodes -> public ShardRouting initializeShard(ShardRouting unassignedShard, String nodeId, @Nullable String existingAllocationId,                                         long expectedSize, RoutingChangesObserver routingChangesObserver);1540847035;Moves a shard from unassigned to initialize state__@param existingAllocationId allocation id to use. If null, a fresh allocation id is generated._@return                     the initialized shard;public ShardRouting initializeShard(ShardRouting unassignedShard, String nodeId, @Nullable String existingAllocationId,_                                        long expectedSize, RoutingChangesObserver routingChangesObserver) {_        ensureMutable()__        assert unassignedShard.unassigned() : "expected an unassigned shard " + unassignedShard__        ShardRouting initializedShard = unassignedShard.initialize(nodeId, existingAllocationId, expectedSize)__        node(nodeId).add(initializedShard)__        inactiveShardCount++__        if (initializedShard.primary()) {_            inactivePrimaryCount++__        }_        addRecovery(initializedShard)__        assignedShardsAdd(initializedShard)__        routingChangesObserver.shardInitialized(unassignedShard, initializedShard)__        return initializedShard__    };moves,a,shard,from,unassigned,to,initialize,state,param,existing,allocation,id,allocation,id,to,use,if,null,a,fresh,allocation,id,is,generated,return,the,initialized,shard;public,shard,routing,initialize,shard,shard,routing,unassigned,shard,string,node,id,nullable,string,existing,allocation,id,long,expected,size,routing,changes,observer,routing,changes,observer,ensure,mutable,assert,unassigned,shard,unassigned,expected,an,unassigned,shard,unassigned,shard,shard,routing,initialized,shard,unassigned,shard,initialize,node,id,existing,allocation,id,expected,size,node,node,id,add,initialized,shard,inactive,shard,count,if,initialized,shard,primary,inactive,primary,count,add,recovery,initialized,shard,assigned,shards,add,initialized,shard,routing,changes,observer,shard,initialized,unassigned,shard,initialized,shard,return,initialized,shard
RoutingNodes -> public ShardRouting initializeShard(ShardRouting unassignedShard, String nodeId, @Nullable String existingAllocationId,                                         long expectedSize, RoutingChangesObserver routingChangesObserver);1541446827;Moves a shard from unassigned to initialize state__@param existingAllocationId allocation id to use. If null, a fresh allocation id is generated._@return                     the initialized shard;public ShardRouting initializeShard(ShardRouting unassignedShard, String nodeId, @Nullable String existingAllocationId,_                                        long expectedSize, RoutingChangesObserver routingChangesObserver) {_        ensureMutable()__        assert unassignedShard.unassigned() : "expected an unassigned shard " + unassignedShard__        ShardRouting initializedShard = unassignedShard.initialize(nodeId, existingAllocationId, expectedSize)__        node(nodeId).add(initializedShard)__        inactiveShardCount++__        if (initializedShard.primary()) {_            inactivePrimaryCount++__        }_        addRecovery(initializedShard)__        assignedShardsAdd(initializedShard)__        routingChangesObserver.shardInitialized(unassignedShard, initializedShard)__        return initializedShard__    };moves,a,shard,from,unassigned,to,initialize,state,param,existing,allocation,id,allocation,id,to,use,if,null,a,fresh,allocation,id,is,generated,return,the,initialized,shard;public,shard,routing,initialize,shard,shard,routing,unassigned,shard,string,node,id,nullable,string,existing,allocation,id,long,expected,size,routing,changes,observer,routing,changes,observer,ensure,mutable,assert,unassigned,shard,unassigned,expected,an,unassigned,shard,unassigned,shard,shard,routing,initialized,shard,unassigned,shard,initialize,node,id,existing,allocation,id,expected,size,node,node,id,add,initialized,shard,inactive,shard,count,if,initialized,shard,primary,inactive,primary,count,add,recovery,initialized,shard,assigned,shards,add,initialized,shard,routing,changes,observer,shard,initialized,unassigned,shard,initialized,shard,return,initialized,shard
RoutingNodes -> public ShardRouting initializeShard(ShardRouting unassignedShard, String nodeId, @Nullable String existingAllocationId,                                         long expectedSize, RoutingChangesObserver routingChangesObserver);1548259585;Moves a shard from unassigned to initialize state__@param existingAllocationId allocation id to use. If null, a fresh allocation id is generated._@return                     the initialized shard;public ShardRouting initializeShard(ShardRouting unassignedShard, String nodeId, @Nullable String existingAllocationId,_                                        long expectedSize, RoutingChangesObserver routingChangesObserver) {_        ensureMutable()__        assert unassignedShard.unassigned() : "expected an unassigned shard " + unassignedShard__        ShardRouting initializedShard = unassignedShard.initialize(nodeId, existingAllocationId, expectedSize)__        node(nodeId).add(initializedShard)__        inactiveShardCount++__        if (initializedShard.primary()) {_            inactivePrimaryCount++__        }_        addRecovery(initializedShard)__        assignedShardsAdd(initializedShard)__        routingChangesObserver.shardInitialized(unassignedShard, initializedShard)__        return initializedShard__    };moves,a,shard,from,unassigned,to,initialize,state,param,existing,allocation,id,allocation,id,to,use,if,null,a,fresh,allocation,id,is,generated,return,the,initialized,shard;public,shard,routing,initialize,shard,shard,routing,unassigned,shard,string,node,id,nullable,string,existing,allocation,id,long,expected,size,routing,changes,observer,routing,changes,observer,ensure,mutable,assert,unassigned,shard,unassigned,expected,an,unassigned,shard,unassigned,shard,shard,routing,initialized,shard,unassigned,shard,initialize,node,id,existing,allocation,id,expected,size,node,node,id,add,initialized,shard,inactive,shard,count,if,initialized,shard,primary,inactive,primary,count,add,recovery,initialized,shard,assigned,shards,add,initialized,shard,routing,changes,observer,shard,initialized,unassigned,shard,initialized,shard,return,initialized,shard
RoutingNodes -> public ShardRouting initializeShard(ShardRouting unassignedShard, String nodeId, @Nullable String existingAllocationId,                                         long expectedSize, RoutingChangesObserver routingChangesObserver);1549912434;Moves a shard from unassigned to initialize state__@param existingAllocationId allocation id to use. If null, a fresh allocation id is generated._@return                     the initialized shard;public ShardRouting initializeShard(ShardRouting unassignedShard, String nodeId, @Nullable String existingAllocationId,_                                        long expectedSize, RoutingChangesObserver routingChangesObserver) {_        ensureMutable()__        assert unassignedShard.unassigned() : "expected an unassigned shard " + unassignedShard__        ShardRouting initializedShard = unassignedShard.initialize(nodeId, existingAllocationId, expectedSize)__        node(nodeId).add(initializedShard)__        inactiveShardCount++__        if (initializedShard.primary()) {_            inactivePrimaryCount++__        }_        addRecovery(initializedShard)__        assignedShardsAdd(initializedShard)__        routingChangesObserver.shardInitialized(unassignedShard, initializedShard)__        return initializedShard__    };moves,a,shard,from,unassigned,to,initialize,state,param,existing,allocation,id,allocation,id,to,use,if,null,a,fresh,allocation,id,is,generated,return,the,initialized,shard;public,shard,routing,initialize,shard,shard,routing,unassigned,shard,string,node,id,nullable,string,existing,allocation,id,long,expected,size,routing,changes,observer,routing,changes,observer,ensure,mutable,assert,unassigned,shard,unassigned,expected,an,unassigned,shard,unassigned,shard,shard,routing,initialized,shard,unassigned,shard,initialize,node,id,existing,allocation,id,expected,size,node,node,id,add,initialized,shard,inactive,shard,count,if,initialized,shard,primary,inactive,primary,count,add,recovery,initialized,shard,assigned,shards,add,initialized,shard,routing,changes,observer,shard,initialized,unassigned,shard,initialized,shard,return,initialized,shard
