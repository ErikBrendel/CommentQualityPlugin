commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * How long the bulk execution took. Excluding ingest preprocessing.  */ ;/**  * How long the bulk execution took. Excluding ingest preprocessing.  */ public TimeValue getTook() {     return new TimeValue(tookInMillis). }
true;public;0;3;/**  * If ingest is enabled returns the bulk ingest preprocessing time, otherwise 0 is returned.  */ ;/**  * If ingest is enabled returns the bulk ingest preprocessing time, otherwise 0 is returned.  */ public TimeValue getIngestTook() {     return new TimeValue(ingestTookInMillis). }
true;public;0;3;/**  * If ingest is enabled returns the bulk ingest preprocessing time. in milliseconds, otherwise -1 is returned.  */ ;/**  * If ingest is enabled returns the bulk ingest preprocessing time. in milliseconds, otherwise -1 is returned.  */ public long getIngestTookInMillis() {     return ingestTookInMillis. }
true;public;0;8;/**  * Has anything failed with the execution.  */ ;/**  * Has anything failed with the execution.  */ public boolean hasFailures() {     for (BulkItemResponse response : responses) {         if (response.isFailed()) {             return true.         }     }     return false. }
false;public;0;14;;public String buildFailureMessage() {     StringBuilder sb = new StringBuilder().     sb.append("failure in bulk execution:").     for (int i = 0. i < responses.length. i++) {         BulkItemResponse response = responses[i].         if (response.isFailed()) {             sb.append("\n[").append(i).append("]: index [").append(response.getIndex()).append("], type [").append(response.getType()).append("], id [").append(response.getId()).append("], message [").append(response.getFailureMessage()).append("]").         }     }     return sb.toString(). }
true;public;0;3;/**  * The items representing each action performed in the bulk operation (in the same order!).  */ ;/**  * The items representing each action performed in the bulk operation (in the same order!).  */ public BulkItemResponse[] getItems() {     return responses. }
false;public;0;4;;@Override public Iterator<BulkItemResponse> iterator() {     return Arrays.stream(responses).iterator(). }
false;public;1;10;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     responses = new BulkItemResponse[in.readVInt()].     for (int i = 0. i < responses.length. i++) {         responses[i] = BulkItemResponse.readBulkItem(in).     }     tookInMillis = in.readVLong().     ingestTookInMillis = in.readZLong(). }
false;public;1;10;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeVInt(responses.length).     for (BulkItemResponse response : responses) {         response.writeTo(out).     }     out.writeVLong(tookInMillis).     out.writeZLong(ingestTookInMillis). }
false;public;0;4;;@Override public RestStatus status() {     return RestStatus.OK. }
false;public;2;16;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.field(TOOK, tookInMillis).     if (ingestTookInMillis != BulkResponse.NO_INGEST_TOOK) {         builder.field(INGEST_TOOK, ingestTookInMillis).     }     builder.field(ERRORS, hasFailures()).     builder.startArray(ITEMS).     for (BulkItemResponse item : this) {         item.toXContent(builder, params).     }     builder.endArray().     builder.endObject().     return builder. }
false;public,static;1;34;;public static BulkResponse fromXContent(XContentParser parser) throws IOException {     XContentParser.Token token = parser.nextToken().     ensureExpectedToken(XContentParser.Token.START_OBJECT, token, parser::getTokenLocation).     long took = -1L.     long ingestTook = NO_INGEST_TOOK.     List<BulkItemResponse> items = new ArrayList<>().     String currentFieldName = parser.currentName().     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token.isValue()) {             if (TOOK.equals(currentFieldName)) {                 took = parser.longValue().             } else if (INGEST_TOOK.equals(currentFieldName)) {                 ingestTook = parser.longValue().             } else if (ERRORS.equals(currentFieldName) == false) {                 throwUnknownField(currentFieldName, parser.getTokenLocation()).             }         } else if (token == XContentParser.Token.START_ARRAY) {             if (ITEMS.equals(currentFieldName)) {                 while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {                     items.add(BulkItemResponse.fromXContent(parser, items.size())).                 }             } else {                 throwUnknownField(currentFieldName, parser.getTokenLocation()).             }         } else {             throwUnknownToken(token, parser.getTokenLocation()).         }     }     return new BulkResponse(items.toArray(new BulkItemResponse[items.size()]), took, ingestTook). }
