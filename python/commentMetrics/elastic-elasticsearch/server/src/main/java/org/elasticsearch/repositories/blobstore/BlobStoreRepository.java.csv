# id;timestamp;commentText;codeText;commentWords;codeWords
BlobStoreRepository -> RestoreContext -> RestoreContext(IndexShard shard, SnapshotId snapshotId, Version version, IndexId indexId, ShardId snapshotShardId, RecoveryState recoveryState);1524684173;Constructs new restore context__@param shard           shard to restore into_@param snapshotId      snapshot id_@param indexId         id of the index being restored_@param snapshotShardId shard in the snapshot that data should be restored from_@param recoveryState   recovery state to report progress;RestoreContext(IndexShard shard, SnapshotId snapshotId, Version version, IndexId indexId, ShardId snapshotShardId, RecoveryState recoveryState) {_            super(snapshotId, version, indexId, shard.shardId(), snapshotShardId)__            this.recoveryState = recoveryState__            this.targetShard = shard__        };constructs,new,restore,context,param,shard,shard,to,restore,into,param,snapshot,id,snapshot,id,param,index,id,id,of,the,index,being,restored,param,snapshot,shard,id,shard,in,the,snapshot,that,data,should,be,restored,from,param,recovery,state,recovery,state,to,report,progress;restore,context,index,shard,shard,snapshot,id,snapshot,id,version,version,index,id,index,id,shard,id,snapshot,shard,id,recovery,state,recovery,state,super,snapshot,id,version,index,id,shard,shard,id,snapshot,shard,id,this,recovery,state,recovery,state,this,target,shard,shard
BlobStoreRepository -> RestoreContext -> RestoreContext(IndexShard shard, SnapshotId snapshotId, Version version, IndexId indexId, ShardId snapshotShardId, RecoveryState recoveryState);1525334055;Constructs new restore context__@param shard           shard to restore into_@param snapshotId      snapshot id_@param indexId         id of the index being restored_@param snapshotShardId shard in the snapshot that data should be restored from_@param recoveryState   recovery state to report progress;RestoreContext(IndexShard shard, SnapshotId snapshotId, Version version, IndexId indexId, ShardId snapshotShardId, RecoveryState recoveryState) {_            super(snapshotId, version, indexId, shard.shardId(), snapshotShardId)__            this.recoveryState = recoveryState__            this.targetShard = shard__        };constructs,new,restore,context,param,shard,shard,to,restore,into,param,snapshot,id,snapshot,id,param,index,id,id,of,the,index,being,restored,param,snapshot,shard,id,shard,in,the,snapshot,that,data,should,be,restored,from,param,recovery,state,recovery,state,to,report,progress;restore,context,index,shard,shard,snapshot,id,snapshot,id,version,version,index,id,index,id,shard,id,snapshot,shard,id,recovery,state,recovery,state,super,snapshot,id,version,index,id,shard,shard,id,snapshot,shard,id,this,recovery,state,recovery,state,this,target,shard,shard
BlobStoreRepository -> RestoreContext -> RestoreContext(IndexShard shard, SnapshotId snapshotId, Version version, IndexId indexId, ShardId snapshotShardId, RecoveryState recoveryState);1525798020;Constructs new restore context__@param shard           shard to restore into_@param snapshotId      snapshot id_@param indexId         id of the index being restored_@param snapshotShardId shard in the snapshot that data should be restored from_@param recoveryState   recovery state to report progress;RestoreContext(IndexShard shard, SnapshotId snapshotId, Version version, IndexId indexId, ShardId snapshotShardId, RecoveryState recoveryState) {_            super(snapshotId, version, indexId, shard.shardId(), snapshotShardId)__            this.recoveryState = recoveryState__            this.targetShard = shard__        };constructs,new,restore,context,param,shard,shard,to,restore,into,param,snapshot,id,snapshot,id,param,index,id,id,of,the,index,being,restored,param,snapshot,shard,id,shard,in,the,snapshot,that,data,should,be,restored,from,param,recovery,state,recovery,state,to,report,progress;restore,context,index,shard,shard,snapshot,id,snapshot,id,version,version,index,id,index,id,shard,id,snapshot,shard,id,recovery,state,recovery,state,super,snapshot,id,version,index,id,shard,shard,id,snapshot,shard,id,this,recovery,state,recovery,state,this,target,shard,shard
BlobStoreRepository -> RestoreContext -> RestoreContext(IndexShard shard, SnapshotId snapshotId, Version version, IndexId indexId, ShardId snapshotShardId, RecoveryState recoveryState);1526289033;Constructs new restore context__@param shard           shard to restore into_@param snapshotId      snapshot id_@param indexId         id of the index being restored_@param snapshotShardId shard in the snapshot that data should be restored from_@param recoveryState   recovery state to report progress;RestoreContext(IndexShard shard, SnapshotId snapshotId, Version version, IndexId indexId, ShardId snapshotShardId, RecoveryState recoveryState) {_            super(snapshotId, version, indexId, shard.shardId(), snapshotShardId)__            this.recoveryState = recoveryState__            this.targetShard = shard__        };constructs,new,restore,context,param,shard,shard,to,restore,into,param,snapshot,id,snapshot,id,param,index,id,id,of,the,index,being,restored,param,snapshot,shard,id,shard,in,the,snapshot,that,data,should,be,restored,from,param,recovery,state,recovery,state,to,report,progress;restore,context,index,shard,shard,snapshot,id,snapshot,id,version,version,index,id,index,id,shard,id,snapshot,shard,id,recovery,state,recovery,state,super,snapshot,id,version,index,id,shard,shard,id,snapshot,shard,id,this,recovery,state,recovery,state,this,target,shard,shard
BlobStoreRepository -> RestoreContext -> RestoreContext(IndexShard shard, SnapshotId snapshotId, Version version, IndexId indexId, ShardId snapshotShardId, RecoveryState recoveryState);1526574077;Constructs new restore context__@param shard           shard to restore into_@param snapshotId      snapshot id_@param indexId         id of the index being restored_@param snapshotShardId shard in the snapshot that data should be restored from_@param recoveryState   recovery state to report progress;RestoreContext(IndexShard shard, SnapshotId snapshotId, Version version, IndexId indexId, ShardId snapshotShardId, RecoveryState recoveryState) {_            super(snapshotId, version, indexId, shard.shardId(), snapshotShardId)__            this.recoveryState = recoveryState__            this.targetShard = shard__        };constructs,new,restore,context,param,shard,shard,to,restore,into,param,snapshot,id,snapshot,id,param,index,id,id,of,the,index,being,restored,param,snapshot,shard,id,shard,in,the,snapshot,that,data,should,be,restored,from,param,recovery,state,recovery,state,to,report,progress;restore,context,index,shard,shard,snapshot,id,snapshot,id,version,version,index,id,index,id,shard,id,snapshot,shard,id,recovery,state,recovery,state,super,snapshot,id,version,index,id,shard,shard,id,snapshot,shard,id,this,recovery,state,recovery,state,this,target,shard,shard
BlobStoreRepository -> RestoreContext -> RestoreContext(IndexShard shard, SnapshotId snapshotId, Version version, IndexId indexId, ShardId snapshotShardId, RecoveryState recoveryState);1527583663;Constructs new restore context__@param shard           shard to restore into_@param snapshotId      snapshot id_@param indexId         id of the index being restored_@param snapshotShardId shard in the snapshot that data should be restored from_@param recoveryState   recovery state to report progress;RestoreContext(IndexShard shard, SnapshotId snapshotId, Version version, IndexId indexId, ShardId snapshotShardId, RecoveryState recoveryState) {_            super(snapshotId, version, indexId, shard.shardId(), snapshotShardId)__            this.recoveryState = recoveryState__            this.targetShard = shard__        };constructs,new,restore,context,param,shard,shard,to,restore,into,param,snapshot,id,snapshot,id,param,index,id,id,of,the,index,being,restored,param,snapshot,shard,id,shard,in,the,snapshot,that,data,should,be,restored,from,param,recovery,state,recovery,state,to,report,progress;restore,context,index,shard,shard,snapshot,id,snapshot,id,version,version,index,id,index,id,shard,id,snapshot,shard,id,recovery,state,recovery,state,super,snapshot,id,version,index,id,shard,shard,id,snapshot,shard,id,this,recovery,state,recovery,state,this,target,shard,shard
BlobStoreRepository -> RestoreContext -> RestoreContext(IndexShard shard, SnapshotId snapshotId, Version version, IndexId indexId, ShardId snapshotShardId, RecoveryState recoveryState);1528211342;Constructs new restore context__@param shard           shard to restore into_@param snapshotId      snapshot id_@param indexId         id of the index being restored_@param snapshotShardId shard in the snapshot that data should be restored from_@param recoveryState   recovery state to report progress;RestoreContext(IndexShard shard, SnapshotId snapshotId, Version version, IndexId indexId, ShardId snapshotShardId, RecoveryState recoveryState) {_            super(snapshotId, version, indexId, shard.shardId(), snapshotShardId)__            this.recoveryState = recoveryState__            this.targetShard = shard__        };constructs,new,restore,context,param,shard,shard,to,restore,into,param,snapshot,id,snapshot,id,param,index,id,id,of,the,index,being,restored,param,snapshot,shard,id,shard,in,the,snapshot,that,data,should,be,restored,from,param,recovery,state,recovery,state,to,report,progress;restore,context,index,shard,shard,snapshot,id,snapshot,id,version,version,index,id,index,id,shard,id,snapshot,shard,id,recovery,state,recovery,state,super,snapshot,id,version,index,id,shard,shard,id,snapshot,shard,id,this,recovery,state,recovery,state,this,target,shard,shard
BlobStoreRepository -> RestoreContext -> RestoreContext(IndexShard shard, SnapshotId snapshotId, Version version, IndexId indexId, ShardId snapshotShardId, RecoveryState recoveryState);1531179852;Constructs new restore context__@param shard           shard to restore into_@param snapshotId      snapshot id_@param indexId         id of the index being restored_@param snapshotShardId shard in the snapshot that data should be restored from_@param recoveryState   recovery state to report progress;RestoreContext(IndexShard shard, SnapshotId snapshotId, Version version, IndexId indexId, ShardId snapshotShardId, RecoveryState recoveryState) {_            super(snapshotId, version, indexId, shard.shardId(), snapshotShardId)__            this.recoveryState = recoveryState__            this.targetShard = shard__        };constructs,new,restore,context,param,shard,shard,to,restore,into,param,snapshot,id,snapshot,id,param,index,id,id,of,the,index,being,restored,param,snapshot,shard,id,shard,in,the,snapshot,that,data,should,be,restored,from,param,recovery,state,recovery,state,to,report,progress;restore,context,index,shard,shard,snapshot,id,snapshot,id,version,version,index,id,index,id,shard,id,snapshot,shard,id,recovery,state,recovery,state,super,snapshot,id,version,index,id,shard,shard,id,snapshot,shard,id,this,recovery,state,recovery,state,this,target,shard,shard
BlobStoreRepository -> RestoreContext -> RestoreContext(IndexShard shard, SnapshotId snapshotId, Version version, IndexId indexId, ShardId snapshotShardId, RecoveryState recoveryState);1531729807;Constructs new restore context__@param shard           shard to restore into_@param snapshotId      snapshot id_@param indexId         id of the index being restored_@param snapshotShardId shard in the snapshot that data should be restored from_@param recoveryState   recovery state to report progress;RestoreContext(IndexShard shard, SnapshotId snapshotId, Version version, IndexId indexId, ShardId snapshotShardId, RecoveryState recoveryState) {_            super(snapshotId, version, indexId, shard.shardId(), snapshotShardId)__            this.recoveryState = recoveryState__            this.targetShard = shard__        };constructs,new,restore,context,param,shard,shard,to,restore,into,param,snapshot,id,snapshot,id,param,index,id,id,of,the,index,being,restored,param,snapshot,shard,id,shard,in,the,snapshot,that,data,should,be,restored,from,param,recovery,state,recovery,state,to,report,progress;restore,context,index,shard,shard,snapshot,id,snapshot,id,version,version,index,id,index,id,shard,id,snapshot,shard,id,recovery,state,recovery,state,super,snapshot,id,version,index,id,shard,shard,id,snapshot,shard,id,this,recovery,state,recovery,state,this,target,shard,shard
BlobStoreRepository -> RestoreContext -> RestoreContext(IndexShard shard, SnapshotId snapshotId, Version version, IndexId indexId, ShardId snapshotShardId, RecoveryState recoveryState);1532685069;Constructs new restore context__@param shard           shard to restore into_@param snapshotId      snapshot id_@param indexId         id of the index being restored_@param snapshotShardId shard in the snapshot that data should be restored from_@param recoveryState   recovery state to report progress;RestoreContext(IndexShard shard, SnapshotId snapshotId, Version version, IndexId indexId, ShardId snapshotShardId, RecoveryState recoveryState) {_            super(snapshotId, version, indexId, shard.shardId(), snapshotShardId)__            this.recoveryState = recoveryState__            this.targetShard = shard__        };constructs,new,restore,context,param,shard,shard,to,restore,into,param,snapshot,id,snapshot,id,param,index,id,id,of,the,index,being,restored,param,snapshot,shard,id,shard,in,the,snapshot,that,data,should,be,restored,from,param,recovery,state,recovery,state,to,report,progress;restore,context,index,shard,shard,snapshot,id,snapshot,id,version,version,index,id,index,id,shard,id,snapshot,shard,id,recovery,state,recovery,state,super,snapshot,id,version,index,id,shard,shard,id,snapshot,shard,id,this,recovery,state,recovery,state,this,target,shard,shard
BlobStoreRepository -> RestoreContext -> RestoreContext(IndexShard shard, SnapshotId snapshotId, Version version, IndexId indexId, ShardId snapshotShardId, RecoveryState recoveryState);1535139672;Constructs new restore context__@param shard           shard to restore into_@param snapshotId      snapshot id_@param indexId         id of the index being restored_@param snapshotShardId shard in the snapshot that data should be restored from_@param recoveryState   recovery state to report progress;RestoreContext(IndexShard shard, SnapshotId snapshotId, Version version, IndexId indexId, ShardId snapshotShardId, RecoveryState recoveryState) {_            super(snapshotId, version, indexId, shard.shardId(), snapshotShardId)__            this.recoveryState = recoveryState__            this.targetShard = shard__        };constructs,new,restore,context,param,shard,shard,to,restore,into,param,snapshot,id,snapshot,id,param,index,id,id,of,the,index,being,restored,param,snapshot,shard,id,shard,in,the,snapshot,that,data,should,be,restored,from,param,recovery,state,recovery,state,to,report,progress;restore,context,index,shard,shard,snapshot,id,snapshot,id,version,version,index,id,index,id,shard,id,snapshot,shard,id,recovery,state,recovery,state,super,snapshot,id,version,index,id,shard,shard,id,snapshot,shard,id,this,recovery,state,recovery,state,this,target,shard,shard
BlobStoreRepository -> RestoreContext -> RestoreContext(IndexShard shard, SnapshotId snapshotId, Version version, IndexId indexId, ShardId snapshotShardId, RecoveryState recoveryState);1535723122;Constructs new restore context__@param shard           shard to restore into_@param snapshotId      snapshot id_@param indexId         id of the index being restored_@param snapshotShardId shard in the snapshot that data should be restored from_@param recoveryState   recovery state to report progress;RestoreContext(IndexShard shard, SnapshotId snapshotId, Version version, IndexId indexId, ShardId snapshotShardId, RecoveryState recoveryState) {_            super(snapshotId, version, indexId, shard.shardId(), snapshotShardId)__            this.recoveryState = recoveryState__            this.targetShard = shard__        };constructs,new,restore,context,param,shard,shard,to,restore,into,param,snapshot,id,snapshot,id,param,index,id,id,of,the,index,being,restored,param,snapshot,shard,id,shard,in,the,snapshot,that,data,should,be,restored,from,param,recovery,state,recovery,state,to,report,progress;restore,context,index,shard,shard,snapshot,id,snapshot,id,version,version,index,id,index,id,shard,id,snapshot,shard,id,recovery,state,recovery,state,super,snapshot,id,version,index,id,shard,shard,id,snapshot,shard,id,this,recovery,state,recovery,state,this,target,shard,shard
BlobStoreRepository -> RestoreContext -> RestoreContext(IndexShard shard, SnapshotId snapshotId, Version version, IndexId indexId, ShardId snapshotShardId, RecoveryState recoveryState);1536314350;Constructs new restore context__@param shard           shard to restore into_@param snapshotId      snapshot id_@param indexId         id of the index being restored_@param snapshotShardId shard in the snapshot that data should be restored from_@param recoveryState   recovery state to report progress;RestoreContext(IndexShard shard, SnapshotId snapshotId, Version version, IndexId indexId, ShardId snapshotShardId, RecoveryState recoveryState) {_            super(snapshotId, version, indexId, shard.shardId(), snapshotShardId)__            this.recoveryState = recoveryState__            this.targetShard = shard__        };constructs,new,restore,context,param,shard,shard,to,restore,into,param,snapshot,id,snapshot,id,param,index,id,id,of,the,index,being,restored,param,snapshot,shard,id,shard,in,the,snapshot,that,data,should,be,restored,from,param,recovery,state,recovery,state,to,report,progress;restore,context,index,shard,shard,snapshot,id,snapshot,id,version,version,index,id,index,id,shard,id,snapshot,shard,id,recovery,state,recovery,state,super,snapshot,id,version,index,id,shard,shard,id,snapshot,shard,id,this,recovery,state,recovery,state,this,target,shard,shard
BlobStoreRepository -> RestoreContext -> RestoreContext(IndexShard shard, SnapshotId snapshotId, Version version, IndexId indexId, ShardId snapshotShardId, RecoveryState recoveryState);1536828374;Constructs new restore context__@param shard           shard to restore into_@param snapshotId      snapshot id_@param indexId         id of the index being restored_@param snapshotShardId shard in the snapshot that data should be restored from_@param recoveryState   recovery state to report progress;RestoreContext(IndexShard shard, SnapshotId snapshotId, Version version, IndexId indexId, ShardId snapshotShardId, RecoveryState recoveryState) {_            super(snapshotId, version, indexId, shard.shardId(), snapshotShardId)__            this.recoveryState = recoveryState__            this.targetShard = shard__        };constructs,new,restore,context,param,shard,shard,to,restore,into,param,snapshot,id,snapshot,id,param,index,id,id,of,the,index,being,restored,param,snapshot,shard,id,shard,in,the,snapshot,that,data,should,be,restored,from,param,recovery,state,recovery,state,to,report,progress;restore,context,index,shard,shard,snapshot,id,snapshot,id,version,version,index,id,index,id,shard,id,snapshot,shard,id,recovery,state,recovery,state,super,snapshot,id,version,index,id,shard,shard,id,snapshot,shard,id,this,recovery,state,recovery,state,this,target,shard,shard
BlobStoreRepository -> RestoreContext -> RestoreContext(IndexShard shard, SnapshotId snapshotId, Version version, IndexId indexId, ShardId snapshotShardId, RecoveryState recoveryState);1541008027;Constructs new restore context__@param shard           shard to restore into_@param snapshotId      snapshot id_@param indexId         id of the index being restored_@param snapshotShardId shard in the snapshot that data should be restored from_@param recoveryState   recovery state to report progress;RestoreContext(IndexShard shard, SnapshotId snapshotId, Version version, IndexId indexId, ShardId snapshotShardId, RecoveryState recoveryState) {_            super(snapshotId, version, indexId, shard.shardId(), snapshotShardId)__            this.recoveryState = recoveryState__            this.targetShard = shard__        };constructs,new,restore,context,param,shard,shard,to,restore,into,param,snapshot,id,snapshot,id,param,index,id,id,of,the,index,being,restored,param,snapshot,shard,id,shard,in,the,snapshot,that,data,should,be,restored,from,param,recovery,state,recovery,state,to,report,progress;restore,context,index,shard,shard,snapshot,id,snapshot,id,version,version,index,id,index,id,shard,id,snapshot,shard,id,recovery,state,recovery,state,super,snapshot,id,version,index,id,shard,shard,id,snapshot,shard,id,this,recovery,state,recovery,state,this,target,shard,shard
BlobStoreRepository -> RestoreContext -> RestoreContext(IndexShard shard, SnapshotId snapshotId, Version version, IndexId indexId, ShardId snapshotShardId, RecoveryState recoveryState);1542646292;Constructs new restore context__@param shard           shard to restore into_@param snapshotId      snapshot id_@param indexId         id of the index being restored_@param snapshotShardId shard in the snapshot that data should be restored from_@param recoveryState   recovery state to report progress;RestoreContext(IndexShard shard, SnapshotId snapshotId, Version version, IndexId indexId, ShardId snapshotShardId, RecoveryState recoveryState) {_            super(snapshotId, version, indexId, shard.shardId(), snapshotShardId)__            this.recoveryState = recoveryState__            this.targetShard = shard__        };constructs,new,restore,context,param,shard,shard,to,restore,into,param,snapshot,id,snapshot,id,param,index,id,id,of,the,index,being,restored,param,snapshot,shard,id,shard,in,the,snapshot,that,data,should,be,restored,from,param,recovery,state,recovery,state,to,report,progress;restore,context,index,shard,shard,snapshot,id,snapshot,id,version,version,index,id,index,id,shard,id,snapshot,shard,id,recovery,state,recovery,state,super,snapshot,id,version,index,id,shard,shard,id,snapshot,shard,id,this,recovery,state,recovery,state,this,target,shard,shard
BlobStoreRepository -> RestoreContext -> RestoreContext(IndexShard shard, SnapshotId snapshotId, Version version, IndexId indexId, ShardId snapshotShardId, RecoveryState recoveryState);1542980705;Constructs new restore context__@param shard           shard to restore into_@param snapshotId      snapshot id_@param indexId         id of the index being restored_@param snapshotShardId shard in the snapshot that data should be restored from_@param recoveryState   recovery state to report progress;RestoreContext(IndexShard shard, SnapshotId snapshotId, Version version, IndexId indexId, ShardId snapshotShardId, RecoveryState recoveryState) {_            super(snapshotId, version, indexId, shard.shardId(), snapshotShardId)__            this.recoveryState = recoveryState__            this.targetShard = shard__        };constructs,new,restore,context,param,shard,shard,to,restore,into,param,snapshot,id,snapshot,id,param,index,id,id,of,the,index,being,restored,param,snapshot,shard,id,shard,in,the,snapshot,that,data,should,be,restored,from,param,recovery,state,recovery,state,to,report,progress;restore,context,index,shard,shard,snapshot,id,snapshot,id,version,version,index,id,index,id,shard,id,snapshot,shard,id,recovery,state,recovery,state,super,snapshot,id,version,index,id,shard,shard,id,snapshot,shard,id,this,recovery,state,recovery,state,this,target,shard,shard
BlobStoreRepository -> SnapshotContext -> private void snapshotFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo) throws IOException;1524684173;Snapshot individual file_<p>_This is asynchronous method. Upon completion of the operation latch is getting counted down and any failures are_added to the {@code failures} list__@param fileInfo file to be snapshotted;private void snapshotFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo) throws IOException {_            final String file = fileInfo.physicalName()__            try (IndexInput indexInput = store.openVerifyingInput(file, IOContext.READONCE, fileInfo.metadata())) {_                for (int i = 0_ i < fileInfo.numberOfParts()_ i++) {_                    final long partBytes = fileInfo.partBytes(i)___                    final InputStreamIndexInput inputStreamIndexInput = new InputStreamIndexInput(indexInput, partBytes)__                    InputStream inputStream = inputStreamIndexInput__                    if (snapshotRateLimiter != null) {_                        inputStream = new RateLimitingInputStream(inputStreamIndexInput, snapshotRateLimiter,_                                                                  snapshotRateLimitingTimeInNanos::inc)__                    }_                    inputStream = new AbortableInputStream(inputStream, fileInfo.physicalName())__                    blobContainer.writeBlob(fileInfo.partName(i), inputStream, partBytes)__                }_                Store.verify(indexInput)__                snapshotStatus.addProcessedFile(fileInfo.length())__            } catch (Exception t) {_                failStoreIfCorrupted(t)__                snapshotStatus.addProcessedFile(0)__                throw t__            }_        };snapshot,individual,file,p,this,is,asynchronous,method,upon,completion,of,the,operation,latch,is,getting,counted,down,and,any,failures,are,added,to,the,code,failures,list,param,file,info,file,to,be,snapshotted;private,void,snapshot,file,final,blob,store,index,shard,snapshot,file,info,file,info,throws,ioexception,final,string,file,file,info,physical,name,try,index,input,index,input,store,open,verifying,input,file,iocontext,readonce,file,info,metadata,for,int,i,0,i,file,info,number,of,parts,i,final,long,part,bytes,file,info,part,bytes,i,final,input,stream,index,input,input,stream,index,input,new,input,stream,index,input,index,input,part,bytes,input,stream,input,stream,input,stream,index,input,if,snapshot,rate,limiter,null,input,stream,new,rate,limiting,input,stream,input,stream,index,input,snapshot,rate,limiter,snapshot,rate,limiting,time,in,nanos,inc,input,stream,new,abortable,input,stream,input,stream,file,info,physical,name,blob,container,write,blob,file,info,part,name,i,input,stream,part,bytes,store,verify,index,input,snapshot,status,add,processed,file,file,info,length,catch,exception,t,fail,store,if,corrupted,t,snapshot,status,add,processed,file,0,throw,t
BlobStoreRepository -> SnapshotContext -> private void snapshotFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo) throws IOException;1525334055;Snapshot individual file_<p>_This is asynchronous method. Upon completion of the operation latch is getting counted down and any failures are_added to the {@code failures} list__@param fileInfo file to be snapshotted;private void snapshotFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo) throws IOException {_            final String file = fileInfo.physicalName()__            try (IndexInput indexInput = store.openVerifyingInput(file, IOContext.READONCE, fileInfo.metadata())) {_                for (int i = 0_ i < fileInfo.numberOfParts()_ i++) {_                    final long partBytes = fileInfo.partBytes(i)___                    final InputStreamIndexInput inputStreamIndexInput = new InputStreamIndexInput(indexInput, partBytes)__                    InputStream inputStream = inputStreamIndexInput__                    if (snapshotRateLimiter != null) {_                        inputStream = new RateLimitingInputStream(inputStreamIndexInput, snapshotRateLimiter,_                                                                  snapshotRateLimitingTimeInNanos::inc)__                    }_                    inputStream = new AbortableInputStream(inputStream, fileInfo.physicalName())__                    blobContainer.writeBlob(fileInfo.partName(i), inputStream, partBytes)__                }_                Store.verify(indexInput)__                snapshotStatus.addProcessedFile(fileInfo.length())__            } catch (Exception t) {_                failStoreIfCorrupted(t)__                snapshotStatus.addProcessedFile(0)__                throw t__            }_        };snapshot,individual,file,p,this,is,asynchronous,method,upon,completion,of,the,operation,latch,is,getting,counted,down,and,any,failures,are,added,to,the,code,failures,list,param,file,info,file,to,be,snapshotted;private,void,snapshot,file,final,blob,store,index,shard,snapshot,file,info,file,info,throws,ioexception,final,string,file,file,info,physical,name,try,index,input,index,input,store,open,verifying,input,file,iocontext,readonce,file,info,metadata,for,int,i,0,i,file,info,number,of,parts,i,final,long,part,bytes,file,info,part,bytes,i,final,input,stream,index,input,input,stream,index,input,new,input,stream,index,input,index,input,part,bytes,input,stream,input,stream,input,stream,index,input,if,snapshot,rate,limiter,null,input,stream,new,rate,limiting,input,stream,input,stream,index,input,snapshot,rate,limiter,snapshot,rate,limiting,time,in,nanos,inc,input,stream,new,abortable,input,stream,input,stream,file,info,physical,name,blob,container,write,blob,file,info,part,name,i,input,stream,part,bytes,store,verify,index,input,snapshot,status,add,processed,file,file,info,length,catch,exception,t,fail,store,if,corrupted,t,snapshot,status,add,processed,file,0,throw,t
BlobStoreRepository -> SnapshotContext -> private void snapshotFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo) throws IOException;1525798020;Snapshot individual file_<p>_This is asynchronous method. Upon completion of the operation latch is getting counted down and any failures are_added to the {@code failures} list__@param fileInfo file to be snapshotted;private void snapshotFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo) throws IOException {_            final String file = fileInfo.physicalName()__            try (IndexInput indexInput = store.openVerifyingInput(file, IOContext.READONCE, fileInfo.metadata())) {_                for (int i = 0_ i < fileInfo.numberOfParts()_ i++) {_                    final long partBytes = fileInfo.partBytes(i)___                    final InputStreamIndexInput inputStreamIndexInput = new InputStreamIndexInput(indexInput, partBytes)__                    InputStream inputStream = inputStreamIndexInput__                    if (snapshotRateLimiter != null) {_                        inputStream = new RateLimitingInputStream(inputStreamIndexInput, snapshotRateLimiter,_                                                                  snapshotRateLimitingTimeInNanos::inc)__                    }_                    inputStream = new AbortableInputStream(inputStream, fileInfo.physicalName())__                    blobContainer.writeBlob(fileInfo.partName(i), inputStream, partBytes)__                }_                Store.verify(indexInput)__                snapshotStatus.addProcessedFile(fileInfo.length())__            } catch (Exception t) {_                failStoreIfCorrupted(t)__                snapshotStatus.addProcessedFile(0)__                throw t__            }_        };snapshot,individual,file,p,this,is,asynchronous,method,upon,completion,of,the,operation,latch,is,getting,counted,down,and,any,failures,are,added,to,the,code,failures,list,param,file,info,file,to,be,snapshotted;private,void,snapshot,file,final,blob,store,index,shard,snapshot,file,info,file,info,throws,ioexception,final,string,file,file,info,physical,name,try,index,input,index,input,store,open,verifying,input,file,iocontext,readonce,file,info,metadata,for,int,i,0,i,file,info,number,of,parts,i,final,long,part,bytes,file,info,part,bytes,i,final,input,stream,index,input,input,stream,index,input,new,input,stream,index,input,index,input,part,bytes,input,stream,input,stream,input,stream,index,input,if,snapshot,rate,limiter,null,input,stream,new,rate,limiting,input,stream,input,stream,index,input,snapshot,rate,limiter,snapshot,rate,limiting,time,in,nanos,inc,input,stream,new,abortable,input,stream,input,stream,file,info,physical,name,blob,container,write,blob,file,info,part,name,i,input,stream,part,bytes,store,verify,index,input,snapshot,status,add,processed,file,file,info,length,catch,exception,t,fail,store,if,corrupted,t,snapshot,status,add,processed,file,0,throw,t
BlobStoreRepository -> SnapshotContext -> private void snapshotFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo) throws IOException;1526289033;Snapshot individual file_<p>_This is asynchronous method. Upon completion of the operation latch is getting counted down and any failures are_added to the {@code failures} list__@param fileInfo file to be snapshotted;private void snapshotFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo) throws IOException {_            final String file = fileInfo.physicalName()__            try (IndexInput indexInput = store.openVerifyingInput(file, IOContext.READONCE, fileInfo.metadata())) {_                for (int i = 0_ i < fileInfo.numberOfParts()_ i++) {_                    final long partBytes = fileInfo.partBytes(i)___                    final InputStreamIndexInput inputStreamIndexInput = new InputStreamIndexInput(indexInput, partBytes)__                    InputStream inputStream = inputStreamIndexInput__                    if (snapshotRateLimiter != null) {_                        inputStream = new RateLimitingInputStream(inputStreamIndexInput, snapshotRateLimiter,_                                                                  snapshotRateLimitingTimeInNanos::inc)__                    }_                    inputStream = new AbortableInputStream(inputStream, fileInfo.physicalName())__                    blobContainer.writeBlob(fileInfo.partName(i), inputStream, partBytes)__                }_                Store.verify(indexInput)__                snapshotStatus.addProcessedFile(fileInfo.length())__            } catch (Exception t) {_                failStoreIfCorrupted(t)__                snapshotStatus.addProcessedFile(0)__                throw t__            }_        };snapshot,individual,file,p,this,is,asynchronous,method,upon,completion,of,the,operation,latch,is,getting,counted,down,and,any,failures,are,added,to,the,code,failures,list,param,file,info,file,to,be,snapshotted;private,void,snapshot,file,final,blob,store,index,shard,snapshot,file,info,file,info,throws,ioexception,final,string,file,file,info,physical,name,try,index,input,index,input,store,open,verifying,input,file,iocontext,readonce,file,info,metadata,for,int,i,0,i,file,info,number,of,parts,i,final,long,part,bytes,file,info,part,bytes,i,final,input,stream,index,input,input,stream,index,input,new,input,stream,index,input,index,input,part,bytes,input,stream,input,stream,input,stream,index,input,if,snapshot,rate,limiter,null,input,stream,new,rate,limiting,input,stream,input,stream,index,input,snapshot,rate,limiter,snapshot,rate,limiting,time,in,nanos,inc,input,stream,new,abortable,input,stream,input,stream,file,info,physical,name,blob,container,write,blob,file,info,part,name,i,input,stream,part,bytes,store,verify,index,input,snapshot,status,add,processed,file,file,info,length,catch,exception,t,fail,store,if,corrupted,t,snapshot,status,add,processed,file,0,throw,t
BlobStoreRepository -> SnapshotContext -> private void snapshotFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo) throws IOException;1526574077;Snapshot individual file__@param fileInfo file to be snapshotted;private void snapshotFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo) throws IOException {_            final String file = fileInfo.physicalName()__            try (IndexInput indexInput = store.openVerifyingInput(file, IOContext.READONCE, fileInfo.metadata())) {_                for (int i = 0_ i < fileInfo.numberOfParts()_ i++) {_                    final long partBytes = fileInfo.partBytes(i)___                    final InputStreamIndexInput inputStreamIndexInput = new InputStreamIndexInput(indexInput, partBytes)__                    InputStream inputStream = inputStreamIndexInput__                    if (snapshotRateLimiter != null) {_                        inputStream = new RateLimitingInputStream(inputStreamIndexInput, snapshotRateLimiter,_                                                                  snapshotRateLimitingTimeInNanos::inc)__                    }_                    inputStream = new AbortableInputStream(inputStream, fileInfo.physicalName())__                    blobContainer.writeBlob(fileInfo.partName(i), inputStream, partBytes)__                }_                Store.verify(indexInput)__                snapshotStatus.addProcessedFile(fileInfo.length())__            } catch (Exception t) {_                failStoreIfCorrupted(t)__                snapshotStatus.addProcessedFile(0)__                throw t__            }_        };snapshot,individual,file,param,file,info,file,to,be,snapshotted;private,void,snapshot,file,final,blob,store,index,shard,snapshot,file,info,file,info,throws,ioexception,final,string,file,file,info,physical,name,try,index,input,index,input,store,open,verifying,input,file,iocontext,readonce,file,info,metadata,for,int,i,0,i,file,info,number,of,parts,i,final,long,part,bytes,file,info,part,bytes,i,final,input,stream,index,input,input,stream,index,input,new,input,stream,index,input,index,input,part,bytes,input,stream,input,stream,input,stream,index,input,if,snapshot,rate,limiter,null,input,stream,new,rate,limiting,input,stream,input,stream,index,input,snapshot,rate,limiter,snapshot,rate,limiting,time,in,nanos,inc,input,stream,new,abortable,input,stream,input,stream,file,info,physical,name,blob,container,write,blob,file,info,part,name,i,input,stream,part,bytes,store,verify,index,input,snapshot,status,add,processed,file,file,info,length,catch,exception,t,fail,store,if,corrupted,t,snapshot,status,add,processed,file,0,throw,t
BlobStoreRepository -> SnapshotContext -> private void snapshotFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo) throws IOException;1527583663;Snapshot individual file__@param fileInfo file to be snapshotted;private void snapshotFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo) throws IOException {_            final String file = fileInfo.physicalName()__            try (IndexInput indexInput = store.openVerifyingInput(file, IOContext.READONCE, fileInfo.metadata())) {_                for (int i = 0_ i < fileInfo.numberOfParts()_ i++) {_                    final long partBytes = fileInfo.partBytes(i)___                    final InputStreamIndexInput inputStreamIndexInput = new InputStreamIndexInput(indexInput, partBytes)__                    InputStream inputStream = inputStreamIndexInput__                    if (snapshotRateLimiter != null) {_                        inputStream = new RateLimitingInputStream(inputStreamIndexInput, snapshotRateLimiter,_                                                                  snapshotRateLimitingTimeInNanos::inc)__                    }_                    inputStream = new AbortableInputStream(inputStream, fileInfo.physicalName())__                    blobContainer.writeBlob(fileInfo.partName(i), inputStream, partBytes)__                }_                Store.verify(indexInput)__                snapshotStatus.addProcessedFile(fileInfo.length())__            } catch (Exception t) {_                failStoreIfCorrupted(t)__                snapshotStatus.addProcessedFile(0)__                throw t__            }_        };snapshot,individual,file,param,file,info,file,to,be,snapshotted;private,void,snapshot,file,final,blob,store,index,shard,snapshot,file,info,file,info,throws,ioexception,final,string,file,file,info,physical,name,try,index,input,index,input,store,open,verifying,input,file,iocontext,readonce,file,info,metadata,for,int,i,0,i,file,info,number,of,parts,i,final,long,part,bytes,file,info,part,bytes,i,final,input,stream,index,input,input,stream,index,input,new,input,stream,index,input,index,input,part,bytes,input,stream,input,stream,input,stream,index,input,if,snapshot,rate,limiter,null,input,stream,new,rate,limiting,input,stream,input,stream,index,input,snapshot,rate,limiter,snapshot,rate,limiting,time,in,nanos,inc,input,stream,new,abortable,input,stream,input,stream,file,info,physical,name,blob,container,write,blob,file,info,part,name,i,input,stream,part,bytes,store,verify,index,input,snapshot,status,add,processed,file,file,info,length,catch,exception,t,fail,store,if,corrupted,t,snapshot,status,add,processed,file,0,throw,t
BlobStoreRepository -> SnapshotContext -> private void snapshotFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo) throws IOException;1528211342;Snapshot individual file__@param fileInfo file to be snapshotted;private void snapshotFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo) throws IOException {_            final String file = fileInfo.physicalName()__            try (IndexInput indexInput = store.openVerifyingInput(file, IOContext.READONCE, fileInfo.metadata())) {_                for (int i = 0_ i < fileInfo.numberOfParts()_ i++) {_                    final long partBytes = fileInfo.partBytes(i)___                    final InputStreamIndexInput inputStreamIndexInput = new InputStreamIndexInput(indexInput, partBytes)__                    InputStream inputStream = inputStreamIndexInput__                    if (snapshotRateLimiter != null) {_                        inputStream = new RateLimitingInputStream(inputStreamIndexInput, snapshotRateLimiter,_                                                                  snapshotRateLimitingTimeInNanos::inc)__                    }_                    inputStream = new AbortableInputStream(inputStream, fileInfo.physicalName())__                    blobContainer.writeBlob(fileInfo.partName(i), inputStream, partBytes)__                }_                Store.verify(indexInput)__                snapshotStatus.addProcessedFile(fileInfo.length())__            } catch (Exception t) {_                failStoreIfCorrupted(t)__                snapshotStatus.addProcessedFile(0)__                throw t__            }_        };snapshot,individual,file,param,file,info,file,to,be,snapshotted;private,void,snapshot,file,final,blob,store,index,shard,snapshot,file,info,file,info,throws,ioexception,final,string,file,file,info,physical,name,try,index,input,index,input,store,open,verifying,input,file,iocontext,readonce,file,info,metadata,for,int,i,0,i,file,info,number,of,parts,i,final,long,part,bytes,file,info,part,bytes,i,final,input,stream,index,input,input,stream,index,input,new,input,stream,index,input,index,input,part,bytes,input,stream,input,stream,input,stream,index,input,if,snapshot,rate,limiter,null,input,stream,new,rate,limiting,input,stream,input,stream,index,input,snapshot,rate,limiter,snapshot,rate,limiting,time,in,nanos,inc,input,stream,new,abortable,input,stream,input,stream,file,info,physical,name,blob,container,write,blob,file,info,part,name,i,input,stream,part,bytes,store,verify,index,input,snapshot,status,add,processed,file,file,info,length,catch,exception,t,fail,store,if,corrupted,t,snapshot,status,add,processed,file,0,throw,t
BlobStoreRepository -> SnapshotContext -> private void snapshotFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo) throws IOException;1531179852;Snapshot individual file__@param fileInfo file to be snapshotted;private void snapshotFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo) throws IOException {_            final String file = fileInfo.physicalName()__            try (IndexInput indexInput = store.openVerifyingInput(file, IOContext.READONCE, fileInfo.metadata())) {_                for (int i = 0_ i < fileInfo.numberOfParts()_ i++) {_                    final long partBytes = fileInfo.partBytes(i)___                    final InputStreamIndexInput inputStreamIndexInput = new InputStreamIndexInput(indexInput, partBytes)__                    InputStream inputStream = inputStreamIndexInput__                    if (snapshotRateLimiter != null) {_                        inputStream = new RateLimitingInputStream(inputStreamIndexInput, snapshotRateLimiter,_                                                                  snapshotRateLimitingTimeInNanos::inc)__                    }_                    inputStream = new AbortableInputStream(inputStream, fileInfo.physicalName())__                    blobContainer.writeBlob(fileInfo.partName(i), inputStream, partBytes, true)__                }_                Store.verify(indexInput)__                snapshotStatus.addProcessedFile(fileInfo.length())__            } catch (Exception t) {_                failStoreIfCorrupted(t)__                snapshotStatus.addProcessedFile(0)__                throw t__            }_        };snapshot,individual,file,param,file,info,file,to,be,snapshotted;private,void,snapshot,file,final,blob,store,index,shard,snapshot,file,info,file,info,throws,ioexception,final,string,file,file,info,physical,name,try,index,input,index,input,store,open,verifying,input,file,iocontext,readonce,file,info,metadata,for,int,i,0,i,file,info,number,of,parts,i,final,long,part,bytes,file,info,part,bytes,i,final,input,stream,index,input,input,stream,index,input,new,input,stream,index,input,index,input,part,bytes,input,stream,input,stream,input,stream,index,input,if,snapshot,rate,limiter,null,input,stream,new,rate,limiting,input,stream,input,stream,index,input,snapshot,rate,limiter,snapshot,rate,limiting,time,in,nanos,inc,input,stream,new,abortable,input,stream,input,stream,file,info,physical,name,blob,container,write,blob,file,info,part,name,i,input,stream,part,bytes,true,store,verify,index,input,snapshot,status,add,processed,file,file,info,length,catch,exception,t,fail,store,if,corrupted,t,snapshot,status,add,processed,file,0,throw,t
BlobStoreRepository -> SnapshotContext -> private void snapshotFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo) throws IOException;1531729807;Snapshot individual file__@param fileInfo file to be snapshotted;private void snapshotFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo) throws IOException {_            final String file = fileInfo.physicalName()__            try (IndexInput indexInput = store.openVerifyingInput(file, IOContext.READONCE, fileInfo.metadata())) {_                for (int i = 0_ i < fileInfo.numberOfParts()_ i++) {_                    final long partBytes = fileInfo.partBytes(i)___                    final InputStreamIndexInput inputStreamIndexInput = new InputStreamIndexInput(indexInput, partBytes)__                    InputStream inputStream = inputStreamIndexInput__                    if (snapshotRateLimiter != null) {_                        inputStream = new RateLimitingInputStream(inputStreamIndexInput, snapshotRateLimiter,_                                                                  snapshotRateLimitingTimeInNanos::inc)__                    }_                    inputStream = new AbortableInputStream(inputStream, fileInfo.physicalName())__                    blobContainer.writeBlob(fileInfo.partName(i), inputStream, partBytes, true)__                }_                Store.verify(indexInput)__                snapshotStatus.addProcessedFile(fileInfo.length())__            } catch (Exception t) {_                failStoreIfCorrupted(t)__                snapshotStatus.addProcessedFile(0)__                throw t__            }_        };snapshot,individual,file,param,file,info,file,to,be,snapshotted;private,void,snapshot,file,final,blob,store,index,shard,snapshot,file,info,file,info,throws,ioexception,final,string,file,file,info,physical,name,try,index,input,index,input,store,open,verifying,input,file,iocontext,readonce,file,info,metadata,for,int,i,0,i,file,info,number,of,parts,i,final,long,part,bytes,file,info,part,bytes,i,final,input,stream,index,input,input,stream,index,input,new,input,stream,index,input,index,input,part,bytes,input,stream,input,stream,input,stream,index,input,if,snapshot,rate,limiter,null,input,stream,new,rate,limiting,input,stream,input,stream,index,input,snapshot,rate,limiter,snapshot,rate,limiting,time,in,nanos,inc,input,stream,new,abortable,input,stream,input,stream,file,info,physical,name,blob,container,write,blob,file,info,part,name,i,input,stream,part,bytes,true,store,verify,index,input,snapshot,status,add,processed,file,file,info,length,catch,exception,t,fail,store,if,corrupted,t,snapshot,status,add,processed,file,0,throw,t
BlobStoreRepository -> SnapshotContext -> private void snapshotFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo) throws IOException;1532685069;Snapshot individual file__@param fileInfo file to be snapshotted;private void snapshotFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo) throws IOException {_            final String file = fileInfo.physicalName()__            try (IndexInput indexInput = store.openVerifyingInput(file, IOContext.READONCE, fileInfo.metadata())) {_                for (int i = 0_ i < fileInfo.numberOfParts()_ i++) {_                    final long partBytes = fileInfo.partBytes(i)___                    final InputStreamIndexInput inputStreamIndexInput = new InputStreamIndexInput(indexInput, partBytes)__                    InputStream inputStream = inputStreamIndexInput__                    if (snapshotRateLimiter != null) {_                        inputStream = new RateLimitingInputStream(inputStreamIndexInput, snapshotRateLimiter,_                                                                  snapshotRateLimitingTimeInNanos::inc)__                    }_                    inputStream = new AbortableInputStream(inputStream, fileInfo.physicalName())__                    blobContainer.writeBlob(fileInfo.partName(i), inputStream, partBytes, true)__                }_                Store.verify(indexInput)__                snapshotStatus.addProcessedFile(fileInfo.length())__            } catch (Exception t) {_                failStoreIfCorrupted(t)__                snapshotStatus.addProcessedFile(0)__                throw t__            }_        };snapshot,individual,file,param,file,info,file,to,be,snapshotted;private,void,snapshot,file,final,blob,store,index,shard,snapshot,file,info,file,info,throws,ioexception,final,string,file,file,info,physical,name,try,index,input,index,input,store,open,verifying,input,file,iocontext,readonce,file,info,metadata,for,int,i,0,i,file,info,number,of,parts,i,final,long,part,bytes,file,info,part,bytes,i,final,input,stream,index,input,input,stream,index,input,new,input,stream,index,input,index,input,part,bytes,input,stream,input,stream,input,stream,index,input,if,snapshot,rate,limiter,null,input,stream,new,rate,limiting,input,stream,input,stream,index,input,snapshot,rate,limiter,snapshot,rate,limiting,time,in,nanos,inc,input,stream,new,abortable,input,stream,input,stream,file,info,physical,name,blob,container,write,blob,file,info,part,name,i,input,stream,part,bytes,true,store,verify,index,input,snapshot,status,add,processed,file,file,info,length,catch,exception,t,fail,store,if,corrupted,t,snapshot,status,add,processed,file,0,throw,t
BlobStoreRepository -> SnapshotContext -> private void snapshotFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo) throws IOException;1535139672;Snapshot individual file__@param fileInfo file to be snapshotted;private void snapshotFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo) throws IOException {_            final String file = fileInfo.physicalName()__            try (IndexInput indexInput = store.openVerifyingInput(file, IOContext.READONCE, fileInfo.metadata())) {_                for (int i = 0_ i < fileInfo.numberOfParts()_ i++) {_                    final long partBytes = fileInfo.partBytes(i)___                    final InputStreamIndexInput inputStreamIndexInput = new InputStreamIndexInput(indexInput, partBytes)__                    InputStream inputStream = inputStreamIndexInput__                    if (snapshotRateLimiter != null) {_                        inputStream = new RateLimitingInputStream(inputStreamIndexInput, snapshotRateLimiter,_                                                                  snapshotRateLimitingTimeInNanos::inc)__                    }_                    inputStream = new AbortableInputStream(inputStream, fileInfo.physicalName())__                    blobContainer.writeBlob(fileInfo.partName(i), inputStream, partBytes, true)__                }_                Store.verify(indexInput)__                snapshotStatus.addProcessedFile(fileInfo.length())__            } catch (Exception t) {_                failStoreIfCorrupted(t)__                snapshotStatus.addProcessedFile(0)__                throw t__            }_        };snapshot,individual,file,param,file,info,file,to,be,snapshotted;private,void,snapshot,file,final,blob,store,index,shard,snapshot,file,info,file,info,throws,ioexception,final,string,file,file,info,physical,name,try,index,input,index,input,store,open,verifying,input,file,iocontext,readonce,file,info,metadata,for,int,i,0,i,file,info,number,of,parts,i,final,long,part,bytes,file,info,part,bytes,i,final,input,stream,index,input,input,stream,index,input,new,input,stream,index,input,index,input,part,bytes,input,stream,input,stream,input,stream,index,input,if,snapshot,rate,limiter,null,input,stream,new,rate,limiting,input,stream,input,stream,index,input,snapshot,rate,limiter,snapshot,rate,limiting,time,in,nanos,inc,input,stream,new,abortable,input,stream,input,stream,file,info,physical,name,blob,container,write,blob,file,info,part,name,i,input,stream,part,bytes,true,store,verify,index,input,snapshot,status,add,processed,file,file,info,length,catch,exception,t,fail,store,if,corrupted,t,snapshot,status,add,processed,file,0,throw,t
BlobStoreRepository -> SnapshotContext -> private void snapshotFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo) throws IOException;1535723122;Snapshot individual file__@param fileInfo file to be snapshotted;private void snapshotFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo) throws IOException {_            final String file = fileInfo.physicalName()__            try (IndexInput indexInput = store.openVerifyingInput(file, IOContext.READONCE, fileInfo.metadata())) {_                for (int i = 0_ i < fileInfo.numberOfParts()_ i++) {_                    final long partBytes = fileInfo.partBytes(i)___                    final InputStreamIndexInput inputStreamIndexInput = new InputStreamIndexInput(indexInput, partBytes)__                    InputStream inputStream = inputStreamIndexInput__                    if (snapshotRateLimiter != null) {_                        inputStream = new RateLimitingInputStream(inputStreamIndexInput, snapshotRateLimiter,_                                                                  snapshotRateLimitingTimeInNanos::inc)__                    }_                    inputStream = new AbortableInputStream(inputStream, fileInfo.physicalName())__                    blobContainer.writeBlob(fileInfo.partName(i), inputStream, partBytes, true)__                }_                Store.verify(indexInput)__                snapshotStatus.addProcessedFile(fileInfo.length())__            } catch (Exception t) {_                failStoreIfCorrupted(t)__                snapshotStatus.addProcessedFile(0)__                throw t__            }_        };snapshot,individual,file,param,file,info,file,to,be,snapshotted;private,void,snapshot,file,final,blob,store,index,shard,snapshot,file,info,file,info,throws,ioexception,final,string,file,file,info,physical,name,try,index,input,index,input,store,open,verifying,input,file,iocontext,readonce,file,info,metadata,for,int,i,0,i,file,info,number,of,parts,i,final,long,part,bytes,file,info,part,bytes,i,final,input,stream,index,input,input,stream,index,input,new,input,stream,index,input,index,input,part,bytes,input,stream,input,stream,input,stream,index,input,if,snapshot,rate,limiter,null,input,stream,new,rate,limiting,input,stream,input,stream,index,input,snapshot,rate,limiter,snapshot,rate,limiting,time,in,nanos,inc,input,stream,new,abortable,input,stream,input,stream,file,info,physical,name,blob,container,write,blob,file,info,part,name,i,input,stream,part,bytes,true,store,verify,index,input,snapshot,status,add,processed,file,file,info,length,catch,exception,t,fail,store,if,corrupted,t,snapshot,status,add,processed,file,0,throw,t
BlobStoreRepository -> SnapshotContext -> private void snapshotFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo) throws IOException;1536314350;Snapshot individual file__@param fileInfo file to be snapshotted;private void snapshotFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo) throws IOException {_            final String file = fileInfo.physicalName()__            try (IndexInput indexInput = store.openVerifyingInput(file, IOContext.READONCE, fileInfo.metadata())) {_                for (int i = 0_ i < fileInfo.numberOfParts()_ i++) {_                    final long partBytes = fileInfo.partBytes(i)___                    final InputStreamIndexInput inputStreamIndexInput = new InputStreamIndexInput(indexInput, partBytes)__                    InputStream inputStream = inputStreamIndexInput__                    if (snapshotRateLimiter != null) {_                        inputStream = new RateLimitingInputStream(inputStreamIndexInput, snapshotRateLimiter,_                                                                  snapshotRateLimitingTimeInNanos::inc)__                    }_                    inputStream = new AbortableInputStream(inputStream, fileInfo.physicalName())__                    blobContainer.writeBlob(fileInfo.partName(i), inputStream, partBytes, true)__                }_                Store.verify(indexInput)__                snapshotStatus.addProcessedFile(fileInfo.length())__            } catch (Exception t) {_                failStoreIfCorrupted(t)__                snapshotStatus.addProcessedFile(0)__                throw t__            }_        };snapshot,individual,file,param,file,info,file,to,be,snapshotted;private,void,snapshot,file,final,blob,store,index,shard,snapshot,file,info,file,info,throws,ioexception,final,string,file,file,info,physical,name,try,index,input,index,input,store,open,verifying,input,file,iocontext,readonce,file,info,metadata,for,int,i,0,i,file,info,number,of,parts,i,final,long,part,bytes,file,info,part,bytes,i,final,input,stream,index,input,input,stream,index,input,new,input,stream,index,input,index,input,part,bytes,input,stream,input,stream,input,stream,index,input,if,snapshot,rate,limiter,null,input,stream,new,rate,limiting,input,stream,input,stream,index,input,snapshot,rate,limiter,snapshot,rate,limiting,time,in,nanos,inc,input,stream,new,abortable,input,stream,input,stream,file,info,physical,name,blob,container,write,blob,file,info,part,name,i,input,stream,part,bytes,true,store,verify,index,input,snapshot,status,add,processed,file,file,info,length,catch,exception,t,fail,store,if,corrupted,t,snapshot,status,add,processed,file,0,throw,t
BlobStoreRepository -> SnapshotContext -> private void snapshotFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo) throws IOException;1536828374;Snapshot individual file__@param fileInfo file to be snapshotted;private void snapshotFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo) throws IOException {_            final String file = fileInfo.physicalName()__            try (IndexInput indexInput = store.openVerifyingInput(file, IOContext.READONCE, fileInfo.metadata())) {_                for (int i = 0_ i < fileInfo.numberOfParts()_ i++) {_                    final long partBytes = fileInfo.partBytes(i)___                    final InputStreamIndexInput inputStreamIndexInput = new InputStreamIndexInput(indexInput, partBytes)__                    InputStream inputStream = inputStreamIndexInput__                    if (snapshotRateLimiter != null) {_                        inputStream = new RateLimitingInputStream(inputStreamIndexInput, snapshotRateLimiter,_                                                                  snapshotRateLimitingTimeInNanos::inc)__                    }_                    inputStream = new AbortableInputStream(inputStream, fileInfo.physicalName())__                    blobContainer.writeBlob(fileInfo.partName(i), inputStream, partBytes, true)__                }_                Store.verify(indexInput)__                snapshotStatus.addProcessedFile(fileInfo.length())__            } catch (Exception t) {_                failStoreIfCorrupted(t)__                snapshotStatus.addProcessedFile(0)__                throw t__            }_        };snapshot,individual,file,param,file,info,file,to,be,snapshotted;private,void,snapshot,file,final,blob,store,index,shard,snapshot,file,info,file,info,throws,ioexception,final,string,file,file,info,physical,name,try,index,input,index,input,store,open,verifying,input,file,iocontext,readonce,file,info,metadata,for,int,i,0,i,file,info,number,of,parts,i,final,long,part,bytes,file,info,part,bytes,i,final,input,stream,index,input,input,stream,index,input,new,input,stream,index,input,index,input,part,bytes,input,stream,input,stream,input,stream,index,input,if,snapshot,rate,limiter,null,input,stream,new,rate,limiting,input,stream,input,stream,index,input,snapshot,rate,limiter,snapshot,rate,limiting,time,in,nanos,inc,input,stream,new,abortable,input,stream,input,stream,file,info,physical,name,blob,container,write,blob,file,info,part,name,i,input,stream,part,bytes,true,store,verify,index,input,snapshot,status,add,processed,file,file,info,length,catch,exception,t,fail,store,if,corrupted,t,snapshot,status,add,processed,file,0,throw,t
BlobStoreRepository -> SnapshotContext -> private void snapshotFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo) throws IOException;1541008027;Snapshot individual file__@param fileInfo file to be snapshotted;private void snapshotFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo) throws IOException {_            final String file = fileInfo.physicalName()__            try (IndexInput indexInput = store.openVerifyingInput(file, IOContext.READONCE, fileInfo.metadata())) {_                for (int i = 0_ i < fileInfo.numberOfParts()_ i++) {_                    final long partBytes = fileInfo.partBytes(i)___                    final InputStreamIndexInput inputStreamIndexInput = new InputStreamIndexInput(indexInput, partBytes)__                    InputStream inputStream = inputStreamIndexInput__                    if (snapshotRateLimiter != null) {_                        inputStream = new RateLimitingInputStream(inputStreamIndexInput, snapshotRateLimiter,_                                                                  snapshotRateLimitingTimeInNanos::inc)__                    }_                    inputStream = new AbortableInputStream(inputStream, fileInfo.physicalName())__                    blobContainer.writeBlob(fileInfo.partName(i), inputStream, partBytes, true)__                }_                Store.verify(indexInput)__                snapshotStatus.addProcessedFile(fileInfo.length())__            } catch (Exception t) {_                failStoreIfCorrupted(t)__                snapshotStatus.addProcessedFile(0)__                throw t__            }_        };snapshot,individual,file,param,file,info,file,to,be,snapshotted;private,void,snapshot,file,final,blob,store,index,shard,snapshot,file,info,file,info,throws,ioexception,final,string,file,file,info,physical,name,try,index,input,index,input,store,open,verifying,input,file,iocontext,readonce,file,info,metadata,for,int,i,0,i,file,info,number,of,parts,i,final,long,part,bytes,file,info,part,bytes,i,final,input,stream,index,input,input,stream,index,input,new,input,stream,index,input,index,input,part,bytes,input,stream,input,stream,input,stream,index,input,if,snapshot,rate,limiter,null,input,stream,new,rate,limiting,input,stream,input,stream,index,input,snapshot,rate,limiter,snapshot,rate,limiting,time,in,nanos,inc,input,stream,new,abortable,input,stream,input,stream,file,info,physical,name,blob,container,write,blob,file,info,part,name,i,input,stream,part,bytes,true,store,verify,index,input,snapshot,status,add,processed,file,file,info,length,catch,exception,t,fail,store,if,corrupted,t,snapshot,status,add,processed,file,0,throw,t
BlobStoreRepository -> SnapshotContext -> private void snapshotFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo) throws IOException;1542646292;Snapshot individual file__@param fileInfo file to be snapshotted;private void snapshotFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo) throws IOException {_            final String file = fileInfo.physicalName()__            try (IndexInput indexInput = store.openVerifyingInput(file, IOContext.READONCE, fileInfo.metadata())) {_                for (int i = 0_ i < fileInfo.numberOfParts()_ i++) {_                    final long partBytes = fileInfo.partBytes(i)___                    final InputStreamIndexInput inputStreamIndexInput = new InputStreamIndexInput(indexInput, partBytes)__                    InputStream inputStream = inputStreamIndexInput__                    if (snapshotRateLimiter != null) {_                        inputStream = new RateLimitingInputStream(inputStreamIndexInput, snapshotRateLimiter,_                                                                  snapshotRateLimitingTimeInNanos::inc)__                    }_                    inputStream = new AbortableInputStream(inputStream, fileInfo.physicalName())__                    blobContainer.writeBlob(fileInfo.partName(i), inputStream, partBytes, true)__                }_                Store.verify(indexInput)__                snapshotStatus.addProcessedFile(fileInfo.length())__            } catch (Exception t) {_                failStoreIfCorrupted(t)__                snapshotStatus.addProcessedFile(0)__                throw t__            }_        };snapshot,individual,file,param,file,info,file,to,be,snapshotted;private,void,snapshot,file,final,blob,store,index,shard,snapshot,file,info,file,info,throws,ioexception,final,string,file,file,info,physical,name,try,index,input,index,input,store,open,verifying,input,file,iocontext,readonce,file,info,metadata,for,int,i,0,i,file,info,number,of,parts,i,final,long,part,bytes,file,info,part,bytes,i,final,input,stream,index,input,input,stream,index,input,new,input,stream,index,input,index,input,part,bytes,input,stream,input,stream,input,stream,index,input,if,snapshot,rate,limiter,null,input,stream,new,rate,limiting,input,stream,input,stream,index,input,snapshot,rate,limiter,snapshot,rate,limiting,time,in,nanos,inc,input,stream,new,abortable,input,stream,input,stream,file,info,physical,name,blob,container,write,blob,file,info,part,name,i,input,stream,part,bytes,true,store,verify,index,input,snapshot,status,add,processed,file,file,info,length,catch,exception,t,fail,store,if,corrupted,t,snapshot,status,add,processed,file,0,throw,t
BlobStoreRepository -> SnapshotContext -> private void snapshotFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo) throws IOException;1542980705;Snapshot individual file__@param fileInfo file to be snapshotted;private void snapshotFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo) throws IOException {_            final String file = fileInfo.physicalName()__            try (IndexInput indexInput = store.openVerifyingInput(file, IOContext.READONCE, fileInfo.metadata())) {_                for (int i = 0_ i < fileInfo.numberOfParts()_ i++) {_                    final long partBytes = fileInfo.partBytes(i)___                    final InputStreamIndexInput inputStreamIndexInput = new InputStreamIndexInput(indexInput, partBytes)__                    InputStream inputStream = inputStreamIndexInput__                    if (snapshotRateLimiter != null) {_                        inputStream = new RateLimitingInputStream(inputStreamIndexInput, snapshotRateLimiter,_                                                                  snapshotRateLimitingTimeInNanos::inc)__                    }_                    inputStream = new AbortableInputStream(inputStream, fileInfo.physicalName())__                    blobContainer.writeBlob(fileInfo.partName(i), inputStream, partBytes, true)__                }_                Store.verify(indexInput)__                snapshotStatus.addProcessedFile(fileInfo.length())__            } catch (Exception t) {_                failStoreIfCorrupted(t)__                snapshotStatus.addProcessedFile(0)__                throw t__            }_        };snapshot,individual,file,param,file,info,file,to,be,snapshotted;private,void,snapshot,file,final,blob,store,index,shard,snapshot,file,info,file,info,throws,ioexception,final,string,file,file,info,physical,name,try,index,input,index,input,store,open,verifying,input,file,iocontext,readonce,file,info,metadata,for,int,i,0,i,file,info,number,of,parts,i,final,long,part,bytes,file,info,part,bytes,i,final,input,stream,index,input,input,stream,index,input,new,input,stream,index,input,index,input,part,bytes,input,stream,input,stream,input,stream,index,input,if,snapshot,rate,limiter,null,input,stream,new,rate,limiting,input,stream,input,stream,index,input,snapshot,rate,limiter,snapshot,rate,limiting,time,in,nanos,inc,input,stream,new,abortable,input,stream,input,stream,file,info,physical,name,blob,container,write,blob,file,info,part,name,i,input,stream,part,bytes,true,store,verify,index,input,snapshot,status,add,processed,file,file,info,length,catch,exception,t,fail,store,if,corrupted,t,snapshot,status,add,processed,file,0,throw,t
BlobStoreRepository -> SnapshotContext -> private void snapshotFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo) throws IOException;1543831870;Snapshot individual file__@param fileInfo file to be snapshotted;private void snapshotFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo) throws IOException {_            final String file = fileInfo.physicalName()__            try (IndexInput indexInput = store.openVerifyingInput(file, IOContext.READONCE, fileInfo.metadata())) {_                for (int i = 0_ i < fileInfo.numberOfParts()_ i++) {_                    final long partBytes = fileInfo.partBytes(i)___                    final InputStreamIndexInput inputStreamIndexInput = new InputStreamIndexInput(indexInput, partBytes)__                    InputStream inputStream = inputStreamIndexInput__                    if (snapshotRateLimiter != null) {_                        inputStream = new RateLimitingInputStream(inputStreamIndexInput, snapshotRateLimiter,_                                                                  snapshotRateLimitingTimeInNanos::inc)__                    }_                    inputStream = new AbortableInputStream(inputStream, fileInfo.physicalName())__                    blobContainer.writeBlob(fileInfo.partName(i), inputStream, partBytes, true)__                }_                Store.verify(indexInput)__                snapshotStatus.addProcessedFile(fileInfo.length())__            } catch (Exception t) {_                failStoreIfCorrupted(t)__                snapshotStatus.addProcessedFile(0)__                throw t__            }_        };snapshot,individual,file,param,file,info,file,to,be,snapshotted;private,void,snapshot,file,final,blob,store,index,shard,snapshot,file,info,file,info,throws,ioexception,final,string,file,file,info,physical,name,try,index,input,index,input,store,open,verifying,input,file,iocontext,readonce,file,info,metadata,for,int,i,0,i,file,info,number,of,parts,i,final,long,part,bytes,file,info,part,bytes,i,final,input,stream,index,input,input,stream,index,input,new,input,stream,index,input,index,input,part,bytes,input,stream,input,stream,input,stream,index,input,if,snapshot,rate,limiter,null,input,stream,new,rate,limiting,input,stream,input,stream,index,input,snapshot,rate,limiter,snapshot,rate,limiting,time,in,nanos,inc,input,stream,new,abortable,input,stream,input,stream,file,info,physical,name,blob,container,write,blob,file,info,part,name,i,input,stream,part,bytes,true,store,verify,index,input,snapshot,status,add,processed,file,file,info,length,catch,exception,t,fail,store,if,corrupted,t,snapshot,status,add,processed,file,0,throw,t
BlobStoreRepository -> SnapshotContext -> private void snapshotFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo) throws IOException;1543942400;Snapshot individual file__@param fileInfo file to be snapshotted;private void snapshotFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo) throws IOException {_            final String file = fileInfo.physicalName()__            try (IndexInput indexInput = store.openVerifyingInput(file, IOContext.READONCE, fileInfo.metadata())) {_                for (int i = 0_ i < fileInfo.numberOfParts()_ i++) {_                    final long partBytes = fileInfo.partBytes(i)___                    final InputStreamIndexInput inputStreamIndexInput = new InputStreamIndexInput(indexInput, partBytes)__                    InputStream inputStream = inputStreamIndexInput__                    if (snapshotRateLimiter != null) {_                        inputStream = new RateLimitingInputStream(inputStreamIndexInput, snapshotRateLimiter,_                                                                  snapshotRateLimitingTimeInNanos::inc)__                    }_                    inputStream = new AbortableInputStream(inputStream, fileInfo.physicalName())__                    blobContainer.writeBlob(fileInfo.partName(i), inputStream, partBytes, true)__                }_                Store.verify(indexInput)__                snapshotStatus.addProcessedFile(fileInfo.length())__            } catch (Exception t) {_                failStoreIfCorrupted(t)__                snapshotStatus.addProcessedFile(0)__                throw t__            }_        };snapshot,individual,file,param,file,info,file,to,be,snapshotted;private,void,snapshot,file,final,blob,store,index,shard,snapshot,file,info,file,info,throws,ioexception,final,string,file,file,info,physical,name,try,index,input,index,input,store,open,verifying,input,file,iocontext,readonce,file,info,metadata,for,int,i,0,i,file,info,number,of,parts,i,final,long,part,bytes,file,info,part,bytes,i,final,input,stream,index,input,input,stream,index,input,new,input,stream,index,input,index,input,part,bytes,input,stream,input,stream,input,stream,index,input,if,snapshot,rate,limiter,null,input,stream,new,rate,limiting,input,stream,input,stream,index,input,snapshot,rate,limiter,snapshot,rate,limiting,time,in,nanos,inc,input,stream,new,abortable,input,stream,input,stream,file,info,physical,name,blob,container,write,blob,file,info,part,name,i,input,stream,part,bytes,true,store,verify,index,input,snapshot,status,add,processed,file,file,info,length,catch,exception,t,fail,store,if,corrupted,t,snapshot,status,add,processed,file,0,throw,t
BlobStoreRepository -> SnapshotContext -> private void snapshotFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo) throws IOException;1546974294;Snapshot individual file__@param fileInfo file to be snapshotted;private void snapshotFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo) throws IOException {_            final String file = fileInfo.physicalName()__            try (IndexInput indexInput = store.openVerifyingInput(file, IOContext.READONCE, fileInfo.metadata())) {_                for (int i = 0_ i < fileInfo.numberOfParts()_ i++) {_                    final long partBytes = fileInfo.partBytes(i)___                    final InputStreamIndexInput inputStreamIndexInput = new InputStreamIndexInput(indexInput, partBytes)__                    InputStream inputStream = inputStreamIndexInput__                    if (snapshotRateLimiter != null) {_                        inputStream = new RateLimitingInputStream(inputStreamIndexInput, snapshotRateLimiter,_                                                                  snapshotRateLimitingTimeInNanos::inc)__                    }_                    inputStream = new AbortableInputStream(inputStream, fileInfo.physicalName())__                    blobContainer.writeBlob(fileInfo.partName(i), inputStream, partBytes, true)__                }_                Store.verify(indexInput)__                snapshotStatus.addProcessedFile(fileInfo.length())__            } catch (Exception t) {_                failStoreIfCorrupted(t)__                snapshotStatus.addProcessedFile(0)__                throw t__            }_        };snapshot,individual,file,param,file,info,file,to,be,snapshotted;private,void,snapshot,file,final,blob,store,index,shard,snapshot,file,info,file,info,throws,ioexception,final,string,file,file,info,physical,name,try,index,input,index,input,store,open,verifying,input,file,iocontext,readonce,file,info,metadata,for,int,i,0,i,file,info,number,of,parts,i,final,long,part,bytes,file,info,part,bytes,i,final,input,stream,index,input,input,stream,index,input,new,input,stream,index,input,index,input,part,bytes,input,stream,input,stream,input,stream,index,input,if,snapshot,rate,limiter,null,input,stream,new,rate,limiting,input,stream,input,stream,index,input,snapshot,rate,limiter,snapshot,rate,limiting,time,in,nanos,inc,input,stream,new,abortable,input,stream,input,stream,file,info,physical,name,blob,container,write,blob,file,info,part,name,i,input,stream,part,bytes,true,store,verify,index,input,snapshot,status,add,processed,file,file,info,length,catch,exception,t,fail,store,if,corrupted,t,snapshot,status,add,processed,file,0,throw,t
BlobStoreRepository -> SnapshotContext -> private void snapshotFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo) throws IOException;1547496475;Snapshot individual file__@param fileInfo file to be snapshotted;private void snapshotFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo) throws IOException {_            final String file = fileInfo.physicalName()__            try (IndexInput indexInput = store.openVerifyingInput(file, IOContext.READONCE, fileInfo.metadata())) {_                for (int i = 0_ i < fileInfo.numberOfParts()_ i++) {_                    final long partBytes = fileInfo.partBytes(i)___                    final InputStreamIndexInput inputStreamIndexInput = new InputStreamIndexInput(indexInput, partBytes)__                    InputStream inputStream = inputStreamIndexInput__                    if (snapshotRateLimiter != null) {_                        inputStream = new RateLimitingInputStream(inputStreamIndexInput, snapshotRateLimiter,_                                                                  snapshotRateLimitingTimeInNanos::inc)__                    }_                    inputStream = new AbortableInputStream(inputStream, fileInfo.physicalName())__                    blobContainer.writeBlob(fileInfo.partName(i), inputStream, partBytes, true)__                }_                Store.verify(indexInput)__                snapshotStatus.addProcessedFile(fileInfo.length())__            } catch (Exception t) {_                failStoreIfCorrupted(t)__                snapshotStatus.addProcessedFile(0)__                throw t__            }_        };snapshot,individual,file,param,file,info,file,to,be,snapshotted;private,void,snapshot,file,final,blob,store,index,shard,snapshot,file,info,file,info,throws,ioexception,final,string,file,file,info,physical,name,try,index,input,index,input,store,open,verifying,input,file,iocontext,readonce,file,info,metadata,for,int,i,0,i,file,info,number,of,parts,i,final,long,part,bytes,file,info,part,bytes,i,final,input,stream,index,input,input,stream,index,input,new,input,stream,index,input,index,input,part,bytes,input,stream,input,stream,input,stream,index,input,if,snapshot,rate,limiter,null,input,stream,new,rate,limiting,input,stream,input,stream,index,input,snapshot,rate,limiter,snapshot,rate,limiting,time,in,nanos,inc,input,stream,new,abortable,input,stream,input,stream,file,info,physical,name,blob,container,write,blob,file,info,part,name,i,input,stream,part,bytes,true,store,verify,index,input,snapshot,status,add,processed,file,file,info,length,catch,exception,t,fail,store,if,corrupted,t,snapshot,status,add,processed,file,0,throw,t
BlobStoreRepository -> SnapshotContext -> private void snapshotFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo) throws IOException;1547625930;Snapshot individual file__@param fileInfo file to be snapshotted;private void snapshotFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo) throws IOException {_            final String file = fileInfo.physicalName()__            try (IndexInput indexInput = store.openVerifyingInput(file, IOContext.READONCE, fileInfo.metadata())) {_                for (int i = 0_ i < fileInfo.numberOfParts()_ i++) {_                    final long partBytes = fileInfo.partBytes(i)___                    final InputStreamIndexInput inputStreamIndexInput = new InputStreamIndexInput(indexInput, partBytes)__                    InputStream inputStream = inputStreamIndexInput__                    if (snapshotRateLimiter != null) {_                        inputStream = new RateLimitingInputStream(inputStreamIndexInput, snapshotRateLimiter,_                                                                  snapshotRateLimitingTimeInNanos::inc)__                    }_                    inputStream = new AbortableInputStream(inputStream, fileInfo.physicalName())__                    blobContainer.writeBlob(fileInfo.partName(i), inputStream, partBytes, true)__                }_                Store.verify(indexInput)__                snapshotStatus.addProcessedFile(fileInfo.length())__            } catch (Exception t) {_                failStoreIfCorrupted(t)__                snapshotStatus.addProcessedFile(0)__                throw t__            }_        };snapshot,individual,file,param,file,info,file,to,be,snapshotted;private,void,snapshot,file,final,blob,store,index,shard,snapshot,file,info,file,info,throws,ioexception,final,string,file,file,info,physical,name,try,index,input,index,input,store,open,verifying,input,file,iocontext,readonce,file,info,metadata,for,int,i,0,i,file,info,number,of,parts,i,final,long,part,bytes,file,info,part,bytes,i,final,input,stream,index,input,input,stream,index,input,new,input,stream,index,input,index,input,part,bytes,input,stream,input,stream,input,stream,index,input,if,snapshot,rate,limiter,null,input,stream,new,rate,limiting,input,stream,input,stream,index,input,snapshot,rate,limiter,snapshot,rate,limiting,time,in,nanos,inc,input,stream,new,abortable,input,stream,input,stream,file,info,physical,name,blob,container,write,blob,file,info,part,name,i,input,stream,part,bytes,true,store,verify,index,input,snapshot,status,add,processed,file,file,info,length,catch,exception,t,fail,store,if,corrupted,t,snapshot,status,add,processed,file,0,throw,t
BlobStoreRepository -> SnapshotContext -> private void snapshotFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo) throws IOException;1550647627;Snapshot individual file__@param fileInfo file to be snapshotted;private void snapshotFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo) throws IOException {_            final String file = fileInfo.physicalName()__            try (IndexInput indexInput = store.openVerifyingInput(file, IOContext.READONCE, fileInfo.metadata())) {_                for (int i = 0_ i < fileInfo.numberOfParts()_ i++) {_                    final long partBytes = fileInfo.partBytes(i)___                    final InputStreamIndexInput inputStreamIndexInput = new InputStreamIndexInput(indexInput, partBytes)__                    InputStream inputStream = inputStreamIndexInput__                    if (snapshotRateLimiter != null) {_                        inputStream = new RateLimitingInputStream(inputStreamIndexInput, snapshotRateLimiter,_                                                                  snapshotRateLimitingTimeInNanos::inc)__                    }_                    inputStream = new AbortableInputStream(inputStream, fileInfo.physicalName())__                    blobContainer.writeBlob(fileInfo.partName(i), inputStream, partBytes, true)__                }_                Store.verify(indexInput)__                snapshotStatus.addProcessedFile(fileInfo.length())__            } catch (Exception t) {_                failStoreIfCorrupted(t)__                snapshotStatus.addProcessedFile(0)__                throw t__            }_        };snapshot,individual,file,param,file,info,file,to,be,snapshotted;private,void,snapshot,file,final,blob,store,index,shard,snapshot,file,info,file,info,throws,ioexception,final,string,file,file,info,physical,name,try,index,input,index,input,store,open,verifying,input,file,iocontext,readonce,file,info,metadata,for,int,i,0,i,file,info,number,of,parts,i,final,long,part,bytes,file,info,part,bytes,i,final,input,stream,index,input,input,stream,index,input,new,input,stream,index,input,index,input,part,bytes,input,stream,input,stream,input,stream,index,input,if,snapshot,rate,limiter,null,input,stream,new,rate,limiting,input,stream,input,stream,index,input,snapshot,rate,limiter,snapshot,rate,limiting,time,in,nanos,inc,input,stream,new,abortable,input,stream,input,stream,file,info,physical,name,blob,container,write,blob,file,info,part,name,i,input,stream,part,bytes,true,store,verify,index,input,snapshot,status,add,processed,file,file,info,length,catch,exception,t,fail,store,if,corrupted,t,snapshot,status,add,processed,file,0,throw,t
BlobStoreRepository -> RestoreContext -> RestoreContext(IndexShard shard, SnapshotId snapshotId, IndexId indexId, ShardId snapshotShardId, RecoveryState recoveryState);1543831870;Constructs new restore context__@param shard           shard to restore into_@param snapshotId      snapshot id_@param indexId         id of the index being restored_@param snapshotShardId shard in the snapshot that data should be restored from_@param recoveryState   recovery state to report progress;RestoreContext(IndexShard shard, SnapshotId snapshotId, IndexId indexId, ShardId snapshotShardId, RecoveryState recoveryState) {_            super(snapshotId, indexId, shard.shardId(), snapshotShardId)__            this.recoveryState = recoveryState__            this.targetShard = shard__        };constructs,new,restore,context,param,shard,shard,to,restore,into,param,snapshot,id,snapshot,id,param,index,id,id,of,the,index,being,restored,param,snapshot,shard,id,shard,in,the,snapshot,that,data,should,be,restored,from,param,recovery,state,recovery,state,to,report,progress;restore,context,index,shard,shard,snapshot,id,snapshot,id,index,id,index,id,shard,id,snapshot,shard,id,recovery,state,recovery,state,super,snapshot,id,index,id,shard,shard,id,snapshot,shard,id,this,recovery,state,recovery,state,this,target,shard,shard
BlobStoreRepository -> RestoreContext -> RestoreContext(IndexShard shard, SnapshotId snapshotId, IndexId indexId, ShardId snapshotShardId, RecoveryState recoveryState);1543942400;Constructs new restore context__@param shard           shard to restore into_@param snapshotId      snapshot id_@param indexId         id of the index being restored_@param snapshotShardId shard in the snapshot that data should be restored from_@param recoveryState   recovery state to report progress;RestoreContext(IndexShard shard, SnapshotId snapshotId, IndexId indexId, ShardId snapshotShardId, RecoveryState recoveryState) {_            super(snapshotId, indexId, shard.shardId(), snapshotShardId)__            this.recoveryState = recoveryState__            this.targetShard = shard__        };constructs,new,restore,context,param,shard,shard,to,restore,into,param,snapshot,id,snapshot,id,param,index,id,id,of,the,index,being,restored,param,snapshot,shard,id,shard,in,the,snapshot,that,data,should,be,restored,from,param,recovery,state,recovery,state,to,report,progress;restore,context,index,shard,shard,snapshot,id,snapshot,id,index,id,index,id,shard,id,snapshot,shard,id,recovery,state,recovery,state,super,snapshot,id,index,id,shard,shard,id,snapshot,shard,id,this,recovery,state,recovery,state,this,target,shard,shard
BlobStoreRepository -> RestoreContext -> RestoreContext(IndexShard shard, SnapshotId snapshotId, IndexId indexId, ShardId snapshotShardId, RecoveryState recoveryState);1546974294;Constructs new restore context__@param shard           shard to restore into_@param snapshotId      snapshot id_@param indexId         id of the index being restored_@param snapshotShardId shard in the snapshot that data should be restored from_@param recoveryState   recovery state to report progress;RestoreContext(IndexShard shard, SnapshotId snapshotId, IndexId indexId, ShardId snapshotShardId, RecoveryState recoveryState) {_            super(snapshotId, indexId, shard.shardId(), snapshotShardId)__            this.recoveryState = recoveryState__            this.targetShard = shard__        };constructs,new,restore,context,param,shard,shard,to,restore,into,param,snapshot,id,snapshot,id,param,index,id,id,of,the,index,being,restored,param,snapshot,shard,id,shard,in,the,snapshot,that,data,should,be,restored,from,param,recovery,state,recovery,state,to,report,progress;restore,context,index,shard,shard,snapshot,id,snapshot,id,index,id,index,id,shard,id,snapshot,shard,id,recovery,state,recovery,state,super,snapshot,id,index,id,shard,shard,id,snapshot,shard,id,this,recovery,state,recovery,state,this,target,shard,shard
BlobStoreRepository -> RestoreContext -> private void restoreFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo, final Store store) throws IOException;1524684173;Restores a file_This is asynchronous method. Upon completion of the operation latch is getting counted down and any failures are_added to the {@code failures} list__@param fileInfo file to be restored;private void restoreFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo, final Store store) throws IOException {_            boolean success = false___            try (InputStream partSliceStream = new PartSliceStream(blobContainer, fileInfo)) {_                final InputStream stream__                if (restoreRateLimiter == null) {_                    stream = partSliceStream__                } else {_                    stream = new RateLimitingInputStream(partSliceStream, restoreRateLimiter, restoreRateLimitingTimeInNanos::inc)__                }__                try (IndexOutput indexOutput = store.createVerifyingOutput(fileInfo.physicalName(), fileInfo.metadata(), IOContext.DEFAULT)) {_                    final byte[] buffer = new byte[BUFFER_SIZE]__                    int length__                    while ((length = stream.read(buffer)) > 0) {_                        indexOutput.writeBytes(buffer, 0, length)__                        recoveryState.getIndex().addRecoveredBytesToFile(fileInfo.name(), length)__                    }_                    Store.verify(indexOutput)__                    indexOutput.close()__                    store.directory().sync(Collections.singleton(fileInfo.physicalName()))__                    success = true__                } catch (CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {_                    try {_                        store.markStoreCorrupted(ex)__                    } catch (IOException e) {_                        logger.warn("store cannot be marked as corrupted", e)__                    }_                    throw ex__                } finally {_                    if (success == false) {_                        store.deleteQuiet(fileInfo.physicalName())__                    }_                }_            }_        };restores,a,file,this,is,asynchronous,method,upon,completion,of,the,operation,latch,is,getting,counted,down,and,any,failures,are,added,to,the,code,failures,list,param,file,info,file,to,be,restored;private,void,restore,file,final,blob,store,index,shard,snapshot,file,info,file,info,final,store,store,throws,ioexception,boolean,success,false,try,input,stream,part,slice,stream,new,part,slice,stream,blob,container,file,info,final,input,stream,stream,if,restore,rate,limiter,null,stream,part,slice,stream,else,stream,new,rate,limiting,input,stream,part,slice,stream,restore,rate,limiter,restore,rate,limiting,time,in,nanos,inc,try,index,output,index,output,store,create,verifying,output,file,info,physical,name,file,info,metadata,iocontext,default,final,byte,buffer,new,byte,int,length,while,length,stream,read,buffer,0,index,output,write,bytes,buffer,0,length,recovery,state,get,index,add,recovered,bytes,to,file,file,info,name,length,store,verify,index,output,index,output,close,store,directory,sync,collections,singleton,file,info,physical,name,success,true,catch,corrupt,index,exception,index,format,too,old,exception,index,format,too,new,exception,ex,try,store,mark,store,corrupted,ex,catch,ioexception,e,logger,warn,store,cannot,be,marked,as,corrupted,e,throw,ex,finally,if,success,false,store,delete,quiet,file,info,physical,name
BlobStoreRepository -> RestoreContext -> private void restoreFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo, final Store store) throws IOException;1525334055;Restores a file_This is asynchronous method. Upon completion of the operation latch is getting counted down and any failures are_added to the {@code failures} list__@param fileInfo file to be restored;private void restoreFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo, final Store store) throws IOException {_            boolean success = false___            try (InputStream partSliceStream = new PartSliceStream(blobContainer, fileInfo)) {_                final InputStream stream__                if (restoreRateLimiter == null) {_                    stream = partSliceStream__                } else {_                    stream = new RateLimitingInputStream(partSliceStream, restoreRateLimiter, restoreRateLimitingTimeInNanos::inc)__                }__                try (IndexOutput indexOutput = store.createVerifyingOutput(fileInfo.physicalName(), fileInfo.metadata(), IOContext.DEFAULT)) {_                    final byte[] buffer = new byte[BUFFER_SIZE]__                    int length__                    while ((length = stream.read(buffer)) > 0) {_                        indexOutput.writeBytes(buffer, 0, length)__                        recoveryState.getIndex().addRecoveredBytesToFile(fileInfo.name(), length)__                    }_                    Store.verify(indexOutput)__                    indexOutput.close()__                    store.directory().sync(Collections.singleton(fileInfo.physicalName()))__                    success = true__                } catch (CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {_                    try {_                        store.markStoreCorrupted(ex)__                    } catch (IOException e) {_                        logger.warn("store cannot be marked as corrupted", e)__                    }_                    throw ex__                } finally {_                    if (success == false) {_                        store.deleteQuiet(fileInfo.physicalName())__                    }_                }_            }_        };restores,a,file,this,is,asynchronous,method,upon,completion,of,the,operation,latch,is,getting,counted,down,and,any,failures,are,added,to,the,code,failures,list,param,file,info,file,to,be,restored;private,void,restore,file,final,blob,store,index,shard,snapshot,file,info,file,info,final,store,store,throws,ioexception,boolean,success,false,try,input,stream,part,slice,stream,new,part,slice,stream,blob,container,file,info,final,input,stream,stream,if,restore,rate,limiter,null,stream,part,slice,stream,else,stream,new,rate,limiting,input,stream,part,slice,stream,restore,rate,limiter,restore,rate,limiting,time,in,nanos,inc,try,index,output,index,output,store,create,verifying,output,file,info,physical,name,file,info,metadata,iocontext,default,final,byte,buffer,new,byte,int,length,while,length,stream,read,buffer,0,index,output,write,bytes,buffer,0,length,recovery,state,get,index,add,recovered,bytes,to,file,file,info,name,length,store,verify,index,output,index,output,close,store,directory,sync,collections,singleton,file,info,physical,name,success,true,catch,corrupt,index,exception,index,format,too,old,exception,index,format,too,new,exception,ex,try,store,mark,store,corrupted,ex,catch,ioexception,e,logger,warn,store,cannot,be,marked,as,corrupted,e,throw,ex,finally,if,success,false,store,delete,quiet,file,info,physical,name
BlobStoreRepository -> RestoreContext -> private void restoreFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo, final Store store) throws IOException;1525798020;Restores a file_This is asynchronous method. Upon completion of the operation latch is getting counted down and any failures are_added to the {@code failures} list__@param fileInfo file to be restored;private void restoreFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo, final Store store) throws IOException {_            boolean success = false___            try (InputStream partSliceStream = new PartSliceStream(blobContainer, fileInfo)) {_                final InputStream stream__                if (restoreRateLimiter == null) {_                    stream = partSliceStream__                } else {_                    stream = new RateLimitingInputStream(partSliceStream, restoreRateLimiter, restoreRateLimitingTimeInNanos::inc)__                }__                try (IndexOutput indexOutput = store.createVerifyingOutput(fileInfo.physicalName(), fileInfo.metadata(), IOContext.DEFAULT)) {_                    final byte[] buffer = new byte[BUFFER_SIZE]__                    int length__                    while ((length = stream.read(buffer)) > 0) {_                        indexOutput.writeBytes(buffer, 0, length)__                        recoveryState.getIndex().addRecoveredBytesToFile(fileInfo.name(), length)__                    }_                    Store.verify(indexOutput)__                    indexOutput.close()__                    store.directory().sync(Collections.singleton(fileInfo.physicalName()))__                    success = true__                } catch (CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {_                    try {_                        store.markStoreCorrupted(ex)__                    } catch (IOException e) {_                        logger.warn("store cannot be marked as corrupted", e)__                    }_                    throw ex__                } finally {_                    if (success == false) {_                        store.deleteQuiet(fileInfo.physicalName())__                    }_                }_            }_        };restores,a,file,this,is,asynchronous,method,upon,completion,of,the,operation,latch,is,getting,counted,down,and,any,failures,are,added,to,the,code,failures,list,param,file,info,file,to,be,restored;private,void,restore,file,final,blob,store,index,shard,snapshot,file,info,file,info,final,store,store,throws,ioexception,boolean,success,false,try,input,stream,part,slice,stream,new,part,slice,stream,blob,container,file,info,final,input,stream,stream,if,restore,rate,limiter,null,stream,part,slice,stream,else,stream,new,rate,limiting,input,stream,part,slice,stream,restore,rate,limiter,restore,rate,limiting,time,in,nanos,inc,try,index,output,index,output,store,create,verifying,output,file,info,physical,name,file,info,metadata,iocontext,default,final,byte,buffer,new,byte,int,length,while,length,stream,read,buffer,0,index,output,write,bytes,buffer,0,length,recovery,state,get,index,add,recovered,bytes,to,file,file,info,name,length,store,verify,index,output,index,output,close,store,directory,sync,collections,singleton,file,info,physical,name,success,true,catch,corrupt,index,exception,index,format,too,old,exception,index,format,too,new,exception,ex,try,store,mark,store,corrupted,ex,catch,ioexception,e,logger,warn,store,cannot,be,marked,as,corrupted,e,throw,ex,finally,if,success,false,store,delete,quiet,file,info,physical,name
BlobStoreRepository -> RestoreContext -> private void restoreFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo, final Store store) throws IOException;1526289033;Restores a file_This is asynchronous method. Upon completion of the operation latch is getting counted down and any failures are_added to the {@code failures} list__@param fileInfo file to be restored;private void restoreFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo, final Store store) throws IOException {_            boolean success = false___            try (InputStream partSliceStream = new PartSliceStream(blobContainer, fileInfo)) {_                final InputStream stream__                if (restoreRateLimiter == null) {_                    stream = partSliceStream__                } else {_                    stream = new RateLimitingInputStream(partSliceStream, restoreRateLimiter, restoreRateLimitingTimeInNanos::inc)__                }__                try (IndexOutput indexOutput = store.createVerifyingOutput(fileInfo.physicalName(), fileInfo.metadata(), IOContext.DEFAULT)) {_                    final byte[] buffer = new byte[BUFFER_SIZE]__                    int length__                    while ((length = stream.read(buffer)) > 0) {_                        indexOutput.writeBytes(buffer, 0, length)__                        recoveryState.getIndex().addRecoveredBytesToFile(fileInfo.name(), length)__                    }_                    Store.verify(indexOutput)__                    indexOutput.close()__                    store.directory().sync(Collections.singleton(fileInfo.physicalName()))__                    success = true__                } catch (CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {_                    try {_                        store.markStoreCorrupted(ex)__                    } catch (IOException e) {_                        logger.warn("store cannot be marked as corrupted", e)__                    }_                    throw ex__                } finally {_                    if (success == false) {_                        store.deleteQuiet(fileInfo.physicalName())__                    }_                }_            }_        };restores,a,file,this,is,asynchronous,method,upon,completion,of,the,operation,latch,is,getting,counted,down,and,any,failures,are,added,to,the,code,failures,list,param,file,info,file,to,be,restored;private,void,restore,file,final,blob,store,index,shard,snapshot,file,info,file,info,final,store,store,throws,ioexception,boolean,success,false,try,input,stream,part,slice,stream,new,part,slice,stream,blob,container,file,info,final,input,stream,stream,if,restore,rate,limiter,null,stream,part,slice,stream,else,stream,new,rate,limiting,input,stream,part,slice,stream,restore,rate,limiter,restore,rate,limiting,time,in,nanos,inc,try,index,output,index,output,store,create,verifying,output,file,info,physical,name,file,info,metadata,iocontext,default,final,byte,buffer,new,byte,int,length,while,length,stream,read,buffer,0,index,output,write,bytes,buffer,0,length,recovery,state,get,index,add,recovered,bytes,to,file,file,info,name,length,store,verify,index,output,index,output,close,store,directory,sync,collections,singleton,file,info,physical,name,success,true,catch,corrupt,index,exception,index,format,too,old,exception,index,format,too,new,exception,ex,try,store,mark,store,corrupted,ex,catch,ioexception,e,logger,warn,store,cannot,be,marked,as,corrupted,e,throw,ex,finally,if,success,false,store,delete,quiet,file,info,physical,name
BlobStoreRepository -> RestoreContext -> private void restoreFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo, final Store store) throws IOException;1526574077;Restores a file_This is asynchronous method. Upon completion of the operation latch is getting counted down and any failures are_added to the {@code failures} list__@param fileInfo file to be restored;private void restoreFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo, final Store store) throws IOException {_            boolean success = false___            try (InputStream partSliceStream = new PartSliceStream(blobContainer, fileInfo)) {_                final InputStream stream__                if (restoreRateLimiter == null) {_                    stream = partSliceStream__                } else {_                    stream = new RateLimitingInputStream(partSliceStream, restoreRateLimiter, restoreRateLimitingTimeInNanos::inc)__                }__                try (IndexOutput indexOutput = store.createVerifyingOutput(fileInfo.physicalName(), fileInfo.metadata(), IOContext.DEFAULT)) {_                    final byte[] buffer = new byte[BUFFER_SIZE]__                    int length__                    while ((length = stream.read(buffer)) > 0) {_                        indexOutput.writeBytes(buffer, 0, length)__                        recoveryState.getIndex().addRecoveredBytesToFile(fileInfo.name(), length)__                    }_                    Store.verify(indexOutput)__                    indexOutput.close()__                    store.directory().sync(Collections.singleton(fileInfo.physicalName()))__                    success = true__                } catch (CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {_                    try {_                        store.markStoreCorrupted(ex)__                    } catch (IOException e) {_                        logger.warn("store cannot be marked as corrupted", e)__                    }_                    throw ex__                } finally {_                    if (success == false) {_                        store.deleteQuiet(fileInfo.physicalName())__                    }_                }_            }_        };restores,a,file,this,is,asynchronous,method,upon,completion,of,the,operation,latch,is,getting,counted,down,and,any,failures,are,added,to,the,code,failures,list,param,file,info,file,to,be,restored;private,void,restore,file,final,blob,store,index,shard,snapshot,file,info,file,info,final,store,store,throws,ioexception,boolean,success,false,try,input,stream,part,slice,stream,new,part,slice,stream,blob,container,file,info,final,input,stream,stream,if,restore,rate,limiter,null,stream,part,slice,stream,else,stream,new,rate,limiting,input,stream,part,slice,stream,restore,rate,limiter,restore,rate,limiting,time,in,nanos,inc,try,index,output,index,output,store,create,verifying,output,file,info,physical,name,file,info,metadata,iocontext,default,final,byte,buffer,new,byte,int,length,while,length,stream,read,buffer,0,index,output,write,bytes,buffer,0,length,recovery,state,get,index,add,recovered,bytes,to,file,file,info,name,length,store,verify,index,output,index,output,close,store,directory,sync,collections,singleton,file,info,physical,name,success,true,catch,corrupt,index,exception,index,format,too,old,exception,index,format,too,new,exception,ex,try,store,mark,store,corrupted,ex,catch,ioexception,e,logger,warn,store,cannot,be,marked,as,corrupted,e,throw,ex,finally,if,success,false,store,delete,quiet,file,info,physical,name
BlobStoreRepository -> RestoreContext -> private void restoreFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo, final Store store) throws IOException;1527583663;Restores a file_This is asynchronous method. Upon completion of the operation latch is getting counted down and any failures are_added to the {@code failures} list__@param fileInfo file to be restored;private void restoreFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo, final Store store) throws IOException {_            boolean success = false___            try (InputStream partSliceStream = new PartSliceStream(blobContainer, fileInfo)) {_                final InputStream stream__                if (restoreRateLimiter == null) {_                    stream = partSliceStream__                } else {_                    stream = new RateLimitingInputStream(partSliceStream, restoreRateLimiter, restoreRateLimitingTimeInNanos::inc)__                }__                try (IndexOutput indexOutput = store.createVerifyingOutput(fileInfo.physicalName(), fileInfo.metadata(), IOContext.DEFAULT)) {_                    final byte[] buffer = new byte[BUFFER_SIZE]__                    int length__                    while ((length = stream.read(buffer)) > 0) {_                        indexOutput.writeBytes(buffer, 0, length)__                        recoveryState.getIndex().addRecoveredBytesToFile(fileInfo.name(), length)__                    }_                    Store.verify(indexOutput)__                    indexOutput.close()__                    store.directory().sync(Collections.singleton(fileInfo.physicalName()))__                    success = true__                } catch (CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {_                    try {_                        store.markStoreCorrupted(ex)__                    } catch (IOException e) {_                        logger.warn("store cannot be marked as corrupted", e)__                    }_                    throw ex__                } finally {_                    if (success == false) {_                        store.deleteQuiet(fileInfo.physicalName())__                    }_                }_            }_        };restores,a,file,this,is,asynchronous,method,upon,completion,of,the,operation,latch,is,getting,counted,down,and,any,failures,are,added,to,the,code,failures,list,param,file,info,file,to,be,restored;private,void,restore,file,final,blob,store,index,shard,snapshot,file,info,file,info,final,store,store,throws,ioexception,boolean,success,false,try,input,stream,part,slice,stream,new,part,slice,stream,blob,container,file,info,final,input,stream,stream,if,restore,rate,limiter,null,stream,part,slice,stream,else,stream,new,rate,limiting,input,stream,part,slice,stream,restore,rate,limiter,restore,rate,limiting,time,in,nanos,inc,try,index,output,index,output,store,create,verifying,output,file,info,physical,name,file,info,metadata,iocontext,default,final,byte,buffer,new,byte,int,length,while,length,stream,read,buffer,0,index,output,write,bytes,buffer,0,length,recovery,state,get,index,add,recovered,bytes,to,file,file,info,name,length,store,verify,index,output,index,output,close,store,directory,sync,collections,singleton,file,info,physical,name,success,true,catch,corrupt,index,exception,index,format,too,old,exception,index,format,too,new,exception,ex,try,store,mark,store,corrupted,ex,catch,ioexception,e,logger,warn,store,cannot,be,marked,as,corrupted,e,throw,ex,finally,if,success,false,store,delete,quiet,file,info,physical,name
BlobStoreRepository -> RestoreContext -> private void restoreFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo, final Store store) throws IOException;1528211342;Restores a file_This is asynchronous method. Upon completion of the operation latch is getting counted down and any failures are_added to the {@code failures} list__@param fileInfo file to be restored;private void restoreFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo, final Store store) throws IOException {_            boolean success = false___            try (InputStream partSliceStream = new PartSliceStream(blobContainer, fileInfo)) {_                final InputStream stream__                if (restoreRateLimiter == null) {_                    stream = partSliceStream__                } else {_                    stream = new RateLimitingInputStream(partSliceStream, restoreRateLimiter, restoreRateLimitingTimeInNanos::inc)__                }__                try (IndexOutput indexOutput = store.createVerifyingOutput(fileInfo.physicalName(), fileInfo.metadata(), IOContext.DEFAULT)) {_                    final byte[] buffer = new byte[BUFFER_SIZE]__                    int length__                    while ((length = stream.read(buffer)) > 0) {_                        indexOutput.writeBytes(buffer, 0, length)__                        recoveryState.getIndex().addRecoveredBytesToFile(fileInfo.name(), length)__                    }_                    Store.verify(indexOutput)__                    indexOutput.close()__                    store.directory().sync(Collections.singleton(fileInfo.physicalName()))__                    success = true__                } catch (CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {_                    try {_                        store.markStoreCorrupted(ex)__                    } catch (IOException e) {_                        logger.warn("store cannot be marked as corrupted", e)__                    }_                    throw ex__                } finally {_                    if (success == false) {_                        store.deleteQuiet(fileInfo.physicalName())__                    }_                }_            }_        };restores,a,file,this,is,asynchronous,method,upon,completion,of,the,operation,latch,is,getting,counted,down,and,any,failures,are,added,to,the,code,failures,list,param,file,info,file,to,be,restored;private,void,restore,file,final,blob,store,index,shard,snapshot,file,info,file,info,final,store,store,throws,ioexception,boolean,success,false,try,input,stream,part,slice,stream,new,part,slice,stream,blob,container,file,info,final,input,stream,stream,if,restore,rate,limiter,null,stream,part,slice,stream,else,stream,new,rate,limiting,input,stream,part,slice,stream,restore,rate,limiter,restore,rate,limiting,time,in,nanos,inc,try,index,output,index,output,store,create,verifying,output,file,info,physical,name,file,info,metadata,iocontext,default,final,byte,buffer,new,byte,int,length,while,length,stream,read,buffer,0,index,output,write,bytes,buffer,0,length,recovery,state,get,index,add,recovered,bytes,to,file,file,info,name,length,store,verify,index,output,index,output,close,store,directory,sync,collections,singleton,file,info,physical,name,success,true,catch,corrupt,index,exception,index,format,too,old,exception,index,format,too,new,exception,ex,try,store,mark,store,corrupted,ex,catch,ioexception,e,logger,warn,store,cannot,be,marked,as,corrupted,e,throw,ex,finally,if,success,false,store,delete,quiet,file,info,physical,name
BlobStoreRepository -> RestoreContext -> private void restoreFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo, final Store store) throws IOException;1531179852;Restores a file_This is asynchronous method. Upon completion of the operation latch is getting counted down and any failures are_added to the {@code failures} list__@param fileInfo file to be restored;private void restoreFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo, final Store store) throws IOException {_            boolean success = false___            try (InputStream partSliceStream = new PartSliceStream(blobContainer, fileInfo)) {_                final InputStream stream__                if (restoreRateLimiter == null) {_                    stream = partSliceStream__                } else {_                    stream = new RateLimitingInputStream(partSliceStream, restoreRateLimiter, restoreRateLimitingTimeInNanos::inc)__                }__                try (IndexOutput indexOutput = store.createVerifyingOutput(fileInfo.physicalName(), fileInfo.metadata(), IOContext.DEFAULT)) {_                    final byte[] buffer = new byte[BUFFER_SIZE]__                    int length__                    while ((length = stream.read(buffer)) > 0) {_                        indexOutput.writeBytes(buffer, 0, length)__                        recoveryState.getIndex().addRecoveredBytesToFile(fileInfo.name(), length)__                    }_                    Store.verify(indexOutput)__                    indexOutput.close()__                    store.directory().sync(Collections.singleton(fileInfo.physicalName()))__                    success = true__                } catch (CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {_                    try {_                        store.markStoreCorrupted(ex)__                    } catch (IOException e) {_                        logger.warn("store cannot be marked as corrupted", e)__                    }_                    throw ex__                } finally {_                    if (success == false) {_                        store.deleteQuiet(fileInfo.physicalName())__                    }_                }_            }_        };restores,a,file,this,is,asynchronous,method,upon,completion,of,the,operation,latch,is,getting,counted,down,and,any,failures,are,added,to,the,code,failures,list,param,file,info,file,to,be,restored;private,void,restore,file,final,blob,store,index,shard,snapshot,file,info,file,info,final,store,store,throws,ioexception,boolean,success,false,try,input,stream,part,slice,stream,new,part,slice,stream,blob,container,file,info,final,input,stream,stream,if,restore,rate,limiter,null,stream,part,slice,stream,else,stream,new,rate,limiting,input,stream,part,slice,stream,restore,rate,limiter,restore,rate,limiting,time,in,nanos,inc,try,index,output,index,output,store,create,verifying,output,file,info,physical,name,file,info,metadata,iocontext,default,final,byte,buffer,new,byte,int,length,while,length,stream,read,buffer,0,index,output,write,bytes,buffer,0,length,recovery,state,get,index,add,recovered,bytes,to,file,file,info,name,length,store,verify,index,output,index,output,close,store,directory,sync,collections,singleton,file,info,physical,name,success,true,catch,corrupt,index,exception,index,format,too,old,exception,index,format,too,new,exception,ex,try,store,mark,store,corrupted,ex,catch,ioexception,e,logger,warn,store,cannot,be,marked,as,corrupted,e,throw,ex,finally,if,success,false,store,delete,quiet,file,info,physical,name
BlobStoreRepository -> RestoreContext -> private void restoreFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo, final Store store) throws IOException;1531729807;Restores a file_This is asynchronous method. Upon completion of the operation latch is getting counted down and any failures are_added to the {@code failures} list__@param fileInfo file to be restored;private void restoreFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo, final Store store) throws IOException {_            boolean success = false___            try (InputStream partSliceStream = new PartSliceStream(blobContainer, fileInfo)) {_                final InputStream stream__                if (restoreRateLimiter == null) {_                    stream = partSliceStream__                } else {_                    stream = new RateLimitingInputStream(partSliceStream, restoreRateLimiter, restoreRateLimitingTimeInNanos::inc)__                }__                try (IndexOutput indexOutput = store.createVerifyingOutput(fileInfo.physicalName(), fileInfo.metadata(), IOContext.DEFAULT)) {_                    final byte[] buffer = new byte[BUFFER_SIZE]__                    int length__                    while ((length = stream.read(buffer)) > 0) {_                        indexOutput.writeBytes(buffer, 0, length)__                        recoveryState.getIndex().addRecoveredBytesToFile(fileInfo.name(), length)__                    }_                    Store.verify(indexOutput)__                    indexOutput.close()__                    store.directory().sync(Collections.singleton(fileInfo.physicalName()))__                    success = true__                } catch (CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {_                    try {_                        store.markStoreCorrupted(ex)__                    } catch (IOException e) {_                        logger.warn("store cannot be marked as corrupted", e)__                    }_                    throw ex__                } finally {_                    if (success == false) {_                        store.deleteQuiet(fileInfo.physicalName())__                    }_                }_            }_        };restores,a,file,this,is,asynchronous,method,upon,completion,of,the,operation,latch,is,getting,counted,down,and,any,failures,are,added,to,the,code,failures,list,param,file,info,file,to,be,restored;private,void,restore,file,final,blob,store,index,shard,snapshot,file,info,file,info,final,store,store,throws,ioexception,boolean,success,false,try,input,stream,part,slice,stream,new,part,slice,stream,blob,container,file,info,final,input,stream,stream,if,restore,rate,limiter,null,stream,part,slice,stream,else,stream,new,rate,limiting,input,stream,part,slice,stream,restore,rate,limiter,restore,rate,limiting,time,in,nanos,inc,try,index,output,index,output,store,create,verifying,output,file,info,physical,name,file,info,metadata,iocontext,default,final,byte,buffer,new,byte,int,length,while,length,stream,read,buffer,0,index,output,write,bytes,buffer,0,length,recovery,state,get,index,add,recovered,bytes,to,file,file,info,name,length,store,verify,index,output,index,output,close,store,directory,sync,collections,singleton,file,info,physical,name,success,true,catch,corrupt,index,exception,index,format,too,old,exception,index,format,too,new,exception,ex,try,store,mark,store,corrupted,ex,catch,ioexception,e,logger,warn,store,cannot,be,marked,as,corrupted,e,throw,ex,finally,if,success,false,store,delete,quiet,file,info,physical,name
BlobStoreRepository -> RestoreContext -> private void restoreFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo, final Store store) throws IOException;1532685069;Restores a file_This is asynchronous method. Upon completion of the operation latch is getting counted down and any failures are_added to the {@code failures} list__@param fileInfo file to be restored;private void restoreFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo, final Store store) throws IOException {_            boolean success = false___            try (InputStream partSliceStream = new PartSliceStream(blobContainer, fileInfo)) {_                final InputStream stream__                if (restoreRateLimiter == null) {_                    stream = partSliceStream__                } else {_                    stream = new RateLimitingInputStream(partSliceStream, restoreRateLimiter, restoreRateLimitingTimeInNanos::inc)__                }__                try (IndexOutput indexOutput = store.createVerifyingOutput(fileInfo.physicalName(), fileInfo.metadata(), IOContext.DEFAULT)) {_                    final byte[] buffer = new byte[BUFFER_SIZE]__                    int length__                    while ((length = stream.read(buffer)) > 0) {_                        indexOutput.writeBytes(buffer, 0, length)__                        recoveryState.getIndex().addRecoveredBytesToFile(fileInfo.name(), length)__                    }_                    Store.verify(indexOutput)__                    indexOutput.close()__                    store.directory().sync(Collections.singleton(fileInfo.physicalName()))__                    success = true__                } catch (CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {_                    try {_                        store.markStoreCorrupted(ex)__                    } catch (IOException e) {_                        logger.warn("store cannot be marked as corrupted", e)__                    }_                    throw ex__                } finally {_                    if (success == false) {_                        store.deleteQuiet(fileInfo.physicalName())__                    }_                }_            }_        };restores,a,file,this,is,asynchronous,method,upon,completion,of,the,operation,latch,is,getting,counted,down,and,any,failures,are,added,to,the,code,failures,list,param,file,info,file,to,be,restored;private,void,restore,file,final,blob,store,index,shard,snapshot,file,info,file,info,final,store,store,throws,ioexception,boolean,success,false,try,input,stream,part,slice,stream,new,part,slice,stream,blob,container,file,info,final,input,stream,stream,if,restore,rate,limiter,null,stream,part,slice,stream,else,stream,new,rate,limiting,input,stream,part,slice,stream,restore,rate,limiter,restore,rate,limiting,time,in,nanos,inc,try,index,output,index,output,store,create,verifying,output,file,info,physical,name,file,info,metadata,iocontext,default,final,byte,buffer,new,byte,int,length,while,length,stream,read,buffer,0,index,output,write,bytes,buffer,0,length,recovery,state,get,index,add,recovered,bytes,to,file,file,info,name,length,store,verify,index,output,index,output,close,store,directory,sync,collections,singleton,file,info,physical,name,success,true,catch,corrupt,index,exception,index,format,too,old,exception,index,format,too,new,exception,ex,try,store,mark,store,corrupted,ex,catch,ioexception,e,logger,warn,store,cannot,be,marked,as,corrupted,e,throw,ex,finally,if,success,false,store,delete,quiet,file,info,physical,name
BlobStoreRepository -> RestoreContext -> private void restoreFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo, final Store store) throws IOException;1535139672;Restores a file_This is asynchronous method. Upon completion of the operation latch is getting counted down and any failures are_added to the {@code failures} list__@param fileInfo file to be restored;private void restoreFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo, final Store store) throws IOException {_            boolean success = false___            try (InputStream partSliceStream = new PartSliceStream(blobContainer, fileInfo)) {_                final InputStream stream__                if (restoreRateLimiter == null) {_                    stream = partSliceStream__                } else {_                    stream = new RateLimitingInputStream(partSliceStream, restoreRateLimiter, restoreRateLimitingTimeInNanos::inc)__                }__                try (IndexOutput indexOutput = store.createVerifyingOutput(fileInfo.physicalName(), fileInfo.metadata(), IOContext.DEFAULT)) {_                    final byte[] buffer = new byte[BUFFER_SIZE]__                    int length__                    while ((length = stream.read(buffer)) > 0) {_                        indexOutput.writeBytes(buffer, 0, length)__                        recoveryState.getIndex().addRecoveredBytesToFile(fileInfo.name(), length)__                    }_                    Store.verify(indexOutput)__                    indexOutput.close()__                    store.directory().sync(Collections.singleton(fileInfo.physicalName()))__                    success = true__                } catch (CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {_                    try {_                        store.markStoreCorrupted(ex)__                    } catch (IOException e) {_                        logger.warn("store cannot be marked as corrupted", e)__                    }_                    throw ex__                } finally {_                    if (success == false) {_                        store.deleteQuiet(fileInfo.physicalName())__                    }_                }_            }_        };restores,a,file,this,is,asynchronous,method,upon,completion,of,the,operation,latch,is,getting,counted,down,and,any,failures,are,added,to,the,code,failures,list,param,file,info,file,to,be,restored;private,void,restore,file,final,blob,store,index,shard,snapshot,file,info,file,info,final,store,store,throws,ioexception,boolean,success,false,try,input,stream,part,slice,stream,new,part,slice,stream,blob,container,file,info,final,input,stream,stream,if,restore,rate,limiter,null,stream,part,slice,stream,else,stream,new,rate,limiting,input,stream,part,slice,stream,restore,rate,limiter,restore,rate,limiting,time,in,nanos,inc,try,index,output,index,output,store,create,verifying,output,file,info,physical,name,file,info,metadata,iocontext,default,final,byte,buffer,new,byte,int,length,while,length,stream,read,buffer,0,index,output,write,bytes,buffer,0,length,recovery,state,get,index,add,recovered,bytes,to,file,file,info,name,length,store,verify,index,output,index,output,close,store,directory,sync,collections,singleton,file,info,physical,name,success,true,catch,corrupt,index,exception,index,format,too,old,exception,index,format,too,new,exception,ex,try,store,mark,store,corrupted,ex,catch,ioexception,e,logger,warn,store,cannot,be,marked,as,corrupted,e,throw,ex,finally,if,success,false,store,delete,quiet,file,info,physical,name
BlobStoreRepository -> RestoreContext -> private void restoreFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo, final Store store) throws IOException;1535723122;Restores a file_This is asynchronous method. Upon completion of the operation latch is getting counted down and any failures are_added to the {@code failures} list__@param fileInfo file to be restored;private void restoreFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo, final Store store) throws IOException {_            boolean success = false___            try (InputStream partSliceStream = new PartSliceStream(blobContainer, fileInfo)) {_                final InputStream stream__                if (restoreRateLimiter == null) {_                    stream = partSliceStream__                } else {_                    stream = new RateLimitingInputStream(partSliceStream, restoreRateLimiter, restoreRateLimitingTimeInNanos::inc)__                }__                try (IndexOutput indexOutput = store.createVerifyingOutput(fileInfo.physicalName(), fileInfo.metadata(), IOContext.DEFAULT)) {_                    final byte[] buffer = new byte[BUFFER_SIZE]__                    int length__                    while ((length = stream.read(buffer)) > 0) {_                        indexOutput.writeBytes(buffer, 0, length)__                        recoveryState.getIndex().addRecoveredBytesToFile(fileInfo.name(), length)__                    }_                    Store.verify(indexOutput)__                    indexOutput.close()__                    store.directory().sync(Collections.singleton(fileInfo.physicalName()))__                    success = true__                } catch (CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {_                    try {_                        store.markStoreCorrupted(ex)__                    } catch (IOException e) {_                        logger.warn("store cannot be marked as corrupted", e)__                    }_                    throw ex__                } finally {_                    if (success == false) {_                        store.deleteQuiet(fileInfo.physicalName())__                    }_                }_            }_        };restores,a,file,this,is,asynchronous,method,upon,completion,of,the,operation,latch,is,getting,counted,down,and,any,failures,are,added,to,the,code,failures,list,param,file,info,file,to,be,restored;private,void,restore,file,final,blob,store,index,shard,snapshot,file,info,file,info,final,store,store,throws,ioexception,boolean,success,false,try,input,stream,part,slice,stream,new,part,slice,stream,blob,container,file,info,final,input,stream,stream,if,restore,rate,limiter,null,stream,part,slice,stream,else,stream,new,rate,limiting,input,stream,part,slice,stream,restore,rate,limiter,restore,rate,limiting,time,in,nanos,inc,try,index,output,index,output,store,create,verifying,output,file,info,physical,name,file,info,metadata,iocontext,default,final,byte,buffer,new,byte,int,length,while,length,stream,read,buffer,0,index,output,write,bytes,buffer,0,length,recovery,state,get,index,add,recovered,bytes,to,file,file,info,name,length,store,verify,index,output,index,output,close,store,directory,sync,collections,singleton,file,info,physical,name,success,true,catch,corrupt,index,exception,index,format,too,old,exception,index,format,too,new,exception,ex,try,store,mark,store,corrupted,ex,catch,ioexception,e,logger,warn,store,cannot,be,marked,as,corrupted,e,throw,ex,finally,if,success,false,store,delete,quiet,file,info,physical,name
BlobStoreRepository -> RestoreContext -> private void restoreFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo, final Store store) throws IOException;1536314350;Restores a file_This is asynchronous method. Upon completion of the operation latch is getting counted down and any failures are_added to the {@code failures} list__@param fileInfo file to be restored;private void restoreFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo, final Store store) throws IOException {_            boolean success = false___            try (InputStream partSliceStream = new PartSliceStream(blobContainer, fileInfo)) {_                final InputStream stream__                if (restoreRateLimiter == null) {_                    stream = partSliceStream__                } else {_                    stream = new RateLimitingInputStream(partSliceStream, restoreRateLimiter, restoreRateLimitingTimeInNanos::inc)__                }__                try (IndexOutput indexOutput = store.createVerifyingOutput(fileInfo.physicalName(), fileInfo.metadata(), IOContext.DEFAULT)) {_                    final byte[] buffer = new byte[BUFFER_SIZE]__                    int length__                    while ((length = stream.read(buffer)) > 0) {_                        indexOutput.writeBytes(buffer, 0, length)__                        recoveryState.getIndex().addRecoveredBytesToFile(fileInfo.name(), length)__                    }_                    Store.verify(indexOutput)__                    indexOutput.close()__                    store.directory().sync(Collections.singleton(fileInfo.physicalName()))__                    success = true__                } catch (CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {_                    try {_                        store.markStoreCorrupted(ex)__                    } catch (IOException e) {_                        logger.warn("store cannot be marked as corrupted", e)__                    }_                    throw ex__                } finally {_                    if (success == false) {_                        store.deleteQuiet(fileInfo.physicalName())__                    }_                }_            }_        };restores,a,file,this,is,asynchronous,method,upon,completion,of,the,operation,latch,is,getting,counted,down,and,any,failures,are,added,to,the,code,failures,list,param,file,info,file,to,be,restored;private,void,restore,file,final,blob,store,index,shard,snapshot,file,info,file,info,final,store,store,throws,ioexception,boolean,success,false,try,input,stream,part,slice,stream,new,part,slice,stream,blob,container,file,info,final,input,stream,stream,if,restore,rate,limiter,null,stream,part,slice,stream,else,stream,new,rate,limiting,input,stream,part,slice,stream,restore,rate,limiter,restore,rate,limiting,time,in,nanos,inc,try,index,output,index,output,store,create,verifying,output,file,info,physical,name,file,info,metadata,iocontext,default,final,byte,buffer,new,byte,int,length,while,length,stream,read,buffer,0,index,output,write,bytes,buffer,0,length,recovery,state,get,index,add,recovered,bytes,to,file,file,info,name,length,store,verify,index,output,index,output,close,store,directory,sync,collections,singleton,file,info,physical,name,success,true,catch,corrupt,index,exception,index,format,too,old,exception,index,format,too,new,exception,ex,try,store,mark,store,corrupted,ex,catch,ioexception,e,logger,warn,store,cannot,be,marked,as,corrupted,e,throw,ex,finally,if,success,false,store,delete,quiet,file,info,physical,name
BlobStoreRepository -> RestoreContext -> private void restoreFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo, final Store store) throws IOException;1536828374;Restores a file_This is asynchronous method. Upon completion of the operation latch is getting counted down and any failures are_added to the {@code failures} list__@param fileInfo file to be restored;private void restoreFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo, final Store store) throws IOException {_            boolean success = false___            try (InputStream partSliceStream = new PartSliceStream(blobContainer, fileInfo)) {_                final InputStream stream__                if (restoreRateLimiter == null) {_                    stream = partSliceStream__                } else {_                    stream = new RateLimitingInputStream(partSliceStream, restoreRateLimiter, restoreRateLimitingTimeInNanos::inc)__                }__                try (IndexOutput indexOutput = store.createVerifyingOutput(fileInfo.physicalName(), fileInfo.metadata(), IOContext.DEFAULT)) {_                    final byte[] buffer = new byte[BUFFER_SIZE]__                    int length__                    while ((length = stream.read(buffer)) > 0) {_                        indexOutput.writeBytes(buffer, 0, length)__                        recoveryState.getIndex().addRecoveredBytesToFile(fileInfo.name(), length)__                    }_                    Store.verify(indexOutput)__                    indexOutput.close()__                    store.directory().sync(Collections.singleton(fileInfo.physicalName()))__                    success = true__                } catch (CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {_                    try {_                        store.markStoreCorrupted(ex)__                    } catch (IOException e) {_                        logger.warn("store cannot be marked as corrupted", e)__                    }_                    throw ex__                } finally {_                    if (success == false) {_                        store.deleteQuiet(fileInfo.physicalName())__                    }_                }_            }_        };restores,a,file,this,is,asynchronous,method,upon,completion,of,the,operation,latch,is,getting,counted,down,and,any,failures,are,added,to,the,code,failures,list,param,file,info,file,to,be,restored;private,void,restore,file,final,blob,store,index,shard,snapshot,file,info,file,info,final,store,store,throws,ioexception,boolean,success,false,try,input,stream,part,slice,stream,new,part,slice,stream,blob,container,file,info,final,input,stream,stream,if,restore,rate,limiter,null,stream,part,slice,stream,else,stream,new,rate,limiting,input,stream,part,slice,stream,restore,rate,limiter,restore,rate,limiting,time,in,nanos,inc,try,index,output,index,output,store,create,verifying,output,file,info,physical,name,file,info,metadata,iocontext,default,final,byte,buffer,new,byte,int,length,while,length,stream,read,buffer,0,index,output,write,bytes,buffer,0,length,recovery,state,get,index,add,recovered,bytes,to,file,file,info,name,length,store,verify,index,output,index,output,close,store,directory,sync,collections,singleton,file,info,physical,name,success,true,catch,corrupt,index,exception,index,format,too,old,exception,index,format,too,new,exception,ex,try,store,mark,store,corrupted,ex,catch,ioexception,e,logger,warn,store,cannot,be,marked,as,corrupted,e,throw,ex,finally,if,success,false,store,delete,quiet,file,info,physical,name
BlobStoreRepository -> RestoreContext -> private void restoreFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo, final Store store) throws IOException;1541008027;Restores a file_This is asynchronous method. Upon completion of the operation latch is getting counted down and any failures are_added to the {@code failures} list__@param fileInfo file to be restored;private void restoreFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo, final Store store) throws IOException {_            boolean success = false___            try (InputStream partSliceStream = new PartSliceStream(blobContainer, fileInfo)) {_                final InputStream stream__                if (restoreRateLimiter == null) {_                    stream = partSliceStream__                } else {_                    stream = new RateLimitingInputStream(partSliceStream, restoreRateLimiter, restoreRateLimitingTimeInNanos::inc)__                }__                try (IndexOutput indexOutput = store.createVerifyingOutput(fileInfo.physicalName(), fileInfo.metadata(), IOContext.DEFAULT)) {_                    final byte[] buffer = new byte[BUFFER_SIZE]__                    int length__                    while ((length = stream.read(buffer)) > 0) {_                        indexOutput.writeBytes(buffer, 0, length)__                        recoveryState.getIndex().addRecoveredBytesToFile(fileInfo.name(), length)__                    }_                    Store.verify(indexOutput)__                    indexOutput.close()__                    store.directory().sync(Collections.singleton(fileInfo.physicalName()))__                    success = true__                } catch (CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {_                    try {_                        store.markStoreCorrupted(ex)__                    } catch (IOException e) {_                        logger.warn("store cannot be marked as corrupted", e)__                    }_                    throw ex__                } finally {_                    if (success == false) {_                        store.deleteQuiet(fileInfo.physicalName())__                    }_                }_            }_        };restores,a,file,this,is,asynchronous,method,upon,completion,of,the,operation,latch,is,getting,counted,down,and,any,failures,are,added,to,the,code,failures,list,param,file,info,file,to,be,restored;private,void,restore,file,final,blob,store,index,shard,snapshot,file,info,file,info,final,store,store,throws,ioexception,boolean,success,false,try,input,stream,part,slice,stream,new,part,slice,stream,blob,container,file,info,final,input,stream,stream,if,restore,rate,limiter,null,stream,part,slice,stream,else,stream,new,rate,limiting,input,stream,part,slice,stream,restore,rate,limiter,restore,rate,limiting,time,in,nanos,inc,try,index,output,index,output,store,create,verifying,output,file,info,physical,name,file,info,metadata,iocontext,default,final,byte,buffer,new,byte,int,length,while,length,stream,read,buffer,0,index,output,write,bytes,buffer,0,length,recovery,state,get,index,add,recovered,bytes,to,file,file,info,name,length,store,verify,index,output,index,output,close,store,directory,sync,collections,singleton,file,info,physical,name,success,true,catch,corrupt,index,exception,index,format,too,old,exception,index,format,too,new,exception,ex,try,store,mark,store,corrupted,ex,catch,ioexception,e,logger,warn,store,cannot,be,marked,as,corrupted,e,throw,ex,finally,if,success,false,store,delete,quiet,file,info,physical,name
BlobStoreRepository -> RestoreContext -> private void restoreFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo, final Store store) throws IOException;1542646292;Restores a file_This is asynchronous method. Upon completion of the operation latch is getting counted down and any failures are_added to the {@code failures} list__@param fileInfo file to be restored;private void restoreFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo, final Store store) throws IOException {_            boolean success = false___            try (InputStream partSliceStream = new PartSliceStream(blobContainer, fileInfo)) {_                final InputStream stream__                if (restoreRateLimiter == null) {_                    stream = partSliceStream__                } else {_                    stream = new RateLimitingInputStream(partSliceStream, restoreRateLimiter, restoreRateLimitingTimeInNanos::inc)__                }__                try (IndexOutput indexOutput = store.createVerifyingOutput(fileInfo.physicalName(), fileInfo.metadata(), IOContext.DEFAULT)) {_                    final byte[] buffer = new byte[BUFFER_SIZE]__                    int length__                    while ((length = stream.read(buffer)) > 0) {_                        indexOutput.writeBytes(buffer, 0, length)__                        recoveryState.getIndex().addRecoveredBytesToFile(fileInfo.name(), length)__                    }_                    Store.verify(indexOutput)__                    indexOutput.close()__                    store.directory().sync(Collections.singleton(fileInfo.physicalName()))__                    success = true__                } catch (CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {_                    try {_                        store.markStoreCorrupted(ex)__                    } catch (IOException e) {_                        logger.warn("store cannot be marked as corrupted", e)__                    }_                    throw ex__                } finally {_                    if (success == false) {_                        store.deleteQuiet(fileInfo.physicalName())__                    }_                }_            }_        };restores,a,file,this,is,asynchronous,method,upon,completion,of,the,operation,latch,is,getting,counted,down,and,any,failures,are,added,to,the,code,failures,list,param,file,info,file,to,be,restored;private,void,restore,file,final,blob,store,index,shard,snapshot,file,info,file,info,final,store,store,throws,ioexception,boolean,success,false,try,input,stream,part,slice,stream,new,part,slice,stream,blob,container,file,info,final,input,stream,stream,if,restore,rate,limiter,null,stream,part,slice,stream,else,stream,new,rate,limiting,input,stream,part,slice,stream,restore,rate,limiter,restore,rate,limiting,time,in,nanos,inc,try,index,output,index,output,store,create,verifying,output,file,info,physical,name,file,info,metadata,iocontext,default,final,byte,buffer,new,byte,int,length,while,length,stream,read,buffer,0,index,output,write,bytes,buffer,0,length,recovery,state,get,index,add,recovered,bytes,to,file,file,info,name,length,store,verify,index,output,index,output,close,store,directory,sync,collections,singleton,file,info,physical,name,success,true,catch,corrupt,index,exception,index,format,too,old,exception,index,format,too,new,exception,ex,try,store,mark,store,corrupted,ex,catch,ioexception,e,logger,warn,store,cannot,be,marked,as,corrupted,e,throw,ex,finally,if,success,false,store,delete,quiet,file,info,physical,name
BlobStoreRepository -> RestoreContext -> private void restoreFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo, final Store store) throws IOException;1542980705;Restores a file_This is asynchronous method. Upon completion of the operation latch is getting counted down and any failures are_added to the {@code failures} list__@param fileInfo file to be restored;private void restoreFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo, final Store store) throws IOException {_            boolean success = false___            try (InputStream partSliceStream = new PartSliceStream(blobContainer, fileInfo)) {_                final InputStream stream__                if (restoreRateLimiter == null) {_                    stream = partSliceStream__                } else {_                    stream = new RateLimitingInputStream(partSliceStream, restoreRateLimiter, restoreRateLimitingTimeInNanos::inc)__                }__                try (IndexOutput indexOutput = store.createVerifyingOutput(fileInfo.physicalName(), fileInfo.metadata(), IOContext.DEFAULT)) {_                    final byte[] buffer = new byte[BUFFER_SIZE]__                    int length__                    while ((length = stream.read(buffer)) > 0) {_                        indexOutput.writeBytes(buffer, 0, length)__                        recoveryState.getIndex().addRecoveredBytesToFile(fileInfo.name(), length)__                    }_                    Store.verify(indexOutput)__                    indexOutput.close()__                    store.directory().sync(Collections.singleton(fileInfo.physicalName()))__                    success = true__                } catch (CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {_                    try {_                        store.markStoreCorrupted(ex)__                    } catch (IOException e) {_                        logger.warn("store cannot be marked as corrupted", e)__                    }_                    throw ex__                } finally {_                    if (success == false) {_                        store.deleteQuiet(fileInfo.physicalName())__                    }_                }_            }_        };restores,a,file,this,is,asynchronous,method,upon,completion,of,the,operation,latch,is,getting,counted,down,and,any,failures,are,added,to,the,code,failures,list,param,file,info,file,to,be,restored;private,void,restore,file,final,blob,store,index,shard,snapshot,file,info,file,info,final,store,store,throws,ioexception,boolean,success,false,try,input,stream,part,slice,stream,new,part,slice,stream,blob,container,file,info,final,input,stream,stream,if,restore,rate,limiter,null,stream,part,slice,stream,else,stream,new,rate,limiting,input,stream,part,slice,stream,restore,rate,limiter,restore,rate,limiting,time,in,nanos,inc,try,index,output,index,output,store,create,verifying,output,file,info,physical,name,file,info,metadata,iocontext,default,final,byte,buffer,new,byte,int,length,while,length,stream,read,buffer,0,index,output,write,bytes,buffer,0,length,recovery,state,get,index,add,recovered,bytes,to,file,file,info,name,length,store,verify,index,output,index,output,close,store,directory,sync,collections,singleton,file,info,physical,name,success,true,catch,corrupt,index,exception,index,format,too,old,exception,index,format,too,new,exception,ex,try,store,mark,store,corrupted,ex,catch,ioexception,e,logger,warn,store,cannot,be,marked,as,corrupted,e,throw,ex,finally,if,success,false,store,delete,quiet,file,info,physical,name
BlobStoreRepository -> RestoreContext -> private void restoreFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo, final Store store) throws IOException;1543831870;Restores a file_This is asynchronous method. Upon completion of the operation latch is getting counted down and any failures are_added to the {@code failures} list__@param fileInfo file to be restored;private void restoreFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo, final Store store) throws IOException {_            boolean success = false___            try (InputStream partSliceStream = new PartSliceStream(blobContainer, fileInfo)) {_                final InputStream stream__                if (restoreRateLimiter == null) {_                    stream = partSliceStream__                } else {_                    stream = new RateLimitingInputStream(partSliceStream, restoreRateLimiter, restoreRateLimitingTimeInNanos::inc)__                }__                try (IndexOutput indexOutput = store.createVerifyingOutput(fileInfo.physicalName(), fileInfo.metadata(), IOContext.DEFAULT)) {_                    final byte[] buffer = new byte[BUFFER_SIZE]__                    int length__                    while ((length = stream.read(buffer)) > 0) {_                        indexOutput.writeBytes(buffer, 0, length)__                        recoveryState.getIndex().addRecoveredBytesToFile(fileInfo.name(), length)__                    }_                    Store.verify(indexOutput)__                    indexOutput.close()__                    store.directory().sync(Collections.singleton(fileInfo.physicalName()))__                    success = true__                } catch (CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {_                    try {_                        store.markStoreCorrupted(ex)__                    } catch (IOException e) {_                        logger.warn("store cannot be marked as corrupted", e)__                    }_                    throw ex__                } finally {_                    if (success == false) {_                        store.deleteQuiet(fileInfo.physicalName())__                    }_                }_            }_        };restores,a,file,this,is,asynchronous,method,upon,completion,of,the,operation,latch,is,getting,counted,down,and,any,failures,are,added,to,the,code,failures,list,param,file,info,file,to,be,restored;private,void,restore,file,final,blob,store,index,shard,snapshot,file,info,file,info,final,store,store,throws,ioexception,boolean,success,false,try,input,stream,part,slice,stream,new,part,slice,stream,blob,container,file,info,final,input,stream,stream,if,restore,rate,limiter,null,stream,part,slice,stream,else,stream,new,rate,limiting,input,stream,part,slice,stream,restore,rate,limiter,restore,rate,limiting,time,in,nanos,inc,try,index,output,index,output,store,create,verifying,output,file,info,physical,name,file,info,metadata,iocontext,default,final,byte,buffer,new,byte,int,length,while,length,stream,read,buffer,0,index,output,write,bytes,buffer,0,length,recovery,state,get,index,add,recovered,bytes,to,file,file,info,name,length,store,verify,index,output,index,output,close,store,directory,sync,collections,singleton,file,info,physical,name,success,true,catch,corrupt,index,exception,index,format,too,old,exception,index,format,too,new,exception,ex,try,store,mark,store,corrupted,ex,catch,ioexception,e,logger,warn,store,cannot,be,marked,as,corrupted,e,throw,ex,finally,if,success,false,store,delete,quiet,file,info,physical,name
BlobStoreRepository -> RestoreContext -> private void restoreFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo, final Store store) throws IOException;1543942400;Restores a file_This is asynchronous method. Upon completion of the operation latch is getting counted down and any failures are_added to the {@code failures} list__@param fileInfo file to be restored;private void restoreFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo, final Store store) throws IOException {_            boolean success = false___            try (InputStream partSliceStream = new PartSliceStream(blobContainer, fileInfo)) {_                final InputStream stream__                if (restoreRateLimiter == null) {_                    stream = partSliceStream__                } else {_                    stream = new RateLimitingInputStream(partSliceStream, restoreRateLimiter, restoreRateLimitingTimeInNanos::inc)__                }__                try (IndexOutput indexOutput = store.createVerifyingOutput(fileInfo.physicalName(), fileInfo.metadata(), IOContext.DEFAULT)) {_                    final byte[] buffer = new byte[BUFFER_SIZE]__                    int length__                    while ((length = stream.read(buffer)) > 0) {_                        indexOutput.writeBytes(buffer, 0, length)__                        recoveryState.getIndex().addRecoveredBytesToFile(fileInfo.name(), length)__                    }_                    Store.verify(indexOutput)__                    indexOutput.close()__                    store.directory().sync(Collections.singleton(fileInfo.physicalName()))__                    success = true__                } catch (CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {_                    try {_                        store.markStoreCorrupted(ex)__                    } catch (IOException e) {_                        logger.warn("store cannot be marked as corrupted", e)__                    }_                    throw ex__                } finally {_                    if (success == false) {_                        store.deleteQuiet(fileInfo.physicalName())__                    }_                }_            }_        };restores,a,file,this,is,asynchronous,method,upon,completion,of,the,operation,latch,is,getting,counted,down,and,any,failures,are,added,to,the,code,failures,list,param,file,info,file,to,be,restored;private,void,restore,file,final,blob,store,index,shard,snapshot,file,info,file,info,final,store,store,throws,ioexception,boolean,success,false,try,input,stream,part,slice,stream,new,part,slice,stream,blob,container,file,info,final,input,stream,stream,if,restore,rate,limiter,null,stream,part,slice,stream,else,stream,new,rate,limiting,input,stream,part,slice,stream,restore,rate,limiter,restore,rate,limiting,time,in,nanos,inc,try,index,output,index,output,store,create,verifying,output,file,info,physical,name,file,info,metadata,iocontext,default,final,byte,buffer,new,byte,int,length,while,length,stream,read,buffer,0,index,output,write,bytes,buffer,0,length,recovery,state,get,index,add,recovered,bytes,to,file,file,info,name,length,store,verify,index,output,index,output,close,store,directory,sync,collections,singleton,file,info,physical,name,success,true,catch,corrupt,index,exception,index,format,too,old,exception,index,format,too,new,exception,ex,try,store,mark,store,corrupted,ex,catch,ioexception,e,logger,warn,store,cannot,be,marked,as,corrupted,e,throw,ex,finally,if,success,false,store,delete,quiet,file,info,physical,name
BlobStoreRepository -> RestoreContext -> private void restoreFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo, final Store store) throws IOException;1546974294;Restores a file_This is asynchronous method. Upon completion of the operation latch is getting counted down and any failures are_added to the {@code failures} list__@param fileInfo file to be restored;private void restoreFile(final BlobStoreIndexShardSnapshot.FileInfo fileInfo, final Store store) throws IOException {_            boolean success = false___            try (InputStream partSliceStream = new PartSliceStream(blobContainer, fileInfo)) {_                final InputStream stream__                if (restoreRateLimiter == null) {_                    stream = partSliceStream__                } else {_                    stream = new RateLimitingInputStream(partSliceStream, restoreRateLimiter, restoreRateLimitingTimeInNanos::inc)__                }__                try (IndexOutput indexOutput = store.createVerifyingOutput(fileInfo.physicalName(),_                                                                           fileInfo.metadata(), IOContext.DEFAULT)) {_                    final byte[] buffer = new byte[BUFFER_SIZE]__                    int length__                    while ((length = stream.read(buffer)) > 0) {_                        indexOutput.writeBytes(buffer, 0, length)__                        recoveryState.getIndex().addRecoveredBytesToFile(fileInfo.name(), length)__                    }_                    Store.verify(indexOutput)__                    indexOutput.close()__                    store.directory().sync(Collections.singleton(fileInfo.physicalName()))__                    success = true__                } catch (CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {_                    try {_                        store.markStoreCorrupted(ex)__                    } catch (IOException e) {_                        logger.warn("store cannot be marked as corrupted", e)__                    }_                    throw ex__                } finally {_                    if (success == false) {_                        store.deleteQuiet(fileInfo.physicalName())__                    }_                }_            }_        };restores,a,file,this,is,asynchronous,method,upon,completion,of,the,operation,latch,is,getting,counted,down,and,any,failures,are,added,to,the,code,failures,list,param,file,info,file,to,be,restored;private,void,restore,file,final,blob,store,index,shard,snapshot,file,info,file,info,final,store,store,throws,ioexception,boolean,success,false,try,input,stream,part,slice,stream,new,part,slice,stream,blob,container,file,info,final,input,stream,stream,if,restore,rate,limiter,null,stream,part,slice,stream,else,stream,new,rate,limiting,input,stream,part,slice,stream,restore,rate,limiter,restore,rate,limiting,time,in,nanos,inc,try,index,output,index,output,store,create,verifying,output,file,info,physical,name,file,info,metadata,iocontext,default,final,byte,buffer,new,byte,int,length,while,length,stream,read,buffer,0,index,output,write,bytes,buffer,0,length,recovery,state,get,index,add,recovered,bytes,to,file,file,info,name,length,store,verify,index,output,index,output,close,store,directory,sync,collections,singleton,file,info,physical,name,success,true,catch,corrupt,index,exception,index,format,too,old,exception,index,format,too,new,exception,ex,try,store,mark,store,corrupted,ex,catch,ioexception,e,logger,warn,store,cannot,be,marked,as,corrupted,e,throw,ex,finally,if,success,false,store,delete,quiet,file,info,physical,name
BlobStoreRepository -> Context -> BlobStoreIndexShardSnapshot loadSnapshot();1525798020;Loads information about shard snapshot;BlobStoreIndexShardSnapshot loadSnapshot() {_            try {_                return indexShardSnapshotFormat(version).read(blobContainer, snapshotId.getUUID())__            } catch (IOException ex) {_                throw new SnapshotException(metadata.name(), snapshotId, "failed to read shard snapshot file for " + shardId, ex)__            }_        };loads,information,about,shard,snapshot;blob,store,index,shard,snapshot,load,snapshot,try,return,index,shard,snapshot,format,version,read,blob,container,snapshot,id,get,uuid,catch,ioexception,ex,throw,new,snapshot,exception,metadata,name,snapshot,id,failed,to,read,shard,snapshot,file,for,shard,id,ex
BlobStoreRepository -> Context -> BlobStoreIndexShardSnapshot loadSnapshot();1526289033;Loads information about shard snapshot;BlobStoreIndexShardSnapshot loadSnapshot() {_            try {_                return indexShardSnapshotFormat(version).read(blobContainer, snapshotId.getUUID())__            } catch (IOException ex) {_                throw new SnapshotException(metadata.name(), snapshotId, "failed to read shard snapshot file for " + shardId, ex)__            }_        };loads,information,about,shard,snapshot;blob,store,index,shard,snapshot,load,snapshot,try,return,index,shard,snapshot,format,version,read,blob,container,snapshot,id,get,uuid,catch,ioexception,ex,throw,new,snapshot,exception,metadata,name,snapshot,id,failed,to,read,shard,snapshot,file,for,shard,id,ex
BlobStoreRepository -> Context -> BlobStoreIndexShardSnapshot loadSnapshot();1526574077;Loads information about shard snapshot;BlobStoreIndexShardSnapshot loadSnapshot() {_            try {_                return indexShardSnapshotFormat(version).read(blobContainer, snapshotId.getUUID())__            } catch (IOException ex) {_                throw new SnapshotException(metadata.name(), snapshotId, "failed to read shard snapshot file for " + shardId, ex)__            }_        };loads,information,about,shard,snapshot;blob,store,index,shard,snapshot,load,snapshot,try,return,index,shard,snapshot,format,version,read,blob,container,snapshot,id,get,uuid,catch,ioexception,ex,throw,new,snapshot,exception,metadata,name,snapshot,id,failed,to,read,shard,snapshot,file,for,shard,id,ex
BlobStoreRepository -> Context -> BlobStoreIndexShardSnapshot loadSnapshot();1527583663;Loads information about shard snapshot;BlobStoreIndexShardSnapshot loadSnapshot() {_            try {_                return indexShardSnapshotFormat(version).read(blobContainer, snapshotId.getUUID())__            } catch (IOException ex) {_                throw new SnapshotException(metadata.name(), snapshotId, "failed to read shard snapshot file for " + shardId, ex)__            }_        };loads,information,about,shard,snapshot;blob,store,index,shard,snapshot,load,snapshot,try,return,index,shard,snapshot,format,version,read,blob,container,snapshot,id,get,uuid,catch,ioexception,ex,throw,new,snapshot,exception,metadata,name,snapshot,id,failed,to,read,shard,snapshot,file,for,shard,id,ex
BlobStoreRepository -> Context -> BlobStoreIndexShardSnapshot loadSnapshot();1528211342;Loads information about shard snapshot;BlobStoreIndexShardSnapshot loadSnapshot() {_            try {_                return indexShardSnapshotFormat(version).read(blobContainer, snapshotId.getUUID())__            } catch (IOException ex) {_                throw new SnapshotException(metadata.name(), snapshotId, "failed to read shard snapshot file for " + shardId, ex)__            }_        };loads,information,about,shard,snapshot;blob,store,index,shard,snapshot,load,snapshot,try,return,index,shard,snapshot,format,version,read,blob,container,snapshot,id,get,uuid,catch,ioexception,ex,throw,new,snapshot,exception,metadata,name,snapshot,id,failed,to,read,shard,snapshot,file,for,shard,id,ex
BlobStoreRepository -> Context -> BlobStoreIndexShardSnapshot loadSnapshot();1531179852;Loads information about shard snapshot;BlobStoreIndexShardSnapshot loadSnapshot() {_            try {_                return indexShardSnapshotFormat(version).read(blobContainer, snapshotId.getUUID())__            } catch (IOException ex) {_                throw new SnapshotException(metadata.name(), snapshotId, "failed to read shard snapshot file for " + shardId, ex)__            }_        };loads,information,about,shard,snapshot;blob,store,index,shard,snapshot,load,snapshot,try,return,index,shard,snapshot,format,version,read,blob,container,snapshot,id,get,uuid,catch,ioexception,ex,throw,new,snapshot,exception,metadata,name,snapshot,id,failed,to,read,shard,snapshot,file,for,shard,id,ex
BlobStoreRepository -> Context -> BlobStoreIndexShardSnapshot loadSnapshot();1531729807;Loads information about shard snapshot;BlobStoreIndexShardSnapshot loadSnapshot() {_            try {_                return indexShardSnapshotFormat(version).read(blobContainer, snapshotId.getUUID())__            } catch (IOException ex) {_                throw new SnapshotException(metadata.name(), snapshotId, "failed to read shard snapshot file for " + shardId, ex)__            }_        };loads,information,about,shard,snapshot;blob,store,index,shard,snapshot,load,snapshot,try,return,index,shard,snapshot,format,version,read,blob,container,snapshot,id,get,uuid,catch,ioexception,ex,throw,new,snapshot,exception,metadata,name,snapshot,id,failed,to,read,shard,snapshot,file,for,shard,id,ex
BlobStoreRepository -> Context -> BlobStoreIndexShardSnapshot loadSnapshot();1532685069;Loads information about shard snapshot;BlobStoreIndexShardSnapshot loadSnapshot() {_            try {_                return indexShardSnapshotFormat(version).read(blobContainer, snapshotId.getUUID())__            } catch (IOException ex) {_                throw new SnapshotException(metadata.name(), snapshotId, "failed to read shard snapshot file for " + shardId, ex)__            }_        };loads,information,about,shard,snapshot;blob,store,index,shard,snapshot,load,snapshot,try,return,index,shard,snapshot,format,version,read,blob,container,snapshot,id,get,uuid,catch,ioexception,ex,throw,new,snapshot,exception,metadata,name,snapshot,id,failed,to,read,shard,snapshot,file,for,shard,id,ex
BlobStoreRepository -> Context -> BlobStoreIndexShardSnapshot loadSnapshot();1535139672;Loads information about shard snapshot;BlobStoreIndexShardSnapshot loadSnapshot() {_            try {_                return indexShardSnapshotFormat(version).read(blobContainer, snapshotId.getUUID())__            } catch (IOException ex) {_                throw new SnapshotException(metadata.name(), snapshotId, "failed to read shard snapshot file for " + shardId, ex)__            }_        };loads,information,about,shard,snapshot;blob,store,index,shard,snapshot,load,snapshot,try,return,index,shard,snapshot,format,version,read,blob,container,snapshot,id,get,uuid,catch,ioexception,ex,throw,new,snapshot,exception,metadata,name,snapshot,id,failed,to,read,shard,snapshot,file,for,shard,id,ex
BlobStoreRepository -> Context -> BlobStoreIndexShardSnapshot loadSnapshot();1535723122;Loads information about shard snapshot;BlobStoreIndexShardSnapshot loadSnapshot() {_            try {_                return indexShardSnapshotFormat(version).read(blobContainer, snapshotId.getUUID())__            } catch (IOException ex) {_                throw new SnapshotException(metadata.name(), snapshotId, "failed to read shard snapshot file for " + shardId, ex)__            }_        };loads,information,about,shard,snapshot;blob,store,index,shard,snapshot,load,snapshot,try,return,index,shard,snapshot,format,version,read,blob,container,snapshot,id,get,uuid,catch,ioexception,ex,throw,new,snapshot,exception,metadata,name,snapshot,id,failed,to,read,shard,snapshot,file,for,shard,id,ex
BlobStoreRepository -> Context -> BlobStoreIndexShardSnapshot loadSnapshot();1536314350;Loads information about shard snapshot;BlobStoreIndexShardSnapshot loadSnapshot() {_            try {_                return indexShardSnapshotFormat(version).read(blobContainer, snapshotId.getUUID())__            } catch (IOException ex) {_                throw new SnapshotException(metadata.name(), snapshotId, "failed to read shard snapshot file for " + shardId, ex)__            }_        };loads,information,about,shard,snapshot;blob,store,index,shard,snapshot,load,snapshot,try,return,index,shard,snapshot,format,version,read,blob,container,snapshot,id,get,uuid,catch,ioexception,ex,throw,new,snapshot,exception,metadata,name,snapshot,id,failed,to,read,shard,snapshot,file,for,shard,id,ex
BlobStoreRepository -> Context -> BlobStoreIndexShardSnapshot loadSnapshot();1536828374;Loads information about shard snapshot;BlobStoreIndexShardSnapshot loadSnapshot() {_            try {_                return indexShardSnapshotFormat(version).read(blobContainer, snapshotId.getUUID())__            } catch (IOException ex) {_                throw new SnapshotException(metadata.name(), snapshotId, "failed to read shard snapshot file for " + shardId, ex)__            }_        };loads,information,about,shard,snapshot;blob,store,index,shard,snapshot,load,snapshot,try,return,index,shard,snapshot,format,version,read,blob,container,snapshot,id,get,uuid,catch,ioexception,ex,throw,new,snapshot,exception,metadata,name,snapshot,id,failed,to,read,shard,snapshot,file,for,shard,id,ex
BlobStoreRepository -> Context -> BlobStoreIndexShardSnapshot loadSnapshot();1541008027;Loads information about shard snapshot;BlobStoreIndexShardSnapshot loadSnapshot() {_            try {_                return indexShardSnapshotFormat(version).read(blobContainer, snapshotId.getUUID())__            } catch (IOException ex) {_                throw new SnapshotException(metadata.name(), snapshotId, "failed to read shard snapshot file for " + shardId, ex)__            }_        };loads,information,about,shard,snapshot;blob,store,index,shard,snapshot,load,snapshot,try,return,index,shard,snapshot,format,version,read,blob,container,snapshot,id,get,uuid,catch,ioexception,ex,throw,new,snapshot,exception,metadata,name,snapshot,id,failed,to,read,shard,snapshot,file,for,shard,id,ex
BlobStoreRepository -> Context -> BlobStoreIndexShardSnapshot loadSnapshot();1542646292;Loads information about shard snapshot;BlobStoreIndexShardSnapshot loadSnapshot() {_            try {_                return indexShardSnapshotFormat(version).read(blobContainer, snapshotId.getUUID())__            } catch (IOException ex) {_                throw new SnapshotException(metadata.name(), snapshotId, "failed to read shard snapshot file for " + shardId, ex)__            }_        };loads,information,about,shard,snapshot;blob,store,index,shard,snapshot,load,snapshot,try,return,index,shard,snapshot,format,version,read,blob,container,snapshot,id,get,uuid,catch,ioexception,ex,throw,new,snapshot,exception,metadata,name,snapshot,id,failed,to,read,shard,snapshot,file,for,shard,id,ex
BlobStoreRepository -> Context -> BlobStoreIndexShardSnapshot loadSnapshot();1542980705;Loads information about shard snapshot;BlobStoreIndexShardSnapshot loadSnapshot() {_            try {_                return indexShardSnapshotFormat(version).read(blobContainer, snapshotId.getUUID())__            } catch (IOException ex) {_                throw new SnapshotException(metadata.name(), snapshotId, "failed to read shard snapshot file for " + shardId, ex)__            }_        };loads,information,about,shard,snapshot;blob,store,index,shard,snapshot,load,snapshot,try,return,index,shard,snapshot,format,version,read,blob,container,snapshot,id,get,uuid,catch,ioexception,ex,throw,new,snapshot,exception,metadata,name,snapshot,id,failed,to,read,shard,snapshot,file,for,shard,id,ex
BlobStoreRepository -> Context -> BlobStoreIndexShardSnapshot loadSnapshot();1543831870;Loads information about shard snapshot;BlobStoreIndexShardSnapshot loadSnapshot() {_            try {_                return indexShardSnapshotFormat.read(blobContainer, snapshotId.getUUID())__            } catch (IOException ex) {_                throw new SnapshotException(metadata.name(), snapshotId, "failed to read shard snapshot file for " + shardId, ex)__            }_        };loads,information,about,shard,snapshot;blob,store,index,shard,snapshot,load,snapshot,try,return,index,shard,snapshot,format,read,blob,container,snapshot,id,get,uuid,catch,ioexception,ex,throw,new,snapshot,exception,metadata,name,snapshot,id,failed,to,read,shard,snapshot,file,for,shard,id,ex
BlobStoreRepository -> Context -> BlobStoreIndexShardSnapshot loadSnapshot();1543942400;Loads information about shard snapshot;BlobStoreIndexShardSnapshot loadSnapshot() {_            try {_                return indexShardSnapshotFormat.read(blobContainer, snapshotId.getUUID())__            } catch (IOException ex) {_                throw new SnapshotException(metadata.name(), snapshotId, "failed to read shard snapshot file for " + shardId, ex)__            }_        };loads,information,about,shard,snapshot;blob,store,index,shard,snapshot,load,snapshot,try,return,index,shard,snapshot,format,read,blob,container,snapshot,id,get,uuid,catch,ioexception,ex,throw,new,snapshot,exception,metadata,name,snapshot,id,failed,to,read,shard,snapshot,file,for,shard,id,ex
BlobStoreRepository -> Context -> BlobStoreIndexShardSnapshot loadSnapshot();1546974294;Loads information about shard snapshot;BlobStoreIndexShardSnapshot loadSnapshot() {_            try {_                return indexShardSnapshotFormat.read(blobContainer, snapshotId.getUUID())__            } catch (IOException ex) {_                throw new SnapshotException(metadata.name(), snapshotId, "failed to read shard snapshot file for " + shardId, ex)__            }_        };loads,information,about,shard,snapshot;blob,store,index,shard,snapshot,load,snapshot,try,return,index,shard,snapshot,format,read,blob,container,snapshot,id,get,uuid,catch,ioexception,ex,throw,new,snapshot,exception,metadata,name,snapshot,id,failed,to,read,shard,snapshot,file,for,shard,id,ex
BlobStoreRepository -> Context -> BlobStoreIndexShardSnapshot loadSnapshot();1547496475;Loads information about shard snapshot;BlobStoreIndexShardSnapshot loadSnapshot() {_            try {_                return indexShardSnapshotFormat.read(blobContainer, snapshotId.getUUID())__            } catch (IOException ex) {_                throw new SnapshotException(metadata.name(), snapshotId, "failed to read shard snapshot file for " + shardId, ex)__            }_        };loads,information,about,shard,snapshot;blob,store,index,shard,snapshot,load,snapshot,try,return,index,shard,snapshot,format,read,blob,container,snapshot,id,get,uuid,catch,ioexception,ex,throw,new,snapshot,exception,metadata,name,snapshot,id,failed,to,read,shard,snapshot,file,for,shard,id,ex
BlobStoreRepository -> Context -> BlobStoreIndexShardSnapshot loadSnapshot();1547625930;Loads information about shard snapshot;BlobStoreIndexShardSnapshot loadSnapshot() {_            try {_                return indexShardSnapshotFormat.read(blobContainer, snapshotId.getUUID())__            } catch (IOException ex) {_                throw new SnapshotException(metadata.name(), snapshotId, "failed to read shard snapshot file for " + shardId, ex)__            }_        };loads,information,about,shard,snapshot;blob,store,index,shard,snapshot,load,snapshot,try,return,index,shard,snapshot,format,read,blob,container,snapshot,id,get,uuid,catch,ioexception,ex,throw,new,snapshot,exception,metadata,name,snapshot,id,failed,to,read,shard,snapshot,file,for,shard,id,ex
BlobStoreRepository -> Context -> BlobStoreIndexShardSnapshot loadSnapshot();1550647627;Loads information about shard snapshot;BlobStoreIndexShardSnapshot loadSnapshot() {_            try {_                return indexShardSnapshotFormat.read(blobContainer, snapshotId.getUUID())__            } catch (IOException ex) {_                throw new SnapshotException(metadata.name(), snapshotId, "failed to read shard snapshot file for " + shardId, ex)__            }_        };loads,information,about,shard,snapshot;blob,store,index,shard,snapshot,load,snapshot,try,return,index,shard,snapshot,format,read,blob,container,snapshot,id,get,uuid,catch,ioexception,ex,throw,new,snapshot,exception,metadata,name,snapshot,id,failed,to,read,shard,snapshot,file,for,shard,id,ex
BlobStoreRepository -> private void delete(SnapshotId snapshotId, Version version, IndexId indexId, ShardId shardId);1524684173;Delete shard snapshot__@param snapshotId snapshot id_@param shardId    shard id;private void delete(SnapshotId snapshotId, Version version, IndexId indexId, ShardId shardId) {_        Context context = new Context(snapshotId, version, indexId, shardId, shardId)__        context.delete()__    };delete,shard,snapshot,param,snapshot,id,snapshot,id,param,shard,id,shard,id;private,void,delete,snapshot,id,snapshot,id,version,version,index,id,index,id,shard,id,shard,id,context,context,new,context,snapshot,id,version,index,id,shard,id,shard,id,context,delete
BlobStoreRepository -> private void delete(SnapshotId snapshotId, Version version, IndexId indexId, ShardId shardId);1525334055;Delete shard snapshot__@param snapshotId snapshot id_@param shardId    shard id;private void delete(SnapshotId snapshotId, Version version, IndexId indexId, ShardId shardId) {_        Context context = new Context(snapshotId, version, indexId, shardId, shardId)__        context.delete()__    };delete,shard,snapshot,param,snapshot,id,snapshot,id,param,shard,id,shard,id;private,void,delete,snapshot,id,snapshot,id,version,version,index,id,index,id,shard,id,shard,id,context,context,new,context,snapshot,id,version,index,id,shard,id,shard,id,context,delete
BlobStoreRepository -> private void delete(SnapshotId snapshotId, Version version, IndexId indexId, ShardId shardId);1525798020;Delete shard snapshot__@param snapshotId snapshot id_@param shardId    shard id;private void delete(SnapshotId snapshotId, Version version, IndexId indexId, ShardId shardId) {_        Context context = new Context(snapshotId, version, indexId, shardId, shardId)__        context.delete()__    };delete,shard,snapshot,param,snapshot,id,snapshot,id,param,shard,id,shard,id;private,void,delete,snapshot,id,snapshot,id,version,version,index,id,index,id,shard,id,shard,id,context,context,new,context,snapshot,id,version,index,id,shard,id,shard,id,context,delete
BlobStoreRepository -> private void delete(SnapshotId snapshotId, Version version, IndexId indexId, ShardId shardId);1526289033;Delete shard snapshot__@param snapshotId snapshot id_@param shardId    shard id;private void delete(SnapshotId snapshotId, Version version, IndexId indexId, ShardId shardId) {_        Context context = new Context(snapshotId, version, indexId, shardId, shardId)__        context.delete()__    };delete,shard,snapshot,param,snapshot,id,snapshot,id,param,shard,id,shard,id;private,void,delete,snapshot,id,snapshot,id,version,version,index,id,index,id,shard,id,shard,id,context,context,new,context,snapshot,id,version,index,id,shard,id,shard,id,context,delete
BlobStoreRepository -> private void delete(SnapshotId snapshotId, Version version, IndexId indexId, ShardId shardId);1526574077;Delete shard snapshot__@param snapshotId snapshot id_@param shardId    shard id;private void delete(SnapshotId snapshotId, Version version, IndexId indexId, ShardId shardId) {_        Context context = new Context(snapshotId, version, indexId, shardId, shardId)__        context.delete()__    };delete,shard,snapshot,param,snapshot,id,snapshot,id,param,shard,id,shard,id;private,void,delete,snapshot,id,snapshot,id,version,version,index,id,index,id,shard,id,shard,id,context,context,new,context,snapshot,id,version,index,id,shard,id,shard,id,context,delete
BlobStoreRepository -> private void delete(SnapshotId snapshotId, Version version, IndexId indexId, ShardId shardId);1527583663;Delete shard snapshot__@param snapshotId snapshot id_@param shardId    shard id;private void delete(SnapshotId snapshotId, Version version, IndexId indexId, ShardId shardId) {_        Context context = new Context(snapshotId, version, indexId, shardId, shardId)__        context.delete()__    };delete,shard,snapshot,param,snapshot,id,snapshot,id,param,shard,id,shard,id;private,void,delete,snapshot,id,snapshot,id,version,version,index,id,index,id,shard,id,shard,id,context,context,new,context,snapshot,id,version,index,id,shard,id,shard,id,context,delete
BlobStoreRepository -> private void delete(SnapshotId snapshotId, Version version, IndexId indexId, ShardId shardId);1528211342;Delete shard snapshot__@param snapshotId snapshot id_@param shardId    shard id;private void delete(SnapshotId snapshotId, Version version, IndexId indexId, ShardId shardId) {_        Context context = new Context(snapshotId, version, indexId, shardId, shardId)__        context.delete()__    };delete,shard,snapshot,param,snapshot,id,snapshot,id,param,shard,id,shard,id;private,void,delete,snapshot,id,snapshot,id,version,version,index,id,index,id,shard,id,shard,id,context,context,new,context,snapshot,id,version,index,id,shard,id,shard,id,context,delete
BlobStoreRepository -> private void delete(SnapshotId snapshotId, Version version, IndexId indexId, ShardId shardId);1531179852;Delete shard snapshot__@param snapshotId snapshot id_@param shardId    shard id;private void delete(SnapshotId snapshotId, Version version, IndexId indexId, ShardId shardId) {_        Context context = new Context(snapshotId, version, indexId, shardId, shardId)__        context.delete()__    };delete,shard,snapshot,param,snapshot,id,snapshot,id,param,shard,id,shard,id;private,void,delete,snapshot,id,snapshot,id,version,version,index,id,index,id,shard,id,shard,id,context,context,new,context,snapshot,id,version,index,id,shard,id,shard,id,context,delete
BlobStoreRepository -> private void delete(SnapshotId snapshotId, Version version, IndexId indexId, ShardId shardId);1531729807;Delete shard snapshot__@param snapshotId snapshot id_@param shardId    shard id;private void delete(SnapshotId snapshotId, Version version, IndexId indexId, ShardId shardId) {_        Context context = new Context(snapshotId, version, indexId, shardId, shardId)__        context.delete()__    };delete,shard,snapshot,param,snapshot,id,snapshot,id,param,shard,id,shard,id;private,void,delete,snapshot,id,snapshot,id,version,version,index,id,index,id,shard,id,shard,id,context,context,new,context,snapshot,id,version,index,id,shard,id,shard,id,context,delete
BlobStoreRepository -> private void delete(SnapshotId snapshotId, Version version, IndexId indexId, ShardId shardId);1532685069;Delete shard snapshot__@param snapshotId snapshot id_@param shardId    shard id;private void delete(SnapshotId snapshotId, Version version, IndexId indexId, ShardId shardId) {_        Context context = new Context(snapshotId, version, indexId, shardId, shardId)__        context.delete()__    };delete,shard,snapshot,param,snapshot,id,snapshot,id,param,shard,id,shard,id;private,void,delete,snapshot,id,snapshot,id,version,version,index,id,index,id,shard,id,shard,id,context,context,new,context,snapshot,id,version,index,id,shard,id,shard,id,context,delete
BlobStoreRepository -> private void delete(SnapshotId snapshotId, Version version, IndexId indexId, ShardId shardId);1535139672;Delete shard snapshot__@param snapshotId snapshot id_@param shardId    shard id;private void delete(SnapshotId snapshotId, Version version, IndexId indexId, ShardId shardId) {_        Context context = new Context(snapshotId, version, indexId, shardId, shardId)__        context.delete()__    };delete,shard,snapshot,param,snapshot,id,snapshot,id,param,shard,id,shard,id;private,void,delete,snapshot,id,snapshot,id,version,version,index,id,index,id,shard,id,shard,id,context,context,new,context,snapshot,id,version,index,id,shard,id,shard,id,context,delete
BlobStoreRepository -> private void delete(SnapshotId snapshotId, Version version, IndexId indexId, ShardId shardId);1535723122;Delete shard snapshot__@param snapshotId snapshot id_@param shardId    shard id;private void delete(SnapshotId snapshotId, Version version, IndexId indexId, ShardId shardId) {_        Context context = new Context(snapshotId, version, indexId, shardId, shardId)__        context.delete()__    };delete,shard,snapshot,param,snapshot,id,snapshot,id,param,shard,id,shard,id;private,void,delete,snapshot,id,snapshot,id,version,version,index,id,index,id,shard,id,shard,id,context,context,new,context,snapshot,id,version,index,id,shard,id,shard,id,context,delete
BlobStoreRepository -> private void delete(SnapshotId snapshotId, Version version, IndexId indexId, ShardId shardId);1536314350;Delete shard snapshot__@param snapshotId snapshot id_@param shardId    shard id;private void delete(SnapshotId snapshotId, Version version, IndexId indexId, ShardId shardId) {_        Context context = new Context(snapshotId, version, indexId, shardId, shardId)__        context.delete()__    };delete,shard,snapshot,param,snapshot,id,snapshot,id,param,shard,id,shard,id;private,void,delete,snapshot,id,snapshot,id,version,version,index,id,index,id,shard,id,shard,id,context,context,new,context,snapshot,id,version,index,id,shard,id,shard,id,context,delete
BlobStoreRepository -> private void delete(SnapshotId snapshotId, Version version, IndexId indexId, ShardId shardId);1536828374;Delete shard snapshot__@param snapshotId snapshot id_@param shardId    shard id;private void delete(SnapshotId snapshotId, Version version, IndexId indexId, ShardId shardId) {_        Context context = new Context(snapshotId, version, indexId, shardId, shardId)__        context.delete()__    };delete,shard,snapshot,param,snapshot,id,snapshot,id,param,shard,id,shard,id;private,void,delete,snapshot,id,snapshot,id,version,version,index,id,index,id,shard,id,shard,id,context,context,new,context,snapshot,id,version,index,id,shard,id,shard,id,context,delete
BlobStoreRepository -> private void delete(SnapshotId snapshotId, Version version, IndexId indexId, ShardId shardId);1541008027;Delete shard snapshot__@param snapshotId snapshot id_@param shardId    shard id;private void delete(SnapshotId snapshotId, Version version, IndexId indexId, ShardId shardId) {_        Context context = new Context(snapshotId, version, indexId, shardId, shardId)__        context.delete()__    };delete,shard,snapshot,param,snapshot,id,snapshot,id,param,shard,id,shard,id;private,void,delete,snapshot,id,snapshot,id,version,version,index,id,index,id,shard,id,shard,id,context,context,new,context,snapshot,id,version,index,id,shard,id,shard,id,context,delete
BlobStoreRepository -> private void delete(SnapshotId snapshotId, Version version, IndexId indexId, ShardId shardId);1542646292;Delete shard snapshot__@param snapshotId snapshot id_@param shardId    shard id;private void delete(SnapshotId snapshotId, Version version, IndexId indexId, ShardId shardId) {_        Context context = new Context(snapshotId, version, indexId, shardId, shardId)__        context.delete()__    };delete,shard,snapshot,param,snapshot,id,snapshot,id,param,shard,id,shard,id;private,void,delete,snapshot,id,snapshot,id,version,version,index,id,index,id,shard,id,shard,id,context,context,new,context,snapshot,id,version,index,id,shard,id,shard,id,context,delete
BlobStoreRepository -> private void delete(SnapshotId snapshotId, Version version, IndexId indexId, ShardId shardId);1542980705;Delete shard snapshot__@param snapshotId snapshot id_@param shardId    shard id;private void delete(SnapshotId snapshotId, Version version, IndexId indexId, ShardId shardId) {_        Context context = new Context(snapshotId, version, indexId, shardId, shardId)__        context.delete()__    };delete,shard,snapshot,param,snapshot,id,snapshot,id,param,shard,id,shard,id;private,void,delete,snapshot,id,snapshot,id,version,version,index,id,index,id,shard,id,shard,id,context,context,new,context,snapshot,id,version,index,id,shard,id,shard,id,context,delete
BlobStoreRepository -> protected BlobContainer blobContainer();1531729807;maintains single lazy instance of {@link BlobContainer};protected BlobContainer blobContainer() {_        assertSnapshotOrGenericThread()___        BlobContainer blobContainer = this.blobContainer.get()__        if (blobContainer == null) {_           synchronized (lock) {_               blobContainer = this.blobContainer.get()__               if (blobContainer == null) {_                   blobContainer = blobStore().blobContainer(basePath())__                   this.blobContainer.set(blobContainer)__               }_           }_        }__        return blobContainer__    };maintains,single,lazy,instance,of,link,blob,container;protected,blob,container,blob,container,assert,snapshot,or,generic,thread,blob,container,blob,container,this,blob,container,get,if,blob,container,null,synchronized,lock,blob,container,this,blob,container,get,if,blob,container,null,blob,container,blob,store,blob,container,base,path,this,blob,container,set,blob,container,return,blob,container
BlobStoreRepository -> protected BlobContainer blobContainer();1532685069;maintains single lazy instance of {@link BlobContainer};protected BlobContainer blobContainer() {_        assertSnapshotOrGenericThread()___        BlobContainer blobContainer = this.blobContainer.get()__        if (blobContainer == null) {_           synchronized (lock) {_               blobContainer = this.blobContainer.get()__               if (blobContainer == null) {_                   blobContainer = blobStore().blobContainer(basePath())__                   this.blobContainer.set(blobContainer)__               }_           }_        }__        return blobContainer__    };maintains,single,lazy,instance,of,link,blob,container;protected,blob,container,blob,container,assert,snapshot,or,generic,thread,blob,container,blob,container,this,blob,container,get,if,blob,container,null,synchronized,lock,blob,container,this,blob,container,get,if,blob,container,null,blob,container,blob,store,blob,container,base,path,this,blob,container,set,blob,container,return,blob,container
BlobStoreRepository -> protected BlobContainer blobContainer();1535139672;maintains single lazy instance of {@link BlobContainer};protected BlobContainer blobContainer() {_        assertSnapshotOrGenericThread()___        BlobContainer blobContainer = this.blobContainer.get()__        if (blobContainer == null) {_           synchronized (lock) {_               blobContainer = this.blobContainer.get()__               if (blobContainer == null) {_                   blobContainer = blobStore().blobContainer(basePath())__                   this.blobContainer.set(blobContainer)__               }_           }_        }__        return blobContainer__    };maintains,single,lazy,instance,of,link,blob,container;protected,blob,container,blob,container,assert,snapshot,or,generic,thread,blob,container,blob,container,this,blob,container,get,if,blob,container,null,synchronized,lock,blob,container,this,blob,container,get,if,blob,container,null,blob,container,blob,store,blob,container,base,path,this,blob,container,set,blob,container,return,blob,container
BlobStoreRepository -> protected BlobContainer blobContainer();1535723122;maintains single lazy instance of {@link BlobContainer};protected BlobContainer blobContainer() {_        assertSnapshotOrGenericThread()___        BlobContainer blobContainer = this.blobContainer.get()__        if (blobContainer == null) {_           synchronized (lock) {_               blobContainer = this.blobContainer.get()__               if (blobContainer == null) {_                   blobContainer = blobStore().blobContainer(basePath())__                   this.blobContainer.set(blobContainer)__               }_           }_        }__        return blobContainer__    };maintains,single,lazy,instance,of,link,blob,container;protected,blob,container,blob,container,assert,snapshot,or,generic,thread,blob,container,blob,container,this,blob,container,get,if,blob,container,null,synchronized,lock,blob,container,this,blob,container,get,if,blob,container,null,blob,container,blob,store,blob,container,base,path,this,blob,container,set,blob,container,return,blob,container
BlobStoreRepository -> protected BlobContainer blobContainer();1536314350;maintains single lazy instance of {@link BlobContainer};protected BlobContainer blobContainer() {_        assertSnapshotOrGenericThread()___        BlobContainer blobContainer = this.blobContainer.get()__        if (blobContainer == null) {_           synchronized (lock) {_               blobContainer = this.blobContainer.get()__               if (blobContainer == null) {_                   blobContainer = blobStore().blobContainer(basePath())__                   this.blobContainer.set(blobContainer)__               }_           }_        }__        return blobContainer__    };maintains,single,lazy,instance,of,link,blob,container;protected,blob,container,blob,container,assert,snapshot,or,generic,thread,blob,container,blob,container,this,blob,container,get,if,blob,container,null,synchronized,lock,blob,container,this,blob,container,get,if,blob,container,null,blob,container,blob,store,blob,container,base,path,this,blob,container,set,blob,container,return,blob,container
BlobStoreRepository -> protected BlobContainer blobContainer();1536828374;maintains single lazy instance of {@link BlobContainer};protected BlobContainer blobContainer() {_        assertSnapshotOrGenericThread()___        BlobContainer blobContainer = this.blobContainer.get()__        if (blobContainer == null) {_           synchronized (lock) {_               blobContainer = this.blobContainer.get()__               if (blobContainer == null) {_                   blobContainer = blobStore().blobContainer(basePath())__                   this.blobContainer.set(blobContainer)__               }_           }_        }__        return blobContainer__    };maintains,single,lazy,instance,of,link,blob,container;protected,blob,container,blob,container,assert,snapshot,or,generic,thread,blob,container,blob,container,this,blob,container,get,if,blob,container,null,synchronized,lock,blob,container,this,blob,container,get,if,blob,container,null,blob,container,blob,store,blob,container,base,path,this,blob,container,set,blob,container,return,blob,container
BlobStoreRepository -> protected BlobContainer blobContainer();1541008027;maintains single lazy instance of {@link BlobContainer};protected BlobContainer blobContainer() {_        assertSnapshotOrGenericThread()___        BlobContainer blobContainer = this.blobContainer.get()__        if (blobContainer == null) {_           synchronized (lock) {_               blobContainer = this.blobContainer.get()__               if (blobContainer == null) {_                   blobContainer = blobStore().blobContainer(basePath())__                   this.blobContainer.set(blobContainer)__               }_           }_        }__        return blobContainer__    };maintains,single,lazy,instance,of,link,blob,container;protected,blob,container,blob,container,assert,snapshot,or,generic,thread,blob,container,blob,container,this,blob,container,get,if,blob,container,null,synchronized,lock,blob,container,this,blob,container,get,if,blob,container,null,blob,container,blob,store,blob,container,base,path,this,blob,container,set,blob,container,return,blob,container
BlobStoreRepository -> protected BlobContainer blobContainer();1542646292;maintains single lazy instance of {@link BlobContainer};protected BlobContainer blobContainer() {_        assertSnapshotOrGenericThread()___        BlobContainer blobContainer = this.blobContainer.get()__        if (blobContainer == null) {_           synchronized (lock) {_               blobContainer = this.blobContainer.get()__               if (blobContainer == null) {_                   blobContainer = blobStore().blobContainer(basePath())__                   this.blobContainer.set(blobContainer)__               }_           }_        }__        return blobContainer__    };maintains,single,lazy,instance,of,link,blob,container;protected,blob,container,blob,container,assert,snapshot,or,generic,thread,blob,container,blob,container,this,blob,container,get,if,blob,container,null,synchronized,lock,blob,container,this,blob,container,get,if,blob,container,null,blob,container,blob,store,blob,container,base,path,this,blob,container,set,blob,container,return,blob,container
BlobStoreRepository -> protected BlobContainer blobContainer();1542980705;maintains single lazy instance of {@link BlobContainer};protected BlobContainer blobContainer() {_        assertSnapshotOrGenericThread()___        BlobContainer blobContainer = this.blobContainer.get()__        if (blobContainer == null) {_           synchronized (lock) {_               blobContainer = this.blobContainer.get()__               if (blobContainer == null) {_                   blobContainer = blobStore().blobContainer(basePath())__                   this.blobContainer.set(blobContainer)__               }_           }_        }__        return blobContainer__    };maintains,single,lazy,instance,of,link,blob,container;protected,blob,container,blob,container,assert,snapshot,or,generic,thread,blob,container,blob,container,this,blob,container,get,if,blob,container,null,synchronized,lock,blob,container,this,blob,container,get,if,blob,container,null,blob,container,blob,store,blob,container,base,path,this,blob,container,set,blob,container,return,blob,container
BlobStoreRepository -> protected BlobContainer blobContainer();1543831870;maintains single lazy instance of {@link BlobContainer};protected BlobContainer blobContainer() {_        assertSnapshotOrGenericThread()___        BlobContainer blobContainer = this.blobContainer.get()__        if (blobContainer == null) {_           synchronized (lock) {_               blobContainer = this.blobContainer.get()__               if (blobContainer == null) {_                   blobContainer = blobStore().blobContainer(basePath())__                   this.blobContainer.set(blobContainer)__               }_           }_        }__        return blobContainer__    };maintains,single,lazy,instance,of,link,blob,container;protected,blob,container,blob,container,assert,snapshot,or,generic,thread,blob,container,blob,container,this,blob,container,get,if,blob,container,null,synchronized,lock,blob,container,this,blob,container,get,if,blob,container,null,blob,container,blob,store,blob,container,base,path,this,blob,container,set,blob,container,return,blob,container
BlobStoreRepository -> protected BlobContainer blobContainer();1543942400;maintains single lazy instance of {@link BlobContainer};protected BlobContainer blobContainer() {_        assertSnapshotOrGenericThread()___        BlobContainer blobContainer = this.blobContainer.get()__        if (blobContainer == null) {_           synchronized (lock) {_               blobContainer = this.blobContainer.get()__               if (blobContainer == null) {_                   blobContainer = blobStore().blobContainer(basePath())__                   this.blobContainer.set(blobContainer)__               }_           }_        }__        return blobContainer__    };maintains,single,lazy,instance,of,link,blob,container;protected,blob,container,blob,container,assert,snapshot,or,generic,thread,blob,container,blob,container,this,blob,container,get,if,blob,container,null,synchronized,lock,blob,container,this,blob,container,get,if,blob,container,null,blob,container,blob,store,blob,container,base,path,this,blob,container,set,blob,container,return,blob,container
BlobStoreRepository -> protected BlobContainer blobContainer();1546974294;maintains single lazy instance of {@link BlobContainer};protected BlobContainer blobContainer() {_        assertSnapshotOrGenericThread()___        BlobContainer blobContainer = this.blobContainer.get()__        if (blobContainer == null) {_           synchronized (lock) {_               blobContainer = this.blobContainer.get()__               if (blobContainer == null) {_                   blobContainer = blobStore().blobContainer(basePath())__                   this.blobContainer.set(blobContainer)__               }_           }_        }__        return blobContainer__    };maintains,single,lazy,instance,of,link,blob,container;protected,blob,container,blob,container,assert,snapshot,or,generic,thread,blob,container,blob,container,this,blob,container,get,if,blob,container,null,synchronized,lock,blob,container,this,blob,container,get,if,blob,container,null,blob,container,blob,store,blob,container,base,path,this,blob,container,set,blob,container,return,blob,container
BlobStoreRepository -> protected BlobContainer blobContainer();1547496475;maintains single lazy instance of {@link BlobContainer};protected BlobContainer blobContainer() {_        assertSnapshotOrGenericThread()___        BlobContainer blobContainer = this.blobContainer.get()__        if (blobContainer == null) {_           synchronized (lock) {_               blobContainer = this.blobContainer.get()__               if (blobContainer == null) {_                   blobContainer = blobStore().blobContainer(basePath())__                   this.blobContainer.set(blobContainer)__               }_           }_        }__        return blobContainer__    };maintains,single,lazy,instance,of,link,blob,container;protected,blob,container,blob,container,assert,snapshot,or,generic,thread,blob,container,blob,container,this,blob,container,get,if,blob,container,null,synchronized,lock,blob,container,this,blob,container,get,if,blob,container,null,blob,container,blob,store,blob,container,base,path,this,blob,container,set,blob,container,return,blob,container
BlobStoreRepository -> protected BlobContainer blobContainer();1547625930;maintains single lazy instance of {@link BlobContainer};protected BlobContainer blobContainer() {_        assertSnapshotOrGenericThread()___        BlobContainer blobContainer = this.blobContainer.get()__        if (blobContainer == null) {_           synchronized (lock) {_               blobContainer = this.blobContainer.get()__               if (blobContainer == null) {_                   blobContainer = blobStore().blobContainer(basePath())__                   this.blobContainer.set(blobContainer)__               }_           }_        }__        return blobContainer__    };maintains,single,lazy,instance,of,link,blob,container;protected,blob,container,blob,container,assert,snapshot,or,generic,thread,blob,container,blob,container,this,blob,container,get,if,blob,container,null,synchronized,lock,blob,container,this,blob,container,get,if,blob,container,null,blob,container,blob,store,blob,container,base,path,this,blob,container,set,blob,container,return,blob,container
BlobStoreRepository -> protected BlobContainer blobContainer();1550647627;maintains single lazy instance of {@link BlobContainer};protected BlobContainer blobContainer() {_        assertSnapshotOrGenericThread()___        BlobContainer blobContainer = this.blobContainer.get()__        if (blobContainer == null) {_           synchronized (lock) {_               blobContainer = this.blobContainer.get()__               if (blobContainer == null) {_                   blobContainer = blobStore().blobContainer(basePath())__                   this.blobContainer.set(blobContainer)__               }_           }_        }__        return blobContainer__    };maintains,single,lazy,instance,of,link,blob,container;protected,blob,container,blob,container,assert,snapshot,or,generic,thread,blob,container,blob,container,this,blob,container,get,if,blob,container,null,synchronized,lock,blob,container,this,blob,container,get,if,blob,container,null,blob,container,blob,store,blob,container,base,path,this,blob,container,set,blob,container,return,blob,container
BlobStoreRepository -> protected abstract BlobStore createBlobStore() throws Exception_;1531729807;Creates new BlobStore to read and write data.;protected abstract BlobStore createBlobStore() throws Exception_;creates,new,blob,store,to,read,and,write,data;protected,abstract,blob,store,create,blob,store,throws,exception
BlobStoreRepository -> protected abstract BlobStore createBlobStore() throws Exception_;1532685069;Creates new BlobStore to read and write data.;protected abstract BlobStore createBlobStore() throws Exception_;creates,new,blob,store,to,read,and,write,data;protected,abstract,blob,store,create,blob,store,throws,exception
BlobStoreRepository -> protected abstract BlobStore createBlobStore() throws Exception_;1535139672;Creates new BlobStore to read and write data.;protected abstract BlobStore createBlobStore() throws Exception_;creates,new,blob,store,to,read,and,write,data;protected,abstract,blob,store,create,blob,store,throws,exception
BlobStoreRepository -> protected abstract BlobStore createBlobStore() throws Exception_;1535723122;Creates new BlobStore to read and write data.;protected abstract BlobStore createBlobStore() throws Exception_;creates,new,blob,store,to,read,and,write,data;protected,abstract,blob,store,create,blob,store,throws,exception
BlobStoreRepository -> protected abstract BlobStore createBlobStore() throws Exception_;1536314350;Creates new BlobStore to read and write data.;protected abstract BlobStore createBlobStore() throws Exception_;creates,new,blob,store,to,read,and,write,data;protected,abstract,blob,store,create,blob,store,throws,exception
BlobStoreRepository -> protected abstract BlobStore createBlobStore() throws Exception_;1536828374;Creates new BlobStore to read and write data.;protected abstract BlobStore createBlobStore() throws Exception_;creates,new,blob,store,to,read,and,write,data;protected,abstract,blob,store,create,blob,store,throws,exception
BlobStoreRepository -> protected abstract BlobStore createBlobStore() throws Exception_;1541008027;Creates new BlobStore to read and write data.;protected abstract BlobStore createBlobStore() throws Exception_;creates,new,blob,store,to,read,and,write,data;protected,abstract,blob,store,create,blob,store,throws,exception
BlobStoreRepository -> protected abstract BlobStore createBlobStore() throws Exception_;1542646292;Creates new BlobStore to read and write data.;protected abstract BlobStore createBlobStore() throws Exception_;creates,new,blob,store,to,read,and,write,data;protected,abstract,blob,store,create,blob,store,throws,exception
BlobStoreRepository -> protected abstract BlobStore createBlobStore() throws Exception_;1542980705;Creates new BlobStore to read and write data.;protected abstract BlobStore createBlobStore() throws Exception_;creates,new,blob,store,to,read,and,write,data;protected,abstract,blob,store,create,blob,store,throws,exception
BlobStoreRepository -> protected abstract BlobStore createBlobStore() throws Exception_;1543831870;Creates new BlobStore to read and write data.;protected abstract BlobStore createBlobStore() throws Exception_;creates,new,blob,store,to,read,and,write,data;protected,abstract,blob,store,create,blob,store,throws,exception
BlobStoreRepository -> protected abstract BlobStore createBlobStore() throws Exception_;1543942400;Creates new BlobStore to read and write data.;protected abstract BlobStore createBlobStore() throws Exception_;creates,new,blob,store,to,read,and,write,data;protected,abstract,blob,store,create,blob,store,throws,exception
BlobStoreRepository -> protected abstract BlobStore createBlobStore() throws Exception_;1546974294;Creates new BlobStore to read and write data.;protected abstract BlobStore createBlobStore() throws Exception_;creates,new,blob,store,to,read,and,write,data;protected,abstract,blob,store,create,blob,store,throws,exception
BlobStoreRepository -> protected abstract BlobStore createBlobStore() throws Exception_;1547496475;Creates new BlobStore to read and write data.;protected abstract BlobStore createBlobStore() throws Exception_;creates,new,blob,store,to,read,and,write,data;protected,abstract,blob,store,create,blob,store,throws,exception
BlobStoreRepository -> protected abstract BlobStore createBlobStore() throws Exception_;1547625930;Creates new BlobStore to read and write data.;protected abstract BlobStore createBlobStore() throws Exception_;creates,new,blob,store,to,read,and,write,data;protected,abstract,blob,store,create,blob,store,throws,exception
BlobStoreRepository -> protected abstract BlobStore createBlobStore() throws Exception_;1550647627;Creates new BlobStore to read and write data.;protected abstract BlobStore createBlobStore() throws Exception_;creates,new,blob,store,to,read,and,write,data;protected,abstract,blob,store,create,blob,store,throws,exception
BlobStoreRepository -> Context -> protected void finalize(final List<SnapshotFiles> snapshots,                                 final int fileListGeneration,                                 final Map<String, BlobMetaData> blobs,                                 final String reason);1525798020;Writes a new index file for the shard and removes all unreferenced files from the repository.__We need to be really careful in handling index files in case of failures to make sure we don't_have index file that points to files that were deleted.__@param snapshots          list of active snapshots in the container_@param fileListGeneration the generation number of the snapshot index file_@param blobs              list of blobs in the container_@param reason             a reason explaining why the shard index file is written;protected void finalize(final List<SnapshotFiles> snapshots,_                                final int fileListGeneration,_                                final Map<String, BlobMetaData> blobs,_                                final String reason) {_            final String indexGeneration = Integer.toString(fileListGeneration)__            final String currentIndexGen = indexShardSnapshotsFormat.blobName(indexGeneration)___            final BlobStoreIndexShardSnapshots updatedSnapshots = new BlobStoreIndexShardSnapshots(snapshots)__            try {_                _                if (snapshots.size() > 0) {_                    indexShardSnapshotsFormat.writeAtomic(updatedSnapshots, blobContainer, indexGeneration)__                }__                _                for (final String blobName : blobs.keySet()) {_                    if (indexShardSnapshotsFormat.isTempBlobName(blobName) || blobName.startsWith(SNAPSHOT_INDEX_PREFIX)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete index blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                            throw e__                        }_                    }_                }__                _                for (final String blobName : blobs.keySet()) {_                    if (blobName.startsWith(DATA_BLOB_PREFIX) && (updatedSnapshots.findNameFile(canonicalName(blobName)) == null)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete data blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                        }_                    }_                }_            } catch (IOException e) {_                String message = "Failed to finalize " + reason + " with shard index [" + currentIndexGen + "]"__                throw new IndexShardSnapshotFailedException(shardId, message, e)__            }_        };writes,a,new,index,file,for,the,shard,and,removes,all,unreferenced,files,from,the,repository,we,need,to,be,really,careful,in,handling,index,files,in,case,of,failures,to,make,sure,we,don,t,have,index,file,that,points,to,files,that,were,deleted,param,snapshots,list,of,active,snapshots,in,the,container,param,file,list,generation,the,generation,number,of,the,snapshot,index,file,param,blobs,list,of,blobs,in,the,container,param,reason,a,reason,explaining,why,the,shard,index,file,is,written;protected,void,finalize,final,list,snapshot,files,snapshots,final,int,file,list,generation,final,map,string,blob,meta,data,blobs,final,string,reason,final,string,index,generation,integer,to,string,file,list,generation,final,string,current,index,gen,index,shard,snapshots,format,blob,name,index,generation,final,blob,store,index,shard,snapshots,updated,snapshots,new,blob,store,index,shard,snapshots,snapshots,try,if,snapshots,size,0,index,shard,snapshots,format,write,atomic,updated,snapshots,blob,container,index,generation,for,final,string,blob,name,blobs,key,set,if,index,shard,snapshots,format,is,temp,blob,name,blob,name,blob,name,starts,with,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,index,blob,during,finalization,snapshot,id,shard,id,blob,name,e,throw,e,for,final,string,blob,name,blobs,key,set,if,blob,name,starts,with,updated,snapshots,find,name,file,canonical,name,blob,name,null,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,data,blob,during,finalization,snapshot,id,shard,id,blob,name,e,catch,ioexception,e,string,message,failed,to,finalize,reason,with,shard,index,current,index,gen,throw,new,index,shard,snapshot,failed,exception,shard,id,message,e
BlobStoreRepository -> Context -> protected void finalize(final List<SnapshotFiles> snapshots,                                 final int fileListGeneration,                                 final Map<String, BlobMetaData> blobs,                                 final String reason);1526289033;Writes a new index file for the shard and removes all unreferenced files from the repository.__We need to be really careful in handling index files in case of failures to make sure we don't_have index file that points to files that were deleted.__@param snapshots          list of active snapshots in the container_@param fileListGeneration the generation number of the snapshot index file_@param blobs              list of blobs in the container_@param reason             a reason explaining why the shard index file is written;protected void finalize(final List<SnapshotFiles> snapshots,_                                final int fileListGeneration,_                                final Map<String, BlobMetaData> blobs,_                                final String reason) {_            final String indexGeneration = Integer.toString(fileListGeneration)__            final String currentIndexGen = indexShardSnapshotsFormat.blobName(indexGeneration)___            final BlobStoreIndexShardSnapshots updatedSnapshots = new BlobStoreIndexShardSnapshots(snapshots)__            try {_                _                _                for (final String blobName : blobs.keySet()) {_                    if (indexShardSnapshotsFormat.isTempBlobName(blobName)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete index blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                            throw e__                        }_                    }_                }__                _                if (snapshots.size() > 0) {_                    indexShardSnapshotsFormat.writeAtomic(updatedSnapshots, blobContainer, indexGeneration)__                }__                _                for (final String blobName : blobs.keySet()) {_                    if (blobName.startsWith(SNAPSHOT_INDEX_PREFIX)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete index blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                            throw e__                        }_                    }_                }__                _                for (final String blobName : blobs.keySet()) {_                    if (blobName.startsWith(DATA_BLOB_PREFIX) && (updatedSnapshots.findNameFile(canonicalName(blobName)) == null)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete data blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                        }_                    }_                }_            } catch (IOException e) {_                String message = "Failed to finalize " + reason + " with shard index [" + currentIndexGen + "]"__                throw new IndexShardSnapshotFailedException(shardId, message, e)__            }_        };writes,a,new,index,file,for,the,shard,and,removes,all,unreferenced,files,from,the,repository,we,need,to,be,really,careful,in,handling,index,files,in,case,of,failures,to,make,sure,we,don,t,have,index,file,that,points,to,files,that,were,deleted,param,snapshots,list,of,active,snapshots,in,the,container,param,file,list,generation,the,generation,number,of,the,snapshot,index,file,param,blobs,list,of,blobs,in,the,container,param,reason,a,reason,explaining,why,the,shard,index,file,is,written;protected,void,finalize,final,list,snapshot,files,snapshots,final,int,file,list,generation,final,map,string,blob,meta,data,blobs,final,string,reason,final,string,index,generation,integer,to,string,file,list,generation,final,string,current,index,gen,index,shard,snapshots,format,blob,name,index,generation,final,blob,store,index,shard,snapshots,updated,snapshots,new,blob,store,index,shard,snapshots,snapshots,try,for,final,string,blob,name,blobs,key,set,if,index,shard,snapshots,format,is,temp,blob,name,blob,name,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,index,blob,during,finalization,snapshot,id,shard,id,blob,name,e,throw,e,if,snapshots,size,0,index,shard,snapshots,format,write,atomic,updated,snapshots,blob,container,index,generation,for,final,string,blob,name,blobs,key,set,if,blob,name,starts,with,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,index,blob,during,finalization,snapshot,id,shard,id,blob,name,e,throw,e,for,final,string,blob,name,blobs,key,set,if,blob,name,starts,with,updated,snapshots,find,name,file,canonical,name,blob,name,null,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,data,blob,during,finalization,snapshot,id,shard,id,blob,name,e,catch,ioexception,e,string,message,failed,to,finalize,reason,with,shard,index,current,index,gen,throw,new,index,shard,snapshot,failed,exception,shard,id,message,e
BlobStoreRepository -> Context -> protected void finalize(final List<SnapshotFiles> snapshots,                                 final int fileListGeneration,                                 final Map<String, BlobMetaData> blobs,                                 final String reason);1526574077;Writes a new index file for the shard and removes all unreferenced files from the repository.__We need to be really careful in handling index files in case of failures to make sure we don't_have index file that points to files that were deleted.__@param snapshots          list of active snapshots in the container_@param fileListGeneration the generation number of the snapshot index file_@param blobs              list of blobs in the container_@param reason             a reason explaining why the shard index file is written;protected void finalize(final List<SnapshotFiles> snapshots,_                                final int fileListGeneration,_                                final Map<String, BlobMetaData> blobs,_                                final String reason) {_            final String indexGeneration = Integer.toString(fileListGeneration)__            final String currentIndexGen = indexShardSnapshotsFormat.blobName(indexGeneration)___            final BlobStoreIndexShardSnapshots updatedSnapshots = new BlobStoreIndexShardSnapshots(snapshots)__            try {_                _                _                for (final String blobName : blobs.keySet()) {_                    if (indexShardSnapshotsFormat.isTempBlobName(blobName)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete index blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                            throw e__                        }_                    }_                }__                _                if (snapshots.size() > 0) {_                    indexShardSnapshotsFormat.writeAtomic(updatedSnapshots, blobContainer, indexGeneration)__                }__                _                for (final String blobName : blobs.keySet()) {_                    if (blobName.startsWith(SNAPSHOT_INDEX_PREFIX)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete index blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                            throw e__                        }_                    }_                }__                _                for (final String blobName : blobs.keySet()) {_                    if (blobName.startsWith(DATA_BLOB_PREFIX) && (updatedSnapshots.findNameFile(canonicalName(blobName)) == null)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete data blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                        }_                    }_                }_            } catch (IOException e) {_                String message = "Failed to finalize " + reason + " with shard index [" + currentIndexGen + "]"__                throw new IndexShardSnapshotFailedException(shardId, message, e)__            }_        };writes,a,new,index,file,for,the,shard,and,removes,all,unreferenced,files,from,the,repository,we,need,to,be,really,careful,in,handling,index,files,in,case,of,failures,to,make,sure,we,don,t,have,index,file,that,points,to,files,that,were,deleted,param,snapshots,list,of,active,snapshots,in,the,container,param,file,list,generation,the,generation,number,of,the,snapshot,index,file,param,blobs,list,of,blobs,in,the,container,param,reason,a,reason,explaining,why,the,shard,index,file,is,written;protected,void,finalize,final,list,snapshot,files,snapshots,final,int,file,list,generation,final,map,string,blob,meta,data,blobs,final,string,reason,final,string,index,generation,integer,to,string,file,list,generation,final,string,current,index,gen,index,shard,snapshots,format,blob,name,index,generation,final,blob,store,index,shard,snapshots,updated,snapshots,new,blob,store,index,shard,snapshots,snapshots,try,for,final,string,blob,name,blobs,key,set,if,index,shard,snapshots,format,is,temp,blob,name,blob,name,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,index,blob,during,finalization,snapshot,id,shard,id,blob,name,e,throw,e,if,snapshots,size,0,index,shard,snapshots,format,write,atomic,updated,snapshots,blob,container,index,generation,for,final,string,blob,name,blobs,key,set,if,blob,name,starts,with,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,index,blob,during,finalization,snapshot,id,shard,id,blob,name,e,throw,e,for,final,string,blob,name,blobs,key,set,if,blob,name,starts,with,updated,snapshots,find,name,file,canonical,name,blob,name,null,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,data,blob,during,finalization,snapshot,id,shard,id,blob,name,e,catch,ioexception,e,string,message,failed,to,finalize,reason,with,shard,index,current,index,gen,throw,new,index,shard,snapshot,failed,exception,shard,id,message,e
BlobStoreRepository -> Context -> protected void finalize(final List<SnapshotFiles> snapshots,                                 final int fileListGeneration,                                 final Map<String, BlobMetaData> blobs,                                 final String reason);1527583663;Writes a new index file for the shard and removes all unreferenced files from the repository.__We need to be really careful in handling index files in case of failures to make sure we don't_have index file that points to files that were deleted.__@param snapshots          list of active snapshots in the container_@param fileListGeneration the generation number of the snapshot index file_@param blobs              list of blobs in the container_@param reason             a reason explaining why the shard index file is written;protected void finalize(final List<SnapshotFiles> snapshots,_                                final int fileListGeneration,_                                final Map<String, BlobMetaData> blobs,_                                final String reason) {_            final String indexGeneration = Integer.toString(fileListGeneration)__            final String currentIndexGen = indexShardSnapshotsFormat.blobName(indexGeneration)___            final BlobStoreIndexShardSnapshots updatedSnapshots = new BlobStoreIndexShardSnapshots(snapshots)__            try {_                _                _                for (final String blobName : blobs.keySet()) {_                    if (indexShardSnapshotsFormat.isTempBlobName(blobName)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete index blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                            throw e__                        }_                    }_                }__                _                if (snapshots.size() > 0) {_                    indexShardSnapshotsFormat.writeAtomic(updatedSnapshots, blobContainer, indexGeneration)__                }__                _                for (final String blobName : blobs.keySet()) {_                    if (blobName.startsWith(SNAPSHOT_INDEX_PREFIX)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete index blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                            throw e__                        }_                    }_                }__                _                for (final String blobName : blobs.keySet()) {_                    if (blobName.startsWith(DATA_BLOB_PREFIX) && (updatedSnapshots.findNameFile(canonicalName(blobName)) == null)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete data blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                        }_                    }_                }_            } catch (IOException e) {_                String message = "Failed to finalize " + reason + " with shard index [" + currentIndexGen + "]"__                throw new IndexShardSnapshotFailedException(shardId, message, e)__            }_        };writes,a,new,index,file,for,the,shard,and,removes,all,unreferenced,files,from,the,repository,we,need,to,be,really,careful,in,handling,index,files,in,case,of,failures,to,make,sure,we,don,t,have,index,file,that,points,to,files,that,were,deleted,param,snapshots,list,of,active,snapshots,in,the,container,param,file,list,generation,the,generation,number,of,the,snapshot,index,file,param,blobs,list,of,blobs,in,the,container,param,reason,a,reason,explaining,why,the,shard,index,file,is,written;protected,void,finalize,final,list,snapshot,files,snapshots,final,int,file,list,generation,final,map,string,blob,meta,data,blobs,final,string,reason,final,string,index,generation,integer,to,string,file,list,generation,final,string,current,index,gen,index,shard,snapshots,format,blob,name,index,generation,final,blob,store,index,shard,snapshots,updated,snapshots,new,blob,store,index,shard,snapshots,snapshots,try,for,final,string,blob,name,blobs,key,set,if,index,shard,snapshots,format,is,temp,blob,name,blob,name,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,index,blob,during,finalization,snapshot,id,shard,id,blob,name,e,throw,e,if,snapshots,size,0,index,shard,snapshots,format,write,atomic,updated,snapshots,blob,container,index,generation,for,final,string,blob,name,blobs,key,set,if,blob,name,starts,with,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,index,blob,during,finalization,snapshot,id,shard,id,blob,name,e,throw,e,for,final,string,blob,name,blobs,key,set,if,blob,name,starts,with,updated,snapshots,find,name,file,canonical,name,blob,name,null,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,data,blob,during,finalization,snapshot,id,shard,id,blob,name,e,catch,ioexception,e,string,message,failed,to,finalize,reason,with,shard,index,current,index,gen,throw,new,index,shard,snapshot,failed,exception,shard,id,message,e
BlobStoreRepository -> Context -> protected void finalize(final List<SnapshotFiles> snapshots,                                 final int fileListGeneration,                                 final Map<String, BlobMetaData> blobs,                                 final String reason);1528211342;Writes a new index file for the shard and removes all unreferenced files from the repository.__We need to be really careful in handling index files in case of failures to make sure we don't_have index file that points to files that were deleted.__@param snapshots          list of active snapshots in the container_@param fileListGeneration the generation number of the snapshot index file_@param blobs              list of blobs in the container_@param reason             a reason explaining why the shard index file is written;protected void finalize(final List<SnapshotFiles> snapshots,_                                final int fileListGeneration,_                                final Map<String, BlobMetaData> blobs,_                                final String reason) {_            final String indexGeneration = Integer.toString(fileListGeneration)__            final String currentIndexGen = indexShardSnapshotsFormat.blobName(indexGeneration)___            final BlobStoreIndexShardSnapshots updatedSnapshots = new BlobStoreIndexShardSnapshots(snapshots)__            try {_                _                _                for (final String blobName : blobs.keySet()) {_                    if (FsBlobContainer.isTempBlobName(blobName)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete index blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                            throw e__                        }_                    }_                }__                _                if (snapshots.size() > 0) {_                    indexShardSnapshotsFormat.writeAtomic(updatedSnapshots, blobContainer, indexGeneration)__                }__                _                for (final String blobName : blobs.keySet()) {_                    if (blobName.startsWith(SNAPSHOT_INDEX_PREFIX)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete index blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                            throw e__                        }_                    }_                }__                _                for (final String blobName : blobs.keySet()) {_                    if (blobName.startsWith(DATA_BLOB_PREFIX) && (updatedSnapshots.findNameFile(canonicalName(blobName)) == null)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete data blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                        }_                    }_                }_            } catch (IOException e) {_                String message = "Failed to finalize " + reason + " with shard index [" + currentIndexGen + "]"__                throw new IndexShardSnapshotFailedException(shardId, message, e)__            }_        };writes,a,new,index,file,for,the,shard,and,removes,all,unreferenced,files,from,the,repository,we,need,to,be,really,careful,in,handling,index,files,in,case,of,failures,to,make,sure,we,don,t,have,index,file,that,points,to,files,that,were,deleted,param,snapshots,list,of,active,snapshots,in,the,container,param,file,list,generation,the,generation,number,of,the,snapshot,index,file,param,blobs,list,of,blobs,in,the,container,param,reason,a,reason,explaining,why,the,shard,index,file,is,written;protected,void,finalize,final,list,snapshot,files,snapshots,final,int,file,list,generation,final,map,string,blob,meta,data,blobs,final,string,reason,final,string,index,generation,integer,to,string,file,list,generation,final,string,current,index,gen,index,shard,snapshots,format,blob,name,index,generation,final,blob,store,index,shard,snapshots,updated,snapshots,new,blob,store,index,shard,snapshots,snapshots,try,for,final,string,blob,name,blobs,key,set,if,fs,blob,container,is,temp,blob,name,blob,name,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,index,blob,during,finalization,snapshot,id,shard,id,blob,name,e,throw,e,if,snapshots,size,0,index,shard,snapshots,format,write,atomic,updated,snapshots,blob,container,index,generation,for,final,string,blob,name,blobs,key,set,if,blob,name,starts,with,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,index,blob,during,finalization,snapshot,id,shard,id,blob,name,e,throw,e,for,final,string,blob,name,blobs,key,set,if,blob,name,starts,with,updated,snapshots,find,name,file,canonical,name,blob,name,null,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,data,blob,during,finalization,snapshot,id,shard,id,blob,name,e,catch,ioexception,e,string,message,failed,to,finalize,reason,with,shard,index,current,index,gen,throw,new,index,shard,snapshot,failed,exception,shard,id,message,e
BlobStoreRepository -> Context -> protected void finalize(final List<SnapshotFiles> snapshots,                                 final int fileListGeneration,                                 final Map<String, BlobMetaData> blobs,                                 final String reason);1531179852;Writes a new index file for the shard and removes all unreferenced files from the repository.__We need to be really careful in handling index files in case of failures to make sure we don't_have index file that points to files that were deleted.__@param snapshots          list of active snapshots in the container_@param fileListGeneration the generation number of the snapshot index file_@param blobs              list of blobs in the container_@param reason             a reason explaining why the shard index file is written;protected void finalize(final List<SnapshotFiles> snapshots,_                                final int fileListGeneration,_                                final Map<String, BlobMetaData> blobs,_                                final String reason) {_            final String indexGeneration = Integer.toString(fileListGeneration)__            final String currentIndexGen = indexShardSnapshotsFormat.blobName(indexGeneration)___            final BlobStoreIndexShardSnapshots updatedSnapshots = new BlobStoreIndexShardSnapshots(snapshots)__            try {_                _                _                for (final String blobName : blobs.keySet()) {_                    if (FsBlobContainer.isTempBlobName(blobName)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete index blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                            throw e__                        }_                    }_                }__                _                if (snapshots.size() > 0) {_                    indexShardSnapshotsFormat.writeAtomic(updatedSnapshots, blobContainer, indexGeneration)__                }__                _                for (final String blobName : blobs.keySet()) {_                    if (blobName.startsWith(SNAPSHOT_INDEX_PREFIX)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete index blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                            throw e__                        }_                    }_                }__                _                for (final String blobName : blobs.keySet()) {_                    if (blobName.startsWith(DATA_BLOB_PREFIX) && (updatedSnapshots.findNameFile(canonicalName(blobName)) == null)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete data blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                        }_                    }_                }_            } catch (IOException e) {_                String message = "Failed to finalize " + reason + " with shard index [" + currentIndexGen + "]"__                throw new IndexShardSnapshotFailedException(shardId, message, e)__            }_        };writes,a,new,index,file,for,the,shard,and,removes,all,unreferenced,files,from,the,repository,we,need,to,be,really,careful,in,handling,index,files,in,case,of,failures,to,make,sure,we,don,t,have,index,file,that,points,to,files,that,were,deleted,param,snapshots,list,of,active,snapshots,in,the,container,param,file,list,generation,the,generation,number,of,the,snapshot,index,file,param,blobs,list,of,blobs,in,the,container,param,reason,a,reason,explaining,why,the,shard,index,file,is,written;protected,void,finalize,final,list,snapshot,files,snapshots,final,int,file,list,generation,final,map,string,blob,meta,data,blobs,final,string,reason,final,string,index,generation,integer,to,string,file,list,generation,final,string,current,index,gen,index,shard,snapshots,format,blob,name,index,generation,final,blob,store,index,shard,snapshots,updated,snapshots,new,blob,store,index,shard,snapshots,snapshots,try,for,final,string,blob,name,blobs,key,set,if,fs,blob,container,is,temp,blob,name,blob,name,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,index,blob,during,finalization,snapshot,id,shard,id,blob,name,e,throw,e,if,snapshots,size,0,index,shard,snapshots,format,write,atomic,updated,snapshots,blob,container,index,generation,for,final,string,blob,name,blobs,key,set,if,blob,name,starts,with,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,index,blob,during,finalization,snapshot,id,shard,id,blob,name,e,throw,e,for,final,string,blob,name,blobs,key,set,if,blob,name,starts,with,updated,snapshots,find,name,file,canonical,name,blob,name,null,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,data,blob,during,finalization,snapshot,id,shard,id,blob,name,e,catch,ioexception,e,string,message,failed,to,finalize,reason,with,shard,index,current,index,gen,throw,new,index,shard,snapshot,failed,exception,shard,id,message,e
BlobStoreRepository -> Context -> protected void finalize(final List<SnapshotFiles> snapshots,                                 final int fileListGeneration,                                 final Map<String, BlobMetaData> blobs,                                 final String reason);1531729807;Writes a new index file for the shard and removes all unreferenced files from the repository.__We need to be really careful in handling index files in case of failures to make sure we don't_have index file that points to files that were deleted.__@param snapshots          list of active snapshots in the container_@param fileListGeneration the generation number of the snapshot index file_@param blobs              list of blobs in the container_@param reason             a reason explaining why the shard index file is written;protected void finalize(final List<SnapshotFiles> snapshots,_                                final int fileListGeneration,_                                final Map<String, BlobMetaData> blobs,_                                final String reason) {_            final String indexGeneration = Integer.toString(fileListGeneration)__            final String currentIndexGen = indexShardSnapshotsFormat.blobName(indexGeneration)___            final BlobStoreIndexShardSnapshots updatedSnapshots = new BlobStoreIndexShardSnapshots(snapshots)__            try {_                _                _                for (final String blobName : blobs.keySet()) {_                    if (FsBlobContainer.isTempBlobName(blobName)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete index blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                            throw e__                        }_                    }_                }__                _                if (snapshots.size() > 0) {_                    indexShardSnapshotsFormat.writeAtomic(updatedSnapshots, blobContainer, indexGeneration)__                }__                _                for (final String blobName : blobs.keySet()) {_                    if (blobName.startsWith(SNAPSHOT_INDEX_PREFIX)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete index blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                            throw e__                        }_                    }_                }__                _                for (final String blobName : blobs.keySet()) {_                    if (blobName.startsWith(DATA_BLOB_PREFIX) && (updatedSnapshots.findNameFile(canonicalName(blobName)) == null)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete data blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                        }_                    }_                }_            } catch (IOException e) {_                String message = "Failed to finalize " + reason + " with shard index [" + currentIndexGen + "]"__                throw new IndexShardSnapshotFailedException(shardId, message, e)__            }_        };writes,a,new,index,file,for,the,shard,and,removes,all,unreferenced,files,from,the,repository,we,need,to,be,really,careful,in,handling,index,files,in,case,of,failures,to,make,sure,we,don,t,have,index,file,that,points,to,files,that,were,deleted,param,snapshots,list,of,active,snapshots,in,the,container,param,file,list,generation,the,generation,number,of,the,snapshot,index,file,param,blobs,list,of,blobs,in,the,container,param,reason,a,reason,explaining,why,the,shard,index,file,is,written;protected,void,finalize,final,list,snapshot,files,snapshots,final,int,file,list,generation,final,map,string,blob,meta,data,blobs,final,string,reason,final,string,index,generation,integer,to,string,file,list,generation,final,string,current,index,gen,index,shard,snapshots,format,blob,name,index,generation,final,blob,store,index,shard,snapshots,updated,snapshots,new,blob,store,index,shard,snapshots,snapshots,try,for,final,string,blob,name,blobs,key,set,if,fs,blob,container,is,temp,blob,name,blob,name,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,index,blob,during,finalization,snapshot,id,shard,id,blob,name,e,throw,e,if,snapshots,size,0,index,shard,snapshots,format,write,atomic,updated,snapshots,blob,container,index,generation,for,final,string,blob,name,blobs,key,set,if,blob,name,starts,with,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,index,blob,during,finalization,snapshot,id,shard,id,blob,name,e,throw,e,for,final,string,blob,name,blobs,key,set,if,blob,name,starts,with,updated,snapshots,find,name,file,canonical,name,blob,name,null,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,data,blob,during,finalization,snapshot,id,shard,id,blob,name,e,catch,ioexception,e,string,message,failed,to,finalize,reason,with,shard,index,current,index,gen,throw,new,index,shard,snapshot,failed,exception,shard,id,message,e
BlobStoreRepository -> Context -> protected void finalize(final List<SnapshotFiles> snapshots,                                 final int fileListGeneration,                                 final Map<String, BlobMetaData> blobs,                                 final String reason);1532685069;Writes a new index file for the shard and removes all unreferenced files from the repository.__We need to be really careful in handling index files in case of failures to make sure we don't_have index file that points to files that were deleted.__@param snapshots          list of active snapshots in the container_@param fileListGeneration the generation number of the snapshot index file_@param blobs              list of blobs in the container_@param reason             a reason explaining why the shard index file is written;protected void finalize(final List<SnapshotFiles> snapshots,_                                final int fileListGeneration,_                                final Map<String, BlobMetaData> blobs,_                                final String reason) {_            final String indexGeneration = Integer.toString(fileListGeneration)__            final String currentIndexGen = indexShardSnapshotsFormat.blobName(indexGeneration)___            final BlobStoreIndexShardSnapshots updatedSnapshots = new BlobStoreIndexShardSnapshots(snapshots)__            try {_                _                _                for (final String blobName : blobs.keySet()) {_                    if (FsBlobContainer.isTempBlobName(blobName)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete index blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                            throw e__                        }_                    }_                }__                _                if (snapshots.size() > 0) {_                    indexShardSnapshotsFormat.writeAtomic(updatedSnapshots, blobContainer, indexGeneration)__                }__                _                for (final String blobName : blobs.keySet()) {_                    if (blobName.startsWith(SNAPSHOT_INDEX_PREFIX)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete index blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                            throw e__                        }_                    }_                }__                _                for (final String blobName : blobs.keySet()) {_                    if (blobName.startsWith(DATA_BLOB_PREFIX) && (updatedSnapshots.findNameFile(canonicalName(blobName)) == null)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete data blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                        }_                    }_                }_            } catch (IOException e) {_                String message = "Failed to finalize " + reason + " with shard index [" + currentIndexGen + "]"__                throw new IndexShardSnapshotFailedException(shardId, message, e)__            }_        };writes,a,new,index,file,for,the,shard,and,removes,all,unreferenced,files,from,the,repository,we,need,to,be,really,careful,in,handling,index,files,in,case,of,failures,to,make,sure,we,don,t,have,index,file,that,points,to,files,that,were,deleted,param,snapshots,list,of,active,snapshots,in,the,container,param,file,list,generation,the,generation,number,of,the,snapshot,index,file,param,blobs,list,of,blobs,in,the,container,param,reason,a,reason,explaining,why,the,shard,index,file,is,written;protected,void,finalize,final,list,snapshot,files,snapshots,final,int,file,list,generation,final,map,string,blob,meta,data,blobs,final,string,reason,final,string,index,generation,integer,to,string,file,list,generation,final,string,current,index,gen,index,shard,snapshots,format,blob,name,index,generation,final,blob,store,index,shard,snapshots,updated,snapshots,new,blob,store,index,shard,snapshots,snapshots,try,for,final,string,blob,name,blobs,key,set,if,fs,blob,container,is,temp,blob,name,blob,name,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,index,blob,during,finalization,snapshot,id,shard,id,blob,name,e,throw,e,if,snapshots,size,0,index,shard,snapshots,format,write,atomic,updated,snapshots,blob,container,index,generation,for,final,string,blob,name,blobs,key,set,if,blob,name,starts,with,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,index,blob,during,finalization,snapshot,id,shard,id,blob,name,e,throw,e,for,final,string,blob,name,blobs,key,set,if,blob,name,starts,with,updated,snapshots,find,name,file,canonical,name,blob,name,null,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,data,blob,during,finalization,snapshot,id,shard,id,blob,name,e,catch,ioexception,e,string,message,failed,to,finalize,reason,with,shard,index,current,index,gen,throw,new,index,shard,snapshot,failed,exception,shard,id,message,e
BlobStoreRepository -> Context -> protected void finalize(final List<SnapshotFiles> snapshots,                                 final int fileListGeneration,                                 final Map<String, BlobMetaData> blobs,                                 final String reason);1535139672;Writes a new index file for the shard and removes all unreferenced files from the repository.__We need to be really careful in handling index files in case of failures to make sure we don't_have index file that points to files that were deleted.__@param snapshots          list of active snapshots in the container_@param fileListGeneration the generation number of the snapshot index file_@param blobs              list of blobs in the container_@param reason             a reason explaining why the shard index file is written;protected void finalize(final List<SnapshotFiles> snapshots,_                                final int fileListGeneration,_                                final Map<String, BlobMetaData> blobs,_                                final String reason) {_            final String indexGeneration = Integer.toString(fileListGeneration)__            final String currentIndexGen = indexShardSnapshotsFormat.blobName(indexGeneration)___            final BlobStoreIndexShardSnapshots updatedSnapshots = new BlobStoreIndexShardSnapshots(snapshots)__            try {_                _                _                for (final String blobName : blobs.keySet()) {_                    if (FsBlobContainer.isTempBlobName(blobName)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete index blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                            throw e__                        }_                    }_                }__                _                if (snapshots.size() > 0) {_                    indexShardSnapshotsFormat.writeAtomic(updatedSnapshots, blobContainer, indexGeneration)__                }__                _                for (final String blobName : blobs.keySet()) {_                    if (blobName.startsWith(SNAPSHOT_INDEX_PREFIX)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete index blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                            throw e__                        }_                    }_                }__                _                for (final String blobName : blobs.keySet()) {_                    if (blobName.startsWith(DATA_BLOB_PREFIX) && (updatedSnapshots.findNameFile(canonicalName(blobName)) == null)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete data blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                        }_                    }_                }_            } catch (IOException e) {_                String message = "Failed to finalize " + reason + " with shard index [" + currentIndexGen + "]"__                throw new IndexShardSnapshotFailedException(shardId, message, e)__            }_        };writes,a,new,index,file,for,the,shard,and,removes,all,unreferenced,files,from,the,repository,we,need,to,be,really,careful,in,handling,index,files,in,case,of,failures,to,make,sure,we,don,t,have,index,file,that,points,to,files,that,were,deleted,param,snapshots,list,of,active,snapshots,in,the,container,param,file,list,generation,the,generation,number,of,the,snapshot,index,file,param,blobs,list,of,blobs,in,the,container,param,reason,a,reason,explaining,why,the,shard,index,file,is,written;protected,void,finalize,final,list,snapshot,files,snapshots,final,int,file,list,generation,final,map,string,blob,meta,data,blobs,final,string,reason,final,string,index,generation,integer,to,string,file,list,generation,final,string,current,index,gen,index,shard,snapshots,format,blob,name,index,generation,final,blob,store,index,shard,snapshots,updated,snapshots,new,blob,store,index,shard,snapshots,snapshots,try,for,final,string,blob,name,blobs,key,set,if,fs,blob,container,is,temp,blob,name,blob,name,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,index,blob,during,finalization,snapshot,id,shard,id,blob,name,e,throw,e,if,snapshots,size,0,index,shard,snapshots,format,write,atomic,updated,snapshots,blob,container,index,generation,for,final,string,blob,name,blobs,key,set,if,blob,name,starts,with,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,index,blob,during,finalization,snapshot,id,shard,id,blob,name,e,throw,e,for,final,string,blob,name,blobs,key,set,if,blob,name,starts,with,updated,snapshots,find,name,file,canonical,name,blob,name,null,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,data,blob,during,finalization,snapshot,id,shard,id,blob,name,e,catch,ioexception,e,string,message,failed,to,finalize,reason,with,shard,index,current,index,gen,throw,new,index,shard,snapshot,failed,exception,shard,id,message,e
BlobStoreRepository -> Context -> protected void finalize(final List<SnapshotFiles> snapshots,                                 final int fileListGeneration,                                 final Map<String, BlobMetaData> blobs,                                 final String reason);1535723122;Writes a new index file for the shard and removes all unreferenced files from the repository.__We need to be really careful in handling index files in case of failures to make sure we don't_have index file that points to files that were deleted.__@param snapshots          list of active snapshots in the container_@param fileListGeneration the generation number of the snapshot index file_@param blobs              list of blobs in the container_@param reason             a reason explaining why the shard index file is written;protected void finalize(final List<SnapshotFiles> snapshots,_                                final int fileListGeneration,_                                final Map<String, BlobMetaData> blobs,_                                final String reason) {_            final String indexGeneration = Integer.toString(fileListGeneration)__            final String currentIndexGen = indexShardSnapshotsFormat.blobName(indexGeneration)___            final BlobStoreIndexShardSnapshots updatedSnapshots = new BlobStoreIndexShardSnapshots(snapshots)__            try {_                _                _                for (final String blobName : blobs.keySet()) {_                    if (FsBlobContainer.isTempBlobName(blobName)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete index blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                            throw e__                        }_                    }_                }__                _                if (snapshots.size() > 0) {_                    indexShardSnapshotsFormat.writeAtomic(updatedSnapshots, blobContainer, indexGeneration)__                }__                _                for (final String blobName : blobs.keySet()) {_                    if (blobName.startsWith(SNAPSHOT_INDEX_PREFIX)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete index blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                            throw e__                        }_                    }_                }__                _                for (final String blobName : blobs.keySet()) {_                    if (blobName.startsWith(DATA_BLOB_PREFIX) && (updatedSnapshots.findNameFile(canonicalName(blobName)) == null)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete data blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                        }_                    }_                }_            } catch (IOException e) {_                String message = "Failed to finalize " + reason + " with shard index [" + currentIndexGen + "]"__                throw new IndexShardSnapshotFailedException(shardId, message, e)__            }_        };writes,a,new,index,file,for,the,shard,and,removes,all,unreferenced,files,from,the,repository,we,need,to,be,really,careful,in,handling,index,files,in,case,of,failures,to,make,sure,we,don,t,have,index,file,that,points,to,files,that,were,deleted,param,snapshots,list,of,active,snapshots,in,the,container,param,file,list,generation,the,generation,number,of,the,snapshot,index,file,param,blobs,list,of,blobs,in,the,container,param,reason,a,reason,explaining,why,the,shard,index,file,is,written;protected,void,finalize,final,list,snapshot,files,snapshots,final,int,file,list,generation,final,map,string,blob,meta,data,blobs,final,string,reason,final,string,index,generation,integer,to,string,file,list,generation,final,string,current,index,gen,index,shard,snapshots,format,blob,name,index,generation,final,blob,store,index,shard,snapshots,updated,snapshots,new,blob,store,index,shard,snapshots,snapshots,try,for,final,string,blob,name,blobs,key,set,if,fs,blob,container,is,temp,blob,name,blob,name,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,index,blob,during,finalization,snapshot,id,shard,id,blob,name,e,throw,e,if,snapshots,size,0,index,shard,snapshots,format,write,atomic,updated,snapshots,blob,container,index,generation,for,final,string,blob,name,blobs,key,set,if,blob,name,starts,with,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,index,blob,during,finalization,snapshot,id,shard,id,blob,name,e,throw,e,for,final,string,blob,name,blobs,key,set,if,blob,name,starts,with,updated,snapshots,find,name,file,canonical,name,blob,name,null,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,data,blob,during,finalization,snapshot,id,shard,id,blob,name,e,catch,ioexception,e,string,message,failed,to,finalize,reason,with,shard,index,current,index,gen,throw,new,index,shard,snapshot,failed,exception,shard,id,message,e
BlobStoreRepository -> Context -> protected void finalize(final List<SnapshotFiles> snapshots,                                 final int fileListGeneration,                                 final Map<String, BlobMetaData> blobs,                                 final String reason);1536314350;Writes a new index file for the shard and removes all unreferenced files from the repository.__We need to be really careful in handling index files in case of failures to make sure we don't_have index file that points to files that were deleted.__@param snapshots          list of active snapshots in the container_@param fileListGeneration the generation number of the snapshot index file_@param blobs              list of blobs in the container_@param reason             a reason explaining why the shard index file is written;protected void finalize(final List<SnapshotFiles> snapshots,_                                final int fileListGeneration,_                                final Map<String, BlobMetaData> blobs,_                                final String reason) {_            final String indexGeneration = Integer.toString(fileListGeneration)__            final String currentIndexGen = indexShardSnapshotsFormat.blobName(indexGeneration)___            final BlobStoreIndexShardSnapshots updatedSnapshots = new BlobStoreIndexShardSnapshots(snapshots)__            try {_                _                _                for (final String blobName : blobs.keySet()) {_                    if (FsBlobContainer.isTempBlobName(blobName)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete index blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                            throw e__                        }_                    }_                }__                _                if (snapshots.size() > 0) {_                    indexShardSnapshotsFormat.writeAtomic(updatedSnapshots, blobContainer, indexGeneration)__                }__                _                for (final String blobName : blobs.keySet()) {_                    if (blobName.startsWith(SNAPSHOT_INDEX_PREFIX)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete index blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                            throw e__                        }_                    }_                }__                _                for (final String blobName : blobs.keySet()) {_                    if (blobName.startsWith(DATA_BLOB_PREFIX) && (updatedSnapshots.findNameFile(canonicalName(blobName)) == null)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete data blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                        }_                    }_                }_            } catch (IOException e) {_                String message = "Failed to finalize " + reason + " with shard index [" + currentIndexGen + "]"__                throw new IndexShardSnapshotFailedException(shardId, message, e)__            }_        };writes,a,new,index,file,for,the,shard,and,removes,all,unreferenced,files,from,the,repository,we,need,to,be,really,careful,in,handling,index,files,in,case,of,failures,to,make,sure,we,don,t,have,index,file,that,points,to,files,that,were,deleted,param,snapshots,list,of,active,snapshots,in,the,container,param,file,list,generation,the,generation,number,of,the,snapshot,index,file,param,blobs,list,of,blobs,in,the,container,param,reason,a,reason,explaining,why,the,shard,index,file,is,written;protected,void,finalize,final,list,snapshot,files,snapshots,final,int,file,list,generation,final,map,string,blob,meta,data,blobs,final,string,reason,final,string,index,generation,integer,to,string,file,list,generation,final,string,current,index,gen,index,shard,snapshots,format,blob,name,index,generation,final,blob,store,index,shard,snapshots,updated,snapshots,new,blob,store,index,shard,snapshots,snapshots,try,for,final,string,blob,name,blobs,key,set,if,fs,blob,container,is,temp,blob,name,blob,name,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,index,blob,during,finalization,snapshot,id,shard,id,blob,name,e,throw,e,if,snapshots,size,0,index,shard,snapshots,format,write,atomic,updated,snapshots,blob,container,index,generation,for,final,string,blob,name,blobs,key,set,if,blob,name,starts,with,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,index,blob,during,finalization,snapshot,id,shard,id,blob,name,e,throw,e,for,final,string,blob,name,blobs,key,set,if,blob,name,starts,with,updated,snapshots,find,name,file,canonical,name,blob,name,null,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,data,blob,during,finalization,snapshot,id,shard,id,blob,name,e,catch,ioexception,e,string,message,failed,to,finalize,reason,with,shard,index,current,index,gen,throw,new,index,shard,snapshot,failed,exception,shard,id,message,e
BlobStoreRepository -> Context -> protected void finalize(final List<SnapshotFiles> snapshots,                                 final int fileListGeneration,                                 final Map<String, BlobMetaData> blobs,                                 final String reason);1536828374;Writes a new index file for the shard and removes all unreferenced files from the repository.__We need to be really careful in handling index files in case of failures to make sure we don't_have index file that points to files that were deleted.__@param snapshots          list of active snapshots in the container_@param fileListGeneration the generation number of the snapshot index file_@param blobs              list of blobs in the container_@param reason             a reason explaining why the shard index file is written;protected void finalize(final List<SnapshotFiles> snapshots,_                                final int fileListGeneration,_                                final Map<String, BlobMetaData> blobs,_                                final String reason) {_            final String indexGeneration = Integer.toString(fileListGeneration)__            final String currentIndexGen = indexShardSnapshotsFormat.blobName(indexGeneration)___            final BlobStoreIndexShardSnapshots updatedSnapshots = new BlobStoreIndexShardSnapshots(snapshots)__            try {_                _                _                for (final String blobName : blobs.keySet()) {_                    if (FsBlobContainer.isTempBlobName(blobName)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete index blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                            throw e__                        }_                    }_                }__                _                if (snapshots.size() > 0) {_                    indexShardSnapshotsFormat.writeAtomic(updatedSnapshots, blobContainer, indexGeneration)__                }__                _                for (final String blobName : blobs.keySet()) {_                    if (blobName.startsWith(SNAPSHOT_INDEX_PREFIX)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete index blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                            throw e__                        }_                    }_                }__                _                for (final String blobName : blobs.keySet()) {_                    if (blobName.startsWith(DATA_BLOB_PREFIX) && (updatedSnapshots.findNameFile(canonicalName(blobName)) == null)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete data blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                        }_                    }_                }_            } catch (IOException e) {_                String message = "Failed to finalize " + reason + " with shard index [" + currentIndexGen + "]"__                throw new IndexShardSnapshotFailedException(shardId, message, e)__            }_        };writes,a,new,index,file,for,the,shard,and,removes,all,unreferenced,files,from,the,repository,we,need,to,be,really,careful,in,handling,index,files,in,case,of,failures,to,make,sure,we,don,t,have,index,file,that,points,to,files,that,were,deleted,param,snapshots,list,of,active,snapshots,in,the,container,param,file,list,generation,the,generation,number,of,the,snapshot,index,file,param,blobs,list,of,blobs,in,the,container,param,reason,a,reason,explaining,why,the,shard,index,file,is,written;protected,void,finalize,final,list,snapshot,files,snapshots,final,int,file,list,generation,final,map,string,blob,meta,data,blobs,final,string,reason,final,string,index,generation,integer,to,string,file,list,generation,final,string,current,index,gen,index,shard,snapshots,format,blob,name,index,generation,final,blob,store,index,shard,snapshots,updated,snapshots,new,blob,store,index,shard,snapshots,snapshots,try,for,final,string,blob,name,blobs,key,set,if,fs,blob,container,is,temp,blob,name,blob,name,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,index,blob,during,finalization,snapshot,id,shard,id,blob,name,e,throw,e,if,snapshots,size,0,index,shard,snapshots,format,write,atomic,updated,snapshots,blob,container,index,generation,for,final,string,blob,name,blobs,key,set,if,blob,name,starts,with,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,index,blob,during,finalization,snapshot,id,shard,id,blob,name,e,throw,e,for,final,string,blob,name,blobs,key,set,if,blob,name,starts,with,updated,snapshots,find,name,file,canonical,name,blob,name,null,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,data,blob,during,finalization,snapshot,id,shard,id,blob,name,e,catch,ioexception,e,string,message,failed,to,finalize,reason,with,shard,index,current,index,gen,throw,new,index,shard,snapshot,failed,exception,shard,id,message,e
BlobStoreRepository -> Context -> protected void finalize(final List<SnapshotFiles> snapshots,                                 final int fileListGeneration,                                 final Map<String, BlobMetaData> blobs,                                 final String reason);1541008027;Writes a new index file for the shard and removes all unreferenced files from the repository.__We need to be really careful in handling index files in case of failures to make sure we don't_have index file that points to files that were deleted.__@param snapshots          list of active snapshots in the container_@param fileListGeneration the generation number of the snapshot index file_@param blobs              list of blobs in the container_@param reason             a reason explaining why the shard index file is written;protected void finalize(final List<SnapshotFiles> snapshots,_                                final int fileListGeneration,_                                final Map<String, BlobMetaData> blobs,_                                final String reason) {_            final String indexGeneration = Integer.toString(fileListGeneration)__            final String currentIndexGen = indexShardSnapshotsFormat.blobName(indexGeneration)___            final BlobStoreIndexShardSnapshots updatedSnapshots = new BlobStoreIndexShardSnapshots(snapshots)__            try {_                _                _                for (final String blobName : blobs.keySet()) {_                    if (FsBlobContainer.isTempBlobName(blobName)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete index blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                            throw e__                        }_                    }_                }__                _                if (snapshots.size() > 0) {_                    indexShardSnapshotsFormat.writeAtomic(updatedSnapshots, blobContainer, indexGeneration)__                }__                _                for (final String blobName : blobs.keySet()) {_                    if (blobName.startsWith(SNAPSHOT_INDEX_PREFIX)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete index blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                            throw e__                        }_                    }_                }__                _                for (final String blobName : blobs.keySet()) {_                    if (blobName.startsWith(DATA_BLOB_PREFIX) && (updatedSnapshots.findNameFile(canonicalName(blobName)) == null)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete data blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                        }_                    }_                }_            } catch (IOException e) {_                String message = "Failed to finalize " + reason + " with shard index [" + currentIndexGen + "]"__                throw new IndexShardSnapshotFailedException(shardId, message, e)__            }_        };writes,a,new,index,file,for,the,shard,and,removes,all,unreferenced,files,from,the,repository,we,need,to,be,really,careful,in,handling,index,files,in,case,of,failures,to,make,sure,we,don,t,have,index,file,that,points,to,files,that,were,deleted,param,snapshots,list,of,active,snapshots,in,the,container,param,file,list,generation,the,generation,number,of,the,snapshot,index,file,param,blobs,list,of,blobs,in,the,container,param,reason,a,reason,explaining,why,the,shard,index,file,is,written;protected,void,finalize,final,list,snapshot,files,snapshots,final,int,file,list,generation,final,map,string,blob,meta,data,blobs,final,string,reason,final,string,index,generation,integer,to,string,file,list,generation,final,string,current,index,gen,index,shard,snapshots,format,blob,name,index,generation,final,blob,store,index,shard,snapshots,updated,snapshots,new,blob,store,index,shard,snapshots,snapshots,try,for,final,string,blob,name,blobs,key,set,if,fs,blob,container,is,temp,blob,name,blob,name,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,index,blob,during,finalization,snapshot,id,shard,id,blob,name,e,throw,e,if,snapshots,size,0,index,shard,snapshots,format,write,atomic,updated,snapshots,blob,container,index,generation,for,final,string,blob,name,blobs,key,set,if,blob,name,starts,with,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,index,blob,during,finalization,snapshot,id,shard,id,blob,name,e,throw,e,for,final,string,blob,name,blobs,key,set,if,blob,name,starts,with,updated,snapshots,find,name,file,canonical,name,blob,name,null,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,data,blob,during,finalization,snapshot,id,shard,id,blob,name,e,catch,ioexception,e,string,message,failed,to,finalize,reason,with,shard,index,current,index,gen,throw,new,index,shard,snapshot,failed,exception,shard,id,message,e
BlobStoreRepository -> Context -> protected void finalize(final List<SnapshotFiles> snapshots,                                 final int fileListGeneration,                                 final Map<String, BlobMetaData> blobs,                                 final String reason);1542646292;Writes a new index file for the shard and removes all unreferenced files from the repository.__We need to be really careful in handling index files in case of failures to make sure we don't_have index file that points to files that were deleted.__@param snapshots          list of active snapshots in the container_@param fileListGeneration the generation number of the snapshot index file_@param blobs              list of blobs in the container_@param reason             a reason explaining why the shard index file is written;protected void finalize(final List<SnapshotFiles> snapshots,_                                final int fileListGeneration,_                                final Map<String, BlobMetaData> blobs,_                                final String reason) {_            final String indexGeneration = Integer.toString(fileListGeneration)__            final String currentIndexGen = indexShardSnapshotsFormat.blobName(indexGeneration)___            final BlobStoreIndexShardSnapshots updatedSnapshots = new BlobStoreIndexShardSnapshots(snapshots)__            try {_                _                _                for (final String blobName : blobs.keySet()) {_                    if (FsBlobContainer.isTempBlobName(blobName)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete index blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                            throw e__                        }_                    }_                }__                _                if (snapshots.size() > 0) {_                    indexShardSnapshotsFormat.writeAtomic(updatedSnapshots, blobContainer, indexGeneration)__                }__                _                for (final String blobName : blobs.keySet()) {_                    if (blobName.startsWith(SNAPSHOT_INDEX_PREFIX)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete index blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                            throw e__                        }_                    }_                }__                _                for (final String blobName : blobs.keySet()) {_                    if (blobName.startsWith(DATA_BLOB_PREFIX) && (updatedSnapshots.findNameFile(canonicalName(blobName)) == null)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete data blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                        }_                    }_                }_            } catch (IOException e) {_                String message = "Failed to finalize " + reason + " with shard index [" + currentIndexGen + "]"__                throw new IndexShardSnapshotFailedException(shardId, message, e)__            }_        };writes,a,new,index,file,for,the,shard,and,removes,all,unreferenced,files,from,the,repository,we,need,to,be,really,careful,in,handling,index,files,in,case,of,failures,to,make,sure,we,don,t,have,index,file,that,points,to,files,that,were,deleted,param,snapshots,list,of,active,snapshots,in,the,container,param,file,list,generation,the,generation,number,of,the,snapshot,index,file,param,blobs,list,of,blobs,in,the,container,param,reason,a,reason,explaining,why,the,shard,index,file,is,written;protected,void,finalize,final,list,snapshot,files,snapshots,final,int,file,list,generation,final,map,string,blob,meta,data,blobs,final,string,reason,final,string,index,generation,integer,to,string,file,list,generation,final,string,current,index,gen,index,shard,snapshots,format,blob,name,index,generation,final,blob,store,index,shard,snapshots,updated,snapshots,new,blob,store,index,shard,snapshots,snapshots,try,for,final,string,blob,name,blobs,key,set,if,fs,blob,container,is,temp,blob,name,blob,name,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,index,blob,during,finalization,snapshot,id,shard,id,blob,name,e,throw,e,if,snapshots,size,0,index,shard,snapshots,format,write,atomic,updated,snapshots,blob,container,index,generation,for,final,string,blob,name,blobs,key,set,if,blob,name,starts,with,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,index,blob,during,finalization,snapshot,id,shard,id,blob,name,e,throw,e,for,final,string,blob,name,blobs,key,set,if,blob,name,starts,with,updated,snapshots,find,name,file,canonical,name,blob,name,null,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,data,blob,during,finalization,snapshot,id,shard,id,blob,name,e,catch,ioexception,e,string,message,failed,to,finalize,reason,with,shard,index,current,index,gen,throw,new,index,shard,snapshot,failed,exception,shard,id,message,e
BlobStoreRepository -> Context -> protected void finalize(final List<SnapshotFiles> snapshots,                                 final int fileListGeneration,                                 final Map<String, BlobMetaData> blobs,                                 final String reason);1542980705;Writes a new index file for the shard and removes all unreferenced files from the repository.__We need to be really careful in handling index files in case of failures to make sure we don't_have index file that points to files that were deleted.__@param snapshots          list of active snapshots in the container_@param fileListGeneration the generation number of the snapshot index file_@param blobs              list of blobs in the container_@param reason             a reason explaining why the shard index file is written;protected void finalize(final List<SnapshotFiles> snapshots,_                                final int fileListGeneration,_                                final Map<String, BlobMetaData> blobs,_                                final String reason) {_            final String indexGeneration = Integer.toString(fileListGeneration)__            final String currentIndexGen = indexShardSnapshotsFormat.blobName(indexGeneration)___            final BlobStoreIndexShardSnapshots updatedSnapshots = new BlobStoreIndexShardSnapshots(snapshots)__            try {_                _                _                for (final String blobName : blobs.keySet()) {_                    if (FsBlobContainer.isTempBlobName(blobName)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete index blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                            throw e__                        }_                    }_                }__                _                if (snapshots.size() > 0) {_                    indexShardSnapshotsFormat.writeAtomic(updatedSnapshots, blobContainer, indexGeneration)__                }__                _                for (final String blobName : blobs.keySet()) {_                    if (blobName.startsWith(SNAPSHOT_INDEX_PREFIX)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete index blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                            throw e__                        }_                    }_                }__                _                for (final String blobName : blobs.keySet()) {_                    if (blobName.startsWith(DATA_BLOB_PREFIX) && (updatedSnapshots.findNameFile(canonicalName(blobName)) == null)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete data blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                        }_                    }_                }_            } catch (IOException e) {_                String message = "Failed to finalize " + reason + " with shard index [" + currentIndexGen + "]"__                throw new IndexShardSnapshotFailedException(shardId, message, e)__            }_        };writes,a,new,index,file,for,the,shard,and,removes,all,unreferenced,files,from,the,repository,we,need,to,be,really,careful,in,handling,index,files,in,case,of,failures,to,make,sure,we,don,t,have,index,file,that,points,to,files,that,were,deleted,param,snapshots,list,of,active,snapshots,in,the,container,param,file,list,generation,the,generation,number,of,the,snapshot,index,file,param,blobs,list,of,blobs,in,the,container,param,reason,a,reason,explaining,why,the,shard,index,file,is,written;protected,void,finalize,final,list,snapshot,files,snapshots,final,int,file,list,generation,final,map,string,blob,meta,data,blobs,final,string,reason,final,string,index,generation,integer,to,string,file,list,generation,final,string,current,index,gen,index,shard,snapshots,format,blob,name,index,generation,final,blob,store,index,shard,snapshots,updated,snapshots,new,blob,store,index,shard,snapshots,snapshots,try,for,final,string,blob,name,blobs,key,set,if,fs,blob,container,is,temp,blob,name,blob,name,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,index,blob,during,finalization,snapshot,id,shard,id,blob,name,e,throw,e,if,snapshots,size,0,index,shard,snapshots,format,write,atomic,updated,snapshots,blob,container,index,generation,for,final,string,blob,name,blobs,key,set,if,blob,name,starts,with,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,index,blob,during,finalization,snapshot,id,shard,id,blob,name,e,throw,e,for,final,string,blob,name,blobs,key,set,if,blob,name,starts,with,updated,snapshots,find,name,file,canonical,name,blob,name,null,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,data,blob,during,finalization,snapshot,id,shard,id,blob,name,e,catch,ioexception,e,string,message,failed,to,finalize,reason,with,shard,index,current,index,gen,throw,new,index,shard,snapshot,failed,exception,shard,id,message,e
BlobStoreRepository -> Context -> protected void finalize(final List<SnapshotFiles> snapshots,                                 final int fileListGeneration,                                 final Map<String, BlobMetaData> blobs,                                 final String reason);1543831870;Writes a new index file for the shard and removes all unreferenced files from the repository.__We need to be really careful in handling index files in case of failures to make sure we don't_have index file that points to files that were deleted.__@param snapshots          list of active snapshots in the container_@param fileListGeneration the generation number of the snapshot index file_@param blobs              list of blobs in the container_@param reason             a reason explaining why the shard index file is written;protected void finalize(final List<SnapshotFiles> snapshots,_                                final int fileListGeneration,_                                final Map<String, BlobMetaData> blobs,_                                final String reason) {_            final String indexGeneration = Integer.toString(fileListGeneration)__            final String currentIndexGen = indexShardSnapshotsFormat.blobName(indexGeneration)___            final BlobStoreIndexShardSnapshots updatedSnapshots = new BlobStoreIndexShardSnapshots(snapshots)__            try {_                _                _                for (final String blobName : blobs.keySet()) {_                    if (FsBlobContainer.isTempBlobName(blobName)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete index blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                            throw e__                        }_                    }_                }__                _                if (snapshots.size() > 0) {_                    indexShardSnapshotsFormat.writeAtomic(updatedSnapshots, blobContainer, indexGeneration)__                }__                _                for (final String blobName : blobs.keySet()) {_                    if (blobName.startsWith(SNAPSHOT_INDEX_PREFIX)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete index blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                            throw e__                        }_                    }_                }__                _                for (final String blobName : blobs.keySet()) {_                    if (blobName.startsWith(DATA_BLOB_PREFIX) && (updatedSnapshots.findNameFile(canonicalName(blobName)) == null)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete data blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                        }_                    }_                }_            } catch (IOException e) {_                String message = "Failed to finalize " + reason + " with shard index [" + currentIndexGen + "]"__                throw new IndexShardSnapshotFailedException(shardId, message, e)__            }_        };writes,a,new,index,file,for,the,shard,and,removes,all,unreferenced,files,from,the,repository,we,need,to,be,really,careful,in,handling,index,files,in,case,of,failures,to,make,sure,we,don,t,have,index,file,that,points,to,files,that,were,deleted,param,snapshots,list,of,active,snapshots,in,the,container,param,file,list,generation,the,generation,number,of,the,snapshot,index,file,param,blobs,list,of,blobs,in,the,container,param,reason,a,reason,explaining,why,the,shard,index,file,is,written;protected,void,finalize,final,list,snapshot,files,snapshots,final,int,file,list,generation,final,map,string,blob,meta,data,blobs,final,string,reason,final,string,index,generation,integer,to,string,file,list,generation,final,string,current,index,gen,index,shard,snapshots,format,blob,name,index,generation,final,blob,store,index,shard,snapshots,updated,snapshots,new,blob,store,index,shard,snapshots,snapshots,try,for,final,string,blob,name,blobs,key,set,if,fs,blob,container,is,temp,blob,name,blob,name,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,index,blob,during,finalization,snapshot,id,shard,id,blob,name,e,throw,e,if,snapshots,size,0,index,shard,snapshots,format,write,atomic,updated,snapshots,blob,container,index,generation,for,final,string,blob,name,blobs,key,set,if,blob,name,starts,with,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,index,blob,during,finalization,snapshot,id,shard,id,blob,name,e,throw,e,for,final,string,blob,name,blobs,key,set,if,blob,name,starts,with,updated,snapshots,find,name,file,canonical,name,blob,name,null,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,data,blob,during,finalization,snapshot,id,shard,id,blob,name,e,catch,ioexception,e,string,message,failed,to,finalize,reason,with,shard,index,current,index,gen,throw,new,index,shard,snapshot,failed,exception,shard,id,message,e
BlobStoreRepository -> Context -> protected void finalize(final List<SnapshotFiles> snapshots,                                 final int fileListGeneration,                                 final Map<String, BlobMetaData> blobs,                                 final String reason);1543942400;Writes a new index file for the shard and removes all unreferenced files from the repository.__We need to be really careful in handling index files in case of failures to make sure we don't_have index file that points to files that were deleted.__@param snapshots          list of active snapshots in the container_@param fileListGeneration the generation number of the snapshot index file_@param blobs              list of blobs in the container_@param reason             a reason explaining why the shard index file is written;protected void finalize(final List<SnapshotFiles> snapshots,_                                final int fileListGeneration,_                                final Map<String, BlobMetaData> blobs,_                                final String reason) {_            final String indexGeneration = Integer.toString(fileListGeneration)__            final String currentIndexGen = indexShardSnapshotsFormat.blobName(indexGeneration)___            final BlobStoreIndexShardSnapshots updatedSnapshots = new BlobStoreIndexShardSnapshots(snapshots)__            try {_                _                _                for (final String blobName : blobs.keySet()) {_                    if (FsBlobContainer.isTempBlobName(blobName)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete index blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                            throw e__                        }_                    }_                }__                _                if (snapshots.size() > 0) {_                    indexShardSnapshotsFormat.writeAtomic(updatedSnapshots, blobContainer, indexGeneration)__                }__                _                for (final String blobName : blobs.keySet()) {_                    if (blobName.startsWith(SNAPSHOT_INDEX_PREFIX)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete index blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                            throw e__                        }_                    }_                }__                _                for (final String blobName : blobs.keySet()) {_                    if (blobName.startsWith(DATA_BLOB_PREFIX) && (updatedSnapshots.findNameFile(canonicalName(blobName)) == null)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete data blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                        }_                    }_                }_            } catch (IOException e) {_                String message = "Failed to finalize " + reason + " with shard index [" + currentIndexGen + "]"__                throw new IndexShardSnapshotFailedException(shardId, message, e)__            }_        };writes,a,new,index,file,for,the,shard,and,removes,all,unreferenced,files,from,the,repository,we,need,to,be,really,careful,in,handling,index,files,in,case,of,failures,to,make,sure,we,don,t,have,index,file,that,points,to,files,that,were,deleted,param,snapshots,list,of,active,snapshots,in,the,container,param,file,list,generation,the,generation,number,of,the,snapshot,index,file,param,blobs,list,of,blobs,in,the,container,param,reason,a,reason,explaining,why,the,shard,index,file,is,written;protected,void,finalize,final,list,snapshot,files,snapshots,final,int,file,list,generation,final,map,string,blob,meta,data,blobs,final,string,reason,final,string,index,generation,integer,to,string,file,list,generation,final,string,current,index,gen,index,shard,snapshots,format,blob,name,index,generation,final,blob,store,index,shard,snapshots,updated,snapshots,new,blob,store,index,shard,snapshots,snapshots,try,for,final,string,blob,name,blobs,key,set,if,fs,blob,container,is,temp,blob,name,blob,name,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,index,blob,during,finalization,snapshot,id,shard,id,blob,name,e,throw,e,if,snapshots,size,0,index,shard,snapshots,format,write,atomic,updated,snapshots,blob,container,index,generation,for,final,string,blob,name,blobs,key,set,if,blob,name,starts,with,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,index,blob,during,finalization,snapshot,id,shard,id,blob,name,e,throw,e,for,final,string,blob,name,blobs,key,set,if,blob,name,starts,with,updated,snapshots,find,name,file,canonical,name,blob,name,null,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,data,blob,during,finalization,snapshot,id,shard,id,blob,name,e,catch,ioexception,e,string,message,failed,to,finalize,reason,with,shard,index,current,index,gen,throw,new,index,shard,snapshot,failed,exception,shard,id,message,e
BlobStoreRepository -> Context -> protected void finalize(final List<SnapshotFiles> snapshots,                                 final int fileListGeneration,                                 final Map<String, BlobMetaData> blobs,                                 final String reason);1546974294;Writes a new index file for the shard and removes all unreferenced files from the repository.__We need to be really careful in handling index files in case of failures to make sure we don't_have index file that points to files that were deleted.__@param snapshots          list of active snapshots in the container_@param fileListGeneration the generation number of the snapshot index file_@param blobs              list of blobs in the container_@param reason             a reason explaining why the shard index file is written;protected void finalize(final List<SnapshotFiles> snapshots,_                                final int fileListGeneration,_                                final Map<String, BlobMetaData> blobs,_                                final String reason) {_            final String indexGeneration = Integer.toString(fileListGeneration)__            final String currentIndexGen = indexShardSnapshotsFormat.blobName(indexGeneration)___            final BlobStoreIndexShardSnapshots updatedSnapshots = new BlobStoreIndexShardSnapshots(snapshots)__            try {_                _                _                for (final String blobName : blobs.keySet()) {_                    if (FsBlobContainer.isTempBlobName(blobName)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete index blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                            throw e__                        }_                    }_                }__                _                if (snapshots.size() > 0) {_                    indexShardSnapshotsFormat.writeAtomic(updatedSnapshots, blobContainer, indexGeneration)__                }__                _                for (final String blobName : blobs.keySet()) {_                    if (blobName.startsWith(SNAPSHOT_INDEX_PREFIX)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete index blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                            throw e__                        }_                    }_                }__                _                for (final String blobName : blobs.keySet()) {_                    if (blobName.startsWith(DATA_BLOB_PREFIX) && (updatedSnapshots.findNameFile(canonicalName(blobName)) == null)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete data blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                        }_                    }_                }_            } catch (IOException e) {_                String message = "Failed to finalize " + reason + " with shard index [" + currentIndexGen + "]"__                throw new IndexShardSnapshotFailedException(shardId, message, e)__            }_        };writes,a,new,index,file,for,the,shard,and,removes,all,unreferenced,files,from,the,repository,we,need,to,be,really,careful,in,handling,index,files,in,case,of,failures,to,make,sure,we,don,t,have,index,file,that,points,to,files,that,were,deleted,param,snapshots,list,of,active,snapshots,in,the,container,param,file,list,generation,the,generation,number,of,the,snapshot,index,file,param,blobs,list,of,blobs,in,the,container,param,reason,a,reason,explaining,why,the,shard,index,file,is,written;protected,void,finalize,final,list,snapshot,files,snapshots,final,int,file,list,generation,final,map,string,blob,meta,data,blobs,final,string,reason,final,string,index,generation,integer,to,string,file,list,generation,final,string,current,index,gen,index,shard,snapshots,format,blob,name,index,generation,final,blob,store,index,shard,snapshots,updated,snapshots,new,blob,store,index,shard,snapshots,snapshots,try,for,final,string,blob,name,blobs,key,set,if,fs,blob,container,is,temp,blob,name,blob,name,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,index,blob,during,finalization,snapshot,id,shard,id,blob,name,e,throw,e,if,snapshots,size,0,index,shard,snapshots,format,write,atomic,updated,snapshots,blob,container,index,generation,for,final,string,blob,name,blobs,key,set,if,blob,name,starts,with,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,index,blob,during,finalization,snapshot,id,shard,id,blob,name,e,throw,e,for,final,string,blob,name,blobs,key,set,if,blob,name,starts,with,updated,snapshots,find,name,file,canonical,name,blob,name,null,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,data,blob,during,finalization,snapshot,id,shard,id,blob,name,e,catch,ioexception,e,string,message,failed,to,finalize,reason,with,shard,index,current,index,gen,throw,new,index,shard,snapshot,failed,exception,shard,id,message,e
BlobStoreRepository -> Context -> protected void finalize(final List<SnapshotFiles> snapshots,                                 final int fileListGeneration,                                 final Map<String, BlobMetaData> blobs,                                 final String reason);1547496475;Writes a new index file for the shard and removes all unreferenced files from the repository.__We need to be really careful in handling index files in case of failures to make sure we don't_have index file that points to files that were deleted.__@param snapshots          list of active snapshots in the container_@param fileListGeneration the generation number of the snapshot index file_@param blobs              list of blobs in the container_@param reason             a reason explaining why the shard index file is written;protected void finalize(final List<SnapshotFiles> snapshots,_                                final int fileListGeneration,_                                final Map<String, BlobMetaData> blobs,_                                final String reason) {_            final String indexGeneration = Integer.toString(fileListGeneration)__            final String currentIndexGen = indexShardSnapshotsFormat.blobName(indexGeneration)___            final BlobStoreIndexShardSnapshots updatedSnapshots = new BlobStoreIndexShardSnapshots(snapshots)__            try {_                _                _                for (final String blobName : blobs.keySet()) {_                    if (FsBlobContainer.isTempBlobName(blobName)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete index blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                            throw e__                        }_                    }_                }__                _                if (snapshots.size() > 0) {_                    indexShardSnapshotsFormat.writeAtomic(updatedSnapshots, blobContainer, indexGeneration)__                }__                _                for (final String blobName : blobs.keySet()) {_                    if (blobName.startsWith(SNAPSHOT_INDEX_PREFIX)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete index blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                            throw e__                        }_                    }_                }__                _                for (final String blobName : blobs.keySet()) {_                    if (blobName.startsWith(DATA_BLOB_PREFIX) && (updatedSnapshots.findNameFile(canonicalName(blobName)) == null)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete data blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                        }_                    }_                }_            } catch (IOException e) {_                String message = "Failed to finalize " + reason + " with shard index [" + currentIndexGen + "]"__                throw new IndexShardSnapshotFailedException(shardId, message, e)__            }_        };writes,a,new,index,file,for,the,shard,and,removes,all,unreferenced,files,from,the,repository,we,need,to,be,really,careful,in,handling,index,files,in,case,of,failures,to,make,sure,we,don,t,have,index,file,that,points,to,files,that,were,deleted,param,snapshots,list,of,active,snapshots,in,the,container,param,file,list,generation,the,generation,number,of,the,snapshot,index,file,param,blobs,list,of,blobs,in,the,container,param,reason,a,reason,explaining,why,the,shard,index,file,is,written;protected,void,finalize,final,list,snapshot,files,snapshots,final,int,file,list,generation,final,map,string,blob,meta,data,blobs,final,string,reason,final,string,index,generation,integer,to,string,file,list,generation,final,string,current,index,gen,index,shard,snapshots,format,blob,name,index,generation,final,blob,store,index,shard,snapshots,updated,snapshots,new,blob,store,index,shard,snapshots,snapshots,try,for,final,string,blob,name,blobs,key,set,if,fs,blob,container,is,temp,blob,name,blob,name,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,index,blob,during,finalization,snapshot,id,shard,id,blob,name,e,throw,e,if,snapshots,size,0,index,shard,snapshots,format,write,atomic,updated,snapshots,blob,container,index,generation,for,final,string,blob,name,blobs,key,set,if,blob,name,starts,with,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,index,blob,during,finalization,snapshot,id,shard,id,blob,name,e,throw,e,for,final,string,blob,name,blobs,key,set,if,blob,name,starts,with,updated,snapshots,find,name,file,canonical,name,blob,name,null,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,data,blob,during,finalization,snapshot,id,shard,id,blob,name,e,catch,ioexception,e,string,message,failed,to,finalize,reason,with,shard,index,current,index,gen,throw,new,index,shard,snapshot,failed,exception,shard,id,message,e
BlobStoreRepository -> Context -> protected void finalize(final List<SnapshotFiles> snapshots,                                 final int fileListGeneration,                                 final Map<String, BlobMetaData> blobs,                                 final String reason);1547625930;Writes a new index file for the shard and removes all unreferenced files from the repository.__We need to be really careful in handling index files in case of failures to make sure we don't_have index file that points to files that were deleted.__@param snapshots          list of active snapshots in the container_@param fileListGeneration the generation number of the snapshot index file_@param blobs              list of blobs in the container_@param reason             a reason explaining why the shard index file is written;protected void finalize(final List<SnapshotFiles> snapshots,_                                final int fileListGeneration,_                                final Map<String, BlobMetaData> blobs,_                                final String reason) {_            final String indexGeneration = Integer.toString(fileListGeneration)__            final String currentIndexGen = indexShardSnapshotsFormat.blobName(indexGeneration)___            final BlobStoreIndexShardSnapshots updatedSnapshots = new BlobStoreIndexShardSnapshots(snapshots)__            try {_                _                _                for (final String blobName : blobs.keySet()) {_                    if (FsBlobContainer.isTempBlobName(blobName)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete index blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                            throw e__                        }_                    }_                }__                _                if (snapshots.size() > 0) {_                    indexShardSnapshotsFormat.writeAtomic(updatedSnapshots, blobContainer, indexGeneration)__                }__                _                for (final String blobName : blobs.keySet()) {_                    if (blobName.startsWith(SNAPSHOT_INDEX_PREFIX)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete index blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                            throw e__                        }_                    }_                }__                _                for (final String blobName : blobs.keySet()) {_                    if (blobName.startsWith(DATA_BLOB_PREFIX) && (updatedSnapshots.findNameFile(canonicalName(blobName)) == null)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete data blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                        }_                    }_                }_            } catch (IOException e) {_                String message = "Failed to finalize " + reason + " with shard index [" + currentIndexGen + "]"__                throw new IndexShardSnapshotFailedException(shardId, message, e)__            }_        };writes,a,new,index,file,for,the,shard,and,removes,all,unreferenced,files,from,the,repository,we,need,to,be,really,careful,in,handling,index,files,in,case,of,failures,to,make,sure,we,don,t,have,index,file,that,points,to,files,that,were,deleted,param,snapshots,list,of,active,snapshots,in,the,container,param,file,list,generation,the,generation,number,of,the,snapshot,index,file,param,blobs,list,of,blobs,in,the,container,param,reason,a,reason,explaining,why,the,shard,index,file,is,written;protected,void,finalize,final,list,snapshot,files,snapshots,final,int,file,list,generation,final,map,string,blob,meta,data,blobs,final,string,reason,final,string,index,generation,integer,to,string,file,list,generation,final,string,current,index,gen,index,shard,snapshots,format,blob,name,index,generation,final,blob,store,index,shard,snapshots,updated,snapshots,new,blob,store,index,shard,snapshots,snapshots,try,for,final,string,blob,name,blobs,key,set,if,fs,blob,container,is,temp,blob,name,blob,name,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,index,blob,during,finalization,snapshot,id,shard,id,blob,name,e,throw,e,if,snapshots,size,0,index,shard,snapshots,format,write,atomic,updated,snapshots,blob,container,index,generation,for,final,string,blob,name,blobs,key,set,if,blob,name,starts,with,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,index,blob,during,finalization,snapshot,id,shard,id,blob,name,e,throw,e,for,final,string,blob,name,blobs,key,set,if,blob,name,starts,with,updated,snapshots,find,name,file,canonical,name,blob,name,null,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,data,blob,during,finalization,snapshot,id,shard,id,blob,name,e,catch,ioexception,e,string,message,failed,to,finalize,reason,with,shard,index,current,index,gen,throw,new,index,shard,snapshot,failed,exception,shard,id,message,e
BlobStoreRepository -> Context -> protected void finalize(final List<SnapshotFiles> snapshots,                                 final int fileListGeneration,                                 final Map<String, BlobMetaData> blobs,                                 final String reason);1550647627;Writes a new index file for the shard and removes all unreferenced files from the repository.__We need to be really careful in handling index files in case of failures to make sure we don't_have index file that points to files that were deleted.__@param snapshots          list of active snapshots in the container_@param fileListGeneration the generation number of the snapshot index file_@param blobs              list of blobs in the container_@param reason             a reason explaining why the shard index file is written;protected void finalize(final List<SnapshotFiles> snapshots,_                                final int fileListGeneration,_                                final Map<String, BlobMetaData> blobs,_                                final String reason) {_            final String indexGeneration = Integer.toString(fileListGeneration)__            final String currentIndexGen = indexShardSnapshotsFormat.blobName(indexGeneration)___            final BlobStoreIndexShardSnapshots updatedSnapshots = new BlobStoreIndexShardSnapshots(snapshots)__            try {_                _                _                for (final String blobName : blobs.keySet()) {_                    if (FsBlobContainer.isTempBlobName(blobName)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete index blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                            throw e__                        }_                    }_                }__                _                if (snapshots.size() > 0) {_                    indexShardSnapshotsFormat.writeAtomic(updatedSnapshots, blobContainer, indexGeneration)__                }__                _                for (final String blobName : blobs.keySet()) {_                    if (blobName.startsWith(SNAPSHOT_INDEX_PREFIX)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete index blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                            throw e__                        }_                    }_                }__                _                for (final String blobName : blobs.keySet()) {_                    if (blobName.startsWith(DATA_BLOB_PREFIX) && (updatedSnapshots.findNameFile(canonicalName(blobName)) == null)) {_                        try {_                            blobContainer.deleteBlobIgnoringIfNotExists(blobName)__                        } catch (IOException e) {_                            logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to delete data blob [{}] during finalization",_                                snapshotId, shardId, blobName), e)__                        }_                    }_                }_            } catch (IOException e) {_                String message = "Failed to finalize " + reason + " with shard index [" + currentIndexGen + "]"__                throw new IndexShardSnapshotFailedException(shardId, message, e)__            }_        };writes,a,new,index,file,for,the,shard,and,removes,all,unreferenced,files,from,the,repository,we,need,to,be,really,careful,in,handling,index,files,in,case,of,failures,to,make,sure,we,don,t,have,index,file,that,points,to,files,that,were,deleted,param,snapshots,list,of,active,snapshots,in,the,container,param,file,list,generation,the,generation,number,of,the,snapshot,index,file,param,blobs,list,of,blobs,in,the,container,param,reason,a,reason,explaining,why,the,shard,index,file,is,written;protected,void,finalize,final,list,snapshot,files,snapshots,final,int,file,list,generation,final,map,string,blob,meta,data,blobs,final,string,reason,final,string,index,generation,integer,to,string,file,list,generation,final,string,current,index,gen,index,shard,snapshots,format,blob,name,index,generation,final,blob,store,index,shard,snapshots,updated,snapshots,new,blob,store,index,shard,snapshots,snapshots,try,for,final,string,blob,name,blobs,key,set,if,fs,blob,container,is,temp,blob,name,blob,name,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,index,blob,during,finalization,snapshot,id,shard,id,blob,name,e,throw,e,if,snapshots,size,0,index,shard,snapshots,format,write,atomic,updated,snapshots,blob,container,index,generation,for,final,string,blob,name,blobs,key,set,if,blob,name,starts,with,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,index,blob,during,finalization,snapshot,id,shard,id,blob,name,e,throw,e,for,final,string,blob,name,blobs,key,set,if,blob,name,starts,with,updated,snapshots,find,name,file,canonical,name,blob,name,null,try,blob,container,delete,blob,ignoring,if,not,exists,blob,name,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,delete,data,blob,during,finalization,snapshot,id,shard,id,blob,name,e,catch,ioexception,e,string,message,failed,to,finalize,reason,with,shard,index,current,index,gen,throw,new,index,shard,snapshot,failed,exception,shard,id,message,e
BlobStoreRepository -> private RateLimiter getRateLimiter(Settings repositorySettings, String setting, ByteSizeValue defaultRate);1524684173;Configures RateLimiter based on repository and global settings__@param repositorySettings repository settings_@param setting            setting to use to configure rate limiter_@param defaultRate        default limiting rate_@return rate limiter or null of no throttling is needed;private RateLimiter getRateLimiter(Settings repositorySettings, String setting, ByteSizeValue defaultRate) {_        ByteSizeValue maxSnapshotBytesPerSec = repositorySettings.getAsBytesSize(setting,_                settings.getAsBytesSize(setting, defaultRate))__        if (maxSnapshotBytesPerSec.getBytes() <= 0) {_            return null__        } else {_            return new RateLimiter.SimpleRateLimiter(maxSnapshotBytesPerSec.getMbFrac())__        }_    };configures,rate,limiter,based,on,repository,and,global,settings,param,repository,settings,repository,settings,param,setting,setting,to,use,to,configure,rate,limiter,param,default,rate,default,limiting,rate,return,rate,limiter,or,null,of,no,throttling,is,needed;private,rate,limiter,get,rate,limiter,settings,repository,settings,string,setting,byte,size,value,default,rate,byte,size,value,max,snapshot,bytes,per,sec,repository,settings,get,as,bytes,size,setting,settings,get,as,bytes,size,setting,default,rate,if,max,snapshot,bytes,per,sec,get,bytes,0,return,null,else,return,new,rate,limiter,simple,rate,limiter,max,snapshot,bytes,per,sec,get,mb,frac
BlobStoreRepository -> private RateLimiter getRateLimiter(Settings repositorySettings, String setting, ByteSizeValue defaultRate);1525334055;Configures RateLimiter based on repository and global settings__@param repositorySettings repository settings_@param setting            setting to use to configure rate limiter_@param defaultRate        default limiting rate_@return rate limiter or null of no throttling is needed;private RateLimiter getRateLimiter(Settings repositorySettings, String setting, ByteSizeValue defaultRate) {_        ByteSizeValue maxSnapshotBytesPerSec = repositorySettings.getAsBytesSize(setting,_                settings.getAsBytesSize(setting, defaultRate))__        if (maxSnapshotBytesPerSec.getBytes() <= 0) {_            return null__        } else {_            return new RateLimiter.SimpleRateLimiter(maxSnapshotBytesPerSec.getMbFrac())__        }_    };configures,rate,limiter,based,on,repository,and,global,settings,param,repository,settings,repository,settings,param,setting,setting,to,use,to,configure,rate,limiter,param,default,rate,default,limiting,rate,return,rate,limiter,or,null,of,no,throttling,is,needed;private,rate,limiter,get,rate,limiter,settings,repository,settings,string,setting,byte,size,value,default,rate,byte,size,value,max,snapshot,bytes,per,sec,repository,settings,get,as,bytes,size,setting,settings,get,as,bytes,size,setting,default,rate,if,max,snapshot,bytes,per,sec,get,bytes,0,return,null,else,return,new,rate,limiter,simple,rate,limiter,max,snapshot,bytes,per,sec,get,mb,frac
BlobStoreRepository -> private RateLimiter getRateLimiter(Settings repositorySettings, String setting, ByteSizeValue defaultRate);1525798020;Configures RateLimiter based on repository and global settings__@param repositorySettings repository settings_@param setting            setting to use to configure rate limiter_@param defaultRate        default limiting rate_@return rate limiter or null of no throttling is needed;private RateLimiter getRateLimiter(Settings repositorySettings, String setting, ByteSizeValue defaultRate) {_        ByteSizeValue maxSnapshotBytesPerSec = repositorySettings.getAsBytesSize(setting,_                settings.getAsBytesSize(setting, defaultRate))__        if (maxSnapshotBytesPerSec.getBytes() <= 0) {_            return null__        } else {_            return new RateLimiter.SimpleRateLimiter(maxSnapshotBytesPerSec.getMbFrac())__        }_    };configures,rate,limiter,based,on,repository,and,global,settings,param,repository,settings,repository,settings,param,setting,setting,to,use,to,configure,rate,limiter,param,default,rate,default,limiting,rate,return,rate,limiter,or,null,of,no,throttling,is,needed;private,rate,limiter,get,rate,limiter,settings,repository,settings,string,setting,byte,size,value,default,rate,byte,size,value,max,snapshot,bytes,per,sec,repository,settings,get,as,bytes,size,setting,settings,get,as,bytes,size,setting,default,rate,if,max,snapshot,bytes,per,sec,get,bytes,0,return,null,else,return,new,rate,limiter,simple,rate,limiter,max,snapshot,bytes,per,sec,get,mb,frac
BlobStoreRepository -> private RateLimiter getRateLimiter(Settings repositorySettings, String setting, ByteSizeValue defaultRate);1526289033;Configures RateLimiter based on repository and global settings__@param repositorySettings repository settings_@param setting            setting to use to configure rate limiter_@param defaultRate        default limiting rate_@return rate limiter or null of no throttling is needed;private RateLimiter getRateLimiter(Settings repositorySettings, String setting, ByteSizeValue defaultRate) {_        ByteSizeValue maxSnapshotBytesPerSec = repositorySettings.getAsBytesSize(setting,_                settings.getAsBytesSize(setting, defaultRate))__        if (maxSnapshotBytesPerSec.getBytes() <= 0) {_            return null__        } else {_            return new RateLimiter.SimpleRateLimiter(maxSnapshotBytesPerSec.getMbFrac())__        }_    };configures,rate,limiter,based,on,repository,and,global,settings,param,repository,settings,repository,settings,param,setting,setting,to,use,to,configure,rate,limiter,param,default,rate,default,limiting,rate,return,rate,limiter,or,null,of,no,throttling,is,needed;private,rate,limiter,get,rate,limiter,settings,repository,settings,string,setting,byte,size,value,default,rate,byte,size,value,max,snapshot,bytes,per,sec,repository,settings,get,as,bytes,size,setting,settings,get,as,bytes,size,setting,default,rate,if,max,snapshot,bytes,per,sec,get,bytes,0,return,null,else,return,new,rate,limiter,simple,rate,limiter,max,snapshot,bytes,per,sec,get,mb,frac
BlobStoreRepository -> private RateLimiter getRateLimiter(Settings repositorySettings, String setting, ByteSizeValue defaultRate);1526574077;Configures RateLimiter based on repository and global settings__@param repositorySettings repository settings_@param setting            setting to use to configure rate limiter_@param defaultRate        default limiting rate_@return rate limiter or null of no throttling is needed;private RateLimiter getRateLimiter(Settings repositorySettings, String setting, ByteSizeValue defaultRate) {_        ByteSizeValue maxSnapshotBytesPerSec = repositorySettings.getAsBytesSize(setting,_                settings.getAsBytesSize(setting, defaultRate))__        if (maxSnapshotBytesPerSec.getBytes() <= 0) {_            return null__        } else {_            return new RateLimiter.SimpleRateLimiter(maxSnapshotBytesPerSec.getMbFrac())__        }_    };configures,rate,limiter,based,on,repository,and,global,settings,param,repository,settings,repository,settings,param,setting,setting,to,use,to,configure,rate,limiter,param,default,rate,default,limiting,rate,return,rate,limiter,or,null,of,no,throttling,is,needed;private,rate,limiter,get,rate,limiter,settings,repository,settings,string,setting,byte,size,value,default,rate,byte,size,value,max,snapshot,bytes,per,sec,repository,settings,get,as,bytes,size,setting,settings,get,as,bytes,size,setting,default,rate,if,max,snapshot,bytes,per,sec,get,bytes,0,return,null,else,return,new,rate,limiter,simple,rate,limiter,max,snapshot,bytes,per,sec,get,mb,frac
BlobStoreRepository -> private RateLimiter getRateLimiter(Settings repositorySettings, String setting, ByteSizeValue defaultRate);1527583663;Configures RateLimiter based on repository and global settings__@param repositorySettings repository settings_@param setting            setting to use to configure rate limiter_@param defaultRate        default limiting rate_@return rate limiter or null of no throttling is needed;private RateLimiter getRateLimiter(Settings repositorySettings, String setting, ByteSizeValue defaultRate) {_        ByteSizeValue maxSnapshotBytesPerSec = repositorySettings.getAsBytesSize(setting,_                settings.getAsBytesSize(setting, defaultRate))__        if (maxSnapshotBytesPerSec.getBytes() <= 0) {_            return null__        } else {_            return new RateLimiter.SimpleRateLimiter(maxSnapshotBytesPerSec.getMbFrac())__        }_    };configures,rate,limiter,based,on,repository,and,global,settings,param,repository,settings,repository,settings,param,setting,setting,to,use,to,configure,rate,limiter,param,default,rate,default,limiting,rate,return,rate,limiter,or,null,of,no,throttling,is,needed;private,rate,limiter,get,rate,limiter,settings,repository,settings,string,setting,byte,size,value,default,rate,byte,size,value,max,snapshot,bytes,per,sec,repository,settings,get,as,bytes,size,setting,settings,get,as,bytes,size,setting,default,rate,if,max,snapshot,bytes,per,sec,get,bytes,0,return,null,else,return,new,rate,limiter,simple,rate,limiter,max,snapshot,bytes,per,sec,get,mb,frac
BlobStoreRepository -> private RateLimiter getRateLimiter(Settings repositorySettings, String setting, ByteSizeValue defaultRate);1528211342;Configures RateLimiter based on repository and global settings__@param repositorySettings repository settings_@param setting            setting to use to configure rate limiter_@param defaultRate        default limiting rate_@return rate limiter or null of no throttling is needed;private RateLimiter getRateLimiter(Settings repositorySettings, String setting, ByteSizeValue defaultRate) {_        ByteSizeValue maxSnapshotBytesPerSec = repositorySettings.getAsBytesSize(setting,_                settings.getAsBytesSize(setting, defaultRate))__        if (maxSnapshotBytesPerSec.getBytes() <= 0) {_            return null__        } else {_            return new RateLimiter.SimpleRateLimiter(maxSnapshotBytesPerSec.getMbFrac())__        }_    };configures,rate,limiter,based,on,repository,and,global,settings,param,repository,settings,repository,settings,param,setting,setting,to,use,to,configure,rate,limiter,param,default,rate,default,limiting,rate,return,rate,limiter,or,null,of,no,throttling,is,needed;private,rate,limiter,get,rate,limiter,settings,repository,settings,string,setting,byte,size,value,default,rate,byte,size,value,max,snapshot,bytes,per,sec,repository,settings,get,as,bytes,size,setting,settings,get,as,bytes,size,setting,default,rate,if,max,snapshot,bytes,per,sec,get,bytes,0,return,null,else,return,new,rate,limiter,simple,rate,limiter,max,snapshot,bytes,per,sec,get,mb,frac
BlobStoreRepository -> private RateLimiter getRateLimiter(Settings repositorySettings, String setting, ByteSizeValue defaultRate);1531179852;Configures RateLimiter based on repository and global settings__@param repositorySettings repository settings_@param setting            setting to use to configure rate limiter_@param defaultRate        default limiting rate_@return rate limiter or null of no throttling is needed;private RateLimiter getRateLimiter(Settings repositorySettings, String setting, ByteSizeValue defaultRate) {_        ByteSizeValue maxSnapshotBytesPerSec = repositorySettings.getAsBytesSize(setting,_                settings.getAsBytesSize(setting, defaultRate))__        if (maxSnapshotBytesPerSec.getBytes() <= 0) {_            return null__        } else {_            return new RateLimiter.SimpleRateLimiter(maxSnapshotBytesPerSec.getMbFrac())__        }_    };configures,rate,limiter,based,on,repository,and,global,settings,param,repository,settings,repository,settings,param,setting,setting,to,use,to,configure,rate,limiter,param,default,rate,default,limiting,rate,return,rate,limiter,or,null,of,no,throttling,is,needed;private,rate,limiter,get,rate,limiter,settings,repository,settings,string,setting,byte,size,value,default,rate,byte,size,value,max,snapshot,bytes,per,sec,repository,settings,get,as,bytes,size,setting,settings,get,as,bytes,size,setting,default,rate,if,max,snapshot,bytes,per,sec,get,bytes,0,return,null,else,return,new,rate,limiter,simple,rate,limiter,max,snapshot,bytes,per,sec,get,mb,frac
BlobStoreRepository -> private RateLimiter getRateLimiter(Settings repositorySettings, String setting, ByteSizeValue defaultRate);1531729807;Configures RateLimiter based on repository and global settings__@param repositorySettings repository settings_@param setting            setting to use to configure rate limiter_@param defaultRate        default limiting rate_@return rate limiter or null of no throttling is needed;private RateLimiter getRateLimiter(Settings repositorySettings, String setting, ByteSizeValue defaultRate) {_        ByteSizeValue maxSnapshotBytesPerSec = repositorySettings.getAsBytesSize(setting,_                settings.getAsBytesSize(setting, defaultRate))__        if (maxSnapshotBytesPerSec.getBytes() <= 0) {_            return null__        } else {_            return new RateLimiter.SimpleRateLimiter(maxSnapshotBytesPerSec.getMbFrac())__        }_    };configures,rate,limiter,based,on,repository,and,global,settings,param,repository,settings,repository,settings,param,setting,setting,to,use,to,configure,rate,limiter,param,default,rate,default,limiting,rate,return,rate,limiter,or,null,of,no,throttling,is,needed;private,rate,limiter,get,rate,limiter,settings,repository,settings,string,setting,byte,size,value,default,rate,byte,size,value,max,snapshot,bytes,per,sec,repository,settings,get,as,bytes,size,setting,settings,get,as,bytes,size,setting,default,rate,if,max,snapshot,bytes,per,sec,get,bytes,0,return,null,else,return,new,rate,limiter,simple,rate,limiter,max,snapshot,bytes,per,sec,get,mb,frac
BlobStoreRepository -> private RateLimiter getRateLimiter(Settings repositorySettings, String setting, ByteSizeValue defaultRate);1532685069;Configures RateLimiter based on repository and global settings__@param repositorySettings repository settings_@param setting            setting to use to configure rate limiter_@param defaultRate        default limiting rate_@return rate limiter or null of no throttling is needed;private RateLimiter getRateLimiter(Settings repositorySettings, String setting, ByteSizeValue defaultRate) {_        ByteSizeValue maxSnapshotBytesPerSec = repositorySettings.getAsBytesSize(setting,_                settings.getAsBytesSize(setting, defaultRate))__        if (maxSnapshotBytesPerSec.getBytes() <= 0) {_            return null__        } else {_            return new RateLimiter.SimpleRateLimiter(maxSnapshotBytesPerSec.getMbFrac())__        }_    };configures,rate,limiter,based,on,repository,and,global,settings,param,repository,settings,repository,settings,param,setting,setting,to,use,to,configure,rate,limiter,param,default,rate,default,limiting,rate,return,rate,limiter,or,null,of,no,throttling,is,needed;private,rate,limiter,get,rate,limiter,settings,repository,settings,string,setting,byte,size,value,default,rate,byte,size,value,max,snapshot,bytes,per,sec,repository,settings,get,as,bytes,size,setting,settings,get,as,bytes,size,setting,default,rate,if,max,snapshot,bytes,per,sec,get,bytes,0,return,null,else,return,new,rate,limiter,simple,rate,limiter,max,snapshot,bytes,per,sec,get,mb,frac
BlobStoreRepository -> private RateLimiter getRateLimiter(Settings repositorySettings, String setting, ByteSizeValue defaultRate);1535139672;Configures RateLimiter based on repository and global settings__@param repositorySettings repository settings_@param setting            setting to use to configure rate limiter_@param defaultRate        default limiting rate_@return rate limiter or null of no throttling is needed;private RateLimiter getRateLimiter(Settings repositorySettings, String setting, ByteSizeValue defaultRate) {_        ByteSizeValue maxSnapshotBytesPerSec = repositorySettings.getAsBytesSize(setting,_                settings.getAsBytesSize(setting, defaultRate))__        if (maxSnapshotBytesPerSec.getBytes() <= 0) {_            return null__        } else {_            return new RateLimiter.SimpleRateLimiter(maxSnapshotBytesPerSec.getMbFrac())__        }_    };configures,rate,limiter,based,on,repository,and,global,settings,param,repository,settings,repository,settings,param,setting,setting,to,use,to,configure,rate,limiter,param,default,rate,default,limiting,rate,return,rate,limiter,or,null,of,no,throttling,is,needed;private,rate,limiter,get,rate,limiter,settings,repository,settings,string,setting,byte,size,value,default,rate,byte,size,value,max,snapshot,bytes,per,sec,repository,settings,get,as,bytes,size,setting,settings,get,as,bytes,size,setting,default,rate,if,max,snapshot,bytes,per,sec,get,bytes,0,return,null,else,return,new,rate,limiter,simple,rate,limiter,max,snapshot,bytes,per,sec,get,mb,frac
BlobStoreRepository -> private RateLimiter getRateLimiter(Settings repositorySettings, String setting, ByteSizeValue defaultRate);1535723122;Configures RateLimiter based on repository and global settings__@param repositorySettings repository settings_@param setting            setting to use to configure rate limiter_@param defaultRate        default limiting rate_@return rate limiter or null of no throttling is needed;private RateLimiter getRateLimiter(Settings repositorySettings, String setting, ByteSizeValue defaultRate) {_        ByteSizeValue maxSnapshotBytesPerSec = repositorySettings.getAsBytesSize(setting,_                settings.getAsBytesSize(setting, defaultRate))__        if (maxSnapshotBytesPerSec.getBytes() <= 0) {_            return null__        } else {_            return new RateLimiter.SimpleRateLimiter(maxSnapshotBytesPerSec.getMbFrac())__        }_    };configures,rate,limiter,based,on,repository,and,global,settings,param,repository,settings,repository,settings,param,setting,setting,to,use,to,configure,rate,limiter,param,default,rate,default,limiting,rate,return,rate,limiter,or,null,of,no,throttling,is,needed;private,rate,limiter,get,rate,limiter,settings,repository,settings,string,setting,byte,size,value,default,rate,byte,size,value,max,snapshot,bytes,per,sec,repository,settings,get,as,bytes,size,setting,settings,get,as,bytes,size,setting,default,rate,if,max,snapshot,bytes,per,sec,get,bytes,0,return,null,else,return,new,rate,limiter,simple,rate,limiter,max,snapshot,bytes,per,sec,get,mb,frac
BlobStoreRepository -> private RateLimiter getRateLimiter(Settings repositorySettings, String setting, ByteSizeValue defaultRate);1536314350;Configures RateLimiter based on repository and global settings__@param repositorySettings repository settings_@param setting            setting to use to configure rate limiter_@param defaultRate        default limiting rate_@return rate limiter or null of no throttling is needed;private RateLimiter getRateLimiter(Settings repositorySettings, String setting, ByteSizeValue defaultRate) {_        ByteSizeValue maxSnapshotBytesPerSec = repositorySettings.getAsBytesSize(setting,_                settings.getAsBytesSize(setting, defaultRate))__        if (maxSnapshotBytesPerSec.getBytes() <= 0) {_            return null__        } else {_            return new RateLimiter.SimpleRateLimiter(maxSnapshotBytesPerSec.getMbFrac())__        }_    };configures,rate,limiter,based,on,repository,and,global,settings,param,repository,settings,repository,settings,param,setting,setting,to,use,to,configure,rate,limiter,param,default,rate,default,limiting,rate,return,rate,limiter,or,null,of,no,throttling,is,needed;private,rate,limiter,get,rate,limiter,settings,repository,settings,string,setting,byte,size,value,default,rate,byte,size,value,max,snapshot,bytes,per,sec,repository,settings,get,as,bytes,size,setting,settings,get,as,bytes,size,setting,default,rate,if,max,snapshot,bytes,per,sec,get,bytes,0,return,null,else,return,new,rate,limiter,simple,rate,limiter,max,snapshot,bytes,per,sec,get,mb,frac
BlobStoreRepository -> private RateLimiter getRateLimiter(Settings repositorySettings, String setting, ByteSizeValue defaultRate);1536828374;Configures RateLimiter based on repository and global settings__@param repositorySettings repository settings_@param setting            setting to use to configure rate limiter_@param defaultRate        default limiting rate_@return rate limiter or null of no throttling is needed;private RateLimiter getRateLimiter(Settings repositorySettings, String setting, ByteSizeValue defaultRate) {_        ByteSizeValue maxSnapshotBytesPerSec = repositorySettings.getAsBytesSize(setting,_                settings.getAsBytesSize(setting, defaultRate))__        if (maxSnapshotBytesPerSec.getBytes() <= 0) {_            return null__        } else {_            return new RateLimiter.SimpleRateLimiter(maxSnapshotBytesPerSec.getMbFrac())__        }_    };configures,rate,limiter,based,on,repository,and,global,settings,param,repository,settings,repository,settings,param,setting,setting,to,use,to,configure,rate,limiter,param,default,rate,default,limiting,rate,return,rate,limiter,or,null,of,no,throttling,is,needed;private,rate,limiter,get,rate,limiter,settings,repository,settings,string,setting,byte,size,value,default,rate,byte,size,value,max,snapshot,bytes,per,sec,repository,settings,get,as,bytes,size,setting,settings,get,as,bytes,size,setting,default,rate,if,max,snapshot,bytes,per,sec,get,bytes,0,return,null,else,return,new,rate,limiter,simple,rate,limiter,max,snapshot,bytes,per,sec,get,mb,frac
BlobStoreRepository -> private RateLimiter getRateLimiter(Settings repositorySettings, String setting, ByteSizeValue defaultRate);1541008027;Configures RateLimiter based on repository and global settings__@param repositorySettings repository settings_@param setting            setting to use to configure rate limiter_@param defaultRate        default limiting rate_@return rate limiter or null of no throttling is needed;private RateLimiter getRateLimiter(Settings repositorySettings, String setting, ByteSizeValue defaultRate) {_        ByteSizeValue maxSnapshotBytesPerSec = repositorySettings.getAsBytesSize(setting,_                settings.getAsBytesSize(setting, defaultRate))__        if (maxSnapshotBytesPerSec.getBytes() <= 0) {_            return null__        } else {_            return new RateLimiter.SimpleRateLimiter(maxSnapshotBytesPerSec.getMbFrac())__        }_    };configures,rate,limiter,based,on,repository,and,global,settings,param,repository,settings,repository,settings,param,setting,setting,to,use,to,configure,rate,limiter,param,default,rate,default,limiting,rate,return,rate,limiter,or,null,of,no,throttling,is,needed;private,rate,limiter,get,rate,limiter,settings,repository,settings,string,setting,byte,size,value,default,rate,byte,size,value,max,snapshot,bytes,per,sec,repository,settings,get,as,bytes,size,setting,settings,get,as,bytes,size,setting,default,rate,if,max,snapshot,bytes,per,sec,get,bytes,0,return,null,else,return,new,rate,limiter,simple,rate,limiter,max,snapshot,bytes,per,sec,get,mb,frac
BlobStoreRepository -> private RateLimiter getRateLimiter(Settings repositorySettings, String setting, ByteSizeValue defaultRate);1542646292;Configures RateLimiter based on repository and global settings__@param repositorySettings repository settings_@param setting            setting to use to configure rate limiter_@param defaultRate        default limiting rate_@return rate limiter or null of no throttling is needed;private RateLimiter getRateLimiter(Settings repositorySettings, String setting, ByteSizeValue defaultRate) {_        ByteSizeValue maxSnapshotBytesPerSec = repositorySettings.getAsBytesSize(setting,_                settings.getAsBytesSize(setting, defaultRate))__        if (maxSnapshotBytesPerSec.getBytes() <= 0) {_            return null__        } else {_            return new RateLimiter.SimpleRateLimiter(maxSnapshotBytesPerSec.getMbFrac())__        }_    };configures,rate,limiter,based,on,repository,and,global,settings,param,repository,settings,repository,settings,param,setting,setting,to,use,to,configure,rate,limiter,param,default,rate,default,limiting,rate,return,rate,limiter,or,null,of,no,throttling,is,needed;private,rate,limiter,get,rate,limiter,settings,repository,settings,string,setting,byte,size,value,default,rate,byte,size,value,max,snapshot,bytes,per,sec,repository,settings,get,as,bytes,size,setting,settings,get,as,bytes,size,setting,default,rate,if,max,snapshot,bytes,per,sec,get,bytes,0,return,null,else,return,new,rate,limiter,simple,rate,limiter,max,snapshot,bytes,per,sec,get,mb,frac
BlobStoreRepository -> private RateLimiter getRateLimiter(Settings repositorySettings, String setting, ByteSizeValue defaultRate);1542980705;Configures RateLimiter based on repository and global settings__@param repositorySettings repository settings_@param setting            setting to use to configure rate limiter_@param defaultRate        default limiting rate_@return rate limiter or null of no throttling is needed;private RateLimiter getRateLimiter(Settings repositorySettings, String setting, ByteSizeValue defaultRate) {_        ByteSizeValue maxSnapshotBytesPerSec = repositorySettings.getAsBytesSize(setting,_                settings.getAsBytesSize(setting, defaultRate))__        if (maxSnapshotBytesPerSec.getBytes() <= 0) {_            return null__        } else {_            return new RateLimiter.SimpleRateLimiter(maxSnapshotBytesPerSec.getMbFrac())__        }_    };configures,rate,limiter,based,on,repository,and,global,settings,param,repository,settings,repository,settings,param,setting,setting,to,use,to,configure,rate,limiter,param,default,rate,default,limiting,rate,return,rate,limiter,or,null,of,no,throttling,is,needed;private,rate,limiter,get,rate,limiter,settings,repository,settings,string,setting,byte,size,value,default,rate,byte,size,value,max,snapshot,bytes,per,sec,repository,settings,get,as,bytes,size,setting,settings,get,as,bytes,size,setting,default,rate,if,max,snapshot,bytes,per,sec,get,bytes,0,return,null,else,return,new,rate,limiter,simple,rate,limiter,max,snapshot,bytes,per,sec,get,mb,frac
BlobStoreRepository -> private RateLimiter getRateLimiter(Settings repositorySettings, String setting, ByteSizeValue defaultRate);1543831870;Configures RateLimiter based on repository and global settings__@param repositorySettings repository settings_@param setting            setting to use to configure rate limiter_@param defaultRate        default limiting rate_@return rate limiter or null of no throttling is needed;private RateLimiter getRateLimiter(Settings repositorySettings, String setting, ByteSizeValue defaultRate) {_        ByteSizeValue maxSnapshotBytesPerSec = repositorySettings.getAsBytesSize(setting,_                settings.getAsBytesSize(setting, defaultRate))__        if (maxSnapshotBytesPerSec.getBytes() <= 0) {_            return null__        } else {_            return new RateLimiter.SimpleRateLimiter(maxSnapshotBytesPerSec.getMbFrac())__        }_    };configures,rate,limiter,based,on,repository,and,global,settings,param,repository,settings,repository,settings,param,setting,setting,to,use,to,configure,rate,limiter,param,default,rate,default,limiting,rate,return,rate,limiter,or,null,of,no,throttling,is,needed;private,rate,limiter,get,rate,limiter,settings,repository,settings,string,setting,byte,size,value,default,rate,byte,size,value,max,snapshot,bytes,per,sec,repository,settings,get,as,bytes,size,setting,settings,get,as,bytes,size,setting,default,rate,if,max,snapshot,bytes,per,sec,get,bytes,0,return,null,else,return,new,rate,limiter,simple,rate,limiter,max,snapshot,bytes,per,sec,get,mb,frac
BlobStoreRepository -> private RateLimiter getRateLimiter(Settings repositorySettings, String setting, ByteSizeValue defaultRate);1543942400;Configures RateLimiter based on repository and global settings__@param repositorySettings repository settings_@param setting            setting to use to configure rate limiter_@param defaultRate        default limiting rate_@return rate limiter or null of no throttling is needed;private RateLimiter getRateLimiter(Settings repositorySettings, String setting, ByteSizeValue defaultRate) {_        ByteSizeValue maxSnapshotBytesPerSec = repositorySettings.getAsBytesSize(setting,_                settings.getAsBytesSize(setting, defaultRate))__        if (maxSnapshotBytesPerSec.getBytes() <= 0) {_            return null__        } else {_            return new RateLimiter.SimpleRateLimiter(maxSnapshotBytesPerSec.getMbFrac())__        }_    };configures,rate,limiter,based,on,repository,and,global,settings,param,repository,settings,repository,settings,param,setting,setting,to,use,to,configure,rate,limiter,param,default,rate,default,limiting,rate,return,rate,limiter,or,null,of,no,throttling,is,needed;private,rate,limiter,get,rate,limiter,settings,repository,settings,string,setting,byte,size,value,default,rate,byte,size,value,max,snapshot,bytes,per,sec,repository,settings,get,as,bytes,size,setting,settings,get,as,bytes,size,setting,default,rate,if,max,snapshot,bytes,per,sec,get,bytes,0,return,null,else,return,new,rate,limiter,simple,rate,limiter,max,snapshot,bytes,per,sec,get,mb,frac
BlobStoreRepository -> private RateLimiter getRateLimiter(Settings repositorySettings, String setting, ByteSizeValue defaultRate);1546974294;Configures RateLimiter based on repository and global settings__@param repositorySettings repository settings_@param setting            setting to use to configure rate limiter_@param defaultRate        default limiting rate_@return rate limiter or null of no throttling is needed;private RateLimiter getRateLimiter(Settings repositorySettings, String setting, ByteSizeValue defaultRate) {_        ByteSizeValue maxSnapshotBytesPerSec = repositorySettings.getAsBytesSize(setting,_                settings.getAsBytesSize(setting, defaultRate))__        if (maxSnapshotBytesPerSec.getBytes() <= 0) {_            return null__        } else {_            return new RateLimiter.SimpleRateLimiter(maxSnapshotBytesPerSec.getMbFrac())__        }_    };configures,rate,limiter,based,on,repository,and,global,settings,param,repository,settings,repository,settings,param,setting,setting,to,use,to,configure,rate,limiter,param,default,rate,default,limiting,rate,return,rate,limiter,or,null,of,no,throttling,is,needed;private,rate,limiter,get,rate,limiter,settings,repository,settings,string,setting,byte,size,value,default,rate,byte,size,value,max,snapshot,bytes,per,sec,repository,settings,get,as,bytes,size,setting,settings,get,as,bytes,size,setting,default,rate,if,max,snapshot,bytes,per,sec,get,bytes,0,return,null,else,return,new,rate,limiter,simple,rate,limiter,max,snapshot,bytes,per,sec,get,mb,frac
BlobStoreRepository -> private RateLimiter getRateLimiter(Settings repositorySettings, String setting, ByteSizeValue defaultRate);1547496475;Configures RateLimiter based on repository and global settings__@param repositorySettings repository settings_@param setting            setting to use to configure rate limiter_@param defaultRate        default limiting rate_@return rate limiter or null of no throttling is needed;private RateLimiter getRateLimiter(Settings repositorySettings, String setting, ByteSizeValue defaultRate) {_        ByteSizeValue maxSnapshotBytesPerSec = repositorySettings.getAsBytesSize(setting,_                settings.getAsBytesSize(setting, defaultRate))__        if (maxSnapshotBytesPerSec.getBytes() <= 0) {_            return null__        } else {_            return new RateLimiter.SimpleRateLimiter(maxSnapshotBytesPerSec.getMbFrac())__        }_    };configures,rate,limiter,based,on,repository,and,global,settings,param,repository,settings,repository,settings,param,setting,setting,to,use,to,configure,rate,limiter,param,default,rate,default,limiting,rate,return,rate,limiter,or,null,of,no,throttling,is,needed;private,rate,limiter,get,rate,limiter,settings,repository,settings,string,setting,byte,size,value,default,rate,byte,size,value,max,snapshot,bytes,per,sec,repository,settings,get,as,bytes,size,setting,settings,get,as,bytes,size,setting,default,rate,if,max,snapshot,bytes,per,sec,get,bytes,0,return,null,else,return,new,rate,limiter,simple,rate,limiter,max,snapshot,bytes,per,sec,get,mb,frac
BlobStoreRepository -> private RateLimiter getRateLimiter(Settings repositorySettings, String setting, ByteSizeValue defaultRate);1547625930;Configures RateLimiter based on repository and global settings__@param repositorySettings repository settings_@param setting            setting to use to configure rate limiter_@param defaultRate        default limiting rate_@return rate limiter or null of no throttling is needed;private RateLimiter getRateLimiter(Settings repositorySettings, String setting, ByteSizeValue defaultRate) {_        ByteSizeValue maxSnapshotBytesPerSec = repositorySettings.getAsBytesSize(setting,_                settings.getAsBytesSize(setting, defaultRate))__        if (maxSnapshotBytesPerSec.getBytes() <= 0) {_            return null__        } else {_            return new RateLimiter.SimpleRateLimiter(maxSnapshotBytesPerSec.getMbFrac())__        }_    };configures,rate,limiter,based,on,repository,and,global,settings,param,repository,settings,repository,settings,param,setting,setting,to,use,to,configure,rate,limiter,param,default,rate,default,limiting,rate,return,rate,limiter,or,null,of,no,throttling,is,needed;private,rate,limiter,get,rate,limiter,settings,repository,settings,string,setting,byte,size,value,default,rate,byte,size,value,max,snapshot,bytes,per,sec,repository,settings,get,as,bytes,size,setting,settings,get,as,bytes,size,setting,default,rate,if,max,snapshot,bytes,per,sec,get,bytes,0,return,null,else,return,new,rate,limiter,simple,rate,limiter,max,snapshot,bytes,per,sec,get,mb,frac
BlobStoreRepository -> private RateLimiter getRateLimiter(Settings repositorySettings, String setting, ByteSizeValue defaultRate);1550647627;Configures RateLimiter based on repository and global settings__@param repositorySettings repository settings_@param setting            setting to use to configure rate limiter_@param defaultRate        default limiting rate_@return rate limiter or null of no throttling is needed;private RateLimiter getRateLimiter(Settings repositorySettings, String setting, ByteSizeValue defaultRate) {_        ByteSizeValue maxSnapshotBytesPerSec = repositorySettings.getAsBytesSize(setting,_                settings.getAsBytesSize(setting, defaultRate))__        if (maxSnapshotBytesPerSec.getBytes() <= 0) {_            return null__        } else {_            return new RateLimiter.SimpleRateLimiter(maxSnapshotBytesPerSec.getMbFrac())__        }_    };configures,rate,limiter,based,on,repository,and,global,settings,param,repository,settings,repository,settings,param,setting,setting,to,use,to,configure,rate,limiter,param,default,rate,default,limiting,rate,return,rate,limiter,or,null,of,no,throttling,is,needed;private,rate,limiter,get,rate,limiter,settings,repository,settings,string,setting,byte,size,value,default,rate,byte,size,value,max,snapshot,bytes,per,sec,repository,settings,get,as,bytes,size,setting,settings,get,as,bytes,size,setting,default,rate,if,max,snapshot,bytes,per,sec,get,bytes,0,return,null,else,return,new,rate,limiter,simple,rate,limiter,max,snapshot,bytes,per,sec,get,mb,frac
BlobStoreRepository -> protected BlobStoreRepository(RepositoryMetaData metadata, Settings settings, NamedXContentRegistry namedXContentRegistry);1541008027;Constructs new BlobStoreRepository__@param metadata       The metadata for this repository including name and settings_@param settings Settings for the node this repository object is created on;protected BlobStoreRepository(RepositoryMetaData metadata, Settings settings, NamedXContentRegistry namedXContentRegistry) {_        super(settings)__        this.settings = settings__        this.metadata = metadata__        this.namedXContentRegistry = namedXContentRegistry__        snapshotRateLimiter = getRateLimiter(metadata.settings(), "max_snapshot_bytes_per_sec", new ByteSizeValue(40, ByteSizeUnit.MB))__        restoreRateLimiter = getRateLimiter(metadata.settings(), "max_restore_bytes_per_sec", new ByteSizeValue(40, ByteSizeUnit.MB))__        readOnly = metadata.settings().getAsBoolean("readonly", false)___        indexShardSnapshotFormat = new ChecksumBlobStoreFormat<>(SNAPSHOT_CODEC, SNAPSHOT_NAME_FORMAT,_            BlobStoreIndexShardSnapshot::fromXContent, namedXContentRegistry, isCompress())__        indexShardSnapshotsFormat = new ChecksumBlobStoreFormat<>(SNAPSHOT_INDEX_CODEC, SNAPSHOT_INDEX_NAME_FORMAT,_            BlobStoreIndexShardSnapshots::fromXContent, namedXContentRegistry, isCompress())__        ByteSizeValue chunkSize = chunkSize()__        if (chunkSize != null && chunkSize.getBytes() <= 0) {_            throw new IllegalArgumentException("the chunk size cannot be negative: [" + chunkSize + "]")__        }_    };constructs,new,blob,store,repository,param,metadata,the,metadata,for,this,repository,including,name,and,settings,param,settings,settings,for,the,node,this,repository,object,is,created,on;protected,blob,store,repository,repository,meta,data,metadata,settings,settings,named,xcontent,registry,named,xcontent,registry,super,settings,this,settings,settings,this,metadata,metadata,this,named,xcontent,registry,named,xcontent,registry,snapshot,rate,limiter,get,rate,limiter,metadata,settings,new,byte,size,value,40,byte,size,unit,mb,restore,rate,limiter,get,rate,limiter,metadata,settings,new,byte,size,value,40,byte,size,unit,mb,read,only,metadata,settings,get,as,boolean,readonly,false,index,shard,snapshot,format,new,checksum,blob,store,format,blob,store,index,shard,snapshot,from,xcontent,named,xcontent,registry,is,compress,index,shard,snapshots,format,new,checksum,blob,store,format,blob,store,index,shard,snapshots,from,xcontent,named,xcontent,registry,is,compress,byte,size,value,chunk,size,chunk,size,if,chunk,size,null,chunk,size,get,bytes,0,throw,new,illegal,argument,exception,the,chunk,size,cannot,be,negative,chunk,size
BlobStoreRepository -> protected BlobStoreRepository(RepositoryMetaData metadata, Settings settings, NamedXContentRegistry namedXContentRegistry);1542646292;Constructs new BlobStoreRepository__@param metadata       The metadata for this repository including name and settings_@param settings Settings for the node this repository object is created on;protected BlobStoreRepository(RepositoryMetaData metadata, Settings settings, NamedXContentRegistry namedXContentRegistry) {_        super(settings)__        this.settings = settings__        this.metadata = metadata__        this.namedXContentRegistry = namedXContentRegistry__        snapshotRateLimiter = getRateLimiter(metadata.settings(), "max_snapshot_bytes_per_sec", new ByteSizeValue(40, ByteSizeUnit.MB))__        restoreRateLimiter = getRateLimiter(metadata.settings(), "max_restore_bytes_per_sec", new ByteSizeValue(40, ByteSizeUnit.MB))__        readOnly = metadata.settings().getAsBoolean("readonly", false)___        indexShardSnapshotFormat = new ChecksumBlobStoreFormat<>(SNAPSHOT_CODEC, SNAPSHOT_NAME_FORMAT,_            BlobStoreIndexShardSnapshot::fromXContent, namedXContentRegistry, isCompress())__        indexShardSnapshotsFormat = new ChecksumBlobStoreFormat<>(SNAPSHOT_INDEX_CODEC, SNAPSHOT_INDEX_NAME_FORMAT,_            BlobStoreIndexShardSnapshots::fromXContent, namedXContentRegistry, isCompress())__        ByteSizeValue chunkSize = chunkSize()__        if (chunkSize != null && chunkSize.getBytes() <= 0) {_            throw new IllegalArgumentException("the chunk size cannot be negative: [" + chunkSize + "]")__        }_    };constructs,new,blob,store,repository,param,metadata,the,metadata,for,this,repository,including,name,and,settings,param,settings,settings,for,the,node,this,repository,object,is,created,on;protected,blob,store,repository,repository,meta,data,metadata,settings,settings,named,xcontent,registry,named,xcontent,registry,super,settings,this,settings,settings,this,metadata,metadata,this,named,xcontent,registry,named,xcontent,registry,snapshot,rate,limiter,get,rate,limiter,metadata,settings,new,byte,size,value,40,byte,size,unit,mb,restore,rate,limiter,get,rate,limiter,metadata,settings,new,byte,size,value,40,byte,size,unit,mb,read,only,metadata,settings,get,as,boolean,readonly,false,index,shard,snapshot,format,new,checksum,blob,store,format,blob,store,index,shard,snapshot,from,xcontent,named,xcontent,registry,is,compress,index,shard,snapshots,format,new,checksum,blob,store,format,blob,store,index,shard,snapshots,from,xcontent,named,xcontent,registry,is,compress,byte,size,value,chunk,size,chunk,size,if,chunk,size,null,chunk,size,get,bytes,0,throw,new,illegal,argument,exception,the,chunk,size,cannot,be,negative,chunk,size
BlobStoreRepository -> protected BlobStoreRepository(RepositoryMetaData metadata, Settings settings, NamedXContentRegistry namedXContentRegistry);1542980705;Constructs new BlobStoreRepository__@param metadata       The metadata for this repository including name and settings_@param settings Settings for the node this repository object is created on;protected BlobStoreRepository(RepositoryMetaData metadata, Settings settings, NamedXContentRegistry namedXContentRegistry) {_        super(settings)__        this.settings = settings__        this.metadata = metadata__        this.namedXContentRegistry = namedXContentRegistry__        snapshotRateLimiter = getRateLimiter(metadata.settings(), "max_snapshot_bytes_per_sec", new ByteSizeValue(40, ByteSizeUnit.MB))__        restoreRateLimiter = getRateLimiter(metadata.settings(), "max_restore_bytes_per_sec", new ByteSizeValue(40, ByteSizeUnit.MB))__        readOnly = metadata.settings().getAsBoolean("readonly", false)___        indexShardSnapshotFormat = new ChecksumBlobStoreFormat<>(SNAPSHOT_CODEC, SNAPSHOT_NAME_FORMAT,_            BlobStoreIndexShardSnapshot::fromXContent, namedXContentRegistry, isCompress())__        indexShardSnapshotsFormat = new ChecksumBlobStoreFormat<>(SNAPSHOT_INDEX_CODEC, SNAPSHOT_INDEX_NAME_FORMAT,_            BlobStoreIndexShardSnapshots::fromXContent, namedXContentRegistry, isCompress())__        ByteSizeValue chunkSize = chunkSize()__        if (chunkSize != null && chunkSize.getBytes() <= 0) {_            throw new IllegalArgumentException("the chunk size cannot be negative: [" + chunkSize + "]")__        }_    };constructs,new,blob,store,repository,param,metadata,the,metadata,for,this,repository,including,name,and,settings,param,settings,settings,for,the,node,this,repository,object,is,created,on;protected,blob,store,repository,repository,meta,data,metadata,settings,settings,named,xcontent,registry,named,xcontent,registry,super,settings,this,settings,settings,this,metadata,metadata,this,named,xcontent,registry,named,xcontent,registry,snapshot,rate,limiter,get,rate,limiter,metadata,settings,new,byte,size,value,40,byte,size,unit,mb,restore,rate,limiter,get,rate,limiter,metadata,settings,new,byte,size,value,40,byte,size,unit,mb,read,only,metadata,settings,get,as,boolean,readonly,false,index,shard,snapshot,format,new,checksum,blob,store,format,blob,store,index,shard,snapshot,from,xcontent,named,xcontent,registry,is,compress,index,shard,snapshots,format,new,checksum,blob,store,format,blob,store,index,shard,snapshots,from,xcontent,named,xcontent,registry,is,compress,byte,size,value,chunk,size,chunk,size,if,chunk,size,null,chunk,size,get,bytes,0,throw,new,illegal,argument,exception,the,chunk,size,cannot,be,negative,chunk,size
BlobStoreRepository -> protected BlobStoreRepository(RepositoryMetaData metadata, Settings settings, NamedXContentRegistry namedXContentRegistry);1543831870;Constructs new BlobStoreRepository__@param metadata       The metadata for this repository including name and settings_@param settings Settings for the node this repository object is created on;protected BlobStoreRepository(RepositoryMetaData metadata, Settings settings, NamedXContentRegistry namedXContentRegistry) {_        super(settings)__        this.settings = settings__        this.metadata = metadata__        this.namedXContentRegistry = namedXContentRegistry__        snapshotRateLimiter = getRateLimiter(metadata.settings(), "max_snapshot_bytes_per_sec", new ByteSizeValue(40, ByteSizeUnit.MB))__        restoreRateLimiter = getRateLimiter(metadata.settings(), "max_restore_bytes_per_sec", new ByteSizeValue(40, ByteSizeUnit.MB))__        readOnly = metadata.settings().getAsBoolean("readonly", false)___        indexShardSnapshotFormat = new ChecksumBlobStoreFormat<>(SNAPSHOT_CODEC, SNAPSHOT_NAME_FORMAT,_            BlobStoreIndexShardSnapshot::fromXContent, namedXContentRegistry, isCompress())__        indexShardSnapshotsFormat = new ChecksumBlobStoreFormat<>(SNAPSHOT_INDEX_CODEC, SNAPSHOT_INDEX_NAME_FORMAT,_            BlobStoreIndexShardSnapshots::fromXContent, namedXContentRegistry, isCompress())__        ByteSizeValue chunkSize = chunkSize()__        if (chunkSize != null && chunkSize.getBytes() <= 0) {_            throw new IllegalArgumentException("the chunk size cannot be negative: [" + chunkSize + "]")__        }_    };constructs,new,blob,store,repository,param,metadata,the,metadata,for,this,repository,including,name,and,settings,param,settings,settings,for,the,node,this,repository,object,is,created,on;protected,blob,store,repository,repository,meta,data,metadata,settings,settings,named,xcontent,registry,named,xcontent,registry,super,settings,this,settings,settings,this,metadata,metadata,this,named,xcontent,registry,named,xcontent,registry,snapshot,rate,limiter,get,rate,limiter,metadata,settings,new,byte,size,value,40,byte,size,unit,mb,restore,rate,limiter,get,rate,limiter,metadata,settings,new,byte,size,value,40,byte,size,unit,mb,read,only,metadata,settings,get,as,boolean,readonly,false,index,shard,snapshot,format,new,checksum,blob,store,format,blob,store,index,shard,snapshot,from,xcontent,named,xcontent,registry,is,compress,index,shard,snapshots,format,new,checksum,blob,store,format,blob,store,index,shard,snapshots,from,xcontent,named,xcontent,registry,is,compress,byte,size,value,chunk,size,chunk,size,if,chunk,size,null,chunk,size,get,bytes,0,throw,new,illegal,argument,exception,the,chunk,size,cannot,be,negative,chunk,size
BlobStoreRepository -> protected BlobStoreRepository(RepositoryMetaData metadata, Settings settings, NamedXContentRegistry namedXContentRegistry);1543942400;Constructs new BlobStoreRepository__@param metadata       The metadata for this repository including name and settings_@param settings Settings for the node this repository object is created on;protected BlobStoreRepository(RepositoryMetaData metadata, Settings settings, NamedXContentRegistry namedXContentRegistry) {_        super(settings)__        this.settings = settings__        this.metadata = metadata__        this.namedXContentRegistry = namedXContentRegistry__        snapshotRateLimiter = getRateLimiter(metadata.settings(), "max_snapshot_bytes_per_sec", new ByteSizeValue(40, ByteSizeUnit.MB))__        restoreRateLimiter = getRateLimiter(metadata.settings(), "max_restore_bytes_per_sec", new ByteSizeValue(40, ByteSizeUnit.MB))__        readOnly = metadata.settings().getAsBoolean("readonly", false)___        indexShardSnapshotFormat = new ChecksumBlobStoreFormat<>(SNAPSHOT_CODEC, SNAPSHOT_NAME_FORMAT,_            BlobStoreIndexShardSnapshot::fromXContent, namedXContentRegistry, isCompress())__        indexShardSnapshotsFormat = new ChecksumBlobStoreFormat<>(SNAPSHOT_INDEX_CODEC, SNAPSHOT_INDEX_NAME_FORMAT,_            BlobStoreIndexShardSnapshots::fromXContent, namedXContentRegistry, isCompress())__        ByteSizeValue chunkSize = chunkSize()__        if (chunkSize != null && chunkSize.getBytes() <= 0) {_            throw new IllegalArgumentException("the chunk size cannot be negative: [" + chunkSize + "]")__        }_    };constructs,new,blob,store,repository,param,metadata,the,metadata,for,this,repository,including,name,and,settings,param,settings,settings,for,the,node,this,repository,object,is,created,on;protected,blob,store,repository,repository,meta,data,metadata,settings,settings,named,xcontent,registry,named,xcontent,registry,super,settings,this,settings,settings,this,metadata,metadata,this,named,xcontent,registry,named,xcontent,registry,snapshot,rate,limiter,get,rate,limiter,metadata,settings,new,byte,size,value,40,byte,size,unit,mb,restore,rate,limiter,get,rate,limiter,metadata,settings,new,byte,size,value,40,byte,size,unit,mb,read,only,metadata,settings,get,as,boolean,readonly,false,index,shard,snapshot,format,new,checksum,blob,store,format,blob,store,index,shard,snapshot,from,xcontent,named,xcontent,registry,is,compress,index,shard,snapshots,format,new,checksum,blob,store,format,blob,store,index,shard,snapshots,from,xcontent,named,xcontent,registry,is,compress,byte,size,value,chunk,size,chunk,size,if,chunk,size,null,chunk,size,get,bytes,0,throw,new,illegal,argument,exception,the,chunk,size,cannot,be,negative,chunk,size
BlobStoreRepository -> protected BlobStoreRepository(RepositoryMetaData metadata, Settings settings, NamedXContentRegistry namedXContentRegistry);1546974294;Constructs new BlobStoreRepository__@param metadata       The metadata for this repository including name and settings_@param settings Settings for the node this repository object is created on;protected BlobStoreRepository(RepositoryMetaData metadata, Settings settings, NamedXContentRegistry namedXContentRegistry) {_        super(settings)__        this.settings = settings__        this.metadata = metadata__        this.namedXContentRegistry = namedXContentRegistry__        snapshotRateLimiter = getRateLimiter(metadata.settings(), "max_snapshot_bytes_per_sec", new ByteSizeValue(40, ByteSizeUnit.MB))__        restoreRateLimiter = getRateLimiter(metadata.settings(), "max_restore_bytes_per_sec", new ByteSizeValue(40, ByteSizeUnit.MB))__        readOnly = metadata.settings().getAsBoolean("readonly", false)___        indexShardSnapshotFormat = new ChecksumBlobStoreFormat<>(SNAPSHOT_CODEC, SNAPSHOT_NAME_FORMAT,_            BlobStoreIndexShardSnapshot::fromXContent, namedXContentRegistry, isCompress())__        indexShardSnapshotsFormat = new ChecksumBlobStoreFormat<>(SNAPSHOT_INDEX_CODEC, SNAPSHOT_INDEX_NAME_FORMAT,_            BlobStoreIndexShardSnapshots::fromXContent, namedXContentRegistry, isCompress())__        ByteSizeValue chunkSize = chunkSize()__        if (chunkSize != null && chunkSize.getBytes() <= 0) {_            throw new IllegalArgumentException("the chunk size cannot be negative: [" + chunkSize + "]")__        }_    };constructs,new,blob,store,repository,param,metadata,the,metadata,for,this,repository,including,name,and,settings,param,settings,settings,for,the,node,this,repository,object,is,created,on;protected,blob,store,repository,repository,meta,data,metadata,settings,settings,named,xcontent,registry,named,xcontent,registry,super,settings,this,settings,settings,this,metadata,metadata,this,named,xcontent,registry,named,xcontent,registry,snapshot,rate,limiter,get,rate,limiter,metadata,settings,new,byte,size,value,40,byte,size,unit,mb,restore,rate,limiter,get,rate,limiter,metadata,settings,new,byte,size,value,40,byte,size,unit,mb,read,only,metadata,settings,get,as,boolean,readonly,false,index,shard,snapshot,format,new,checksum,blob,store,format,blob,store,index,shard,snapshot,from,xcontent,named,xcontent,registry,is,compress,index,shard,snapshots,format,new,checksum,blob,store,format,blob,store,index,shard,snapshots,from,xcontent,named,xcontent,registry,is,compress,byte,size,value,chunk,size,chunk,size,if,chunk,size,null,chunk,size,get,bytes,0,throw,new,illegal,argument,exception,the,chunk,size,cannot,be,negative,chunk,size
BlobStoreRepository -> protected BlobStoreRepository(RepositoryMetaData metadata, Settings settings, NamedXContentRegistry namedXContentRegistry);1547496475;Constructs new BlobStoreRepository__@param metadata       The metadata for this repository including name and settings_@param settings Settings for the node this repository object is created on;protected BlobStoreRepository(RepositoryMetaData metadata, Settings settings, NamedXContentRegistry namedXContentRegistry) {_        super(settings)__        this.settings = settings__        this.metadata = metadata__        this.namedXContentRegistry = namedXContentRegistry__        snapshotRateLimiter = getRateLimiter(metadata.settings(), "max_snapshot_bytes_per_sec", new ByteSizeValue(40, ByteSizeUnit.MB))__        restoreRateLimiter = getRateLimiter(metadata.settings(), "max_restore_bytes_per_sec", new ByteSizeValue(40, ByteSizeUnit.MB))__        readOnly = metadata.settings().getAsBoolean("readonly", false)___        indexShardSnapshotFormat = new ChecksumBlobStoreFormat<>(SNAPSHOT_CODEC, SNAPSHOT_NAME_FORMAT,_            BlobStoreIndexShardSnapshot::fromXContent, namedXContentRegistry, isCompress())__        indexShardSnapshotsFormat = new ChecksumBlobStoreFormat<>(SNAPSHOT_INDEX_CODEC, SNAPSHOT_INDEX_NAME_FORMAT,_            BlobStoreIndexShardSnapshots::fromXContent, namedXContentRegistry, isCompress())__        ByteSizeValue chunkSize = chunkSize()__        if (chunkSize != null && chunkSize.getBytes() <= 0) {_            throw new IllegalArgumentException("the chunk size cannot be negative: [" + chunkSize + "]")__        }_    };constructs,new,blob,store,repository,param,metadata,the,metadata,for,this,repository,including,name,and,settings,param,settings,settings,for,the,node,this,repository,object,is,created,on;protected,blob,store,repository,repository,meta,data,metadata,settings,settings,named,xcontent,registry,named,xcontent,registry,super,settings,this,settings,settings,this,metadata,metadata,this,named,xcontent,registry,named,xcontent,registry,snapshot,rate,limiter,get,rate,limiter,metadata,settings,new,byte,size,value,40,byte,size,unit,mb,restore,rate,limiter,get,rate,limiter,metadata,settings,new,byte,size,value,40,byte,size,unit,mb,read,only,metadata,settings,get,as,boolean,readonly,false,index,shard,snapshot,format,new,checksum,blob,store,format,blob,store,index,shard,snapshot,from,xcontent,named,xcontent,registry,is,compress,index,shard,snapshots,format,new,checksum,blob,store,format,blob,store,index,shard,snapshots,from,xcontent,named,xcontent,registry,is,compress,byte,size,value,chunk,size,chunk,size,if,chunk,size,null,chunk,size,get,bytes,0,throw,new,illegal,argument,exception,the,chunk,size,cannot,be,negative,chunk,size
BlobStoreRepository -> protected BlobStoreRepository(RepositoryMetaData metadata, Settings settings, NamedXContentRegistry namedXContentRegistry);1547625930;Constructs new BlobStoreRepository__@param metadata       The metadata for this repository including name and settings_@param settings Settings for the node this repository object is created on;protected BlobStoreRepository(RepositoryMetaData metadata, Settings settings, NamedXContentRegistry namedXContentRegistry) {_        this.settings = settings__        this.metadata = metadata__        this.namedXContentRegistry = namedXContentRegistry__        snapshotRateLimiter = getRateLimiter(metadata.settings(), "max_snapshot_bytes_per_sec", new ByteSizeValue(40, ByteSizeUnit.MB))__        restoreRateLimiter = getRateLimiter(metadata.settings(), "max_restore_bytes_per_sec", new ByteSizeValue(40, ByteSizeUnit.MB))__        readOnly = metadata.settings().getAsBoolean("readonly", false)___        indexShardSnapshotFormat = new ChecksumBlobStoreFormat<>(SNAPSHOT_CODEC, SNAPSHOT_NAME_FORMAT,_            BlobStoreIndexShardSnapshot::fromXContent, namedXContentRegistry, isCompress())__        indexShardSnapshotsFormat = new ChecksumBlobStoreFormat<>(SNAPSHOT_INDEX_CODEC, SNAPSHOT_INDEX_NAME_FORMAT,_            BlobStoreIndexShardSnapshots::fromXContent, namedXContentRegistry, isCompress())__        ByteSizeValue chunkSize = chunkSize()__        if (chunkSize != null && chunkSize.getBytes() <= 0) {_            throw new IllegalArgumentException("the chunk size cannot be negative: [" + chunkSize + "]")__        }_    };constructs,new,blob,store,repository,param,metadata,the,metadata,for,this,repository,including,name,and,settings,param,settings,settings,for,the,node,this,repository,object,is,created,on;protected,blob,store,repository,repository,meta,data,metadata,settings,settings,named,xcontent,registry,named,xcontent,registry,this,settings,settings,this,metadata,metadata,this,named,xcontent,registry,named,xcontent,registry,snapshot,rate,limiter,get,rate,limiter,metadata,settings,new,byte,size,value,40,byte,size,unit,mb,restore,rate,limiter,get,rate,limiter,metadata,settings,new,byte,size,value,40,byte,size,unit,mb,read,only,metadata,settings,get,as,boolean,readonly,false,index,shard,snapshot,format,new,checksum,blob,store,format,blob,store,index,shard,snapshot,from,xcontent,named,xcontent,registry,is,compress,index,shard,snapshots,format,new,checksum,blob,store,format,blob,store,index,shard,snapshots,from,xcontent,named,xcontent,registry,is,compress,byte,size,value,chunk,size,chunk,size,if,chunk,size,null,chunk,size,get,bytes,0,throw,new,illegal,argument,exception,the,chunk,size,cannot,be,negative,chunk,size
BlobStoreRepository -> protected abstract BlobStore blobStore()_;1524684173;Returns the BlobStore to read and write data.;protected abstract BlobStore blobStore()_;returns,the,blob,store,to,read,and,write,data;protected,abstract,blob,store,blob,store
BlobStoreRepository -> protected abstract BlobStore blobStore()_;1525334055;Returns the BlobStore to read and write data.;protected abstract BlobStore blobStore()_;returns,the,blob,store,to,read,and,write,data;protected,abstract,blob,store,blob,store
BlobStoreRepository -> protected abstract BlobStore blobStore()_;1525798020;Returns the BlobStore to read and write data.;protected abstract BlobStore blobStore()_;returns,the,blob,store,to,read,and,write,data;protected,abstract,blob,store,blob,store
BlobStoreRepository -> protected abstract BlobStore blobStore()_;1526289033;Returns the BlobStore to read and write data.;protected abstract BlobStore blobStore()_;returns,the,blob,store,to,read,and,write,data;protected,abstract,blob,store,blob,store
BlobStoreRepository -> protected abstract BlobStore blobStore()_;1526574077;Returns the BlobStore to read and write data.;protected abstract BlobStore blobStore()_;returns,the,blob,store,to,read,and,write,data;protected,abstract,blob,store,blob,store
BlobStoreRepository -> protected abstract BlobStore blobStore()_;1527583663;Returns the BlobStore to read and write data.;protected abstract BlobStore blobStore()_;returns,the,blob,store,to,read,and,write,data;protected,abstract,blob,store,blob,store
BlobStoreRepository -> protected abstract BlobStore blobStore()_;1528211342;Returns the BlobStore to read and write data.;protected abstract BlobStore blobStore()_;returns,the,blob,store,to,read,and,write,data;protected,abstract,blob,store,blob,store
BlobStoreRepository -> protected abstract BlobStore blobStore()_;1531179852;Returns the BlobStore to read and write data.;protected abstract BlobStore blobStore()_;returns,the,blob,store,to,read,and,write,data;protected,abstract,blob,store,blob,store
BlobStoreRepository -> RestoreContext -> public void restore() throws IOException;1524684173;Performs restore operation;public void restore() throws IOException {_            final Store store = targetShard.store()__            store.incRef()__            try {_                logger.debug("[{}] [{}] restoring to [{}] ...", snapshotId, metadata.name(), shardId)__                BlobStoreIndexShardSnapshot snapshot = loadSnapshot()___                if (snapshot.indexFiles().size() == 1_                    && snapshot.indexFiles().get(0).physicalName().startsWith("segments_")_                    && snapshot.indexFiles().get(0).hasUnknownChecksum()) {_                    _                    _                    _                    _                    _                    _                    _                    _                    IndexWriter writer = new IndexWriter(store.directory(), new IndexWriterConfig(null)_                        .setOpenMode(IndexWriterConfig.OpenMode.CREATE)_                        .setCommitOnClose(true))__                    writer.close()__                    return__                }__                SnapshotFiles snapshotFiles = new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles())__                Store.MetadataSnapshot recoveryTargetMetadata__                try {_                    _                    _                    _                    recoveryTargetMetadata = targetShard.snapshotStoreMetadata()__                } catch (IndexNotFoundException e) {_                    _                    logger.trace("[{}] [{}] restoring from to an empty shard", shardId, snapshotId)__                    recoveryTargetMetadata = Store.MetadataSnapshot.EMPTY__                } catch (IOException e) {_                    logger.warn(() -> new ParameterizedMessage("{} Can't read metadata from store, will not reuse any local file while restoring", shardId), e)__                    recoveryTargetMetadata = Store.MetadataSnapshot.EMPTY__                }__                final List<BlobStoreIndexShardSnapshot.FileInfo> filesToRecover = new ArrayList<>()__                final Map<String, StoreFileMetaData> snapshotMetaData = new HashMap<>()__                final Map<String, BlobStoreIndexShardSnapshot.FileInfo> fileInfos = new HashMap<>()__                for (final BlobStoreIndexShardSnapshot.FileInfo fileInfo : snapshot.indexFiles()) {_                    try {_                        _                        _                        _                        _                        maybeRecalculateMetadataHash(blobContainer, fileInfo, recoveryTargetMetadata)__                    } catch (Exception e) {_                        _                        logger.warn(() -> new ParameterizedMessage("{} Can't calculate hash from blog for file [{}] [{}]", shardId, fileInfo.physicalName(), fileInfo.metadata()), e)__                    }_                    snapshotMetaData.put(fileInfo.metadata().name(), fileInfo.metadata())__                    fileInfos.put(fileInfo.metadata().name(), fileInfo)__                }__                final Store.MetadataSnapshot sourceMetaData = new Store.MetadataSnapshot(unmodifiableMap(snapshotMetaData), emptyMap(), 0)___                final StoreFileMetaData restoredSegmentsFile = sourceMetaData.getSegmentsFile()__                if (restoredSegmentsFile == null) {_                    throw new IndexShardRestoreFailedException(shardId, "Snapshot has no segments file")__                }__                final Store.RecoveryDiff diff = sourceMetaData.recoveryDiff(recoveryTargetMetadata)__                for (StoreFileMetaData md : diff.identical) {_                    BlobStoreIndexShardSnapshot.FileInfo fileInfo = fileInfos.get(md.name())__                    recoveryState.getIndex().addFileDetail(fileInfo.name(), fileInfo.length(), true)__                    if (logger.isTraceEnabled()) {_                        logger.trace("[{}] [{}] not_recovering [{}] from [{}], exists in local store and is same", shardId, snapshotId, fileInfo.physicalName(), fileInfo.name())__                    }_                }__                for (StoreFileMetaData md : Iterables.concat(diff.different, diff.missing)) {_                    BlobStoreIndexShardSnapshot.FileInfo fileInfo = fileInfos.get(md.name())__                    filesToRecover.add(fileInfo)__                    recoveryState.getIndex().addFileDetail(fileInfo.name(), fileInfo.length(), false)__                    if (logger.isTraceEnabled()) {_                        if (md == null) {_                            logger.trace("[{}] [{}] recovering [{}] from [{}], does not exists in local store", shardId, snapshotId, fileInfo.physicalName(), fileInfo.name())__                        } else {_                            logger.trace("[{}] [{}] recovering [{}] from [{}], exists in local store but is different", shardId, snapshotId, fileInfo.physicalName(), fileInfo.name())__                        }_                    }_                }__                if (filesToRecover.isEmpty()) {_                    logger.trace("no files to recover, all exists within the local store")__                }__                try {_                    _                    final List<String> deleteIfExistFiles = Arrays.asList(store.directory().listAll())___                    _                    for (final BlobStoreIndexShardSnapshot.FileInfo fileToRecover : filesToRecover) {_                        _                        _                        _                        _                        _                        _                        final String physicalName = fileToRecover.physicalName()__                        if (deleteIfExistFiles.contains(physicalName)) {_                            logger.trace("[{}] [{}] deleting pre-existing file [{}]", shardId, snapshotId, physicalName)__                            store.directory().deleteFile(physicalName)__                        }__                        logger.trace("[{}] [{}] restoring file [{}]", shardId, snapshotId, fileToRecover.name())__                        restoreFile(fileToRecover, store)__                    }_                } catch (IOException ex) {_                    throw new IndexShardRestoreFailedException(shardId, "Failed to recover index", ex)__                }__                _                final SegmentInfos segmentCommitInfos__                try {_                    segmentCommitInfos = Lucene.pruneUnreferencedFiles(restoredSegmentsFile.name(), store.directory())__                } catch (IOException e) {_                    throw new IndexShardRestoreFailedException(shardId, "Failed to fetch index version after copying it over", e)__                }_                recoveryState.getIndex().updateVersion(segmentCommitInfos.getVersion())___                _                try {_                    for (String storeFile : store.directory().listAll()) {_                        if (Store.isAutogenerated(storeFile) || snapshotFiles.containPhysicalIndexFile(storeFile)) {_                            continue_ _                        }_                        try {_                            store.deleteQuiet("restore", storeFile)__                            store.directory().deleteFile(storeFile)__                        } catch (IOException e) {_                            logger.warn("[{}] failed to delete file [{}] during snapshot cleanup", snapshotId, storeFile)__                        }_                    }_                } catch (IOException e) {_                    logger.warn("[{}] failed to list directory - some of files might not be deleted", snapshotId)__                }_            } finally {_                store.decRef()__            }_        };performs,restore,operation;public,void,restore,throws,ioexception,final,store,store,target,shard,store,store,inc,ref,try,logger,debug,restoring,to,snapshot,id,metadata,name,shard,id,blob,store,index,shard,snapshot,snapshot,load,snapshot,if,snapshot,index,files,size,1,snapshot,index,files,get,0,physical,name,starts,with,snapshot,index,files,get,0,has,unknown,checksum,index,writer,writer,new,index,writer,store,directory,new,index,writer,config,null,set,open,mode,index,writer,config,open,mode,create,set,commit,on,close,true,writer,close,return,snapshot,files,snapshot,files,new,snapshot,files,snapshot,snapshot,snapshot,index,files,store,metadata,snapshot,recovery,target,metadata,try,recovery,target,metadata,target,shard,snapshot,store,metadata,catch,index,not,found,exception,e,logger,trace,restoring,from,to,an,empty,shard,shard,id,snapshot,id,recovery,target,metadata,store,metadata,snapshot,empty,catch,ioexception,e,logger,warn,new,parameterized,message,can,t,read,metadata,from,store,will,not,reuse,any,local,file,while,restoring,shard,id,e,recovery,target,metadata,store,metadata,snapshot,empty,final,list,blob,store,index,shard,snapshot,file,info,files,to,recover,new,array,list,final,map,string,store,file,meta,data,snapshot,meta,data,new,hash,map,final,map,string,blob,store,index,shard,snapshot,file,info,file,infos,new,hash,map,for,final,blob,store,index,shard,snapshot,file,info,file,info,snapshot,index,files,try,maybe,recalculate,metadata,hash,blob,container,file,info,recovery,target,metadata,catch,exception,e,logger,warn,new,parameterized,message,can,t,calculate,hash,from,blog,for,file,shard,id,file,info,physical,name,file,info,metadata,e,snapshot,meta,data,put,file,info,metadata,name,file,info,metadata,file,infos,put,file,info,metadata,name,file,info,final,store,metadata,snapshot,source,meta,data,new,store,metadata,snapshot,unmodifiable,map,snapshot,meta,data,empty,map,0,final,store,file,meta,data,restored,segments,file,source,meta,data,get,segments,file,if,restored,segments,file,null,throw,new,index,shard,restore,failed,exception,shard,id,snapshot,has,no,segments,file,final,store,recovery,diff,diff,source,meta,data,recovery,diff,recovery,target,metadata,for,store,file,meta,data,md,diff,identical,blob,store,index,shard,snapshot,file,info,file,info,file,infos,get,md,name,recovery,state,get,index,add,file,detail,file,info,name,file,info,length,true,if,logger,is,trace,enabled,logger,trace,from,exists,in,local,store,and,is,same,shard,id,snapshot,id,file,info,physical,name,file,info,name,for,store,file,meta,data,md,iterables,concat,diff,different,diff,missing,blob,store,index,shard,snapshot,file,info,file,info,file,infos,get,md,name,files,to,recover,add,file,info,recovery,state,get,index,add,file,detail,file,info,name,file,info,length,false,if,logger,is,trace,enabled,if,md,null,logger,trace,recovering,from,does,not,exists,in,local,store,shard,id,snapshot,id,file,info,physical,name,file,info,name,else,logger,trace,recovering,from,exists,in,local,store,but,is,different,shard,id,snapshot,id,file,info,physical,name,file,info,name,if,files,to,recover,is,empty,logger,trace,no,files,to,recover,all,exists,within,the,local,store,try,final,list,string,delete,if,exist,files,arrays,as,list,store,directory,list,all,for,final,blob,store,index,shard,snapshot,file,info,file,to,recover,files,to,recover,final,string,physical,name,file,to,recover,physical,name,if,delete,if,exist,files,contains,physical,name,logger,trace,deleting,pre,existing,file,shard,id,snapshot,id,physical,name,store,directory,delete,file,physical,name,logger,trace,restoring,file,shard,id,snapshot,id,file,to,recover,name,restore,file,file,to,recover,store,catch,ioexception,ex,throw,new,index,shard,restore,failed,exception,shard,id,failed,to,recover,index,ex,final,segment,infos,segment,commit,infos,try,segment,commit,infos,lucene,prune,unreferenced,files,restored,segments,file,name,store,directory,catch,ioexception,e,throw,new,index,shard,restore,failed,exception,shard,id,failed,to,fetch,index,version,after,copying,it,over,e,recovery,state,get,index,update,version,segment,commit,infos,get,version,try,for,string,store,file,store,directory,list,all,if,store,is,autogenerated,store,file,snapshot,files,contain,physical,index,file,store,file,continue,try,store,delete,quiet,restore,store,file,store,directory,delete,file,store,file,catch,ioexception,e,logger,warn,failed,to,delete,file,during,snapshot,cleanup,snapshot,id,store,file,catch,ioexception,e,logger,warn,failed,to,list,directory,some,of,files,might,not,be,deleted,snapshot,id,finally,store,dec,ref
BlobStoreRepository -> RestoreContext -> public void restore() throws IOException;1525334055;Performs restore operation;public void restore() throws IOException {_            final Store store = targetShard.store()__            store.incRef()__            try {_                logger.debug("[{}] [{}] restoring to [{}] ...", snapshotId, metadata.name(), shardId)__                BlobStoreIndexShardSnapshot snapshot = loadSnapshot()___                if (snapshot.indexFiles().size() == 1_                    && snapshot.indexFiles().get(0).physicalName().startsWith("segments_")_                    && snapshot.indexFiles().get(0).hasUnknownChecksum()) {_                    _                    _                    _                    _                    _                    _                    _                    _                    IndexWriter writer = new IndexWriter(store.directory(), new IndexWriterConfig(null)_                        .setOpenMode(IndexWriterConfig.OpenMode.CREATE)_                        .setCommitOnClose(true))__                    writer.close()__                    return__                }__                SnapshotFiles snapshotFiles = new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles())__                Store.MetadataSnapshot recoveryTargetMetadata__                try {_                    _                    _                    _                    recoveryTargetMetadata = targetShard.snapshotStoreMetadata()__                } catch (IndexNotFoundException e) {_                    _                    logger.trace("[{}] [{}] restoring from to an empty shard", shardId, snapshotId)__                    recoveryTargetMetadata = Store.MetadataSnapshot.EMPTY__                } catch (IOException e) {_                    logger.warn(() -> new ParameterizedMessage("{} Can't read metadata from store, will not reuse any local file while restoring", shardId), e)__                    recoveryTargetMetadata = Store.MetadataSnapshot.EMPTY__                }__                final List<BlobStoreIndexShardSnapshot.FileInfo> filesToRecover = new ArrayList<>()__                final Map<String, StoreFileMetaData> snapshotMetaData = new HashMap<>()__                final Map<String, BlobStoreIndexShardSnapshot.FileInfo> fileInfos = new HashMap<>()__                for (final BlobStoreIndexShardSnapshot.FileInfo fileInfo : snapshot.indexFiles()) {_                    try {_                        _                        _                        _                        _                        maybeRecalculateMetadataHash(blobContainer, fileInfo, recoveryTargetMetadata)__                    } catch (Exception e) {_                        _                        logger.warn(() -> new ParameterizedMessage("{} Can't calculate hash from blog for file [{}] [{}]", shardId, fileInfo.physicalName(), fileInfo.metadata()), e)__                    }_                    snapshotMetaData.put(fileInfo.metadata().name(), fileInfo.metadata())__                    fileInfos.put(fileInfo.metadata().name(), fileInfo)__                }__                final Store.MetadataSnapshot sourceMetaData = new Store.MetadataSnapshot(unmodifiableMap(snapshotMetaData), emptyMap(), 0)___                final StoreFileMetaData restoredSegmentsFile = sourceMetaData.getSegmentsFile()__                if (restoredSegmentsFile == null) {_                    throw new IndexShardRestoreFailedException(shardId, "Snapshot has no segments file")__                }__                final Store.RecoveryDiff diff = sourceMetaData.recoveryDiff(recoveryTargetMetadata)__                for (StoreFileMetaData md : diff.identical) {_                    BlobStoreIndexShardSnapshot.FileInfo fileInfo = fileInfos.get(md.name())__                    recoveryState.getIndex().addFileDetail(fileInfo.name(), fileInfo.length(), true)__                    if (logger.isTraceEnabled()) {_                        logger.trace("[{}] [{}] not_recovering [{}] from [{}], exists in local store and is same", shardId, snapshotId, fileInfo.physicalName(), fileInfo.name())__                    }_                }__                for (StoreFileMetaData md : Iterables.concat(diff.different, diff.missing)) {_                    BlobStoreIndexShardSnapshot.FileInfo fileInfo = fileInfos.get(md.name())__                    filesToRecover.add(fileInfo)__                    recoveryState.getIndex().addFileDetail(fileInfo.name(), fileInfo.length(), false)__                    if (logger.isTraceEnabled()) {_                        if (md == null) {_                            logger.trace("[{}] [{}] recovering [{}] from [{}], does not exists in local store", shardId, snapshotId, fileInfo.physicalName(), fileInfo.name())__                        } else {_                            logger.trace("[{}] [{}] recovering [{}] from [{}], exists in local store but is different", shardId, snapshotId, fileInfo.physicalName(), fileInfo.name())__                        }_                    }_                }__                if (filesToRecover.isEmpty()) {_                    logger.trace("no files to recover, all exists within the local store")__                }__                try {_                    _                    final List<String> deleteIfExistFiles = Arrays.asList(store.directory().listAll())___                    _                    for (final BlobStoreIndexShardSnapshot.FileInfo fileToRecover : filesToRecover) {_                        _                        _                        _                        _                        _                        _                        final String physicalName = fileToRecover.physicalName()__                        if (deleteIfExistFiles.contains(physicalName)) {_                            logger.trace("[{}] [{}] deleting pre-existing file [{}]", shardId, snapshotId, physicalName)__                            store.directory().deleteFile(physicalName)__                        }__                        logger.trace("[{}] [{}] restoring file [{}]", shardId, snapshotId, fileToRecover.name())__                        restoreFile(fileToRecover, store)__                    }_                } catch (IOException ex) {_                    throw new IndexShardRestoreFailedException(shardId, "Failed to recover index", ex)__                }__                _                final SegmentInfos segmentCommitInfos__                try {_                    segmentCommitInfos = Lucene.pruneUnreferencedFiles(restoredSegmentsFile.name(), store.directory())__                } catch (IOException e) {_                    throw new IndexShardRestoreFailedException(shardId, "Failed to fetch index version after copying it over", e)__                }_                recoveryState.getIndex().updateVersion(segmentCommitInfos.getVersion())___                _                try {_                    for (String storeFile : store.directory().listAll()) {_                        if (Store.isAutogenerated(storeFile) || snapshotFiles.containPhysicalIndexFile(storeFile)) {_                            continue_ _                        }_                        try {_                            store.deleteQuiet("restore", storeFile)__                            store.directory().deleteFile(storeFile)__                        } catch (IOException e) {_                            logger.warn("[{}] failed to delete file [{}] during snapshot cleanup", snapshotId, storeFile)__                        }_                    }_                } catch (IOException e) {_                    logger.warn("[{}] failed to list directory - some of files might not be deleted", snapshotId)__                }_            } finally {_                store.decRef()__            }_        };performs,restore,operation;public,void,restore,throws,ioexception,final,store,store,target,shard,store,store,inc,ref,try,logger,debug,restoring,to,snapshot,id,metadata,name,shard,id,blob,store,index,shard,snapshot,snapshot,load,snapshot,if,snapshot,index,files,size,1,snapshot,index,files,get,0,physical,name,starts,with,snapshot,index,files,get,0,has,unknown,checksum,index,writer,writer,new,index,writer,store,directory,new,index,writer,config,null,set,open,mode,index,writer,config,open,mode,create,set,commit,on,close,true,writer,close,return,snapshot,files,snapshot,files,new,snapshot,files,snapshot,snapshot,snapshot,index,files,store,metadata,snapshot,recovery,target,metadata,try,recovery,target,metadata,target,shard,snapshot,store,metadata,catch,index,not,found,exception,e,logger,trace,restoring,from,to,an,empty,shard,shard,id,snapshot,id,recovery,target,metadata,store,metadata,snapshot,empty,catch,ioexception,e,logger,warn,new,parameterized,message,can,t,read,metadata,from,store,will,not,reuse,any,local,file,while,restoring,shard,id,e,recovery,target,metadata,store,metadata,snapshot,empty,final,list,blob,store,index,shard,snapshot,file,info,files,to,recover,new,array,list,final,map,string,store,file,meta,data,snapshot,meta,data,new,hash,map,final,map,string,blob,store,index,shard,snapshot,file,info,file,infos,new,hash,map,for,final,blob,store,index,shard,snapshot,file,info,file,info,snapshot,index,files,try,maybe,recalculate,metadata,hash,blob,container,file,info,recovery,target,metadata,catch,exception,e,logger,warn,new,parameterized,message,can,t,calculate,hash,from,blog,for,file,shard,id,file,info,physical,name,file,info,metadata,e,snapshot,meta,data,put,file,info,metadata,name,file,info,metadata,file,infos,put,file,info,metadata,name,file,info,final,store,metadata,snapshot,source,meta,data,new,store,metadata,snapshot,unmodifiable,map,snapshot,meta,data,empty,map,0,final,store,file,meta,data,restored,segments,file,source,meta,data,get,segments,file,if,restored,segments,file,null,throw,new,index,shard,restore,failed,exception,shard,id,snapshot,has,no,segments,file,final,store,recovery,diff,diff,source,meta,data,recovery,diff,recovery,target,metadata,for,store,file,meta,data,md,diff,identical,blob,store,index,shard,snapshot,file,info,file,info,file,infos,get,md,name,recovery,state,get,index,add,file,detail,file,info,name,file,info,length,true,if,logger,is,trace,enabled,logger,trace,from,exists,in,local,store,and,is,same,shard,id,snapshot,id,file,info,physical,name,file,info,name,for,store,file,meta,data,md,iterables,concat,diff,different,diff,missing,blob,store,index,shard,snapshot,file,info,file,info,file,infos,get,md,name,files,to,recover,add,file,info,recovery,state,get,index,add,file,detail,file,info,name,file,info,length,false,if,logger,is,trace,enabled,if,md,null,logger,trace,recovering,from,does,not,exists,in,local,store,shard,id,snapshot,id,file,info,physical,name,file,info,name,else,logger,trace,recovering,from,exists,in,local,store,but,is,different,shard,id,snapshot,id,file,info,physical,name,file,info,name,if,files,to,recover,is,empty,logger,trace,no,files,to,recover,all,exists,within,the,local,store,try,final,list,string,delete,if,exist,files,arrays,as,list,store,directory,list,all,for,final,blob,store,index,shard,snapshot,file,info,file,to,recover,files,to,recover,final,string,physical,name,file,to,recover,physical,name,if,delete,if,exist,files,contains,physical,name,logger,trace,deleting,pre,existing,file,shard,id,snapshot,id,physical,name,store,directory,delete,file,physical,name,logger,trace,restoring,file,shard,id,snapshot,id,file,to,recover,name,restore,file,file,to,recover,store,catch,ioexception,ex,throw,new,index,shard,restore,failed,exception,shard,id,failed,to,recover,index,ex,final,segment,infos,segment,commit,infos,try,segment,commit,infos,lucene,prune,unreferenced,files,restored,segments,file,name,store,directory,catch,ioexception,e,throw,new,index,shard,restore,failed,exception,shard,id,failed,to,fetch,index,version,after,copying,it,over,e,recovery,state,get,index,update,version,segment,commit,infos,get,version,try,for,string,store,file,store,directory,list,all,if,store,is,autogenerated,store,file,snapshot,files,contain,physical,index,file,store,file,continue,try,store,delete,quiet,restore,store,file,store,directory,delete,file,store,file,catch,ioexception,e,logger,warn,failed,to,delete,file,during,snapshot,cleanup,snapshot,id,store,file,catch,ioexception,e,logger,warn,failed,to,list,directory,some,of,files,might,not,be,deleted,snapshot,id,finally,store,dec,ref
BlobStoreRepository -> RestoreContext -> public void restore() throws IOException;1525798020;Performs restore operation;public void restore() throws IOException {_            final Store store = targetShard.store()__            store.incRef()__            try {_                logger.debug("[{}] [{}] restoring to [{}] ...", snapshotId, metadata.name(), shardId)__                BlobStoreIndexShardSnapshot snapshot = loadSnapshot()___                if (snapshot.indexFiles().size() == 1_                    && snapshot.indexFiles().get(0).physicalName().startsWith("segments_")_                    && snapshot.indexFiles().get(0).hasUnknownChecksum()) {_                    _                    _                    _                    _                    _                    _                    _                    _                    IndexWriter writer = new IndexWriter(store.directory(), new IndexWriterConfig(null)_                        .setOpenMode(IndexWriterConfig.OpenMode.CREATE)_                        .setCommitOnClose(true))__                    writer.close()__                    return__                }__                SnapshotFiles snapshotFiles = new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles())__                Store.MetadataSnapshot recoveryTargetMetadata__                try {_                    _                    _                    _                    recoveryTargetMetadata = targetShard.snapshotStoreMetadata()__                } catch (IndexNotFoundException e) {_                    _                    logger.trace("[{}] [{}] restoring from to an empty shard", shardId, snapshotId)__                    recoveryTargetMetadata = Store.MetadataSnapshot.EMPTY__                } catch (IOException e) {_                    logger.warn(() -> new ParameterizedMessage("{} Can't read metadata from store, will not reuse any local file while restoring", shardId), e)__                    recoveryTargetMetadata = Store.MetadataSnapshot.EMPTY__                }__                final List<BlobStoreIndexShardSnapshot.FileInfo> filesToRecover = new ArrayList<>()__                final Map<String, StoreFileMetaData> snapshotMetaData = new HashMap<>()__                final Map<String, BlobStoreIndexShardSnapshot.FileInfo> fileInfos = new HashMap<>()__                for (final BlobStoreIndexShardSnapshot.FileInfo fileInfo : snapshot.indexFiles()) {_                    try {_                        _                        _                        _                        _                        maybeRecalculateMetadataHash(blobContainer, fileInfo, recoveryTargetMetadata)__                    } catch (Exception e) {_                        _                        logger.warn(() -> new ParameterizedMessage("{} Can't calculate hash from blog for file [{}] [{}]", shardId, fileInfo.physicalName(), fileInfo.metadata()), e)__                    }_                    snapshotMetaData.put(fileInfo.metadata().name(), fileInfo.metadata())__                    fileInfos.put(fileInfo.metadata().name(), fileInfo)__                }__                final Store.MetadataSnapshot sourceMetaData = new Store.MetadataSnapshot(unmodifiableMap(snapshotMetaData), emptyMap(), 0)___                final StoreFileMetaData restoredSegmentsFile = sourceMetaData.getSegmentsFile()__                if (restoredSegmentsFile == null) {_                    throw new IndexShardRestoreFailedException(shardId, "Snapshot has no segments file")__                }__                final Store.RecoveryDiff diff = sourceMetaData.recoveryDiff(recoveryTargetMetadata)__                for (StoreFileMetaData md : diff.identical) {_                    BlobStoreIndexShardSnapshot.FileInfo fileInfo = fileInfos.get(md.name())__                    recoveryState.getIndex().addFileDetail(fileInfo.name(), fileInfo.length(), true)__                    if (logger.isTraceEnabled()) {_                        logger.trace("[{}] [{}] not_recovering [{}] from [{}], exists in local store and is same", shardId, snapshotId, fileInfo.physicalName(), fileInfo.name())__                    }_                }__                for (StoreFileMetaData md : Iterables.concat(diff.different, diff.missing)) {_                    BlobStoreIndexShardSnapshot.FileInfo fileInfo = fileInfos.get(md.name())__                    filesToRecover.add(fileInfo)__                    recoveryState.getIndex().addFileDetail(fileInfo.name(), fileInfo.length(), false)__                    if (logger.isTraceEnabled()) {_                        if (md == null) {_                            logger.trace("[{}] [{}] recovering [{}] from [{}], does not exists in local store", shardId, snapshotId, fileInfo.physicalName(), fileInfo.name())__                        } else {_                            logger.trace("[{}] [{}] recovering [{}] from [{}], exists in local store but is different", shardId, snapshotId, fileInfo.physicalName(), fileInfo.name())__                        }_                    }_                }__                if (filesToRecover.isEmpty()) {_                    logger.trace("no files to recover, all exists within the local store")__                }__                try {_                    _                    final List<String> deleteIfExistFiles = Arrays.asList(store.directory().listAll())___                    _                    for (final BlobStoreIndexShardSnapshot.FileInfo fileToRecover : filesToRecover) {_                        _                        _                        _                        _                        _                        _                        final String physicalName = fileToRecover.physicalName()__                        if (deleteIfExistFiles.contains(physicalName)) {_                            logger.trace("[{}] [{}] deleting pre-existing file [{}]", shardId, snapshotId, physicalName)__                            store.directory().deleteFile(physicalName)__                        }__                        logger.trace("[{}] [{}] restoring file [{}]", shardId, snapshotId, fileToRecover.name())__                        restoreFile(fileToRecover, store)__                    }_                } catch (IOException ex) {_                    throw new IndexShardRestoreFailedException(shardId, "Failed to recover index", ex)__                }__                _                final SegmentInfos segmentCommitInfos__                try {_                    segmentCommitInfos = Lucene.pruneUnreferencedFiles(restoredSegmentsFile.name(), store.directory())__                } catch (IOException e) {_                    throw new IndexShardRestoreFailedException(shardId, "Failed to fetch index version after copying it over", e)__                }_                recoveryState.getIndex().updateVersion(segmentCommitInfos.getVersion())___                _                try {_                    for (String storeFile : store.directory().listAll()) {_                        if (Store.isAutogenerated(storeFile) || snapshotFiles.containPhysicalIndexFile(storeFile)) {_                            continue_ _                        }_                        try {_                            store.deleteQuiet("restore", storeFile)__                            store.directory().deleteFile(storeFile)__                        } catch (IOException e) {_                            logger.warn("[{}] failed to delete file [{}] during snapshot cleanup", snapshotId, storeFile)__                        }_                    }_                } catch (IOException e) {_                    logger.warn("[{}] failed to list directory - some of files might not be deleted", snapshotId)__                }_            } finally {_                store.decRef()__            }_        };performs,restore,operation;public,void,restore,throws,ioexception,final,store,store,target,shard,store,store,inc,ref,try,logger,debug,restoring,to,snapshot,id,metadata,name,shard,id,blob,store,index,shard,snapshot,snapshot,load,snapshot,if,snapshot,index,files,size,1,snapshot,index,files,get,0,physical,name,starts,with,snapshot,index,files,get,0,has,unknown,checksum,index,writer,writer,new,index,writer,store,directory,new,index,writer,config,null,set,open,mode,index,writer,config,open,mode,create,set,commit,on,close,true,writer,close,return,snapshot,files,snapshot,files,new,snapshot,files,snapshot,snapshot,snapshot,index,files,store,metadata,snapshot,recovery,target,metadata,try,recovery,target,metadata,target,shard,snapshot,store,metadata,catch,index,not,found,exception,e,logger,trace,restoring,from,to,an,empty,shard,shard,id,snapshot,id,recovery,target,metadata,store,metadata,snapshot,empty,catch,ioexception,e,logger,warn,new,parameterized,message,can,t,read,metadata,from,store,will,not,reuse,any,local,file,while,restoring,shard,id,e,recovery,target,metadata,store,metadata,snapshot,empty,final,list,blob,store,index,shard,snapshot,file,info,files,to,recover,new,array,list,final,map,string,store,file,meta,data,snapshot,meta,data,new,hash,map,final,map,string,blob,store,index,shard,snapshot,file,info,file,infos,new,hash,map,for,final,blob,store,index,shard,snapshot,file,info,file,info,snapshot,index,files,try,maybe,recalculate,metadata,hash,blob,container,file,info,recovery,target,metadata,catch,exception,e,logger,warn,new,parameterized,message,can,t,calculate,hash,from,blog,for,file,shard,id,file,info,physical,name,file,info,metadata,e,snapshot,meta,data,put,file,info,metadata,name,file,info,metadata,file,infos,put,file,info,metadata,name,file,info,final,store,metadata,snapshot,source,meta,data,new,store,metadata,snapshot,unmodifiable,map,snapshot,meta,data,empty,map,0,final,store,file,meta,data,restored,segments,file,source,meta,data,get,segments,file,if,restored,segments,file,null,throw,new,index,shard,restore,failed,exception,shard,id,snapshot,has,no,segments,file,final,store,recovery,diff,diff,source,meta,data,recovery,diff,recovery,target,metadata,for,store,file,meta,data,md,diff,identical,blob,store,index,shard,snapshot,file,info,file,info,file,infos,get,md,name,recovery,state,get,index,add,file,detail,file,info,name,file,info,length,true,if,logger,is,trace,enabled,logger,trace,from,exists,in,local,store,and,is,same,shard,id,snapshot,id,file,info,physical,name,file,info,name,for,store,file,meta,data,md,iterables,concat,diff,different,diff,missing,blob,store,index,shard,snapshot,file,info,file,info,file,infos,get,md,name,files,to,recover,add,file,info,recovery,state,get,index,add,file,detail,file,info,name,file,info,length,false,if,logger,is,trace,enabled,if,md,null,logger,trace,recovering,from,does,not,exists,in,local,store,shard,id,snapshot,id,file,info,physical,name,file,info,name,else,logger,trace,recovering,from,exists,in,local,store,but,is,different,shard,id,snapshot,id,file,info,physical,name,file,info,name,if,files,to,recover,is,empty,logger,trace,no,files,to,recover,all,exists,within,the,local,store,try,final,list,string,delete,if,exist,files,arrays,as,list,store,directory,list,all,for,final,blob,store,index,shard,snapshot,file,info,file,to,recover,files,to,recover,final,string,physical,name,file,to,recover,physical,name,if,delete,if,exist,files,contains,physical,name,logger,trace,deleting,pre,existing,file,shard,id,snapshot,id,physical,name,store,directory,delete,file,physical,name,logger,trace,restoring,file,shard,id,snapshot,id,file,to,recover,name,restore,file,file,to,recover,store,catch,ioexception,ex,throw,new,index,shard,restore,failed,exception,shard,id,failed,to,recover,index,ex,final,segment,infos,segment,commit,infos,try,segment,commit,infos,lucene,prune,unreferenced,files,restored,segments,file,name,store,directory,catch,ioexception,e,throw,new,index,shard,restore,failed,exception,shard,id,failed,to,fetch,index,version,after,copying,it,over,e,recovery,state,get,index,update,version,segment,commit,infos,get,version,try,for,string,store,file,store,directory,list,all,if,store,is,autogenerated,store,file,snapshot,files,contain,physical,index,file,store,file,continue,try,store,delete,quiet,restore,store,file,store,directory,delete,file,store,file,catch,ioexception,e,logger,warn,failed,to,delete,file,during,snapshot,cleanup,snapshot,id,store,file,catch,ioexception,e,logger,warn,failed,to,list,directory,some,of,files,might,not,be,deleted,snapshot,id,finally,store,dec,ref
BlobStoreRepository -> RestoreContext -> public void restore() throws IOException;1526289033;Performs restore operation;public void restore() throws IOException {_            final Store store = targetShard.store()__            store.incRef()__            try {_                logger.debug("[{}] [{}] restoring to [{}] ...", snapshotId, metadata.name(), shardId)__                BlobStoreIndexShardSnapshot snapshot = loadSnapshot()___                if (snapshot.indexFiles().size() == 1_                    && snapshot.indexFiles().get(0).physicalName().startsWith("segments_")_                    && snapshot.indexFiles().get(0).hasUnknownChecksum()) {_                    _                    _                    _                    _                    _                    _                    _                    _                    IndexWriter writer = new IndexWriter(store.directory(), new IndexWriterConfig(null)_                        .setOpenMode(IndexWriterConfig.OpenMode.CREATE)_                        .setCommitOnClose(true))__                    writer.close()__                    return__                }__                SnapshotFiles snapshotFiles = new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles())__                Store.MetadataSnapshot recoveryTargetMetadata__                try {_                    _                    _                    _                    recoveryTargetMetadata = targetShard.snapshotStoreMetadata()__                } catch (IndexNotFoundException e) {_                    _                    logger.trace("[{}] [{}] restoring from to an empty shard", shardId, snapshotId)__                    recoveryTargetMetadata = Store.MetadataSnapshot.EMPTY__                } catch (IOException e) {_                    logger.warn(() -> new ParameterizedMessage("{} Can't read metadata from store, will not reuse any local file while restoring", shardId), e)__                    recoveryTargetMetadata = Store.MetadataSnapshot.EMPTY__                }__                final List<BlobStoreIndexShardSnapshot.FileInfo> filesToRecover = new ArrayList<>()__                final Map<String, StoreFileMetaData> snapshotMetaData = new HashMap<>()__                final Map<String, BlobStoreIndexShardSnapshot.FileInfo> fileInfos = new HashMap<>()__                for (final BlobStoreIndexShardSnapshot.FileInfo fileInfo : snapshot.indexFiles()) {_                    try {_                        _                        _                        _                        _                        maybeRecalculateMetadataHash(blobContainer, fileInfo, recoveryTargetMetadata)__                    } catch (Exception e) {_                        _                        logger.warn(() -> new ParameterizedMessage("{} Can't calculate hash from blog for file [{}] [{}]", shardId, fileInfo.physicalName(), fileInfo.metadata()), e)__                    }_                    snapshotMetaData.put(fileInfo.metadata().name(), fileInfo.metadata())__                    fileInfos.put(fileInfo.metadata().name(), fileInfo)__                }__                final Store.MetadataSnapshot sourceMetaData = new Store.MetadataSnapshot(unmodifiableMap(snapshotMetaData), emptyMap(), 0)___                final StoreFileMetaData restoredSegmentsFile = sourceMetaData.getSegmentsFile()__                if (restoredSegmentsFile == null) {_                    throw new IndexShardRestoreFailedException(shardId, "Snapshot has no segments file")__                }__                final Store.RecoveryDiff diff = sourceMetaData.recoveryDiff(recoveryTargetMetadata)__                for (StoreFileMetaData md : diff.identical) {_                    BlobStoreIndexShardSnapshot.FileInfo fileInfo = fileInfos.get(md.name())__                    recoveryState.getIndex().addFileDetail(fileInfo.name(), fileInfo.length(), true)__                    if (logger.isTraceEnabled()) {_                        logger.trace("[{}] [{}] not_recovering [{}] from [{}], exists in local store and is same", shardId, snapshotId, fileInfo.physicalName(), fileInfo.name())__                    }_                }__                for (StoreFileMetaData md : Iterables.concat(diff.different, diff.missing)) {_                    BlobStoreIndexShardSnapshot.FileInfo fileInfo = fileInfos.get(md.name())__                    filesToRecover.add(fileInfo)__                    recoveryState.getIndex().addFileDetail(fileInfo.name(), fileInfo.length(), false)__                    if (logger.isTraceEnabled()) {_                        if (md == null) {_                            logger.trace("[{}] [{}] recovering [{}] from [{}], does not exists in local store", shardId, snapshotId, fileInfo.physicalName(), fileInfo.name())__                        } else {_                            logger.trace("[{}] [{}] recovering [{}] from [{}], exists in local store but is different", shardId, snapshotId, fileInfo.physicalName(), fileInfo.name())__                        }_                    }_                }__                if (filesToRecover.isEmpty()) {_                    logger.trace("no files to recover, all exists within the local store")__                }__                try {_                    _                    final List<String> deleteIfExistFiles = Arrays.asList(store.directory().listAll())___                    _                    for (final BlobStoreIndexShardSnapshot.FileInfo fileToRecover : filesToRecover) {_                        _                        _                        _                        _                        _                        _                        final String physicalName = fileToRecover.physicalName()__                        if (deleteIfExistFiles.contains(physicalName)) {_                            logger.trace("[{}] [{}] deleting pre-existing file [{}]", shardId, snapshotId, physicalName)__                            store.directory().deleteFile(physicalName)__                        }__                        logger.trace("[{}] [{}] restoring file [{}]", shardId, snapshotId, fileToRecover.name())__                        restoreFile(fileToRecover, store)__                    }_                } catch (IOException ex) {_                    throw new IndexShardRestoreFailedException(shardId, "Failed to recover index", ex)__                }__                _                final SegmentInfos segmentCommitInfos__                try {_                    segmentCommitInfos = Lucene.pruneUnreferencedFiles(restoredSegmentsFile.name(), store.directory())__                } catch (IOException e) {_                    throw new IndexShardRestoreFailedException(shardId, "Failed to fetch index version after copying it over", e)__                }_                recoveryState.getIndex().updateVersion(segmentCommitInfos.getVersion())___                _                try {_                    for (String storeFile : store.directory().listAll()) {_                        if (Store.isAutogenerated(storeFile) || snapshotFiles.containPhysicalIndexFile(storeFile)) {_                            continue_ _                        }_                        try {_                            store.deleteQuiet("restore", storeFile)__                            store.directory().deleteFile(storeFile)__                        } catch (IOException e) {_                            logger.warn("[{}] failed to delete file [{}] during snapshot cleanup", snapshotId, storeFile)__                        }_                    }_                } catch (IOException e) {_                    logger.warn("[{}] failed to list directory - some of files might not be deleted", snapshotId)__                }_            } finally {_                store.decRef()__            }_        };performs,restore,operation;public,void,restore,throws,ioexception,final,store,store,target,shard,store,store,inc,ref,try,logger,debug,restoring,to,snapshot,id,metadata,name,shard,id,blob,store,index,shard,snapshot,snapshot,load,snapshot,if,snapshot,index,files,size,1,snapshot,index,files,get,0,physical,name,starts,with,snapshot,index,files,get,0,has,unknown,checksum,index,writer,writer,new,index,writer,store,directory,new,index,writer,config,null,set,open,mode,index,writer,config,open,mode,create,set,commit,on,close,true,writer,close,return,snapshot,files,snapshot,files,new,snapshot,files,snapshot,snapshot,snapshot,index,files,store,metadata,snapshot,recovery,target,metadata,try,recovery,target,metadata,target,shard,snapshot,store,metadata,catch,index,not,found,exception,e,logger,trace,restoring,from,to,an,empty,shard,shard,id,snapshot,id,recovery,target,metadata,store,metadata,snapshot,empty,catch,ioexception,e,logger,warn,new,parameterized,message,can,t,read,metadata,from,store,will,not,reuse,any,local,file,while,restoring,shard,id,e,recovery,target,metadata,store,metadata,snapshot,empty,final,list,blob,store,index,shard,snapshot,file,info,files,to,recover,new,array,list,final,map,string,store,file,meta,data,snapshot,meta,data,new,hash,map,final,map,string,blob,store,index,shard,snapshot,file,info,file,infos,new,hash,map,for,final,blob,store,index,shard,snapshot,file,info,file,info,snapshot,index,files,try,maybe,recalculate,metadata,hash,blob,container,file,info,recovery,target,metadata,catch,exception,e,logger,warn,new,parameterized,message,can,t,calculate,hash,from,blog,for,file,shard,id,file,info,physical,name,file,info,metadata,e,snapshot,meta,data,put,file,info,metadata,name,file,info,metadata,file,infos,put,file,info,metadata,name,file,info,final,store,metadata,snapshot,source,meta,data,new,store,metadata,snapshot,unmodifiable,map,snapshot,meta,data,empty,map,0,final,store,file,meta,data,restored,segments,file,source,meta,data,get,segments,file,if,restored,segments,file,null,throw,new,index,shard,restore,failed,exception,shard,id,snapshot,has,no,segments,file,final,store,recovery,diff,diff,source,meta,data,recovery,diff,recovery,target,metadata,for,store,file,meta,data,md,diff,identical,blob,store,index,shard,snapshot,file,info,file,info,file,infos,get,md,name,recovery,state,get,index,add,file,detail,file,info,name,file,info,length,true,if,logger,is,trace,enabled,logger,trace,from,exists,in,local,store,and,is,same,shard,id,snapshot,id,file,info,physical,name,file,info,name,for,store,file,meta,data,md,iterables,concat,diff,different,diff,missing,blob,store,index,shard,snapshot,file,info,file,info,file,infos,get,md,name,files,to,recover,add,file,info,recovery,state,get,index,add,file,detail,file,info,name,file,info,length,false,if,logger,is,trace,enabled,if,md,null,logger,trace,recovering,from,does,not,exists,in,local,store,shard,id,snapshot,id,file,info,physical,name,file,info,name,else,logger,trace,recovering,from,exists,in,local,store,but,is,different,shard,id,snapshot,id,file,info,physical,name,file,info,name,if,files,to,recover,is,empty,logger,trace,no,files,to,recover,all,exists,within,the,local,store,try,final,list,string,delete,if,exist,files,arrays,as,list,store,directory,list,all,for,final,blob,store,index,shard,snapshot,file,info,file,to,recover,files,to,recover,final,string,physical,name,file,to,recover,physical,name,if,delete,if,exist,files,contains,physical,name,logger,trace,deleting,pre,existing,file,shard,id,snapshot,id,physical,name,store,directory,delete,file,physical,name,logger,trace,restoring,file,shard,id,snapshot,id,file,to,recover,name,restore,file,file,to,recover,store,catch,ioexception,ex,throw,new,index,shard,restore,failed,exception,shard,id,failed,to,recover,index,ex,final,segment,infos,segment,commit,infos,try,segment,commit,infos,lucene,prune,unreferenced,files,restored,segments,file,name,store,directory,catch,ioexception,e,throw,new,index,shard,restore,failed,exception,shard,id,failed,to,fetch,index,version,after,copying,it,over,e,recovery,state,get,index,update,version,segment,commit,infos,get,version,try,for,string,store,file,store,directory,list,all,if,store,is,autogenerated,store,file,snapshot,files,contain,physical,index,file,store,file,continue,try,store,delete,quiet,restore,store,file,store,directory,delete,file,store,file,catch,ioexception,e,logger,warn,failed,to,delete,file,during,snapshot,cleanup,snapshot,id,store,file,catch,ioexception,e,logger,warn,failed,to,list,directory,some,of,files,might,not,be,deleted,snapshot,id,finally,store,dec,ref
BlobStoreRepository -> RestoreContext -> public void restore() throws IOException;1526574077;Performs restore operation;public void restore() throws IOException {_            final Store store = targetShard.store()__            store.incRef()__            try {_                logger.debug("[{}] [{}] restoring to [{}] ...", snapshotId, metadata.name(), shardId)__                BlobStoreIndexShardSnapshot snapshot = loadSnapshot()___                if (snapshot.indexFiles().size() == 1_                    && snapshot.indexFiles().get(0).physicalName().startsWith("segments_")_                    && snapshot.indexFiles().get(0).hasUnknownChecksum()) {_                    _                    _                    _                    _                    _                    _                    _                    _                    IndexWriter writer = new IndexWriter(store.directory(), new IndexWriterConfig(null)_                        .setOpenMode(IndexWriterConfig.OpenMode.CREATE)_                        .setCommitOnClose(true))__                    writer.close()__                    return__                }__                SnapshotFiles snapshotFiles = new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles())__                Store.MetadataSnapshot recoveryTargetMetadata__                try {_                    _                    _                    _                    recoveryTargetMetadata = targetShard.snapshotStoreMetadata()__                } catch (IndexNotFoundException e) {_                    _                    logger.trace("[{}] [{}] restoring from to an empty shard", shardId, snapshotId)__                    recoveryTargetMetadata = Store.MetadataSnapshot.EMPTY__                } catch (IOException e) {_                    logger.warn(() -> new ParameterizedMessage("{} Can't read metadata from store, will not reuse any local file while restoring", shardId), e)__                    recoveryTargetMetadata = Store.MetadataSnapshot.EMPTY__                }__                final List<BlobStoreIndexShardSnapshot.FileInfo> filesToRecover = new ArrayList<>()__                final Map<String, StoreFileMetaData> snapshotMetaData = new HashMap<>()__                final Map<String, BlobStoreIndexShardSnapshot.FileInfo> fileInfos = new HashMap<>()__                for (final BlobStoreIndexShardSnapshot.FileInfo fileInfo : snapshot.indexFiles()) {_                    try {_                        _                        _                        _                        _                        maybeRecalculateMetadataHash(blobContainer, fileInfo, recoveryTargetMetadata)__                    } catch (Exception e) {_                        _                        logger.warn(() -> new ParameterizedMessage("{} Can't calculate hash from blog for file [{}] [{}]", shardId, fileInfo.physicalName(), fileInfo.metadata()), e)__                    }_                    snapshotMetaData.put(fileInfo.metadata().name(), fileInfo.metadata())__                    fileInfos.put(fileInfo.metadata().name(), fileInfo)__                }__                final Store.MetadataSnapshot sourceMetaData = new Store.MetadataSnapshot(unmodifiableMap(snapshotMetaData), emptyMap(), 0)___                final StoreFileMetaData restoredSegmentsFile = sourceMetaData.getSegmentsFile()__                if (restoredSegmentsFile == null) {_                    throw new IndexShardRestoreFailedException(shardId, "Snapshot has no segments file")__                }__                final Store.RecoveryDiff diff = sourceMetaData.recoveryDiff(recoveryTargetMetadata)__                for (StoreFileMetaData md : diff.identical) {_                    BlobStoreIndexShardSnapshot.FileInfo fileInfo = fileInfos.get(md.name())__                    recoveryState.getIndex().addFileDetail(fileInfo.name(), fileInfo.length(), true)__                    if (logger.isTraceEnabled()) {_                        logger.trace("[{}] [{}] not_recovering [{}] from [{}], exists in local store and is same", shardId, snapshotId, fileInfo.physicalName(), fileInfo.name())__                    }_                }__                for (StoreFileMetaData md : Iterables.concat(diff.different, diff.missing)) {_                    BlobStoreIndexShardSnapshot.FileInfo fileInfo = fileInfos.get(md.name())__                    filesToRecover.add(fileInfo)__                    recoveryState.getIndex().addFileDetail(fileInfo.name(), fileInfo.length(), false)__                    if (logger.isTraceEnabled()) {_                        if (md == null) {_                            logger.trace("[{}] [{}] recovering [{}] from [{}], does not exists in local store", shardId, snapshotId, fileInfo.physicalName(), fileInfo.name())__                        } else {_                            logger.trace("[{}] [{}] recovering [{}] from [{}], exists in local store but is different", shardId, snapshotId, fileInfo.physicalName(), fileInfo.name())__                        }_                    }_                }__                if (filesToRecover.isEmpty()) {_                    logger.trace("no files to recover, all exists within the local store")__                }__                try {_                    _                    final List<String> deleteIfExistFiles = Arrays.asList(store.directory().listAll())___                    _                    for (final BlobStoreIndexShardSnapshot.FileInfo fileToRecover : filesToRecover) {_                        _                        _                        _                        _                        _                        _                        final String physicalName = fileToRecover.physicalName()__                        if (deleteIfExistFiles.contains(physicalName)) {_                            logger.trace("[{}] [{}] deleting pre-existing file [{}]", shardId, snapshotId, physicalName)__                            store.directory().deleteFile(physicalName)__                        }__                        logger.trace("[{}] [{}] restoring file [{}]", shardId, snapshotId, fileToRecover.name())__                        restoreFile(fileToRecover, store)__                    }_                } catch (IOException ex) {_                    throw new IndexShardRestoreFailedException(shardId, "Failed to recover index", ex)__                }__                _                final SegmentInfos segmentCommitInfos__                try {_                    segmentCommitInfos = Lucene.pruneUnreferencedFiles(restoredSegmentsFile.name(), store.directory())__                } catch (IOException e) {_                    throw new IndexShardRestoreFailedException(shardId, "Failed to fetch index version after copying it over", e)__                }_                recoveryState.getIndex().updateVersion(segmentCommitInfos.getVersion())___                _                try {_                    for (String storeFile : store.directory().listAll()) {_                        if (Store.isAutogenerated(storeFile) || snapshotFiles.containPhysicalIndexFile(storeFile)) {_                            continue_ _                        }_                        try {_                            store.deleteQuiet("restore", storeFile)__                            store.directory().deleteFile(storeFile)__                        } catch (IOException e) {_                            logger.warn("[{}] failed to delete file [{}] during snapshot cleanup", snapshotId, storeFile)__                        }_                    }_                } catch (IOException e) {_                    logger.warn("[{}] failed to list directory - some of files might not be deleted", snapshotId)__                }_            } finally {_                store.decRef()__            }_        };performs,restore,operation;public,void,restore,throws,ioexception,final,store,store,target,shard,store,store,inc,ref,try,logger,debug,restoring,to,snapshot,id,metadata,name,shard,id,blob,store,index,shard,snapshot,snapshot,load,snapshot,if,snapshot,index,files,size,1,snapshot,index,files,get,0,physical,name,starts,with,snapshot,index,files,get,0,has,unknown,checksum,index,writer,writer,new,index,writer,store,directory,new,index,writer,config,null,set,open,mode,index,writer,config,open,mode,create,set,commit,on,close,true,writer,close,return,snapshot,files,snapshot,files,new,snapshot,files,snapshot,snapshot,snapshot,index,files,store,metadata,snapshot,recovery,target,metadata,try,recovery,target,metadata,target,shard,snapshot,store,metadata,catch,index,not,found,exception,e,logger,trace,restoring,from,to,an,empty,shard,shard,id,snapshot,id,recovery,target,metadata,store,metadata,snapshot,empty,catch,ioexception,e,logger,warn,new,parameterized,message,can,t,read,metadata,from,store,will,not,reuse,any,local,file,while,restoring,shard,id,e,recovery,target,metadata,store,metadata,snapshot,empty,final,list,blob,store,index,shard,snapshot,file,info,files,to,recover,new,array,list,final,map,string,store,file,meta,data,snapshot,meta,data,new,hash,map,final,map,string,blob,store,index,shard,snapshot,file,info,file,infos,new,hash,map,for,final,blob,store,index,shard,snapshot,file,info,file,info,snapshot,index,files,try,maybe,recalculate,metadata,hash,blob,container,file,info,recovery,target,metadata,catch,exception,e,logger,warn,new,parameterized,message,can,t,calculate,hash,from,blog,for,file,shard,id,file,info,physical,name,file,info,metadata,e,snapshot,meta,data,put,file,info,metadata,name,file,info,metadata,file,infos,put,file,info,metadata,name,file,info,final,store,metadata,snapshot,source,meta,data,new,store,metadata,snapshot,unmodifiable,map,snapshot,meta,data,empty,map,0,final,store,file,meta,data,restored,segments,file,source,meta,data,get,segments,file,if,restored,segments,file,null,throw,new,index,shard,restore,failed,exception,shard,id,snapshot,has,no,segments,file,final,store,recovery,diff,diff,source,meta,data,recovery,diff,recovery,target,metadata,for,store,file,meta,data,md,diff,identical,blob,store,index,shard,snapshot,file,info,file,info,file,infos,get,md,name,recovery,state,get,index,add,file,detail,file,info,name,file,info,length,true,if,logger,is,trace,enabled,logger,trace,from,exists,in,local,store,and,is,same,shard,id,snapshot,id,file,info,physical,name,file,info,name,for,store,file,meta,data,md,iterables,concat,diff,different,diff,missing,blob,store,index,shard,snapshot,file,info,file,info,file,infos,get,md,name,files,to,recover,add,file,info,recovery,state,get,index,add,file,detail,file,info,name,file,info,length,false,if,logger,is,trace,enabled,if,md,null,logger,trace,recovering,from,does,not,exists,in,local,store,shard,id,snapshot,id,file,info,physical,name,file,info,name,else,logger,trace,recovering,from,exists,in,local,store,but,is,different,shard,id,snapshot,id,file,info,physical,name,file,info,name,if,files,to,recover,is,empty,logger,trace,no,files,to,recover,all,exists,within,the,local,store,try,final,list,string,delete,if,exist,files,arrays,as,list,store,directory,list,all,for,final,blob,store,index,shard,snapshot,file,info,file,to,recover,files,to,recover,final,string,physical,name,file,to,recover,physical,name,if,delete,if,exist,files,contains,physical,name,logger,trace,deleting,pre,existing,file,shard,id,snapshot,id,physical,name,store,directory,delete,file,physical,name,logger,trace,restoring,file,shard,id,snapshot,id,file,to,recover,name,restore,file,file,to,recover,store,catch,ioexception,ex,throw,new,index,shard,restore,failed,exception,shard,id,failed,to,recover,index,ex,final,segment,infos,segment,commit,infos,try,segment,commit,infos,lucene,prune,unreferenced,files,restored,segments,file,name,store,directory,catch,ioexception,e,throw,new,index,shard,restore,failed,exception,shard,id,failed,to,fetch,index,version,after,copying,it,over,e,recovery,state,get,index,update,version,segment,commit,infos,get,version,try,for,string,store,file,store,directory,list,all,if,store,is,autogenerated,store,file,snapshot,files,contain,physical,index,file,store,file,continue,try,store,delete,quiet,restore,store,file,store,directory,delete,file,store,file,catch,ioexception,e,logger,warn,failed,to,delete,file,during,snapshot,cleanup,snapshot,id,store,file,catch,ioexception,e,logger,warn,failed,to,list,directory,some,of,files,might,not,be,deleted,snapshot,id,finally,store,dec,ref
BlobStoreRepository -> RestoreContext -> public void restore() throws IOException;1527583663;Performs restore operation;public void restore() throws IOException {_            final Store store = targetShard.store()__            store.incRef()__            try {_                logger.debug("[{}] [{}] restoring to [{}] ...", snapshotId, metadata.name(), shardId)__                BlobStoreIndexShardSnapshot snapshot = loadSnapshot()___                if (snapshot.indexFiles().size() == 1_                    && snapshot.indexFiles().get(0).physicalName().startsWith("segments_")_                    && snapshot.indexFiles().get(0).hasUnknownChecksum()) {_                    _                    _                    _                    _                    _                    _                    _                    _                    IndexWriter writer = new IndexWriter(store.directory(), new IndexWriterConfig(null)_                        .setOpenMode(IndexWriterConfig.OpenMode.CREATE)_                        .setCommitOnClose(true))__                    writer.close()__                    return__                }__                SnapshotFiles snapshotFiles = new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles())__                Store.MetadataSnapshot recoveryTargetMetadata__                try {_                    _                    _                    _                    recoveryTargetMetadata = targetShard.snapshotStoreMetadata()__                } catch (IndexNotFoundException e) {_                    _                    logger.trace("[{}] [{}] restoring from to an empty shard", shardId, snapshotId)__                    recoveryTargetMetadata = Store.MetadataSnapshot.EMPTY__                } catch (IOException e) {_                    logger.warn(() -> new ParameterizedMessage("{} Can't read metadata from store, will not reuse any local file while restoring", shardId), e)__                    recoveryTargetMetadata = Store.MetadataSnapshot.EMPTY__                }__                final List<BlobStoreIndexShardSnapshot.FileInfo> filesToRecover = new ArrayList<>()__                final Map<String, StoreFileMetaData> snapshotMetaData = new HashMap<>()__                final Map<String, BlobStoreIndexShardSnapshot.FileInfo> fileInfos = new HashMap<>()__                for (final BlobStoreIndexShardSnapshot.FileInfo fileInfo : snapshot.indexFiles()) {_                    try {_                        _                        _                        _                        _                        maybeRecalculateMetadataHash(blobContainer, fileInfo, recoveryTargetMetadata)__                    } catch (Exception e) {_                        _                        logger.warn(() -> new ParameterizedMessage("{} Can't calculate hash from blog for file [{}] [{}]", shardId, fileInfo.physicalName(), fileInfo.metadata()), e)__                    }_                    snapshotMetaData.put(fileInfo.metadata().name(), fileInfo.metadata())__                    fileInfos.put(fileInfo.metadata().name(), fileInfo)__                }__                final Store.MetadataSnapshot sourceMetaData = new Store.MetadataSnapshot(unmodifiableMap(snapshotMetaData), emptyMap(), 0)___                final StoreFileMetaData restoredSegmentsFile = sourceMetaData.getSegmentsFile()__                if (restoredSegmentsFile == null) {_                    throw new IndexShardRestoreFailedException(shardId, "Snapshot has no segments file")__                }__                final Store.RecoveryDiff diff = sourceMetaData.recoveryDiff(recoveryTargetMetadata)__                for (StoreFileMetaData md : diff.identical) {_                    BlobStoreIndexShardSnapshot.FileInfo fileInfo = fileInfos.get(md.name())__                    recoveryState.getIndex().addFileDetail(fileInfo.name(), fileInfo.length(), true)__                    if (logger.isTraceEnabled()) {_                        logger.trace("[{}] [{}] not_recovering [{}] from [{}], exists in local store and is same", shardId, snapshotId, fileInfo.physicalName(), fileInfo.name())__                    }_                }__                for (StoreFileMetaData md : Iterables.concat(diff.different, diff.missing)) {_                    BlobStoreIndexShardSnapshot.FileInfo fileInfo = fileInfos.get(md.name())__                    filesToRecover.add(fileInfo)__                    recoveryState.getIndex().addFileDetail(fileInfo.name(), fileInfo.length(), false)__                    if (logger.isTraceEnabled()) {_                        if (md == null) {_                            logger.trace("[{}] [{}] recovering [{}] from [{}], does not exists in local store", shardId, snapshotId, fileInfo.physicalName(), fileInfo.name())__                        } else {_                            logger.trace("[{}] [{}] recovering [{}] from [{}], exists in local store but is different", shardId, snapshotId, fileInfo.physicalName(), fileInfo.name())__                        }_                    }_                }__                if (filesToRecover.isEmpty()) {_                    logger.trace("no files to recover, all exists within the local store")__                }__                try {_                    _                    final List<String> deleteIfExistFiles = Arrays.asList(store.directory().listAll())___                    _                    for (final BlobStoreIndexShardSnapshot.FileInfo fileToRecover : filesToRecover) {_                        _                        _                        _                        _                        _                        _                        final String physicalName = fileToRecover.physicalName()__                        if (deleteIfExistFiles.contains(physicalName)) {_                            logger.trace("[{}] [{}] deleting pre-existing file [{}]", shardId, snapshotId, physicalName)__                            store.directory().deleteFile(physicalName)__                        }__                        logger.trace("[{}] [{}] restoring file [{}]", shardId, snapshotId, fileToRecover.name())__                        restoreFile(fileToRecover, store)__                    }_                } catch (IOException ex) {_                    throw new IndexShardRestoreFailedException(shardId, "Failed to recover index", ex)__                }__                _                final SegmentInfos segmentCommitInfos__                try {_                    segmentCommitInfos = Lucene.pruneUnreferencedFiles(restoredSegmentsFile.name(), store.directory())__                } catch (IOException e) {_                    throw new IndexShardRestoreFailedException(shardId, "Failed to fetch index version after copying it over", e)__                }_                recoveryState.getIndex().updateVersion(segmentCommitInfos.getVersion())___                _                try {_                    for (String storeFile : store.directory().listAll()) {_                        if (Store.isAutogenerated(storeFile) || snapshotFiles.containPhysicalIndexFile(storeFile)) {_                            continue_ _                        }_                        try {_                            store.deleteQuiet("restore", storeFile)__                            store.directory().deleteFile(storeFile)__                        } catch (IOException e) {_                            logger.warn("[{}] failed to delete file [{}] during snapshot cleanup", snapshotId, storeFile)__                        }_                    }_                } catch (IOException e) {_                    logger.warn("[{}] failed to list directory - some of files might not be deleted", snapshotId)__                }_            } finally {_                store.decRef()__            }_        };performs,restore,operation;public,void,restore,throws,ioexception,final,store,store,target,shard,store,store,inc,ref,try,logger,debug,restoring,to,snapshot,id,metadata,name,shard,id,blob,store,index,shard,snapshot,snapshot,load,snapshot,if,snapshot,index,files,size,1,snapshot,index,files,get,0,physical,name,starts,with,snapshot,index,files,get,0,has,unknown,checksum,index,writer,writer,new,index,writer,store,directory,new,index,writer,config,null,set,open,mode,index,writer,config,open,mode,create,set,commit,on,close,true,writer,close,return,snapshot,files,snapshot,files,new,snapshot,files,snapshot,snapshot,snapshot,index,files,store,metadata,snapshot,recovery,target,metadata,try,recovery,target,metadata,target,shard,snapshot,store,metadata,catch,index,not,found,exception,e,logger,trace,restoring,from,to,an,empty,shard,shard,id,snapshot,id,recovery,target,metadata,store,metadata,snapshot,empty,catch,ioexception,e,logger,warn,new,parameterized,message,can,t,read,metadata,from,store,will,not,reuse,any,local,file,while,restoring,shard,id,e,recovery,target,metadata,store,metadata,snapshot,empty,final,list,blob,store,index,shard,snapshot,file,info,files,to,recover,new,array,list,final,map,string,store,file,meta,data,snapshot,meta,data,new,hash,map,final,map,string,blob,store,index,shard,snapshot,file,info,file,infos,new,hash,map,for,final,blob,store,index,shard,snapshot,file,info,file,info,snapshot,index,files,try,maybe,recalculate,metadata,hash,blob,container,file,info,recovery,target,metadata,catch,exception,e,logger,warn,new,parameterized,message,can,t,calculate,hash,from,blog,for,file,shard,id,file,info,physical,name,file,info,metadata,e,snapshot,meta,data,put,file,info,metadata,name,file,info,metadata,file,infos,put,file,info,metadata,name,file,info,final,store,metadata,snapshot,source,meta,data,new,store,metadata,snapshot,unmodifiable,map,snapshot,meta,data,empty,map,0,final,store,file,meta,data,restored,segments,file,source,meta,data,get,segments,file,if,restored,segments,file,null,throw,new,index,shard,restore,failed,exception,shard,id,snapshot,has,no,segments,file,final,store,recovery,diff,diff,source,meta,data,recovery,diff,recovery,target,metadata,for,store,file,meta,data,md,diff,identical,blob,store,index,shard,snapshot,file,info,file,info,file,infos,get,md,name,recovery,state,get,index,add,file,detail,file,info,name,file,info,length,true,if,logger,is,trace,enabled,logger,trace,from,exists,in,local,store,and,is,same,shard,id,snapshot,id,file,info,physical,name,file,info,name,for,store,file,meta,data,md,iterables,concat,diff,different,diff,missing,blob,store,index,shard,snapshot,file,info,file,info,file,infos,get,md,name,files,to,recover,add,file,info,recovery,state,get,index,add,file,detail,file,info,name,file,info,length,false,if,logger,is,trace,enabled,if,md,null,logger,trace,recovering,from,does,not,exists,in,local,store,shard,id,snapshot,id,file,info,physical,name,file,info,name,else,logger,trace,recovering,from,exists,in,local,store,but,is,different,shard,id,snapshot,id,file,info,physical,name,file,info,name,if,files,to,recover,is,empty,logger,trace,no,files,to,recover,all,exists,within,the,local,store,try,final,list,string,delete,if,exist,files,arrays,as,list,store,directory,list,all,for,final,blob,store,index,shard,snapshot,file,info,file,to,recover,files,to,recover,final,string,physical,name,file,to,recover,physical,name,if,delete,if,exist,files,contains,physical,name,logger,trace,deleting,pre,existing,file,shard,id,snapshot,id,physical,name,store,directory,delete,file,physical,name,logger,trace,restoring,file,shard,id,snapshot,id,file,to,recover,name,restore,file,file,to,recover,store,catch,ioexception,ex,throw,new,index,shard,restore,failed,exception,shard,id,failed,to,recover,index,ex,final,segment,infos,segment,commit,infos,try,segment,commit,infos,lucene,prune,unreferenced,files,restored,segments,file,name,store,directory,catch,ioexception,e,throw,new,index,shard,restore,failed,exception,shard,id,failed,to,fetch,index,version,after,copying,it,over,e,recovery,state,get,index,update,version,segment,commit,infos,get,version,try,for,string,store,file,store,directory,list,all,if,store,is,autogenerated,store,file,snapshot,files,contain,physical,index,file,store,file,continue,try,store,delete,quiet,restore,store,file,store,directory,delete,file,store,file,catch,ioexception,e,logger,warn,failed,to,delete,file,during,snapshot,cleanup,snapshot,id,store,file,catch,ioexception,e,logger,warn,failed,to,list,directory,some,of,files,might,not,be,deleted,snapshot,id,finally,store,dec,ref
BlobStoreRepository -> RestoreContext -> public void restore() throws IOException;1528211342;Performs restore operation;public void restore() throws IOException {_            final Store store = targetShard.store()__            store.incRef()__            try {_                logger.debug("[{}] [{}] restoring to [{}] ...", snapshotId, metadata.name(), shardId)__                BlobStoreIndexShardSnapshot snapshot = loadSnapshot()___                if (snapshot.indexFiles().size() == 1_                    && snapshot.indexFiles().get(0).physicalName().startsWith("segments_")_                    && snapshot.indexFiles().get(0).hasUnknownChecksum()) {_                    _                    _                    _                    _                    _                    _                    _                    _                    IndexWriter writer = new IndexWriter(store.directory(), new IndexWriterConfig(null)_                        .setOpenMode(IndexWriterConfig.OpenMode.CREATE)_                        .setCommitOnClose(true))__                    writer.close()__                    return__                }__                SnapshotFiles snapshotFiles = new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles())__                Store.MetadataSnapshot recoveryTargetMetadata__                try {_                    _                    _                    _                    recoveryTargetMetadata = targetShard.snapshotStoreMetadata()__                } catch (IndexNotFoundException e) {_                    _                    logger.trace("[{}] [{}] restoring from to an empty shard", shardId, snapshotId)__                    recoveryTargetMetadata = Store.MetadataSnapshot.EMPTY__                } catch (IOException e) {_                    logger.warn(() -> new ParameterizedMessage("{} Can't read metadata from store, will not reuse any local file while restoring", shardId), e)__                    recoveryTargetMetadata = Store.MetadataSnapshot.EMPTY__                }__                final List<BlobStoreIndexShardSnapshot.FileInfo> filesToRecover = new ArrayList<>()__                final Map<String, StoreFileMetaData> snapshotMetaData = new HashMap<>()__                final Map<String, BlobStoreIndexShardSnapshot.FileInfo> fileInfos = new HashMap<>()__                for (final BlobStoreIndexShardSnapshot.FileInfo fileInfo : snapshot.indexFiles()) {_                    try {_                        _                        _                        _                        _                        maybeRecalculateMetadataHash(blobContainer, fileInfo, recoveryTargetMetadata)__                    } catch (Exception e) {_                        _                        logger.warn(() -> new ParameterizedMessage("{} Can't calculate hash from blog for file [{}] [{}]", shardId, fileInfo.physicalName(), fileInfo.metadata()), e)__                    }_                    snapshotMetaData.put(fileInfo.metadata().name(), fileInfo.metadata())__                    fileInfos.put(fileInfo.metadata().name(), fileInfo)__                }__                final Store.MetadataSnapshot sourceMetaData = new Store.MetadataSnapshot(unmodifiableMap(snapshotMetaData), emptyMap(), 0)___                final StoreFileMetaData restoredSegmentsFile = sourceMetaData.getSegmentsFile()__                if (restoredSegmentsFile == null) {_                    throw new IndexShardRestoreFailedException(shardId, "Snapshot has no segments file")__                }__                final Store.RecoveryDiff diff = sourceMetaData.recoveryDiff(recoveryTargetMetadata)__                for (StoreFileMetaData md : diff.identical) {_                    BlobStoreIndexShardSnapshot.FileInfo fileInfo = fileInfos.get(md.name())__                    recoveryState.getIndex().addFileDetail(fileInfo.name(), fileInfo.length(), true)__                    if (logger.isTraceEnabled()) {_                        logger.trace("[{}] [{}] not_recovering [{}] from [{}], exists in local store and is same", shardId, snapshotId, fileInfo.physicalName(), fileInfo.name())__                    }_                }__                for (StoreFileMetaData md : Iterables.concat(diff.different, diff.missing)) {_                    BlobStoreIndexShardSnapshot.FileInfo fileInfo = fileInfos.get(md.name())__                    filesToRecover.add(fileInfo)__                    recoveryState.getIndex().addFileDetail(fileInfo.name(), fileInfo.length(), false)__                    if (logger.isTraceEnabled()) {_                        if (md == null) {_                            logger.trace("[{}] [{}] recovering [{}] from [{}], does not exists in local store", shardId, snapshotId, fileInfo.physicalName(), fileInfo.name())__                        } else {_                            logger.trace("[{}] [{}] recovering [{}] from [{}], exists in local store but is different", shardId, snapshotId, fileInfo.physicalName(), fileInfo.name())__                        }_                    }_                }__                if (filesToRecover.isEmpty()) {_                    logger.trace("no files to recover, all exists within the local store")__                }__                try {_                    _                    final List<String> deleteIfExistFiles = Arrays.asList(store.directory().listAll())___                    _                    for (final BlobStoreIndexShardSnapshot.FileInfo fileToRecover : filesToRecover) {_                        _                        _                        _                        _                        _                        _                        final String physicalName = fileToRecover.physicalName()__                        if (deleteIfExistFiles.contains(physicalName)) {_                            logger.trace("[{}] [{}] deleting pre-existing file [{}]", shardId, snapshotId, physicalName)__                            store.directory().deleteFile(physicalName)__                        }__                        logger.trace("[{}] [{}] restoring file [{}]", shardId, snapshotId, fileToRecover.name())__                        restoreFile(fileToRecover, store)__                    }_                } catch (IOException ex) {_                    throw new IndexShardRestoreFailedException(shardId, "Failed to recover index", ex)__                }__                _                final SegmentInfos segmentCommitInfos__                try {_                    segmentCommitInfos = Lucene.pruneUnreferencedFiles(restoredSegmentsFile.name(), store.directory())__                } catch (IOException e) {_                    throw new IndexShardRestoreFailedException(shardId, "Failed to fetch index version after copying it over", e)__                }_                recoveryState.getIndex().updateVersion(segmentCommitInfos.getVersion())___                _                try {_                    for (String storeFile : store.directory().listAll()) {_                        if (Store.isAutogenerated(storeFile) || snapshotFiles.containPhysicalIndexFile(storeFile)) {_                            continue_ _                        }_                        try {_                            store.deleteQuiet("restore", storeFile)__                            store.directory().deleteFile(storeFile)__                        } catch (IOException e) {_                            logger.warn("[{}] failed to delete file [{}] during snapshot cleanup", snapshotId, storeFile)__                        }_                    }_                } catch (IOException e) {_                    logger.warn("[{}] failed to list directory - some of files might not be deleted", snapshotId)__                }_            } finally {_                store.decRef()__            }_        };performs,restore,operation;public,void,restore,throws,ioexception,final,store,store,target,shard,store,store,inc,ref,try,logger,debug,restoring,to,snapshot,id,metadata,name,shard,id,blob,store,index,shard,snapshot,snapshot,load,snapshot,if,snapshot,index,files,size,1,snapshot,index,files,get,0,physical,name,starts,with,snapshot,index,files,get,0,has,unknown,checksum,index,writer,writer,new,index,writer,store,directory,new,index,writer,config,null,set,open,mode,index,writer,config,open,mode,create,set,commit,on,close,true,writer,close,return,snapshot,files,snapshot,files,new,snapshot,files,snapshot,snapshot,snapshot,index,files,store,metadata,snapshot,recovery,target,metadata,try,recovery,target,metadata,target,shard,snapshot,store,metadata,catch,index,not,found,exception,e,logger,trace,restoring,from,to,an,empty,shard,shard,id,snapshot,id,recovery,target,metadata,store,metadata,snapshot,empty,catch,ioexception,e,logger,warn,new,parameterized,message,can,t,read,metadata,from,store,will,not,reuse,any,local,file,while,restoring,shard,id,e,recovery,target,metadata,store,metadata,snapshot,empty,final,list,blob,store,index,shard,snapshot,file,info,files,to,recover,new,array,list,final,map,string,store,file,meta,data,snapshot,meta,data,new,hash,map,final,map,string,blob,store,index,shard,snapshot,file,info,file,infos,new,hash,map,for,final,blob,store,index,shard,snapshot,file,info,file,info,snapshot,index,files,try,maybe,recalculate,metadata,hash,blob,container,file,info,recovery,target,metadata,catch,exception,e,logger,warn,new,parameterized,message,can,t,calculate,hash,from,blog,for,file,shard,id,file,info,physical,name,file,info,metadata,e,snapshot,meta,data,put,file,info,metadata,name,file,info,metadata,file,infos,put,file,info,metadata,name,file,info,final,store,metadata,snapshot,source,meta,data,new,store,metadata,snapshot,unmodifiable,map,snapshot,meta,data,empty,map,0,final,store,file,meta,data,restored,segments,file,source,meta,data,get,segments,file,if,restored,segments,file,null,throw,new,index,shard,restore,failed,exception,shard,id,snapshot,has,no,segments,file,final,store,recovery,diff,diff,source,meta,data,recovery,diff,recovery,target,metadata,for,store,file,meta,data,md,diff,identical,blob,store,index,shard,snapshot,file,info,file,info,file,infos,get,md,name,recovery,state,get,index,add,file,detail,file,info,name,file,info,length,true,if,logger,is,trace,enabled,logger,trace,from,exists,in,local,store,and,is,same,shard,id,snapshot,id,file,info,physical,name,file,info,name,for,store,file,meta,data,md,iterables,concat,diff,different,diff,missing,blob,store,index,shard,snapshot,file,info,file,info,file,infos,get,md,name,files,to,recover,add,file,info,recovery,state,get,index,add,file,detail,file,info,name,file,info,length,false,if,logger,is,trace,enabled,if,md,null,logger,trace,recovering,from,does,not,exists,in,local,store,shard,id,snapshot,id,file,info,physical,name,file,info,name,else,logger,trace,recovering,from,exists,in,local,store,but,is,different,shard,id,snapshot,id,file,info,physical,name,file,info,name,if,files,to,recover,is,empty,logger,trace,no,files,to,recover,all,exists,within,the,local,store,try,final,list,string,delete,if,exist,files,arrays,as,list,store,directory,list,all,for,final,blob,store,index,shard,snapshot,file,info,file,to,recover,files,to,recover,final,string,physical,name,file,to,recover,physical,name,if,delete,if,exist,files,contains,physical,name,logger,trace,deleting,pre,existing,file,shard,id,snapshot,id,physical,name,store,directory,delete,file,physical,name,logger,trace,restoring,file,shard,id,snapshot,id,file,to,recover,name,restore,file,file,to,recover,store,catch,ioexception,ex,throw,new,index,shard,restore,failed,exception,shard,id,failed,to,recover,index,ex,final,segment,infos,segment,commit,infos,try,segment,commit,infos,lucene,prune,unreferenced,files,restored,segments,file,name,store,directory,catch,ioexception,e,throw,new,index,shard,restore,failed,exception,shard,id,failed,to,fetch,index,version,after,copying,it,over,e,recovery,state,get,index,update,version,segment,commit,infos,get,version,try,for,string,store,file,store,directory,list,all,if,store,is,autogenerated,store,file,snapshot,files,contain,physical,index,file,store,file,continue,try,store,delete,quiet,restore,store,file,store,directory,delete,file,store,file,catch,ioexception,e,logger,warn,failed,to,delete,file,during,snapshot,cleanup,snapshot,id,store,file,catch,ioexception,e,logger,warn,failed,to,list,directory,some,of,files,might,not,be,deleted,snapshot,id,finally,store,dec,ref
BlobStoreRepository -> RestoreContext -> public void restore() throws IOException;1531179852;Performs restore operation;public void restore() throws IOException {_            final Store store = targetShard.store()__            store.incRef()__            try {_                logger.debug("[{}] [{}] restoring to [{}] ...", snapshotId, metadata.name(), shardId)__                BlobStoreIndexShardSnapshot snapshot = loadSnapshot()___                if (snapshot.indexFiles().size() == 1_                    && snapshot.indexFiles().get(0).physicalName().startsWith("segments_")_                    && snapshot.indexFiles().get(0).hasUnknownChecksum()) {_                    _                    _                    _                    _                    _                    _                    _                    _                    IndexWriter writer = new IndexWriter(store.directory(), new IndexWriterConfig(null)_                        .setOpenMode(IndexWriterConfig.OpenMode.CREATE)_                        .setCommitOnClose(true))__                    writer.close()__                    return__                }__                SnapshotFiles snapshotFiles = new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles())__                Store.MetadataSnapshot recoveryTargetMetadata__                try {_                    _                    _                    _                    recoveryTargetMetadata = targetShard.snapshotStoreMetadata()__                } catch (IndexNotFoundException e) {_                    _                    logger.trace("[{}] [{}] restoring from to an empty shard", shardId, snapshotId)__                    recoveryTargetMetadata = Store.MetadataSnapshot.EMPTY__                } catch (IOException e) {_                    logger.warn(() -> new ParameterizedMessage("{} Can't read metadata from store, will not reuse any local file while restoring", shardId), e)__                    recoveryTargetMetadata = Store.MetadataSnapshot.EMPTY__                }__                final List<BlobStoreIndexShardSnapshot.FileInfo> filesToRecover = new ArrayList<>()__                final Map<String, StoreFileMetaData> snapshotMetaData = new HashMap<>()__                final Map<String, BlobStoreIndexShardSnapshot.FileInfo> fileInfos = new HashMap<>()__                for (final BlobStoreIndexShardSnapshot.FileInfo fileInfo : snapshot.indexFiles()) {_                    try {_                        _                        _                        _                        _                        maybeRecalculateMetadataHash(blobContainer, fileInfo, recoveryTargetMetadata)__                    } catch (Exception e) {_                        _                        logger.warn(() -> new ParameterizedMessage("{} Can't calculate hash from blog for file [{}] [{}]", shardId, fileInfo.physicalName(), fileInfo.metadata()), e)__                    }_                    snapshotMetaData.put(fileInfo.metadata().name(), fileInfo.metadata())__                    fileInfos.put(fileInfo.metadata().name(), fileInfo)__                }__                final Store.MetadataSnapshot sourceMetaData = new Store.MetadataSnapshot(unmodifiableMap(snapshotMetaData), emptyMap(), 0)___                final StoreFileMetaData restoredSegmentsFile = sourceMetaData.getSegmentsFile()__                if (restoredSegmentsFile == null) {_                    throw new IndexShardRestoreFailedException(shardId, "Snapshot has no segments file")__                }__                final Store.RecoveryDiff diff = sourceMetaData.recoveryDiff(recoveryTargetMetadata)__                for (StoreFileMetaData md : diff.identical) {_                    BlobStoreIndexShardSnapshot.FileInfo fileInfo = fileInfos.get(md.name())__                    recoveryState.getIndex().addFileDetail(fileInfo.name(), fileInfo.length(), true)__                    if (logger.isTraceEnabled()) {_                        logger.trace("[{}] [{}] not_recovering [{}] from [{}], exists in local store and is same", shardId, snapshotId, fileInfo.physicalName(), fileInfo.name())__                    }_                }__                for (StoreFileMetaData md : Iterables.concat(diff.different, diff.missing)) {_                    BlobStoreIndexShardSnapshot.FileInfo fileInfo = fileInfos.get(md.name())__                    filesToRecover.add(fileInfo)__                    recoveryState.getIndex().addFileDetail(fileInfo.name(), fileInfo.length(), false)__                    if (logger.isTraceEnabled()) {_                        if (md == null) {_                            logger.trace("[{}] [{}] recovering [{}] from [{}], does not exists in local store", shardId, snapshotId, fileInfo.physicalName(), fileInfo.name())__                        } else {_                            logger.trace("[{}] [{}] recovering [{}] from [{}], exists in local store but is different", shardId, snapshotId, fileInfo.physicalName(), fileInfo.name())__                        }_                    }_                }__                if (filesToRecover.isEmpty()) {_                    logger.trace("no files to recover, all exists within the local store")__                }__                try {_                    _                    final List<String> deleteIfExistFiles = Arrays.asList(store.directory().listAll())___                    _                    for (final BlobStoreIndexShardSnapshot.FileInfo fileToRecover : filesToRecover) {_                        _                        _                        _                        _                        _                        _                        final String physicalName = fileToRecover.physicalName()__                        if (deleteIfExistFiles.contains(physicalName)) {_                            logger.trace("[{}] [{}] deleting pre-existing file [{}]", shardId, snapshotId, physicalName)__                            store.directory().deleteFile(physicalName)__                        }__                        logger.trace("[{}] [{}] restoring file [{}]", shardId, snapshotId, fileToRecover.name())__                        restoreFile(fileToRecover, store)__                    }_                } catch (IOException ex) {_                    throw new IndexShardRestoreFailedException(shardId, "Failed to recover index", ex)__                }__                _                final SegmentInfos segmentCommitInfos__                try {_                    segmentCommitInfos = Lucene.pruneUnreferencedFiles(restoredSegmentsFile.name(), store.directory())__                } catch (IOException e) {_                    throw new IndexShardRestoreFailedException(shardId, "Failed to fetch index version after copying it over", e)__                }_                recoveryState.getIndex().updateVersion(segmentCommitInfos.getVersion())___                _                try {_                    for (String storeFile : store.directory().listAll()) {_                        if (Store.isAutogenerated(storeFile) || snapshotFiles.containPhysicalIndexFile(storeFile)) {_                            continue_ _                        }_                        try {_                            store.deleteQuiet("restore", storeFile)__                            store.directory().deleteFile(storeFile)__                        } catch (IOException e) {_                            logger.warn("[{}] failed to delete file [{}] during snapshot cleanup", snapshotId, storeFile)__                        }_                    }_                } catch (IOException e) {_                    logger.warn("[{}] failed to list directory - some of files might not be deleted", snapshotId)__                }_            } finally {_                store.decRef()__            }_        };performs,restore,operation;public,void,restore,throws,ioexception,final,store,store,target,shard,store,store,inc,ref,try,logger,debug,restoring,to,snapshot,id,metadata,name,shard,id,blob,store,index,shard,snapshot,snapshot,load,snapshot,if,snapshot,index,files,size,1,snapshot,index,files,get,0,physical,name,starts,with,snapshot,index,files,get,0,has,unknown,checksum,index,writer,writer,new,index,writer,store,directory,new,index,writer,config,null,set,open,mode,index,writer,config,open,mode,create,set,commit,on,close,true,writer,close,return,snapshot,files,snapshot,files,new,snapshot,files,snapshot,snapshot,snapshot,index,files,store,metadata,snapshot,recovery,target,metadata,try,recovery,target,metadata,target,shard,snapshot,store,metadata,catch,index,not,found,exception,e,logger,trace,restoring,from,to,an,empty,shard,shard,id,snapshot,id,recovery,target,metadata,store,metadata,snapshot,empty,catch,ioexception,e,logger,warn,new,parameterized,message,can,t,read,metadata,from,store,will,not,reuse,any,local,file,while,restoring,shard,id,e,recovery,target,metadata,store,metadata,snapshot,empty,final,list,blob,store,index,shard,snapshot,file,info,files,to,recover,new,array,list,final,map,string,store,file,meta,data,snapshot,meta,data,new,hash,map,final,map,string,blob,store,index,shard,snapshot,file,info,file,infos,new,hash,map,for,final,blob,store,index,shard,snapshot,file,info,file,info,snapshot,index,files,try,maybe,recalculate,metadata,hash,blob,container,file,info,recovery,target,metadata,catch,exception,e,logger,warn,new,parameterized,message,can,t,calculate,hash,from,blog,for,file,shard,id,file,info,physical,name,file,info,metadata,e,snapshot,meta,data,put,file,info,metadata,name,file,info,metadata,file,infos,put,file,info,metadata,name,file,info,final,store,metadata,snapshot,source,meta,data,new,store,metadata,snapshot,unmodifiable,map,snapshot,meta,data,empty,map,0,final,store,file,meta,data,restored,segments,file,source,meta,data,get,segments,file,if,restored,segments,file,null,throw,new,index,shard,restore,failed,exception,shard,id,snapshot,has,no,segments,file,final,store,recovery,diff,diff,source,meta,data,recovery,diff,recovery,target,metadata,for,store,file,meta,data,md,diff,identical,blob,store,index,shard,snapshot,file,info,file,info,file,infos,get,md,name,recovery,state,get,index,add,file,detail,file,info,name,file,info,length,true,if,logger,is,trace,enabled,logger,trace,from,exists,in,local,store,and,is,same,shard,id,snapshot,id,file,info,physical,name,file,info,name,for,store,file,meta,data,md,iterables,concat,diff,different,diff,missing,blob,store,index,shard,snapshot,file,info,file,info,file,infos,get,md,name,files,to,recover,add,file,info,recovery,state,get,index,add,file,detail,file,info,name,file,info,length,false,if,logger,is,trace,enabled,if,md,null,logger,trace,recovering,from,does,not,exists,in,local,store,shard,id,snapshot,id,file,info,physical,name,file,info,name,else,logger,trace,recovering,from,exists,in,local,store,but,is,different,shard,id,snapshot,id,file,info,physical,name,file,info,name,if,files,to,recover,is,empty,logger,trace,no,files,to,recover,all,exists,within,the,local,store,try,final,list,string,delete,if,exist,files,arrays,as,list,store,directory,list,all,for,final,blob,store,index,shard,snapshot,file,info,file,to,recover,files,to,recover,final,string,physical,name,file,to,recover,physical,name,if,delete,if,exist,files,contains,physical,name,logger,trace,deleting,pre,existing,file,shard,id,snapshot,id,physical,name,store,directory,delete,file,physical,name,logger,trace,restoring,file,shard,id,snapshot,id,file,to,recover,name,restore,file,file,to,recover,store,catch,ioexception,ex,throw,new,index,shard,restore,failed,exception,shard,id,failed,to,recover,index,ex,final,segment,infos,segment,commit,infos,try,segment,commit,infos,lucene,prune,unreferenced,files,restored,segments,file,name,store,directory,catch,ioexception,e,throw,new,index,shard,restore,failed,exception,shard,id,failed,to,fetch,index,version,after,copying,it,over,e,recovery,state,get,index,update,version,segment,commit,infos,get,version,try,for,string,store,file,store,directory,list,all,if,store,is,autogenerated,store,file,snapshot,files,contain,physical,index,file,store,file,continue,try,store,delete,quiet,restore,store,file,store,directory,delete,file,store,file,catch,ioexception,e,logger,warn,failed,to,delete,file,during,snapshot,cleanup,snapshot,id,store,file,catch,ioexception,e,logger,warn,failed,to,list,directory,some,of,files,might,not,be,deleted,snapshot,id,finally,store,dec,ref
BlobStoreRepository -> RestoreContext -> public void restore() throws IOException;1531729807;Performs restore operation;public void restore() throws IOException {_            final Store store = targetShard.store()__            store.incRef()__            try {_                logger.debug("[{}] [{}] restoring to [{}] ...", snapshotId, metadata.name(), shardId)__                BlobStoreIndexShardSnapshot snapshot = loadSnapshot()___                if (snapshot.indexFiles().size() == 1_                    && snapshot.indexFiles().get(0).physicalName().startsWith("segments_")_                    && snapshot.indexFiles().get(0).hasUnknownChecksum()) {_                    _                    _                    _                    _                    _                    _                    _                    _                    IndexWriter writer = new IndexWriter(store.directory(), new IndexWriterConfig(null)_                        .setOpenMode(IndexWriterConfig.OpenMode.CREATE)_                        .setCommitOnClose(true))__                    writer.close()__                    return__                }__                SnapshotFiles snapshotFiles = new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles())__                Store.MetadataSnapshot recoveryTargetMetadata__                try {_                    _                    _                    _                    recoveryTargetMetadata = targetShard.snapshotStoreMetadata()__                } catch (IndexNotFoundException e) {_                    _                    logger.trace("[{}] [{}] restoring from to an empty shard", shardId, snapshotId)__                    recoveryTargetMetadata = Store.MetadataSnapshot.EMPTY__                } catch (IOException e) {_                    logger.warn(() -> new ParameterizedMessage("{} Can't read metadata from store, will not reuse any local file while restoring", shardId), e)__                    recoveryTargetMetadata = Store.MetadataSnapshot.EMPTY__                }__                final List<BlobStoreIndexShardSnapshot.FileInfo> filesToRecover = new ArrayList<>()__                final Map<String, StoreFileMetaData> snapshotMetaData = new HashMap<>()__                final Map<String, BlobStoreIndexShardSnapshot.FileInfo> fileInfos = new HashMap<>()__                for (final BlobStoreIndexShardSnapshot.FileInfo fileInfo : snapshot.indexFiles()) {_                    try {_                        _                        _                        _                        _                        maybeRecalculateMetadataHash(blobContainer, fileInfo, recoveryTargetMetadata)__                    } catch (Exception e) {_                        _                        logger.warn(() -> new ParameterizedMessage("{} Can't calculate hash from blog for file [{}] [{}]", shardId, fileInfo.physicalName(), fileInfo.metadata()), e)__                    }_                    snapshotMetaData.put(fileInfo.metadata().name(), fileInfo.metadata())__                    fileInfos.put(fileInfo.metadata().name(), fileInfo)__                }__                final Store.MetadataSnapshot sourceMetaData = new Store.MetadataSnapshot(unmodifiableMap(snapshotMetaData), emptyMap(), 0)___                final StoreFileMetaData restoredSegmentsFile = sourceMetaData.getSegmentsFile()__                if (restoredSegmentsFile == null) {_                    throw new IndexShardRestoreFailedException(shardId, "Snapshot has no segments file")__                }__                final Store.RecoveryDiff diff = sourceMetaData.recoveryDiff(recoveryTargetMetadata)__                for (StoreFileMetaData md : diff.identical) {_                    BlobStoreIndexShardSnapshot.FileInfo fileInfo = fileInfos.get(md.name())__                    recoveryState.getIndex().addFileDetail(fileInfo.name(), fileInfo.length(), true)__                    if (logger.isTraceEnabled()) {_                        logger.trace("[{}] [{}] not_recovering [{}] from [{}], exists in local store and is same", shardId, snapshotId, fileInfo.physicalName(), fileInfo.name())__                    }_                }__                for (StoreFileMetaData md : Iterables.concat(diff.different, diff.missing)) {_                    BlobStoreIndexShardSnapshot.FileInfo fileInfo = fileInfos.get(md.name())__                    filesToRecover.add(fileInfo)__                    recoveryState.getIndex().addFileDetail(fileInfo.name(), fileInfo.length(), false)__                    if (logger.isTraceEnabled()) {_                        if (md == null) {_                            logger.trace("[{}] [{}] recovering [{}] from [{}], does not exists in local store", shardId, snapshotId, fileInfo.physicalName(), fileInfo.name())__                        } else {_                            logger.trace("[{}] [{}] recovering [{}] from [{}], exists in local store but is different", shardId, snapshotId, fileInfo.physicalName(), fileInfo.name())__                        }_                    }_                }__                if (filesToRecover.isEmpty()) {_                    logger.trace("no files to recover, all exists within the local store")__                }__                try {_                    _                    final List<String> deleteIfExistFiles = Arrays.asList(store.directory().listAll())___                    _                    for (final BlobStoreIndexShardSnapshot.FileInfo fileToRecover : filesToRecover) {_                        _                        _                        _                        _                        _                        _                        final String physicalName = fileToRecover.physicalName()__                        if (deleteIfExistFiles.contains(physicalName)) {_                            logger.trace("[{}] [{}] deleting pre-existing file [{}]", shardId, snapshotId, physicalName)__                            store.directory().deleteFile(physicalName)__                        }__                        logger.trace("[{}] [{}] restoring file [{}]", shardId, snapshotId, fileToRecover.name())__                        restoreFile(fileToRecover, store)__                    }_                } catch (IOException ex) {_                    throw new IndexShardRestoreFailedException(shardId, "Failed to recover index", ex)__                }__                _                final SegmentInfos segmentCommitInfos__                try {_                    segmentCommitInfos = Lucene.pruneUnreferencedFiles(restoredSegmentsFile.name(), store.directory())__                } catch (IOException e) {_                    throw new IndexShardRestoreFailedException(shardId, "Failed to fetch index version after copying it over", e)__                }_                recoveryState.getIndex().updateVersion(segmentCommitInfos.getVersion())___                _                try {_                    for (String storeFile : store.directory().listAll()) {_                        if (Store.isAutogenerated(storeFile) || snapshotFiles.containPhysicalIndexFile(storeFile)) {_                            continue_ _                        }_                        try {_                            store.deleteQuiet("restore", storeFile)__                            store.directory().deleteFile(storeFile)__                        } catch (IOException e) {_                            logger.warn("[{}] failed to delete file [{}] during snapshot cleanup", snapshotId, storeFile)__                        }_                    }_                } catch (IOException e) {_                    logger.warn("[{}] failed to list directory - some of files might not be deleted", snapshotId)__                }_            } finally {_                store.decRef()__            }_        };performs,restore,operation;public,void,restore,throws,ioexception,final,store,store,target,shard,store,store,inc,ref,try,logger,debug,restoring,to,snapshot,id,metadata,name,shard,id,blob,store,index,shard,snapshot,snapshot,load,snapshot,if,snapshot,index,files,size,1,snapshot,index,files,get,0,physical,name,starts,with,snapshot,index,files,get,0,has,unknown,checksum,index,writer,writer,new,index,writer,store,directory,new,index,writer,config,null,set,open,mode,index,writer,config,open,mode,create,set,commit,on,close,true,writer,close,return,snapshot,files,snapshot,files,new,snapshot,files,snapshot,snapshot,snapshot,index,files,store,metadata,snapshot,recovery,target,metadata,try,recovery,target,metadata,target,shard,snapshot,store,metadata,catch,index,not,found,exception,e,logger,trace,restoring,from,to,an,empty,shard,shard,id,snapshot,id,recovery,target,metadata,store,metadata,snapshot,empty,catch,ioexception,e,logger,warn,new,parameterized,message,can,t,read,metadata,from,store,will,not,reuse,any,local,file,while,restoring,shard,id,e,recovery,target,metadata,store,metadata,snapshot,empty,final,list,blob,store,index,shard,snapshot,file,info,files,to,recover,new,array,list,final,map,string,store,file,meta,data,snapshot,meta,data,new,hash,map,final,map,string,blob,store,index,shard,snapshot,file,info,file,infos,new,hash,map,for,final,blob,store,index,shard,snapshot,file,info,file,info,snapshot,index,files,try,maybe,recalculate,metadata,hash,blob,container,file,info,recovery,target,metadata,catch,exception,e,logger,warn,new,parameterized,message,can,t,calculate,hash,from,blog,for,file,shard,id,file,info,physical,name,file,info,metadata,e,snapshot,meta,data,put,file,info,metadata,name,file,info,metadata,file,infos,put,file,info,metadata,name,file,info,final,store,metadata,snapshot,source,meta,data,new,store,metadata,snapshot,unmodifiable,map,snapshot,meta,data,empty,map,0,final,store,file,meta,data,restored,segments,file,source,meta,data,get,segments,file,if,restored,segments,file,null,throw,new,index,shard,restore,failed,exception,shard,id,snapshot,has,no,segments,file,final,store,recovery,diff,diff,source,meta,data,recovery,diff,recovery,target,metadata,for,store,file,meta,data,md,diff,identical,blob,store,index,shard,snapshot,file,info,file,info,file,infos,get,md,name,recovery,state,get,index,add,file,detail,file,info,name,file,info,length,true,if,logger,is,trace,enabled,logger,trace,from,exists,in,local,store,and,is,same,shard,id,snapshot,id,file,info,physical,name,file,info,name,for,store,file,meta,data,md,iterables,concat,diff,different,diff,missing,blob,store,index,shard,snapshot,file,info,file,info,file,infos,get,md,name,files,to,recover,add,file,info,recovery,state,get,index,add,file,detail,file,info,name,file,info,length,false,if,logger,is,trace,enabled,if,md,null,logger,trace,recovering,from,does,not,exists,in,local,store,shard,id,snapshot,id,file,info,physical,name,file,info,name,else,logger,trace,recovering,from,exists,in,local,store,but,is,different,shard,id,snapshot,id,file,info,physical,name,file,info,name,if,files,to,recover,is,empty,logger,trace,no,files,to,recover,all,exists,within,the,local,store,try,final,list,string,delete,if,exist,files,arrays,as,list,store,directory,list,all,for,final,blob,store,index,shard,snapshot,file,info,file,to,recover,files,to,recover,final,string,physical,name,file,to,recover,physical,name,if,delete,if,exist,files,contains,physical,name,logger,trace,deleting,pre,existing,file,shard,id,snapshot,id,physical,name,store,directory,delete,file,physical,name,logger,trace,restoring,file,shard,id,snapshot,id,file,to,recover,name,restore,file,file,to,recover,store,catch,ioexception,ex,throw,new,index,shard,restore,failed,exception,shard,id,failed,to,recover,index,ex,final,segment,infos,segment,commit,infos,try,segment,commit,infos,lucene,prune,unreferenced,files,restored,segments,file,name,store,directory,catch,ioexception,e,throw,new,index,shard,restore,failed,exception,shard,id,failed,to,fetch,index,version,after,copying,it,over,e,recovery,state,get,index,update,version,segment,commit,infos,get,version,try,for,string,store,file,store,directory,list,all,if,store,is,autogenerated,store,file,snapshot,files,contain,physical,index,file,store,file,continue,try,store,delete,quiet,restore,store,file,store,directory,delete,file,store,file,catch,ioexception,e,logger,warn,failed,to,delete,file,during,snapshot,cleanup,snapshot,id,store,file,catch,ioexception,e,logger,warn,failed,to,list,directory,some,of,files,might,not,be,deleted,snapshot,id,finally,store,dec,ref
BlobStoreRepository -> RestoreContext -> public void restore() throws IOException;1532685069;Performs restore operation;public void restore() throws IOException {_            final Store store = targetShard.store()__            store.incRef()__            try {_                logger.debug("[{}] [{}] restoring to [{}] ...", snapshotId, metadata.name(), shardId)__                BlobStoreIndexShardSnapshot snapshot = loadSnapshot()___                if (snapshot.indexFiles().size() == 1_                    && snapshot.indexFiles().get(0).physicalName().startsWith("segments_")_                    && snapshot.indexFiles().get(0).hasUnknownChecksum()) {_                    _                    _                    _                    _                    _                    _                    _                    _                    IndexWriter writer = new IndexWriter(store.directory(), new IndexWriterConfig(null)_                        .setOpenMode(IndexWriterConfig.OpenMode.CREATE)_                        .setCommitOnClose(true))__                    writer.close()__                    return__                }__                SnapshotFiles snapshotFiles = new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles())__                Store.MetadataSnapshot recoveryTargetMetadata__                try {_                    _                    _                    _                    recoveryTargetMetadata = targetShard.snapshotStoreMetadata()__                } catch (IndexNotFoundException e) {_                    _                    logger.trace("[{}] [{}] restoring from to an empty shard", shardId, snapshotId)__                    recoveryTargetMetadata = Store.MetadataSnapshot.EMPTY__                } catch (IOException e) {_                    logger.warn(() -> new ParameterizedMessage("{} Can't read metadata from store, will not reuse any local file while restoring", shardId), e)__                    recoveryTargetMetadata = Store.MetadataSnapshot.EMPTY__                }__                final List<BlobStoreIndexShardSnapshot.FileInfo> filesToRecover = new ArrayList<>()__                final Map<String, StoreFileMetaData> snapshotMetaData = new HashMap<>()__                final Map<String, BlobStoreIndexShardSnapshot.FileInfo> fileInfos = new HashMap<>()__                for (final BlobStoreIndexShardSnapshot.FileInfo fileInfo : snapshot.indexFiles()) {_                    try {_                        _                        _                        _                        _                        maybeRecalculateMetadataHash(blobContainer, fileInfo, recoveryTargetMetadata)__                    } catch (Exception e) {_                        _                        logger.warn(() -> new ParameterizedMessage("{} Can't calculate hash from blog for file [{}] [{}]", shardId, fileInfo.physicalName(), fileInfo.metadata()), e)__                    }_                    snapshotMetaData.put(fileInfo.metadata().name(), fileInfo.metadata())__                    fileInfos.put(fileInfo.metadata().name(), fileInfo)__                }__                final Store.MetadataSnapshot sourceMetaData = new Store.MetadataSnapshot(unmodifiableMap(snapshotMetaData), emptyMap(), 0)___                final StoreFileMetaData restoredSegmentsFile = sourceMetaData.getSegmentsFile()__                if (restoredSegmentsFile == null) {_                    throw new IndexShardRestoreFailedException(shardId, "Snapshot has no segments file")__                }__                final Store.RecoveryDiff diff = sourceMetaData.recoveryDiff(recoveryTargetMetadata)__                for (StoreFileMetaData md : diff.identical) {_                    BlobStoreIndexShardSnapshot.FileInfo fileInfo = fileInfos.get(md.name())__                    recoveryState.getIndex().addFileDetail(fileInfo.name(), fileInfo.length(), true)__                    if (logger.isTraceEnabled()) {_                        logger.trace("[{}] [{}] not_recovering [{}] from [{}], exists in local store and is same", shardId, snapshotId, fileInfo.physicalName(), fileInfo.name())__                    }_                }__                for (StoreFileMetaData md : Iterables.concat(diff.different, diff.missing)) {_                    BlobStoreIndexShardSnapshot.FileInfo fileInfo = fileInfos.get(md.name())__                    filesToRecover.add(fileInfo)__                    recoveryState.getIndex().addFileDetail(fileInfo.name(), fileInfo.length(), false)__                    if (logger.isTraceEnabled()) {_                        logger.trace("[{}] [{}] recovering [{}] from [{}], exists in local store but is different", shardId, snapshotId,_                                fileInfo.physicalName(), fileInfo.name())__                    }_                }__                if (filesToRecover.isEmpty()) {_                    logger.trace("no files to recover, all exists within the local store")__                }__                try {_                    _                    final List<String> deleteIfExistFiles = Arrays.asList(store.directory().listAll())___                    _                    for (final BlobStoreIndexShardSnapshot.FileInfo fileToRecover : filesToRecover) {_                        _                        _                        _                        _                        _                        _                        final String physicalName = fileToRecover.physicalName()__                        if (deleteIfExistFiles.contains(physicalName)) {_                            logger.trace("[{}] [{}] deleting pre-existing file [{}]", shardId, snapshotId, physicalName)__                            store.directory().deleteFile(physicalName)__                        }__                        logger.trace("[{}] [{}] restoring file [{}]", shardId, snapshotId, fileToRecover.name())__                        restoreFile(fileToRecover, store)__                    }_                } catch (IOException ex) {_                    throw new IndexShardRestoreFailedException(shardId, "Failed to recover index", ex)__                }__                _                final SegmentInfos segmentCommitInfos__                try {_                    segmentCommitInfos = Lucene.pruneUnreferencedFiles(restoredSegmentsFile.name(), store.directory())__                } catch (IOException e) {_                    throw new IndexShardRestoreFailedException(shardId, "Failed to fetch index version after copying it over", e)__                }_                recoveryState.getIndex().updateVersion(segmentCommitInfos.getVersion())___                _                try {_                    for (String storeFile : store.directory().listAll()) {_                        if (Store.isAutogenerated(storeFile) || snapshotFiles.containPhysicalIndexFile(storeFile)) {_                            continue_ _                        }_                        try {_                            store.deleteQuiet("restore", storeFile)__                            store.directory().deleteFile(storeFile)__                        } catch (IOException e) {_                            logger.warn("[{}] failed to delete file [{}] during snapshot cleanup", snapshotId, storeFile)__                        }_                    }_                } catch (IOException e) {_                    logger.warn("[{}] failed to list directory - some of files might not be deleted", snapshotId)__                }_            } finally {_                store.decRef()__            }_        };performs,restore,operation;public,void,restore,throws,ioexception,final,store,store,target,shard,store,store,inc,ref,try,logger,debug,restoring,to,snapshot,id,metadata,name,shard,id,blob,store,index,shard,snapshot,snapshot,load,snapshot,if,snapshot,index,files,size,1,snapshot,index,files,get,0,physical,name,starts,with,snapshot,index,files,get,0,has,unknown,checksum,index,writer,writer,new,index,writer,store,directory,new,index,writer,config,null,set,open,mode,index,writer,config,open,mode,create,set,commit,on,close,true,writer,close,return,snapshot,files,snapshot,files,new,snapshot,files,snapshot,snapshot,snapshot,index,files,store,metadata,snapshot,recovery,target,metadata,try,recovery,target,metadata,target,shard,snapshot,store,metadata,catch,index,not,found,exception,e,logger,trace,restoring,from,to,an,empty,shard,shard,id,snapshot,id,recovery,target,metadata,store,metadata,snapshot,empty,catch,ioexception,e,logger,warn,new,parameterized,message,can,t,read,metadata,from,store,will,not,reuse,any,local,file,while,restoring,shard,id,e,recovery,target,metadata,store,metadata,snapshot,empty,final,list,blob,store,index,shard,snapshot,file,info,files,to,recover,new,array,list,final,map,string,store,file,meta,data,snapshot,meta,data,new,hash,map,final,map,string,blob,store,index,shard,snapshot,file,info,file,infos,new,hash,map,for,final,blob,store,index,shard,snapshot,file,info,file,info,snapshot,index,files,try,maybe,recalculate,metadata,hash,blob,container,file,info,recovery,target,metadata,catch,exception,e,logger,warn,new,parameterized,message,can,t,calculate,hash,from,blog,for,file,shard,id,file,info,physical,name,file,info,metadata,e,snapshot,meta,data,put,file,info,metadata,name,file,info,metadata,file,infos,put,file,info,metadata,name,file,info,final,store,metadata,snapshot,source,meta,data,new,store,metadata,snapshot,unmodifiable,map,snapshot,meta,data,empty,map,0,final,store,file,meta,data,restored,segments,file,source,meta,data,get,segments,file,if,restored,segments,file,null,throw,new,index,shard,restore,failed,exception,shard,id,snapshot,has,no,segments,file,final,store,recovery,diff,diff,source,meta,data,recovery,diff,recovery,target,metadata,for,store,file,meta,data,md,diff,identical,blob,store,index,shard,snapshot,file,info,file,info,file,infos,get,md,name,recovery,state,get,index,add,file,detail,file,info,name,file,info,length,true,if,logger,is,trace,enabled,logger,trace,from,exists,in,local,store,and,is,same,shard,id,snapshot,id,file,info,physical,name,file,info,name,for,store,file,meta,data,md,iterables,concat,diff,different,diff,missing,blob,store,index,shard,snapshot,file,info,file,info,file,infos,get,md,name,files,to,recover,add,file,info,recovery,state,get,index,add,file,detail,file,info,name,file,info,length,false,if,logger,is,trace,enabled,logger,trace,recovering,from,exists,in,local,store,but,is,different,shard,id,snapshot,id,file,info,physical,name,file,info,name,if,files,to,recover,is,empty,logger,trace,no,files,to,recover,all,exists,within,the,local,store,try,final,list,string,delete,if,exist,files,arrays,as,list,store,directory,list,all,for,final,blob,store,index,shard,snapshot,file,info,file,to,recover,files,to,recover,final,string,physical,name,file,to,recover,physical,name,if,delete,if,exist,files,contains,physical,name,logger,trace,deleting,pre,existing,file,shard,id,snapshot,id,physical,name,store,directory,delete,file,physical,name,logger,trace,restoring,file,shard,id,snapshot,id,file,to,recover,name,restore,file,file,to,recover,store,catch,ioexception,ex,throw,new,index,shard,restore,failed,exception,shard,id,failed,to,recover,index,ex,final,segment,infos,segment,commit,infos,try,segment,commit,infos,lucene,prune,unreferenced,files,restored,segments,file,name,store,directory,catch,ioexception,e,throw,new,index,shard,restore,failed,exception,shard,id,failed,to,fetch,index,version,after,copying,it,over,e,recovery,state,get,index,update,version,segment,commit,infos,get,version,try,for,string,store,file,store,directory,list,all,if,store,is,autogenerated,store,file,snapshot,files,contain,physical,index,file,store,file,continue,try,store,delete,quiet,restore,store,file,store,directory,delete,file,store,file,catch,ioexception,e,logger,warn,failed,to,delete,file,during,snapshot,cleanup,snapshot,id,store,file,catch,ioexception,e,logger,warn,failed,to,list,directory,some,of,files,might,not,be,deleted,snapshot,id,finally,store,dec,ref
BlobStoreRepository -> RestoreContext -> public void restore() throws IOException;1535139672;Performs restore operation;public void restore() throws IOException {_            final Store store = targetShard.store()__            store.incRef()__            try {_                logger.debug("[{}] [{}] restoring to [{}] ...", snapshotId, metadata.name(), shardId)__                BlobStoreIndexShardSnapshot snapshot = loadSnapshot()___                if (snapshot.indexFiles().size() == 1_                    && snapshot.indexFiles().get(0).physicalName().startsWith("segments_")_                    && snapshot.indexFiles().get(0).hasUnknownChecksum()) {_                    _                    _                    _                    _                    _                    _                    _                    _                    IndexWriter writer = new IndexWriter(store.directory(), new IndexWriterConfig(null)_                        .setOpenMode(IndexWriterConfig.OpenMode.CREATE)_                        .setCommitOnClose(true))__                    writer.close()__                    return__                }__                SnapshotFiles snapshotFiles = new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles())__                Store.MetadataSnapshot recoveryTargetMetadata__                try {_                    _                    _                    _                    recoveryTargetMetadata = targetShard.snapshotStoreMetadata()__                } catch (IndexNotFoundException e) {_                    _                    logger.trace("[{}] [{}] restoring from to an empty shard", shardId, snapshotId)__                    recoveryTargetMetadata = Store.MetadataSnapshot.EMPTY__                } catch (IOException e) {_                    logger.warn(() -> new ParameterizedMessage("{} Can't read metadata from store, will not reuse any local file while restoring", shardId), e)__                    recoveryTargetMetadata = Store.MetadataSnapshot.EMPTY__                }__                final List<BlobStoreIndexShardSnapshot.FileInfo> filesToRecover = new ArrayList<>()__                final Map<String, StoreFileMetaData> snapshotMetaData = new HashMap<>()__                final Map<String, BlobStoreIndexShardSnapshot.FileInfo> fileInfos = new HashMap<>()__                for (final BlobStoreIndexShardSnapshot.FileInfo fileInfo : snapshot.indexFiles()) {_                    try {_                        _                        _                        _                        _                        maybeRecalculateMetadataHash(blobContainer, fileInfo, recoveryTargetMetadata)__                    } catch (Exception e) {_                        _                        logger.warn(() -> new ParameterizedMessage("{} Can't calculate hash from blog for file [{}] [{}]", shardId, fileInfo.physicalName(), fileInfo.metadata()), e)__                    }_                    snapshotMetaData.put(fileInfo.metadata().name(), fileInfo.metadata())__                    fileInfos.put(fileInfo.metadata().name(), fileInfo)__                }__                final Store.MetadataSnapshot sourceMetaData = new Store.MetadataSnapshot(unmodifiableMap(snapshotMetaData), emptyMap(), 0)___                final StoreFileMetaData restoredSegmentsFile = sourceMetaData.getSegmentsFile()__                if (restoredSegmentsFile == null) {_                    throw new IndexShardRestoreFailedException(shardId, "Snapshot has no segments file")__                }__                final Store.RecoveryDiff diff = sourceMetaData.recoveryDiff(recoveryTargetMetadata)__                for (StoreFileMetaData md : diff.identical) {_                    BlobStoreIndexShardSnapshot.FileInfo fileInfo = fileInfos.get(md.name())__                    recoveryState.getIndex().addFileDetail(fileInfo.name(), fileInfo.length(), true)__                    if (logger.isTraceEnabled()) {_                        logger.trace("[{}] [{}] not_recovering [{}] from [{}], exists in local store and is same", shardId, snapshotId, fileInfo.physicalName(), fileInfo.name())__                    }_                }__                for (StoreFileMetaData md : Iterables.concat(diff.different, diff.missing)) {_                    BlobStoreIndexShardSnapshot.FileInfo fileInfo = fileInfos.get(md.name())__                    filesToRecover.add(fileInfo)__                    recoveryState.getIndex().addFileDetail(fileInfo.name(), fileInfo.length(), false)__                    if (logger.isTraceEnabled()) {_                        logger.trace("[{}] [{}] recovering [{}] from [{}], exists in local store but is different", shardId, snapshotId,_                                fileInfo.physicalName(), fileInfo.name())__                    }_                }__                if (filesToRecover.isEmpty()) {_                    logger.trace("no files to recover, all exists within the local store")__                }__                try {_                    _                    final List<String> deleteIfExistFiles = Arrays.asList(store.directory().listAll())___                    _                    for (final BlobStoreIndexShardSnapshot.FileInfo fileToRecover : filesToRecover) {_                        _                        _                        _                        _                        _                        _                        final String physicalName = fileToRecover.physicalName()__                        if (deleteIfExistFiles.contains(physicalName)) {_                            logger.trace("[{}] [{}] deleting pre-existing file [{}]", shardId, snapshotId, physicalName)__                            store.directory().deleteFile(physicalName)__                        }__                        logger.trace("[{}] [{}] restoring file [{}]", shardId, snapshotId, fileToRecover.name())__                        restoreFile(fileToRecover, store)__                    }_                } catch (IOException ex) {_                    throw new IndexShardRestoreFailedException(shardId, "Failed to recover index", ex)__                }__                _                final SegmentInfos segmentCommitInfos__                try {_                    segmentCommitInfos = Lucene.pruneUnreferencedFiles(restoredSegmentsFile.name(), store.directory())__                } catch (IOException e) {_                    throw new IndexShardRestoreFailedException(shardId, "Failed to fetch index version after copying it over", e)__                }_                recoveryState.getIndex().updateVersion(segmentCommitInfos.getVersion())___                _                try {_                    for (String storeFile : store.directory().listAll()) {_                        if (Store.isAutogenerated(storeFile) || snapshotFiles.containPhysicalIndexFile(storeFile)) {_                            continue_ _                        }_                        try {_                            store.deleteQuiet("restore", storeFile)__                            store.directory().deleteFile(storeFile)__                        } catch (IOException e) {_                            logger.warn("[{}] failed to delete file [{}] during snapshot cleanup", snapshotId, storeFile)__                        }_                    }_                } catch (IOException e) {_                    logger.warn("[{}] failed to list directory - some of files might not be deleted", snapshotId)__                }_            } finally {_                store.decRef()__            }_        };performs,restore,operation;public,void,restore,throws,ioexception,final,store,store,target,shard,store,store,inc,ref,try,logger,debug,restoring,to,snapshot,id,metadata,name,shard,id,blob,store,index,shard,snapshot,snapshot,load,snapshot,if,snapshot,index,files,size,1,snapshot,index,files,get,0,physical,name,starts,with,snapshot,index,files,get,0,has,unknown,checksum,index,writer,writer,new,index,writer,store,directory,new,index,writer,config,null,set,open,mode,index,writer,config,open,mode,create,set,commit,on,close,true,writer,close,return,snapshot,files,snapshot,files,new,snapshot,files,snapshot,snapshot,snapshot,index,files,store,metadata,snapshot,recovery,target,metadata,try,recovery,target,metadata,target,shard,snapshot,store,metadata,catch,index,not,found,exception,e,logger,trace,restoring,from,to,an,empty,shard,shard,id,snapshot,id,recovery,target,metadata,store,metadata,snapshot,empty,catch,ioexception,e,logger,warn,new,parameterized,message,can,t,read,metadata,from,store,will,not,reuse,any,local,file,while,restoring,shard,id,e,recovery,target,metadata,store,metadata,snapshot,empty,final,list,blob,store,index,shard,snapshot,file,info,files,to,recover,new,array,list,final,map,string,store,file,meta,data,snapshot,meta,data,new,hash,map,final,map,string,blob,store,index,shard,snapshot,file,info,file,infos,new,hash,map,for,final,blob,store,index,shard,snapshot,file,info,file,info,snapshot,index,files,try,maybe,recalculate,metadata,hash,blob,container,file,info,recovery,target,metadata,catch,exception,e,logger,warn,new,parameterized,message,can,t,calculate,hash,from,blog,for,file,shard,id,file,info,physical,name,file,info,metadata,e,snapshot,meta,data,put,file,info,metadata,name,file,info,metadata,file,infos,put,file,info,metadata,name,file,info,final,store,metadata,snapshot,source,meta,data,new,store,metadata,snapshot,unmodifiable,map,snapshot,meta,data,empty,map,0,final,store,file,meta,data,restored,segments,file,source,meta,data,get,segments,file,if,restored,segments,file,null,throw,new,index,shard,restore,failed,exception,shard,id,snapshot,has,no,segments,file,final,store,recovery,diff,diff,source,meta,data,recovery,diff,recovery,target,metadata,for,store,file,meta,data,md,diff,identical,blob,store,index,shard,snapshot,file,info,file,info,file,infos,get,md,name,recovery,state,get,index,add,file,detail,file,info,name,file,info,length,true,if,logger,is,trace,enabled,logger,trace,from,exists,in,local,store,and,is,same,shard,id,snapshot,id,file,info,physical,name,file,info,name,for,store,file,meta,data,md,iterables,concat,diff,different,diff,missing,blob,store,index,shard,snapshot,file,info,file,info,file,infos,get,md,name,files,to,recover,add,file,info,recovery,state,get,index,add,file,detail,file,info,name,file,info,length,false,if,logger,is,trace,enabled,logger,trace,recovering,from,exists,in,local,store,but,is,different,shard,id,snapshot,id,file,info,physical,name,file,info,name,if,files,to,recover,is,empty,logger,trace,no,files,to,recover,all,exists,within,the,local,store,try,final,list,string,delete,if,exist,files,arrays,as,list,store,directory,list,all,for,final,blob,store,index,shard,snapshot,file,info,file,to,recover,files,to,recover,final,string,physical,name,file,to,recover,physical,name,if,delete,if,exist,files,contains,physical,name,logger,trace,deleting,pre,existing,file,shard,id,snapshot,id,physical,name,store,directory,delete,file,physical,name,logger,trace,restoring,file,shard,id,snapshot,id,file,to,recover,name,restore,file,file,to,recover,store,catch,ioexception,ex,throw,new,index,shard,restore,failed,exception,shard,id,failed,to,recover,index,ex,final,segment,infos,segment,commit,infos,try,segment,commit,infos,lucene,prune,unreferenced,files,restored,segments,file,name,store,directory,catch,ioexception,e,throw,new,index,shard,restore,failed,exception,shard,id,failed,to,fetch,index,version,after,copying,it,over,e,recovery,state,get,index,update,version,segment,commit,infos,get,version,try,for,string,store,file,store,directory,list,all,if,store,is,autogenerated,store,file,snapshot,files,contain,physical,index,file,store,file,continue,try,store,delete,quiet,restore,store,file,store,directory,delete,file,store,file,catch,ioexception,e,logger,warn,failed,to,delete,file,during,snapshot,cleanup,snapshot,id,store,file,catch,ioexception,e,logger,warn,failed,to,list,directory,some,of,files,might,not,be,deleted,snapshot,id,finally,store,dec,ref
BlobStoreRepository -> RestoreContext -> public void restore() throws IOException;1535723122;Performs restore operation;public void restore() throws IOException {_            final Store store = targetShard.store()__            store.incRef()__            try {_                logger.debug("[{}] [{}] restoring to [{}] ...", snapshotId, metadata.name(), shardId)__                BlobStoreIndexShardSnapshot snapshot = loadSnapshot()___                if (snapshot.indexFiles().size() == 1_                    && snapshot.indexFiles().get(0).physicalName().startsWith("segments_")_                    && snapshot.indexFiles().get(0).hasUnknownChecksum()) {_                    _                    _                    _                    _                    _                    _                    _                    _                    IndexWriter writer = new IndexWriter(store.directory(), new IndexWriterConfig(null)_                        .setSoftDeletesField(Lucene.SOFT_DELETES_FIELD)_                        .setOpenMode(IndexWriterConfig.OpenMode.CREATE)_                        .setCommitOnClose(true))__                    writer.close()__                    return__                }__                SnapshotFiles snapshotFiles = new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles())__                Store.MetadataSnapshot recoveryTargetMetadata__                try {_                    _                    _                    _                    recoveryTargetMetadata = targetShard.snapshotStoreMetadata()__                } catch (IndexNotFoundException e) {_                    _                    logger.trace("[{}] [{}] restoring from to an empty shard", shardId, snapshotId)__                    recoveryTargetMetadata = Store.MetadataSnapshot.EMPTY__                } catch (IOException e) {_                    logger.warn(() -> new ParameterizedMessage("{} Can't read metadata from store, will not reuse any local file while restoring", shardId), e)__                    recoveryTargetMetadata = Store.MetadataSnapshot.EMPTY__                }__                final List<BlobStoreIndexShardSnapshot.FileInfo> filesToRecover = new ArrayList<>()__                final Map<String, StoreFileMetaData> snapshotMetaData = new HashMap<>()__                final Map<String, BlobStoreIndexShardSnapshot.FileInfo> fileInfos = new HashMap<>()__                for (final BlobStoreIndexShardSnapshot.FileInfo fileInfo : snapshot.indexFiles()) {_                    try {_                        _                        _                        _                        _                        maybeRecalculateMetadataHash(blobContainer, fileInfo, recoveryTargetMetadata)__                    } catch (Exception e) {_                        _                        logger.warn(() -> new ParameterizedMessage("{} Can't calculate hash from blog for file [{}] [{}]", shardId, fileInfo.physicalName(), fileInfo.metadata()), e)__                    }_                    snapshotMetaData.put(fileInfo.metadata().name(), fileInfo.metadata())__                    fileInfos.put(fileInfo.metadata().name(), fileInfo)__                }__                final Store.MetadataSnapshot sourceMetaData = new Store.MetadataSnapshot(unmodifiableMap(snapshotMetaData), emptyMap(), 0)___                final StoreFileMetaData restoredSegmentsFile = sourceMetaData.getSegmentsFile()__                if (restoredSegmentsFile == null) {_                    throw new IndexShardRestoreFailedException(shardId, "Snapshot has no segments file")__                }__                final Store.RecoveryDiff diff = sourceMetaData.recoveryDiff(recoveryTargetMetadata)__                for (StoreFileMetaData md : diff.identical) {_                    BlobStoreIndexShardSnapshot.FileInfo fileInfo = fileInfos.get(md.name())__                    recoveryState.getIndex().addFileDetail(fileInfo.name(), fileInfo.length(), true)__                    if (logger.isTraceEnabled()) {_                        logger.trace("[{}] [{}] not_recovering [{}] from [{}], exists in local store and is same", shardId, snapshotId, fileInfo.physicalName(), fileInfo.name())__                    }_                }__                for (StoreFileMetaData md : Iterables.concat(diff.different, diff.missing)) {_                    BlobStoreIndexShardSnapshot.FileInfo fileInfo = fileInfos.get(md.name())__                    filesToRecover.add(fileInfo)__                    recoveryState.getIndex().addFileDetail(fileInfo.name(), fileInfo.length(), false)__                    if (logger.isTraceEnabled()) {_                        logger.trace("[{}] [{}] recovering [{}] from [{}], exists in local store but is different", shardId, snapshotId,_                                fileInfo.physicalName(), fileInfo.name())__                    }_                }__                if (filesToRecover.isEmpty()) {_                    logger.trace("no files to recover, all exists within the local store")__                }__                try {_                    _                    final List<String> deleteIfExistFiles = Arrays.asList(store.directory().listAll())___                    _                    for (final BlobStoreIndexShardSnapshot.FileInfo fileToRecover : filesToRecover) {_                        _                        _                        _                        _                        _                        _                        final String physicalName = fileToRecover.physicalName()__                        if (deleteIfExistFiles.contains(physicalName)) {_                            logger.trace("[{}] [{}] deleting pre-existing file [{}]", shardId, snapshotId, physicalName)__                            store.directory().deleteFile(physicalName)__                        }__                        logger.trace("[{}] [{}] restoring file [{}]", shardId, snapshotId, fileToRecover.name())__                        restoreFile(fileToRecover, store)__                    }_                } catch (IOException ex) {_                    throw new IndexShardRestoreFailedException(shardId, "Failed to recover index", ex)__                }__                _                final SegmentInfos segmentCommitInfos__                try {_                    segmentCommitInfos = Lucene.pruneUnreferencedFiles(restoredSegmentsFile.name(), store.directory())__                } catch (IOException e) {_                    throw new IndexShardRestoreFailedException(shardId, "Failed to fetch index version after copying it over", e)__                }_                recoveryState.getIndex().updateVersion(segmentCommitInfos.getVersion())___                _                try {_                    for (String storeFile : store.directory().listAll()) {_                        if (Store.isAutogenerated(storeFile) || snapshotFiles.containPhysicalIndexFile(storeFile)) {_                            continue_ _                        }_                        try {_                            store.deleteQuiet("restore", storeFile)__                            store.directory().deleteFile(storeFile)__                        } catch (IOException e) {_                            logger.warn("[{}] failed to delete file [{}] during snapshot cleanup", snapshotId, storeFile)__                        }_                    }_                } catch (IOException e) {_                    logger.warn("[{}] failed to list directory - some of files might not be deleted", snapshotId)__                }_            } finally {_                store.decRef()__            }_        };performs,restore,operation;public,void,restore,throws,ioexception,final,store,store,target,shard,store,store,inc,ref,try,logger,debug,restoring,to,snapshot,id,metadata,name,shard,id,blob,store,index,shard,snapshot,snapshot,load,snapshot,if,snapshot,index,files,size,1,snapshot,index,files,get,0,physical,name,starts,with,snapshot,index,files,get,0,has,unknown,checksum,index,writer,writer,new,index,writer,store,directory,new,index,writer,config,null,set,soft,deletes,field,lucene,set,open,mode,index,writer,config,open,mode,create,set,commit,on,close,true,writer,close,return,snapshot,files,snapshot,files,new,snapshot,files,snapshot,snapshot,snapshot,index,files,store,metadata,snapshot,recovery,target,metadata,try,recovery,target,metadata,target,shard,snapshot,store,metadata,catch,index,not,found,exception,e,logger,trace,restoring,from,to,an,empty,shard,shard,id,snapshot,id,recovery,target,metadata,store,metadata,snapshot,empty,catch,ioexception,e,logger,warn,new,parameterized,message,can,t,read,metadata,from,store,will,not,reuse,any,local,file,while,restoring,shard,id,e,recovery,target,metadata,store,metadata,snapshot,empty,final,list,blob,store,index,shard,snapshot,file,info,files,to,recover,new,array,list,final,map,string,store,file,meta,data,snapshot,meta,data,new,hash,map,final,map,string,blob,store,index,shard,snapshot,file,info,file,infos,new,hash,map,for,final,blob,store,index,shard,snapshot,file,info,file,info,snapshot,index,files,try,maybe,recalculate,metadata,hash,blob,container,file,info,recovery,target,metadata,catch,exception,e,logger,warn,new,parameterized,message,can,t,calculate,hash,from,blog,for,file,shard,id,file,info,physical,name,file,info,metadata,e,snapshot,meta,data,put,file,info,metadata,name,file,info,metadata,file,infos,put,file,info,metadata,name,file,info,final,store,metadata,snapshot,source,meta,data,new,store,metadata,snapshot,unmodifiable,map,snapshot,meta,data,empty,map,0,final,store,file,meta,data,restored,segments,file,source,meta,data,get,segments,file,if,restored,segments,file,null,throw,new,index,shard,restore,failed,exception,shard,id,snapshot,has,no,segments,file,final,store,recovery,diff,diff,source,meta,data,recovery,diff,recovery,target,metadata,for,store,file,meta,data,md,diff,identical,blob,store,index,shard,snapshot,file,info,file,info,file,infos,get,md,name,recovery,state,get,index,add,file,detail,file,info,name,file,info,length,true,if,logger,is,trace,enabled,logger,trace,from,exists,in,local,store,and,is,same,shard,id,snapshot,id,file,info,physical,name,file,info,name,for,store,file,meta,data,md,iterables,concat,diff,different,diff,missing,blob,store,index,shard,snapshot,file,info,file,info,file,infos,get,md,name,files,to,recover,add,file,info,recovery,state,get,index,add,file,detail,file,info,name,file,info,length,false,if,logger,is,trace,enabled,logger,trace,recovering,from,exists,in,local,store,but,is,different,shard,id,snapshot,id,file,info,physical,name,file,info,name,if,files,to,recover,is,empty,logger,trace,no,files,to,recover,all,exists,within,the,local,store,try,final,list,string,delete,if,exist,files,arrays,as,list,store,directory,list,all,for,final,blob,store,index,shard,snapshot,file,info,file,to,recover,files,to,recover,final,string,physical,name,file,to,recover,physical,name,if,delete,if,exist,files,contains,physical,name,logger,trace,deleting,pre,existing,file,shard,id,snapshot,id,physical,name,store,directory,delete,file,physical,name,logger,trace,restoring,file,shard,id,snapshot,id,file,to,recover,name,restore,file,file,to,recover,store,catch,ioexception,ex,throw,new,index,shard,restore,failed,exception,shard,id,failed,to,recover,index,ex,final,segment,infos,segment,commit,infos,try,segment,commit,infos,lucene,prune,unreferenced,files,restored,segments,file,name,store,directory,catch,ioexception,e,throw,new,index,shard,restore,failed,exception,shard,id,failed,to,fetch,index,version,after,copying,it,over,e,recovery,state,get,index,update,version,segment,commit,infos,get,version,try,for,string,store,file,store,directory,list,all,if,store,is,autogenerated,store,file,snapshot,files,contain,physical,index,file,store,file,continue,try,store,delete,quiet,restore,store,file,store,directory,delete,file,store,file,catch,ioexception,e,logger,warn,failed,to,delete,file,during,snapshot,cleanup,snapshot,id,store,file,catch,ioexception,e,logger,warn,failed,to,list,directory,some,of,files,might,not,be,deleted,snapshot,id,finally,store,dec,ref
BlobStoreRepository -> RestoreContext -> public void restore() throws IOException;1536314350;Performs restore operation;public void restore() throws IOException {_            final Store store = targetShard.store()__            store.incRef()__            try {_                logger.debug("[{}] [{}] restoring to [{}] ...", snapshotId, metadata.name(), shardId)__                BlobStoreIndexShardSnapshot snapshot = loadSnapshot()___                if (snapshot.indexFiles().size() == 1_                    && snapshot.indexFiles().get(0).physicalName().startsWith("segments_")_                    && snapshot.indexFiles().get(0).hasUnknownChecksum()) {_                    _                    _                    _                    _                    _                    _                    _                    _                    IndexWriter writer = new IndexWriter(store.directory(), new IndexWriterConfig(null)_                        .setSoftDeletesField(Lucene.SOFT_DELETES_FIELD)_                        .setOpenMode(IndexWriterConfig.OpenMode.CREATE)_                        .setCommitOnClose(true))__                    writer.close()__                    return__                }__                SnapshotFiles snapshotFiles = new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles())__                Store.MetadataSnapshot recoveryTargetMetadata__                try {_                    _                    _                    _                    recoveryTargetMetadata = targetShard.snapshotStoreMetadata()__                } catch (IndexNotFoundException e) {_                    _                    logger.trace("[{}] [{}] restoring from to an empty shard", shardId, snapshotId)__                    recoveryTargetMetadata = Store.MetadataSnapshot.EMPTY__                } catch (IOException e) {_                    logger.warn(() -> new ParameterizedMessage("{} Can't read metadata from store, will not reuse any local file while restoring", shardId), e)__                    recoveryTargetMetadata = Store.MetadataSnapshot.EMPTY__                }__                final List<BlobStoreIndexShardSnapshot.FileInfo> filesToRecover = new ArrayList<>()__                final Map<String, StoreFileMetaData> snapshotMetaData = new HashMap<>()__                final Map<String, BlobStoreIndexShardSnapshot.FileInfo> fileInfos = new HashMap<>()__                for (final BlobStoreIndexShardSnapshot.FileInfo fileInfo : snapshot.indexFiles()) {_                    try {_                        _                        _                        _                        _                        maybeRecalculateMetadataHash(blobContainer, fileInfo, recoveryTargetMetadata)__                    } catch (Exception e) {_                        _                        logger.warn(() -> new ParameterizedMessage("{} Can't calculate hash from blog for file [{}] [{}]", shardId, fileInfo.physicalName(), fileInfo.metadata()), e)__                    }_                    snapshotMetaData.put(fileInfo.metadata().name(), fileInfo.metadata())__                    fileInfos.put(fileInfo.metadata().name(), fileInfo)__                }__                final Store.MetadataSnapshot sourceMetaData = new Store.MetadataSnapshot(unmodifiableMap(snapshotMetaData), emptyMap(), 0)___                final StoreFileMetaData restoredSegmentsFile = sourceMetaData.getSegmentsFile()__                if (restoredSegmentsFile == null) {_                    throw new IndexShardRestoreFailedException(shardId, "Snapshot has no segments file")__                }__                final Store.RecoveryDiff diff = sourceMetaData.recoveryDiff(recoveryTargetMetadata)__                for (StoreFileMetaData md : diff.identical) {_                    BlobStoreIndexShardSnapshot.FileInfo fileInfo = fileInfos.get(md.name())__                    recoveryState.getIndex().addFileDetail(fileInfo.name(), fileInfo.length(), true)__                    if (logger.isTraceEnabled()) {_                        logger.trace("[{}] [{}] not_recovering [{}] from [{}], exists in local store and is same", shardId, snapshotId, fileInfo.physicalName(), fileInfo.name())__                    }_                }__                for (StoreFileMetaData md : Iterables.concat(diff.different, diff.missing)) {_                    BlobStoreIndexShardSnapshot.FileInfo fileInfo = fileInfos.get(md.name())__                    filesToRecover.add(fileInfo)__                    recoveryState.getIndex().addFileDetail(fileInfo.name(), fileInfo.length(), false)__                    if (logger.isTraceEnabled()) {_                        logger.trace("[{}] [{}] recovering [{}] from [{}], exists in local store but is different", shardId, snapshotId,_                                fileInfo.physicalName(), fileInfo.name())__                    }_                }__                if (filesToRecover.isEmpty()) {_                    logger.trace("no files to recover, all exists within the local store")__                }__                try {_                    _                    final List<String> deleteIfExistFiles = Arrays.asList(store.directory().listAll())___                    _                    for (final BlobStoreIndexShardSnapshot.FileInfo fileToRecover : filesToRecover) {_                        _                        _                        _                        _                        _                        _                        final String physicalName = fileToRecover.physicalName()__                        if (deleteIfExistFiles.contains(physicalName)) {_                            logger.trace("[{}] [{}] deleting pre-existing file [{}]", shardId, snapshotId, physicalName)__                            store.directory().deleteFile(physicalName)__                        }__                        logger.trace("[{}] [{}] restoring file [{}]", shardId, snapshotId, fileToRecover.name())__                        restoreFile(fileToRecover, store)__                    }_                } catch (IOException ex) {_                    throw new IndexShardRestoreFailedException(shardId, "Failed to recover index", ex)__                }__                _                final SegmentInfos segmentCommitInfos__                try {_                    segmentCommitInfos = Lucene.pruneUnreferencedFiles(restoredSegmentsFile.name(), store.directory())__                } catch (IOException e) {_                    throw new IndexShardRestoreFailedException(shardId, "Failed to fetch index version after copying it over", e)__                }_                recoveryState.getIndex().updateVersion(segmentCommitInfos.getVersion())___                _                try {_                    for (String storeFile : store.directory().listAll()) {_                        if (Store.isAutogenerated(storeFile) || snapshotFiles.containPhysicalIndexFile(storeFile)) {_                            continue_ _                        }_                        try {_                            store.deleteQuiet("restore", storeFile)__                            store.directory().deleteFile(storeFile)__                        } catch (IOException e) {_                            logger.warn("[{}] failed to delete file [{}] during snapshot cleanup", snapshotId, storeFile)__                        }_                    }_                } catch (IOException e) {_                    logger.warn("[{}] failed to list directory - some of files might not be deleted", snapshotId)__                }_            } finally {_                store.decRef()__            }_        };performs,restore,operation;public,void,restore,throws,ioexception,final,store,store,target,shard,store,store,inc,ref,try,logger,debug,restoring,to,snapshot,id,metadata,name,shard,id,blob,store,index,shard,snapshot,snapshot,load,snapshot,if,snapshot,index,files,size,1,snapshot,index,files,get,0,physical,name,starts,with,snapshot,index,files,get,0,has,unknown,checksum,index,writer,writer,new,index,writer,store,directory,new,index,writer,config,null,set,soft,deletes,field,lucene,set,open,mode,index,writer,config,open,mode,create,set,commit,on,close,true,writer,close,return,snapshot,files,snapshot,files,new,snapshot,files,snapshot,snapshot,snapshot,index,files,store,metadata,snapshot,recovery,target,metadata,try,recovery,target,metadata,target,shard,snapshot,store,metadata,catch,index,not,found,exception,e,logger,trace,restoring,from,to,an,empty,shard,shard,id,snapshot,id,recovery,target,metadata,store,metadata,snapshot,empty,catch,ioexception,e,logger,warn,new,parameterized,message,can,t,read,metadata,from,store,will,not,reuse,any,local,file,while,restoring,shard,id,e,recovery,target,metadata,store,metadata,snapshot,empty,final,list,blob,store,index,shard,snapshot,file,info,files,to,recover,new,array,list,final,map,string,store,file,meta,data,snapshot,meta,data,new,hash,map,final,map,string,blob,store,index,shard,snapshot,file,info,file,infos,new,hash,map,for,final,blob,store,index,shard,snapshot,file,info,file,info,snapshot,index,files,try,maybe,recalculate,metadata,hash,blob,container,file,info,recovery,target,metadata,catch,exception,e,logger,warn,new,parameterized,message,can,t,calculate,hash,from,blog,for,file,shard,id,file,info,physical,name,file,info,metadata,e,snapshot,meta,data,put,file,info,metadata,name,file,info,metadata,file,infos,put,file,info,metadata,name,file,info,final,store,metadata,snapshot,source,meta,data,new,store,metadata,snapshot,unmodifiable,map,snapshot,meta,data,empty,map,0,final,store,file,meta,data,restored,segments,file,source,meta,data,get,segments,file,if,restored,segments,file,null,throw,new,index,shard,restore,failed,exception,shard,id,snapshot,has,no,segments,file,final,store,recovery,diff,diff,source,meta,data,recovery,diff,recovery,target,metadata,for,store,file,meta,data,md,diff,identical,blob,store,index,shard,snapshot,file,info,file,info,file,infos,get,md,name,recovery,state,get,index,add,file,detail,file,info,name,file,info,length,true,if,logger,is,trace,enabled,logger,trace,from,exists,in,local,store,and,is,same,shard,id,snapshot,id,file,info,physical,name,file,info,name,for,store,file,meta,data,md,iterables,concat,diff,different,diff,missing,blob,store,index,shard,snapshot,file,info,file,info,file,infos,get,md,name,files,to,recover,add,file,info,recovery,state,get,index,add,file,detail,file,info,name,file,info,length,false,if,logger,is,trace,enabled,logger,trace,recovering,from,exists,in,local,store,but,is,different,shard,id,snapshot,id,file,info,physical,name,file,info,name,if,files,to,recover,is,empty,logger,trace,no,files,to,recover,all,exists,within,the,local,store,try,final,list,string,delete,if,exist,files,arrays,as,list,store,directory,list,all,for,final,blob,store,index,shard,snapshot,file,info,file,to,recover,files,to,recover,final,string,physical,name,file,to,recover,physical,name,if,delete,if,exist,files,contains,physical,name,logger,trace,deleting,pre,existing,file,shard,id,snapshot,id,physical,name,store,directory,delete,file,physical,name,logger,trace,restoring,file,shard,id,snapshot,id,file,to,recover,name,restore,file,file,to,recover,store,catch,ioexception,ex,throw,new,index,shard,restore,failed,exception,shard,id,failed,to,recover,index,ex,final,segment,infos,segment,commit,infos,try,segment,commit,infos,lucene,prune,unreferenced,files,restored,segments,file,name,store,directory,catch,ioexception,e,throw,new,index,shard,restore,failed,exception,shard,id,failed,to,fetch,index,version,after,copying,it,over,e,recovery,state,get,index,update,version,segment,commit,infos,get,version,try,for,string,store,file,store,directory,list,all,if,store,is,autogenerated,store,file,snapshot,files,contain,physical,index,file,store,file,continue,try,store,delete,quiet,restore,store,file,store,directory,delete,file,store,file,catch,ioexception,e,logger,warn,failed,to,delete,file,during,snapshot,cleanup,snapshot,id,store,file,catch,ioexception,e,logger,warn,failed,to,list,directory,some,of,files,might,not,be,deleted,snapshot,id,finally,store,dec,ref
BlobStoreRepository -> RestoreContext -> public void restore() throws IOException;1536828374;Performs restore operation;public void restore() throws IOException {_            final Store store = targetShard.store()__            store.incRef()__            try {_                logger.debug("[{}] [{}] restoring to [{}] ...", snapshotId, metadata.name(), shardId)__                BlobStoreIndexShardSnapshot snapshot = loadSnapshot()___                if (snapshot.indexFiles().size() == 1_                    && snapshot.indexFiles().get(0).physicalName().startsWith("segments_")_                    && snapshot.indexFiles().get(0).hasUnknownChecksum()) {_                    _                    _                    _                    _                    _                    _                    _                    _                    IndexWriter writer = new IndexWriter(store.directory(), new IndexWriterConfig(null)_                        .setSoftDeletesField(Lucene.SOFT_DELETES_FIELD)_                        .setOpenMode(IndexWriterConfig.OpenMode.CREATE)_                        .setCommitOnClose(true))__                    writer.close()__                    return__                }__                SnapshotFiles snapshotFiles = new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles())__                Store.MetadataSnapshot recoveryTargetMetadata__                try {_                    _                    _                    _                    recoveryTargetMetadata = targetShard.snapshotStoreMetadata()__                } catch (IndexNotFoundException e) {_                    _                    logger.trace("[{}] [{}] restoring from to an empty shard", shardId, snapshotId)__                    recoveryTargetMetadata = Store.MetadataSnapshot.EMPTY__                } catch (IOException e) {_                    logger.warn(() -> new ParameterizedMessage("{} Can't read metadata from store, will not reuse any local file while restoring", shardId), e)__                    recoveryTargetMetadata = Store.MetadataSnapshot.EMPTY__                }__                final List<BlobStoreIndexShardSnapshot.FileInfo> filesToRecover = new ArrayList<>()__                final Map<String, StoreFileMetaData> snapshotMetaData = new HashMap<>()__                final Map<String, BlobStoreIndexShardSnapshot.FileInfo> fileInfos = new HashMap<>()__                for (final BlobStoreIndexShardSnapshot.FileInfo fileInfo : snapshot.indexFiles()) {_                    try {_                        _                        _                        _                        _                        maybeRecalculateMetadataHash(blobContainer, fileInfo, recoveryTargetMetadata)__                    } catch (Exception e) {_                        _                        logger.warn(() -> new ParameterizedMessage("{} Can't calculate hash from blog for file [{}] [{}]", shardId, fileInfo.physicalName(), fileInfo.metadata()), e)__                    }_                    snapshotMetaData.put(fileInfo.metadata().name(), fileInfo.metadata())__                    fileInfos.put(fileInfo.metadata().name(), fileInfo)__                }__                final Store.MetadataSnapshot sourceMetaData = new Store.MetadataSnapshot(unmodifiableMap(snapshotMetaData), emptyMap(), 0)___                final StoreFileMetaData restoredSegmentsFile = sourceMetaData.getSegmentsFile()__                if (restoredSegmentsFile == null) {_                    throw new IndexShardRestoreFailedException(shardId, "Snapshot has no segments file")__                }__                final Store.RecoveryDiff diff = sourceMetaData.recoveryDiff(recoveryTargetMetadata)__                for (StoreFileMetaData md : diff.identical) {_                    BlobStoreIndexShardSnapshot.FileInfo fileInfo = fileInfos.get(md.name())__                    recoveryState.getIndex().addFileDetail(fileInfo.name(), fileInfo.length(), true)__                    if (logger.isTraceEnabled()) {_                        logger.trace("[{}] [{}] not_recovering [{}] from [{}], exists in local store and is same", shardId, snapshotId, fileInfo.physicalName(), fileInfo.name())__                    }_                }__                for (StoreFileMetaData md : Iterables.concat(diff.different, diff.missing)) {_                    BlobStoreIndexShardSnapshot.FileInfo fileInfo = fileInfos.get(md.name())__                    filesToRecover.add(fileInfo)__                    recoveryState.getIndex().addFileDetail(fileInfo.name(), fileInfo.length(), false)__                    if (logger.isTraceEnabled()) {_                        logger.trace("[{}] [{}] recovering [{}] from [{}], exists in local store but is different", shardId, snapshotId,_                                fileInfo.physicalName(), fileInfo.name())__                    }_                }__                if (filesToRecover.isEmpty()) {_                    logger.trace("no files to recover, all exists within the local store")__                }__                try {_                    _                    final List<String> deleteIfExistFiles = Arrays.asList(store.directory().listAll())___                    _                    for (final BlobStoreIndexShardSnapshot.FileInfo fileToRecover : filesToRecover) {_                        _                        _                        _                        _                        _                        _                        final String physicalName = fileToRecover.physicalName()__                        if (deleteIfExistFiles.contains(physicalName)) {_                            logger.trace("[{}] [{}] deleting pre-existing file [{}]", shardId, snapshotId, physicalName)__                            store.directory().deleteFile(physicalName)__                        }__                        logger.trace("[{}] [{}] restoring file [{}]", shardId, snapshotId, fileToRecover.name())__                        restoreFile(fileToRecover, store)__                    }_                } catch (IOException ex) {_                    throw new IndexShardRestoreFailedException(shardId, "Failed to recover index", ex)__                }__                _                final SegmentInfos segmentCommitInfos__                try {_                    segmentCommitInfos = Lucene.pruneUnreferencedFiles(restoredSegmentsFile.name(), store.directory())__                } catch (IOException e) {_                    throw new IndexShardRestoreFailedException(shardId, "Failed to fetch index version after copying it over", e)__                }_                recoveryState.getIndex().updateVersion(segmentCommitInfos.getVersion())___                _                try {_                    for (String storeFile : store.directory().listAll()) {_                        if (Store.isAutogenerated(storeFile) || snapshotFiles.containPhysicalIndexFile(storeFile)) {_                            continue_ _                        }_                        try {_                            store.deleteQuiet("restore", storeFile)__                            store.directory().deleteFile(storeFile)__                        } catch (IOException e) {_                            logger.warn("[{}] failed to delete file [{}] during snapshot cleanup", snapshotId, storeFile)__                        }_                    }_                } catch (IOException e) {_                    logger.warn("[{}] failed to list directory - some of files might not be deleted", snapshotId)__                }_            } finally {_                store.decRef()__            }_        };performs,restore,operation;public,void,restore,throws,ioexception,final,store,store,target,shard,store,store,inc,ref,try,logger,debug,restoring,to,snapshot,id,metadata,name,shard,id,blob,store,index,shard,snapshot,snapshot,load,snapshot,if,snapshot,index,files,size,1,snapshot,index,files,get,0,physical,name,starts,with,snapshot,index,files,get,0,has,unknown,checksum,index,writer,writer,new,index,writer,store,directory,new,index,writer,config,null,set,soft,deletes,field,lucene,set,open,mode,index,writer,config,open,mode,create,set,commit,on,close,true,writer,close,return,snapshot,files,snapshot,files,new,snapshot,files,snapshot,snapshot,snapshot,index,files,store,metadata,snapshot,recovery,target,metadata,try,recovery,target,metadata,target,shard,snapshot,store,metadata,catch,index,not,found,exception,e,logger,trace,restoring,from,to,an,empty,shard,shard,id,snapshot,id,recovery,target,metadata,store,metadata,snapshot,empty,catch,ioexception,e,logger,warn,new,parameterized,message,can,t,read,metadata,from,store,will,not,reuse,any,local,file,while,restoring,shard,id,e,recovery,target,metadata,store,metadata,snapshot,empty,final,list,blob,store,index,shard,snapshot,file,info,files,to,recover,new,array,list,final,map,string,store,file,meta,data,snapshot,meta,data,new,hash,map,final,map,string,blob,store,index,shard,snapshot,file,info,file,infos,new,hash,map,for,final,blob,store,index,shard,snapshot,file,info,file,info,snapshot,index,files,try,maybe,recalculate,metadata,hash,blob,container,file,info,recovery,target,metadata,catch,exception,e,logger,warn,new,parameterized,message,can,t,calculate,hash,from,blog,for,file,shard,id,file,info,physical,name,file,info,metadata,e,snapshot,meta,data,put,file,info,metadata,name,file,info,metadata,file,infos,put,file,info,metadata,name,file,info,final,store,metadata,snapshot,source,meta,data,new,store,metadata,snapshot,unmodifiable,map,snapshot,meta,data,empty,map,0,final,store,file,meta,data,restored,segments,file,source,meta,data,get,segments,file,if,restored,segments,file,null,throw,new,index,shard,restore,failed,exception,shard,id,snapshot,has,no,segments,file,final,store,recovery,diff,diff,source,meta,data,recovery,diff,recovery,target,metadata,for,store,file,meta,data,md,diff,identical,blob,store,index,shard,snapshot,file,info,file,info,file,infos,get,md,name,recovery,state,get,index,add,file,detail,file,info,name,file,info,length,true,if,logger,is,trace,enabled,logger,trace,from,exists,in,local,store,and,is,same,shard,id,snapshot,id,file,info,physical,name,file,info,name,for,store,file,meta,data,md,iterables,concat,diff,different,diff,missing,blob,store,index,shard,snapshot,file,info,file,info,file,infos,get,md,name,files,to,recover,add,file,info,recovery,state,get,index,add,file,detail,file,info,name,file,info,length,false,if,logger,is,trace,enabled,logger,trace,recovering,from,exists,in,local,store,but,is,different,shard,id,snapshot,id,file,info,physical,name,file,info,name,if,files,to,recover,is,empty,logger,trace,no,files,to,recover,all,exists,within,the,local,store,try,final,list,string,delete,if,exist,files,arrays,as,list,store,directory,list,all,for,final,blob,store,index,shard,snapshot,file,info,file,to,recover,files,to,recover,final,string,physical,name,file,to,recover,physical,name,if,delete,if,exist,files,contains,physical,name,logger,trace,deleting,pre,existing,file,shard,id,snapshot,id,physical,name,store,directory,delete,file,physical,name,logger,trace,restoring,file,shard,id,snapshot,id,file,to,recover,name,restore,file,file,to,recover,store,catch,ioexception,ex,throw,new,index,shard,restore,failed,exception,shard,id,failed,to,recover,index,ex,final,segment,infos,segment,commit,infos,try,segment,commit,infos,lucene,prune,unreferenced,files,restored,segments,file,name,store,directory,catch,ioexception,e,throw,new,index,shard,restore,failed,exception,shard,id,failed,to,fetch,index,version,after,copying,it,over,e,recovery,state,get,index,update,version,segment,commit,infos,get,version,try,for,string,store,file,store,directory,list,all,if,store,is,autogenerated,store,file,snapshot,files,contain,physical,index,file,store,file,continue,try,store,delete,quiet,restore,store,file,store,directory,delete,file,store,file,catch,ioexception,e,logger,warn,failed,to,delete,file,during,snapshot,cleanup,snapshot,id,store,file,catch,ioexception,e,logger,warn,failed,to,list,directory,some,of,files,might,not,be,deleted,snapshot,id,finally,store,dec,ref
BlobStoreRepository -> RestoreContext -> public void restore() throws IOException;1541008027;Performs restore operation;public void restore() throws IOException {_            final Store store = targetShard.store()__            store.incRef()__            try {_                logger.debug("[{}] [{}] restoring to [{}] ...", snapshotId, metadata.name(), shardId)__                BlobStoreIndexShardSnapshot snapshot = loadSnapshot()___                if (snapshot.indexFiles().size() == 1_                    && snapshot.indexFiles().get(0).physicalName().startsWith("segments_")_                    && snapshot.indexFiles().get(0).hasUnknownChecksum()) {_                    _                    _                    _                    _                    _                    _                    _                    _                    IndexWriter writer = new IndexWriter(store.directory(), new IndexWriterConfig(null)_                        .setSoftDeletesField(Lucene.SOFT_DELETES_FIELD)_                        .setOpenMode(IndexWriterConfig.OpenMode.CREATE)_                        .setCommitOnClose(true))__                    writer.close()__                    return__                }__                SnapshotFiles snapshotFiles = new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles())__                Store.MetadataSnapshot recoveryTargetMetadata__                try {_                    _                    _                    _                    recoveryTargetMetadata = targetShard.snapshotStoreMetadata()__                } catch (IndexNotFoundException e) {_                    _                    logger.trace("[{}] [{}] restoring from to an empty shard", shardId, snapshotId)__                    recoveryTargetMetadata = Store.MetadataSnapshot.EMPTY__                } catch (IOException e) {_                    logger.warn(() -> new ParameterizedMessage("{} Can't read metadata from store, will not reuse any local file while restoring", shardId), e)__                    recoveryTargetMetadata = Store.MetadataSnapshot.EMPTY__                }__                final List<BlobStoreIndexShardSnapshot.FileInfo> filesToRecover = new ArrayList<>()__                final Map<String, StoreFileMetaData> snapshotMetaData = new HashMap<>()__                final Map<String, BlobStoreIndexShardSnapshot.FileInfo> fileInfos = new HashMap<>()__                for (final BlobStoreIndexShardSnapshot.FileInfo fileInfo : snapshot.indexFiles()) {_                    try {_                        _                        _                        _                        _                        maybeRecalculateMetadataHash(blobContainer, fileInfo, recoveryTargetMetadata)__                    } catch (Exception e) {_                        _                        logger.warn(() -> new ParameterizedMessage("{} Can't calculate hash from blog for file [{}] [{}]", shardId, fileInfo.physicalName(), fileInfo.metadata()), e)__                    }_                    snapshotMetaData.put(fileInfo.metadata().name(), fileInfo.metadata())__                    fileInfos.put(fileInfo.metadata().name(), fileInfo)__                }__                final Store.MetadataSnapshot sourceMetaData = new Store.MetadataSnapshot(unmodifiableMap(snapshotMetaData), emptyMap(), 0)___                final StoreFileMetaData restoredSegmentsFile = sourceMetaData.getSegmentsFile()__                if (restoredSegmentsFile == null) {_                    throw new IndexShardRestoreFailedException(shardId, "Snapshot has no segments file")__                }__                final Store.RecoveryDiff diff = sourceMetaData.recoveryDiff(recoveryTargetMetadata)__                for (StoreFileMetaData md : diff.identical) {_                    BlobStoreIndexShardSnapshot.FileInfo fileInfo = fileInfos.get(md.name())__                    recoveryState.getIndex().addFileDetail(fileInfo.name(), fileInfo.length(), true)__                    if (logger.isTraceEnabled()) {_                        logger.trace("[{}] [{}] not_recovering [{}] from [{}], exists in local store and is same", shardId, snapshotId, fileInfo.physicalName(), fileInfo.name())__                    }_                }__                for (StoreFileMetaData md : Iterables.concat(diff.different, diff.missing)) {_                    BlobStoreIndexShardSnapshot.FileInfo fileInfo = fileInfos.get(md.name())__                    filesToRecover.add(fileInfo)__                    recoveryState.getIndex().addFileDetail(fileInfo.name(), fileInfo.length(), false)__                    if (logger.isTraceEnabled()) {_                        logger.trace("[{}] [{}] recovering [{}] from [{}], exists in local store but is different", shardId, snapshotId,_                                fileInfo.physicalName(), fileInfo.name())__                    }_                }__                if (filesToRecover.isEmpty()) {_                    logger.trace("no files to recover, all exists within the local store")__                }__                try {_                    _                    final List<String> deleteIfExistFiles = Arrays.asList(store.directory().listAll())___                    _                    for (final BlobStoreIndexShardSnapshot.FileInfo fileToRecover : filesToRecover) {_                        _                        _                        _                        _                        _                        _                        final String physicalName = fileToRecover.physicalName()__                        if (deleteIfExistFiles.contains(physicalName)) {_                            logger.trace("[{}] [{}] deleting pre-existing file [{}]", shardId, snapshotId, physicalName)__                            store.directory().deleteFile(physicalName)__                        }__                        logger.trace("[{}] [{}] restoring file [{}]", shardId, snapshotId, fileToRecover.name())__                        restoreFile(fileToRecover, store)__                    }_                } catch (IOException ex) {_                    throw new IndexShardRestoreFailedException(shardId, "Failed to recover index", ex)__                }__                _                final SegmentInfos segmentCommitInfos__                try {_                    segmentCommitInfos = Lucene.pruneUnreferencedFiles(restoredSegmentsFile.name(), store.directory())__                } catch (IOException e) {_                    throw new IndexShardRestoreFailedException(shardId, "Failed to fetch index version after copying it over", e)__                }_                recoveryState.getIndex().updateVersion(segmentCommitInfos.getVersion())___                _                try {_                    for (String storeFile : store.directory().listAll()) {_                        if (Store.isAutogenerated(storeFile) || snapshotFiles.containPhysicalIndexFile(storeFile)) {_                            continue_ _                        }_                        try {_                            store.deleteQuiet("restore", storeFile)__                            store.directory().deleteFile(storeFile)__                        } catch (IOException e) {_                            logger.warn("[{}] failed to delete file [{}] during snapshot cleanup", snapshotId, storeFile)__                        }_                    }_                } catch (IOException e) {_                    logger.warn("[{}] failed to list directory - some of files might not be deleted", snapshotId)__                }_            } finally {_                store.decRef()__            }_        };performs,restore,operation;public,void,restore,throws,ioexception,final,store,store,target,shard,store,store,inc,ref,try,logger,debug,restoring,to,snapshot,id,metadata,name,shard,id,blob,store,index,shard,snapshot,snapshot,load,snapshot,if,snapshot,index,files,size,1,snapshot,index,files,get,0,physical,name,starts,with,snapshot,index,files,get,0,has,unknown,checksum,index,writer,writer,new,index,writer,store,directory,new,index,writer,config,null,set,soft,deletes,field,lucene,set,open,mode,index,writer,config,open,mode,create,set,commit,on,close,true,writer,close,return,snapshot,files,snapshot,files,new,snapshot,files,snapshot,snapshot,snapshot,index,files,store,metadata,snapshot,recovery,target,metadata,try,recovery,target,metadata,target,shard,snapshot,store,metadata,catch,index,not,found,exception,e,logger,trace,restoring,from,to,an,empty,shard,shard,id,snapshot,id,recovery,target,metadata,store,metadata,snapshot,empty,catch,ioexception,e,logger,warn,new,parameterized,message,can,t,read,metadata,from,store,will,not,reuse,any,local,file,while,restoring,shard,id,e,recovery,target,metadata,store,metadata,snapshot,empty,final,list,blob,store,index,shard,snapshot,file,info,files,to,recover,new,array,list,final,map,string,store,file,meta,data,snapshot,meta,data,new,hash,map,final,map,string,blob,store,index,shard,snapshot,file,info,file,infos,new,hash,map,for,final,blob,store,index,shard,snapshot,file,info,file,info,snapshot,index,files,try,maybe,recalculate,metadata,hash,blob,container,file,info,recovery,target,metadata,catch,exception,e,logger,warn,new,parameterized,message,can,t,calculate,hash,from,blog,for,file,shard,id,file,info,physical,name,file,info,metadata,e,snapshot,meta,data,put,file,info,metadata,name,file,info,metadata,file,infos,put,file,info,metadata,name,file,info,final,store,metadata,snapshot,source,meta,data,new,store,metadata,snapshot,unmodifiable,map,snapshot,meta,data,empty,map,0,final,store,file,meta,data,restored,segments,file,source,meta,data,get,segments,file,if,restored,segments,file,null,throw,new,index,shard,restore,failed,exception,shard,id,snapshot,has,no,segments,file,final,store,recovery,diff,diff,source,meta,data,recovery,diff,recovery,target,metadata,for,store,file,meta,data,md,diff,identical,blob,store,index,shard,snapshot,file,info,file,info,file,infos,get,md,name,recovery,state,get,index,add,file,detail,file,info,name,file,info,length,true,if,logger,is,trace,enabled,logger,trace,from,exists,in,local,store,and,is,same,shard,id,snapshot,id,file,info,physical,name,file,info,name,for,store,file,meta,data,md,iterables,concat,diff,different,diff,missing,blob,store,index,shard,snapshot,file,info,file,info,file,infos,get,md,name,files,to,recover,add,file,info,recovery,state,get,index,add,file,detail,file,info,name,file,info,length,false,if,logger,is,trace,enabled,logger,trace,recovering,from,exists,in,local,store,but,is,different,shard,id,snapshot,id,file,info,physical,name,file,info,name,if,files,to,recover,is,empty,logger,trace,no,files,to,recover,all,exists,within,the,local,store,try,final,list,string,delete,if,exist,files,arrays,as,list,store,directory,list,all,for,final,blob,store,index,shard,snapshot,file,info,file,to,recover,files,to,recover,final,string,physical,name,file,to,recover,physical,name,if,delete,if,exist,files,contains,physical,name,logger,trace,deleting,pre,existing,file,shard,id,snapshot,id,physical,name,store,directory,delete,file,physical,name,logger,trace,restoring,file,shard,id,snapshot,id,file,to,recover,name,restore,file,file,to,recover,store,catch,ioexception,ex,throw,new,index,shard,restore,failed,exception,shard,id,failed,to,recover,index,ex,final,segment,infos,segment,commit,infos,try,segment,commit,infos,lucene,prune,unreferenced,files,restored,segments,file,name,store,directory,catch,ioexception,e,throw,new,index,shard,restore,failed,exception,shard,id,failed,to,fetch,index,version,after,copying,it,over,e,recovery,state,get,index,update,version,segment,commit,infos,get,version,try,for,string,store,file,store,directory,list,all,if,store,is,autogenerated,store,file,snapshot,files,contain,physical,index,file,store,file,continue,try,store,delete,quiet,restore,store,file,store,directory,delete,file,store,file,catch,ioexception,e,logger,warn,failed,to,delete,file,during,snapshot,cleanup,snapshot,id,store,file,catch,ioexception,e,logger,warn,failed,to,list,directory,some,of,files,might,not,be,deleted,snapshot,id,finally,store,dec,ref
BlobStoreRepository -> RestoreContext -> public void restore() throws IOException;1542646292;Performs restore operation;public void restore() throws IOException {_            final Store store = targetShard.store()__            store.incRef()__            try {_                logger.debug("[{}] [{}] restoring to [{}] ...", snapshotId, metadata.name(), shardId)__                BlobStoreIndexShardSnapshot snapshot = loadSnapshot()___                if (snapshot.indexFiles().size() == 1_                    && snapshot.indexFiles().get(0).physicalName().startsWith("segments_")_                    && snapshot.indexFiles().get(0).hasUnknownChecksum()) {_                    _                    _                    _                    _                    _                    _                    _                    _                    IndexWriter writer = new IndexWriter(store.directory(), new IndexWriterConfig(null)_                        .setSoftDeletesField(Lucene.SOFT_DELETES_FIELD)_                        .setOpenMode(IndexWriterConfig.OpenMode.CREATE)_                        .setCommitOnClose(true))__                    writer.close()__                    return__                }__                SnapshotFiles snapshotFiles = new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles())__                Store.MetadataSnapshot recoveryTargetMetadata__                try {_                    _                    _                    _                    recoveryTargetMetadata = targetShard.snapshotStoreMetadata()__                } catch (IndexNotFoundException e) {_                    _                    logger.trace("[{}] [{}] restoring from to an empty shard", shardId, snapshotId)__                    recoveryTargetMetadata = Store.MetadataSnapshot.EMPTY__                } catch (IOException e) {_                    logger.warn(() -> new ParameterizedMessage("{} Can't read metadata from store, will not reuse any local file while restoring", shardId), e)__                    recoveryTargetMetadata = Store.MetadataSnapshot.EMPTY__                }__                final List<BlobStoreIndexShardSnapshot.FileInfo> filesToRecover = new ArrayList<>()__                final Map<String, StoreFileMetaData> snapshotMetaData = new HashMap<>()__                final Map<String, BlobStoreIndexShardSnapshot.FileInfo> fileInfos = new HashMap<>()__                for (final BlobStoreIndexShardSnapshot.FileInfo fileInfo : snapshot.indexFiles()) {_                    try {_                        _                        _                        _                        _                        maybeRecalculateMetadataHash(blobContainer, fileInfo, recoveryTargetMetadata)__                    } catch (Exception e) {_                        _                        logger.warn(() -> new ParameterizedMessage("{} Can't calculate hash from blog for file [{}] [{}]", shardId, fileInfo.physicalName(), fileInfo.metadata()), e)__                    }_                    snapshotMetaData.put(fileInfo.metadata().name(), fileInfo.metadata())__                    fileInfos.put(fileInfo.metadata().name(), fileInfo)__                }__                final Store.MetadataSnapshot sourceMetaData = new Store.MetadataSnapshot(unmodifiableMap(snapshotMetaData), emptyMap(), 0)___                final StoreFileMetaData restoredSegmentsFile = sourceMetaData.getSegmentsFile()__                if (restoredSegmentsFile == null) {_                    throw new IndexShardRestoreFailedException(shardId, "Snapshot has no segments file")__                }__                final Store.RecoveryDiff diff = sourceMetaData.recoveryDiff(recoveryTargetMetadata)__                for (StoreFileMetaData md : diff.identical) {_                    BlobStoreIndexShardSnapshot.FileInfo fileInfo = fileInfos.get(md.name())__                    recoveryState.getIndex().addFileDetail(fileInfo.name(), fileInfo.length(), true)__                    if (logger.isTraceEnabled()) {_                        logger.trace("[{}] [{}] not_recovering [{}] from [{}], exists in local store and is same", shardId, snapshotId, fileInfo.physicalName(), fileInfo.name())__                    }_                }__                for (StoreFileMetaData md : Iterables.concat(diff.different, diff.missing)) {_                    BlobStoreIndexShardSnapshot.FileInfo fileInfo = fileInfos.get(md.name())__                    filesToRecover.add(fileInfo)__                    recoveryState.getIndex().addFileDetail(fileInfo.name(), fileInfo.length(), false)__                    if (logger.isTraceEnabled()) {_                        logger.trace("[{}] [{}] recovering [{}] from [{}], exists in local store but is different", shardId, snapshotId,_                                fileInfo.physicalName(), fileInfo.name())__                    }_                }__                if (filesToRecover.isEmpty()) {_                    logger.trace("no files to recover, all exists within the local store")__                }__                try {_                    _                    final List<String> deleteIfExistFiles = Arrays.asList(store.directory().listAll())___                    _                    for (final BlobStoreIndexShardSnapshot.FileInfo fileToRecover : filesToRecover) {_                        _                        _                        _                        _                        _                        _                        final String physicalName = fileToRecover.physicalName()__                        if (deleteIfExistFiles.contains(physicalName)) {_                            logger.trace("[{}] [{}] deleting pre-existing file [{}]", shardId, snapshotId, physicalName)__                            store.directory().deleteFile(physicalName)__                        }__                        logger.trace("[{}] [{}] restoring file [{}]", shardId, snapshotId, fileToRecover.name())__                        restoreFile(fileToRecover, store)__                    }_                } catch (IOException ex) {_                    throw new IndexShardRestoreFailedException(shardId, "Failed to recover index", ex)__                }__                _                final SegmentInfos segmentCommitInfos__                try {_                    segmentCommitInfos = Lucene.pruneUnreferencedFiles(restoredSegmentsFile.name(), store.directory())__                } catch (IOException e) {_                    throw new IndexShardRestoreFailedException(shardId, "Failed to fetch index version after copying it over", e)__                }_                recoveryState.getIndex().updateVersion(segmentCommitInfos.getVersion())___                _                try {_                    for (String storeFile : store.directory().listAll()) {_                        if (Store.isAutogenerated(storeFile) || snapshotFiles.containPhysicalIndexFile(storeFile)) {_                            continue_ _                        }_                        try {_                            store.deleteQuiet("restore", storeFile)__                            store.directory().deleteFile(storeFile)__                        } catch (IOException e) {_                            logger.warn("[{}] failed to delete file [{}] during snapshot cleanup", snapshotId, storeFile)__                        }_                    }_                } catch (IOException e) {_                    logger.warn("[{}] failed to list directory - some of files might not be deleted", snapshotId)__                }_            } finally {_                store.decRef()__            }_        };performs,restore,operation;public,void,restore,throws,ioexception,final,store,store,target,shard,store,store,inc,ref,try,logger,debug,restoring,to,snapshot,id,metadata,name,shard,id,blob,store,index,shard,snapshot,snapshot,load,snapshot,if,snapshot,index,files,size,1,snapshot,index,files,get,0,physical,name,starts,with,snapshot,index,files,get,0,has,unknown,checksum,index,writer,writer,new,index,writer,store,directory,new,index,writer,config,null,set,soft,deletes,field,lucene,set,open,mode,index,writer,config,open,mode,create,set,commit,on,close,true,writer,close,return,snapshot,files,snapshot,files,new,snapshot,files,snapshot,snapshot,snapshot,index,files,store,metadata,snapshot,recovery,target,metadata,try,recovery,target,metadata,target,shard,snapshot,store,metadata,catch,index,not,found,exception,e,logger,trace,restoring,from,to,an,empty,shard,shard,id,snapshot,id,recovery,target,metadata,store,metadata,snapshot,empty,catch,ioexception,e,logger,warn,new,parameterized,message,can,t,read,metadata,from,store,will,not,reuse,any,local,file,while,restoring,shard,id,e,recovery,target,metadata,store,metadata,snapshot,empty,final,list,blob,store,index,shard,snapshot,file,info,files,to,recover,new,array,list,final,map,string,store,file,meta,data,snapshot,meta,data,new,hash,map,final,map,string,blob,store,index,shard,snapshot,file,info,file,infos,new,hash,map,for,final,blob,store,index,shard,snapshot,file,info,file,info,snapshot,index,files,try,maybe,recalculate,metadata,hash,blob,container,file,info,recovery,target,metadata,catch,exception,e,logger,warn,new,parameterized,message,can,t,calculate,hash,from,blog,for,file,shard,id,file,info,physical,name,file,info,metadata,e,snapshot,meta,data,put,file,info,metadata,name,file,info,metadata,file,infos,put,file,info,metadata,name,file,info,final,store,metadata,snapshot,source,meta,data,new,store,metadata,snapshot,unmodifiable,map,snapshot,meta,data,empty,map,0,final,store,file,meta,data,restored,segments,file,source,meta,data,get,segments,file,if,restored,segments,file,null,throw,new,index,shard,restore,failed,exception,shard,id,snapshot,has,no,segments,file,final,store,recovery,diff,diff,source,meta,data,recovery,diff,recovery,target,metadata,for,store,file,meta,data,md,diff,identical,blob,store,index,shard,snapshot,file,info,file,info,file,infos,get,md,name,recovery,state,get,index,add,file,detail,file,info,name,file,info,length,true,if,logger,is,trace,enabled,logger,trace,from,exists,in,local,store,and,is,same,shard,id,snapshot,id,file,info,physical,name,file,info,name,for,store,file,meta,data,md,iterables,concat,diff,different,diff,missing,blob,store,index,shard,snapshot,file,info,file,info,file,infos,get,md,name,files,to,recover,add,file,info,recovery,state,get,index,add,file,detail,file,info,name,file,info,length,false,if,logger,is,trace,enabled,logger,trace,recovering,from,exists,in,local,store,but,is,different,shard,id,snapshot,id,file,info,physical,name,file,info,name,if,files,to,recover,is,empty,logger,trace,no,files,to,recover,all,exists,within,the,local,store,try,final,list,string,delete,if,exist,files,arrays,as,list,store,directory,list,all,for,final,blob,store,index,shard,snapshot,file,info,file,to,recover,files,to,recover,final,string,physical,name,file,to,recover,physical,name,if,delete,if,exist,files,contains,physical,name,logger,trace,deleting,pre,existing,file,shard,id,snapshot,id,physical,name,store,directory,delete,file,physical,name,logger,trace,restoring,file,shard,id,snapshot,id,file,to,recover,name,restore,file,file,to,recover,store,catch,ioexception,ex,throw,new,index,shard,restore,failed,exception,shard,id,failed,to,recover,index,ex,final,segment,infos,segment,commit,infos,try,segment,commit,infos,lucene,prune,unreferenced,files,restored,segments,file,name,store,directory,catch,ioexception,e,throw,new,index,shard,restore,failed,exception,shard,id,failed,to,fetch,index,version,after,copying,it,over,e,recovery,state,get,index,update,version,segment,commit,infos,get,version,try,for,string,store,file,store,directory,list,all,if,store,is,autogenerated,store,file,snapshot,files,contain,physical,index,file,store,file,continue,try,store,delete,quiet,restore,store,file,store,directory,delete,file,store,file,catch,ioexception,e,logger,warn,failed,to,delete,file,during,snapshot,cleanup,snapshot,id,store,file,catch,ioexception,e,logger,warn,failed,to,list,directory,some,of,files,might,not,be,deleted,snapshot,id,finally,store,dec,ref
BlobStoreRepository -> RestoreContext -> public void restore() throws IOException;1542980705;Performs restore operation;public void restore() throws IOException {_            final Store store = targetShard.store()__            store.incRef()__            try {_                logger.debug("[{}] [{}] restoring to [{}] ...", snapshotId, metadata.name(), shardId)__                BlobStoreIndexShardSnapshot snapshot = loadSnapshot()___                if (snapshot.indexFiles().size() == 1_                    && snapshot.indexFiles().get(0).physicalName().startsWith("segments_")_                    && snapshot.indexFiles().get(0).hasUnknownChecksum()) {_                    _                    _                    _                    _                    _                    _                    _                    _                    IndexWriter writer = new IndexWriter(store.directory(), new IndexWriterConfig(null)_                        .setSoftDeletesField(Lucene.SOFT_DELETES_FIELD)_                        .setOpenMode(IndexWriterConfig.OpenMode.CREATE)_                        .setCommitOnClose(true))__                    writer.close()__                    return__                }__                SnapshotFiles snapshotFiles = new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles())__                Store.MetadataSnapshot recoveryTargetMetadata__                try {_                    _                    _                    _                    recoveryTargetMetadata = targetShard.snapshotStoreMetadata()__                } catch (IndexNotFoundException e) {_                    _                    logger.trace("[{}] [{}] restoring from to an empty shard", shardId, snapshotId)__                    recoveryTargetMetadata = Store.MetadataSnapshot.EMPTY__                } catch (IOException e) {_                    logger.warn(() -> new ParameterizedMessage("{} Can't read metadata from store, will not reuse any local file while restoring", shardId), e)__                    recoveryTargetMetadata = Store.MetadataSnapshot.EMPTY__                }__                final List<BlobStoreIndexShardSnapshot.FileInfo> filesToRecover = new ArrayList<>()__                final Map<String, StoreFileMetaData> snapshotMetaData = new HashMap<>()__                final Map<String, BlobStoreIndexShardSnapshot.FileInfo> fileInfos = new HashMap<>()__                for (final BlobStoreIndexShardSnapshot.FileInfo fileInfo : snapshot.indexFiles()) {_                    try {_                        _                        _                        _                        _                        maybeRecalculateMetadataHash(blobContainer, fileInfo, recoveryTargetMetadata)__                    } catch (Exception e) {_                        _                        logger.warn(() -> new ParameterizedMessage("{} Can't calculate hash from blog for file [{}] [{}]", shardId, fileInfo.physicalName(), fileInfo.metadata()), e)__                    }_                    snapshotMetaData.put(fileInfo.metadata().name(), fileInfo.metadata())__                    fileInfos.put(fileInfo.metadata().name(), fileInfo)__                }__                final Store.MetadataSnapshot sourceMetaData = new Store.MetadataSnapshot(unmodifiableMap(snapshotMetaData), emptyMap(), 0)___                final StoreFileMetaData restoredSegmentsFile = sourceMetaData.getSegmentsFile()__                if (restoredSegmentsFile == null) {_                    throw new IndexShardRestoreFailedException(shardId, "Snapshot has no segments file")__                }__                final Store.RecoveryDiff diff = sourceMetaData.recoveryDiff(recoveryTargetMetadata)__                for (StoreFileMetaData md : diff.identical) {_                    BlobStoreIndexShardSnapshot.FileInfo fileInfo = fileInfos.get(md.name())__                    recoveryState.getIndex().addFileDetail(fileInfo.name(), fileInfo.length(), true)__                    if (logger.isTraceEnabled()) {_                        logger.trace("[{}] [{}] not_recovering [{}] from [{}], exists in local store and is same", shardId, snapshotId, fileInfo.physicalName(), fileInfo.name())__                    }_                }__                for (StoreFileMetaData md : Iterables.concat(diff.different, diff.missing)) {_                    BlobStoreIndexShardSnapshot.FileInfo fileInfo = fileInfos.get(md.name())__                    filesToRecover.add(fileInfo)__                    recoveryState.getIndex().addFileDetail(fileInfo.name(), fileInfo.length(), false)__                    if (logger.isTraceEnabled()) {_                        logger.trace("[{}] [{}] recovering [{}] from [{}], exists in local store but is different", shardId, snapshotId,_                                fileInfo.physicalName(), fileInfo.name())__                    }_                }__                if (filesToRecover.isEmpty()) {_                    logger.trace("no files to recover, all exists within the local store")__                }__                try {_                    _                    final List<String> deleteIfExistFiles = Arrays.asList(store.directory().listAll())___                    _                    for (final BlobStoreIndexShardSnapshot.FileInfo fileToRecover : filesToRecover) {_                        _                        _                        _                        _                        _                        _                        final String physicalName = fileToRecover.physicalName()__                        if (deleteIfExistFiles.contains(physicalName)) {_                            logger.trace("[{}] [{}] deleting pre-existing file [{}]", shardId, snapshotId, physicalName)__                            store.directory().deleteFile(physicalName)__                        }__                        logger.trace("[{}] [{}] restoring file [{}]", shardId, snapshotId, fileToRecover.name())__                        restoreFile(fileToRecover, store)__                    }_                } catch (IOException ex) {_                    throw new IndexShardRestoreFailedException(shardId, "Failed to recover index", ex)__                }__                _                final SegmentInfos segmentCommitInfos__                try {_                    segmentCommitInfos = Lucene.pruneUnreferencedFiles(restoredSegmentsFile.name(), store.directory())__                } catch (IOException e) {_                    throw new IndexShardRestoreFailedException(shardId, "Failed to fetch index version after copying it over", e)__                }_                recoveryState.getIndex().updateVersion(segmentCommitInfos.getVersion())___                _                try {_                    for (String storeFile : store.directory().listAll()) {_                        if (Store.isAutogenerated(storeFile) || snapshotFiles.containPhysicalIndexFile(storeFile)) {_                            continue_ _                        }_                        try {_                            store.deleteQuiet("restore", storeFile)__                            store.directory().deleteFile(storeFile)__                        } catch (IOException e) {_                            logger.warn("[{}] failed to delete file [{}] during snapshot cleanup", snapshotId, storeFile)__                        }_                    }_                } catch (IOException e) {_                    logger.warn("[{}] failed to list directory - some of files might not be deleted", snapshotId)__                }_            } finally {_                store.decRef()__            }_        };performs,restore,operation;public,void,restore,throws,ioexception,final,store,store,target,shard,store,store,inc,ref,try,logger,debug,restoring,to,snapshot,id,metadata,name,shard,id,blob,store,index,shard,snapshot,snapshot,load,snapshot,if,snapshot,index,files,size,1,snapshot,index,files,get,0,physical,name,starts,with,snapshot,index,files,get,0,has,unknown,checksum,index,writer,writer,new,index,writer,store,directory,new,index,writer,config,null,set,soft,deletes,field,lucene,set,open,mode,index,writer,config,open,mode,create,set,commit,on,close,true,writer,close,return,snapshot,files,snapshot,files,new,snapshot,files,snapshot,snapshot,snapshot,index,files,store,metadata,snapshot,recovery,target,metadata,try,recovery,target,metadata,target,shard,snapshot,store,metadata,catch,index,not,found,exception,e,logger,trace,restoring,from,to,an,empty,shard,shard,id,snapshot,id,recovery,target,metadata,store,metadata,snapshot,empty,catch,ioexception,e,logger,warn,new,parameterized,message,can,t,read,metadata,from,store,will,not,reuse,any,local,file,while,restoring,shard,id,e,recovery,target,metadata,store,metadata,snapshot,empty,final,list,blob,store,index,shard,snapshot,file,info,files,to,recover,new,array,list,final,map,string,store,file,meta,data,snapshot,meta,data,new,hash,map,final,map,string,blob,store,index,shard,snapshot,file,info,file,infos,new,hash,map,for,final,blob,store,index,shard,snapshot,file,info,file,info,snapshot,index,files,try,maybe,recalculate,metadata,hash,blob,container,file,info,recovery,target,metadata,catch,exception,e,logger,warn,new,parameterized,message,can,t,calculate,hash,from,blog,for,file,shard,id,file,info,physical,name,file,info,metadata,e,snapshot,meta,data,put,file,info,metadata,name,file,info,metadata,file,infos,put,file,info,metadata,name,file,info,final,store,metadata,snapshot,source,meta,data,new,store,metadata,snapshot,unmodifiable,map,snapshot,meta,data,empty,map,0,final,store,file,meta,data,restored,segments,file,source,meta,data,get,segments,file,if,restored,segments,file,null,throw,new,index,shard,restore,failed,exception,shard,id,snapshot,has,no,segments,file,final,store,recovery,diff,diff,source,meta,data,recovery,diff,recovery,target,metadata,for,store,file,meta,data,md,diff,identical,blob,store,index,shard,snapshot,file,info,file,info,file,infos,get,md,name,recovery,state,get,index,add,file,detail,file,info,name,file,info,length,true,if,logger,is,trace,enabled,logger,trace,from,exists,in,local,store,and,is,same,shard,id,snapshot,id,file,info,physical,name,file,info,name,for,store,file,meta,data,md,iterables,concat,diff,different,diff,missing,blob,store,index,shard,snapshot,file,info,file,info,file,infos,get,md,name,files,to,recover,add,file,info,recovery,state,get,index,add,file,detail,file,info,name,file,info,length,false,if,logger,is,trace,enabled,logger,trace,recovering,from,exists,in,local,store,but,is,different,shard,id,snapshot,id,file,info,physical,name,file,info,name,if,files,to,recover,is,empty,logger,trace,no,files,to,recover,all,exists,within,the,local,store,try,final,list,string,delete,if,exist,files,arrays,as,list,store,directory,list,all,for,final,blob,store,index,shard,snapshot,file,info,file,to,recover,files,to,recover,final,string,physical,name,file,to,recover,physical,name,if,delete,if,exist,files,contains,physical,name,logger,trace,deleting,pre,existing,file,shard,id,snapshot,id,physical,name,store,directory,delete,file,physical,name,logger,trace,restoring,file,shard,id,snapshot,id,file,to,recover,name,restore,file,file,to,recover,store,catch,ioexception,ex,throw,new,index,shard,restore,failed,exception,shard,id,failed,to,recover,index,ex,final,segment,infos,segment,commit,infos,try,segment,commit,infos,lucene,prune,unreferenced,files,restored,segments,file,name,store,directory,catch,ioexception,e,throw,new,index,shard,restore,failed,exception,shard,id,failed,to,fetch,index,version,after,copying,it,over,e,recovery,state,get,index,update,version,segment,commit,infos,get,version,try,for,string,store,file,store,directory,list,all,if,store,is,autogenerated,store,file,snapshot,files,contain,physical,index,file,store,file,continue,try,store,delete,quiet,restore,store,file,store,directory,delete,file,store,file,catch,ioexception,e,logger,warn,failed,to,delete,file,during,snapshot,cleanup,snapshot,id,store,file,catch,ioexception,e,logger,warn,failed,to,list,directory,some,of,files,might,not,be,deleted,snapshot,id,finally,store,dec,ref
BlobStoreRepository -> RestoreContext -> public void restore() throws IOException;1543831870;Performs restore operation;public void restore() throws IOException {_            final Store store = targetShard.store()__            store.incRef()__            try {_                logger.debug("[{}] [{}] restoring to [{}] ...", snapshotId, metadata.name(), shardId)__                BlobStoreIndexShardSnapshot snapshot = loadSnapshot()___                if (snapshot.indexFiles().size() == 1_                    && snapshot.indexFiles().get(0).physicalName().startsWith("segments_")_                    && snapshot.indexFiles().get(0).hasUnknownChecksum()) {_                    _                    _                    _                    _                    _                    _                    _                    _                    IndexWriter writer = new IndexWriter(store.directory(), new IndexWriterConfig(null)_                        .setSoftDeletesField(Lucene.SOFT_DELETES_FIELD)_                        .setOpenMode(IndexWriterConfig.OpenMode.CREATE)_                        .setCommitOnClose(true))__                    writer.close()__                    return__                }__                SnapshotFiles snapshotFiles = new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles())__                Store.MetadataSnapshot recoveryTargetMetadata__                try {_                    _                    _                    _                    recoveryTargetMetadata = targetShard.snapshotStoreMetadata()__                } catch (IndexNotFoundException e) {_                    _                    logger.trace("[{}] [{}] restoring from to an empty shard", shardId, snapshotId)__                    recoveryTargetMetadata = Store.MetadataSnapshot.EMPTY__                } catch (IOException e) {_                    logger.warn(() -> new ParameterizedMessage("{} Can't read metadata from store, will not reuse any local file while restoring", shardId), e)__                    recoveryTargetMetadata = Store.MetadataSnapshot.EMPTY__                }__                final List<BlobStoreIndexShardSnapshot.FileInfo> filesToRecover = new ArrayList<>()__                final Map<String, StoreFileMetaData> snapshotMetaData = new HashMap<>()__                final Map<String, BlobStoreIndexShardSnapshot.FileInfo> fileInfos = new HashMap<>()__                for (final BlobStoreIndexShardSnapshot.FileInfo fileInfo : snapshot.indexFiles()) {_                    try {_                        _                        _                        _                        _                        maybeRecalculateMetadataHash(blobContainer, fileInfo, recoveryTargetMetadata)__                    } catch (Exception e) {_                        _                        logger.warn(() -> new ParameterizedMessage("{} Can't calculate hash from blog for file [{}] [{}]", shardId, fileInfo.physicalName(), fileInfo.metadata()), e)__                    }_                    snapshotMetaData.put(fileInfo.metadata().name(), fileInfo.metadata())__                    fileInfos.put(fileInfo.metadata().name(), fileInfo)__                }__                final Store.MetadataSnapshot sourceMetaData = new Store.MetadataSnapshot(unmodifiableMap(snapshotMetaData), emptyMap(), 0)___                final StoreFileMetaData restoredSegmentsFile = sourceMetaData.getSegmentsFile()__                if (restoredSegmentsFile == null) {_                    throw new IndexShardRestoreFailedException(shardId, "Snapshot has no segments file")__                }__                final Store.RecoveryDiff diff = sourceMetaData.recoveryDiff(recoveryTargetMetadata)__                for (StoreFileMetaData md : diff.identical) {_                    BlobStoreIndexShardSnapshot.FileInfo fileInfo = fileInfos.get(md.name())__                    recoveryState.getIndex().addFileDetail(fileInfo.name(), fileInfo.length(), true)__                    if (logger.isTraceEnabled()) {_                        logger.trace("[{}] [{}] not_recovering [{}] from [{}], exists in local store and is same", shardId, snapshotId, fileInfo.physicalName(), fileInfo.name())__                    }_                }__                for (StoreFileMetaData md : Iterables.concat(diff.different, diff.missing)) {_                    BlobStoreIndexShardSnapshot.FileInfo fileInfo = fileInfos.get(md.name())__                    filesToRecover.add(fileInfo)__                    recoveryState.getIndex().addFileDetail(fileInfo.name(), fileInfo.length(), false)__                    if (logger.isTraceEnabled()) {_                        logger.trace("[{}] [{}] recovering [{}] from [{}], exists in local store but is different", shardId, snapshotId,_                                fileInfo.physicalName(), fileInfo.name())__                    }_                }__                if (filesToRecover.isEmpty()) {_                    logger.trace("no files to recover, all exists within the local store")__                }__                try {_                    _                    final List<String> deleteIfExistFiles = Arrays.asList(store.directory().listAll())___                    _                    for (final BlobStoreIndexShardSnapshot.FileInfo fileToRecover : filesToRecover) {_                        _                        _                        _                        _                        _                        _                        final String physicalName = fileToRecover.physicalName()__                        if (deleteIfExistFiles.contains(physicalName)) {_                            logger.trace("[{}] [{}] deleting pre-existing file [{}]", shardId, snapshotId, physicalName)__                            store.directory().deleteFile(physicalName)__                        }__                        logger.trace("[{}] [{}] restoring file [{}]", shardId, snapshotId, fileToRecover.name())__                        restoreFile(fileToRecover, store)__                    }_                } catch (IOException ex) {_                    throw new IndexShardRestoreFailedException(shardId, "Failed to recover index", ex)__                }__                _                final SegmentInfos segmentCommitInfos__                try {_                    segmentCommitInfos = Lucene.pruneUnreferencedFiles(restoredSegmentsFile.name(), store.directory())__                } catch (IOException e) {_                    throw new IndexShardRestoreFailedException(shardId, "Failed to fetch index version after copying it over", e)__                }_                recoveryState.getIndex().updateVersion(segmentCommitInfos.getVersion())___                _                try {_                    for (String storeFile : store.directory().listAll()) {_                        if (Store.isAutogenerated(storeFile) || snapshotFiles.containPhysicalIndexFile(storeFile)) {_                            continue_ _                        }_                        try {_                            store.deleteQuiet("restore", storeFile)__                            store.directory().deleteFile(storeFile)__                        } catch (IOException e) {_                            logger.warn("[{}] failed to delete file [{}] during snapshot cleanup", snapshotId, storeFile)__                        }_                    }_                } catch (IOException e) {_                    logger.warn("[{}] failed to list directory - some of files might not be deleted", snapshotId)__                }_            } finally {_                store.decRef()__            }_        };performs,restore,operation;public,void,restore,throws,ioexception,final,store,store,target,shard,store,store,inc,ref,try,logger,debug,restoring,to,snapshot,id,metadata,name,shard,id,blob,store,index,shard,snapshot,snapshot,load,snapshot,if,snapshot,index,files,size,1,snapshot,index,files,get,0,physical,name,starts,with,snapshot,index,files,get,0,has,unknown,checksum,index,writer,writer,new,index,writer,store,directory,new,index,writer,config,null,set,soft,deletes,field,lucene,set,open,mode,index,writer,config,open,mode,create,set,commit,on,close,true,writer,close,return,snapshot,files,snapshot,files,new,snapshot,files,snapshot,snapshot,snapshot,index,files,store,metadata,snapshot,recovery,target,metadata,try,recovery,target,metadata,target,shard,snapshot,store,metadata,catch,index,not,found,exception,e,logger,trace,restoring,from,to,an,empty,shard,shard,id,snapshot,id,recovery,target,metadata,store,metadata,snapshot,empty,catch,ioexception,e,logger,warn,new,parameterized,message,can,t,read,metadata,from,store,will,not,reuse,any,local,file,while,restoring,shard,id,e,recovery,target,metadata,store,metadata,snapshot,empty,final,list,blob,store,index,shard,snapshot,file,info,files,to,recover,new,array,list,final,map,string,store,file,meta,data,snapshot,meta,data,new,hash,map,final,map,string,blob,store,index,shard,snapshot,file,info,file,infos,new,hash,map,for,final,blob,store,index,shard,snapshot,file,info,file,info,snapshot,index,files,try,maybe,recalculate,metadata,hash,blob,container,file,info,recovery,target,metadata,catch,exception,e,logger,warn,new,parameterized,message,can,t,calculate,hash,from,blog,for,file,shard,id,file,info,physical,name,file,info,metadata,e,snapshot,meta,data,put,file,info,metadata,name,file,info,metadata,file,infos,put,file,info,metadata,name,file,info,final,store,metadata,snapshot,source,meta,data,new,store,metadata,snapshot,unmodifiable,map,snapshot,meta,data,empty,map,0,final,store,file,meta,data,restored,segments,file,source,meta,data,get,segments,file,if,restored,segments,file,null,throw,new,index,shard,restore,failed,exception,shard,id,snapshot,has,no,segments,file,final,store,recovery,diff,diff,source,meta,data,recovery,diff,recovery,target,metadata,for,store,file,meta,data,md,diff,identical,blob,store,index,shard,snapshot,file,info,file,info,file,infos,get,md,name,recovery,state,get,index,add,file,detail,file,info,name,file,info,length,true,if,logger,is,trace,enabled,logger,trace,from,exists,in,local,store,and,is,same,shard,id,snapshot,id,file,info,physical,name,file,info,name,for,store,file,meta,data,md,iterables,concat,diff,different,diff,missing,blob,store,index,shard,snapshot,file,info,file,info,file,infos,get,md,name,files,to,recover,add,file,info,recovery,state,get,index,add,file,detail,file,info,name,file,info,length,false,if,logger,is,trace,enabled,logger,trace,recovering,from,exists,in,local,store,but,is,different,shard,id,snapshot,id,file,info,physical,name,file,info,name,if,files,to,recover,is,empty,logger,trace,no,files,to,recover,all,exists,within,the,local,store,try,final,list,string,delete,if,exist,files,arrays,as,list,store,directory,list,all,for,final,blob,store,index,shard,snapshot,file,info,file,to,recover,files,to,recover,final,string,physical,name,file,to,recover,physical,name,if,delete,if,exist,files,contains,physical,name,logger,trace,deleting,pre,existing,file,shard,id,snapshot,id,physical,name,store,directory,delete,file,physical,name,logger,trace,restoring,file,shard,id,snapshot,id,file,to,recover,name,restore,file,file,to,recover,store,catch,ioexception,ex,throw,new,index,shard,restore,failed,exception,shard,id,failed,to,recover,index,ex,final,segment,infos,segment,commit,infos,try,segment,commit,infos,lucene,prune,unreferenced,files,restored,segments,file,name,store,directory,catch,ioexception,e,throw,new,index,shard,restore,failed,exception,shard,id,failed,to,fetch,index,version,after,copying,it,over,e,recovery,state,get,index,update,version,segment,commit,infos,get,version,try,for,string,store,file,store,directory,list,all,if,store,is,autogenerated,store,file,snapshot,files,contain,physical,index,file,store,file,continue,try,store,delete,quiet,restore,store,file,store,directory,delete,file,store,file,catch,ioexception,e,logger,warn,failed,to,delete,file,during,snapshot,cleanup,snapshot,id,store,file,catch,ioexception,e,logger,warn,failed,to,list,directory,some,of,files,might,not,be,deleted,snapshot,id,finally,store,dec,ref
BlobStoreRepository -> RestoreContext -> public void restore() throws IOException;1543942400;Performs restore operation;public void restore() throws IOException {_            final Store store = targetShard.store()__            store.incRef()__            try {_                logger.debug("[{}] [{}] restoring to [{}] ...", snapshotId, metadata.name(), shardId)__                BlobStoreIndexShardSnapshot snapshot = loadSnapshot()___                if (snapshot.indexFiles().size() == 1_                    && snapshot.indexFiles().get(0).physicalName().startsWith("segments_")_                    && snapshot.indexFiles().get(0).hasUnknownChecksum()) {_                    _                    _                    _                    _                    _                    _                    _                    _                    store.createEmpty(targetShard.indexSettings().getIndexMetaData().getCreationVersion().luceneVersion)__                    return__                }__                SnapshotFiles snapshotFiles = new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles())__                Store.MetadataSnapshot recoveryTargetMetadata__                try {_                    _                    _                    _                    recoveryTargetMetadata = targetShard.snapshotStoreMetadata()__                } catch (IndexNotFoundException e) {_                    _                    logger.trace("[{}] [{}] restoring from to an empty shard", shardId, snapshotId)__                    recoveryTargetMetadata = Store.MetadataSnapshot.EMPTY__                } catch (IOException e) {_                    logger.warn(() -> new ParameterizedMessage("{} Can't read metadata from store, will not reuse any local file while restoring", shardId), e)__                    recoveryTargetMetadata = Store.MetadataSnapshot.EMPTY__                }__                final List<BlobStoreIndexShardSnapshot.FileInfo> filesToRecover = new ArrayList<>()__                final Map<String, StoreFileMetaData> snapshotMetaData = new HashMap<>()__                final Map<String, BlobStoreIndexShardSnapshot.FileInfo> fileInfos = new HashMap<>()__                for (final BlobStoreIndexShardSnapshot.FileInfo fileInfo : snapshot.indexFiles()) {_                    try {_                        _                        _                        _                        _                        maybeRecalculateMetadataHash(blobContainer, fileInfo, recoveryTargetMetadata)__                    } catch (Exception e) {_                        _                        logger.warn(() -> new ParameterizedMessage("{} Can't calculate hash from blog for file [{}] [{}]", shardId, fileInfo.physicalName(), fileInfo.metadata()), e)__                    }_                    snapshotMetaData.put(fileInfo.metadata().name(), fileInfo.metadata())__                    fileInfos.put(fileInfo.metadata().name(), fileInfo)__                }__                final Store.MetadataSnapshot sourceMetaData = new Store.MetadataSnapshot(unmodifiableMap(snapshotMetaData), emptyMap(), 0)___                final StoreFileMetaData restoredSegmentsFile = sourceMetaData.getSegmentsFile()__                if (restoredSegmentsFile == null) {_                    throw new IndexShardRestoreFailedException(shardId, "Snapshot has no segments file")__                }__                final Store.RecoveryDiff diff = sourceMetaData.recoveryDiff(recoveryTargetMetadata)__                for (StoreFileMetaData md : diff.identical) {_                    BlobStoreIndexShardSnapshot.FileInfo fileInfo = fileInfos.get(md.name())__                    recoveryState.getIndex().addFileDetail(fileInfo.name(), fileInfo.length(), true)__                    if (logger.isTraceEnabled()) {_                        logger.trace("[{}] [{}] not_recovering [{}] from [{}], exists in local store and is same", shardId, snapshotId, fileInfo.physicalName(), fileInfo.name())__                    }_                }__                for (StoreFileMetaData md : Iterables.concat(diff.different, diff.missing)) {_                    BlobStoreIndexShardSnapshot.FileInfo fileInfo = fileInfos.get(md.name())__                    filesToRecover.add(fileInfo)__                    recoveryState.getIndex().addFileDetail(fileInfo.name(), fileInfo.length(), false)__                    if (logger.isTraceEnabled()) {_                        logger.trace("[{}] [{}] recovering [{}] from [{}], exists in local store but is different", shardId, snapshotId,_                                fileInfo.physicalName(), fileInfo.name())__                    }_                }__                if (filesToRecover.isEmpty()) {_                    logger.trace("no files to recover, all exists within the local store")__                }__                try {_                    _                    final List<String> deleteIfExistFiles = Arrays.asList(store.directory().listAll())___                    _                    for (final BlobStoreIndexShardSnapshot.FileInfo fileToRecover : filesToRecover) {_                        _                        _                        _                        _                        _                        _                        final String physicalName = fileToRecover.physicalName()__                        if (deleteIfExistFiles.contains(physicalName)) {_                            logger.trace("[{}] [{}] deleting pre-existing file [{}]", shardId, snapshotId, physicalName)__                            store.directory().deleteFile(physicalName)__                        }__                        logger.trace("[{}] [{}] restoring file [{}]", shardId, snapshotId, fileToRecover.name())__                        restoreFile(fileToRecover, store)__                    }_                } catch (IOException ex) {_                    throw new IndexShardRestoreFailedException(shardId, "Failed to recover index", ex)__                }__                _                final SegmentInfos segmentCommitInfos__                try {_                    segmentCommitInfos = Lucene.pruneUnreferencedFiles(restoredSegmentsFile.name(), store.directory())__                } catch (IOException e) {_                    throw new IndexShardRestoreFailedException(shardId, "Failed to fetch index version after copying it over", e)__                }_                recoveryState.getIndex().updateVersion(segmentCommitInfos.getVersion())___                _                try {_                    for (String storeFile : store.directory().listAll()) {_                        if (Store.isAutogenerated(storeFile) || snapshotFiles.containPhysicalIndexFile(storeFile)) {_                            continue_ _                        }_                        try {_                            store.deleteQuiet("restore", storeFile)__                            store.directory().deleteFile(storeFile)__                        } catch (IOException e) {_                            logger.warn("[{}] failed to delete file [{}] during snapshot cleanup", snapshotId, storeFile)__                        }_                    }_                } catch (IOException e) {_                    logger.warn("[{}] failed to list directory - some of files might not be deleted", snapshotId)__                }_            } finally {_                store.decRef()__            }_        };performs,restore,operation;public,void,restore,throws,ioexception,final,store,store,target,shard,store,store,inc,ref,try,logger,debug,restoring,to,snapshot,id,metadata,name,shard,id,blob,store,index,shard,snapshot,snapshot,load,snapshot,if,snapshot,index,files,size,1,snapshot,index,files,get,0,physical,name,starts,with,snapshot,index,files,get,0,has,unknown,checksum,store,create,empty,target,shard,index,settings,get,index,meta,data,get,creation,version,lucene,version,return,snapshot,files,snapshot,files,new,snapshot,files,snapshot,snapshot,snapshot,index,files,store,metadata,snapshot,recovery,target,metadata,try,recovery,target,metadata,target,shard,snapshot,store,metadata,catch,index,not,found,exception,e,logger,trace,restoring,from,to,an,empty,shard,shard,id,snapshot,id,recovery,target,metadata,store,metadata,snapshot,empty,catch,ioexception,e,logger,warn,new,parameterized,message,can,t,read,metadata,from,store,will,not,reuse,any,local,file,while,restoring,shard,id,e,recovery,target,metadata,store,metadata,snapshot,empty,final,list,blob,store,index,shard,snapshot,file,info,files,to,recover,new,array,list,final,map,string,store,file,meta,data,snapshot,meta,data,new,hash,map,final,map,string,blob,store,index,shard,snapshot,file,info,file,infos,new,hash,map,for,final,blob,store,index,shard,snapshot,file,info,file,info,snapshot,index,files,try,maybe,recalculate,metadata,hash,blob,container,file,info,recovery,target,metadata,catch,exception,e,logger,warn,new,parameterized,message,can,t,calculate,hash,from,blog,for,file,shard,id,file,info,physical,name,file,info,metadata,e,snapshot,meta,data,put,file,info,metadata,name,file,info,metadata,file,infos,put,file,info,metadata,name,file,info,final,store,metadata,snapshot,source,meta,data,new,store,metadata,snapshot,unmodifiable,map,snapshot,meta,data,empty,map,0,final,store,file,meta,data,restored,segments,file,source,meta,data,get,segments,file,if,restored,segments,file,null,throw,new,index,shard,restore,failed,exception,shard,id,snapshot,has,no,segments,file,final,store,recovery,diff,diff,source,meta,data,recovery,diff,recovery,target,metadata,for,store,file,meta,data,md,diff,identical,blob,store,index,shard,snapshot,file,info,file,info,file,infos,get,md,name,recovery,state,get,index,add,file,detail,file,info,name,file,info,length,true,if,logger,is,trace,enabled,logger,trace,from,exists,in,local,store,and,is,same,shard,id,snapshot,id,file,info,physical,name,file,info,name,for,store,file,meta,data,md,iterables,concat,diff,different,diff,missing,blob,store,index,shard,snapshot,file,info,file,info,file,infos,get,md,name,files,to,recover,add,file,info,recovery,state,get,index,add,file,detail,file,info,name,file,info,length,false,if,logger,is,trace,enabled,logger,trace,recovering,from,exists,in,local,store,but,is,different,shard,id,snapshot,id,file,info,physical,name,file,info,name,if,files,to,recover,is,empty,logger,trace,no,files,to,recover,all,exists,within,the,local,store,try,final,list,string,delete,if,exist,files,arrays,as,list,store,directory,list,all,for,final,blob,store,index,shard,snapshot,file,info,file,to,recover,files,to,recover,final,string,physical,name,file,to,recover,physical,name,if,delete,if,exist,files,contains,physical,name,logger,trace,deleting,pre,existing,file,shard,id,snapshot,id,physical,name,store,directory,delete,file,physical,name,logger,trace,restoring,file,shard,id,snapshot,id,file,to,recover,name,restore,file,file,to,recover,store,catch,ioexception,ex,throw,new,index,shard,restore,failed,exception,shard,id,failed,to,recover,index,ex,final,segment,infos,segment,commit,infos,try,segment,commit,infos,lucene,prune,unreferenced,files,restored,segments,file,name,store,directory,catch,ioexception,e,throw,new,index,shard,restore,failed,exception,shard,id,failed,to,fetch,index,version,after,copying,it,over,e,recovery,state,get,index,update,version,segment,commit,infos,get,version,try,for,string,store,file,store,directory,list,all,if,store,is,autogenerated,store,file,snapshot,files,contain,physical,index,file,store,file,continue,try,store,delete,quiet,restore,store,file,store,directory,delete,file,store,file,catch,ioexception,e,logger,warn,failed,to,delete,file,during,snapshot,cleanup,snapshot,id,store,file,catch,ioexception,e,logger,warn,failed,to,list,directory,some,of,files,might,not,be,deleted,snapshot,id,finally,store,dec,ref
BlobStoreRepository -> RestoreContext -> public void restore() throws IOException;1546974294;Performs restore operation;public void restore() throws IOException {_            final Store store = targetShard.store()__            store.incRef()__            try {_                logger.debug("[{}] [{}] restoring to [{}] ...", snapshotId, metadata.name(), shardId)__                BlobStoreIndexShardSnapshot snapshot = loadSnapshot()___                if (snapshot.indexFiles().size() == 1_                    && snapshot.indexFiles().get(0).physicalName().startsWith("segments_")_                    && snapshot.indexFiles().get(0).hasUnknownChecksum()) {_                    _                    _                    _                    _                    _                    _                    _                    _                    store.createEmpty(targetShard.indexSettings().getIndexMetaData().getCreationVersion().luceneVersion)__                    return__                }__                SnapshotFiles snapshotFiles = new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles())__                Store.MetadataSnapshot recoveryTargetMetadata__                try {_                    _                    _                    _                    recoveryTargetMetadata = targetShard.snapshotStoreMetadata()__                } catch (IndexNotFoundException e) {_                    _                    logger.trace("[{}] [{}] restoring from to an empty shard", shardId, snapshotId)__                    recoveryTargetMetadata = Store.MetadataSnapshot.EMPTY__                } catch (IOException e) {_                    logger.warn(() -> new ParameterizedMessage("{} Can't read metadata from store, will not reuse any " +_                        "local file while restoring", shardId), e)__                    recoveryTargetMetadata = Store.MetadataSnapshot.EMPTY__                }__                final List<BlobStoreIndexShardSnapshot.FileInfo> filesToRecover = new ArrayList<>()__                final Map<String, StoreFileMetaData> snapshotMetaData = new HashMap<>()__                final Map<String, BlobStoreIndexShardSnapshot.FileInfo> fileInfos = new HashMap<>()__                for (final BlobStoreIndexShardSnapshot.FileInfo fileInfo : snapshot.indexFiles()) {_                    try {_                        _                        _                        _                        _                        maybeRecalculateMetadataHash(blobContainer, fileInfo, recoveryTargetMetadata)__                    } catch (Exception e) {_                        _                        logger.warn(() -> new ParameterizedMessage("{} Can't calculate hash from blog for file [{}] [{}]",_                            shardId, fileInfo.physicalName(), fileInfo.metadata()), e)__                    }_                    snapshotMetaData.put(fileInfo.metadata().name(), fileInfo.metadata())__                    fileInfos.put(fileInfo.metadata().name(), fileInfo)__                }__                final Store.MetadataSnapshot sourceMetaData = new Store.MetadataSnapshot(unmodifiableMap(snapshotMetaData), emptyMap(), 0)___                final StoreFileMetaData restoredSegmentsFile = sourceMetaData.getSegmentsFile()__                if (restoredSegmentsFile == null) {_                    throw new IndexShardRestoreFailedException(shardId, "Snapshot has no segments file")__                }__                final Store.RecoveryDiff diff = sourceMetaData.recoveryDiff(recoveryTargetMetadata)__                for (StoreFileMetaData md : diff.identical) {_                    BlobStoreIndexShardSnapshot.FileInfo fileInfo = fileInfos.get(md.name())__                    recoveryState.getIndex().addFileDetail(fileInfo.name(), fileInfo.length(), true)__                    if (logger.isTraceEnabled()) {_                        logger.trace("[{}] [{}] not_recovering [{}] from [{}], exists in local store and is same",_                            shardId, snapshotId, fileInfo.physicalName(), fileInfo.name())__                    }_                }__                for (StoreFileMetaData md : Iterables.concat(diff.different, diff.missing)) {_                    BlobStoreIndexShardSnapshot.FileInfo fileInfo = fileInfos.get(md.name())__                    filesToRecover.add(fileInfo)__                    recoveryState.getIndex().addFileDetail(fileInfo.name(), fileInfo.length(), false)__                    if (logger.isTraceEnabled()) {_                        logger.trace("[{}] [{}] recovering [{}] from [{}], exists in local store but is different", shardId, snapshotId,_                                fileInfo.physicalName(), fileInfo.name())__                    }_                }__                if (filesToRecover.isEmpty()) {_                    logger.trace("no files to recover, all exists within the local store")__                }__                try {_                    _                    final List<String> deleteIfExistFiles = Arrays.asList(store.directory().listAll())___                    _                    for (final BlobStoreIndexShardSnapshot.FileInfo fileToRecover : filesToRecover) {_                        _                        _                        _                        _                        _                        _                        final String physicalName = fileToRecover.physicalName()__                        if (deleteIfExistFiles.contains(physicalName)) {_                            logger.trace("[{}] [{}] deleting pre-existing file [{}]", shardId, snapshotId, physicalName)__                            store.directory().deleteFile(physicalName)__                        }__                        logger.trace("[{}] [{}] restoring file [{}]", shardId, snapshotId, fileToRecover.name())__                        restoreFile(fileToRecover, store)__                    }_                } catch (IOException ex) {_                    throw new IndexShardRestoreFailedException(shardId, "Failed to recover index", ex)__                }__                _                final SegmentInfos segmentCommitInfos__                try {_                    segmentCommitInfos = Lucene.pruneUnreferencedFiles(restoredSegmentsFile.name(), store.directory())__                } catch (IOException e) {_                    throw new IndexShardRestoreFailedException(shardId, "Failed to fetch index version after copying it over", e)__                }_                recoveryState.getIndex().updateVersion(segmentCommitInfos.getVersion())___                _                try {_                    for (String storeFile : store.directory().listAll()) {_                        if (Store.isAutogenerated(storeFile) || snapshotFiles.containPhysicalIndexFile(storeFile)) {_                            continue_ _                        }_                        try {_                            store.deleteQuiet("restore", storeFile)__                            store.directory().deleteFile(storeFile)__                        } catch (IOException e) {_                            logger.warn("[{}] failed to delete file [{}] during snapshot cleanup", snapshotId, storeFile)__                        }_                    }_                } catch (IOException e) {_                    logger.warn("[{}] failed to list directory - some of files might not be deleted", snapshotId)__                }_            } finally {_                store.decRef()__            }_        };performs,restore,operation;public,void,restore,throws,ioexception,final,store,store,target,shard,store,store,inc,ref,try,logger,debug,restoring,to,snapshot,id,metadata,name,shard,id,blob,store,index,shard,snapshot,snapshot,load,snapshot,if,snapshot,index,files,size,1,snapshot,index,files,get,0,physical,name,starts,with,snapshot,index,files,get,0,has,unknown,checksum,store,create,empty,target,shard,index,settings,get,index,meta,data,get,creation,version,lucene,version,return,snapshot,files,snapshot,files,new,snapshot,files,snapshot,snapshot,snapshot,index,files,store,metadata,snapshot,recovery,target,metadata,try,recovery,target,metadata,target,shard,snapshot,store,metadata,catch,index,not,found,exception,e,logger,trace,restoring,from,to,an,empty,shard,shard,id,snapshot,id,recovery,target,metadata,store,metadata,snapshot,empty,catch,ioexception,e,logger,warn,new,parameterized,message,can,t,read,metadata,from,store,will,not,reuse,any,local,file,while,restoring,shard,id,e,recovery,target,metadata,store,metadata,snapshot,empty,final,list,blob,store,index,shard,snapshot,file,info,files,to,recover,new,array,list,final,map,string,store,file,meta,data,snapshot,meta,data,new,hash,map,final,map,string,blob,store,index,shard,snapshot,file,info,file,infos,new,hash,map,for,final,blob,store,index,shard,snapshot,file,info,file,info,snapshot,index,files,try,maybe,recalculate,metadata,hash,blob,container,file,info,recovery,target,metadata,catch,exception,e,logger,warn,new,parameterized,message,can,t,calculate,hash,from,blog,for,file,shard,id,file,info,physical,name,file,info,metadata,e,snapshot,meta,data,put,file,info,metadata,name,file,info,metadata,file,infos,put,file,info,metadata,name,file,info,final,store,metadata,snapshot,source,meta,data,new,store,metadata,snapshot,unmodifiable,map,snapshot,meta,data,empty,map,0,final,store,file,meta,data,restored,segments,file,source,meta,data,get,segments,file,if,restored,segments,file,null,throw,new,index,shard,restore,failed,exception,shard,id,snapshot,has,no,segments,file,final,store,recovery,diff,diff,source,meta,data,recovery,diff,recovery,target,metadata,for,store,file,meta,data,md,diff,identical,blob,store,index,shard,snapshot,file,info,file,info,file,infos,get,md,name,recovery,state,get,index,add,file,detail,file,info,name,file,info,length,true,if,logger,is,trace,enabled,logger,trace,from,exists,in,local,store,and,is,same,shard,id,snapshot,id,file,info,physical,name,file,info,name,for,store,file,meta,data,md,iterables,concat,diff,different,diff,missing,blob,store,index,shard,snapshot,file,info,file,info,file,infos,get,md,name,files,to,recover,add,file,info,recovery,state,get,index,add,file,detail,file,info,name,file,info,length,false,if,logger,is,trace,enabled,logger,trace,recovering,from,exists,in,local,store,but,is,different,shard,id,snapshot,id,file,info,physical,name,file,info,name,if,files,to,recover,is,empty,logger,trace,no,files,to,recover,all,exists,within,the,local,store,try,final,list,string,delete,if,exist,files,arrays,as,list,store,directory,list,all,for,final,blob,store,index,shard,snapshot,file,info,file,to,recover,files,to,recover,final,string,physical,name,file,to,recover,physical,name,if,delete,if,exist,files,contains,physical,name,logger,trace,deleting,pre,existing,file,shard,id,snapshot,id,physical,name,store,directory,delete,file,physical,name,logger,trace,restoring,file,shard,id,snapshot,id,file,to,recover,name,restore,file,file,to,recover,store,catch,ioexception,ex,throw,new,index,shard,restore,failed,exception,shard,id,failed,to,recover,index,ex,final,segment,infos,segment,commit,infos,try,segment,commit,infos,lucene,prune,unreferenced,files,restored,segments,file,name,store,directory,catch,ioexception,e,throw,new,index,shard,restore,failed,exception,shard,id,failed,to,fetch,index,version,after,copying,it,over,e,recovery,state,get,index,update,version,segment,commit,infos,get,version,try,for,string,store,file,store,directory,list,all,if,store,is,autogenerated,store,file,snapshot,files,contain,physical,index,file,store,file,continue,try,store,delete,quiet,restore,store,file,store,directory,delete,file,store,file,catch,ioexception,e,logger,warn,failed,to,delete,file,during,snapshot,cleanup,snapshot,id,store,file,catch,ioexception,e,logger,warn,failed,to,list,directory,some,of,files,might,not,be,deleted,snapshot,id,finally,store,dec,ref
BlobStoreRepository -> long latestIndexBlobId() throws IOException;1524684173;Get the latest snapshot index blob id.  Snapshot index blobs are named index-N, where N is_the next version number from when the index blob was written.  Each individual index-N blob is_only written once and never overwritten.  The highest numbered index-N blob is the latest one_that contains the current snapshots in the repository.__Package private for testing;long latestIndexBlobId() throws IOException {_        try {_            _            _            _            _            _            _            _            _            _            _            _            return listBlobsToGetLatestIndexId()__        } catch (UnsupportedOperationException e) {_            _            _            try {_                return readSnapshotIndexLatestBlob()__            } catch (NoSuchFileException nsfe) {_                return RepositoryData.EMPTY_REPO_GEN__            }_        }_    };get,the,latest,snapshot,index,blob,id,snapshot,index,blobs,are,named,index,n,where,n,is,the,next,version,number,from,when,the,index,blob,was,written,each,individual,index,n,blob,is,only,written,once,and,never,overwritten,the,highest,numbered,index,n,blob,is,the,latest,one,that,contains,the,current,snapshots,in,the,repository,package,private,for,testing;long,latest,index,blob,id,throws,ioexception,try,return,list,blobs,to,get,latest,index,id,catch,unsupported,operation,exception,e,try,return,read,snapshot,index,latest,blob,catch,no,such,file,exception,nsfe,return,repository,data
BlobStoreRepository -> long latestIndexBlobId() throws IOException;1525334055;Get the latest snapshot index blob id.  Snapshot index blobs are named index-N, where N is_the next version number from when the index blob was written.  Each individual index-N blob is_only written once and never overwritten.  The highest numbered index-N blob is the latest one_that contains the current snapshots in the repository.__Package private for testing;long latestIndexBlobId() throws IOException {_        try {_            _            _            _            _            _            _            _            _            _            _            _            return listBlobsToGetLatestIndexId()__        } catch (UnsupportedOperationException e) {_            _            _            try {_                return readSnapshotIndexLatestBlob()__            } catch (NoSuchFileException nsfe) {_                return RepositoryData.EMPTY_REPO_GEN__            }_        }_    };get,the,latest,snapshot,index,blob,id,snapshot,index,blobs,are,named,index,n,where,n,is,the,next,version,number,from,when,the,index,blob,was,written,each,individual,index,n,blob,is,only,written,once,and,never,overwritten,the,highest,numbered,index,n,blob,is,the,latest,one,that,contains,the,current,snapshots,in,the,repository,package,private,for,testing;long,latest,index,blob,id,throws,ioexception,try,return,list,blobs,to,get,latest,index,id,catch,unsupported,operation,exception,e,try,return,read,snapshot,index,latest,blob,catch,no,such,file,exception,nsfe,return,repository,data
BlobStoreRepository -> long latestIndexBlobId() throws IOException;1525798020;Get the latest snapshot index blob id.  Snapshot index blobs are named index-N, where N is_the next version number from when the index blob was written.  Each individual index-N blob is_only written once and never overwritten.  The highest numbered index-N blob is the latest one_that contains the current snapshots in the repository.__Package private for testing;long latestIndexBlobId() throws IOException {_        try {_            _            _            _            _            _            _            _            _            _            _            _            return listBlobsToGetLatestIndexId()__        } catch (UnsupportedOperationException e) {_            _            _            try {_                return readSnapshotIndexLatestBlob()__            } catch (NoSuchFileException nsfe) {_                return RepositoryData.EMPTY_REPO_GEN__            }_        }_    };get,the,latest,snapshot,index,blob,id,snapshot,index,blobs,are,named,index,n,where,n,is,the,next,version,number,from,when,the,index,blob,was,written,each,individual,index,n,blob,is,only,written,once,and,never,overwritten,the,highest,numbered,index,n,blob,is,the,latest,one,that,contains,the,current,snapshots,in,the,repository,package,private,for,testing;long,latest,index,blob,id,throws,ioexception,try,return,list,blobs,to,get,latest,index,id,catch,unsupported,operation,exception,e,try,return,read,snapshot,index,latest,blob,catch,no,such,file,exception,nsfe,return,repository,data
BlobStoreRepository -> long latestIndexBlobId() throws IOException;1526289033;Get the latest snapshot index blob id.  Snapshot index blobs are named index-N, where N is_the next version number from when the index blob was written.  Each individual index-N blob is_only written once and never overwritten.  The highest numbered index-N blob is the latest one_that contains the current snapshots in the repository.__Package private for testing;long latestIndexBlobId() throws IOException {_        try {_            _            _            _            _            _            _            _            _            _            _            _            return listBlobsToGetLatestIndexId()__        } catch (UnsupportedOperationException e) {_            _            _            try {_                return readSnapshotIndexLatestBlob()__            } catch (NoSuchFileException nsfe) {_                return RepositoryData.EMPTY_REPO_GEN__            }_        }_    };get,the,latest,snapshot,index,blob,id,snapshot,index,blobs,are,named,index,n,where,n,is,the,next,version,number,from,when,the,index,blob,was,written,each,individual,index,n,blob,is,only,written,once,and,never,overwritten,the,highest,numbered,index,n,blob,is,the,latest,one,that,contains,the,current,snapshots,in,the,repository,package,private,for,testing;long,latest,index,blob,id,throws,ioexception,try,return,list,blobs,to,get,latest,index,id,catch,unsupported,operation,exception,e,try,return,read,snapshot,index,latest,blob,catch,no,such,file,exception,nsfe,return,repository,data
BlobStoreRepository -> long latestIndexBlobId() throws IOException;1526574077;Get the latest snapshot index blob id.  Snapshot index blobs are named index-N, where N is_the next version number from when the index blob was written.  Each individual index-N blob is_only written once and never overwritten.  The highest numbered index-N blob is the latest one_that contains the current snapshots in the repository.__Package private for testing;long latestIndexBlobId() throws IOException {_        try {_            _            _            _            _            _            _            _            _            _            _            _            return listBlobsToGetLatestIndexId()__        } catch (UnsupportedOperationException e) {_            _            _            try {_                return readSnapshotIndexLatestBlob()__            } catch (NoSuchFileException nsfe) {_                return RepositoryData.EMPTY_REPO_GEN__            }_        }_    };get,the,latest,snapshot,index,blob,id,snapshot,index,blobs,are,named,index,n,where,n,is,the,next,version,number,from,when,the,index,blob,was,written,each,individual,index,n,blob,is,only,written,once,and,never,overwritten,the,highest,numbered,index,n,blob,is,the,latest,one,that,contains,the,current,snapshots,in,the,repository,package,private,for,testing;long,latest,index,blob,id,throws,ioexception,try,return,list,blobs,to,get,latest,index,id,catch,unsupported,operation,exception,e,try,return,read,snapshot,index,latest,blob,catch,no,such,file,exception,nsfe,return,repository,data
BlobStoreRepository -> long latestIndexBlobId() throws IOException;1527583663;Get the latest snapshot index blob id.  Snapshot index blobs are named index-N, where N is_the next version number from when the index blob was written.  Each individual index-N blob is_only written once and never overwritten.  The highest numbered index-N blob is the latest one_that contains the current snapshots in the repository.__Package private for testing;long latestIndexBlobId() throws IOException {_        try {_            _            _            _            _            _            _            _            _            _            _            _            return listBlobsToGetLatestIndexId()__        } catch (UnsupportedOperationException e) {_            _            _            try {_                return readSnapshotIndexLatestBlob()__            } catch (NoSuchFileException nsfe) {_                return RepositoryData.EMPTY_REPO_GEN__            }_        }_    };get,the,latest,snapshot,index,blob,id,snapshot,index,blobs,are,named,index,n,where,n,is,the,next,version,number,from,when,the,index,blob,was,written,each,individual,index,n,blob,is,only,written,once,and,never,overwritten,the,highest,numbered,index,n,blob,is,the,latest,one,that,contains,the,current,snapshots,in,the,repository,package,private,for,testing;long,latest,index,blob,id,throws,ioexception,try,return,list,blobs,to,get,latest,index,id,catch,unsupported,operation,exception,e,try,return,read,snapshot,index,latest,blob,catch,no,such,file,exception,nsfe,return,repository,data
BlobStoreRepository -> long latestIndexBlobId() throws IOException;1528211342;Get the latest snapshot index blob id.  Snapshot index blobs are named index-N, where N is_the next version number from when the index blob was written.  Each individual index-N blob is_only written once and never overwritten.  The highest numbered index-N blob is the latest one_that contains the current snapshots in the repository.__Package private for testing;long latestIndexBlobId() throws IOException {_        try {_            _            _            _            _            _            _            _            _            _            _            _            return listBlobsToGetLatestIndexId()__        } catch (UnsupportedOperationException e) {_            _            _            try {_                return readSnapshotIndexLatestBlob()__            } catch (NoSuchFileException nsfe) {_                return RepositoryData.EMPTY_REPO_GEN__            }_        }_    };get,the,latest,snapshot,index,blob,id,snapshot,index,blobs,are,named,index,n,where,n,is,the,next,version,number,from,when,the,index,blob,was,written,each,individual,index,n,blob,is,only,written,once,and,never,overwritten,the,highest,numbered,index,n,blob,is,the,latest,one,that,contains,the,current,snapshots,in,the,repository,package,private,for,testing;long,latest,index,blob,id,throws,ioexception,try,return,list,blobs,to,get,latest,index,id,catch,unsupported,operation,exception,e,try,return,read,snapshot,index,latest,blob,catch,no,such,file,exception,nsfe,return,repository,data
BlobStoreRepository -> long latestIndexBlobId() throws IOException;1531179852;Get the latest snapshot index blob id.  Snapshot index blobs are named index-N, where N is_the next version number from when the index blob was written.  Each individual index-N blob is_only written once and never overwritten.  The highest numbered index-N blob is the latest one_that contains the current snapshots in the repository.__Package private for testing;long latestIndexBlobId() throws IOException {_        try {_            _            _            _            _            _            _            _            _            _            _            _            return listBlobsToGetLatestIndexId()__        } catch (UnsupportedOperationException e) {_            _            _            try {_                return readSnapshotIndexLatestBlob()__            } catch (NoSuchFileException nsfe) {_                return RepositoryData.EMPTY_REPO_GEN__            }_        }_    };get,the,latest,snapshot,index,blob,id,snapshot,index,blobs,are,named,index,n,where,n,is,the,next,version,number,from,when,the,index,blob,was,written,each,individual,index,n,blob,is,only,written,once,and,never,overwritten,the,highest,numbered,index,n,blob,is,the,latest,one,that,contains,the,current,snapshots,in,the,repository,package,private,for,testing;long,latest,index,blob,id,throws,ioexception,try,return,list,blobs,to,get,latest,index,id,catch,unsupported,operation,exception,e,try,return,read,snapshot,index,latest,blob,catch,no,such,file,exception,nsfe,return,repository,data
BlobStoreRepository -> long latestIndexBlobId() throws IOException;1531729807;Get the latest snapshot index blob id.  Snapshot index blobs are named index-N, where N is_the next version number from when the index blob was written.  Each individual index-N blob is_only written once and never overwritten.  The highest numbered index-N blob is the latest one_that contains the current snapshots in the repository.__Package private for testing;long latestIndexBlobId() throws IOException {_        try {_            _            _            _            _            _            _            _            _            _            _            _            return listBlobsToGetLatestIndexId()__        } catch (UnsupportedOperationException e) {_            _            _            try {_                return readSnapshotIndexLatestBlob()__            } catch (NoSuchFileException nsfe) {_                return RepositoryData.EMPTY_REPO_GEN__            }_        }_    };get,the,latest,snapshot,index,blob,id,snapshot,index,blobs,are,named,index,n,where,n,is,the,next,version,number,from,when,the,index,blob,was,written,each,individual,index,n,blob,is,only,written,once,and,never,overwritten,the,highest,numbered,index,n,blob,is,the,latest,one,that,contains,the,current,snapshots,in,the,repository,package,private,for,testing;long,latest,index,blob,id,throws,ioexception,try,return,list,blobs,to,get,latest,index,id,catch,unsupported,operation,exception,e,try,return,read,snapshot,index,latest,blob,catch,no,such,file,exception,nsfe,return,repository,data
BlobStoreRepository -> long latestIndexBlobId() throws IOException;1532685069;Get the latest snapshot index blob id.  Snapshot index blobs are named index-N, where N is_the next version number from when the index blob was written.  Each individual index-N blob is_only written once and never overwritten.  The highest numbered index-N blob is the latest one_that contains the current snapshots in the repository.__Package private for testing;long latestIndexBlobId() throws IOException {_        try {_            _            _            _            _            _            _            _            _            _            _            _            return listBlobsToGetLatestIndexId()__        } catch (UnsupportedOperationException e) {_            _            _            try {_                return readSnapshotIndexLatestBlob()__            } catch (NoSuchFileException nsfe) {_                return RepositoryData.EMPTY_REPO_GEN__            }_        }_    };get,the,latest,snapshot,index,blob,id,snapshot,index,blobs,are,named,index,n,where,n,is,the,next,version,number,from,when,the,index,blob,was,written,each,individual,index,n,blob,is,only,written,once,and,never,overwritten,the,highest,numbered,index,n,blob,is,the,latest,one,that,contains,the,current,snapshots,in,the,repository,package,private,for,testing;long,latest,index,blob,id,throws,ioexception,try,return,list,blobs,to,get,latest,index,id,catch,unsupported,operation,exception,e,try,return,read,snapshot,index,latest,blob,catch,no,such,file,exception,nsfe,return,repository,data
BlobStoreRepository -> long latestIndexBlobId() throws IOException;1535139672;Get the latest snapshot index blob id.  Snapshot index blobs are named index-N, where N is_the next version number from when the index blob was written.  Each individual index-N blob is_only written once and never overwritten.  The highest numbered index-N blob is the latest one_that contains the current snapshots in the repository.__Package private for testing;long latestIndexBlobId() throws IOException {_        try {_            _            _            _            _            _            _            _            _            _            _            _            return listBlobsToGetLatestIndexId()__        } catch (UnsupportedOperationException e) {_            _            _            try {_                return readSnapshotIndexLatestBlob()__            } catch (NoSuchFileException nsfe) {_                return RepositoryData.EMPTY_REPO_GEN__            }_        }_    };get,the,latest,snapshot,index,blob,id,snapshot,index,blobs,are,named,index,n,where,n,is,the,next,version,number,from,when,the,index,blob,was,written,each,individual,index,n,blob,is,only,written,once,and,never,overwritten,the,highest,numbered,index,n,blob,is,the,latest,one,that,contains,the,current,snapshots,in,the,repository,package,private,for,testing;long,latest,index,blob,id,throws,ioexception,try,return,list,blobs,to,get,latest,index,id,catch,unsupported,operation,exception,e,try,return,read,snapshot,index,latest,blob,catch,no,such,file,exception,nsfe,return,repository,data
BlobStoreRepository -> long latestIndexBlobId() throws IOException;1535723122;Get the latest snapshot index blob id.  Snapshot index blobs are named index-N, where N is_the next version number from when the index blob was written.  Each individual index-N blob is_only written once and never overwritten.  The highest numbered index-N blob is the latest one_that contains the current snapshots in the repository.__Package private for testing;long latestIndexBlobId() throws IOException {_        try {_            _            _            _            _            _            _            _            _            _            _            _            return listBlobsToGetLatestIndexId()__        } catch (UnsupportedOperationException e) {_            _            _            try {_                return readSnapshotIndexLatestBlob()__            } catch (NoSuchFileException nsfe) {_                return RepositoryData.EMPTY_REPO_GEN__            }_        }_    };get,the,latest,snapshot,index,blob,id,snapshot,index,blobs,are,named,index,n,where,n,is,the,next,version,number,from,when,the,index,blob,was,written,each,individual,index,n,blob,is,only,written,once,and,never,overwritten,the,highest,numbered,index,n,blob,is,the,latest,one,that,contains,the,current,snapshots,in,the,repository,package,private,for,testing;long,latest,index,blob,id,throws,ioexception,try,return,list,blobs,to,get,latest,index,id,catch,unsupported,operation,exception,e,try,return,read,snapshot,index,latest,blob,catch,no,such,file,exception,nsfe,return,repository,data
BlobStoreRepository -> long latestIndexBlobId() throws IOException;1536314350;Get the latest snapshot index blob id.  Snapshot index blobs are named index-N, where N is_the next version number from when the index blob was written.  Each individual index-N blob is_only written once and never overwritten.  The highest numbered index-N blob is the latest one_that contains the current snapshots in the repository.__Package private for testing;long latestIndexBlobId() throws IOException {_        try {_            _            _            _            _            _            _            _            _            _            _            _            return listBlobsToGetLatestIndexId()__        } catch (UnsupportedOperationException e) {_            _            _            try {_                return readSnapshotIndexLatestBlob()__            } catch (NoSuchFileException nsfe) {_                return RepositoryData.EMPTY_REPO_GEN__            }_        }_    };get,the,latest,snapshot,index,blob,id,snapshot,index,blobs,are,named,index,n,where,n,is,the,next,version,number,from,when,the,index,blob,was,written,each,individual,index,n,blob,is,only,written,once,and,never,overwritten,the,highest,numbered,index,n,blob,is,the,latest,one,that,contains,the,current,snapshots,in,the,repository,package,private,for,testing;long,latest,index,blob,id,throws,ioexception,try,return,list,blobs,to,get,latest,index,id,catch,unsupported,operation,exception,e,try,return,read,snapshot,index,latest,blob,catch,no,such,file,exception,nsfe,return,repository,data
BlobStoreRepository -> long latestIndexBlobId() throws IOException;1536828374;Get the latest snapshot index blob id.  Snapshot index blobs are named index-N, where N is_the next version number from when the index blob was written.  Each individual index-N blob is_only written once and never overwritten.  The highest numbered index-N blob is the latest one_that contains the current snapshots in the repository.__Package private for testing;long latestIndexBlobId() throws IOException {_        try {_            _            _            _            _            _            _            _            _            _            _            _            return listBlobsToGetLatestIndexId()__        } catch (UnsupportedOperationException e) {_            _            _            try {_                return readSnapshotIndexLatestBlob()__            } catch (NoSuchFileException nsfe) {_                return RepositoryData.EMPTY_REPO_GEN__            }_        }_    };get,the,latest,snapshot,index,blob,id,snapshot,index,blobs,are,named,index,n,where,n,is,the,next,version,number,from,when,the,index,blob,was,written,each,individual,index,n,blob,is,only,written,once,and,never,overwritten,the,highest,numbered,index,n,blob,is,the,latest,one,that,contains,the,current,snapshots,in,the,repository,package,private,for,testing;long,latest,index,blob,id,throws,ioexception,try,return,list,blobs,to,get,latest,index,id,catch,unsupported,operation,exception,e,try,return,read,snapshot,index,latest,blob,catch,no,such,file,exception,nsfe,return,repository,data
BlobStoreRepository -> long latestIndexBlobId() throws IOException;1541008027;Get the latest snapshot index blob id.  Snapshot index blobs are named index-N, where N is_the next version number from when the index blob was written.  Each individual index-N blob is_only written once and never overwritten.  The highest numbered index-N blob is the latest one_that contains the current snapshots in the repository.__Package private for testing;long latestIndexBlobId() throws IOException {_        try {_            _            _            _            _            _            _            _            _            _            _            _            return listBlobsToGetLatestIndexId()__        } catch (UnsupportedOperationException e) {_            _            _            try {_                return readSnapshotIndexLatestBlob()__            } catch (NoSuchFileException nsfe) {_                return RepositoryData.EMPTY_REPO_GEN__            }_        }_    };get,the,latest,snapshot,index,blob,id,snapshot,index,blobs,are,named,index,n,where,n,is,the,next,version,number,from,when,the,index,blob,was,written,each,individual,index,n,blob,is,only,written,once,and,never,overwritten,the,highest,numbered,index,n,blob,is,the,latest,one,that,contains,the,current,snapshots,in,the,repository,package,private,for,testing;long,latest,index,blob,id,throws,ioexception,try,return,list,blobs,to,get,latest,index,id,catch,unsupported,operation,exception,e,try,return,read,snapshot,index,latest,blob,catch,no,such,file,exception,nsfe,return,repository,data
BlobStoreRepository -> long latestIndexBlobId() throws IOException;1542646292;Get the latest snapshot index blob id.  Snapshot index blobs are named index-N, where N is_the next version number from when the index blob was written.  Each individual index-N blob is_only written once and never overwritten.  The highest numbered index-N blob is the latest one_that contains the current snapshots in the repository.__Package private for testing;long latestIndexBlobId() throws IOException {_        try {_            _            _            _            _            _            _            _            _            _            _            _            return listBlobsToGetLatestIndexId()__        } catch (UnsupportedOperationException e) {_            _            _            try {_                return readSnapshotIndexLatestBlob()__            } catch (NoSuchFileException nsfe) {_                return RepositoryData.EMPTY_REPO_GEN__            }_        }_    };get,the,latest,snapshot,index,blob,id,snapshot,index,blobs,are,named,index,n,where,n,is,the,next,version,number,from,when,the,index,blob,was,written,each,individual,index,n,blob,is,only,written,once,and,never,overwritten,the,highest,numbered,index,n,blob,is,the,latest,one,that,contains,the,current,snapshots,in,the,repository,package,private,for,testing;long,latest,index,blob,id,throws,ioexception,try,return,list,blobs,to,get,latest,index,id,catch,unsupported,operation,exception,e,try,return,read,snapshot,index,latest,blob,catch,no,such,file,exception,nsfe,return,repository,data
BlobStoreRepository -> long latestIndexBlobId() throws IOException;1542980705;Get the latest snapshot index blob id.  Snapshot index blobs are named index-N, where N is_the next version number from when the index blob was written.  Each individual index-N blob is_only written once and never overwritten.  The highest numbered index-N blob is the latest one_that contains the current snapshots in the repository.__Package private for testing;long latestIndexBlobId() throws IOException {_        try {_            _            _            _            _            _            _            _            _            _            _            _            return listBlobsToGetLatestIndexId()__        } catch (UnsupportedOperationException e) {_            _            _            try {_                return readSnapshotIndexLatestBlob()__            } catch (NoSuchFileException nsfe) {_                return RepositoryData.EMPTY_REPO_GEN__            }_        }_    };get,the,latest,snapshot,index,blob,id,snapshot,index,blobs,are,named,index,n,where,n,is,the,next,version,number,from,when,the,index,blob,was,written,each,individual,index,n,blob,is,only,written,once,and,never,overwritten,the,highest,numbered,index,n,blob,is,the,latest,one,that,contains,the,current,snapshots,in,the,repository,package,private,for,testing;long,latest,index,blob,id,throws,ioexception,try,return,list,blobs,to,get,latest,index,id,catch,unsupported,operation,exception,e,try,return,read,snapshot,index,latest,blob,catch,no,such,file,exception,nsfe,return,repository,data
BlobStoreRepository -> long latestIndexBlobId() throws IOException;1543831870;Get the latest snapshot index blob id.  Snapshot index blobs are named index-N, where N is_the next version number from when the index blob was written.  Each individual index-N blob is_only written once and never overwritten.  The highest numbered index-N blob is the latest one_that contains the current snapshots in the repository.__Package private for testing;long latestIndexBlobId() throws IOException {_        try {_            _            _            _            _            _            _            _            _            _            _            _            return listBlobsToGetLatestIndexId()__        } catch (UnsupportedOperationException e) {_            _            _            try {_                return readSnapshotIndexLatestBlob()__            } catch (NoSuchFileException nsfe) {_                return RepositoryData.EMPTY_REPO_GEN__            }_        }_    };get,the,latest,snapshot,index,blob,id,snapshot,index,blobs,are,named,index,n,where,n,is,the,next,version,number,from,when,the,index,blob,was,written,each,individual,index,n,blob,is,only,written,once,and,never,overwritten,the,highest,numbered,index,n,blob,is,the,latest,one,that,contains,the,current,snapshots,in,the,repository,package,private,for,testing;long,latest,index,blob,id,throws,ioexception,try,return,list,blobs,to,get,latest,index,id,catch,unsupported,operation,exception,e,try,return,read,snapshot,index,latest,blob,catch,no,such,file,exception,nsfe,return,repository,data
BlobStoreRepository -> long latestIndexBlobId() throws IOException;1543942400;Get the latest snapshot index blob id.  Snapshot index blobs are named index-N, where N is_the next version number from when the index blob was written.  Each individual index-N blob is_only written once and never overwritten.  The highest numbered index-N blob is the latest one_that contains the current snapshots in the repository.__Package private for testing;long latestIndexBlobId() throws IOException {_        try {_            _            _            _            _            _            _            _            _            _            _            _            return listBlobsToGetLatestIndexId()__        } catch (UnsupportedOperationException e) {_            _            _            try {_                return readSnapshotIndexLatestBlob()__            } catch (NoSuchFileException nsfe) {_                return RepositoryData.EMPTY_REPO_GEN__            }_        }_    };get,the,latest,snapshot,index,blob,id,snapshot,index,blobs,are,named,index,n,where,n,is,the,next,version,number,from,when,the,index,blob,was,written,each,individual,index,n,blob,is,only,written,once,and,never,overwritten,the,highest,numbered,index,n,blob,is,the,latest,one,that,contains,the,current,snapshots,in,the,repository,package,private,for,testing;long,latest,index,blob,id,throws,ioexception,try,return,list,blobs,to,get,latest,index,id,catch,unsupported,operation,exception,e,try,return,read,snapshot,index,latest,blob,catch,no,such,file,exception,nsfe,return,repository,data
BlobStoreRepository -> long latestIndexBlobId() throws IOException;1546974294;Get the latest snapshot index blob id.  Snapshot index blobs are named index-N, where N is_the next version number from when the index blob was written.  Each individual index-N blob is_only written once and never overwritten.  The highest numbered index-N blob is the latest one_that contains the current snapshots in the repository.__Package private for testing;long latestIndexBlobId() throws IOException {_        try {_            _            _            _            _            _            _            _            _            _            _            _            return listBlobsToGetLatestIndexId()__        } catch (UnsupportedOperationException e) {_            _            _            try {_                return readSnapshotIndexLatestBlob()__            } catch (NoSuchFileException nsfe) {_                return RepositoryData.EMPTY_REPO_GEN__            }_        }_    };get,the,latest,snapshot,index,blob,id,snapshot,index,blobs,are,named,index,n,where,n,is,the,next,version,number,from,when,the,index,blob,was,written,each,individual,index,n,blob,is,only,written,once,and,never,overwritten,the,highest,numbered,index,n,blob,is,the,latest,one,that,contains,the,current,snapshots,in,the,repository,package,private,for,testing;long,latest,index,blob,id,throws,ioexception,try,return,list,blobs,to,get,latest,index,id,catch,unsupported,operation,exception,e,try,return,read,snapshot,index,latest,blob,catch,no,such,file,exception,nsfe,return,repository,data
BlobStoreRepository -> long latestIndexBlobId() throws IOException;1547496475;Get the latest snapshot index blob id.  Snapshot index blobs are named index-N, where N is_the next version number from when the index blob was written.  Each individual index-N blob is_only written once and never overwritten.  The highest numbered index-N blob is the latest one_that contains the current snapshots in the repository.__Package private for testing;long latestIndexBlobId() throws IOException {_        try {_            _            _            _            _            _            _            _            _            _            _            _            return listBlobsToGetLatestIndexId()__        } catch (UnsupportedOperationException e) {_            _            _            try {_                return readSnapshotIndexLatestBlob()__            } catch (NoSuchFileException nsfe) {_                return RepositoryData.EMPTY_REPO_GEN__            }_        }_    };get,the,latest,snapshot,index,blob,id,snapshot,index,blobs,are,named,index,n,where,n,is,the,next,version,number,from,when,the,index,blob,was,written,each,individual,index,n,blob,is,only,written,once,and,never,overwritten,the,highest,numbered,index,n,blob,is,the,latest,one,that,contains,the,current,snapshots,in,the,repository,package,private,for,testing;long,latest,index,blob,id,throws,ioexception,try,return,list,blobs,to,get,latest,index,id,catch,unsupported,operation,exception,e,try,return,read,snapshot,index,latest,blob,catch,no,such,file,exception,nsfe,return,repository,data
BlobStoreRepository -> long latestIndexBlobId() throws IOException;1547625930;Get the latest snapshot index blob id.  Snapshot index blobs are named index-N, where N is_the next version number from when the index blob was written.  Each individual index-N blob is_only written once and never overwritten.  The highest numbered index-N blob is the latest one_that contains the current snapshots in the repository.__Package private for testing;long latestIndexBlobId() throws IOException {_        try {_            _            _            _            _            _            _            _            _            _            _            _            return listBlobsToGetLatestIndexId()__        } catch (UnsupportedOperationException e) {_            _            _            try {_                return readSnapshotIndexLatestBlob()__            } catch (NoSuchFileException nsfe) {_                return RepositoryData.EMPTY_REPO_GEN__            }_        }_    };get,the,latest,snapshot,index,blob,id,snapshot,index,blobs,are,named,index,n,where,n,is,the,next,version,number,from,when,the,index,blob,was,written,each,individual,index,n,blob,is,only,written,once,and,never,overwritten,the,highest,numbered,index,n,blob,is,the,latest,one,that,contains,the,current,snapshots,in,the,repository,package,private,for,testing;long,latest,index,blob,id,throws,ioexception,try,return,list,blobs,to,get,latest,index,id,catch,unsupported,operation,exception,e,try,return,read,snapshot,index,latest,blob,catch,no,such,file,exception,nsfe,return,repository,data
BlobStoreRepository -> long latestIndexBlobId() throws IOException;1550647627;Get the latest snapshot index blob id.  Snapshot index blobs are named index-N, where N is_the next version number from when the index blob was written.  Each individual index-N blob is_only written once and never overwritten.  The highest numbered index-N blob is the latest one_that contains the current snapshots in the repository.__Package private for testing;long latestIndexBlobId() throws IOException {_        try {_            _            _            _            _            _            _            _            _            _            _            _            return listBlobsToGetLatestIndexId()__        } catch (UnsupportedOperationException e) {_            _            _            try {_                return readSnapshotIndexLatestBlob()__            } catch (NoSuchFileException nsfe) {_                return RepositoryData.EMPTY_REPO_GEN__            }_        }_    };get,the,latest,snapshot,index,blob,id,snapshot,index,blobs,are,named,index,n,where,n,is,the,next,version,number,from,when,the,index,blob,was,written,each,individual,index,n,blob,is,only,written,once,and,never,overwritten,the,highest,numbered,index,n,blob,is,the,latest,one,that,contains,the,current,snapshots,in,the,repository,package,private,for,testing;long,latest,index,blob,id,throws,ioexception,try,return,list,blobs,to,get,latest,index,id,catch,unsupported,operation,exception,e,try,return,read,snapshot,index,latest,blob,catch,no,such,file,exception,nsfe,return,repository,data
BlobStoreRepository -> private static void maybeRecalculateMetadataHash(final BlobContainer blobContainer, final BlobStoreIndexShardSnapshot.FileInfo fileInfo,                                                      Store.MetadataSnapshot snapshot) throws Exception;1546974294;This is a BWC layer to ensure we update the snapshots metadata with the corresponding hashes before we compare them._The new logic for StoreFileMetaData reads the entire {@code .si} and {@code segments.n} files to strengthen the_comparison of the files on a per-segment / per-commit level.;private static void maybeRecalculateMetadataHash(final BlobContainer blobContainer, final BlobStoreIndexShardSnapshot.FileInfo fileInfo,_                                                     Store.MetadataSnapshot snapshot) throws Exception {_        final StoreFileMetaData metadata__        if (fileInfo != null && (metadata = snapshot.get(fileInfo.physicalName())) != null) {_            if (metadata.hash().length > 0 && fileInfo.metadata().hash().length == 0) {_                _                _                _                try (InputStream stream = new PartSliceStream(blobContainer, fileInfo)) {_                    BytesRefBuilder builder = new BytesRefBuilder()__                    Store.MetadataSnapshot.hashFile(builder, stream, fileInfo.length())__                    BytesRef hash = fileInfo.metadata().hash()_ _                    assert hash.length == 0__                    hash.bytes = builder.bytes()__                    hash.offset = 0__                    hash.length = builder.length()__                }_            }_        }_    };this,is,a,bwc,layer,to,ensure,we,update,the,snapshots,metadata,with,the,corresponding,hashes,before,we,compare,them,the,new,logic,for,store,file,meta,data,reads,the,entire,code,si,and,code,segments,n,files,to,strengthen,the,comparison,of,the,files,on,a,per,segment,per,commit,level;private,static,void,maybe,recalculate,metadata,hash,final,blob,container,blob,container,final,blob,store,index,shard,snapshot,file,info,file,info,store,metadata,snapshot,snapshot,throws,exception,final,store,file,meta,data,metadata,if,file,info,null,metadata,snapshot,get,file,info,physical,name,null,if,metadata,hash,length,0,file,info,metadata,hash,length,0,try,input,stream,stream,new,part,slice,stream,blob,container,file,info,bytes,ref,builder,builder,new,bytes,ref,builder,store,metadata,snapshot,hash,file,builder,stream,file,info,length,bytes,ref,hash,file,info,metadata,hash,assert,hash,length,0,hash,bytes,builder,bytes,hash,offset,0,hash,length,builder,length
BlobStoreRepository -> private static void maybeRecalculateMetadataHash(final BlobContainer blobContainer, final BlobStoreIndexShardSnapshot.FileInfo fileInfo,                                                      Store.MetadataSnapshot snapshot) throws Exception;1547496475;This is a BWC layer to ensure we update the snapshots metadata with the corresponding hashes before we compare them._The new logic for StoreFileMetaData reads the entire {@code .si} and {@code segments.n} files to strengthen the_comparison of the files on a per-segment / per-commit level.;private static void maybeRecalculateMetadataHash(final BlobContainer blobContainer, final BlobStoreIndexShardSnapshot.FileInfo fileInfo,_                                                     Store.MetadataSnapshot snapshot) throws Exception {_        final StoreFileMetaData metadata__        if (fileInfo != null && (metadata = snapshot.get(fileInfo.physicalName())) != null) {_            if (metadata.hash().length > 0 && fileInfo.metadata().hash().length == 0) {_                _                _                _                try (InputStream stream = new PartSliceStream(blobContainer, fileInfo)) {_                    BytesRefBuilder builder = new BytesRefBuilder()__                    Store.MetadataSnapshot.hashFile(builder, stream, fileInfo.length())__                    BytesRef hash = fileInfo.metadata().hash()_ _                    assert hash.length == 0__                    hash.bytes = builder.bytes()__                    hash.offset = 0__                    hash.length = builder.length()__                }_            }_        }_    };this,is,a,bwc,layer,to,ensure,we,update,the,snapshots,metadata,with,the,corresponding,hashes,before,we,compare,them,the,new,logic,for,store,file,meta,data,reads,the,entire,code,si,and,code,segments,n,files,to,strengthen,the,comparison,of,the,files,on,a,per,segment,per,commit,level;private,static,void,maybe,recalculate,metadata,hash,final,blob,container,blob,container,final,blob,store,index,shard,snapshot,file,info,file,info,store,metadata,snapshot,snapshot,throws,exception,final,store,file,meta,data,metadata,if,file,info,null,metadata,snapshot,get,file,info,physical,name,null,if,metadata,hash,length,0,file,info,metadata,hash,length,0,try,input,stream,stream,new,part,slice,stream,blob,container,file,info,bytes,ref,builder,builder,new,bytes,ref,builder,store,metadata,snapshot,hash,file,builder,stream,file,info,length,bytes,ref,hash,file,info,metadata,hash,assert,hash,length,0,hash,bytes,builder,bytes,hash,offset,0,hash,length,builder,length
BlobStoreRepository -> private static void maybeRecalculateMetadataHash(final BlobContainer blobContainer, final BlobStoreIndexShardSnapshot.FileInfo fileInfo,                                                      Store.MetadataSnapshot snapshot) throws Exception;1547625930;This is a BWC layer to ensure we update the snapshots metadata with the corresponding hashes before we compare them._The new logic for StoreFileMetaData reads the entire {@code .si} and {@code segments.n} files to strengthen the_comparison of the files on a per-segment / per-commit level.;private static void maybeRecalculateMetadataHash(final BlobContainer blobContainer, final BlobStoreIndexShardSnapshot.FileInfo fileInfo,_                                                     Store.MetadataSnapshot snapshot) throws Exception {_        final StoreFileMetaData metadata__        if (fileInfo != null && (metadata = snapshot.get(fileInfo.physicalName())) != null) {_            if (metadata.hash().length > 0 && fileInfo.metadata().hash().length == 0) {_                _                _                _                try (InputStream stream = new PartSliceStream(blobContainer, fileInfo)) {_                    BytesRefBuilder builder = new BytesRefBuilder()__                    Store.MetadataSnapshot.hashFile(builder, stream, fileInfo.length())__                    BytesRef hash = fileInfo.metadata().hash()_ _                    assert hash.length == 0__                    hash.bytes = builder.bytes()__                    hash.offset = 0__                    hash.length = builder.length()__                }_            }_        }_    };this,is,a,bwc,layer,to,ensure,we,update,the,snapshots,metadata,with,the,corresponding,hashes,before,we,compare,them,the,new,logic,for,store,file,meta,data,reads,the,entire,code,si,and,code,segments,n,files,to,strengthen,the,comparison,of,the,files,on,a,per,segment,per,commit,level;private,static,void,maybe,recalculate,metadata,hash,final,blob,container,blob,container,final,blob,store,index,shard,snapshot,file,info,file,info,store,metadata,snapshot,snapshot,throws,exception,final,store,file,meta,data,metadata,if,file,info,null,metadata,snapshot,get,file,info,physical,name,null,if,metadata,hash,length,0,file,info,metadata,hash,length,0,try,input,stream,stream,new,part,slice,stream,blob,container,file,info,bytes,ref,builder,builder,new,bytes,ref,builder,store,metadata,snapshot,hash,file,builder,stream,file,info,length,bytes,ref,hash,file,info,metadata,hash,assert,hash,length,0,hash,bytes,builder,bytes,hash,offset,0,hash,length,builder,length
BlobStoreRepository -> private static void maybeRecalculateMetadataHash(final BlobContainer blobContainer, final BlobStoreIndexShardSnapshot.FileInfo fileInfo,                                                      Store.MetadataSnapshot snapshot) throws Exception;1550647627;This is a BWC layer to ensure we update the snapshots metadata with the corresponding hashes before we compare them._The new logic for StoreFileMetaData reads the entire {@code .si} and {@code segments.n} files to strengthen the_comparison of the files on a per-segment / per-commit level.;private static void maybeRecalculateMetadataHash(final BlobContainer blobContainer, final BlobStoreIndexShardSnapshot.FileInfo fileInfo,_                                                     Store.MetadataSnapshot snapshot) throws Exception {_        final StoreFileMetaData metadata__        if (fileInfo != null && (metadata = snapshot.get(fileInfo.physicalName())) != null) {_            if (metadata.hash().length > 0 && fileInfo.metadata().hash().length == 0) {_                _                _                _                try (InputStream stream = new PartSliceStream(blobContainer, fileInfo)) {_                    BytesRefBuilder builder = new BytesRefBuilder()__                    Store.MetadataSnapshot.hashFile(builder, stream, fileInfo.length())__                    BytesRef hash = fileInfo.metadata().hash()_ _                    assert hash.length == 0__                    hash.bytes = builder.bytes()__                    hash.offset = 0__                    hash.length = builder.length()__                }_            }_        }_    };this,is,a,bwc,layer,to,ensure,we,update,the,snapshots,metadata,with,the,corresponding,hashes,before,we,compare,them,the,new,logic,for,store,file,meta,data,reads,the,entire,code,si,and,code,segments,n,files,to,strengthen,the,comparison,of,the,files,on,a,per,segment,per,commit,level;private,static,void,maybe,recalculate,metadata,hash,final,blob,container,blob,container,final,blob,store,index,shard,snapshot,file,info,file,info,store,metadata,snapshot,snapshot,throws,exception,final,store,file,meta,data,metadata,if,file,info,null,metadata,snapshot,get,file,info,physical,name,null,if,metadata,hash,length,0,file,info,metadata,hash,length,0,try,input,stream,stream,new,part,slice,stream,blob,container,file,info,bytes,ref,builder,builder,new,bytes,ref,builder,store,metadata,snapshot,hash,file,builder,stream,file,info,length,bytes,ref,hash,file,info,metadata,hash,assert,hash,length,0,hash,bytes,builder,bytes,hash,offset,0,hash,length,builder,length
BlobStoreRepository -> SnapshotContext -> SnapshotContext(Store store, SnapshotId snapshotId, IndexId indexId, IndexShardSnapshotStatus snapshotStatus, long startTime);1536828374;Constructs new context__@param store          store to be snapshotted_@param snapshotId     snapshot id_@param indexId        the id of the index being snapshotted_@param snapshotStatus snapshot status to report progress;SnapshotContext(Store store, SnapshotId snapshotId, IndexId indexId, IndexShardSnapshotStatus snapshotStatus, long startTime) {_            super(snapshotId, Version.CURRENT, indexId, store.shardId())__            this.snapshotStatus = snapshotStatus__            this.store = store__            this.startTime = startTime__        };constructs,new,context,param,store,store,to,be,snapshotted,param,snapshot,id,snapshot,id,param,index,id,the,id,of,the,index,being,snapshotted,param,snapshot,status,snapshot,status,to,report,progress;snapshot,context,store,store,snapshot,id,snapshot,id,index,id,index,id,index,shard,snapshot,status,snapshot,status,long,start,time,super,snapshot,id,version,current,index,id,store,shard,id,this,snapshot,status,snapshot,status,this,store,store,this,start,time,start,time
BlobStoreRepository -> SnapshotContext -> SnapshotContext(Store store, SnapshotId snapshotId, IndexId indexId, IndexShardSnapshotStatus snapshotStatus, long startTime);1541008027;Constructs new context__@param store          store to be snapshotted_@param snapshotId     snapshot id_@param indexId        the id of the index being snapshotted_@param snapshotStatus snapshot status to report progress;SnapshotContext(Store store, SnapshotId snapshotId, IndexId indexId, IndexShardSnapshotStatus snapshotStatus, long startTime) {_            super(snapshotId, Version.CURRENT, indexId, store.shardId())__            this.snapshotStatus = snapshotStatus__            this.store = store__            this.startTime = startTime__        };constructs,new,context,param,store,store,to,be,snapshotted,param,snapshot,id,snapshot,id,param,index,id,the,id,of,the,index,being,snapshotted,param,snapshot,status,snapshot,status,to,report,progress;snapshot,context,store,store,snapshot,id,snapshot,id,index,id,index,id,index,shard,snapshot,status,snapshot,status,long,start,time,super,snapshot,id,version,current,index,id,store,shard,id,this,snapshot,status,snapshot,status,this,store,store,this,start,time,start,time
BlobStoreRepository -> SnapshotContext -> SnapshotContext(Store store, SnapshotId snapshotId, IndexId indexId, IndexShardSnapshotStatus snapshotStatus, long startTime);1542646292;Constructs new context__@param store          store to be snapshotted_@param snapshotId     snapshot id_@param indexId        the id of the index being snapshotted_@param snapshotStatus snapshot status to report progress;SnapshotContext(Store store, SnapshotId snapshotId, IndexId indexId, IndexShardSnapshotStatus snapshotStatus, long startTime) {_            super(snapshotId, Version.CURRENT, indexId, store.shardId())__            this.snapshotStatus = snapshotStatus__            this.store = store__            this.startTime = startTime__        };constructs,new,context,param,store,store,to,be,snapshotted,param,snapshot,id,snapshot,id,param,index,id,the,id,of,the,index,being,snapshotted,param,snapshot,status,snapshot,status,to,report,progress;snapshot,context,store,store,snapshot,id,snapshot,id,index,id,index,id,index,shard,snapshot,status,snapshot,status,long,start,time,super,snapshot,id,version,current,index,id,store,shard,id,this,snapshot,status,snapshot,status,this,store,store,this,start,time,start,time
BlobStoreRepository -> SnapshotContext -> SnapshotContext(Store store, SnapshotId snapshotId, IndexId indexId, IndexShardSnapshotStatus snapshotStatus, long startTime);1542980705;Constructs new context__@param store          store to be snapshotted_@param snapshotId     snapshot id_@param indexId        the id of the index being snapshotted_@param snapshotStatus snapshot status to report progress;SnapshotContext(Store store, SnapshotId snapshotId, IndexId indexId, IndexShardSnapshotStatus snapshotStatus, long startTime) {_            super(snapshotId, Version.CURRENT, indexId, store.shardId())__            this.snapshotStatus = snapshotStatus__            this.store = store__            this.startTime = startTime__        };constructs,new,context,param,store,store,to,be,snapshotted,param,snapshot,id,snapshot,id,param,index,id,the,id,of,the,index,being,snapshotted,param,snapshot,status,snapshot,status,to,report,progress;snapshot,context,store,store,snapshot,id,snapshot,id,index,id,index,id,index,shard,snapshot,status,snapshot,status,long,start,time,super,snapshot,id,version,current,index,id,store,shard,id,this,snapshot,status,snapshot,status,this,store,store,this,start,time,start,time
BlobStoreRepository -> SnapshotContext -> SnapshotContext(Store store, SnapshotId snapshotId, IndexId indexId, IndexShardSnapshotStatus snapshotStatus, long startTime);1543831870;Constructs new context__@param store          store to be snapshotted_@param snapshotId     snapshot id_@param indexId        the id of the index being snapshotted_@param snapshotStatus snapshot status to report progress;SnapshotContext(Store store, SnapshotId snapshotId, IndexId indexId, IndexShardSnapshotStatus snapshotStatus, long startTime) {_            super(snapshotId, indexId, store.shardId())__            this.snapshotStatus = snapshotStatus__            this.store = store__            this.startTime = startTime__        };constructs,new,context,param,store,store,to,be,snapshotted,param,snapshot,id,snapshot,id,param,index,id,the,id,of,the,index,being,snapshotted,param,snapshot,status,snapshot,status,to,report,progress;snapshot,context,store,store,snapshot,id,snapshot,id,index,id,index,id,index,shard,snapshot,status,snapshot,status,long,start,time,super,snapshot,id,index,id,store,shard,id,this,snapshot,status,snapshot,status,this,store,store,this,start,time,start,time
BlobStoreRepository -> SnapshotContext -> SnapshotContext(Store store, SnapshotId snapshotId, IndexId indexId, IndexShardSnapshotStatus snapshotStatus, long startTime);1543942400;Constructs new context__@param store          store to be snapshotted_@param snapshotId     snapshot id_@param indexId        the id of the index being snapshotted_@param snapshotStatus snapshot status to report progress;SnapshotContext(Store store, SnapshotId snapshotId, IndexId indexId, IndexShardSnapshotStatus snapshotStatus, long startTime) {_            super(snapshotId, indexId, store.shardId())__            this.snapshotStatus = snapshotStatus__            this.store = store__            this.startTime = startTime__        };constructs,new,context,param,store,store,to,be,snapshotted,param,snapshot,id,snapshot,id,param,index,id,the,id,of,the,index,being,snapshotted,param,snapshot,status,snapshot,status,to,report,progress;snapshot,context,store,store,snapshot,id,snapshot,id,index,id,index,id,index,shard,snapshot,status,snapshot,status,long,start,time,super,snapshot,id,index,id,store,shard,id,this,snapshot,status,snapshot,status,this,store,store,this,start,time,start,time
BlobStoreRepository -> SnapshotContext -> SnapshotContext(Store store, SnapshotId snapshotId, IndexId indexId, IndexShardSnapshotStatus snapshotStatus, long startTime);1546974294;Constructs new context__@param store          store to be snapshotted_@param snapshotId     snapshot id_@param indexId        the id of the index being snapshotted_@param snapshotStatus snapshot status to report progress;SnapshotContext(Store store, SnapshotId snapshotId, IndexId indexId, IndexShardSnapshotStatus snapshotStatus, long startTime) {_            super(snapshotId, indexId, store.shardId())__            this.snapshotStatus = snapshotStatus__            this.store = store__            this.startTime = startTime__        };constructs,new,context,param,store,store,to,be,snapshotted,param,snapshot,id,snapshot,id,param,index,id,the,id,of,the,index,being,snapshotted,param,snapshot,status,snapshot,status,to,report,progress;snapshot,context,store,store,snapshot,id,snapshot,id,index,id,index,id,index,shard,snapshot,status,snapshot,status,long,start,time,super,snapshot,id,index,id,store,shard,id,this,snapshot,status,snapshot,status,this,store,store,this,start,time,start,time
BlobStoreRepository -> SnapshotContext -> SnapshotContext(Store store, SnapshotId snapshotId, IndexId indexId, IndexShardSnapshotStatus snapshotStatus, long startTime);1547496475;Constructs new context__@param store          store to be snapshotted_@param snapshotId     snapshot id_@param indexId        the id of the index being snapshotted_@param snapshotStatus snapshot status to report progress;SnapshotContext(Store store, SnapshotId snapshotId, IndexId indexId, IndexShardSnapshotStatus snapshotStatus, long startTime) {_            super(snapshotId, indexId, store.shardId())__            this.snapshotStatus = snapshotStatus__            this.store = store__            this.startTime = startTime__        };constructs,new,context,param,store,store,to,be,snapshotted,param,snapshot,id,snapshot,id,param,index,id,the,id,of,the,index,being,snapshotted,param,snapshot,status,snapshot,status,to,report,progress;snapshot,context,store,store,snapshot,id,snapshot,id,index,id,index,id,index,shard,snapshot,status,snapshot,status,long,start,time,super,snapshot,id,index,id,store,shard,id,this,snapshot,status,snapshot,status,this,store,store,this,start,time,start,time
BlobStoreRepository -> SnapshotContext -> SnapshotContext(Store store, SnapshotId snapshotId, IndexId indexId, IndexShardSnapshotStatus snapshotStatus, long startTime);1547625930;Constructs new context__@param store          store to be snapshotted_@param snapshotId     snapshot id_@param indexId        the id of the index being snapshotted_@param snapshotStatus snapshot status to report progress;SnapshotContext(Store store, SnapshotId snapshotId, IndexId indexId, IndexShardSnapshotStatus snapshotStatus, long startTime) {_            super(snapshotId, indexId, store.shardId())__            this.snapshotStatus = snapshotStatus__            this.store = store__            this.startTime = startTime__        };constructs,new,context,param,store,store,to,be,snapshotted,param,snapshot,id,snapshot,id,param,index,id,the,id,of,the,index,being,snapshotted,param,snapshot,status,snapshot,status,to,report,progress;snapshot,context,store,store,snapshot,id,snapshot,id,index,id,index,id,index,shard,snapshot,status,snapshot,status,long,start,time,super,snapshot,id,index,id,store,shard,id,this,snapshot,status,snapshot,status,this,store,store,this,start,time,start,time
BlobStoreRepository -> SnapshotContext -> SnapshotContext(Store store, SnapshotId snapshotId, IndexId indexId, IndexShardSnapshotStatus snapshotStatus, long startTime);1550647627;Constructs new context__@param store          store to be snapshotted_@param snapshotId     snapshot id_@param indexId        the id of the index being snapshotted_@param snapshotStatus snapshot status to report progress;SnapshotContext(Store store, SnapshotId snapshotId, IndexId indexId, IndexShardSnapshotStatus snapshotStatus, long startTime) {_            super(snapshotId, indexId, store.shardId())__            this.snapshotStatus = snapshotStatus__            this.store = store__            this.startTime = startTime__        };constructs,new,context,param,store,store,to,be,snapshotted,param,snapshot,id,snapshot,id,param,index,id,the,id,of,the,index,being,snapshotted,param,snapshot,status,snapshot,status,to,report,progress;snapshot,context,store,store,snapshot,id,snapshot,id,index,id,index,id,index,shard,snapshot,status,snapshot,status,long,start,time,super,snapshot,id,index,id,store,shard,id,this,snapshot,status,snapshot,status,this,store,store,this,start,time,start,time
BlobStoreRepository -> private static void maybeRecalculateMetadataHash(final BlobContainer blobContainer, final BlobStoreIndexShardSnapshot.FileInfo fileInfo, Store.MetadataSnapshot snapshot) throws Exception;1524684173;This is a BWC layer to ensure we update the snapshots metadata with the corresponding hashes before we compare them._The new logic for StoreFileMetaData reads the entire <tt>.si</tt> and <tt>segments.n</tt> files to strengthen the_comparison of the files on a per-segment / per-commit level.;private static void maybeRecalculateMetadataHash(final BlobContainer blobContainer, final BlobStoreIndexShardSnapshot.FileInfo fileInfo, Store.MetadataSnapshot snapshot) throws Exception {_        final StoreFileMetaData metadata__        if (fileInfo != null && (metadata = snapshot.get(fileInfo.physicalName())) != null) {_            if (metadata.hash().length > 0 && fileInfo.metadata().hash().length == 0) {_                _                _                _                try (InputStream stream = new PartSliceStream(blobContainer, fileInfo)) {_                    BytesRefBuilder builder = new BytesRefBuilder()__                    Store.MetadataSnapshot.hashFile(builder, stream, fileInfo.length())__                    BytesRef hash = fileInfo.metadata().hash()_ _                    assert hash.length == 0__                    hash.bytes = builder.bytes()__                    hash.offset = 0__                    hash.length = builder.length()__                }_            }_        }_    };this,is,a,bwc,layer,to,ensure,we,update,the,snapshots,metadata,with,the,corresponding,hashes,before,we,compare,them,the,new,logic,for,store,file,meta,data,reads,the,entire,tt,si,tt,and,tt,segments,n,tt,files,to,strengthen,the,comparison,of,the,files,on,a,per,segment,per,commit,level;private,static,void,maybe,recalculate,metadata,hash,final,blob,container,blob,container,final,blob,store,index,shard,snapshot,file,info,file,info,store,metadata,snapshot,snapshot,throws,exception,final,store,file,meta,data,metadata,if,file,info,null,metadata,snapshot,get,file,info,physical,name,null,if,metadata,hash,length,0,file,info,metadata,hash,length,0,try,input,stream,stream,new,part,slice,stream,blob,container,file,info,bytes,ref,builder,builder,new,bytes,ref,builder,store,metadata,snapshot,hash,file,builder,stream,file,info,length,bytes,ref,hash,file,info,metadata,hash,assert,hash,length,0,hash,bytes,builder,bytes,hash,offset,0,hash,length,builder,length
BlobStoreRepository -> private static void maybeRecalculateMetadataHash(final BlobContainer blobContainer, final BlobStoreIndexShardSnapshot.FileInfo fileInfo, Store.MetadataSnapshot snapshot) throws Exception;1525334055;This is a BWC layer to ensure we update the snapshots metadata with the corresponding hashes before we compare them._The new logic for StoreFileMetaData reads the entire {@code .si} and {@code segments.n} files to strengthen the_comparison of the files on a per-segment / per-commit level.;private static void maybeRecalculateMetadataHash(final BlobContainer blobContainer, final BlobStoreIndexShardSnapshot.FileInfo fileInfo, Store.MetadataSnapshot snapshot) throws Exception {_        final StoreFileMetaData metadata__        if (fileInfo != null && (metadata = snapshot.get(fileInfo.physicalName())) != null) {_            if (metadata.hash().length > 0 && fileInfo.metadata().hash().length == 0) {_                _                _                _                try (InputStream stream = new PartSliceStream(blobContainer, fileInfo)) {_                    BytesRefBuilder builder = new BytesRefBuilder()__                    Store.MetadataSnapshot.hashFile(builder, stream, fileInfo.length())__                    BytesRef hash = fileInfo.metadata().hash()_ _                    assert hash.length == 0__                    hash.bytes = builder.bytes()__                    hash.offset = 0__                    hash.length = builder.length()__                }_            }_        }_    };this,is,a,bwc,layer,to,ensure,we,update,the,snapshots,metadata,with,the,corresponding,hashes,before,we,compare,them,the,new,logic,for,store,file,meta,data,reads,the,entire,code,si,and,code,segments,n,files,to,strengthen,the,comparison,of,the,files,on,a,per,segment,per,commit,level;private,static,void,maybe,recalculate,metadata,hash,final,blob,container,blob,container,final,blob,store,index,shard,snapshot,file,info,file,info,store,metadata,snapshot,snapshot,throws,exception,final,store,file,meta,data,metadata,if,file,info,null,metadata,snapshot,get,file,info,physical,name,null,if,metadata,hash,length,0,file,info,metadata,hash,length,0,try,input,stream,stream,new,part,slice,stream,blob,container,file,info,bytes,ref,builder,builder,new,bytes,ref,builder,store,metadata,snapshot,hash,file,builder,stream,file,info,length,bytes,ref,hash,file,info,metadata,hash,assert,hash,length,0,hash,bytes,builder,bytes,hash,offset,0,hash,length,builder,length
BlobStoreRepository -> private static void maybeRecalculateMetadataHash(final BlobContainer blobContainer, final BlobStoreIndexShardSnapshot.FileInfo fileInfo, Store.MetadataSnapshot snapshot) throws Exception;1525798020;This is a BWC layer to ensure we update the snapshots metadata with the corresponding hashes before we compare them._The new logic for StoreFileMetaData reads the entire {@code .si} and {@code segments.n} files to strengthen the_comparison of the files on a per-segment / per-commit level.;private static void maybeRecalculateMetadataHash(final BlobContainer blobContainer, final BlobStoreIndexShardSnapshot.FileInfo fileInfo, Store.MetadataSnapshot snapshot) throws Exception {_        final StoreFileMetaData metadata__        if (fileInfo != null && (metadata = snapshot.get(fileInfo.physicalName())) != null) {_            if (metadata.hash().length > 0 && fileInfo.metadata().hash().length == 0) {_                _                _                _                try (InputStream stream = new PartSliceStream(blobContainer, fileInfo)) {_                    BytesRefBuilder builder = new BytesRefBuilder()__                    Store.MetadataSnapshot.hashFile(builder, stream, fileInfo.length())__                    BytesRef hash = fileInfo.metadata().hash()_ _                    assert hash.length == 0__                    hash.bytes = builder.bytes()__                    hash.offset = 0__                    hash.length = builder.length()__                }_            }_        }_    };this,is,a,bwc,layer,to,ensure,we,update,the,snapshots,metadata,with,the,corresponding,hashes,before,we,compare,them,the,new,logic,for,store,file,meta,data,reads,the,entire,code,si,and,code,segments,n,files,to,strengthen,the,comparison,of,the,files,on,a,per,segment,per,commit,level;private,static,void,maybe,recalculate,metadata,hash,final,blob,container,blob,container,final,blob,store,index,shard,snapshot,file,info,file,info,store,metadata,snapshot,snapshot,throws,exception,final,store,file,meta,data,metadata,if,file,info,null,metadata,snapshot,get,file,info,physical,name,null,if,metadata,hash,length,0,file,info,metadata,hash,length,0,try,input,stream,stream,new,part,slice,stream,blob,container,file,info,bytes,ref,builder,builder,new,bytes,ref,builder,store,metadata,snapshot,hash,file,builder,stream,file,info,length,bytes,ref,hash,file,info,metadata,hash,assert,hash,length,0,hash,bytes,builder,bytes,hash,offset,0,hash,length,builder,length
BlobStoreRepository -> private static void maybeRecalculateMetadataHash(final BlobContainer blobContainer, final BlobStoreIndexShardSnapshot.FileInfo fileInfo, Store.MetadataSnapshot snapshot) throws Exception;1526289033;This is a BWC layer to ensure we update the snapshots metadata with the corresponding hashes before we compare them._The new logic for StoreFileMetaData reads the entire {@code .si} and {@code segments.n} files to strengthen the_comparison of the files on a per-segment / per-commit level.;private static void maybeRecalculateMetadataHash(final BlobContainer blobContainer, final BlobStoreIndexShardSnapshot.FileInfo fileInfo, Store.MetadataSnapshot snapshot) throws Exception {_        final StoreFileMetaData metadata__        if (fileInfo != null && (metadata = snapshot.get(fileInfo.physicalName())) != null) {_            if (metadata.hash().length > 0 && fileInfo.metadata().hash().length == 0) {_                _                _                _                try (InputStream stream = new PartSliceStream(blobContainer, fileInfo)) {_                    BytesRefBuilder builder = new BytesRefBuilder()__                    Store.MetadataSnapshot.hashFile(builder, stream, fileInfo.length())__                    BytesRef hash = fileInfo.metadata().hash()_ _                    assert hash.length == 0__                    hash.bytes = builder.bytes()__                    hash.offset = 0__                    hash.length = builder.length()__                }_            }_        }_    };this,is,a,bwc,layer,to,ensure,we,update,the,snapshots,metadata,with,the,corresponding,hashes,before,we,compare,them,the,new,logic,for,store,file,meta,data,reads,the,entire,code,si,and,code,segments,n,files,to,strengthen,the,comparison,of,the,files,on,a,per,segment,per,commit,level;private,static,void,maybe,recalculate,metadata,hash,final,blob,container,blob,container,final,blob,store,index,shard,snapshot,file,info,file,info,store,metadata,snapshot,snapshot,throws,exception,final,store,file,meta,data,metadata,if,file,info,null,metadata,snapshot,get,file,info,physical,name,null,if,metadata,hash,length,0,file,info,metadata,hash,length,0,try,input,stream,stream,new,part,slice,stream,blob,container,file,info,bytes,ref,builder,builder,new,bytes,ref,builder,store,metadata,snapshot,hash,file,builder,stream,file,info,length,bytes,ref,hash,file,info,metadata,hash,assert,hash,length,0,hash,bytes,builder,bytes,hash,offset,0,hash,length,builder,length
BlobStoreRepository -> private static void maybeRecalculateMetadataHash(final BlobContainer blobContainer, final BlobStoreIndexShardSnapshot.FileInfo fileInfo, Store.MetadataSnapshot snapshot) throws Exception;1526574077;This is a BWC layer to ensure we update the snapshots metadata with the corresponding hashes before we compare them._The new logic for StoreFileMetaData reads the entire {@code .si} and {@code segments.n} files to strengthen the_comparison of the files on a per-segment / per-commit level.;private static void maybeRecalculateMetadataHash(final BlobContainer blobContainer, final BlobStoreIndexShardSnapshot.FileInfo fileInfo, Store.MetadataSnapshot snapshot) throws Exception {_        final StoreFileMetaData metadata__        if (fileInfo != null && (metadata = snapshot.get(fileInfo.physicalName())) != null) {_            if (metadata.hash().length > 0 && fileInfo.metadata().hash().length == 0) {_                _                _                _                try (InputStream stream = new PartSliceStream(blobContainer, fileInfo)) {_                    BytesRefBuilder builder = new BytesRefBuilder()__                    Store.MetadataSnapshot.hashFile(builder, stream, fileInfo.length())__                    BytesRef hash = fileInfo.metadata().hash()_ _                    assert hash.length == 0__                    hash.bytes = builder.bytes()__                    hash.offset = 0__                    hash.length = builder.length()__                }_            }_        }_    };this,is,a,bwc,layer,to,ensure,we,update,the,snapshots,metadata,with,the,corresponding,hashes,before,we,compare,them,the,new,logic,for,store,file,meta,data,reads,the,entire,code,si,and,code,segments,n,files,to,strengthen,the,comparison,of,the,files,on,a,per,segment,per,commit,level;private,static,void,maybe,recalculate,metadata,hash,final,blob,container,blob,container,final,blob,store,index,shard,snapshot,file,info,file,info,store,metadata,snapshot,snapshot,throws,exception,final,store,file,meta,data,metadata,if,file,info,null,metadata,snapshot,get,file,info,physical,name,null,if,metadata,hash,length,0,file,info,metadata,hash,length,0,try,input,stream,stream,new,part,slice,stream,blob,container,file,info,bytes,ref,builder,builder,new,bytes,ref,builder,store,metadata,snapshot,hash,file,builder,stream,file,info,length,bytes,ref,hash,file,info,metadata,hash,assert,hash,length,0,hash,bytes,builder,bytes,hash,offset,0,hash,length,builder,length
BlobStoreRepository -> private static void maybeRecalculateMetadataHash(final BlobContainer blobContainer, final BlobStoreIndexShardSnapshot.FileInfo fileInfo, Store.MetadataSnapshot snapshot) throws Exception;1527583663;This is a BWC layer to ensure we update the snapshots metadata with the corresponding hashes before we compare them._The new logic for StoreFileMetaData reads the entire {@code .si} and {@code segments.n} files to strengthen the_comparison of the files on a per-segment / per-commit level.;private static void maybeRecalculateMetadataHash(final BlobContainer blobContainer, final BlobStoreIndexShardSnapshot.FileInfo fileInfo, Store.MetadataSnapshot snapshot) throws Exception {_        final StoreFileMetaData metadata__        if (fileInfo != null && (metadata = snapshot.get(fileInfo.physicalName())) != null) {_            if (metadata.hash().length > 0 && fileInfo.metadata().hash().length == 0) {_                _                _                _                try (InputStream stream = new PartSliceStream(blobContainer, fileInfo)) {_                    BytesRefBuilder builder = new BytesRefBuilder()__                    Store.MetadataSnapshot.hashFile(builder, stream, fileInfo.length())__                    BytesRef hash = fileInfo.metadata().hash()_ _                    assert hash.length == 0__                    hash.bytes = builder.bytes()__                    hash.offset = 0__                    hash.length = builder.length()__                }_            }_        }_    };this,is,a,bwc,layer,to,ensure,we,update,the,snapshots,metadata,with,the,corresponding,hashes,before,we,compare,them,the,new,logic,for,store,file,meta,data,reads,the,entire,code,si,and,code,segments,n,files,to,strengthen,the,comparison,of,the,files,on,a,per,segment,per,commit,level;private,static,void,maybe,recalculate,metadata,hash,final,blob,container,blob,container,final,blob,store,index,shard,snapshot,file,info,file,info,store,metadata,snapshot,snapshot,throws,exception,final,store,file,meta,data,metadata,if,file,info,null,metadata,snapshot,get,file,info,physical,name,null,if,metadata,hash,length,0,file,info,metadata,hash,length,0,try,input,stream,stream,new,part,slice,stream,blob,container,file,info,bytes,ref,builder,builder,new,bytes,ref,builder,store,metadata,snapshot,hash,file,builder,stream,file,info,length,bytes,ref,hash,file,info,metadata,hash,assert,hash,length,0,hash,bytes,builder,bytes,hash,offset,0,hash,length,builder,length
BlobStoreRepository -> private static void maybeRecalculateMetadataHash(final BlobContainer blobContainer, final BlobStoreIndexShardSnapshot.FileInfo fileInfo, Store.MetadataSnapshot snapshot) throws Exception;1528211342;This is a BWC layer to ensure we update the snapshots metadata with the corresponding hashes before we compare them._The new logic for StoreFileMetaData reads the entire {@code .si} and {@code segments.n} files to strengthen the_comparison of the files on a per-segment / per-commit level.;private static void maybeRecalculateMetadataHash(final BlobContainer blobContainer, final BlobStoreIndexShardSnapshot.FileInfo fileInfo, Store.MetadataSnapshot snapshot) throws Exception {_        final StoreFileMetaData metadata__        if (fileInfo != null && (metadata = snapshot.get(fileInfo.physicalName())) != null) {_            if (metadata.hash().length > 0 && fileInfo.metadata().hash().length == 0) {_                _                _                _                try (InputStream stream = new PartSliceStream(blobContainer, fileInfo)) {_                    BytesRefBuilder builder = new BytesRefBuilder()__                    Store.MetadataSnapshot.hashFile(builder, stream, fileInfo.length())__                    BytesRef hash = fileInfo.metadata().hash()_ _                    assert hash.length == 0__                    hash.bytes = builder.bytes()__                    hash.offset = 0__                    hash.length = builder.length()__                }_            }_        }_    };this,is,a,bwc,layer,to,ensure,we,update,the,snapshots,metadata,with,the,corresponding,hashes,before,we,compare,them,the,new,logic,for,store,file,meta,data,reads,the,entire,code,si,and,code,segments,n,files,to,strengthen,the,comparison,of,the,files,on,a,per,segment,per,commit,level;private,static,void,maybe,recalculate,metadata,hash,final,blob,container,blob,container,final,blob,store,index,shard,snapshot,file,info,file,info,store,metadata,snapshot,snapshot,throws,exception,final,store,file,meta,data,metadata,if,file,info,null,metadata,snapshot,get,file,info,physical,name,null,if,metadata,hash,length,0,file,info,metadata,hash,length,0,try,input,stream,stream,new,part,slice,stream,blob,container,file,info,bytes,ref,builder,builder,new,bytes,ref,builder,store,metadata,snapshot,hash,file,builder,stream,file,info,length,bytes,ref,hash,file,info,metadata,hash,assert,hash,length,0,hash,bytes,builder,bytes,hash,offset,0,hash,length,builder,length
BlobStoreRepository -> private static void maybeRecalculateMetadataHash(final BlobContainer blobContainer, final BlobStoreIndexShardSnapshot.FileInfo fileInfo, Store.MetadataSnapshot snapshot) throws Exception;1531179852;This is a BWC layer to ensure we update the snapshots metadata with the corresponding hashes before we compare them._The new logic for StoreFileMetaData reads the entire {@code .si} and {@code segments.n} files to strengthen the_comparison of the files on a per-segment / per-commit level.;private static void maybeRecalculateMetadataHash(final BlobContainer blobContainer, final BlobStoreIndexShardSnapshot.FileInfo fileInfo, Store.MetadataSnapshot snapshot) throws Exception {_        final StoreFileMetaData metadata__        if (fileInfo != null && (metadata = snapshot.get(fileInfo.physicalName())) != null) {_            if (metadata.hash().length > 0 && fileInfo.metadata().hash().length == 0) {_                _                _                _                try (InputStream stream = new PartSliceStream(blobContainer, fileInfo)) {_                    BytesRefBuilder builder = new BytesRefBuilder()__                    Store.MetadataSnapshot.hashFile(builder, stream, fileInfo.length())__                    BytesRef hash = fileInfo.metadata().hash()_ _                    assert hash.length == 0__                    hash.bytes = builder.bytes()__                    hash.offset = 0__                    hash.length = builder.length()__                }_            }_        }_    };this,is,a,bwc,layer,to,ensure,we,update,the,snapshots,metadata,with,the,corresponding,hashes,before,we,compare,them,the,new,logic,for,store,file,meta,data,reads,the,entire,code,si,and,code,segments,n,files,to,strengthen,the,comparison,of,the,files,on,a,per,segment,per,commit,level;private,static,void,maybe,recalculate,metadata,hash,final,blob,container,blob,container,final,blob,store,index,shard,snapshot,file,info,file,info,store,metadata,snapshot,snapshot,throws,exception,final,store,file,meta,data,metadata,if,file,info,null,metadata,snapshot,get,file,info,physical,name,null,if,metadata,hash,length,0,file,info,metadata,hash,length,0,try,input,stream,stream,new,part,slice,stream,blob,container,file,info,bytes,ref,builder,builder,new,bytes,ref,builder,store,metadata,snapshot,hash,file,builder,stream,file,info,length,bytes,ref,hash,file,info,metadata,hash,assert,hash,length,0,hash,bytes,builder,bytes,hash,offset,0,hash,length,builder,length
BlobStoreRepository -> private static void maybeRecalculateMetadataHash(final BlobContainer blobContainer, final BlobStoreIndexShardSnapshot.FileInfo fileInfo, Store.MetadataSnapshot snapshot) throws Exception;1531729807;This is a BWC layer to ensure we update the snapshots metadata with the corresponding hashes before we compare them._The new logic for StoreFileMetaData reads the entire {@code .si} and {@code segments.n} files to strengthen the_comparison of the files on a per-segment / per-commit level.;private static void maybeRecalculateMetadataHash(final BlobContainer blobContainer, final BlobStoreIndexShardSnapshot.FileInfo fileInfo, Store.MetadataSnapshot snapshot) throws Exception {_        final StoreFileMetaData metadata__        if (fileInfo != null && (metadata = snapshot.get(fileInfo.physicalName())) != null) {_            if (metadata.hash().length > 0 && fileInfo.metadata().hash().length == 0) {_                _                _                _                try (InputStream stream = new PartSliceStream(blobContainer, fileInfo)) {_                    BytesRefBuilder builder = new BytesRefBuilder()__                    Store.MetadataSnapshot.hashFile(builder, stream, fileInfo.length())__                    BytesRef hash = fileInfo.metadata().hash()_ _                    assert hash.length == 0__                    hash.bytes = builder.bytes()__                    hash.offset = 0__                    hash.length = builder.length()__                }_            }_        }_    };this,is,a,bwc,layer,to,ensure,we,update,the,snapshots,metadata,with,the,corresponding,hashes,before,we,compare,them,the,new,logic,for,store,file,meta,data,reads,the,entire,code,si,and,code,segments,n,files,to,strengthen,the,comparison,of,the,files,on,a,per,segment,per,commit,level;private,static,void,maybe,recalculate,metadata,hash,final,blob,container,blob,container,final,blob,store,index,shard,snapshot,file,info,file,info,store,metadata,snapshot,snapshot,throws,exception,final,store,file,meta,data,metadata,if,file,info,null,metadata,snapshot,get,file,info,physical,name,null,if,metadata,hash,length,0,file,info,metadata,hash,length,0,try,input,stream,stream,new,part,slice,stream,blob,container,file,info,bytes,ref,builder,builder,new,bytes,ref,builder,store,metadata,snapshot,hash,file,builder,stream,file,info,length,bytes,ref,hash,file,info,metadata,hash,assert,hash,length,0,hash,bytes,builder,bytes,hash,offset,0,hash,length,builder,length
BlobStoreRepository -> private static void maybeRecalculateMetadataHash(final BlobContainer blobContainer, final BlobStoreIndexShardSnapshot.FileInfo fileInfo, Store.MetadataSnapshot snapshot) throws Exception;1532685069;This is a BWC layer to ensure we update the snapshots metadata with the corresponding hashes before we compare them._The new logic for StoreFileMetaData reads the entire {@code .si} and {@code segments.n} files to strengthen the_comparison of the files on a per-segment / per-commit level.;private static void maybeRecalculateMetadataHash(final BlobContainer blobContainer, final BlobStoreIndexShardSnapshot.FileInfo fileInfo, Store.MetadataSnapshot snapshot) throws Exception {_        final StoreFileMetaData metadata__        if (fileInfo != null && (metadata = snapshot.get(fileInfo.physicalName())) != null) {_            if (metadata.hash().length > 0 && fileInfo.metadata().hash().length == 0) {_                _                _                _                try (InputStream stream = new PartSliceStream(blobContainer, fileInfo)) {_                    BytesRefBuilder builder = new BytesRefBuilder()__                    Store.MetadataSnapshot.hashFile(builder, stream, fileInfo.length())__                    BytesRef hash = fileInfo.metadata().hash()_ _                    assert hash.length == 0__                    hash.bytes = builder.bytes()__                    hash.offset = 0__                    hash.length = builder.length()__                }_            }_        }_    };this,is,a,bwc,layer,to,ensure,we,update,the,snapshots,metadata,with,the,corresponding,hashes,before,we,compare,them,the,new,logic,for,store,file,meta,data,reads,the,entire,code,si,and,code,segments,n,files,to,strengthen,the,comparison,of,the,files,on,a,per,segment,per,commit,level;private,static,void,maybe,recalculate,metadata,hash,final,blob,container,blob,container,final,blob,store,index,shard,snapshot,file,info,file,info,store,metadata,snapshot,snapshot,throws,exception,final,store,file,meta,data,metadata,if,file,info,null,metadata,snapshot,get,file,info,physical,name,null,if,metadata,hash,length,0,file,info,metadata,hash,length,0,try,input,stream,stream,new,part,slice,stream,blob,container,file,info,bytes,ref,builder,builder,new,bytes,ref,builder,store,metadata,snapshot,hash,file,builder,stream,file,info,length,bytes,ref,hash,file,info,metadata,hash,assert,hash,length,0,hash,bytes,builder,bytes,hash,offset,0,hash,length,builder,length
BlobStoreRepository -> private static void maybeRecalculateMetadataHash(final BlobContainer blobContainer, final BlobStoreIndexShardSnapshot.FileInfo fileInfo, Store.MetadataSnapshot snapshot) throws Exception;1535139672;This is a BWC layer to ensure we update the snapshots metadata with the corresponding hashes before we compare them._The new logic for StoreFileMetaData reads the entire {@code .si} and {@code segments.n} files to strengthen the_comparison of the files on a per-segment / per-commit level.;private static void maybeRecalculateMetadataHash(final BlobContainer blobContainer, final BlobStoreIndexShardSnapshot.FileInfo fileInfo, Store.MetadataSnapshot snapshot) throws Exception {_        final StoreFileMetaData metadata__        if (fileInfo != null && (metadata = snapshot.get(fileInfo.physicalName())) != null) {_            if (metadata.hash().length > 0 && fileInfo.metadata().hash().length == 0) {_                _                _                _                try (InputStream stream = new PartSliceStream(blobContainer, fileInfo)) {_                    BytesRefBuilder builder = new BytesRefBuilder()__                    Store.MetadataSnapshot.hashFile(builder, stream, fileInfo.length())__                    BytesRef hash = fileInfo.metadata().hash()_ _                    assert hash.length == 0__                    hash.bytes = builder.bytes()__                    hash.offset = 0__                    hash.length = builder.length()__                }_            }_        }_    };this,is,a,bwc,layer,to,ensure,we,update,the,snapshots,metadata,with,the,corresponding,hashes,before,we,compare,them,the,new,logic,for,store,file,meta,data,reads,the,entire,code,si,and,code,segments,n,files,to,strengthen,the,comparison,of,the,files,on,a,per,segment,per,commit,level;private,static,void,maybe,recalculate,metadata,hash,final,blob,container,blob,container,final,blob,store,index,shard,snapshot,file,info,file,info,store,metadata,snapshot,snapshot,throws,exception,final,store,file,meta,data,metadata,if,file,info,null,metadata,snapshot,get,file,info,physical,name,null,if,metadata,hash,length,0,file,info,metadata,hash,length,0,try,input,stream,stream,new,part,slice,stream,blob,container,file,info,bytes,ref,builder,builder,new,bytes,ref,builder,store,metadata,snapshot,hash,file,builder,stream,file,info,length,bytes,ref,hash,file,info,metadata,hash,assert,hash,length,0,hash,bytes,builder,bytes,hash,offset,0,hash,length,builder,length
BlobStoreRepository -> private static void maybeRecalculateMetadataHash(final BlobContainer blobContainer, final BlobStoreIndexShardSnapshot.FileInfo fileInfo, Store.MetadataSnapshot snapshot) throws Exception;1535723122;This is a BWC layer to ensure we update the snapshots metadata with the corresponding hashes before we compare them._The new logic for StoreFileMetaData reads the entire {@code .si} and {@code segments.n} files to strengthen the_comparison of the files on a per-segment / per-commit level.;private static void maybeRecalculateMetadataHash(final BlobContainer blobContainer, final BlobStoreIndexShardSnapshot.FileInfo fileInfo, Store.MetadataSnapshot snapshot) throws Exception {_        final StoreFileMetaData metadata__        if (fileInfo != null && (metadata = snapshot.get(fileInfo.physicalName())) != null) {_            if (metadata.hash().length > 0 && fileInfo.metadata().hash().length == 0) {_                _                _                _                try (InputStream stream = new PartSliceStream(blobContainer, fileInfo)) {_                    BytesRefBuilder builder = new BytesRefBuilder()__                    Store.MetadataSnapshot.hashFile(builder, stream, fileInfo.length())__                    BytesRef hash = fileInfo.metadata().hash()_ _                    assert hash.length == 0__                    hash.bytes = builder.bytes()__                    hash.offset = 0__                    hash.length = builder.length()__                }_            }_        }_    };this,is,a,bwc,layer,to,ensure,we,update,the,snapshots,metadata,with,the,corresponding,hashes,before,we,compare,them,the,new,logic,for,store,file,meta,data,reads,the,entire,code,si,and,code,segments,n,files,to,strengthen,the,comparison,of,the,files,on,a,per,segment,per,commit,level;private,static,void,maybe,recalculate,metadata,hash,final,blob,container,blob,container,final,blob,store,index,shard,snapshot,file,info,file,info,store,metadata,snapshot,snapshot,throws,exception,final,store,file,meta,data,metadata,if,file,info,null,metadata,snapshot,get,file,info,physical,name,null,if,metadata,hash,length,0,file,info,metadata,hash,length,0,try,input,stream,stream,new,part,slice,stream,blob,container,file,info,bytes,ref,builder,builder,new,bytes,ref,builder,store,metadata,snapshot,hash,file,builder,stream,file,info,length,bytes,ref,hash,file,info,metadata,hash,assert,hash,length,0,hash,bytes,builder,bytes,hash,offset,0,hash,length,builder,length
BlobStoreRepository -> private static void maybeRecalculateMetadataHash(final BlobContainer blobContainer, final BlobStoreIndexShardSnapshot.FileInfo fileInfo, Store.MetadataSnapshot snapshot) throws Exception;1536314350;This is a BWC layer to ensure we update the snapshots metadata with the corresponding hashes before we compare them._The new logic for StoreFileMetaData reads the entire {@code .si} and {@code segments.n} files to strengthen the_comparison of the files on a per-segment / per-commit level.;private static void maybeRecalculateMetadataHash(final BlobContainer blobContainer, final BlobStoreIndexShardSnapshot.FileInfo fileInfo, Store.MetadataSnapshot snapshot) throws Exception {_        final StoreFileMetaData metadata__        if (fileInfo != null && (metadata = snapshot.get(fileInfo.physicalName())) != null) {_            if (metadata.hash().length > 0 && fileInfo.metadata().hash().length == 0) {_                _                _                _                try (InputStream stream = new PartSliceStream(blobContainer, fileInfo)) {_                    BytesRefBuilder builder = new BytesRefBuilder()__                    Store.MetadataSnapshot.hashFile(builder, stream, fileInfo.length())__                    BytesRef hash = fileInfo.metadata().hash()_ _                    assert hash.length == 0__                    hash.bytes = builder.bytes()__                    hash.offset = 0__                    hash.length = builder.length()__                }_            }_        }_    };this,is,a,bwc,layer,to,ensure,we,update,the,snapshots,metadata,with,the,corresponding,hashes,before,we,compare,them,the,new,logic,for,store,file,meta,data,reads,the,entire,code,si,and,code,segments,n,files,to,strengthen,the,comparison,of,the,files,on,a,per,segment,per,commit,level;private,static,void,maybe,recalculate,metadata,hash,final,blob,container,blob,container,final,blob,store,index,shard,snapshot,file,info,file,info,store,metadata,snapshot,snapshot,throws,exception,final,store,file,meta,data,metadata,if,file,info,null,metadata,snapshot,get,file,info,physical,name,null,if,metadata,hash,length,0,file,info,metadata,hash,length,0,try,input,stream,stream,new,part,slice,stream,blob,container,file,info,bytes,ref,builder,builder,new,bytes,ref,builder,store,metadata,snapshot,hash,file,builder,stream,file,info,length,bytes,ref,hash,file,info,metadata,hash,assert,hash,length,0,hash,bytes,builder,bytes,hash,offset,0,hash,length,builder,length
BlobStoreRepository -> private static void maybeRecalculateMetadataHash(final BlobContainer blobContainer, final BlobStoreIndexShardSnapshot.FileInfo fileInfo, Store.MetadataSnapshot snapshot) throws Exception;1536828374;This is a BWC layer to ensure we update the snapshots metadata with the corresponding hashes before we compare them._The new logic for StoreFileMetaData reads the entire {@code .si} and {@code segments.n} files to strengthen the_comparison of the files on a per-segment / per-commit level.;private static void maybeRecalculateMetadataHash(final BlobContainer blobContainer, final BlobStoreIndexShardSnapshot.FileInfo fileInfo, Store.MetadataSnapshot snapshot) throws Exception {_        final StoreFileMetaData metadata__        if (fileInfo != null && (metadata = snapshot.get(fileInfo.physicalName())) != null) {_            if (metadata.hash().length > 0 && fileInfo.metadata().hash().length == 0) {_                _                _                _                try (InputStream stream = new PartSliceStream(blobContainer, fileInfo)) {_                    BytesRefBuilder builder = new BytesRefBuilder()__                    Store.MetadataSnapshot.hashFile(builder, stream, fileInfo.length())__                    BytesRef hash = fileInfo.metadata().hash()_ _                    assert hash.length == 0__                    hash.bytes = builder.bytes()__                    hash.offset = 0__                    hash.length = builder.length()__                }_            }_        }_    };this,is,a,bwc,layer,to,ensure,we,update,the,snapshots,metadata,with,the,corresponding,hashes,before,we,compare,them,the,new,logic,for,store,file,meta,data,reads,the,entire,code,si,and,code,segments,n,files,to,strengthen,the,comparison,of,the,files,on,a,per,segment,per,commit,level;private,static,void,maybe,recalculate,metadata,hash,final,blob,container,blob,container,final,blob,store,index,shard,snapshot,file,info,file,info,store,metadata,snapshot,snapshot,throws,exception,final,store,file,meta,data,metadata,if,file,info,null,metadata,snapshot,get,file,info,physical,name,null,if,metadata,hash,length,0,file,info,metadata,hash,length,0,try,input,stream,stream,new,part,slice,stream,blob,container,file,info,bytes,ref,builder,builder,new,bytes,ref,builder,store,metadata,snapshot,hash,file,builder,stream,file,info,length,bytes,ref,hash,file,info,metadata,hash,assert,hash,length,0,hash,bytes,builder,bytes,hash,offset,0,hash,length,builder,length
BlobStoreRepository -> private static void maybeRecalculateMetadataHash(final BlobContainer blobContainer, final BlobStoreIndexShardSnapshot.FileInfo fileInfo, Store.MetadataSnapshot snapshot) throws Exception;1541008027;This is a BWC layer to ensure we update the snapshots metadata with the corresponding hashes before we compare them._The new logic for StoreFileMetaData reads the entire {@code .si} and {@code segments.n} files to strengthen the_comparison of the files on a per-segment / per-commit level.;private static void maybeRecalculateMetadataHash(final BlobContainer blobContainer, final BlobStoreIndexShardSnapshot.FileInfo fileInfo, Store.MetadataSnapshot snapshot) throws Exception {_        final StoreFileMetaData metadata__        if (fileInfo != null && (metadata = snapshot.get(fileInfo.physicalName())) != null) {_            if (metadata.hash().length > 0 && fileInfo.metadata().hash().length == 0) {_                _                _                _                try (InputStream stream = new PartSliceStream(blobContainer, fileInfo)) {_                    BytesRefBuilder builder = new BytesRefBuilder()__                    Store.MetadataSnapshot.hashFile(builder, stream, fileInfo.length())__                    BytesRef hash = fileInfo.metadata().hash()_ _                    assert hash.length == 0__                    hash.bytes = builder.bytes()__                    hash.offset = 0__                    hash.length = builder.length()__                }_            }_        }_    };this,is,a,bwc,layer,to,ensure,we,update,the,snapshots,metadata,with,the,corresponding,hashes,before,we,compare,them,the,new,logic,for,store,file,meta,data,reads,the,entire,code,si,and,code,segments,n,files,to,strengthen,the,comparison,of,the,files,on,a,per,segment,per,commit,level;private,static,void,maybe,recalculate,metadata,hash,final,blob,container,blob,container,final,blob,store,index,shard,snapshot,file,info,file,info,store,metadata,snapshot,snapshot,throws,exception,final,store,file,meta,data,metadata,if,file,info,null,metadata,snapshot,get,file,info,physical,name,null,if,metadata,hash,length,0,file,info,metadata,hash,length,0,try,input,stream,stream,new,part,slice,stream,blob,container,file,info,bytes,ref,builder,builder,new,bytes,ref,builder,store,metadata,snapshot,hash,file,builder,stream,file,info,length,bytes,ref,hash,file,info,metadata,hash,assert,hash,length,0,hash,bytes,builder,bytes,hash,offset,0,hash,length,builder,length
BlobStoreRepository -> private static void maybeRecalculateMetadataHash(final BlobContainer blobContainer, final BlobStoreIndexShardSnapshot.FileInfo fileInfo, Store.MetadataSnapshot snapshot) throws Exception;1542646292;This is a BWC layer to ensure we update the snapshots metadata with the corresponding hashes before we compare them._The new logic for StoreFileMetaData reads the entire {@code .si} and {@code segments.n} files to strengthen the_comparison of the files on a per-segment / per-commit level.;private static void maybeRecalculateMetadataHash(final BlobContainer blobContainer, final BlobStoreIndexShardSnapshot.FileInfo fileInfo, Store.MetadataSnapshot snapshot) throws Exception {_        final StoreFileMetaData metadata__        if (fileInfo != null && (metadata = snapshot.get(fileInfo.physicalName())) != null) {_            if (metadata.hash().length > 0 && fileInfo.metadata().hash().length == 0) {_                _                _                _                try (InputStream stream = new PartSliceStream(blobContainer, fileInfo)) {_                    BytesRefBuilder builder = new BytesRefBuilder()__                    Store.MetadataSnapshot.hashFile(builder, stream, fileInfo.length())__                    BytesRef hash = fileInfo.metadata().hash()_ _                    assert hash.length == 0__                    hash.bytes = builder.bytes()__                    hash.offset = 0__                    hash.length = builder.length()__                }_            }_        }_    };this,is,a,bwc,layer,to,ensure,we,update,the,snapshots,metadata,with,the,corresponding,hashes,before,we,compare,them,the,new,logic,for,store,file,meta,data,reads,the,entire,code,si,and,code,segments,n,files,to,strengthen,the,comparison,of,the,files,on,a,per,segment,per,commit,level;private,static,void,maybe,recalculate,metadata,hash,final,blob,container,blob,container,final,blob,store,index,shard,snapshot,file,info,file,info,store,metadata,snapshot,snapshot,throws,exception,final,store,file,meta,data,metadata,if,file,info,null,metadata,snapshot,get,file,info,physical,name,null,if,metadata,hash,length,0,file,info,metadata,hash,length,0,try,input,stream,stream,new,part,slice,stream,blob,container,file,info,bytes,ref,builder,builder,new,bytes,ref,builder,store,metadata,snapshot,hash,file,builder,stream,file,info,length,bytes,ref,hash,file,info,metadata,hash,assert,hash,length,0,hash,bytes,builder,bytes,hash,offset,0,hash,length,builder,length
BlobStoreRepository -> private static void maybeRecalculateMetadataHash(final BlobContainer blobContainer, final BlobStoreIndexShardSnapshot.FileInfo fileInfo, Store.MetadataSnapshot snapshot) throws Exception;1542980705;This is a BWC layer to ensure we update the snapshots metadata with the corresponding hashes before we compare them._The new logic for StoreFileMetaData reads the entire {@code .si} and {@code segments.n} files to strengthen the_comparison of the files on a per-segment / per-commit level.;private static void maybeRecalculateMetadataHash(final BlobContainer blobContainer, final BlobStoreIndexShardSnapshot.FileInfo fileInfo, Store.MetadataSnapshot snapshot) throws Exception {_        final StoreFileMetaData metadata__        if (fileInfo != null && (metadata = snapshot.get(fileInfo.physicalName())) != null) {_            if (metadata.hash().length > 0 && fileInfo.metadata().hash().length == 0) {_                _                _                _                try (InputStream stream = new PartSliceStream(blobContainer, fileInfo)) {_                    BytesRefBuilder builder = new BytesRefBuilder()__                    Store.MetadataSnapshot.hashFile(builder, stream, fileInfo.length())__                    BytesRef hash = fileInfo.metadata().hash()_ _                    assert hash.length == 0__                    hash.bytes = builder.bytes()__                    hash.offset = 0__                    hash.length = builder.length()__                }_            }_        }_    };this,is,a,bwc,layer,to,ensure,we,update,the,snapshots,metadata,with,the,corresponding,hashes,before,we,compare,them,the,new,logic,for,store,file,meta,data,reads,the,entire,code,si,and,code,segments,n,files,to,strengthen,the,comparison,of,the,files,on,a,per,segment,per,commit,level;private,static,void,maybe,recalculate,metadata,hash,final,blob,container,blob,container,final,blob,store,index,shard,snapshot,file,info,file,info,store,metadata,snapshot,snapshot,throws,exception,final,store,file,meta,data,metadata,if,file,info,null,metadata,snapshot,get,file,info,physical,name,null,if,metadata,hash,length,0,file,info,metadata,hash,length,0,try,input,stream,stream,new,part,slice,stream,blob,container,file,info,bytes,ref,builder,builder,new,bytes,ref,builder,store,metadata,snapshot,hash,file,builder,stream,file,info,length,bytes,ref,hash,file,info,metadata,hash,assert,hash,length,0,hash,bytes,builder,bytes,hash,offset,0,hash,length,builder,length
BlobStoreRepository -> private static void maybeRecalculateMetadataHash(final BlobContainer blobContainer, final BlobStoreIndexShardSnapshot.FileInfo fileInfo, Store.MetadataSnapshot snapshot) throws Exception;1543831870;This is a BWC layer to ensure we update the snapshots metadata with the corresponding hashes before we compare them._The new logic for StoreFileMetaData reads the entire {@code .si} and {@code segments.n} files to strengthen the_comparison of the files on a per-segment / per-commit level.;private static void maybeRecalculateMetadataHash(final BlobContainer blobContainer, final BlobStoreIndexShardSnapshot.FileInfo fileInfo, Store.MetadataSnapshot snapshot) throws Exception {_        final StoreFileMetaData metadata__        if (fileInfo != null && (metadata = snapshot.get(fileInfo.physicalName())) != null) {_            if (metadata.hash().length > 0 && fileInfo.metadata().hash().length == 0) {_                _                _                _                try (InputStream stream = new PartSliceStream(blobContainer, fileInfo)) {_                    BytesRefBuilder builder = new BytesRefBuilder()__                    Store.MetadataSnapshot.hashFile(builder, stream, fileInfo.length())__                    BytesRef hash = fileInfo.metadata().hash()_ _                    assert hash.length == 0__                    hash.bytes = builder.bytes()__                    hash.offset = 0__                    hash.length = builder.length()__                }_            }_        }_    };this,is,a,bwc,layer,to,ensure,we,update,the,snapshots,metadata,with,the,corresponding,hashes,before,we,compare,them,the,new,logic,for,store,file,meta,data,reads,the,entire,code,si,and,code,segments,n,files,to,strengthen,the,comparison,of,the,files,on,a,per,segment,per,commit,level;private,static,void,maybe,recalculate,metadata,hash,final,blob,container,blob,container,final,blob,store,index,shard,snapshot,file,info,file,info,store,metadata,snapshot,snapshot,throws,exception,final,store,file,meta,data,metadata,if,file,info,null,metadata,snapshot,get,file,info,physical,name,null,if,metadata,hash,length,0,file,info,metadata,hash,length,0,try,input,stream,stream,new,part,slice,stream,blob,container,file,info,bytes,ref,builder,builder,new,bytes,ref,builder,store,metadata,snapshot,hash,file,builder,stream,file,info,length,bytes,ref,hash,file,info,metadata,hash,assert,hash,length,0,hash,bytes,builder,bytes,hash,offset,0,hash,length,builder,length
BlobStoreRepository -> private static void maybeRecalculateMetadataHash(final BlobContainer blobContainer, final BlobStoreIndexShardSnapshot.FileInfo fileInfo, Store.MetadataSnapshot snapshot) throws Exception;1543942400;This is a BWC layer to ensure we update the snapshots metadata with the corresponding hashes before we compare them._The new logic for StoreFileMetaData reads the entire {@code .si} and {@code segments.n} files to strengthen the_comparison of the files on a per-segment / per-commit level.;private static void maybeRecalculateMetadataHash(final BlobContainer blobContainer, final BlobStoreIndexShardSnapshot.FileInfo fileInfo, Store.MetadataSnapshot snapshot) throws Exception {_        final StoreFileMetaData metadata__        if (fileInfo != null && (metadata = snapshot.get(fileInfo.physicalName())) != null) {_            if (metadata.hash().length > 0 && fileInfo.metadata().hash().length == 0) {_                _                _                _                try (InputStream stream = new PartSliceStream(blobContainer, fileInfo)) {_                    BytesRefBuilder builder = new BytesRefBuilder()__                    Store.MetadataSnapshot.hashFile(builder, stream, fileInfo.length())__                    BytesRef hash = fileInfo.metadata().hash()_ _                    assert hash.length == 0__                    hash.bytes = builder.bytes()__                    hash.offset = 0__                    hash.length = builder.length()__                }_            }_        }_    };this,is,a,bwc,layer,to,ensure,we,update,the,snapshots,metadata,with,the,corresponding,hashes,before,we,compare,them,the,new,logic,for,store,file,meta,data,reads,the,entire,code,si,and,code,segments,n,files,to,strengthen,the,comparison,of,the,files,on,a,per,segment,per,commit,level;private,static,void,maybe,recalculate,metadata,hash,final,blob,container,blob,container,final,blob,store,index,shard,snapshot,file,info,file,info,store,metadata,snapshot,snapshot,throws,exception,final,store,file,meta,data,metadata,if,file,info,null,metadata,snapshot,get,file,info,physical,name,null,if,metadata,hash,length,0,file,info,metadata,hash,length,0,try,input,stream,stream,new,part,slice,stream,blob,container,file,info,bytes,ref,builder,builder,new,bytes,ref,builder,store,metadata,snapshot,hash,file,builder,stream,file,info,length,bytes,ref,hash,file,info,metadata,hash,assert,hash,length,0,hash,bytes,builder,bytes,hash,offset,0,hash,length,builder,length
BlobStoreRepository -> Context -> public void delete();1524684173;Delete shard snapshot;public void delete() {_            final Map<String, BlobMetaData> blobs__            try {_                blobs = blobContainer.listBlobs()__            } catch (IOException e) {_                throw new IndexShardSnapshotException(shardId, "Failed to list content of gateway", e)__            }__            Tuple<BlobStoreIndexShardSnapshots, Integer> tuple = buildBlobStoreIndexShardSnapshots(blobs)__            BlobStoreIndexShardSnapshots snapshots = tuple.v1()__            int fileListGeneration = tuple.v2()___            try {_                indexShardSnapshotFormat(version).delete(blobContainer, snapshotId.getUUID())__            } catch (IOException e) {_                logger.debug("[{}] [{}] failed to delete shard snapshot file", shardId, snapshotId)__            }__            _            List<SnapshotFiles> newSnapshotsList = new ArrayList<>()__            for (SnapshotFiles point : snapshots) {_                if (!point.snapshot().equals(snapshotId.getName())) {_                    newSnapshotsList.add(point)__                }_            }_            _            finalize(newSnapshotsList, fileListGeneration + 1, blobs)__        };delete,shard,snapshot;public,void,delete,final,map,string,blob,meta,data,blobs,try,blobs,blob,container,list,blobs,catch,ioexception,e,throw,new,index,shard,snapshot,exception,shard,id,failed,to,list,content,of,gateway,e,tuple,blob,store,index,shard,snapshots,integer,tuple,build,blob,store,index,shard,snapshots,blobs,blob,store,index,shard,snapshots,snapshots,tuple,v1,int,file,list,generation,tuple,v2,try,index,shard,snapshot,format,version,delete,blob,container,snapshot,id,get,uuid,catch,ioexception,e,logger,debug,failed,to,delete,shard,snapshot,file,shard,id,snapshot,id,list,snapshot,files,new,snapshots,list,new,array,list,for,snapshot,files,point,snapshots,if,point,snapshot,equals,snapshot,id,get,name,new,snapshots,list,add,point,finalize,new,snapshots,list,file,list,generation,1,blobs
BlobStoreRepository -> Context -> public void delete();1525334055;Delete shard snapshot;public void delete() {_            final Map<String, BlobMetaData> blobs__            try {_                blobs = blobContainer.listBlobs()__            } catch (IOException e) {_                throw new IndexShardSnapshotException(shardId, "Failed to list content of gateway", e)__            }__            Tuple<BlobStoreIndexShardSnapshots, Integer> tuple = buildBlobStoreIndexShardSnapshots(blobs)__            BlobStoreIndexShardSnapshots snapshots = tuple.v1()__            int fileListGeneration = tuple.v2()___            try {_                indexShardSnapshotFormat(version).delete(blobContainer, snapshotId.getUUID())__            } catch (IOException e) {_                logger.debug("[{}] [{}] failed to delete shard snapshot file", shardId, snapshotId)__            }__            _            List<SnapshotFiles> newSnapshotsList = new ArrayList<>()__            for (SnapshotFiles point : snapshots) {_                if (!point.snapshot().equals(snapshotId.getName())) {_                    newSnapshotsList.add(point)__                }_            }_            _            finalize(newSnapshotsList, fileListGeneration + 1, blobs)__        };delete,shard,snapshot;public,void,delete,final,map,string,blob,meta,data,blobs,try,blobs,blob,container,list,blobs,catch,ioexception,e,throw,new,index,shard,snapshot,exception,shard,id,failed,to,list,content,of,gateway,e,tuple,blob,store,index,shard,snapshots,integer,tuple,build,blob,store,index,shard,snapshots,blobs,blob,store,index,shard,snapshots,snapshots,tuple,v1,int,file,list,generation,tuple,v2,try,index,shard,snapshot,format,version,delete,blob,container,snapshot,id,get,uuid,catch,ioexception,e,logger,debug,failed,to,delete,shard,snapshot,file,shard,id,snapshot,id,list,snapshot,files,new,snapshots,list,new,array,list,for,snapshot,files,point,snapshots,if,point,snapshot,equals,snapshot,id,get,name,new,snapshots,list,add,point,finalize,new,snapshots,list,file,list,generation,1,blobs
BlobStoreRepository -> Context -> public void delete();1525798020;Delete shard snapshot;public void delete() {_            final Map<String, BlobMetaData> blobs__            try {_                blobs = blobContainer.listBlobs()__            } catch (IOException e) {_                throw new IndexShardSnapshotException(shardId, "Failed to list content of gateway", e)__            }__            Tuple<BlobStoreIndexShardSnapshots, Integer> tuple = buildBlobStoreIndexShardSnapshots(blobs)__            BlobStoreIndexShardSnapshots snapshots = tuple.v1()__            int fileListGeneration = tuple.v2()___            try {_                indexShardSnapshotFormat(version).delete(blobContainer, snapshotId.getUUID())__            } catch (IOException e) {_                logger.debug("[{}] [{}] failed to delete shard snapshot file", shardId, snapshotId)__            }__            _            List<SnapshotFiles> newSnapshotsList = new ArrayList<>()__            for (SnapshotFiles point : snapshots) {_                if (!point.snapshot().equals(snapshotId.getName())) {_                    newSnapshotsList.add(point)__                }_            }_            _            finalize(newSnapshotsList, fileListGeneration + 1, blobs, "snapshot deletion [" + snapshotId + "]")__        };delete,shard,snapshot;public,void,delete,final,map,string,blob,meta,data,blobs,try,blobs,blob,container,list,blobs,catch,ioexception,e,throw,new,index,shard,snapshot,exception,shard,id,failed,to,list,content,of,gateway,e,tuple,blob,store,index,shard,snapshots,integer,tuple,build,blob,store,index,shard,snapshots,blobs,blob,store,index,shard,snapshots,snapshots,tuple,v1,int,file,list,generation,tuple,v2,try,index,shard,snapshot,format,version,delete,blob,container,snapshot,id,get,uuid,catch,ioexception,e,logger,debug,failed,to,delete,shard,snapshot,file,shard,id,snapshot,id,list,snapshot,files,new,snapshots,list,new,array,list,for,snapshot,files,point,snapshots,if,point,snapshot,equals,snapshot,id,get,name,new,snapshots,list,add,point,finalize,new,snapshots,list,file,list,generation,1,blobs,snapshot,deletion,snapshot,id
BlobStoreRepository -> Context -> public void delete();1526289033;Delete shard snapshot;public void delete() {_            final Map<String, BlobMetaData> blobs__            try {_                blobs = blobContainer.listBlobs()__            } catch (IOException e) {_                throw new IndexShardSnapshotException(shardId, "Failed to list content of gateway", e)__            }__            Tuple<BlobStoreIndexShardSnapshots, Integer> tuple = buildBlobStoreIndexShardSnapshots(blobs)__            BlobStoreIndexShardSnapshots snapshots = tuple.v1()__            int fileListGeneration = tuple.v2()___            try {_                indexShardSnapshotFormat(version).delete(blobContainer, snapshotId.getUUID())__            } catch (IOException e) {_                logger.debug("[{}] [{}] failed to delete shard snapshot file", shardId, snapshotId)__            }__            _            List<SnapshotFiles> newSnapshotsList = new ArrayList<>()__            for (SnapshotFiles point : snapshots) {_                if (!point.snapshot().equals(snapshotId.getName())) {_                    newSnapshotsList.add(point)__                }_            }_            _            finalize(newSnapshotsList, fileListGeneration + 1, blobs, "snapshot deletion [" + snapshotId + "]")__        };delete,shard,snapshot;public,void,delete,final,map,string,blob,meta,data,blobs,try,blobs,blob,container,list,blobs,catch,ioexception,e,throw,new,index,shard,snapshot,exception,shard,id,failed,to,list,content,of,gateway,e,tuple,blob,store,index,shard,snapshots,integer,tuple,build,blob,store,index,shard,snapshots,blobs,blob,store,index,shard,snapshots,snapshots,tuple,v1,int,file,list,generation,tuple,v2,try,index,shard,snapshot,format,version,delete,blob,container,snapshot,id,get,uuid,catch,ioexception,e,logger,debug,failed,to,delete,shard,snapshot,file,shard,id,snapshot,id,list,snapshot,files,new,snapshots,list,new,array,list,for,snapshot,files,point,snapshots,if,point,snapshot,equals,snapshot,id,get,name,new,snapshots,list,add,point,finalize,new,snapshots,list,file,list,generation,1,blobs,snapshot,deletion,snapshot,id
BlobStoreRepository -> Context -> public void delete();1526574077;Delete shard snapshot;public void delete() {_            final Map<String, BlobMetaData> blobs__            try {_                blobs = blobContainer.listBlobs()__            } catch (IOException e) {_                throw new IndexShardSnapshotException(shardId, "Failed to list content of gateway", e)__            }__            Tuple<BlobStoreIndexShardSnapshots, Integer> tuple = buildBlobStoreIndexShardSnapshots(blobs)__            BlobStoreIndexShardSnapshots snapshots = tuple.v1()__            int fileListGeneration = tuple.v2()___            try {_                indexShardSnapshotFormat(version).delete(blobContainer, snapshotId.getUUID())__            } catch (IOException e) {_                logger.debug("[{}] [{}] failed to delete shard snapshot file", shardId, snapshotId)__            }__            _            List<SnapshotFiles> newSnapshotsList = new ArrayList<>()__            for (SnapshotFiles point : snapshots) {_                if (!point.snapshot().equals(snapshotId.getName())) {_                    newSnapshotsList.add(point)__                }_            }_            _            finalize(newSnapshotsList, fileListGeneration + 1, blobs, "snapshot deletion [" + snapshotId + "]")__        };delete,shard,snapshot;public,void,delete,final,map,string,blob,meta,data,blobs,try,blobs,blob,container,list,blobs,catch,ioexception,e,throw,new,index,shard,snapshot,exception,shard,id,failed,to,list,content,of,gateway,e,tuple,blob,store,index,shard,snapshots,integer,tuple,build,blob,store,index,shard,snapshots,blobs,blob,store,index,shard,snapshots,snapshots,tuple,v1,int,file,list,generation,tuple,v2,try,index,shard,snapshot,format,version,delete,blob,container,snapshot,id,get,uuid,catch,ioexception,e,logger,debug,failed,to,delete,shard,snapshot,file,shard,id,snapshot,id,list,snapshot,files,new,snapshots,list,new,array,list,for,snapshot,files,point,snapshots,if,point,snapshot,equals,snapshot,id,get,name,new,snapshots,list,add,point,finalize,new,snapshots,list,file,list,generation,1,blobs,snapshot,deletion,snapshot,id
BlobStoreRepository -> Context -> public void delete();1527583663;Delete shard snapshot;public void delete() {_            final Map<String, BlobMetaData> blobs__            try {_                blobs = blobContainer.listBlobs()__            } catch (IOException e) {_                throw new IndexShardSnapshotException(shardId, "Failed to list content of gateway", e)__            }__            Tuple<BlobStoreIndexShardSnapshots, Integer> tuple = buildBlobStoreIndexShardSnapshots(blobs)__            BlobStoreIndexShardSnapshots snapshots = tuple.v1()__            int fileListGeneration = tuple.v2()___            try {_                indexShardSnapshotFormat(version).delete(blobContainer, snapshotId.getUUID())__            } catch (IOException e) {_                logger.debug("[{}] [{}] failed to delete shard snapshot file", shardId, snapshotId)__            }__            _            List<SnapshotFiles> newSnapshotsList = new ArrayList<>()__            for (SnapshotFiles point : snapshots) {_                if (!point.snapshot().equals(snapshotId.getName())) {_                    newSnapshotsList.add(point)__                }_            }_            _            finalize(newSnapshotsList, fileListGeneration + 1, blobs, "snapshot deletion [" + snapshotId + "]")__        };delete,shard,snapshot;public,void,delete,final,map,string,blob,meta,data,blobs,try,blobs,blob,container,list,blobs,catch,ioexception,e,throw,new,index,shard,snapshot,exception,shard,id,failed,to,list,content,of,gateway,e,tuple,blob,store,index,shard,snapshots,integer,tuple,build,blob,store,index,shard,snapshots,blobs,blob,store,index,shard,snapshots,snapshots,tuple,v1,int,file,list,generation,tuple,v2,try,index,shard,snapshot,format,version,delete,blob,container,snapshot,id,get,uuid,catch,ioexception,e,logger,debug,failed,to,delete,shard,snapshot,file,shard,id,snapshot,id,list,snapshot,files,new,snapshots,list,new,array,list,for,snapshot,files,point,snapshots,if,point,snapshot,equals,snapshot,id,get,name,new,snapshots,list,add,point,finalize,new,snapshots,list,file,list,generation,1,blobs,snapshot,deletion,snapshot,id
BlobStoreRepository -> Context -> public void delete();1528211342;Delete shard snapshot;public void delete() {_            final Map<String, BlobMetaData> blobs__            try {_                blobs = blobContainer.listBlobs()__            } catch (IOException e) {_                throw new IndexShardSnapshotException(shardId, "Failed to list content of gateway", e)__            }__            Tuple<BlobStoreIndexShardSnapshots, Integer> tuple = buildBlobStoreIndexShardSnapshots(blobs)__            BlobStoreIndexShardSnapshots snapshots = tuple.v1()__            int fileListGeneration = tuple.v2()___            try {_                indexShardSnapshotFormat(version).delete(blobContainer, snapshotId.getUUID())__            } catch (IOException e) {_                logger.debug("[{}] [{}] failed to delete shard snapshot file", shardId, snapshotId)__            }__            _            List<SnapshotFiles> newSnapshotsList = new ArrayList<>()__            for (SnapshotFiles point : snapshots) {_                if (!point.snapshot().equals(snapshotId.getName())) {_                    newSnapshotsList.add(point)__                }_            }_            _            finalize(newSnapshotsList, fileListGeneration + 1, blobs, "snapshot deletion [" + snapshotId + "]")__        };delete,shard,snapshot;public,void,delete,final,map,string,blob,meta,data,blobs,try,blobs,blob,container,list,blobs,catch,ioexception,e,throw,new,index,shard,snapshot,exception,shard,id,failed,to,list,content,of,gateway,e,tuple,blob,store,index,shard,snapshots,integer,tuple,build,blob,store,index,shard,snapshots,blobs,blob,store,index,shard,snapshots,snapshots,tuple,v1,int,file,list,generation,tuple,v2,try,index,shard,snapshot,format,version,delete,blob,container,snapshot,id,get,uuid,catch,ioexception,e,logger,debug,failed,to,delete,shard,snapshot,file,shard,id,snapshot,id,list,snapshot,files,new,snapshots,list,new,array,list,for,snapshot,files,point,snapshots,if,point,snapshot,equals,snapshot,id,get,name,new,snapshots,list,add,point,finalize,new,snapshots,list,file,list,generation,1,blobs,snapshot,deletion,snapshot,id
BlobStoreRepository -> Context -> public void delete();1531179852;Delete shard snapshot;public void delete() {_            final Map<String, BlobMetaData> blobs__            try {_                blobs = blobContainer.listBlobs()__            } catch (IOException e) {_                throw new IndexShardSnapshotException(shardId, "Failed to list content of gateway", e)__            }__            Tuple<BlobStoreIndexShardSnapshots, Integer> tuple = buildBlobStoreIndexShardSnapshots(blobs)__            BlobStoreIndexShardSnapshots snapshots = tuple.v1()__            int fileListGeneration = tuple.v2()___            try {_                indexShardSnapshotFormat(version).delete(blobContainer, snapshotId.getUUID())__            } catch (IOException e) {_                logger.debug("[{}] [{}] failed to delete shard snapshot file", shardId, snapshotId)__            }__            _            List<SnapshotFiles> newSnapshotsList = new ArrayList<>()__            for (SnapshotFiles point : snapshots) {_                if (!point.snapshot().equals(snapshotId.getName())) {_                    newSnapshotsList.add(point)__                }_            }_            _            finalize(newSnapshotsList, fileListGeneration + 1, blobs, "snapshot deletion [" + snapshotId + "]")__        };delete,shard,snapshot;public,void,delete,final,map,string,blob,meta,data,blobs,try,blobs,blob,container,list,blobs,catch,ioexception,e,throw,new,index,shard,snapshot,exception,shard,id,failed,to,list,content,of,gateway,e,tuple,blob,store,index,shard,snapshots,integer,tuple,build,blob,store,index,shard,snapshots,blobs,blob,store,index,shard,snapshots,snapshots,tuple,v1,int,file,list,generation,tuple,v2,try,index,shard,snapshot,format,version,delete,blob,container,snapshot,id,get,uuid,catch,ioexception,e,logger,debug,failed,to,delete,shard,snapshot,file,shard,id,snapshot,id,list,snapshot,files,new,snapshots,list,new,array,list,for,snapshot,files,point,snapshots,if,point,snapshot,equals,snapshot,id,get,name,new,snapshots,list,add,point,finalize,new,snapshots,list,file,list,generation,1,blobs,snapshot,deletion,snapshot,id
BlobStoreRepository -> Context -> public void delete();1531729807;Delete shard snapshot;public void delete() {_            final Map<String, BlobMetaData> blobs__            try {_                blobs = blobContainer.listBlobs()__            } catch (IOException e) {_                throw new IndexShardSnapshotException(shardId, "Failed to list content of gateway", e)__            }__            Tuple<BlobStoreIndexShardSnapshots, Integer> tuple = buildBlobStoreIndexShardSnapshots(blobs)__            BlobStoreIndexShardSnapshots snapshots = tuple.v1()__            int fileListGeneration = tuple.v2()___            try {_                indexShardSnapshotFormat(version).delete(blobContainer, snapshotId.getUUID())__            } catch (IOException e) {_                logger.debug("[{}] [{}] failed to delete shard snapshot file", shardId, snapshotId)__            }__            _            List<SnapshotFiles> newSnapshotsList = new ArrayList<>()__            for (SnapshotFiles point : snapshots) {_                if (!point.snapshot().equals(snapshotId.getName())) {_                    newSnapshotsList.add(point)__                }_            }_            _            finalize(newSnapshotsList, fileListGeneration + 1, blobs, "snapshot deletion [" + snapshotId + "]")__        };delete,shard,snapshot;public,void,delete,final,map,string,blob,meta,data,blobs,try,blobs,blob,container,list,blobs,catch,ioexception,e,throw,new,index,shard,snapshot,exception,shard,id,failed,to,list,content,of,gateway,e,tuple,blob,store,index,shard,snapshots,integer,tuple,build,blob,store,index,shard,snapshots,blobs,blob,store,index,shard,snapshots,snapshots,tuple,v1,int,file,list,generation,tuple,v2,try,index,shard,snapshot,format,version,delete,blob,container,snapshot,id,get,uuid,catch,ioexception,e,logger,debug,failed,to,delete,shard,snapshot,file,shard,id,snapshot,id,list,snapshot,files,new,snapshots,list,new,array,list,for,snapshot,files,point,snapshots,if,point,snapshot,equals,snapshot,id,get,name,new,snapshots,list,add,point,finalize,new,snapshots,list,file,list,generation,1,blobs,snapshot,deletion,snapshot,id
BlobStoreRepository -> Context -> public void delete();1532685069;Delete shard snapshot;public void delete() {_            final Map<String, BlobMetaData> blobs__            try {_                blobs = blobContainer.listBlobs()__            } catch (IOException e) {_                throw new IndexShardSnapshotException(shardId, "Failed to list content of gateway", e)__            }__            Tuple<BlobStoreIndexShardSnapshots, Integer> tuple = buildBlobStoreIndexShardSnapshots(blobs)__            BlobStoreIndexShardSnapshots snapshots = tuple.v1()__            int fileListGeneration = tuple.v2()___            try {_                indexShardSnapshotFormat(version).delete(blobContainer, snapshotId.getUUID())__            } catch (IOException e) {_                logger.debug("[{}] [{}] failed to delete shard snapshot file", shardId, snapshotId)__            }__            _            List<SnapshotFiles> newSnapshotsList = new ArrayList<>()__            for (SnapshotFiles point : snapshots) {_                if (!point.snapshot().equals(snapshotId.getName())) {_                    newSnapshotsList.add(point)__                }_            }_            _            finalize(newSnapshotsList, fileListGeneration + 1, blobs, "snapshot deletion [" + snapshotId + "]")__        };delete,shard,snapshot;public,void,delete,final,map,string,blob,meta,data,blobs,try,blobs,blob,container,list,blobs,catch,ioexception,e,throw,new,index,shard,snapshot,exception,shard,id,failed,to,list,content,of,gateway,e,tuple,blob,store,index,shard,snapshots,integer,tuple,build,blob,store,index,shard,snapshots,blobs,blob,store,index,shard,snapshots,snapshots,tuple,v1,int,file,list,generation,tuple,v2,try,index,shard,snapshot,format,version,delete,blob,container,snapshot,id,get,uuid,catch,ioexception,e,logger,debug,failed,to,delete,shard,snapshot,file,shard,id,snapshot,id,list,snapshot,files,new,snapshots,list,new,array,list,for,snapshot,files,point,snapshots,if,point,snapshot,equals,snapshot,id,get,name,new,snapshots,list,add,point,finalize,new,snapshots,list,file,list,generation,1,blobs,snapshot,deletion,snapshot,id
BlobStoreRepository -> Context -> public void delete();1535139672;Delete shard snapshot;public void delete() {_            final Map<String, BlobMetaData> blobs__            try {_                blobs = blobContainer.listBlobs()__            } catch (IOException e) {_                throw new IndexShardSnapshotException(shardId, "Failed to list content of gateway", e)__            }__            Tuple<BlobStoreIndexShardSnapshots, Integer> tuple = buildBlobStoreIndexShardSnapshots(blobs)__            BlobStoreIndexShardSnapshots snapshots = tuple.v1()__            int fileListGeneration = tuple.v2()___            try {_                indexShardSnapshotFormat(version).delete(blobContainer, snapshotId.getUUID())__            } catch (IOException e) {_                logger.debug("[{}] [{}] failed to delete shard snapshot file", shardId, snapshotId)__            }__            _            List<SnapshotFiles> newSnapshotsList = new ArrayList<>()__            for (SnapshotFiles point : snapshots) {_                if (!point.snapshot().equals(snapshotId.getName())) {_                    newSnapshotsList.add(point)__                }_            }_            _            finalize(newSnapshotsList, fileListGeneration + 1, blobs, "snapshot deletion [" + snapshotId + "]")__        };delete,shard,snapshot;public,void,delete,final,map,string,blob,meta,data,blobs,try,blobs,blob,container,list,blobs,catch,ioexception,e,throw,new,index,shard,snapshot,exception,shard,id,failed,to,list,content,of,gateway,e,tuple,blob,store,index,shard,snapshots,integer,tuple,build,blob,store,index,shard,snapshots,blobs,blob,store,index,shard,snapshots,snapshots,tuple,v1,int,file,list,generation,tuple,v2,try,index,shard,snapshot,format,version,delete,blob,container,snapshot,id,get,uuid,catch,ioexception,e,logger,debug,failed,to,delete,shard,snapshot,file,shard,id,snapshot,id,list,snapshot,files,new,snapshots,list,new,array,list,for,snapshot,files,point,snapshots,if,point,snapshot,equals,snapshot,id,get,name,new,snapshots,list,add,point,finalize,new,snapshots,list,file,list,generation,1,blobs,snapshot,deletion,snapshot,id
BlobStoreRepository -> Context -> public void delete();1535723122;Delete shard snapshot;public void delete() {_            final Map<String, BlobMetaData> blobs__            try {_                blobs = blobContainer.listBlobs()__            } catch (IOException e) {_                throw new IndexShardSnapshotException(shardId, "Failed to list content of gateway", e)__            }__            Tuple<BlobStoreIndexShardSnapshots, Integer> tuple = buildBlobStoreIndexShardSnapshots(blobs)__            BlobStoreIndexShardSnapshots snapshots = tuple.v1()__            int fileListGeneration = tuple.v2()___            try {_                indexShardSnapshotFormat(version).delete(blobContainer, snapshotId.getUUID())__            } catch (IOException e) {_                logger.debug("[{}] [{}] failed to delete shard snapshot file", shardId, snapshotId)__            }__            _            List<SnapshotFiles> newSnapshotsList = new ArrayList<>()__            for (SnapshotFiles point : snapshots) {_                if (!point.snapshot().equals(snapshotId.getName())) {_                    newSnapshotsList.add(point)__                }_            }_            _            finalize(newSnapshotsList, fileListGeneration + 1, blobs, "snapshot deletion [" + snapshotId + "]")__        };delete,shard,snapshot;public,void,delete,final,map,string,blob,meta,data,blobs,try,blobs,blob,container,list,blobs,catch,ioexception,e,throw,new,index,shard,snapshot,exception,shard,id,failed,to,list,content,of,gateway,e,tuple,blob,store,index,shard,snapshots,integer,tuple,build,blob,store,index,shard,snapshots,blobs,blob,store,index,shard,snapshots,snapshots,tuple,v1,int,file,list,generation,tuple,v2,try,index,shard,snapshot,format,version,delete,blob,container,snapshot,id,get,uuid,catch,ioexception,e,logger,debug,failed,to,delete,shard,snapshot,file,shard,id,snapshot,id,list,snapshot,files,new,snapshots,list,new,array,list,for,snapshot,files,point,snapshots,if,point,snapshot,equals,snapshot,id,get,name,new,snapshots,list,add,point,finalize,new,snapshots,list,file,list,generation,1,blobs,snapshot,deletion,snapshot,id
BlobStoreRepository -> Context -> public void delete();1536314350;Delete shard snapshot;public void delete() {_            final Map<String, BlobMetaData> blobs__            try {_                blobs = blobContainer.listBlobs()__            } catch (IOException e) {_                throw new IndexShardSnapshotException(shardId, "Failed to list content of gateway", e)__            }__            Tuple<BlobStoreIndexShardSnapshots, Integer> tuple = buildBlobStoreIndexShardSnapshots(blobs)__            BlobStoreIndexShardSnapshots snapshots = tuple.v1()__            int fileListGeneration = tuple.v2()___            try {_                indexShardSnapshotFormat(version).delete(blobContainer, snapshotId.getUUID())__            } catch (IOException e) {_                logger.debug("[{}] [{}] failed to delete shard snapshot file", shardId, snapshotId)__            }__            _            List<SnapshotFiles> newSnapshotsList = new ArrayList<>()__            for (SnapshotFiles point : snapshots) {_                if (!point.snapshot().equals(snapshotId.getName())) {_                    newSnapshotsList.add(point)__                }_            }_            _            finalize(newSnapshotsList, fileListGeneration + 1, blobs, "snapshot deletion [" + snapshotId + "]")__        };delete,shard,snapshot;public,void,delete,final,map,string,blob,meta,data,blobs,try,blobs,blob,container,list,blobs,catch,ioexception,e,throw,new,index,shard,snapshot,exception,shard,id,failed,to,list,content,of,gateway,e,tuple,blob,store,index,shard,snapshots,integer,tuple,build,blob,store,index,shard,snapshots,blobs,blob,store,index,shard,snapshots,snapshots,tuple,v1,int,file,list,generation,tuple,v2,try,index,shard,snapshot,format,version,delete,blob,container,snapshot,id,get,uuid,catch,ioexception,e,logger,debug,failed,to,delete,shard,snapshot,file,shard,id,snapshot,id,list,snapshot,files,new,snapshots,list,new,array,list,for,snapshot,files,point,snapshots,if,point,snapshot,equals,snapshot,id,get,name,new,snapshots,list,add,point,finalize,new,snapshots,list,file,list,generation,1,blobs,snapshot,deletion,snapshot,id
BlobStoreRepository -> Context -> public void delete();1536828374;Delete shard snapshot;public void delete() {_            final Map<String, BlobMetaData> blobs__            try {_                blobs = blobContainer.listBlobs()__            } catch (IOException e) {_                throw new IndexShardSnapshotException(shardId, "Failed to list content of gateway", e)__            }__            Tuple<BlobStoreIndexShardSnapshots, Integer> tuple = buildBlobStoreIndexShardSnapshots(blobs)__            BlobStoreIndexShardSnapshots snapshots = tuple.v1()__            int fileListGeneration = tuple.v2()___            try {_                indexShardSnapshotFormat(version).delete(blobContainer, snapshotId.getUUID())__            } catch (IOException e) {_                logger.debug("[{}] [{}] failed to delete shard snapshot file", shardId, snapshotId)__            }__            _            List<SnapshotFiles> newSnapshotsList = new ArrayList<>()__            for (SnapshotFiles point : snapshots) {_                if (!point.snapshot().equals(snapshotId.getName())) {_                    newSnapshotsList.add(point)__                }_            }_            _            finalize(newSnapshotsList, fileListGeneration + 1, blobs, "snapshot deletion [" + snapshotId + "]")__        };delete,shard,snapshot;public,void,delete,final,map,string,blob,meta,data,blobs,try,blobs,blob,container,list,blobs,catch,ioexception,e,throw,new,index,shard,snapshot,exception,shard,id,failed,to,list,content,of,gateway,e,tuple,blob,store,index,shard,snapshots,integer,tuple,build,blob,store,index,shard,snapshots,blobs,blob,store,index,shard,snapshots,snapshots,tuple,v1,int,file,list,generation,tuple,v2,try,index,shard,snapshot,format,version,delete,blob,container,snapshot,id,get,uuid,catch,ioexception,e,logger,debug,failed,to,delete,shard,snapshot,file,shard,id,snapshot,id,list,snapshot,files,new,snapshots,list,new,array,list,for,snapshot,files,point,snapshots,if,point,snapshot,equals,snapshot,id,get,name,new,snapshots,list,add,point,finalize,new,snapshots,list,file,list,generation,1,blobs,snapshot,deletion,snapshot,id
BlobStoreRepository -> Context -> public void delete();1541008027;Delete shard snapshot;public void delete() {_            final Map<String, BlobMetaData> blobs__            try {_                blobs = blobContainer.listBlobs()__            } catch (IOException e) {_                throw new IndexShardSnapshotException(shardId, "Failed to list content of gateway", e)__            }__            Tuple<BlobStoreIndexShardSnapshots, Integer> tuple = buildBlobStoreIndexShardSnapshots(blobs)__            BlobStoreIndexShardSnapshots snapshots = tuple.v1()__            int fileListGeneration = tuple.v2()___            try {_                indexShardSnapshotFormat(version).delete(blobContainer, snapshotId.getUUID())__            } catch (IOException e) {_                logger.debug("[{}] [{}] failed to delete shard snapshot file", shardId, snapshotId)__            }__            _            List<SnapshotFiles> newSnapshotsList = new ArrayList<>()__            for (SnapshotFiles point : snapshots) {_                if (!point.snapshot().equals(snapshotId.getName())) {_                    newSnapshotsList.add(point)__                }_            }_            _            finalize(newSnapshotsList, fileListGeneration + 1, blobs, "snapshot deletion [" + snapshotId + "]")__        };delete,shard,snapshot;public,void,delete,final,map,string,blob,meta,data,blobs,try,blobs,blob,container,list,blobs,catch,ioexception,e,throw,new,index,shard,snapshot,exception,shard,id,failed,to,list,content,of,gateway,e,tuple,blob,store,index,shard,snapshots,integer,tuple,build,blob,store,index,shard,snapshots,blobs,blob,store,index,shard,snapshots,snapshots,tuple,v1,int,file,list,generation,tuple,v2,try,index,shard,snapshot,format,version,delete,blob,container,snapshot,id,get,uuid,catch,ioexception,e,logger,debug,failed,to,delete,shard,snapshot,file,shard,id,snapshot,id,list,snapshot,files,new,snapshots,list,new,array,list,for,snapshot,files,point,snapshots,if,point,snapshot,equals,snapshot,id,get,name,new,snapshots,list,add,point,finalize,new,snapshots,list,file,list,generation,1,blobs,snapshot,deletion,snapshot,id
BlobStoreRepository -> Context -> public void delete();1542646292;Delete shard snapshot;public void delete() {_            final Map<String, BlobMetaData> blobs__            try {_                blobs = blobContainer.listBlobs()__            } catch (IOException e) {_                throw new IndexShardSnapshotException(shardId, "Failed to list content of gateway", e)__            }__            Tuple<BlobStoreIndexShardSnapshots, Integer> tuple = buildBlobStoreIndexShardSnapshots(blobs)__            BlobStoreIndexShardSnapshots snapshots = tuple.v1()__            int fileListGeneration = tuple.v2()___            try {_                indexShardSnapshotFormat(version).delete(blobContainer, snapshotId.getUUID())__            } catch (IOException e) {_                logger.debug("[{}] [{}] failed to delete shard snapshot file", shardId, snapshotId)__            }__            _            List<SnapshotFiles> newSnapshotsList = new ArrayList<>()__            for (SnapshotFiles point : snapshots) {_                if (!point.snapshot().equals(snapshotId.getName())) {_                    newSnapshotsList.add(point)__                }_            }_            _            finalize(newSnapshotsList, fileListGeneration + 1, blobs, "snapshot deletion [" + snapshotId + "]")__        };delete,shard,snapshot;public,void,delete,final,map,string,blob,meta,data,blobs,try,blobs,blob,container,list,blobs,catch,ioexception,e,throw,new,index,shard,snapshot,exception,shard,id,failed,to,list,content,of,gateway,e,tuple,blob,store,index,shard,snapshots,integer,tuple,build,blob,store,index,shard,snapshots,blobs,blob,store,index,shard,snapshots,snapshots,tuple,v1,int,file,list,generation,tuple,v2,try,index,shard,snapshot,format,version,delete,blob,container,snapshot,id,get,uuid,catch,ioexception,e,logger,debug,failed,to,delete,shard,snapshot,file,shard,id,snapshot,id,list,snapshot,files,new,snapshots,list,new,array,list,for,snapshot,files,point,snapshots,if,point,snapshot,equals,snapshot,id,get,name,new,snapshots,list,add,point,finalize,new,snapshots,list,file,list,generation,1,blobs,snapshot,deletion,snapshot,id
BlobStoreRepository -> Context -> public void delete();1542980705;Delete shard snapshot;public void delete() {_            final Map<String, BlobMetaData> blobs__            try {_                blobs = blobContainer.listBlobs()__            } catch (IOException e) {_                throw new IndexShardSnapshotException(shardId, "Failed to list content of gateway", e)__            }__            Tuple<BlobStoreIndexShardSnapshots, Integer> tuple = buildBlobStoreIndexShardSnapshots(blobs)__            BlobStoreIndexShardSnapshots snapshots = tuple.v1()__            int fileListGeneration = tuple.v2()___            try {_                indexShardSnapshotFormat(version).delete(blobContainer, snapshotId.getUUID())__            } catch (IOException e) {_                logger.debug("[{}] [{}] failed to delete shard snapshot file", shardId, snapshotId)__            }__            _            List<SnapshotFiles> newSnapshotsList = new ArrayList<>()__            for (SnapshotFiles point : snapshots) {_                if (!point.snapshot().equals(snapshotId.getName())) {_                    newSnapshotsList.add(point)__                }_            }_            _            finalize(newSnapshotsList, fileListGeneration + 1, blobs, "snapshot deletion [" + snapshotId + "]")__        };delete,shard,snapshot;public,void,delete,final,map,string,blob,meta,data,blobs,try,blobs,blob,container,list,blobs,catch,ioexception,e,throw,new,index,shard,snapshot,exception,shard,id,failed,to,list,content,of,gateway,e,tuple,blob,store,index,shard,snapshots,integer,tuple,build,blob,store,index,shard,snapshots,blobs,blob,store,index,shard,snapshots,snapshots,tuple,v1,int,file,list,generation,tuple,v2,try,index,shard,snapshot,format,version,delete,blob,container,snapshot,id,get,uuid,catch,ioexception,e,logger,debug,failed,to,delete,shard,snapshot,file,shard,id,snapshot,id,list,snapshot,files,new,snapshots,list,new,array,list,for,snapshot,files,point,snapshots,if,point,snapshot,equals,snapshot,id,get,name,new,snapshots,list,add,point,finalize,new,snapshots,list,file,list,generation,1,blobs,snapshot,deletion,snapshot,id
BlobStoreRepository -> Context -> public void delete();1543831870;Delete shard snapshot;public void delete() {_            final Map<String, BlobMetaData> blobs__            try {_                blobs = blobContainer.listBlobs()__            } catch (IOException e) {_                throw new IndexShardSnapshotException(shardId, "Failed to list content of gateway", e)__            }__            Tuple<BlobStoreIndexShardSnapshots, Integer> tuple = buildBlobStoreIndexShardSnapshots(blobs)__            BlobStoreIndexShardSnapshots snapshots = tuple.v1()__            int fileListGeneration = tuple.v2()___            try {_                indexShardSnapshotFormat.delete(blobContainer, snapshotId.getUUID())__            } catch (IOException e) {_                logger.debug("[{}] [{}] failed to delete shard snapshot file", shardId, snapshotId)__            }__            _            List<SnapshotFiles> newSnapshotsList = new ArrayList<>()__            for (SnapshotFiles point : snapshots) {_                if (!point.snapshot().equals(snapshotId.getName())) {_                    newSnapshotsList.add(point)__                }_            }_            _            finalize(newSnapshotsList, fileListGeneration + 1, blobs, "snapshot deletion [" + snapshotId + "]")__        };delete,shard,snapshot;public,void,delete,final,map,string,blob,meta,data,blobs,try,blobs,blob,container,list,blobs,catch,ioexception,e,throw,new,index,shard,snapshot,exception,shard,id,failed,to,list,content,of,gateway,e,tuple,blob,store,index,shard,snapshots,integer,tuple,build,blob,store,index,shard,snapshots,blobs,blob,store,index,shard,snapshots,snapshots,tuple,v1,int,file,list,generation,tuple,v2,try,index,shard,snapshot,format,delete,blob,container,snapshot,id,get,uuid,catch,ioexception,e,logger,debug,failed,to,delete,shard,snapshot,file,shard,id,snapshot,id,list,snapshot,files,new,snapshots,list,new,array,list,for,snapshot,files,point,snapshots,if,point,snapshot,equals,snapshot,id,get,name,new,snapshots,list,add,point,finalize,new,snapshots,list,file,list,generation,1,blobs,snapshot,deletion,snapshot,id
BlobStoreRepository -> Context -> public void delete();1543942400;Delete shard snapshot;public void delete() {_            final Map<String, BlobMetaData> blobs__            try {_                blobs = blobContainer.listBlobs()__            } catch (IOException e) {_                throw new IndexShardSnapshotException(shardId, "Failed to list content of gateway", e)__            }__            Tuple<BlobStoreIndexShardSnapshots, Integer> tuple = buildBlobStoreIndexShardSnapshots(blobs)__            BlobStoreIndexShardSnapshots snapshots = tuple.v1()__            int fileListGeneration = tuple.v2()___            try {_                indexShardSnapshotFormat.delete(blobContainer, snapshotId.getUUID())__            } catch (IOException e) {_                logger.debug("[{}] [{}] failed to delete shard snapshot file", shardId, snapshotId)__            }__            _            List<SnapshotFiles> newSnapshotsList = new ArrayList<>()__            for (SnapshotFiles point : snapshots) {_                if (!point.snapshot().equals(snapshotId.getName())) {_                    newSnapshotsList.add(point)__                }_            }_            _            finalize(newSnapshotsList, fileListGeneration + 1, blobs, "snapshot deletion [" + snapshotId + "]")__        };delete,shard,snapshot;public,void,delete,final,map,string,blob,meta,data,blobs,try,blobs,blob,container,list,blobs,catch,ioexception,e,throw,new,index,shard,snapshot,exception,shard,id,failed,to,list,content,of,gateway,e,tuple,blob,store,index,shard,snapshots,integer,tuple,build,blob,store,index,shard,snapshots,blobs,blob,store,index,shard,snapshots,snapshots,tuple,v1,int,file,list,generation,tuple,v2,try,index,shard,snapshot,format,delete,blob,container,snapshot,id,get,uuid,catch,ioexception,e,logger,debug,failed,to,delete,shard,snapshot,file,shard,id,snapshot,id,list,snapshot,files,new,snapshots,list,new,array,list,for,snapshot,files,point,snapshots,if,point,snapshot,equals,snapshot,id,get,name,new,snapshots,list,add,point,finalize,new,snapshots,list,file,list,generation,1,blobs,snapshot,deletion,snapshot,id
BlobStoreRepository -> Context -> public void delete();1546974294;Delete shard snapshot;public void delete() {_            final Map<String, BlobMetaData> blobs__            try {_                blobs = blobContainer.listBlobs()__            } catch (IOException e) {_                throw new IndexShardSnapshotException(shardId, "Failed to list content of gateway", e)__            }__            Tuple<BlobStoreIndexShardSnapshots, Integer> tuple = buildBlobStoreIndexShardSnapshots(blobs)__            BlobStoreIndexShardSnapshots snapshots = tuple.v1()__            int fileListGeneration = tuple.v2()___            try {_                indexShardSnapshotFormat.delete(blobContainer, snapshotId.getUUID())__            } catch (IOException e) {_                logger.debug("[{}] [{}] failed to delete shard snapshot file", shardId, snapshotId)__            }__            _            List<SnapshotFiles> newSnapshotsList = new ArrayList<>()__            for (SnapshotFiles point : snapshots) {_                if (!point.snapshot().equals(snapshotId.getName())) {_                    newSnapshotsList.add(point)__                }_            }_            _            finalize(newSnapshotsList, fileListGeneration + 1, blobs, "snapshot deletion [" + snapshotId + "]")__        };delete,shard,snapshot;public,void,delete,final,map,string,blob,meta,data,blobs,try,blobs,blob,container,list,blobs,catch,ioexception,e,throw,new,index,shard,snapshot,exception,shard,id,failed,to,list,content,of,gateway,e,tuple,blob,store,index,shard,snapshots,integer,tuple,build,blob,store,index,shard,snapshots,blobs,blob,store,index,shard,snapshots,snapshots,tuple,v1,int,file,list,generation,tuple,v2,try,index,shard,snapshot,format,delete,blob,container,snapshot,id,get,uuid,catch,ioexception,e,logger,debug,failed,to,delete,shard,snapshot,file,shard,id,snapshot,id,list,snapshot,files,new,snapshots,list,new,array,list,for,snapshot,files,point,snapshots,if,point,snapshot,equals,snapshot,id,get,name,new,snapshots,list,add,point,finalize,new,snapshots,list,file,list,generation,1,blobs,snapshot,deletion,snapshot,id
BlobStoreRepository -> Context -> public void delete();1547496475;Delete shard snapshot;public void delete() {_            final Map<String, BlobMetaData> blobs__            try {_                blobs = blobContainer.listBlobs()__            } catch (IOException e) {_                throw new IndexShardSnapshotException(shardId, "Failed to list content of gateway", e)__            }__            Tuple<BlobStoreIndexShardSnapshots, Integer> tuple = buildBlobStoreIndexShardSnapshots(blobs)__            BlobStoreIndexShardSnapshots snapshots = tuple.v1()__            int fileListGeneration = tuple.v2()___            try {_                indexShardSnapshotFormat.delete(blobContainer, snapshotId.getUUID())__            } catch (IOException e) {_                logger.debug("[{}] [{}] failed to delete shard snapshot file", shardId, snapshotId)__            }__            _            List<SnapshotFiles> newSnapshotsList = new ArrayList<>()__            for (SnapshotFiles point : snapshots) {_                if (!point.snapshot().equals(snapshotId.getName())) {_                    newSnapshotsList.add(point)__                }_            }_            _            finalize(newSnapshotsList, fileListGeneration + 1, blobs, "snapshot deletion [" + snapshotId + "]")__        };delete,shard,snapshot;public,void,delete,final,map,string,blob,meta,data,blobs,try,blobs,blob,container,list,blobs,catch,ioexception,e,throw,new,index,shard,snapshot,exception,shard,id,failed,to,list,content,of,gateway,e,tuple,blob,store,index,shard,snapshots,integer,tuple,build,blob,store,index,shard,snapshots,blobs,blob,store,index,shard,snapshots,snapshots,tuple,v1,int,file,list,generation,tuple,v2,try,index,shard,snapshot,format,delete,blob,container,snapshot,id,get,uuid,catch,ioexception,e,logger,debug,failed,to,delete,shard,snapshot,file,shard,id,snapshot,id,list,snapshot,files,new,snapshots,list,new,array,list,for,snapshot,files,point,snapshots,if,point,snapshot,equals,snapshot,id,get,name,new,snapshots,list,add,point,finalize,new,snapshots,list,file,list,generation,1,blobs,snapshot,deletion,snapshot,id
BlobStoreRepository -> Context -> public void delete();1547625930;Delete shard snapshot;public void delete() {_            final Map<String, BlobMetaData> blobs__            try {_                blobs = blobContainer.listBlobs()__            } catch (IOException e) {_                throw new IndexShardSnapshotException(shardId, "Failed to list content of gateway", e)__            }__            Tuple<BlobStoreIndexShardSnapshots, Integer> tuple = buildBlobStoreIndexShardSnapshots(blobs)__            BlobStoreIndexShardSnapshots snapshots = tuple.v1()__            int fileListGeneration = tuple.v2()___            try {_                indexShardSnapshotFormat.delete(blobContainer, snapshotId.getUUID())__            } catch (IOException e) {_                logger.debug("[{}] [{}] failed to delete shard snapshot file", shardId, snapshotId)__            }__            _            List<SnapshotFiles> newSnapshotsList = new ArrayList<>()__            for (SnapshotFiles point : snapshots) {_                if (!point.snapshot().equals(snapshotId.getName())) {_                    newSnapshotsList.add(point)__                }_            }_            _            finalize(newSnapshotsList, fileListGeneration + 1, blobs, "snapshot deletion [" + snapshotId + "]")__        };delete,shard,snapshot;public,void,delete,final,map,string,blob,meta,data,blobs,try,blobs,blob,container,list,blobs,catch,ioexception,e,throw,new,index,shard,snapshot,exception,shard,id,failed,to,list,content,of,gateway,e,tuple,blob,store,index,shard,snapshots,integer,tuple,build,blob,store,index,shard,snapshots,blobs,blob,store,index,shard,snapshots,snapshots,tuple,v1,int,file,list,generation,tuple,v2,try,index,shard,snapshot,format,delete,blob,container,snapshot,id,get,uuid,catch,ioexception,e,logger,debug,failed,to,delete,shard,snapshot,file,shard,id,snapshot,id,list,snapshot,files,new,snapshots,list,new,array,list,for,snapshot,files,point,snapshots,if,point,snapshot,equals,snapshot,id,get,name,new,snapshots,list,add,point,finalize,new,snapshots,list,file,list,generation,1,blobs,snapshot,deletion,snapshot,id
BlobStoreRepository -> Context -> public void delete();1550647627;Delete shard snapshot;public void delete() {_            final Map<String, BlobMetaData> blobs__            try {_                blobs = blobContainer.listBlobs()__            } catch (IOException e) {_                throw new IndexShardSnapshotException(shardId, "Failed to list content of gateway", e)__            }__            Tuple<BlobStoreIndexShardSnapshots, Integer> tuple = buildBlobStoreIndexShardSnapshots(blobs)__            BlobStoreIndexShardSnapshots snapshots = tuple.v1()__            int fileListGeneration = tuple.v2()___            try {_                indexShardSnapshotFormat.delete(blobContainer, snapshotId.getUUID())__            } catch (IOException e) {_                logger.debug("[{}] [{}] failed to delete shard snapshot file", shardId, snapshotId)__            }__            _            List<SnapshotFiles> newSnapshotsList = new ArrayList<>()__            for (SnapshotFiles point : snapshots) {_                if (!point.snapshot().equals(snapshotId.getName())) {_                    newSnapshotsList.add(point)__                }_            }_            _            finalize(newSnapshotsList, fileListGeneration + 1, blobs, "snapshot deletion [" + snapshotId + "]")__        };delete,shard,snapshot;public,void,delete,final,map,string,blob,meta,data,blobs,try,blobs,blob,container,list,blobs,catch,ioexception,e,throw,new,index,shard,snapshot,exception,shard,id,failed,to,list,content,of,gateway,e,tuple,blob,store,index,shard,snapshots,integer,tuple,build,blob,store,index,shard,snapshots,blobs,blob,store,index,shard,snapshots,snapshots,tuple,v1,int,file,list,generation,tuple,v2,try,index,shard,snapshot,format,delete,blob,container,snapshot,id,get,uuid,catch,ioexception,e,logger,debug,failed,to,delete,shard,snapshot,file,shard,id,snapshot,id,list,snapshot,files,new,snapshots,list,new,array,list,for,snapshot,files,point,snapshots,if,point,snapshot,equals,snapshot,id,get,name,new,snapshots,list,add,point,finalize,new,snapshots,list,file,list,generation,1,blobs,snapshot,deletion,snapshot,id
BlobStoreRepository -> SnapshotContext -> public void snapshot(final IndexCommit snapshotIndexCommit);1524684173;Create snapshot from index commit point__@param snapshotIndexCommit snapshot commit point;public void snapshot(final IndexCommit snapshotIndexCommit) {_            logger.debug("[{}] [{}] snapshot to [{}] ...", shardId, snapshotId, metadata.name())___            final Map<String, BlobMetaData> blobs__            try {_                blobs = blobContainer.listBlobs()__            } catch (IOException e) {_                throw new IndexShardSnapshotFailedException(shardId, "failed to list blobs", e)__            }__            long generation = findLatestFileNameGeneration(blobs)__            Tuple<BlobStoreIndexShardSnapshots, Integer> tuple = buildBlobStoreIndexShardSnapshots(blobs)__            BlobStoreIndexShardSnapshots snapshots = tuple.v1()__            int fileListGeneration = tuple.v2()___            if (snapshots.snapshots().stream().anyMatch(sf -> sf.snapshot().equals(snapshotId.getName()))) {_                throw new IndexShardSnapshotFailedException(shardId,_                    "Duplicate snapshot name [" + snapshotId.getName() + "] detected, aborting")__            }__            final List<BlobStoreIndexShardSnapshot.FileInfo> indexCommitPointFiles = new ArrayList<>()___            store.incRef()__            try {_                int indexNumberOfFiles = 0__                long indexTotalFilesSize = 0__                ArrayList<BlobStoreIndexShardSnapshot.FileInfo> filesToSnapshot = new ArrayList<>()__                final Store.MetadataSnapshot metadata__                _                final Collection<String> fileNames__                try {_                    metadata = store.getMetadata(snapshotIndexCommit)__                    fileNames = snapshotIndexCommit.getFileNames()__                } catch (IOException e) {_                    throw new IndexShardSnapshotFailedException(shardId, "Failed to get store file metadata", e)__                }_                for (String fileName : fileNames) {_                    if (snapshotStatus.isAborted()) {_                        logger.debug("[{}] [{}] Aborted on the file [{}], exiting", shardId, snapshotId, fileName)__                        throw new IndexShardSnapshotFailedException(shardId, "Aborted")__                    }__                    logger.trace("[{}] [{}] Processing [{}]", shardId, snapshotId, fileName)__                    final StoreFileMetaData md = metadata.get(fileName)__                    BlobStoreIndexShardSnapshot.FileInfo existingFileInfo = null__                    List<BlobStoreIndexShardSnapshot.FileInfo> filesInfo = snapshots.findPhysicalIndexFiles(fileName)__                    if (filesInfo != null) {_                        for (BlobStoreIndexShardSnapshot.FileInfo fileInfo : filesInfo) {_                            try {_                                _                                _                                _                                _                                maybeRecalculateMetadataHash(blobContainer, fileInfo, metadata)__                            } catch (Exception e) {_                                logger.warn(() -> new ParameterizedMessage("{} Can't calculate hash from blob for file [{}] [{}]", shardId, fileInfo.physicalName(), fileInfo.metadata()), e)__                            }_                            if (fileInfo.isSame(md) && snapshotFileExistsInBlobs(fileInfo, blobs)) {_                                _                                _                                existingFileInfo = fileInfo__                                break__                            }_                        }_                    }_                    if (existingFileInfo == null) {_                        indexNumberOfFiles++__                        indexTotalFilesSize += md.length()__                        _                        BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo = new BlobStoreIndexShardSnapshot.FileInfo(fileNameFromGeneration(++generation), md, chunkSize())__                        indexCommitPointFiles.add(snapshotFileInfo)__                        filesToSnapshot.add(snapshotFileInfo)__                    } else {_                        indexCommitPointFiles.add(existingFileInfo)__                    }_                }__                snapshotStatus.moveToStarted(startTime, indexNumberOfFiles, indexTotalFilesSize)___                for (BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo : filesToSnapshot) {_                    try {_                        snapshotFile(snapshotFileInfo)__                    } catch (IOException e) {_                        throw new IndexShardSnapshotFailedException(shardId, "Failed to perform snapshot (index files)", e)__                    }_                }_            } finally {_                store.decRef()__            }__            final IndexShardSnapshotStatus.Copy lastSnapshotStatus = snapshotStatus.moveToFinalize(snapshotIndexCommit.getGeneration())___            _            final BlobStoreIndexShardSnapshot snapshot = new BlobStoreIndexShardSnapshot(snapshotId.getName(),_                                                                        lastSnapshotStatus.getIndexVersion(),_                                                                        indexCommitPointFiles,_                                                                        lastSnapshotStatus.getStartTime(),_                                                                        _                                                                        _                                                                        System.currentTimeMillis() - lastSnapshotStatus.getStartTime(),_                                                                        lastSnapshotStatus.getNumberOfFiles(),_                                                                        lastSnapshotStatus.getTotalSize())___            _            logger.trace("[{}] [{}] writing shard snapshot file", shardId, snapshotId)__            try {_                indexShardSnapshotFormat.write(snapshot, blobContainer, snapshotId.getUUID())__            } catch (IOException e) {_                throw new IndexShardSnapshotFailedException(shardId, "Failed to write commit point", e)__            }__            _            _            List<SnapshotFiles> newSnapshotsList = new ArrayList<>()__            newSnapshotsList.add(new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles()))__            for (SnapshotFiles point : snapshots) {_                newSnapshotsList.add(point)__            }_            _            finalize(newSnapshotsList, fileListGeneration + 1, blobs)__            snapshotStatus.moveToDone(System.currentTimeMillis())___        };create,snapshot,from,index,commit,point,param,snapshot,index,commit,snapshot,commit,point;public,void,snapshot,final,index,commit,snapshot,index,commit,logger,debug,snapshot,to,shard,id,snapshot,id,metadata,name,final,map,string,blob,meta,data,blobs,try,blobs,blob,container,list,blobs,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,list,blobs,e,long,generation,find,latest,file,name,generation,blobs,tuple,blob,store,index,shard,snapshots,integer,tuple,build,blob,store,index,shard,snapshots,blobs,blob,store,index,shard,snapshots,snapshots,tuple,v1,int,file,list,generation,tuple,v2,if,snapshots,snapshots,stream,any,match,sf,sf,snapshot,equals,snapshot,id,get,name,throw,new,index,shard,snapshot,failed,exception,shard,id,duplicate,snapshot,name,snapshot,id,get,name,detected,aborting,final,list,blob,store,index,shard,snapshot,file,info,index,commit,point,files,new,array,list,store,inc,ref,try,int,index,number,of,files,0,long,index,total,files,size,0,array,list,blob,store,index,shard,snapshot,file,info,files,to,snapshot,new,array,list,final,store,metadata,snapshot,metadata,final,collection,string,file,names,try,metadata,store,get,metadata,snapshot,index,commit,file,names,snapshot,index,commit,get,file,names,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,get,store,file,metadata,e,for,string,file,name,file,names,if,snapshot,status,is,aborted,logger,debug,aborted,on,the,file,exiting,shard,id,snapshot,id,file,name,throw,new,index,shard,snapshot,failed,exception,shard,id,aborted,logger,trace,processing,shard,id,snapshot,id,file,name,final,store,file,meta,data,md,metadata,get,file,name,blob,store,index,shard,snapshot,file,info,existing,file,info,null,list,blob,store,index,shard,snapshot,file,info,files,info,snapshots,find,physical,index,files,file,name,if,files,info,null,for,blob,store,index,shard,snapshot,file,info,file,info,files,info,try,maybe,recalculate,metadata,hash,blob,container,file,info,metadata,catch,exception,e,logger,warn,new,parameterized,message,can,t,calculate,hash,from,blob,for,file,shard,id,file,info,physical,name,file,info,metadata,e,if,file,info,is,same,md,snapshot,file,exists,in,blobs,file,info,blobs,existing,file,info,file,info,break,if,existing,file,info,null,index,number,of,files,index,total,files,size,md,length,blob,store,index,shard,snapshot,file,info,snapshot,file,info,new,blob,store,index,shard,snapshot,file,info,file,name,from,generation,generation,md,chunk,size,index,commit,point,files,add,snapshot,file,info,files,to,snapshot,add,snapshot,file,info,else,index,commit,point,files,add,existing,file,info,snapshot,status,move,to,started,start,time,index,number,of,files,index,total,files,size,for,blob,store,index,shard,snapshot,file,info,snapshot,file,info,files,to,snapshot,try,snapshot,file,snapshot,file,info,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,perform,snapshot,index,files,e,finally,store,dec,ref,final,index,shard,snapshot,status,copy,last,snapshot,status,snapshot,status,move,to,finalize,snapshot,index,commit,get,generation,final,blob,store,index,shard,snapshot,snapshot,new,blob,store,index,shard,snapshot,snapshot,id,get,name,last,snapshot,status,get,index,version,index,commit,point,files,last,snapshot,status,get,start,time,system,current,time,millis,last,snapshot,status,get,start,time,last,snapshot,status,get,number,of,files,last,snapshot,status,get,total,size,logger,trace,writing,shard,snapshot,file,shard,id,snapshot,id,try,index,shard,snapshot,format,write,snapshot,blob,container,snapshot,id,get,uuid,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,write,commit,point,e,list,snapshot,files,new,snapshots,list,new,array,list,new,snapshots,list,add,new,snapshot,files,snapshot,snapshot,snapshot,index,files,for,snapshot,files,point,snapshots,new,snapshots,list,add,point,finalize,new,snapshots,list,file,list,generation,1,blobs,snapshot,status,move,to,done,system,current,time,millis
BlobStoreRepository -> SnapshotContext -> public void snapshot(final IndexCommit snapshotIndexCommit);1525334055;Create snapshot from index commit point__@param snapshotIndexCommit snapshot commit point;public void snapshot(final IndexCommit snapshotIndexCommit) {_            logger.debug("[{}] [{}] snapshot to [{}] ...", shardId, snapshotId, metadata.name())___            final Map<String, BlobMetaData> blobs__            try {_                blobs = blobContainer.listBlobs()__            } catch (IOException e) {_                throw new IndexShardSnapshotFailedException(shardId, "failed to list blobs", e)__            }__            long generation = findLatestFileNameGeneration(blobs)__            Tuple<BlobStoreIndexShardSnapshots, Integer> tuple = buildBlobStoreIndexShardSnapshots(blobs)__            BlobStoreIndexShardSnapshots snapshots = tuple.v1()__            int fileListGeneration = tuple.v2()___            if (snapshots.snapshots().stream().anyMatch(sf -> sf.snapshot().equals(snapshotId.getName()))) {_                throw new IndexShardSnapshotFailedException(shardId,_                    "Duplicate snapshot name [" + snapshotId.getName() + "] detected, aborting")__            }__            final List<BlobStoreIndexShardSnapshot.FileInfo> indexCommitPointFiles = new ArrayList<>()___            store.incRef()__            try {_                int indexNumberOfFiles = 0__                long indexTotalFilesSize = 0__                ArrayList<BlobStoreIndexShardSnapshot.FileInfo> filesToSnapshot = new ArrayList<>()__                final Store.MetadataSnapshot metadata__                _                final Collection<String> fileNames__                try {_                    metadata = store.getMetadata(snapshotIndexCommit)__                    fileNames = snapshotIndexCommit.getFileNames()__                } catch (IOException e) {_                    throw new IndexShardSnapshotFailedException(shardId, "Failed to get store file metadata", e)__                }_                for (String fileName : fileNames) {_                    if (snapshotStatus.isAborted()) {_                        logger.debug("[{}] [{}] Aborted on the file [{}], exiting", shardId, snapshotId, fileName)__                        throw new IndexShardSnapshotFailedException(shardId, "Aborted")__                    }__                    logger.trace("[{}] [{}] Processing [{}]", shardId, snapshotId, fileName)__                    final StoreFileMetaData md = metadata.get(fileName)__                    BlobStoreIndexShardSnapshot.FileInfo existingFileInfo = null__                    List<BlobStoreIndexShardSnapshot.FileInfo> filesInfo = snapshots.findPhysicalIndexFiles(fileName)__                    if (filesInfo != null) {_                        for (BlobStoreIndexShardSnapshot.FileInfo fileInfo : filesInfo) {_                            try {_                                _                                _                                _                                _                                maybeRecalculateMetadataHash(blobContainer, fileInfo, metadata)__                            } catch (Exception e) {_                                logger.warn(() -> new ParameterizedMessage("{} Can't calculate hash from blob for file [{}] [{}]", shardId, fileInfo.physicalName(), fileInfo.metadata()), e)__                            }_                            if (fileInfo.isSame(md) && snapshotFileExistsInBlobs(fileInfo, blobs)) {_                                _                                _                                existingFileInfo = fileInfo__                                break__                            }_                        }_                    }_                    if (existingFileInfo == null) {_                        indexNumberOfFiles++__                        indexTotalFilesSize += md.length()__                        _                        BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo = new BlobStoreIndexShardSnapshot.FileInfo(fileNameFromGeneration(++generation), md, chunkSize())__                        indexCommitPointFiles.add(snapshotFileInfo)__                        filesToSnapshot.add(snapshotFileInfo)__                    } else {_                        indexCommitPointFiles.add(existingFileInfo)__                    }_                }__                snapshotStatus.moveToStarted(startTime, indexNumberOfFiles, indexTotalFilesSize)___                for (BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo : filesToSnapshot) {_                    try {_                        snapshotFile(snapshotFileInfo)__                    } catch (IOException e) {_                        throw new IndexShardSnapshotFailedException(shardId, "Failed to perform snapshot (index files)", e)__                    }_                }_            } finally {_                store.decRef()__            }__            final IndexShardSnapshotStatus.Copy lastSnapshotStatus = snapshotStatus.moveToFinalize(snapshotIndexCommit.getGeneration())___            _            final BlobStoreIndexShardSnapshot snapshot = new BlobStoreIndexShardSnapshot(snapshotId.getName(),_                                                                        lastSnapshotStatus.getIndexVersion(),_                                                                        indexCommitPointFiles,_                                                                        lastSnapshotStatus.getStartTime(),_                                                                        _                                                                        _                                                                        System.currentTimeMillis() - lastSnapshotStatus.getStartTime(),_                                                                        lastSnapshotStatus.getNumberOfFiles(),_                                                                        lastSnapshotStatus.getTotalSize())___            _            logger.trace("[{}] [{}] writing shard snapshot file", shardId, snapshotId)__            try {_                indexShardSnapshotFormat.write(snapshot, blobContainer, snapshotId.getUUID())__            } catch (IOException e) {_                throw new IndexShardSnapshotFailedException(shardId, "Failed to write commit point", e)__            }__            _            _            List<SnapshotFiles> newSnapshotsList = new ArrayList<>()__            newSnapshotsList.add(new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles()))__            for (SnapshotFiles point : snapshots) {_                newSnapshotsList.add(point)__            }_            _            finalize(newSnapshotsList, fileListGeneration + 1, blobs)__            snapshotStatus.moveToDone(System.currentTimeMillis())___        };create,snapshot,from,index,commit,point,param,snapshot,index,commit,snapshot,commit,point;public,void,snapshot,final,index,commit,snapshot,index,commit,logger,debug,snapshot,to,shard,id,snapshot,id,metadata,name,final,map,string,blob,meta,data,blobs,try,blobs,blob,container,list,blobs,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,list,blobs,e,long,generation,find,latest,file,name,generation,blobs,tuple,blob,store,index,shard,snapshots,integer,tuple,build,blob,store,index,shard,snapshots,blobs,blob,store,index,shard,snapshots,snapshots,tuple,v1,int,file,list,generation,tuple,v2,if,snapshots,snapshots,stream,any,match,sf,sf,snapshot,equals,snapshot,id,get,name,throw,new,index,shard,snapshot,failed,exception,shard,id,duplicate,snapshot,name,snapshot,id,get,name,detected,aborting,final,list,blob,store,index,shard,snapshot,file,info,index,commit,point,files,new,array,list,store,inc,ref,try,int,index,number,of,files,0,long,index,total,files,size,0,array,list,blob,store,index,shard,snapshot,file,info,files,to,snapshot,new,array,list,final,store,metadata,snapshot,metadata,final,collection,string,file,names,try,metadata,store,get,metadata,snapshot,index,commit,file,names,snapshot,index,commit,get,file,names,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,get,store,file,metadata,e,for,string,file,name,file,names,if,snapshot,status,is,aborted,logger,debug,aborted,on,the,file,exiting,shard,id,snapshot,id,file,name,throw,new,index,shard,snapshot,failed,exception,shard,id,aborted,logger,trace,processing,shard,id,snapshot,id,file,name,final,store,file,meta,data,md,metadata,get,file,name,blob,store,index,shard,snapshot,file,info,existing,file,info,null,list,blob,store,index,shard,snapshot,file,info,files,info,snapshots,find,physical,index,files,file,name,if,files,info,null,for,blob,store,index,shard,snapshot,file,info,file,info,files,info,try,maybe,recalculate,metadata,hash,blob,container,file,info,metadata,catch,exception,e,logger,warn,new,parameterized,message,can,t,calculate,hash,from,blob,for,file,shard,id,file,info,physical,name,file,info,metadata,e,if,file,info,is,same,md,snapshot,file,exists,in,blobs,file,info,blobs,existing,file,info,file,info,break,if,existing,file,info,null,index,number,of,files,index,total,files,size,md,length,blob,store,index,shard,snapshot,file,info,snapshot,file,info,new,blob,store,index,shard,snapshot,file,info,file,name,from,generation,generation,md,chunk,size,index,commit,point,files,add,snapshot,file,info,files,to,snapshot,add,snapshot,file,info,else,index,commit,point,files,add,existing,file,info,snapshot,status,move,to,started,start,time,index,number,of,files,index,total,files,size,for,blob,store,index,shard,snapshot,file,info,snapshot,file,info,files,to,snapshot,try,snapshot,file,snapshot,file,info,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,perform,snapshot,index,files,e,finally,store,dec,ref,final,index,shard,snapshot,status,copy,last,snapshot,status,snapshot,status,move,to,finalize,snapshot,index,commit,get,generation,final,blob,store,index,shard,snapshot,snapshot,new,blob,store,index,shard,snapshot,snapshot,id,get,name,last,snapshot,status,get,index,version,index,commit,point,files,last,snapshot,status,get,start,time,system,current,time,millis,last,snapshot,status,get,start,time,last,snapshot,status,get,number,of,files,last,snapshot,status,get,total,size,logger,trace,writing,shard,snapshot,file,shard,id,snapshot,id,try,index,shard,snapshot,format,write,snapshot,blob,container,snapshot,id,get,uuid,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,write,commit,point,e,list,snapshot,files,new,snapshots,list,new,array,list,new,snapshots,list,add,new,snapshot,files,snapshot,snapshot,snapshot,index,files,for,snapshot,files,point,snapshots,new,snapshots,list,add,point,finalize,new,snapshots,list,file,list,generation,1,blobs,snapshot,status,move,to,done,system,current,time,millis
BlobStoreRepository -> SnapshotContext -> public void snapshot(final IndexCommit snapshotIndexCommit);1525798020;Create snapshot from index commit point__@param snapshotIndexCommit snapshot commit point;public void snapshot(final IndexCommit snapshotIndexCommit) {_            logger.debug("[{}] [{}] snapshot to [{}] ...", shardId, snapshotId, metadata.name())___            final Map<String, BlobMetaData> blobs__            try {_                blobs = blobContainer.listBlobs()__            } catch (IOException e) {_                throw new IndexShardSnapshotFailedException(shardId, "failed to list blobs", e)__            }__            long generation = findLatestFileNameGeneration(blobs)__            Tuple<BlobStoreIndexShardSnapshots, Integer> tuple = buildBlobStoreIndexShardSnapshots(blobs)__            BlobStoreIndexShardSnapshots snapshots = tuple.v1()__            int fileListGeneration = tuple.v2()___            if (snapshots.snapshots().stream().anyMatch(sf -> sf.snapshot().equals(snapshotId.getName()))) {_                throw new IndexShardSnapshotFailedException(shardId,_                    "Duplicate snapshot name [" + snapshotId.getName() + "] detected, aborting")__            }__            final List<BlobStoreIndexShardSnapshot.FileInfo> indexCommitPointFiles = new ArrayList<>()___            store.incRef()__            try {_                int indexNumberOfFiles = 0__                long indexTotalFilesSize = 0__                ArrayList<BlobStoreIndexShardSnapshot.FileInfo> filesToSnapshot = new ArrayList<>()__                final Store.MetadataSnapshot metadata__                _                final Collection<String> fileNames__                try {_                    metadata = store.getMetadata(snapshotIndexCommit)__                    fileNames = snapshotIndexCommit.getFileNames()__                } catch (IOException e) {_                    throw new IndexShardSnapshotFailedException(shardId, "Failed to get store file metadata", e)__                }_                for (String fileName : fileNames) {_                    if (snapshotStatus.isAborted()) {_                        logger.debug("[{}] [{}] Aborted on the file [{}], exiting", shardId, snapshotId, fileName)__                        throw new IndexShardSnapshotFailedException(shardId, "Aborted")__                    }__                    logger.trace("[{}] [{}] Processing [{}]", shardId, snapshotId, fileName)__                    final StoreFileMetaData md = metadata.get(fileName)__                    BlobStoreIndexShardSnapshot.FileInfo existingFileInfo = null__                    List<BlobStoreIndexShardSnapshot.FileInfo> filesInfo = snapshots.findPhysicalIndexFiles(fileName)__                    if (filesInfo != null) {_                        for (BlobStoreIndexShardSnapshot.FileInfo fileInfo : filesInfo) {_                            try {_                                _                                _                                _                                _                                maybeRecalculateMetadataHash(blobContainer, fileInfo, metadata)__                            } catch (Exception e) {_                                logger.warn(() -> new ParameterizedMessage("{} Can't calculate hash from blob for file [{}] [{}]", shardId, fileInfo.physicalName(), fileInfo.metadata()), e)__                            }_                            if (fileInfo.isSame(md) && snapshotFileExistsInBlobs(fileInfo, blobs)) {_                                _                                _                                existingFileInfo = fileInfo__                                break__                            }_                        }_                    }_                    if (existingFileInfo == null) {_                        indexNumberOfFiles++__                        indexTotalFilesSize += md.length()__                        _                        BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo = new BlobStoreIndexShardSnapshot.FileInfo(fileNameFromGeneration(++generation), md, chunkSize())__                        indexCommitPointFiles.add(snapshotFileInfo)__                        filesToSnapshot.add(snapshotFileInfo)__                    } else {_                        indexCommitPointFiles.add(existingFileInfo)__                    }_                }__                snapshotStatus.moveToStarted(startTime, indexNumberOfFiles, indexTotalFilesSize)___                for (BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo : filesToSnapshot) {_                    try {_                        snapshotFile(snapshotFileInfo)__                    } catch (IOException e) {_                        throw new IndexShardSnapshotFailedException(shardId, "Failed to perform snapshot (index files)", e)__                    }_                }_            } finally {_                store.decRef()__            }__            final IndexShardSnapshotStatus.Copy lastSnapshotStatus = snapshotStatus.moveToFinalize(snapshotIndexCommit.getGeneration())___            _            final BlobStoreIndexShardSnapshot snapshot = new BlobStoreIndexShardSnapshot(snapshotId.getName(),_                                                                        lastSnapshotStatus.getIndexVersion(),_                                                                        indexCommitPointFiles,_                                                                        lastSnapshotStatus.getStartTime(),_                                                                        _                                                                        _                                                                        System.currentTimeMillis() - lastSnapshotStatus.getStartTime(),_                                                                        lastSnapshotStatus.getNumberOfFiles(),_                                                                        lastSnapshotStatus.getTotalSize())___            _            logger.trace("[{}] [{}] writing shard snapshot file", shardId, snapshotId)__            try {_                indexShardSnapshotFormat.write(snapshot, blobContainer, snapshotId.getUUID())__            } catch (IOException e) {_                throw new IndexShardSnapshotFailedException(shardId, "Failed to write commit point", e)__            }__            _            _            List<SnapshotFiles> newSnapshotsList = new ArrayList<>()__            newSnapshotsList.add(new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles()))__            for (SnapshotFiles point : snapshots) {_                newSnapshotsList.add(point)__            }_            _            finalize(newSnapshotsList, fileListGeneration + 1, blobs, "snapshot creation [" + snapshotId + "]")__            snapshotStatus.moveToDone(System.currentTimeMillis())___        };create,snapshot,from,index,commit,point,param,snapshot,index,commit,snapshot,commit,point;public,void,snapshot,final,index,commit,snapshot,index,commit,logger,debug,snapshot,to,shard,id,snapshot,id,metadata,name,final,map,string,blob,meta,data,blobs,try,blobs,blob,container,list,blobs,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,list,blobs,e,long,generation,find,latest,file,name,generation,blobs,tuple,blob,store,index,shard,snapshots,integer,tuple,build,blob,store,index,shard,snapshots,blobs,blob,store,index,shard,snapshots,snapshots,tuple,v1,int,file,list,generation,tuple,v2,if,snapshots,snapshots,stream,any,match,sf,sf,snapshot,equals,snapshot,id,get,name,throw,new,index,shard,snapshot,failed,exception,shard,id,duplicate,snapshot,name,snapshot,id,get,name,detected,aborting,final,list,blob,store,index,shard,snapshot,file,info,index,commit,point,files,new,array,list,store,inc,ref,try,int,index,number,of,files,0,long,index,total,files,size,0,array,list,blob,store,index,shard,snapshot,file,info,files,to,snapshot,new,array,list,final,store,metadata,snapshot,metadata,final,collection,string,file,names,try,metadata,store,get,metadata,snapshot,index,commit,file,names,snapshot,index,commit,get,file,names,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,get,store,file,metadata,e,for,string,file,name,file,names,if,snapshot,status,is,aborted,logger,debug,aborted,on,the,file,exiting,shard,id,snapshot,id,file,name,throw,new,index,shard,snapshot,failed,exception,shard,id,aborted,logger,trace,processing,shard,id,snapshot,id,file,name,final,store,file,meta,data,md,metadata,get,file,name,blob,store,index,shard,snapshot,file,info,existing,file,info,null,list,blob,store,index,shard,snapshot,file,info,files,info,snapshots,find,physical,index,files,file,name,if,files,info,null,for,blob,store,index,shard,snapshot,file,info,file,info,files,info,try,maybe,recalculate,metadata,hash,blob,container,file,info,metadata,catch,exception,e,logger,warn,new,parameterized,message,can,t,calculate,hash,from,blob,for,file,shard,id,file,info,physical,name,file,info,metadata,e,if,file,info,is,same,md,snapshot,file,exists,in,blobs,file,info,blobs,existing,file,info,file,info,break,if,existing,file,info,null,index,number,of,files,index,total,files,size,md,length,blob,store,index,shard,snapshot,file,info,snapshot,file,info,new,blob,store,index,shard,snapshot,file,info,file,name,from,generation,generation,md,chunk,size,index,commit,point,files,add,snapshot,file,info,files,to,snapshot,add,snapshot,file,info,else,index,commit,point,files,add,existing,file,info,snapshot,status,move,to,started,start,time,index,number,of,files,index,total,files,size,for,blob,store,index,shard,snapshot,file,info,snapshot,file,info,files,to,snapshot,try,snapshot,file,snapshot,file,info,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,perform,snapshot,index,files,e,finally,store,dec,ref,final,index,shard,snapshot,status,copy,last,snapshot,status,snapshot,status,move,to,finalize,snapshot,index,commit,get,generation,final,blob,store,index,shard,snapshot,snapshot,new,blob,store,index,shard,snapshot,snapshot,id,get,name,last,snapshot,status,get,index,version,index,commit,point,files,last,snapshot,status,get,start,time,system,current,time,millis,last,snapshot,status,get,start,time,last,snapshot,status,get,number,of,files,last,snapshot,status,get,total,size,logger,trace,writing,shard,snapshot,file,shard,id,snapshot,id,try,index,shard,snapshot,format,write,snapshot,blob,container,snapshot,id,get,uuid,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,write,commit,point,e,list,snapshot,files,new,snapshots,list,new,array,list,new,snapshots,list,add,new,snapshot,files,snapshot,snapshot,snapshot,index,files,for,snapshot,files,point,snapshots,new,snapshots,list,add,point,finalize,new,snapshots,list,file,list,generation,1,blobs,snapshot,creation,snapshot,id,snapshot,status,move,to,done,system,current,time,millis
BlobStoreRepository -> SnapshotContext -> public void snapshot(final IndexCommit snapshotIndexCommit);1526289033;Create snapshot from index commit point__@param snapshotIndexCommit snapshot commit point;public void snapshot(final IndexCommit snapshotIndexCommit) {_            logger.debug("[{}] [{}] snapshot to [{}] ...", shardId, snapshotId, metadata.name())___            final Map<String, BlobMetaData> blobs__            try {_                blobs = blobContainer.listBlobs()__            } catch (IOException e) {_                throw new IndexShardSnapshotFailedException(shardId, "failed to list blobs", e)__            }__            long generation = findLatestFileNameGeneration(blobs)__            Tuple<BlobStoreIndexShardSnapshots, Integer> tuple = buildBlobStoreIndexShardSnapshots(blobs)__            BlobStoreIndexShardSnapshots snapshots = tuple.v1()__            int fileListGeneration = tuple.v2()___            if (snapshots.snapshots().stream().anyMatch(sf -> sf.snapshot().equals(snapshotId.getName()))) {_                throw new IndexShardSnapshotFailedException(shardId,_                    "Duplicate snapshot name [" + snapshotId.getName() + "] detected, aborting")__            }__            final List<BlobStoreIndexShardSnapshot.FileInfo> indexCommitPointFiles = new ArrayList<>()___            store.incRef()__            try {_                int indexNumberOfFiles = 0__                long indexTotalFilesSize = 0__                ArrayList<BlobStoreIndexShardSnapshot.FileInfo> filesToSnapshot = new ArrayList<>()__                final Store.MetadataSnapshot metadata__                _                final Collection<String> fileNames__                try {_                    metadata = store.getMetadata(snapshotIndexCommit)__                    fileNames = snapshotIndexCommit.getFileNames()__                } catch (IOException e) {_                    throw new IndexShardSnapshotFailedException(shardId, "Failed to get store file metadata", e)__                }_                for (String fileName : fileNames) {_                    if (snapshotStatus.isAborted()) {_                        logger.debug("[{}] [{}] Aborted on the file [{}], exiting", shardId, snapshotId, fileName)__                        throw new IndexShardSnapshotFailedException(shardId, "Aborted")__                    }__                    logger.trace("[{}] [{}] Processing [{}]", shardId, snapshotId, fileName)__                    final StoreFileMetaData md = metadata.get(fileName)__                    BlobStoreIndexShardSnapshot.FileInfo existingFileInfo = null__                    List<BlobStoreIndexShardSnapshot.FileInfo> filesInfo = snapshots.findPhysicalIndexFiles(fileName)__                    if (filesInfo != null) {_                        for (BlobStoreIndexShardSnapshot.FileInfo fileInfo : filesInfo) {_                            try {_                                _                                _                                _                                _                                maybeRecalculateMetadataHash(blobContainer, fileInfo, metadata)__                            } catch (Exception e) {_                                logger.warn(() -> new ParameterizedMessage("{} Can't calculate hash from blob for file [{}] [{}]", shardId, fileInfo.physicalName(), fileInfo.metadata()), e)__                            }_                            if (fileInfo.isSame(md) && snapshotFileExistsInBlobs(fileInfo, blobs)) {_                                _                                _                                existingFileInfo = fileInfo__                                break__                            }_                        }_                    }_                    if (existingFileInfo == null) {_                        indexNumberOfFiles++__                        indexTotalFilesSize += md.length()__                        _                        BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo = new BlobStoreIndexShardSnapshot.FileInfo(fileNameFromGeneration(++generation), md, chunkSize())__                        indexCommitPointFiles.add(snapshotFileInfo)__                        filesToSnapshot.add(snapshotFileInfo)__                    } else {_                        indexCommitPointFiles.add(existingFileInfo)__                    }_                }__                snapshotStatus.moveToStarted(startTime, indexNumberOfFiles, indexTotalFilesSize)___                for (BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo : filesToSnapshot) {_                    try {_                        snapshotFile(snapshotFileInfo)__                    } catch (IOException e) {_                        throw new IndexShardSnapshotFailedException(shardId, "Failed to perform snapshot (index files)", e)__                    }_                }_            } finally {_                store.decRef()__            }__            final IndexShardSnapshotStatus.Copy lastSnapshotStatus = snapshotStatus.moveToFinalize(snapshotIndexCommit.getGeneration())___            _            final BlobStoreIndexShardSnapshot snapshot = new BlobStoreIndexShardSnapshot(snapshotId.getName(),_                                                                        lastSnapshotStatus.getIndexVersion(),_                                                                        indexCommitPointFiles,_                                                                        lastSnapshotStatus.getStartTime(),_                                                                        _                                                                        _                                                                        System.currentTimeMillis() - lastSnapshotStatus.getStartTime(),_                                                                        lastSnapshotStatus.getNumberOfFiles(),_                                                                        lastSnapshotStatus.getTotalSize())___            _            logger.trace("[{}] [{}] writing shard snapshot file", shardId, snapshotId)__            try {_                indexShardSnapshotFormat.write(snapshot, blobContainer, snapshotId.getUUID())__            } catch (IOException e) {_                throw new IndexShardSnapshotFailedException(shardId, "Failed to write commit point", e)__            }__            _            _            List<SnapshotFiles> newSnapshotsList = new ArrayList<>()__            newSnapshotsList.add(new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles()))__            for (SnapshotFiles point : snapshots) {_                newSnapshotsList.add(point)__            }_            _            finalize(newSnapshotsList, fileListGeneration + 1, blobs, "snapshot creation [" + snapshotId + "]")__            snapshotStatus.moveToDone(System.currentTimeMillis())___        };create,snapshot,from,index,commit,point,param,snapshot,index,commit,snapshot,commit,point;public,void,snapshot,final,index,commit,snapshot,index,commit,logger,debug,snapshot,to,shard,id,snapshot,id,metadata,name,final,map,string,blob,meta,data,blobs,try,blobs,blob,container,list,blobs,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,list,blobs,e,long,generation,find,latest,file,name,generation,blobs,tuple,blob,store,index,shard,snapshots,integer,tuple,build,blob,store,index,shard,snapshots,blobs,blob,store,index,shard,snapshots,snapshots,tuple,v1,int,file,list,generation,tuple,v2,if,snapshots,snapshots,stream,any,match,sf,sf,snapshot,equals,snapshot,id,get,name,throw,new,index,shard,snapshot,failed,exception,shard,id,duplicate,snapshot,name,snapshot,id,get,name,detected,aborting,final,list,blob,store,index,shard,snapshot,file,info,index,commit,point,files,new,array,list,store,inc,ref,try,int,index,number,of,files,0,long,index,total,files,size,0,array,list,blob,store,index,shard,snapshot,file,info,files,to,snapshot,new,array,list,final,store,metadata,snapshot,metadata,final,collection,string,file,names,try,metadata,store,get,metadata,snapshot,index,commit,file,names,snapshot,index,commit,get,file,names,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,get,store,file,metadata,e,for,string,file,name,file,names,if,snapshot,status,is,aborted,logger,debug,aborted,on,the,file,exiting,shard,id,snapshot,id,file,name,throw,new,index,shard,snapshot,failed,exception,shard,id,aborted,logger,trace,processing,shard,id,snapshot,id,file,name,final,store,file,meta,data,md,metadata,get,file,name,blob,store,index,shard,snapshot,file,info,existing,file,info,null,list,blob,store,index,shard,snapshot,file,info,files,info,snapshots,find,physical,index,files,file,name,if,files,info,null,for,blob,store,index,shard,snapshot,file,info,file,info,files,info,try,maybe,recalculate,metadata,hash,blob,container,file,info,metadata,catch,exception,e,logger,warn,new,parameterized,message,can,t,calculate,hash,from,blob,for,file,shard,id,file,info,physical,name,file,info,metadata,e,if,file,info,is,same,md,snapshot,file,exists,in,blobs,file,info,blobs,existing,file,info,file,info,break,if,existing,file,info,null,index,number,of,files,index,total,files,size,md,length,blob,store,index,shard,snapshot,file,info,snapshot,file,info,new,blob,store,index,shard,snapshot,file,info,file,name,from,generation,generation,md,chunk,size,index,commit,point,files,add,snapshot,file,info,files,to,snapshot,add,snapshot,file,info,else,index,commit,point,files,add,existing,file,info,snapshot,status,move,to,started,start,time,index,number,of,files,index,total,files,size,for,blob,store,index,shard,snapshot,file,info,snapshot,file,info,files,to,snapshot,try,snapshot,file,snapshot,file,info,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,perform,snapshot,index,files,e,finally,store,dec,ref,final,index,shard,snapshot,status,copy,last,snapshot,status,snapshot,status,move,to,finalize,snapshot,index,commit,get,generation,final,blob,store,index,shard,snapshot,snapshot,new,blob,store,index,shard,snapshot,snapshot,id,get,name,last,snapshot,status,get,index,version,index,commit,point,files,last,snapshot,status,get,start,time,system,current,time,millis,last,snapshot,status,get,start,time,last,snapshot,status,get,number,of,files,last,snapshot,status,get,total,size,logger,trace,writing,shard,snapshot,file,shard,id,snapshot,id,try,index,shard,snapshot,format,write,snapshot,blob,container,snapshot,id,get,uuid,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,write,commit,point,e,list,snapshot,files,new,snapshots,list,new,array,list,new,snapshots,list,add,new,snapshot,files,snapshot,snapshot,snapshot,index,files,for,snapshot,files,point,snapshots,new,snapshots,list,add,point,finalize,new,snapshots,list,file,list,generation,1,blobs,snapshot,creation,snapshot,id,snapshot,status,move,to,done,system,current,time,millis
BlobStoreRepository -> SnapshotContext -> public void snapshot(final IndexCommit snapshotIndexCommit);1526574077;Create snapshot from index commit point__@param snapshotIndexCommit snapshot commit point;public void snapshot(final IndexCommit snapshotIndexCommit) {_            logger.debug("[{}] [{}] snapshot to [{}] ...", shardId, snapshotId, metadata.name())___            final Map<String, BlobMetaData> blobs__            try {_                blobs = blobContainer.listBlobs()__            } catch (IOException e) {_                throw new IndexShardSnapshotFailedException(shardId, "failed to list blobs", e)__            }__            long generation = findLatestFileNameGeneration(blobs)__            Tuple<BlobStoreIndexShardSnapshots, Integer> tuple = buildBlobStoreIndexShardSnapshots(blobs)__            BlobStoreIndexShardSnapshots snapshots = tuple.v1()__            int fileListGeneration = tuple.v2()___            if (snapshots.snapshots().stream().anyMatch(sf -> sf.snapshot().equals(snapshotId.getName()))) {_                throw new IndexShardSnapshotFailedException(shardId,_                    "Duplicate snapshot name [" + snapshotId.getName() + "] detected, aborting")__            }__            final List<BlobStoreIndexShardSnapshot.FileInfo> indexCommitPointFiles = new ArrayList<>()___            store.incRef()__            try {_                int indexNumberOfFiles = 0__                long indexTotalFilesSize = 0__                ArrayList<BlobStoreIndexShardSnapshot.FileInfo> filesToSnapshot = new ArrayList<>()__                final Store.MetadataSnapshot metadata__                _                final Collection<String> fileNames__                try {_                    logger.trace("[{}] [{}] Loading store metadata using index commit [{}]", shardId, snapshotId, snapshotIndexCommit)__                    metadata = store.getMetadata(snapshotIndexCommit)__                    fileNames = snapshotIndexCommit.getFileNames()__                } catch (IOException e) {_                    throw new IndexShardSnapshotFailedException(shardId, "Failed to get store file metadata", e)__                }_                for (String fileName : fileNames) {_                    if (snapshotStatus.isAborted()) {_                        logger.debug("[{}] [{}] Aborted on the file [{}], exiting", shardId, snapshotId, fileName)__                        throw new IndexShardSnapshotFailedException(shardId, "Aborted")__                    }__                    logger.trace("[{}] [{}] Processing [{}]", shardId, snapshotId, fileName)__                    final StoreFileMetaData md = metadata.get(fileName)__                    BlobStoreIndexShardSnapshot.FileInfo existingFileInfo = null__                    List<BlobStoreIndexShardSnapshot.FileInfo> filesInfo = snapshots.findPhysicalIndexFiles(fileName)__                    if (filesInfo != null) {_                        for (BlobStoreIndexShardSnapshot.FileInfo fileInfo : filesInfo) {_                            try {_                                _                                _                                _                                _                                maybeRecalculateMetadataHash(blobContainer, fileInfo, metadata)__                            } catch (Exception e) {_                                logger.warn(() -> new ParameterizedMessage("{} Can't calculate hash from blob for file [{}] [{}]", shardId, fileInfo.physicalName(), fileInfo.metadata()), e)__                            }_                            if (fileInfo.isSame(md) && snapshotFileExistsInBlobs(fileInfo, blobs)) {_                                _                                _                                existingFileInfo = fileInfo__                                break__                            }_                        }_                    }_                    if (existingFileInfo == null) {_                        indexNumberOfFiles++__                        indexTotalFilesSize += md.length()__                        _                        BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo = new BlobStoreIndexShardSnapshot.FileInfo(fileNameFromGeneration(++generation), md, chunkSize())__                        indexCommitPointFiles.add(snapshotFileInfo)__                        filesToSnapshot.add(snapshotFileInfo)__                    } else {_                        indexCommitPointFiles.add(existingFileInfo)__                    }_                }__                snapshotStatus.moveToStarted(startTime, indexNumberOfFiles, indexTotalFilesSize)___                for (BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo : filesToSnapshot) {_                    try {_                        snapshotFile(snapshotFileInfo)__                    } catch (IOException e) {_                        throw new IndexShardSnapshotFailedException(shardId, "Failed to perform snapshot (index files)", e)__                    }_                }_            } finally {_                store.decRef()__            }__            final IndexShardSnapshotStatus.Copy lastSnapshotStatus = snapshotStatus.moveToFinalize(snapshotIndexCommit.getGeneration())___            _            final BlobStoreIndexShardSnapshot snapshot = new BlobStoreIndexShardSnapshot(snapshotId.getName(),_                                                                        lastSnapshotStatus.getIndexVersion(),_                                                                        indexCommitPointFiles,_                                                                        lastSnapshotStatus.getStartTime(),_                                                                        _                                                                        _                                                                        System.currentTimeMillis() - lastSnapshotStatus.getStartTime(),_                                                                        lastSnapshotStatus.getNumberOfFiles(),_                                                                        lastSnapshotStatus.getTotalSize())___            _            logger.trace("[{}] [{}] writing shard snapshot file", shardId, snapshotId)__            try {_                indexShardSnapshotFormat.write(snapshot, blobContainer, snapshotId.getUUID())__            } catch (IOException e) {_                throw new IndexShardSnapshotFailedException(shardId, "Failed to write commit point", e)__            }__            _            _            List<SnapshotFiles> newSnapshotsList = new ArrayList<>()__            newSnapshotsList.add(new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles()))__            for (SnapshotFiles point : snapshots) {_                newSnapshotsList.add(point)__            }_            _            finalize(newSnapshotsList, fileListGeneration + 1, blobs, "snapshot creation [" + snapshotId + "]")__            snapshotStatus.moveToDone(System.currentTimeMillis())___        };create,snapshot,from,index,commit,point,param,snapshot,index,commit,snapshot,commit,point;public,void,snapshot,final,index,commit,snapshot,index,commit,logger,debug,snapshot,to,shard,id,snapshot,id,metadata,name,final,map,string,blob,meta,data,blobs,try,blobs,blob,container,list,blobs,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,list,blobs,e,long,generation,find,latest,file,name,generation,blobs,tuple,blob,store,index,shard,snapshots,integer,tuple,build,blob,store,index,shard,snapshots,blobs,blob,store,index,shard,snapshots,snapshots,tuple,v1,int,file,list,generation,tuple,v2,if,snapshots,snapshots,stream,any,match,sf,sf,snapshot,equals,snapshot,id,get,name,throw,new,index,shard,snapshot,failed,exception,shard,id,duplicate,snapshot,name,snapshot,id,get,name,detected,aborting,final,list,blob,store,index,shard,snapshot,file,info,index,commit,point,files,new,array,list,store,inc,ref,try,int,index,number,of,files,0,long,index,total,files,size,0,array,list,blob,store,index,shard,snapshot,file,info,files,to,snapshot,new,array,list,final,store,metadata,snapshot,metadata,final,collection,string,file,names,try,logger,trace,loading,store,metadata,using,index,commit,shard,id,snapshot,id,snapshot,index,commit,metadata,store,get,metadata,snapshot,index,commit,file,names,snapshot,index,commit,get,file,names,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,get,store,file,metadata,e,for,string,file,name,file,names,if,snapshot,status,is,aborted,logger,debug,aborted,on,the,file,exiting,shard,id,snapshot,id,file,name,throw,new,index,shard,snapshot,failed,exception,shard,id,aborted,logger,trace,processing,shard,id,snapshot,id,file,name,final,store,file,meta,data,md,metadata,get,file,name,blob,store,index,shard,snapshot,file,info,existing,file,info,null,list,blob,store,index,shard,snapshot,file,info,files,info,snapshots,find,physical,index,files,file,name,if,files,info,null,for,blob,store,index,shard,snapshot,file,info,file,info,files,info,try,maybe,recalculate,metadata,hash,blob,container,file,info,metadata,catch,exception,e,logger,warn,new,parameterized,message,can,t,calculate,hash,from,blob,for,file,shard,id,file,info,physical,name,file,info,metadata,e,if,file,info,is,same,md,snapshot,file,exists,in,blobs,file,info,blobs,existing,file,info,file,info,break,if,existing,file,info,null,index,number,of,files,index,total,files,size,md,length,blob,store,index,shard,snapshot,file,info,snapshot,file,info,new,blob,store,index,shard,snapshot,file,info,file,name,from,generation,generation,md,chunk,size,index,commit,point,files,add,snapshot,file,info,files,to,snapshot,add,snapshot,file,info,else,index,commit,point,files,add,existing,file,info,snapshot,status,move,to,started,start,time,index,number,of,files,index,total,files,size,for,blob,store,index,shard,snapshot,file,info,snapshot,file,info,files,to,snapshot,try,snapshot,file,snapshot,file,info,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,perform,snapshot,index,files,e,finally,store,dec,ref,final,index,shard,snapshot,status,copy,last,snapshot,status,snapshot,status,move,to,finalize,snapshot,index,commit,get,generation,final,blob,store,index,shard,snapshot,snapshot,new,blob,store,index,shard,snapshot,snapshot,id,get,name,last,snapshot,status,get,index,version,index,commit,point,files,last,snapshot,status,get,start,time,system,current,time,millis,last,snapshot,status,get,start,time,last,snapshot,status,get,number,of,files,last,snapshot,status,get,total,size,logger,trace,writing,shard,snapshot,file,shard,id,snapshot,id,try,index,shard,snapshot,format,write,snapshot,blob,container,snapshot,id,get,uuid,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,write,commit,point,e,list,snapshot,files,new,snapshots,list,new,array,list,new,snapshots,list,add,new,snapshot,files,snapshot,snapshot,snapshot,index,files,for,snapshot,files,point,snapshots,new,snapshots,list,add,point,finalize,new,snapshots,list,file,list,generation,1,blobs,snapshot,creation,snapshot,id,snapshot,status,move,to,done,system,current,time,millis
BlobStoreRepository -> SnapshotContext -> public void snapshot(final IndexCommit snapshotIndexCommit);1527583663;Create snapshot from index commit point__@param snapshotIndexCommit snapshot commit point;public void snapshot(final IndexCommit snapshotIndexCommit) {_            logger.debug("[{}] [{}] snapshot to [{}] ...", shardId, snapshotId, metadata.name())___            final Map<String, BlobMetaData> blobs__            try {_                blobs = blobContainer.listBlobs()__            } catch (IOException e) {_                throw new IndexShardSnapshotFailedException(shardId, "failed to list blobs", e)__            }__            long generation = findLatestFileNameGeneration(blobs)__            Tuple<BlobStoreIndexShardSnapshots, Integer> tuple = buildBlobStoreIndexShardSnapshots(blobs)__            BlobStoreIndexShardSnapshots snapshots = tuple.v1()__            int fileListGeneration = tuple.v2()___            if (snapshots.snapshots().stream().anyMatch(sf -> sf.snapshot().equals(snapshotId.getName()))) {_                throw new IndexShardSnapshotFailedException(shardId,_                    "Duplicate snapshot name [" + snapshotId.getName() + "] detected, aborting")__            }__            final List<BlobStoreIndexShardSnapshot.FileInfo> indexCommitPointFiles = new ArrayList<>()___            store.incRef()__            int indexIncrementalFileCount = 0__            int indexTotalNumberOfFiles = 0__            long indexIncrementalSize = 0__            long indexTotalFileCount = 0__            try {_                ArrayList<BlobStoreIndexShardSnapshot.FileInfo> filesToSnapshot = new ArrayList<>()__                final Store.MetadataSnapshot metadata__                _                final Collection<String> fileNames__                try {_                    logger.trace("[{}] [{}] Loading store metadata using index commit [{}]", shardId, snapshotId, snapshotIndexCommit)__                    metadata = store.getMetadata(snapshotIndexCommit)__                    fileNames = snapshotIndexCommit.getFileNames()__                } catch (IOException e) {_                    throw new IndexShardSnapshotFailedException(shardId, "Failed to get store file metadata", e)__                }_                for (String fileName : fileNames) {_                    if (snapshotStatus.isAborted()) {_                        logger.debug("[{}] [{}] Aborted on the file [{}], exiting", shardId, snapshotId, fileName)__                        throw new IndexShardSnapshotFailedException(shardId, "Aborted")__                    }__                    logger.trace("[{}] [{}] Processing [{}]", shardId, snapshotId, fileName)__                    final StoreFileMetaData md = metadata.get(fileName)__                    BlobStoreIndexShardSnapshot.FileInfo existingFileInfo = null__                    List<BlobStoreIndexShardSnapshot.FileInfo> filesInfo = snapshots.findPhysicalIndexFiles(fileName)__                    if (filesInfo != null) {_                        for (BlobStoreIndexShardSnapshot.FileInfo fileInfo : filesInfo) {_                            try {_                                _                                _                                _                                _                                maybeRecalculateMetadataHash(blobContainer, fileInfo, metadata)__                            } catch (Exception e) {_                                logger.warn(() -> new ParameterizedMessage("{} Can't calculate hash from blob for file [{}] [{}]", shardId, fileInfo.physicalName(), fileInfo.metadata()), e)__                            }_                            if (fileInfo.isSame(md) && snapshotFileExistsInBlobs(fileInfo, blobs)) {_                                _                                _                                existingFileInfo = fileInfo__                                break__                            }_                        }_                    }__                    indexTotalFileCount += md.length()__                    indexTotalNumberOfFiles++___                    if (existingFileInfo == null) {_                        indexIncrementalFileCount++__                        indexIncrementalSize += md.length()__                        _                        BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo = new BlobStoreIndexShardSnapshot.FileInfo(fileNameFromGeneration(++generation), md, chunkSize())__                        indexCommitPointFiles.add(snapshotFileInfo)__                        filesToSnapshot.add(snapshotFileInfo)__                    } else {_                        indexCommitPointFiles.add(existingFileInfo)__                    }_                }__                snapshotStatus.moveToStarted(startTime, indexIncrementalFileCount,_                    indexTotalNumberOfFiles, indexIncrementalSize, indexTotalFileCount)___                for (BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo : filesToSnapshot) {_                    try {_                        snapshotFile(snapshotFileInfo)__                    } catch (IOException e) {_                        throw new IndexShardSnapshotFailedException(shardId, "Failed to perform snapshot (index files)", e)__                    }_                }_            } finally {_                store.decRef()__            }__            final IndexShardSnapshotStatus.Copy lastSnapshotStatus = snapshotStatus.moveToFinalize(snapshotIndexCommit.getGeneration())___            _            final BlobStoreIndexShardSnapshot snapshot = new BlobStoreIndexShardSnapshot(snapshotId.getName(),_                                                                        lastSnapshotStatus.getIndexVersion(),_                                                                        indexCommitPointFiles,_                                                                        lastSnapshotStatus.getStartTime(),_                                                                        _                                                                        _                                                                        System.currentTimeMillis() - lastSnapshotStatus.getStartTime(),_                                                                        lastSnapshotStatus.getIncrementalFileCount(),_                                                                        lastSnapshotStatus.getIncrementalSize()_            )___            _            logger.trace("[{}] [{}] writing shard snapshot file", shardId, snapshotId)__            try {_                indexShardSnapshotFormat.write(snapshot, blobContainer, snapshotId.getUUID())__            } catch (IOException e) {_                throw new IndexShardSnapshotFailedException(shardId, "Failed to write commit point", e)__            }__            _            _            List<SnapshotFiles> newSnapshotsList = new ArrayList<>()__            newSnapshotsList.add(new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles()))__            for (SnapshotFiles point : snapshots) {_                newSnapshotsList.add(point)__            }_            _            finalize(newSnapshotsList, fileListGeneration + 1, blobs, "snapshot creation [" + snapshotId + "]")__            snapshotStatus.moveToDone(System.currentTimeMillis())___        };create,snapshot,from,index,commit,point,param,snapshot,index,commit,snapshot,commit,point;public,void,snapshot,final,index,commit,snapshot,index,commit,logger,debug,snapshot,to,shard,id,snapshot,id,metadata,name,final,map,string,blob,meta,data,blobs,try,blobs,blob,container,list,blobs,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,list,blobs,e,long,generation,find,latest,file,name,generation,blobs,tuple,blob,store,index,shard,snapshots,integer,tuple,build,blob,store,index,shard,snapshots,blobs,blob,store,index,shard,snapshots,snapshots,tuple,v1,int,file,list,generation,tuple,v2,if,snapshots,snapshots,stream,any,match,sf,sf,snapshot,equals,snapshot,id,get,name,throw,new,index,shard,snapshot,failed,exception,shard,id,duplicate,snapshot,name,snapshot,id,get,name,detected,aborting,final,list,blob,store,index,shard,snapshot,file,info,index,commit,point,files,new,array,list,store,inc,ref,int,index,incremental,file,count,0,int,index,total,number,of,files,0,long,index,incremental,size,0,long,index,total,file,count,0,try,array,list,blob,store,index,shard,snapshot,file,info,files,to,snapshot,new,array,list,final,store,metadata,snapshot,metadata,final,collection,string,file,names,try,logger,trace,loading,store,metadata,using,index,commit,shard,id,snapshot,id,snapshot,index,commit,metadata,store,get,metadata,snapshot,index,commit,file,names,snapshot,index,commit,get,file,names,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,get,store,file,metadata,e,for,string,file,name,file,names,if,snapshot,status,is,aborted,logger,debug,aborted,on,the,file,exiting,shard,id,snapshot,id,file,name,throw,new,index,shard,snapshot,failed,exception,shard,id,aborted,logger,trace,processing,shard,id,snapshot,id,file,name,final,store,file,meta,data,md,metadata,get,file,name,blob,store,index,shard,snapshot,file,info,existing,file,info,null,list,blob,store,index,shard,snapshot,file,info,files,info,snapshots,find,physical,index,files,file,name,if,files,info,null,for,blob,store,index,shard,snapshot,file,info,file,info,files,info,try,maybe,recalculate,metadata,hash,blob,container,file,info,metadata,catch,exception,e,logger,warn,new,parameterized,message,can,t,calculate,hash,from,blob,for,file,shard,id,file,info,physical,name,file,info,metadata,e,if,file,info,is,same,md,snapshot,file,exists,in,blobs,file,info,blobs,existing,file,info,file,info,break,index,total,file,count,md,length,index,total,number,of,files,if,existing,file,info,null,index,incremental,file,count,index,incremental,size,md,length,blob,store,index,shard,snapshot,file,info,snapshot,file,info,new,blob,store,index,shard,snapshot,file,info,file,name,from,generation,generation,md,chunk,size,index,commit,point,files,add,snapshot,file,info,files,to,snapshot,add,snapshot,file,info,else,index,commit,point,files,add,existing,file,info,snapshot,status,move,to,started,start,time,index,incremental,file,count,index,total,number,of,files,index,incremental,size,index,total,file,count,for,blob,store,index,shard,snapshot,file,info,snapshot,file,info,files,to,snapshot,try,snapshot,file,snapshot,file,info,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,perform,snapshot,index,files,e,finally,store,dec,ref,final,index,shard,snapshot,status,copy,last,snapshot,status,snapshot,status,move,to,finalize,snapshot,index,commit,get,generation,final,blob,store,index,shard,snapshot,snapshot,new,blob,store,index,shard,snapshot,snapshot,id,get,name,last,snapshot,status,get,index,version,index,commit,point,files,last,snapshot,status,get,start,time,system,current,time,millis,last,snapshot,status,get,start,time,last,snapshot,status,get,incremental,file,count,last,snapshot,status,get,incremental,size,logger,trace,writing,shard,snapshot,file,shard,id,snapshot,id,try,index,shard,snapshot,format,write,snapshot,blob,container,snapshot,id,get,uuid,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,write,commit,point,e,list,snapshot,files,new,snapshots,list,new,array,list,new,snapshots,list,add,new,snapshot,files,snapshot,snapshot,snapshot,index,files,for,snapshot,files,point,snapshots,new,snapshots,list,add,point,finalize,new,snapshots,list,file,list,generation,1,blobs,snapshot,creation,snapshot,id,snapshot,status,move,to,done,system,current,time,millis
BlobStoreRepository -> SnapshotContext -> public void snapshot(final IndexCommit snapshotIndexCommit);1528211342;Create snapshot from index commit point__@param snapshotIndexCommit snapshot commit point;public void snapshot(final IndexCommit snapshotIndexCommit) {_            logger.debug("[{}] [{}] snapshot to [{}] ...", shardId, snapshotId, metadata.name())___            final Map<String, BlobMetaData> blobs__            try {_                blobs = blobContainer.listBlobs()__            } catch (IOException e) {_                throw new IndexShardSnapshotFailedException(shardId, "failed to list blobs", e)__            }__            long generation = findLatestFileNameGeneration(blobs)__            Tuple<BlobStoreIndexShardSnapshots, Integer> tuple = buildBlobStoreIndexShardSnapshots(blobs)__            BlobStoreIndexShardSnapshots snapshots = tuple.v1()__            int fileListGeneration = tuple.v2()___            if (snapshots.snapshots().stream().anyMatch(sf -> sf.snapshot().equals(snapshotId.getName()))) {_                throw new IndexShardSnapshotFailedException(shardId,_                    "Duplicate snapshot name [" + snapshotId.getName() + "] detected, aborting")__            }__            final List<BlobStoreIndexShardSnapshot.FileInfo> indexCommitPointFiles = new ArrayList<>()___            store.incRef()__            int indexIncrementalFileCount = 0__            int indexTotalNumberOfFiles = 0__            long indexIncrementalSize = 0__            long indexTotalFileCount = 0__            try {_                ArrayList<BlobStoreIndexShardSnapshot.FileInfo> filesToSnapshot = new ArrayList<>()__                final Store.MetadataSnapshot metadata__                _                final Collection<String> fileNames__                try {_                    logger.trace("[{}] [{}] Loading store metadata using index commit [{}]", shardId, snapshotId, snapshotIndexCommit)__                    metadata = store.getMetadata(snapshotIndexCommit)__                    fileNames = snapshotIndexCommit.getFileNames()__                } catch (IOException e) {_                    throw new IndexShardSnapshotFailedException(shardId, "Failed to get store file metadata", e)__                }_                for (String fileName : fileNames) {_                    if (snapshotStatus.isAborted()) {_                        logger.debug("[{}] [{}] Aborted on the file [{}], exiting", shardId, snapshotId, fileName)__                        throw new IndexShardSnapshotFailedException(shardId, "Aborted")__                    }__                    logger.trace("[{}] [{}] Processing [{}]", shardId, snapshotId, fileName)__                    final StoreFileMetaData md = metadata.get(fileName)__                    BlobStoreIndexShardSnapshot.FileInfo existingFileInfo = null__                    List<BlobStoreIndexShardSnapshot.FileInfo> filesInfo = snapshots.findPhysicalIndexFiles(fileName)__                    if (filesInfo != null) {_                        for (BlobStoreIndexShardSnapshot.FileInfo fileInfo : filesInfo) {_                            try {_                                _                                _                                _                                _                                maybeRecalculateMetadataHash(blobContainer, fileInfo, metadata)__                            } catch (Exception e) {_                                logger.warn(() -> new ParameterizedMessage("{} Can't calculate hash from blob for file [{}] [{}]", shardId, fileInfo.physicalName(), fileInfo.metadata()), e)__                            }_                            if (fileInfo.isSame(md) && snapshotFileExistsInBlobs(fileInfo, blobs)) {_                                _                                _                                existingFileInfo = fileInfo__                                break__                            }_                        }_                    }__                    indexTotalFileCount += md.length()__                    indexTotalNumberOfFiles++___                    if (existingFileInfo == null) {_                        indexIncrementalFileCount++__                        indexIncrementalSize += md.length()__                        _                        BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo = new BlobStoreIndexShardSnapshot.FileInfo(fileNameFromGeneration(++generation), md, chunkSize())__                        indexCommitPointFiles.add(snapshotFileInfo)__                        filesToSnapshot.add(snapshotFileInfo)__                    } else {_                        indexCommitPointFiles.add(existingFileInfo)__                    }_                }__                snapshotStatus.moveToStarted(startTime, indexIncrementalFileCount,_                    indexTotalNumberOfFiles, indexIncrementalSize, indexTotalFileCount)___                for (BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo : filesToSnapshot) {_                    try {_                        snapshotFile(snapshotFileInfo)__                    } catch (IOException e) {_                        throw new IndexShardSnapshotFailedException(shardId, "Failed to perform snapshot (index files)", e)__                    }_                }_            } finally {_                store.decRef()__            }__            final IndexShardSnapshotStatus.Copy lastSnapshotStatus = snapshotStatus.moveToFinalize(snapshotIndexCommit.getGeneration())___            _            final BlobStoreIndexShardSnapshot snapshot = new BlobStoreIndexShardSnapshot(snapshotId.getName(),_                                                                        lastSnapshotStatus.getIndexVersion(),_                                                                        indexCommitPointFiles,_                                                                        lastSnapshotStatus.getStartTime(),_                                                                        _                                                                        _                                                                        System.currentTimeMillis() - lastSnapshotStatus.getStartTime(),_                                                                        lastSnapshotStatus.getIncrementalFileCount(),_                                                                        lastSnapshotStatus.getIncrementalSize()_            )___            _            logger.trace("[{}] [{}] writing shard snapshot file", shardId, snapshotId)__            try {_                indexShardSnapshotFormat.write(snapshot, blobContainer, snapshotId.getUUID())__            } catch (IOException e) {_                throw new IndexShardSnapshotFailedException(shardId, "Failed to write commit point", e)__            }__            _            _            List<SnapshotFiles> newSnapshotsList = new ArrayList<>()__            newSnapshotsList.add(new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles()))__            for (SnapshotFiles point : snapshots) {_                newSnapshotsList.add(point)__            }_            _            finalize(newSnapshotsList, fileListGeneration + 1, blobs, "snapshot creation [" + snapshotId + "]")__            snapshotStatus.moveToDone(System.currentTimeMillis())___        };create,snapshot,from,index,commit,point,param,snapshot,index,commit,snapshot,commit,point;public,void,snapshot,final,index,commit,snapshot,index,commit,logger,debug,snapshot,to,shard,id,snapshot,id,metadata,name,final,map,string,blob,meta,data,blobs,try,blobs,blob,container,list,blobs,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,list,blobs,e,long,generation,find,latest,file,name,generation,blobs,tuple,blob,store,index,shard,snapshots,integer,tuple,build,blob,store,index,shard,snapshots,blobs,blob,store,index,shard,snapshots,snapshots,tuple,v1,int,file,list,generation,tuple,v2,if,snapshots,snapshots,stream,any,match,sf,sf,snapshot,equals,snapshot,id,get,name,throw,new,index,shard,snapshot,failed,exception,shard,id,duplicate,snapshot,name,snapshot,id,get,name,detected,aborting,final,list,blob,store,index,shard,snapshot,file,info,index,commit,point,files,new,array,list,store,inc,ref,int,index,incremental,file,count,0,int,index,total,number,of,files,0,long,index,incremental,size,0,long,index,total,file,count,0,try,array,list,blob,store,index,shard,snapshot,file,info,files,to,snapshot,new,array,list,final,store,metadata,snapshot,metadata,final,collection,string,file,names,try,logger,trace,loading,store,metadata,using,index,commit,shard,id,snapshot,id,snapshot,index,commit,metadata,store,get,metadata,snapshot,index,commit,file,names,snapshot,index,commit,get,file,names,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,get,store,file,metadata,e,for,string,file,name,file,names,if,snapshot,status,is,aborted,logger,debug,aborted,on,the,file,exiting,shard,id,snapshot,id,file,name,throw,new,index,shard,snapshot,failed,exception,shard,id,aborted,logger,trace,processing,shard,id,snapshot,id,file,name,final,store,file,meta,data,md,metadata,get,file,name,blob,store,index,shard,snapshot,file,info,existing,file,info,null,list,blob,store,index,shard,snapshot,file,info,files,info,snapshots,find,physical,index,files,file,name,if,files,info,null,for,blob,store,index,shard,snapshot,file,info,file,info,files,info,try,maybe,recalculate,metadata,hash,blob,container,file,info,metadata,catch,exception,e,logger,warn,new,parameterized,message,can,t,calculate,hash,from,blob,for,file,shard,id,file,info,physical,name,file,info,metadata,e,if,file,info,is,same,md,snapshot,file,exists,in,blobs,file,info,blobs,existing,file,info,file,info,break,index,total,file,count,md,length,index,total,number,of,files,if,existing,file,info,null,index,incremental,file,count,index,incremental,size,md,length,blob,store,index,shard,snapshot,file,info,snapshot,file,info,new,blob,store,index,shard,snapshot,file,info,file,name,from,generation,generation,md,chunk,size,index,commit,point,files,add,snapshot,file,info,files,to,snapshot,add,snapshot,file,info,else,index,commit,point,files,add,existing,file,info,snapshot,status,move,to,started,start,time,index,incremental,file,count,index,total,number,of,files,index,incremental,size,index,total,file,count,for,blob,store,index,shard,snapshot,file,info,snapshot,file,info,files,to,snapshot,try,snapshot,file,snapshot,file,info,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,perform,snapshot,index,files,e,finally,store,dec,ref,final,index,shard,snapshot,status,copy,last,snapshot,status,snapshot,status,move,to,finalize,snapshot,index,commit,get,generation,final,blob,store,index,shard,snapshot,snapshot,new,blob,store,index,shard,snapshot,snapshot,id,get,name,last,snapshot,status,get,index,version,index,commit,point,files,last,snapshot,status,get,start,time,system,current,time,millis,last,snapshot,status,get,start,time,last,snapshot,status,get,incremental,file,count,last,snapshot,status,get,incremental,size,logger,trace,writing,shard,snapshot,file,shard,id,snapshot,id,try,index,shard,snapshot,format,write,snapshot,blob,container,snapshot,id,get,uuid,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,write,commit,point,e,list,snapshot,files,new,snapshots,list,new,array,list,new,snapshots,list,add,new,snapshot,files,snapshot,snapshot,snapshot,index,files,for,snapshot,files,point,snapshots,new,snapshots,list,add,point,finalize,new,snapshots,list,file,list,generation,1,blobs,snapshot,creation,snapshot,id,snapshot,status,move,to,done,system,current,time,millis
BlobStoreRepository -> SnapshotContext -> public void snapshot(final IndexCommit snapshotIndexCommit);1531179852;Create snapshot from index commit point__@param snapshotIndexCommit snapshot commit point;public void snapshot(final IndexCommit snapshotIndexCommit) {_            logger.debug("[{}] [{}] snapshot to [{}] ...", shardId, snapshotId, metadata.name())___            final Map<String, BlobMetaData> blobs__            try {_                blobs = blobContainer.listBlobs()__            } catch (IOException e) {_                throw new IndexShardSnapshotFailedException(shardId, "failed to list blobs", e)__            }__            long generation = findLatestFileNameGeneration(blobs)__            Tuple<BlobStoreIndexShardSnapshots, Integer> tuple = buildBlobStoreIndexShardSnapshots(blobs)__            BlobStoreIndexShardSnapshots snapshots = tuple.v1()__            int fileListGeneration = tuple.v2()___            if (snapshots.snapshots().stream().anyMatch(sf -> sf.snapshot().equals(snapshotId.getName()))) {_                throw new IndexShardSnapshotFailedException(shardId,_                    "Duplicate snapshot name [" + snapshotId.getName() + "] detected, aborting")__            }__            final List<BlobStoreIndexShardSnapshot.FileInfo> indexCommitPointFiles = new ArrayList<>()___            store.incRef()__            int indexIncrementalFileCount = 0__            int indexTotalNumberOfFiles = 0__            long indexIncrementalSize = 0__            long indexTotalFileCount = 0__            try {_                ArrayList<BlobStoreIndexShardSnapshot.FileInfo> filesToSnapshot = new ArrayList<>()__                final Store.MetadataSnapshot metadata__                _                final Collection<String> fileNames__                try {_                    logger.trace("[{}] [{}] Loading store metadata using index commit [{}]", shardId, snapshotId, snapshotIndexCommit)__                    metadata = store.getMetadata(snapshotIndexCommit)__                    fileNames = snapshotIndexCommit.getFileNames()__                } catch (IOException e) {_                    throw new IndexShardSnapshotFailedException(shardId, "Failed to get store file metadata", e)__                }_                for (String fileName : fileNames) {_                    if (snapshotStatus.isAborted()) {_                        logger.debug("[{}] [{}] Aborted on the file [{}], exiting", shardId, snapshotId, fileName)__                        throw new IndexShardSnapshotFailedException(shardId, "Aborted")__                    }__                    logger.trace("[{}] [{}] Processing [{}]", shardId, snapshotId, fileName)__                    final StoreFileMetaData md = metadata.get(fileName)__                    BlobStoreIndexShardSnapshot.FileInfo existingFileInfo = null__                    List<BlobStoreIndexShardSnapshot.FileInfo> filesInfo = snapshots.findPhysicalIndexFiles(fileName)__                    if (filesInfo != null) {_                        for (BlobStoreIndexShardSnapshot.FileInfo fileInfo : filesInfo) {_                            try {_                                _                                _                                _                                _                                maybeRecalculateMetadataHash(blobContainer, fileInfo, metadata)__                            } catch (Exception e) {_                                logger.warn(() -> new ParameterizedMessage("{} Can't calculate hash from blob for file [{}] [{}]", shardId, fileInfo.physicalName(), fileInfo.metadata()), e)__                            }_                            if (fileInfo.isSame(md) && snapshotFileExistsInBlobs(fileInfo, blobs)) {_                                _                                _                                existingFileInfo = fileInfo__                                break__                            }_                        }_                    }__                    indexTotalFileCount += md.length()__                    indexTotalNumberOfFiles++___                    if (existingFileInfo == null) {_                        indexIncrementalFileCount++__                        indexIncrementalSize += md.length()__                        _                        BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo = new BlobStoreIndexShardSnapshot.FileInfo(fileNameFromGeneration(++generation), md, chunkSize())__                        indexCommitPointFiles.add(snapshotFileInfo)__                        filesToSnapshot.add(snapshotFileInfo)__                    } else {_                        indexCommitPointFiles.add(existingFileInfo)__                    }_                }__                snapshotStatus.moveToStarted(startTime, indexIncrementalFileCount,_                    indexTotalNumberOfFiles, indexIncrementalSize, indexTotalFileCount)___                for (BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo : filesToSnapshot) {_                    try {_                        snapshotFile(snapshotFileInfo)__                    } catch (IOException e) {_                        throw new IndexShardSnapshotFailedException(shardId, "Failed to perform snapshot (index files)", e)__                    }_                }_            } finally {_                store.decRef()__            }__            final IndexShardSnapshotStatus.Copy lastSnapshotStatus = snapshotStatus.moveToFinalize(snapshotIndexCommit.getGeneration())___            _            final BlobStoreIndexShardSnapshot snapshot = new BlobStoreIndexShardSnapshot(snapshotId.getName(),_                                                                        lastSnapshotStatus.getIndexVersion(),_                                                                        indexCommitPointFiles,_                                                                        lastSnapshotStatus.getStartTime(),_                                                                        _                                                                        _                                                                        System.currentTimeMillis() - lastSnapshotStatus.getStartTime(),_                                                                        lastSnapshotStatus.getIncrementalFileCount(),_                                                                        lastSnapshotStatus.getIncrementalSize()_            )___            _            logger.trace("[{}] [{}] writing shard snapshot file", shardId, snapshotId)__            try {_                indexShardSnapshotFormat.write(snapshot, blobContainer, snapshotId.getUUID())__            } catch (IOException e) {_                throw new IndexShardSnapshotFailedException(shardId, "Failed to write commit point", e)__            }__            _            _            List<SnapshotFiles> newSnapshotsList = new ArrayList<>()__            newSnapshotsList.add(new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles()))__            for (SnapshotFiles point : snapshots) {_                newSnapshotsList.add(point)__            }_            _            finalize(newSnapshotsList, fileListGeneration + 1, blobs, "snapshot creation [" + snapshotId + "]")__            snapshotStatus.moveToDone(System.currentTimeMillis())___        };create,snapshot,from,index,commit,point,param,snapshot,index,commit,snapshot,commit,point;public,void,snapshot,final,index,commit,snapshot,index,commit,logger,debug,snapshot,to,shard,id,snapshot,id,metadata,name,final,map,string,blob,meta,data,blobs,try,blobs,blob,container,list,blobs,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,list,blobs,e,long,generation,find,latest,file,name,generation,blobs,tuple,blob,store,index,shard,snapshots,integer,tuple,build,blob,store,index,shard,snapshots,blobs,blob,store,index,shard,snapshots,snapshots,tuple,v1,int,file,list,generation,tuple,v2,if,snapshots,snapshots,stream,any,match,sf,sf,snapshot,equals,snapshot,id,get,name,throw,new,index,shard,snapshot,failed,exception,shard,id,duplicate,snapshot,name,snapshot,id,get,name,detected,aborting,final,list,blob,store,index,shard,snapshot,file,info,index,commit,point,files,new,array,list,store,inc,ref,int,index,incremental,file,count,0,int,index,total,number,of,files,0,long,index,incremental,size,0,long,index,total,file,count,0,try,array,list,blob,store,index,shard,snapshot,file,info,files,to,snapshot,new,array,list,final,store,metadata,snapshot,metadata,final,collection,string,file,names,try,logger,trace,loading,store,metadata,using,index,commit,shard,id,snapshot,id,snapshot,index,commit,metadata,store,get,metadata,snapshot,index,commit,file,names,snapshot,index,commit,get,file,names,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,get,store,file,metadata,e,for,string,file,name,file,names,if,snapshot,status,is,aborted,logger,debug,aborted,on,the,file,exiting,shard,id,snapshot,id,file,name,throw,new,index,shard,snapshot,failed,exception,shard,id,aborted,logger,trace,processing,shard,id,snapshot,id,file,name,final,store,file,meta,data,md,metadata,get,file,name,blob,store,index,shard,snapshot,file,info,existing,file,info,null,list,blob,store,index,shard,snapshot,file,info,files,info,snapshots,find,physical,index,files,file,name,if,files,info,null,for,blob,store,index,shard,snapshot,file,info,file,info,files,info,try,maybe,recalculate,metadata,hash,blob,container,file,info,metadata,catch,exception,e,logger,warn,new,parameterized,message,can,t,calculate,hash,from,blob,for,file,shard,id,file,info,physical,name,file,info,metadata,e,if,file,info,is,same,md,snapshot,file,exists,in,blobs,file,info,blobs,existing,file,info,file,info,break,index,total,file,count,md,length,index,total,number,of,files,if,existing,file,info,null,index,incremental,file,count,index,incremental,size,md,length,blob,store,index,shard,snapshot,file,info,snapshot,file,info,new,blob,store,index,shard,snapshot,file,info,file,name,from,generation,generation,md,chunk,size,index,commit,point,files,add,snapshot,file,info,files,to,snapshot,add,snapshot,file,info,else,index,commit,point,files,add,existing,file,info,snapshot,status,move,to,started,start,time,index,incremental,file,count,index,total,number,of,files,index,incremental,size,index,total,file,count,for,blob,store,index,shard,snapshot,file,info,snapshot,file,info,files,to,snapshot,try,snapshot,file,snapshot,file,info,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,perform,snapshot,index,files,e,finally,store,dec,ref,final,index,shard,snapshot,status,copy,last,snapshot,status,snapshot,status,move,to,finalize,snapshot,index,commit,get,generation,final,blob,store,index,shard,snapshot,snapshot,new,blob,store,index,shard,snapshot,snapshot,id,get,name,last,snapshot,status,get,index,version,index,commit,point,files,last,snapshot,status,get,start,time,system,current,time,millis,last,snapshot,status,get,start,time,last,snapshot,status,get,incremental,file,count,last,snapshot,status,get,incremental,size,logger,trace,writing,shard,snapshot,file,shard,id,snapshot,id,try,index,shard,snapshot,format,write,snapshot,blob,container,snapshot,id,get,uuid,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,write,commit,point,e,list,snapshot,files,new,snapshots,list,new,array,list,new,snapshots,list,add,new,snapshot,files,snapshot,snapshot,snapshot,index,files,for,snapshot,files,point,snapshots,new,snapshots,list,add,point,finalize,new,snapshots,list,file,list,generation,1,blobs,snapshot,creation,snapshot,id,snapshot,status,move,to,done,system,current,time,millis
BlobStoreRepository -> SnapshotContext -> public void snapshot(final IndexCommit snapshotIndexCommit);1531729807;Create snapshot from index commit point__@param snapshotIndexCommit snapshot commit point;public void snapshot(final IndexCommit snapshotIndexCommit) {_            logger.debug("[{}] [{}] snapshot to [{}] ...", shardId, snapshotId, metadata.name())___            final Map<String, BlobMetaData> blobs__            try {_                blobs = blobContainer.listBlobs()__            } catch (IOException e) {_                throw new IndexShardSnapshotFailedException(shardId, "failed to list blobs", e)__            }__            long generation = findLatestFileNameGeneration(blobs)__            Tuple<BlobStoreIndexShardSnapshots, Integer> tuple = buildBlobStoreIndexShardSnapshots(blobs)__            BlobStoreIndexShardSnapshots snapshots = tuple.v1()__            int fileListGeneration = tuple.v2()___            if (snapshots.snapshots().stream().anyMatch(sf -> sf.snapshot().equals(snapshotId.getName()))) {_                throw new IndexShardSnapshotFailedException(shardId,_                    "Duplicate snapshot name [" + snapshotId.getName() + "] detected, aborting")__            }__            final List<BlobStoreIndexShardSnapshot.FileInfo> indexCommitPointFiles = new ArrayList<>()___            store.incRef()__            int indexIncrementalFileCount = 0__            int indexTotalNumberOfFiles = 0__            long indexIncrementalSize = 0__            long indexTotalFileCount = 0__            try {_                ArrayList<BlobStoreIndexShardSnapshot.FileInfo> filesToSnapshot = new ArrayList<>()__                final Store.MetadataSnapshot metadata__                _                final Collection<String> fileNames__                try {_                    logger.trace("[{}] [{}] Loading store metadata using index commit [{}]", shardId, snapshotId, snapshotIndexCommit)__                    metadata = store.getMetadata(snapshotIndexCommit)__                    fileNames = snapshotIndexCommit.getFileNames()__                } catch (IOException e) {_                    throw new IndexShardSnapshotFailedException(shardId, "Failed to get store file metadata", e)__                }_                for (String fileName : fileNames) {_                    if (snapshotStatus.isAborted()) {_                        logger.debug("[{}] [{}] Aborted on the file [{}], exiting", shardId, snapshotId, fileName)__                        throw new IndexShardSnapshotFailedException(shardId, "Aborted")__                    }__                    logger.trace("[{}] [{}] Processing [{}]", shardId, snapshotId, fileName)__                    final StoreFileMetaData md = metadata.get(fileName)__                    BlobStoreIndexShardSnapshot.FileInfo existingFileInfo = null__                    List<BlobStoreIndexShardSnapshot.FileInfo> filesInfo = snapshots.findPhysicalIndexFiles(fileName)__                    if (filesInfo != null) {_                        for (BlobStoreIndexShardSnapshot.FileInfo fileInfo : filesInfo) {_                            try {_                                _                                _                                _                                _                                maybeRecalculateMetadataHash(blobContainer, fileInfo, metadata)__                            } catch (Exception e) {_                                logger.warn(() -> new ParameterizedMessage("{} Can't calculate hash from blob for file [{}] [{}]", shardId, fileInfo.physicalName(), fileInfo.metadata()), e)__                            }_                            if (fileInfo.isSame(md) && snapshotFileExistsInBlobs(fileInfo, blobs)) {_                                _                                _                                existingFileInfo = fileInfo__                                break__                            }_                        }_                    }__                    indexTotalFileCount += md.length()__                    indexTotalNumberOfFiles++___                    if (existingFileInfo == null) {_                        indexIncrementalFileCount++__                        indexIncrementalSize += md.length()__                        _                        BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo = new BlobStoreIndexShardSnapshot.FileInfo(fileNameFromGeneration(++generation), md, chunkSize())__                        indexCommitPointFiles.add(snapshotFileInfo)__                        filesToSnapshot.add(snapshotFileInfo)__                    } else {_                        indexCommitPointFiles.add(existingFileInfo)__                    }_                }__                snapshotStatus.moveToStarted(startTime, indexIncrementalFileCount,_                    indexTotalNumberOfFiles, indexIncrementalSize, indexTotalFileCount)___                for (BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo : filesToSnapshot) {_                    try {_                        snapshotFile(snapshotFileInfo)__                    } catch (IOException e) {_                        throw new IndexShardSnapshotFailedException(shardId, "Failed to perform snapshot (index files)", e)__                    }_                }_            } finally {_                store.decRef()__            }__            final IndexShardSnapshotStatus.Copy lastSnapshotStatus = snapshotStatus.moveToFinalize(snapshotIndexCommit.getGeneration())___            _            final BlobStoreIndexShardSnapshot snapshot = new BlobStoreIndexShardSnapshot(snapshotId.getName(),_                                                                        lastSnapshotStatus.getIndexVersion(),_                                                                        indexCommitPointFiles,_                                                                        lastSnapshotStatus.getStartTime(),_                                                                        _                                                                        _                                                                        System.currentTimeMillis() - lastSnapshotStatus.getStartTime(),_                                                                        lastSnapshotStatus.getIncrementalFileCount(),_                                                                        lastSnapshotStatus.getIncrementalSize()_            )___            _            logger.trace("[{}] [{}] writing shard snapshot file", shardId, snapshotId)__            try {_                indexShardSnapshotFormat.write(snapshot, blobContainer, snapshotId.getUUID())__            } catch (IOException e) {_                throw new IndexShardSnapshotFailedException(shardId, "Failed to write commit point", e)__            }__            _            _            List<SnapshotFiles> newSnapshotsList = new ArrayList<>()__            newSnapshotsList.add(new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles()))__            for (SnapshotFiles point : snapshots) {_                newSnapshotsList.add(point)__            }_            _            finalize(newSnapshotsList, fileListGeneration + 1, blobs, "snapshot creation [" + snapshotId + "]")__            snapshotStatus.moveToDone(System.currentTimeMillis())___        };create,snapshot,from,index,commit,point,param,snapshot,index,commit,snapshot,commit,point;public,void,snapshot,final,index,commit,snapshot,index,commit,logger,debug,snapshot,to,shard,id,snapshot,id,metadata,name,final,map,string,blob,meta,data,blobs,try,blobs,blob,container,list,blobs,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,list,blobs,e,long,generation,find,latest,file,name,generation,blobs,tuple,blob,store,index,shard,snapshots,integer,tuple,build,blob,store,index,shard,snapshots,blobs,blob,store,index,shard,snapshots,snapshots,tuple,v1,int,file,list,generation,tuple,v2,if,snapshots,snapshots,stream,any,match,sf,sf,snapshot,equals,snapshot,id,get,name,throw,new,index,shard,snapshot,failed,exception,shard,id,duplicate,snapshot,name,snapshot,id,get,name,detected,aborting,final,list,blob,store,index,shard,snapshot,file,info,index,commit,point,files,new,array,list,store,inc,ref,int,index,incremental,file,count,0,int,index,total,number,of,files,0,long,index,incremental,size,0,long,index,total,file,count,0,try,array,list,blob,store,index,shard,snapshot,file,info,files,to,snapshot,new,array,list,final,store,metadata,snapshot,metadata,final,collection,string,file,names,try,logger,trace,loading,store,metadata,using,index,commit,shard,id,snapshot,id,snapshot,index,commit,metadata,store,get,metadata,snapshot,index,commit,file,names,snapshot,index,commit,get,file,names,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,get,store,file,metadata,e,for,string,file,name,file,names,if,snapshot,status,is,aborted,logger,debug,aborted,on,the,file,exiting,shard,id,snapshot,id,file,name,throw,new,index,shard,snapshot,failed,exception,shard,id,aborted,logger,trace,processing,shard,id,snapshot,id,file,name,final,store,file,meta,data,md,metadata,get,file,name,blob,store,index,shard,snapshot,file,info,existing,file,info,null,list,blob,store,index,shard,snapshot,file,info,files,info,snapshots,find,physical,index,files,file,name,if,files,info,null,for,blob,store,index,shard,snapshot,file,info,file,info,files,info,try,maybe,recalculate,metadata,hash,blob,container,file,info,metadata,catch,exception,e,logger,warn,new,parameterized,message,can,t,calculate,hash,from,blob,for,file,shard,id,file,info,physical,name,file,info,metadata,e,if,file,info,is,same,md,snapshot,file,exists,in,blobs,file,info,blobs,existing,file,info,file,info,break,index,total,file,count,md,length,index,total,number,of,files,if,existing,file,info,null,index,incremental,file,count,index,incremental,size,md,length,blob,store,index,shard,snapshot,file,info,snapshot,file,info,new,blob,store,index,shard,snapshot,file,info,file,name,from,generation,generation,md,chunk,size,index,commit,point,files,add,snapshot,file,info,files,to,snapshot,add,snapshot,file,info,else,index,commit,point,files,add,existing,file,info,snapshot,status,move,to,started,start,time,index,incremental,file,count,index,total,number,of,files,index,incremental,size,index,total,file,count,for,blob,store,index,shard,snapshot,file,info,snapshot,file,info,files,to,snapshot,try,snapshot,file,snapshot,file,info,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,perform,snapshot,index,files,e,finally,store,dec,ref,final,index,shard,snapshot,status,copy,last,snapshot,status,snapshot,status,move,to,finalize,snapshot,index,commit,get,generation,final,blob,store,index,shard,snapshot,snapshot,new,blob,store,index,shard,snapshot,snapshot,id,get,name,last,snapshot,status,get,index,version,index,commit,point,files,last,snapshot,status,get,start,time,system,current,time,millis,last,snapshot,status,get,start,time,last,snapshot,status,get,incremental,file,count,last,snapshot,status,get,incremental,size,logger,trace,writing,shard,snapshot,file,shard,id,snapshot,id,try,index,shard,snapshot,format,write,snapshot,blob,container,snapshot,id,get,uuid,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,write,commit,point,e,list,snapshot,files,new,snapshots,list,new,array,list,new,snapshots,list,add,new,snapshot,files,snapshot,snapshot,snapshot,index,files,for,snapshot,files,point,snapshots,new,snapshots,list,add,point,finalize,new,snapshots,list,file,list,generation,1,blobs,snapshot,creation,snapshot,id,snapshot,status,move,to,done,system,current,time,millis
BlobStoreRepository -> SnapshotContext -> public void snapshot(final IndexCommit snapshotIndexCommit);1532685069;Create snapshot from index commit point__@param snapshotIndexCommit snapshot commit point;public void snapshot(final IndexCommit snapshotIndexCommit) {_            logger.debug("[{}] [{}] snapshot to [{}] ...", shardId, snapshotId, metadata.name())___            final Map<String, BlobMetaData> blobs__            try {_                blobs = blobContainer.listBlobs()__            } catch (IOException e) {_                throw new IndexShardSnapshotFailedException(shardId, "failed to list blobs", e)__            }__            long generation = findLatestFileNameGeneration(blobs)__            Tuple<BlobStoreIndexShardSnapshots, Integer> tuple = buildBlobStoreIndexShardSnapshots(blobs)__            BlobStoreIndexShardSnapshots snapshots = tuple.v1()__            int fileListGeneration = tuple.v2()___            if (snapshots.snapshots().stream().anyMatch(sf -> sf.snapshot().equals(snapshotId.getName()))) {_                throw new IndexShardSnapshotFailedException(shardId,_                    "Duplicate snapshot name [" + snapshotId.getName() + "] detected, aborting")__            }__            final List<BlobStoreIndexShardSnapshot.FileInfo> indexCommitPointFiles = new ArrayList<>()___            store.incRef()__            int indexIncrementalFileCount = 0__            int indexTotalNumberOfFiles = 0__            long indexIncrementalSize = 0__            long indexTotalFileCount = 0__            try {_                ArrayList<BlobStoreIndexShardSnapshot.FileInfo> filesToSnapshot = new ArrayList<>()__                final Store.MetadataSnapshot metadata__                _                final Collection<String> fileNames__                try {_                    logger.trace("[{}] [{}] Loading store metadata using index commit [{}]", shardId, snapshotId, snapshotIndexCommit)__                    metadata = store.getMetadata(snapshotIndexCommit)__                    fileNames = snapshotIndexCommit.getFileNames()__                } catch (IOException e) {_                    throw new IndexShardSnapshotFailedException(shardId, "Failed to get store file metadata", e)__                }_                for (String fileName : fileNames) {_                    if (snapshotStatus.isAborted()) {_                        logger.debug("[{}] [{}] Aborted on the file [{}], exiting", shardId, snapshotId, fileName)__                        throw new IndexShardSnapshotFailedException(shardId, "Aborted")__                    }__                    logger.trace("[{}] [{}] Processing [{}]", shardId, snapshotId, fileName)__                    final StoreFileMetaData md = metadata.get(fileName)__                    BlobStoreIndexShardSnapshot.FileInfo existingFileInfo = null__                    List<BlobStoreIndexShardSnapshot.FileInfo> filesInfo = snapshots.findPhysicalIndexFiles(fileName)__                    if (filesInfo != null) {_                        for (BlobStoreIndexShardSnapshot.FileInfo fileInfo : filesInfo) {_                            try {_                                _                                _                                _                                _                                maybeRecalculateMetadataHash(blobContainer, fileInfo, metadata)__                            } catch (Exception e) {_                                logger.warn(() -> new ParameterizedMessage("{} Can't calculate hash from blob for file [{}] [{}]", shardId, fileInfo.physicalName(), fileInfo.metadata()), e)__                            }_                            if (fileInfo.isSame(md) && snapshotFileExistsInBlobs(fileInfo, blobs)) {_                                _                                _                                existingFileInfo = fileInfo__                                break__                            }_                        }_                    }__                    indexTotalFileCount += md.length()__                    indexTotalNumberOfFiles++___                    if (existingFileInfo == null) {_                        indexIncrementalFileCount++__                        indexIncrementalSize += md.length()__                        _                        BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo = new BlobStoreIndexShardSnapshot.FileInfo(fileNameFromGeneration(++generation), md, chunkSize())__                        indexCommitPointFiles.add(snapshotFileInfo)__                        filesToSnapshot.add(snapshotFileInfo)__                    } else {_                        indexCommitPointFiles.add(existingFileInfo)__                    }_                }__                snapshotStatus.moveToStarted(startTime, indexIncrementalFileCount,_                    indexTotalNumberOfFiles, indexIncrementalSize, indexTotalFileCount)___                for (BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo : filesToSnapshot) {_                    try {_                        snapshotFile(snapshotFileInfo)__                    } catch (IOException e) {_                        throw new IndexShardSnapshotFailedException(shardId, "Failed to perform snapshot (index files)", e)__                    }_                }_            } finally {_                store.decRef()__            }__            final IndexShardSnapshotStatus.Copy lastSnapshotStatus = snapshotStatus.moveToFinalize(snapshotIndexCommit.getGeneration())___            _            final BlobStoreIndexShardSnapshot snapshot = new BlobStoreIndexShardSnapshot(snapshotId.getName(),_                                                                        lastSnapshotStatus.getIndexVersion(),_                                                                        indexCommitPointFiles,_                                                                        lastSnapshotStatus.getStartTime(),_                                                                        _                                                                        _                                                                        System.currentTimeMillis() - lastSnapshotStatus.getStartTime(),_                                                                        lastSnapshotStatus.getIncrementalFileCount(),_                                                                        lastSnapshotStatus.getIncrementalSize()_            )___            _            logger.trace("[{}] [{}] writing shard snapshot file", shardId, snapshotId)__            try {_                indexShardSnapshotFormat.write(snapshot, blobContainer, snapshotId.getUUID())__            } catch (IOException e) {_                throw new IndexShardSnapshotFailedException(shardId, "Failed to write commit point", e)__            }__            _            _            List<SnapshotFiles> newSnapshotsList = new ArrayList<>()__            newSnapshotsList.add(new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles()))__            for (SnapshotFiles point : snapshots) {_                newSnapshotsList.add(point)__            }_            _            finalize(newSnapshotsList, fileListGeneration + 1, blobs, "snapshot creation [" + snapshotId + "]")__            snapshotStatus.moveToDone(System.currentTimeMillis())___        };create,snapshot,from,index,commit,point,param,snapshot,index,commit,snapshot,commit,point;public,void,snapshot,final,index,commit,snapshot,index,commit,logger,debug,snapshot,to,shard,id,snapshot,id,metadata,name,final,map,string,blob,meta,data,blobs,try,blobs,blob,container,list,blobs,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,list,blobs,e,long,generation,find,latest,file,name,generation,blobs,tuple,blob,store,index,shard,snapshots,integer,tuple,build,blob,store,index,shard,snapshots,blobs,blob,store,index,shard,snapshots,snapshots,tuple,v1,int,file,list,generation,tuple,v2,if,snapshots,snapshots,stream,any,match,sf,sf,snapshot,equals,snapshot,id,get,name,throw,new,index,shard,snapshot,failed,exception,shard,id,duplicate,snapshot,name,snapshot,id,get,name,detected,aborting,final,list,blob,store,index,shard,snapshot,file,info,index,commit,point,files,new,array,list,store,inc,ref,int,index,incremental,file,count,0,int,index,total,number,of,files,0,long,index,incremental,size,0,long,index,total,file,count,0,try,array,list,blob,store,index,shard,snapshot,file,info,files,to,snapshot,new,array,list,final,store,metadata,snapshot,metadata,final,collection,string,file,names,try,logger,trace,loading,store,metadata,using,index,commit,shard,id,snapshot,id,snapshot,index,commit,metadata,store,get,metadata,snapshot,index,commit,file,names,snapshot,index,commit,get,file,names,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,get,store,file,metadata,e,for,string,file,name,file,names,if,snapshot,status,is,aborted,logger,debug,aborted,on,the,file,exiting,shard,id,snapshot,id,file,name,throw,new,index,shard,snapshot,failed,exception,shard,id,aborted,logger,trace,processing,shard,id,snapshot,id,file,name,final,store,file,meta,data,md,metadata,get,file,name,blob,store,index,shard,snapshot,file,info,existing,file,info,null,list,blob,store,index,shard,snapshot,file,info,files,info,snapshots,find,physical,index,files,file,name,if,files,info,null,for,blob,store,index,shard,snapshot,file,info,file,info,files,info,try,maybe,recalculate,metadata,hash,blob,container,file,info,metadata,catch,exception,e,logger,warn,new,parameterized,message,can,t,calculate,hash,from,blob,for,file,shard,id,file,info,physical,name,file,info,metadata,e,if,file,info,is,same,md,snapshot,file,exists,in,blobs,file,info,blobs,existing,file,info,file,info,break,index,total,file,count,md,length,index,total,number,of,files,if,existing,file,info,null,index,incremental,file,count,index,incremental,size,md,length,blob,store,index,shard,snapshot,file,info,snapshot,file,info,new,blob,store,index,shard,snapshot,file,info,file,name,from,generation,generation,md,chunk,size,index,commit,point,files,add,snapshot,file,info,files,to,snapshot,add,snapshot,file,info,else,index,commit,point,files,add,existing,file,info,snapshot,status,move,to,started,start,time,index,incremental,file,count,index,total,number,of,files,index,incremental,size,index,total,file,count,for,blob,store,index,shard,snapshot,file,info,snapshot,file,info,files,to,snapshot,try,snapshot,file,snapshot,file,info,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,perform,snapshot,index,files,e,finally,store,dec,ref,final,index,shard,snapshot,status,copy,last,snapshot,status,snapshot,status,move,to,finalize,snapshot,index,commit,get,generation,final,blob,store,index,shard,snapshot,snapshot,new,blob,store,index,shard,snapshot,snapshot,id,get,name,last,snapshot,status,get,index,version,index,commit,point,files,last,snapshot,status,get,start,time,system,current,time,millis,last,snapshot,status,get,start,time,last,snapshot,status,get,incremental,file,count,last,snapshot,status,get,incremental,size,logger,trace,writing,shard,snapshot,file,shard,id,snapshot,id,try,index,shard,snapshot,format,write,snapshot,blob,container,snapshot,id,get,uuid,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,write,commit,point,e,list,snapshot,files,new,snapshots,list,new,array,list,new,snapshots,list,add,new,snapshot,files,snapshot,snapshot,snapshot,index,files,for,snapshot,files,point,snapshots,new,snapshots,list,add,point,finalize,new,snapshots,list,file,list,generation,1,blobs,snapshot,creation,snapshot,id,snapshot,status,move,to,done,system,current,time,millis
BlobStoreRepository -> SnapshotContext -> public void snapshot(final IndexCommit snapshotIndexCommit);1535139672;Create snapshot from index commit point__@param snapshotIndexCommit snapshot commit point;public void snapshot(final IndexCommit snapshotIndexCommit) {_            logger.debug("[{}] [{}] snapshot to [{}] ...", shardId, snapshotId, metadata.name())___            final Map<String, BlobMetaData> blobs__            try {_                blobs = blobContainer.listBlobs()__            } catch (IOException e) {_                throw new IndexShardSnapshotFailedException(shardId, "failed to list blobs", e)__            }__            long generation = findLatestFileNameGeneration(blobs)__            Tuple<BlobStoreIndexShardSnapshots, Integer> tuple = buildBlobStoreIndexShardSnapshots(blobs)__            BlobStoreIndexShardSnapshots snapshots = tuple.v1()__            int fileListGeneration = tuple.v2()___            if (snapshots.snapshots().stream().anyMatch(sf -> sf.snapshot().equals(snapshotId.getName()))) {_                throw new IndexShardSnapshotFailedException(shardId,_                    "Duplicate snapshot name [" + snapshotId.getName() + "] detected, aborting")__            }__            final List<BlobStoreIndexShardSnapshot.FileInfo> indexCommitPointFiles = new ArrayList<>()___            store.incRef()__            int indexIncrementalFileCount = 0__            int indexTotalNumberOfFiles = 0__            long indexIncrementalSize = 0__            long indexTotalFileCount = 0__            try {_                ArrayList<BlobStoreIndexShardSnapshot.FileInfo> filesToSnapshot = new ArrayList<>()__                final Store.MetadataSnapshot metadata__                _                final Collection<String> fileNames__                try {_                    logger.trace("[{}] [{}] Loading store metadata using index commit [{}]", shardId, snapshotId, snapshotIndexCommit)__                    metadata = store.getMetadata(snapshotIndexCommit)__                    fileNames = snapshotIndexCommit.getFileNames()__                } catch (IOException e) {_                    throw new IndexShardSnapshotFailedException(shardId, "Failed to get store file metadata", e)__                }_                for (String fileName : fileNames) {_                    if (snapshotStatus.isAborted()) {_                        logger.debug("[{}] [{}] Aborted on the file [{}], exiting", shardId, snapshotId, fileName)__                        throw new IndexShardSnapshotFailedException(shardId, "Aborted")__                    }__                    logger.trace("[{}] [{}] Processing [{}]", shardId, snapshotId, fileName)__                    final StoreFileMetaData md = metadata.get(fileName)__                    BlobStoreIndexShardSnapshot.FileInfo existingFileInfo = null__                    List<BlobStoreIndexShardSnapshot.FileInfo> filesInfo = snapshots.findPhysicalIndexFiles(fileName)__                    if (filesInfo != null) {_                        for (BlobStoreIndexShardSnapshot.FileInfo fileInfo : filesInfo) {_                            try {_                                _                                _                                _                                _                                maybeRecalculateMetadataHash(blobContainer, fileInfo, metadata)__                            } catch (Exception e) {_                                logger.warn(() -> new ParameterizedMessage("{} Can't calculate hash from blob for file [{}] [{}]", shardId, fileInfo.physicalName(), fileInfo.metadata()), e)__                            }_                            if (fileInfo.isSame(md) && snapshotFileExistsInBlobs(fileInfo, blobs)) {_                                _                                _                                existingFileInfo = fileInfo__                                break__                            }_                        }_                    }__                    indexTotalFileCount += md.length()__                    indexTotalNumberOfFiles++___                    if (existingFileInfo == null) {_                        indexIncrementalFileCount++__                        indexIncrementalSize += md.length()__                        _                        BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo = new BlobStoreIndexShardSnapshot.FileInfo(fileNameFromGeneration(++generation), md, chunkSize())__                        indexCommitPointFiles.add(snapshotFileInfo)__                        filesToSnapshot.add(snapshotFileInfo)__                    } else {_                        indexCommitPointFiles.add(existingFileInfo)__                    }_                }__                snapshotStatus.moveToStarted(startTime, indexIncrementalFileCount,_                    indexTotalNumberOfFiles, indexIncrementalSize, indexTotalFileCount)___                for (BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo : filesToSnapshot) {_                    try {_                        snapshotFile(snapshotFileInfo)__                    } catch (IOException e) {_                        throw new IndexShardSnapshotFailedException(shardId, "Failed to perform snapshot (index files)", e)__                    }_                }_            } finally {_                store.decRef()__            }__            final IndexShardSnapshotStatus.Copy lastSnapshotStatus = snapshotStatus.moveToFinalize(snapshotIndexCommit.getGeneration())___            _            final BlobStoreIndexShardSnapshot snapshot = new BlobStoreIndexShardSnapshot(snapshotId.getName(),_                                                                        lastSnapshotStatus.getIndexVersion(),_                                                                        indexCommitPointFiles,_                                                                        lastSnapshotStatus.getStartTime(),_                                                                        _                                                                        _                                                                        System.currentTimeMillis() - lastSnapshotStatus.getStartTime(),_                                                                        lastSnapshotStatus.getIncrementalFileCount(),_                                                                        lastSnapshotStatus.getIncrementalSize()_            )___            _            logger.trace("[{}] [{}] writing shard snapshot file", shardId, snapshotId)__            try {_                indexShardSnapshotFormat.write(snapshot, blobContainer, snapshotId.getUUID())__            } catch (IOException e) {_                throw new IndexShardSnapshotFailedException(shardId, "Failed to write commit point", e)__            }__            _            _            List<SnapshotFiles> newSnapshotsList = new ArrayList<>()__            newSnapshotsList.add(new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles()))__            for (SnapshotFiles point : snapshots) {_                newSnapshotsList.add(point)__            }_            _            finalize(newSnapshotsList, fileListGeneration + 1, blobs, "snapshot creation [" + snapshotId + "]")__            snapshotStatus.moveToDone(System.currentTimeMillis())___        };create,snapshot,from,index,commit,point,param,snapshot,index,commit,snapshot,commit,point;public,void,snapshot,final,index,commit,snapshot,index,commit,logger,debug,snapshot,to,shard,id,snapshot,id,metadata,name,final,map,string,blob,meta,data,blobs,try,blobs,blob,container,list,blobs,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,list,blobs,e,long,generation,find,latest,file,name,generation,blobs,tuple,blob,store,index,shard,snapshots,integer,tuple,build,blob,store,index,shard,snapshots,blobs,blob,store,index,shard,snapshots,snapshots,tuple,v1,int,file,list,generation,tuple,v2,if,snapshots,snapshots,stream,any,match,sf,sf,snapshot,equals,snapshot,id,get,name,throw,new,index,shard,snapshot,failed,exception,shard,id,duplicate,snapshot,name,snapshot,id,get,name,detected,aborting,final,list,blob,store,index,shard,snapshot,file,info,index,commit,point,files,new,array,list,store,inc,ref,int,index,incremental,file,count,0,int,index,total,number,of,files,0,long,index,incremental,size,0,long,index,total,file,count,0,try,array,list,blob,store,index,shard,snapshot,file,info,files,to,snapshot,new,array,list,final,store,metadata,snapshot,metadata,final,collection,string,file,names,try,logger,trace,loading,store,metadata,using,index,commit,shard,id,snapshot,id,snapshot,index,commit,metadata,store,get,metadata,snapshot,index,commit,file,names,snapshot,index,commit,get,file,names,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,get,store,file,metadata,e,for,string,file,name,file,names,if,snapshot,status,is,aborted,logger,debug,aborted,on,the,file,exiting,shard,id,snapshot,id,file,name,throw,new,index,shard,snapshot,failed,exception,shard,id,aborted,logger,trace,processing,shard,id,snapshot,id,file,name,final,store,file,meta,data,md,metadata,get,file,name,blob,store,index,shard,snapshot,file,info,existing,file,info,null,list,blob,store,index,shard,snapshot,file,info,files,info,snapshots,find,physical,index,files,file,name,if,files,info,null,for,blob,store,index,shard,snapshot,file,info,file,info,files,info,try,maybe,recalculate,metadata,hash,blob,container,file,info,metadata,catch,exception,e,logger,warn,new,parameterized,message,can,t,calculate,hash,from,blob,for,file,shard,id,file,info,physical,name,file,info,metadata,e,if,file,info,is,same,md,snapshot,file,exists,in,blobs,file,info,blobs,existing,file,info,file,info,break,index,total,file,count,md,length,index,total,number,of,files,if,existing,file,info,null,index,incremental,file,count,index,incremental,size,md,length,blob,store,index,shard,snapshot,file,info,snapshot,file,info,new,blob,store,index,shard,snapshot,file,info,file,name,from,generation,generation,md,chunk,size,index,commit,point,files,add,snapshot,file,info,files,to,snapshot,add,snapshot,file,info,else,index,commit,point,files,add,existing,file,info,snapshot,status,move,to,started,start,time,index,incremental,file,count,index,total,number,of,files,index,incremental,size,index,total,file,count,for,blob,store,index,shard,snapshot,file,info,snapshot,file,info,files,to,snapshot,try,snapshot,file,snapshot,file,info,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,perform,snapshot,index,files,e,finally,store,dec,ref,final,index,shard,snapshot,status,copy,last,snapshot,status,snapshot,status,move,to,finalize,snapshot,index,commit,get,generation,final,blob,store,index,shard,snapshot,snapshot,new,blob,store,index,shard,snapshot,snapshot,id,get,name,last,snapshot,status,get,index,version,index,commit,point,files,last,snapshot,status,get,start,time,system,current,time,millis,last,snapshot,status,get,start,time,last,snapshot,status,get,incremental,file,count,last,snapshot,status,get,incremental,size,logger,trace,writing,shard,snapshot,file,shard,id,snapshot,id,try,index,shard,snapshot,format,write,snapshot,blob,container,snapshot,id,get,uuid,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,write,commit,point,e,list,snapshot,files,new,snapshots,list,new,array,list,new,snapshots,list,add,new,snapshot,files,snapshot,snapshot,snapshot,index,files,for,snapshot,files,point,snapshots,new,snapshots,list,add,point,finalize,new,snapshots,list,file,list,generation,1,blobs,snapshot,creation,snapshot,id,snapshot,status,move,to,done,system,current,time,millis
BlobStoreRepository -> SnapshotContext -> public void snapshot(final IndexCommit snapshotIndexCommit);1535723122;Create snapshot from index commit point__@param snapshotIndexCommit snapshot commit point;public void snapshot(final IndexCommit snapshotIndexCommit) {_            logger.debug("[{}] [{}] snapshot to [{}] ...", shardId, snapshotId, metadata.name())___            final Map<String, BlobMetaData> blobs__            try {_                blobs = blobContainer.listBlobs()__            } catch (IOException e) {_                throw new IndexShardSnapshotFailedException(shardId, "failed to list blobs", e)__            }__            long generation = findLatestFileNameGeneration(blobs)__            Tuple<BlobStoreIndexShardSnapshots, Integer> tuple = buildBlobStoreIndexShardSnapshots(blobs)__            BlobStoreIndexShardSnapshots snapshots = tuple.v1()__            int fileListGeneration = tuple.v2()___            if (snapshots.snapshots().stream().anyMatch(sf -> sf.snapshot().equals(snapshotId.getName()))) {_                throw new IndexShardSnapshotFailedException(shardId,_                    "Duplicate snapshot name [" + snapshotId.getName() + "] detected, aborting")__            }__            final List<BlobStoreIndexShardSnapshot.FileInfo> indexCommitPointFiles = new ArrayList<>()___            store.incRef()__            int indexIncrementalFileCount = 0__            int indexTotalNumberOfFiles = 0__            long indexIncrementalSize = 0__            long indexTotalFileCount = 0__            try {_                ArrayList<BlobStoreIndexShardSnapshot.FileInfo> filesToSnapshot = new ArrayList<>()__                final Store.MetadataSnapshot metadata__                _                final Collection<String> fileNames__                try {_                    logger.trace("[{}] [{}] Loading store metadata using index commit [{}]", shardId, snapshotId, snapshotIndexCommit)__                    metadata = store.getMetadata(snapshotIndexCommit)__                    fileNames = snapshotIndexCommit.getFileNames()__                } catch (IOException e) {_                    throw new IndexShardSnapshotFailedException(shardId, "Failed to get store file metadata", e)__                }_                for (String fileName : fileNames) {_                    if (snapshotStatus.isAborted()) {_                        logger.debug("[{}] [{}] Aborted on the file [{}], exiting", shardId, snapshotId, fileName)__                        throw new IndexShardSnapshotFailedException(shardId, "Aborted")__                    }__                    logger.trace("[{}] [{}] Processing [{}]", shardId, snapshotId, fileName)__                    final StoreFileMetaData md = metadata.get(fileName)__                    BlobStoreIndexShardSnapshot.FileInfo existingFileInfo = null__                    List<BlobStoreIndexShardSnapshot.FileInfo> filesInfo = snapshots.findPhysicalIndexFiles(fileName)__                    if (filesInfo != null) {_                        for (BlobStoreIndexShardSnapshot.FileInfo fileInfo : filesInfo) {_                            try {_                                _                                _                                _                                _                                maybeRecalculateMetadataHash(blobContainer, fileInfo, metadata)__                            } catch (Exception e) {_                                logger.warn(() -> new ParameterizedMessage("{} Can't calculate hash from blob for file [{}] [{}]", shardId, fileInfo.physicalName(), fileInfo.metadata()), e)__                            }_                            if (fileInfo.isSame(md) && snapshotFileExistsInBlobs(fileInfo, blobs)) {_                                _                                _                                existingFileInfo = fileInfo__                                break__                            }_                        }_                    }__                    indexTotalFileCount += md.length()__                    indexTotalNumberOfFiles++___                    if (existingFileInfo == null) {_                        indexIncrementalFileCount++__                        indexIncrementalSize += md.length()__                        _                        BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo = new BlobStoreIndexShardSnapshot.FileInfo(fileNameFromGeneration(++generation), md, chunkSize())__                        indexCommitPointFiles.add(snapshotFileInfo)__                        filesToSnapshot.add(snapshotFileInfo)__                    } else {_                        indexCommitPointFiles.add(existingFileInfo)__                    }_                }__                snapshotStatus.moveToStarted(startTime, indexIncrementalFileCount,_                    indexTotalNumberOfFiles, indexIncrementalSize, indexTotalFileCount)___                for (BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo : filesToSnapshot) {_                    try {_                        snapshotFile(snapshotFileInfo)__                    } catch (IOException e) {_                        throw new IndexShardSnapshotFailedException(shardId, "Failed to perform snapshot (index files)", e)__                    }_                }_            } finally {_                store.decRef()__            }__            final IndexShardSnapshotStatus.Copy lastSnapshotStatus = snapshotStatus.moveToFinalize(snapshotIndexCommit.getGeneration())___            _            final BlobStoreIndexShardSnapshot snapshot = new BlobStoreIndexShardSnapshot(snapshotId.getName(),_                                                                        lastSnapshotStatus.getIndexVersion(),_                                                                        indexCommitPointFiles,_                                                                        lastSnapshotStatus.getStartTime(),_                                                                        _                                                                        _                                                                        System.currentTimeMillis() - lastSnapshotStatus.getStartTime(),_                                                                        lastSnapshotStatus.getIncrementalFileCount(),_                                                                        lastSnapshotStatus.getIncrementalSize()_            )___            _            logger.trace("[{}] [{}] writing shard snapshot file", shardId, snapshotId)__            try {_                indexShardSnapshotFormat.write(snapshot, blobContainer, snapshotId.getUUID())__            } catch (IOException e) {_                throw new IndexShardSnapshotFailedException(shardId, "Failed to write commit point", e)__            }__            _            _            List<SnapshotFiles> newSnapshotsList = new ArrayList<>()__            newSnapshotsList.add(new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles()))__            for (SnapshotFiles point : snapshots) {_                newSnapshotsList.add(point)__            }_            _            finalize(newSnapshotsList, fileListGeneration + 1, blobs, "snapshot creation [" + snapshotId + "]")__            snapshotStatus.moveToDone(System.currentTimeMillis())___        };create,snapshot,from,index,commit,point,param,snapshot,index,commit,snapshot,commit,point;public,void,snapshot,final,index,commit,snapshot,index,commit,logger,debug,snapshot,to,shard,id,snapshot,id,metadata,name,final,map,string,blob,meta,data,blobs,try,blobs,blob,container,list,blobs,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,list,blobs,e,long,generation,find,latest,file,name,generation,blobs,tuple,blob,store,index,shard,snapshots,integer,tuple,build,blob,store,index,shard,snapshots,blobs,blob,store,index,shard,snapshots,snapshots,tuple,v1,int,file,list,generation,tuple,v2,if,snapshots,snapshots,stream,any,match,sf,sf,snapshot,equals,snapshot,id,get,name,throw,new,index,shard,snapshot,failed,exception,shard,id,duplicate,snapshot,name,snapshot,id,get,name,detected,aborting,final,list,blob,store,index,shard,snapshot,file,info,index,commit,point,files,new,array,list,store,inc,ref,int,index,incremental,file,count,0,int,index,total,number,of,files,0,long,index,incremental,size,0,long,index,total,file,count,0,try,array,list,blob,store,index,shard,snapshot,file,info,files,to,snapshot,new,array,list,final,store,metadata,snapshot,metadata,final,collection,string,file,names,try,logger,trace,loading,store,metadata,using,index,commit,shard,id,snapshot,id,snapshot,index,commit,metadata,store,get,metadata,snapshot,index,commit,file,names,snapshot,index,commit,get,file,names,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,get,store,file,metadata,e,for,string,file,name,file,names,if,snapshot,status,is,aborted,logger,debug,aborted,on,the,file,exiting,shard,id,snapshot,id,file,name,throw,new,index,shard,snapshot,failed,exception,shard,id,aborted,logger,trace,processing,shard,id,snapshot,id,file,name,final,store,file,meta,data,md,metadata,get,file,name,blob,store,index,shard,snapshot,file,info,existing,file,info,null,list,blob,store,index,shard,snapshot,file,info,files,info,snapshots,find,physical,index,files,file,name,if,files,info,null,for,blob,store,index,shard,snapshot,file,info,file,info,files,info,try,maybe,recalculate,metadata,hash,blob,container,file,info,metadata,catch,exception,e,logger,warn,new,parameterized,message,can,t,calculate,hash,from,blob,for,file,shard,id,file,info,physical,name,file,info,metadata,e,if,file,info,is,same,md,snapshot,file,exists,in,blobs,file,info,blobs,existing,file,info,file,info,break,index,total,file,count,md,length,index,total,number,of,files,if,existing,file,info,null,index,incremental,file,count,index,incremental,size,md,length,blob,store,index,shard,snapshot,file,info,snapshot,file,info,new,blob,store,index,shard,snapshot,file,info,file,name,from,generation,generation,md,chunk,size,index,commit,point,files,add,snapshot,file,info,files,to,snapshot,add,snapshot,file,info,else,index,commit,point,files,add,existing,file,info,snapshot,status,move,to,started,start,time,index,incremental,file,count,index,total,number,of,files,index,incremental,size,index,total,file,count,for,blob,store,index,shard,snapshot,file,info,snapshot,file,info,files,to,snapshot,try,snapshot,file,snapshot,file,info,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,perform,snapshot,index,files,e,finally,store,dec,ref,final,index,shard,snapshot,status,copy,last,snapshot,status,snapshot,status,move,to,finalize,snapshot,index,commit,get,generation,final,blob,store,index,shard,snapshot,snapshot,new,blob,store,index,shard,snapshot,snapshot,id,get,name,last,snapshot,status,get,index,version,index,commit,point,files,last,snapshot,status,get,start,time,system,current,time,millis,last,snapshot,status,get,start,time,last,snapshot,status,get,incremental,file,count,last,snapshot,status,get,incremental,size,logger,trace,writing,shard,snapshot,file,shard,id,snapshot,id,try,index,shard,snapshot,format,write,snapshot,blob,container,snapshot,id,get,uuid,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,write,commit,point,e,list,snapshot,files,new,snapshots,list,new,array,list,new,snapshots,list,add,new,snapshot,files,snapshot,snapshot,snapshot,index,files,for,snapshot,files,point,snapshots,new,snapshots,list,add,point,finalize,new,snapshots,list,file,list,generation,1,blobs,snapshot,creation,snapshot,id,snapshot,status,move,to,done,system,current,time,millis
BlobStoreRepository -> SnapshotContext -> public void snapshot(final IndexCommit snapshotIndexCommit);1536314350;Create snapshot from index commit point__@param snapshotIndexCommit snapshot commit point;public void snapshot(final IndexCommit snapshotIndexCommit) {_            logger.debug("[{}] [{}] snapshot to [{}] ...", shardId, snapshotId, metadata.name())___            final Map<String, BlobMetaData> blobs__            try {_                blobs = blobContainer.listBlobs()__            } catch (IOException e) {_                throw new IndexShardSnapshotFailedException(shardId, "failed to list blobs", e)__            }__            long generation = findLatestFileNameGeneration(blobs)__            Tuple<BlobStoreIndexShardSnapshots, Integer> tuple = buildBlobStoreIndexShardSnapshots(blobs)__            BlobStoreIndexShardSnapshots snapshots = tuple.v1()__            int fileListGeneration = tuple.v2()___            if (snapshots.snapshots().stream().anyMatch(sf -> sf.snapshot().equals(snapshotId.getName()))) {_                throw new IndexShardSnapshotFailedException(shardId,_                    "Duplicate snapshot name [" + snapshotId.getName() + "] detected, aborting")__            }__            final List<BlobStoreIndexShardSnapshot.FileInfo> indexCommitPointFiles = new ArrayList<>()___            store.incRef()__            int indexIncrementalFileCount = 0__            int indexTotalNumberOfFiles = 0__            long indexIncrementalSize = 0__            long indexTotalFileCount = 0__            try {_                ArrayList<BlobStoreIndexShardSnapshot.FileInfo> filesToSnapshot = new ArrayList<>()__                final Store.MetadataSnapshot metadata__                _                final Collection<String> fileNames__                try {_                    logger.trace("[{}] [{}] Loading store metadata using index commit [{}]", shardId, snapshotId, snapshotIndexCommit)__                    metadata = store.getMetadata(snapshotIndexCommit)__                    fileNames = snapshotIndexCommit.getFileNames()__                } catch (IOException e) {_                    throw new IndexShardSnapshotFailedException(shardId, "Failed to get store file metadata", e)__                }_                for (String fileName : fileNames) {_                    if (snapshotStatus.isAborted()) {_                        logger.debug("[{}] [{}] Aborted on the file [{}], exiting", shardId, snapshotId, fileName)__                        throw new IndexShardSnapshotFailedException(shardId, "Aborted")__                    }__                    logger.trace("[{}] [{}] Processing [{}]", shardId, snapshotId, fileName)__                    final StoreFileMetaData md = metadata.get(fileName)__                    BlobStoreIndexShardSnapshot.FileInfo existingFileInfo = null__                    List<BlobStoreIndexShardSnapshot.FileInfo> filesInfo = snapshots.findPhysicalIndexFiles(fileName)__                    if (filesInfo != null) {_                        for (BlobStoreIndexShardSnapshot.FileInfo fileInfo : filesInfo) {_                            try {_                                _                                _                                _                                _                                maybeRecalculateMetadataHash(blobContainer, fileInfo, metadata)__                            } catch (Exception e) {_                                logger.warn(() -> new ParameterizedMessage("{} Can't calculate hash from blob for file [{}] [{}]", shardId, fileInfo.physicalName(), fileInfo.metadata()), e)__                            }_                            if (fileInfo.isSame(md) && snapshotFileExistsInBlobs(fileInfo, blobs)) {_                                _                                _                                existingFileInfo = fileInfo__                                break__                            }_                        }_                    }__                    indexTotalFileCount += md.length()__                    indexTotalNumberOfFiles++___                    if (existingFileInfo == null) {_                        indexIncrementalFileCount++__                        indexIncrementalSize += md.length()__                        _                        BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo = new BlobStoreIndexShardSnapshot.FileInfo(fileNameFromGeneration(++generation), md, chunkSize())__                        indexCommitPointFiles.add(snapshotFileInfo)__                        filesToSnapshot.add(snapshotFileInfo)__                    } else {_                        indexCommitPointFiles.add(existingFileInfo)__                    }_                }__                snapshotStatus.moveToStarted(startTime, indexIncrementalFileCount,_                    indexTotalNumberOfFiles, indexIncrementalSize, indexTotalFileCount)___                for (BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo : filesToSnapshot) {_                    try {_                        snapshotFile(snapshotFileInfo)__                    } catch (IOException e) {_                        throw new IndexShardSnapshotFailedException(shardId, "Failed to perform snapshot (index files)", e)__                    }_                }_            } finally {_                store.decRef()__            }__            final IndexShardSnapshotStatus.Copy lastSnapshotStatus = snapshotStatus.moveToFinalize(snapshotIndexCommit.getGeneration())___            _            final BlobStoreIndexShardSnapshot snapshot = new BlobStoreIndexShardSnapshot(snapshotId.getName(),_                                                                        lastSnapshotStatus.getIndexVersion(),_                                                                        indexCommitPointFiles,_                                                                        lastSnapshotStatus.getStartTime(),_                                                                        _                                                                        _                                                                        System.currentTimeMillis() - lastSnapshotStatus.getStartTime(),_                                                                        lastSnapshotStatus.getIncrementalFileCount(),_                                                                        lastSnapshotStatus.getIncrementalSize()_            )___            _            logger.trace("[{}] [{}] writing shard snapshot file", shardId, snapshotId)__            try {_                indexShardSnapshotFormat.write(snapshot, blobContainer, snapshotId.getUUID())__            } catch (IOException e) {_                throw new IndexShardSnapshotFailedException(shardId, "Failed to write commit point", e)__            }__            _            _            List<SnapshotFiles> newSnapshotsList = new ArrayList<>()__            newSnapshotsList.add(new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles()))__            for (SnapshotFiles point : snapshots) {_                newSnapshotsList.add(point)__            }_            _            finalize(newSnapshotsList, fileListGeneration + 1, blobs, "snapshot creation [" + snapshotId + "]")__            snapshotStatus.moveToDone(System.currentTimeMillis())___        };create,snapshot,from,index,commit,point,param,snapshot,index,commit,snapshot,commit,point;public,void,snapshot,final,index,commit,snapshot,index,commit,logger,debug,snapshot,to,shard,id,snapshot,id,metadata,name,final,map,string,blob,meta,data,blobs,try,blobs,blob,container,list,blobs,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,list,blobs,e,long,generation,find,latest,file,name,generation,blobs,tuple,blob,store,index,shard,snapshots,integer,tuple,build,blob,store,index,shard,snapshots,blobs,blob,store,index,shard,snapshots,snapshots,tuple,v1,int,file,list,generation,tuple,v2,if,snapshots,snapshots,stream,any,match,sf,sf,snapshot,equals,snapshot,id,get,name,throw,new,index,shard,snapshot,failed,exception,shard,id,duplicate,snapshot,name,snapshot,id,get,name,detected,aborting,final,list,blob,store,index,shard,snapshot,file,info,index,commit,point,files,new,array,list,store,inc,ref,int,index,incremental,file,count,0,int,index,total,number,of,files,0,long,index,incremental,size,0,long,index,total,file,count,0,try,array,list,blob,store,index,shard,snapshot,file,info,files,to,snapshot,new,array,list,final,store,metadata,snapshot,metadata,final,collection,string,file,names,try,logger,trace,loading,store,metadata,using,index,commit,shard,id,snapshot,id,snapshot,index,commit,metadata,store,get,metadata,snapshot,index,commit,file,names,snapshot,index,commit,get,file,names,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,get,store,file,metadata,e,for,string,file,name,file,names,if,snapshot,status,is,aborted,logger,debug,aborted,on,the,file,exiting,shard,id,snapshot,id,file,name,throw,new,index,shard,snapshot,failed,exception,shard,id,aborted,logger,trace,processing,shard,id,snapshot,id,file,name,final,store,file,meta,data,md,metadata,get,file,name,blob,store,index,shard,snapshot,file,info,existing,file,info,null,list,blob,store,index,shard,snapshot,file,info,files,info,snapshots,find,physical,index,files,file,name,if,files,info,null,for,blob,store,index,shard,snapshot,file,info,file,info,files,info,try,maybe,recalculate,metadata,hash,blob,container,file,info,metadata,catch,exception,e,logger,warn,new,parameterized,message,can,t,calculate,hash,from,blob,for,file,shard,id,file,info,physical,name,file,info,metadata,e,if,file,info,is,same,md,snapshot,file,exists,in,blobs,file,info,blobs,existing,file,info,file,info,break,index,total,file,count,md,length,index,total,number,of,files,if,existing,file,info,null,index,incremental,file,count,index,incremental,size,md,length,blob,store,index,shard,snapshot,file,info,snapshot,file,info,new,blob,store,index,shard,snapshot,file,info,file,name,from,generation,generation,md,chunk,size,index,commit,point,files,add,snapshot,file,info,files,to,snapshot,add,snapshot,file,info,else,index,commit,point,files,add,existing,file,info,snapshot,status,move,to,started,start,time,index,incremental,file,count,index,total,number,of,files,index,incremental,size,index,total,file,count,for,blob,store,index,shard,snapshot,file,info,snapshot,file,info,files,to,snapshot,try,snapshot,file,snapshot,file,info,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,perform,snapshot,index,files,e,finally,store,dec,ref,final,index,shard,snapshot,status,copy,last,snapshot,status,snapshot,status,move,to,finalize,snapshot,index,commit,get,generation,final,blob,store,index,shard,snapshot,snapshot,new,blob,store,index,shard,snapshot,snapshot,id,get,name,last,snapshot,status,get,index,version,index,commit,point,files,last,snapshot,status,get,start,time,system,current,time,millis,last,snapshot,status,get,start,time,last,snapshot,status,get,incremental,file,count,last,snapshot,status,get,incremental,size,logger,trace,writing,shard,snapshot,file,shard,id,snapshot,id,try,index,shard,snapshot,format,write,snapshot,blob,container,snapshot,id,get,uuid,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,write,commit,point,e,list,snapshot,files,new,snapshots,list,new,array,list,new,snapshots,list,add,new,snapshot,files,snapshot,snapshot,snapshot,index,files,for,snapshot,files,point,snapshots,new,snapshots,list,add,point,finalize,new,snapshots,list,file,list,generation,1,blobs,snapshot,creation,snapshot,id,snapshot,status,move,to,done,system,current,time,millis
BlobStoreRepository -> SnapshotContext -> public void snapshot(final IndexCommit snapshotIndexCommit);1536828374;Create snapshot from index commit point__@param snapshotIndexCommit snapshot commit point;public void snapshot(final IndexCommit snapshotIndexCommit) {_            logger.debug("[{}] [{}] snapshot to [{}] ...", shardId, snapshotId, metadata.name())___            final Map<String, BlobMetaData> blobs__            try {_                blobs = blobContainer.listBlobs()__            } catch (IOException e) {_                throw new IndexShardSnapshotFailedException(shardId, "failed to list blobs", e)__            }__            long generation = findLatestFileNameGeneration(blobs)__            Tuple<BlobStoreIndexShardSnapshots, Integer> tuple = buildBlobStoreIndexShardSnapshots(blobs)__            BlobStoreIndexShardSnapshots snapshots = tuple.v1()__            int fileListGeneration = tuple.v2()___            if (snapshots.snapshots().stream().anyMatch(sf -> sf.snapshot().equals(snapshotId.getName()))) {_                throw new IndexShardSnapshotFailedException(shardId,_                    "Duplicate snapshot name [" + snapshotId.getName() + "] detected, aborting")__            }__            final List<BlobStoreIndexShardSnapshot.FileInfo> indexCommitPointFiles = new ArrayList<>()___            store.incRef()__            int indexIncrementalFileCount = 0__            int indexTotalNumberOfFiles = 0__            long indexIncrementalSize = 0__            long indexTotalFileCount = 0__            try {_                ArrayList<BlobStoreIndexShardSnapshot.FileInfo> filesToSnapshot = new ArrayList<>()__                final Store.MetadataSnapshot metadata__                _                final Collection<String> fileNames__                try {_                    logger.trace("[{}] [{}] Loading store metadata using index commit [{}]", shardId, snapshotId, snapshotIndexCommit)__                    metadata = store.getMetadata(snapshotIndexCommit)__                    fileNames = snapshotIndexCommit.getFileNames()__                } catch (IOException e) {_                    throw new IndexShardSnapshotFailedException(shardId, "Failed to get store file metadata", e)__                }_                for (String fileName : fileNames) {_                    if (snapshotStatus.isAborted()) {_                        logger.debug("[{}] [{}] Aborted on the file [{}], exiting", shardId, snapshotId, fileName)__                        throw new IndexShardSnapshotFailedException(shardId, "Aborted")__                    }__                    logger.trace("[{}] [{}] Processing [{}]", shardId, snapshotId, fileName)__                    final StoreFileMetaData md = metadata.get(fileName)__                    BlobStoreIndexShardSnapshot.FileInfo existingFileInfo = null__                    List<BlobStoreIndexShardSnapshot.FileInfo> filesInfo = snapshots.findPhysicalIndexFiles(fileName)__                    if (filesInfo != null) {_                        for (BlobStoreIndexShardSnapshot.FileInfo fileInfo : filesInfo) {_                            try {_                                _                                _                                _                                _                                maybeRecalculateMetadataHash(blobContainer, fileInfo, metadata)__                            } catch (Exception e) {_                                logger.warn(() -> new ParameterizedMessage("{} Can't calculate hash from blob for file [{}] [{}]", shardId, fileInfo.physicalName(), fileInfo.metadata()), e)__                            }_                            if (fileInfo.isSame(md) && snapshotFileExistsInBlobs(fileInfo, blobs)) {_                                _                                _                                existingFileInfo = fileInfo__                                break__                            }_                        }_                    }__                    indexTotalFileCount += md.length()__                    indexTotalNumberOfFiles++___                    if (existingFileInfo == null) {_                        indexIncrementalFileCount++__                        indexIncrementalSize += md.length()__                        _                        BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo = new BlobStoreIndexShardSnapshot.FileInfo(fileNameFromGeneration(++generation), md, chunkSize())__                        indexCommitPointFiles.add(snapshotFileInfo)__                        filesToSnapshot.add(snapshotFileInfo)__                    } else {_                        indexCommitPointFiles.add(existingFileInfo)__                    }_                }__                snapshotStatus.moveToStarted(startTime, indexIncrementalFileCount,_                    indexTotalNumberOfFiles, indexIncrementalSize, indexTotalFileCount)___                for (BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo : filesToSnapshot) {_                    try {_                        snapshotFile(snapshotFileInfo)__                    } catch (IOException e) {_                        throw new IndexShardSnapshotFailedException(shardId, "Failed to perform snapshot (index files)", e)__                    }_                }_            } finally {_                store.decRef()__            }__            final IndexShardSnapshotStatus.Copy lastSnapshotStatus = snapshotStatus.moveToFinalize(snapshotIndexCommit.getGeneration())___            _            final BlobStoreIndexShardSnapshot snapshot = new BlobStoreIndexShardSnapshot(snapshotId.getName(),_                                                                        lastSnapshotStatus.getIndexVersion(),_                                                                        indexCommitPointFiles,_                                                                        lastSnapshotStatus.getStartTime(),_                                                                        _                                                                        _                                                                        System.currentTimeMillis() - lastSnapshotStatus.getStartTime(),_                                                                        lastSnapshotStatus.getIncrementalFileCount(),_                                                                        lastSnapshotStatus.getIncrementalSize()_            )___            _            logger.trace("[{}] [{}] writing shard snapshot file", shardId, snapshotId)__            try {_                indexShardSnapshotFormat.write(snapshot, blobContainer, snapshotId.getUUID())__            } catch (IOException e) {_                throw new IndexShardSnapshotFailedException(shardId, "Failed to write commit point", e)__            }__            _            _            List<SnapshotFiles> newSnapshotsList = new ArrayList<>()__            newSnapshotsList.add(new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles()))__            for (SnapshotFiles point : snapshots) {_                newSnapshotsList.add(point)__            }_            _            finalize(newSnapshotsList, fileListGeneration + 1, blobs, "snapshot creation [" + snapshotId + "]")__            snapshotStatus.moveToDone(System.currentTimeMillis())___        };create,snapshot,from,index,commit,point,param,snapshot,index,commit,snapshot,commit,point;public,void,snapshot,final,index,commit,snapshot,index,commit,logger,debug,snapshot,to,shard,id,snapshot,id,metadata,name,final,map,string,blob,meta,data,blobs,try,blobs,blob,container,list,blobs,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,list,blobs,e,long,generation,find,latest,file,name,generation,blobs,tuple,blob,store,index,shard,snapshots,integer,tuple,build,blob,store,index,shard,snapshots,blobs,blob,store,index,shard,snapshots,snapshots,tuple,v1,int,file,list,generation,tuple,v2,if,snapshots,snapshots,stream,any,match,sf,sf,snapshot,equals,snapshot,id,get,name,throw,new,index,shard,snapshot,failed,exception,shard,id,duplicate,snapshot,name,snapshot,id,get,name,detected,aborting,final,list,blob,store,index,shard,snapshot,file,info,index,commit,point,files,new,array,list,store,inc,ref,int,index,incremental,file,count,0,int,index,total,number,of,files,0,long,index,incremental,size,0,long,index,total,file,count,0,try,array,list,blob,store,index,shard,snapshot,file,info,files,to,snapshot,new,array,list,final,store,metadata,snapshot,metadata,final,collection,string,file,names,try,logger,trace,loading,store,metadata,using,index,commit,shard,id,snapshot,id,snapshot,index,commit,metadata,store,get,metadata,snapshot,index,commit,file,names,snapshot,index,commit,get,file,names,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,get,store,file,metadata,e,for,string,file,name,file,names,if,snapshot,status,is,aborted,logger,debug,aborted,on,the,file,exiting,shard,id,snapshot,id,file,name,throw,new,index,shard,snapshot,failed,exception,shard,id,aborted,logger,trace,processing,shard,id,snapshot,id,file,name,final,store,file,meta,data,md,metadata,get,file,name,blob,store,index,shard,snapshot,file,info,existing,file,info,null,list,blob,store,index,shard,snapshot,file,info,files,info,snapshots,find,physical,index,files,file,name,if,files,info,null,for,blob,store,index,shard,snapshot,file,info,file,info,files,info,try,maybe,recalculate,metadata,hash,blob,container,file,info,metadata,catch,exception,e,logger,warn,new,parameterized,message,can,t,calculate,hash,from,blob,for,file,shard,id,file,info,physical,name,file,info,metadata,e,if,file,info,is,same,md,snapshot,file,exists,in,blobs,file,info,blobs,existing,file,info,file,info,break,index,total,file,count,md,length,index,total,number,of,files,if,existing,file,info,null,index,incremental,file,count,index,incremental,size,md,length,blob,store,index,shard,snapshot,file,info,snapshot,file,info,new,blob,store,index,shard,snapshot,file,info,file,name,from,generation,generation,md,chunk,size,index,commit,point,files,add,snapshot,file,info,files,to,snapshot,add,snapshot,file,info,else,index,commit,point,files,add,existing,file,info,snapshot,status,move,to,started,start,time,index,incremental,file,count,index,total,number,of,files,index,incremental,size,index,total,file,count,for,blob,store,index,shard,snapshot,file,info,snapshot,file,info,files,to,snapshot,try,snapshot,file,snapshot,file,info,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,perform,snapshot,index,files,e,finally,store,dec,ref,final,index,shard,snapshot,status,copy,last,snapshot,status,snapshot,status,move,to,finalize,snapshot,index,commit,get,generation,final,blob,store,index,shard,snapshot,snapshot,new,blob,store,index,shard,snapshot,snapshot,id,get,name,last,snapshot,status,get,index,version,index,commit,point,files,last,snapshot,status,get,start,time,system,current,time,millis,last,snapshot,status,get,start,time,last,snapshot,status,get,incremental,file,count,last,snapshot,status,get,incremental,size,logger,trace,writing,shard,snapshot,file,shard,id,snapshot,id,try,index,shard,snapshot,format,write,snapshot,blob,container,snapshot,id,get,uuid,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,write,commit,point,e,list,snapshot,files,new,snapshots,list,new,array,list,new,snapshots,list,add,new,snapshot,files,snapshot,snapshot,snapshot,index,files,for,snapshot,files,point,snapshots,new,snapshots,list,add,point,finalize,new,snapshots,list,file,list,generation,1,blobs,snapshot,creation,snapshot,id,snapshot,status,move,to,done,system,current,time,millis
BlobStoreRepository -> SnapshotContext -> public void snapshot(final IndexCommit snapshotIndexCommit);1541008027;Create snapshot from index commit point__@param snapshotIndexCommit snapshot commit point;public void snapshot(final IndexCommit snapshotIndexCommit) {_            logger.debug("[{}] [{}] snapshot to [{}] ...", shardId, snapshotId, metadata.name())___            final Map<String, BlobMetaData> blobs__            try {_                blobs = blobContainer.listBlobs()__            } catch (IOException e) {_                throw new IndexShardSnapshotFailedException(shardId, "failed to list blobs", e)__            }__            long generation = findLatestFileNameGeneration(blobs)__            Tuple<BlobStoreIndexShardSnapshots, Integer> tuple = buildBlobStoreIndexShardSnapshots(blobs)__            BlobStoreIndexShardSnapshots snapshots = tuple.v1()__            int fileListGeneration = tuple.v2()___            if (snapshots.snapshots().stream().anyMatch(sf -> sf.snapshot().equals(snapshotId.getName()))) {_                throw new IndexShardSnapshotFailedException(shardId,_                    "Duplicate snapshot name [" + snapshotId.getName() + "] detected, aborting")__            }__            final List<BlobStoreIndexShardSnapshot.FileInfo> indexCommitPointFiles = new ArrayList<>()___            store.incRef()__            int indexIncrementalFileCount = 0__            int indexTotalNumberOfFiles = 0__            long indexIncrementalSize = 0__            long indexTotalFileCount = 0__            try {_                ArrayList<BlobStoreIndexShardSnapshot.FileInfo> filesToSnapshot = new ArrayList<>()__                final Store.MetadataSnapshot metadata__                _                final Collection<String> fileNames__                try {_                    logger.trace("[{}] [{}] Loading store metadata using index commit [{}]", shardId, snapshotId, snapshotIndexCommit)__                    metadata = store.getMetadata(snapshotIndexCommit)__                    fileNames = snapshotIndexCommit.getFileNames()__                } catch (IOException e) {_                    throw new IndexShardSnapshotFailedException(shardId, "Failed to get store file metadata", e)__                }_                for (String fileName : fileNames) {_                    if (snapshotStatus.isAborted()) {_                        logger.debug("[{}] [{}] Aborted on the file [{}], exiting", shardId, snapshotId, fileName)__                        throw new IndexShardSnapshotFailedException(shardId, "Aborted")__                    }__                    logger.trace("[{}] [{}] Processing [{}]", shardId, snapshotId, fileName)__                    final StoreFileMetaData md = metadata.get(fileName)__                    BlobStoreIndexShardSnapshot.FileInfo existingFileInfo = null__                    List<BlobStoreIndexShardSnapshot.FileInfo> filesInfo = snapshots.findPhysicalIndexFiles(fileName)__                    if (filesInfo != null) {_                        for (BlobStoreIndexShardSnapshot.FileInfo fileInfo : filesInfo) {_                            try {_                                _                                _                                _                                _                                maybeRecalculateMetadataHash(blobContainer, fileInfo, metadata)__                            } catch (Exception e) {_                                logger.warn(() -> new ParameterizedMessage("{} Can't calculate hash from blob for file [{}] [{}]", shardId, fileInfo.physicalName(), fileInfo.metadata()), e)__                            }_                            if (fileInfo.isSame(md) && snapshotFileExistsInBlobs(fileInfo, blobs)) {_                                _                                _                                existingFileInfo = fileInfo__                                break__                            }_                        }_                    }__                    indexTotalFileCount += md.length()__                    indexTotalNumberOfFiles++___                    if (existingFileInfo == null) {_                        indexIncrementalFileCount++__                        indexIncrementalSize += md.length()__                        _                        BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo = new BlobStoreIndexShardSnapshot.FileInfo(fileNameFromGeneration(++generation), md, chunkSize())__                        indexCommitPointFiles.add(snapshotFileInfo)__                        filesToSnapshot.add(snapshotFileInfo)__                    } else {_                        indexCommitPointFiles.add(existingFileInfo)__                    }_                }__                snapshotStatus.moveToStarted(startTime, indexIncrementalFileCount,_                    indexTotalNumberOfFiles, indexIncrementalSize, indexTotalFileCount)___                for (BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo : filesToSnapshot) {_                    try {_                        snapshotFile(snapshotFileInfo)__                    } catch (IOException e) {_                        throw new IndexShardSnapshotFailedException(shardId, "Failed to perform snapshot (index files)", e)__                    }_                }_            } finally {_                store.decRef()__            }__            final IndexShardSnapshotStatus.Copy lastSnapshotStatus = snapshotStatus.moveToFinalize(snapshotIndexCommit.getGeneration())___            _            final BlobStoreIndexShardSnapshot snapshot = new BlobStoreIndexShardSnapshot(snapshotId.getName(),_                                                                        lastSnapshotStatus.getIndexVersion(),_                                                                        indexCommitPointFiles,_                                                                        lastSnapshotStatus.getStartTime(),_                                                                        _                                                                        _                                                                        System.currentTimeMillis() - lastSnapshotStatus.getStartTime(),_                                                                        lastSnapshotStatus.getIncrementalFileCount(),_                                                                        lastSnapshotStatus.getIncrementalSize()_            )___            _            logger.trace("[{}] [{}] writing shard snapshot file", shardId, snapshotId)__            try {_                indexShardSnapshotFormat.write(snapshot, blobContainer, snapshotId.getUUID())__            } catch (IOException e) {_                throw new IndexShardSnapshotFailedException(shardId, "Failed to write commit point", e)__            }__            _            _            List<SnapshotFiles> newSnapshotsList = new ArrayList<>()__            newSnapshotsList.add(new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles()))__            for (SnapshotFiles point : snapshots) {_                newSnapshotsList.add(point)__            }_            _            finalize(newSnapshotsList, fileListGeneration + 1, blobs, "snapshot creation [" + snapshotId + "]")__            snapshotStatus.moveToDone(System.currentTimeMillis())___        };create,snapshot,from,index,commit,point,param,snapshot,index,commit,snapshot,commit,point;public,void,snapshot,final,index,commit,snapshot,index,commit,logger,debug,snapshot,to,shard,id,snapshot,id,metadata,name,final,map,string,blob,meta,data,blobs,try,blobs,blob,container,list,blobs,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,list,blobs,e,long,generation,find,latest,file,name,generation,blobs,tuple,blob,store,index,shard,snapshots,integer,tuple,build,blob,store,index,shard,snapshots,blobs,blob,store,index,shard,snapshots,snapshots,tuple,v1,int,file,list,generation,tuple,v2,if,snapshots,snapshots,stream,any,match,sf,sf,snapshot,equals,snapshot,id,get,name,throw,new,index,shard,snapshot,failed,exception,shard,id,duplicate,snapshot,name,snapshot,id,get,name,detected,aborting,final,list,blob,store,index,shard,snapshot,file,info,index,commit,point,files,new,array,list,store,inc,ref,int,index,incremental,file,count,0,int,index,total,number,of,files,0,long,index,incremental,size,0,long,index,total,file,count,0,try,array,list,blob,store,index,shard,snapshot,file,info,files,to,snapshot,new,array,list,final,store,metadata,snapshot,metadata,final,collection,string,file,names,try,logger,trace,loading,store,metadata,using,index,commit,shard,id,snapshot,id,snapshot,index,commit,metadata,store,get,metadata,snapshot,index,commit,file,names,snapshot,index,commit,get,file,names,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,get,store,file,metadata,e,for,string,file,name,file,names,if,snapshot,status,is,aborted,logger,debug,aborted,on,the,file,exiting,shard,id,snapshot,id,file,name,throw,new,index,shard,snapshot,failed,exception,shard,id,aborted,logger,trace,processing,shard,id,snapshot,id,file,name,final,store,file,meta,data,md,metadata,get,file,name,blob,store,index,shard,snapshot,file,info,existing,file,info,null,list,blob,store,index,shard,snapshot,file,info,files,info,snapshots,find,physical,index,files,file,name,if,files,info,null,for,blob,store,index,shard,snapshot,file,info,file,info,files,info,try,maybe,recalculate,metadata,hash,blob,container,file,info,metadata,catch,exception,e,logger,warn,new,parameterized,message,can,t,calculate,hash,from,blob,for,file,shard,id,file,info,physical,name,file,info,metadata,e,if,file,info,is,same,md,snapshot,file,exists,in,blobs,file,info,blobs,existing,file,info,file,info,break,index,total,file,count,md,length,index,total,number,of,files,if,existing,file,info,null,index,incremental,file,count,index,incremental,size,md,length,blob,store,index,shard,snapshot,file,info,snapshot,file,info,new,blob,store,index,shard,snapshot,file,info,file,name,from,generation,generation,md,chunk,size,index,commit,point,files,add,snapshot,file,info,files,to,snapshot,add,snapshot,file,info,else,index,commit,point,files,add,existing,file,info,snapshot,status,move,to,started,start,time,index,incremental,file,count,index,total,number,of,files,index,incremental,size,index,total,file,count,for,blob,store,index,shard,snapshot,file,info,snapshot,file,info,files,to,snapshot,try,snapshot,file,snapshot,file,info,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,perform,snapshot,index,files,e,finally,store,dec,ref,final,index,shard,snapshot,status,copy,last,snapshot,status,snapshot,status,move,to,finalize,snapshot,index,commit,get,generation,final,blob,store,index,shard,snapshot,snapshot,new,blob,store,index,shard,snapshot,snapshot,id,get,name,last,snapshot,status,get,index,version,index,commit,point,files,last,snapshot,status,get,start,time,system,current,time,millis,last,snapshot,status,get,start,time,last,snapshot,status,get,incremental,file,count,last,snapshot,status,get,incremental,size,logger,trace,writing,shard,snapshot,file,shard,id,snapshot,id,try,index,shard,snapshot,format,write,snapshot,blob,container,snapshot,id,get,uuid,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,write,commit,point,e,list,snapshot,files,new,snapshots,list,new,array,list,new,snapshots,list,add,new,snapshot,files,snapshot,snapshot,snapshot,index,files,for,snapshot,files,point,snapshots,new,snapshots,list,add,point,finalize,new,snapshots,list,file,list,generation,1,blobs,snapshot,creation,snapshot,id,snapshot,status,move,to,done,system,current,time,millis
BlobStoreRepository -> SnapshotContext -> public void snapshot(final IndexCommit snapshotIndexCommit);1542646292;Create snapshot from index commit point__@param snapshotIndexCommit snapshot commit point;public void snapshot(final IndexCommit snapshotIndexCommit) {_            logger.debug("[{}] [{}] snapshot to [{}] ...", shardId, snapshotId, metadata.name())___            final Map<String, BlobMetaData> blobs__            try {_                blobs = blobContainer.listBlobs()__            } catch (IOException e) {_                throw new IndexShardSnapshotFailedException(shardId, "failed to list blobs", e)__            }__            long generation = findLatestFileNameGeneration(blobs)__            Tuple<BlobStoreIndexShardSnapshots, Integer> tuple = buildBlobStoreIndexShardSnapshots(blobs)__            BlobStoreIndexShardSnapshots snapshots = tuple.v1()__            int fileListGeneration = tuple.v2()___            if (snapshots.snapshots().stream().anyMatch(sf -> sf.snapshot().equals(snapshotId.getName()))) {_                throw new IndexShardSnapshotFailedException(shardId,_                    "Duplicate snapshot name [" + snapshotId.getName() + "] detected, aborting")__            }__            final List<BlobStoreIndexShardSnapshot.FileInfo> indexCommitPointFiles = new ArrayList<>()___            store.incRef()__            int indexIncrementalFileCount = 0__            int indexTotalNumberOfFiles = 0__            long indexIncrementalSize = 0__            long indexTotalFileCount = 0__            try {_                ArrayList<BlobStoreIndexShardSnapshot.FileInfo> filesToSnapshot = new ArrayList<>()__                final Store.MetadataSnapshot metadata__                _                final Collection<String> fileNames__                try {_                    logger.trace("[{}] [{}] Loading store metadata using index commit [{}]", shardId, snapshotId, snapshotIndexCommit)__                    metadata = store.getMetadata(snapshotIndexCommit)__                    fileNames = snapshotIndexCommit.getFileNames()__                } catch (IOException e) {_                    throw new IndexShardSnapshotFailedException(shardId, "Failed to get store file metadata", e)__                }_                for (String fileName : fileNames) {_                    if (snapshotStatus.isAborted()) {_                        logger.debug("[{}] [{}] Aborted on the file [{}], exiting", shardId, snapshotId, fileName)__                        throw new IndexShardSnapshotFailedException(shardId, "Aborted")__                    }__                    logger.trace("[{}] [{}] Processing [{}]", shardId, snapshotId, fileName)__                    final StoreFileMetaData md = metadata.get(fileName)__                    BlobStoreIndexShardSnapshot.FileInfo existingFileInfo = null__                    List<BlobStoreIndexShardSnapshot.FileInfo> filesInfo = snapshots.findPhysicalIndexFiles(fileName)__                    if (filesInfo != null) {_                        for (BlobStoreIndexShardSnapshot.FileInfo fileInfo : filesInfo) {_                            try {_                                _                                _                                _                                _                                maybeRecalculateMetadataHash(blobContainer, fileInfo, metadata)__                            } catch (Exception e) {_                                logger.warn(() -> new ParameterizedMessage("{} Can't calculate hash from blob for file [{}] [{}]", shardId, fileInfo.physicalName(), fileInfo.metadata()), e)__                            }_                            if (fileInfo.isSame(md) && snapshotFileExistsInBlobs(fileInfo, blobs)) {_                                _                                _                                existingFileInfo = fileInfo__                                break__                            }_                        }_                    }__                    indexTotalFileCount += md.length()__                    indexTotalNumberOfFiles++___                    if (existingFileInfo == null) {_                        indexIncrementalFileCount++__                        indexIncrementalSize += md.length()__                        _                        BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo = new BlobStoreIndexShardSnapshot.FileInfo(fileNameFromGeneration(++generation), md, chunkSize())__                        indexCommitPointFiles.add(snapshotFileInfo)__                        filesToSnapshot.add(snapshotFileInfo)__                    } else {_                        indexCommitPointFiles.add(existingFileInfo)__                    }_                }__                snapshotStatus.moveToStarted(startTime, indexIncrementalFileCount,_                    indexTotalNumberOfFiles, indexIncrementalSize, indexTotalFileCount)___                for (BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo : filesToSnapshot) {_                    try {_                        snapshotFile(snapshotFileInfo)__                    } catch (IOException e) {_                        throw new IndexShardSnapshotFailedException(shardId, "Failed to perform snapshot (index files)", e)__                    }_                }_            } finally {_                store.decRef()__            }__            final IndexShardSnapshotStatus.Copy lastSnapshotStatus = snapshotStatus.moveToFinalize(snapshotIndexCommit.getGeneration())___            _            final BlobStoreIndexShardSnapshot snapshot = new BlobStoreIndexShardSnapshot(snapshotId.getName(),_                                                                        lastSnapshotStatus.getIndexVersion(),_                                                                        indexCommitPointFiles,_                                                                        lastSnapshotStatus.getStartTime(),_                                                                        _                                                                        _                                                                        System.currentTimeMillis() - lastSnapshotStatus.getStartTime(),_                                                                        lastSnapshotStatus.getIncrementalFileCount(),_                                                                        lastSnapshotStatus.getIncrementalSize()_            )___            _            logger.trace("[{}] [{}] writing shard snapshot file", shardId, snapshotId)__            try {_                indexShardSnapshotFormat.write(snapshot, blobContainer, snapshotId.getUUID())__            } catch (IOException e) {_                throw new IndexShardSnapshotFailedException(shardId, "Failed to write commit point", e)__            }__            _            _            List<SnapshotFiles> newSnapshotsList = new ArrayList<>()__            newSnapshotsList.add(new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles()))__            for (SnapshotFiles point : snapshots) {_                newSnapshotsList.add(point)__            }_            _            finalize(newSnapshotsList, fileListGeneration + 1, blobs, "snapshot creation [" + snapshotId + "]")__            snapshotStatus.moveToDone(System.currentTimeMillis())___        };create,snapshot,from,index,commit,point,param,snapshot,index,commit,snapshot,commit,point;public,void,snapshot,final,index,commit,snapshot,index,commit,logger,debug,snapshot,to,shard,id,snapshot,id,metadata,name,final,map,string,blob,meta,data,blobs,try,blobs,blob,container,list,blobs,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,list,blobs,e,long,generation,find,latest,file,name,generation,blobs,tuple,blob,store,index,shard,snapshots,integer,tuple,build,blob,store,index,shard,snapshots,blobs,blob,store,index,shard,snapshots,snapshots,tuple,v1,int,file,list,generation,tuple,v2,if,snapshots,snapshots,stream,any,match,sf,sf,snapshot,equals,snapshot,id,get,name,throw,new,index,shard,snapshot,failed,exception,shard,id,duplicate,snapshot,name,snapshot,id,get,name,detected,aborting,final,list,blob,store,index,shard,snapshot,file,info,index,commit,point,files,new,array,list,store,inc,ref,int,index,incremental,file,count,0,int,index,total,number,of,files,0,long,index,incremental,size,0,long,index,total,file,count,0,try,array,list,blob,store,index,shard,snapshot,file,info,files,to,snapshot,new,array,list,final,store,metadata,snapshot,metadata,final,collection,string,file,names,try,logger,trace,loading,store,metadata,using,index,commit,shard,id,snapshot,id,snapshot,index,commit,metadata,store,get,metadata,snapshot,index,commit,file,names,snapshot,index,commit,get,file,names,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,get,store,file,metadata,e,for,string,file,name,file,names,if,snapshot,status,is,aborted,logger,debug,aborted,on,the,file,exiting,shard,id,snapshot,id,file,name,throw,new,index,shard,snapshot,failed,exception,shard,id,aborted,logger,trace,processing,shard,id,snapshot,id,file,name,final,store,file,meta,data,md,metadata,get,file,name,blob,store,index,shard,snapshot,file,info,existing,file,info,null,list,blob,store,index,shard,snapshot,file,info,files,info,snapshots,find,physical,index,files,file,name,if,files,info,null,for,blob,store,index,shard,snapshot,file,info,file,info,files,info,try,maybe,recalculate,metadata,hash,blob,container,file,info,metadata,catch,exception,e,logger,warn,new,parameterized,message,can,t,calculate,hash,from,blob,for,file,shard,id,file,info,physical,name,file,info,metadata,e,if,file,info,is,same,md,snapshot,file,exists,in,blobs,file,info,blobs,existing,file,info,file,info,break,index,total,file,count,md,length,index,total,number,of,files,if,existing,file,info,null,index,incremental,file,count,index,incremental,size,md,length,blob,store,index,shard,snapshot,file,info,snapshot,file,info,new,blob,store,index,shard,snapshot,file,info,file,name,from,generation,generation,md,chunk,size,index,commit,point,files,add,snapshot,file,info,files,to,snapshot,add,snapshot,file,info,else,index,commit,point,files,add,existing,file,info,snapshot,status,move,to,started,start,time,index,incremental,file,count,index,total,number,of,files,index,incremental,size,index,total,file,count,for,blob,store,index,shard,snapshot,file,info,snapshot,file,info,files,to,snapshot,try,snapshot,file,snapshot,file,info,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,perform,snapshot,index,files,e,finally,store,dec,ref,final,index,shard,snapshot,status,copy,last,snapshot,status,snapshot,status,move,to,finalize,snapshot,index,commit,get,generation,final,blob,store,index,shard,snapshot,snapshot,new,blob,store,index,shard,snapshot,snapshot,id,get,name,last,snapshot,status,get,index,version,index,commit,point,files,last,snapshot,status,get,start,time,system,current,time,millis,last,snapshot,status,get,start,time,last,snapshot,status,get,incremental,file,count,last,snapshot,status,get,incremental,size,logger,trace,writing,shard,snapshot,file,shard,id,snapshot,id,try,index,shard,snapshot,format,write,snapshot,blob,container,snapshot,id,get,uuid,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,write,commit,point,e,list,snapshot,files,new,snapshots,list,new,array,list,new,snapshots,list,add,new,snapshot,files,snapshot,snapshot,snapshot,index,files,for,snapshot,files,point,snapshots,new,snapshots,list,add,point,finalize,new,snapshots,list,file,list,generation,1,blobs,snapshot,creation,snapshot,id,snapshot,status,move,to,done,system,current,time,millis
BlobStoreRepository -> SnapshotContext -> public void snapshot(final IndexCommit snapshotIndexCommit);1542980705;Create snapshot from index commit point__@param snapshotIndexCommit snapshot commit point;public void snapshot(final IndexCommit snapshotIndexCommit) {_            logger.debug("[{}] [{}] snapshot to [{}] ...", shardId, snapshotId, metadata.name())___            final Map<String, BlobMetaData> blobs__            try {_                blobs = blobContainer.listBlobs()__            } catch (IOException e) {_                throw new IndexShardSnapshotFailedException(shardId, "failed to list blobs", e)__            }__            long generation = findLatestFileNameGeneration(blobs)__            Tuple<BlobStoreIndexShardSnapshots, Integer> tuple = buildBlobStoreIndexShardSnapshots(blobs)__            BlobStoreIndexShardSnapshots snapshots = tuple.v1()__            int fileListGeneration = tuple.v2()___            if (snapshots.snapshots().stream().anyMatch(sf -> sf.snapshot().equals(snapshotId.getName()))) {_                throw new IndexShardSnapshotFailedException(shardId,_                    "Duplicate snapshot name [" + snapshotId.getName() + "] detected, aborting")__            }__            final List<BlobStoreIndexShardSnapshot.FileInfo> indexCommitPointFiles = new ArrayList<>()___            store.incRef()__            int indexIncrementalFileCount = 0__            int indexTotalNumberOfFiles = 0__            long indexIncrementalSize = 0__            long indexTotalFileCount = 0__            try {_                ArrayList<BlobStoreIndexShardSnapshot.FileInfo> filesToSnapshot = new ArrayList<>()__                final Store.MetadataSnapshot metadata__                _                final Collection<String> fileNames__                try {_                    logger.trace("[{}] [{}] Loading store metadata using index commit [{}]", shardId, snapshotId, snapshotIndexCommit)__                    metadata = store.getMetadata(snapshotIndexCommit)__                    fileNames = snapshotIndexCommit.getFileNames()__                } catch (IOException e) {_                    throw new IndexShardSnapshotFailedException(shardId, "Failed to get store file metadata", e)__                }_                for (String fileName : fileNames) {_                    if (snapshotStatus.isAborted()) {_                        logger.debug("[{}] [{}] Aborted on the file [{}], exiting", shardId, snapshotId, fileName)__                        throw new IndexShardSnapshotFailedException(shardId, "Aborted")__                    }__                    logger.trace("[{}] [{}] Processing [{}]", shardId, snapshotId, fileName)__                    final StoreFileMetaData md = metadata.get(fileName)__                    BlobStoreIndexShardSnapshot.FileInfo existingFileInfo = null__                    List<BlobStoreIndexShardSnapshot.FileInfo> filesInfo = snapshots.findPhysicalIndexFiles(fileName)__                    if (filesInfo != null) {_                        for (BlobStoreIndexShardSnapshot.FileInfo fileInfo : filesInfo) {_                            try {_                                _                                _                                _                                _                                maybeRecalculateMetadataHash(blobContainer, fileInfo, metadata)__                            } catch (Exception e) {_                                logger.warn(() -> new ParameterizedMessage("{} Can't calculate hash from blob for file [{}] [{}]", shardId, fileInfo.physicalName(), fileInfo.metadata()), e)__                            }_                            if (fileInfo.isSame(md) && snapshotFileExistsInBlobs(fileInfo, blobs)) {_                                _                                _                                existingFileInfo = fileInfo__                                break__                            }_                        }_                    }__                    indexTotalFileCount += md.length()__                    indexTotalNumberOfFiles++___                    if (existingFileInfo == null) {_                        indexIncrementalFileCount++__                        indexIncrementalSize += md.length()__                        _                        BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo = new BlobStoreIndexShardSnapshot.FileInfo(fileNameFromGeneration(++generation), md, chunkSize())__                        indexCommitPointFiles.add(snapshotFileInfo)__                        filesToSnapshot.add(snapshotFileInfo)__                    } else {_                        indexCommitPointFiles.add(existingFileInfo)__                    }_                }__                snapshotStatus.moveToStarted(startTime, indexIncrementalFileCount,_                    indexTotalNumberOfFiles, indexIncrementalSize, indexTotalFileCount)___                for (BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo : filesToSnapshot) {_                    try {_                        snapshotFile(snapshotFileInfo)__                    } catch (IOException e) {_                        throw new IndexShardSnapshotFailedException(shardId, "Failed to perform snapshot (index files)", e)__                    }_                }_            } finally {_                store.decRef()__            }__            final IndexShardSnapshotStatus.Copy lastSnapshotStatus = snapshotStatus.moveToFinalize(snapshotIndexCommit.getGeneration())___            _            final BlobStoreIndexShardSnapshot snapshot = new BlobStoreIndexShardSnapshot(snapshotId.getName(),_                                                                        lastSnapshotStatus.getIndexVersion(),_                                                                        indexCommitPointFiles,_                                                                        lastSnapshotStatus.getStartTime(),_                                                                        _                                                                        _                                                                        System.currentTimeMillis() - lastSnapshotStatus.getStartTime(),_                                                                        lastSnapshotStatus.getIncrementalFileCount(),_                                                                        lastSnapshotStatus.getIncrementalSize()_            )___            _            logger.trace("[{}] [{}] writing shard snapshot file", shardId, snapshotId)__            try {_                indexShardSnapshotFormat.write(snapshot, blobContainer, snapshotId.getUUID())__            } catch (IOException e) {_                throw new IndexShardSnapshotFailedException(shardId, "Failed to write commit point", e)__            }__            _            _            List<SnapshotFiles> newSnapshotsList = new ArrayList<>()__            newSnapshotsList.add(new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles()))__            for (SnapshotFiles point : snapshots) {_                newSnapshotsList.add(point)__            }_            _            finalize(newSnapshotsList, fileListGeneration + 1, blobs, "snapshot creation [" + snapshotId + "]")__            snapshotStatus.moveToDone(System.currentTimeMillis())___        };create,snapshot,from,index,commit,point,param,snapshot,index,commit,snapshot,commit,point;public,void,snapshot,final,index,commit,snapshot,index,commit,logger,debug,snapshot,to,shard,id,snapshot,id,metadata,name,final,map,string,blob,meta,data,blobs,try,blobs,blob,container,list,blobs,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,list,blobs,e,long,generation,find,latest,file,name,generation,blobs,tuple,blob,store,index,shard,snapshots,integer,tuple,build,blob,store,index,shard,snapshots,blobs,blob,store,index,shard,snapshots,snapshots,tuple,v1,int,file,list,generation,tuple,v2,if,snapshots,snapshots,stream,any,match,sf,sf,snapshot,equals,snapshot,id,get,name,throw,new,index,shard,snapshot,failed,exception,shard,id,duplicate,snapshot,name,snapshot,id,get,name,detected,aborting,final,list,blob,store,index,shard,snapshot,file,info,index,commit,point,files,new,array,list,store,inc,ref,int,index,incremental,file,count,0,int,index,total,number,of,files,0,long,index,incremental,size,0,long,index,total,file,count,0,try,array,list,blob,store,index,shard,snapshot,file,info,files,to,snapshot,new,array,list,final,store,metadata,snapshot,metadata,final,collection,string,file,names,try,logger,trace,loading,store,metadata,using,index,commit,shard,id,snapshot,id,snapshot,index,commit,metadata,store,get,metadata,snapshot,index,commit,file,names,snapshot,index,commit,get,file,names,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,get,store,file,metadata,e,for,string,file,name,file,names,if,snapshot,status,is,aborted,logger,debug,aborted,on,the,file,exiting,shard,id,snapshot,id,file,name,throw,new,index,shard,snapshot,failed,exception,shard,id,aborted,logger,trace,processing,shard,id,snapshot,id,file,name,final,store,file,meta,data,md,metadata,get,file,name,blob,store,index,shard,snapshot,file,info,existing,file,info,null,list,blob,store,index,shard,snapshot,file,info,files,info,snapshots,find,physical,index,files,file,name,if,files,info,null,for,blob,store,index,shard,snapshot,file,info,file,info,files,info,try,maybe,recalculate,metadata,hash,blob,container,file,info,metadata,catch,exception,e,logger,warn,new,parameterized,message,can,t,calculate,hash,from,blob,for,file,shard,id,file,info,physical,name,file,info,metadata,e,if,file,info,is,same,md,snapshot,file,exists,in,blobs,file,info,blobs,existing,file,info,file,info,break,index,total,file,count,md,length,index,total,number,of,files,if,existing,file,info,null,index,incremental,file,count,index,incremental,size,md,length,blob,store,index,shard,snapshot,file,info,snapshot,file,info,new,blob,store,index,shard,snapshot,file,info,file,name,from,generation,generation,md,chunk,size,index,commit,point,files,add,snapshot,file,info,files,to,snapshot,add,snapshot,file,info,else,index,commit,point,files,add,existing,file,info,snapshot,status,move,to,started,start,time,index,incremental,file,count,index,total,number,of,files,index,incremental,size,index,total,file,count,for,blob,store,index,shard,snapshot,file,info,snapshot,file,info,files,to,snapshot,try,snapshot,file,snapshot,file,info,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,perform,snapshot,index,files,e,finally,store,dec,ref,final,index,shard,snapshot,status,copy,last,snapshot,status,snapshot,status,move,to,finalize,snapshot,index,commit,get,generation,final,blob,store,index,shard,snapshot,snapshot,new,blob,store,index,shard,snapshot,snapshot,id,get,name,last,snapshot,status,get,index,version,index,commit,point,files,last,snapshot,status,get,start,time,system,current,time,millis,last,snapshot,status,get,start,time,last,snapshot,status,get,incremental,file,count,last,snapshot,status,get,incremental,size,logger,trace,writing,shard,snapshot,file,shard,id,snapshot,id,try,index,shard,snapshot,format,write,snapshot,blob,container,snapshot,id,get,uuid,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,write,commit,point,e,list,snapshot,files,new,snapshots,list,new,array,list,new,snapshots,list,add,new,snapshot,files,snapshot,snapshot,snapshot,index,files,for,snapshot,files,point,snapshots,new,snapshots,list,add,point,finalize,new,snapshots,list,file,list,generation,1,blobs,snapshot,creation,snapshot,id,snapshot,status,move,to,done,system,current,time,millis
BlobStoreRepository -> SnapshotContext -> public void snapshot(final IndexCommit snapshotIndexCommit);1543831870;Create snapshot from index commit point__@param snapshotIndexCommit snapshot commit point;public void snapshot(final IndexCommit snapshotIndexCommit) {_            logger.debug("[{}] [{}] snapshot to [{}] ...", shardId, snapshotId, metadata.name())___            final Map<String, BlobMetaData> blobs__            try {_                blobs = blobContainer.listBlobs()__            } catch (IOException e) {_                throw new IndexShardSnapshotFailedException(shardId, "failed to list blobs", e)__            }__            long generation = findLatestFileNameGeneration(blobs)__            Tuple<BlobStoreIndexShardSnapshots, Integer> tuple = buildBlobStoreIndexShardSnapshots(blobs)__            BlobStoreIndexShardSnapshots snapshots = tuple.v1()__            int fileListGeneration = tuple.v2()___            if (snapshots.snapshots().stream().anyMatch(sf -> sf.snapshot().equals(snapshotId.getName()))) {_                throw new IndexShardSnapshotFailedException(shardId,_                    "Duplicate snapshot name [" + snapshotId.getName() + "] detected, aborting")__            }__            final List<BlobStoreIndexShardSnapshot.FileInfo> indexCommitPointFiles = new ArrayList<>()___            store.incRef()__            int indexIncrementalFileCount = 0__            int indexTotalNumberOfFiles = 0__            long indexIncrementalSize = 0__            long indexTotalFileCount = 0__            try {_                ArrayList<BlobStoreIndexShardSnapshot.FileInfo> filesToSnapshot = new ArrayList<>()__                final Store.MetadataSnapshot metadata__                _                final Collection<String> fileNames__                try {_                    logger.trace("[{}] [{}] Loading store metadata using index commit [{}]", shardId, snapshotId, snapshotIndexCommit)__                    metadata = store.getMetadata(snapshotIndexCommit)__                    fileNames = snapshotIndexCommit.getFileNames()__                } catch (IOException e) {_                    throw new IndexShardSnapshotFailedException(shardId, "Failed to get store file metadata", e)__                }_                for (String fileName : fileNames) {_                    if (snapshotStatus.isAborted()) {_                        logger.debug("[{}] [{}] Aborted on the file [{}], exiting", shardId, snapshotId, fileName)__                        throw new IndexShardSnapshotFailedException(shardId, "Aborted")__                    }__                    logger.trace("[{}] [{}] Processing [{}]", shardId, snapshotId, fileName)__                    final StoreFileMetaData md = metadata.get(fileName)__                    BlobStoreIndexShardSnapshot.FileInfo existingFileInfo = null__                    List<BlobStoreIndexShardSnapshot.FileInfo> filesInfo = snapshots.findPhysicalIndexFiles(fileName)__                    if (filesInfo != null) {_                        for (BlobStoreIndexShardSnapshot.FileInfo fileInfo : filesInfo) {_                            try {_                                _                                _                                _                                _                                maybeRecalculateMetadataHash(blobContainer, fileInfo, metadata)__                            } catch (Exception e) {_                                logger.warn(() -> new ParameterizedMessage("{} Can't calculate hash from blob for file [{}] [{}]", shardId, fileInfo.physicalName(), fileInfo.metadata()), e)__                            }_                            if (fileInfo.isSame(md) && snapshotFileExistsInBlobs(fileInfo, blobs)) {_                                _                                _                                existingFileInfo = fileInfo__                                break__                            }_                        }_                    }__                    indexTotalFileCount += md.length()__                    indexTotalNumberOfFiles++___                    if (existingFileInfo == null) {_                        indexIncrementalFileCount++__                        indexIncrementalSize += md.length()__                        _                        BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo = new BlobStoreIndexShardSnapshot.FileInfo(fileNameFromGeneration(++generation), md, chunkSize())__                        indexCommitPointFiles.add(snapshotFileInfo)__                        filesToSnapshot.add(snapshotFileInfo)__                    } else {_                        indexCommitPointFiles.add(existingFileInfo)__                    }_                }__                snapshotStatus.moveToStarted(startTime, indexIncrementalFileCount,_                    indexTotalNumberOfFiles, indexIncrementalSize, indexTotalFileCount)___                for (BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo : filesToSnapshot) {_                    try {_                        snapshotFile(snapshotFileInfo)__                    } catch (IOException e) {_                        throw new IndexShardSnapshotFailedException(shardId, "Failed to perform snapshot (index files)", e)__                    }_                }_            } finally {_                store.decRef()__            }__            final IndexShardSnapshotStatus.Copy lastSnapshotStatus = snapshotStatus.moveToFinalize(snapshotIndexCommit.getGeneration())___            _            final BlobStoreIndexShardSnapshot snapshot = new BlobStoreIndexShardSnapshot(snapshotId.getName(),_                                                                        lastSnapshotStatus.getIndexVersion(),_                                                                        indexCommitPointFiles,_                                                                        lastSnapshotStatus.getStartTime(),_                                                                        _                                                                        _                                                                        System.currentTimeMillis() - lastSnapshotStatus.getStartTime(),_                                                                        lastSnapshotStatus.getIncrementalFileCount(),_                                                                        lastSnapshotStatus.getIncrementalSize()_            )___            _            logger.trace("[{}] [{}] writing shard snapshot file", shardId, snapshotId)__            try {_                indexShardSnapshotFormat.write(snapshot, blobContainer, snapshotId.getUUID())__            } catch (IOException e) {_                throw new IndexShardSnapshotFailedException(shardId, "Failed to write commit point", e)__            }__            _            _            List<SnapshotFiles> newSnapshotsList = new ArrayList<>()__            newSnapshotsList.add(new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles()))__            for (SnapshotFiles point : snapshots) {_                newSnapshotsList.add(point)__            }_            _            finalize(newSnapshotsList, fileListGeneration + 1, blobs, "snapshot creation [" + snapshotId + "]")__            snapshotStatus.moveToDone(System.currentTimeMillis())__        };create,snapshot,from,index,commit,point,param,snapshot,index,commit,snapshot,commit,point;public,void,snapshot,final,index,commit,snapshot,index,commit,logger,debug,snapshot,to,shard,id,snapshot,id,metadata,name,final,map,string,blob,meta,data,blobs,try,blobs,blob,container,list,blobs,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,list,blobs,e,long,generation,find,latest,file,name,generation,blobs,tuple,blob,store,index,shard,snapshots,integer,tuple,build,blob,store,index,shard,snapshots,blobs,blob,store,index,shard,snapshots,snapshots,tuple,v1,int,file,list,generation,tuple,v2,if,snapshots,snapshots,stream,any,match,sf,sf,snapshot,equals,snapshot,id,get,name,throw,new,index,shard,snapshot,failed,exception,shard,id,duplicate,snapshot,name,snapshot,id,get,name,detected,aborting,final,list,blob,store,index,shard,snapshot,file,info,index,commit,point,files,new,array,list,store,inc,ref,int,index,incremental,file,count,0,int,index,total,number,of,files,0,long,index,incremental,size,0,long,index,total,file,count,0,try,array,list,blob,store,index,shard,snapshot,file,info,files,to,snapshot,new,array,list,final,store,metadata,snapshot,metadata,final,collection,string,file,names,try,logger,trace,loading,store,metadata,using,index,commit,shard,id,snapshot,id,snapshot,index,commit,metadata,store,get,metadata,snapshot,index,commit,file,names,snapshot,index,commit,get,file,names,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,get,store,file,metadata,e,for,string,file,name,file,names,if,snapshot,status,is,aborted,logger,debug,aborted,on,the,file,exiting,shard,id,snapshot,id,file,name,throw,new,index,shard,snapshot,failed,exception,shard,id,aborted,logger,trace,processing,shard,id,snapshot,id,file,name,final,store,file,meta,data,md,metadata,get,file,name,blob,store,index,shard,snapshot,file,info,existing,file,info,null,list,blob,store,index,shard,snapshot,file,info,files,info,snapshots,find,physical,index,files,file,name,if,files,info,null,for,blob,store,index,shard,snapshot,file,info,file,info,files,info,try,maybe,recalculate,metadata,hash,blob,container,file,info,metadata,catch,exception,e,logger,warn,new,parameterized,message,can,t,calculate,hash,from,blob,for,file,shard,id,file,info,physical,name,file,info,metadata,e,if,file,info,is,same,md,snapshot,file,exists,in,blobs,file,info,blobs,existing,file,info,file,info,break,index,total,file,count,md,length,index,total,number,of,files,if,existing,file,info,null,index,incremental,file,count,index,incremental,size,md,length,blob,store,index,shard,snapshot,file,info,snapshot,file,info,new,blob,store,index,shard,snapshot,file,info,file,name,from,generation,generation,md,chunk,size,index,commit,point,files,add,snapshot,file,info,files,to,snapshot,add,snapshot,file,info,else,index,commit,point,files,add,existing,file,info,snapshot,status,move,to,started,start,time,index,incremental,file,count,index,total,number,of,files,index,incremental,size,index,total,file,count,for,blob,store,index,shard,snapshot,file,info,snapshot,file,info,files,to,snapshot,try,snapshot,file,snapshot,file,info,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,perform,snapshot,index,files,e,finally,store,dec,ref,final,index,shard,snapshot,status,copy,last,snapshot,status,snapshot,status,move,to,finalize,snapshot,index,commit,get,generation,final,blob,store,index,shard,snapshot,snapshot,new,blob,store,index,shard,snapshot,snapshot,id,get,name,last,snapshot,status,get,index,version,index,commit,point,files,last,snapshot,status,get,start,time,system,current,time,millis,last,snapshot,status,get,start,time,last,snapshot,status,get,incremental,file,count,last,snapshot,status,get,incremental,size,logger,trace,writing,shard,snapshot,file,shard,id,snapshot,id,try,index,shard,snapshot,format,write,snapshot,blob,container,snapshot,id,get,uuid,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,write,commit,point,e,list,snapshot,files,new,snapshots,list,new,array,list,new,snapshots,list,add,new,snapshot,files,snapshot,snapshot,snapshot,index,files,for,snapshot,files,point,snapshots,new,snapshots,list,add,point,finalize,new,snapshots,list,file,list,generation,1,blobs,snapshot,creation,snapshot,id,snapshot,status,move,to,done,system,current,time,millis
BlobStoreRepository -> SnapshotContext -> public void snapshot(final IndexCommit snapshotIndexCommit);1543942400;Create snapshot from index commit point__@param snapshotIndexCommit snapshot commit point;public void snapshot(final IndexCommit snapshotIndexCommit) {_            logger.debug("[{}] [{}] snapshot to [{}] ...", shardId, snapshotId, metadata.name())___            final Map<String, BlobMetaData> blobs__            try {_                blobs = blobContainer.listBlobs()__            } catch (IOException e) {_                throw new IndexShardSnapshotFailedException(shardId, "failed to list blobs", e)__            }__            long generation = findLatestFileNameGeneration(blobs)__            Tuple<BlobStoreIndexShardSnapshots, Integer> tuple = buildBlobStoreIndexShardSnapshots(blobs)__            BlobStoreIndexShardSnapshots snapshots = tuple.v1()__            int fileListGeneration = tuple.v2()___            if (snapshots.snapshots().stream().anyMatch(sf -> sf.snapshot().equals(snapshotId.getName()))) {_                throw new IndexShardSnapshotFailedException(shardId,_                    "Duplicate snapshot name [" + snapshotId.getName() + "] detected, aborting")__            }__            final List<BlobStoreIndexShardSnapshot.FileInfo> indexCommitPointFiles = new ArrayList<>()___            store.incRef()__            int indexIncrementalFileCount = 0__            int indexTotalNumberOfFiles = 0__            long indexIncrementalSize = 0__            long indexTotalFileCount = 0__            try {_                ArrayList<BlobStoreIndexShardSnapshot.FileInfo> filesToSnapshot = new ArrayList<>()__                final Store.MetadataSnapshot metadata__                _                final Collection<String> fileNames__                try {_                    logger.trace("[{}] [{}] Loading store metadata using index commit [{}]", shardId, snapshotId, snapshotIndexCommit)__                    metadata = store.getMetadata(snapshotIndexCommit)__                    fileNames = snapshotIndexCommit.getFileNames()__                } catch (IOException e) {_                    throw new IndexShardSnapshotFailedException(shardId, "Failed to get store file metadata", e)__                }_                for (String fileName : fileNames) {_                    if (snapshotStatus.isAborted()) {_                        logger.debug("[{}] [{}] Aborted on the file [{}], exiting", shardId, snapshotId, fileName)__                        throw new IndexShardSnapshotFailedException(shardId, "Aborted")__                    }__                    logger.trace("[{}] [{}] Processing [{}]", shardId, snapshotId, fileName)__                    final StoreFileMetaData md = metadata.get(fileName)__                    BlobStoreIndexShardSnapshot.FileInfo existingFileInfo = null__                    List<BlobStoreIndexShardSnapshot.FileInfo> filesInfo = snapshots.findPhysicalIndexFiles(fileName)__                    if (filesInfo != null) {_                        for (BlobStoreIndexShardSnapshot.FileInfo fileInfo : filesInfo) {_                            try {_                                _                                _                                _                                _                                maybeRecalculateMetadataHash(blobContainer, fileInfo, metadata)__                            } catch (Exception e) {_                                logger.warn(() -> new ParameterizedMessage("{} Can't calculate hash from blob for file [{}] [{}]", shardId, fileInfo.physicalName(), fileInfo.metadata()), e)__                            }_                            if (fileInfo.isSame(md) && snapshotFileExistsInBlobs(fileInfo, blobs)) {_                                _                                _                                existingFileInfo = fileInfo__                                break__                            }_                        }_                    }__                    indexTotalFileCount += md.length()__                    indexTotalNumberOfFiles++___                    if (existingFileInfo == null) {_                        indexIncrementalFileCount++__                        indexIncrementalSize += md.length()__                        _                        BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo = new BlobStoreIndexShardSnapshot.FileInfo(fileNameFromGeneration(++generation), md, chunkSize())__                        indexCommitPointFiles.add(snapshotFileInfo)__                        filesToSnapshot.add(snapshotFileInfo)__                    } else {_                        indexCommitPointFiles.add(existingFileInfo)__                    }_                }__                snapshotStatus.moveToStarted(startTime, indexIncrementalFileCount,_                    indexTotalNumberOfFiles, indexIncrementalSize, indexTotalFileCount)___                for (BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo : filesToSnapshot) {_                    try {_                        snapshotFile(snapshotFileInfo)__                    } catch (IOException e) {_                        throw new IndexShardSnapshotFailedException(shardId, "Failed to perform snapshot (index files)", e)__                    }_                }_            } finally {_                store.decRef()__            }__            final IndexShardSnapshotStatus.Copy lastSnapshotStatus = snapshotStatus.moveToFinalize(snapshotIndexCommit.getGeneration())___            _            final BlobStoreIndexShardSnapshot snapshot = new BlobStoreIndexShardSnapshot(snapshotId.getName(),_                                                                        lastSnapshotStatus.getIndexVersion(),_                                                                        indexCommitPointFiles,_                                                                        lastSnapshotStatus.getStartTime(),_                                                                        _                                                                        _                                                                        System.currentTimeMillis() - lastSnapshotStatus.getStartTime(),_                                                                        lastSnapshotStatus.getIncrementalFileCount(),_                                                                        lastSnapshotStatus.getIncrementalSize()_            )___            _            logger.trace("[{}] [{}] writing shard snapshot file", shardId, snapshotId)__            try {_                indexShardSnapshotFormat.write(snapshot, blobContainer, snapshotId.getUUID())__            } catch (IOException e) {_                throw new IndexShardSnapshotFailedException(shardId, "Failed to write commit point", e)__            }__            _            _            List<SnapshotFiles> newSnapshotsList = new ArrayList<>()__            newSnapshotsList.add(new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles()))__            for (SnapshotFiles point : snapshots) {_                newSnapshotsList.add(point)__            }_            _            finalize(newSnapshotsList, fileListGeneration + 1, blobs, "snapshot creation [" + snapshotId + "]")__            snapshotStatus.moveToDone(System.currentTimeMillis())__        };create,snapshot,from,index,commit,point,param,snapshot,index,commit,snapshot,commit,point;public,void,snapshot,final,index,commit,snapshot,index,commit,logger,debug,snapshot,to,shard,id,snapshot,id,metadata,name,final,map,string,blob,meta,data,blobs,try,blobs,blob,container,list,blobs,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,list,blobs,e,long,generation,find,latest,file,name,generation,blobs,tuple,blob,store,index,shard,snapshots,integer,tuple,build,blob,store,index,shard,snapshots,blobs,blob,store,index,shard,snapshots,snapshots,tuple,v1,int,file,list,generation,tuple,v2,if,snapshots,snapshots,stream,any,match,sf,sf,snapshot,equals,snapshot,id,get,name,throw,new,index,shard,snapshot,failed,exception,shard,id,duplicate,snapshot,name,snapshot,id,get,name,detected,aborting,final,list,blob,store,index,shard,snapshot,file,info,index,commit,point,files,new,array,list,store,inc,ref,int,index,incremental,file,count,0,int,index,total,number,of,files,0,long,index,incremental,size,0,long,index,total,file,count,0,try,array,list,blob,store,index,shard,snapshot,file,info,files,to,snapshot,new,array,list,final,store,metadata,snapshot,metadata,final,collection,string,file,names,try,logger,trace,loading,store,metadata,using,index,commit,shard,id,snapshot,id,snapshot,index,commit,metadata,store,get,metadata,snapshot,index,commit,file,names,snapshot,index,commit,get,file,names,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,get,store,file,metadata,e,for,string,file,name,file,names,if,snapshot,status,is,aborted,logger,debug,aborted,on,the,file,exiting,shard,id,snapshot,id,file,name,throw,new,index,shard,snapshot,failed,exception,shard,id,aborted,logger,trace,processing,shard,id,snapshot,id,file,name,final,store,file,meta,data,md,metadata,get,file,name,blob,store,index,shard,snapshot,file,info,existing,file,info,null,list,blob,store,index,shard,snapshot,file,info,files,info,snapshots,find,physical,index,files,file,name,if,files,info,null,for,blob,store,index,shard,snapshot,file,info,file,info,files,info,try,maybe,recalculate,metadata,hash,blob,container,file,info,metadata,catch,exception,e,logger,warn,new,parameterized,message,can,t,calculate,hash,from,blob,for,file,shard,id,file,info,physical,name,file,info,metadata,e,if,file,info,is,same,md,snapshot,file,exists,in,blobs,file,info,blobs,existing,file,info,file,info,break,index,total,file,count,md,length,index,total,number,of,files,if,existing,file,info,null,index,incremental,file,count,index,incremental,size,md,length,blob,store,index,shard,snapshot,file,info,snapshot,file,info,new,blob,store,index,shard,snapshot,file,info,file,name,from,generation,generation,md,chunk,size,index,commit,point,files,add,snapshot,file,info,files,to,snapshot,add,snapshot,file,info,else,index,commit,point,files,add,existing,file,info,snapshot,status,move,to,started,start,time,index,incremental,file,count,index,total,number,of,files,index,incremental,size,index,total,file,count,for,blob,store,index,shard,snapshot,file,info,snapshot,file,info,files,to,snapshot,try,snapshot,file,snapshot,file,info,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,perform,snapshot,index,files,e,finally,store,dec,ref,final,index,shard,snapshot,status,copy,last,snapshot,status,snapshot,status,move,to,finalize,snapshot,index,commit,get,generation,final,blob,store,index,shard,snapshot,snapshot,new,blob,store,index,shard,snapshot,snapshot,id,get,name,last,snapshot,status,get,index,version,index,commit,point,files,last,snapshot,status,get,start,time,system,current,time,millis,last,snapshot,status,get,start,time,last,snapshot,status,get,incremental,file,count,last,snapshot,status,get,incremental,size,logger,trace,writing,shard,snapshot,file,shard,id,snapshot,id,try,index,shard,snapshot,format,write,snapshot,blob,container,snapshot,id,get,uuid,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,write,commit,point,e,list,snapshot,files,new,snapshots,list,new,array,list,new,snapshots,list,add,new,snapshot,files,snapshot,snapshot,snapshot,index,files,for,snapshot,files,point,snapshots,new,snapshots,list,add,point,finalize,new,snapshots,list,file,list,generation,1,blobs,snapshot,creation,snapshot,id,snapshot,status,move,to,done,system,current,time,millis
BlobStoreRepository -> SnapshotContext -> public void snapshot(final IndexCommit snapshotIndexCommit);1546974294;Create snapshot from index commit point__@param snapshotIndexCommit snapshot commit point;public void snapshot(final IndexCommit snapshotIndexCommit) {_            logger.debug("[{}] [{}] snapshot to [{}] ...", shardId, snapshotId, metadata.name())___            final Map<String, BlobMetaData> blobs__            try {_                blobs = blobContainer.listBlobs()__            } catch (IOException e) {_                throw new IndexShardSnapshotFailedException(shardId, "failed to list blobs", e)__            }__            long generation = findLatestFileNameGeneration(blobs)__            Tuple<BlobStoreIndexShardSnapshots, Integer> tuple = buildBlobStoreIndexShardSnapshots(blobs)__            BlobStoreIndexShardSnapshots snapshots = tuple.v1()__            int fileListGeneration = tuple.v2()___            if (snapshots.snapshots().stream().anyMatch(sf -> sf.snapshot().equals(snapshotId.getName()))) {_                throw new IndexShardSnapshotFailedException(shardId,_                    "Duplicate snapshot name [" + snapshotId.getName() + "] detected, aborting")__            }__            final List<BlobStoreIndexShardSnapshot.FileInfo> indexCommitPointFiles = new ArrayList<>()___            store.incRef()__            int indexIncrementalFileCount = 0__            int indexTotalNumberOfFiles = 0__            long indexIncrementalSize = 0__            long indexTotalFileCount = 0__            try {_                ArrayList<BlobStoreIndexShardSnapshot.FileInfo> filesToSnapshot = new ArrayList<>()__                final Store.MetadataSnapshot metadata__                _                final Collection<String> fileNames__                try {_                    logger.trace("[{}] [{}] Loading store metadata using index commit [{}]", shardId, snapshotId, snapshotIndexCommit)__                    metadata = store.getMetadata(snapshotIndexCommit)__                    fileNames = snapshotIndexCommit.getFileNames()__                } catch (IOException e) {_                    throw new IndexShardSnapshotFailedException(shardId, "Failed to get store file metadata", e)__                }_                for (String fileName : fileNames) {_                    if (snapshotStatus.isAborted()) {_                        logger.debug("[{}] [{}] Aborted on the file [{}], exiting", shardId, snapshotId, fileName)__                        throw new IndexShardSnapshotFailedException(shardId, "Aborted")__                    }__                    logger.trace("[{}] [{}] Processing [{}]", shardId, snapshotId, fileName)__                    final StoreFileMetaData md = metadata.get(fileName)__                    BlobStoreIndexShardSnapshot.FileInfo existingFileInfo = null__                    List<BlobStoreIndexShardSnapshot.FileInfo> filesInfo = snapshots.findPhysicalIndexFiles(fileName)__                    if (filesInfo != null) {_                        for (BlobStoreIndexShardSnapshot.FileInfo fileInfo : filesInfo) {_                            try {_                                _                                _                                _                                _                                maybeRecalculateMetadataHash(blobContainer, fileInfo, metadata)__                            } catch (Exception e) {_                                logger.warn(() -> new ParameterizedMessage("{} Can't calculate hash from blob for file [{}] [{}]",_                                    shardId, fileInfo.physicalName(), fileInfo.metadata()), e)__                            }_                            if (fileInfo.isSame(md) && snapshotFileExistsInBlobs(fileInfo, blobs)) {_                                _                                _                                existingFileInfo = fileInfo__                                break__                            }_                        }_                    }__                    indexTotalFileCount += md.length()__                    indexTotalNumberOfFiles++___                    if (existingFileInfo == null) {_                        indexIncrementalFileCount++__                        indexIncrementalSize += md.length()__                        _                        BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo =_                            new BlobStoreIndexShardSnapshot.FileInfo(fileNameFromGeneration(++generation), md, chunkSize())__                        indexCommitPointFiles.add(snapshotFileInfo)__                        filesToSnapshot.add(snapshotFileInfo)__                    } else {_                        indexCommitPointFiles.add(existingFileInfo)__                    }_                }__                snapshotStatus.moveToStarted(startTime, indexIncrementalFileCount,_                    indexTotalNumberOfFiles, indexIncrementalSize, indexTotalFileCount)___                for (BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo : filesToSnapshot) {_                    try {_                        snapshotFile(snapshotFileInfo)__                    } catch (IOException e) {_                        throw new IndexShardSnapshotFailedException(shardId, "Failed to perform snapshot (index files)", e)__                    }_                }_            } finally {_                store.decRef()__            }__            final IndexShardSnapshotStatus.Copy lastSnapshotStatus = snapshotStatus.moveToFinalize(snapshotIndexCommit.getGeneration())___            _            final BlobStoreIndexShardSnapshot snapshot = new BlobStoreIndexShardSnapshot(snapshotId.getName(),_                                                                        lastSnapshotStatus.getIndexVersion(),_                                                                        indexCommitPointFiles,_                                                                        lastSnapshotStatus.getStartTime(),_                                                                        _                                                                        _                                                                        System.currentTimeMillis() - lastSnapshotStatus.getStartTime(),_                                                                        lastSnapshotStatus.getIncrementalFileCount(),_                                                                        lastSnapshotStatus.getIncrementalSize()_            )___            _            logger.trace("[{}] [{}] writing shard snapshot file", shardId, snapshotId)__            try {_                indexShardSnapshotFormat.write(snapshot, blobContainer, snapshotId.getUUID())__            } catch (IOException e) {_                throw new IndexShardSnapshotFailedException(shardId, "Failed to write commit point", e)__            }__            _            _            List<SnapshotFiles> newSnapshotsList = new ArrayList<>()__            newSnapshotsList.add(new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles()))__            for (SnapshotFiles point : snapshots) {_                newSnapshotsList.add(point)__            }_            _            finalize(newSnapshotsList, fileListGeneration + 1, blobs, "snapshot creation [" + snapshotId + "]")__            snapshotStatus.moveToDone(System.currentTimeMillis())__        };create,snapshot,from,index,commit,point,param,snapshot,index,commit,snapshot,commit,point;public,void,snapshot,final,index,commit,snapshot,index,commit,logger,debug,snapshot,to,shard,id,snapshot,id,metadata,name,final,map,string,blob,meta,data,blobs,try,blobs,blob,container,list,blobs,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,list,blobs,e,long,generation,find,latest,file,name,generation,blobs,tuple,blob,store,index,shard,snapshots,integer,tuple,build,blob,store,index,shard,snapshots,blobs,blob,store,index,shard,snapshots,snapshots,tuple,v1,int,file,list,generation,tuple,v2,if,snapshots,snapshots,stream,any,match,sf,sf,snapshot,equals,snapshot,id,get,name,throw,new,index,shard,snapshot,failed,exception,shard,id,duplicate,snapshot,name,snapshot,id,get,name,detected,aborting,final,list,blob,store,index,shard,snapshot,file,info,index,commit,point,files,new,array,list,store,inc,ref,int,index,incremental,file,count,0,int,index,total,number,of,files,0,long,index,incremental,size,0,long,index,total,file,count,0,try,array,list,blob,store,index,shard,snapshot,file,info,files,to,snapshot,new,array,list,final,store,metadata,snapshot,metadata,final,collection,string,file,names,try,logger,trace,loading,store,metadata,using,index,commit,shard,id,snapshot,id,snapshot,index,commit,metadata,store,get,metadata,snapshot,index,commit,file,names,snapshot,index,commit,get,file,names,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,get,store,file,metadata,e,for,string,file,name,file,names,if,snapshot,status,is,aborted,logger,debug,aborted,on,the,file,exiting,shard,id,snapshot,id,file,name,throw,new,index,shard,snapshot,failed,exception,shard,id,aborted,logger,trace,processing,shard,id,snapshot,id,file,name,final,store,file,meta,data,md,metadata,get,file,name,blob,store,index,shard,snapshot,file,info,existing,file,info,null,list,blob,store,index,shard,snapshot,file,info,files,info,snapshots,find,physical,index,files,file,name,if,files,info,null,for,blob,store,index,shard,snapshot,file,info,file,info,files,info,try,maybe,recalculate,metadata,hash,blob,container,file,info,metadata,catch,exception,e,logger,warn,new,parameterized,message,can,t,calculate,hash,from,blob,for,file,shard,id,file,info,physical,name,file,info,metadata,e,if,file,info,is,same,md,snapshot,file,exists,in,blobs,file,info,blobs,existing,file,info,file,info,break,index,total,file,count,md,length,index,total,number,of,files,if,existing,file,info,null,index,incremental,file,count,index,incremental,size,md,length,blob,store,index,shard,snapshot,file,info,snapshot,file,info,new,blob,store,index,shard,snapshot,file,info,file,name,from,generation,generation,md,chunk,size,index,commit,point,files,add,snapshot,file,info,files,to,snapshot,add,snapshot,file,info,else,index,commit,point,files,add,existing,file,info,snapshot,status,move,to,started,start,time,index,incremental,file,count,index,total,number,of,files,index,incremental,size,index,total,file,count,for,blob,store,index,shard,snapshot,file,info,snapshot,file,info,files,to,snapshot,try,snapshot,file,snapshot,file,info,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,perform,snapshot,index,files,e,finally,store,dec,ref,final,index,shard,snapshot,status,copy,last,snapshot,status,snapshot,status,move,to,finalize,snapshot,index,commit,get,generation,final,blob,store,index,shard,snapshot,snapshot,new,blob,store,index,shard,snapshot,snapshot,id,get,name,last,snapshot,status,get,index,version,index,commit,point,files,last,snapshot,status,get,start,time,system,current,time,millis,last,snapshot,status,get,start,time,last,snapshot,status,get,incremental,file,count,last,snapshot,status,get,incremental,size,logger,trace,writing,shard,snapshot,file,shard,id,snapshot,id,try,index,shard,snapshot,format,write,snapshot,blob,container,snapshot,id,get,uuid,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,write,commit,point,e,list,snapshot,files,new,snapshots,list,new,array,list,new,snapshots,list,add,new,snapshot,files,snapshot,snapshot,snapshot,index,files,for,snapshot,files,point,snapshots,new,snapshots,list,add,point,finalize,new,snapshots,list,file,list,generation,1,blobs,snapshot,creation,snapshot,id,snapshot,status,move,to,done,system,current,time,millis
BlobStoreRepository -> SnapshotContext -> public void snapshot(final IndexCommit snapshotIndexCommit);1547496475;Create snapshot from index commit point__@param snapshotIndexCommit snapshot commit point;public void snapshot(final IndexCommit snapshotIndexCommit) {_            logger.debug("[{}] [{}] snapshot to [{}] ...", shardId, snapshotId, metadata.name())___            final Map<String, BlobMetaData> blobs__            try {_                blobs = blobContainer.listBlobs()__            } catch (IOException e) {_                throw new IndexShardSnapshotFailedException(shardId, "failed to list blobs", e)__            }__            long generation = findLatestFileNameGeneration(blobs)__            Tuple<BlobStoreIndexShardSnapshots, Integer> tuple = buildBlobStoreIndexShardSnapshots(blobs)__            BlobStoreIndexShardSnapshots snapshots = tuple.v1()__            int fileListGeneration = tuple.v2()___            if (snapshots.snapshots().stream().anyMatch(sf -> sf.snapshot().equals(snapshotId.getName()))) {_                throw new IndexShardSnapshotFailedException(shardId,_                    "Duplicate snapshot name [" + snapshotId.getName() + "] detected, aborting")__            }__            final List<BlobStoreIndexShardSnapshot.FileInfo> indexCommitPointFiles = new ArrayList<>()___            store.incRef()__            int indexIncrementalFileCount = 0__            int indexTotalNumberOfFiles = 0__            long indexIncrementalSize = 0__            long indexTotalFileCount = 0__            try {_                ArrayList<BlobStoreIndexShardSnapshot.FileInfo> filesToSnapshot = new ArrayList<>()__                final Store.MetadataSnapshot metadata__                _                final Collection<String> fileNames__                try {_                    logger.trace("[{}] [{}] Loading store metadata using index commit [{}]", shardId, snapshotId, snapshotIndexCommit)__                    metadata = store.getMetadata(snapshotIndexCommit)__                    fileNames = snapshotIndexCommit.getFileNames()__                } catch (IOException e) {_                    throw new IndexShardSnapshotFailedException(shardId, "Failed to get store file metadata", e)__                }_                for (String fileName : fileNames) {_                    if (snapshotStatus.isAborted()) {_                        logger.debug("[{}] [{}] Aborted on the file [{}], exiting", shardId, snapshotId, fileName)__                        throw new IndexShardSnapshotFailedException(shardId, "Aborted")__                    }__                    logger.trace("[{}] [{}] Processing [{}]", shardId, snapshotId, fileName)__                    final StoreFileMetaData md = metadata.get(fileName)__                    BlobStoreIndexShardSnapshot.FileInfo existingFileInfo = null__                    List<BlobStoreIndexShardSnapshot.FileInfo> filesInfo = snapshots.findPhysicalIndexFiles(fileName)__                    if (filesInfo != null) {_                        for (BlobStoreIndexShardSnapshot.FileInfo fileInfo : filesInfo) {_                            try {_                                _                                _                                _                                _                                maybeRecalculateMetadataHash(blobContainer, fileInfo, metadata)__                            } catch (Exception e) {_                                logger.warn(() -> new ParameterizedMessage("{} Can't calculate hash from blob for file [{}] [{}]",_                                    shardId, fileInfo.physicalName(), fileInfo.metadata()), e)__                            }_                            if (fileInfo.isSame(md) && snapshotFileExistsInBlobs(fileInfo, blobs)) {_                                _                                _                                existingFileInfo = fileInfo__                                break__                            }_                        }_                    }__                    indexTotalFileCount += md.length()__                    indexTotalNumberOfFiles++___                    if (existingFileInfo == null) {_                        indexIncrementalFileCount++__                        indexIncrementalSize += md.length()__                        _                        BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo =_                            new BlobStoreIndexShardSnapshot.FileInfo(fileNameFromGeneration(++generation), md, chunkSize())__                        indexCommitPointFiles.add(snapshotFileInfo)__                        filesToSnapshot.add(snapshotFileInfo)__                    } else {_                        indexCommitPointFiles.add(existingFileInfo)__                    }_                }__                snapshotStatus.moveToStarted(startTime, indexIncrementalFileCount,_                    indexTotalNumberOfFiles, indexIncrementalSize, indexTotalFileCount)___                for (BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo : filesToSnapshot) {_                    try {_                        snapshotFile(snapshotFileInfo)__                    } catch (IOException e) {_                        throw new IndexShardSnapshotFailedException(shardId, "Failed to perform snapshot (index files)", e)__                    }_                }_            } finally {_                store.decRef()__            }__            final IndexShardSnapshotStatus.Copy lastSnapshotStatus = snapshotStatus.moveToFinalize(snapshotIndexCommit.getGeneration())___            _            final BlobStoreIndexShardSnapshot snapshot = new BlobStoreIndexShardSnapshot(snapshotId.getName(),_                                                                        lastSnapshotStatus.getIndexVersion(),_                                                                        indexCommitPointFiles,_                                                                        lastSnapshotStatus.getStartTime(),_                                                                        _                                                                        _                                                                        System.currentTimeMillis() - lastSnapshotStatus.getStartTime(),_                                                                        lastSnapshotStatus.getIncrementalFileCount(),_                                                                        lastSnapshotStatus.getIncrementalSize()_            )___            _            logger.trace("[{}] [{}] writing shard snapshot file", shardId, snapshotId)__            try {_                indexShardSnapshotFormat.write(snapshot, blobContainer, snapshotId.getUUID())__            } catch (IOException e) {_                throw new IndexShardSnapshotFailedException(shardId, "Failed to write commit point", e)__            }__            _            _            List<SnapshotFiles> newSnapshotsList = new ArrayList<>()__            newSnapshotsList.add(new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles()))__            for (SnapshotFiles point : snapshots) {_                newSnapshotsList.add(point)__            }_            _            finalize(newSnapshotsList, fileListGeneration + 1, blobs, "snapshot creation [" + snapshotId + "]")__            snapshotStatus.moveToDone(System.currentTimeMillis())__        };create,snapshot,from,index,commit,point,param,snapshot,index,commit,snapshot,commit,point;public,void,snapshot,final,index,commit,snapshot,index,commit,logger,debug,snapshot,to,shard,id,snapshot,id,metadata,name,final,map,string,blob,meta,data,blobs,try,blobs,blob,container,list,blobs,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,list,blobs,e,long,generation,find,latest,file,name,generation,blobs,tuple,blob,store,index,shard,snapshots,integer,tuple,build,blob,store,index,shard,snapshots,blobs,blob,store,index,shard,snapshots,snapshots,tuple,v1,int,file,list,generation,tuple,v2,if,snapshots,snapshots,stream,any,match,sf,sf,snapshot,equals,snapshot,id,get,name,throw,new,index,shard,snapshot,failed,exception,shard,id,duplicate,snapshot,name,snapshot,id,get,name,detected,aborting,final,list,blob,store,index,shard,snapshot,file,info,index,commit,point,files,new,array,list,store,inc,ref,int,index,incremental,file,count,0,int,index,total,number,of,files,0,long,index,incremental,size,0,long,index,total,file,count,0,try,array,list,blob,store,index,shard,snapshot,file,info,files,to,snapshot,new,array,list,final,store,metadata,snapshot,metadata,final,collection,string,file,names,try,logger,trace,loading,store,metadata,using,index,commit,shard,id,snapshot,id,snapshot,index,commit,metadata,store,get,metadata,snapshot,index,commit,file,names,snapshot,index,commit,get,file,names,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,get,store,file,metadata,e,for,string,file,name,file,names,if,snapshot,status,is,aborted,logger,debug,aborted,on,the,file,exiting,shard,id,snapshot,id,file,name,throw,new,index,shard,snapshot,failed,exception,shard,id,aborted,logger,trace,processing,shard,id,snapshot,id,file,name,final,store,file,meta,data,md,metadata,get,file,name,blob,store,index,shard,snapshot,file,info,existing,file,info,null,list,blob,store,index,shard,snapshot,file,info,files,info,snapshots,find,physical,index,files,file,name,if,files,info,null,for,blob,store,index,shard,snapshot,file,info,file,info,files,info,try,maybe,recalculate,metadata,hash,blob,container,file,info,metadata,catch,exception,e,logger,warn,new,parameterized,message,can,t,calculate,hash,from,blob,for,file,shard,id,file,info,physical,name,file,info,metadata,e,if,file,info,is,same,md,snapshot,file,exists,in,blobs,file,info,blobs,existing,file,info,file,info,break,index,total,file,count,md,length,index,total,number,of,files,if,existing,file,info,null,index,incremental,file,count,index,incremental,size,md,length,blob,store,index,shard,snapshot,file,info,snapshot,file,info,new,blob,store,index,shard,snapshot,file,info,file,name,from,generation,generation,md,chunk,size,index,commit,point,files,add,snapshot,file,info,files,to,snapshot,add,snapshot,file,info,else,index,commit,point,files,add,existing,file,info,snapshot,status,move,to,started,start,time,index,incremental,file,count,index,total,number,of,files,index,incremental,size,index,total,file,count,for,blob,store,index,shard,snapshot,file,info,snapshot,file,info,files,to,snapshot,try,snapshot,file,snapshot,file,info,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,perform,snapshot,index,files,e,finally,store,dec,ref,final,index,shard,snapshot,status,copy,last,snapshot,status,snapshot,status,move,to,finalize,snapshot,index,commit,get,generation,final,blob,store,index,shard,snapshot,snapshot,new,blob,store,index,shard,snapshot,snapshot,id,get,name,last,snapshot,status,get,index,version,index,commit,point,files,last,snapshot,status,get,start,time,system,current,time,millis,last,snapshot,status,get,start,time,last,snapshot,status,get,incremental,file,count,last,snapshot,status,get,incremental,size,logger,trace,writing,shard,snapshot,file,shard,id,snapshot,id,try,index,shard,snapshot,format,write,snapshot,blob,container,snapshot,id,get,uuid,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,write,commit,point,e,list,snapshot,files,new,snapshots,list,new,array,list,new,snapshots,list,add,new,snapshot,files,snapshot,snapshot,snapshot,index,files,for,snapshot,files,point,snapshots,new,snapshots,list,add,point,finalize,new,snapshots,list,file,list,generation,1,blobs,snapshot,creation,snapshot,id,snapshot,status,move,to,done,system,current,time,millis
BlobStoreRepository -> SnapshotContext -> public void snapshot(final IndexCommit snapshotIndexCommit);1547625930;Create snapshot from index commit point__@param snapshotIndexCommit snapshot commit point;public void snapshot(final IndexCommit snapshotIndexCommit) {_            logger.debug("[{}] [{}] snapshot to [{}] ...", shardId, snapshotId, metadata.name())___            final Map<String, BlobMetaData> blobs__            try {_                blobs = blobContainer.listBlobs()__            } catch (IOException e) {_                throw new IndexShardSnapshotFailedException(shardId, "failed to list blobs", e)__            }__            long generation = findLatestFileNameGeneration(blobs)__            Tuple<BlobStoreIndexShardSnapshots, Integer> tuple = buildBlobStoreIndexShardSnapshots(blobs)__            BlobStoreIndexShardSnapshots snapshots = tuple.v1()__            int fileListGeneration = tuple.v2()___            if (snapshots.snapshots().stream().anyMatch(sf -> sf.snapshot().equals(snapshotId.getName()))) {_                throw new IndexShardSnapshotFailedException(shardId,_                    "Duplicate snapshot name [" + snapshotId.getName() + "] detected, aborting")__            }__            final List<BlobStoreIndexShardSnapshot.FileInfo> indexCommitPointFiles = new ArrayList<>()___            store.incRef()__            int indexIncrementalFileCount = 0__            int indexTotalNumberOfFiles = 0__            long indexIncrementalSize = 0__            long indexTotalFileCount = 0__            try {_                ArrayList<BlobStoreIndexShardSnapshot.FileInfo> filesToSnapshot = new ArrayList<>()__                final Store.MetadataSnapshot metadata__                _                final Collection<String> fileNames__                try {_                    logger.trace("[{}] [{}] Loading store metadata using index commit [{}]", shardId, snapshotId, snapshotIndexCommit)__                    metadata = store.getMetadata(snapshotIndexCommit)__                    fileNames = snapshotIndexCommit.getFileNames()__                } catch (IOException e) {_                    throw new IndexShardSnapshotFailedException(shardId, "Failed to get store file metadata", e)__                }_                for (String fileName : fileNames) {_                    if (snapshotStatus.isAborted()) {_                        logger.debug("[{}] [{}] Aborted on the file [{}], exiting", shardId, snapshotId, fileName)__                        throw new IndexShardSnapshotFailedException(shardId, "Aborted")__                    }__                    logger.trace("[{}] [{}] Processing [{}]", shardId, snapshotId, fileName)__                    final StoreFileMetaData md = metadata.get(fileName)__                    BlobStoreIndexShardSnapshot.FileInfo existingFileInfo = null__                    List<BlobStoreIndexShardSnapshot.FileInfo> filesInfo = snapshots.findPhysicalIndexFiles(fileName)__                    if (filesInfo != null) {_                        for (BlobStoreIndexShardSnapshot.FileInfo fileInfo : filesInfo) {_                            try {_                                _                                _                                _                                _                                maybeRecalculateMetadataHash(blobContainer, fileInfo, metadata)__                            } catch (Exception e) {_                                logger.warn(() -> new ParameterizedMessage("{} Can't calculate hash from blob for file [{}] [{}]",_                                    shardId, fileInfo.physicalName(), fileInfo.metadata()), e)__                            }_                            if (fileInfo.isSame(md) && snapshotFileExistsInBlobs(fileInfo, blobs)) {_                                _                                _                                existingFileInfo = fileInfo__                                break__                            }_                        }_                    }__                    indexTotalFileCount += md.length()__                    indexTotalNumberOfFiles++___                    if (existingFileInfo == null) {_                        indexIncrementalFileCount++__                        indexIncrementalSize += md.length()__                        _                        BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo =_                            new BlobStoreIndexShardSnapshot.FileInfo(fileNameFromGeneration(++generation), md, chunkSize())__                        indexCommitPointFiles.add(snapshotFileInfo)__                        filesToSnapshot.add(snapshotFileInfo)__                    } else {_                        indexCommitPointFiles.add(existingFileInfo)__                    }_                }__                snapshotStatus.moveToStarted(startTime, indexIncrementalFileCount,_                    indexTotalNumberOfFiles, indexIncrementalSize, indexTotalFileCount)___                for (BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo : filesToSnapshot) {_                    try {_                        snapshotFile(snapshotFileInfo)__                    } catch (IOException e) {_                        throw new IndexShardSnapshotFailedException(shardId, "Failed to perform snapshot (index files)", e)__                    }_                }_            } finally {_                store.decRef()__            }__            final IndexShardSnapshotStatus.Copy lastSnapshotStatus = snapshotStatus.moveToFinalize(snapshotIndexCommit.getGeneration())___            _            final BlobStoreIndexShardSnapshot snapshot = new BlobStoreIndexShardSnapshot(snapshotId.getName(),_                                                                        lastSnapshotStatus.getIndexVersion(),_                                                                        indexCommitPointFiles,_                                                                        lastSnapshotStatus.getStartTime(),_                                                                        _                                                                        _                                                                        System.currentTimeMillis() - lastSnapshotStatus.getStartTime(),_                                                                        lastSnapshotStatus.getIncrementalFileCount(),_                                                                        lastSnapshotStatus.getIncrementalSize()_            )___            _            logger.trace("[{}] [{}] writing shard snapshot file", shardId, snapshotId)__            try {_                indexShardSnapshotFormat.write(snapshot, blobContainer, snapshotId.getUUID())__            } catch (IOException e) {_                throw new IndexShardSnapshotFailedException(shardId, "Failed to write commit point", e)__            }__            _            _            List<SnapshotFiles> newSnapshotsList = new ArrayList<>()__            newSnapshotsList.add(new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles()))__            for (SnapshotFiles point : snapshots) {_                newSnapshotsList.add(point)__            }_            _            finalize(newSnapshotsList, fileListGeneration + 1, blobs, "snapshot creation [" + snapshotId + "]")__            snapshotStatus.moveToDone(System.currentTimeMillis())__        };create,snapshot,from,index,commit,point,param,snapshot,index,commit,snapshot,commit,point;public,void,snapshot,final,index,commit,snapshot,index,commit,logger,debug,snapshot,to,shard,id,snapshot,id,metadata,name,final,map,string,blob,meta,data,blobs,try,blobs,blob,container,list,blobs,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,list,blobs,e,long,generation,find,latest,file,name,generation,blobs,tuple,blob,store,index,shard,snapshots,integer,tuple,build,blob,store,index,shard,snapshots,blobs,blob,store,index,shard,snapshots,snapshots,tuple,v1,int,file,list,generation,tuple,v2,if,snapshots,snapshots,stream,any,match,sf,sf,snapshot,equals,snapshot,id,get,name,throw,new,index,shard,snapshot,failed,exception,shard,id,duplicate,snapshot,name,snapshot,id,get,name,detected,aborting,final,list,blob,store,index,shard,snapshot,file,info,index,commit,point,files,new,array,list,store,inc,ref,int,index,incremental,file,count,0,int,index,total,number,of,files,0,long,index,incremental,size,0,long,index,total,file,count,0,try,array,list,blob,store,index,shard,snapshot,file,info,files,to,snapshot,new,array,list,final,store,metadata,snapshot,metadata,final,collection,string,file,names,try,logger,trace,loading,store,metadata,using,index,commit,shard,id,snapshot,id,snapshot,index,commit,metadata,store,get,metadata,snapshot,index,commit,file,names,snapshot,index,commit,get,file,names,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,get,store,file,metadata,e,for,string,file,name,file,names,if,snapshot,status,is,aborted,logger,debug,aborted,on,the,file,exiting,shard,id,snapshot,id,file,name,throw,new,index,shard,snapshot,failed,exception,shard,id,aborted,logger,trace,processing,shard,id,snapshot,id,file,name,final,store,file,meta,data,md,metadata,get,file,name,blob,store,index,shard,snapshot,file,info,existing,file,info,null,list,blob,store,index,shard,snapshot,file,info,files,info,snapshots,find,physical,index,files,file,name,if,files,info,null,for,blob,store,index,shard,snapshot,file,info,file,info,files,info,try,maybe,recalculate,metadata,hash,blob,container,file,info,metadata,catch,exception,e,logger,warn,new,parameterized,message,can,t,calculate,hash,from,blob,for,file,shard,id,file,info,physical,name,file,info,metadata,e,if,file,info,is,same,md,snapshot,file,exists,in,blobs,file,info,blobs,existing,file,info,file,info,break,index,total,file,count,md,length,index,total,number,of,files,if,existing,file,info,null,index,incremental,file,count,index,incremental,size,md,length,blob,store,index,shard,snapshot,file,info,snapshot,file,info,new,blob,store,index,shard,snapshot,file,info,file,name,from,generation,generation,md,chunk,size,index,commit,point,files,add,snapshot,file,info,files,to,snapshot,add,snapshot,file,info,else,index,commit,point,files,add,existing,file,info,snapshot,status,move,to,started,start,time,index,incremental,file,count,index,total,number,of,files,index,incremental,size,index,total,file,count,for,blob,store,index,shard,snapshot,file,info,snapshot,file,info,files,to,snapshot,try,snapshot,file,snapshot,file,info,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,perform,snapshot,index,files,e,finally,store,dec,ref,final,index,shard,snapshot,status,copy,last,snapshot,status,snapshot,status,move,to,finalize,snapshot,index,commit,get,generation,final,blob,store,index,shard,snapshot,snapshot,new,blob,store,index,shard,snapshot,snapshot,id,get,name,last,snapshot,status,get,index,version,index,commit,point,files,last,snapshot,status,get,start,time,system,current,time,millis,last,snapshot,status,get,start,time,last,snapshot,status,get,incremental,file,count,last,snapshot,status,get,incremental,size,logger,trace,writing,shard,snapshot,file,shard,id,snapshot,id,try,index,shard,snapshot,format,write,snapshot,blob,container,snapshot,id,get,uuid,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,write,commit,point,e,list,snapshot,files,new,snapshots,list,new,array,list,new,snapshots,list,add,new,snapshot,files,snapshot,snapshot,snapshot,index,files,for,snapshot,files,point,snapshots,new,snapshots,list,add,point,finalize,new,snapshots,list,file,list,generation,1,blobs,snapshot,creation,snapshot,id,snapshot,status,move,to,done,system,current,time,millis
BlobStoreRepository -> SnapshotContext -> public void snapshot(final IndexCommit snapshotIndexCommit);1550647627;Create snapshot from index commit point__@param snapshotIndexCommit snapshot commit point;public void snapshot(final IndexCommit snapshotIndexCommit) {_            logger.debug("[{}] [{}] snapshot to [{}] ...", shardId, snapshotId, metadata.name())___            final Map<String, BlobMetaData> blobs__            try {_                blobs = blobContainer.listBlobs()__            } catch (IOException e) {_                throw new IndexShardSnapshotFailedException(shardId, "failed to list blobs", e)__            }__            long generation = findLatestFileNameGeneration(blobs)__            Tuple<BlobStoreIndexShardSnapshots, Integer> tuple = buildBlobStoreIndexShardSnapshots(blobs)__            BlobStoreIndexShardSnapshots snapshots = tuple.v1()__            int fileListGeneration = tuple.v2()___            if (snapshots.snapshots().stream().anyMatch(sf -> sf.snapshot().equals(snapshotId.getName()))) {_                throw new IndexShardSnapshotFailedException(shardId,_                    "Duplicate snapshot name [" + snapshotId.getName() + "] detected, aborting")__            }__            final List<BlobStoreIndexShardSnapshot.FileInfo> indexCommitPointFiles = new ArrayList<>()___            store.incRef()__            int indexIncrementalFileCount = 0__            int indexTotalNumberOfFiles = 0__            long indexIncrementalSize = 0__            long indexTotalFileCount = 0__            try {_                ArrayList<BlobStoreIndexShardSnapshot.FileInfo> filesToSnapshot = new ArrayList<>()__                final Store.MetadataSnapshot metadata__                _                final Collection<String> fileNames__                try {_                    logger.trace("[{}] [{}] Loading store metadata using index commit [{}]", shardId, snapshotId, snapshotIndexCommit)__                    metadata = store.getMetadata(snapshotIndexCommit)__                    fileNames = snapshotIndexCommit.getFileNames()__                } catch (IOException e) {_                    throw new IndexShardSnapshotFailedException(shardId, "Failed to get store file metadata", e)__                }_                for (String fileName : fileNames) {_                    if (snapshotStatus.isAborted()) {_                        logger.debug("[{}] [{}] Aborted on the file [{}], exiting", shardId, snapshotId, fileName)__                        throw new IndexShardSnapshotFailedException(shardId, "Aborted")__                    }__                    logger.trace("[{}] [{}] Processing [{}]", shardId, snapshotId, fileName)__                    final StoreFileMetaData md = metadata.get(fileName)__                    BlobStoreIndexShardSnapshot.FileInfo existingFileInfo = null__                    List<BlobStoreIndexShardSnapshot.FileInfo> filesInfo = snapshots.findPhysicalIndexFiles(fileName)__                    if (filesInfo != null) {_                        for (BlobStoreIndexShardSnapshot.FileInfo fileInfo : filesInfo) {_                            try {_                                _                                _                                _                                _                                maybeRecalculateMetadataHash(blobContainer, fileInfo, metadata)__                            } catch (Exception e) {_                                logger.warn(() -> new ParameterizedMessage("{} Can't calculate hash from blob for file [{}] [{}]",_                                    shardId, fileInfo.physicalName(), fileInfo.metadata()), e)__                            }_                            if (fileInfo.isSame(md) && snapshotFileExistsInBlobs(fileInfo, blobs)) {_                                _                                _                                existingFileInfo = fileInfo__                                break__                            }_                        }_                    }__                    indexTotalFileCount += md.length()__                    indexTotalNumberOfFiles++___                    if (existingFileInfo == null) {_                        indexIncrementalFileCount++__                        indexIncrementalSize += md.length()__                        _                        BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo =_                            new BlobStoreIndexShardSnapshot.FileInfo(fileNameFromGeneration(++generation), md, chunkSize())__                        indexCommitPointFiles.add(snapshotFileInfo)__                        filesToSnapshot.add(snapshotFileInfo)__                    } else {_                        indexCommitPointFiles.add(existingFileInfo)__                    }_                }__                snapshotStatus.moveToStarted(startTime, indexIncrementalFileCount,_                    indexTotalNumberOfFiles, indexIncrementalSize, indexTotalFileCount)___                for (BlobStoreIndexShardSnapshot.FileInfo snapshotFileInfo : filesToSnapshot) {_                    try {_                        snapshotFile(snapshotFileInfo)__                    } catch (IOException e) {_                        throw new IndexShardSnapshotFailedException(shardId, "Failed to perform snapshot (index files)", e)__                    }_                }_            } finally {_                store.decRef()__            }__            final IndexShardSnapshotStatus.Copy lastSnapshotStatus = snapshotStatus.moveToFinalize(snapshotIndexCommit.getGeneration())___            _            final BlobStoreIndexShardSnapshot snapshot = new BlobStoreIndexShardSnapshot(snapshotId.getName(),_                                                                        lastSnapshotStatus.getIndexVersion(),_                                                                        indexCommitPointFiles,_                                                                        lastSnapshotStatus.getStartTime(),_                                                                        _                                                                        _                                                                        System.currentTimeMillis() - lastSnapshotStatus.getStartTime(),_                                                                        lastSnapshotStatus.getIncrementalFileCount(),_                                                                        lastSnapshotStatus.getIncrementalSize()_            )___            _            logger.trace("[{}] [{}] writing shard snapshot file", shardId, snapshotId)__            try {_                indexShardSnapshotFormat.write(snapshot, blobContainer, snapshotId.getUUID())__            } catch (IOException e) {_                throw new IndexShardSnapshotFailedException(shardId, "Failed to write commit point", e)__            }__            _            _            List<SnapshotFiles> newSnapshotsList = new ArrayList<>()__            newSnapshotsList.add(new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles()))__            for (SnapshotFiles point : snapshots) {_                newSnapshotsList.add(point)__            }_            _            finalize(newSnapshotsList, fileListGeneration + 1, blobs, "snapshot creation [" + snapshotId + "]")__            snapshotStatus.moveToDone(System.currentTimeMillis())__        };create,snapshot,from,index,commit,point,param,snapshot,index,commit,snapshot,commit,point;public,void,snapshot,final,index,commit,snapshot,index,commit,logger,debug,snapshot,to,shard,id,snapshot,id,metadata,name,final,map,string,blob,meta,data,blobs,try,blobs,blob,container,list,blobs,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,list,blobs,e,long,generation,find,latest,file,name,generation,blobs,tuple,blob,store,index,shard,snapshots,integer,tuple,build,blob,store,index,shard,snapshots,blobs,blob,store,index,shard,snapshots,snapshots,tuple,v1,int,file,list,generation,tuple,v2,if,snapshots,snapshots,stream,any,match,sf,sf,snapshot,equals,snapshot,id,get,name,throw,new,index,shard,snapshot,failed,exception,shard,id,duplicate,snapshot,name,snapshot,id,get,name,detected,aborting,final,list,blob,store,index,shard,snapshot,file,info,index,commit,point,files,new,array,list,store,inc,ref,int,index,incremental,file,count,0,int,index,total,number,of,files,0,long,index,incremental,size,0,long,index,total,file,count,0,try,array,list,blob,store,index,shard,snapshot,file,info,files,to,snapshot,new,array,list,final,store,metadata,snapshot,metadata,final,collection,string,file,names,try,logger,trace,loading,store,metadata,using,index,commit,shard,id,snapshot,id,snapshot,index,commit,metadata,store,get,metadata,snapshot,index,commit,file,names,snapshot,index,commit,get,file,names,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,get,store,file,metadata,e,for,string,file,name,file,names,if,snapshot,status,is,aborted,logger,debug,aborted,on,the,file,exiting,shard,id,snapshot,id,file,name,throw,new,index,shard,snapshot,failed,exception,shard,id,aborted,logger,trace,processing,shard,id,snapshot,id,file,name,final,store,file,meta,data,md,metadata,get,file,name,blob,store,index,shard,snapshot,file,info,existing,file,info,null,list,blob,store,index,shard,snapshot,file,info,files,info,snapshots,find,physical,index,files,file,name,if,files,info,null,for,blob,store,index,shard,snapshot,file,info,file,info,files,info,try,maybe,recalculate,metadata,hash,blob,container,file,info,metadata,catch,exception,e,logger,warn,new,parameterized,message,can,t,calculate,hash,from,blob,for,file,shard,id,file,info,physical,name,file,info,metadata,e,if,file,info,is,same,md,snapshot,file,exists,in,blobs,file,info,blobs,existing,file,info,file,info,break,index,total,file,count,md,length,index,total,number,of,files,if,existing,file,info,null,index,incremental,file,count,index,incremental,size,md,length,blob,store,index,shard,snapshot,file,info,snapshot,file,info,new,blob,store,index,shard,snapshot,file,info,file,name,from,generation,generation,md,chunk,size,index,commit,point,files,add,snapshot,file,info,files,to,snapshot,add,snapshot,file,info,else,index,commit,point,files,add,existing,file,info,snapshot,status,move,to,started,start,time,index,incremental,file,count,index,total,number,of,files,index,incremental,size,index,total,file,count,for,blob,store,index,shard,snapshot,file,info,snapshot,file,info,files,to,snapshot,try,snapshot,file,snapshot,file,info,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,perform,snapshot,index,files,e,finally,store,dec,ref,final,index,shard,snapshot,status,copy,last,snapshot,status,snapshot,status,move,to,finalize,snapshot,index,commit,get,generation,final,blob,store,index,shard,snapshot,snapshot,new,blob,store,index,shard,snapshot,snapshot,id,get,name,last,snapshot,status,get,index,version,index,commit,point,files,last,snapshot,status,get,start,time,system,current,time,millis,last,snapshot,status,get,start,time,last,snapshot,status,get,incremental,file,count,last,snapshot,status,get,incremental,size,logger,trace,writing,shard,snapshot,file,shard,id,snapshot,id,try,index,shard,snapshot,format,write,snapshot,blob,container,snapshot,id,get,uuid,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,write,commit,point,e,list,snapshot,files,new,snapshots,list,new,array,list,new,snapshots,list,add,new,snapshot,files,snapshot,snapshot,snapshot,index,files,for,snapshot,files,point,snapshots,new,snapshots,list,add,point,finalize,new,snapshots,list,file,list,generation,1,blobs,snapshot,creation,snapshot,id,snapshot,status,move,to,done,system,current,time,millis
BlobStoreRepository -> protected ByteSizeValue chunkSize();1524684173;Returns data file chunk size._<p>_This method should return null if no chunking is needed.__@return chunk size;protected ByteSizeValue chunkSize() {_        return null__    };returns,data,file,chunk,size,p,this,method,should,return,null,if,no,chunking,is,needed,return,chunk,size;protected,byte,size,value,chunk,size,return,null
BlobStoreRepository -> protected ByteSizeValue chunkSize();1525334055;Returns data file chunk size._<p>_This method should return null if no chunking is needed.__@return chunk size;protected ByteSizeValue chunkSize() {_        return null__    };returns,data,file,chunk,size,p,this,method,should,return,null,if,no,chunking,is,needed,return,chunk,size;protected,byte,size,value,chunk,size,return,null
BlobStoreRepository -> protected ByteSizeValue chunkSize();1525798020;Returns data file chunk size._<p>_This method should return null if no chunking is needed.__@return chunk size;protected ByteSizeValue chunkSize() {_        return null__    };returns,data,file,chunk,size,p,this,method,should,return,null,if,no,chunking,is,needed,return,chunk,size;protected,byte,size,value,chunk,size,return,null
BlobStoreRepository -> protected ByteSizeValue chunkSize();1526289033;Returns data file chunk size._<p>_This method should return null if no chunking is needed.__@return chunk size;protected ByteSizeValue chunkSize() {_        return null__    };returns,data,file,chunk,size,p,this,method,should,return,null,if,no,chunking,is,needed,return,chunk,size;protected,byte,size,value,chunk,size,return,null
BlobStoreRepository -> protected ByteSizeValue chunkSize();1526574077;Returns data file chunk size._<p>_This method should return null if no chunking is needed.__@return chunk size;protected ByteSizeValue chunkSize() {_        return null__    };returns,data,file,chunk,size,p,this,method,should,return,null,if,no,chunking,is,needed,return,chunk,size;protected,byte,size,value,chunk,size,return,null
BlobStoreRepository -> protected ByteSizeValue chunkSize();1527583663;Returns data file chunk size._<p>_This method should return null if no chunking is needed.__@return chunk size;protected ByteSizeValue chunkSize() {_        return null__    };returns,data,file,chunk,size,p,this,method,should,return,null,if,no,chunking,is,needed,return,chunk,size;protected,byte,size,value,chunk,size,return,null
BlobStoreRepository -> protected ByteSizeValue chunkSize();1528211342;Returns data file chunk size._<p>_This method should return null if no chunking is needed.__@return chunk size;protected ByteSizeValue chunkSize() {_        return null__    };returns,data,file,chunk,size,p,this,method,should,return,null,if,no,chunking,is,needed,return,chunk,size;protected,byte,size,value,chunk,size,return,null
BlobStoreRepository -> protected ByteSizeValue chunkSize();1531179852;Returns data file chunk size._<p>_This method should return null if no chunking is needed.__@return chunk size;protected ByteSizeValue chunkSize() {_        return null__    };returns,data,file,chunk,size,p,this,method,should,return,null,if,no,chunking,is,needed,return,chunk,size;protected,byte,size,value,chunk,size,return,null
BlobStoreRepository -> protected ByteSizeValue chunkSize();1531729807;Returns data file chunk size._<p>_This method should return null if no chunking is needed.__@return chunk size;protected ByteSizeValue chunkSize() {_        return null__    };returns,data,file,chunk,size,p,this,method,should,return,null,if,no,chunking,is,needed,return,chunk,size;protected,byte,size,value,chunk,size,return,null
BlobStoreRepository -> protected ByteSizeValue chunkSize();1532685069;Returns data file chunk size._<p>_This method should return null if no chunking is needed.__@return chunk size;protected ByteSizeValue chunkSize() {_        return null__    };returns,data,file,chunk,size,p,this,method,should,return,null,if,no,chunking,is,needed,return,chunk,size;protected,byte,size,value,chunk,size,return,null
BlobStoreRepository -> protected ByteSizeValue chunkSize();1535139672;Returns data file chunk size._<p>_This method should return null if no chunking is needed.__@return chunk size;protected ByteSizeValue chunkSize() {_        return null__    };returns,data,file,chunk,size,p,this,method,should,return,null,if,no,chunking,is,needed,return,chunk,size;protected,byte,size,value,chunk,size,return,null
BlobStoreRepository -> protected ByteSizeValue chunkSize();1535723122;Returns data file chunk size._<p>_This method should return null if no chunking is needed.__@return chunk size;protected ByteSizeValue chunkSize() {_        return null__    };returns,data,file,chunk,size,p,this,method,should,return,null,if,no,chunking,is,needed,return,chunk,size;protected,byte,size,value,chunk,size,return,null
BlobStoreRepository -> protected ByteSizeValue chunkSize();1536314350;Returns data file chunk size._<p>_This method should return null if no chunking is needed.__@return chunk size;protected ByteSizeValue chunkSize() {_        return null__    };returns,data,file,chunk,size,p,this,method,should,return,null,if,no,chunking,is,needed,return,chunk,size;protected,byte,size,value,chunk,size,return,null
BlobStoreRepository -> protected ByteSizeValue chunkSize();1536828374;Returns data file chunk size._<p>_This method should return null if no chunking is needed.__@return chunk size;protected ByteSizeValue chunkSize() {_        return null__    };returns,data,file,chunk,size,p,this,method,should,return,null,if,no,chunking,is,needed,return,chunk,size;protected,byte,size,value,chunk,size,return,null
BlobStoreRepository -> protected ByteSizeValue chunkSize();1541008027;Returns data file chunk size._<p>_This method should return null if no chunking is needed.__@return chunk size;protected ByteSizeValue chunkSize() {_        return null__    };returns,data,file,chunk,size,p,this,method,should,return,null,if,no,chunking,is,needed,return,chunk,size;protected,byte,size,value,chunk,size,return,null
BlobStoreRepository -> protected ByteSizeValue chunkSize();1542646292;Returns data file chunk size._<p>_This method should return null if no chunking is needed.__@return chunk size;protected ByteSizeValue chunkSize() {_        return null__    };returns,data,file,chunk,size,p,this,method,should,return,null,if,no,chunking,is,needed,return,chunk,size;protected,byte,size,value,chunk,size,return,null
BlobStoreRepository -> protected ByteSizeValue chunkSize();1542980705;Returns data file chunk size._<p>_This method should return null if no chunking is needed.__@return chunk size;protected ByteSizeValue chunkSize() {_        return null__    };returns,data,file,chunk,size,p,this,method,should,return,null,if,no,chunking,is,needed,return,chunk,size;protected,byte,size,value,chunk,size,return,null
BlobStoreRepository -> protected ByteSizeValue chunkSize();1543831870;Returns data file chunk size._<p>_This method should return null if no chunking is needed.__@return chunk size;protected ByteSizeValue chunkSize() {_        return null__    };returns,data,file,chunk,size,p,this,method,should,return,null,if,no,chunking,is,needed,return,chunk,size;protected,byte,size,value,chunk,size,return,null
BlobStoreRepository -> protected ByteSizeValue chunkSize();1543942400;Returns data file chunk size._<p>_This method should return null if no chunking is needed.__@return chunk size;protected ByteSizeValue chunkSize() {_        return null__    };returns,data,file,chunk,size,p,this,method,should,return,null,if,no,chunking,is,needed,return,chunk,size;protected,byte,size,value,chunk,size,return,null
BlobStoreRepository -> protected ByteSizeValue chunkSize();1546974294;Returns data file chunk size._<p>_This method should return null if no chunking is needed.__@return chunk size;protected ByteSizeValue chunkSize() {_        return null__    };returns,data,file,chunk,size,p,this,method,should,return,null,if,no,chunking,is,needed,return,chunk,size;protected,byte,size,value,chunk,size,return,null
BlobStoreRepository -> protected ByteSizeValue chunkSize();1547496475;Returns data file chunk size._<p>_This method should return null if no chunking is needed.__@return chunk size;protected ByteSizeValue chunkSize() {_        return null__    };returns,data,file,chunk,size,p,this,method,should,return,null,if,no,chunking,is,needed,return,chunk,size;protected,byte,size,value,chunk,size,return,null
BlobStoreRepository -> protected ByteSizeValue chunkSize();1547625930;Returns data file chunk size._<p>_This method should return null if no chunking is needed.__@return chunk size;protected ByteSizeValue chunkSize() {_        return null__    };returns,data,file,chunk,size,p,this,method,should,return,null,if,no,chunking,is,needed,return,chunk,size;protected,byte,size,value,chunk,size,return,null
BlobStoreRepository -> protected ByteSizeValue chunkSize();1550647627;Returns data file chunk size._<p>_This method should return null if no chunking is needed.__@return chunk size;protected ByteSizeValue chunkSize() {_        return null__    };returns,data,file,chunk,size,p,this,method,should,return,null,if,no,chunking,is,needed,return,chunk,size;protected,byte,size,value,chunk,size,return,null
BlobStoreRepository -> protected BlobStore blobStore();1531729807;maintains single lazy instance of {@link BlobStore};protected BlobStore blobStore() {_        assertSnapshotOrGenericThread()___        BlobStore store = blobStore.get()__        if (store == null) {_            synchronized (lock) {_                store = blobStore.get()__                if (store == null) {_                    if (lifecycle.started() == false) {_                        throw new RepositoryException(metadata.name(), "repository is not in started state")__                    }_                    try {_                        store = createBlobStore()__                    } catch (RepositoryException e) {_                        throw e__                    } catch (Exception e) {_                        throw new RepositoryException(metadata.name(), "cannot create blob store" , e)__                    }_                    blobStore.set(store)__                }_            }_        }_        return store__    };maintains,single,lazy,instance,of,link,blob,store;protected,blob,store,blob,store,assert,snapshot,or,generic,thread,blob,store,store,blob,store,get,if,store,null,synchronized,lock,store,blob,store,get,if,store,null,if,lifecycle,started,false,throw,new,repository,exception,metadata,name,repository,is,not,in,started,state,try,store,create,blob,store,catch,repository,exception,e,throw,e,catch,exception,e,throw,new,repository,exception,metadata,name,cannot,create,blob,store,e,blob,store,set,store,return,store
BlobStoreRepository -> protected BlobStore blobStore();1532685069;maintains single lazy instance of {@link BlobStore};protected BlobStore blobStore() {_        assertSnapshotOrGenericThread()___        BlobStore store = blobStore.get()__        if (store == null) {_            synchronized (lock) {_                store = blobStore.get()__                if (store == null) {_                    if (lifecycle.started() == false) {_                        throw new RepositoryException(metadata.name(), "repository is not in started state")__                    }_                    try {_                        store = createBlobStore()__                    } catch (RepositoryException e) {_                        throw e__                    } catch (Exception e) {_                        throw new RepositoryException(metadata.name(), "cannot create blob store" , e)__                    }_                    blobStore.set(store)__                }_            }_        }_        return store__    };maintains,single,lazy,instance,of,link,blob,store;protected,blob,store,blob,store,assert,snapshot,or,generic,thread,blob,store,store,blob,store,get,if,store,null,synchronized,lock,store,blob,store,get,if,store,null,if,lifecycle,started,false,throw,new,repository,exception,metadata,name,repository,is,not,in,started,state,try,store,create,blob,store,catch,repository,exception,e,throw,e,catch,exception,e,throw,new,repository,exception,metadata,name,cannot,create,blob,store,e,blob,store,set,store,return,store
BlobStoreRepository -> protected BlobStore blobStore();1535139672;maintains single lazy instance of {@link BlobStore};protected BlobStore blobStore() {_        assertSnapshotOrGenericThread()___        BlobStore store = blobStore.get()__        if (store == null) {_            synchronized (lock) {_                store = blobStore.get()__                if (store == null) {_                    if (lifecycle.started() == false) {_                        throw new RepositoryException(metadata.name(), "repository is not in started state")__                    }_                    try {_                        store = createBlobStore()__                    } catch (RepositoryException e) {_                        throw e__                    } catch (Exception e) {_                        throw new RepositoryException(metadata.name(), "cannot create blob store" , e)__                    }_                    blobStore.set(store)__                }_            }_        }_        return store__    };maintains,single,lazy,instance,of,link,blob,store;protected,blob,store,blob,store,assert,snapshot,or,generic,thread,blob,store,store,blob,store,get,if,store,null,synchronized,lock,store,blob,store,get,if,store,null,if,lifecycle,started,false,throw,new,repository,exception,metadata,name,repository,is,not,in,started,state,try,store,create,blob,store,catch,repository,exception,e,throw,e,catch,exception,e,throw,new,repository,exception,metadata,name,cannot,create,blob,store,e,blob,store,set,store,return,store
BlobStoreRepository -> protected BlobStore blobStore();1535723122;maintains single lazy instance of {@link BlobStore};protected BlobStore blobStore() {_        assertSnapshotOrGenericThread()___        BlobStore store = blobStore.get()__        if (store == null) {_            synchronized (lock) {_                store = blobStore.get()__                if (store == null) {_                    if (lifecycle.started() == false) {_                        throw new RepositoryException(metadata.name(), "repository is not in started state")__                    }_                    try {_                        store = createBlobStore()__                    } catch (RepositoryException e) {_                        throw e__                    } catch (Exception e) {_                        throw new RepositoryException(metadata.name(), "cannot create blob store" , e)__                    }_                    blobStore.set(store)__                }_            }_        }_        return store__    };maintains,single,lazy,instance,of,link,blob,store;protected,blob,store,blob,store,assert,snapshot,or,generic,thread,blob,store,store,blob,store,get,if,store,null,synchronized,lock,store,blob,store,get,if,store,null,if,lifecycle,started,false,throw,new,repository,exception,metadata,name,repository,is,not,in,started,state,try,store,create,blob,store,catch,repository,exception,e,throw,e,catch,exception,e,throw,new,repository,exception,metadata,name,cannot,create,blob,store,e,blob,store,set,store,return,store
BlobStoreRepository -> protected BlobStore blobStore();1536314350;maintains single lazy instance of {@link BlobStore};protected BlobStore blobStore() {_        assertSnapshotOrGenericThread()___        BlobStore store = blobStore.get()__        if (store == null) {_            synchronized (lock) {_                store = blobStore.get()__                if (store == null) {_                    if (lifecycle.started() == false) {_                        throw new RepositoryException(metadata.name(), "repository is not in started state")__                    }_                    try {_                        store = createBlobStore()__                    } catch (RepositoryException e) {_                        throw e__                    } catch (Exception e) {_                        throw new RepositoryException(metadata.name(), "cannot create blob store" , e)__                    }_                    blobStore.set(store)__                }_            }_        }_        return store__    };maintains,single,lazy,instance,of,link,blob,store;protected,blob,store,blob,store,assert,snapshot,or,generic,thread,blob,store,store,blob,store,get,if,store,null,synchronized,lock,store,blob,store,get,if,store,null,if,lifecycle,started,false,throw,new,repository,exception,metadata,name,repository,is,not,in,started,state,try,store,create,blob,store,catch,repository,exception,e,throw,e,catch,exception,e,throw,new,repository,exception,metadata,name,cannot,create,blob,store,e,blob,store,set,store,return,store
BlobStoreRepository -> protected BlobStore blobStore();1536828374;maintains single lazy instance of {@link BlobStore};protected BlobStore blobStore() {_        assertSnapshotOrGenericThread()___        BlobStore store = blobStore.get()__        if (store == null) {_            synchronized (lock) {_                store = blobStore.get()__                if (store == null) {_                    if (lifecycle.started() == false) {_                        throw new RepositoryException(metadata.name(), "repository is not in started state")__                    }_                    try {_                        store = createBlobStore()__                    } catch (RepositoryException e) {_                        throw e__                    } catch (Exception e) {_                        throw new RepositoryException(metadata.name(), "cannot create blob store" , e)__                    }_                    blobStore.set(store)__                }_            }_        }_        return store__    };maintains,single,lazy,instance,of,link,blob,store;protected,blob,store,blob,store,assert,snapshot,or,generic,thread,blob,store,store,blob,store,get,if,store,null,synchronized,lock,store,blob,store,get,if,store,null,if,lifecycle,started,false,throw,new,repository,exception,metadata,name,repository,is,not,in,started,state,try,store,create,blob,store,catch,repository,exception,e,throw,e,catch,exception,e,throw,new,repository,exception,metadata,name,cannot,create,blob,store,e,blob,store,set,store,return,store
BlobStoreRepository -> protected BlobStore blobStore();1541008027;maintains single lazy instance of {@link BlobStore};protected BlobStore blobStore() {_        assertSnapshotOrGenericThread()___        BlobStore store = blobStore.get()__        if (store == null) {_            synchronized (lock) {_                store = blobStore.get()__                if (store == null) {_                    if (lifecycle.started() == false) {_                        throw new RepositoryException(metadata.name(), "repository is not in started state")__                    }_                    try {_                        store = createBlobStore()__                    } catch (RepositoryException e) {_                        throw e__                    } catch (Exception e) {_                        throw new RepositoryException(metadata.name(), "cannot create blob store" , e)__                    }_                    blobStore.set(store)__                }_            }_        }_        return store__    };maintains,single,lazy,instance,of,link,blob,store;protected,blob,store,blob,store,assert,snapshot,or,generic,thread,blob,store,store,blob,store,get,if,store,null,synchronized,lock,store,blob,store,get,if,store,null,if,lifecycle,started,false,throw,new,repository,exception,metadata,name,repository,is,not,in,started,state,try,store,create,blob,store,catch,repository,exception,e,throw,e,catch,exception,e,throw,new,repository,exception,metadata,name,cannot,create,blob,store,e,blob,store,set,store,return,store
BlobStoreRepository -> protected BlobStore blobStore();1542646292;maintains single lazy instance of {@link BlobStore};protected BlobStore blobStore() {_        assertSnapshotOrGenericThread()___        BlobStore store = blobStore.get()__        if (store == null) {_            synchronized (lock) {_                store = blobStore.get()__                if (store == null) {_                    if (lifecycle.started() == false) {_                        throw new RepositoryException(metadata.name(), "repository is not in started state")__                    }_                    try {_                        store = createBlobStore()__                    } catch (RepositoryException e) {_                        throw e__                    } catch (Exception e) {_                        throw new RepositoryException(metadata.name(), "cannot create blob store" , e)__                    }_                    blobStore.set(store)__                }_            }_        }_        return store__    };maintains,single,lazy,instance,of,link,blob,store;protected,blob,store,blob,store,assert,snapshot,or,generic,thread,blob,store,store,blob,store,get,if,store,null,synchronized,lock,store,blob,store,get,if,store,null,if,lifecycle,started,false,throw,new,repository,exception,metadata,name,repository,is,not,in,started,state,try,store,create,blob,store,catch,repository,exception,e,throw,e,catch,exception,e,throw,new,repository,exception,metadata,name,cannot,create,blob,store,e,blob,store,set,store,return,store
BlobStoreRepository -> protected BlobStore blobStore();1542980705;maintains single lazy instance of {@link BlobStore};protected BlobStore blobStore() {_        assertSnapshotOrGenericThread()___        BlobStore store = blobStore.get()__        if (store == null) {_            synchronized (lock) {_                store = blobStore.get()__                if (store == null) {_                    if (lifecycle.started() == false) {_                        throw new RepositoryException(metadata.name(), "repository is not in started state")__                    }_                    try {_                        store = createBlobStore()__                    } catch (RepositoryException e) {_                        throw e__                    } catch (Exception e) {_                        throw new RepositoryException(metadata.name(), "cannot create blob store" , e)__                    }_                    blobStore.set(store)__                }_            }_        }_        return store__    };maintains,single,lazy,instance,of,link,blob,store;protected,blob,store,blob,store,assert,snapshot,or,generic,thread,blob,store,store,blob,store,get,if,store,null,synchronized,lock,store,blob,store,get,if,store,null,if,lifecycle,started,false,throw,new,repository,exception,metadata,name,repository,is,not,in,started,state,try,store,create,blob,store,catch,repository,exception,e,throw,e,catch,exception,e,throw,new,repository,exception,metadata,name,cannot,create,blob,store,e,blob,store,set,store,return,store
BlobStoreRepository -> protected BlobStore blobStore();1543831870;maintains single lazy instance of {@link BlobStore};protected BlobStore blobStore() {_        assertSnapshotOrGenericThread()___        BlobStore store = blobStore.get()__        if (store == null) {_            synchronized (lock) {_                store = blobStore.get()__                if (store == null) {_                    if (lifecycle.started() == false) {_                        throw new RepositoryException(metadata.name(), "repository is not in started state")__                    }_                    try {_                        store = createBlobStore()__                    } catch (RepositoryException e) {_                        throw e__                    } catch (Exception e) {_                        throw new RepositoryException(metadata.name(), "cannot create blob store" , e)__                    }_                    blobStore.set(store)__                }_            }_        }_        return store__    };maintains,single,lazy,instance,of,link,blob,store;protected,blob,store,blob,store,assert,snapshot,or,generic,thread,blob,store,store,blob,store,get,if,store,null,synchronized,lock,store,blob,store,get,if,store,null,if,lifecycle,started,false,throw,new,repository,exception,metadata,name,repository,is,not,in,started,state,try,store,create,blob,store,catch,repository,exception,e,throw,e,catch,exception,e,throw,new,repository,exception,metadata,name,cannot,create,blob,store,e,blob,store,set,store,return,store
BlobStoreRepository -> protected BlobStore blobStore();1543942400;maintains single lazy instance of {@link BlobStore};protected BlobStore blobStore() {_        assertSnapshotOrGenericThread()___        BlobStore store = blobStore.get()__        if (store == null) {_            synchronized (lock) {_                store = blobStore.get()__                if (store == null) {_                    if (lifecycle.started() == false) {_                        throw new RepositoryException(metadata.name(), "repository is not in started state")__                    }_                    try {_                        store = createBlobStore()__                    } catch (RepositoryException e) {_                        throw e__                    } catch (Exception e) {_                        throw new RepositoryException(metadata.name(), "cannot create blob store" , e)__                    }_                    blobStore.set(store)__                }_            }_        }_        return store__    };maintains,single,lazy,instance,of,link,blob,store;protected,blob,store,blob,store,assert,snapshot,or,generic,thread,blob,store,store,blob,store,get,if,store,null,synchronized,lock,store,blob,store,get,if,store,null,if,lifecycle,started,false,throw,new,repository,exception,metadata,name,repository,is,not,in,started,state,try,store,create,blob,store,catch,repository,exception,e,throw,e,catch,exception,e,throw,new,repository,exception,metadata,name,cannot,create,blob,store,e,blob,store,set,store,return,store
BlobStoreRepository -> protected BlobStore blobStore();1546974294;maintains single lazy instance of {@link BlobStore};protected BlobStore blobStore() {_        assertSnapshotOrGenericThread()___        BlobStore store = blobStore.get()__        if (store == null) {_            synchronized (lock) {_                store = blobStore.get()__                if (store == null) {_                    if (lifecycle.started() == false) {_                        throw new RepositoryException(metadata.name(), "repository is not in started state")__                    }_                    try {_                        store = createBlobStore()__                    } catch (RepositoryException e) {_                        throw e__                    } catch (Exception e) {_                        throw new RepositoryException(metadata.name(), "cannot create blob store" , e)__                    }_                    blobStore.set(store)__                }_            }_        }_        return store__    };maintains,single,lazy,instance,of,link,blob,store;protected,blob,store,blob,store,assert,snapshot,or,generic,thread,blob,store,store,blob,store,get,if,store,null,synchronized,lock,store,blob,store,get,if,store,null,if,lifecycle,started,false,throw,new,repository,exception,metadata,name,repository,is,not,in,started,state,try,store,create,blob,store,catch,repository,exception,e,throw,e,catch,exception,e,throw,new,repository,exception,metadata,name,cannot,create,blob,store,e,blob,store,set,store,return,store
BlobStoreRepository -> protected BlobStore blobStore();1547496475;maintains single lazy instance of {@link BlobStore};protected BlobStore blobStore() {_        assertSnapshotOrGenericThread()___        BlobStore store = blobStore.get()__        if (store == null) {_            synchronized (lock) {_                store = blobStore.get()__                if (store == null) {_                    if (lifecycle.started() == false) {_                        throw new RepositoryException(metadata.name(), "repository is not in started state")__                    }_                    try {_                        store = createBlobStore()__                    } catch (RepositoryException e) {_                        throw e__                    } catch (Exception e) {_                        throw new RepositoryException(metadata.name(), "cannot create blob store" , e)__                    }_                    blobStore.set(store)__                }_            }_        }_        return store__    };maintains,single,lazy,instance,of,link,blob,store;protected,blob,store,blob,store,assert,snapshot,or,generic,thread,blob,store,store,blob,store,get,if,store,null,synchronized,lock,store,blob,store,get,if,store,null,if,lifecycle,started,false,throw,new,repository,exception,metadata,name,repository,is,not,in,started,state,try,store,create,blob,store,catch,repository,exception,e,throw,e,catch,exception,e,throw,new,repository,exception,metadata,name,cannot,create,blob,store,e,blob,store,set,store,return,store
BlobStoreRepository -> protected BlobStore blobStore();1547625930;maintains single lazy instance of {@link BlobStore};protected BlobStore blobStore() {_        assertSnapshotOrGenericThread()___        BlobStore store = blobStore.get()__        if (store == null) {_            synchronized (lock) {_                store = blobStore.get()__                if (store == null) {_                    if (lifecycle.started() == false) {_                        throw new RepositoryException(metadata.name(), "repository is not in started state")__                    }_                    try {_                        store = createBlobStore()__                    } catch (RepositoryException e) {_                        throw e__                    } catch (Exception e) {_                        throw new RepositoryException(metadata.name(), "cannot create blob store" , e)__                    }_                    blobStore.set(store)__                }_            }_        }_        return store__    };maintains,single,lazy,instance,of,link,blob,store;protected,blob,store,blob,store,assert,snapshot,or,generic,thread,blob,store,store,blob,store,get,if,store,null,synchronized,lock,store,blob,store,get,if,store,null,if,lifecycle,started,false,throw,new,repository,exception,metadata,name,repository,is,not,in,started,state,try,store,create,blob,store,catch,repository,exception,e,throw,e,catch,exception,e,throw,new,repository,exception,metadata,name,cannot,create,blob,store,e,blob,store,set,store,return,store
BlobStoreRepository -> protected BlobStore blobStore();1550647627;maintains single lazy instance of {@link BlobStore};protected BlobStore blobStore() {_        assertSnapshotOrGenericThread()___        BlobStore store = blobStore.get()__        if (store == null) {_            synchronized (lock) {_                store = blobStore.get()__                if (store == null) {_                    if (lifecycle.started() == false) {_                        throw new RepositoryException(metadata.name(), "repository is not in started state")__                    }_                    try {_                        store = createBlobStore()__                    } catch (RepositoryException e) {_                        throw e__                    } catch (Exception e) {_                        throw new RepositoryException(metadata.name(), "cannot create blob store" , e)__                    }_                    blobStore.set(store)__                }_            }_        }_        return store__    };maintains,single,lazy,instance,of,link,blob,store;protected,blob,store,blob,store,assert,snapshot,or,generic,thread,blob,store,store,blob,store,get,if,store,null,synchronized,lock,store,blob,store,get,if,store,null,if,lifecycle,started,false,throw,new,repository,exception,metadata,name,repository,is,not,in,started,state,try,store,create,blob,store,catch,repository,exception,e,throw,e,catch,exception,e,throw,new,repository,exception,metadata,name,cannot,create,blob,store,e,blob,store,set,store,return,store
BlobStoreRepository -> protected boolean isCompress();1524684173;Returns true if metadata and snapshot files should be compressed__@return true if compression is needed;protected boolean isCompress() {_        return false__    };returns,true,if,metadata,and,snapshot,files,should,be,compressed,return,true,if,compression,is,needed;protected,boolean,is,compress,return,false
BlobStoreRepository -> protected boolean isCompress();1525334055;Returns true if metadata and snapshot files should be compressed__@return true if compression is needed;protected boolean isCompress() {_        return false__    };returns,true,if,metadata,and,snapshot,files,should,be,compressed,return,true,if,compression,is,needed;protected,boolean,is,compress,return,false
BlobStoreRepository -> protected boolean isCompress();1525798020;Returns true if metadata and snapshot files should be compressed__@return true if compression is needed;protected boolean isCompress() {_        return false__    };returns,true,if,metadata,and,snapshot,files,should,be,compressed,return,true,if,compression,is,needed;protected,boolean,is,compress,return,false
BlobStoreRepository -> protected boolean isCompress();1526289033;Returns true if metadata and snapshot files should be compressed__@return true if compression is needed;protected boolean isCompress() {_        return false__    };returns,true,if,metadata,and,snapshot,files,should,be,compressed,return,true,if,compression,is,needed;protected,boolean,is,compress,return,false
BlobStoreRepository -> protected boolean isCompress();1526574077;Returns true if metadata and snapshot files should be compressed__@return true if compression is needed;protected boolean isCompress() {_        return false__    };returns,true,if,metadata,and,snapshot,files,should,be,compressed,return,true,if,compression,is,needed;protected,boolean,is,compress,return,false
BlobStoreRepository -> protected boolean isCompress();1527583663;Returns true if metadata and snapshot files should be compressed__@return true if compression is needed;protected boolean isCompress() {_        return false__    };returns,true,if,metadata,and,snapshot,files,should,be,compressed,return,true,if,compression,is,needed;protected,boolean,is,compress,return,false
BlobStoreRepository -> protected boolean isCompress();1528211342;Returns true if metadata and snapshot files should be compressed__@return true if compression is needed;protected boolean isCompress() {_        return false__    };returns,true,if,metadata,and,snapshot,files,should,be,compressed,return,true,if,compression,is,needed;protected,boolean,is,compress,return,false
BlobStoreRepository -> protected boolean isCompress();1531179852;Returns true if metadata and snapshot files should be compressed__@return true if compression is needed;protected boolean isCompress() {_        return false__    };returns,true,if,metadata,and,snapshot,files,should,be,compressed,return,true,if,compression,is,needed;protected,boolean,is,compress,return,false
BlobStoreRepository -> protected boolean isCompress();1531729807;Returns true if metadata and snapshot files should be compressed__@return true if compression is needed;protected boolean isCompress() {_        return false__    };returns,true,if,metadata,and,snapshot,files,should,be,compressed,return,true,if,compression,is,needed;protected,boolean,is,compress,return,false
BlobStoreRepository -> protected boolean isCompress();1532685069;Returns true if metadata and snapshot files should be compressed__@return true if compression is needed;protected boolean isCompress() {_        return false__    };returns,true,if,metadata,and,snapshot,files,should,be,compressed,return,true,if,compression,is,needed;protected,boolean,is,compress,return,false
BlobStoreRepository -> protected boolean isCompress();1535139672;Returns true if metadata and snapshot files should be compressed__@return true if compression is needed;protected boolean isCompress() {_        return false__    };returns,true,if,metadata,and,snapshot,files,should,be,compressed,return,true,if,compression,is,needed;protected,boolean,is,compress,return,false
BlobStoreRepository -> protected boolean isCompress();1535723122;Returns true if metadata and snapshot files should be compressed__@return true if compression is needed;protected boolean isCompress() {_        return false__    };returns,true,if,metadata,and,snapshot,files,should,be,compressed,return,true,if,compression,is,needed;protected,boolean,is,compress,return,false
BlobStoreRepository -> protected boolean isCompress();1536314350;Returns true if metadata and snapshot files should be compressed__@return true if compression is needed;protected boolean isCompress() {_        return false__    };returns,true,if,metadata,and,snapshot,files,should,be,compressed,return,true,if,compression,is,needed;protected,boolean,is,compress,return,false
BlobStoreRepository -> protected boolean isCompress();1536828374;Returns true if metadata and snapshot files should be compressed__@return true if compression is needed;protected boolean isCompress() {_        return false__    };returns,true,if,metadata,and,snapshot,files,should,be,compressed,return,true,if,compression,is,needed;protected,boolean,is,compress,return,false
BlobStoreRepository -> protected boolean isCompress();1541008027;Returns true if metadata and snapshot files should be compressed__@return true if compression is needed;protected boolean isCompress() {_        return false__    };returns,true,if,metadata,and,snapshot,files,should,be,compressed,return,true,if,compression,is,needed;protected,boolean,is,compress,return,false
BlobStoreRepository -> protected boolean isCompress();1542646292;Returns true if metadata and snapshot files should be compressed__@return true if compression is needed;protected boolean isCompress() {_        return false__    };returns,true,if,metadata,and,snapshot,files,should,be,compressed,return,true,if,compression,is,needed;protected,boolean,is,compress,return,false
BlobStoreRepository -> protected boolean isCompress();1542980705;Returns true if metadata and snapshot files should be compressed__@return true if compression is needed;protected boolean isCompress() {_        return false__    };returns,true,if,metadata,and,snapshot,files,should,be,compressed,return,true,if,compression,is,needed;protected,boolean,is,compress,return,false
BlobStoreRepository -> protected boolean isCompress();1543831870;Returns true if metadata and snapshot files should be compressed__@return true if compression is needed;protected boolean isCompress() {_        return false__    };returns,true,if,metadata,and,snapshot,files,should,be,compressed,return,true,if,compression,is,needed;protected,boolean,is,compress,return,false
BlobStoreRepository -> protected boolean isCompress();1543942400;Returns true if metadata and snapshot files should be compressed__@return true if compression is needed;protected boolean isCompress() {_        return false__    };returns,true,if,metadata,and,snapshot,files,should,be,compressed,return,true,if,compression,is,needed;protected,boolean,is,compress,return,false
BlobStoreRepository -> protected boolean isCompress();1546974294;Returns true if metadata and snapshot files should be compressed__@return true if compression is needed;protected boolean isCompress() {_        return false__    };returns,true,if,metadata,and,snapshot,files,should,be,compressed,return,true,if,compression,is,needed;protected,boolean,is,compress,return,false
BlobStoreRepository -> protected boolean isCompress();1547496475;Returns true if metadata and snapshot files should be compressed__@return true if compression is needed;protected boolean isCompress() {_        return false__    };returns,true,if,metadata,and,snapshot,files,should,be,compressed,return,true,if,compression,is,needed;protected,boolean,is,compress,return,false
BlobStoreRepository -> protected boolean isCompress();1547625930;Returns true if metadata and snapshot files should be compressed__@return true if compression is needed;protected boolean isCompress() {_        return false__    };returns,true,if,metadata,and,snapshot,files,should,be,compressed,return,true,if,compression,is,needed;protected,boolean,is,compress,return,false
BlobStoreRepository -> private void delete(SnapshotId snapshotId, IndexId indexId, ShardId shardId);1543831870;Delete shard snapshot__@param snapshotId snapshot id_@param shardId    shard id;private void delete(SnapshotId snapshotId, IndexId indexId, ShardId shardId) {_        Context context = new Context(snapshotId, indexId, shardId, shardId)__        context.delete()__    };delete,shard,snapshot,param,snapshot,id,snapshot,id,param,shard,id,shard,id;private,void,delete,snapshot,id,snapshot,id,index,id,index,id,shard,id,shard,id,context,context,new,context,snapshot,id,index,id,shard,id,shard,id,context,delete
BlobStoreRepository -> private void delete(SnapshotId snapshotId, IndexId indexId, ShardId shardId);1543942400;Delete shard snapshot__@param snapshotId snapshot id_@param shardId    shard id;private void delete(SnapshotId snapshotId, IndexId indexId, ShardId shardId) {_        Context context = new Context(snapshotId, indexId, shardId, shardId)__        context.delete()__    };delete,shard,snapshot,param,snapshot,id,snapshot,id,param,shard,id,shard,id;private,void,delete,snapshot,id,snapshot,id,index,id,index,id,shard,id,shard,id,context,context,new,context,snapshot,id,index,id,shard,id,shard,id,context,delete
BlobStoreRepository -> private void delete(SnapshotId snapshotId, IndexId indexId, ShardId shardId);1546974294;Delete shard snapshot__@param snapshotId snapshot id_@param shardId    shard id;private void delete(SnapshotId snapshotId, IndexId indexId, ShardId shardId) {_        Context context = new Context(snapshotId, indexId, shardId, shardId)__        context.delete()__    };delete,shard,snapshot,param,snapshot,id,snapshot,id,param,shard,id,shard,id;private,void,delete,snapshot,id,snapshot,id,index,id,index,id,shard,id,shard,id,context,context,new,context,snapshot,id,index,id,shard,id,shard,id,context,delete
BlobStoreRepository -> private void delete(SnapshotId snapshotId, IndexId indexId, ShardId shardId);1547496475;Delete shard snapshot__@param snapshotId snapshot id_@param shardId    shard id;private void delete(SnapshotId snapshotId, IndexId indexId, ShardId shardId) {_        Context context = new Context(snapshotId, indexId, shardId, shardId)__        context.delete()__    };delete,shard,snapshot,param,snapshot,id,snapshot,id,param,shard,id,shard,id;private,void,delete,snapshot,id,snapshot,id,index,id,index,id,shard,id,shard,id,context,context,new,context,snapshot,id,index,id,shard,id,shard,id,context,delete
BlobStoreRepository -> private void delete(SnapshotId snapshotId, IndexId indexId, ShardId shardId);1547625930;Delete shard snapshot__@param snapshotId snapshot id_@param shardId    shard id;private void delete(SnapshotId snapshotId, IndexId indexId, ShardId shardId) {_        Context context = new Context(snapshotId, indexId, shardId, shardId)__        context.delete()__    };delete,shard,snapshot,param,snapshot,id,snapshot,id,param,shard,id,shard,id;private,void,delete,snapshot,id,snapshot,id,index,id,index,id,shard,id,shard,id,context,context,new,context,snapshot,id,index,id,shard,id,shard,id,context,delete
BlobStoreRepository -> private void delete(SnapshotId snapshotId, IndexId indexId, ShardId shardId);1550647627;Delete shard snapshot__@param snapshotId snapshot id_@param shardId    shard id;private void delete(SnapshotId snapshotId, IndexId indexId, ShardId shardId) {_        Context context = new Context(snapshotId, indexId, shardId, shardId)__        context.delete()__    };delete,shard,snapshot,param,snapshot,id,snapshot,id,param,shard,id,shard,id;private,void,delete,snapshot,id,snapshot,id,index,id,index,id,shard,id,shard,id,context,context,new,context,snapshot,id,index,id,shard,id,shard,id,context,delete
BlobStoreRepository -> Context -> protected long findLatestFileNameGeneration(Map<String, BlobMetaData> blobs);1524684173;Finds the next available blob number__@param blobs list of blobs in the repository_@return next available blob number;protected long findLatestFileNameGeneration(Map<String, BlobMetaData> blobs) {_            long generation = -1__            for (String name : blobs.keySet()) {_                if (!name.startsWith(DATA_BLOB_PREFIX)) {_                    continue__                }_                name = BlobStoreIndexShardSnapshot.FileInfo.canonicalName(name)__                try {_                    long currentGen = Long.parseLong(name.substring(DATA_BLOB_PREFIX.length()), Character.MAX_RADIX)__                    if (currentGen > generation) {_                        generation = currentGen__                    }_                } catch (NumberFormatException e) {_                    logger.warn("file [{}] does not conform to the '{}' schema", name, DATA_BLOB_PREFIX)__                }_            }_            return generation__        };finds,the,next,available,blob,number,param,blobs,list,of,blobs,in,the,repository,return,next,available,blob,number;protected,long,find,latest,file,name,generation,map,string,blob,meta,data,blobs,long,generation,1,for,string,name,blobs,key,set,if,name,starts,with,continue,name,blob,store,index,shard,snapshot,file,info,canonical,name,name,try,long,current,gen,long,parse,long,name,substring,length,character,if,current,gen,generation,generation,current,gen,catch,number,format,exception,e,logger,warn,file,does,not,conform,to,the,schema,name,return,generation
BlobStoreRepository -> Context -> protected long findLatestFileNameGeneration(Map<String, BlobMetaData> blobs);1525334055;Finds the next available blob number__@param blobs list of blobs in the repository_@return next available blob number;protected long findLatestFileNameGeneration(Map<String, BlobMetaData> blobs) {_            long generation = -1__            for (String name : blobs.keySet()) {_                if (!name.startsWith(DATA_BLOB_PREFIX)) {_                    continue__                }_                name = BlobStoreIndexShardSnapshot.FileInfo.canonicalName(name)__                try {_                    long currentGen = Long.parseLong(name.substring(DATA_BLOB_PREFIX.length()), Character.MAX_RADIX)__                    if (currentGen > generation) {_                        generation = currentGen__                    }_                } catch (NumberFormatException e) {_                    logger.warn("file [{}] does not conform to the '{}' schema", name, DATA_BLOB_PREFIX)__                }_            }_            return generation__        };finds,the,next,available,blob,number,param,blobs,list,of,blobs,in,the,repository,return,next,available,blob,number;protected,long,find,latest,file,name,generation,map,string,blob,meta,data,blobs,long,generation,1,for,string,name,blobs,key,set,if,name,starts,with,continue,name,blob,store,index,shard,snapshot,file,info,canonical,name,name,try,long,current,gen,long,parse,long,name,substring,length,character,if,current,gen,generation,generation,current,gen,catch,number,format,exception,e,logger,warn,file,does,not,conform,to,the,schema,name,return,generation
BlobStoreRepository -> Context -> protected long findLatestFileNameGeneration(Map<String, BlobMetaData> blobs);1525798020;Finds the next available blob number__@param blobs list of blobs in the repository_@return next available blob number;protected long findLatestFileNameGeneration(Map<String, BlobMetaData> blobs) {_            long generation = -1__            for (String name : blobs.keySet()) {_                if (!name.startsWith(DATA_BLOB_PREFIX)) {_                    continue__                }_                name = canonicalName(name)__                try {_                    long currentGen = Long.parseLong(name.substring(DATA_BLOB_PREFIX.length()), Character.MAX_RADIX)__                    if (currentGen > generation) {_                        generation = currentGen__                    }_                } catch (NumberFormatException e) {_                    logger.warn("file [{}] does not conform to the '{}' schema", name, DATA_BLOB_PREFIX)__                }_            }_            return generation__        };finds,the,next,available,blob,number,param,blobs,list,of,blobs,in,the,repository,return,next,available,blob,number;protected,long,find,latest,file,name,generation,map,string,blob,meta,data,blobs,long,generation,1,for,string,name,blobs,key,set,if,name,starts,with,continue,name,canonical,name,name,try,long,current,gen,long,parse,long,name,substring,length,character,if,current,gen,generation,generation,current,gen,catch,number,format,exception,e,logger,warn,file,does,not,conform,to,the,schema,name,return,generation
BlobStoreRepository -> Context -> protected long findLatestFileNameGeneration(Map<String, BlobMetaData> blobs);1526289033;Finds the next available blob number__@param blobs list of blobs in the repository_@return next available blob number;protected long findLatestFileNameGeneration(Map<String, BlobMetaData> blobs) {_            long generation = -1__            for (String name : blobs.keySet()) {_                if (!name.startsWith(DATA_BLOB_PREFIX)) {_                    continue__                }_                name = canonicalName(name)__                try {_                    long currentGen = Long.parseLong(name.substring(DATA_BLOB_PREFIX.length()), Character.MAX_RADIX)__                    if (currentGen > generation) {_                        generation = currentGen__                    }_                } catch (NumberFormatException e) {_                    logger.warn("file [{}] does not conform to the '{}' schema", name, DATA_BLOB_PREFIX)__                }_            }_            return generation__        };finds,the,next,available,blob,number,param,blobs,list,of,blobs,in,the,repository,return,next,available,blob,number;protected,long,find,latest,file,name,generation,map,string,blob,meta,data,blobs,long,generation,1,for,string,name,blobs,key,set,if,name,starts,with,continue,name,canonical,name,name,try,long,current,gen,long,parse,long,name,substring,length,character,if,current,gen,generation,generation,current,gen,catch,number,format,exception,e,logger,warn,file,does,not,conform,to,the,schema,name,return,generation
BlobStoreRepository -> Context -> protected long findLatestFileNameGeneration(Map<String, BlobMetaData> blobs);1526574077;Finds the next available blob number__@param blobs list of blobs in the repository_@return next available blob number;protected long findLatestFileNameGeneration(Map<String, BlobMetaData> blobs) {_            long generation = -1__            for (String name : blobs.keySet()) {_                if (!name.startsWith(DATA_BLOB_PREFIX)) {_                    continue__                }_                name = canonicalName(name)__                try {_                    long currentGen = Long.parseLong(name.substring(DATA_BLOB_PREFIX.length()), Character.MAX_RADIX)__                    if (currentGen > generation) {_                        generation = currentGen__                    }_                } catch (NumberFormatException e) {_                    logger.warn("file [{}] does not conform to the '{}' schema", name, DATA_BLOB_PREFIX)__                }_            }_            return generation__        };finds,the,next,available,blob,number,param,blobs,list,of,blobs,in,the,repository,return,next,available,blob,number;protected,long,find,latest,file,name,generation,map,string,blob,meta,data,blobs,long,generation,1,for,string,name,blobs,key,set,if,name,starts,with,continue,name,canonical,name,name,try,long,current,gen,long,parse,long,name,substring,length,character,if,current,gen,generation,generation,current,gen,catch,number,format,exception,e,logger,warn,file,does,not,conform,to,the,schema,name,return,generation
BlobStoreRepository -> Context -> protected long findLatestFileNameGeneration(Map<String, BlobMetaData> blobs);1527583663;Finds the next available blob number__@param blobs list of blobs in the repository_@return next available blob number;protected long findLatestFileNameGeneration(Map<String, BlobMetaData> blobs) {_            long generation = -1__            for (String name : blobs.keySet()) {_                if (!name.startsWith(DATA_BLOB_PREFIX)) {_                    continue__                }_                name = canonicalName(name)__                try {_                    long currentGen = Long.parseLong(name.substring(DATA_BLOB_PREFIX.length()), Character.MAX_RADIX)__                    if (currentGen > generation) {_                        generation = currentGen__                    }_                } catch (NumberFormatException e) {_                    logger.warn("file [{}] does not conform to the '{}' schema", name, DATA_BLOB_PREFIX)__                }_            }_            return generation__        };finds,the,next,available,blob,number,param,blobs,list,of,blobs,in,the,repository,return,next,available,blob,number;protected,long,find,latest,file,name,generation,map,string,blob,meta,data,blobs,long,generation,1,for,string,name,blobs,key,set,if,name,starts,with,continue,name,canonical,name,name,try,long,current,gen,long,parse,long,name,substring,length,character,if,current,gen,generation,generation,current,gen,catch,number,format,exception,e,logger,warn,file,does,not,conform,to,the,schema,name,return,generation
BlobStoreRepository -> Context -> protected long findLatestFileNameGeneration(Map<String, BlobMetaData> blobs);1528211342;Finds the next available blob number__@param blobs list of blobs in the repository_@return next available blob number;protected long findLatestFileNameGeneration(Map<String, BlobMetaData> blobs) {_            long generation = -1__            for (String name : blobs.keySet()) {_                if (!name.startsWith(DATA_BLOB_PREFIX)) {_                    continue__                }_                name = canonicalName(name)__                try {_                    long currentGen = Long.parseLong(name.substring(DATA_BLOB_PREFIX.length()), Character.MAX_RADIX)__                    if (currentGen > generation) {_                        generation = currentGen__                    }_                } catch (NumberFormatException e) {_                    logger.warn("file [{}] does not conform to the '{}' schema", name, DATA_BLOB_PREFIX)__                }_            }_            return generation__        };finds,the,next,available,blob,number,param,blobs,list,of,blobs,in,the,repository,return,next,available,blob,number;protected,long,find,latest,file,name,generation,map,string,blob,meta,data,blobs,long,generation,1,for,string,name,blobs,key,set,if,name,starts,with,continue,name,canonical,name,name,try,long,current,gen,long,parse,long,name,substring,length,character,if,current,gen,generation,generation,current,gen,catch,number,format,exception,e,logger,warn,file,does,not,conform,to,the,schema,name,return,generation
BlobStoreRepository -> Context -> protected long findLatestFileNameGeneration(Map<String, BlobMetaData> blobs);1531179852;Finds the next available blob number__@param blobs list of blobs in the repository_@return next available blob number;protected long findLatestFileNameGeneration(Map<String, BlobMetaData> blobs) {_            long generation = -1__            for (String name : blobs.keySet()) {_                if (!name.startsWith(DATA_BLOB_PREFIX)) {_                    continue__                }_                name = canonicalName(name)__                try {_                    long currentGen = Long.parseLong(name.substring(DATA_BLOB_PREFIX.length()), Character.MAX_RADIX)__                    if (currentGen > generation) {_                        generation = currentGen__                    }_                } catch (NumberFormatException e) {_                    logger.warn("file [{}] does not conform to the '{}' schema", name, DATA_BLOB_PREFIX)__                }_            }_            return generation__        };finds,the,next,available,blob,number,param,blobs,list,of,blobs,in,the,repository,return,next,available,blob,number;protected,long,find,latest,file,name,generation,map,string,blob,meta,data,blobs,long,generation,1,for,string,name,blobs,key,set,if,name,starts,with,continue,name,canonical,name,name,try,long,current,gen,long,parse,long,name,substring,length,character,if,current,gen,generation,generation,current,gen,catch,number,format,exception,e,logger,warn,file,does,not,conform,to,the,schema,name,return,generation
BlobStoreRepository -> Context -> protected long findLatestFileNameGeneration(Map<String, BlobMetaData> blobs);1531729807;Finds the next available blob number__@param blobs list of blobs in the repository_@return next available blob number;protected long findLatestFileNameGeneration(Map<String, BlobMetaData> blobs) {_            long generation = -1__            for (String name : blobs.keySet()) {_                if (!name.startsWith(DATA_BLOB_PREFIX)) {_                    continue__                }_                name = canonicalName(name)__                try {_                    long currentGen = Long.parseLong(name.substring(DATA_BLOB_PREFIX.length()), Character.MAX_RADIX)__                    if (currentGen > generation) {_                        generation = currentGen__                    }_                } catch (NumberFormatException e) {_                    logger.warn("file [{}] does not conform to the '{}' schema", name, DATA_BLOB_PREFIX)__                }_            }_            return generation__        };finds,the,next,available,blob,number,param,blobs,list,of,blobs,in,the,repository,return,next,available,blob,number;protected,long,find,latest,file,name,generation,map,string,blob,meta,data,blobs,long,generation,1,for,string,name,blobs,key,set,if,name,starts,with,continue,name,canonical,name,name,try,long,current,gen,long,parse,long,name,substring,length,character,if,current,gen,generation,generation,current,gen,catch,number,format,exception,e,logger,warn,file,does,not,conform,to,the,schema,name,return,generation
BlobStoreRepository -> Context -> protected long findLatestFileNameGeneration(Map<String, BlobMetaData> blobs);1532685069;Finds the next available blob number__@param blobs list of blobs in the repository_@return next available blob number;protected long findLatestFileNameGeneration(Map<String, BlobMetaData> blobs) {_            long generation = -1__            for (String name : blobs.keySet()) {_                if (!name.startsWith(DATA_BLOB_PREFIX)) {_                    continue__                }_                name = canonicalName(name)__                try {_                    long currentGen = Long.parseLong(name.substring(DATA_BLOB_PREFIX.length()), Character.MAX_RADIX)__                    if (currentGen > generation) {_                        generation = currentGen__                    }_                } catch (NumberFormatException e) {_                    logger.warn("file [{}] does not conform to the '{}' schema", name, DATA_BLOB_PREFIX)__                }_            }_            return generation__        };finds,the,next,available,blob,number,param,blobs,list,of,blobs,in,the,repository,return,next,available,blob,number;protected,long,find,latest,file,name,generation,map,string,blob,meta,data,blobs,long,generation,1,for,string,name,blobs,key,set,if,name,starts,with,continue,name,canonical,name,name,try,long,current,gen,long,parse,long,name,substring,length,character,if,current,gen,generation,generation,current,gen,catch,number,format,exception,e,logger,warn,file,does,not,conform,to,the,schema,name,return,generation
BlobStoreRepository -> Context -> protected long findLatestFileNameGeneration(Map<String, BlobMetaData> blobs);1535139672;Finds the next available blob number__@param blobs list of blobs in the repository_@return next available blob number;protected long findLatestFileNameGeneration(Map<String, BlobMetaData> blobs) {_            long generation = -1__            for (String name : blobs.keySet()) {_                if (!name.startsWith(DATA_BLOB_PREFIX)) {_                    continue__                }_                name = canonicalName(name)__                try {_                    long currentGen = Long.parseLong(name.substring(DATA_BLOB_PREFIX.length()), Character.MAX_RADIX)__                    if (currentGen > generation) {_                        generation = currentGen__                    }_                } catch (NumberFormatException e) {_                    logger.warn("file [{}] does not conform to the '{}' schema", name, DATA_BLOB_PREFIX)__                }_            }_            return generation__        };finds,the,next,available,blob,number,param,blobs,list,of,blobs,in,the,repository,return,next,available,blob,number;protected,long,find,latest,file,name,generation,map,string,blob,meta,data,blobs,long,generation,1,for,string,name,blobs,key,set,if,name,starts,with,continue,name,canonical,name,name,try,long,current,gen,long,parse,long,name,substring,length,character,if,current,gen,generation,generation,current,gen,catch,number,format,exception,e,logger,warn,file,does,not,conform,to,the,schema,name,return,generation
BlobStoreRepository -> Context -> protected long findLatestFileNameGeneration(Map<String, BlobMetaData> blobs);1535723122;Finds the next available blob number__@param blobs list of blobs in the repository_@return next available blob number;protected long findLatestFileNameGeneration(Map<String, BlobMetaData> blobs) {_            long generation = -1__            for (String name : blobs.keySet()) {_                if (!name.startsWith(DATA_BLOB_PREFIX)) {_                    continue__                }_                name = canonicalName(name)__                try {_                    long currentGen = Long.parseLong(name.substring(DATA_BLOB_PREFIX.length()), Character.MAX_RADIX)__                    if (currentGen > generation) {_                        generation = currentGen__                    }_                } catch (NumberFormatException e) {_                    logger.warn("file [{}] does not conform to the '{}' schema", name, DATA_BLOB_PREFIX)__                }_            }_            return generation__        };finds,the,next,available,blob,number,param,blobs,list,of,blobs,in,the,repository,return,next,available,blob,number;protected,long,find,latest,file,name,generation,map,string,blob,meta,data,blobs,long,generation,1,for,string,name,blobs,key,set,if,name,starts,with,continue,name,canonical,name,name,try,long,current,gen,long,parse,long,name,substring,length,character,if,current,gen,generation,generation,current,gen,catch,number,format,exception,e,logger,warn,file,does,not,conform,to,the,schema,name,return,generation
BlobStoreRepository -> Context -> protected long findLatestFileNameGeneration(Map<String, BlobMetaData> blobs);1536314350;Finds the next available blob number__@param blobs list of blobs in the repository_@return next available blob number;protected long findLatestFileNameGeneration(Map<String, BlobMetaData> blobs) {_            long generation = -1__            for (String name : blobs.keySet()) {_                if (!name.startsWith(DATA_BLOB_PREFIX)) {_                    continue__                }_                name = canonicalName(name)__                try {_                    long currentGen = Long.parseLong(name.substring(DATA_BLOB_PREFIX.length()), Character.MAX_RADIX)__                    if (currentGen > generation) {_                        generation = currentGen__                    }_                } catch (NumberFormatException e) {_                    logger.warn("file [{}] does not conform to the '{}' schema", name, DATA_BLOB_PREFIX)__                }_            }_            return generation__        };finds,the,next,available,blob,number,param,blobs,list,of,blobs,in,the,repository,return,next,available,blob,number;protected,long,find,latest,file,name,generation,map,string,blob,meta,data,blobs,long,generation,1,for,string,name,blobs,key,set,if,name,starts,with,continue,name,canonical,name,name,try,long,current,gen,long,parse,long,name,substring,length,character,if,current,gen,generation,generation,current,gen,catch,number,format,exception,e,logger,warn,file,does,not,conform,to,the,schema,name,return,generation
BlobStoreRepository -> Context -> protected long findLatestFileNameGeneration(Map<String, BlobMetaData> blobs);1536828374;Finds the next available blob number__@param blobs list of blobs in the repository_@return next available blob number;protected long findLatestFileNameGeneration(Map<String, BlobMetaData> blobs) {_            long generation = -1__            for (String name : blobs.keySet()) {_                if (!name.startsWith(DATA_BLOB_PREFIX)) {_                    continue__                }_                name = canonicalName(name)__                try {_                    long currentGen = Long.parseLong(name.substring(DATA_BLOB_PREFIX.length()), Character.MAX_RADIX)__                    if (currentGen > generation) {_                        generation = currentGen__                    }_                } catch (NumberFormatException e) {_                    logger.warn("file [{}] does not conform to the '{}' schema", name, DATA_BLOB_PREFIX)__                }_            }_            return generation__        };finds,the,next,available,blob,number,param,blobs,list,of,blobs,in,the,repository,return,next,available,blob,number;protected,long,find,latest,file,name,generation,map,string,blob,meta,data,blobs,long,generation,1,for,string,name,blobs,key,set,if,name,starts,with,continue,name,canonical,name,name,try,long,current,gen,long,parse,long,name,substring,length,character,if,current,gen,generation,generation,current,gen,catch,number,format,exception,e,logger,warn,file,does,not,conform,to,the,schema,name,return,generation
BlobStoreRepository -> Context -> protected long findLatestFileNameGeneration(Map<String, BlobMetaData> blobs);1541008027;Finds the next available blob number__@param blobs list of blobs in the repository_@return next available blob number;protected long findLatestFileNameGeneration(Map<String, BlobMetaData> blobs) {_            long generation = -1__            for (String name : blobs.keySet()) {_                if (!name.startsWith(DATA_BLOB_PREFIX)) {_                    continue__                }_                name = canonicalName(name)__                try {_                    long currentGen = Long.parseLong(name.substring(DATA_BLOB_PREFIX.length()), Character.MAX_RADIX)__                    if (currentGen > generation) {_                        generation = currentGen__                    }_                } catch (NumberFormatException e) {_                    logger.warn("file [{}] does not conform to the '{}' schema", name, DATA_BLOB_PREFIX)__                }_            }_            return generation__        };finds,the,next,available,blob,number,param,blobs,list,of,blobs,in,the,repository,return,next,available,blob,number;protected,long,find,latest,file,name,generation,map,string,blob,meta,data,blobs,long,generation,1,for,string,name,blobs,key,set,if,name,starts,with,continue,name,canonical,name,name,try,long,current,gen,long,parse,long,name,substring,length,character,if,current,gen,generation,generation,current,gen,catch,number,format,exception,e,logger,warn,file,does,not,conform,to,the,schema,name,return,generation
BlobStoreRepository -> Context -> protected long findLatestFileNameGeneration(Map<String, BlobMetaData> blobs);1542646292;Finds the next available blob number__@param blobs list of blobs in the repository_@return next available blob number;protected long findLatestFileNameGeneration(Map<String, BlobMetaData> blobs) {_            long generation = -1__            for (String name : blobs.keySet()) {_                if (!name.startsWith(DATA_BLOB_PREFIX)) {_                    continue__                }_                name = canonicalName(name)__                try {_                    long currentGen = Long.parseLong(name.substring(DATA_BLOB_PREFIX.length()), Character.MAX_RADIX)__                    if (currentGen > generation) {_                        generation = currentGen__                    }_                } catch (NumberFormatException e) {_                    logger.warn("file [{}] does not conform to the '{}' schema", name, DATA_BLOB_PREFIX)__                }_            }_            return generation__        };finds,the,next,available,blob,number,param,blobs,list,of,blobs,in,the,repository,return,next,available,blob,number;protected,long,find,latest,file,name,generation,map,string,blob,meta,data,blobs,long,generation,1,for,string,name,blobs,key,set,if,name,starts,with,continue,name,canonical,name,name,try,long,current,gen,long,parse,long,name,substring,length,character,if,current,gen,generation,generation,current,gen,catch,number,format,exception,e,logger,warn,file,does,not,conform,to,the,schema,name,return,generation
BlobStoreRepository -> Context -> protected long findLatestFileNameGeneration(Map<String, BlobMetaData> blobs);1542980705;Finds the next available blob number__@param blobs list of blobs in the repository_@return next available blob number;protected long findLatestFileNameGeneration(Map<String, BlobMetaData> blobs) {_            long generation = -1__            for (String name : blobs.keySet()) {_                if (!name.startsWith(DATA_BLOB_PREFIX)) {_                    continue__                }_                name = canonicalName(name)__                try {_                    long currentGen = Long.parseLong(name.substring(DATA_BLOB_PREFIX.length()), Character.MAX_RADIX)__                    if (currentGen > generation) {_                        generation = currentGen__                    }_                } catch (NumberFormatException e) {_                    logger.warn("file [{}] does not conform to the '{}' schema", name, DATA_BLOB_PREFIX)__                }_            }_            return generation__        };finds,the,next,available,blob,number,param,blobs,list,of,blobs,in,the,repository,return,next,available,blob,number;protected,long,find,latest,file,name,generation,map,string,blob,meta,data,blobs,long,generation,1,for,string,name,blobs,key,set,if,name,starts,with,continue,name,canonical,name,name,try,long,current,gen,long,parse,long,name,substring,length,character,if,current,gen,generation,generation,current,gen,catch,number,format,exception,e,logger,warn,file,does,not,conform,to,the,schema,name,return,generation
BlobStoreRepository -> Context -> protected long findLatestFileNameGeneration(Map<String, BlobMetaData> blobs);1543831870;Finds the next available blob number__@param blobs list of blobs in the repository_@return next available blob number;protected long findLatestFileNameGeneration(Map<String, BlobMetaData> blobs) {_            long generation = -1__            for (String name : blobs.keySet()) {_                if (!name.startsWith(DATA_BLOB_PREFIX)) {_                    continue__                }_                name = canonicalName(name)__                try {_                    long currentGen = Long.parseLong(name.substring(DATA_BLOB_PREFIX.length()), Character.MAX_RADIX)__                    if (currentGen > generation) {_                        generation = currentGen__                    }_                } catch (NumberFormatException e) {_                    logger.warn("file [{}] does not conform to the '{}' schema", name, DATA_BLOB_PREFIX)__                }_            }_            return generation__        };finds,the,next,available,blob,number,param,blobs,list,of,blobs,in,the,repository,return,next,available,blob,number;protected,long,find,latest,file,name,generation,map,string,blob,meta,data,blobs,long,generation,1,for,string,name,blobs,key,set,if,name,starts,with,continue,name,canonical,name,name,try,long,current,gen,long,parse,long,name,substring,length,character,if,current,gen,generation,generation,current,gen,catch,number,format,exception,e,logger,warn,file,does,not,conform,to,the,schema,name,return,generation
BlobStoreRepository -> Context -> protected long findLatestFileNameGeneration(Map<String, BlobMetaData> blobs);1543942400;Finds the next available blob number__@param blobs list of blobs in the repository_@return next available blob number;protected long findLatestFileNameGeneration(Map<String, BlobMetaData> blobs) {_            long generation = -1__            for (String name : blobs.keySet()) {_                if (!name.startsWith(DATA_BLOB_PREFIX)) {_                    continue__                }_                name = canonicalName(name)__                try {_                    long currentGen = Long.parseLong(name.substring(DATA_BLOB_PREFIX.length()), Character.MAX_RADIX)__                    if (currentGen > generation) {_                        generation = currentGen__                    }_                } catch (NumberFormatException e) {_                    logger.warn("file [{}] does not conform to the '{}' schema", name, DATA_BLOB_PREFIX)__                }_            }_            return generation__        };finds,the,next,available,blob,number,param,blobs,list,of,blobs,in,the,repository,return,next,available,blob,number;protected,long,find,latest,file,name,generation,map,string,blob,meta,data,blobs,long,generation,1,for,string,name,blobs,key,set,if,name,starts,with,continue,name,canonical,name,name,try,long,current,gen,long,parse,long,name,substring,length,character,if,current,gen,generation,generation,current,gen,catch,number,format,exception,e,logger,warn,file,does,not,conform,to,the,schema,name,return,generation
BlobStoreRepository -> Context -> protected long findLatestFileNameGeneration(Map<String, BlobMetaData> blobs);1546974294;Finds the next available blob number__@param blobs list of blobs in the repository_@return next available blob number;protected long findLatestFileNameGeneration(Map<String, BlobMetaData> blobs) {_            long generation = -1__            for (String name : blobs.keySet()) {_                if (!name.startsWith(DATA_BLOB_PREFIX)) {_                    continue__                }_                name = canonicalName(name)__                try {_                    long currentGen = Long.parseLong(name.substring(DATA_BLOB_PREFIX.length()), Character.MAX_RADIX)__                    if (currentGen > generation) {_                        generation = currentGen__                    }_                } catch (NumberFormatException e) {_                    logger.warn("file [{}] does not conform to the '{}' schema", name, DATA_BLOB_PREFIX)__                }_            }_            return generation__        };finds,the,next,available,blob,number,param,blobs,list,of,blobs,in,the,repository,return,next,available,blob,number;protected,long,find,latest,file,name,generation,map,string,blob,meta,data,blobs,long,generation,1,for,string,name,blobs,key,set,if,name,starts,with,continue,name,canonical,name,name,try,long,current,gen,long,parse,long,name,substring,length,character,if,current,gen,generation,generation,current,gen,catch,number,format,exception,e,logger,warn,file,does,not,conform,to,the,schema,name,return,generation
BlobStoreRepository -> Context -> protected long findLatestFileNameGeneration(Map<String, BlobMetaData> blobs);1547496475;Finds the next available blob number__@param blobs list of blobs in the repository_@return next available blob number;protected long findLatestFileNameGeneration(Map<String, BlobMetaData> blobs) {_            long generation = -1__            for (String name : blobs.keySet()) {_                if (!name.startsWith(DATA_BLOB_PREFIX)) {_                    continue__                }_                name = canonicalName(name)__                try {_                    long currentGen = Long.parseLong(name.substring(DATA_BLOB_PREFIX.length()), Character.MAX_RADIX)__                    if (currentGen > generation) {_                        generation = currentGen__                    }_                } catch (NumberFormatException e) {_                    logger.warn("file [{}] does not conform to the '{}' schema", name, DATA_BLOB_PREFIX)__                }_            }_            return generation__        };finds,the,next,available,blob,number,param,blobs,list,of,blobs,in,the,repository,return,next,available,blob,number;protected,long,find,latest,file,name,generation,map,string,blob,meta,data,blobs,long,generation,1,for,string,name,blobs,key,set,if,name,starts,with,continue,name,canonical,name,name,try,long,current,gen,long,parse,long,name,substring,length,character,if,current,gen,generation,generation,current,gen,catch,number,format,exception,e,logger,warn,file,does,not,conform,to,the,schema,name,return,generation
BlobStoreRepository -> Context -> protected long findLatestFileNameGeneration(Map<String, BlobMetaData> blobs);1547625930;Finds the next available blob number__@param blobs list of blobs in the repository_@return next available blob number;protected long findLatestFileNameGeneration(Map<String, BlobMetaData> blobs) {_            long generation = -1__            for (String name : blobs.keySet()) {_                if (!name.startsWith(DATA_BLOB_PREFIX)) {_                    continue__                }_                name = canonicalName(name)__                try {_                    long currentGen = Long.parseLong(name.substring(DATA_BLOB_PREFIX.length()), Character.MAX_RADIX)__                    if (currentGen > generation) {_                        generation = currentGen__                    }_                } catch (NumberFormatException e) {_                    logger.warn("file [{}] does not conform to the '{}' schema", name, DATA_BLOB_PREFIX)__                }_            }_            return generation__        };finds,the,next,available,blob,number,param,blobs,list,of,blobs,in,the,repository,return,next,available,blob,number;protected,long,find,latest,file,name,generation,map,string,blob,meta,data,blobs,long,generation,1,for,string,name,blobs,key,set,if,name,starts,with,continue,name,canonical,name,name,try,long,current,gen,long,parse,long,name,substring,length,character,if,current,gen,generation,generation,current,gen,catch,number,format,exception,e,logger,warn,file,does,not,conform,to,the,schema,name,return,generation
BlobStoreRepository -> Context -> protected long findLatestFileNameGeneration(Map<String, BlobMetaData> blobs);1550647627;Finds the next available blob number__@param blobs list of blobs in the repository_@return next available blob number;protected long findLatestFileNameGeneration(Map<String, BlobMetaData> blobs) {_            long generation = -1__            for (String name : blobs.keySet()) {_                if (!name.startsWith(DATA_BLOB_PREFIX)) {_                    continue__                }_                name = canonicalName(name)__                try {_                    long currentGen = Long.parseLong(name.substring(DATA_BLOB_PREFIX.length()), Character.MAX_RADIX)__                    if (currentGen > generation) {_                        generation = currentGen__                    }_                } catch (NumberFormatException e) {_                    logger.warn("file [{}] does not conform to the '{}' schema", name, DATA_BLOB_PREFIX)__                }_            }_            return generation__        };finds,the,next,available,blob,number,param,blobs,list,of,blobs,in,the,repository,return,next,available,blob,number;protected,long,find,latest,file,name,generation,map,string,blob,meta,data,blobs,long,generation,1,for,string,name,blobs,key,set,if,name,starts,with,continue,name,canonical,name,name,try,long,current,gen,long,parse,long,name,substring,length,character,if,current,gen,generation,generation,current,gen,catch,number,format,exception,e,logger,warn,file,does,not,conform,to,the,schema,name,return,generation
BlobStoreRepository -> protected BlobStoreRepository(RepositoryMetaData metadata, Settings globalSettings, NamedXContentRegistry namedXContentRegistry);1524684173;Constructs new BlobStoreRepository__@param metadata       The metadata for this repository including name and settings_@param globalSettings Settings for the node this repository object is created on;protected BlobStoreRepository(RepositoryMetaData metadata, Settings globalSettings, NamedXContentRegistry namedXContentRegistry) {_        super(globalSettings)__        this.metadata = metadata__        this.namedXContentRegistry = namedXContentRegistry__        snapshotRateLimiter = getRateLimiter(metadata.settings(), "max_snapshot_bytes_per_sec", new ByteSizeValue(40, ByteSizeUnit.MB))__        restoreRateLimiter = getRateLimiter(metadata.settings(), "max_restore_bytes_per_sec", new ByteSizeValue(40, ByteSizeUnit.MB))__        readOnly = metadata.settings().getAsBoolean("readonly", false)___        indexShardSnapshotFormat = new ChecksumBlobStoreFormat<>(SNAPSHOT_CODEC, SNAPSHOT_NAME_FORMAT,_            BlobStoreIndexShardSnapshot::fromXContent, namedXContentRegistry, isCompress())__        indexShardSnapshotsFormat = new ChecksumBlobStoreFormat<>(SNAPSHOT_INDEX_CODEC, SNAPSHOT_INDEX_NAME_FORMAT,_            BlobStoreIndexShardSnapshots::fromXContent, namedXContentRegistry, isCompress())__        ByteSizeValue chunkSize = chunkSize()__        if (chunkSize != null && chunkSize.getBytes() <= 0) {_            throw new IllegalArgumentException("the chunk size cannot be negative: [" + chunkSize + "]")__        }_    };constructs,new,blob,store,repository,param,metadata,the,metadata,for,this,repository,including,name,and,settings,param,global,settings,settings,for,the,node,this,repository,object,is,created,on;protected,blob,store,repository,repository,meta,data,metadata,settings,global,settings,named,xcontent,registry,named,xcontent,registry,super,global,settings,this,metadata,metadata,this,named,xcontent,registry,named,xcontent,registry,snapshot,rate,limiter,get,rate,limiter,metadata,settings,new,byte,size,value,40,byte,size,unit,mb,restore,rate,limiter,get,rate,limiter,metadata,settings,new,byte,size,value,40,byte,size,unit,mb,read,only,metadata,settings,get,as,boolean,readonly,false,index,shard,snapshot,format,new,checksum,blob,store,format,blob,store,index,shard,snapshot,from,xcontent,named,xcontent,registry,is,compress,index,shard,snapshots,format,new,checksum,blob,store,format,blob,store,index,shard,snapshots,from,xcontent,named,xcontent,registry,is,compress,byte,size,value,chunk,size,chunk,size,if,chunk,size,null,chunk,size,get,bytes,0,throw,new,illegal,argument,exception,the,chunk,size,cannot,be,negative,chunk,size
BlobStoreRepository -> protected BlobStoreRepository(RepositoryMetaData metadata, Settings globalSettings, NamedXContentRegistry namedXContentRegistry);1525334055;Constructs new BlobStoreRepository__@param metadata       The metadata for this repository including name and settings_@param globalSettings Settings for the node this repository object is created on;protected BlobStoreRepository(RepositoryMetaData metadata, Settings globalSettings, NamedXContentRegistry namedXContentRegistry) {_        super(globalSettings)__        this.metadata = metadata__        this.namedXContentRegistry = namedXContentRegistry__        snapshotRateLimiter = getRateLimiter(metadata.settings(), "max_snapshot_bytes_per_sec", new ByteSizeValue(40, ByteSizeUnit.MB))__        restoreRateLimiter = getRateLimiter(metadata.settings(), "max_restore_bytes_per_sec", new ByteSizeValue(40, ByteSizeUnit.MB))__        readOnly = metadata.settings().getAsBoolean("readonly", false)___        indexShardSnapshotFormat = new ChecksumBlobStoreFormat<>(SNAPSHOT_CODEC, SNAPSHOT_NAME_FORMAT,_            BlobStoreIndexShardSnapshot::fromXContent, namedXContentRegistry, isCompress())__        indexShardSnapshotsFormat = new ChecksumBlobStoreFormat<>(SNAPSHOT_INDEX_CODEC, SNAPSHOT_INDEX_NAME_FORMAT,_            BlobStoreIndexShardSnapshots::fromXContent, namedXContentRegistry, isCompress())__        ByteSizeValue chunkSize = chunkSize()__        if (chunkSize != null && chunkSize.getBytes() <= 0) {_            throw new IllegalArgumentException("the chunk size cannot be negative: [" + chunkSize + "]")__        }_    };constructs,new,blob,store,repository,param,metadata,the,metadata,for,this,repository,including,name,and,settings,param,global,settings,settings,for,the,node,this,repository,object,is,created,on;protected,blob,store,repository,repository,meta,data,metadata,settings,global,settings,named,xcontent,registry,named,xcontent,registry,super,global,settings,this,metadata,metadata,this,named,xcontent,registry,named,xcontent,registry,snapshot,rate,limiter,get,rate,limiter,metadata,settings,new,byte,size,value,40,byte,size,unit,mb,restore,rate,limiter,get,rate,limiter,metadata,settings,new,byte,size,value,40,byte,size,unit,mb,read,only,metadata,settings,get,as,boolean,readonly,false,index,shard,snapshot,format,new,checksum,blob,store,format,blob,store,index,shard,snapshot,from,xcontent,named,xcontent,registry,is,compress,index,shard,snapshots,format,new,checksum,blob,store,format,blob,store,index,shard,snapshots,from,xcontent,named,xcontent,registry,is,compress,byte,size,value,chunk,size,chunk,size,if,chunk,size,null,chunk,size,get,bytes,0,throw,new,illegal,argument,exception,the,chunk,size,cannot,be,negative,chunk,size
BlobStoreRepository -> protected BlobStoreRepository(RepositoryMetaData metadata, Settings globalSettings, NamedXContentRegistry namedXContentRegistry);1525798020;Constructs new BlobStoreRepository__@param metadata       The metadata for this repository including name and settings_@param globalSettings Settings for the node this repository object is created on;protected BlobStoreRepository(RepositoryMetaData metadata, Settings globalSettings, NamedXContentRegistry namedXContentRegistry) {_        super(globalSettings)__        this.metadata = metadata__        this.namedXContentRegistry = namedXContentRegistry__        snapshotRateLimiter = getRateLimiter(metadata.settings(), "max_snapshot_bytes_per_sec", new ByteSizeValue(40, ByteSizeUnit.MB))__        restoreRateLimiter = getRateLimiter(metadata.settings(), "max_restore_bytes_per_sec", new ByteSizeValue(40, ByteSizeUnit.MB))__        readOnly = metadata.settings().getAsBoolean("readonly", false)___        indexShardSnapshotFormat = new ChecksumBlobStoreFormat<>(SNAPSHOT_CODEC, SNAPSHOT_NAME_FORMAT,_            BlobStoreIndexShardSnapshot::fromXContent, namedXContentRegistry, isCompress())__        indexShardSnapshotsFormat = new ChecksumBlobStoreFormat<>(SNAPSHOT_INDEX_CODEC, SNAPSHOT_INDEX_NAME_FORMAT,_            BlobStoreIndexShardSnapshots::fromXContent, namedXContentRegistry, isCompress())__        ByteSizeValue chunkSize = chunkSize()__        if (chunkSize != null && chunkSize.getBytes() <= 0) {_            throw new IllegalArgumentException("the chunk size cannot be negative: [" + chunkSize + "]")__        }_    };constructs,new,blob,store,repository,param,metadata,the,metadata,for,this,repository,including,name,and,settings,param,global,settings,settings,for,the,node,this,repository,object,is,created,on;protected,blob,store,repository,repository,meta,data,metadata,settings,global,settings,named,xcontent,registry,named,xcontent,registry,super,global,settings,this,metadata,metadata,this,named,xcontent,registry,named,xcontent,registry,snapshot,rate,limiter,get,rate,limiter,metadata,settings,new,byte,size,value,40,byte,size,unit,mb,restore,rate,limiter,get,rate,limiter,metadata,settings,new,byte,size,value,40,byte,size,unit,mb,read,only,metadata,settings,get,as,boolean,readonly,false,index,shard,snapshot,format,new,checksum,blob,store,format,blob,store,index,shard,snapshot,from,xcontent,named,xcontent,registry,is,compress,index,shard,snapshots,format,new,checksum,blob,store,format,blob,store,index,shard,snapshots,from,xcontent,named,xcontent,registry,is,compress,byte,size,value,chunk,size,chunk,size,if,chunk,size,null,chunk,size,get,bytes,0,throw,new,illegal,argument,exception,the,chunk,size,cannot,be,negative,chunk,size
BlobStoreRepository -> protected BlobStoreRepository(RepositoryMetaData metadata, Settings globalSettings, NamedXContentRegistry namedXContentRegistry);1526289033;Constructs new BlobStoreRepository__@param metadata       The metadata for this repository including name and settings_@param globalSettings Settings for the node this repository object is created on;protected BlobStoreRepository(RepositoryMetaData metadata, Settings globalSettings, NamedXContentRegistry namedXContentRegistry) {_        super(globalSettings)__        this.metadata = metadata__        this.namedXContentRegistry = namedXContentRegistry__        snapshotRateLimiter = getRateLimiter(metadata.settings(), "max_snapshot_bytes_per_sec", new ByteSizeValue(40, ByteSizeUnit.MB))__        restoreRateLimiter = getRateLimiter(metadata.settings(), "max_restore_bytes_per_sec", new ByteSizeValue(40, ByteSizeUnit.MB))__        readOnly = metadata.settings().getAsBoolean("readonly", false)___        indexShardSnapshotFormat = new ChecksumBlobStoreFormat<>(SNAPSHOT_CODEC, SNAPSHOT_NAME_FORMAT,_            BlobStoreIndexShardSnapshot::fromXContent, namedXContentRegistry, isCompress())__        indexShardSnapshotsFormat = new ChecksumBlobStoreFormat<>(SNAPSHOT_INDEX_CODEC, SNAPSHOT_INDEX_NAME_FORMAT,_            BlobStoreIndexShardSnapshots::fromXContent, namedXContentRegistry, isCompress())__        ByteSizeValue chunkSize = chunkSize()__        if (chunkSize != null && chunkSize.getBytes() <= 0) {_            throw new IllegalArgumentException("the chunk size cannot be negative: [" + chunkSize + "]")__        }_    };constructs,new,blob,store,repository,param,metadata,the,metadata,for,this,repository,including,name,and,settings,param,global,settings,settings,for,the,node,this,repository,object,is,created,on;protected,blob,store,repository,repository,meta,data,metadata,settings,global,settings,named,xcontent,registry,named,xcontent,registry,super,global,settings,this,metadata,metadata,this,named,xcontent,registry,named,xcontent,registry,snapshot,rate,limiter,get,rate,limiter,metadata,settings,new,byte,size,value,40,byte,size,unit,mb,restore,rate,limiter,get,rate,limiter,metadata,settings,new,byte,size,value,40,byte,size,unit,mb,read,only,metadata,settings,get,as,boolean,readonly,false,index,shard,snapshot,format,new,checksum,blob,store,format,blob,store,index,shard,snapshot,from,xcontent,named,xcontent,registry,is,compress,index,shard,snapshots,format,new,checksum,blob,store,format,blob,store,index,shard,snapshots,from,xcontent,named,xcontent,registry,is,compress,byte,size,value,chunk,size,chunk,size,if,chunk,size,null,chunk,size,get,bytes,0,throw,new,illegal,argument,exception,the,chunk,size,cannot,be,negative,chunk,size
BlobStoreRepository -> protected BlobStoreRepository(RepositoryMetaData metadata, Settings globalSettings, NamedXContentRegistry namedXContentRegistry);1526574077;Constructs new BlobStoreRepository__@param metadata       The metadata for this repository including name and settings_@param globalSettings Settings for the node this repository object is created on;protected BlobStoreRepository(RepositoryMetaData metadata, Settings globalSettings, NamedXContentRegistry namedXContentRegistry) {_        super(globalSettings)__        this.metadata = metadata__        this.namedXContentRegistry = namedXContentRegistry__        snapshotRateLimiter = getRateLimiter(metadata.settings(), "max_snapshot_bytes_per_sec", new ByteSizeValue(40, ByteSizeUnit.MB))__        restoreRateLimiter = getRateLimiter(metadata.settings(), "max_restore_bytes_per_sec", new ByteSizeValue(40, ByteSizeUnit.MB))__        readOnly = metadata.settings().getAsBoolean("readonly", false)___        indexShardSnapshotFormat = new ChecksumBlobStoreFormat<>(SNAPSHOT_CODEC, SNAPSHOT_NAME_FORMAT,_            BlobStoreIndexShardSnapshot::fromXContent, namedXContentRegistry, isCompress())__        indexShardSnapshotsFormat = new ChecksumBlobStoreFormat<>(SNAPSHOT_INDEX_CODEC, SNAPSHOT_INDEX_NAME_FORMAT,_            BlobStoreIndexShardSnapshots::fromXContent, namedXContentRegistry, isCompress())__        ByteSizeValue chunkSize = chunkSize()__        if (chunkSize != null && chunkSize.getBytes() <= 0) {_            throw new IllegalArgumentException("the chunk size cannot be negative: [" + chunkSize + "]")__        }_    };constructs,new,blob,store,repository,param,metadata,the,metadata,for,this,repository,including,name,and,settings,param,global,settings,settings,for,the,node,this,repository,object,is,created,on;protected,blob,store,repository,repository,meta,data,metadata,settings,global,settings,named,xcontent,registry,named,xcontent,registry,super,global,settings,this,metadata,metadata,this,named,xcontent,registry,named,xcontent,registry,snapshot,rate,limiter,get,rate,limiter,metadata,settings,new,byte,size,value,40,byte,size,unit,mb,restore,rate,limiter,get,rate,limiter,metadata,settings,new,byte,size,value,40,byte,size,unit,mb,read,only,metadata,settings,get,as,boolean,readonly,false,index,shard,snapshot,format,new,checksum,blob,store,format,blob,store,index,shard,snapshot,from,xcontent,named,xcontent,registry,is,compress,index,shard,snapshots,format,new,checksum,blob,store,format,blob,store,index,shard,snapshots,from,xcontent,named,xcontent,registry,is,compress,byte,size,value,chunk,size,chunk,size,if,chunk,size,null,chunk,size,get,bytes,0,throw,new,illegal,argument,exception,the,chunk,size,cannot,be,negative,chunk,size
BlobStoreRepository -> protected BlobStoreRepository(RepositoryMetaData metadata, Settings globalSettings, NamedXContentRegistry namedXContentRegistry);1527583663;Constructs new BlobStoreRepository__@param metadata       The metadata for this repository including name and settings_@param globalSettings Settings for the node this repository object is created on;protected BlobStoreRepository(RepositoryMetaData metadata, Settings globalSettings, NamedXContentRegistry namedXContentRegistry) {_        super(globalSettings)__        this.metadata = metadata__        this.namedXContentRegistry = namedXContentRegistry__        snapshotRateLimiter = getRateLimiter(metadata.settings(), "max_snapshot_bytes_per_sec", new ByteSizeValue(40, ByteSizeUnit.MB))__        restoreRateLimiter = getRateLimiter(metadata.settings(), "max_restore_bytes_per_sec", new ByteSizeValue(40, ByteSizeUnit.MB))__        readOnly = metadata.settings().getAsBoolean("readonly", false)___        indexShardSnapshotFormat = new ChecksumBlobStoreFormat<>(SNAPSHOT_CODEC, SNAPSHOT_NAME_FORMAT,_            BlobStoreIndexShardSnapshot::fromXContent, namedXContentRegistry, isCompress())__        indexShardSnapshotsFormat = new ChecksumBlobStoreFormat<>(SNAPSHOT_INDEX_CODEC, SNAPSHOT_INDEX_NAME_FORMAT,_            BlobStoreIndexShardSnapshots::fromXContent, namedXContentRegistry, isCompress())__        ByteSizeValue chunkSize = chunkSize()__        if (chunkSize != null && chunkSize.getBytes() <= 0) {_            throw new IllegalArgumentException("the chunk size cannot be negative: [" + chunkSize + "]")__        }_    };constructs,new,blob,store,repository,param,metadata,the,metadata,for,this,repository,including,name,and,settings,param,global,settings,settings,for,the,node,this,repository,object,is,created,on;protected,blob,store,repository,repository,meta,data,metadata,settings,global,settings,named,xcontent,registry,named,xcontent,registry,super,global,settings,this,metadata,metadata,this,named,xcontent,registry,named,xcontent,registry,snapshot,rate,limiter,get,rate,limiter,metadata,settings,new,byte,size,value,40,byte,size,unit,mb,restore,rate,limiter,get,rate,limiter,metadata,settings,new,byte,size,value,40,byte,size,unit,mb,read,only,metadata,settings,get,as,boolean,readonly,false,index,shard,snapshot,format,new,checksum,blob,store,format,blob,store,index,shard,snapshot,from,xcontent,named,xcontent,registry,is,compress,index,shard,snapshots,format,new,checksum,blob,store,format,blob,store,index,shard,snapshots,from,xcontent,named,xcontent,registry,is,compress,byte,size,value,chunk,size,chunk,size,if,chunk,size,null,chunk,size,get,bytes,0,throw,new,illegal,argument,exception,the,chunk,size,cannot,be,negative,chunk,size
BlobStoreRepository -> protected BlobStoreRepository(RepositoryMetaData metadata, Settings globalSettings, NamedXContentRegistry namedXContentRegistry);1528211342;Constructs new BlobStoreRepository__@param metadata       The metadata for this repository including name and settings_@param globalSettings Settings for the node this repository object is created on;protected BlobStoreRepository(RepositoryMetaData metadata, Settings globalSettings, NamedXContentRegistry namedXContentRegistry) {_        super(globalSettings)__        this.metadata = metadata__        this.namedXContentRegistry = namedXContentRegistry__        snapshotRateLimiter = getRateLimiter(metadata.settings(), "max_snapshot_bytes_per_sec", new ByteSizeValue(40, ByteSizeUnit.MB))__        restoreRateLimiter = getRateLimiter(metadata.settings(), "max_restore_bytes_per_sec", new ByteSizeValue(40, ByteSizeUnit.MB))__        readOnly = metadata.settings().getAsBoolean("readonly", false)___        indexShardSnapshotFormat = new ChecksumBlobStoreFormat<>(SNAPSHOT_CODEC, SNAPSHOT_NAME_FORMAT,_            BlobStoreIndexShardSnapshot::fromXContent, namedXContentRegistry, isCompress())__        indexShardSnapshotsFormat = new ChecksumBlobStoreFormat<>(SNAPSHOT_INDEX_CODEC, SNAPSHOT_INDEX_NAME_FORMAT,_            BlobStoreIndexShardSnapshots::fromXContent, namedXContentRegistry, isCompress())__        ByteSizeValue chunkSize = chunkSize()__        if (chunkSize != null && chunkSize.getBytes() <= 0) {_            throw new IllegalArgumentException("the chunk size cannot be negative: [" + chunkSize + "]")__        }_    };constructs,new,blob,store,repository,param,metadata,the,metadata,for,this,repository,including,name,and,settings,param,global,settings,settings,for,the,node,this,repository,object,is,created,on;protected,blob,store,repository,repository,meta,data,metadata,settings,global,settings,named,xcontent,registry,named,xcontent,registry,super,global,settings,this,metadata,metadata,this,named,xcontent,registry,named,xcontent,registry,snapshot,rate,limiter,get,rate,limiter,metadata,settings,new,byte,size,value,40,byte,size,unit,mb,restore,rate,limiter,get,rate,limiter,metadata,settings,new,byte,size,value,40,byte,size,unit,mb,read,only,metadata,settings,get,as,boolean,readonly,false,index,shard,snapshot,format,new,checksum,blob,store,format,blob,store,index,shard,snapshot,from,xcontent,named,xcontent,registry,is,compress,index,shard,snapshots,format,new,checksum,blob,store,format,blob,store,index,shard,snapshots,from,xcontent,named,xcontent,registry,is,compress,byte,size,value,chunk,size,chunk,size,if,chunk,size,null,chunk,size,get,bytes,0,throw,new,illegal,argument,exception,the,chunk,size,cannot,be,negative,chunk,size
BlobStoreRepository -> protected BlobStoreRepository(RepositoryMetaData metadata, Settings globalSettings, NamedXContentRegistry namedXContentRegistry);1531179852;Constructs new BlobStoreRepository__@param metadata       The metadata for this repository including name and settings_@param globalSettings Settings for the node this repository object is created on;protected BlobStoreRepository(RepositoryMetaData metadata, Settings globalSettings, NamedXContentRegistry namedXContentRegistry) {_        super(globalSettings)__        this.metadata = metadata__        this.namedXContentRegistry = namedXContentRegistry__        snapshotRateLimiter = getRateLimiter(metadata.settings(), "max_snapshot_bytes_per_sec", new ByteSizeValue(40, ByteSizeUnit.MB))__        restoreRateLimiter = getRateLimiter(metadata.settings(), "max_restore_bytes_per_sec", new ByteSizeValue(40, ByteSizeUnit.MB))__        readOnly = metadata.settings().getAsBoolean("readonly", false)___        indexShardSnapshotFormat = new ChecksumBlobStoreFormat<>(SNAPSHOT_CODEC, SNAPSHOT_NAME_FORMAT,_            BlobStoreIndexShardSnapshot::fromXContent, namedXContentRegistry, isCompress())__        indexShardSnapshotsFormat = new ChecksumBlobStoreFormat<>(SNAPSHOT_INDEX_CODEC, SNAPSHOT_INDEX_NAME_FORMAT,_            BlobStoreIndexShardSnapshots::fromXContent, namedXContentRegistry, isCompress())__        ByteSizeValue chunkSize = chunkSize()__        if (chunkSize != null && chunkSize.getBytes() <= 0) {_            throw new IllegalArgumentException("the chunk size cannot be negative: [" + chunkSize + "]")__        }_    };constructs,new,blob,store,repository,param,metadata,the,metadata,for,this,repository,including,name,and,settings,param,global,settings,settings,for,the,node,this,repository,object,is,created,on;protected,blob,store,repository,repository,meta,data,metadata,settings,global,settings,named,xcontent,registry,named,xcontent,registry,super,global,settings,this,metadata,metadata,this,named,xcontent,registry,named,xcontent,registry,snapshot,rate,limiter,get,rate,limiter,metadata,settings,new,byte,size,value,40,byte,size,unit,mb,restore,rate,limiter,get,rate,limiter,metadata,settings,new,byte,size,value,40,byte,size,unit,mb,read,only,metadata,settings,get,as,boolean,readonly,false,index,shard,snapshot,format,new,checksum,blob,store,format,blob,store,index,shard,snapshot,from,xcontent,named,xcontent,registry,is,compress,index,shard,snapshots,format,new,checksum,blob,store,format,blob,store,index,shard,snapshots,from,xcontent,named,xcontent,registry,is,compress,byte,size,value,chunk,size,chunk,size,if,chunk,size,null,chunk,size,get,bytes,0,throw,new,illegal,argument,exception,the,chunk,size,cannot,be,negative,chunk,size
BlobStoreRepository -> protected BlobStoreRepository(RepositoryMetaData metadata, Settings globalSettings, NamedXContentRegistry namedXContentRegistry);1531729807;Constructs new BlobStoreRepository__@param metadata       The metadata for this repository including name and settings_@param globalSettings Settings for the node this repository object is created on;protected BlobStoreRepository(RepositoryMetaData metadata, Settings globalSettings, NamedXContentRegistry namedXContentRegistry) {_        super(globalSettings)__        this.metadata = metadata__        this.namedXContentRegistry = namedXContentRegistry__        snapshotRateLimiter = getRateLimiter(metadata.settings(), "max_snapshot_bytes_per_sec", new ByteSizeValue(40, ByteSizeUnit.MB))__        restoreRateLimiter = getRateLimiter(metadata.settings(), "max_restore_bytes_per_sec", new ByteSizeValue(40, ByteSizeUnit.MB))__        readOnly = metadata.settings().getAsBoolean("readonly", false)___        indexShardSnapshotFormat = new ChecksumBlobStoreFormat<>(SNAPSHOT_CODEC, SNAPSHOT_NAME_FORMAT,_            BlobStoreIndexShardSnapshot::fromXContent, namedXContentRegistry, isCompress())__        indexShardSnapshotsFormat = new ChecksumBlobStoreFormat<>(SNAPSHOT_INDEX_CODEC, SNAPSHOT_INDEX_NAME_FORMAT,_            BlobStoreIndexShardSnapshots::fromXContent, namedXContentRegistry, isCompress())__        ByteSizeValue chunkSize = chunkSize()__        if (chunkSize != null && chunkSize.getBytes() <= 0) {_            throw new IllegalArgumentException("the chunk size cannot be negative: [" + chunkSize + "]")__        }_    };constructs,new,blob,store,repository,param,metadata,the,metadata,for,this,repository,including,name,and,settings,param,global,settings,settings,for,the,node,this,repository,object,is,created,on;protected,blob,store,repository,repository,meta,data,metadata,settings,global,settings,named,xcontent,registry,named,xcontent,registry,super,global,settings,this,metadata,metadata,this,named,xcontent,registry,named,xcontent,registry,snapshot,rate,limiter,get,rate,limiter,metadata,settings,new,byte,size,value,40,byte,size,unit,mb,restore,rate,limiter,get,rate,limiter,metadata,settings,new,byte,size,value,40,byte,size,unit,mb,read,only,metadata,settings,get,as,boolean,readonly,false,index,shard,snapshot,format,new,checksum,blob,store,format,blob,store,index,shard,snapshot,from,xcontent,named,xcontent,registry,is,compress,index,shard,snapshots,format,new,checksum,blob,store,format,blob,store,index,shard,snapshots,from,xcontent,named,xcontent,registry,is,compress,byte,size,value,chunk,size,chunk,size,if,chunk,size,null,chunk,size,get,bytes,0,throw,new,illegal,argument,exception,the,chunk,size,cannot,be,negative,chunk,size
BlobStoreRepository -> protected BlobStoreRepository(RepositoryMetaData metadata, Settings globalSettings, NamedXContentRegistry namedXContentRegistry);1532685069;Constructs new BlobStoreRepository__@param metadata       The metadata for this repository including name and settings_@param globalSettings Settings for the node this repository object is created on;protected BlobStoreRepository(RepositoryMetaData metadata, Settings globalSettings, NamedXContentRegistry namedXContentRegistry) {_        super(globalSettings)__        this.metadata = metadata__        this.namedXContentRegistry = namedXContentRegistry__        snapshotRateLimiter = getRateLimiter(metadata.settings(), "max_snapshot_bytes_per_sec", new ByteSizeValue(40, ByteSizeUnit.MB))__        restoreRateLimiter = getRateLimiter(metadata.settings(), "max_restore_bytes_per_sec", new ByteSizeValue(40, ByteSizeUnit.MB))__        readOnly = metadata.settings().getAsBoolean("readonly", false)___        indexShardSnapshotFormat = new ChecksumBlobStoreFormat<>(SNAPSHOT_CODEC, SNAPSHOT_NAME_FORMAT,_            BlobStoreIndexShardSnapshot::fromXContent, namedXContentRegistry, isCompress())__        indexShardSnapshotsFormat = new ChecksumBlobStoreFormat<>(SNAPSHOT_INDEX_CODEC, SNAPSHOT_INDEX_NAME_FORMAT,_            BlobStoreIndexShardSnapshots::fromXContent, namedXContentRegistry, isCompress())__        ByteSizeValue chunkSize = chunkSize()__        if (chunkSize != null && chunkSize.getBytes() <= 0) {_            throw new IllegalArgumentException("the chunk size cannot be negative: [" + chunkSize + "]")__        }_    };constructs,new,blob,store,repository,param,metadata,the,metadata,for,this,repository,including,name,and,settings,param,global,settings,settings,for,the,node,this,repository,object,is,created,on;protected,blob,store,repository,repository,meta,data,metadata,settings,global,settings,named,xcontent,registry,named,xcontent,registry,super,global,settings,this,metadata,metadata,this,named,xcontent,registry,named,xcontent,registry,snapshot,rate,limiter,get,rate,limiter,metadata,settings,new,byte,size,value,40,byte,size,unit,mb,restore,rate,limiter,get,rate,limiter,metadata,settings,new,byte,size,value,40,byte,size,unit,mb,read,only,metadata,settings,get,as,boolean,readonly,false,index,shard,snapshot,format,new,checksum,blob,store,format,blob,store,index,shard,snapshot,from,xcontent,named,xcontent,registry,is,compress,index,shard,snapshots,format,new,checksum,blob,store,format,blob,store,index,shard,snapshots,from,xcontent,named,xcontent,registry,is,compress,byte,size,value,chunk,size,chunk,size,if,chunk,size,null,chunk,size,get,bytes,0,throw,new,illegal,argument,exception,the,chunk,size,cannot,be,negative,chunk,size
BlobStoreRepository -> protected BlobStoreRepository(RepositoryMetaData metadata, Settings globalSettings, NamedXContentRegistry namedXContentRegistry);1535139672;Constructs new BlobStoreRepository__@param metadata       The metadata for this repository including name and settings_@param globalSettings Settings for the node this repository object is created on;protected BlobStoreRepository(RepositoryMetaData metadata, Settings globalSettings, NamedXContentRegistry namedXContentRegistry) {_        super(globalSettings)__        this.metadata = metadata__        this.namedXContentRegistry = namedXContentRegistry__        snapshotRateLimiter = getRateLimiter(metadata.settings(), "max_snapshot_bytes_per_sec", new ByteSizeValue(40, ByteSizeUnit.MB))__        restoreRateLimiter = getRateLimiter(metadata.settings(), "max_restore_bytes_per_sec", new ByteSizeValue(40, ByteSizeUnit.MB))__        readOnly = metadata.settings().getAsBoolean("readonly", false)___        indexShardSnapshotFormat = new ChecksumBlobStoreFormat<>(SNAPSHOT_CODEC, SNAPSHOT_NAME_FORMAT,_            BlobStoreIndexShardSnapshot::fromXContent, namedXContentRegistry, isCompress())__        indexShardSnapshotsFormat = new ChecksumBlobStoreFormat<>(SNAPSHOT_INDEX_CODEC, SNAPSHOT_INDEX_NAME_FORMAT,_            BlobStoreIndexShardSnapshots::fromXContent, namedXContentRegistry, isCompress())__        ByteSizeValue chunkSize = chunkSize()__        if (chunkSize != null && chunkSize.getBytes() <= 0) {_            throw new IllegalArgumentException("the chunk size cannot be negative: [" + chunkSize + "]")__        }_    };constructs,new,blob,store,repository,param,metadata,the,metadata,for,this,repository,including,name,and,settings,param,global,settings,settings,for,the,node,this,repository,object,is,created,on;protected,blob,store,repository,repository,meta,data,metadata,settings,global,settings,named,xcontent,registry,named,xcontent,registry,super,global,settings,this,metadata,metadata,this,named,xcontent,registry,named,xcontent,registry,snapshot,rate,limiter,get,rate,limiter,metadata,settings,new,byte,size,value,40,byte,size,unit,mb,restore,rate,limiter,get,rate,limiter,metadata,settings,new,byte,size,value,40,byte,size,unit,mb,read,only,metadata,settings,get,as,boolean,readonly,false,index,shard,snapshot,format,new,checksum,blob,store,format,blob,store,index,shard,snapshot,from,xcontent,named,xcontent,registry,is,compress,index,shard,snapshots,format,new,checksum,blob,store,format,blob,store,index,shard,snapshots,from,xcontent,named,xcontent,registry,is,compress,byte,size,value,chunk,size,chunk,size,if,chunk,size,null,chunk,size,get,bytes,0,throw,new,illegal,argument,exception,the,chunk,size,cannot,be,negative,chunk,size
BlobStoreRepository -> protected BlobStoreRepository(RepositoryMetaData metadata, Settings globalSettings, NamedXContentRegistry namedXContentRegistry);1535723122;Constructs new BlobStoreRepository__@param metadata       The metadata for this repository including name and settings_@param globalSettings Settings for the node this repository object is created on;protected BlobStoreRepository(RepositoryMetaData metadata, Settings globalSettings, NamedXContentRegistry namedXContentRegistry) {_        super(globalSettings)__        this.metadata = metadata__        this.namedXContentRegistry = namedXContentRegistry__        snapshotRateLimiter = getRateLimiter(metadata.settings(), "max_snapshot_bytes_per_sec", new ByteSizeValue(40, ByteSizeUnit.MB))__        restoreRateLimiter = getRateLimiter(metadata.settings(), "max_restore_bytes_per_sec", new ByteSizeValue(40, ByteSizeUnit.MB))__        readOnly = metadata.settings().getAsBoolean("readonly", false)___        indexShardSnapshotFormat = new ChecksumBlobStoreFormat<>(SNAPSHOT_CODEC, SNAPSHOT_NAME_FORMAT,_            BlobStoreIndexShardSnapshot::fromXContent, namedXContentRegistry, isCompress())__        indexShardSnapshotsFormat = new ChecksumBlobStoreFormat<>(SNAPSHOT_INDEX_CODEC, SNAPSHOT_INDEX_NAME_FORMAT,_            BlobStoreIndexShardSnapshots::fromXContent, namedXContentRegistry, isCompress())__        ByteSizeValue chunkSize = chunkSize()__        if (chunkSize != null && chunkSize.getBytes() <= 0) {_            throw new IllegalArgumentException("the chunk size cannot be negative: [" + chunkSize + "]")__        }_    };constructs,new,blob,store,repository,param,metadata,the,metadata,for,this,repository,including,name,and,settings,param,global,settings,settings,for,the,node,this,repository,object,is,created,on;protected,blob,store,repository,repository,meta,data,metadata,settings,global,settings,named,xcontent,registry,named,xcontent,registry,super,global,settings,this,metadata,metadata,this,named,xcontent,registry,named,xcontent,registry,snapshot,rate,limiter,get,rate,limiter,metadata,settings,new,byte,size,value,40,byte,size,unit,mb,restore,rate,limiter,get,rate,limiter,metadata,settings,new,byte,size,value,40,byte,size,unit,mb,read,only,metadata,settings,get,as,boolean,readonly,false,index,shard,snapshot,format,new,checksum,blob,store,format,blob,store,index,shard,snapshot,from,xcontent,named,xcontent,registry,is,compress,index,shard,snapshots,format,new,checksum,blob,store,format,blob,store,index,shard,snapshots,from,xcontent,named,xcontent,registry,is,compress,byte,size,value,chunk,size,chunk,size,if,chunk,size,null,chunk,size,get,bytes,0,throw,new,illegal,argument,exception,the,chunk,size,cannot,be,negative,chunk,size
BlobStoreRepository -> protected BlobStoreRepository(RepositoryMetaData metadata, Settings globalSettings, NamedXContentRegistry namedXContentRegistry);1536314350;Constructs new BlobStoreRepository__@param metadata       The metadata for this repository including name and settings_@param globalSettings Settings for the node this repository object is created on;protected BlobStoreRepository(RepositoryMetaData metadata, Settings globalSettings, NamedXContentRegistry namedXContentRegistry) {_        super(globalSettings)__        this.metadata = metadata__        this.namedXContentRegistry = namedXContentRegistry__        snapshotRateLimiter = getRateLimiter(metadata.settings(), "max_snapshot_bytes_per_sec", new ByteSizeValue(40, ByteSizeUnit.MB))__        restoreRateLimiter = getRateLimiter(metadata.settings(), "max_restore_bytes_per_sec", new ByteSizeValue(40, ByteSizeUnit.MB))__        readOnly = metadata.settings().getAsBoolean("readonly", false)___        indexShardSnapshotFormat = new ChecksumBlobStoreFormat<>(SNAPSHOT_CODEC, SNAPSHOT_NAME_FORMAT,_            BlobStoreIndexShardSnapshot::fromXContent, namedXContentRegistry, isCompress())__        indexShardSnapshotsFormat = new ChecksumBlobStoreFormat<>(SNAPSHOT_INDEX_CODEC, SNAPSHOT_INDEX_NAME_FORMAT,_            BlobStoreIndexShardSnapshots::fromXContent, namedXContentRegistry, isCompress())__        ByteSizeValue chunkSize = chunkSize()__        if (chunkSize != null && chunkSize.getBytes() <= 0) {_            throw new IllegalArgumentException("the chunk size cannot be negative: [" + chunkSize + "]")__        }_    };constructs,new,blob,store,repository,param,metadata,the,metadata,for,this,repository,including,name,and,settings,param,global,settings,settings,for,the,node,this,repository,object,is,created,on;protected,blob,store,repository,repository,meta,data,metadata,settings,global,settings,named,xcontent,registry,named,xcontent,registry,super,global,settings,this,metadata,metadata,this,named,xcontent,registry,named,xcontent,registry,snapshot,rate,limiter,get,rate,limiter,metadata,settings,new,byte,size,value,40,byte,size,unit,mb,restore,rate,limiter,get,rate,limiter,metadata,settings,new,byte,size,value,40,byte,size,unit,mb,read,only,metadata,settings,get,as,boolean,readonly,false,index,shard,snapshot,format,new,checksum,blob,store,format,blob,store,index,shard,snapshot,from,xcontent,named,xcontent,registry,is,compress,index,shard,snapshots,format,new,checksum,blob,store,format,blob,store,index,shard,snapshots,from,xcontent,named,xcontent,registry,is,compress,byte,size,value,chunk,size,chunk,size,if,chunk,size,null,chunk,size,get,bytes,0,throw,new,illegal,argument,exception,the,chunk,size,cannot,be,negative,chunk,size
BlobStoreRepository -> protected BlobStoreRepository(RepositoryMetaData metadata, Settings globalSettings, NamedXContentRegistry namedXContentRegistry);1536828374;Constructs new BlobStoreRepository__@param metadata       The metadata for this repository including name and settings_@param globalSettings Settings for the node this repository object is created on;protected BlobStoreRepository(RepositoryMetaData metadata, Settings globalSettings, NamedXContentRegistry namedXContentRegistry) {_        super(globalSettings)__        this.metadata = metadata__        this.namedXContentRegistry = namedXContentRegistry__        snapshotRateLimiter = getRateLimiter(metadata.settings(), "max_snapshot_bytes_per_sec", new ByteSizeValue(40, ByteSizeUnit.MB))__        restoreRateLimiter = getRateLimiter(metadata.settings(), "max_restore_bytes_per_sec", new ByteSizeValue(40, ByteSizeUnit.MB))__        readOnly = metadata.settings().getAsBoolean("readonly", false)___        indexShardSnapshotFormat = new ChecksumBlobStoreFormat<>(SNAPSHOT_CODEC, SNAPSHOT_NAME_FORMAT,_            BlobStoreIndexShardSnapshot::fromXContent, namedXContentRegistry, isCompress())__        indexShardSnapshotsFormat = new ChecksumBlobStoreFormat<>(SNAPSHOT_INDEX_CODEC, SNAPSHOT_INDEX_NAME_FORMAT,_            BlobStoreIndexShardSnapshots::fromXContent, namedXContentRegistry, isCompress())__        ByteSizeValue chunkSize = chunkSize()__        if (chunkSize != null && chunkSize.getBytes() <= 0) {_            throw new IllegalArgumentException("the chunk size cannot be negative: [" + chunkSize + "]")__        }_    };constructs,new,blob,store,repository,param,metadata,the,metadata,for,this,repository,including,name,and,settings,param,global,settings,settings,for,the,node,this,repository,object,is,created,on;protected,blob,store,repository,repository,meta,data,metadata,settings,global,settings,named,xcontent,registry,named,xcontent,registry,super,global,settings,this,metadata,metadata,this,named,xcontent,registry,named,xcontent,registry,snapshot,rate,limiter,get,rate,limiter,metadata,settings,new,byte,size,value,40,byte,size,unit,mb,restore,rate,limiter,get,rate,limiter,metadata,settings,new,byte,size,value,40,byte,size,unit,mb,read,only,metadata,settings,get,as,boolean,readonly,false,index,shard,snapshot,format,new,checksum,blob,store,format,blob,store,index,shard,snapshot,from,xcontent,named,xcontent,registry,is,compress,index,shard,snapshots,format,new,checksum,blob,store,format,blob,store,index,shard,snapshots,from,xcontent,named,xcontent,registry,is,compress,byte,size,value,chunk,size,chunk,size,if,chunk,size,null,chunk,size,get,bytes,0,throw,new,illegal,argument,exception,the,chunk,size,cannot,be,negative,chunk,size
BlobStoreRepository -> Context -> protected void finalize(List<SnapshotFiles> snapshots, int fileListGeneration, Map<String, BlobMetaData> blobs);1524684173;Removes all unreferenced files from the repository and writes new index file__We need to be really careful in handling index files in case of failures to make sure we have index file that_points to files that were deleted.___@param snapshots list of active snapshots in the container_@param fileListGeneration the generation number of the snapshot index file_@param blobs     list of blobs in the container;protected void finalize(List<SnapshotFiles> snapshots, int fileListGeneration, Map<String, BlobMetaData> blobs) {_            BlobStoreIndexShardSnapshots newSnapshots = new BlobStoreIndexShardSnapshots(snapshots)__            _            for (String blobName : blobs.keySet()) {_                if (indexShardSnapshotsFormat.isTempBlobName(blobName) || blobName.startsWith(SNAPSHOT_INDEX_PREFIX)) {_                    try {_                        blobContainer.deleteBlob(blobName)__                    } catch (IOException e) {_                        _                        _                        throw new IndexShardSnapshotFailedException(shardId, "error deleting index file ["_                            + blobName + "] during cleanup", e)__                    }_                }_            }__            _            for (String blobName : blobs.keySet()) {_                _                if (blobName.startsWith(DATA_BLOB_PREFIX)) {_                    if (newSnapshots.findNameFile(BlobStoreIndexShardSnapshot.FileInfo.canonicalName(blobName)) == null) {_                        try {_                            blobContainer.deleteBlob(blobName)__                        } catch (IOException e) {_                            _                            logger.debug(() -> new ParameterizedMessage("[{}] [{}] error deleting blob [{}] during cleanup", snapshotId, shardId, blobName), e)__                        }_                    }_                }_            }__            _            if (snapshots.size() > 0) {_                try {_                    indexShardSnapshotsFormat.writeAtomic(newSnapshots, blobContainer, Integer.toString(fileListGeneration))__                } catch (IOException e) {_                    throw new IndexShardSnapshotFailedException(shardId, "Failed to write file list", e)__                }_            }_        };removes,all,unreferenced,files,from,the,repository,and,writes,new,index,file,we,need,to,be,really,careful,in,handling,index,files,in,case,of,failures,to,make,sure,we,have,index,file,that,points,to,files,that,were,deleted,param,snapshots,list,of,active,snapshots,in,the,container,param,file,list,generation,the,generation,number,of,the,snapshot,index,file,param,blobs,list,of,blobs,in,the,container;protected,void,finalize,list,snapshot,files,snapshots,int,file,list,generation,map,string,blob,meta,data,blobs,blob,store,index,shard,snapshots,new,snapshots,new,blob,store,index,shard,snapshots,snapshots,for,string,blob,name,blobs,key,set,if,index,shard,snapshots,format,is,temp,blob,name,blob,name,blob,name,starts,with,try,blob,container,delete,blob,blob,name,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,error,deleting,index,file,blob,name,during,cleanup,e,for,string,blob,name,blobs,key,set,if,blob,name,starts,with,if,new,snapshots,find,name,file,blob,store,index,shard,snapshot,file,info,canonical,name,blob,name,null,try,blob,container,delete,blob,blob,name,catch,ioexception,e,logger,debug,new,parameterized,message,error,deleting,blob,during,cleanup,snapshot,id,shard,id,blob,name,e,if,snapshots,size,0,try,index,shard,snapshots,format,write,atomic,new,snapshots,blob,container,integer,to,string,file,list,generation,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,write,file,list,e
BlobStoreRepository -> Context -> protected void finalize(List<SnapshotFiles> snapshots, int fileListGeneration, Map<String, BlobMetaData> blobs);1525334055;Removes all unreferenced files from the repository and writes new index file__We need to be really careful in handling index files in case of failures to make sure we have index file that_points to files that were deleted.___@param snapshots list of active snapshots in the container_@param fileListGeneration the generation number of the snapshot index file_@param blobs     list of blobs in the container;protected void finalize(List<SnapshotFiles> snapshots, int fileListGeneration, Map<String, BlobMetaData> blobs) {_            BlobStoreIndexShardSnapshots newSnapshots = new BlobStoreIndexShardSnapshots(snapshots)__            _            for (String blobName : blobs.keySet()) {_                if (indexShardSnapshotsFormat.isTempBlobName(blobName) || blobName.startsWith(SNAPSHOT_INDEX_PREFIX)) {_                    try {_                        blobContainer.deleteBlob(blobName)__                    } catch (IOException e) {_                        _                        _                        throw new IndexShardSnapshotFailedException(shardId, "error deleting index file ["_                            + blobName + "] during cleanup", e)__                    }_                }_            }__            _            for (String blobName : blobs.keySet()) {_                _                if (blobName.startsWith(DATA_BLOB_PREFIX)) {_                    if (newSnapshots.findNameFile(BlobStoreIndexShardSnapshot.FileInfo.canonicalName(blobName)) == null) {_                        try {_                            blobContainer.deleteBlob(blobName)__                        } catch (IOException e) {_                            _                            logger.debug(() -> new ParameterizedMessage("[{}] [{}] error deleting blob [{}] during cleanup", snapshotId, shardId, blobName), e)__                        }_                    }_                }_            }__            _            if (snapshots.size() > 0) {_                try {_                    indexShardSnapshotsFormat.writeAtomic(newSnapshots, blobContainer, Integer.toString(fileListGeneration))__                } catch (IOException e) {_                    throw new IndexShardSnapshotFailedException(shardId, "Failed to write file list", e)__                }_            }_        };removes,all,unreferenced,files,from,the,repository,and,writes,new,index,file,we,need,to,be,really,careful,in,handling,index,files,in,case,of,failures,to,make,sure,we,have,index,file,that,points,to,files,that,were,deleted,param,snapshots,list,of,active,snapshots,in,the,container,param,file,list,generation,the,generation,number,of,the,snapshot,index,file,param,blobs,list,of,blobs,in,the,container;protected,void,finalize,list,snapshot,files,snapshots,int,file,list,generation,map,string,blob,meta,data,blobs,blob,store,index,shard,snapshots,new,snapshots,new,blob,store,index,shard,snapshots,snapshots,for,string,blob,name,blobs,key,set,if,index,shard,snapshots,format,is,temp,blob,name,blob,name,blob,name,starts,with,try,blob,container,delete,blob,blob,name,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,error,deleting,index,file,blob,name,during,cleanup,e,for,string,blob,name,blobs,key,set,if,blob,name,starts,with,if,new,snapshots,find,name,file,blob,store,index,shard,snapshot,file,info,canonical,name,blob,name,null,try,blob,container,delete,blob,blob,name,catch,ioexception,e,logger,debug,new,parameterized,message,error,deleting,blob,during,cleanup,snapshot,id,shard,id,blob,name,e,if,snapshots,size,0,try,index,shard,snapshots,format,write,atomic,new,snapshots,blob,container,integer,to,string,file,list,generation,catch,ioexception,e,throw,new,index,shard,snapshot,failed,exception,shard,id,failed,to,write,file,list,e
BlobStoreRepository -> SnapshotContext -> private boolean snapshotFileExistsInBlobs(BlobStoreIndexShardSnapshot.FileInfo fileInfo, Map<String, BlobMetaData> blobs);1524684173;Checks if snapshot file already exists in the list of blobs__@param fileInfo file to check_@param blobs    list of blobs_@return true if file exists in the list of blobs;private boolean snapshotFileExistsInBlobs(BlobStoreIndexShardSnapshot.FileInfo fileInfo, Map<String, BlobMetaData> blobs) {_            BlobMetaData blobMetaData = blobs.get(fileInfo.name())__            if (blobMetaData != null) {_                return blobMetaData.length() == fileInfo.length()__            } else if (blobs.containsKey(fileInfo.partName(0))) {_                _                int part = 0__                long totalSize = 0__                while (true) {_                    blobMetaData = blobs.get(fileInfo.partName(part++))__                    if (blobMetaData == null) {_                        break__                    }_                    totalSize += blobMetaData.length()__                }_                return totalSize == fileInfo.length()__            }_            _            return false__        };checks,if,snapshot,file,already,exists,in,the,list,of,blobs,param,file,info,file,to,check,param,blobs,list,of,blobs,return,true,if,file,exists,in,the,list,of,blobs;private,boolean,snapshot,file,exists,in,blobs,blob,store,index,shard,snapshot,file,info,file,info,map,string,blob,meta,data,blobs,blob,meta,data,blob,meta,data,blobs,get,file,info,name,if,blob,meta,data,null,return,blob,meta,data,length,file,info,length,else,if,blobs,contains,key,file,info,part,name,0,int,part,0,long,total,size,0,while,true,blob,meta,data,blobs,get,file,info,part,name,part,if,blob,meta,data,null,break,total,size,blob,meta,data,length,return,total,size,file,info,length,return,false
BlobStoreRepository -> SnapshotContext -> private boolean snapshotFileExistsInBlobs(BlobStoreIndexShardSnapshot.FileInfo fileInfo, Map<String, BlobMetaData> blobs);1525334055;Checks if snapshot file already exists in the list of blobs__@param fileInfo file to check_@param blobs    list of blobs_@return true if file exists in the list of blobs;private boolean snapshotFileExistsInBlobs(BlobStoreIndexShardSnapshot.FileInfo fileInfo, Map<String, BlobMetaData> blobs) {_            BlobMetaData blobMetaData = blobs.get(fileInfo.name())__            if (blobMetaData != null) {_                return blobMetaData.length() == fileInfo.length()__            } else if (blobs.containsKey(fileInfo.partName(0))) {_                _                int part = 0__                long totalSize = 0__                while (true) {_                    blobMetaData = blobs.get(fileInfo.partName(part++))__                    if (blobMetaData == null) {_                        break__                    }_                    totalSize += blobMetaData.length()__                }_                return totalSize == fileInfo.length()__            }_            _            return false__        };checks,if,snapshot,file,already,exists,in,the,list,of,blobs,param,file,info,file,to,check,param,blobs,list,of,blobs,return,true,if,file,exists,in,the,list,of,blobs;private,boolean,snapshot,file,exists,in,blobs,blob,store,index,shard,snapshot,file,info,file,info,map,string,blob,meta,data,blobs,blob,meta,data,blob,meta,data,blobs,get,file,info,name,if,blob,meta,data,null,return,blob,meta,data,length,file,info,length,else,if,blobs,contains,key,file,info,part,name,0,int,part,0,long,total,size,0,while,true,blob,meta,data,blobs,get,file,info,part,name,part,if,blob,meta,data,null,break,total,size,blob,meta,data,length,return,total,size,file,info,length,return,false
BlobStoreRepository -> SnapshotContext -> private boolean snapshotFileExistsInBlobs(BlobStoreIndexShardSnapshot.FileInfo fileInfo, Map<String, BlobMetaData> blobs);1525798020;Checks if snapshot file already exists in the list of blobs__@param fileInfo file to check_@param blobs    list of blobs_@return true if file exists in the list of blobs;private boolean snapshotFileExistsInBlobs(BlobStoreIndexShardSnapshot.FileInfo fileInfo, Map<String, BlobMetaData> blobs) {_            BlobMetaData blobMetaData = blobs.get(fileInfo.name())__            if (blobMetaData != null) {_                return blobMetaData.length() == fileInfo.length()__            } else if (blobs.containsKey(fileInfo.partName(0))) {_                _                int part = 0__                long totalSize = 0__                while (true) {_                    blobMetaData = blobs.get(fileInfo.partName(part++))__                    if (blobMetaData == null) {_                        break__                    }_                    totalSize += blobMetaData.length()__                }_                return totalSize == fileInfo.length()__            }_            _            return false__        };checks,if,snapshot,file,already,exists,in,the,list,of,blobs,param,file,info,file,to,check,param,blobs,list,of,blobs,return,true,if,file,exists,in,the,list,of,blobs;private,boolean,snapshot,file,exists,in,blobs,blob,store,index,shard,snapshot,file,info,file,info,map,string,blob,meta,data,blobs,blob,meta,data,blob,meta,data,blobs,get,file,info,name,if,blob,meta,data,null,return,blob,meta,data,length,file,info,length,else,if,blobs,contains,key,file,info,part,name,0,int,part,0,long,total,size,0,while,true,blob,meta,data,blobs,get,file,info,part,name,part,if,blob,meta,data,null,break,total,size,blob,meta,data,length,return,total,size,file,info,length,return,false
BlobStoreRepository -> SnapshotContext -> private boolean snapshotFileExistsInBlobs(BlobStoreIndexShardSnapshot.FileInfo fileInfo, Map<String, BlobMetaData> blobs);1526289033;Checks if snapshot file already exists in the list of blobs__@param fileInfo file to check_@param blobs    list of blobs_@return true if file exists in the list of blobs;private boolean snapshotFileExistsInBlobs(BlobStoreIndexShardSnapshot.FileInfo fileInfo, Map<String, BlobMetaData> blobs) {_            BlobMetaData blobMetaData = blobs.get(fileInfo.name())__            if (blobMetaData != null) {_                return blobMetaData.length() == fileInfo.length()__            } else if (blobs.containsKey(fileInfo.partName(0))) {_                _                int part = 0__                long totalSize = 0__                while (true) {_                    blobMetaData = blobs.get(fileInfo.partName(part++))__                    if (blobMetaData == null) {_                        break__                    }_                    totalSize += blobMetaData.length()__                }_                return totalSize == fileInfo.length()__            }_            _            return false__        };checks,if,snapshot,file,already,exists,in,the,list,of,blobs,param,file,info,file,to,check,param,blobs,list,of,blobs,return,true,if,file,exists,in,the,list,of,blobs;private,boolean,snapshot,file,exists,in,blobs,blob,store,index,shard,snapshot,file,info,file,info,map,string,blob,meta,data,blobs,blob,meta,data,blob,meta,data,blobs,get,file,info,name,if,blob,meta,data,null,return,blob,meta,data,length,file,info,length,else,if,blobs,contains,key,file,info,part,name,0,int,part,0,long,total,size,0,while,true,blob,meta,data,blobs,get,file,info,part,name,part,if,blob,meta,data,null,break,total,size,blob,meta,data,length,return,total,size,file,info,length,return,false
BlobStoreRepository -> SnapshotContext -> private boolean snapshotFileExistsInBlobs(BlobStoreIndexShardSnapshot.FileInfo fileInfo, Map<String, BlobMetaData> blobs);1526574077;Checks if snapshot file already exists in the list of blobs__@param fileInfo file to check_@param blobs    list of blobs_@return true if file exists in the list of blobs;private boolean snapshotFileExistsInBlobs(BlobStoreIndexShardSnapshot.FileInfo fileInfo, Map<String, BlobMetaData> blobs) {_            BlobMetaData blobMetaData = blobs.get(fileInfo.name())__            if (blobMetaData != null) {_                return blobMetaData.length() == fileInfo.length()__            } else if (blobs.containsKey(fileInfo.partName(0))) {_                _                int part = 0__                long totalSize = 0__                while (true) {_                    blobMetaData = blobs.get(fileInfo.partName(part++))__                    if (blobMetaData == null) {_                        break__                    }_                    totalSize += blobMetaData.length()__                }_                return totalSize == fileInfo.length()__            }_            _            return false__        };checks,if,snapshot,file,already,exists,in,the,list,of,blobs,param,file,info,file,to,check,param,blobs,list,of,blobs,return,true,if,file,exists,in,the,list,of,blobs;private,boolean,snapshot,file,exists,in,blobs,blob,store,index,shard,snapshot,file,info,file,info,map,string,blob,meta,data,blobs,blob,meta,data,blob,meta,data,blobs,get,file,info,name,if,blob,meta,data,null,return,blob,meta,data,length,file,info,length,else,if,blobs,contains,key,file,info,part,name,0,int,part,0,long,total,size,0,while,true,blob,meta,data,blobs,get,file,info,part,name,part,if,blob,meta,data,null,break,total,size,blob,meta,data,length,return,total,size,file,info,length,return,false
BlobStoreRepository -> SnapshotContext -> private boolean snapshotFileExistsInBlobs(BlobStoreIndexShardSnapshot.FileInfo fileInfo, Map<String, BlobMetaData> blobs);1527583663;Checks if snapshot file already exists in the list of blobs__@param fileInfo file to check_@param blobs    list of blobs_@return true if file exists in the list of blobs;private boolean snapshotFileExistsInBlobs(BlobStoreIndexShardSnapshot.FileInfo fileInfo, Map<String, BlobMetaData> blobs) {_            BlobMetaData blobMetaData = blobs.get(fileInfo.name())__            if (blobMetaData != null) {_                return blobMetaData.length() == fileInfo.length()__            } else if (blobs.containsKey(fileInfo.partName(0))) {_                _                int part = 0__                long totalSize = 0__                while (true) {_                    blobMetaData = blobs.get(fileInfo.partName(part++))__                    if (blobMetaData == null) {_                        break__                    }_                    totalSize += blobMetaData.length()__                }_                return totalSize == fileInfo.length()__            }_            _            return false__        };checks,if,snapshot,file,already,exists,in,the,list,of,blobs,param,file,info,file,to,check,param,blobs,list,of,blobs,return,true,if,file,exists,in,the,list,of,blobs;private,boolean,snapshot,file,exists,in,blobs,blob,store,index,shard,snapshot,file,info,file,info,map,string,blob,meta,data,blobs,blob,meta,data,blob,meta,data,blobs,get,file,info,name,if,blob,meta,data,null,return,blob,meta,data,length,file,info,length,else,if,blobs,contains,key,file,info,part,name,0,int,part,0,long,total,size,0,while,true,blob,meta,data,blobs,get,file,info,part,name,part,if,blob,meta,data,null,break,total,size,blob,meta,data,length,return,total,size,file,info,length,return,false
BlobStoreRepository -> SnapshotContext -> private boolean snapshotFileExistsInBlobs(BlobStoreIndexShardSnapshot.FileInfo fileInfo, Map<String, BlobMetaData> blobs);1528211342;Checks if snapshot file already exists in the list of blobs__@param fileInfo file to check_@param blobs    list of blobs_@return true if file exists in the list of blobs;private boolean snapshotFileExistsInBlobs(BlobStoreIndexShardSnapshot.FileInfo fileInfo, Map<String, BlobMetaData> blobs) {_            BlobMetaData blobMetaData = blobs.get(fileInfo.name())__            if (blobMetaData != null) {_                return blobMetaData.length() == fileInfo.length()__            } else if (blobs.containsKey(fileInfo.partName(0))) {_                _                int part = 0__                long totalSize = 0__                while (true) {_                    blobMetaData = blobs.get(fileInfo.partName(part++))__                    if (blobMetaData == null) {_                        break__                    }_                    totalSize += blobMetaData.length()__                }_                return totalSize == fileInfo.length()__            }_            _            return false__        };checks,if,snapshot,file,already,exists,in,the,list,of,blobs,param,file,info,file,to,check,param,blobs,list,of,blobs,return,true,if,file,exists,in,the,list,of,blobs;private,boolean,snapshot,file,exists,in,blobs,blob,store,index,shard,snapshot,file,info,file,info,map,string,blob,meta,data,blobs,blob,meta,data,blob,meta,data,blobs,get,file,info,name,if,blob,meta,data,null,return,blob,meta,data,length,file,info,length,else,if,blobs,contains,key,file,info,part,name,0,int,part,0,long,total,size,0,while,true,blob,meta,data,blobs,get,file,info,part,name,part,if,blob,meta,data,null,break,total,size,blob,meta,data,length,return,total,size,file,info,length,return,false
BlobStoreRepository -> SnapshotContext -> private boolean snapshotFileExistsInBlobs(BlobStoreIndexShardSnapshot.FileInfo fileInfo, Map<String, BlobMetaData> blobs);1531179852;Checks if snapshot file already exists in the list of blobs__@param fileInfo file to check_@param blobs    list of blobs_@return true if file exists in the list of blobs;private boolean snapshotFileExistsInBlobs(BlobStoreIndexShardSnapshot.FileInfo fileInfo, Map<String, BlobMetaData> blobs) {_            BlobMetaData blobMetaData = blobs.get(fileInfo.name())__            if (blobMetaData != null) {_                return blobMetaData.length() == fileInfo.length()__            } else if (blobs.containsKey(fileInfo.partName(0))) {_                _                int part = 0__                long totalSize = 0__                while (true) {_                    blobMetaData = blobs.get(fileInfo.partName(part++))__                    if (blobMetaData == null) {_                        break__                    }_                    totalSize += blobMetaData.length()__                }_                return totalSize == fileInfo.length()__            }_            _            return false__        };checks,if,snapshot,file,already,exists,in,the,list,of,blobs,param,file,info,file,to,check,param,blobs,list,of,blobs,return,true,if,file,exists,in,the,list,of,blobs;private,boolean,snapshot,file,exists,in,blobs,blob,store,index,shard,snapshot,file,info,file,info,map,string,blob,meta,data,blobs,blob,meta,data,blob,meta,data,blobs,get,file,info,name,if,blob,meta,data,null,return,blob,meta,data,length,file,info,length,else,if,blobs,contains,key,file,info,part,name,0,int,part,0,long,total,size,0,while,true,blob,meta,data,blobs,get,file,info,part,name,part,if,blob,meta,data,null,break,total,size,blob,meta,data,length,return,total,size,file,info,length,return,false
BlobStoreRepository -> SnapshotContext -> private boolean snapshotFileExistsInBlobs(BlobStoreIndexShardSnapshot.FileInfo fileInfo, Map<String, BlobMetaData> blobs);1531729807;Checks if snapshot file already exists in the list of blobs__@param fileInfo file to check_@param blobs    list of blobs_@return true if file exists in the list of blobs;private boolean snapshotFileExistsInBlobs(BlobStoreIndexShardSnapshot.FileInfo fileInfo, Map<String, BlobMetaData> blobs) {_            BlobMetaData blobMetaData = blobs.get(fileInfo.name())__            if (blobMetaData != null) {_                return blobMetaData.length() == fileInfo.length()__            } else if (blobs.containsKey(fileInfo.partName(0))) {_                _                int part = 0__                long totalSize = 0__                while (true) {_                    blobMetaData = blobs.get(fileInfo.partName(part++))__                    if (blobMetaData == null) {_                        break__                    }_                    totalSize += blobMetaData.length()__                }_                return totalSize == fileInfo.length()__            }_            _            return false__        };checks,if,snapshot,file,already,exists,in,the,list,of,blobs,param,file,info,file,to,check,param,blobs,list,of,blobs,return,true,if,file,exists,in,the,list,of,blobs;private,boolean,snapshot,file,exists,in,blobs,blob,store,index,shard,snapshot,file,info,file,info,map,string,blob,meta,data,blobs,blob,meta,data,blob,meta,data,blobs,get,file,info,name,if,blob,meta,data,null,return,blob,meta,data,length,file,info,length,else,if,blobs,contains,key,file,info,part,name,0,int,part,0,long,total,size,0,while,true,blob,meta,data,blobs,get,file,info,part,name,part,if,blob,meta,data,null,break,total,size,blob,meta,data,length,return,total,size,file,info,length,return,false
BlobStoreRepository -> SnapshotContext -> private boolean snapshotFileExistsInBlobs(BlobStoreIndexShardSnapshot.FileInfo fileInfo, Map<String, BlobMetaData> blobs);1532685069;Checks if snapshot file already exists in the list of blobs__@param fileInfo file to check_@param blobs    list of blobs_@return true if file exists in the list of blobs;private boolean snapshotFileExistsInBlobs(BlobStoreIndexShardSnapshot.FileInfo fileInfo, Map<String, BlobMetaData> blobs) {_            BlobMetaData blobMetaData = blobs.get(fileInfo.name())__            if (blobMetaData != null) {_                return blobMetaData.length() == fileInfo.length()__            } else if (blobs.containsKey(fileInfo.partName(0))) {_                _                int part = 0__                long totalSize = 0__                while (true) {_                    blobMetaData = blobs.get(fileInfo.partName(part++))__                    if (blobMetaData == null) {_                        break__                    }_                    totalSize += blobMetaData.length()__                }_                return totalSize == fileInfo.length()__            }_            _            return false__        };checks,if,snapshot,file,already,exists,in,the,list,of,blobs,param,file,info,file,to,check,param,blobs,list,of,blobs,return,true,if,file,exists,in,the,list,of,blobs;private,boolean,snapshot,file,exists,in,blobs,blob,store,index,shard,snapshot,file,info,file,info,map,string,blob,meta,data,blobs,blob,meta,data,blob,meta,data,blobs,get,file,info,name,if,blob,meta,data,null,return,blob,meta,data,length,file,info,length,else,if,blobs,contains,key,file,info,part,name,0,int,part,0,long,total,size,0,while,true,blob,meta,data,blobs,get,file,info,part,name,part,if,blob,meta,data,null,break,total,size,blob,meta,data,length,return,total,size,file,info,length,return,false
BlobStoreRepository -> SnapshotContext -> private boolean snapshotFileExistsInBlobs(BlobStoreIndexShardSnapshot.FileInfo fileInfo, Map<String, BlobMetaData> blobs);1535139672;Checks if snapshot file already exists in the list of blobs__@param fileInfo file to check_@param blobs    list of blobs_@return true if file exists in the list of blobs;private boolean snapshotFileExistsInBlobs(BlobStoreIndexShardSnapshot.FileInfo fileInfo, Map<String, BlobMetaData> blobs) {_            BlobMetaData blobMetaData = blobs.get(fileInfo.name())__            if (blobMetaData != null) {_                return blobMetaData.length() == fileInfo.length()__            } else if (blobs.containsKey(fileInfo.partName(0))) {_                _                int part = 0__                long totalSize = 0__                while (true) {_                    blobMetaData = blobs.get(fileInfo.partName(part++))__                    if (blobMetaData == null) {_                        break__                    }_                    totalSize += blobMetaData.length()__                }_                return totalSize == fileInfo.length()__            }_            _            return false__        };checks,if,snapshot,file,already,exists,in,the,list,of,blobs,param,file,info,file,to,check,param,blobs,list,of,blobs,return,true,if,file,exists,in,the,list,of,blobs;private,boolean,snapshot,file,exists,in,blobs,blob,store,index,shard,snapshot,file,info,file,info,map,string,blob,meta,data,blobs,blob,meta,data,blob,meta,data,blobs,get,file,info,name,if,blob,meta,data,null,return,blob,meta,data,length,file,info,length,else,if,blobs,contains,key,file,info,part,name,0,int,part,0,long,total,size,0,while,true,blob,meta,data,blobs,get,file,info,part,name,part,if,blob,meta,data,null,break,total,size,blob,meta,data,length,return,total,size,file,info,length,return,false
BlobStoreRepository -> SnapshotContext -> private boolean snapshotFileExistsInBlobs(BlobStoreIndexShardSnapshot.FileInfo fileInfo, Map<String, BlobMetaData> blobs);1535723122;Checks if snapshot file already exists in the list of blobs__@param fileInfo file to check_@param blobs    list of blobs_@return true if file exists in the list of blobs;private boolean snapshotFileExistsInBlobs(BlobStoreIndexShardSnapshot.FileInfo fileInfo, Map<String, BlobMetaData> blobs) {_            BlobMetaData blobMetaData = blobs.get(fileInfo.name())__            if (blobMetaData != null) {_                return blobMetaData.length() == fileInfo.length()__            } else if (blobs.containsKey(fileInfo.partName(0))) {_                _                int part = 0__                long totalSize = 0__                while (true) {_                    blobMetaData = blobs.get(fileInfo.partName(part++))__                    if (blobMetaData == null) {_                        break__                    }_                    totalSize += blobMetaData.length()__                }_                return totalSize == fileInfo.length()__            }_            _            return false__        };checks,if,snapshot,file,already,exists,in,the,list,of,blobs,param,file,info,file,to,check,param,blobs,list,of,blobs,return,true,if,file,exists,in,the,list,of,blobs;private,boolean,snapshot,file,exists,in,blobs,blob,store,index,shard,snapshot,file,info,file,info,map,string,blob,meta,data,blobs,blob,meta,data,blob,meta,data,blobs,get,file,info,name,if,blob,meta,data,null,return,blob,meta,data,length,file,info,length,else,if,blobs,contains,key,file,info,part,name,0,int,part,0,long,total,size,0,while,true,blob,meta,data,blobs,get,file,info,part,name,part,if,blob,meta,data,null,break,total,size,blob,meta,data,length,return,total,size,file,info,length,return,false
BlobStoreRepository -> SnapshotContext -> private boolean snapshotFileExistsInBlobs(BlobStoreIndexShardSnapshot.FileInfo fileInfo, Map<String, BlobMetaData> blobs);1536314350;Checks if snapshot file already exists in the list of blobs__@param fileInfo file to check_@param blobs    list of blobs_@return true if file exists in the list of blobs;private boolean snapshotFileExistsInBlobs(BlobStoreIndexShardSnapshot.FileInfo fileInfo, Map<String, BlobMetaData> blobs) {_            BlobMetaData blobMetaData = blobs.get(fileInfo.name())__            if (blobMetaData != null) {_                return blobMetaData.length() == fileInfo.length()__            } else if (blobs.containsKey(fileInfo.partName(0))) {_                _                int part = 0__                long totalSize = 0__                while (true) {_                    blobMetaData = blobs.get(fileInfo.partName(part++))__                    if (blobMetaData == null) {_                        break__                    }_                    totalSize += blobMetaData.length()__                }_                return totalSize == fileInfo.length()__            }_            _            return false__        };checks,if,snapshot,file,already,exists,in,the,list,of,blobs,param,file,info,file,to,check,param,blobs,list,of,blobs,return,true,if,file,exists,in,the,list,of,blobs;private,boolean,snapshot,file,exists,in,blobs,blob,store,index,shard,snapshot,file,info,file,info,map,string,blob,meta,data,blobs,blob,meta,data,blob,meta,data,blobs,get,file,info,name,if,blob,meta,data,null,return,blob,meta,data,length,file,info,length,else,if,blobs,contains,key,file,info,part,name,0,int,part,0,long,total,size,0,while,true,blob,meta,data,blobs,get,file,info,part,name,part,if,blob,meta,data,null,break,total,size,blob,meta,data,length,return,total,size,file,info,length,return,false
BlobStoreRepository -> SnapshotContext -> private boolean snapshotFileExistsInBlobs(BlobStoreIndexShardSnapshot.FileInfo fileInfo, Map<String, BlobMetaData> blobs);1536828374;Checks if snapshot file already exists in the list of blobs__@param fileInfo file to check_@param blobs    list of blobs_@return true if file exists in the list of blobs;private boolean snapshotFileExistsInBlobs(BlobStoreIndexShardSnapshot.FileInfo fileInfo, Map<String, BlobMetaData> blobs) {_            BlobMetaData blobMetaData = blobs.get(fileInfo.name())__            if (blobMetaData != null) {_                return blobMetaData.length() == fileInfo.length()__            } else if (blobs.containsKey(fileInfo.partName(0))) {_                _                int part = 0__                long totalSize = 0__                while (true) {_                    blobMetaData = blobs.get(fileInfo.partName(part++))__                    if (blobMetaData == null) {_                        break__                    }_                    totalSize += blobMetaData.length()__                }_                return totalSize == fileInfo.length()__            }_            _            return false__        };checks,if,snapshot,file,already,exists,in,the,list,of,blobs,param,file,info,file,to,check,param,blobs,list,of,blobs,return,true,if,file,exists,in,the,list,of,blobs;private,boolean,snapshot,file,exists,in,blobs,blob,store,index,shard,snapshot,file,info,file,info,map,string,blob,meta,data,blobs,blob,meta,data,blob,meta,data,blobs,get,file,info,name,if,blob,meta,data,null,return,blob,meta,data,length,file,info,length,else,if,blobs,contains,key,file,info,part,name,0,int,part,0,long,total,size,0,while,true,blob,meta,data,blobs,get,file,info,part,name,part,if,blob,meta,data,null,break,total,size,blob,meta,data,length,return,total,size,file,info,length,return,false
BlobStoreRepository -> SnapshotContext -> private boolean snapshotFileExistsInBlobs(BlobStoreIndexShardSnapshot.FileInfo fileInfo, Map<String, BlobMetaData> blobs);1541008027;Checks if snapshot file already exists in the list of blobs__@param fileInfo file to check_@param blobs    list of blobs_@return true if file exists in the list of blobs;private boolean snapshotFileExistsInBlobs(BlobStoreIndexShardSnapshot.FileInfo fileInfo, Map<String, BlobMetaData> blobs) {_            BlobMetaData blobMetaData = blobs.get(fileInfo.name())__            if (blobMetaData != null) {_                return blobMetaData.length() == fileInfo.length()__            } else if (blobs.containsKey(fileInfo.partName(0))) {_                _                int part = 0__                long totalSize = 0__                while (true) {_                    blobMetaData = blobs.get(fileInfo.partName(part++))__                    if (blobMetaData == null) {_                        break__                    }_                    totalSize += blobMetaData.length()__                }_                return totalSize == fileInfo.length()__            }_            _            return false__        };checks,if,snapshot,file,already,exists,in,the,list,of,blobs,param,file,info,file,to,check,param,blobs,list,of,blobs,return,true,if,file,exists,in,the,list,of,blobs;private,boolean,snapshot,file,exists,in,blobs,blob,store,index,shard,snapshot,file,info,file,info,map,string,blob,meta,data,blobs,blob,meta,data,blob,meta,data,blobs,get,file,info,name,if,blob,meta,data,null,return,blob,meta,data,length,file,info,length,else,if,blobs,contains,key,file,info,part,name,0,int,part,0,long,total,size,0,while,true,blob,meta,data,blobs,get,file,info,part,name,part,if,blob,meta,data,null,break,total,size,blob,meta,data,length,return,total,size,file,info,length,return,false
BlobStoreRepository -> SnapshotContext -> private boolean snapshotFileExistsInBlobs(BlobStoreIndexShardSnapshot.FileInfo fileInfo, Map<String, BlobMetaData> blobs);1542646292;Checks if snapshot file already exists in the list of blobs__@param fileInfo file to check_@param blobs    list of blobs_@return true if file exists in the list of blobs;private boolean snapshotFileExistsInBlobs(BlobStoreIndexShardSnapshot.FileInfo fileInfo, Map<String, BlobMetaData> blobs) {_            BlobMetaData blobMetaData = blobs.get(fileInfo.name())__            if (blobMetaData != null) {_                return blobMetaData.length() == fileInfo.length()__            } else if (blobs.containsKey(fileInfo.partName(0))) {_                _                int part = 0__                long totalSize = 0__                while (true) {_                    blobMetaData = blobs.get(fileInfo.partName(part++))__                    if (blobMetaData == null) {_                        break__                    }_                    totalSize += blobMetaData.length()__                }_                return totalSize == fileInfo.length()__            }_            _            return false__        };checks,if,snapshot,file,already,exists,in,the,list,of,blobs,param,file,info,file,to,check,param,blobs,list,of,blobs,return,true,if,file,exists,in,the,list,of,blobs;private,boolean,snapshot,file,exists,in,blobs,blob,store,index,shard,snapshot,file,info,file,info,map,string,blob,meta,data,blobs,blob,meta,data,blob,meta,data,blobs,get,file,info,name,if,blob,meta,data,null,return,blob,meta,data,length,file,info,length,else,if,blobs,contains,key,file,info,part,name,0,int,part,0,long,total,size,0,while,true,blob,meta,data,blobs,get,file,info,part,name,part,if,blob,meta,data,null,break,total,size,blob,meta,data,length,return,total,size,file,info,length,return,false
BlobStoreRepository -> SnapshotContext -> private boolean snapshotFileExistsInBlobs(BlobStoreIndexShardSnapshot.FileInfo fileInfo, Map<String, BlobMetaData> blobs);1542980705;Checks if snapshot file already exists in the list of blobs__@param fileInfo file to check_@param blobs    list of blobs_@return true if file exists in the list of blobs;private boolean snapshotFileExistsInBlobs(BlobStoreIndexShardSnapshot.FileInfo fileInfo, Map<String, BlobMetaData> blobs) {_            BlobMetaData blobMetaData = blobs.get(fileInfo.name())__            if (blobMetaData != null) {_                return blobMetaData.length() == fileInfo.length()__            } else if (blobs.containsKey(fileInfo.partName(0))) {_                _                int part = 0__                long totalSize = 0__                while (true) {_                    blobMetaData = blobs.get(fileInfo.partName(part++))__                    if (blobMetaData == null) {_                        break__                    }_                    totalSize += blobMetaData.length()__                }_                return totalSize == fileInfo.length()__            }_            _            return false__        };checks,if,snapshot,file,already,exists,in,the,list,of,blobs,param,file,info,file,to,check,param,blobs,list,of,blobs,return,true,if,file,exists,in,the,list,of,blobs;private,boolean,snapshot,file,exists,in,blobs,blob,store,index,shard,snapshot,file,info,file,info,map,string,blob,meta,data,blobs,blob,meta,data,blob,meta,data,blobs,get,file,info,name,if,blob,meta,data,null,return,blob,meta,data,length,file,info,length,else,if,blobs,contains,key,file,info,part,name,0,int,part,0,long,total,size,0,while,true,blob,meta,data,blobs,get,file,info,part,name,part,if,blob,meta,data,null,break,total,size,blob,meta,data,length,return,total,size,file,info,length,return,false
BlobStoreRepository -> SnapshotContext -> private boolean snapshotFileExistsInBlobs(BlobStoreIndexShardSnapshot.FileInfo fileInfo, Map<String, BlobMetaData> blobs);1543831870;Checks if snapshot file already exists in the list of blobs__@param fileInfo file to check_@param blobs    list of blobs_@return true if file exists in the list of blobs;private boolean snapshotFileExistsInBlobs(BlobStoreIndexShardSnapshot.FileInfo fileInfo, Map<String, BlobMetaData> blobs) {_            BlobMetaData blobMetaData = blobs.get(fileInfo.name())__            if (blobMetaData != null) {_                return blobMetaData.length() == fileInfo.length()__            } else if (blobs.containsKey(fileInfo.partName(0))) {_                _                int part = 0__                long totalSize = 0__                while (true) {_                    blobMetaData = blobs.get(fileInfo.partName(part++))__                    if (blobMetaData == null) {_                        break__                    }_                    totalSize += blobMetaData.length()__                }_                return totalSize == fileInfo.length()__            }_            _            return false__        };checks,if,snapshot,file,already,exists,in,the,list,of,blobs,param,file,info,file,to,check,param,blobs,list,of,blobs,return,true,if,file,exists,in,the,list,of,blobs;private,boolean,snapshot,file,exists,in,blobs,blob,store,index,shard,snapshot,file,info,file,info,map,string,blob,meta,data,blobs,blob,meta,data,blob,meta,data,blobs,get,file,info,name,if,blob,meta,data,null,return,blob,meta,data,length,file,info,length,else,if,blobs,contains,key,file,info,part,name,0,int,part,0,long,total,size,0,while,true,blob,meta,data,blobs,get,file,info,part,name,part,if,blob,meta,data,null,break,total,size,blob,meta,data,length,return,total,size,file,info,length,return,false
BlobStoreRepository -> SnapshotContext -> private boolean snapshotFileExistsInBlobs(BlobStoreIndexShardSnapshot.FileInfo fileInfo, Map<String, BlobMetaData> blobs);1543942400;Checks if snapshot file already exists in the list of blobs__@param fileInfo file to check_@param blobs    list of blobs_@return true if file exists in the list of blobs;private boolean snapshotFileExistsInBlobs(BlobStoreIndexShardSnapshot.FileInfo fileInfo, Map<String, BlobMetaData> blobs) {_            BlobMetaData blobMetaData = blobs.get(fileInfo.name())__            if (blobMetaData != null) {_                return blobMetaData.length() == fileInfo.length()__            } else if (blobs.containsKey(fileInfo.partName(0))) {_                _                int part = 0__                long totalSize = 0__                while (true) {_                    blobMetaData = blobs.get(fileInfo.partName(part++))__                    if (blobMetaData == null) {_                        break__                    }_                    totalSize += blobMetaData.length()__                }_                return totalSize == fileInfo.length()__            }_            _            return false__        };checks,if,snapshot,file,already,exists,in,the,list,of,blobs,param,file,info,file,to,check,param,blobs,list,of,blobs,return,true,if,file,exists,in,the,list,of,blobs;private,boolean,snapshot,file,exists,in,blobs,blob,store,index,shard,snapshot,file,info,file,info,map,string,blob,meta,data,blobs,blob,meta,data,blob,meta,data,blobs,get,file,info,name,if,blob,meta,data,null,return,blob,meta,data,length,file,info,length,else,if,blobs,contains,key,file,info,part,name,0,int,part,0,long,total,size,0,while,true,blob,meta,data,blobs,get,file,info,part,name,part,if,blob,meta,data,null,break,total,size,blob,meta,data,length,return,total,size,file,info,length,return,false
BlobStoreRepository -> SnapshotContext -> private boolean snapshotFileExistsInBlobs(BlobStoreIndexShardSnapshot.FileInfo fileInfo, Map<String, BlobMetaData> blobs);1546974294;Checks if snapshot file already exists in the list of blobs__@param fileInfo file to check_@param blobs    list of blobs_@return true if file exists in the list of blobs;private boolean snapshotFileExistsInBlobs(BlobStoreIndexShardSnapshot.FileInfo fileInfo, Map<String, BlobMetaData> blobs) {_            BlobMetaData blobMetaData = blobs.get(fileInfo.name())__            if (blobMetaData != null) {_                return blobMetaData.length() == fileInfo.length()__            } else if (blobs.containsKey(fileInfo.partName(0))) {_                _                int part = 0__                long totalSize = 0__                while (true) {_                    blobMetaData = blobs.get(fileInfo.partName(part++))__                    if (blobMetaData == null) {_                        break__                    }_                    totalSize += blobMetaData.length()__                }_                return totalSize == fileInfo.length()__            }_            _            return false__        };checks,if,snapshot,file,already,exists,in,the,list,of,blobs,param,file,info,file,to,check,param,blobs,list,of,blobs,return,true,if,file,exists,in,the,list,of,blobs;private,boolean,snapshot,file,exists,in,blobs,blob,store,index,shard,snapshot,file,info,file,info,map,string,blob,meta,data,blobs,blob,meta,data,blob,meta,data,blobs,get,file,info,name,if,blob,meta,data,null,return,blob,meta,data,length,file,info,length,else,if,blobs,contains,key,file,info,part,name,0,int,part,0,long,total,size,0,while,true,blob,meta,data,blobs,get,file,info,part,name,part,if,blob,meta,data,null,break,total,size,blob,meta,data,length,return,total,size,file,info,length,return,false
BlobStoreRepository -> SnapshotContext -> private boolean snapshotFileExistsInBlobs(BlobStoreIndexShardSnapshot.FileInfo fileInfo, Map<String, BlobMetaData> blobs);1547496475;Checks if snapshot file already exists in the list of blobs__@param fileInfo file to check_@param blobs    list of blobs_@return true if file exists in the list of blobs;private boolean snapshotFileExistsInBlobs(BlobStoreIndexShardSnapshot.FileInfo fileInfo, Map<String, BlobMetaData> blobs) {_            BlobMetaData blobMetaData = blobs.get(fileInfo.name())__            if (blobMetaData != null) {_                return blobMetaData.length() == fileInfo.length()__            } else if (blobs.containsKey(fileInfo.partName(0))) {_                _                int part = 0__                long totalSize = 0__                while (true) {_                    blobMetaData = blobs.get(fileInfo.partName(part++))__                    if (blobMetaData == null) {_                        break__                    }_                    totalSize += blobMetaData.length()__                }_                return totalSize == fileInfo.length()__            }_            _            return false__        };checks,if,snapshot,file,already,exists,in,the,list,of,blobs,param,file,info,file,to,check,param,blobs,list,of,blobs,return,true,if,file,exists,in,the,list,of,blobs;private,boolean,snapshot,file,exists,in,blobs,blob,store,index,shard,snapshot,file,info,file,info,map,string,blob,meta,data,blobs,blob,meta,data,blob,meta,data,blobs,get,file,info,name,if,blob,meta,data,null,return,blob,meta,data,length,file,info,length,else,if,blobs,contains,key,file,info,part,name,0,int,part,0,long,total,size,0,while,true,blob,meta,data,blobs,get,file,info,part,name,part,if,blob,meta,data,null,break,total,size,blob,meta,data,length,return,total,size,file,info,length,return,false
BlobStoreRepository -> SnapshotContext -> private boolean snapshotFileExistsInBlobs(BlobStoreIndexShardSnapshot.FileInfo fileInfo, Map<String, BlobMetaData> blobs);1547625930;Checks if snapshot file already exists in the list of blobs__@param fileInfo file to check_@param blobs    list of blobs_@return true if file exists in the list of blobs;private boolean snapshotFileExistsInBlobs(BlobStoreIndexShardSnapshot.FileInfo fileInfo, Map<String, BlobMetaData> blobs) {_            BlobMetaData blobMetaData = blobs.get(fileInfo.name())__            if (blobMetaData != null) {_                return blobMetaData.length() == fileInfo.length()__            } else if (blobs.containsKey(fileInfo.partName(0))) {_                _                int part = 0__                long totalSize = 0__                while (true) {_                    blobMetaData = blobs.get(fileInfo.partName(part++))__                    if (blobMetaData == null) {_                        break__                    }_                    totalSize += blobMetaData.length()__                }_                return totalSize == fileInfo.length()__            }_            _            return false__        };checks,if,snapshot,file,already,exists,in,the,list,of,blobs,param,file,info,file,to,check,param,blobs,list,of,blobs,return,true,if,file,exists,in,the,list,of,blobs;private,boolean,snapshot,file,exists,in,blobs,blob,store,index,shard,snapshot,file,info,file,info,map,string,blob,meta,data,blobs,blob,meta,data,blob,meta,data,blobs,get,file,info,name,if,blob,meta,data,null,return,blob,meta,data,length,file,info,length,else,if,blobs,contains,key,file,info,part,name,0,int,part,0,long,total,size,0,while,true,blob,meta,data,blobs,get,file,info,part,name,part,if,blob,meta,data,null,break,total,size,blob,meta,data,length,return,total,size,file,info,length,return,false
BlobStoreRepository -> SnapshotContext -> private boolean snapshotFileExistsInBlobs(BlobStoreIndexShardSnapshot.FileInfo fileInfo, Map<String, BlobMetaData> blobs);1550647627;Checks if snapshot file already exists in the list of blobs__@param fileInfo file to check_@param blobs    list of blobs_@return true if file exists in the list of blobs;private boolean snapshotFileExistsInBlobs(BlobStoreIndexShardSnapshot.FileInfo fileInfo, Map<String, BlobMetaData> blobs) {_            BlobMetaData blobMetaData = blobs.get(fileInfo.name())__            if (blobMetaData != null) {_                return blobMetaData.length() == fileInfo.length()__            } else if (blobs.containsKey(fileInfo.partName(0))) {_                _                int part = 0__                long totalSize = 0__                while (true) {_                    blobMetaData = blobs.get(fileInfo.partName(part++))__                    if (blobMetaData == null) {_                        break__                    }_                    totalSize += blobMetaData.length()__                }_                return totalSize == fileInfo.length()__            }_            _            return false__        };checks,if,snapshot,file,already,exists,in,the,list,of,blobs,param,file,info,file,to,check,param,blobs,list,of,blobs,return,true,if,file,exists,in,the,list,of,blobs;private,boolean,snapshot,file,exists,in,blobs,blob,store,index,shard,snapshot,file,info,file,info,map,string,blob,meta,data,blobs,blob,meta,data,blob,meta,data,blobs,get,file,info,name,if,blob,meta,data,null,return,blob,meta,data,length,file,info,length,else,if,blobs,contains,key,file,info,part,name,0,int,part,0,long,total,size,0,while,true,blob,meta,data,blobs,get,file,info,part,name,part,if,blob,meta,data,null,break,total,size,blob,meta,data,length,return,total,size,file,info,length,return,false
BlobStoreRepository -> Context -> public BlobStoreIndexShardSnapshot loadSnapshot();1524684173;Loads information about shard snapshot;public BlobStoreIndexShardSnapshot loadSnapshot() {_            try {_                return indexShardSnapshotFormat(version).read(blobContainer, snapshotId.getUUID())__            } catch (IOException ex) {_                throw new SnapshotException(metadata.name(), snapshotId, "failed to read shard snapshot file for " + shardId, ex)__            }_        };loads,information,about,shard,snapshot;public,blob,store,index,shard,snapshot,load,snapshot,try,return,index,shard,snapshot,format,version,read,blob,container,snapshot,id,get,uuid,catch,ioexception,ex,throw,new,snapshot,exception,metadata,name,snapshot,id,failed,to,read,shard,snapshot,file,for,shard,id,ex
BlobStoreRepository -> Context -> public BlobStoreIndexShardSnapshot loadSnapshot();1525334055;Loads information about shard snapshot;public BlobStoreIndexShardSnapshot loadSnapshot() {_            try {_                return indexShardSnapshotFormat(version).read(blobContainer, snapshotId.getUUID())__            } catch (IOException ex) {_                throw new SnapshotException(metadata.name(), snapshotId, "failed to read shard snapshot file for " + shardId, ex)__            }_        };loads,information,about,shard,snapshot;public,blob,store,index,shard,snapshot,load,snapshot,try,return,index,shard,snapshot,format,version,read,blob,container,snapshot,id,get,uuid,catch,ioexception,ex,throw,new,snapshot,exception,metadata,name,snapshot,id,failed,to,read,shard,snapshot,file,for,shard,id,ex
BlobStoreRepository -> SnapshotContext -> SnapshotContext(IndexShard shard, SnapshotId snapshotId, IndexId indexId, IndexShardSnapshotStatus snapshotStatus, long startTime);1524684173;Constructs new context__@param shard          shard to be snapshotted_@param snapshotId     snapshot id_@param indexId        the id of the index being snapshotted_@param snapshotStatus snapshot status to report progress;SnapshotContext(IndexShard shard, SnapshotId snapshotId, IndexId indexId, IndexShardSnapshotStatus snapshotStatus, long startTime) {_            super(snapshotId, Version.CURRENT, indexId, shard.shardId())__            this.snapshotStatus = snapshotStatus__            this.store = shard.store()__            this.startTime = startTime__        };constructs,new,context,param,shard,shard,to,be,snapshotted,param,snapshot,id,snapshot,id,param,index,id,the,id,of,the,index,being,snapshotted,param,snapshot,status,snapshot,status,to,report,progress;snapshot,context,index,shard,shard,snapshot,id,snapshot,id,index,id,index,id,index,shard,snapshot,status,snapshot,status,long,start,time,super,snapshot,id,version,current,index,id,shard,shard,id,this,snapshot,status,snapshot,status,this,store,shard,store,this,start,time,start,time
BlobStoreRepository -> SnapshotContext -> SnapshotContext(IndexShard shard, SnapshotId snapshotId, IndexId indexId, IndexShardSnapshotStatus snapshotStatus, long startTime);1525334055;Constructs new context__@param shard          shard to be snapshotted_@param snapshotId     snapshot id_@param indexId        the id of the index being snapshotted_@param snapshotStatus snapshot status to report progress;SnapshotContext(IndexShard shard, SnapshotId snapshotId, IndexId indexId, IndexShardSnapshotStatus snapshotStatus, long startTime) {_            super(snapshotId, Version.CURRENT, indexId, shard.shardId())__            this.snapshotStatus = snapshotStatus__            this.store = shard.store()__            this.startTime = startTime__        };constructs,new,context,param,shard,shard,to,be,snapshotted,param,snapshot,id,snapshot,id,param,index,id,the,id,of,the,index,being,snapshotted,param,snapshot,status,snapshot,status,to,report,progress;snapshot,context,index,shard,shard,snapshot,id,snapshot,id,index,id,index,id,index,shard,snapshot,status,snapshot,status,long,start,time,super,snapshot,id,version,current,index,id,shard,shard,id,this,snapshot,status,snapshot,status,this,store,shard,store,this,start,time,start,time
BlobStoreRepository -> SnapshotContext -> SnapshotContext(IndexShard shard, SnapshotId snapshotId, IndexId indexId, IndexShardSnapshotStatus snapshotStatus, long startTime);1525798020;Constructs new context__@param shard          shard to be snapshotted_@param snapshotId     snapshot id_@param indexId        the id of the index being snapshotted_@param snapshotStatus snapshot status to report progress;SnapshotContext(IndexShard shard, SnapshotId snapshotId, IndexId indexId, IndexShardSnapshotStatus snapshotStatus, long startTime) {_            super(snapshotId, Version.CURRENT, indexId, shard.shardId())__            this.snapshotStatus = snapshotStatus__            this.store = shard.store()__            this.startTime = startTime__        };constructs,new,context,param,shard,shard,to,be,snapshotted,param,snapshot,id,snapshot,id,param,index,id,the,id,of,the,index,being,snapshotted,param,snapshot,status,snapshot,status,to,report,progress;snapshot,context,index,shard,shard,snapshot,id,snapshot,id,index,id,index,id,index,shard,snapshot,status,snapshot,status,long,start,time,super,snapshot,id,version,current,index,id,shard,shard,id,this,snapshot,status,snapshot,status,this,store,shard,store,this,start,time,start,time
BlobStoreRepository -> SnapshotContext -> SnapshotContext(IndexShard shard, SnapshotId snapshotId, IndexId indexId, IndexShardSnapshotStatus snapshotStatus, long startTime);1526289033;Constructs new context__@param shard          shard to be snapshotted_@param snapshotId     snapshot id_@param indexId        the id of the index being snapshotted_@param snapshotStatus snapshot status to report progress;SnapshotContext(IndexShard shard, SnapshotId snapshotId, IndexId indexId, IndexShardSnapshotStatus snapshotStatus, long startTime) {_            super(snapshotId, Version.CURRENT, indexId, shard.shardId())__            this.snapshotStatus = snapshotStatus__            this.store = shard.store()__            this.startTime = startTime__        };constructs,new,context,param,shard,shard,to,be,snapshotted,param,snapshot,id,snapshot,id,param,index,id,the,id,of,the,index,being,snapshotted,param,snapshot,status,snapshot,status,to,report,progress;snapshot,context,index,shard,shard,snapshot,id,snapshot,id,index,id,index,id,index,shard,snapshot,status,snapshot,status,long,start,time,super,snapshot,id,version,current,index,id,shard,shard,id,this,snapshot,status,snapshot,status,this,store,shard,store,this,start,time,start,time
BlobStoreRepository -> SnapshotContext -> SnapshotContext(IndexShard shard, SnapshotId snapshotId, IndexId indexId, IndexShardSnapshotStatus snapshotStatus, long startTime);1526574077;Constructs new context__@param shard          shard to be snapshotted_@param snapshotId     snapshot id_@param indexId        the id of the index being snapshotted_@param snapshotStatus snapshot status to report progress;SnapshotContext(IndexShard shard, SnapshotId snapshotId, IndexId indexId, IndexShardSnapshotStatus snapshotStatus, long startTime) {_            super(snapshotId, Version.CURRENT, indexId, shard.shardId())__            this.snapshotStatus = snapshotStatus__            this.store = shard.store()__            this.startTime = startTime__        };constructs,new,context,param,shard,shard,to,be,snapshotted,param,snapshot,id,snapshot,id,param,index,id,the,id,of,the,index,being,snapshotted,param,snapshot,status,snapshot,status,to,report,progress;snapshot,context,index,shard,shard,snapshot,id,snapshot,id,index,id,index,id,index,shard,snapshot,status,snapshot,status,long,start,time,super,snapshot,id,version,current,index,id,shard,shard,id,this,snapshot,status,snapshot,status,this,store,shard,store,this,start,time,start,time
BlobStoreRepository -> SnapshotContext -> SnapshotContext(IndexShard shard, SnapshotId snapshotId, IndexId indexId, IndexShardSnapshotStatus snapshotStatus, long startTime);1527583663;Constructs new context__@param shard          shard to be snapshotted_@param snapshotId     snapshot id_@param indexId        the id of the index being snapshotted_@param snapshotStatus snapshot status to report progress;SnapshotContext(IndexShard shard, SnapshotId snapshotId, IndexId indexId, IndexShardSnapshotStatus snapshotStatus, long startTime) {_            super(snapshotId, Version.CURRENT, indexId, shard.shardId())__            this.snapshotStatus = snapshotStatus__            this.store = shard.store()__            this.startTime = startTime__        };constructs,new,context,param,shard,shard,to,be,snapshotted,param,snapshot,id,snapshot,id,param,index,id,the,id,of,the,index,being,snapshotted,param,snapshot,status,snapshot,status,to,report,progress;snapshot,context,index,shard,shard,snapshot,id,snapshot,id,index,id,index,id,index,shard,snapshot,status,snapshot,status,long,start,time,super,snapshot,id,version,current,index,id,shard,shard,id,this,snapshot,status,snapshot,status,this,store,shard,store,this,start,time,start,time
BlobStoreRepository -> SnapshotContext -> SnapshotContext(IndexShard shard, SnapshotId snapshotId, IndexId indexId, IndexShardSnapshotStatus snapshotStatus, long startTime);1528211342;Constructs new context__@param shard          shard to be snapshotted_@param snapshotId     snapshot id_@param indexId        the id of the index being snapshotted_@param snapshotStatus snapshot status to report progress;SnapshotContext(IndexShard shard, SnapshotId snapshotId, IndexId indexId, IndexShardSnapshotStatus snapshotStatus, long startTime) {_            super(snapshotId, Version.CURRENT, indexId, shard.shardId())__            this.snapshotStatus = snapshotStatus__            this.store = shard.store()__            this.startTime = startTime__        };constructs,new,context,param,shard,shard,to,be,snapshotted,param,snapshot,id,snapshot,id,param,index,id,the,id,of,the,index,being,snapshotted,param,snapshot,status,snapshot,status,to,report,progress;snapshot,context,index,shard,shard,snapshot,id,snapshot,id,index,id,index,id,index,shard,snapshot,status,snapshot,status,long,start,time,super,snapshot,id,version,current,index,id,shard,shard,id,this,snapshot,status,snapshot,status,this,store,shard,store,this,start,time,start,time
BlobStoreRepository -> SnapshotContext -> SnapshotContext(IndexShard shard, SnapshotId snapshotId, IndexId indexId, IndexShardSnapshotStatus snapshotStatus, long startTime);1531179852;Constructs new context__@param shard          shard to be snapshotted_@param snapshotId     snapshot id_@param indexId        the id of the index being snapshotted_@param snapshotStatus snapshot status to report progress;SnapshotContext(IndexShard shard, SnapshotId snapshotId, IndexId indexId, IndexShardSnapshotStatus snapshotStatus, long startTime) {_            super(snapshotId, Version.CURRENT, indexId, shard.shardId())__            this.snapshotStatus = snapshotStatus__            this.store = shard.store()__            this.startTime = startTime__        };constructs,new,context,param,shard,shard,to,be,snapshotted,param,snapshot,id,snapshot,id,param,index,id,the,id,of,the,index,being,snapshotted,param,snapshot,status,snapshot,status,to,report,progress;snapshot,context,index,shard,shard,snapshot,id,snapshot,id,index,id,index,id,index,shard,snapshot,status,snapshot,status,long,start,time,super,snapshot,id,version,current,index,id,shard,shard,id,this,snapshot,status,snapshot,status,this,store,shard,store,this,start,time,start,time
BlobStoreRepository -> SnapshotContext -> SnapshotContext(IndexShard shard, SnapshotId snapshotId, IndexId indexId, IndexShardSnapshotStatus snapshotStatus, long startTime);1531729807;Constructs new context__@param shard          shard to be snapshotted_@param snapshotId     snapshot id_@param indexId        the id of the index being snapshotted_@param snapshotStatus snapshot status to report progress;SnapshotContext(IndexShard shard, SnapshotId snapshotId, IndexId indexId, IndexShardSnapshotStatus snapshotStatus, long startTime) {_            super(snapshotId, Version.CURRENT, indexId, shard.shardId())__            this.snapshotStatus = snapshotStatus__            this.store = shard.store()__            this.startTime = startTime__        };constructs,new,context,param,shard,shard,to,be,snapshotted,param,snapshot,id,snapshot,id,param,index,id,the,id,of,the,index,being,snapshotted,param,snapshot,status,snapshot,status,to,report,progress;snapshot,context,index,shard,shard,snapshot,id,snapshot,id,index,id,index,id,index,shard,snapshot,status,snapshot,status,long,start,time,super,snapshot,id,version,current,index,id,shard,shard,id,this,snapshot,status,snapshot,status,this,store,shard,store,this,start,time,start,time
BlobStoreRepository -> SnapshotContext -> SnapshotContext(IndexShard shard, SnapshotId snapshotId, IndexId indexId, IndexShardSnapshotStatus snapshotStatus, long startTime);1532685069;Constructs new context__@param shard          shard to be snapshotted_@param snapshotId     snapshot id_@param indexId        the id of the index being snapshotted_@param snapshotStatus snapshot status to report progress;SnapshotContext(IndexShard shard, SnapshotId snapshotId, IndexId indexId, IndexShardSnapshotStatus snapshotStatus, long startTime) {_            super(snapshotId, Version.CURRENT, indexId, shard.shardId())__            this.snapshotStatus = snapshotStatus__            this.store = shard.store()__            this.startTime = startTime__        };constructs,new,context,param,shard,shard,to,be,snapshotted,param,snapshot,id,snapshot,id,param,index,id,the,id,of,the,index,being,snapshotted,param,snapshot,status,snapshot,status,to,report,progress;snapshot,context,index,shard,shard,snapshot,id,snapshot,id,index,id,index,id,index,shard,snapshot,status,snapshot,status,long,start,time,super,snapshot,id,version,current,index,id,shard,shard,id,this,snapshot,status,snapshot,status,this,store,shard,store,this,start,time,start,time
BlobStoreRepository -> SnapshotContext -> SnapshotContext(IndexShard shard, SnapshotId snapshotId, IndexId indexId, IndexShardSnapshotStatus snapshotStatus, long startTime);1535139672;Constructs new context__@param shard          shard to be snapshotted_@param snapshotId     snapshot id_@param indexId        the id of the index being snapshotted_@param snapshotStatus snapshot status to report progress;SnapshotContext(IndexShard shard, SnapshotId snapshotId, IndexId indexId, IndexShardSnapshotStatus snapshotStatus, long startTime) {_            super(snapshotId, Version.CURRENT, indexId, shard.shardId())__            this.snapshotStatus = snapshotStatus__            this.store = shard.store()__            this.startTime = startTime__        };constructs,new,context,param,shard,shard,to,be,snapshotted,param,snapshot,id,snapshot,id,param,index,id,the,id,of,the,index,being,snapshotted,param,snapshot,status,snapshot,status,to,report,progress;snapshot,context,index,shard,shard,snapshot,id,snapshot,id,index,id,index,id,index,shard,snapshot,status,snapshot,status,long,start,time,super,snapshot,id,version,current,index,id,shard,shard,id,this,snapshot,status,snapshot,status,this,store,shard,store,this,start,time,start,time
BlobStoreRepository -> SnapshotContext -> SnapshotContext(IndexShard shard, SnapshotId snapshotId, IndexId indexId, IndexShardSnapshotStatus snapshotStatus, long startTime);1535723122;Constructs new context__@param shard          shard to be snapshotted_@param snapshotId     snapshot id_@param indexId        the id of the index being snapshotted_@param snapshotStatus snapshot status to report progress;SnapshotContext(IndexShard shard, SnapshotId snapshotId, IndexId indexId, IndexShardSnapshotStatus snapshotStatus, long startTime) {_            super(snapshotId, Version.CURRENT, indexId, shard.shardId())__            this.snapshotStatus = snapshotStatus__            this.store = shard.store()__            this.startTime = startTime__        };constructs,new,context,param,shard,shard,to,be,snapshotted,param,snapshot,id,snapshot,id,param,index,id,the,id,of,the,index,being,snapshotted,param,snapshot,status,snapshot,status,to,report,progress;snapshot,context,index,shard,shard,snapshot,id,snapshot,id,index,id,index,id,index,shard,snapshot,status,snapshot,status,long,start,time,super,snapshot,id,version,current,index,id,shard,shard,id,this,snapshot,status,snapshot,status,this,store,shard,store,this,start,time,start,time
BlobStoreRepository -> SnapshotContext -> SnapshotContext(IndexShard shard, SnapshotId snapshotId, IndexId indexId, IndexShardSnapshotStatus snapshotStatus, long startTime);1536314350;Constructs new context__@param shard          shard to be snapshotted_@param snapshotId     snapshot id_@param indexId        the id of the index being snapshotted_@param snapshotStatus snapshot status to report progress;SnapshotContext(IndexShard shard, SnapshotId snapshotId, IndexId indexId, IndexShardSnapshotStatus snapshotStatus, long startTime) {_            super(snapshotId, Version.CURRENT, indexId, shard.shardId())__            this.snapshotStatus = snapshotStatus__            this.store = shard.store()__            this.startTime = startTime__        };constructs,new,context,param,shard,shard,to,be,snapshotted,param,snapshot,id,snapshot,id,param,index,id,the,id,of,the,index,being,snapshotted,param,snapshot,status,snapshot,status,to,report,progress;snapshot,context,index,shard,shard,snapshot,id,snapshot,id,index,id,index,id,index,shard,snapshot,status,snapshot,status,long,start,time,super,snapshot,id,version,current,index,id,shard,shard,id,this,snapshot,status,snapshot,status,this,store,shard,store,this,start,time,start,time
BlobStoreRepository -> protected abstract BlobPath basePath()_;1524684173;Returns base path of the repository;protected abstract BlobPath basePath()_;returns,base,path,of,the,repository;protected,abstract,blob,path,base,path
BlobStoreRepository -> protected abstract BlobPath basePath()_;1525334055;Returns base path of the repository;protected abstract BlobPath basePath()_;returns,base,path,of,the,repository;protected,abstract,blob,path,base,path
BlobStoreRepository -> protected abstract BlobPath basePath()_;1525798020;Returns base path of the repository;protected abstract BlobPath basePath()_;returns,base,path,of,the,repository;protected,abstract,blob,path,base,path
BlobStoreRepository -> protected abstract BlobPath basePath()_;1526289033;Returns base path of the repository;protected abstract BlobPath basePath()_;returns,base,path,of,the,repository;protected,abstract,blob,path,base,path
BlobStoreRepository -> protected abstract BlobPath basePath()_;1526574077;Returns base path of the repository;protected abstract BlobPath basePath()_;returns,base,path,of,the,repository;protected,abstract,blob,path,base,path
BlobStoreRepository -> protected abstract BlobPath basePath()_;1527583663;Returns base path of the repository;protected abstract BlobPath basePath()_;returns,base,path,of,the,repository;protected,abstract,blob,path,base,path
BlobStoreRepository -> protected abstract BlobPath basePath()_;1528211342;Returns base path of the repository;protected abstract BlobPath basePath()_;returns,base,path,of,the,repository;protected,abstract,blob,path,base,path
BlobStoreRepository -> protected abstract BlobPath basePath()_;1531179852;Returns base path of the repository;protected abstract BlobPath basePath()_;returns,base,path,of,the,repository;protected,abstract,blob,path,base,path
BlobStoreRepository -> protected abstract BlobPath basePath()_;1531729807;Returns base path of the repository;protected abstract BlobPath basePath()_;returns,base,path,of,the,repository;protected,abstract,blob,path,base,path
BlobStoreRepository -> protected abstract BlobPath basePath()_;1532685069;Returns base path of the repository;protected abstract BlobPath basePath()_;returns,base,path,of,the,repository;protected,abstract,blob,path,base,path
BlobStoreRepository -> protected abstract BlobPath basePath()_;1535139672;Returns base path of the repository;protected abstract BlobPath basePath()_;returns,base,path,of,the,repository;protected,abstract,blob,path,base,path
BlobStoreRepository -> protected abstract BlobPath basePath()_;1535723122;Returns base path of the repository;protected abstract BlobPath basePath()_;returns,base,path,of,the,repository;protected,abstract,blob,path,base,path
BlobStoreRepository -> protected abstract BlobPath basePath()_;1536314350;Returns base path of the repository;protected abstract BlobPath basePath()_;returns,base,path,of,the,repository;protected,abstract,blob,path,base,path
BlobStoreRepository -> protected abstract BlobPath basePath()_;1536828374;Returns base path of the repository;protected abstract BlobPath basePath()_;returns,base,path,of,the,repository;protected,abstract,blob,path,base,path
BlobStoreRepository -> protected abstract BlobPath basePath()_;1541008027;Returns base path of the repository;protected abstract BlobPath basePath()_;returns,base,path,of,the,repository;protected,abstract,blob,path,base,path
BlobStoreRepository -> protected abstract BlobPath basePath()_;1542646292;Returns base path of the repository;protected abstract BlobPath basePath()_;returns,base,path,of,the,repository;protected,abstract,blob,path,base,path
BlobStoreRepository -> protected abstract BlobPath basePath()_;1542980705;Returns base path of the repository;protected abstract BlobPath basePath()_;returns,base,path,of,the,repository;protected,abstract,blob,path,base,path
BlobStoreRepository -> protected abstract BlobPath basePath()_;1543831870;Returns base path of the repository;protected abstract BlobPath basePath()_;returns,base,path,of,the,repository;protected,abstract,blob,path,base,path
BlobStoreRepository -> protected abstract BlobPath basePath()_;1543942400;Returns base path of the repository;protected abstract BlobPath basePath()_;returns,base,path,of,the,repository;protected,abstract,blob,path,base,path
BlobStoreRepository -> protected abstract BlobPath basePath()_;1546974294;Returns base path of the repository;protected abstract BlobPath basePath()_;returns,base,path,of,the,repository;protected,abstract,blob,path,base,path
BlobStoreRepository -> protected abstract BlobPath basePath()_;1547496475;Returns base path of the repository;protected abstract BlobPath basePath()_;returns,base,path,of,the,repository;protected,abstract,blob,path,base,path
BlobStoreRepository -> protected abstract BlobPath basePath()_;1547625930;Returns base path of the repository;protected abstract BlobPath basePath()_;returns,base,path,of,the,repository;protected,abstract,blob,path,base,path
BlobStoreRepository -> protected abstract BlobPath basePath()_;1550647627;Returns base path of the repository;protected abstract BlobPath basePath()_;returns,base,path,of,the,repository;protected,abstract,blob,path,base,path
BlobStoreRepository -> @Override     public SnapshotInfo finalizeSnapshot(final SnapshotId snapshotId,                                          final List<IndexId> indices,                                          final long startTime,                                          final String failure,                                          final int totalShards,                                          final List<SnapshotShardFailure> shardFailures,                                          final long repositoryStateId,                                          final boolean includeGlobalState);1524684173;{@inheritDoc};@Override_    public SnapshotInfo finalizeSnapshot(final SnapshotId snapshotId,_                                         final List<IndexId> indices,_                                         final long startTime,_                                         final String failure,_                                         final int totalShards,_                                         final List<SnapshotShardFailure> shardFailures,_                                         final long repositoryStateId,_                                         final boolean includeGlobalState) {_        SnapshotInfo blobStoreSnapshot = new SnapshotInfo(snapshotId,_            indices.stream().map(IndexId::getName).collect(Collectors.toList()),_            startTime, failure, System.currentTimeMillis(), totalShards, shardFailures,_            includeGlobalState)__        try {_            snapshotFormat.write(blobStoreSnapshot, snapshotsBlobContainer, snapshotId.getUUID())__            final RepositoryData repositoryData = getRepositoryData()__            writeIndexGen(repositoryData.addSnapshot(snapshotId, blobStoreSnapshot.state(), indices), repositoryStateId)__        } catch (FileAlreadyExistsException ex) {_            _            _            _            throw new RepositoryException(metadata.name(), "Blob already exists while " +_                "finalizing snapshot, assume the snapshot has already been saved", ex)__        } catch (IOException ex) {_            throw new RepositoryException(metadata.name(), "failed to update snapshot in repository", ex)__        }_        return blobStoreSnapshot__    };inherit,doc;override,public,snapshot,info,finalize,snapshot,final,snapshot,id,snapshot,id,final,list,index,id,indices,final,long,start,time,final,string,failure,final,int,total,shards,final,list,snapshot,shard,failure,shard,failures,final,long,repository,state,id,final,boolean,include,global,state,snapshot,info,blob,store,snapshot,new,snapshot,info,snapshot,id,indices,stream,map,index,id,get,name,collect,collectors,to,list,start,time,failure,system,current,time,millis,total,shards,shard,failures,include,global,state,try,snapshot,format,write,blob,store,snapshot,snapshots,blob,container,snapshot,id,get,uuid,final,repository,data,repository,data,get,repository,data,write,index,gen,repository,data,add,snapshot,snapshot,id,blob,store,snapshot,state,indices,repository,state,id,catch,file,already,exists,exception,ex,throw,new,repository,exception,metadata,name,blob,already,exists,while,finalizing,snapshot,assume,the,snapshot,has,already,been,saved,ex,catch,ioexception,ex,throw,new,repository,exception,metadata,name,failed,to,update,snapshot,in,repository,ex,return,blob,store,snapshot
BlobStoreRepository -> @Override     public SnapshotInfo finalizeSnapshot(final SnapshotId snapshotId,                                          final List<IndexId> indices,                                          final long startTime,                                          final String failure,                                          final int totalShards,                                          final List<SnapshotShardFailure> shardFailures,                                          final long repositoryStateId,                                          final boolean includeGlobalState);1525334055;{@inheritDoc};@Override_    public SnapshotInfo finalizeSnapshot(final SnapshotId snapshotId,_                                         final List<IndexId> indices,_                                         final long startTime,_                                         final String failure,_                                         final int totalShards,_                                         final List<SnapshotShardFailure> shardFailures,_                                         final long repositoryStateId,_                                         final boolean includeGlobalState) {_        SnapshotInfo blobStoreSnapshot = new SnapshotInfo(snapshotId,_            indices.stream().map(IndexId::getName).collect(Collectors.toList()),_            startTime, failure, System.currentTimeMillis(), totalShards, shardFailures,_            includeGlobalState)__        try {_            snapshotFormat.write(blobStoreSnapshot, snapshotsBlobContainer, snapshotId.getUUID())__            final RepositoryData repositoryData = getRepositoryData()__            writeIndexGen(repositoryData.addSnapshot(snapshotId, blobStoreSnapshot.state(), indices), repositoryStateId)__        } catch (FileAlreadyExistsException ex) {_            _            _            _            throw new RepositoryException(metadata.name(), "Blob already exists while " +_                "finalizing snapshot, assume the snapshot has already been saved", ex)__        } catch (IOException ex) {_            throw new RepositoryException(metadata.name(), "failed to update snapshot in repository", ex)__        }_        return blobStoreSnapshot__    };inherit,doc;override,public,snapshot,info,finalize,snapshot,final,snapshot,id,snapshot,id,final,list,index,id,indices,final,long,start,time,final,string,failure,final,int,total,shards,final,list,snapshot,shard,failure,shard,failures,final,long,repository,state,id,final,boolean,include,global,state,snapshot,info,blob,store,snapshot,new,snapshot,info,snapshot,id,indices,stream,map,index,id,get,name,collect,collectors,to,list,start,time,failure,system,current,time,millis,total,shards,shard,failures,include,global,state,try,snapshot,format,write,blob,store,snapshot,snapshots,blob,container,snapshot,id,get,uuid,final,repository,data,repository,data,get,repository,data,write,index,gen,repository,data,add,snapshot,snapshot,id,blob,store,snapshot,state,indices,repository,state,id,catch,file,already,exists,exception,ex,throw,new,repository,exception,metadata,name,blob,already,exists,while,finalizing,snapshot,assume,the,snapshot,has,already,been,saved,ex,catch,ioexception,ex,throw,new,repository,exception,metadata,name,failed,to,update,snapshot,in,repository,ex,return,blob,store,snapshot
BlobStoreRepository -> @Override     public SnapshotInfo finalizeSnapshot(final SnapshotId snapshotId,                                          final List<IndexId> indices,                                          final long startTime,                                          final String failure,                                          final int totalShards,                                          final List<SnapshotShardFailure> shardFailures,                                          final long repositoryStateId,                                          final boolean includeGlobalState);1525798020;{@inheritDoc};@Override_    public SnapshotInfo finalizeSnapshot(final SnapshotId snapshotId,_                                         final List<IndexId> indices,_                                         final long startTime,_                                         final String failure,_                                         final int totalShards,_                                         final List<SnapshotShardFailure> shardFailures,_                                         final long repositoryStateId,_                                         final boolean includeGlobalState) {_        SnapshotInfo blobStoreSnapshot = new SnapshotInfo(snapshotId,_            indices.stream().map(IndexId::getName).collect(Collectors.toList()),_            startTime, failure, System.currentTimeMillis(), totalShards, shardFailures,_            includeGlobalState)__        try {_            snapshotFormat.write(blobStoreSnapshot, snapshotsBlobContainer, snapshotId.getUUID())__            final RepositoryData repositoryData = getRepositoryData()__            writeIndexGen(repositoryData.addSnapshot(snapshotId, blobStoreSnapshot.state(), indices), repositoryStateId)__        } catch (FileAlreadyExistsException ex) {_            _            _            _            throw new RepositoryException(metadata.name(), "Blob already exists while " +_                "finalizing snapshot, assume the snapshot has already been saved", ex)__        } catch (IOException ex) {_            throw new RepositoryException(metadata.name(), "failed to update snapshot in repository", ex)__        }_        return blobStoreSnapshot__    };inherit,doc;override,public,snapshot,info,finalize,snapshot,final,snapshot,id,snapshot,id,final,list,index,id,indices,final,long,start,time,final,string,failure,final,int,total,shards,final,list,snapshot,shard,failure,shard,failures,final,long,repository,state,id,final,boolean,include,global,state,snapshot,info,blob,store,snapshot,new,snapshot,info,snapshot,id,indices,stream,map,index,id,get,name,collect,collectors,to,list,start,time,failure,system,current,time,millis,total,shards,shard,failures,include,global,state,try,snapshot,format,write,blob,store,snapshot,snapshots,blob,container,snapshot,id,get,uuid,final,repository,data,repository,data,get,repository,data,write,index,gen,repository,data,add,snapshot,snapshot,id,blob,store,snapshot,state,indices,repository,state,id,catch,file,already,exists,exception,ex,throw,new,repository,exception,metadata,name,blob,already,exists,while,finalizing,snapshot,assume,the,snapshot,has,already,been,saved,ex,catch,ioexception,ex,throw,new,repository,exception,metadata,name,failed,to,update,snapshot,in,repository,ex,return,blob,store,snapshot
BlobStoreRepository -> @Override     public SnapshotInfo finalizeSnapshot(final SnapshotId snapshotId,                                          final List<IndexId> indices,                                          final long startTime,                                          final String failure,                                          final int totalShards,                                          final List<SnapshotShardFailure> shardFailures,                                          final long repositoryStateId,                                          final boolean includeGlobalState);1526289033;{@inheritDoc};@Override_    public SnapshotInfo finalizeSnapshot(final SnapshotId snapshotId,_                                         final List<IndexId> indices,_                                         final long startTime,_                                         final String failure,_                                         final int totalShards,_                                         final List<SnapshotShardFailure> shardFailures,_                                         final long repositoryStateId,_                                         final boolean includeGlobalState) {_        SnapshotInfo blobStoreSnapshot = new SnapshotInfo(snapshotId,_            indices.stream().map(IndexId::getName).collect(Collectors.toList()),_            startTime, failure, System.currentTimeMillis(), totalShards, shardFailures,_            includeGlobalState)__        try {_            snapshotFormat.write(blobStoreSnapshot, snapshotsBlobContainer, snapshotId.getUUID())__            final RepositoryData repositoryData = getRepositoryData()__            writeIndexGen(repositoryData.addSnapshot(snapshotId, blobStoreSnapshot.state(), indices), repositoryStateId)__        } catch (FileAlreadyExistsException ex) {_            _            _            _            throw new RepositoryException(metadata.name(), "Blob already exists while " +_                "finalizing snapshot, assume the snapshot has already been saved", ex)__        } catch (IOException ex) {_            throw new RepositoryException(metadata.name(), "failed to update snapshot in repository", ex)__        }_        return blobStoreSnapshot__    };inherit,doc;override,public,snapshot,info,finalize,snapshot,final,snapshot,id,snapshot,id,final,list,index,id,indices,final,long,start,time,final,string,failure,final,int,total,shards,final,list,snapshot,shard,failure,shard,failures,final,long,repository,state,id,final,boolean,include,global,state,snapshot,info,blob,store,snapshot,new,snapshot,info,snapshot,id,indices,stream,map,index,id,get,name,collect,collectors,to,list,start,time,failure,system,current,time,millis,total,shards,shard,failures,include,global,state,try,snapshot,format,write,blob,store,snapshot,snapshots,blob,container,snapshot,id,get,uuid,final,repository,data,repository,data,get,repository,data,write,index,gen,repository,data,add,snapshot,snapshot,id,blob,store,snapshot,state,indices,repository,state,id,catch,file,already,exists,exception,ex,throw,new,repository,exception,metadata,name,blob,already,exists,while,finalizing,snapshot,assume,the,snapshot,has,already,been,saved,ex,catch,ioexception,ex,throw,new,repository,exception,metadata,name,failed,to,update,snapshot,in,repository,ex,return,blob,store,snapshot
BlobStoreRepository -> @Override     public SnapshotInfo finalizeSnapshot(final SnapshotId snapshotId,                                          final List<IndexId> indices,                                          final long startTime,                                          final String failure,                                          final int totalShards,                                          final List<SnapshotShardFailure> shardFailures,                                          final long repositoryStateId,                                          final boolean includeGlobalState);1526574077;{@inheritDoc};@Override_    public SnapshotInfo finalizeSnapshot(final SnapshotId snapshotId,_                                         final List<IndexId> indices,_                                         final long startTime,_                                         final String failure,_                                         final int totalShards,_                                         final List<SnapshotShardFailure> shardFailures,_                                         final long repositoryStateId,_                                         final boolean includeGlobalState) {_        SnapshotInfo blobStoreSnapshot = new SnapshotInfo(snapshotId,_            indices.stream().map(IndexId::getName).collect(Collectors.toList()),_            startTime, failure, System.currentTimeMillis(), totalShards, shardFailures,_            includeGlobalState)__        try {_            snapshotFormat.write(blobStoreSnapshot, snapshotsBlobContainer, snapshotId.getUUID())__            final RepositoryData repositoryData = getRepositoryData()__            writeIndexGen(repositoryData.addSnapshot(snapshotId, blobStoreSnapshot.state(), indices), repositoryStateId)__        } catch (FileAlreadyExistsException ex) {_            _            _            _            throw new RepositoryException(metadata.name(), "Blob already exists while " +_                "finalizing snapshot, assume the snapshot has already been saved", ex)__        } catch (IOException ex) {_            throw new RepositoryException(metadata.name(), "failed to update snapshot in repository", ex)__        }_        return blobStoreSnapshot__    };inherit,doc;override,public,snapshot,info,finalize,snapshot,final,snapshot,id,snapshot,id,final,list,index,id,indices,final,long,start,time,final,string,failure,final,int,total,shards,final,list,snapshot,shard,failure,shard,failures,final,long,repository,state,id,final,boolean,include,global,state,snapshot,info,blob,store,snapshot,new,snapshot,info,snapshot,id,indices,stream,map,index,id,get,name,collect,collectors,to,list,start,time,failure,system,current,time,millis,total,shards,shard,failures,include,global,state,try,snapshot,format,write,blob,store,snapshot,snapshots,blob,container,snapshot,id,get,uuid,final,repository,data,repository,data,get,repository,data,write,index,gen,repository,data,add,snapshot,snapshot,id,blob,store,snapshot,state,indices,repository,state,id,catch,file,already,exists,exception,ex,throw,new,repository,exception,metadata,name,blob,already,exists,while,finalizing,snapshot,assume,the,snapshot,has,already,been,saved,ex,catch,ioexception,ex,throw,new,repository,exception,metadata,name,failed,to,update,snapshot,in,repository,ex,return,blob,store,snapshot
BlobStoreRepository -> @Override     public SnapshotInfo finalizeSnapshot(final SnapshotId snapshotId,                                          final List<IndexId> indices,                                          final long startTime,                                          final String failure,                                          final int totalShards,                                          final List<SnapshotShardFailure> shardFailures,                                          final long repositoryStateId,                                          final boolean includeGlobalState);1527583663;{@inheritDoc};@Override_    public SnapshotInfo finalizeSnapshot(final SnapshotId snapshotId,_                                         final List<IndexId> indices,_                                         final long startTime,_                                         final String failure,_                                         final int totalShards,_                                         final List<SnapshotShardFailure> shardFailures,_                                         final long repositoryStateId,_                                         final boolean includeGlobalState) {_        SnapshotInfo blobStoreSnapshot = new SnapshotInfo(snapshotId,_            indices.stream().map(IndexId::getName).collect(Collectors.toList()),_            startTime, failure, System.currentTimeMillis(), totalShards, shardFailures,_            includeGlobalState)__        try {_            snapshotFormat.write(blobStoreSnapshot, snapshotsBlobContainer, snapshotId.getUUID())__            final RepositoryData repositoryData = getRepositoryData()__            writeIndexGen(repositoryData.addSnapshot(snapshotId, blobStoreSnapshot.state(), indices), repositoryStateId)__        } catch (FileAlreadyExistsException ex) {_            _            _            _            throw new RepositoryException(metadata.name(), "Blob already exists while " +_                "finalizing snapshot, assume the snapshot has already been saved", ex)__        } catch (IOException ex) {_            throw new RepositoryException(metadata.name(), "failed to update snapshot in repository", ex)__        }_        return blobStoreSnapshot__    };inherit,doc;override,public,snapshot,info,finalize,snapshot,final,snapshot,id,snapshot,id,final,list,index,id,indices,final,long,start,time,final,string,failure,final,int,total,shards,final,list,snapshot,shard,failure,shard,failures,final,long,repository,state,id,final,boolean,include,global,state,snapshot,info,blob,store,snapshot,new,snapshot,info,snapshot,id,indices,stream,map,index,id,get,name,collect,collectors,to,list,start,time,failure,system,current,time,millis,total,shards,shard,failures,include,global,state,try,snapshot,format,write,blob,store,snapshot,snapshots,blob,container,snapshot,id,get,uuid,final,repository,data,repository,data,get,repository,data,write,index,gen,repository,data,add,snapshot,snapshot,id,blob,store,snapshot,state,indices,repository,state,id,catch,file,already,exists,exception,ex,throw,new,repository,exception,metadata,name,blob,already,exists,while,finalizing,snapshot,assume,the,snapshot,has,already,been,saved,ex,catch,ioexception,ex,throw,new,repository,exception,metadata,name,failed,to,update,snapshot,in,repository,ex,return,blob,store,snapshot
BlobStoreRepository -> @Override     public SnapshotInfo finalizeSnapshot(final SnapshotId snapshotId,                                          final List<IndexId> indices,                                          final long startTime,                                          final String failure,                                          final int totalShards,                                          final List<SnapshotShardFailure> shardFailures,                                          final long repositoryStateId,                                          final boolean includeGlobalState);1528211342;{@inheritDoc};@Override_    public SnapshotInfo finalizeSnapshot(final SnapshotId snapshotId,_                                         final List<IndexId> indices,_                                         final long startTime,_                                         final String failure,_                                         final int totalShards,_                                         final List<SnapshotShardFailure> shardFailures,_                                         final long repositoryStateId,_                                         final boolean includeGlobalState) {_        SnapshotInfo blobStoreSnapshot = new SnapshotInfo(snapshotId,_            indices.stream().map(IndexId::getName).collect(Collectors.toList()),_            startTime, failure, System.currentTimeMillis(), totalShards, shardFailures,_            includeGlobalState)__        try {_            snapshotFormat.write(blobStoreSnapshot, snapshotsBlobContainer, snapshotId.getUUID())__            final RepositoryData repositoryData = getRepositoryData()__            writeIndexGen(repositoryData.addSnapshot(snapshotId, blobStoreSnapshot.state(), indices), repositoryStateId)__        } catch (FileAlreadyExistsException ex) {_            _            _            _            throw new RepositoryException(metadata.name(), "Blob already exists while " +_                "finalizing snapshot, assume the snapshot has already been saved", ex)__        } catch (IOException ex) {_            throw new RepositoryException(metadata.name(), "failed to update snapshot in repository", ex)__        }_        return blobStoreSnapshot__    };inherit,doc;override,public,snapshot,info,finalize,snapshot,final,snapshot,id,snapshot,id,final,list,index,id,indices,final,long,start,time,final,string,failure,final,int,total,shards,final,list,snapshot,shard,failure,shard,failures,final,long,repository,state,id,final,boolean,include,global,state,snapshot,info,blob,store,snapshot,new,snapshot,info,snapshot,id,indices,stream,map,index,id,get,name,collect,collectors,to,list,start,time,failure,system,current,time,millis,total,shards,shard,failures,include,global,state,try,snapshot,format,write,blob,store,snapshot,snapshots,blob,container,snapshot,id,get,uuid,final,repository,data,repository,data,get,repository,data,write,index,gen,repository,data,add,snapshot,snapshot,id,blob,store,snapshot,state,indices,repository,state,id,catch,file,already,exists,exception,ex,throw,new,repository,exception,metadata,name,blob,already,exists,while,finalizing,snapshot,assume,the,snapshot,has,already,been,saved,ex,catch,ioexception,ex,throw,new,repository,exception,metadata,name,failed,to,update,snapshot,in,repository,ex,return,blob,store,snapshot
BlobStoreRepository -> @Override     public SnapshotInfo finalizeSnapshot(final SnapshotId snapshotId,                                          final List<IndexId> indices,                                          final long startTime,                                          final String failure,                                          final int totalShards,                                          final List<SnapshotShardFailure> shardFailures,                                          final long repositoryStateId,                                          final boolean includeGlobalState);1531179852;{@inheritDoc};@Override_    public SnapshotInfo finalizeSnapshot(final SnapshotId snapshotId,_                                         final List<IndexId> indices,_                                         final long startTime,_                                         final String failure,_                                         final int totalShards,_                                         final List<SnapshotShardFailure> shardFailures,_                                         final long repositoryStateId,_                                         final boolean includeGlobalState) {_        SnapshotInfo blobStoreSnapshot = new SnapshotInfo(snapshotId,_            indices.stream().map(IndexId::getName).collect(Collectors.toList()),_            startTime, failure, System.currentTimeMillis(), totalShards, shardFailures,_            includeGlobalState)__        try {_            snapshotFormat.write(blobStoreSnapshot, snapshotsBlobContainer, snapshotId.getUUID())__            final RepositoryData repositoryData = getRepositoryData()__            writeIndexGen(repositoryData.addSnapshot(snapshotId, blobStoreSnapshot.state(), indices), repositoryStateId)__        } catch (FileAlreadyExistsException ex) {_            _            _            _            throw new RepositoryException(metadata.name(), "Blob already exists while " +_                "finalizing snapshot, assume the snapshot has already been saved", ex)__        } catch (IOException ex) {_            throw new RepositoryException(metadata.name(), "failed to update snapshot in repository", ex)__        }_        return blobStoreSnapshot__    };inherit,doc;override,public,snapshot,info,finalize,snapshot,final,snapshot,id,snapshot,id,final,list,index,id,indices,final,long,start,time,final,string,failure,final,int,total,shards,final,list,snapshot,shard,failure,shard,failures,final,long,repository,state,id,final,boolean,include,global,state,snapshot,info,blob,store,snapshot,new,snapshot,info,snapshot,id,indices,stream,map,index,id,get,name,collect,collectors,to,list,start,time,failure,system,current,time,millis,total,shards,shard,failures,include,global,state,try,snapshot,format,write,blob,store,snapshot,snapshots,blob,container,snapshot,id,get,uuid,final,repository,data,repository,data,get,repository,data,write,index,gen,repository,data,add,snapshot,snapshot,id,blob,store,snapshot,state,indices,repository,state,id,catch,file,already,exists,exception,ex,throw,new,repository,exception,metadata,name,blob,already,exists,while,finalizing,snapshot,assume,the,snapshot,has,already,been,saved,ex,catch,ioexception,ex,throw,new,repository,exception,metadata,name,failed,to,update,snapshot,in,repository,ex,return,blob,store,snapshot
BlobStoreRepository -> @Override     public SnapshotInfo finalizeSnapshot(final SnapshotId snapshotId,                                          final List<IndexId> indices,                                          final long startTime,                                          final String failure,                                          final int totalShards,                                          final List<SnapshotShardFailure> shardFailures,                                          final long repositoryStateId,                                          final boolean includeGlobalState);1531729807;{@inheritDoc};@Override_    public SnapshotInfo finalizeSnapshot(final SnapshotId snapshotId,_                                         final List<IndexId> indices,_                                         final long startTime,_                                         final String failure,_                                         final int totalShards,_                                         final List<SnapshotShardFailure> shardFailures,_                                         final long repositoryStateId,_                                         final boolean includeGlobalState) {_        SnapshotInfo blobStoreSnapshot = new SnapshotInfo(snapshotId,_            indices.stream().map(IndexId::getName).collect(Collectors.toList()),_            startTime, failure, System.currentTimeMillis(), totalShards, shardFailures,_            includeGlobalState)__        try {_            snapshotFormat.write(blobStoreSnapshot, blobContainer(), snapshotId.getUUID())__            final RepositoryData repositoryData = getRepositoryData()__            writeIndexGen(repositoryData.addSnapshot(snapshotId, blobStoreSnapshot.state(), indices), repositoryStateId)__        } catch (FileAlreadyExistsException ex) {_            _            _            _            throw new RepositoryException(metadata.name(), "Blob already exists while " +_                "finalizing snapshot, assume the snapshot has already been saved", ex)__        } catch (IOException ex) {_            throw new RepositoryException(metadata.name(), "failed to update snapshot in repository", ex)__        }_        return blobStoreSnapshot__    };inherit,doc;override,public,snapshot,info,finalize,snapshot,final,snapshot,id,snapshot,id,final,list,index,id,indices,final,long,start,time,final,string,failure,final,int,total,shards,final,list,snapshot,shard,failure,shard,failures,final,long,repository,state,id,final,boolean,include,global,state,snapshot,info,blob,store,snapshot,new,snapshot,info,snapshot,id,indices,stream,map,index,id,get,name,collect,collectors,to,list,start,time,failure,system,current,time,millis,total,shards,shard,failures,include,global,state,try,snapshot,format,write,blob,store,snapshot,blob,container,snapshot,id,get,uuid,final,repository,data,repository,data,get,repository,data,write,index,gen,repository,data,add,snapshot,snapshot,id,blob,store,snapshot,state,indices,repository,state,id,catch,file,already,exists,exception,ex,throw,new,repository,exception,metadata,name,blob,already,exists,while,finalizing,snapshot,assume,the,snapshot,has,already,been,saved,ex,catch,ioexception,ex,throw,new,repository,exception,metadata,name,failed,to,update,snapshot,in,repository,ex,return,blob,store,snapshot
BlobStoreRepository -> @Override     public SnapshotInfo finalizeSnapshot(final SnapshotId snapshotId,                                          final List<IndexId> indices,                                          final long startTime,                                          final String failure,                                          final int totalShards,                                          final List<SnapshotShardFailure> shardFailures,                                          final long repositoryStateId,                                          final boolean includeGlobalState);1532685069;{@inheritDoc};@Override_    public SnapshotInfo finalizeSnapshot(final SnapshotId snapshotId,_                                         final List<IndexId> indices,_                                         final long startTime,_                                         final String failure,_                                         final int totalShards,_                                         final List<SnapshotShardFailure> shardFailures,_                                         final long repositoryStateId,_                                         final boolean includeGlobalState) {_        SnapshotInfo blobStoreSnapshot = new SnapshotInfo(snapshotId,_            indices.stream().map(IndexId::getName).collect(Collectors.toList()),_            startTime, failure, System.currentTimeMillis(), totalShards, shardFailures,_            includeGlobalState)__        try {_            snapshotFormat.write(blobStoreSnapshot, blobContainer(), snapshotId.getUUID())__            final RepositoryData repositoryData = getRepositoryData()__            writeIndexGen(repositoryData.addSnapshot(snapshotId, blobStoreSnapshot.state(), indices), repositoryStateId)__        } catch (FileAlreadyExistsException ex) {_            _            _            _            throw new RepositoryException(metadata.name(), "Blob already exists while " +_                "finalizing snapshot, assume the snapshot has already been saved", ex)__        } catch (IOException ex) {_            throw new RepositoryException(metadata.name(), "failed to update snapshot in repository", ex)__        }_        return blobStoreSnapshot__    };inherit,doc;override,public,snapshot,info,finalize,snapshot,final,snapshot,id,snapshot,id,final,list,index,id,indices,final,long,start,time,final,string,failure,final,int,total,shards,final,list,snapshot,shard,failure,shard,failures,final,long,repository,state,id,final,boolean,include,global,state,snapshot,info,blob,store,snapshot,new,snapshot,info,snapshot,id,indices,stream,map,index,id,get,name,collect,collectors,to,list,start,time,failure,system,current,time,millis,total,shards,shard,failures,include,global,state,try,snapshot,format,write,blob,store,snapshot,blob,container,snapshot,id,get,uuid,final,repository,data,repository,data,get,repository,data,write,index,gen,repository,data,add,snapshot,snapshot,id,blob,store,snapshot,state,indices,repository,state,id,catch,file,already,exists,exception,ex,throw,new,repository,exception,metadata,name,blob,already,exists,while,finalizing,snapshot,assume,the,snapshot,has,already,been,saved,ex,catch,ioexception,ex,throw,new,repository,exception,metadata,name,failed,to,update,snapshot,in,repository,ex,return,blob,store,snapshot
BlobStoreRepository -> @Override     public SnapshotInfo finalizeSnapshot(final SnapshotId snapshotId,                                          final List<IndexId> indices,                                          final long startTime,                                          final String failure,                                          final int totalShards,                                          final List<SnapshotShardFailure> shardFailures,                                          final long repositoryStateId,                                          final boolean includeGlobalState);1535139672;{@inheritDoc};@Override_    public SnapshotInfo finalizeSnapshot(final SnapshotId snapshotId,_                                         final List<IndexId> indices,_                                         final long startTime,_                                         final String failure,_                                         final int totalShards,_                                         final List<SnapshotShardFailure> shardFailures,_                                         final long repositoryStateId,_                                         final boolean includeGlobalState) {_        SnapshotInfo blobStoreSnapshot = new SnapshotInfo(snapshotId,_            indices.stream().map(IndexId::getName).collect(Collectors.toList()),_            startTime, failure, System.currentTimeMillis(), totalShards, shardFailures,_            includeGlobalState)__        try {_            snapshotFormat.write(blobStoreSnapshot, blobContainer(), snapshotId.getUUID())__            final RepositoryData repositoryData = getRepositoryData()__            writeIndexGen(repositoryData.addSnapshot(snapshotId, blobStoreSnapshot.state(), indices), repositoryStateId)__        } catch (FileAlreadyExistsException ex) {_            _            _            _            throw new RepositoryException(metadata.name(), "Blob already exists while " +_                "finalizing snapshot, assume the snapshot has already been saved", ex)__        } catch (IOException ex) {_            throw new RepositoryException(metadata.name(), "failed to update snapshot in repository", ex)__        }_        return blobStoreSnapshot__    };inherit,doc;override,public,snapshot,info,finalize,snapshot,final,snapshot,id,snapshot,id,final,list,index,id,indices,final,long,start,time,final,string,failure,final,int,total,shards,final,list,snapshot,shard,failure,shard,failures,final,long,repository,state,id,final,boolean,include,global,state,snapshot,info,blob,store,snapshot,new,snapshot,info,snapshot,id,indices,stream,map,index,id,get,name,collect,collectors,to,list,start,time,failure,system,current,time,millis,total,shards,shard,failures,include,global,state,try,snapshot,format,write,blob,store,snapshot,blob,container,snapshot,id,get,uuid,final,repository,data,repository,data,get,repository,data,write,index,gen,repository,data,add,snapshot,snapshot,id,blob,store,snapshot,state,indices,repository,state,id,catch,file,already,exists,exception,ex,throw,new,repository,exception,metadata,name,blob,already,exists,while,finalizing,snapshot,assume,the,snapshot,has,already,been,saved,ex,catch,ioexception,ex,throw,new,repository,exception,metadata,name,failed,to,update,snapshot,in,repository,ex,return,blob,store,snapshot
BlobStoreRepository -> @Override     public SnapshotInfo finalizeSnapshot(final SnapshotId snapshotId,                                          final List<IndexId> indices,                                          final long startTime,                                          final String failure,                                          final int totalShards,                                          final List<SnapshotShardFailure> shardFailures,                                          final long repositoryStateId,                                          final boolean includeGlobalState);1535723122;{@inheritDoc};@Override_    public SnapshotInfo finalizeSnapshot(final SnapshotId snapshotId,_                                         final List<IndexId> indices,_                                         final long startTime,_                                         final String failure,_                                         final int totalShards,_                                         final List<SnapshotShardFailure> shardFailures,_                                         final long repositoryStateId,_                                         final boolean includeGlobalState) {_        SnapshotInfo blobStoreSnapshot = new SnapshotInfo(snapshotId,_            indices.stream().map(IndexId::getName).collect(Collectors.toList()),_            startTime, failure, System.currentTimeMillis(), totalShards, shardFailures,_            includeGlobalState)__        try {_            snapshotFormat.write(blobStoreSnapshot, blobContainer(), snapshotId.getUUID())__            final RepositoryData repositoryData = getRepositoryData()__            writeIndexGen(repositoryData.addSnapshot(snapshotId, blobStoreSnapshot.state(), indices), repositoryStateId)__        } catch (FileAlreadyExistsException ex) {_            _            _            _            throw new RepositoryException(metadata.name(), "Blob already exists while " +_                "finalizing snapshot, assume the snapshot has already been saved", ex)__        } catch (IOException ex) {_            throw new RepositoryException(metadata.name(), "failed to update snapshot in repository", ex)__        }_        return blobStoreSnapshot__    };inherit,doc;override,public,snapshot,info,finalize,snapshot,final,snapshot,id,snapshot,id,final,list,index,id,indices,final,long,start,time,final,string,failure,final,int,total,shards,final,list,snapshot,shard,failure,shard,failures,final,long,repository,state,id,final,boolean,include,global,state,snapshot,info,blob,store,snapshot,new,snapshot,info,snapshot,id,indices,stream,map,index,id,get,name,collect,collectors,to,list,start,time,failure,system,current,time,millis,total,shards,shard,failures,include,global,state,try,snapshot,format,write,blob,store,snapshot,blob,container,snapshot,id,get,uuid,final,repository,data,repository,data,get,repository,data,write,index,gen,repository,data,add,snapshot,snapshot,id,blob,store,snapshot,state,indices,repository,state,id,catch,file,already,exists,exception,ex,throw,new,repository,exception,metadata,name,blob,already,exists,while,finalizing,snapshot,assume,the,snapshot,has,already,been,saved,ex,catch,ioexception,ex,throw,new,repository,exception,metadata,name,failed,to,update,snapshot,in,repository,ex,return,blob,store,snapshot
BlobStoreRepository -> @Override     public SnapshotInfo finalizeSnapshot(final SnapshotId snapshotId,                                          final List<IndexId> indices,                                          final long startTime,                                          final String failure,                                          final int totalShards,                                          final List<SnapshotShardFailure> shardFailures,                                          final long repositoryStateId,                                          final boolean includeGlobalState);1536314350;{@inheritDoc};@Override_    public SnapshotInfo finalizeSnapshot(final SnapshotId snapshotId,_                                         final List<IndexId> indices,_                                         final long startTime,_                                         final String failure,_                                         final int totalShards,_                                         final List<SnapshotShardFailure> shardFailures,_                                         final long repositoryStateId,_                                         final boolean includeGlobalState) {_        SnapshotInfo blobStoreSnapshot = new SnapshotInfo(snapshotId,_            indices.stream().map(IndexId::getName).collect(Collectors.toList()),_            startTime, failure, System.currentTimeMillis(), totalShards, shardFailures,_            includeGlobalState)__        try {_            snapshotFormat.write(blobStoreSnapshot, blobContainer(), snapshotId.getUUID())__            final RepositoryData repositoryData = getRepositoryData()__            writeIndexGen(repositoryData.addSnapshot(snapshotId, blobStoreSnapshot.state(), indices), repositoryStateId)__        } catch (FileAlreadyExistsException ex) {_            _            _            _            throw new RepositoryException(metadata.name(), "Blob already exists while " +_                "finalizing snapshot, assume the snapshot has already been saved", ex)__        } catch (IOException ex) {_            throw new RepositoryException(metadata.name(), "failed to update snapshot in repository", ex)__        }_        return blobStoreSnapshot__    };inherit,doc;override,public,snapshot,info,finalize,snapshot,final,snapshot,id,snapshot,id,final,list,index,id,indices,final,long,start,time,final,string,failure,final,int,total,shards,final,list,snapshot,shard,failure,shard,failures,final,long,repository,state,id,final,boolean,include,global,state,snapshot,info,blob,store,snapshot,new,snapshot,info,snapshot,id,indices,stream,map,index,id,get,name,collect,collectors,to,list,start,time,failure,system,current,time,millis,total,shards,shard,failures,include,global,state,try,snapshot,format,write,blob,store,snapshot,blob,container,snapshot,id,get,uuid,final,repository,data,repository,data,get,repository,data,write,index,gen,repository,data,add,snapshot,snapshot,id,blob,store,snapshot,state,indices,repository,state,id,catch,file,already,exists,exception,ex,throw,new,repository,exception,metadata,name,blob,already,exists,while,finalizing,snapshot,assume,the,snapshot,has,already,been,saved,ex,catch,ioexception,ex,throw,new,repository,exception,metadata,name,failed,to,update,snapshot,in,repository,ex,return,blob,store,snapshot
BlobStoreRepository -> @Override     public SnapshotInfo finalizeSnapshot(final SnapshotId snapshotId,                                          final List<IndexId> indices,                                          final long startTime,                                          final String failure,                                          final int totalShards,                                          final List<SnapshotShardFailure> shardFailures,                                          final long repositoryStateId,                                          final boolean includeGlobalState);1536828374;{@inheritDoc};@Override_    public SnapshotInfo finalizeSnapshot(final SnapshotId snapshotId,_                                         final List<IndexId> indices,_                                         final long startTime,_                                         final String failure,_                                         final int totalShards,_                                         final List<SnapshotShardFailure> shardFailures,_                                         final long repositoryStateId,_                                         final boolean includeGlobalState) {_        SnapshotInfo blobStoreSnapshot = new SnapshotInfo(snapshotId,_            indices.stream().map(IndexId::getName).collect(Collectors.toList()),_            startTime, failure, System.currentTimeMillis(), totalShards, shardFailures,_            includeGlobalState)__        try {_            snapshotFormat.write(blobStoreSnapshot, blobContainer(), snapshotId.getUUID())__            final RepositoryData repositoryData = getRepositoryData()__            writeIndexGen(repositoryData.addSnapshot(snapshotId, blobStoreSnapshot.state(), indices), repositoryStateId)__        } catch (FileAlreadyExistsException ex) {_            _            _            _            throw new RepositoryException(metadata.name(), "Blob already exists while " +_                "finalizing snapshot, assume the snapshot has already been saved", ex)__        } catch (IOException ex) {_            throw new RepositoryException(metadata.name(), "failed to update snapshot in repository", ex)__        }_        return blobStoreSnapshot__    };inherit,doc;override,public,snapshot,info,finalize,snapshot,final,snapshot,id,snapshot,id,final,list,index,id,indices,final,long,start,time,final,string,failure,final,int,total,shards,final,list,snapshot,shard,failure,shard,failures,final,long,repository,state,id,final,boolean,include,global,state,snapshot,info,blob,store,snapshot,new,snapshot,info,snapshot,id,indices,stream,map,index,id,get,name,collect,collectors,to,list,start,time,failure,system,current,time,millis,total,shards,shard,failures,include,global,state,try,snapshot,format,write,blob,store,snapshot,blob,container,snapshot,id,get,uuid,final,repository,data,repository,data,get,repository,data,write,index,gen,repository,data,add,snapshot,snapshot,id,blob,store,snapshot,state,indices,repository,state,id,catch,file,already,exists,exception,ex,throw,new,repository,exception,metadata,name,blob,already,exists,while,finalizing,snapshot,assume,the,snapshot,has,already,been,saved,ex,catch,ioexception,ex,throw,new,repository,exception,metadata,name,failed,to,update,snapshot,in,repository,ex,return,blob,store,snapshot
BlobStoreRepository -> @Override     public SnapshotInfo finalizeSnapshot(final SnapshotId snapshotId,                                          final List<IndexId> indices,                                          final long startTime,                                          final String failure,                                          final int totalShards,                                          final List<SnapshotShardFailure> shardFailures,                                          final long repositoryStateId,                                          final boolean includeGlobalState);1541008027;{@inheritDoc};@Override_    public SnapshotInfo finalizeSnapshot(final SnapshotId snapshotId,_                                         final List<IndexId> indices,_                                         final long startTime,_                                         final String failure,_                                         final int totalShards,_                                         final List<SnapshotShardFailure> shardFailures,_                                         final long repositoryStateId,_                                         final boolean includeGlobalState) {_        SnapshotInfo blobStoreSnapshot = new SnapshotInfo(snapshotId,_            indices.stream().map(IndexId::getName).collect(Collectors.toList()),_            startTime, failure, System.currentTimeMillis(), totalShards, shardFailures,_            includeGlobalState)__        try {_            snapshotFormat.write(blobStoreSnapshot, blobContainer(), snapshotId.getUUID())__            final RepositoryData repositoryData = getRepositoryData()__            writeIndexGen(repositoryData.addSnapshot(snapshotId, blobStoreSnapshot.state(), indices), repositoryStateId)__        } catch (FileAlreadyExistsException ex) {_            _            _            _            throw new RepositoryException(metadata.name(), "Blob already exists while " +_                "finalizing snapshot, assume the snapshot has already been saved", ex)__        } catch (IOException ex) {_            throw new RepositoryException(metadata.name(), "failed to update snapshot in repository", ex)__        }_        return blobStoreSnapshot__    };inherit,doc;override,public,snapshot,info,finalize,snapshot,final,snapshot,id,snapshot,id,final,list,index,id,indices,final,long,start,time,final,string,failure,final,int,total,shards,final,list,snapshot,shard,failure,shard,failures,final,long,repository,state,id,final,boolean,include,global,state,snapshot,info,blob,store,snapshot,new,snapshot,info,snapshot,id,indices,stream,map,index,id,get,name,collect,collectors,to,list,start,time,failure,system,current,time,millis,total,shards,shard,failures,include,global,state,try,snapshot,format,write,blob,store,snapshot,blob,container,snapshot,id,get,uuid,final,repository,data,repository,data,get,repository,data,write,index,gen,repository,data,add,snapshot,snapshot,id,blob,store,snapshot,state,indices,repository,state,id,catch,file,already,exists,exception,ex,throw,new,repository,exception,metadata,name,blob,already,exists,while,finalizing,snapshot,assume,the,snapshot,has,already,been,saved,ex,catch,ioexception,ex,throw,new,repository,exception,metadata,name,failed,to,update,snapshot,in,repository,ex,return,blob,store,snapshot
BlobStoreRepository -> @Override     public SnapshotInfo finalizeSnapshot(final SnapshotId snapshotId,                                          final List<IndexId> indices,                                          final long startTime,                                          final String failure,                                          final int totalShards,                                          final List<SnapshotShardFailure> shardFailures,                                          final long repositoryStateId,                                          final boolean includeGlobalState);1542646292;{@inheritDoc};@Override_    public SnapshotInfo finalizeSnapshot(final SnapshotId snapshotId,_                                         final List<IndexId> indices,_                                         final long startTime,_                                         final String failure,_                                         final int totalShards,_                                         final List<SnapshotShardFailure> shardFailures,_                                         final long repositoryStateId,_                                         final boolean includeGlobalState) {_        SnapshotInfo blobStoreSnapshot = new SnapshotInfo(snapshotId,_            indices.stream().map(IndexId::getName).collect(Collectors.toList()),_            startTime, failure, System.currentTimeMillis(), totalShards, shardFailures,_            includeGlobalState)__        try {_            snapshotFormat.write(blobStoreSnapshot, blobContainer(), snapshotId.getUUID())__            final RepositoryData repositoryData = getRepositoryData()__            writeIndexGen(repositoryData.addSnapshot(snapshotId, blobStoreSnapshot.state(), indices), repositoryStateId)__        } catch (FileAlreadyExistsException ex) {_            _            _            _            throw new RepositoryException(metadata.name(), "Blob already exists while " +_                "finalizing snapshot, assume the snapshot has already been saved", ex)__        } catch (IOException ex) {_            throw new RepositoryException(metadata.name(), "failed to update snapshot in repository", ex)__        }_        return blobStoreSnapshot__    };inherit,doc;override,public,snapshot,info,finalize,snapshot,final,snapshot,id,snapshot,id,final,list,index,id,indices,final,long,start,time,final,string,failure,final,int,total,shards,final,list,snapshot,shard,failure,shard,failures,final,long,repository,state,id,final,boolean,include,global,state,snapshot,info,blob,store,snapshot,new,snapshot,info,snapshot,id,indices,stream,map,index,id,get,name,collect,collectors,to,list,start,time,failure,system,current,time,millis,total,shards,shard,failures,include,global,state,try,snapshot,format,write,blob,store,snapshot,blob,container,snapshot,id,get,uuid,final,repository,data,repository,data,get,repository,data,write,index,gen,repository,data,add,snapshot,snapshot,id,blob,store,snapshot,state,indices,repository,state,id,catch,file,already,exists,exception,ex,throw,new,repository,exception,metadata,name,blob,already,exists,while,finalizing,snapshot,assume,the,snapshot,has,already,been,saved,ex,catch,ioexception,ex,throw,new,repository,exception,metadata,name,failed,to,update,snapshot,in,repository,ex,return,blob,store,snapshot
BlobStoreRepository -> @Override     public SnapshotInfo finalizeSnapshot(final SnapshotId snapshotId,                                          final List<IndexId> indices,                                          final long startTime,                                          final String failure,                                          final int totalShards,                                          final List<SnapshotShardFailure> shardFailures,                                          final long repositoryStateId,                                          final boolean includeGlobalState);1542980705;{@inheritDoc};@Override_    public SnapshotInfo finalizeSnapshot(final SnapshotId snapshotId,_                                         final List<IndexId> indices,_                                         final long startTime,_                                         final String failure,_                                         final int totalShards,_                                         final List<SnapshotShardFailure> shardFailures,_                                         final long repositoryStateId,_                                         final boolean includeGlobalState) {_        SnapshotInfo blobStoreSnapshot = new SnapshotInfo(snapshotId,_            indices.stream().map(IndexId::getName).collect(Collectors.toList()),_            startTime, failure, System.currentTimeMillis(), totalShards, shardFailures,_            includeGlobalState)__        try {_            snapshotFormat.write(blobStoreSnapshot, blobContainer(), snapshotId.getUUID())__            final RepositoryData repositoryData = getRepositoryData()__            writeIndexGen(repositoryData.addSnapshot(snapshotId, blobStoreSnapshot.state(), indices), repositoryStateId)__        } catch (FileAlreadyExistsException ex) {_            _            _            _            throw new RepositoryException(metadata.name(), "Blob already exists while " +_                "finalizing snapshot, assume the snapshot has already been saved", ex)__        } catch (IOException ex) {_            throw new RepositoryException(metadata.name(), "failed to update snapshot in repository", ex)__        }_        return blobStoreSnapshot__    };inherit,doc;override,public,snapshot,info,finalize,snapshot,final,snapshot,id,snapshot,id,final,list,index,id,indices,final,long,start,time,final,string,failure,final,int,total,shards,final,list,snapshot,shard,failure,shard,failures,final,long,repository,state,id,final,boolean,include,global,state,snapshot,info,blob,store,snapshot,new,snapshot,info,snapshot,id,indices,stream,map,index,id,get,name,collect,collectors,to,list,start,time,failure,system,current,time,millis,total,shards,shard,failures,include,global,state,try,snapshot,format,write,blob,store,snapshot,blob,container,snapshot,id,get,uuid,final,repository,data,repository,data,get,repository,data,write,index,gen,repository,data,add,snapshot,snapshot,id,blob,store,snapshot,state,indices,repository,state,id,catch,file,already,exists,exception,ex,throw,new,repository,exception,metadata,name,blob,already,exists,while,finalizing,snapshot,assume,the,snapshot,has,already,been,saved,ex,catch,ioexception,ex,throw,new,repository,exception,metadata,name,failed,to,update,snapshot,in,repository,ex,return,blob,store,snapshot
BlobStoreRepository -> @Override     public SnapshotInfo finalizeSnapshot(final SnapshotId snapshotId,                                          final List<IndexId> indices,                                          final long startTime,                                          final String failure,                                          final int totalShards,                                          final List<SnapshotShardFailure> shardFailures,                                          final long repositoryStateId,                                          final boolean includeGlobalState);1543831870;{@inheritDoc};@Override_    public SnapshotInfo finalizeSnapshot(final SnapshotId snapshotId,_                                         final List<IndexId> indices,_                                         final long startTime,_                                         final String failure,_                                         final int totalShards,_                                         final List<SnapshotShardFailure> shardFailures,_                                         final long repositoryStateId,_                                         final boolean includeGlobalState) {_        SnapshotInfo blobStoreSnapshot = new SnapshotInfo(snapshotId,_            indices.stream().map(IndexId::getName).collect(Collectors.toList()),_            startTime, failure, System.currentTimeMillis(), totalShards, shardFailures,_            includeGlobalState)__        try {_            snapshotFormat.write(blobStoreSnapshot, blobContainer(), snapshotId.getUUID())__            final RepositoryData repositoryData = getRepositoryData()__            writeIndexGen(repositoryData.addSnapshot(snapshotId, blobStoreSnapshot.state(), indices), repositoryStateId)__        } catch (FileAlreadyExistsException ex) {_            _            _            _            throw new RepositoryException(metadata.name(), "Blob already exists while " +_                "finalizing snapshot, assume the snapshot has already been saved", ex)__        } catch (IOException ex) {_            throw new RepositoryException(metadata.name(), "failed to update snapshot in repository", ex)__        }_        return blobStoreSnapshot__    };inherit,doc;override,public,snapshot,info,finalize,snapshot,final,snapshot,id,snapshot,id,final,list,index,id,indices,final,long,start,time,final,string,failure,final,int,total,shards,final,list,snapshot,shard,failure,shard,failures,final,long,repository,state,id,final,boolean,include,global,state,snapshot,info,blob,store,snapshot,new,snapshot,info,snapshot,id,indices,stream,map,index,id,get,name,collect,collectors,to,list,start,time,failure,system,current,time,millis,total,shards,shard,failures,include,global,state,try,snapshot,format,write,blob,store,snapshot,blob,container,snapshot,id,get,uuid,final,repository,data,repository,data,get,repository,data,write,index,gen,repository,data,add,snapshot,snapshot,id,blob,store,snapshot,state,indices,repository,state,id,catch,file,already,exists,exception,ex,throw,new,repository,exception,metadata,name,blob,already,exists,while,finalizing,snapshot,assume,the,snapshot,has,already,been,saved,ex,catch,ioexception,ex,throw,new,repository,exception,metadata,name,failed,to,update,snapshot,in,repository,ex,return,blob,store,snapshot
BlobStoreRepository -> @Override     public SnapshotInfo finalizeSnapshot(final SnapshotId snapshotId,                                          final List<IndexId> indices,                                          final long startTime,                                          final String failure,                                          final int totalShards,                                          final List<SnapshotShardFailure> shardFailures,                                          final long repositoryStateId,                                          final boolean includeGlobalState);1543942400;{@inheritDoc};@Override_    public SnapshotInfo finalizeSnapshot(final SnapshotId snapshotId,_                                         final List<IndexId> indices,_                                         final long startTime,_                                         final String failure,_                                         final int totalShards,_                                         final List<SnapshotShardFailure> shardFailures,_                                         final long repositoryStateId,_                                         final boolean includeGlobalState) {_        SnapshotInfo blobStoreSnapshot = new SnapshotInfo(snapshotId,_            indices.stream().map(IndexId::getName).collect(Collectors.toList()),_            startTime, failure, System.currentTimeMillis(), totalShards, shardFailures,_            includeGlobalState)__        try {_            snapshotFormat.write(blobStoreSnapshot, blobContainer(), snapshotId.getUUID())__            final RepositoryData repositoryData = getRepositoryData()__            writeIndexGen(repositoryData.addSnapshot(snapshotId, blobStoreSnapshot.state(), indices), repositoryStateId)__        } catch (FileAlreadyExistsException ex) {_            _            _            _            throw new RepositoryException(metadata.name(), "Blob already exists while " +_                "finalizing snapshot, assume the snapshot has already been saved", ex)__        } catch (IOException ex) {_            throw new RepositoryException(metadata.name(), "failed to update snapshot in repository", ex)__        }_        return blobStoreSnapshot__    };inherit,doc;override,public,snapshot,info,finalize,snapshot,final,snapshot,id,snapshot,id,final,list,index,id,indices,final,long,start,time,final,string,failure,final,int,total,shards,final,list,snapshot,shard,failure,shard,failures,final,long,repository,state,id,final,boolean,include,global,state,snapshot,info,blob,store,snapshot,new,snapshot,info,snapshot,id,indices,stream,map,index,id,get,name,collect,collectors,to,list,start,time,failure,system,current,time,millis,total,shards,shard,failures,include,global,state,try,snapshot,format,write,blob,store,snapshot,blob,container,snapshot,id,get,uuid,final,repository,data,repository,data,get,repository,data,write,index,gen,repository,data,add,snapshot,snapshot,id,blob,store,snapshot,state,indices,repository,state,id,catch,file,already,exists,exception,ex,throw,new,repository,exception,metadata,name,blob,already,exists,while,finalizing,snapshot,assume,the,snapshot,has,already,been,saved,ex,catch,ioexception,ex,throw,new,repository,exception,metadata,name,failed,to,update,snapshot,in,repository,ex,return,blob,store,snapshot
BlobStoreRepository -> @Override     public SnapshotInfo finalizeSnapshot(final SnapshotId snapshotId,                                          final List<IndexId> indices,                                          final long startTime,                                          final String failure,                                          final int totalShards,                                          final List<SnapshotShardFailure> shardFailures,                                          final long repositoryStateId,                                          final boolean includeGlobalState);1546974294;{@inheritDoc};@Override_    public SnapshotInfo finalizeSnapshot(final SnapshotId snapshotId,_                                         final List<IndexId> indices,_                                         final long startTime,_                                         final String failure,_                                         final int totalShards,_                                         final List<SnapshotShardFailure> shardFailures,_                                         final long repositoryStateId,_                                         final boolean includeGlobalState) {_        SnapshotInfo blobStoreSnapshot = new SnapshotInfo(snapshotId,_            indices.stream().map(IndexId::getName).collect(Collectors.toList()),_            startTime, failure, System.currentTimeMillis(), totalShards, shardFailures,_            includeGlobalState)__        try {_            snapshotFormat.write(blobStoreSnapshot, blobContainer(), snapshotId.getUUID())__            final RepositoryData repositoryData = getRepositoryData()__            writeIndexGen(repositoryData.addSnapshot(snapshotId, blobStoreSnapshot.state(), indices), repositoryStateId)__        } catch (FileAlreadyExistsException ex) {_            _            _            _            throw new RepositoryException(metadata.name(), "Blob already exists while " +_                "finalizing snapshot, assume the snapshot has already been saved", ex)__        } catch (IOException ex) {_            throw new RepositoryException(metadata.name(), "failed to update snapshot in repository", ex)__        }_        return blobStoreSnapshot__    };inherit,doc;override,public,snapshot,info,finalize,snapshot,final,snapshot,id,snapshot,id,final,list,index,id,indices,final,long,start,time,final,string,failure,final,int,total,shards,final,list,snapshot,shard,failure,shard,failures,final,long,repository,state,id,final,boolean,include,global,state,snapshot,info,blob,store,snapshot,new,snapshot,info,snapshot,id,indices,stream,map,index,id,get,name,collect,collectors,to,list,start,time,failure,system,current,time,millis,total,shards,shard,failures,include,global,state,try,snapshot,format,write,blob,store,snapshot,blob,container,snapshot,id,get,uuid,final,repository,data,repository,data,get,repository,data,write,index,gen,repository,data,add,snapshot,snapshot,id,blob,store,snapshot,state,indices,repository,state,id,catch,file,already,exists,exception,ex,throw,new,repository,exception,metadata,name,blob,already,exists,while,finalizing,snapshot,assume,the,snapshot,has,already,been,saved,ex,catch,ioexception,ex,throw,new,repository,exception,metadata,name,failed,to,update,snapshot,in,repository,ex,return,blob,store,snapshot
BlobStoreRepository -> @Override     public SnapshotInfo finalizeSnapshot(final SnapshotId snapshotId,                                          final List<IndexId> indices,                                          final long startTime,                                          final String failure,                                          final int totalShards,                                          final List<SnapshotShardFailure> shardFailures,                                          final long repositoryStateId,                                          final boolean includeGlobalState);1547496475;{@inheritDoc};@Override_    public SnapshotInfo finalizeSnapshot(final SnapshotId snapshotId,_                                         final List<IndexId> indices,_                                         final long startTime,_                                         final String failure,_                                         final int totalShards,_                                         final List<SnapshotShardFailure> shardFailures,_                                         final long repositoryStateId,_                                         final boolean includeGlobalState) {_        SnapshotInfo blobStoreSnapshot = new SnapshotInfo(snapshotId,_            indices.stream().map(IndexId::getName).collect(Collectors.toList()),_            startTime, failure, System.currentTimeMillis(), totalShards, shardFailures,_            includeGlobalState)__        try {_            snapshotFormat.write(blobStoreSnapshot, blobContainer(), snapshotId.getUUID())__            final RepositoryData repositoryData = getRepositoryData()__            writeIndexGen(repositoryData.addSnapshot(snapshotId, blobStoreSnapshot.state(), indices), repositoryStateId)__        } catch (FileAlreadyExistsException ex) {_            _            _            _            throw new RepositoryException(metadata.name(), "Blob already exists while " +_                "finalizing snapshot, assume the snapshot has already been saved", ex)__        } catch (IOException ex) {_            throw new RepositoryException(metadata.name(), "failed to update snapshot in repository", ex)__        }_        return blobStoreSnapshot__    };inherit,doc;override,public,snapshot,info,finalize,snapshot,final,snapshot,id,snapshot,id,final,list,index,id,indices,final,long,start,time,final,string,failure,final,int,total,shards,final,list,snapshot,shard,failure,shard,failures,final,long,repository,state,id,final,boolean,include,global,state,snapshot,info,blob,store,snapshot,new,snapshot,info,snapshot,id,indices,stream,map,index,id,get,name,collect,collectors,to,list,start,time,failure,system,current,time,millis,total,shards,shard,failures,include,global,state,try,snapshot,format,write,blob,store,snapshot,blob,container,snapshot,id,get,uuid,final,repository,data,repository,data,get,repository,data,write,index,gen,repository,data,add,snapshot,snapshot,id,blob,store,snapshot,state,indices,repository,state,id,catch,file,already,exists,exception,ex,throw,new,repository,exception,metadata,name,blob,already,exists,while,finalizing,snapshot,assume,the,snapshot,has,already,been,saved,ex,catch,ioexception,ex,throw,new,repository,exception,metadata,name,failed,to,update,snapshot,in,repository,ex,return,blob,store,snapshot
BlobStoreRepository -> @Override     public SnapshotInfo finalizeSnapshot(final SnapshotId snapshotId,                                          final List<IndexId> indices,                                          final long startTime,                                          final String failure,                                          final int totalShards,                                          final List<SnapshotShardFailure> shardFailures,                                          final long repositoryStateId,                                          final boolean includeGlobalState);1547625930;{@inheritDoc};@Override_    public SnapshotInfo finalizeSnapshot(final SnapshotId snapshotId,_                                         final List<IndexId> indices,_                                         final long startTime,_                                         final String failure,_                                         final int totalShards,_                                         final List<SnapshotShardFailure> shardFailures,_                                         final long repositoryStateId,_                                         final boolean includeGlobalState) {_        SnapshotInfo blobStoreSnapshot = new SnapshotInfo(snapshotId,_            indices.stream().map(IndexId::getName).collect(Collectors.toList()),_            startTime, failure, System.currentTimeMillis(), totalShards, shardFailures,_            includeGlobalState)__        try {_            snapshotFormat.write(blobStoreSnapshot, blobContainer(), snapshotId.getUUID())__            final RepositoryData repositoryData = getRepositoryData()__            writeIndexGen(repositoryData.addSnapshot(snapshotId, blobStoreSnapshot.state(), indices), repositoryStateId)__        } catch (FileAlreadyExistsException ex) {_            _            _            _            throw new RepositoryException(metadata.name(), "Blob already exists while " +_                "finalizing snapshot, assume the snapshot has already been saved", ex)__        } catch (IOException ex) {_            throw new RepositoryException(metadata.name(), "failed to update snapshot in repository", ex)__        }_        return blobStoreSnapshot__    };inherit,doc;override,public,snapshot,info,finalize,snapshot,final,snapshot,id,snapshot,id,final,list,index,id,indices,final,long,start,time,final,string,failure,final,int,total,shards,final,list,snapshot,shard,failure,shard,failures,final,long,repository,state,id,final,boolean,include,global,state,snapshot,info,blob,store,snapshot,new,snapshot,info,snapshot,id,indices,stream,map,index,id,get,name,collect,collectors,to,list,start,time,failure,system,current,time,millis,total,shards,shard,failures,include,global,state,try,snapshot,format,write,blob,store,snapshot,blob,container,snapshot,id,get,uuid,final,repository,data,repository,data,get,repository,data,write,index,gen,repository,data,add,snapshot,snapshot,id,blob,store,snapshot,state,indices,repository,state,id,catch,file,already,exists,exception,ex,throw,new,repository,exception,metadata,name,blob,already,exists,while,finalizing,snapshot,assume,the,snapshot,has,already,been,saved,ex,catch,ioexception,ex,throw,new,repository,exception,metadata,name,failed,to,update,snapshot,in,repository,ex,return,blob,store,snapshot
BlobStoreRepository -> @Override     public SnapshotInfo finalizeSnapshot(final SnapshotId snapshotId,                                          final List<IndexId> indices,                                          final long startTime,                                          final String failure,                                          final int totalShards,                                          final List<SnapshotShardFailure> shardFailures,                                          final long repositoryStateId,                                          final boolean includeGlobalState);1550647627;{@inheritDoc};@Override_    public SnapshotInfo finalizeSnapshot(final SnapshotId snapshotId,_                                         final List<IndexId> indices,_                                         final long startTime,_                                         final String failure,_                                         final int totalShards,_                                         final List<SnapshotShardFailure> shardFailures,_                                         final long repositoryStateId,_                                         final boolean includeGlobalState) {_        SnapshotInfo blobStoreSnapshot = new SnapshotInfo(snapshotId,_            indices.stream().map(IndexId::getName).collect(Collectors.toList()),_            startTime, failure, System.currentTimeMillis(), totalShards, shardFailures,_            includeGlobalState)__        try {_            snapshotFormat.write(blobStoreSnapshot, blobContainer(), snapshotId.getUUID())__            final RepositoryData repositoryData = getRepositoryData()__            writeIndexGen(repositoryData.addSnapshot(snapshotId, blobStoreSnapshot.state(), indices), repositoryStateId)__        } catch (FileAlreadyExistsException ex) {_            _            _            _            throw new RepositoryException(metadata.name(), "Blob already exists while " +_                "finalizing snapshot, assume the snapshot has already been saved", ex)__        } catch (IOException ex) {_            throw new RepositoryException(metadata.name(), "failed to update snapshot in repository", ex)__        }_        return blobStoreSnapshot__    };inherit,doc;override,public,snapshot,info,finalize,snapshot,final,snapshot,id,snapshot,id,final,list,index,id,indices,final,long,start,time,final,string,failure,final,int,total,shards,final,list,snapshot,shard,failure,shard,failures,final,long,repository,state,id,final,boolean,include,global,state,snapshot,info,blob,store,snapshot,new,snapshot,info,snapshot,id,indices,stream,map,index,id,get,name,collect,collectors,to,list,start,time,failure,system,current,time,millis,total,shards,shard,failures,include,global,state,try,snapshot,format,write,blob,store,snapshot,blob,container,snapshot,id,get,uuid,final,repository,data,repository,data,get,repository,data,write,index,gen,repository,data,add,snapshot,snapshot,id,blob,store,snapshot,state,indices,repository,state,id,catch,file,already,exists,exception,ex,throw,new,repository,exception,metadata,name,blob,already,exists,while,finalizing,snapshot,assume,the,snapshot,has,already,been,saved,ex,catch,ioexception,ex,throw,new,repository,exception,metadata,name,failed,to,update,snapshot,in,repository,ex,return,blob,store,snapshot
BlobStoreRepository -> Context -> protected Tuple<BlobStoreIndexShardSnapshots, Integer> buildBlobStoreIndexShardSnapshots(Map<String, BlobMetaData> blobs);1524684173;Loads all available snapshots in the repository__@param blobs list of blobs in repository_@return tuple of BlobStoreIndexShardSnapshots and the last snapshot index generation;protected Tuple<BlobStoreIndexShardSnapshots, Integer> buildBlobStoreIndexShardSnapshots(Map<String, BlobMetaData> blobs) {_            int latest = -1__            Set<String> blobKeys = blobs.keySet()__            for (String name : blobKeys) {_                if (name.startsWith(SNAPSHOT_INDEX_PREFIX)) {_                    try {_                        int gen = Integer.parseInt(name.substring(SNAPSHOT_INDEX_PREFIX.length()))__                        if (gen > latest) {_                            latest = gen__                        }_                    } catch (NumberFormatException ex) {_                        logger.warn("failed to parse index file name [{}]", name)__                    }_                }_            }_            if (latest >= 0) {_                try {_                    final BlobStoreIndexShardSnapshots shardSnapshots =_                        indexShardSnapshotsFormat.read(blobContainer, Integer.toString(latest))__                    return new Tuple<>(shardSnapshots, latest)__                } catch (IOException e) {_                    final String file = SNAPSHOT_INDEX_PREFIX + latest__                    logger.warn(() -> new ParameterizedMessage("failed to read index file [{}]", file), e)__                }_            } else if (blobKeys.isEmpty() == false) {_                logger.debug("Could not find a readable index-N file in a non-empty shard snapshot directory [{}]", blobContainer.path())__            }__            _            List<SnapshotFiles> snapshots = new ArrayList<>()__            for (String name : blobKeys) {_                try {_                    BlobStoreIndexShardSnapshot snapshot = null__                    if (name.startsWith(SNAPSHOT_PREFIX)) {_                        snapshot = indexShardSnapshotFormat.readBlob(blobContainer, name)__                    }_                    if (snapshot != null) {_                        snapshots.add(new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles()))__                    }_                } catch (IOException e) {_                    logger.warn(() -> new ParameterizedMessage("failed to read commit point [{}]", name), e)__                }_            }_            return new Tuple<>(new BlobStoreIndexShardSnapshots(snapshots), -1)__        };loads,all,available,snapshots,in,the,repository,param,blobs,list,of,blobs,in,repository,return,tuple,of,blob,store,index,shard,snapshots,and,the,last,snapshot,index,generation;protected,tuple,blob,store,index,shard,snapshots,integer,build,blob,store,index,shard,snapshots,map,string,blob,meta,data,blobs,int,latest,1,set,string,blob,keys,blobs,key,set,for,string,name,blob,keys,if,name,starts,with,try,int,gen,integer,parse,int,name,substring,length,if,gen,latest,latest,gen,catch,number,format,exception,ex,logger,warn,failed,to,parse,index,file,name,name,if,latest,0,try,final,blob,store,index,shard,snapshots,shard,snapshots,index,shard,snapshots,format,read,blob,container,integer,to,string,latest,return,new,tuple,shard,snapshots,latest,catch,ioexception,e,final,string,file,latest,logger,warn,new,parameterized,message,failed,to,read,index,file,file,e,else,if,blob,keys,is,empty,false,logger,debug,could,not,find,a,readable,index,n,file,in,a,non,empty,shard,snapshot,directory,blob,container,path,list,snapshot,files,snapshots,new,array,list,for,string,name,blob,keys,try,blob,store,index,shard,snapshot,snapshot,null,if,name,starts,with,snapshot,index,shard,snapshot,format,read,blob,blob,container,name,if,snapshot,null,snapshots,add,new,snapshot,files,snapshot,snapshot,snapshot,index,files,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,read,commit,point,name,e,return,new,tuple,new,blob,store,index,shard,snapshots,snapshots,1
BlobStoreRepository -> Context -> protected Tuple<BlobStoreIndexShardSnapshots, Integer> buildBlobStoreIndexShardSnapshots(Map<String, BlobMetaData> blobs);1525334055;Loads all available snapshots in the repository__@param blobs list of blobs in repository_@return tuple of BlobStoreIndexShardSnapshots and the last snapshot index generation;protected Tuple<BlobStoreIndexShardSnapshots, Integer> buildBlobStoreIndexShardSnapshots(Map<String, BlobMetaData> blobs) {_            int latest = -1__            Set<String> blobKeys = blobs.keySet()__            for (String name : blobKeys) {_                if (name.startsWith(SNAPSHOT_INDEX_PREFIX)) {_                    try {_                        int gen = Integer.parseInt(name.substring(SNAPSHOT_INDEX_PREFIX.length()))__                        if (gen > latest) {_                            latest = gen__                        }_                    } catch (NumberFormatException ex) {_                        logger.warn("failed to parse index file name [{}]", name)__                    }_                }_            }_            if (latest >= 0) {_                try {_                    final BlobStoreIndexShardSnapshots shardSnapshots =_                        indexShardSnapshotsFormat.read(blobContainer, Integer.toString(latest))__                    return new Tuple<>(shardSnapshots, latest)__                } catch (IOException e) {_                    final String file = SNAPSHOT_INDEX_PREFIX + latest__                    logger.warn(() -> new ParameterizedMessage("failed to read index file [{}]", file), e)__                }_            } else if (blobKeys.isEmpty() == false) {_                logger.debug("Could not find a readable index-N file in a non-empty shard snapshot directory [{}]", blobContainer.path())__            }__            _            List<SnapshotFiles> snapshots = new ArrayList<>()__            for (String name : blobKeys) {_                try {_                    BlobStoreIndexShardSnapshot snapshot = null__                    if (name.startsWith(SNAPSHOT_PREFIX)) {_                        snapshot = indexShardSnapshotFormat.readBlob(blobContainer, name)__                    }_                    if (snapshot != null) {_                        snapshots.add(new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles()))__                    }_                } catch (IOException e) {_                    logger.warn(() -> new ParameterizedMessage("failed to read commit point [{}]", name), e)__                }_            }_            return new Tuple<>(new BlobStoreIndexShardSnapshots(snapshots), -1)__        };loads,all,available,snapshots,in,the,repository,param,blobs,list,of,blobs,in,repository,return,tuple,of,blob,store,index,shard,snapshots,and,the,last,snapshot,index,generation;protected,tuple,blob,store,index,shard,snapshots,integer,build,blob,store,index,shard,snapshots,map,string,blob,meta,data,blobs,int,latest,1,set,string,blob,keys,blobs,key,set,for,string,name,blob,keys,if,name,starts,with,try,int,gen,integer,parse,int,name,substring,length,if,gen,latest,latest,gen,catch,number,format,exception,ex,logger,warn,failed,to,parse,index,file,name,name,if,latest,0,try,final,blob,store,index,shard,snapshots,shard,snapshots,index,shard,snapshots,format,read,blob,container,integer,to,string,latest,return,new,tuple,shard,snapshots,latest,catch,ioexception,e,final,string,file,latest,logger,warn,new,parameterized,message,failed,to,read,index,file,file,e,else,if,blob,keys,is,empty,false,logger,debug,could,not,find,a,readable,index,n,file,in,a,non,empty,shard,snapshot,directory,blob,container,path,list,snapshot,files,snapshots,new,array,list,for,string,name,blob,keys,try,blob,store,index,shard,snapshot,snapshot,null,if,name,starts,with,snapshot,index,shard,snapshot,format,read,blob,blob,container,name,if,snapshot,null,snapshots,add,new,snapshot,files,snapshot,snapshot,snapshot,index,files,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,read,commit,point,name,e,return,new,tuple,new,blob,store,index,shard,snapshots,snapshots,1
BlobStoreRepository -> Context -> protected Tuple<BlobStoreIndexShardSnapshots, Integer> buildBlobStoreIndexShardSnapshots(Map<String, BlobMetaData> blobs);1525798020;Loads all available snapshots in the repository__@param blobs list of blobs in repository_@return tuple of BlobStoreIndexShardSnapshots and the last snapshot index generation;protected Tuple<BlobStoreIndexShardSnapshots, Integer> buildBlobStoreIndexShardSnapshots(Map<String, BlobMetaData> blobs) {_            int latest = -1__            Set<String> blobKeys = blobs.keySet()__            for (String name : blobKeys) {_                if (name.startsWith(SNAPSHOT_INDEX_PREFIX)) {_                    try {_                        int gen = Integer.parseInt(name.substring(SNAPSHOT_INDEX_PREFIX.length()))__                        if (gen > latest) {_                            latest = gen__                        }_                    } catch (NumberFormatException ex) {_                        logger.warn("failed to parse index file name [{}]", name)__                    }_                }_            }_            if (latest >= 0) {_                try {_                    final BlobStoreIndexShardSnapshots shardSnapshots =_                        indexShardSnapshotsFormat.read(blobContainer, Integer.toString(latest))__                    return new Tuple<>(shardSnapshots, latest)__                } catch (IOException e) {_                    final String file = SNAPSHOT_INDEX_PREFIX + latest__                    logger.warn(() -> new ParameterizedMessage("failed to read index file [{}]", file), e)__                }_            } else if (blobKeys.isEmpty() == false) {_                logger.debug("Could not find a readable index-N file in a non-empty shard snapshot directory [{}]", blobContainer.path())__            }__            _            List<SnapshotFiles> snapshots = new ArrayList<>()__            for (String name : blobKeys) {_                try {_                    BlobStoreIndexShardSnapshot snapshot = null__                    if (name.startsWith(SNAPSHOT_PREFIX)) {_                        snapshot = indexShardSnapshotFormat.readBlob(blobContainer, name)__                    }_                    if (snapshot != null) {_                        snapshots.add(new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles()))__                    }_                } catch (IOException e) {_                    logger.warn(() -> new ParameterizedMessage("failed to read commit point [{}]", name), e)__                }_            }_            return new Tuple<>(new BlobStoreIndexShardSnapshots(snapshots), -1)__        };loads,all,available,snapshots,in,the,repository,param,blobs,list,of,blobs,in,repository,return,tuple,of,blob,store,index,shard,snapshots,and,the,last,snapshot,index,generation;protected,tuple,blob,store,index,shard,snapshots,integer,build,blob,store,index,shard,snapshots,map,string,blob,meta,data,blobs,int,latest,1,set,string,blob,keys,blobs,key,set,for,string,name,blob,keys,if,name,starts,with,try,int,gen,integer,parse,int,name,substring,length,if,gen,latest,latest,gen,catch,number,format,exception,ex,logger,warn,failed,to,parse,index,file,name,name,if,latest,0,try,final,blob,store,index,shard,snapshots,shard,snapshots,index,shard,snapshots,format,read,blob,container,integer,to,string,latest,return,new,tuple,shard,snapshots,latest,catch,ioexception,e,final,string,file,latest,logger,warn,new,parameterized,message,failed,to,read,index,file,file,e,else,if,blob,keys,is,empty,false,logger,debug,could,not,find,a,readable,index,n,file,in,a,non,empty,shard,snapshot,directory,blob,container,path,list,snapshot,files,snapshots,new,array,list,for,string,name,blob,keys,try,blob,store,index,shard,snapshot,snapshot,null,if,name,starts,with,snapshot,index,shard,snapshot,format,read,blob,blob,container,name,if,snapshot,null,snapshots,add,new,snapshot,files,snapshot,snapshot,snapshot,index,files,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,read,commit,point,name,e,return,new,tuple,new,blob,store,index,shard,snapshots,snapshots,1
BlobStoreRepository -> Context -> protected Tuple<BlobStoreIndexShardSnapshots, Integer> buildBlobStoreIndexShardSnapshots(Map<String, BlobMetaData> blobs);1526289033;Loads all available snapshots in the repository__@param blobs list of blobs in repository_@return tuple of BlobStoreIndexShardSnapshots and the last snapshot index generation;protected Tuple<BlobStoreIndexShardSnapshots, Integer> buildBlobStoreIndexShardSnapshots(Map<String, BlobMetaData> blobs) {_            int latest = -1__            Set<String> blobKeys = blobs.keySet()__            for (String name : blobKeys) {_                if (name.startsWith(SNAPSHOT_INDEX_PREFIX)) {_                    try {_                        int gen = Integer.parseInt(name.substring(SNAPSHOT_INDEX_PREFIX.length()))__                        if (gen > latest) {_                            latest = gen__                        }_                    } catch (NumberFormatException ex) {_                        logger.warn("failed to parse index file name [{}]", name)__                    }_                }_            }_            if (latest >= 0) {_                try {_                    final BlobStoreIndexShardSnapshots shardSnapshots =_                        indexShardSnapshotsFormat.read(blobContainer, Integer.toString(latest))__                    return new Tuple<>(shardSnapshots, latest)__                } catch (IOException e) {_                    final String file = SNAPSHOT_INDEX_PREFIX + latest__                    logger.warn(() -> new ParameterizedMessage("failed to read index file [{}]", file), e)__                }_            } else if (blobKeys.isEmpty() == false) {_                logger.debug("Could not find a readable index-N file in a non-empty shard snapshot directory [{}]", blobContainer.path())__            }__            _            List<SnapshotFiles> snapshots = new ArrayList<>()__            for (String name : blobKeys) {_                try {_                    BlobStoreIndexShardSnapshot snapshot = null__                    if (name.startsWith(SNAPSHOT_PREFIX)) {_                        snapshot = indexShardSnapshotFormat.readBlob(blobContainer, name)__                    }_                    if (snapshot != null) {_                        snapshots.add(new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles()))__                    }_                } catch (IOException e) {_                    logger.warn(() -> new ParameterizedMessage("failed to read commit point [{}]", name), e)__                }_            }_            return new Tuple<>(new BlobStoreIndexShardSnapshots(snapshots), -1)__        };loads,all,available,snapshots,in,the,repository,param,blobs,list,of,blobs,in,repository,return,tuple,of,blob,store,index,shard,snapshots,and,the,last,snapshot,index,generation;protected,tuple,blob,store,index,shard,snapshots,integer,build,blob,store,index,shard,snapshots,map,string,blob,meta,data,blobs,int,latest,1,set,string,blob,keys,blobs,key,set,for,string,name,blob,keys,if,name,starts,with,try,int,gen,integer,parse,int,name,substring,length,if,gen,latest,latest,gen,catch,number,format,exception,ex,logger,warn,failed,to,parse,index,file,name,name,if,latest,0,try,final,blob,store,index,shard,snapshots,shard,snapshots,index,shard,snapshots,format,read,blob,container,integer,to,string,latest,return,new,tuple,shard,snapshots,latest,catch,ioexception,e,final,string,file,latest,logger,warn,new,parameterized,message,failed,to,read,index,file,file,e,else,if,blob,keys,is,empty,false,logger,debug,could,not,find,a,readable,index,n,file,in,a,non,empty,shard,snapshot,directory,blob,container,path,list,snapshot,files,snapshots,new,array,list,for,string,name,blob,keys,try,blob,store,index,shard,snapshot,snapshot,null,if,name,starts,with,snapshot,index,shard,snapshot,format,read,blob,blob,container,name,if,snapshot,null,snapshots,add,new,snapshot,files,snapshot,snapshot,snapshot,index,files,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,read,commit,point,name,e,return,new,tuple,new,blob,store,index,shard,snapshots,snapshots,1
BlobStoreRepository -> Context -> protected Tuple<BlobStoreIndexShardSnapshots, Integer> buildBlobStoreIndexShardSnapshots(Map<String, BlobMetaData> blobs);1526574077;Loads all available snapshots in the repository__@param blobs list of blobs in repository_@return tuple of BlobStoreIndexShardSnapshots and the last snapshot index generation;protected Tuple<BlobStoreIndexShardSnapshots, Integer> buildBlobStoreIndexShardSnapshots(Map<String, BlobMetaData> blobs) {_            int latest = -1__            Set<String> blobKeys = blobs.keySet()__            for (String name : blobKeys) {_                if (name.startsWith(SNAPSHOT_INDEX_PREFIX)) {_                    try {_                        int gen = Integer.parseInt(name.substring(SNAPSHOT_INDEX_PREFIX.length()))__                        if (gen > latest) {_                            latest = gen__                        }_                    } catch (NumberFormatException ex) {_                        logger.warn("failed to parse index file name [{}]", name)__                    }_                }_            }_            if (latest >= 0) {_                try {_                    final BlobStoreIndexShardSnapshots shardSnapshots =_                        indexShardSnapshotsFormat.read(blobContainer, Integer.toString(latest))__                    return new Tuple<>(shardSnapshots, latest)__                } catch (IOException e) {_                    final String file = SNAPSHOT_INDEX_PREFIX + latest__                    logger.warn(() -> new ParameterizedMessage("failed to read index file [{}]", file), e)__                }_            } else if (blobKeys.isEmpty() == false) {_                logger.debug("Could not find a readable index-N file in a non-empty shard snapshot directory [{}]", blobContainer.path())__            }__            _            List<SnapshotFiles> snapshots = new ArrayList<>()__            for (String name : blobKeys) {_                try {_                    BlobStoreIndexShardSnapshot snapshot = null__                    if (name.startsWith(SNAPSHOT_PREFIX)) {_                        snapshot = indexShardSnapshotFormat.readBlob(blobContainer, name)__                    }_                    if (snapshot != null) {_                        snapshots.add(new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles()))__                    }_                } catch (IOException e) {_                    logger.warn(() -> new ParameterizedMessage("failed to read commit point [{}]", name), e)__                }_            }_            return new Tuple<>(new BlobStoreIndexShardSnapshots(snapshots), -1)__        };loads,all,available,snapshots,in,the,repository,param,blobs,list,of,blobs,in,repository,return,tuple,of,blob,store,index,shard,snapshots,and,the,last,snapshot,index,generation;protected,tuple,blob,store,index,shard,snapshots,integer,build,blob,store,index,shard,snapshots,map,string,blob,meta,data,blobs,int,latest,1,set,string,blob,keys,blobs,key,set,for,string,name,blob,keys,if,name,starts,with,try,int,gen,integer,parse,int,name,substring,length,if,gen,latest,latest,gen,catch,number,format,exception,ex,logger,warn,failed,to,parse,index,file,name,name,if,latest,0,try,final,blob,store,index,shard,snapshots,shard,snapshots,index,shard,snapshots,format,read,blob,container,integer,to,string,latest,return,new,tuple,shard,snapshots,latest,catch,ioexception,e,final,string,file,latest,logger,warn,new,parameterized,message,failed,to,read,index,file,file,e,else,if,blob,keys,is,empty,false,logger,debug,could,not,find,a,readable,index,n,file,in,a,non,empty,shard,snapshot,directory,blob,container,path,list,snapshot,files,snapshots,new,array,list,for,string,name,blob,keys,try,blob,store,index,shard,snapshot,snapshot,null,if,name,starts,with,snapshot,index,shard,snapshot,format,read,blob,blob,container,name,if,snapshot,null,snapshots,add,new,snapshot,files,snapshot,snapshot,snapshot,index,files,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,read,commit,point,name,e,return,new,tuple,new,blob,store,index,shard,snapshots,snapshots,1
BlobStoreRepository -> Context -> protected Tuple<BlobStoreIndexShardSnapshots, Integer> buildBlobStoreIndexShardSnapshots(Map<String, BlobMetaData> blobs);1527583663;Loads all available snapshots in the repository__@param blobs list of blobs in repository_@return tuple of BlobStoreIndexShardSnapshots and the last snapshot index generation;protected Tuple<BlobStoreIndexShardSnapshots, Integer> buildBlobStoreIndexShardSnapshots(Map<String, BlobMetaData> blobs) {_            int latest = -1__            Set<String> blobKeys = blobs.keySet()__            for (String name : blobKeys) {_                if (name.startsWith(SNAPSHOT_INDEX_PREFIX)) {_                    try {_                        int gen = Integer.parseInt(name.substring(SNAPSHOT_INDEX_PREFIX.length()))__                        if (gen > latest) {_                            latest = gen__                        }_                    } catch (NumberFormatException ex) {_                        logger.warn("failed to parse index file name [{}]", name)__                    }_                }_            }_            if (latest >= 0) {_                try {_                    final BlobStoreIndexShardSnapshots shardSnapshots =_                        indexShardSnapshotsFormat.read(blobContainer, Integer.toString(latest))__                    return new Tuple<>(shardSnapshots, latest)__                } catch (IOException e) {_                    final String file = SNAPSHOT_INDEX_PREFIX + latest__                    logger.warn(() -> new ParameterizedMessage("failed to read index file [{}]", file), e)__                }_            } else if (blobKeys.isEmpty() == false) {_                logger.debug("Could not find a readable index-N file in a non-empty shard snapshot directory [{}]", blobContainer.path())__            }__            _            List<SnapshotFiles> snapshots = new ArrayList<>()__            for (String name : blobKeys) {_                try {_                    BlobStoreIndexShardSnapshot snapshot = null__                    if (name.startsWith(SNAPSHOT_PREFIX)) {_                        snapshot = indexShardSnapshotFormat.readBlob(blobContainer, name)__                    }_                    if (snapshot != null) {_                        snapshots.add(new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles()))__                    }_                } catch (IOException e) {_                    logger.warn(() -> new ParameterizedMessage("failed to read commit point [{}]", name), e)__                }_            }_            return new Tuple<>(new BlobStoreIndexShardSnapshots(snapshots), -1)__        };loads,all,available,snapshots,in,the,repository,param,blobs,list,of,blobs,in,repository,return,tuple,of,blob,store,index,shard,snapshots,and,the,last,snapshot,index,generation;protected,tuple,blob,store,index,shard,snapshots,integer,build,blob,store,index,shard,snapshots,map,string,blob,meta,data,blobs,int,latest,1,set,string,blob,keys,blobs,key,set,for,string,name,blob,keys,if,name,starts,with,try,int,gen,integer,parse,int,name,substring,length,if,gen,latest,latest,gen,catch,number,format,exception,ex,logger,warn,failed,to,parse,index,file,name,name,if,latest,0,try,final,blob,store,index,shard,snapshots,shard,snapshots,index,shard,snapshots,format,read,blob,container,integer,to,string,latest,return,new,tuple,shard,snapshots,latest,catch,ioexception,e,final,string,file,latest,logger,warn,new,parameterized,message,failed,to,read,index,file,file,e,else,if,blob,keys,is,empty,false,logger,debug,could,not,find,a,readable,index,n,file,in,a,non,empty,shard,snapshot,directory,blob,container,path,list,snapshot,files,snapshots,new,array,list,for,string,name,blob,keys,try,blob,store,index,shard,snapshot,snapshot,null,if,name,starts,with,snapshot,index,shard,snapshot,format,read,blob,blob,container,name,if,snapshot,null,snapshots,add,new,snapshot,files,snapshot,snapshot,snapshot,index,files,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,read,commit,point,name,e,return,new,tuple,new,blob,store,index,shard,snapshots,snapshots,1
BlobStoreRepository -> Context -> protected Tuple<BlobStoreIndexShardSnapshots, Integer> buildBlobStoreIndexShardSnapshots(Map<String, BlobMetaData> blobs);1528211342;Loads all available snapshots in the repository__@param blobs list of blobs in repository_@return tuple of BlobStoreIndexShardSnapshots and the last snapshot index generation;protected Tuple<BlobStoreIndexShardSnapshots, Integer> buildBlobStoreIndexShardSnapshots(Map<String, BlobMetaData> blobs) {_            int latest = -1__            Set<String> blobKeys = blobs.keySet()__            for (String name : blobKeys) {_                if (name.startsWith(SNAPSHOT_INDEX_PREFIX)) {_                    try {_                        int gen = Integer.parseInt(name.substring(SNAPSHOT_INDEX_PREFIX.length()))__                        if (gen > latest) {_                            latest = gen__                        }_                    } catch (NumberFormatException ex) {_                        logger.warn("failed to parse index file name [{}]", name)__                    }_                }_            }_            if (latest >= 0) {_                try {_                    final BlobStoreIndexShardSnapshots shardSnapshots =_                        indexShardSnapshotsFormat.read(blobContainer, Integer.toString(latest))__                    return new Tuple<>(shardSnapshots, latest)__                } catch (IOException e) {_                    final String file = SNAPSHOT_INDEX_PREFIX + latest__                    logger.warn(() -> new ParameterizedMessage("failed to read index file [{}]", file), e)__                }_            } else if (blobKeys.isEmpty() == false) {_                logger.debug("Could not find a readable index-N file in a non-empty shard snapshot directory [{}]", blobContainer.path())__            }__            _            List<SnapshotFiles> snapshots = new ArrayList<>()__            for (String name : blobKeys) {_                try {_                    BlobStoreIndexShardSnapshot snapshot = null__                    if (name.startsWith(SNAPSHOT_PREFIX)) {_                        snapshot = indexShardSnapshotFormat.readBlob(blobContainer, name)__                    }_                    if (snapshot != null) {_                        snapshots.add(new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles()))__                    }_                } catch (IOException e) {_                    logger.warn(() -> new ParameterizedMessage("failed to read commit point [{}]", name), e)__                }_            }_            return new Tuple<>(new BlobStoreIndexShardSnapshots(snapshots), -1)__        };loads,all,available,snapshots,in,the,repository,param,blobs,list,of,blobs,in,repository,return,tuple,of,blob,store,index,shard,snapshots,and,the,last,snapshot,index,generation;protected,tuple,blob,store,index,shard,snapshots,integer,build,blob,store,index,shard,snapshots,map,string,blob,meta,data,blobs,int,latest,1,set,string,blob,keys,blobs,key,set,for,string,name,blob,keys,if,name,starts,with,try,int,gen,integer,parse,int,name,substring,length,if,gen,latest,latest,gen,catch,number,format,exception,ex,logger,warn,failed,to,parse,index,file,name,name,if,latest,0,try,final,blob,store,index,shard,snapshots,shard,snapshots,index,shard,snapshots,format,read,blob,container,integer,to,string,latest,return,new,tuple,shard,snapshots,latest,catch,ioexception,e,final,string,file,latest,logger,warn,new,parameterized,message,failed,to,read,index,file,file,e,else,if,blob,keys,is,empty,false,logger,debug,could,not,find,a,readable,index,n,file,in,a,non,empty,shard,snapshot,directory,blob,container,path,list,snapshot,files,snapshots,new,array,list,for,string,name,blob,keys,try,blob,store,index,shard,snapshot,snapshot,null,if,name,starts,with,snapshot,index,shard,snapshot,format,read,blob,blob,container,name,if,snapshot,null,snapshots,add,new,snapshot,files,snapshot,snapshot,snapshot,index,files,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,read,commit,point,name,e,return,new,tuple,new,blob,store,index,shard,snapshots,snapshots,1
BlobStoreRepository -> Context -> protected Tuple<BlobStoreIndexShardSnapshots, Integer> buildBlobStoreIndexShardSnapshots(Map<String, BlobMetaData> blobs);1531179852;Loads all available snapshots in the repository__@param blobs list of blobs in repository_@return tuple of BlobStoreIndexShardSnapshots and the last snapshot index generation;protected Tuple<BlobStoreIndexShardSnapshots, Integer> buildBlobStoreIndexShardSnapshots(Map<String, BlobMetaData> blobs) {_            int latest = -1__            Set<String> blobKeys = blobs.keySet()__            for (String name : blobKeys) {_                if (name.startsWith(SNAPSHOT_INDEX_PREFIX)) {_                    try {_                        int gen = Integer.parseInt(name.substring(SNAPSHOT_INDEX_PREFIX.length()))__                        if (gen > latest) {_                            latest = gen__                        }_                    } catch (NumberFormatException ex) {_                        logger.warn("failed to parse index file name [{}]", name)__                    }_                }_            }_            if (latest >= 0) {_                try {_                    final BlobStoreIndexShardSnapshots shardSnapshots =_                        indexShardSnapshotsFormat.read(blobContainer, Integer.toString(latest))__                    return new Tuple<>(shardSnapshots, latest)__                } catch (IOException e) {_                    final String file = SNAPSHOT_INDEX_PREFIX + latest__                    logger.warn(() -> new ParameterizedMessage("failed to read index file [{}]", file), e)__                }_            } else if (blobKeys.isEmpty() == false) {_                logger.debug("Could not find a readable index-N file in a non-empty shard snapshot directory [{}]", blobContainer.path())__            }__            _            List<SnapshotFiles> snapshots = new ArrayList<>()__            for (String name : blobKeys) {_                try {_                    BlobStoreIndexShardSnapshot snapshot = null__                    if (name.startsWith(SNAPSHOT_PREFIX)) {_                        snapshot = indexShardSnapshotFormat.readBlob(blobContainer, name)__                    }_                    if (snapshot != null) {_                        snapshots.add(new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles()))__                    }_                } catch (IOException e) {_                    logger.warn(() -> new ParameterizedMessage("failed to read commit point [{}]", name), e)__                }_            }_            return new Tuple<>(new BlobStoreIndexShardSnapshots(snapshots), -1)__        };loads,all,available,snapshots,in,the,repository,param,blobs,list,of,blobs,in,repository,return,tuple,of,blob,store,index,shard,snapshots,and,the,last,snapshot,index,generation;protected,tuple,blob,store,index,shard,snapshots,integer,build,blob,store,index,shard,snapshots,map,string,blob,meta,data,blobs,int,latest,1,set,string,blob,keys,blobs,key,set,for,string,name,blob,keys,if,name,starts,with,try,int,gen,integer,parse,int,name,substring,length,if,gen,latest,latest,gen,catch,number,format,exception,ex,logger,warn,failed,to,parse,index,file,name,name,if,latest,0,try,final,blob,store,index,shard,snapshots,shard,snapshots,index,shard,snapshots,format,read,blob,container,integer,to,string,latest,return,new,tuple,shard,snapshots,latest,catch,ioexception,e,final,string,file,latest,logger,warn,new,parameterized,message,failed,to,read,index,file,file,e,else,if,blob,keys,is,empty,false,logger,debug,could,not,find,a,readable,index,n,file,in,a,non,empty,shard,snapshot,directory,blob,container,path,list,snapshot,files,snapshots,new,array,list,for,string,name,blob,keys,try,blob,store,index,shard,snapshot,snapshot,null,if,name,starts,with,snapshot,index,shard,snapshot,format,read,blob,blob,container,name,if,snapshot,null,snapshots,add,new,snapshot,files,snapshot,snapshot,snapshot,index,files,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,read,commit,point,name,e,return,new,tuple,new,blob,store,index,shard,snapshots,snapshots,1
BlobStoreRepository -> Context -> protected Tuple<BlobStoreIndexShardSnapshots, Integer> buildBlobStoreIndexShardSnapshots(Map<String, BlobMetaData> blobs);1531729807;Loads all available snapshots in the repository__@param blobs list of blobs in repository_@return tuple of BlobStoreIndexShardSnapshots and the last snapshot index generation;protected Tuple<BlobStoreIndexShardSnapshots, Integer> buildBlobStoreIndexShardSnapshots(Map<String, BlobMetaData> blobs) {_            int latest = -1__            Set<String> blobKeys = blobs.keySet()__            for (String name : blobKeys) {_                if (name.startsWith(SNAPSHOT_INDEX_PREFIX)) {_                    try {_                        int gen = Integer.parseInt(name.substring(SNAPSHOT_INDEX_PREFIX.length()))__                        if (gen > latest) {_                            latest = gen__                        }_                    } catch (NumberFormatException ex) {_                        logger.warn("failed to parse index file name [{}]", name)__                    }_                }_            }_            if (latest >= 0) {_                try {_                    final BlobStoreIndexShardSnapshots shardSnapshots =_                        indexShardSnapshotsFormat.read(blobContainer, Integer.toString(latest))__                    return new Tuple<>(shardSnapshots, latest)__                } catch (IOException e) {_                    final String file = SNAPSHOT_INDEX_PREFIX + latest__                    logger.warn(() -> new ParameterizedMessage("failed to read index file [{}]", file), e)__                }_            } else if (blobKeys.isEmpty() == false) {_                logger.debug("Could not find a readable index-N file in a non-empty shard snapshot directory [{}]", blobContainer.path())__            }__            _            List<SnapshotFiles> snapshots = new ArrayList<>()__            for (String name : blobKeys) {_                try {_                    BlobStoreIndexShardSnapshot snapshot = null__                    if (name.startsWith(SNAPSHOT_PREFIX)) {_                        snapshot = indexShardSnapshotFormat.readBlob(blobContainer, name)__                    }_                    if (snapshot != null) {_                        snapshots.add(new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles()))__                    }_                } catch (IOException e) {_                    logger.warn(() -> new ParameterizedMessage("failed to read commit point [{}]", name), e)__                }_            }_            return new Tuple<>(new BlobStoreIndexShardSnapshots(snapshots), -1)__        };loads,all,available,snapshots,in,the,repository,param,blobs,list,of,blobs,in,repository,return,tuple,of,blob,store,index,shard,snapshots,and,the,last,snapshot,index,generation;protected,tuple,blob,store,index,shard,snapshots,integer,build,blob,store,index,shard,snapshots,map,string,blob,meta,data,blobs,int,latest,1,set,string,blob,keys,blobs,key,set,for,string,name,blob,keys,if,name,starts,with,try,int,gen,integer,parse,int,name,substring,length,if,gen,latest,latest,gen,catch,number,format,exception,ex,logger,warn,failed,to,parse,index,file,name,name,if,latest,0,try,final,blob,store,index,shard,snapshots,shard,snapshots,index,shard,snapshots,format,read,blob,container,integer,to,string,latest,return,new,tuple,shard,snapshots,latest,catch,ioexception,e,final,string,file,latest,logger,warn,new,parameterized,message,failed,to,read,index,file,file,e,else,if,blob,keys,is,empty,false,logger,debug,could,not,find,a,readable,index,n,file,in,a,non,empty,shard,snapshot,directory,blob,container,path,list,snapshot,files,snapshots,new,array,list,for,string,name,blob,keys,try,blob,store,index,shard,snapshot,snapshot,null,if,name,starts,with,snapshot,index,shard,snapshot,format,read,blob,blob,container,name,if,snapshot,null,snapshots,add,new,snapshot,files,snapshot,snapshot,snapshot,index,files,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,read,commit,point,name,e,return,new,tuple,new,blob,store,index,shard,snapshots,snapshots,1
BlobStoreRepository -> Context -> protected Tuple<BlobStoreIndexShardSnapshots, Integer> buildBlobStoreIndexShardSnapshots(Map<String, BlobMetaData> blobs);1532685069;Loads all available snapshots in the repository__@param blobs list of blobs in repository_@return tuple of BlobStoreIndexShardSnapshots and the last snapshot index generation;protected Tuple<BlobStoreIndexShardSnapshots, Integer> buildBlobStoreIndexShardSnapshots(Map<String, BlobMetaData> blobs) {_            int latest = -1__            Set<String> blobKeys = blobs.keySet()__            for (String name : blobKeys) {_                if (name.startsWith(SNAPSHOT_INDEX_PREFIX)) {_                    try {_                        int gen = Integer.parseInt(name.substring(SNAPSHOT_INDEX_PREFIX.length()))__                        if (gen > latest) {_                            latest = gen__                        }_                    } catch (NumberFormatException ex) {_                        logger.warn("failed to parse index file name [{}]", name)__                    }_                }_            }_            if (latest >= 0) {_                try {_                    final BlobStoreIndexShardSnapshots shardSnapshots =_                        indexShardSnapshotsFormat.read(blobContainer, Integer.toString(latest))__                    return new Tuple<>(shardSnapshots, latest)__                } catch (IOException e) {_                    final String file = SNAPSHOT_INDEX_PREFIX + latest__                    logger.warn(() -> new ParameterizedMessage("failed to read index file [{}]", file), e)__                }_            } else if (blobKeys.isEmpty() == false) {_                logger.debug("Could not find a readable index-N file in a non-empty shard snapshot directory [{}]", blobContainer.path())__            }__            _            List<SnapshotFiles> snapshots = new ArrayList<>()__            for (String name : blobKeys) {_                try {_                    BlobStoreIndexShardSnapshot snapshot = null__                    if (name.startsWith(SNAPSHOT_PREFIX)) {_                        snapshot = indexShardSnapshotFormat.readBlob(blobContainer, name)__                    }_                    if (snapshot != null) {_                        snapshots.add(new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles()))__                    }_                } catch (IOException e) {_                    logger.warn(() -> new ParameterizedMessage("failed to read commit point [{}]", name), e)__                }_            }_            return new Tuple<>(new BlobStoreIndexShardSnapshots(snapshots), -1)__        };loads,all,available,snapshots,in,the,repository,param,blobs,list,of,blobs,in,repository,return,tuple,of,blob,store,index,shard,snapshots,and,the,last,snapshot,index,generation;protected,tuple,blob,store,index,shard,snapshots,integer,build,blob,store,index,shard,snapshots,map,string,blob,meta,data,blobs,int,latest,1,set,string,blob,keys,blobs,key,set,for,string,name,blob,keys,if,name,starts,with,try,int,gen,integer,parse,int,name,substring,length,if,gen,latest,latest,gen,catch,number,format,exception,ex,logger,warn,failed,to,parse,index,file,name,name,if,latest,0,try,final,blob,store,index,shard,snapshots,shard,snapshots,index,shard,snapshots,format,read,blob,container,integer,to,string,latest,return,new,tuple,shard,snapshots,latest,catch,ioexception,e,final,string,file,latest,logger,warn,new,parameterized,message,failed,to,read,index,file,file,e,else,if,blob,keys,is,empty,false,logger,debug,could,not,find,a,readable,index,n,file,in,a,non,empty,shard,snapshot,directory,blob,container,path,list,snapshot,files,snapshots,new,array,list,for,string,name,blob,keys,try,blob,store,index,shard,snapshot,snapshot,null,if,name,starts,with,snapshot,index,shard,snapshot,format,read,blob,blob,container,name,if,snapshot,null,snapshots,add,new,snapshot,files,snapshot,snapshot,snapshot,index,files,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,read,commit,point,name,e,return,new,tuple,new,blob,store,index,shard,snapshots,snapshots,1
BlobStoreRepository -> Context -> protected Tuple<BlobStoreIndexShardSnapshots, Integer> buildBlobStoreIndexShardSnapshots(Map<String, BlobMetaData> blobs);1535139672;Loads all available snapshots in the repository__@param blobs list of blobs in repository_@return tuple of BlobStoreIndexShardSnapshots and the last snapshot index generation;protected Tuple<BlobStoreIndexShardSnapshots, Integer> buildBlobStoreIndexShardSnapshots(Map<String, BlobMetaData> blobs) {_            int latest = -1__            Set<String> blobKeys = blobs.keySet()__            for (String name : blobKeys) {_                if (name.startsWith(SNAPSHOT_INDEX_PREFIX)) {_                    try {_                        int gen = Integer.parseInt(name.substring(SNAPSHOT_INDEX_PREFIX.length()))__                        if (gen > latest) {_                            latest = gen__                        }_                    } catch (NumberFormatException ex) {_                        logger.warn("failed to parse index file name [{}]", name)__                    }_                }_            }_            if (latest >= 0) {_                try {_                    final BlobStoreIndexShardSnapshots shardSnapshots =_                        indexShardSnapshotsFormat.read(blobContainer, Integer.toString(latest))__                    return new Tuple<>(shardSnapshots, latest)__                } catch (IOException e) {_                    final String file = SNAPSHOT_INDEX_PREFIX + latest__                    logger.warn(() -> new ParameterizedMessage("failed to read index file [{}]", file), e)__                }_            } else if (blobKeys.isEmpty() == false) {_                logger.debug("Could not find a readable index-N file in a non-empty shard snapshot directory [{}]", blobContainer.path())__            }__            _            List<SnapshotFiles> snapshots = new ArrayList<>()__            for (String name : blobKeys) {_                try {_                    BlobStoreIndexShardSnapshot snapshot = null__                    if (name.startsWith(SNAPSHOT_PREFIX)) {_                        snapshot = indexShardSnapshotFormat.readBlob(blobContainer, name)__                    }_                    if (snapshot != null) {_                        snapshots.add(new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles()))__                    }_                } catch (IOException e) {_                    logger.warn(() -> new ParameterizedMessage("failed to read commit point [{}]", name), e)__                }_            }_            return new Tuple<>(new BlobStoreIndexShardSnapshots(snapshots), -1)__        };loads,all,available,snapshots,in,the,repository,param,blobs,list,of,blobs,in,repository,return,tuple,of,blob,store,index,shard,snapshots,and,the,last,snapshot,index,generation;protected,tuple,blob,store,index,shard,snapshots,integer,build,blob,store,index,shard,snapshots,map,string,blob,meta,data,blobs,int,latest,1,set,string,blob,keys,blobs,key,set,for,string,name,blob,keys,if,name,starts,with,try,int,gen,integer,parse,int,name,substring,length,if,gen,latest,latest,gen,catch,number,format,exception,ex,logger,warn,failed,to,parse,index,file,name,name,if,latest,0,try,final,blob,store,index,shard,snapshots,shard,snapshots,index,shard,snapshots,format,read,blob,container,integer,to,string,latest,return,new,tuple,shard,snapshots,latest,catch,ioexception,e,final,string,file,latest,logger,warn,new,parameterized,message,failed,to,read,index,file,file,e,else,if,blob,keys,is,empty,false,logger,debug,could,not,find,a,readable,index,n,file,in,a,non,empty,shard,snapshot,directory,blob,container,path,list,snapshot,files,snapshots,new,array,list,for,string,name,blob,keys,try,blob,store,index,shard,snapshot,snapshot,null,if,name,starts,with,snapshot,index,shard,snapshot,format,read,blob,blob,container,name,if,snapshot,null,snapshots,add,new,snapshot,files,snapshot,snapshot,snapshot,index,files,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,read,commit,point,name,e,return,new,tuple,new,blob,store,index,shard,snapshots,snapshots,1
BlobStoreRepository -> Context -> protected Tuple<BlobStoreIndexShardSnapshots, Integer> buildBlobStoreIndexShardSnapshots(Map<String, BlobMetaData> blobs);1535723122;Loads all available snapshots in the repository__@param blobs list of blobs in repository_@return tuple of BlobStoreIndexShardSnapshots and the last snapshot index generation;protected Tuple<BlobStoreIndexShardSnapshots, Integer> buildBlobStoreIndexShardSnapshots(Map<String, BlobMetaData> blobs) {_            int latest = -1__            Set<String> blobKeys = blobs.keySet()__            for (String name : blobKeys) {_                if (name.startsWith(SNAPSHOT_INDEX_PREFIX)) {_                    try {_                        int gen = Integer.parseInt(name.substring(SNAPSHOT_INDEX_PREFIX.length()))__                        if (gen > latest) {_                            latest = gen__                        }_                    } catch (NumberFormatException ex) {_                        logger.warn("failed to parse index file name [{}]", name)__                    }_                }_            }_            if (latest >= 0) {_                try {_                    final BlobStoreIndexShardSnapshots shardSnapshots =_                        indexShardSnapshotsFormat.read(blobContainer, Integer.toString(latest))__                    return new Tuple<>(shardSnapshots, latest)__                } catch (IOException e) {_                    final String file = SNAPSHOT_INDEX_PREFIX + latest__                    logger.warn(() -> new ParameterizedMessage("failed to read index file [{}]", file), e)__                }_            } else if (blobKeys.isEmpty() == false) {_                logger.debug("Could not find a readable index-N file in a non-empty shard snapshot directory [{}]", blobContainer.path())__            }__            _            List<SnapshotFiles> snapshots = new ArrayList<>()__            for (String name : blobKeys) {_                try {_                    BlobStoreIndexShardSnapshot snapshot = null__                    if (name.startsWith(SNAPSHOT_PREFIX)) {_                        snapshot = indexShardSnapshotFormat.readBlob(blobContainer, name)__                    }_                    if (snapshot != null) {_                        snapshots.add(new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles()))__                    }_                } catch (IOException e) {_                    logger.warn(() -> new ParameterizedMessage("failed to read commit point [{}]", name), e)__                }_            }_            return new Tuple<>(new BlobStoreIndexShardSnapshots(snapshots), -1)__        };loads,all,available,snapshots,in,the,repository,param,blobs,list,of,blobs,in,repository,return,tuple,of,blob,store,index,shard,snapshots,and,the,last,snapshot,index,generation;protected,tuple,blob,store,index,shard,snapshots,integer,build,blob,store,index,shard,snapshots,map,string,blob,meta,data,blobs,int,latest,1,set,string,blob,keys,blobs,key,set,for,string,name,blob,keys,if,name,starts,with,try,int,gen,integer,parse,int,name,substring,length,if,gen,latest,latest,gen,catch,number,format,exception,ex,logger,warn,failed,to,parse,index,file,name,name,if,latest,0,try,final,blob,store,index,shard,snapshots,shard,snapshots,index,shard,snapshots,format,read,blob,container,integer,to,string,latest,return,new,tuple,shard,snapshots,latest,catch,ioexception,e,final,string,file,latest,logger,warn,new,parameterized,message,failed,to,read,index,file,file,e,else,if,blob,keys,is,empty,false,logger,debug,could,not,find,a,readable,index,n,file,in,a,non,empty,shard,snapshot,directory,blob,container,path,list,snapshot,files,snapshots,new,array,list,for,string,name,blob,keys,try,blob,store,index,shard,snapshot,snapshot,null,if,name,starts,with,snapshot,index,shard,snapshot,format,read,blob,blob,container,name,if,snapshot,null,snapshots,add,new,snapshot,files,snapshot,snapshot,snapshot,index,files,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,read,commit,point,name,e,return,new,tuple,new,blob,store,index,shard,snapshots,snapshots,1
BlobStoreRepository -> Context -> protected Tuple<BlobStoreIndexShardSnapshots, Integer> buildBlobStoreIndexShardSnapshots(Map<String, BlobMetaData> blobs);1536314350;Loads all available snapshots in the repository__@param blobs list of blobs in repository_@return tuple of BlobStoreIndexShardSnapshots and the last snapshot index generation;protected Tuple<BlobStoreIndexShardSnapshots, Integer> buildBlobStoreIndexShardSnapshots(Map<String, BlobMetaData> blobs) {_            int latest = -1__            Set<String> blobKeys = blobs.keySet()__            for (String name : blobKeys) {_                if (name.startsWith(SNAPSHOT_INDEX_PREFIX)) {_                    try {_                        int gen = Integer.parseInt(name.substring(SNAPSHOT_INDEX_PREFIX.length()))__                        if (gen > latest) {_                            latest = gen__                        }_                    } catch (NumberFormatException ex) {_                        logger.warn("failed to parse index file name [{}]", name)__                    }_                }_            }_            if (latest >= 0) {_                try {_                    final BlobStoreIndexShardSnapshots shardSnapshots =_                        indexShardSnapshotsFormat.read(blobContainer, Integer.toString(latest))__                    return new Tuple<>(shardSnapshots, latest)__                } catch (IOException e) {_                    final String file = SNAPSHOT_INDEX_PREFIX + latest__                    logger.warn(() -> new ParameterizedMessage("failed to read index file [{}]", file), e)__                }_            } else if (blobKeys.isEmpty() == false) {_                logger.debug("Could not find a readable index-N file in a non-empty shard snapshot directory [{}]", blobContainer.path())__            }__            _            List<SnapshotFiles> snapshots = new ArrayList<>()__            for (String name : blobKeys) {_                try {_                    BlobStoreIndexShardSnapshot snapshot = null__                    if (name.startsWith(SNAPSHOT_PREFIX)) {_                        snapshot = indexShardSnapshotFormat.readBlob(blobContainer, name)__                    }_                    if (snapshot != null) {_                        snapshots.add(new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles()))__                    }_                } catch (IOException e) {_                    logger.warn(() -> new ParameterizedMessage("failed to read commit point [{}]", name), e)__                }_            }_            return new Tuple<>(new BlobStoreIndexShardSnapshots(snapshots), -1)__        };loads,all,available,snapshots,in,the,repository,param,blobs,list,of,blobs,in,repository,return,tuple,of,blob,store,index,shard,snapshots,and,the,last,snapshot,index,generation;protected,tuple,blob,store,index,shard,snapshots,integer,build,blob,store,index,shard,snapshots,map,string,blob,meta,data,blobs,int,latest,1,set,string,blob,keys,blobs,key,set,for,string,name,blob,keys,if,name,starts,with,try,int,gen,integer,parse,int,name,substring,length,if,gen,latest,latest,gen,catch,number,format,exception,ex,logger,warn,failed,to,parse,index,file,name,name,if,latest,0,try,final,blob,store,index,shard,snapshots,shard,snapshots,index,shard,snapshots,format,read,blob,container,integer,to,string,latest,return,new,tuple,shard,snapshots,latest,catch,ioexception,e,final,string,file,latest,logger,warn,new,parameterized,message,failed,to,read,index,file,file,e,else,if,blob,keys,is,empty,false,logger,debug,could,not,find,a,readable,index,n,file,in,a,non,empty,shard,snapshot,directory,blob,container,path,list,snapshot,files,snapshots,new,array,list,for,string,name,blob,keys,try,blob,store,index,shard,snapshot,snapshot,null,if,name,starts,with,snapshot,index,shard,snapshot,format,read,blob,blob,container,name,if,snapshot,null,snapshots,add,new,snapshot,files,snapshot,snapshot,snapshot,index,files,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,read,commit,point,name,e,return,new,tuple,new,blob,store,index,shard,snapshots,snapshots,1
BlobStoreRepository -> Context -> protected Tuple<BlobStoreIndexShardSnapshots, Integer> buildBlobStoreIndexShardSnapshots(Map<String, BlobMetaData> blobs);1536828374;Loads all available snapshots in the repository__@param blobs list of blobs in repository_@return tuple of BlobStoreIndexShardSnapshots and the last snapshot index generation;protected Tuple<BlobStoreIndexShardSnapshots, Integer> buildBlobStoreIndexShardSnapshots(Map<String, BlobMetaData> blobs) {_            int latest = -1__            Set<String> blobKeys = blobs.keySet()__            for (String name : blobKeys) {_                if (name.startsWith(SNAPSHOT_INDEX_PREFIX)) {_                    try {_                        int gen = Integer.parseInt(name.substring(SNAPSHOT_INDEX_PREFIX.length()))__                        if (gen > latest) {_                            latest = gen__                        }_                    } catch (NumberFormatException ex) {_                        logger.warn("failed to parse index file name [{}]", name)__                    }_                }_            }_            if (latest >= 0) {_                try {_                    final BlobStoreIndexShardSnapshots shardSnapshots =_                        indexShardSnapshotsFormat.read(blobContainer, Integer.toString(latest))__                    return new Tuple<>(shardSnapshots, latest)__                } catch (IOException e) {_                    final String file = SNAPSHOT_INDEX_PREFIX + latest__                    logger.warn(() -> new ParameterizedMessage("failed to read index file [{}]", file), e)__                }_            } else if (blobKeys.isEmpty() == false) {_                logger.debug("Could not find a readable index-N file in a non-empty shard snapshot directory [{}]", blobContainer.path())__            }__            _            List<SnapshotFiles> snapshots = new ArrayList<>()__            for (String name : blobKeys) {_                try {_                    BlobStoreIndexShardSnapshot snapshot = null__                    if (name.startsWith(SNAPSHOT_PREFIX)) {_                        snapshot = indexShardSnapshotFormat.readBlob(blobContainer, name)__                    }_                    if (snapshot != null) {_                        snapshots.add(new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles()))__                    }_                } catch (IOException e) {_                    logger.warn(() -> new ParameterizedMessage("failed to read commit point [{}]", name), e)__                }_            }_            return new Tuple<>(new BlobStoreIndexShardSnapshots(snapshots), -1)__        };loads,all,available,snapshots,in,the,repository,param,blobs,list,of,blobs,in,repository,return,tuple,of,blob,store,index,shard,snapshots,and,the,last,snapshot,index,generation;protected,tuple,blob,store,index,shard,snapshots,integer,build,blob,store,index,shard,snapshots,map,string,blob,meta,data,blobs,int,latest,1,set,string,blob,keys,blobs,key,set,for,string,name,blob,keys,if,name,starts,with,try,int,gen,integer,parse,int,name,substring,length,if,gen,latest,latest,gen,catch,number,format,exception,ex,logger,warn,failed,to,parse,index,file,name,name,if,latest,0,try,final,blob,store,index,shard,snapshots,shard,snapshots,index,shard,snapshots,format,read,blob,container,integer,to,string,latest,return,new,tuple,shard,snapshots,latest,catch,ioexception,e,final,string,file,latest,logger,warn,new,parameterized,message,failed,to,read,index,file,file,e,else,if,blob,keys,is,empty,false,logger,debug,could,not,find,a,readable,index,n,file,in,a,non,empty,shard,snapshot,directory,blob,container,path,list,snapshot,files,snapshots,new,array,list,for,string,name,blob,keys,try,blob,store,index,shard,snapshot,snapshot,null,if,name,starts,with,snapshot,index,shard,snapshot,format,read,blob,blob,container,name,if,snapshot,null,snapshots,add,new,snapshot,files,snapshot,snapshot,snapshot,index,files,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,read,commit,point,name,e,return,new,tuple,new,blob,store,index,shard,snapshots,snapshots,1
BlobStoreRepository -> Context -> protected Tuple<BlobStoreIndexShardSnapshots, Integer> buildBlobStoreIndexShardSnapshots(Map<String, BlobMetaData> blobs);1541008027;Loads all available snapshots in the repository__@param blobs list of blobs in repository_@return tuple of BlobStoreIndexShardSnapshots and the last snapshot index generation;protected Tuple<BlobStoreIndexShardSnapshots, Integer> buildBlobStoreIndexShardSnapshots(Map<String, BlobMetaData> blobs) {_            int latest = -1__            Set<String> blobKeys = blobs.keySet()__            for (String name : blobKeys) {_                if (name.startsWith(SNAPSHOT_INDEX_PREFIX)) {_                    try {_                        int gen = Integer.parseInt(name.substring(SNAPSHOT_INDEX_PREFIX.length()))__                        if (gen > latest) {_                            latest = gen__                        }_                    } catch (NumberFormatException ex) {_                        logger.warn("failed to parse index file name [{}]", name)__                    }_                }_            }_            if (latest >= 0) {_                try {_                    final BlobStoreIndexShardSnapshots shardSnapshots =_                        indexShardSnapshotsFormat.read(blobContainer, Integer.toString(latest))__                    return new Tuple<>(shardSnapshots, latest)__                } catch (IOException e) {_                    final String file = SNAPSHOT_INDEX_PREFIX + latest__                    logger.warn(() -> new ParameterizedMessage("failed to read index file [{}]", file), e)__                }_            } else if (blobKeys.isEmpty() == false) {_                logger.debug("Could not find a readable index-N file in a non-empty shard snapshot directory [{}]", blobContainer.path())__            }__            _            List<SnapshotFiles> snapshots = new ArrayList<>()__            for (String name : blobKeys) {_                try {_                    BlobStoreIndexShardSnapshot snapshot = null__                    if (name.startsWith(SNAPSHOT_PREFIX)) {_                        snapshot = indexShardSnapshotFormat.readBlob(blobContainer, name)__                    }_                    if (snapshot != null) {_                        snapshots.add(new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles()))__                    }_                } catch (IOException e) {_                    logger.warn(() -> new ParameterizedMessage("failed to read commit point [{}]", name), e)__                }_            }_            return new Tuple<>(new BlobStoreIndexShardSnapshots(snapshots), -1)__        };loads,all,available,snapshots,in,the,repository,param,blobs,list,of,blobs,in,repository,return,tuple,of,blob,store,index,shard,snapshots,and,the,last,snapshot,index,generation;protected,tuple,blob,store,index,shard,snapshots,integer,build,blob,store,index,shard,snapshots,map,string,blob,meta,data,blobs,int,latest,1,set,string,blob,keys,blobs,key,set,for,string,name,blob,keys,if,name,starts,with,try,int,gen,integer,parse,int,name,substring,length,if,gen,latest,latest,gen,catch,number,format,exception,ex,logger,warn,failed,to,parse,index,file,name,name,if,latest,0,try,final,blob,store,index,shard,snapshots,shard,snapshots,index,shard,snapshots,format,read,blob,container,integer,to,string,latest,return,new,tuple,shard,snapshots,latest,catch,ioexception,e,final,string,file,latest,logger,warn,new,parameterized,message,failed,to,read,index,file,file,e,else,if,blob,keys,is,empty,false,logger,debug,could,not,find,a,readable,index,n,file,in,a,non,empty,shard,snapshot,directory,blob,container,path,list,snapshot,files,snapshots,new,array,list,for,string,name,blob,keys,try,blob,store,index,shard,snapshot,snapshot,null,if,name,starts,with,snapshot,index,shard,snapshot,format,read,blob,blob,container,name,if,snapshot,null,snapshots,add,new,snapshot,files,snapshot,snapshot,snapshot,index,files,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,read,commit,point,name,e,return,new,tuple,new,blob,store,index,shard,snapshots,snapshots,1
BlobStoreRepository -> Context -> protected Tuple<BlobStoreIndexShardSnapshots, Integer> buildBlobStoreIndexShardSnapshots(Map<String, BlobMetaData> blobs);1542646292;Loads all available snapshots in the repository__@param blobs list of blobs in repository_@return tuple of BlobStoreIndexShardSnapshots and the last snapshot index generation;protected Tuple<BlobStoreIndexShardSnapshots, Integer> buildBlobStoreIndexShardSnapshots(Map<String, BlobMetaData> blobs) {_            int latest = -1__            Set<String> blobKeys = blobs.keySet()__            for (String name : blobKeys) {_                if (name.startsWith(SNAPSHOT_INDEX_PREFIX)) {_                    try {_                        int gen = Integer.parseInt(name.substring(SNAPSHOT_INDEX_PREFIX.length()))__                        if (gen > latest) {_                            latest = gen__                        }_                    } catch (NumberFormatException ex) {_                        logger.warn("failed to parse index file name [{}]", name)__                    }_                }_            }_            if (latest >= 0) {_                try {_                    final BlobStoreIndexShardSnapshots shardSnapshots =_                        indexShardSnapshotsFormat.read(blobContainer, Integer.toString(latest))__                    return new Tuple<>(shardSnapshots, latest)__                } catch (IOException e) {_                    final String file = SNAPSHOT_INDEX_PREFIX + latest__                    logger.warn(() -> new ParameterizedMessage("failed to read index file [{}]", file), e)__                }_            } else if (blobKeys.isEmpty() == false) {_                logger.debug("Could not find a readable index-N file in a non-empty shard snapshot directory [{}]", blobContainer.path())__            }__            _            List<SnapshotFiles> snapshots = new ArrayList<>()__            for (String name : blobKeys) {_                try {_                    BlobStoreIndexShardSnapshot snapshot = null__                    if (name.startsWith(SNAPSHOT_PREFIX)) {_                        snapshot = indexShardSnapshotFormat.readBlob(blobContainer, name)__                    }_                    if (snapshot != null) {_                        snapshots.add(new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles()))__                    }_                } catch (IOException e) {_                    logger.warn(() -> new ParameterizedMessage("failed to read commit point [{}]", name), e)__                }_            }_            return new Tuple<>(new BlobStoreIndexShardSnapshots(snapshots), -1)__        };loads,all,available,snapshots,in,the,repository,param,blobs,list,of,blobs,in,repository,return,tuple,of,blob,store,index,shard,snapshots,and,the,last,snapshot,index,generation;protected,tuple,blob,store,index,shard,snapshots,integer,build,blob,store,index,shard,snapshots,map,string,blob,meta,data,blobs,int,latest,1,set,string,blob,keys,blobs,key,set,for,string,name,blob,keys,if,name,starts,with,try,int,gen,integer,parse,int,name,substring,length,if,gen,latest,latest,gen,catch,number,format,exception,ex,logger,warn,failed,to,parse,index,file,name,name,if,latest,0,try,final,blob,store,index,shard,snapshots,shard,snapshots,index,shard,snapshots,format,read,blob,container,integer,to,string,latest,return,new,tuple,shard,snapshots,latest,catch,ioexception,e,final,string,file,latest,logger,warn,new,parameterized,message,failed,to,read,index,file,file,e,else,if,blob,keys,is,empty,false,logger,debug,could,not,find,a,readable,index,n,file,in,a,non,empty,shard,snapshot,directory,blob,container,path,list,snapshot,files,snapshots,new,array,list,for,string,name,blob,keys,try,blob,store,index,shard,snapshot,snapshot,null,if,name,starts,with,snapshot,index,shard,snapshot,format,read,blob,blob,container,name,if,snapshot,null,snapshots,add,new,snapshot,files,snapshot,snapshot,snapshot,index,files,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,read,commit,point,name,e,return,new,tuple,new,blob,store,index,shard,snapshots,snapshots,1
BlobStoreRepository -> Context -> protected Tuple<BlobStoreIndexShardSnapshots, Integer> buildBlobStoreIndexShardSnapshots(Map<String, BlobMetaData> blobs);1542980705;Loads all available snapshots in the repository__@param blobs list of blobs in repository_@return tuple of BlobStoreIndexShardSnapshots and the last snapshot index generation;protected Tuple<BlobStoreIndexShardSnapshots, Integer> buildBlobStoreIndexShardSnapshots(Map<String, BlobMetaData> blobs) {_            int latest = -1__            Set<String> blobKeys = blobs.keySet()__            for (String name : blobKeys) {_                if (name.startsWith(SNAPSHOT_INDEX_PREFIX)) {_                    try {_                        int gen = Integer.parseInt(name.substring(SNAPSHOT_INDEX_PREFIX.length()))__                        if (gen > latest) {_                            latest = gen__                        }_                    } catch (NumberFormatException ex) {_                        logger.warn("failed to parse index file name [{}]", name)__                    }_                }_            }_            if (latest >= 0) {_                try {_                    final BlobStoreIndexShardSnapshots shardSnapshots =_                        indexShardSnapshotsFormat.read(blobContainer, Integer.toString(latest))__                    return new Tuple<>(shardSnapshots, latest)__                } catch (IOException e) {_                    final String file = SNAPSHOT_INDEX_PREFIX + latest__                    logger.warn(() -> new ParameterizedMessage("failed to read index file [{}]", file), e)__                }_            } else if (blobKeys.isEmpty() == false) {_                logger.debug("Could not find a readable index-N file in a non-empty shard snapshot directory [{}]", blobContainer.path())__            }__            _            List<SnapshotFiles> snapshots = new ArrayList<>()__            for (String name : blobKeys) {_                try {_                    BlobStoreIndexShardSnapshot snapshot = null__                    if (name.startsWith(SNAPSHOT_PREFIX)) {_                        snapshot = indexShardSnapshotFormat.readBlob(blobContainer, name)__                    }_                    if (snapshot != null) {_                        snapshots.add(new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles()))__                    }_                } catch (IOException e) {_                    logger.warn(() -> new ParameterizedMessage("failed to read commit point [{}]", name), e)__                }_            }_            return new Tuple<>(new BlobStoreIndexShardSnapshots(snapshots), -1)__        };loads,all,available,snapshots,in,the,repository,param,blobs,list,of,blobs,in,repository,return,tuple,of,blob,store,index,shard,snapshots,and,the,last,snapshot,index,generation;protected,tuple,blob,store,index,shard,snapshots,integer,build,blob,store,index,shard,snapshots,map,string,blob,meta,data,blobs,int,latest,1,set,string,blob,keys,blobs,key,set,for,string,name,blob,keys,if,name,starts,with,try,int,gen,integer,parse,int,name,substring,length,if,gen,latest,latest,gen,catch,number,format,exception,ex,logger,warn,failed,to,parse,index,file,name,name,if,latest,0,try,final,blob,store,index,shard,snapshots,shard,snapshots,index,shard,snapshots,format,read,blob,container,integer,to,string,latest,return,new,tuple,shard,snapshots,latest,catch,ioexception,e,final,string,file,latest,logger,warn,new,parameterized,message,failed,to,read,index,file,file,e,else,if,blob,keys,is,empty,false,logger,debug,could,not,find,a,readable,index,n,file,in,a,non,empty,shard,snapshot,directory,blob,container,path,list,snapshot,files,snapshots,new,array,list,for,string,name,blob,keys,try,blob,store,index,shard,snapshot,snapshot,null,if,name,starts,with,snapshot,index,shard,snapshot,format,read,blob,blob,container,name,if,snapshot,null,snapshots,add,new,snapshot,files,snapshot,snapshot,snapshot,index,files,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,read,commit,point,name,e,return,new,tuple,new,blob,store,index,shard,snapshots,snapshots,1
BlobStoreRepository -> Context -> protected Tuple<BlobStoreIndexShardSnapshots, Integer> buildBlobStoreIndexShardSnapshots(Map<String, BlobMetaData> blobs);1543831870;Loads all available snapshots in the repository__@param blobs list of blobs in repository_@return tuple of BlobStoreIndexShardSnapshots and the last snapshot index generation;protected Tuple<BlobStoreIndexShardSnapshots, Integer> buildBlobStoreIndexShardSnapshots(Map<String, BlobMetaData> blobs) {_            int latest = -1__            Set<String> blobKeys = blobs.keySet()__            for (String name : blobKeys) {_                if (name.startsWith(SNAPSHOT_INDEX_PREFIX)) {_                    try {_                        int gen = Integer.parseInt(name.substring(SNAPSHOT_INDEX_PREFIX.length()))__                        if (gen > latest) {_                            latest = gen__                        }_                    } catch (NumberFormatException ex) {_                        logger.warn("failed to parse index file name [{}]", name)__                    }_                }_            }_            if (latest >= 0) {_                try {_                    final BlobStoreIndexShardSnapshots shardSnapshots =_                        indexShardSnapshotsFormat.read(blobContainer, Integer.toString(latest))__                    return new Tuple<>(shardSnapshots, latest)__                } catch (IOException e) {_                    final String file = SNAPSHOT_INDEX_PREFIX + latest__                    logger.warn(() -> new ParameterizedMessage("failed to read index file [{}]", file), e)__                }_            } else if (blobKeys.isEmpty() == false) {_                logger.debug("Could not find a readable index-N file in a non-empty shard snapshot directory [{}]", blobContainer.path())__            }__            _            List<SnapshotFiles> snapshots = new ArrayList<>()__            for (String name : blobKeys) {_                try {_                    BlobStoreIndexShardSnapshot snapshot = null__                    if (name.startsWith(SNAPSHOT_PREFIX)) {_                        snapshot = indexShardSnapshotFormat.readBlob(blobContainer, name)__                    }_                    if (snapshot != null) {_                        snapshots.add(new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles()))__                    }_                } catch (IOException e) {_                    logger.warn(() -> new ParameterizedMessage("failed to read commit point [{}]", name), e)__                }_            }_            return new Tuple<>(new BlobStoreIndexShardSnapshots(snapshots), -1)__        };loads,all,available,snapshots,in,the,repository,param,blobs,list,of,blobs,in,repository,return,tuple,of,blob,store,index,shard,snapshots,and,the,last,snapshot,index,generation;protected,tuple,blob,store,index,shard,snapshots,integer,build,blob,store,index,shard,snapshots,map,string,blob,meta,data,blobs,int,latest,1,set,string,blob,keys,blobs,key,set,for,string,name,blob,keys,if,name,starts,with,try,int,gen,integer,parse,int,name,substring,length,if,gen,latest,latest,gen,catch,number,format,exception,ex,logger,warn,failed,to,parse,index,file,name,name,if,latest,0,try,final,blob,store,index,shard,snapshots,shard,snapshots,index,shard,snapshots,format,read,blob,container,integer,to,string,latest,return,new,tuple,shard,snapshots,latest,catch,ioexception,e,final,string,file,latest,logger,warn,new,parameterized,message,failed,to,read,index,file,file,e,else,if,blob,keys,is,empty,false,logger,debug,could,not,find,a,readable,index,n,file,in,a,non,empty,shard,snapshot,directory,blob,container,path,list,snapshot,files,snapshots,new,array,list,for,string,name,blob,keys,try,blob,store,index,shard,snapshot,snapshot,null,if,name,starts,with,snapshot,index,shard,snapshot,format,read,blob,blob,container,name,if,snapshot,null,snapshots,add,new,snapshot,files,snapshot,snapshot,snapshot,index,files,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,read,commit,point,name,e,return,new,tuple,new,blob,store,index,shard,snapshots,snapshots,1
BlobStoreRepository -> Context -> protected Tuple<BlobStoreIndexShardSnapshots, Integer> buildBlobStoreIndexShardSnapshots(Map<String, BlobMetaData> blobs);1543942400;Loads all available snapshots in the repository__@param blobs list of blobs in repository_@return tuple of BlobStoreIndexShardSnapshots and the last snapshot index generation;protected Tuple<BlobStoreIndexShardSnapshots, Integer> buildBlobStoreIndexShardSnapshots(Map<String, BlobMetaData> blobs) {_            int latest = -1__            Set<String> blobKeys = blobs.keySet()__            for (String name : blobKeys) {_                if (name.startsWith(SNAPSHOT_INDEX_PREFIX)) {_                    try {_                        int gen = Integer.parseInt(name.substring(SNAPSHOT_INDEX_PREFIX.length()))__                        if (gen > latest) {_                            latest = gen__                        }_                    } catch (NumberFormatException ex) {_                        logger.warn("failed to parse index file name [{}]", name)__                    }_                }_            }_            if (latest >= 0) {_                try {_                    final BlobStoreIndexShardSnapshots shardSnapshots =_                        indexShardSnapshotsFormat.read(blobContainer, Integer.toString(latest))__                    return new Tuple<>(shardSnapshots, latest)__                } catch (IOException e) {_                    final String file = SNAPSHOT_INDEX_PREFIX + latest__                    logger.warn(() -> new ParameterizedMessage("failed to read index file [{}]", file), e)__                }_            } else if (blobKeys.isEmpty() == false) {_                logger.debug("Could not find a readable index-N file in a non-empty shard snapshot directory [{}]", blobContainer.path())__            }__            _            List<SnapshotFiles> snapshots = new ArrayList<>()__            for (String name : blobKeys) {_                try {_                    BlobStoreIndexShardSnapshot snapshot = null__                    if (name.startsWith(SNAPSHOT_PREFIX)) {_                        snapshot = indexShardSnapshotFormat.readBlob(blobContainer, name)__                    }_                    if (snapshot != null) {_                        snapshots.add(new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles()))__                    }_                } catch (IOException e) {_                    logger.warn(() -> new ParameterizedMessage("failed to read commit point [{}]", name), e)__                }_            }_            return new Tuple<>(new BlobStoreIndexShardSnapshots(snapshots), -1)__        };loads,all,available,snapshots,in,the,repository,param,blobs,list,of,blobs,in,repository,return,tuple,of,blob,store,index,shard,snapshots,and,the,last,snapshot,index,generation;protected,tuple,blob,store,index,shard,snapshots,integer,build,blob,store,index,shard,snapshots,map,string,blob,meta,data,blobs,int,latest,1,set,string,blob,keys,blobs,key,set,for,string,name,blob,keys,if,name,starts,with,try,int,gen,integer,parse,int,name,substring,length,if,gen,latest,latest,gen,catch,number,format,exception,ex,logger,warn,failed,to,parse,index,file,name,name,if,latest,0,try,final,blob,store,index,shard,snapshots,shard,snapshots,index,shard,snapshots,format,read,blob,container,integer,to,string,latest,return,new,tuple,shard,snapshots,latest,catch,ioexception,e,final,string,file,latest,logger,warn,new,parameterized,message,failed,to,read,index,file,file,e,else,if,blob,keys,is,empty,false,logger,debug,could,not,find,a,readable,index,n,file,in,a,non,empty,shard,snapshot,directory,blob,container,path,list,snapshot,files,snapshots,new,array,list,for,string,name,blob,keys,try,blob,store,index,shard,snapshot,snapshot,null,if,name,starts,with,snapshot,index,shard,snapshot,format,read,blob,blob,container,name,if,snapshot,null,snapshots,add,new,snapshot,files,snapshot,snapshot,snapshot,index,files,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,read,commit,point,name,e,return,new,tuple,new,blob,store,index,shard,snapshots,snapshots,1
BlobStoreRepository -> Context -> protected Tuple<BlobStoreIndexShardSnapshots, Integer> buildBlobStoreIndexShardSnapshots(Map<String, BlobMetaData> blobs);1546974294;Loads all available snapshots in the repository__@param blobs list of blobs in repository_@return tuple of BlobStoreIndexShardSnapshots and the last snapshot index generation;protected Tuple<BlobStoreIndexShardSnapshots, Integer> buildBlobStoreIndexShardSnapshots(Map<String, BlobMetaData> blobs) {_            int latest = -1__            Set<String> blobKeys = blobs.keySet()__            for (String name : blobKeys) {_                if (name.startsWith(SNAPSHOT_INDEX_PREFIX)) {_                    try {_                        int gen = Integer.parseInt(name.substring(SNAPSHOT_INDEX_PREFIX.length()))__                        if (gen > latest) {_                            latest = gen__                        }_                    } catch (NumberFormatException ex) {_                        logger.warn("failed to parse index file name [{}]", name)__                    }_                }_            }_            if (latest >= 0) {_                try {_                    final BlobStoreIndexShardSnapshots shardSnapshots =_                        indexShardSnapshotsFormat.read(blobContainer, Integer.toString(latest))__                    return new Tuple<>(shardSnapshots, latest)__                } catch (IOException e) {_                    final String file = SNAPSHOT_INDEX_PREFIX + latest__                    logger.warn(() -> new ParameterizedMessage("failed to read index file [{}]", file), e)__                }_            } else if (blobKeys.isEmpty() == false) {_                logger.debug("Could not find a readable index-N file in a non-empty shard snapshot directory [{}]", blobContainer.path())__            }__            _            List<SnapshotFiles> snapshots = new ArrayList<>()__            for (String name : blobKeys) {_                try {_                    BlobStoreIndexShardSnapshot snapshot = null__                    if (name.startsWith(SNAPSHOT_PREFIX)) {_                        snapshot = indexShardSnapshotFormat.readBlob(blobContainer, name)__                    }_                    if (snapshot != null) {_                        snapshots.add(new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles()))__                    }_                } catch (IOException e) {_                    logger.warn(() -> new ParameterizedMessage("failed to read commit point [{}]", name), e)__                }_            }_            return new Tuple<>(new BlobStoreIndexShardSnapshots(snapshots), -1)__        };loads,all,available,snapshots,in,the,repository,param,blobs,list,of,blobs,in,repository,return,tuple,of,blob,store,index,shard,snapshots,and,the,last,snapshot,index,generation;protected,tuple,blob,store,index,shard,snapshots,integer,build,blob,store,index,shard,snapshots,map,string,blob,meta,data,blobs,int,latest,1,set,string,blob,keys,blobs,key,set,for,string,name,blob,keys,if,name,starts,with,try,int,gen,integer,parse,int,name,substring,length,if,gen,latest,latest,gen,catch,number,format,exception,ex,logger,warn,failed,to,parse,index,file,name,name,if,latest,0,try,final,blob,store,index,shard,snapshots,shard,snapshots,index,shard,snapshots,format,read,blob,container,integer,to,string,latest,return,new,tuple,shard,snapshots,latest,catch,ioexception,e,final,string,file,latest,logger,warn,new,parameterized,message,failed,to,read,index,file,file,e,else,if,blob,keys,is,empty,false,logger,debug,could,not,find,a,readable,index,n,file,in,a,non,empty,shard,snapshot,directory,blob,container,path,list,snapshot,files,snapshots,new,array,list,for,string,name,blob,keys,try,blob,store,index,shard,snapshot,snapshot,null,if,name,starts,with,snapshot,index,shard,snapshot,format,read,blob,blob,container,name,if,snapshot,null,snapshots,add,new,snapshot,files,snapshot,snapshot,snapshot,index,files,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,read,commit,point,name,e,return,new,tuple,new,blob,store,index,shard,snapshots,snapshots,1
BlobStoreRepository -> Context -> protected Tuple<BlobStoreIndexShardSnapshots, Integer> buildBlobStoreIndexShardSnapshots(Map<String, BlobMetaData> blobs);1547496475;Loads all available snapshots in the repository__@param blobs list of blobs in repository_@return tuple of BlobStoreIndexShardSnapshots and the last snapshot index generation;protected Tuple<BlobStoreIndexShardSnapshots, Integer> buildBlobStoreIndexShardSnapshots(Map<String, BlobMetaData> blobs) {_            int latest = -1__            Set<String> blobKeys = blobs.keySet()__            for (String name : blobKeys) {_                if (name.startsWith(SNAPSHOT_INDEX_PREFIX)) {_                    try {_                        int gen = Integer.parseInt(name.substring(SNAPSHOT_INDEX_PREFIX.length()))__                        if (gen > latest) {_                            latest = gen__                        }_                    } catch (NumberFormatException ex) {_                        logger.warn("failed to parse index file name [{}]", name)__                    }_                }_            }_            if (latest >= 0) {_                try {_                    final BlobStoreIndexShardSnapshots shardSnapshots =_                        indexShardSnapshotsFormat.read(blobContainer, Integer.toString(latest))__                    return new Tuple<>(shardSnapshots, latest)__                } catch (IOException e) {_                    final String file = SNAPSHOT_INDEX_PREFIX + latest__                    logger.warn(() -> new ParameterizedMessage("failed to read index file [{}]", file), e)__                }_            } else if (blobKeys.isEmpty() == false) {_                logger.debug("Could not find a readable index-N file in a non-empty shard snapshot directory [{}]", blobContainer.path())__            }__            _            List<SnapshotFiles> snapshots = new ArrayList<>()__            for (String name : blobKeys) {_                try {_                    BlobStoreIndexShardSnapshot snapshot = null__                    if (name.startsWith(SNAPSHOT_PREFIX)) {_                        snapshot = indexShardSnapshotFormat.readBlob(blobContainer, name)__                    }_                    if (snapshot != null) {_                        snapshots.add(new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles()))__                    }_                } catch (IOException e) {_                    logger.warn(() -> new ParameterizedMessage("failed to read commit point [{}]", name), e)__                }_            }_            return new Tuple<>(new BlobStoreIndexShardSnapshots(snapshots), -1)__        };loads,all,available,snapshots,in,the,repository,param,blobs,list,of,blobs,in,repository,return,tuple,of,blob,store,index,shard,snapshots,and,the,last,snapshot,index,generation;protected,tuple,blob,store,index,shard,snapshots,integer,build,blob,store,index,shard,snapshots,map,string,blob,meta,data,blobs,int,latest,1,set,string,blob,keys,blobs,key,set,for,string,name,blob,keys,if,name,starts,with,try,int,gen,integer,parse,int,name,substring,length,if,gen,latest,latest,gen,catch,number,format,exception,ex,logger,warn,failed,to,parse,index,file,name,name,if,latest,0,try,final,blob,store,index,shard,snapshots,shard,snapshots,index,shard,snapshots,format,read,blob,container,integer,to,string,latest,return,new,tuple,shard,snapshots,latest,catch,ioexception,e,final,string,file,latest,logger,warn,new,parameterized,message,failed,to,read,index,file,file,e,else,if,blob,keys,is,empty,false,logger,debug,could,not,find,a,readable,index,n,file,in,a,non,empty,shard,snapshot,directory,blob,container,path,list,snapshot,files,snapshots,new,array,list,for,string,name,blob,keys,try,blob,store,index,shard,snapshot,snapshot,null,if,name,starts,with,snapshot,index,shard,snapshot,format,read,blob,blob,container,name,if,snapshot,null,snapshots,add,new,snapshot,files,snapshot,snapshot,snapshot,index,files,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,read,commit,point,name,e,return,new,tuple,new,blob,store,index,shard,snapshots,snapshots,1
BlobStoreRepository -> Context -> protected Tuple<BlobStoreIndexShardSnapshots, Integer> buildBlobStoreIndexShardSnapshots(Map<String, BlobMetaData> blobs);1547625930;Loads all available snapshots in the repository__@param blobs list of blobs in repository_@return tuple of BlobStoreIndexShardSnapshots and the last snapshot index generation;protected Tuple<BlobStoreIndexShardSnapshots, Integer> buildBlobStoreIndexShardSnapshots(Map<String, BlobMetaData> blobs) {_            int latest = -1__            Set<String> blobKeys = blobs.keySet()__            for (String name : blobKeys) {_                if (name.startsWith(SNAPSHOT_INDEX_PREFIX)) {_                    try {_                        int gen = Integer.parseInt(name.substring(SNAPSHOT_INDEX_PREFIX.length()))__                        if (gen > latest) {_                            latest = gen__                        }_                    } catch (NumberFormatException ex) {_                        logger.warn("failed to parse index file name [{}]", name)__                    }_                }_            }_            if (latest >= 0) {_                try {_                    final BlobStoreIndexShardSnapshots shardSnapshots =_                        indexShardSnapshotsFormat.read(blobContainer, Integer.toString(latest))__                    return new Tuple<>(shardSnapshots, latest)__                } catch (IOException e) {_                    final String file = SNAPSHOT_INDEX_PREFIX + latest__                    logger.warn(() -> new ParameterizedMessage("failed to read index file [{}]", file), e)__                }_            } else if (blobKeys.isEmpty() == false) {_                logger.debug("Could not find a readable index-N file in a non-empty shard snapshot directory [{}]", blobContainer.path())__            }__            _            List<SnapshotFiles> snapshots = new ArrayList<>()__            for (String name : blobKeys) {_                try {_                    BlobStoreIndexShardSnapshot snapshot = null__                    if (name.startsWith(SNAPSHOT_PREFIX)) {_                        snapshot = indexShardSnapshotFormat.readBlob(blobContainer, name)__                    }_                    if (snapshot != null) {_                        snapshots.add(new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles()))__                    }_                } catch (IOException e) {_                    logger.warn(() -> new ParameterizedMessage("failed to read commit point [{}]", name), e)__                }_            }_            return new Tuple<>(new BlobStoreIndexShardSnapshots(snapshots), -1)__        };loads,all,available,snapshots,in,the,repository,param,blobs,list,of,blobs,in,repository,return,tuple,of,blob,store,index,shard,snapshots,and,the,last,snapshot,index,generation;protected,tuple,blob,store,index,shard,snapshots,integer,build,blob,store,index,shard,snapshots,map,string,blob,meta,data,blobs,int,latest,1,set,string,blob,keys,blobs,key,set,for,string,name,blob,keys,if,name,starts,with,try,int,gen,integer,parse,int,name,substring,length,if,gen,latest,latest,gen,catch,number,format,exception,ex,logger,warn,failed,to,parse,index,file,name,name,if,latest,0,try,final,blob,store,index,shard,snapshots,shard,snapshots,index,shard,snapshots,format,read,blob,container,integer,to,string,latest,return,new,tuple,shard,snapshots,latest,catch,ioexception,e,final,string,file,latest,logger,warn,new,parameterized,message,failed,to,read,index,file,file,e,else,if,blob,keys,is,empty,false,logger,debug,could,not,find,a,readable,index,n,file,in,a,non,empty,shard,snapshot,directory,blob,container,path,list,snapshot,files,snapshots,new,array,list,for,string,name,blob,keys,try,blob,store,index,shard,snapshot,snapshot,null,if,name,starts,with,snapshot,index,shard,snapshot,format,read,blob,blob,container,name,if,snapshot,null,snapshots,add,new,snapshot,files,snapshot,snapshot,snapshot,index,files,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,read,commit,point,name,e,return,new,tuple,new,blob,store,index,shard,snapshots,snapshots,1
BlobStoreRepository -> Context -> protected Tuple<BlobStoreIndexShardSnapshots, Integer> buildBlobStoreIndexShardSnapshots(Map<String, BlobMetaData> blobs);1550647627;Loads all available snapshots in the repository__@param blobs list of blobs in repository_@return tuple of BlobStoreIndexShardSnapshots and the last snapshot index generation;protected Tuple<BlobStoreIndexShardSnapshots, Integer> buildBlobStoreIndexShardSnapshots(Map<String, BlobMetaData> blobs) {_            int latest = -1__            Set<String> blobKeys = blobs.keySet()__            for (String name : blobKeys) {_                if (name.startsWith(SNAPSHOT_INDEX_PREFIX)) {_                    try {_                        int gen = Integer.parseInt(name.substring(SNAPSHOT_INDEX_PREFIX.length()))__                        if (gen > latest) {_                            latest = gen__                        }_                    } catch (NumberFormatException ex) {_                        logger.warn("failed to parse index file name [{}]", name)__                    }_                }_            }_            if (latest >= 0) {_                try {_                    final BlobStoreIndexShardSnapshots shardSnapshots =_                        indexShardSnapshotsFormat.read(blobContainer, Integer.toString(latest))__                    return new Tuple<>(shardSnapshots, latest)__                } catch (IOException e) {_                    final String file = SNAPSHOT_INDEX_PREFIX + latest__                    logger.warn(() -> new ParameterizedMessage("failed to read index file [{}]", file), e)__                }_            } else if (blobKeys.isEmpty() == false) {_                logger.debug("Could not find a readable index-N file in a non-empty shard snapshot directory [{}]", blobContainer.path())__            }__            _            List<SnapshotFiles> snapshots = new ArrayList<>()__            for (String name : blobKeys) {_                try {_                    BlobStoreIndexShardSnapshot snapshot = null__                    if (name.startsWith(SNAPSHOT_PREFIX)) {_                        snapshot = indexShardSnapshotFormat.readBlob(blobContainer, name)__                    }_                    if (snapshot != null) {_                        snapshots.add(new SnapshotFiles(snapshot.snapshot(), snapshot.indexFiles()))__                    }_                } catch (IOException e) {_                    logger.warn(() -> new ParameterizedMessage("failed to read commit point [{}]", name), e)__                }_            }_            return new Tuple<>(new BlobStoreIndexShardSnapshots(snapshots), -1)__        };loads,all,available,snapshots,in,the,repository,param,blobs,list,of,blobs,in,repository,return,tuple,of,blob,store,index,shard,snapshots,and,the,last,snapshot,index,generation;protected,tuple,blob,store,index,shard,snapshots,integer,build,blob,store,index,shard,snapshots,map,string,blob,meta,data,blobs,int,latest,1,set,string,blob,keys,blobs,key,set,for,string,name,blob,keys,if,name,starts,with,try,int,gen,integer,parse,int,name,substring,length,if,gen,latest,latest,gen,catch,number,format,exception,ex,logger,warn,failed,to,parse,index,file,name,name,if,latest,0,try,final,blob,store,index,shard,snapshots,shard,snapshots,index,shard,snapshots,format,read,blob,container,integer,to,string,latest,return,new,tuple,shard,snapshots,latest,catch,ioexception,e,final,string,file,latest,logger,warn,new,parameterized,message,failed,to,read,index,file,file,e,else,if,blob,keys,is,empty,false,logger,debug,could,not,find,a,readable,index,n,file,in,a,non,empty,shard,snapshot,directory,blob,container,path,list,snapshot,files,snapshots,new,array,list,for,string,name,blob,keys,try,blob,store,index,shard,snapshot,snapshot,null,if,name,starts,with,snapshot,index,shard,snapshot,format,read,blob,blob,container,name,if,snapshot,null,snapshots,add,new,snapshot,files,snapshot,snapshot,snapshot,index,files,catch,ioexception,e,logger,warn,new,parameterized,message,failed,to,read,commit,point,name,e,return,new,tuple,new,blob,store,index,shard,snapshots,snapshots,1
BlobStoreRepository -> void writeIncompatibleSnapshots(RepositoryData repositoryData) throws IOException;1524684173;Writes the incompatible snapshot ids list to the `incompatible-snapshots` blob in the repository.__Package private for testing.;void writeIncompatibleSnapshots(RepositoryData repositoryData) throws IOException {_        assert isReadOnly() == false_ _        final BytesReference bytes__        try (BytesStreamOutput bStream = new BytesStreamOutput()) {_            try (StreamOutput stream = new OutputStreamStreamOutput(bStream)) {_                XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON, stream)__                repositoryData.incompatibleSnapshotsToXContent(builder, ToXContent.EMPTY_PARAMS)__                builder.close()__            }_            bytes = bStream.bytes()__        }_        if (snapshotsBlobContainer.blobExists(INCOMPATIBLE_SNAPSHOTS_BLOB)) {_            snapshotsBlobContainer.deleteBlob(INCOMPATIBLE_SNAPSHOTS_BLOB)__        }_        _        writeAtomic(INCOMPATIBLE_SNAPSHOTS_BLOB, bytes)__    };writes,the,incompatible,snapshot,ids,list,to,the,incompatible,snapshots,blob,in,the,repository,package,private,for,testing;void,write,incompatible,snapshots,repository,data,repository,data,throws,ioexception,assert,is,read,only,false,final,bytes,reference,bytes,try,bytes,stream,output,b,stream,new,bytes,stream,output,try,stream,output,stream,new,output,stream,stream,output,b,stream,xcontent,builder,builder,xcontent,factory,content,builder,xcontent,type,json,stream,repository,data,incompatible,snapshots,to,xcontent,builder,to,xcontent,builder,close,bytes,b,stream,bytes,if,snapshots,blob,container,blob,exists,snapshots,blob,container,delete,blob,write,atomic,bytes
BlobStoreRepository -> void writeIncompatibleSnapshots(RepositoryData repositoryData) throws IOException;1525334055;Writes the incompatible snapshot ids list to the `incompatible-snapshots` blob in the repository.__Package private for testing.;void writeIncompatibleSnapshots(RepositoryData repositoryData) throws IOException {_        assert isReadOnly() == false_ _        final BytesReference bytes__        try (BytesStreamOutput bStream = new BytesStreamOutput()) {_            try (StreamOutput stream = new OutputStreamStreamOutput(bStream)) {_                XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON, stream)__                repositoryData.incompatibleSnapshotsToXContent(builder, ToXContent.EMPTY_PARAMS)__                builder.close()__            }_            bytes = bStream.bytes()__        }_        if (snapshotsBlobContainer.blobExists(INCOMPATIBLE_SNAPSHOTS_BLOB)) {_            snapshotsBlobContainer.deleteBlob(INCOMPATIBLE_SNAPSHOTS_BLOB)__        }_        _        writeAtomic(INCOMPATIBLE_SNAPSHOTS_BLOB, bytes)__    };writes,the,incompatible,snapshot,ids,list,to,the,incompatible,snapshots,blob,in,the,repository,package,private,for,testing;void,write,incompatible,snapshots,repository,data,repository,data,throws,ioexception,assert,is,read,only,false,final,bytes,reference,bytes,try,bytes,stream,output,b,stream,new,bytes,stream,output,try,stream,output,stream,new,output,stream,stream,output,b,stream,xcontent,builder,builder,xcontent,factory,content,builder,xcontent,type,json,stream,repository,data,incompatible,snapshots,to,xcontent,builder,to,xcontent,builder,close,bytes,b,stream,bytes,if,snapshots,blob,container,blob,exists,snapshots,blob,container,delete,blob,write,atomic,bytes
BlobStoreRepository -> void writeIncompatibleSnapshots(RepositoryData repositoryData) throws IOException;1525798020;Writes the incompatible snapshot ids list to the `incompatible-snapshots` blob in the repository.__Package private for testing.;void writeIncompatibleSnapshots(RepositoryData repositoryData) throws IOException {_        assert isReadOnly() == false_ _        final BytesReference bytes__        try (BytesStreamOutput bStream = new BytesStreamOutput()) {_            try (StreamOutput stream = new OutputStreamStreamOutput(bStream)) {_                XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON, stream)__                repositoryData.incompatibleSnapshotsToXContent(builder, ToXContent.EMPTY_PARAMS)__                builder.close()__            }_            bytes = bStream.bytes()__        }_        if (snapshotsBlobContainer.blobExists(INCOMPATIBLE_SNAPSHOTS_BLOB)) {_            snapshotsBlobContainer.deleteBlob(INCOMPATIBLE_SNAPSHOTS_BLOB)__        }_        _        writeAtomic(INCOMPATIBLE_SNAPSHOTS_BLOB, bytes)__    };writes,the,incompatible,snapshot,ids,list,to,the,incompatible,snapshots,blob,in,the,repository,package,private,for,testing;void,write,incompatible,snapshots,repository,data,repository,data,throws,ioexception,assert,is,read,only,false,final,bytes,reference,bytes,try,bytes,stream,output,b,stream,new,bytes,stream,output,try,stream,output,stream,new,output,stream,stream,output,b,stream,xcontent,builder,builder,xcontent,factory,content,builder,xcontent,type,json,stream,repository,data,incompatible,snapshots,to,xcontent,builder,to,xcontent,builder,close,bytes,b,stream,bytes,if,snapshots,blob,container,blob,exists,snapshots,blob,container,delete,blob,write,atomic,bytes
BlobStoreRepository -> void writeIncompatibleSnapshots(RepositoryData repositoryData) throws IOException;1526289033;Writes the incompatible snapshot ids list to the `incompatible-snapshots` blob in the repository.__Package private for testing.;void writeIncompatibleSnapshots(RepositoryData repositoryData) throws IOException {_        assert isReadOnly() == false_ _        final BytesReference bytes__        try (BytesStreamOutput bStream = new BytesStreamOutput()) {_            try (StreamOutput stream = new OutputStreamStreamOutput(bStream)) {_                XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON, stream)__                repositoryData.incompatibleSnapshotsToXContent(builder, ToXContent.EMPTY_PARAMS)__                builder.close()__            }_            bytes = bStream.bytes()__        }_        if (snapshotsBlobContainer.blobExists(INCOMPATIBLE_SNAPSHOTS_BLOB)) {_            snapshotsBlobContainer.deleteBlob(INCOMPATIBLE_SNAPSHOTS_BLOB)__        }_        _        writeAtomic(INCOMPATIBLE_SNAPSHOTS_BLOB, bytes)__    };writes,the,incompatible,snapshot,ids,list,to,the,incompatible,snapshots,blob,in,the,repository,package,private,for,testing;void,write,incompatible,snapshots,repository,data,repository,data,throws,ioexception,assert,is,read,only,false,final,bytes,reference,bytes,try,bytes,stream,output,b,stream,new,bytes,stream,output,try,stream,output,stream,new,output,stream,stream,output,b,stream,xcontent,builder,builder,xcontent,factory,content,builder,xcontent,type,json,stream,repository,data,incompatible,snapshots,to,xcontent,builder,to,xcontent,builder,close,bytes,b,stream,bytes,if,snapshots,blob,container,blob,exists,snapshots,blob,container,delete,blob,write,atomic,bytes
BlobStoreRepository -> void writeIncompatibleSnapshots(RepositoryData repositoryData) throws IOException;1526574077;Writes the incompatible snapshot ids list to the `incompatible-snapshots` blob in the repository.__Package private for testing.;void writeIncompatibleSnapshots(RepositoryData repositoryData) throws IOException {_        assert isReadOnly() == false_ _        final BytesReference bytes__        try (BytesStreamOutput bStream = new BytesStreamOutput()) {_            try (StreamOutput stream = new OutputStreamStreamOutput(bStream)) {_                XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON, stream)__                repositoryData.incompatibleSnapshotsToXContent(builder, ToXContent.EMPTY_PARAMS)__                builder.close()__            }_            bytes = bStream.bytes()__        }_        if (snapshotsBlobContainer.blobExists(INCOMPATIBLE_SNAPSHOTS_BLOB)) {_            snapshotsBlobContainer.deleteBlob(INCOMPATIBLE_SNAPSHOTS_BLOB)__        }_        _        writeAtomic(INCOMPATIBLE_SNAPSHOTS_BLOB, bytes)__    };writes,the,incompatible,snapshot,ids,list,to,the,incompatible,snapshots,blob,in,the,repository,package,private,for,testing;void,write,incompatible,snapshots,repository,data,repository,data,throws,ioexception,assert,is,read,only,false,final,bytes,reference,bytes,try,bytes,stream,output,b,stream,new,bytes,stream,output,try,stream,output,stream,new,output,stream,stream,output,b,stream,xcontent,builder,builder,xcontent,factory,content,builder,xcontent,type,json,stream,repository,data,incompatible,snapshots,to,xcontent,builder,to,xcontent,builder,close,bytes,b,stream,bytes,if,snapshots,blob,container,blob,exists,snapshots,blob,container,delete,blob,write,atomic,bytes
BlobStoreRepository -> void writeIncompatibleSnapshots(RepositoryData repositoryData) throws IOException;1527583663;Writes the incompatible snapshot ids list to the `incompatible-snapshots` blob in the repository.__Package private for testing.;void writeIncompatibleSnapshots(RepositoryData repositoryData) throws IOException {_        assert isReadOnly() == false_ _        final BytesReference bytes__        try (BytesStreamOutput bStream = new BytesStreamOutput()) {_            try (StreamOutput stream = new OutputStreamStreamOutput(bStream)) {_                XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON, stream)__                repositoryData.incompatibleSnapshotsToXContent(builder, ToXContent.EMPTY_PARAMS)__                builder.close()__            }_            bytes = bStream.bytes()__        }_        if (snapshotsBlobContainer.blobExists(INCOMPATIBLE_SNAPSHOTS_BLOB)) {_            snapshotsBlobContainer.deleteBlob(INCOMPATIBLE_SNAPSHOTS_BLOB)__        }_        _        writeAtomic(INCOMPATIBLE_SNAPSHOTS_BLOB, bytes)__    };writes,the,incompatible,snapshot,ids,list,to,the,incompatible,snapshots,blob,in,the,repository,package,private,for,testing;void,write,incompatible,snapshots,repository,data,repository,data,throws,ioexception,assert,is,read,only,false,final,bytes,reference,bytes,try,bytes,stream,output,b,stream,new,bytes,stream,output,try,stream,output,stream,new,output,stream,stream,output,b,stream,xcontent,builder,builder,xcontent,factory,content,builder,xcontent,type,json,stream,repository,data,incompatible,snapshots,to,xcontent,builder,to,xcontent,builder,close,bytes,b,stream,bytes,if,snapshots,blob,container,blob,exists,snapshots,blob,container,delete,blob,write,atomic,bytes
BlobStoreRepository -> void writeIncompatibleSnapshots(RepositoryData repositoryData) throws IOException;1528211342;Writes the incompatible snapshot ids list to the `incompatible-snapshots` blob in the repository.__Package private for testing.;void writeIncompatibleSnapshots(RepositoryData repositoryData) throws IOException {_        assert isReadOnly() == false_ _        final BytesReference bytes__        try (BytesStreamOutput bStream = new BytesStreamOutput()) {_            try (StreamOutput stream = new OutputStreamStreamOutput(bStream)) {_                XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON, stream)__                repositoryData.incompatibleSnapshotsToXContent(builder, ToXContent.EMPTY_PARAMS)__                builder.close()__            }_            bytes = bStream.bytes()__        }_        if (snapshotsBlobContainer.blobExists(INCOMPATIBLE_SNAPSHOTS_BLOB)) {_            snapshotsBlobContainer.deleteBlob(INCOMPATIBLE_SNAPSHOTS_BLOB)__        }_        _        writeAtomic(INCOMPATIBLE_SNAPSHOTS_BLOB, bytes)__    };writes,the,incompatible,snapshot,ids,list,to,the,incompatible,snapshots,blob,in,the,repository,package,private,for,testing;void,write,incompatible,snapshots,repository,data,repository,data,throws,ioexception,assert,is,read,only,false,final,bytes,reference,bytes,try,bytes,stream,output,b,stream,new,bytes,stream,output,try,stream,output,stream,new,output,stream,stream,output,b,stream,xcontent,builder,builder,xcontent,factory,content,builder,xcontent,type,json,stream,repository,data,incompatible,snapshots,to,xcontent,builder,to,xcontent,builder,close,bytes,b,stream,bytes,if,snapshots,blob,container,blob,exists,snapshots,blob,container,delete,blob,write,atomic,bytes
BlobStoreRepository -> void writeIncompatibleSnapshots(RepositoryData repositoryData) throws IOException;1531179852;Writes the incompatible snapshot ids list to the `incompatible-snapshots` blob in the repository.__Package private for testing.;void writeIncompatibleSnapshots(RepositoryData repositoryData) throws IOException {_        assert isReadOnly() == false_ _        final BytesReference bytes__        try (BytesStreamOutput bStream = new BytesStreamOutput()) {_            try (StreamOutput stream = new OutputStreamStreamOutput(bStream)) {_                XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON, stream)__                repositoryData.incompatibleSnapshotsToXContent(builder, ToXContent.EMPTY_PARAMS)__                builder.close()__            }_            bytes = bStream.bytes()__        }_        _        writeAtomic(INCOMPATIBLE_SNAPSHOTS_BLOB, bytes, false)__    };writes,the,incompatible,snapshot,ids,list,to,the,incompatible,snapshots,blob,in,the,repository,package,private,for,testing;void,write,incompatible,snapshots,repository,data,repository,data,throws,ioexception,assert,is,read,only,false,final,bytes,reference,bytes,try,bytes,stream,output,b,stream,new,bytes,stream,output,try,stream,output,stream,new,output,stream,stream,output,b,stream,xcontent,builder,builder,xcontent,factory,content,builder,xcontent,type,json,stream,repository,data,incompatible,snapshots,to,xcontent,builder,to,xcontent,builder,close,bytes,b,stream,bytes,write,atomic,bytes,false
BlobStoreRepository -> void writeIncompatibleSnapshots(RepositoryData repositoryData) throws IOException;1531729807;Writes the incompatible snapshot ids list to the `incompatible-snapshots` blob in the repository.__Package private for testing.;void writeIncompatibleSnapshots(RepositoryData repositoryData) throws IOException {_        assert isReadOnly() == false_ _        final BytesReference bytes__        try (BytesStreamOutput bStream = new BytesStreamOutput()) {_            try (StreamOutput stream = new OutputStreamStreamOutput(bStream)) {_                XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON, stream)__                repositoryData.incompatibleSnapshotsToXContent(builder, ToXContent.EMPTY_PARAMS)__                builder.close()__            }_            bytes = bStream.bytes()__        }_        _        writeAtomic(INCOMPATIBLE_SNAPSHOTS_BLOB, bytes, false)__    };writes,the,incompatible,snapshot,ids,list,to,the,incompatible,snapshots,blob,in,the,repository,package,private,for,testing;void,write,incompatible,snapshots,repository,data,repository,data,throws,ioexception,assert,is,read,only,false,final,bytes,reference,bytes,try,bytes,stream,output,b,stream,new,bytes,stream,output,try,stream,output,stream,new,output,stream,stream,output,b,stream,xcontent,builder,builder,xcontent,factory,content,builder,xcontent,type,json,stream,repository,data,incompatible,snapshots,to,xcontent,builder,to,xcontent,builder,close,bytes,b,stream,bytes,write,atomic,bytes,false
BlobStoreRepository -> void writeIncompatibleSnapshots(RepositoryData repositoryData) throws IOException;1532685069;Writes the incompatible snapshot ids list to the `incompatible-snapshots` blob in the repository.__Package private for testing.;void writeIncompatibleSnapshots(RepositoryData repositoryData) throws IOException {_        assert isReadOnly() == false_ _        final BytesReference bytes__        try (BytesStreamOutput bStream = new BytesStreamOutput()) {_            try (StreamOutput stream = new OutputStreamStreamOutput(bStream)) {_                XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON, stream)__                repositoryData.incompatibleSnapshotsToXContent(builder, ToXContent.EMPTY_PARAMS)__                builder.close()__            }_            bytes = bStream.bytes()__        }_        _        writeAtomic(INCOMPATIBLE_SNAPSHOTS_BLOB, bytes, false)__    };writes,the,incompatible,snapshot,ids,list,to,the,incompatible,snapshots,blob,in,the,repository,package,private,for,testing;void,write,incompatible,snapshots,repository,data,repository,data,throws,ioexception,assert,is,read,only,false,final,bytes,reference,bytes,try,bytes,stream,output,b,stream,new,bytes,stream,output,try,stream,output,stream,new,output,stream,stream,output,b,stream,xcontent,builder,builder,xcontent,factory,content,builder,xcontent,type,json,stream,repository,data,incompatible,snapshots,to,xcontent,builder,to,xcontent,builder,close,bytes,b,stream,bytes,write,atomic,bytes,false
BlobStoreRepository -> void writeIncompatibleSnapshots(RepositoryData repositoryData) throws IOException;1535139672;Writes the incompatible snapshot ids list to the `incompatible-snapshots` blob in the repository.__Package private for testing.;void writeIncompatibleSnapshots(RepositoryData repositoryData) throws IOException {_        assert isReadOnly() == false_ _        final BytesReference bytes__        try (BytesStreamOutput bStream = new BytesStreamOutput()) {_            try (StreamOutput stream = new OutputStreamStreamOutput(bStream)) {_                XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON, stream)__                repositoryData.incompatibleSnapshotsToXContent(builder, ToXContent.EMPTY_PARAMS)__                builder.close()__            }_            bytes = bStream.bytes()__        }_        _        writeAtomic(INCOMPATIBLE_SNAPSHOTS_BLOB, bytes, false)__    };writes,the,incompatible,snapshot,ids,list,to,the,incompatible,snapshots,blob,in,the,repository,package,private,for,testing;void,write,incompatible,snapshots,repository,data,repository,data,throws,ioexception,assert,is,read,only,false,final,bytes,reference,bytes,try,bytes,stream,output,b,stream,new,bytes,stream,output,try,stream,output,stream,new,output,stream,stream,output,b,stream,xcontent,builder,builder,xcontent,factory,content,builder,xcontent,type,json,stream,repository,data,incompatible,snapshots,to,xcontent,builder,to,xcontent,builder,close,bytes,b,stream,bytes,write,atomic,bytes,false
BlobStoreRepository -> void writeIncompatibleSnapshots(RepositoryData repositoryData) throws IOException;1535723122;Writes the incompatible snapshot ids list to the `incompatible-snapshots` blob in the repository.__Package private for testing.;void writeIncompatibleSnapshots(RepositoryData repositoryData) throws IOException {_        assert isReadOnly() == false_ _        final BytesReference bytes__        try (BytesStreamOutput bStream = new BytesStreamOutput()) {_            try (StreamOutput stream = new OutputStreamStreamOutput(bStream)) {_                XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON, stream)__                repositoryData.incompatibleSnapshotsToXContent(builder, ToXContent.EMPTY_PARAMS)__                builder.close()__            }_            bytes = bStream.bytes()__        }_        _        writeAtomic(INCOMPATIBLE_SNAPSHOTS_BLOB, bytes, false)__    };writes,the,incompatible,snapshot,ids,list,to,the,incompatible,snapshots,blob,in,the,repository,package,private,for,testing;void,write,incompatible,snapshots,repository,data,repository,data,throws,ioexception,assert,is,read,only,false,final,bytes,reference,bytes,try,bytes,stream,output,b,stream,new,bytes,stream,output,try,stream,output,stream,new,output,stream,stream,output,b,stream,xcontent,builder,builder,xcontent,factory,content,builder,xcontent,type,json,stream,repository,data,incompatible,snapshots,to,xcontent,builder,to,xcontent,builder,close,bytes,b,stream,bytes,write,atomic,bytes,false
BlobStoreRepository -> void writeIncompatibleSnapshots(RepositoryData repositoryData) throws IOException;1536314350;Writes the incompatible snapshot ids list to the `incompatible-snapshots` blob in the repository.__Package private for testing.;void writeIncompatibleSnapshots(RepositoryData repositoryData) throws IOException {_        assert isReadOnly() == false_ _        final BytesReference bytes__        try (BytesStreamOutput bStream = new BytesStreamOutput()) {_            try (StreamOutput stream = new OutputStreamStreamOutput(bStream)) {_                XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON, stream)__                repositoryData.incompatibleSnapshotsToXContent(builder, ToXContent.EMPTY_PARAMS)__                builder.close()__            }_            bytes = bStream.bytes()__        }_        _        writeAtomic(INCOMPATIBLE_SNAPSHOTS_BLOB, bytes, false)__    };writes,the,incompatible,snapshot,ids,list,to,the,incompatible,snapshots,blob,in,the,repository,package,private,for,testing;void,write,incompatible,snapshots,repository,data,repository,data,throws,ioexception,assert,is,read,only,false,final,bytes,reference,bytes,try,bytes,stream,output,b,stream,new,bytes,stream,output,try,stream,output,stream,new,output,stream,stream,output,b,stream,xcontent,builder,builder,xcontent,factory,content,builder,xcontent,type,json,stream,repository,data,incompatible,snapshots,to,xcontent,builder,to,xcontent,builder,close,bytes,b,stream,bytes,write,atomic,bytes,false
BlobStoreRepository -> void writeIncompatibleSnapshots(RepositoryData repositoryData) throws IOException;1536828374;Writes the incompatible snapshot ids list to the `incompatible-snapshots` blob in the repository.__Package private for testing.;void writeIncompatibleSnapshots(RepositoryData repositoryData) throws IOException {_        assert isReadOnly() == false_ _        final BytesReference bytes__        try (BytesStreamOutput bStream = new BytesStreamOutput()) {_            try (StreamOutput stream = new OutputStreamStreamOutput(bStream)) {_                XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON, stream)__                repositoryData.incompatibleSnapshotsToXContent(builder, ToXContent.EMPTY_PARAMS)__                builder.close()__            }_            bytes = bStream.bytes()__        }_        _        writeAtomic(INCOMPATIBLE_SNAPSHOTS_BLOB, bytes, false)__    };writes,the,incompatible,snapshot,ids,list,to,the,incompatible,snapshots,blob,in,the,repository,package,private,for,testing;void,write,incompatible,snapshots,repository,data,repository,data,throws,ioexception,assert,is,read,only,false,final,bytes,reference,bytes,try,bytes,stream,output,b,stream,new,bytes,stream,output,try,stream,output,stream,new,output,stream,stream,output,b,stream,xcontent,builder,builder,xcontent,factory,content,builder,xcontent,type,json,stream,repository,data,incompatible,snapshots,to,xcontent,builder,to,xcontent,builder,close,bytes,b,stream,bytes,write,atomic,bytes,false
BlobStoreRepository -> void writeIncompatibleSnapshots(RepositoryData repositoryData) throws IOException;1541008027;Writes the incompatible snapshot ids list to the `incompatible-snapshots` blob in the repository.__Package private for testing.;void writeIncompatibleSnapshots(RepositoryData repositoryData) throws IOException {_        assert isReadOnly() == false_ _        final BytesReference bytes__        try (BytesStreamOutput bStream = new BytesStreamOutput()) {_            try (StreamOutput stream = new OutputStreamStreamOutput(bStream)) {_                XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON, stream)__                repositoryData.incompatibleSnapshotsToXContent(builder, ToXContent.EMPTY_PARAMS)__                builder.close()__            }_            bytes = bStream.bytes()__        }_        _        writeAtomic(INCOMPATIBLE_SNAPSHOTS_BLOB, bytes, false)__    };writes,the,incompatible,snapshot,ids,list,to,the,incompatible,snapshots,blob,in,the,repository,package,private,for,testing;void,write,incompatible,snapshots,repository,data,repository,data,throws,ioexception,assert,is,read,only,false,final,bytes,reference,bytes,try,bytes,stream,output,b,stream,new,bytes,stream,output,try,stream,output,stream,new,output,stream,stream,output,b,stream,xcontent,builder,builder,xcontent,factory,content,builder,xcontent,type,json,stream,repository,data,incompatible,snapshots,to,xcontent,builder,to,xcontent,builder,close,bytes,b,stream,bytes,write,atomic,bytes,false
BlobStoreRepository -> void writeIncompatibleSnapshots(RepositoryData repositoryData) throws IOException;1542646292;Writes the incompatible snapshot ids list to the `incompatible-snapshots` blob in the repository.__Package private for testing.;void writeIncompatibleSnapshots(RepositoryData repositoryData) throws IOException {_        assert isReadOnly() == false_ _        final BytesReference bytes__        try (BytesStreamOutput bStream = new BytesStreamOutput()) {_            try (StreamOutput stream = new OutputStreamStreamOutput(bStream)) {_                XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON, stream)__                repositoryData.incompatibleSnapshotsToXContent(builder, ToXContent.EMPTY_PARAMS)__                builder.close()__            }_            bytes = bStream.bytes()__        }_        _        writeAtomic(INCOMPATIBLE_SNAPSHOTS_BLOB, bytes, false)__    };writes,the,incompatible,snapshot,ids,list,to,the,incompatible,snapshots,blob,in,the,repository,package,private,for,testing;void,write,incompatible,snapshots,repository,data,repository,data,throws,ioexception,assert,is,read,only,false,final,bytes,reference,bytes,try,bytes,stream,output,b,stream,new,bytes,stream,output,try,stream,output,stream,new,output,stream,stream,output,b,stream,xcontent,builder,builder,xcontent,factory,content,builder,xcontent,type,json,stream,repository,data,incompatible,snapshots,to,xcontent,builder,to,xcontent,builder,close,bytes,b,stream,bytes,write,atomic,bytes,false
BlobStoreRepository -> void writeIncompatibleSnapshots(RepositoryData repositoryData) throws IOException;1542980705;Writes the incompatible snapshot ids list to the `incompatible-snapshots` blob in the repository.__Package private for testing.;void writeIncompatibleSnapshots(RepositoryData repositoryData) throws IOException {_        assert isReadOnly() == false_ _        final BytesReference bytes__        try (BytesStreamOutput bStream = new BytesStreamOutput()) {_            try (StreamOutput stream = new OutputStreamStreamOutput(bStream)) {_                XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON, stream)__                repositoryData.incompatibleSnapshotsToXContent(builder, ToXContent.EMPTY_PARAMS)__                builder.close()__            }_            bytes = bStream.bytes()__        }_        _        writeAtomic(INCOMPATIBLE_SNAPSHOTS_BLOB, bytes, false)__    };writes,the,incompatible,snapshot,ids,list,to,the,incompatible,snapshots,blob,in,the,repository,package,private,for,testing;void,write,incompatible,snapshots,repository,data,repository,data,throws,ioexception,assert,is,read,only,false,final,bytes,reference,bytes,try,bytes,stream,output,b,stream,new,bytes,stream,output,try,stream,output,stream,new,output,stream,stream,output,b,stream,xcontent,builder,builder,xcontent,factory,content,builder,xcontent,type,json,stream,repository,data,incompatible,snapshots,to,xcontent,builder,to,xcontent,builder,close,bytes,b,stream,bytes,write,atomic,bytes,false
BlobStoreRepository -> void writeIncompatibleSnapshots(RepositoryData repositoryData) throws IOException;1543831870;Writes the incompatible snapshot ids list to the `incompatible-snapshots` blob in the repository.__Package private for testing.;void writeIncompatibleSnapshots(RepositoryData repositoryData) throws IOException {_        assert isReadOnly() == false_ _        final BytesReference bytes__        try (BytesStreamOutput bStream = new BytesStreamOutput()) {_            try (StreamOutput stream = new OutputStreamStreamOutput(bStream)) {_                XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON, stream)__                repositoryData.incompatibleSnapshotsToXContent(builder, ToXContent.EMPTY_PARAMS)__                builder.close()__            }_            bytes = bStream.bytes()__        }_        _        writeAtomic(INCOMPATIBLE_SNAPSHOTS_BLOB, bytes, false)__    };writes,the,incompatible,snapshot,ids,list,to,the,incompatible,snapshots,blob,in,the,repository,package,private,for,testing;void,write,incompatible,snapshots,repository,data,repository,data,throws,ioexception,assert,is,read,only,false,final,bytes,reference,bytes,try,bytes,stream,output,b,stream,new,bytes,stream,output,try,stream,output,stream,new,output,stream,stream,output,b,stream,xcontent,builder,builder,xcontent,factory,content,builder,xcontent,type,json,stream,repository,data,incompatible,snapshots,to,xcontent,builder,to,xcontent,builder,close,bytes,b,stream,bytes,write,atomic,bytes,false
BlobStoreRepository -> void writeIncompatibleSnapshots(RepositoryData repositoryData) throws IOException;1543942400;Writes the incompatible snapshot ids list to the `incompatible-snapshots` blob in the repository.__Package private for testing.;void writeIncompatibleSnapshots(RepositoryData repositoryData) throws IOException {_        assert isReadOnly() == false_ _        final BytesReference bytes__        try (BytesStreamOutput bStream = new BytesStreamOutput()) {_            try (StreamOutput stream = new OutputStreamStreamOutput(bStream)) {_                XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON, stream)__                repositoryData.incompatibleSnapshotsToXContent(builder, ToXContent.EMPTY_PARAMS)__                builder.close()__            }_            bytes = bStream.bytes()__        }_        _        writeAtomic(INCOMPATIBLE_SNAPSHOTS_BLOB, bytes, false)__    };writes,the,incompatible,snapshot,ids,list,to,the,incompatible,snapshots,blob,in,the,repository,package,private,for,testing;void,write,incompatible,snapshots,repository,data,repository,data,throws,ioexception,assert,is,read,only,false,final,bytes,reference,bytes,try,bytes,stream,output,b,stream,new,bytes,stream,output,try,stream,output,stream,new,output,stream,stream,output,b,stream,xcontent,builder,builder,xcontent,factory,content,builder,xcontent,type,json,stream,repository,data,incompatible,snapshots,to,xcontent,builder,to,xcontent,builder,close,bytes,b,stream,bytes,write,atomic,bytes,false
BlobStoreRepository -> void writeIncompatibleSnapshots(RepositoryData repositoryData) throws IOException;1546974294;Writes the incompatible snapshot ids list to the `incompatible-snapshots` blob in the repository.__Package private for testing.;void writeIncompatibleSnapshots(RepositoryData repositoryData) throws IOException {_        assert isReadOnly() == false_ _        final BytesReference bytes__        try (BytesStreamOutput bStream = new BytesStreamOutput()) {_            try (StreamOutput stream = new OutputStreamStreamOutput(bStream)) {_                XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON, stream)__                repositoryData.incompatibleSnapshotsToXContent(builder, ToXContent.EMPTY_PARAMS)__                builder.close()__            }_            bytes = bStream.bytes()__        }_        _        writeAtomic(INCOMPATIBLE_SNAPSHOTS_BLOB, bytes, false)__    };writes,the,incompatible,snapshot,ids,list,to,the,incompatible,snapshots,blob,in,the,repository,package,private,for,testing;void,write,incompatible,snapshots,repository,data,repository,data,throws,ioexception,assert,is,read,only,false,final,bytes,reference,bytes,try,bytes,stream,output,b,stream,new,bytes,stream,output,try,stream,output,stream,new,output,stream,stream,output,b,stream,xcontent,builder,builder,xcontent,factory,content,builder,xcontent,type,json,stream,repository,data,incompatible,snapshots,to,xcontent,builder,to,xcontent,builder,close,bytes,b,stream,bytes,write,atomic,bytes,false
BlobStoreRepository -> void writeIncompatibleSnapshots(RepositoryData repositoryData) throws IOException;1547496475;Writes the incompatible snapshot ids list to the `incompatible-snapshots` blob in the repository.__Package private for testing.;void writeIncompatibleSnapshots(RepositoryData repositoryData) throws IOException {_        assert isReadOnly() == false_ _        final BytesReference bytes__        try (BytesStreamOutput bStream = new BytesStreamOutput()) {_            try (StreamOutput stream = new OutputStreamStreamOutput(bStream)) {_                XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON, stream)__                repositoryData.incompatibleSnapshotsToXContent(builder, ToXContent.EMPTY_PARAMS)__                builder.close()__            }_            bytes = bStream.bytes()__        }_        _        writeAtomic(INCOMPATIBLE_SNAPSHOTS_BLOB, bytes, false)__    };writes,the,incompatible,snapshot,ids,list,to,the,incompatible,snapshots,blob,in,the,repository,package,private,for,testing;void,write,incompatible,snapshots,repository,data,repository,data,throws,ioexception,assert,is,read,only,false,final,bytes,reference,bytes,try,bytes,stream,output,b,stream,new,bytes,stream,output,try,stream,output,stream,new,output,stream,stream,output,b,stream,xcontent,builder,builder,xcontent,factory,content,builder,xcontent,type,json,stream,repository,data,incompatible,snapshots,to,xcontent,builder,to,xcontent,builder,close,bytes,b,stream,bytes,write,atomic,bytes,false
BlobStoreRepository -> void writeIncompatibleSnapshots(RepositoryData repositoryData) throws IOException;1547625930;Writes the incompatible snapshot ids list to the `incompatible-snapshots` blob in the repository.__Package private for testing.;void writeIncompatibleSnapshots(RepositoryData repositoryData) throws IOException {_        assert isReadOnly() == false_ _        final BytesReference bytes__        try (BytesStreamOutput bStream = new BytesStreamOutput()) {_            try (StreamOutput stream = new OutputStreamStreamOutput(bStream)) {_                XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON, stream)__                repositoryData.incompatibleSnapshotsToXContent(builder, ToXContent.EMPTY_PARAMS)__                builder.close()__            }_            bytes = bStream.bytes()__        }_        _        writeAtomic(INCOMPATIBLE_SNAPSHOTS_BLOB, bytes, false)__    };writes,the,incompatible,snapshot,ids,list,to,the,incompatible,snapshots,blob,in,the,repository,package,private,for,testing;void,write,incompatible,snapshots,repository,data,repository,data,throws,ioexception,assert,is,read,only,false,final,bytes,reference,bytes,try,bytes,stream,output,b,stream,new,bytes,stream,output,try,stream,output,stream,new,output,stream,stream,output,b,stream,xcontent,builder,builder,xcontent,factory,content,builder,xcontent,type,json,stream,repository,data,incompatible,snapshots,to,xcontent,builder,to,xcontent,builder,close,bytes,b,stream,bytes,write,atomic,bytes,false
BlobStoreRepository -> void writeIncompatibleSnapshots(RepositoryData repositoryData) throws IOException;1550647627;Writes the incompatible snapshot ids list to the `incompatible-snapshots` blob in the repository.__Package private for testing.;void writeIncompatibleSnapshots(RepositoryData repositoryData) throws IOException {_        assert isReadOnly() == false_ _        final BytesReference bytes__        try (BytesStreamOutput bStream = new BytesStreamOutput()) {_            try (StreamOutput stream = new OutputStreamStreamOutput(bStream)) {_                XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON, stream)__                repositoryData.incompatibleSnapshotsToXContent(builder, ToXContent.EMPTY_PARAMS)__                builder.close()__            }_            bytes = bStream.bytes()__        }_        _        writeAtomic(INCOMPATIBLE_SNAPSHOTS_BLOB, bytes, false)__    };writes,the,incompatible,snapshot,ids,list,to,the,incompatible,snapshots,blob,in,the,repository,package,private,for,testing;void,write,incompatible,snapshots,repository,data,repository,data,throws,ioexception,assert,is,read,only,false,final,bytes,reference,bytes,try,bytes,stream,output,b,stream,new,bytes,stream,output,try,stream,output,stream,new,output,stream,stream,output,b,stream,xcontent,builder,builder,xcontent,factory,content,builder,xcontent,type,json,stream,repository,data,incompatible,snapshots,to,xcontent,builder,to,xcontent,builder,close,bytes,b,stream,bytes,write,atomic,bytes,false
BlobStoreRepository -> RestoreContext -> RestoreContext(IndexShard indexShard, SnapshotId snapshotId, RecoveryState recoveryState, BlobContainer blobContainer);1547496475;Constructs new restore context_@param indexShard    shard to restore into_@param snapshotId    snapshot id_@param recoveryState recovery state to report progress_@param blobContainer the blob container to read the files from;RestoreContext(IndexShard indexShard, SnapshotId snapshotId, RecoveryState recoveryState, BlobContainer blobContainer) {_            super(metadata.name(), indexShard, snapshotId, recoveryState, BUFFER_SIZE)__            this.blobContainer = blobContainer__        };constructs,new,restore,context,param,index,shard,shard,to,restore,into,param,snapshot,id,snapshot,id,param,recovery,state,recovery,state,to,report,progress,param,blob,container,the,blob,container,to,read,the,files,from;restore,context,index,shard,index,shard,snapshot,id,snapshot,id,recovery,state,recovery,state,blob,container,blob,container,super,metadata,name,index,shard,snapshot,id,recovery,state,this,blob,container,blob,container
BlobStoreRepository -> RestoreContext -> RestoreContext(IndexShard indexShard, SnapshotId snapshotId, RecoveryState recoveryState, BlobContainer blobContainer);1547625930;Constructs new restore context_@param indexShard    shard to restore into_@param snapshotId    snapshot id_@param recoveryState recovery state to report progress_@param blobContainer the blob container to read the files from;RestoreContext(IndexShard indexShard, SnapshotId snapshotId, RecoveryState recoveryState, BlobContainer blobContainer) {_            super(metadata.name(), indexShard, snapshotId, recoveryState, BUFFER_SIZE)__            this.blobContainer = blobContainer__        };constructs,new,restore,context,param,index,shard,shard,to,restore,into,param,snapshot,id,snapshot,id,param,recovery,state,recovery,state,to,report,progress,param,blob,container,the,blob,container,to,read,the,files,from;restore,context,index,shard,index,shard,snapshot,id,snapshot,id,recovery,state,recovery,state,blob,container,blob,container,super,metadata,name,index,shard,snapshot,id,recovery,state,this,blob,container,blob,container
BlobStoreRepository -> RestoreContext -> RestoreContext(IndexShard indexShard, SnapshotId snapshotId, RecoveryState recoveryState, BlobContainer blobContainer);1550647627;Constructs new restore context_@param indexShard    shard to restore into_@param snapshotId    snapshot id_@param recoveryState recovery state to report progress_@param blobContainer the blob container to read the files from;RestoreContext(IndexShard indexShard, SnapshotId snapshotId, RecoveryState recoveryState, BlobContainer blobContainer) {_            super(metadata.name(), indexShard, snapshotId, recoveryState, BUFFER_SIZE)__            this.blobContainer = blobContainer__        };constructs,new,restore,context,param,index,shard,shard,to,restore,into,param,snapshot,id,snapshot,id,param,recovery,state,recovery,state,to,report,progress,param,blob,container,the,blob,container,to,read,the,files,from;restore,context,index,shard,index,shard,snapshot,id,snapshot,id,recovery,state,recovery,state,blob,container,blob,container,super,metadata,name,index,shard,snapshot,id,recovery,state,this,blob,container,blob,container
BlobStoreRepository -> Context -> protected String fileNameFromGeneration(long generation);1524684173;Generates blob name__@param generation the blob number_@return the blob name;protected String fileNameFromGeneration(long generation) {_            return DATA_BLOB_PREFIX + Long.toString(generation, Character.MAX_RADIX)__        };generates,blob,name,param,generation,the,blob,number,return,the,blob,name;protected,string,file,name,from,generation,long,generation,return,long,to,string,generation,character
BlobStoreRepository -> Context -> protected String fileNameFromGeneration(long generation);1525334055;Generates blob name__@param generation the blob number_@return the blob name;protected String fileNameFromGeneration(long generation) {_            return DATA_BLOB_PREFIX + Long.toString(generation, Character.MAX_RADIX)__        };generates,blob,name,param,generation,the,blob,number,return,the,blob,name;protected,string,file,name,from,generation,long,generation,return,long,to,string,generation,character
BlobStoreRepository -> Context -> protected String fileNameFromGeneration(long generation);1525798020;Generates blob name__@param generation the blob number_@return the blob name;protected String fileNameFromGeneration(long generation) {_            return DATA_BLOB_PREFIX + Long.toString(generation, Character.MAX_RADIX)__        };generates,blob,name,param,generation,the,blob,number,return,the,blob,name;protected,string,file,name,from,generation,long,generation,return,long,to,string,generation,character
BlobStoreRepository -> Context -> protected String fileNameFromGeneration(long generation);1526289033;Generates blob name__@param generation the blob number_@return the blob name;protected String fileNameFromGeneration(long generation) {_            return DATA_BLOB_PREFIX + Long.toString(generation, Character.MAX_RADIX)__        };generates,blob,name,param,generation,the,blob,number,return,the,blob,name;protected,string,file,name,from,generation,long,generation,return,long,to,string,generation,character
BlobStoreRepository -> Context -> protected String fileNameFromGeneration(long generation);1526574077;Generates blob name__@param generation the blob number_@return the blob name;protected String fileNameFromGeneration(long generation) {_            return DATA_BLOB_PREFIX + Long.toString(generation, Character.MAX_RADIX)__        };generates,blob,name,param,generation,the,blob,number,return,the,blob,name;protected,string,file,name,from,generation,long,generation,return,long,to,string,generation,character
BlobStoreRepository -> Context -> protected String fileNameFromGeneration(long generation);1527583663;Generates blob name__@param generation the blob number_@return the blob name;protected String fileNameFromGeneration(long generation) {_            return DATA_BLOB_PREFIX + Long.toString(generation, Character.MAX_RADIX)__        };generates,blob,name,param,generation,the,blob,number,return,the,blob,name;protected,string,file,name,from,generation,long,generation,return,long,to,string,generation,character
BlobStoreRepository -> Context -> protected String fileNameFromGeneration(long generation);1528211342;Generates blob name__@param generation the blob number_@return the blob name;protected String fileNameFromGeneration(long generation) {_            return DATA_BLOB_PREFIX + Long.toString(generation, Character.MAX_RADIX)__        };generates,blob,name,param,generation,the,blob,number,return,the,blob,name;protected,string,file,name,from,generation,long,generation,return,long,to,string,generation,character
BlobStoreRepository -> Context -> protected String fileNameFromGeneration(long generation);1531179852;Generates blob name__@param generation the blob number_@return the blob name;protected String fileNameFromGeneration(long generation) {_            return DATA_BLOB_PREFIX + Long.toString(generation, Character.MAX_RADIX)__        };generates,blob,name,param,generation,the,blob,number,return,the,blob,name;protected,string,file,name,from,generation,long,generation,return,long,to,string,generation,character
BlobStoreRepository -> Context -> protected String fileNameFromGeneration(long generation);1531729807;Generates blob name__@param generation the blob number_@return the blob name;protected String fileNameFromGeneration(long generation) {_            return DATA_BLOB_PREFIX + Long.toString(generation, Character.MAX_RADIX)__        };generates,blob,name,param,generation,the,blob,number,return,the,blob,name;protected,string,file,name,from,generation,long,generation,return,long,to,string,generation,character
BlobStoreRepository -> Context -> protected String fileNameFromGeneration(long generation);1532685069;Generates blob name__@param generation the blob number_@return the blob name;protected String fileNameFromGeneration(long generation) {_            return DATA_BLOB_PREFIX + Long.toString(generation, Character.MAX_RADIX)__        };generates,blob,name,param,generation,the,blob,number,return,the,blob,name;protected,string,file,name,from,generation,long,generation,return,long,to,string,generation,character
BlobStoreRepository -> Context -> protected String fileNameFromGeneration(long generation);1535139672;Generates blob name__@param generation the blob number_@return the blob name;protected String fileNameFromGeneration(long generation) {_            return DATA_BLOB_PREFIX + Long.toString(generation, Character.MAX_RADIX)__        };generates,blob,name,param,generation,the,blob,number,return,the,blob,name;protected,string,file,name,from,generation,long,generation,return,long,to,string,generation,character
BlobStoreRepository -> Context -> protected String fileNameFromGeneration(long generation);1535723122;Generates blob name__@param generation the blob number_@return the blob name;protected String fileNameFromGeneration(long generation) {_            return DATA_BLOB_PREFIX + Long.toString(generation, Character.MAX_RADIX)__        };generates,blob,name,param,generation,the,blob,number,return,the,blob,name;protected,string,file,name,from,generation,long,generation,return,long,to,string,generation,character
BlobStoreRepository -> Context -> protected String fileNameFromGeneration(long generation);1536314350;Generates blob name__@param generation the blob number_@return the blob name;protected String fileNameFromGeneration(long generation) {_            return DATA_BLOB_PREFIX + Long.toString(generation, Character.MAX_RADIX)__        };generates,blob,name,param,generation,the,blob,number,return,the,blob,name;protected,string,file,name,from,generation,long,generation,return,long,to,string,generation,character
BlobStoreRepository -> Context -> protected String fileNameFromGeneration(long generation);1536828374;Generates blob name__@param generation the blob number_@return the blob name;protected String fileNameFromGeneration(long generation) {_            return DATA_BLOB_PREFIX + Long.toString(generation, Character.MAX_RADIX)__        };generates,blob,name,param,generation,the,blob,number,return,the,blob,name;protected,string,file,name,from,generation,long,generation,return,long,to,string,generation,character
BlobStoreRepository -> Context -> protected String fileNameFromGeneration(long generation);1541008027;Generates blob name__@param generation the blob number_@return the blob name;protected String fileNameFromGeneration(long generation) {_            return DATA_BLOB_PREFIX + Long.toString(generation, Character.MAX_RADIX)__        };generates,blob,name,param,generation,the,blob,number,return,the,blob,name;protected,string,file,name,from,generation,long,generation,return,long,to,string,generation,character
BlobStoreRepository -> Context -> protected String fileNameFromGeneration(long generation);1542646292;Generates blob name__@param generation the blob number_@return the blob name;protected String fileNameFromGeneration(long generation) {_            return DATA_BLOB_PREFIX + Long.toString(generation, Character.MAX_RADIX)__        };generates,blob,name,param,generation,the,blob,number,return,the,blob,name;protected,string,file,name,from,generation,long,generation,return,long,to,string,generation,character
BlobStoreRepository -> Context -> protected String fileNameFromGeneration(long generation);1542980705;Generates blob name__@param generation the blob number_@return the blob name;protected String fileNameFromGeneration(long generation) {_            return DATA_BLOB_PREFIX + Long.toString(generation, Character.MAX_RADIX)__        };generates,blob,name,param,generation,the,blob,number,return,the,blob,name;protected,string,file,name,from,generation,long,generation,return,long,to,string,generation,character
BlobStoreRepository -> Context -> protected String fileNameFromGeneration(long generation);1543831870;Generates blob name__@param generation the blob number_@return the blob name;protected String fileNameFromGeneration(long generation) {_            return DATA_BLOB_PREFIX + Long.toString(generation, Character.MAX_RADIX)__        };generates,blob,name,param,generation,the,blob,number,return,the,blob,name;protected,string,file,name,from,generation,long,generation,return,long,to,string,generation,character
BlobStoreRepository -> Context -> protected String fileNameFromGeneration(long generation);1543942400;Generates blob name__@param generation the blob number_@return the blob name;protected String fileNameFromGeneration(long generation) {_            return DATA_BLOB_PREFIX + Long.toString(generation, Character.MAX_RADIX)__        };generates,blob,name,param,generation,the,blob,number,return,the,blob,name;protected,string,file,name,from,generation,long,generation,return,long,to,string,generation,character
BlobStoreRepository -> Context -> protected String fileNameFromGeneration(long generation);1546974294;Generates blob name__@param generation the blob number_@return the blob name;protected String fileNameFromGeneration(long generation) {_            return DATA_BLOB_PREFIX + Long.toString(generation, Character.MAX_RADIX)__        };generates,blob,name,param,generation,the,blob,number,return,the,blob,name;protected,string,file,name,from,generation,long,generation,return,long,to,string,generation,character
BlobStoreRepository -> Context -> protected String fileNameFromGeneration(long generation);1547496475;Generates blob name__@param generation the blob number_@return the blob name;protected String fileNameFromGeneration(long generation) {_            return DATA_BLOB_PREFIX + Long.toString(generation, Character.MAX_RADIX)__        };generates,blob,name,param,generation,the,blob,number,return,the,blob,name;protected,string,file,name,from,generation,long,generation,return,long,to,string,generation,character
BlobStoreRepository -> Context -> protected String fileNameFromGeneration(long generation);1547625930;Generates blob name__@param generation the blob number_@return the blob name;protected String fileNameFromGeneration(long generation) {_            return DATA_BLOB_PREFIX + Long.toString(generation, Character.MAX_RADIX)__        };generates,blob,name,param,generation,the,blob,number,return,the,blob,name;protected,string,file,name,from,generation,long,generation,return,long,to,string,generation,character
BlobStoreRepository -> Context -> protected String fileNameFromGeneration(long generation);1550647627;Generates blob name__@param generation the blob number_@return the blob name;protected String fileNameFromGeneration(long generation) {_            return DATA_BLOB_PREFIX + Long.toString(generation, Character.MAX_RADIX)__        };generates,blob,name,param,generation,the,blob,number,return,the,blob,name;protected,string,file,name,from,generation,long,generation,return,long,to,string,generation,character
