commented;modifiers;parameterAmount;loc;comment;code
false;;1;1;;String decode(String value).
false;public;1;4;;public void updateKeyWithNamedWildcard(String key) {     this.key = key.     namedWildcard = key.substring(key.indexOf('{') + 1, key.indexOf('}')). }
false;private;2;5;;private void addInnerChild(String key, TrieNode child) {     Map<String, TrieNode> newChildren = new HashMap<>(children).     newChildren.put(key, child).     children = unmodifiableMap(newChildren). }
false;public,synchronized;3;34;;public synchronized void insert(String[] path, int index, T value) {     if (index >= path.length)         return.     String token = path[index].     String key = token.     if (isNamedWildcard(token)) {         key = wildcard.     }     TrieNode node = children.get(key).     if (node == null) {         T nodeValue = index == path.length - 1 ? value : null.         node = new TrieNode(token, nodeValue, wildcard).         addInnerChild(key, node).     } else {         if (isNamedWildcard(token)) {             node.updateKeyWithNamedWildcard(token).         }         /*                  * If the target node already exists, but is without a value,                  *  then the value should be updated.                  */         if (index == (path.length - 1)) {             if (node.value != null) {                 throw new IllegalArgumentException("Path [" + String.join("/", path) + "] already has a value [" + node.value + "]").             } else {                 node.value = value.             }         }     }     node.insert(path, index + 1, value). }
false;public,synchronized;4;33;;public synchronized void insertOrUpdate(String[] path, int index, T value, BiFunction<T, T, T> updater) {     if (index >= path.length)         return.     String token = path[index].     String key = token.     if (isNamedWildcard(token)) {         key = wildcard.     }     TrieNode node = children.get(key).     if (node == null) {         T nodeValue = index == path.length - 1 ? value : null.         node = new TrieNode(token, nodeValue, wildcard).         addInnerChild(key, node).     } else {         if (isNamedWildcard(token)) {             node.updateKeyWithNamedWildcard(token).         }         /*                  * If the target node already exists, but is without a value,                  *  then the value should be updated.                  */         if (index == (path.length - 1)) {             if (node.value != null) {                 node.value = updater.apply(node.value, value).             } else {                 node.value = value.             }         }     }     node.insertOrUpdate(path, index + 1, value, updater). }
false;private;1;3;;private boolean isNamedWildcard(String key) {     return key.indexOf('{') != -1 && key.indexOf('}') != -1. }
false;private;0;3;;private String namedWildcard() {     return namedWildcard. }
false;private;0;3;;private boolean isNamedWildcard() {     return namedWildcard != null. }
false;public;4;75;;public T retrieve(String[] path, int index, Map<String, String> params, TrieMatchingMode trieMatchingMode) {     if (index >= path.length)         return null.     String token = path[index].     TrieNode node = children.get(token).     boolean usedWildcard.     if (node == null) {         if (trieMatchingMode == TrieMatchingMode.WILDCARD_NODES_ALLOWED) {             node = children.get(wildcard).             if (node == null) {                 return null.             }             usedWildcard = true.         } else if (trieMatchingMode == TrieMatchingMode.WILDCARD_ROOT_NODES_ALLOWED && index == 1) {             /*                      * Allow root node wildcard matches.                      */             node = children.get(wildcard).             if (node == null) {                 return null.             }             usedWildcard = true.         } else if (trieMatchingMode == TrieMatchingMode.WILDCARD_LEAF_NODES_ALLOWED && index + 1 == path.length) {             /*                      * Allow leaf node wildcard matches.                      */             node = children.get(wildcard).             if (node == null) {                 return null.             }             usedWildcard = true.         } else {             return null.         }     } else {         if (index + 1 == path.length && node.value == null && children.get(wildcard) != null && EXPLICIT_OR_ROOT_WILDCARD.contains(trieMatchingMode) == false) {             /*                      * If we are at the end of the path, the current node does not have a value but                      * there is a child wildcard node, use the child wildcard node.                      */             node = children.get(wildcard).             usedWildcard = true.         } else if (index == 1 && node.value == null && children.get(wildcard) != null && trieMatchingMode == TrieMatchingMode.WILDCARD_ROOT_NODES_ALLOWED) {             /*                      * If we are at the root, and root wildcards are allowed, use the child wildcard                      * node.                      */             node = children.get(wildcard).             usedWildcard = true.         } else {             usedWildcard = token.equals(wildcard).         }     }     put(params, node, token).     if (index == (path.length - 1)) {         return node.value.     }     T nodeValue = node.retrieve(path, index + 1, params, trieMatchingMode).     if (nodeValue == null && !usedWildcard && trieMatchingMode != TrieMatchingMode.EXPLICIT_NODES_ONLY) {         node = children.get(wildcard).         if (node != null) {             put(params, node, token).             nodeValue = node.retrieve(path, index + 1, params, trieMatchingMode).         }     }     return nodeValue. }
false;private;3;5;;private void put(Map<String, String> params, TrieNode node, String value) {     if (params != null && node.isNamedWildcard()) {         params.put(node.namedWildcard(), decoder.decode(value)).     } }
false;public;0;4;;@Override public String toString() {     return key. }
false;public;2;16;;public void insert(String path, T value) {     String[] strings = path.split(SEPARATOR).     if (strings.length == 0) {         if (rootValue != null) {             throw new IllegalArgumentException("Path [/] already has a value [" + rootValue + "]").         }         rootValue = value.         return.     }     int index = 0.     // Supports initial delimiter.     if (strings[0].isEmpty()) {         index = 1.     }     root.insert(strings, index, value). }
true;public;3;17;/**  * Insert a value for the given path. If the path already exists, replace the value with:  * <pre>  * value = updater.apply(oldValue, newValue).  * </pre>  * allowing the value to be updated if desired.  */ ;/**  * Insert a value for the given path. If the path already exists, replace the value with:  * <pre>  * value = updater.apply(oldValue, newValue).  * </pre>  * allowing the value to be updated if desired.  */ public void insertOrUpdate(String path, T value, BiFunction<T, T, T> updater) {     String[] strings = path.split(SEPARATOR).     if (strings.length == 0) {         if (rootValue != null) {             rootValue = updater.apply(rootValue, value).         } else {             rootValue = value.         }         return.     }     int index = 0.     // Supports initial delimiter.     if (strings[0].isEmpty()) {         index = 1.     }     root.insertOrUpdate(strings, index, value, updater). }
false;public;1;3;;public T retrieve(String path) {     return retrieve(path, null, TrieMatchingMode.WILDCARD_NODES_ALLOWED). }
false;public;2;3;;public T retrieve(String path, Map<String, String> params) {     return retrieve(path, params, TrieMatchingMode.WILDCARD_NODES_ALLOWED). }
false;public;3;17;;public T retrieve(String path, Map<String, String> params, TrieMatchingMode trieMatchingMode) {     if (path.length() == 0) {         return rootValue.     }     String[] strings = path.split(SEPARATOR).     if (strings.length == 0) {         return rootValue.     }     int index = 0.     // Supports initial delimiter.     if (strings[0].isEmpty()) {         index = 1.     }     return root.retrieve(strings, index, params, trieMatchingMode). }
true;public;2;3;/**  * Returns an iterator of the objects stored in the {@code PathTrie}, using  * all possible {@code TrieMatchingMode} modes. The {@code paramSupplier}  * is called between each invocation of {@code next()} to supply a new map  * of parameters.  */ ;/**  * Returns an iterator of the objects stored in the {@code PathTrie}, using  * all possible {@code TrieMatchingMode} modes. The {@code paramSupplier}  * is called between each invocation of {@code next()} to supply a new map  * of parameters.  */ public Iterator<T> retrieveAll(String path, Supplier<Map<String, String>> paramSupplier) {     return new PathTrieIterator<>(this, path, paramSupplier). }
false;public;0;4;;@Override public boolean hasNext() {     return modes.isEmpty() == false. }
false;public;0;9;;@Override public T next() {     if (modes.isEmpty()) {         throw new NoSuchElementException("called next() without validating hasNext()! no more modes available").     }     TrieMatchingMode mode = modes.remove(0).     Map<String, String> params = paramSupplier.get().     return trie.retrieve(path, params, mode). }
