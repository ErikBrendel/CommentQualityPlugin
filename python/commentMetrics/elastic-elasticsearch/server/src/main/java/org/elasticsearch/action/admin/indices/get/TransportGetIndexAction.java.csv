commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;5;;@Override protected String executor() {     // very lightweight operation, no need to fork     return ThreadPool.Names.SAME. }
false;protected;2;5;;@Override protected ClusterBlockException checkBlock(GetIndexRequest request, ClusterState state) {     return state.blocks().indicesBlockedException(ClusterBlockLevel.METADATA_READ, indexNameExpressionResolver.concreteIndexNames(state, request)). }
false;protected;0;4;;@Override protected GetIndexResponse newResponse() {     return new GetIndexResponse(). }
false;protected;4;61;;@Override protected void doMasterOperation(final GetIndexRequest request, String[] concreteIndices, final ClusterState state, final ActionListener<GetIndexResponse> listener) {     ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> mappingsResult = ImmutableOpenMap.of().     ImmutableOpenMap<String, List<AliasMetaData>> aliasesResult = ImmutableOpenMap.of().     ImmutableOpenMap<String, Settings> settings = ImmutableOpenMap.of().     ImmutableOpenMap<String, Settings> defaultSettings = ImmutableOpenMap.of().     Feature[] features = request.features().     boolean doneAliases = false.     boolean doneMappings = false.     boolean doneSettings = false.     for (Feature feature : features) {         switch(feature) {             case MAPPINGS:                 if (!doneMappings) {                     try {                         mappingsResult = state.metaData().findMappings(concreteIndices, request.types(), indicesService.getFieldFilter()).                         doneMappings = true.                     } catch (IOException e) {                         listener.onFailure(e).                         return.                     }                 }                 break.             case ALIASES:                 if (!doneAliases) {                     aliasesResult = state.metaData().findAllAliases(concreteIndices).                     doneAliases = true.                 }                 break.             case SETTINGS:                 if (!doneSettings) {                     ImmutableOpenMap.Builder<String, Settings> settingsMapBuilder = ImmutableOpenMap.builder().                     ImmutableOpenMap.Builder<String, Settings> defaultSettingsMapBuilder = ImmutableOpenMap.builder().                     for (String index : concreteIndices) {                         Settings indexSettings = state.metaData().index(index).getSettings().                         if (request.humanReadable()) {                             indexSettings = IndexMetaData.addHumanReadableSettings(indexSettings).                         }                         settingsMapBuilder.put(index, indexSettings).                         if (request.includeDefaults()) {                             Settings defaultIndexSettings = settingsFilter.filter(indexScopedSettings.diff(indexSettings, Settings.EMPTY)).                             defaultSettingsMapBuilder.put(index, defaultIndexSettings).                         }                     }                     settings = settingsMapBuilder.build().                     defaultSettings = defaultSettingsMapBuilder.build().                     doneSettings = true.                 }                 break.             default:                 throw new IllegalStateException("feature [" + feature + "] is not valid").         }     }     listener.onResponse(new GetIndexResponse(concreteIndices, mappingsResult, aliasesResult, settings, defaultSettings)). }
