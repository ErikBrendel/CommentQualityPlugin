commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Returns true if the given uri matches the pattern  */ ;/**  * Returns true if the given uri matches the pattern  */ public boolean match(URI uri) {     return matchNormalized(uri.normalize()). }
false;public,static;2;9;;public static boolean match(URIPattern[] patterns, URI uri) {     URI normalized = uri.normalize().     for (URIPattern pattern : patterns) {         if (pattern.matchNormalized(normalized)) {             return true.         }     }     return false. }
false;private;1;16;;private boolean matchNormalized(URI uri) {     if (uriPattern.isOpaque()) {         // This url only has scheme, scheme-specific part and fragment         return uri.isOpaque() && match(uriPattern.getScheme(), uri.getScheme()) && match(uriPattern.getSchemeSpecificPart(), uri.getSchemeSpecificPart()) && match(uriPattern.getFragment(), uri.getFragment()).     } else {         return match(uriPattern.getScheme(), uri.getScheme()) && match(uriPattern.getAuthority(), uri.getAuthority()) && match(uriPattern.getQuery(), uri.getQuery()) && match(uriPattern.getPath(), uri.getPath()) && match(uriPattern.getFragment(), uri.getFragment()).     } }
false;private;2;9;;private boolean match(String pattern, String value) {     if (value == null) {         // If the pattern is empty or matches anything - it's a match         if (pattern == null || Regex.isMatchAllPattern(pattern)) {             return true.         }     }     return Regex.simpleMatch(pattern, value). }
false;public;0;4;;@Override public String toString() {     return uriPattern.toString(). }
