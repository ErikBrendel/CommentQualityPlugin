commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String getName() {     return "analyze_action". }
false;public;2;13;;@Override public RestChannelConsumer prepareRequest(final RestRequest request, final NodeClient client) throws IOException {     AnalyzeRequest analyzeRequest = new AnalyzeRequest(request.param("index")).     try (XContentParser parser = request.contentOrSourceParamParser()) {         buildFromContent(parser, analyzeRequest).     } catch (IOException e) {         throw new IllegalArgumentException("Failed to parse request body", e).     }     return channel -> client.admin().indices().analyze(analyzeRequest, new RestToXContentListener<>(channel)). }
false;static;2;90;;static void buildFromContent(XContentParser parser, AnalyzeRequest analyzeRequest) throws IOException {     if (parser.nextToken() != XContentParser.Token.START_OBJECT) {         throw new IllegalArgumentException("Malformed content, must start with an object").     } else {         XContentParser.Token token.         String currentFieldName = null.         while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {             if (token == XContentParser.Token.FIELD_NAME) {                 currentFieldName = parser.currentName().             } else if (Fields.TEXT.match(currentFieldName, parser.getDeprecationHandler()) && token == XContentParser.Token.VALUE_STRING) {                 analyzeRequest.text(parser.text()).             } else if (Fields.TEXT.match(currentFieldName, parser.getDeprecationHandler()) && token == XContentParser.Token.START_ARRAY) {                 List<String> texts = new ArrayList<>().                 while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {                     if (token.isValue() == false) {                         throw new IllegalArgumentException(currentFieldName + " array element should only contain text").                     }                     texts.add(parser.text()).                 }                 analyzeRequest.text(texts.toArray(new String[texts.size()])).             } else if (Fields.ANALYZER.match(currentFieldName, parser.getDeprecationHandler()) && token == XContentParser.Token.VALUE_STRING) {                 analyzeRequest.analyzer(parser.text()).             } else if (Fields.FIELD.match(currentFieldName, parser.getDeprecationHandler()) && token == XContentParser.Token.VALUE_STRING) {                 analyzeRequest.field(parser.text()).             } else if (Fields.TOKENIZER.match(currentFieldName, parser.getDeprecationHandler())) {                 if (token == XContentParser.Token.VALUE_STRING) {                     analyzeRequest.tokenizer(parser.text()).                 } else if (token == XContentParser.Token.START_OBJECT) {                     analyzeRequest.tokenizer(parser.map()).                 } else {                     throw new IllegalArgumentException(currentFieldName + " should be tokenizer's name or setting").                 }             } else if (Fields.TOKEN_FILTERS.match(currentFieldName, parser.getDeprecationHandler()) && token == XContentParser.Token.START_ARRAY) {                 while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {                     if (token == XContentParser.Token.VALUE_STRING) {                         analyzeRequest.addTokenFilter(parser.text()).                     } else if (token == XContentParser.Token.START_OBJECT) {                         analyzeRequest.addTokenFilter(parser.map()).                     } else {                         throw new IllegalArgumentException(currentFieldName + " array element should contain filter's name or setting").                     }                 }             } else if (Fields.CHAR_FILTERS.match(currentFieldName, parser.getDeprecationHandler()) && token == XContentParser.Token.START_ARRAY) {                 while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {                     if (token == XContentParser.Token.VALUE_STRING) {                         analyzeRequest.addCharFilter(parser.text()).                     } else if (token == XContentParser.Token.START_OBJECT) {                         analyzeRequest.addCharFilter(parser.map()).                     } else {                         throw new IllegalArgumentException(currentFieldName + " array element should contain char filter's name or setting").                     }                 }             } else if (Fields.EXPLAIN.match(currentFieldName, parser.getDeprecationHandler())) {                 if (parser.isBooleanValue()) {                     analyzeRequest.explain(parser.booleanValue()).                 } else {                     throw new IllegalArgumentException(currentFieldName + " must be either 'true' or 'false'").                 }             } else if (Fields.ATTRIBUTES.match(currentFieldName, parser.getDeprecationHandler()) && token == XContentParser.Token.START_ARRAY) {                 List<String> attributes = new ArrayList<>().                 while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {                     if (token.isValue() == false) {                         throw new IllegalArgumentException(currentFieldName + " array element should only contain attribute name").                     }                     attributes.add(parser.text()).                 }                 analyzeRequest.attributes(attributes.toArray(new String[attributes.size()])).             } else if (Fields.NORMALIZER.match(currentFieldName, parser.getDeprecationHandler())) {                 if (token == XContentParser.Token.VALUE_STRING) {                     analyzeRequest.normalizer(parser.text()).                 } else {                     throw new IllegalArgumentException(currentFieldName + " should be normalizer's name").                 }             } else {                 throw new IllegalArgumentException("Unknown parameter [" + currentFieldName + "] in request body or parameter is of the wrong type[" + token + "] ").             }         }     } }
