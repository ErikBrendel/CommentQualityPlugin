commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;3;/**  * See {@link #wrap(Iterable)}.  */ ;/**  * See {@link #wrap(Iterable)}.  */ public static BucketCollector wrap(BucketCollector... collectors) {     return wrap(Arrays.asList(collectors)). }
true;public,static;1;34;/**  * Wraps a list of {@link BucketCollector}s with a {@link MultiBucketCollector}. This  * method works as follows:  * <ul>  * <li>Filters out the {@link BucketCollector#NO_OP_COLLECTOR}s collectors, so they are not used  * during search time.  * <li>If the input contains 1 real collector, it is returned.  * <li>Otherwise the method returns a {@link MultiBucketCollector} which wraps the  * non-{@link BucketCollector#NO_OP_COLLECTOR} collectors.  * </ul>  */ ;/**  * Wraps a list of {@link BucketCollector}s with a {@link MultiBucketCollector}. This  * method works as follows:  * <ul>  * <li>Filters out the {@link BucketCollector#NO_OP_COLLECTOR}s collectors, so they are not used  * during search time.  * <li>If the input contains 1 real collector, it is returned.  * <li>Otherwise the method returns a {@link MultiBucketCollector} which wraps the  * non-{@link BucketCollector#NO_OP_COLLECTOR} collectors.  * </ul>  */ public static BucketCollector wrap(Iterable<? extends BucketCollector> collectors) {     // For the user's convenience, we allow NO_OP collectors to be passed.     // However, to improve performance, these null collectors are found     // and dropped from the array we save for actual collection time.     int n = 0.     for (BucketCollector c : collectors) {         if (c != NO_OP_COLLECTOR) {             n++.         }     }     if (n == 0) {         return NO_OP_COLLECTOR.     } else if (n == 1) {         // only 1 Collector - return it.         BucketCollector col = null.         for (BucketCollector c : collectors) {             if (c != null) {                 col = c.                 break.             }         }         return col.     } else {         BucketCollector[] colls = new BucketCollector[n].         n = 0.         for (BucketCollector c : collectors) {             if (c != null) {                 colls[n++] = c.             }         }         return new MultiBucketCollector(colls).     } }
false;public;0;12;;@Override public ScoreMode scoreMode() {     ScoreMode scoreMode = null.     for (Collector collector : collectors) {         if (scoreMode == null) {             scoreMode = collector.scoreMode().         } else if (scoreMode != collector.scoreMode()) {             return ScoreMode.COMPLETE.         }     }     return scoreMode. }
false;public;0;6;;@Override public void preCollection() throws IOException {     for (BucketCollector collector : collectors) {         collector.preCollection().     } }
false;public;0;6;;@Override public void postCollection() throws IOException {     for (BucketCollector collector : collectors) {         collector.postCollection().     } }
false;public;0;4;;@Override public String toString() {     return Arrays.toString(collectors). }
false;public;1;22;;@Override public LeafBucketCollector getLeafCollector(LeafReaderContext context) throws IOException {     final List<LeafBucketCollector> leafCollectors = new ArrayList<>().     for (BucketCollector collector : collectors) {         final LeafBucketCollector leafCollector.         try {             leafCollector = collector.getLeafCollector(context).         } catch (CollectionTerminatedException e) {             // this leaf collector does not need this segment             continue.         }         leafCollectors.add(leafCollector).     }     switch(leafCollectors.size()) {         case 0:             throw new CollectionTerminatedException().         case 1:             return leafCollectors.get(0).         default:             return new MultiLeafBucketCollector(leafCollectors, cacheScores).     } }
false;public;1;10;;@Override public void setScorer(Scorable scorer) throws IOException {     if (cacheScores) {         scorer = new ScoreCachingWrappingScorer(scorer).     }     for (int i = 0. i < numCollectors. ++i) {         final LeafCollector c = collectors[i].         c.setScorer(scorer).     } }
false;private;1;5;;private void removeCollector(int i) {     System.arraycopy(collectors, i + 1, collectors, i, numCollectors - i - 1).     --numCollectors.     collectors[numCollectors] = null. }
false;public;2;18;;@Override public void collect(int doc, long bucket) throws IOException {     final LeafBucketCollector[] collectors = this.collectors.     int numCollectors = this.numCollectors.     for (int i = 0. i < numCollectors. ) {         final LeafBucketCollector collector = collectors[i].         try {             collector.collect(doc, bucket).             ++i.         } catch (CollectionTerminatedException e) {             removeCollector(i).             numCollectors = this.numCollectors.             if (numCollectors == 0) {                 throw new CollectionTerminatedException().             }         }     } }
