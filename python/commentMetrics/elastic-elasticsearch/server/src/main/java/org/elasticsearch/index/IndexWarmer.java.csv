commented;modifiers;parameterAmount;loc;comment;code
false;;3;33;;void warm(Engine.Searcher searcher, IndexShard shard, IndexSettings settings) {     if (shard.state() == IndexShardState.CLOSED) {         return.     }     if (settings.isWarmerEnabled() == false) {         return.     }     if (logger.isTraceEnabled()) {         logger.trace("{} top warming [{}]", shard.shardId(), searcher.reader()).     }     shard.warmerService().onPreWarm().     long time = System.nanoTime().     final List<TerminationHandle> terminationHandles = new ArrayList<>().     // get a handle on pending tasks     for (final Listener listener : listeners) {         terminationHandles.add(listener.warmReader(shard, searcher)).     }     // wait for termination     for (TerminationHandle terminationHandle : terminationHandles) {         try {             terminationHandle.awaitTermination().         } catch (InterruptedException e) {             Thread.currentThread().interrupt().             logger.warn("top warming has been interrupted", e).             break.         }     }     long took = System.nanoTime() - time.     shard.warmerService().onPostWarm(took).     if (shard.warmerService().logger().isTraceEnabled()) {         shard.warmerService().logger().trace("top warming took [{}]", new TimeValue(took, TimeUnit.NANOSECONDS)).     } }
true;;0;1;/**  * Wait until execution of the warm-up action completes.  */ ;/**  * Wait until execution of the warm-up action completes.  */ void awaitTermination() throws InterruptedException.
true;;2;1;/**  * Queue tasks to warm-up the given segments and return handles that allow to wait for termination of the  *  execution of those tasks.  */ ;/**  * Queue tasks to warm-up the given segments and return handles that allow to wait for termination of the  *  execution of those tasks.  */ TerminationHandle warmReader(IndexShard indexShard, Engine.Searcher searcher).
false;public;2;41;;@Override public TerminationHandle warmReader(final IndexShard indexShard, final Engine.Searcher searcher) {     final MapperService mapperService = indexShard.mapperService().     final Map<String, MappedFieldType> warmUpGlobalOrdinals = new HashMap<>().     for (MappedFieldType fieldType : mapperService.fieldTypes()) {         final String indexName = fieldType.name().         if (fieldType.eagerGlobalOrdinals() == false) {             continue.         }         warmUpGlobalOrdinals.put(indexName, fieldType).     }     final CountDownLatch latch = new CountDownLatch(warmUpGlobalOrdinals.size()).     for (final MappedFieldType fieldType : warmUpGlobalOrdinals.values()) {         executor.execute(() -> {             try {                 final long start = System.nanoTime().                 IndexFieldData.Global ifd = indexFieldDataService.getForField(fieldType).                 DirectoryReader reader = searcher.getDirectoryReader().                 IndexFieldData<?> global = ifd.loadGlobal(reader).                 if (reader.leaves().isEmpty() == false) {                     global.load(reader.leaves().get(0)).                 }                 if (indexShard.warmerService().logger().isTraceEnabled()) {                     indexShard.warmerService().logger().trace("warmed global ordinals for [{}], took [{}]", fieldType.name(), TimeValue.timeValueNanos(System.nanoTime() - start)).                 }             } catch (Exception e) {                 indexShard.warmerService().logger().warn(() -> new ParameterizedMessage("failed to warm-up global ordinals for [{}]", fieldType.name()), e).             } finally {                 latch.countDown().             }         }).     }     return () -> latch.await(). }
