commented;modifiers;parameterAmount;loc;comment;code
false;private;1;19;;private boolean shouldUpgrade(SegmentCommitInfo info) {     org.apache.lucene.util.Version old = info.info.getVersion().     org.apache.lucene.util.Version cur = Version.CURRENT.luceneVersion.     // Something seriously wrong if this trips:     assert old.major <= cur.major.     if (cur.major > old.major) {         // Always upgrade segment if Lucene's major version is too old         return true.     }     if (upgradeOnlyAncientSegments == false && cur.minor > old.minor) {         // also upgrade:         return true.     }     // Version matches, or segment is not ancient and we are only upgrading ancient segments:     return false. }
false;public;4;43;;@Override public MergeSpecification findForcedMerges(SegmentInfos segmentInfos, int maxSegmentCount, Map<SegmentCommitInfo, Boolean> segmentsToMerge, MergeContext mergeContext) throws IOException {     if (upgradeInProgress) {         MergeSpecification spec = new MergeSpecification().         for (SegmentCommitInfo info : segmentInfos) {             if (shouldUpgrade(info)) {                 // TODO: Use IndexUpgradeMergePolicy instead.  We should be comparing codecs,                 // for now we just assume every minor upgrade has a new format.                 logger.debug("Adding segment {} to be upgraded", info.info.name).                 spec.add(new OneMerge(Collections.singletonList(info))).             }             if (spec.merges.size() == MAX_CONCURRENT_UPGRADE_MERGES) {                 // hit our max upgrades, so return the spec.  we will get a cascaded call to continue.                 logger.debug("Returning {} merges for upgrade", spec.merges.size()).                 return spec.             }         }         // We must have less than our max upgrade merges, so the next return will be our last in upgrading mode.         if (spec.merges.isEmpty() == false) {             logger.debug("Returning {} merges for end of upgrade", spec.merges.size()).             return spec.         }         // Only set this once there are 0 segments needing upgrading, because when we return a         // spec, IndexWriter may (silently!) reject that merge if some of the segments we asked         // to be merged were already being (naturally) merged:         upgradeInProgress = false.     // fall through, so when we don't have any segments to upgrade, the delegate policy     // has a chance to decide what to do (e.g. collapse the segments to satisfy maxSegmentCount)     }     return super.findForcedMerges(segmentInfos, maxSegmentCount, segmentsToMerge, mergeContext). }
true;public;2;4;/**  * When <code>upgrade</code> is true, running a force merge will upgrade any segments written  * with older versions. This will apply to the next call to  * {@link IndexWriter#forceMerge} that is handled by this {@link MergePolicy}, as well as  * cascading calls made by {@link IndexWriter}.  */ ;/**  * When <code>upgrade</code> is true, running a force merge will upgrade any segments written  * with older versions. This will apply to the next call to  * {@link IndexWriter#forceMerge} that is handled by this {@link MergePolicy}, as well as  * cascading calls made by {@link IndexWriter}.  */ public void setUpgradeInProgress(boolean upgrade, boolean onlyAncientSegments) {     this.upgradeInProgress = upgrade.     this.upgradeOnlyAncientSegments = onlyAncientSegments. }
