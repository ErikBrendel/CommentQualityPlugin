commented;modifiers;parameterAmount;loc;comment;code
false;public;2;56;;@Override public void collect(int doc, long bucket) throws IOException {     if (bucket >= tops.size()) {         long from = tops.size().         tops = bigArrays.grow(tops, bucket + 1).         tops.fill(from, tops.size(), Double.NEGATIVE_INFINITY).         bottoms = bigArrays.resize(bottoms, tops.size()).         bottoms.fill(from, bottoms.size(), Double.POSITIVE_INFINITY).         posLefts = bigArrays.resize(posLefts, tops.size()).         posLefts.fill(from, posLefts.size(), Double.POSITIVE_INFINITY).         posRights = bigArrays.resize(posRights, tops.size()).         posRights.fill(from, posRights.size(), Double.NEGATIVE_INFINITY).         negLefts = bigArrays.resize(negLefts, tops.size()).         negLefts.fill(from, negLefts.size(), Double.POSITIVE_INFINITY).         negRights = bigArrays.resize(negRights, tops.size()).         negRights.fill(from, negRights.size(), Double.NEGATIVE_INFINITY).     }     if (values.advanceExact(doc)) {         final int valuesCount = values.docValueCount().         for (int i = 0. i < valuesCount. ++i) {             GeoPoint value = values.nextValue().             double top = tops.get(bucket).             if (value.lat() > top) {                 top = value.lat().             }             double bottom = bottoms.get(bucket).             if (value.lat() < bottom) {                 bottom = value.lat().             }             double posLeft = posLefts.get(bucket).             if (value.lon() >= 0 && value.lon() < posLeft) {                 posLeft = value.lon().             }             double posRight = posRights.get(bucket).             if (value.lon() >= 0 && value.lon() > posRight) {                 posRight = value.lon().             }             double negLeft = negLefts.get(bucket).             if (value.lon() < 0 && value.lon() < negLeft) {                 negLeft = value.lon().             }             double negRight = negRights.get(bucket).             if (value.lon() < 0 && value.lon() > negRight) {                 negRight = value.lon().             }             tops.set(bucket, top).             bottoms.set(bucket, bottom).             posLefts.set(bucket, posLeft).             posRights.set(bucket, posRight).             negLefts.set(bucket, negLeft).             negRights.set(bucket, negRight).         }     } }
false;public;2;67;;@Override public LeafBucketCollector getLeafCollector(LeafReaderContext ctx, LeafBucketCollector sub) {     if (valuesSource == null) {         return LeafBucketCollector.NO_OP_COLLECTOR.     }     final BigArrays bigArrays = context.bigArrays().     final MultiGeoPointValues values = valuesSource.geoPointValues(ctx).     return new LeafBucketCollectorBase(sub, values) {          @Override         public void collect(int doc, long bucket) throws IOException {             if (bucket >= tops.size()) {                 long from = tops.size().                 tops = bigArrays.grow(tops, bucket + 1).                 tops.fill(from, tops.size(), Double.NEGATIVE_INFINITY).                 bottoms = bigArrays.resize(bottoms, tops.size()).                 bottoms.fill(from, bottoms.size(), Double.POSITIVE_INFINITY).                 posLefts = bigArrays.resize(posLefts, tops.size()).                 posLefts.fill(from, posLefts.size(), Double.POSITIVE_INFINITY).                 posRights = bigArrays.resize(posRights, tops.size()).                 posRights.fill(from, posRights.size(), Double.NEGATIVE_INFINITY).                 negLefts = bigArrays.resize(negLefts, tops.size()).                 negLefts.fill(from, negLefts.size(), Double.POSITIVE_INFINITY).                 negRights = bigArrays.resize(negRights, tops.size()).                 negRights.fill(from, negRights.size(), Double.NEGATIVE_INFINITY).             }             if (values.advanceExact(doc)) {                 final int valuesCount = values.docValueCount().                 for (int i = 0. i < valuesCount. ++i) {                     GeoPoint value = values.nextValue().                     double top = tops.get(bucket).                     if (value.lat() > top) {                         top = value.lat().                     }                     double bottom = bottoms.get(bucket).                     if (value.lat() < bottom) {                         bottom = value.lat().                     }                     double posLeft = posLefts.get(bucket).                     if (value.lon() >= 0 && value.lon() < posLeft) {                         posLeft = value.lon().                     }                     double posRight = posRights.get(bucket).                     if (value.lon() >= 0 && value.lon() > posRight) {                         posRight = value.lon().                     }                     double negLeft = negLefts.get(bucket).                     if (value.lon() < 0 && value.lon() < negLeft) {                         negLeft = value.lon().                     }                     double negRight = negRights.get(bucket).                     if (value.lon() < 0 && value.lon() > negRight) {                         negRight = value.lon().                     }                     tops.set(bucket, top).                     bottoms.set(bucket, bottom).                     posLefts.set(bucket, posLeft).                     posRights.set(bucket, posRight).                     negLefts.set(bucket, negLeft).                     negRights.set(bucket, negRight).                 }             }         }     }. }
false;public;1;14;;@Override public InternalAggregation buildAggregation(long owningBucketOrdinal) {     if (valuesSource == null) {         return buildEmptyAggregation().     }     double top = tops.get(owningBucketOrdinal).     double bottom = bottoms.get(owningBucketOrdinal).     double posLeft = posLefts.get(owningBucketOrdinal).     double posRight = posRights.get(owningBucketOrdinal).     double negLeft = negLefts.get(owningBucketOrdinal).     double negRight = negRights.get(owningBucketOrdinal).     return new InternalGeoBounds(name, top, bottom, posLeft, posRight, negLeft, negRight, wrapLongitude, pipelineAggregators(), metaData()). }
false;public;0;6;;@Override public InternalAggregation buildEmptyAggregation() {     return new InternalGeoBounds(name, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, wrapLongitude, pipelineAggregators(), metaData()). }
false;public;0;4;;@Override public void doClose() {     Releasables.close(tops, bottoms, posLefts, posRights, negLefts, negRights). }
