commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected String executor() {     return ThreadPool.Names.SAME. }
false;protected;0;4;;@Override protected IndicesShardStoresResponse newResponse() {     return new IndicesShardStoresResponse(). }
false;protected;3;31;;@Override protected void masterOperation(IndicesShardStoresRequest request, ClusterState state, ActionListener<IndicesShardStoresResponse> listener) {     final RoutingTable routingTables = state.routingTable().     final RoutingNodes routingNodes = state.getRoutingNodes().     final String[] concreteIndices = indexNameExpressionResolver.concreteIndexNames(state, request).     final Set<ShardId> shardIdsToFetch = new HashSet<>().     logger.trace("using cluster state version [{}] to determine shards", state.version()).     // collect relevant shard ids of the requested indices for fetching store infos     for (String index : concreteIndices) {         IndexRoutingTable indexShardRoutingTables = routingTables.index(index).         if (indexShardRoutingTables == null) {             continue.         }         for (IndexShardRoutingTable routing : indexShardRoutingTables) {             final int shardId = routing.shardId().id().             ClusterShardHealth shardHealth = new ClusterShardHealth(shardId, routing).             if (request.shardStatuses().contains(shardHealth.getStatus())) {                 shardIdsToFetch.add(routing.shardId()).             }         }     }     // async fetch store infos from all the nodes     // NOTE: instead of fetching shard store info one by one from every node (nShards * nNodes requests)     // we could fetch all shard store info from every node once (nNodes requests)     // we have to implement a TransportNodesAction instead of using TransportNodesListGatewayStartedShards     // for fetching shard stores info, that operates on a list of shards instead of a single shard     new AsyncShardStoresInfoFetches(state.nodes(), routingNodes, shardIdsToFetch, listener).start(). }
false;protected;2;5;;@Override protected ClusterBlockException checkBlock(IndicesShardStoresRequest request, ClusterState state) {     return state.blocks().indicesBlockedException(ClusterBlockLevel.METADATA_READ, indexNameExpressionResolver.concreteIndexNames(state, request)). }
false;;0;10;;void start() {     if (shardIds.isEmpty()) {         listener.onResponse(new IndicesShardStoresResponse()).     } else {         for (ShardId shardId : shardIds) {             InternalAsyncFetch fetch = new InternalAsyncFetch(logger, "shard_stores", shardId, listShardStoresInfo).             fetch.fetchData(nodes, Collections.<String>emptySet()).         }     } }
false;protected,synchronized;3;8;;@Override protected synchronized void processAsyncFetch(List<NodeGatewayStartedShards> responses, List<FailedNodeException> failures, long fetchingRound) {     fetchResponses.add(new Response(shardId, responses, failures)).     if (expectedOps.countDown()) {         finish().     } }
false;;0;38;;void finish() {     ImmutableOpenMap.Builder<String, ImmutableOpenIntMap<java.util.List<IndicesShardStoresResponse.StoreStatus>>> indicesStoreStatusesBuilder = ImmutableOpenMap.builder().     java.util.List<IndicesShardStoresResponse.Failure> failureBuilder = new ArrayList<>().     for (Response fetchResponse : fetchResponses) {         ImmutableOpenIntMap<java.util.List<IndicesShardStoresResponse.StoreStatus>> indexStoreStatuses = indicesStoreStatusesBuilder.get(fetchResponse.shardId.getIndexName()).         final ImmutableOpenIntMap.Builder<java.util.List<IndicesShardStoresResponse.StoreStatus>> indexShardsBuilder.         if (indexStoreStatuses == null) {             indexShardsBuilder = ImmutableOpenIntMap.builder().         } else {             indexShardsBuilder = ImmutableOpenIntMap.builder(indexStoreStatuses).         }         java.util.List<IndicesShardStoresResponse.StoreStatus> storeStatuses = indexShardsBuilder.get(fetchResponse.shardId.id()).         if (storeStatuses == null) {             storeStatuses = new ArrayList<>().         }         for (NodeGatewayStartedShards response : fetchResponse.responses) {             if (shardExistsInNode(response)) {                 IndicesShardStoresResponse.StoreStatus.AllocationStatus allocationStatus = getAllocationStatus(fetchResponse.shardId.getIndexName(), fetchResponse.shardId.id(), response.getNode()).                 storeStatuses.add(new IndicesShardStoresResponse.StoreStatus(response.getNode(), response.allocationId(), allocationStatus, response.storeException())).             }         }         CollectionUtil.timSort(storeStatuses).         indexShardsBuilder.put(fetchResponse.shardId.id(), storeStatuses).         indicesStoreStatusesBuilder.put(fetchResponse.shardId.getIndexName(), indexShardsBuilder.build()).         for (FailedNodeException failure : fetchResponse.failures) {             failureBuilder.add(new IndicesShardStoresResponse.Failure(failure.nodeId(), fetchResponse.shardId.getIndexName(), fetchResponse.shardId.id(), failure.getCause())).         }     }     listener.onResponse(new IndicesShardStoresResponse(indicesStoreStatusesBuilder.build(), Collections.unmodifiableList(failureBuilder))). }
false;private;3;16;;private IndicesShardStoresResponse.StoreStatus.AllocationStatus getAllocationStatus(String index, int shardID, DiscoveryNode node) {     for (ShardRouting shardRouting : routingNodes.node(node.getId())) {         ShardId shardId = shardRouting.shardId().         if (shardId.id() == shardID && shardId.getIndexName().equals(index)) {             if (shardRouting.primary()) {                 return IndicesShardStoresResponse.StoreStatus.AllocationStatus.PRIMARY.             } else if (shardRouting.assignedToNode()) {                 return IndicesShardStoresResponse.StoreStatus.AllocationStatus.REPLICA.             } else {                 return IndicesShardStoresResponse.StoreStatus.AllocationStatus.UNUSED.             }         }     }     return IndicesShardStoresResponse.StoreStatus.AllocationStatus.UNUSED. }
true;private;1;3;/**  * A shard exists/existed in a node only if shard state file exists in the node  */ ;/**  * A shard exists/existed in a node only if shard state file exists in the node  */ private boolean shardExistsInNode(final NodeGatewayStartedShards response) {     return response.storeException() != null || response.allocationId() != null. }
false;protected;2;4;;@Override protected void reroute(ShardId shardId, String reason) { // no-op }
