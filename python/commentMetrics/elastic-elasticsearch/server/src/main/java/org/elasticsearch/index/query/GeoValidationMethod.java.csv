commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;3;;public static GeoValidationMethod readFromStream(StreamInput in) throws IOException {     return GeoValidationMethod.values()[in.readVInt()]. }
false;public;1;4;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeVInt(this.ordinal()). }
false;public,static;1;9;;public static GeoValidationMethod fromString(String op) {     for (GeoValidationMethod method : GeoValidationMethod.values()) {         if (method.name().equalsIgnoreCase(op)) {             return method.         }     }     throw new IllegalArgumentException("operator needs to be either " + CollectionUtils.arrayAsArrayList(GeoValidationMethod.values()) + ", but not [" + op + "]"). }
true;public,static;1;3;/**  * Returns whether or not to skip bounding box validation.  */ ;/**  * Returns whether or not to skip bounding box validation.  */ public static boolean isIgnoreMalformed(GeoValidationMethod method) {     return (method == GeoValidationMethod.IGNORE_MALFORMED || method == GeoValidationMethod.COERCE). }
true;public,static;1;3;/**  * Returns whether or not to try and fix broken/wrapping bounding boxes.  */ ;/**  * Returns whether or not to try and fix broken/wrapping bounding boxes.  */ public static boolean isCoerce(GeoValidationMethod method) {     return method == GeoValidationMethod.COERCE. }
true;public,static;2;9;/**  * Returns validation method corresponding to given coerce and ignoreMalformed values.  */ ;/**  * Returns validation method corresponding to given coerce and ignoreMalformed values.  */ public static GeoValidationMethod infer(boolean coerce, boolean ignoreMalformed) {     if (coerce) {         return GeoValidationMethod.COERCE.     } else if (ignoreMalformed) {         return GeoValidationMethod.IGNORE_MALFORMED.     } else {         return GeoValidationMethod.STRICT.     } }
