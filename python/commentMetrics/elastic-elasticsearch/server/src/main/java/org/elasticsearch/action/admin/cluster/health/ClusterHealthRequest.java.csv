commented;modifiers;parameterAmount;loc;comment;code
false;public;1;34;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     if (indices == null) {         out.writeVInt(0).     } else {         out.writeVInt(indices.length).         for (String index : indices) {             out.writeString(index).         }     }     out.writeTimeValue(timeout).     if (waitForStatus == null) {         out.writeBoolean(false).     } else {         out.writeBoolean(true).         out.writeByte(waitForStatus.value()).     }     out.writeBoolean(waitForNoRelocatingShards).     waitForActiveShards.writeTo(out).     out.writeString(waitForNodes).     if (waitForEvents == null) {         out.writeBoolean(false).     } else {         out.writeBoolean(true).         Priority.writeTo(waitForEvents, out).     }     if (out.getVersion().onOrAfter(Version.V_6_2_0)) {         out.writeBoolean(waitForNoInitializingShards).     }     if (out.getVersion().onOrAfter(Version.V_7_1_0)) {         indicesOptions.writeIndicesOptions(out).     } }
false;public;0;4;;@Override public String[] indices() {     return indices. }
false;public;1;5;;@Override public ClusterHealthRequest indices(String... indices) {     this.indices = indices.     return this. }
false;public;0;4;;@Override public IndicesOptions indicesOptions() {     return indicesOptions. }
false;public;1;4;;public ClusterHealthRequest indicesOptions(final IndicesOptions indicesOptions) {     this.indicesOptions = indicesOptions.     return this. }
false;public;0;3;;public TimeValue timeout() {     return timeout. }
false;public;1;7;;public ClusterHealthRequest timeout(TimeValue timeout) {     this.timeout = timeout.     if (masterNodeTimeout == DEFAULT_MASTER_NODE_TIMEOUT) {         masterNodeTimeout = timeout.     }     return this. }
false;public;1;3;;public ClusterHealthRequest timeout(String timeout) {     return this.timeout(TimeValue.parseTimeValue(timeout, null, getClass().getSimpleName() + ".timeout")). }
false;public;0;3;;public ClusterHealthStatus waitForStatus() {     return waitForStatus. }
false;public;1;4;;public ClusterHealthRequest waitForStatus(ClusterHealthStatus waitForStatus) {     this.waitForStatus = waitForStatus.     return this. }
false;public;0;3;;public ClusterHealthRequest waitForGreenStatus() {     return waitForStatus(ClusterHealthStatus.GREEN). }
false;public;0;3;;public ClusterHealthRequest waitForYellowStatus() {     return waitForStatus(ClusterHealthStatus.YELLOW). }
false;public;0;3;;public boolean waitForNoRelocatingShards() {     return waitForNoRelocatingShards. }
true;public;1;4;/**  * Sets whether the request should wait for there to be no relocating shards before  * retrieving the cluster health status.  Defaults to {@code false}, meaning the  * operation does not wait on there being no more relocating shards.  Set to <code>true</code>  * to wait until the number of relocating shards in the cluster is 0.  */ ;/**  * Sets whether the request should wait for there to be no relocating shards before  * retrieving the cluster health status.  Defaults to {@code false}, meaning the  * operation does not wait on there being no more relocating shards.  Set to <code>true</code>  * to wait until the number of relocating shards in the cluster is 0.  */ public ClusterHealthRequest waitForNoRelocatingShards(boolean waitForNoRelocatingShards) {     this.waitForNoRelocatingShards = waitForNoRelocatingShards.     return this. }
false;public;0;3;;public boolean waitForNoInitializingShards() {     return waitForNoInitializingShards. }
true;public;1;4;/**  * Sets whether the request should wait for there to be no initializing shards before  * retrieving the cluster health status.  Defaults to {@code false}, meaning the  * operation does not wait on there being no more initializing shards.  Set to <code>true</code>  * to wait until the number of initializing shards in the cluster is 0.  */ ;/**  * Sets whether the request should wait for there to be no initializing shards before  * retrieving the cluster health status.  Defaults to {@code false}, meaning the  * operation does not wait on there being no more initializing shards.  Set to <code>true</code>  * to wait until the number of initializing shards in the cluster is 0.  */ public ClusterHealthRequest waitForNoInitializingShards(boolean waitForNoInitializingShards) {     this.waitForNoInitializingShards = waitForNoInitializingShards.     return this. }
false;public;0;3;;public ActiveShardCount waitForActiveShards() {     return waitForActiveShards. }
true;public;1;9;/**  * Sets the number of shard copies that must be active across all indices before getting the  * health status. Defaults to {@link ActiveShardCount#NONE}, meaning we don't wait on any active shards.  * Set this value to {@link ActiveShardCount#ALL} to wait for all shards (primary and  * all replicas) to be active across all indices in the cluster. Otherwise, use  * {@link ActiveShardCount#from(int)} to set this value to any non-negative integer, up to the  * total number of shard copies to wait for.  */ ;/**  * Sets the number of shard copies that must be active across all indices before getting the  * health status. Defaults to {@link ActiveShardCount#NONE}, meaning we don't wait on any active shards.  * Set this value to {@link ActiveShardCount#ALL} to wait for all shards (primary and  * all replicas) to be active across all indices in the cluster. Otherwise, use  * {@link ActiveShardCount#from(int)} to set this value to any non-negative integer, up to the  * total number of shard copies to wait for.  */ public ClusterHealthRequest waitForActiveShards(ActiveShardCount waitForActiveShards) {     if (waitForActiveShards.equals(ActiveShardCount.DEFAULT)) {         // the default for cluster health request is 0, not 1         this.waitForActiveShards = ActiveShardCount.NONE.     } else {         this.waitForActiveShards = waitForActiveShards.     }     return this. }
true;public;1;3;/**  * A shortcut for {@link #waitForActiveShards(ActiveShardCount)} where the numerical  * shard count is passed in, instead of having to first call {@link ActiveShardCount#from(int)}  * to get the ActiveShardCount.  */ ;/**  * A shortcut for {@link #waitForActiveShards(ActiveShardCount)} where the numerical  * shard count is passed in, instead of having to first call {@link ActiveShardCount#from(int)}  * to get the ActiveShardCount.  */ public ClusterHealthRequest waitForActiveShards(final int waitForActiveShards) {     return waitForActiveShards(ActiveShardCount.from(waitForActiveShards)). }
false;public;0;3;;public String waitForNodes() {     return waitForNodes. }
true;public;1;4;/**  * Waits for N number of nodes. Use "12" for exact mapping, "&gt.12" and "&lt.12" for range.  */ ;/**  * Waits for N number of nodes. Use "12" for exact mapping, "&gt.12" and "&lt.12" for range.  */ public ClusterHealthRequest waitForNodes(String waitForNodes) {     this.waitForNodes = waitForNodes.     return this. }
false;public;1;4;;public ClusterHealthRequest waitForEvents(Priority waitForEvents) {     this.waitForEvents = waitForEvents.     return this. }
false;public;0;3;;public Priority waitForEvents() {     return this.waitForEvents. }
true;public;1;3;/**  * Set the level of detail for the health information to be returned.  * Only used by the high-level REST Client.  */ ;/**  * Set the level of detail for the health information to be returned.  * Only used by the high-level REST Client.  */ public void level(Level level) {     this.level = Objects.requireNonNull(level, "level must not be null"). }
true;public;0;3;/**  * Get the level of detail for the health information to be returned.  * Only used by the high-level REST Client.  */ ;/**  * Get the level of detail for the health information to be returned.  * Only used by the high-level REST Client.  */ public Level level() {     return level. }
false;public;0;4;;@Override public ActionRequestValidationException validate() {     return null. }
false;public;1;4;;@Override public void readFrom(StreamInput in) throws IOException {     throw new UnsupportedOperationException("usage of Streamable is to be replaced by Writeable"). }
