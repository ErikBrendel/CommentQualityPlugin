commented;modifiers;parameterAmount;loc;comment;code
false;public;1;5;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeString(key).     out.writeNamedWriteable(filter). }
false;public;0;3;;public String key() {     return key. }
false;public;0;3;;public QueryBuilder filter() {     return filter. }
false;public;2;5;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.field(key, filter).     return builder. }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(key, filter). }
false;public;1;12;;@Override public boolean equals(Object obj) {     if (obj == null) {         return false.     }     if (getClass() != obj.getClass()) {         return false.     }     KeyedFilter other = (KeyedFilter) obj.     return Objects.equals(key, other.key) && Objects.equals(filter, other.filter). }
false;public;2;13;;@Override public void collect(int doc, long bucket) throws IOException {     boolean matched = false.     for (int i = 0. i < bits.length. i++) {         if (bits[i].get(doc)) {             collectBucket(sub, doc, bucketOrd(bucket, i)).             matched = true.         }     }     if (showOtherBucket && !matched) {         collectBucket(sub, doc, bucketOrd(bucket, bits.length)).     } }
false;public;2;25;;@Override public LeafBucketCollector getLeafCollector(LeafReaderContext ctx, final LeafBucketCollector sub) throws IOException {     // no need to provide deleted docs to the filter     Weight[] filters = this.filters.get().     final Bits[] bits = new Bits[filters.length].     for (int i = 0. i < filters.length. ++i) {         bits[i] = Lucene.asSequentialAccessBits(ctx.reader().maxDoc(), filters[i].scorerSupplier(ctx)).     }     return new LeafBucketCollectorBase(sub, null) {          @Override         public void collect(int doc, long bucket) throws IOException {             boolean matched = false.             for (int i = 0. i < bits.length. i++) {                 if (bits[i].get(doc)) {                     collectBucket(sub, doc, bucketOrd(bucket, i)).                     matched = true.                 }             }             if (showOtherBucket && !matched) {                 collectBucket(sub, doc, bucketOrd(bucket, bits.length)).             }         }     }. }
false;public;1;19;;@Override public InternalAggregation buildAggregation(long owningBucketOrdinal) throws IOException {     consumeBucketsAndMaybeBreak(keys.length + (showOtherBucket ? 1 : 0)).     List<InternalFilters.InternalBucket> buckets = new ArrayList<>(keys.length).     for (int i = 0. i < keys.length. i++) {         long bucketOrd = bucketOrd(owningBucketOrdinal, i).         InternalFilters.InternalBucket bucket = new InternalFilters.InternalBucket(keys[i], bucketDocCount(bucketOrd), bucketAggregations(bucketOrd), keyed).         buckets.add(bucket).     }     // other bucket     if (showOtherBucket) {         long bucketOrd = bucketOrd(owningBucketOrdinal, keys.length).         InternalFilters.InternalBucket bucket = new InternalFilters.InternalBucket(otherBucketKey, bucketDocCount(bucketOrd), bucketAggregations(bucketOrd), keyed).         buckets.add(bucket).     }     return new InternalFilters(name, buckets, keyed, pipelineAggregators(), metaData()). }
false;public;0;16;;@Override public InternalAggregation buildEmptyAggregation() {     InternalAggregations subAggs = buildEmptySubAggregations().     List<InternalFilters.InternalBucket> buckets = new ArrayList<>(keys.length).     for (int i = 0. i < keys.length. i++) {         InternalFilters.InternalBucket bucket = new InternalFilters.InternalBucket(keys[i], 0, subAggs, keyed).         buckets.add(bucket).     }     if (showOtherBucket) {         InternalFilters.InternalBucket bucket = new InternalFilters.InternalBucket(otherBucketKey, 0, subAggs, keyed).         buckets.add(bucket).     }     return new InternalFilters(name, buckets, keyed, pipelineAggregators(), metaData()). }
false;final;2;3;;final long bucketOrd(long owningBucketOrdinal, int filterOrd) {     return owningBucketOrdinal * totalNumKeys + filterOrd. }
