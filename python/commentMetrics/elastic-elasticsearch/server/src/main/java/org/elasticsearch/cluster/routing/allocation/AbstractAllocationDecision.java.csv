commented;modifiers;parameterAmount;loc;comment;code
true;public,abstract;0;1;/**  * Returns {@code true} if a decision was taken by the allocator, {@code false} otherwise.  * If no decision was taken, then the rest of the fields in this object cannot be accessed and will  * throw an {@code IllegalStateException}.  */ ;/**  * Returns {@code true} if a decision was taken by the allocator, {@code false} otherwise.  * If no decision was taken, then the rest of the fields in this object cannot be accessed and will  * throw an {@code IllegalStateException}.  */ public abstract boolean isDecisionTaken().
true;public;0;5;/**  * Get the node that the allocator will assign the shard to, returning {@code null} if there is no node to  * which the shard will be assigned or moved.  If {@link #isDecisionTaken()} returns {@code false}, then  * invoking this method will throw an {@code IllegalStateException}.  */ ;/**  * Get the node that the allocator will assign the shard to, returning {@code null} if there is no node to  * which the shard will be assigned or moved.  If {@link #isDecisionTaken()} returns {@code false}, then  * invoking this method will throw an {@code IllegalStateException}.  */ @Nullable public DiscoveryNode getTargetNode() {     checkDecisionState().     return targetNode. }
true;public;0;5;/**  * Gets the sorted list of individual node-level decisions that went into making the ultimate decision whether  * to allocate or move the shard.  If {@link #isDecisionTaken()} returns {@code false}, then  * invoking this method will throw an {@code IllegalStateException}.  */ ;/**  * Gets the sorted list of individual node-level decisions that went into making the ultimate decision whether  * to allocate or move the shard.  If {@link #isDecisionTaken()} returns {@code false}, then  * invoking this method will throw an {@code IllegalStateException}.  */ @Nullable public List<NodeAllocationResult> getNodeDecisions() {     checkDecisionState().     return nodeDecisions. }
true;public,abstract;0;1;/**  * Gets the explanation for the decision.  If {@link #isDecisionTaken()} returns {@code false}, then invoking  * this method will throw an {@code IllegalStateException}.  */ ;/**  * Gets the explanation for the decision.  If {@link #isDecisionTaken()} returns {@code false}, then invoking  * this method will throw an {@code IllegalStateException}.  */ public abstract String getExplanation().
false;public;1;10;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeOptionalWriteable(targetNode).     if (nodeDecisions != null) {         out.writeBoolean(true).         out.writeList(nodeDecisions).     } else {         out.writeBoolean(false).     } }
false;protected;0;5;;protected void checkDecisionState() {     if (isDecisionTaken() == false) {         throw new IllegalStateException("decision was not taken, individual object fields cannot be accessed").     } }
true;public,static;3;15;/**  * Generates X-Content for a {@link DiscoveryNode} that leaves off some of the non-critical fields.  */ ;/**  * Generates X-Content for a {@link DiscoveryNode} that leaves off some of the non-critical fields.  */ public static XContentBuilder discoveryNodeToXContent(DiscoveryNode node, boolean outerObjectWritten, XContentBuilder builder) throws IOException {     builder.field(outerObjectWritten ? "id" : "node_id", node.getId()).     builder.field(outerObjectWritten ? "name" : "node_name", node.getName()).     builder.field("transport_address", node.getAddress().toString()).     if (node.getAttributes().isEmpty() == false) {         builder.startObject(outerObjectWritten ? "attributes" : "node_attributes").         for (Map.Entry<String, String> entry : node.getAttributes().entrySet()) {             builder.field(entry.getKey(), entry.getValue()).         }         builder.endObject().     }     return builder. }
true;public;1;3;/**  * Sorts a list of node level decisions by the decision type, then by weight ranking, and finally by node id.  */ ;/**  * Sorts a list of node level decisions by the decision type, then by weight ranking, and finally by node id.  */ public List<NodeAllocationResult> sortNodeDecisions(List<NodeAllocationResult> nodeDecisions) {     return Collections.unmodifiableList(nodeDecisions.stream().sorted().collect(Collectors.toList())). }
true;public;3;14;/**  * Generates X-Content for the node-level decisions, creating the outer "node_decisions" object  * in which they are serialized.  */ ;/**  * Generates X-Content for the node-level decisions, creating the outer "node_decisions" object  * in which they are serialized.  */ public XContentBuilder nodeDecisionsToXContent(List<NodeAllocationResult> nodeDecisions, XContentBuilder builder, Params params) throws IOException {     if (nodeDecisions != null && nodeDecisions.isEmpty() == false) {         builder.startArray("node_allocation_decisions").         {             for (NodeAllocationResult explanation : nodeDecisions) {                 explanation.toXContent(builder, params).             }         }         builder.endArray().     }     return builder. }
true;protected;0;11;/**  * Returns {@code true} if there is at least one node that returned a {@link Type#YES} decision for allocating this shard.  */ ;/**  * Returns {@code true} if there is at least one node that returned a {@link Type#YES} decision for allocating this shard.  */ protected boolean atLeastOneNodeWithYesDecision() {     if (nodeDecisions == null) {         return false.     }     for (NodeAllocationResult result : nodeDecisions) {         if (result.getNodeDecision() == AllocationDecision.YES) {             return true.         }     }     return false. }
false;public;1;11;;@Override public boolean equals(Object other) {     if (this == other) {         return true.     }     if (other == null || other instanceof AbstractAllocationDecision == false) {         return false.     }     AbstractAllocationDecision that = (AbstractAllocationDecision) other.     return Objects.equals(targetNode, that.targetNode) && Objects.equals(nodeDecisions, that.nodeDecisions). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(targetNode, nodeDecisions). }
