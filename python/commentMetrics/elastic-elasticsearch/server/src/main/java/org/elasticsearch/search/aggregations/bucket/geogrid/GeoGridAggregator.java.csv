commented;modifiers;parameterAmount;loc;comment;code
false;public;0;7;;@Override public ScoreMode scoreMode() {     if (valuesSource != null && valuesSource.needsScores()) {         return ScoreMode.COMPLETE.     }     return super.scoreMode(). }
false;public;2;22;;@Override public void collect(int doc, long bucket) throws IOException {     assert bucket == 0.     if (values.advanceExact(doc)) {         final int valuesCount = values.docValueCount().         long previous = Long.MAX_VALUE.         for (int i = 0. i < valuesCount. ++i) {             final long val = values.nextValue().             if (previous != val || i == 0) {                 long bucketOrdinal = bucketOrds.add(val).                 if (bucketOrdinal < 0) {                     // already seen                     bucketOrdinal = -1 - bucketOrdinal.                     collectExistingBucket(sub, doc, bucketOrdinal).                 } else {                     collectBucket(sub, doc, bucketOrdinal).                 }                 previous = val.             }         }     } }
false;public;2;29;;@Override public LeafBucketCollector getLeafCollector(LeafReaderContext ctx, final LeafBucketCollector sub) throws IOException {     final SortedNumericDocValues values = valuesSource.longValues(ctx).     return new LeafBucketCollectorBase(sub, null) {          @Override         public void collect(int doc, long bucket) throws IOException {             assert bucket == 0.             if (values.advanceExact(doc)) {                 final int valuesCount = values.docValueCount().                 long previous = Long.MAX_VALUE.                 for (int i = 0. i < valuesCount. ++i) {                     final long val = values.nextValue().                     if (previous != val || i == 0) {                         long bucketOrdinal = bucketOrds.add(val).                         if (bucketOrdinal < 0) {                             // already seen                             bucketOrdinal = -1 - bucketOrdinal.                             collectExistingBucket(sub, doc, bucketOrdinal).                         } else {                             collectBucket(sub, doc, bucketOrdinal).                         }                         previous = val.                     }                 }             }         }     }. }
false;;1;4;;void hashAsLong(long hashAsLong) {     this.hashAsLong = hashAsLong.     this.sourceBucket.hashAsLong = hashAsLong. }
false;;4;14;;@Override InternalGeoGridBucket buildBucket(InternalGeoGridBucket bucket, long hashAsLong, long docCount, InternalAggregations aggregations) {     OrdinalBucket ordBucket = new OrdinalBucket(bucket).     ordBucket.hashAsLong = hashAsLong.     ordBucket.docCount = docCount.     ordBucket.aggregations = aggregations.     // or it may be rebuilding from a new calculation, and therefore copying bucketOrd.     if (bucket instanceof OrdinalBucket) {         ordBucket.bucketOrd = ((OrdinalBucket) bucket).bucketOrd.     }     return ordBucket. }
false;public;0;4;;@Override public Object getKey() {     return sourceBucket.getKey(). }
false;public;0;4;;@Override public String getKeyAsString() {     return sourceBucket.getKeyAsString(). }
false;abstract;5;2;;abstract T buildAggregation(String name, int requiredSize, List<InternalGeoGridBucket> buckets, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData).
true;abstract;0;1;/**  * This method is used to return a re-usable instance of the bucket when building  * the aggregation.  * @return a new {@link InternalGeoGridBucket} implementation with empty parameters  */ ;/**  * This method is used to return a re-usable instance of the bucket when building  * the aggregation.  * @return a new {@link InternalGeoGridBucket} implementation with empty parameters  */ abstract InternalGeoGridBucket newEmptyBucket().
false;public;1;29;;@Override public InternalGeoGrid buildAggregation(long owningBucketOrdinal) throws IOException {     assert owningBucketOrdinal == 0.     final int size = (int) Math.min(bucketOrds.size(), shardSize).     consumeBucketsAndMaybeBreak(size).     BucketPriorityQueue ordered = new BucketPriorityQueue(size).     OrdinalBucket spare = null.     for (long i = 0. i < bucketOrds.size(). i++) {         if (spare == null) {             spare = new OrdinalBucket(newEmptyBucket()).         }         // need a special function to keep the source bucket         // up-to-date so it can get the appropriate key         spare.hashAsLong(bucketOrds.get(i)).         spare.docCount = bucketDocCount(i).         spare.bucketOrd = i.         spare = (OrdinalBucket) ordered.insertWithOverflow(spare).     }     final InternalGeoGridBucket[] list = new InternalGeoGridBucket[ordered.size()].     for (int i = ordered.size() - 1. i >= 0. --i) {         final OrdinalBucket bucket = (OrdinalBucket) ordered.pop().         bucket.aggregations = bucketAggregations(bucket.bucketOrd).         list[i] = bucket.     }     return buildAggregation(name, requiredSize, Arrays.asList(list), pipelineAggregators(), metaData()). }
false;public;0;4;;@Override public InternalGeoGrid buildEmptyAggregation() {     return buildAggregation(name, requiredSize, Collections.emptyList(), pipelineAggregators(), metaData()). }
false;public;0;4;;@Override public void doClose() {     Releasables.close(bucketOrds). }
