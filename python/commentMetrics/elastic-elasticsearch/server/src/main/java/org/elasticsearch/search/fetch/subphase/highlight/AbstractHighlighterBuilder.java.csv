commented;modifiers;parameterAmount;loc;comment;code
true;public,final;1;38;/**  * write common parameters to {@link StreamOutput}  */ ;/**  * write common parameters to {@link StreamOutput}  */ @Override public final void writeTo(StreamOutput out) throws IOException {     out.writeOptionalStringArray(preTags).     out.writeOptionalStringArray(postTags).     out.writeOptionalVInt(fragmentSize).     out.writeOptionalVInt(numOfFragments).     out.writeOptionalString(highlighterType).     out.writeOptionalString(fragmenter).     boolean hasQuery = highlightQuery != null.     out.writeBoolean(hasQuery).     if (hasQuery) {         out.writeNamedWriteable(highlightQuery).     }     out.writeOptionalWriteable(order).     out.writeOptionalBoolean(highlightFilter).     out.writeOptionalBoolean(forceSource).     out.writeOptionalWriteable(boundaryScannerType).     out.writeOptionalVInt(boundaryMaxScan).     boolean hasBounaryChars = boundaryChars != null.     out.writeBoolean(hasBounaryChars).     if (hasBounaryChars) {         out.writeString(String.valueOf(boundaryChars)).     }     boolean hasBoundaryScannerLocale = boundaryScannerLocale != null.     out.writeBoolean(hasBoundaryScannerLocale).     if (hasBoundaryScannerLocale) {         out.writeString(boundaryScannerLocale.toLanguageTag()).     }     out.writeOptionalVInt(noMatchSize).     out.writeOptionalVInt(phraseLimit).     boolean hasOptions = options != null.     out.writeBoolean(hasOptions).     if (hasOptions) {         out.writeMap(options).     }     out.writeOptionalBoolean(requireFieldMatch).     doWriteTo(out). }
false;protected,abstract;1;1;;protected abstract void doWriteTo(StreamOutput out) throws IOException.
true;public;1;5;/**  * Set the pre tags that will be used for highlighting.  */ ;/**  * Set the pre tags that will be used for highlighting.  */ @SuppressWarnings("unchecked") public HB preTags(String... preTags) {     this.preTags = preTags.     return (HB) this. }
true;public;0;3;/**  * @return the value set by {@link #preTags(String...)}  */ ;/**  * @return the value set by {@link #preTags(String...)}  */ public String[] preTags() {     return this.preTags. }
true;public;1;5;/**  * Set the post tags that will be used for highlighting.  */ ;/**  * Set the post tags that will be used for highlighting.  */ @SuppressWarnings("unchecked") public HB postTags(String... postTags) {     this.postTags = postTags.     return (HB) this. }
true;public;0;3;/**  * @return the value set by {@link #postTags(String...)}  */ ;/**  * @return the value set by {@link #postTags(String...)}  */ public String[] postTags() {     return this.postTags. }
true;public;1;5;/**  * Set the fragment size in characters, defaults to {@link HighlightBuilder#DEFAULT_FRAGMENT_CHAR_SIZE}  */ ;/**  * Set the fragment size in characters, defaults to {@link HighlightBuilder#DEFAULT_FRAGMENT_CHAR_SIZE}  */ @SuppressWarnings("unchecked") public HB fragmentSize(Integer fragmentSize) {     this.fragmentSize = fragmentSize.     return (HB) this. }
true;public;0;3;/**  * @return the value set by {@link #fragmentSize(Integer)}  */ ;/**  * @return the value set by {@link #fragmentSize(Integer)}  */ public Integer fragmentSize() {     return this.fragmentSize. }
true;public;1;5;/**  * Set the number of fragments, defaults to {@link HighlightBuilder#DEFAULT_NUMBER_OF_FRAGMENTS}  */ ;/**  * Set the number of fragments, defaults to {@link HighlightBuilder#DEFAULT_NUMBER_OF_FRAGMENTS}  */ @SuppressWarnings("unchecked") public HB numOfFragments(Integer numOfFragments) {     this.numOfFragments = numOfFragments.     return (HB) this. }
true;public;0;3;/**  * @return the value set by {@link #numOfFragments(Integer)}  */ ;/**  * @return the value set by {@link #numOfFragments(Integer)}  */ public Integer numOfFragments() {     return this.numOfFragments. }
true;public;1;5;/**  * Set type of highlighter to use. Out of the box supported types  * are {@code unified}, {@code plain} and {@code fvj}.  * Defaults to {@code unified}.  * Details of the different highlighter types are covered in the reference guide.  */ ;/**  * Set type of highlighter to use. Out of the box supported types  * are {@code unified}, {@code plain} and {@code fvj}.  * Defaults to {@code unified}.  * Details of the different highlighter types are covered in the reference guide.  */ @SuppressWarnings("unchecked") public HB highlighterType(String highlighterType) {     this.highlighterType = highlighterType.     return (HB) this. }
true;public;0;3;/**  * @return the value set by {@link #highlighterType(String)}  */ ;/**  * @return the value set by {@link #highlighterType(String)}  */ public String highlighterType() {     return this.highlighterType. }
true;public;1;5;/**  * Sets what fragmenter to use to break up text that is eligible for highlighting.  * This option is only applicable when using the plain highlighterType {@code highlighter}.  * Permitted values are "simple" or "span" relating to {@link SimpleFragmenter} and  * {@link SimpleSpanFragmenter} implementations respectively with the default being "span"  */ ;/**  * Sets what fragmenter to use to break up text that is eligible for highlighting.  * This option is only applicable when using the plain highlighterType {@code highlighter}.  * Permitted values are "simple" or "span" relating to {@link SimpleFragmenter} and  * {@link SimpleSpanFragmenter} implementations respectively with the default being "span"  */ @SuppressWarnings("unchecked") public HB fragmenter(String fragmenter) {     this.fragmenter = fragmenter.     return (HB) this. }
true;public;0;3;/**  * @return the value set by {@link #fragmenter(String)}  */ ;/**  * @return the value set by {@link #fragmenter(String)}  */ public String fragmenter() {     return this.fragmenter. }
true;public;1;5;/**  * Sets a query to be used for highlighting instead of the search query.  */ ;/**  * Sets a query to be used for highlighting instead of the search query.  */ @SuppressWarnings("unchecked") public HB highlightQuery(QueryBuilder highlightQuery) {     this.highlightQuery = highlightQuery.     return (HB) this. }
true;public;0;3;/**  * @return the value set by {@link #highlightQuery(QueryBuilder)}  */ ;/**  * @return the value set by {@link #highlightQuery(QueryBuilder)}  */ public QueryBuilder highlightQuery() {     return this.highlightQuery. }
true;public;1;3;/**  * The order of fragments per field. By default, ordered by the order in the  * highlighted text. Can be {@code score}, which then it will be ordered  * by score of the fragments, or {@code none}.  */ ;/**  * The order of fragments per field. By default, ordered by the order in the  * highlighted text. Can be {@code score}, which then it will be ordered  * by score of the fragments, or {@code none}.  */ public HB order(String order) {     return order(Order.fromString(order)). }
true;public;1;5;/**  * By default, fragments of a field are ordered by the order in the highlighted text.  * If set to {@link Order#SCORE}, this changes order to score of the fragments.  */ ;/**  * By default, fragments of a field are ordered by the order in the highlighted text.  * If set to {@link Order#SCORE}, this changes order to score of the fragments.  */ @SuppressWarnings("unchecked") public HB order(Order scoreOrdered) {     this.order = scoreOrdered.     return (HB) this. }
true;public;0;3;/**  * @return the value set by {@link #order(Order)}  */ ;/**  * @return the value set by {@link #order(Order)}  */ public Order order() {     return this.order. }
true;public;1;5;/**  * Set this to true when using the highlighterType {@code fvh}  * and you want to provide highlighting on filter clauses in your  * query. Default is {@code false}.  */ ;/**  * Set this to true when using the highlighterType {@code fvh}  * and you want to provide highlighting on filter clauses in your  * query. Default is {@code false}.  */ @SuppressWarnings("unchecked") public HB highlightFilter(Boolean highlightFilter) {     this.highlightFilter = highlightFilter.     return (HB) this. }
true;public;0;3;/**  * @return the value set by {@link #highlightFilter(Boolean)}  */ ;/**  * @return the value set by {@link #highlightFilter(Boolean)}  */ public Boolean highlightFilter() {     return this.highlightFilter. }
true;public;1;5;/**  * When using the highlighterType {@code fvh} this setting  * controls which scanner to use for fragment boundaries, and defaults to "simple".  */ ;/**  * When using the highlighterType {@code fvh} this setting  * controls which scanner to use for fragment boundaries, and defaults to "simple".  */ @SuppressWarnings("unchecked") public HB boundaryScannerType(String boundaryScannerType) {     this.boundaryScannerType = BoundaryScannerType.fromString(boundaryScannerType).     return (HB) this. }
true;public;1;5;/**  * When using the highlighterType {@code fvh} this setting  * controls which scanner to use for fragment boundaries, and defaults to "simple".  */ ;/**  * When using the highlighterType {@code fvh} this setting  * controls which scanner to use for fragment boundaries, and defaults to "simple".  */ @SuppressWarnings("unchecked") public HB boundaryScannerType(BoundaryScannerType boundaryScannerType) {     this.boundaryScannerType = boundaryScannerType.     return (HB) this. }
true;public;0;3;/**  * @return the value set by {@link #boundaryScannerType(String)}  */ ;/**  * @return the value set by {@link #boundaryScannerType(String)}  */ public BoundaryScannerType boundaryScannerType() {     return this.boundaryScannerType. }
true;public;1;5;/**  * When using the highlighterType {@code fvh} this setting  * controls how far to look for boundary characters, and defaults to 20.  */ ;/**  * When using the highlighterType {@code fvh} this setting  * controls how far to look for boundary characters, and defaults to 20.  */ @SuppressWarnings("unchecked") public HB boundaryMaxScan(Integer boundaryMaxScan) {     this.boundaryMaxScan = boundaryMaxScan.     return (HB) this. }
true;public;0;3;/**  * @return the value set by {@link #boundaryMaxScan(Integer)}  */ ;/**  * @return the value set by {@link #boundaryMaxScan(Integer)}  */ public Integer boundaryMaxScan() {     return this.boundaryMaxScan. }
true;public;1;5;/**  * When using the highlighterType {@code fvh} this setting  * defines what constitutes a boundary for highlighting. It’s a single string with  * each boundary character defined in it. It defaults to .,!? \t\n  */ ;/**  * When using the highlighterType {@code fvh} this setting  * defines what constitutes a boundary for highlighting. It’s a single string with  * each boundary character defined in it. It defaults to .,!? \t\n  */ @SuppressWarnings("unchecked") public HB boundaryChars(char[] boundaryChars) {     this.boundaryChars = boundaryChars.     return (HB) this. }
true;public;0;3;/**  * @return the value set by {@link #boundaryChars(char[])}  */ ;/**  * @return the value set by {@link #boundaryChars(char[])}  */ public char[] boundaryChars() {     return this.boundaryChars. }
true;public;1;7;/**  * When using the highlighterType {@code fvh} and boundaryScannerType {@code break_iterator}, this setting  * controls the locale to use by the BreakIterator, defaults to "root".  */ ;/**  * When using the highlighterType {@code fvh} and boundaryScannerType {@code break_iterator}, this setting  * controls the locale to use by the BreakIterator, defaults to "root".  */ @SuppressWarnings("unchecked") public HB boundaryScannerLocale(String boundaryScannerLocale) {     if (boundaryScannerLocale != null) {         this.boundaryScannerLocale = Locale.forLanguageTag(boundaryScannerLocale).     }     return (HB) this. }
true;public;0;3;/**  * @return the value set by {@link #boundaryScannerLocale(String)}  */ ;/**  * @return the value set by {@link #boundaryScannerLocale(String)}  */ public Locale boundaryScannerLocale() {     return this.boundaryScannerLocale. }
true;public;1;5;/**  * Allows to set custom options for custom highlighters.  */ ;/**  * Allows to set custom options for custom highlighters.  */ @SuppressWarnings("unchecked") public HB options(Map<String, Object> options) {     this.options = options.     return (HB) this. }
true;public;0;3;/**  * @return the value set by {@link #options(Map)}  */ ;/**  * @return the value set by {@link #options(Map)}  */ public Map<String, Object> options() {     return this.options. }
true;public;1;5;/**  * Set to true to cause a field to be highlighted only if a query matches that field.  * Default is false meaning that terms are highlighted on all requested fields regardless  * if the query matches specifically on them.  */ ;/**  * Set to true to cause a field to be highlighted only if a query matches that field.  * Default is false meaning that terms are highlighted on all requested fields regardless  * if the query matches specifically on them.  */ @SuppressWarnings("unchecked") public HB requireFieldMatch(Boolean requireFieldMatch) {     this.requireFieldMatch = requireFieldMatch.     return (HB) this. }
true;public;0;3;/**  * @return the value set by {@link #requireFieldMatch(Boolean)}  */ ;/**  * @return the value set by {@link #requireFieldMatch(Boolean)}  */ public Boolean requireFieldMatch() {     return this.requireFieldMatch. }
true;public;1;5;/**  * Sets the size of the fragment to return from the beginning of the field if there are no matches to  * highlight and the field doesn't also define noMatchSize.  * @param noMatchSize integer to set or null to leave out of request.  default is null.  * @return this for chaining  */ ;/**  * Sets the size of the fragment to return from the beginning of the field if there are no matches to  * highlight and the field doesn't also define noMatchSize.  * @param noMatchSize integer to set or null to leave out of request.  default is null.  * @return this for chaining  */ @SuppressWarnings("unchecked") public HB noMatchSize(Integer noMatchSize) {     this.noMatchSize = noMatchSize.     return (HB) this. }
true;public;0;3;/**  * @return the value set by {@link #noMatchSize(Integer)}  */ ;/**  * @return the value set by {@link #noMatchSize(Integer)}  */ public Integer noMatchSize() {     return this.noMatchSize. }
true;public;1;5;/**  * Sets the maximum number of phrases the fvh will consider if the field doesn't also define phraseLimit.  * @param phraseLimit maximum number of phrases the fvh will consider  * @return this for chaining  */ ;/**  * Sets the maximum number of phrases the fvh will consider if the field doesn't also define phraseLimit.  * @param phraseLimit maximum number of phrases the fvh will consider  * @return this for chaining  */ @SuppressWarnings("unchecked") public HB phraseLimit(Integer phraseLimit) {     this.phraseLimit = phraseLimit.     return (HB) this. }
true;public;0;3;/**  * @return the value set by {@link #phraseLimit(Integer)}  */ ;/**  * @return the value set by {@link #phraseLimit(Integer)}  */ public Integer phraseLimit() {     return this.phraseLimit. }
true;public;1;5;/**  * Forces the highlighting to highlight fields based on the source even if fields are stored separately.  */ ;/**  * Forces the highlighting to highlight fields based on the source even if fields are stored separately.  */ @SuppressWarnings("unchecked") public HB forceSource(Boolean forceSource) {     this.forceSource = forceSource.     return (HB) this. }
true;public;0;3;/**  * @return the value set by {@link #forceSource(Boolean)}  */ ;/**  * @return the value set by {@link #forceSource(Boolean)}  */ public Boolean forceSource() {     return this.forceSource. }
false;public;2;7;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     innerXContent(builder).     builder.endObject().     return builder. }
false;protected,abstract;1;1;;protected abstract void innerXContent(XContentBuilder builder) throws IOException.
false;;1;56;;void commonOptionsToXContent(XContentBuilder builder) throws IOException {     if (preTags != null) {         builder.array(PRE_TAGS_FIELD.getPreferredName(), preTags).     }     if (postTags != null) {         builder.array(POST_TAGS_FIELD.getPreferredName(), postTags).     }     if (fragmentSize != null) {         builder.field(FRAGMENT_SIZE_FIELD.getPreferredName(), fragmentSize).     }     if (numOfFragments != null) {         builder.field(NUMBER_OF_FRAGMENTS_FIELD.getPreferredName(), numOfFragments).     }     if (highlighterType != null) {         builder.field(TYPE_FIELD.getPreferredName(), highlighterType).     }     if (fragmenter != null) {         builder.field(FRAGMENTER_FIELD.getPreferredName(), fragmenter).     }     if (highlightQuery != null) {         builder.field(HIGHLIGHT_QUERY_FIELD.getPreferredName(), highlightQuery).     }     if (order != null) {         builder.field(ORDER_FIELD.getPreferredName(), order.toString()).     }     if (highlightFilter != null) {         builder.field(HIGHLIGHT_FILTER_FIELD.getPreferredName(), highlightFilter).     }     if (boundaryScannerType != null) {         builder.field(BOUNDARY_SCANNER_FIELD.getPreferredName(), boundaryScannerType.name()).     }     if (boundaryMaxScan != null) {         builder.field(BOUNDARY_MAX_SCAN_FIELD.getPreferredName(), boundaryMaxScan).     }     if (boundaryChars != null) {         builder.field(BOUNDARY_CHARS_FIELD.getPreferredName(), new String(boundaryChars)).     }     if (boundaryScannerLocale != null) {         builder.field(BOUNDARY_SCANNER_LOCALE_FIELD.getPreferredName(), boundaryScannerLocale.toLanguageTag()).     }     if (options != null && options.size() > 0) {         builder.field(OPTIONS_FIELD.getPreferredName(), options).     }     if (forceSource != null) {         builder.field(FORCE_SOURCE_FIELD.getPreferredName(), forceSource).     }     if (requireFieldMatch != null) {         builder.field(REQUIRE_FIELD_MATCH_FIELD.getPreferredName(), requireFieldMatch).     }     if (noMatchSize != null) {         builder.field(NO_MATCH_SIZE_FIELD.getPreferredName(), noMatchSize).     }     if (phraseLimit != null) {         builder.field(PHRASE_LIMIT_FIELD.getPreferredName(), phraseLimit).     } }
false;static;1;45;;static <HB extends AbstractHighlighterBuilder<HB>> BiFunction<XContentParser, HB, HB> setupParser(ObjectParser<HB, Void> parser) {     parser.declareStringArray(fromList(String.class, HB::preTags), PRE_TAGS_FIELD).     parser.declareStringArray(fromList(String.class, HB::postTags), POST_TAGS_FIELD).     parser.declareString(HB::order, ORDER_FIELD).     parser.declareBoolean(HB::highlightFilter, HIGHLIGHT_FILTER_FIELD).     parser.declareInt(HB::fragmentSize, FRAGMENT_SIZE_FIELD).     parser.declareInt(HB::numOfFragments, NUMBER_OF_FRAGMENTS_FIELD).     parser.declareBoolean(HB::requireFieldMatch, REQUIRE_FIELD_MATCH_FIELD).     parser.declareString(HB::boundaryScannerType, BOUNDARY_SCANNER_FIELD).     parser.declareInt(HB::boundaryMaxScan, BOUNDARY_MAX_SCAN_FIELD).     parser.declareString((HB hb, String bc) -> hb.boundaryChars(bc.toCharArray()), BOUNDARY_CHARS_FIELD).     parser.declareString(HB::boundaryScannerLocale, BOUNDARY_SCANNER_LOCALE_FIELD).     parser.declareString(HB::highlighterType, TYPE_FIELD).     parser.declareString(HB::fragmenter, FRAGMENTER_FIELD).     parser.declareInt(HB::noMatchSize, NO_MATCH_SIZE_FIELD).     parser.declareBoolean(HB::forceSource, FORCE_SOURCE_FIELD).     parser.declareInt(HB::phraseLimit, PHRASE_LIMIT_FIELD).     parser.declareObject(HB::options, (XContentParser p, Void c) -> {         try {             return p.map().         } catch (IOException e) {             throw new RuntimeException("Error parsing options", e).         }     }, OPTIONS_FIELD).     parser.declareObject(HB::highlightQuery, (XContentParser p, Void c) -> {         try {             return parseInnerQueryBuilder(p).         } catch (IOException e) {             throw new RuntimeException("Error parsing query", e).         }     }, HIGHLIGHT_QUERY_FIELD).     return (XContentParser p, HB hb) -> {         try {             parser.parse(p, hb, null).             if (hb.preTags() != null && hb.postTags() == null) {                 throw new ParsingException(p.getTokenLocation(), "pre_tags are set but post_tags are not set").             }         } catch (IOException e) {             throw new RuntimeException(e).         }         return hb.     }. }
false;public,final;0;7;;@Override public final int hashCode() {     return Objects.hash(getClass(), Arrays.hashCode(preTags), Arrays.hashCode(postTags), fragmentSize, numOfFragments, highlighterType, fragmenter, highlightQuery, order, highlightFilter, forceSource, boundaryScannerType, boundaryMaxScan, Arrays.hashCode(boundaryChars), boundaryScannerLocale, noMatchSize, phraseLimit, options, requireFieldMatch, doHashCode()). }
true;protected,abstract;0;1;/**  * fields only present in subclass should contribute to hashCode in the implementation  */ ;/**  * fields only present in subclass should contribute to hashCode in the implementation  */ protected abstract int doHashCode().
false;public,final;1;30;;@Override public final boolean equals(Object obj) {     if (this == obj) {         return true.     }     if (obj == null || getClass() != obj.getClass()) {         return false.     }     @SuppressWarnings("unchecked")     HB other = (HB) obj.     return Arrays.equals(preTags, other.preTags) && Arrays.equals(postTags, other.postTags) && Objects.equals(fragmentSize, other.fragmentSize) && Objects.equals(numOfFragments, other.numOfFragments) && Objects.equals(highlighterType, other.highlighterType) && Objects.equals(fragmenter, other.fragmenter) && Objects.equals(highlightQuery, other.highlightQuery) && Objects.equals(order, other.order) && Objects.equals(highlightFilter, other.highlightFilter) && Objects.equals(forceSource, other.forceSource) && Objects.equals(boundaryScannerType, other.boundaryScannerType) && Objects.equals(boundaryMaxScan, other.boundaryMaxScan) && Arrays.equals(boundaryChars, other.boundaryChars) && Objects.equals(boundaryScannerLocale, other.boundaryScannerLocale) && Objects.equals(noMatchSize, other.noMatchSize) && Objects.equals(phraseLimit, other.phraseLimit) && Objects.equals(options, other.options) && Objects.equals(requireFieldMatch, other.requireFieldMatch) && doEquals(other). }
true;protected,abstract;1;1;/**  * fields only present in subclass should be checked for equality in the implementation  */ ;/**  * fields only present in subclass should be checked for equality in the implementation  */ protected abstract boolean doEquals(HB other).
false;public;0;4;;@Override public String toString() {     return Strings.toString(this, true, true). }
