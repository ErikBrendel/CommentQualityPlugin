commented;modifiers;parameterAmount;loc;comment;code
true;public;2;5;/**  * Start the process to schedule repeated election attempts.  *  * @param gracePeriod       An initial period to wait before attempting the first election.  * @param scheduledRunnable The action to run each time an election should be attempted.  */ ;/**  * Start the process to schedule repeated election attempts.  *  * @param gracePeriod       An initial period to wait before attempting the first election.  * @param scheduledRunnable The action to run each time an election should be attempted.  */ public Releasable startElectionScheduler(TimeValue gracePeriod, Runnable scheduledRunnable) {     final ElectionScheduler scheduler = new ElectionScheduler().     scheduler.scheduleNextElection(gracePeriod, scheduledRunnable).     return scheduler. }
false;private,static;1;4;;@SuppressForbidden(reason = "Argument to Math.abs() is definitely not Long.MIN_VALUE") private static long nonNegative(long n) {     return n == Long.MIN_VALUE ? 0 : Math.abs(n). }
true;static;2;4;// package-private for testing ;/**  * @param randomNumber a randomly-chosen long  * @param upperBound   inclusive upper bound  * @return a number in the range (0, upperBound]  */ // package-private for testing static long toPositiveLongAtMost(long randomNumber, long upperBound) {     assert 0 < upperBound : upperBound.     return nonNegative(randomNumber) % upperBound + 1. }
false;public;0;8;;@Override public String toString() {     return "ElectionSchedulerFactory{" + "initialTimeout=" + initialTimeout + ", backoffTime=" + backoffTime + ", maxTimeout=" + maxTimeout + '}'. }
false;public;1;5;;@Override public void onFailure(Exception e) {     logger.debug(new ParameterizedMessage("unexpected exception in wakeup of {}", this), e).     assert false : e. }
false;protected;0;10;;@Override protected void doRun() {     if (isClosed.get()) {         logger.debug("{} not starting election", this).     } else {         logger.debug("{} starting election", this).         scheduleNextElection(duration, scheduledRunnable).         scheduledRunnable.run().     } }
false;public;0;8;;@Override public String toString() {     return "scheduleNextElection{gracePeriod=" + gracePeriod + ", thisAttempt=" + thisAttempt + ", maxDelayMillis=" + maxDelayMillis + ", delayMillis=" + delayMillis + ", " + ElectionScheduler.this + "}". }
false;;2;41;;void scheduleNextElection(final TimeValue gracePeriod, final Runnable scheduledRunnable) {     if (isClosed.get()) {         logger.debug("{} not scheduling election", this).         return.     }     final long thisAttempt = attempt.getAndIncrement().     // to overflow here would take over a million years of failed election attempts, so we won't worry about that:     final long maxDelayMillis = Math.min(maxTimeout.millis(), initialTimeout.millis() + thisAttempt * backoffTime.millis()).     final long delayMillis = toPositiveLongAtMost(random.nextLong(), maxDelayMillis) + gracePeriod.millis().     final Runnable runnable = new AbstractRunnable() {          @Override         public void onFailure(Exception e) {             logger.debug(new ParameterizedMessage("unexpected exception in wakeup of {}", this), e).             assert false : e.         }          @Override         protected void doRun() {             if (isClosed.get()) {                 logger.debug("{} not starting election", this).             } else {                 logger.debug("{} starting election", this).                 scheduleNextElection(duration, scheduledRunnable).                 scheduledRunnable.run().             }         }          @Override         public String toString() {             return "scheduleNextElection{gracePeriod=" + gracePeriod + ", thisAttempt=" + thisAttempt + ", maxDelayMillis=" + maxDelayMillis + ", delayMillis=" + delayMillis + ", " + ElectionScheduler.this + "}".         }     }.     logger.debug("scheduling {}", runnable).     threadPool.scheduleUnlessShuttingDown(TimeValue.timeValueMillis(delayMillis), Names.GENERIC, runnable). }
false;public;0;5;;@Override public String toString() {     return "ElectionScheduler{attempt=" + attempt + ", " + ElectionSchedulerFactory.this + "}". }
false;public;0;5;;@Override public void close() {     boolean wasNotPreviouslyClosed = isClosed.compareAndSet(false, true).     assert wasNotPreviouslyClosed. }
