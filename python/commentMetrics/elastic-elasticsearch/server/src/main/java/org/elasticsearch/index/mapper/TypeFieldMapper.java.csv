commented;modifiers;parameterAmount;loc;comment;code
false;public;3;5;;@Override public MetadataFieldMapper.Builder<?, ?> parse(String name, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {     throw new MapperParsingException(NAME + " is not configurable"). }
false;public;2;5;;@Override public MetadataFieldMapper getDefault(MappedFieldType fieldType, ParserContext context) {     final IndexSettings indexSettings = context.mapperService().getIndexSettings().     return new TypeFieldMapper(indexSettings, fieldType). }
false;public;0;4;;@Override public MappedFieldType clone() {     return new TypeFieldType(this). }
false;public;0;4;;@Override public String typeName() {     return CONTENT_TYPE. }
false;public;1;5;;@Override public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {     Function<MapperService, String> typeFunction = mapperService -> mapperService.documentMapper().type().     return new ConstantIndexFieldData.Builder(typeFunction). }
false;public;0;4;;@Override public boolean isSearchable() {     return true. }
false;public;1;4;;@Override public Query existsQuery(QueryShardContext context) {     return new MatchAllDocsQuery(). }
false;public;2;4;;@Override public Query termQuery(Object value, QueryShardContext context) {     return termsQuery(Arrays.asList(value), context). }
false;public;2;20;;@Override public Query termsQuery(List<?> values, QueryShardContext context) {     DocumentMapper mapper = context.getMapperService().documentMapper().     if (mapper == null) {         return new MatchNoDocsQuery("No types").     }     BytesRef indexType = indexedValueForSearch(mapper.type()).     if (values.stream().map(this::indexedValueForSearch).anyMatch(indexType::equals)) {         if (context.getMapperService().hasNested()) {             // type filters are expected not to match nested docs             return Queries.newNonNestedFilter(context.indexVersionCreated()).         } else {             return new MatchAllDocsQuery().         }     } else {         return new MatchNoDocsQuery("Type list does not contain the index type").     } }
false;public;5;21;;@Override public Query rangeQuery(Object lowerTerm, Object upperTerm, boolean includeLower, boolean includeUpper, QueryShardContext context) {     Query result = new MatchAllDocsQuery().     String type = context.getMapperService().documentMapper().type().     if (type != null) {         BytesRef typeBytes = new BytesRef(type).         if (lowerTerm != null) {             int comp = indexedValueForSearch(lowerTerm).compareTo(typeBytes).             if (comp > 0 || (comp == 0 && includeLower == false)) {                 result = new MatchNoDocsQuery("[_type] was lexicographically smaller than lower bound of range").             }         }         if (upperTerm != null) {             int comp = indexedValueForSearch(upperTerm).compareTo(typeBytes).             if (comp < 0 || (comp == 0 && includeUpper == false)) {                 result = new MatchNoDocsQuery("[_type] was lexicographically greater than upper bound of range").             }         }     }     return result. }
false;public;0;3;;public BytesRef[] getTerms() {     return types. }
false;public;1;31;;@Override public Query rewrite(IndexReader reader) throws IOException {     final int threshold = Math.min(BOOLEAN_REWRITE_TERM_COUNT_THRESHOLD, BooleanQuery.getMaxClauseCount()).     if (types.length <= threshold) {         Set<BytesRef> uniqueTypes = new HashSet<>().         BooleanQuery.Builder bq = new BooleanQuery.Builder().         int totalDocFreq = 0.         for (BytesRef type : types) {             if (uniqueTypes.add(type)) {                 Term term = new Term(CONTENT_TYPE, type).                 TermStates context = TermStates.build(reader.getContext(), term, true).                 if (context.docFreq() == 0) {                     // this _type is not present in the reader                     continue.                 }                 totalDocFreq += context.docFreq().                 // strict equality should be enough ?                 if (totalDocFreq >= reader.maxDoc()) {                     assert totalDocFreq == reader.maxDoc().                     // For instance, match_all queries as filter clauses are automatically removed                     return new MatchAllDocsQuery().                 }                 bq.add(new TermQuery(term, context), BooleanClause.Occur.SHOULD).             }         }         return new ConstantScoreQuery(bq.build()).     }     return new TermInSetQuery(CONTENT_TYPE, types). }
false;public;1;8;;@Override public boolean equals(Object obj) {     if (sameClassAs(obj) == false) {         return false.     }     TypesQuery that = (TypesQuery) obj.     return Arrays.equals(types, that.types). }
false;public;0;4;;@Override public int hashCode() {     return 31 * classHash() + Arrays.hashCode(types). }
false;public;1;11;;@Override public String toString(String field) {     StringBuilder builder = new StringBuilder().     for (BytesRef type : types) {         if (builder.length() > 0) {             builder.append(' ').         }         builder.append(new Term(CONTENT_TYPE, type).toString()).     }     return builder.toString(). }
false;private,static;1;6;;private static MappedFieldType defaultFieldType(IndexSettings indexSettings) {     MappedFieldType defaultFieldType = Defaults.FIELD_TYPE.clone().     defaultFieldType.setIndexOptions(IndexOptions.NONE).     defaultFieldType.setHasDocValues(false).     return defaultFieldType. }
false;public;1;4;;@Override public void preParse(ParseContext context) throws IOException {     super.parse(context). }
false;public;1;4;;@Override public void parse(ParseContext context) throws IOException { // we parse in pre parse }
false;protected;2;10;;@Override protected void parseCreateField(ParseContext context, List<IndexableField> fields) throws IOException {     if (fieldType().indexOptions() == IndexOptions.NONE && !fieldType().stored()) {         return.     }     fields.add(new Field(fieldType().name(), context.sourceToParse().type(), fieldType())).     if (fieldType().hasDocValues()) {         fields.add(new SortedSetDocValuesField(fieldType().name(), new BytesRef(context.sourceToParse().type()))).     } }
false;protected;0;4;;@Override protected String contentType() {     return CONTENT_TYPE. }
false;public;2;4;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     return builder. }
false;protected;1;4;;@Override protected void doMerge(Mapper mergeWith) { // do nothing here, no merging, but also no exception }
