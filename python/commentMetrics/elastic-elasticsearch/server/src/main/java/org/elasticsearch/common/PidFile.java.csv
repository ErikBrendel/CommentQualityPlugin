commented;modifiers;parameterAmount;loc;comment;code
true;public,static;2;3;/**  * Creates a new PidFile and writes the current process ID into the provided path  *  * @param path the path to the pid file. The file is newly created or truncated if it already exists  * @param deleteOnExit if <code>true</code> the pid file is deleted with best effort on system exit  * @throws IOException if an IOException occurs  */ ;/**  * Creates a new PidFile and writes the current process ID into the provided path  *  * @param path the path to the pid file. The file is newly created or truncated if it already exists  * @param deleteOnExit if <code>true</code> the pid file is deleted with best effort on system exit  * @throws IOException if an IOException occurs  */ public static PidFile create(Path path, boolean deleteOnExit) throws IOException {     return create(path, deleteOnExit, JvmInfo.jvmInfo().pid()). }
false;static;3;27;;static PidFile create(Path path, boolean deleteOnExit, long pid) throws IOException {     Path parent = path.getParent().     if (parent != null) {         if (Files.exists(parent) && Files.isDirectory(parent) == false) {             throw new IllegalArgumentException(parent + " exists but is not a directory").         }         if (Files.exists(parent) == false) {             // only do this if it doesn't exists we get a better exception further down             // if there are security issues etc. this also doesn't work if the parent exists             // and is a soft-link like on many linux systems /var/run can be a link and that should             // not prevent us from writing the PID             Files.createDirectories(parent).         }     }     if (Files.exists(path) && Files.isRegularFile(path) == false) {         throw new IllegalArgumentException(path + " exists but is not a regular file").     }     try (OutputStream stream = Files.newOutputStream(path, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {         stream.write(Long.toString(pid).getBytes(StandardCharsets.UTF_8)).     }     if (deleteOnExit) {         addShutdownHook(path).     }     return new PidFile(path, deleteOnExit, pid). }
true;public;0;3;/**  * Returns the current process id  */ ;/**  * Returns the current process id  */ public long getPid() {     return pid. }
true;public;0;3;/**  * Returns the process id file path  */ ;/**  * Returns the process id file path  */ public Path getPath() {     return path. }
true;public;0;3;/**  * Returns <code>true</code> iff the process id file is deleted on system exit. Otherwise <code>false</code>.  */ ;/**  * Returns <code>true</code> iff the process id file is deleted on system exit. Otherwise <code>false</code>.  */ public boolean isDeleteOnExit() {     return deleteOnExit. }
false;public;0;8;;@Override public void run() {     try {         Files.deleteIfExists(path).     } catch (IOException e) {         throw new ElasticsearchException("Failed to delete pid file " + path, e).     } }
false;private,static;1;12;;private static void addShutdownHook(final Path path) {     Runtime.getRuntime().addShutdownHook(new Thread() {          @Override         public void run() {             try {                 Files.deleteIfExists(path).             } catch (IOException e) {                 throw new ElasticsearchException("Failed to delete pid file " + path, e).             }         }     }). }
