commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public Lifecycle.State lifecycleState() {     return this.lifecycle.state(). }
false;public;1;4;;@Override public void addLifecycleListener(LifecycleListener listener) {     listeners.add(listener). }
false;public;1;4;;@Override public void removeLifecycleListener(LifecycleListener listener) {     listeners.remove(listener). }
false;public;0;14;;@Override public void start() {     if (!lifecycle.canMoveToStarted()) {         return.     }     for (LifecycleListener listener : listeners) {         listener.beforeStart().     }     doStart().     lifecycle.moveToStarted().     for (LifecycleListener listener : listeners) {         listener.afterStart().     } }
false;protected,abstract;0;1;;protected abstract void doStart().
false;public;0;14;;@Override public void stop() {     if (!lifecycle.canMoveToStopped()) {         return.     }     for (LifecycleListener listener : listeners) {         listener.beforeStop().     }     lifecycle.moveToStopped().     doStop().     for (LifecycleListener listener : listeners) {         listener.afterStop().     } }
false;protected,abstract;0;1;;protected abstract void doStop().
false;public;0;23;;@Override public void close() {     if (lifecycle.started()) {         stop().     }     if (!lifecycle.canMoveToClosed()) {         return.     }     for (LifecycleListener listener : listeners) {         listener.beforeClose().     }     lifecycle.moveToClosed().     try {         doClose().     } catch (IOException e) {         // TODO: we need to separate out closing (ie shutting down) services, vs releasing runtime transient         // structures. Shutting down services should use IOUtils.close         logger.warn("failed to close " + getClass().getName(), e).     }     for (LifecycleListener listener : listeners) {         listener.afterClose().     } }
false;protected,abstract;0;1;;protected abstract void doClose() throws IOException.
