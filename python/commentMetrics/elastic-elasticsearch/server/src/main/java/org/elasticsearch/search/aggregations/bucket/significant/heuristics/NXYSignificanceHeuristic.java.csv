commented;modifiers;parameterAmount;loc;comment;code
false;public;1;5;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeBoolean(includeNegatives).     out.writeBoolean(backgroundIsSuperset). }
false;public;1;15;;@Override public boolean equals(Object obj) {     if (this == obj)         return true.     if (obj == null)         return false.     if (getClass() != obj.getClass())         return false.     NXYSignificanceHeuristic other = (NXYSignificanceHeuristic) obj.     if (backgroundIsSuperset != other.backgroundIsSuperset)         return false.     if (includeNegatives != other.includeNegatives)         return false.     return true. }
false;public;0;6;;@Override public int hashCode() {     int result = (includeNegatives ? 1 : 0).     result = 31 * result + (backgroundIsSuperset ? 1 : 0).     return result. }
false;protected;5;44;;protected Frequencies computeNxys(long subsetFreq, long subsetSize, long supersetFreq, long supersetSize, String scoreFunctionName) {     checkFrequencies(subsetFreq, subsetSize, supersetFreq, supersetSize, scoreFunctionName).     Frequencies frequencies = new Frequencies().     if (backgroundIsSuperset) {         // documents not in class and do not contain term         frequencies.N00 = supersetSize - supersetFreq - (subsetSize - subsetFreq).         // documents in class and do not contain term         frequencies.N01 = (subsetSize - subsetFreq).         // documents not in class and do contain term         frequencies.N10 = supersetFreq - subsetFreq.         // documents in class and do contain term         frequencies.N11 = subsetFreq.         // documents that do not contain term         frequencies.N0_ = supersetSize - supersetFreq.         // documents that contain term         frequencies.N1_ = supersetFreq.         // documents that are not in class         frequencies.N_0 = supersetSize - subsetSize.         // documents that are in class         frequencies.N_1 = subsetSize.         // all docs         frequencies.N = supersetSize.     } else {         // documents not in class and do not contain term         frequencies.N00 = supersetSize - supersetFreq.         // documents in class and do not contain term         frequencies.N01 = subsetSize - subsetFreq.         // documents not in class and do contain term         frequencies.N10 = supersetFreq.         // documents in class and do contain term         frequencies.N11 = subsetFreq.         // documents that do not contain term         frequencies.N0_ = supersetSize - supersetFreq + subsetSize - subsetFreq.         // documents that contain term         frequencies.N1_ = supersetFreq + subsetFreq.         // documents that are not in class         frequencies.N_0 = supersetSize.         // documents that are in class         frequencies.N_1 = subsetSize.         // all docs         frequencies.N = supersetSize + subsetSize.     }     return frequencies. }
false;protected;5;14;;protected void checkFrequencies(long subsetFreq, long subsetSize, long supersetFreq, long supersetSize, String scoreFunctionName) {     checkFrequencyValidity(subsetFreq, subsetSize, supersetFreq, supersetSize, scoreFunctionName).     if (backgroundIsSuperset) {         if (subsetFreq > supersetFreq) {             throw new IllegalArgumentException("subsetFreq > supersetFreq" + SCORE_ERROR_MESSAGE).         }         if (subsetSize > supersetSize) {             throw new IllegalArgumentException("subsetSize > supersetSize" + SCORE_ERROR_MESSAGE).         }         if (supersetFreq - subsetFreq > supersetSize - subsetSize) {             throw new IllegalArgumentException("supersetFreq - subsetFreq > supersetSize - subsetSize" + SCORE_ERROR_MESSAGE).         }     } }
false;protected;1;4;;protected void build(XContentBuilder builder) throws IOException {     builder.field(INCLUDE_NEGATIVES_FIELD.getPreferredName(), includeNegatives).field(BACKGROUND_IS_SUPERSET.getPreferredName(), backgroundIsSuperset). }
false;public;1;22;;@Override public SignificanceHeuristic parse(XContentParser parser) throws IOException, QueryShardException {     String givenName = parser.currentName().     boolean includeNegatives = false.     boolean backgroundIsSuperset = true.     XContentParser.Token token = parser.nextToken().     while (!token.equals(XContentParser.Token.END_OBJECT)) {         if (INCLUDE_NEGATIVES_FIELD.match(parser.currentName(), parser.getDeprecationHandler())) {             parser.nextToken().             includeNegatives = parser.booleanValue().         } else if (BACKGROUND_IS_SUPERSET.match(parser.currentName(), parser.getDeprecationHandler())) {             parser.nextToken().             backgroundIsSuperset = parser.booleanValue().         } else {             throw new ElasticsearchParseException("failed to parse [{}] significance heuristic. unknown field [{}]", givenName, parser.currentName()).         }         token = parser.nextToken().     }     return newHeuristic(includeNegatives, backgroundIsSuperset). }
false;protected,abstract;2;1;;protected abstract SignificanceHeuristic newHeuristic(boolean includeNegatives, boolean backgroundIsSuperset).
false;protected;1;4;;protected void build(XContentBuilder builder) throws IOException {     builder.field(INCLUDE_NEGATIVES_FIELD.getPreferredName(), includeNegatives).field(BACKGROUND_IS_SUPERSET.getPreferredName(), backgroundIsSuperset). }
