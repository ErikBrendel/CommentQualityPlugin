# id;timestamp;commentText;codeText;commentWords;codeWords
CoordinationState -> public Optional<ApplyCommitRequest> handlePublishResponse(DiscoveryNode sourceNode, PublishResponse publishResponse);1544081506;May be called on receipt of a PublishResponse from the given sourceNode.__@param sourceNode      The sender of the PublishResponse received._@param publishResponse The PublishResponse received._@return An optional ApplyCommitRequest which, if present, may be broadcast to all peers, indicating that this publication_has been accepted at a quorum of peers and is therefore committed._@throws CoordinationStateRejectedException if the arguments were incompatible with the current state of this object.;public Optional<ApplyCommitRequest> handlePublishResponse(DiscoveryNode sourceNode, PublishResponse publishResponse) {_        if (electionWon == false) {_            logger.debug("handlePublishResponse: ignored response as election not won")__            throw new CoordinationStateRejectedException("election not won")__        }_        if (publishResponse.getTerm() != getCurrentTerm()) {_            logger.debug("handlePublishResponse: ignored publish response due to term mismatch (expected: [{}], actual: [{}])",_                getCurrentTerm(), publishResponse.getTerm())__            throw new CoordinationStateRejectedException("incoming term " + publishResponse.getTerm()_                + " does not match current term " + getCurrentTerm())__        }_        if (publishResponse.getVersion() != lastPublishedVersion) {_            logger.debug("handlePublishResponse: ignored publish response due to version mismatch (expected: [{}], actual: [{}])",_                lastPublishedVersion, publishResponse.getVersion())__            throw new CoordinationStateRejectedException("incoming version " + publishResponse.getVersion() +_                " does not match current version " + lastPublishedVersion)__        }__        logger.trace("handlePublishResponse: accepted publish response for version [{}] and term [{}] from [{}]",_            publishResponse.getVersion(), publishResponse.getTerm(), sourceNode)__        publishVotes.addVote(sourceNode)__        if (isPublishQuorum(publishVotes)) {_            logger.trace("handlePublishResponse: value committed for version [{}] and term [{}]",_                publishResponse.getVersion(), publishResponse.getTerm())__            return Optional.of(new ApplyCommitRequest(localNode, publishResponse.getTerm(), publishResponse.getVersion()))__        }__        return Optional.empty()__    };may,be,called,on,receipt,of,a,publish,response,from,the,given,source,node,param,source,node,the,sender,of,the,publish,response,received,param,publish,response,the,publish,response,received,return,an,optional,apply,commit,request,which,if,present,may,be,broadcast,to,all,peers,indicating,that,this,publication,has,been,accepted,at,a,quorum,of,peers,and,is,therefore,committed,throws,coordination,state,rejected,exception,if,the,arguments,were,incompatible,with,the,current,state,of,this,object;public,optional,apply,commit,request,handle,publish,response,discovery,node,source,node,publish,response,publish,response,if,election,won,false,logger,debug,handle,publish,response,ignored,response,as,election,not,won,throw,new,coordination,state,rejected,exception,election,not,won,if,publish,response,get,term,get,current,term,logger,debug,handle,publish,response,ignored,publish,response,due,to,term,mismatch,expected,actual,get,current,term,publish,response,get,term,throw,new,coordination,state,rejected,exception,incoming,term,publish,response,get,term,does,not,match,current,term,get,current,term,if,publish,response,get,version,last,published,version,logger,debug,handle,publish,response,ignored,publish,response,due,to,version,mismatch,expected,actual,last,published,version,publish,response,get,version,throw,new,coordination,state,rejected,exception,incoming,version,publish,response,get,version,does,not,match,current,version,last,published,version,logger,trace,handle,publish,response,accepted,publish,response,for,version,and,term,from,publish,response,get,version,publish,response,get,term,source,node,publish,votes,add,vote,source,node,if,is,publish,quorum,publish,votes,logger,trace,handle,publish,response,value,committed,for,version,and,term,publish,response,get,version,publish,response,get,term,return,optional,of,new,apply,commit,request,local,node,publish,response,get,term,publish,response,get,version,return,optional,empty
CoordinationState -> public Optional<ApplyCommitRequest> handlePublishResponse(DiscoveryNode sourceNode, PublishResponse publishResponse);1544254415;May be called on receipt of a PublishResponse from the given sourceNode.__@param sourceNode      The sender of the PublishResponse received._@param publishResponse The PublishResponse received._@return An optional ApplyCommitRequest which, if present, may be broadcast to all peers, indicating that this publication_has been accepted at a quorum of peers and is therefore committed._@throws CoordinationStateRejectedException if the arguments were incompatible with the current state of this object.;public Optional<ApplyCommitRequest> handlePublishResponse(DiscoveryNode sourceNode, PublishResponse publishResponse) {_        if (electionWon == false) {_            logger.debug("handlePublishResponse: ignored response as election not won")__            throw new CoordinationStateRejectedException("election not won")__        }_        if (publishResponse.getTerm() != getCurrentTerm()) {_            logger.debug("handlePublishResponse: ignored publish response due to term mismatch (expected: [{}], actual: [{}])",_                getCurrentTerm(), publishResponse.getTerm())__            throw new CoordinationStateRejectedException("incoming term " + publishResponse.getTerm()_                + " does not match current term " + getCurrentTerm())__        }_        if (publishResponse.getVersion() != lastPublishedVersion) {_            logger.debug("handlePublishResponse: ignored publish response due to version mismatch (expected: [{}], actual: [{}])",_                lastPublishedVersion, publishResponse.getVersion())__            throw new CoordinationStateRejectedException("incoming version " + publishResponse.getVersion() +_                " does not match current version " + lastPublishedVersion)__        }__        logger.trace("handlePublishResponse: accepted publish response for version [{}] and term [{}] from [{}]",_            publishResponse.getVersion(), publishResponse.getTerm(), sourceNode)__        publishVotes.addVote(sourceNode)__        if (isPublishQuorum(publishVotes)) {_            logger.trace("handlePublishResponse: value committed for version [{}] and term [{}]",_                publishResponse.getVersion(), publishResponse.getTerm())__            return Optional.of(new ApplyCommitRequest(localNode, publishResponse.getTerm(), publishResponse.getVersion()))__        }__        return Optional.empty()__    };may,be,called,on,receipt,of,a,publish,response,from,the,given,source,node,param,source,node,the,sender,of,the,publish,response,received,param,publish,response,the,publish,response,received,return,an,optional,apply,commit,request,which,if,present,may,be,broadcast,to,all,peers,indicating,that,this,publication,has,been,accepted,at,a,quorum,of,peers,and,is,therefore,committed,throws,coordination,state,rejected,exception,if,the,arguments,were,incompatible,with,the,current,state,of,this,object;public,optional,apply,commit,request,handle,publish,response,discovery,node,source,node,publish,response,publish,response,if,election,won,false,logger,debug,handle,publish,response,ignored,response,as,election,not,won,throw,new,coordination,state,rejected,exception,election,not,won,if,publish,response,get,term,get,current,term,logger,debug,handle,publish,response,ignored,publish,response,due,to,term,mismatch,expected,actual,get,current,term,publish,response,get,term,throw,new,coordination,state,rejected,exception,incoming,term,publish,response,get,term,does,not,match,current,term,get,current,term,if,publish,response,get,version,last,published,version,logger,debug,handle,publish,response,ignored,publish,response,due,to,version,mismatch,expected,actual,last,published,version,publish,response,get,version,throw,new,coordination,state,rejected,exception,incoming,version,publish,response,get,version,does,not,match,current,version,last,published,version,logger,trace,handle,publish,response,accepted,publish,response,for,version,and,term,from,publish,response,get,version,publish,response,get,term,source,node,publish,votes,add,vote,source,node,if,is,publish,quorum,publish,votes,logger,trace,handle,publish,response,value,committed,for,version,and,term,publish,response,get,version,publish,response,get,term,return,optional,of,new,apply,commit,request,local,node,publish,response,get,term,publish,response,get,version,return,optional,empty
CoordinationState -> public Optional<ApplyCommitRequest> handlePublishResponse(DiscoveryNode sourceNode, PublishResponse publishResponse);1546592956;May be called on receipt of a PublishResponse from the given sourceNode.__@param sourceNode      The sender of the PublishResponse received._@param publishResponse The PublishResponse received._@return An optional ApplyCommitRequest which, if present, may be broadcast to all peers, indicating that this publication_has been accepted at a quorum of peers and is therefore committed._@throws CoordinationStateRejectedException if the arguments were incompatible with the current state of this object.;public Optional<ApplyCommitRequest> handlePublishResponse(DiscoveryNode sourceNode, PublishResponse publishResponse) {_        if (electionWon == false) {_            logger.debug("handlePublishResponse: ignored response as election not won")__            throw new CoordinationStateRejectedException("election not won")__        }_        if (publishResponse.getTerm() != getCurrentTerm()) {_            logger.debug("handlePublishResponse: ignored publish response due to term mismatch (expected: [{}], actual: [{}])",_                getCurrentTerm(), publishResponse.getTerm())__            throw new CoordinationStateRejectedException("incoming term " + publishResponse.getTerm()_                + " does not match current term " + getCurrentTerm())__        }_        if (publishResponse.getVersion() != lastPublishedVersion) {_            logger.debug("handlePublishResponse: ignored publish response due to version mismatch (expected: [{}], actual: [{}])",_                lastPublishedVersion, publishResponse.getVersion())__            throw new CoordinationStateRejectedException("incoming version " + publishResponse.getVersion() +_                " does not match current version " + lastPublishedVersion)__        }__        logger.trace("handlePublishResponse: accepted publish response for version [{}] and term [{}] from [{}]",_            publishResponse.getVersion(), publishResponse.getTerm(), sourceNode)__        publishVotes.addVote(sourceNode)__        if (isPublishQuorum(publishVotes)) {_            logger.trace("handlePublishResponse: value committed for version [{}] and term [{}]",_                publishResponse.getVersion(), publishResponse.getTerm())__            return Optional.of(new ApplyCommitRequest(localNode, publishResponse.getTerm(), publishResponse.getVersion()))__        }__        return Optional.empty()__    };may,be,called,on,receipt,of,a,publish,response,from,the,given,source,node,param,source,node,the,sender,of,the,publish,response,received,param,publish,response,the,publish,response,received,return,an,optional,apply,commit,request,which,if,present,may,be,broadcast,to,all,peers,indicating,that,this,publication,has,been,accepted,at,a,quorum,of,peers,and,is,therefore,committed,throws,coordination,state,rejected,exception,if,the,arguments,were,incompatible,with,the,current,state,of,this,object;public,optional,apply,commit,request,handle,publish,response,discovery,node,source,node,publish,response,publish,response,if,election,won,false,logger,debug,handle,publish,response,ignored,response,as,election,not,won,throw,new,coordination,state,rejected,exception,election,not,won,if,publish,response,get,term,get,current,term,logger,debug,handle,publish,response,ignored,publish,response,due,to,term,mismatch,expected,actual,get,current,term,publish,response,get,term,throw,new,coordination,state,rejected,exception,incoming,term,publish,response,get,term,does,not,match,current,term,get,current,term,if,publish,response,get,version,last,published,version,logger,debug,handle,publish,response,ignored,publish,response,due,to,version,mismatch,expected,actual,last,published,version,publish,response,get,version,throw,new,coordination,state,rejected,exception,incoming,version,publish,response,get,version,does,not,match,current,version,last,published,version,logger,trace,handle,publish,response,accepted,publish,response,for,version,and,term,from,publish,response,get,version,publish,response,get,term,source,node,publish,votes,add,vote,source,node,if,is,publish,quorum,publish,votes,logger,trace,handle,publish,response,value,committed,for,version,and,term,publish,response,get,version,publish,response,get,term,return,optional,of,new,apply,commit,request,local,node,publish,response,get,term,publish,response,get,version,return,optional,empty
CoordinationState -> public Optional<ApplyCommitRequest> handlePublishResponse(DiscoveryNode sourceNode, PublishResponse publishResponse);1547219208;May be called on receipt of a PublishResponse from the given sourceNode.__@param sourceNode      The sender of the PublishResponse received._@param publishResponse The PublishResponse received._@return An optional ApplyCommitRequest which, if present, may be broadcast to all peers, indicating that this publication_has been accepted at a quorum of peers and is therefore committed._@throws CoordinationStateRejectedException if the arguments were incompatible with the current state of this object.;public Optional<ApplyCommitRequest> handlePublishResponse(DiscoveryNode sourceNode, PublishResponse publishResponse) {_        if (electionWon == false) {_            logger.debug("handlePublishResponse: ignored response as election not won")__            throw new CoordinationStateRejectedException("election not won")__        }_        if (publishResponse.getTerm() != getCurrentTerm()) {_            logger.debug("handlePublishResponse: ignored publish response due to term mismatch (expected: [{}], actual: [{}])",_                getCurrentTerm(), publishResponse.getTerm())__            throw new CoordinationStateRejectedException("incoming term " + publishResponse.getTerm()_                + " does not match current term " + getCurrentTerm())__        }_        if (publishResponse.getVersion() != lastPublishedVersion) {_            logger.debug("handlePublishResponse: ignored publish response due to version mismatch (expected: [{}], actual: [{}])",_                lastPublishedVersion, publishResponse.getVersion())__            throw new CoordinationStateRejectedException("incoming version " + publishResponse.getVersion() +_                " does not match current version " + lastPublishedVersion)__        }__        logger.trace("handlePublishResponse: accepted publish response for version [{}] and term [{}] from [{}]",_            publishResponse.getVersion(), publishResponse.getTerm(), sourceNode)__        publishVotes.addVote(sourceNode)__        if (isPublishQuorum(publishVotes)) {_            logger.trace("handlePublishResponse: value committed for version [{}] and term [{}]",_                publishResponse.getVersion(), publishResponse.getTerm())__            return Optional.of(new ApplyCommitRequest(localNode, publishResponse.getTerm(), publishResponse.getVersion()))__        }__        return Optional.empty()__    };may,be,called,on,receipt,of,a,publish,response,from,the,given,source,node,param,source,node,the,sender,of,the,publish,response,received,param,publish,response,the,publish,response,received,return,an,optional,apply,commit,request,which,if,present,may,be,broadcast,to,all,peers,indicating,that,this,publication,has,been,accepted,at,a,quorum,of,peers,and,is,therefore,committed,throws,coordination,state,rejected,exception,if,the,arguments,were,incompatible,with,the,current,state,of,this,object;public,optional,apply,commit,request,handle,publish,response,discovery,node,source,node,publish,response,publish,response,if,election,won,false,logger,debug,handle,publish,response,ignored,response,as,election,not,won,throw,new,coordination,state,rejected,exception,election,not,won,if,publish,response,get,term,get,current,term,logger,debug,handle,publish,response,ignored,publish,response,due,to,term,mismatch,expected,actual,get,current,term,publish,response,get,term,throw,new,coordination,state,rejected,exception,incoming,term,publish,response,get,term,does,not,match,current,term,get,current,term,if,publish,response,get,version,last,published,version,logger,debug,handle,publish,response,ignored,publish,response,due,to,version,mismatch,expected,actual,last,published,version,publish,response,get,version,throw,new,coordination,state,rejected,exception,incoming,version,publish,response,get,version,does,not,match,current,version,last,published,version,logger,trace,handle,publish,response,accepted,publish,response,for,version,and,term,from,publish,response,get,version,publish,response,get,term,source,node,publish,votes,add,vote,source,node,if,is,publish,quorum,publish,votes,logger,trace,handle,publish,response,value,committed,for,version,and,term,publish,response,get,version,publish,response,get,term,return,optional,of,new,apply,commit,request,local,node,publish,response,get,term,publish,response,get,version,return,optional,empty
CoordinationState -> public Optional<ApplyCommitRequest> handlePublishResponse(DiscoveryNode sourceNode, PublishResponse publishResponse);1548772865;May be called on receipt of a PublishResponse from the given sourceNode.__@param sourceNode      The sender of the PublishResponse received._@param publishResponse The PublishResponse received._@return An optional ApplyCommitRequest which, if present, may be broadcast to all peers, indicating that this publication_has been accepted at a quorum of peers and is therefore committed._@throws CoordinationStateRejectedException if the arguments were incompatible with the current state of this object.;public Optional<ApplyCommitRequest> handlePublishResponse(DiscoveryNode sourceNode, PublishResponse publishResponse) {_        if (electionWon == false) {_            logger.debug("handlePublishResponse: ignored response as election not won")__            throw new CoordinationStateRejectedException("election not won")__        }_        if (publishResponse.getTerm() != getCurrentTerm()) {_            logger.debug("handlePublishResponse: ignored publish response due to term mismatch (expected: [{}], actual: [{}])",_                getCurrentTerm(), publishResponse.getTerm())__            throw new CoordinationStateRejectedException("incoming term " + publishResponse.getTerm()_                + " does not match current term " + getCurrentTerm())__        }_        if (publishResponse.getVersion() != lastPublishedVersion) {_            logger.debug("handlePublishResponse: ignored publish response due to version mismatch (expected: [{}], actual: [{}])",_                lastPublishedVersion, publishResponse.getVersion())__            throw new CoordinationStateRejectedException("incoming version " + publishResponse.getVersion() +_                " does not match current version " + lastPublishedVersion)__        }__        logger.trace("handlePublishResponse: accepted publish response for version [{}] and term [{}] from [{}]",_            publishResponse.getVersion(), publishResponse.getTerm(), sourceNode)__        publishVotes.addVote(sourceNode)__        if (isPublishQuorum(publishVotes)) {_            logger.trace("handlePublishResponse: value committed for version [{}] and term [{}]",_                publishResponse.getVersion(), publishResponse.getTerm())__            return Optional.of(new ApplyCommitRequest(localNode, publishResponse.getTerm(), publishResponse.getVersion()))__        }__        return Optional.empty()__    };may,be,called,on,receipt,of,a,publish,response,from,the,given,source,node,param,source,node,the,sender,of,the,publish,response,received,param,publish,response,the,publish,response,received,return,an,optional,apply,commit,request,which,if,present,may,be,broadcast,to,all,peers,indicating,that,this,publication,has,been,accepted,at,a,quorum,of,peers,and,is,therefore,committed,throws,coordination,state,rejected,exception,if,the,arguments,were,incompatible,with,the,current,state,of,this,object;public,optional,apply,commit,request,handle,publish,response,discovery,node,source,node,publish,response,publish,response,if,election,won,false,logger,debug,handle,publish,response,ignored,response,as,election,not,won,throw,new,coordination,state,rejected,exception,election,not,won,if,publish,response,get,term,get,current,term,logger,debug,handle,publish,response,ignored,publish,response,due,to,term,mismatch,expected,actual,get,current,term,publish,response,get,term,throw,new,coordination,state,rejected,exception,incoming,term,publish,response,get,term,does,not,match,current,term,get,current,term,if,publish,response,get,version,last,published,version,logger,debug,handle,publish,response,ignored,publish,response,due,to,version,mismatch,expected,actual,last,published,version,publish,response,get,version,throw,new,coordination,state,rejected,exception,incoming,version,publish,response,get,version,does,not,match,current,version,last,published,version,logger,trace,handle,publish,response,accepted,publish,response,for,version,and,term,from,publish,response,get,version,publish,response,get,term,source,node,publish,votes,add,vote,source,node,if,is,publish,quorum,publish,votes,logger,trace,handle,publish,response,value,committed,for,version,and,term,publish,response,get,version,publish,response,get,term,return,optional,of,new,apply,commit,request,local,node,publish,response,get,term,publish,response,get,version,return,optional,empty
CoordinationState -> public void handleCommit(ApplyCommitRequest applyCommit);1544081506;May be called on receipt of an ApplyCommitRequest. Updates the committed configuration accordingly.__@param applyCommit The ApplyCommitRequest received._@throws CoordinationStateRejectedException if the arguments were incompatible with the current state of this object.;public void handleCommit(ApplyCommitRequest applyCommit) {_        if (applyCommit.getTerm() != getCurrentTerm()) {_            logger.debug("handleCommit: ignored commit request due to term mismatch " +_                    "(expected: [term {} version {}], actual: [term {} version {}])",_                getLastAcceptedTerm(), getLastAcceptedVersion(), applyCommit.getTerm(), applyCommit.getVersion())__            throw new CoordinationStateRejectedException("incoming term " + applyCommit.getTerm() + " does not match current term " +_                getCurrentTerm())__        }_        if (applyCommit.getTerm() != getLastAcceptedTerm()) {_            logger.debug("handleCommit: ignored commit request due to term mismatch " +_                    "(expected: [term {} version {}], actual: [term {} version {}])",_                getLastAcceptedTerm(), getLastAcceptedVersion(), applyCommit.getTerm(), applyCommit.getVersion())__            throw new CoordinationStateRejectedException("incoming term " + applyCommit.getTerm() + " does not match last accepted term " +_                getLastAcceptedTerm())__        }_        if (applyCommit.getVersion() != getLastAcceptedVersion()) {_            logger.debug("handleCommit: ignored commit request due to version mismatch (term {}, expected: [{}], actual: [{}])",_                getLastAcceptedTerm(), getLastAcceptedVersion(), applyCommit.getVersion())__            throw new CoordinationStateRejectedException("incoming version " + applyCommit.getVersion() +_                " does not match current version " + getLastAcceptedVersion())__        }__        logger.trace("handleCommit: applying commit request for term [{}] and version [{}]", applyCommit.getTerm(),_            applyCommit.getVersion())___        persistedState.markLastAcceptedConfigAsCommitted()__        assert getLastCommittedConfiguration().equals(getLastAcceptedConfiguration())__    };may,be,called,on,receipt,of,an,apply,commit,request,updates,the,committed,configuration,accordingly,param,apply,commit,the,apply,commit,request,received,throws,coordination,state,rejected,exception,if,the,arguments,were,incompatible,with,the,current,state,of,this,object;public,void,handle,commit,apply,commit,request,apply,commit,if,apply,commit,get,term,get,current,term,logger,debug,handle,commit,ignored,commit,request,due,to,term,mismatch,expected,term,version,actual,term,version,get,last,accepted,term,get,last,accepted,version,apply,commit,get,term,apply,commit,get,version,throw,new,coordination,state,rejected,exception,incoming,term,apply,commit,get,term,does,not,match,current,term,get,current,term,if,apply,commit,get,term,get,last,accepted,term,logger,debug,handle,commit,ignored,commit,request,due,to,term,mismatch,expected,term,version,actual,term,version,get,last,accepted,term,get,last,accepted,version,apply,commit,get,term,apply,commit,get,version,throw,new,coordination,state,rejected,exception,incoming,term,apply,commit,get,term,does,not,match,last,accepted,term,get,last,accepted,term,if,apply,commit,get,version,get,last,accepted,version,logger,debug,handle,commit,ignored,commit,request,due,to,version,mismatch,term,expected,actual,get,last,accepted,term,get,last,accepted,version,apply,commit,get,version,throw,new,coordination,state,rejected,exception,incoming,version,apply,commit,get,version,does,not,match,current,version,get,last,accepted,version,logger,trace,handle,commit,applying,commit,request,for,term,and,version,apply,commit,get,term,apply,commit,get,version,persisted,state,mark,last,accepted,config,as,committed,assert,get,last,committed,configuration,equals,get,last,accepted,configuration
CoordinationState -> public void handleCommit(ApplyCommitRequest applyCommit);1544254415;May be called on receipt of an ApplyCommitRequest. Updates the committed configuration accordingly.__@param applyCommit The ApplyCommitRequest received._@throws CoordinationStateRejectedException if the arguments were incompatible with the current state of this object.;public void handleCommit(ApplyCommitRequest applyCommit) {_        if (applyCommit.getTerm() != getCurrentTerm()) {_            logger.debug("handleCommit: ignored commit request due to term mismatch " +_                    "(expected: [term {} version {}], actual: [term {} version {}])",_                getLastAcceptedTerm(), getLastAcceptedVersion(), applyCommit.getTerm(), applyCommit.getVersion())__            throw new CoordinationStateRejectedException("incoming term " + applyCommit.getTerm() + " does not match current term " +_                getCurrentTerm())__        }_        if (applyCommit.getTerm() != getLastAcceptedTerm()) {_            logger.debug("handleCommit: ignored commit request due to term mismatch " +_                    "(expected: [term {} version {}], actual: [term {} version {}])",_                getLastAcceptedTerm(), getLastAcceptedVersion(), applyCommit.getTerm(), applyCommit.getVersion())__            throw new CoordinationStateRejectedException("incoming term " + applyCommit.getTerm() + " does not match last accepted term " +_                getLastAcceptedTerm())__        }_        if (applyCommit.getVersion() != getLastAcceptedVersion()) {_            logger.debug("handleCommit: ignored commit request due to version mismatch (term {}, expected: [{}], actual: [{}])",_                getLastAcceptedTerm(), getLastAcceptedVersion(), applyCommit.getVersion())__            throw new CoordinationStateRejectedException("incoming version " + applyCommit.getVersion() +_                " does not match current version " + getLastAcceptedVersion())__        }__        logger.trace("handleCommit: applying commit request for term [{}] and version [{}]", applyCommit.getTerm(),_            applyCommit.getVersion())___        persistedState.markLastAcceptedConfigAsCommitted()__        assert getLastCommittedConfiguration().equals(getLastAcceptedConfiguration())__    };may,be,called,on,receipt,of,an,apply,commit,request,updates,the,committed,configuration,accordingly,param,apply,commit,the,apply,commit,request,received,throws,coordination,state,rejected,exception,if,the,arguments,were,incompatible,with,the,current,state,of,this,object;public,void,handle,commit,apply,commit,request,apply,commit,if,apply,commit,get,term,get,current,term,logger,debug,handle,commit,ignored,commit,request,due,to,term,mismatch,expected,term,version,actual,term,version,get,last,accepted,term,get,last,accepted,version,apply,commit,get,term,apply,commit,get,version,throw,new,coordination,state,rejected,exception,incoming,term,apply,commit,get,term,does,not,match,current,term,get,current,term,if,apply,commit,get,term,get,last,accepted,term,logger,debug,handle,commit,ignored,commit,request,due,to,term,mismatch,expected,term,version,actual,term,version,get,last,accepted,term,get,last,accepted,version,apply,commit,get,term,apply,commit,get,version,throw,new,coordination,state,rejected,exception,incoming,term,apply,commit,get,term,does,not,match,last,accepted,term,get,last,accepted,term,if,apply,commit,get,version,get,last,accepted,version,logger,debug,handle,commit,ignored,commit,request,due,to,version,mismatch,term,expected,actual,get,last,accepted,term,get,last,accepted,version,apply,commit,get,version,throw,new,coordination,state,rejected,exception,incoming,version,apply,commit,get,version,does,not,match,current,version,get,last,accepted,version,logger,trace,handle,commit,applying,commit,request,for,term,and,version,apply,commit,get,term,apply,commit,get,version,persisted,state,mark,last,accepted,config,as,committed,assert,get,last,committed,configuration,equals,get,last,accepted,configuration
CoordinationState -> public void handleCommit(ApplyCommitRequest applyCommit);1546592956;May be called on receipt of an ApplyCommitRequest. Updates the committed configuration accordingly.__@param applyCommit The ApplyCommitRequest received._@throws CoordinationStateRejectedException if the arguments were incompatible with the current state of this object.;public void handleCommit(ApplyCommitRequest applyCommit) {_        if (applyCommit.getTerm() != getCurrentTerm()) {_            logger.debug("handleCommit: ignored commit request due to term mismatch " +_                    "(expected: [term {} version {}], actual: [term {} version {}])",_                getLastAcceptedTerm(), getLastAcceptedVersion(), applyCommit.getTerm(), applyCommit.getVersion())__            throw new CoordinationStateRejectedException("incoming term " + applyCommit.getTerm() + " does not match current term " +_                getCurrentTerm())__        }_        if (applyCommit.getTerm() != getLastAcceptedTerm()) {_            logger.debug("handleCommit: ignored commit request due to term mismatch " +_                    "(expected: [term {} version {}], actual: [term {} version {}])",_                getLastAcceptedTerm(), getLastAcceptedVersion(), applyCommit.getTerm(), applyCommit.getVersion())__            throw new CoordinationStateRejectedException("incoming term " + applyCommit.getTerm() + " does not match last accepted term " +_                getLastAcceptedTerm())__        }_        if (applyCommit.getVersion() != getLastAcceptedVersion()) {_            logger.debug("handleCommit: ignored commit request due to version mismatch (term {}, expected: [{}], actual: [{}])",_                getLastAcceptedTerm(), getLastAcceptedVersion(), applyCommit.getVersion())__            throw new CoordinationStateRejectedException("incoming version " + applyCommit.getVersion() +_                " does not match current version " + getLastAcceptedVersion())__        }__        logger.trace("handleCommit: applying commit request for term [{}] and version [{}]", applyCommit.getTerm(),_            applyCommit.getVersion())___        persistedState.markLastAcceptedConfigAsCommitted()__        assert getLastCommittedConfiguration().equals(getLastAcceptedConfiguration())__    };may,be,called,on,receipt,of,an,apply,commit,request,updates,the,committed,configuration,accordingly,param,apply,commit,the,apply,commit,request,received,throws,coordination,state,rejected,exception,if,the,arguments,were,incompatible,with,the,current,state,of,this,object;public,void,handle,commit,apply,commit,request,apply,commit,if,apply,commit,get,term,get,current,term,logger,debug,handle,commit,ignored,commit,request,due,to,term,mismatch,expected,term,version,actual,term,version,get,last,accepted,term,get,last,accepted,version,apply,commit,get,term,apply,commit,get,version,throw,new,coordination,state,rejected,exception,incoming,term,apply,commit,get,term,does,not,match,current,term,get,current,term,if,apply,commit,get,term,get,last,accepted,term,logger,debug,handle,commit,ignored,commit,request,due,to,term,mismatch,expected,term,version,actual,term,version,get,last,accepted,term,get,last,accepted,version,apply,commit,get,term,apply,commit,get,version,throw,new,coordination,state,rejected,exception,incoming,term,apply,commit,get,term,does,not,match,last,accepted,term,get,last,accepted,term,if,apply,commit,get,version,get,last,accepted,version,logger,debug,handle,commit,ignored,commit,request,due,to,version,mismatch,term,expected,actual,get,last,accepted,term,get,last,accepted,version,apply,commit,get,version,throw,new,coordination,state,rejected,exception,incoming,version,apply,commit,get,version,does,not,match,current,version,get,last,accepted,version,logger,trace,handle,commit,applying,commit,request,for,term,and,version,apply,commit,get,term,apply,commit,get,version,persisted,state,mark,last,accepted,config,as,committed,assert,get,last,committed,configuration,equals,get,last,accepted,configuration
CoordinationState -> public void handleCommit(ApplyCommitRequest applyCommit);1547219208;May be called on receipt of an ApplyCommitRequest. Updates the committed configuration accordingly.__@param applyCommit The ApplyCommitRequest received._@throws CoordinationStateRejectedException if the arguments were incompatible with the current state of this object.;public void handleCommit(ApplyCommitRequest applyCommit) {_        if (applyCommit.getTerm() != getCurrentTerm()) {_            logger.debug("handleCommit: ignored commit request due to term mismatch " +_                    "(expected: [term {} version {}], actual: [term {} version {}])",_                getLastAcceptedTerm(), getLastAcceptedVersion(), applyCommit.getTerm(), applyCommit.getVersion())__            throw new CoordinationStateRejectedException("incoming term " + applyCommit.getTerm() + " does not match current term " +_                getCurrentTerm())__        }_        if (applyCommit.getTerm() != getLastAcceptedTerm()) {_            logger.debug("handleCommit: ignored commit request due to term mismatch " +_                    "(expected: [term {} version {}], actual: [term {} version {}])",_                getLastAcceptedTerm(), getLastAcceptedVersion(), applyCommit.getTerm(), applyCommit.getVersion())__            throw new CoordinationStateRejectedException("incoming term " + applyCommit.getTerm() + " does not match last accepted term " +_                getLastAcceptedTerm())__        }_        if (applyCommit.getVersion() != getLastAcceptedVersion()) {_            logger.debug("handleCommit: ignored commit request due to version mismatch (term {}, expected: [{}], actual: [{}])",_                getLastAcceptedTerm(), getLastAcceptedVersion(), applyCommit.getVersion())__            throw new CoordinationStateRejectedException("incoming version " + applyCommit.getVersion() +_                " does not match current version " + getLastAcceptedVersion())__        }__        logger.trace("handleCommit: applying commit request for term [{}] and version [{}]", applyCommit.getTerm(),_            applyCommit.getVersion())___        persistedState.markLastAcceptedConfigAsCommitted()__        assert getLastCommittedConfiguration().equals(getLastAcceptedConfiguration())__    };may,be,called,on,receipt,of,an,apply,commit,request,updates,the,committed,configuration,accordingly,param,apply,commit,the,apply,commit,request,received,throws,coordination,state,rejected,exception,if,the,arguments,were,incompatible,with,the,current,state,of,this,object;public,void,handle,commit,apply,commit,request,apply,commit,if,apply,commit,get,term,get,current,term,logger,debug,handle,commit,ignored,commit,request,due,to,term,mismatch,expected,term,version,actual,term,version,get,last,accepted,term,get,last,accepted,version,apply,commit,get,term,apply,commit,get,version,throw,new,coordination,state,rejected,exception,incoming,term,apply,commit,get,term,does,not,match,current,term,get,current,term,if,apply,commit,get,term,get,last,accepted,term,logger,debug,handle,commit,ignored,commit,request,due,to,term,mismatch,expected,term,version,actual,term,version,get,last,accepted,term,get,last,accepted,version,apply,commit,get,term,apply,commit,get,version,throw,new,coordination,state,rejected,exception,incoming,term,apply,commit,get,term,does,not,match,last,accepted,term,get,last,accepted,term,if,apply,commit,get,version,get,last,accepted,version,logger,debug,handle,commit,ignored,commit,request,due,to,version,mismatch,term,expected,actual,get,last,accepted,term,get,last,accepted,version,apply,commit,get,version,throw,new,coordination,state,rejected,exception,incoming,version,apply,commit,get,version,does,not,match,current,version,get,last,accepted,version,logger,trace,handle,commit,applying,commit,request,for,term,and,version,apply,commit,get,term,apply,commit,get,version,persisted,state,mark,last,accepted,config,as,committed,assert,get,last,committed,configuration,equals,get,last,accepted,configuration
CoordinationState -> public void handleCommit(ApplyCommitRequest applyCommit);1548772865;May be called on receipt of an ApplyCommitRequest. Updates the committed configuration accordingly.__@param applyCommit The ApplyCommitRequest received._@throws CoordinationStateRejectedException if the arguments were incompatible with the current state of this object.;public void handleCommit(ApplyCommitRequest applyCommit) {_        if (applyCommit.getTerm() != getCurrentTerm()) {_            logger.debug("handleCommit: ignored commit request due to term mismatch " +_                    "(expected: [term {} version {}], actual: [term {} version {}])",_                getLastAcceptedTerm(), getLastAcceptedVersion(), applyCommit.getTerm(), applyCommit.getVersion())__            throw new CoordinationStateRejectedException("incoming term " + applyCommit.getTerm() + " does not match current term " +_                getCurrentTerm())__        }_        if (applyCommit.getTerm() != getLastAcceptedTerm()) {_            logger.debug("handleCommit: ignored commit request due to term mismatch " +_                    "(expected: [term {} version {}], actual: [term {} version {}])",_                getLastAcceptedTerm(), getLastAcceptedVersion(), applyCommit.getTerm(), applyCommit.getVersion())__            throw new CoordinationStateRejectedException("incoming term " + applyCommit.getTerm() + " does not match last accepted term " +_                getLastAcceptedTerm())__        }_        if (applyCommit.getVersion() != getLastAcceptedVersion()) {_            logger.debug("handleCommit: ignored commit request due to version mismatch (term {}, expected: [{}], actual: [{}])",_                getLastAcceptedTerm(), getLastAcceptedVersion(), applyCommit.getVersion())__            throw new CoordinationStateRejectedException("incoming version " + applyCommit.getVersion() +_                " does not match current version " + getLastAcceptedVersion())__        }__        logger.trace("handleCommit: applying commit request for term [{}] and version [{}]", applyCommit.getTerm(),_            applyCommit.getVersion())___        persistedState.markLastAcceptedStateAsCommitted()__        assert getLastCommittedConfiguration().equals(getLastAcceptedConfiguration())__    };may,be,called,on,receipt,of,an,apply,commit,request,updates,the,committed,configuration,accordingly,param,apply,commit,the,apply,commit,request,received,throws,coordination,state,rejected,exception,if,the,arguments,were,incompatible,with,the,current,state,of,this,object;public,void,handle,commit,apply,commit,request,apply,commit,if,apply,commit,get,term,get,current,term,logger,debug,handle,commit,ignored,commit,request,due,to,term,mismatch,expected,term,version,actual,term,version,get,last,accepted,term,get,last,accepted,version,apply,commit,get,term,apply,commit,get,version,throw,new,coordination,state,rejected,exception,incoming,term,apply,commit,get,term,does,not,match,current,term,get,current,term,if,apply,commit,get,term,get,last,accepted,term,logger,debug,handle,commit,ignored,commit,request,due,to,term,mismatch,expected,term,version,actual,term,version,get,last,accepted,term,get,last,accepted,version,apply,commit,get,term,apply,commit,get,version,throw,new,coordination,state,rejected,exception,incoming,term,apply,commit,get,term,does,not,match,last,accepted,term,get,last,accepted,term,if,apply,commit,get,version,get,last,accepted,version,logger,debug,handle,commit,ignored,commit,request,due,to,version,mismatch,term,expected,actual,get,last,accepted,term,get,last,accepted,version,apply,commit,get,version,throw,new,coordination,state,rejected,exception,incoming,version,apply,commit,get,version,does,not,match,current,version,get,last,accepted,version,logger,trace,handle,commit,applying,commit,request,for,term,and,version,apply,commit,get,term,apply,commit,get,version,persisted,state,mark,last,accepted,state,as,committed,assert,get,last,committed,configuration,equals,get,last,accepted,configuration
CoordinationState -> public PublishRequest handleClientValue(ClusterState clusterState);1544081506;May be called in order to prepare publication of the given cluster state__@param clusterState The cluster state to publish._@return A PublishRequest to publish the given cluster state_@throws CoordinationStateRejectedException if the arguments were incompatible with the current state of this object.;public PublishRequest handleClientValue(ClusterState clusterState) {_        if (electionWon == false) {_            logger.debug("handleClientValue: ignored request as election not won")__            throw new CoordinationStateRejectedException("election not won")__        }_        if (lastPublishedVersion != getLastAcceptedVersion()) {_            logger.debug("handleClientValue: cannot start publishing next value before accepting previous one")__            throw new CoordinationStateRejectedException("cannot start publishing next value before accepting previous one")__        }_        if (clusterState.term() != getCurrentTerm()) {_            logger.debug("handleClientValue: ignored request due to term mismatch " +_                    "(expected: [term {} version >{}], actual: [term {} version {}])",_                getCurrentTerm(), lastPublishedVersion, clusterState.term(), clusterState.version())__            throw new CoordinationStateRejectedException("incoming term " + clusterState.term() + " does not match current term " +_                getCurrentTerm())__        }_        if (clusterState.version() <= lastPublishedVersion) {_            logger.debug("handleClientValue: ignored request due to version mismatch " +_                    "(expected: [term {} version >{}], actual: [term {} version {}])",_                getCurrentTerm(), lastPublishedVersion, clusterState.term(), clusterState.version())__            throw new CoordinationStateRejectedException("incoming cluster state version " + clusterState.version() +_                " lower or equal to last published version " + lastPublishedVersion)__        }__        if (clusterState.getLastAcceptedConfiguration().equals(getLastAcceptedConfiguration()) == false_            && getLastCommittedConfiguration().equals(getLastAcceptedConfiguration()) == false) {_            logger.debug("handleClientValue: only allow reconfiguration while not already reconfiguring")__            throw new CoordinationStateRejectedException("only allow reconfiguration while not already reconfiguring")__        }_        if (joinVotesHaveQuorumFor(clusterState.getLastAcceptedConfiguration()) == false) {_            logger.debug("handleClientValue: only allow reconfiguration if joinVotes have quorum for new config")__            throw new CoordinationStateRejectedException("only allow reconfiguration if joinVotes have quorum for new config")__        }__        assert clusterState.getLastCommittedConfiguration().equals(getLastCommittedConfiguration()) :_            "last committed configuration should not change"___        lastPublishedVersion = clusterState.version()__        lastPublishedConfiguration = clusterState.getLastAcceptedConfiguration()__        publishVotes = new VoteCollection()___        logger.trace("handleClientValue: processing request for version [{}] and term [{}]", lastPublishedVersion, getCurrentTerm())___        return new PublishRequest(clusterState)__    };may,be,called,in,order,to,prepare,publication,of,the,given,cluster,state,param,cluster,state,the,cluster,state,to,publish,return,a,publish,request,to,publish,the,given,cluster,state,throws,coordination,state,rejected,exception,if,the,arguments,were,incompatible,with,the,current,state,of,this,object;public,publish,request,handle,client,value,cluster,state,cluster,state,if,election,won,false,logger,debug,handle,client,value,ignored,request,as,election,not,won,throw,new,coordination,state,rejected,exception,election,not,won,if,last,published,version,get,last,accepted,version,logger,debug,handle,client,value,cannot,start,publishing,next,value,before,accepting,previous,one,throw,new,coordination,state,rejected,exception,cannot,start,publishing,next,value,before,accepting,previous,one,if,cluster,state,term,get,current,term,logger,debug,handle,client,value,ignored,request,due,to,term,mismatch,expected,term,version,actual,term,version,get,current,term,last,published,version,cluster,state,term,cluster,state,version,throw,new,coordination,state,rejected,exception,incoming,term,cluster,state,term,does,not,match,current,term,get,current,term,if,cluster,state,version,last,published,version,logger,debug,handle,client,value,ignored,request,due,to,version,mismatch,expected,term,version,actual,term,version,get,current,term,last,published,version,cluster,state,term,cluster,state,version,throw,new,coordination,state,rejected,exception,incoming,cluster,state,version,cluster,state,version,lower,or,equal,to,last,published,version,last,published,version,if,cluster,state,get,last,accepted,configuration,equals,get,last,accepted,configuration,false,get,last,committed,configuration,equals,get,last,accepted,configuration,false,logger,debug,handle,client,value,only,allow,reconfiguration,while,not,already,reconfiguring,throw,new,coordination,state,rejected,exception,only,allow,reconfiguration,while,not,already,reconfiguring,if,join,votes,have,quorum,for,cluster,state,get,last,accepted,configuration,false,logger,debug,handle,client,value,only,allow,reconfiguration,if,join,votes,have,quorum,for,new,config,throw,new,coordination,state,rejected,exception,only,allow,reconfiguration,if,join,votes,have,quorum,for,new,config,assert,cluster,state,get,last,committed,configuration,equals,get,last,committed,configuration,last,committed,configuration,should,not,change,last,published,version,cluster,state,version,last,published,configuration,cluster,state,get,last,accepted,configuration,publish,votes,new,vote,collection,logger,trace,handle,client,value,processing,request,for,version,and,term,last,published,version,get,current,term,return,new,publish,request,cluster,state
CoordinationState -> public PublishRequest handleClientValue(ClusterState clusterState);1544254415;May be called in order to prepare publication of the given cluster state__@param clusterState The cluster state to publish._@return A PublishRequest to publish the given cluster state_@throws CoordinationStateRejectedException if the arguments were incompatible with the current state of this object.;public PublishRequest handleClientValue(ClusterState clusterState) {_        if (electionWon == false) {_            logger.debug("handleClientValue: ignored request as election not won")__            throw new CoordinationStateRejectedException("election not won")__        }_        if (lastPublishedVersion != getLastAcceptedVersion()) {_            logger.debug("handleClientValue: cannot start publishing next value before accepting previous one")__            throw new CoordinationStateRejectedException("cannot start publishing next value before accepting previous one")__        }_        if (clusterState.term() != getCurrentTerm()) {_            logger.debug("handleClientValue: ignored request due to term mismatch " +_                    "(expected: [term {} version >{}], actual: [term {} version {}])",_                getCurrentTerm(), lastPublishedVersion, clusterState.term(), clusterState.version())__            throw new CoordinationStateRejectedException("incoming term " + clusterState.term() + " does not match current term " +_                getCurrentTerm())__        }_        if (clusterState.version() <= lastPublishedVersion) {_            logger.debug("handleClientValue: ignored request due to version mismatch " +_                    "(expected: [term {} version >{}], actual: [term {} version {}])",_                getCurrentTerm(), lastPublishedVersion, clusterState.term(), clusterState.version())__            throw new CoordinationStateRejectedException("incoming cluster state version " + clusterState.version() +_                " lower or equal to last published version " + lastPublishedVersion)__        }__        if (clusterState.getLastAcceptedConfiguration().equals(getLastAcceptedConfiguration()) == false_            && getLastCommittedConfiguration().equals(getLastAcceptedConfiguration()) == false) {_            logger.debug("handleClientValue: only allow reconfiguration while not already reconfiguring")__            throw new CoordinationStateRejectedException("only allow reconfiguration while not already reconfiguring")__        }_        if (joinVotesHaveQuorumFor(clusterState.getLastAcceptedConfiguration()) == false) {_            logger.debug("handleClientValue: only allow reconfiguration if joinVotes have quorum for new config")__            throw new CoordinationStateRejectedException("only allow reconfiguration if joinVotes have quorum for new config")__        }__        assert clusterState.getLastCommittedConfiguration().equals(getLastCommittedConfiguration()) :_            "last committed configuration should not change"___        lastPublishedVersion = clusterState.version()__        lastPublishedConfiguration = clusterState.getLastAcceptedConfiguration()__        publishVotes = new VoteCollection()___        logger.trace("handleClientValue: processing request for version [{}] and term [{}]", lastPublishedVersion, getCurrentTerm())___        return new PublishRequest(clusterState)__    };may,be,called,in,order,to,prepare,publication,of,the,given,cluster,state,param,cluster,state,the,cluster,state,to,publish,return,a,publish,request,to,publish,the,given,cluster,state,throws,coordination,state,rejected,exception,if,the,arguments,were,incompatible,with,the,current,state,of,this,object;public,publish,request,handle,client,value,cluster,state,cluster,state,if,election,won,false,logger,debug,handle,client,value,ignored,request,as,election,not,won,throw,new,coordination,state,rejected,exception,election,not,won,if,last,published,version,get,last,accepted,version,logger,debug,handle,client,value,cannot,start,publishing,next,value,before,accepting,previous,one,throw,new,coordination,state,rejected,exception,cannot,start,publishing,next,value,before,accepting,previous,one,if,cluster,state,term,get,current,term,logger,debug,handle,client,value,ignored,request,due,to,term,mismatch,expected,term,version,actual,term,version,get,current,term,last,published,version,cluster,state,term,cluster,state,version,throw,new,coordination,state,rejected,exception,incoming,term,cluster,state,term,does,not,match,current,term,get,current,term,if,cluster,state,version,last,published,version,logger,debug,handle,client,value,ignored,request,due,to,version,mismatch,expected,term,version,actual,term,version,get,current,term,last,published,version,cluster,state,term,cluster,state,version,throw,new,coordination,state,rejected,exception,incoming,cluster,state,version,cluster,state,version,lower,or,equal,to,last,published,version,last,published,version,if,cluster,state,get,last,accepted,configuration,equals,get,last,accepted,configuration,false,get,last,committed,configuration,equals,get,last,accepted,configuration,false,logger,debug,handle,client,value,only,allow,reconfiguration,while,not,already,reconfiguring,throw,new,coordination,state,rejected,exception,only,allow,reconfiguration,while,not,already,reconfiguring,if,join,votes,have,quorum,for,cluster,state,get,last,accepted,configuration,false,logger,debug,handle,client,value,only,allow,reconfiguration,if,join,votes,have,quorum,for,new,config,throw,new,coordination,state,rejected,exception,only,allow,reconfiguration,if,join,votes,have,quorum,for,new,config,assert,cluster,state,get,last,committed,configuration,equals,get,last,committed,configuration,last,committed,configuration,should,not,change,last,published,version,cluster,state,version,last,published,configuration,cluster,state,get,last,accepted,configuration,publish,votes,new,vote,collection,logger,trace,handle,client,value,processing,request,for,version,and,term,last,published,version,get,current,term,return,new,publish,request,cluster,state
CoordinationState -> public PublishRequest handleClientValue(ClusterState clusterState);1546592956;May be called in order to prepare publication of the given cluster state__@param clusterState The cluster state to publish._@return A PublishRequest to publish the given cluster state_@throws CoordinationStateRejectedException if the arguments were incompatible with the current state of this object.;public PublishRequest handleClientValue(ClusterState clusterState) {_        if (electionWon == false) {_            logger.debug("handleClientValue: ignored request as election not won")__            throw new CoordinationStateRejectedException("election not won")__        }_        if (lastPublishedVersion != getLastAcceptedVersion()) {_            logger.debug("handleClientValue: cannot start publishing next value before accepting previous one")__            throw new CoordinationStateRejectedException("cannot start publishing next value before accepting previous one")__        }_        if (clusterState.term() != getCurrentTerm()) {_            logger.debug("handleClientValue: ignored request due to term mismatch " +_                    "(expected: [term {} version >{}], actual: [term {} version {}])",_                getCurrentTerm(), lastPublishedVersion, clusterState.term(), clusterState.version())__            throw new CoordinationStateRejectedException("incoming term " + clusterState.term() + " does not match current term " +_                getCurrentTerm())__        }_        if (clusterState.version() <= lastPublishedVersion) {_            logger.debug("handleClientValue: ignored request due to version mismatch " +_                    "(expected: [term {} version >{}], actual: [term {} version {}])",_                getCurrentTerm(), lastPublishedVersion, clusterState.term(), clusterState.version())__            throw new CoordinationStateRejectedException("incoming cluster state version " + clusterState.version() +_                " lower or equal to last published version " + lastPublishedVersion)__        }__        if (clusterState.getLastAcceptedConfiguration().equals(getLastAcceptedConfiguration()) == false_            && getLastCommittedConfiguration().equals(getLastAcceptedConfiguration()) == false) {_            logger.debug("handleClientValue: only allow reconfiguration while not already reconfiguring")__            throw new CoordinationStateRejectedException("only allow reconfiguration while not already reconfiguring")__        }_        if (joinVotesHaveQuorumFor(clusterState.getLastAcceptedConfiguration()) == false) {_            logger.debug("handleClientValue: only allow reconfiguration if joinVotes have quorum for new config")__            throw new CoordinationStateRejectedException("only allow reconfiguration if joinVotes have quorum for new config")__        }__        assert clusterState.getLastCommittedConfiguration().equals(getLastCommittedConfiguration()) :_            "last committed configuration should not change"___        lastPublishedVersion = clusterState.version()__        lastPublishedConfiguration = clusterState.getLastAcceptedConfiguration()__        publishVotes = new VoteCollection()___        logger.trace("handleClientValue: processing request for version [{}] and term [{}]", lastPublishedVersion, getCurrentTerm())___        return new PublishRequest(clusterState)__    };may,be,called,in,order,to,prepare,publication,of,the,given,cluster,state,param,cluster,state,the,cluster,state,to,publish,return,a,publish,request,to,publish,the,given,cluster,state,throws,coordination,state,rejected,exception,if,the,arguments,were,incompatible,with,the,current,state,of,this,object;public,publish,request,handle,client,value,cluster,state,cluster,state,if,election,won,false,logger,debug,handle,client,value,ignored,request,as,election,not,won,throw,new,coordination,state,rejected,exception,election,not,won,if,last,published,version,get,last,accepted,version,logger,debug,handle,client,value,cannot,start,publishing,next,value,before,accepting,previous,one,throw,new,coordination,state,rejected,exception,cannot,start,publishing,next,value,before,accepting,previous,one,if,cluster,state,term,get,current,term,logger,debug,handle,client,value,ignored,request,due,to,term,mismatch,expected,term,version,actual,term,version,get,current,term,last,published,version,cluster,state,term,cluster,state,version,throw,new,coordination,state,rejected,exception,incoming,term,cluster,state,term,does,not,match,current,term,get,current,term,if,cluster,state,version,last,published,version,logger,debug,handle,client,value,ignored,request,due,to,version,mismatch,expected,term,version,actual,term,version,get,current,term,last,published,version,cluster,state,term,cluster,state,version,throw,new,coordination,state,rejected,exception,incoming,cluster,state,version,cluster,state,version,lower,or,equal,to,last,published,version,last,published,version,if,cluster,state,get,last,accepted,configuration,equals,get,last,accepted,configuration,false,get,last,committed,configuration,equals,get,last,accepted,configuration,false,logger,debug,handle,client,value,only,allow,reconfiguration,while,not,already,reconfiguring,throw,new,coordination,state,rejected,exception,only,allow,reconfiguration,while,not,already,reconfiguring,if,join,votes,have,quorum,for,cluster,state,get,last,accepted,configuration,false,logger,debug,handle,client,value,only,allow,reconfiguration,if,join,votes,have,quorum,for,new,config,throw,new,coordination,state,rejected,exception,only,allow,reconfiguration,if,join,votes,have,quorum,for,new,config,assert,cluster,state,get,last,committed,configuration,equals,get,last,committed,configuration,last,committed,configuration,should,not,change,last,published,version,cluster,state,version,last,published,configuration,cluster,state,get,last,accepted,configuration,publish,votes,new,vote,collection,logger,trace,handle,client,value,processing,request,for,version,and,term,last,published,version,get,current,term,return,new,publish,request,cluster,state
CoordinationState -> public PublishRequest handleClientValue(ClusterState clusterState);1547219208;May be called in order to prepare publication of the given cluster state__@param clusterState The cluster state to publish._@return A PublishRequest to publish the given cluster state_@throws CoordinationStateRejectedException if the arguments were incompatible with the current state of this object.;public PublishRequest handleClientValue(ClusterState clusterState) {_        if (electionWon == false) {_            logger.debug("handleClientValue: ignored request as election not won")__            throw new CoordinationStateRejectedException("election not won")__        }_        if (lastPublishedVersion != getLastAcceptedVersion()) {_            logger.debug("handleClientValue: cannot start publishing next value before accepting previous one")__            throw new CoordinationStateRejectedException("cannot start publishing next value before accepting previous one")__        }_        if (clusterState.term() != getCurrentTerm()) {_            logger.debug("handleClientValue: ignored request due to term mismatch " +_                    "(expected: [term {} version >{}], actual: [term {} version {}])",_                getCurrentTerm(), lastPublishedVersion, clusterState.term(), clusterState.version())__            throw new CoordinationStateRejectedException("incoming term " + clusterState.term() + " does not match current term " +_                getCurrentTerm())__        }_        if (clusterState.version() <= lastPublishedVersion) {_            logger.debug("handleClientValue: ignored request due to version mismatch " +_                    "(expected: [term {} version >{}], actual: [term {} version {}])",_                getCurrentTerm(), lastPublishedVersion, clusterState.term(), clusterState.version())__            throw new CoordinationStateRejectedException("incoming cluster state version " + clusterState.version() +_                " lower or equal to last published version " + lastPublishedVersion)__        }__        if (clusterState.getLastAcceptedConfiguration().equals(getLastAcceptedConfiguration()) == false_            && getLastCommittedConfiguration().equals(getLastAcceptedConfiguration()) == false) {_            logger.debug("handleClientValue: only allow reconfiguration while not already reconfiguring")__            throw new CoordinationStateRejectedException("only allow reconfiguration while not already reconfiguring")__        }_        if (joinVotesHaveQuorumFor(clusterState.getLastAcceptedConfiguration()) == false) {_            logger.debug("handleClientValue: only allow reconfiguration if joinVotes have quorum for new config")__            throw new CoordinationStateRejectedException("only allow reconfiguration if joinVotes have quorum for new config")__        }__        assert clusterState.getLastCommittedConfiguration().equals(getLastCommittedConfiguration()) :_            "last committed configuration should not change"___        lastPublishedVersion = clusterState.version()__        lastPublishedConfiguration = clusterState.getLastAcceptedConfiguration()__        publishVotes = new VoteCollection()___        logger.trace("handleClientValue: processing request for version [{}] and term [{}]", lastPublishedVersion, getCurrentTerm())___        return new PublishRequest(clusterState)__    };may,be,called,in,order,to,prepare,publication,of,the,given,cluster,state,param,cluster,state,the,cluster,state,to,publish,return,a,publish,request,to,publish,the,given,cluster,state,throws,coordination,state,rejected,exception,if,the,arguments,were,incompatible,with,the,current,state,of,this,object;public,publish,request,handle,client,value,cluster,state,cluster,state,if,election,won,false,logger,debug,handle,client,value,ignored,request,as,election,not,won,throw,new,coordination,state,rejected,exception,election,not,won,if,last,published,version,get,last,accepted,version,logger,debug,handle,client,value,cannot,start,publishing,next,value,before,accepting,previous,one,throw,new,coordination,state,rejected,exception,cannot,start,publishing,next,value,before,accepting,previous,one,if,cluster,state,term,get,current,term,logger,debug,handle,client,value,ignored,request,due,to,term,mismatch,expected,term,version,actual,term,version,get,current,term,last,published,version,cluster,state,term,cluster,state,version,throw,new,coordination,state,rejected,exception,incoming,term,cluster,state,term,does,not,match,current,term,get,current,term,if,cluster,state,version,last,published,version,logger,debug,handle,client,value,ignored,request,due,to,version,mismatch,expected,term,version,actual,term,version,get,current,term,last,published,version,cluster,state,term,cluster,state,version,throw,new,coordination,state,rejected,exception,incoming,cluster,state,version,cluster,state,version,lower,or,equal,to,last,published,version,last,published,version,if,cluster,state,get,last,accepted,configuration,equals,get,last,accepted,configuration,false,get,last,committed,configuration,equals,get,last,accepted,configuration,false,logger,debug,handle,client,value,only,allow,reconfiguration,while,not,already,reconfiguring,throw,new,coordination,state,rejected,exception,only,allow,reconfiguration,while,not,already,reconfiguring,if,join,votes,have,quorum,for,cluster,state,get,last,accepted,configuration,false,logger,debug,handle,client,value,only,allow,reconfiguration,if,join,votes,have,quorum,for,new,config,throw,new,coordination,state,rejected,exception,only,allow,reconfiguration,if,join,votes,have,quorum,for,new,config,assert,cluster,state,get,last,committed,configuration,equals,get,last,committed,configuration,last,committed,configuration,should,not,change,last,published,version,cluster,state,version,last,published,configuration,cluster,state,get,last,accepted,configuration,publish,votes,new,vote,collection,logger,trace,handle,client,value,processing,request,for,version,and,term,last,published,version,get,current,term,return,new,publish,request,cluster,state
CoordinationState -> public PublishRequest handleClientValue(ClusterState clusterState);1548772865;May be called in order to prepare publication of the given cluster state__@param clusterState The cluster state to publish._@return A PublishRequest to publish the given cluster state_@throws CoordinationStateRejectedException if the arguments were incompatible with the current state of this object.;public PublishRequest handleClientValue(ClusterState clusterState) {_        if (electionWon == false) {_            logger.debug("handleClientValue: ignored request as election not won")__            throw new CoordinationStateRejectedException("election not won")__        }_        if (lastPublishedVersion != getLastAcceptedVersion()) {_            logger.debug("handleClientValue: cannot start publishing next value before accepting previous one")__            throw new CoordinationStateRejectedException("cannot start publishing next value before accepting previous one")__        }_        if (clusterState.term() != getCurrentTerm()) {_            logger.debug("handleClientValue: ignored request due to term mismatch " +_                    "(expected: [term {} version >{}], actual: [term {} version {}])",_                getCurrentTerm(), lastPublishedVersion, clusterState.term(), clusterState.version())__            throw new CoordinationStateRejectedException("incoming term " + clusterState.term() + " does not match current term " +_                getCurrentTerm())__        }_        if (clusterState.version() <= lastPublishedVersion) {_            logger.debug("handleClientValue: ignored request due to version mismatch " +_                    "(expected: [term {} version >{}], actual: [term {} version {}])",_                getCurrentTerm(), lastPublishedVersion, clusterState.term(), clusterState.version())__            throw new CoordinationStateRejectedException("incoming cluster state version " + clusterState.version() +_                " lower or equal to last published version " + lastPublishedVersion)__        }__        if (clusterState.getLastAcceptedConfiguration().equals(getLastAcceptedConfiguration()) == false_            && getLastCommittedConfiguration().equals(getLastAcceptedConfiguration()) == false) {_            logger.debug("handleClientValue: only allow reconfiguration while not already reconfiguring")__            throw new CoordinationStateRejectedException("only allow reconfiguration while not already reconfiguring")__        }_        if (joinVotesHaveQuorumFor(clusterState.getLastAcceptedConfiguration()) == false) {_            logger.debug("handleClientValue: only allow reconfiguration if joinVotes have quorum for new config")__            throw new CoordinationStateRejectedException("only allow reconfiguration if joinVotes have quorum for new config")__        }__        assert clusterState.getLastCommittedConfiguration().equals(getLastCommittedConfiguration()) :_            "last committed configuration should not change"___        lastPublishedVersion = clusterState.version()__        lastPublishedConfiguration = clusterState.getLastAcceptedConfiguration()__        publishVotes = new VoteCollection()___        logger.trace("handleClientValue: processing request for version [{}] and term [{}]", lastPublishedVersion, getCurrentTerm())___        return new PublishRequest(clusterState)__    };may,be,called,in,order,to,prepare,publication,of,the,given,cluster,state,param,cluster,state,the,cluster,state,to,publish,return,a,publish,request,to,publish,the,given,cluster,state,throws,coordination,state,rejected,exception,if,the,arguments,were,incompatible,with,the,current,state,of,this,object;public,publish,request,handle,client,value,cluster,state,cluster,state,if,election,won,false,logger,debug,handle,client,value,ignored,request,as,election,not,won,throw,new,coordination,state,rejected,exception,election,not,won,if,last,published,version,get,last,accepted,version,logger,debug,handle,client,value,cannot,start,publishing,next,value,before,accepting,previous,one,throw,new,coordination,state,rejected,exception,cannot,start,publishing,next,value,before,accepting,previous,one,if,cluster,state,term,get,current,term,logger,debug,handle,client,value,ignored,request,due,to,term,mismatch,expected,term,version,actual,term,version,get,current,term,last,published,version,cluster,state,term,cluster,state,version,throw,new,coordination,state,rejected,exception,incoming,term,cluster,state,term,does,not,match,current,term,get,current,term,if,cluster,state,version,last,published,version,logger,debug,handle,client,value,ignored,request,due,to,version,mismatch,expected,term,version,actual,term,version,get,current,term,last,published,version,cluster,state,term,cluster,state,version,throw,new,coordination,state,rejected,exception,incoming,cluster,state,version,cluster,state,version,lower,or,equal,to,last,published,version,last,published,version,if,cluster,state,get,last,accepted,configuration,equals,get,last,accepted,configuration,false,get,last,committed,configuration,equals,get,last,accepted,configuration,false,logger,debug,handle,client,value,only,allow,reconfiguration,while,not,already,reconfiguring,throw,new,coordination,state,rejected,exception,only,allow,reconfiguration,while,not,already,reconfiguring,if,join,votes,have,quorum,for,cluster,state,get,last,accepted,configuration,false,logger,debug,handle,client,value,only,allow,reconfiguration,if,join,votes,have,quorum,for,new,config,throw,new,coordination,state,rejected,exception,only,allow,reconfiguration,if,join,votes,have,quorum,for,new,config,assert,cluster,state,get,last,committed,configuration,equals,get,last,committed,configuration,last,committed,configuration,should,not,change,last,published,version,cluster,state,version,last,published,configuration,cluster,state,get,last,accepted,configuration,publish,votes,new,vote,collection,logger,trace,handle,client,value,processing,request,for,version,and,term,last,published,version,get,current,term,return,new,publish,request,cluster,state
CoordinationState -> public boolean handleJoin(Join join);1544081506;May be called on receipt of a Join.__@param join The Join received._@return true iff this instance does not already have a join vote from the given source node for this term_@throws CoordinationStateRejectedException if the arguments were incompatible with the current state of this object.;public boolean handleJoin(Join join) {_        assert join.getTargetNode().equals(localNode) : "handling join " + join + " for the wrong node " + localNode___        if (join.getTerm() != getCurrentTerm()) {_            logger.debug("handleJoin: ignored join due to term mismatch (expected: [{}], actual: [{}])",_                getCurrentTerm(), join.getTerm())__            throw new CoordinationStateRejectedException(_                "incoming term " + join.getTerm() + " does not match current term " + getCurrentTerm())__        }__        if (startedJoinSinceLastReboot == false) {_            logger.debug("handleJoin: ignored join as term was not incremented yet after reboot")__            throw new CoordinationStateRejectedException("ignored join as term has not been incremented yet after reboot")__        }__        final long lastAcceptedTerm = getLastAcceptedTerm()__        if (join.getLastAcceptedTerm() > lastAcceptedTerm) {_            logger.debug("handleJoin: ignored join as joiner has a better last accepted term (expected: <=[{}], actual: [{}])",_                lastAcceptedTerm, join.getLastAcceptedTerm())__            throw new CoordinationStateRejectedException("incoming last accepted term " + join.getLastAcceptedTerm() +_                " of join higher than current last accepted term " + lastAcceptedTerm)__        }__        if (join.getLastAcceptedTerm() == lastAcceptedTerm && join.getLastAcceptedVersion() > getLastAcceptedVersion()) {_            logger.debug("handleJoin: ignored join as joiner has a better last accepted version (expected: <=[{}], actual: [{}])",_                getLastAcceptedVersion(), join.getLastAcceptedVersion())__            throw new CoordinationStateRejectedException("incoming last accepted version " + join.getLastAcceptedVersion() +_                " of join higher than current last accepted version " + getLastAcceptedVersion())__        }__        if (getLastAcceptedVersion() == 0) {_            _            _            _            _            logger.debug("handleJoin: ignored join because initial configuration not set")__            throw new CoordinationStateRejectedException("initial configuration not set")__        }__        boolean added = joinVotes.addVote(join.getSourceNode())__        boolean prevElectionWon = electionWon__        electionWon = isElectionQuorum(joinVotes)__        assert !prevElectionWon || electionWon_ _        logger.debug("handleJoin: added join {} from [{}] for election, electionWon={} lastAcceptedTerm={} lastAcceptedVersion={}", join,_            join.getSourceNode(), electionWon, lastAcceptedTerm, getLastAcceptedVersion())___        if (electionWon && prevElectionWon == false) {_            logger.debug("handleJoin: election won in term [{}] with {}", getCurrentTerm(), joinVotes)__            lastPublishedVersion = getLastAcceptedVersion()__        }_        return added__    };may,be,called,on,receipt,of,a,join,param,join,the,join,received,return,true,iff,this,instance,does,not,already,have,a,join,vote,from,the,given,source,node,for,this,term,throws,coordination,state,rejected,exception,if,the,arguments,were,incompatible,with,the,current,state,of,this,object;public,boolean,handle,join,join,join,assert,join,get,target,node,equals,local,node,handling,join,join,for,the,wrong,node,local,node,if,join,get,term,get,current,term,logger,debug,handle,join,ignored,join,due,to,term,mismatch,expected,actual,get,current,term,join,get,term,throw,new,coordination,state,rejected,exception,incoming,term,join,get,term,does,not,match,current,term,get,current,term,if,started,join,since,last,reboot,false,logger,debug,handle,join,ignored,join,as,term,was,not,incremented,yet,after,reboot,throw,new,coordination,state,rejected,exception,ignored,join,as,term,has,not,been,incremented,yet,after,reboot,final,long,last,accepted,term,get,last,accepted,term,if,join,get,last,accepted,term,last,accepted,term,logger,debug,handle,join,ignored,join,as,joiner,has,a,better,last,accepted,term,expected,actual,last,accepted,term,join,get,last,accepted,term,throw,new,coordination,state,rejected,exception,incoming,last,accepted,term,join,get,last,accepted,term,of,join,higher,than,current,last,accepted,term,last,accepted,term,if,join,get,last,accepted,term,last,accepted,term,join,get,last,accepted,version,get,last,accepted,version,logger,debug,handle,join,ignored,join,as,joiner,has,a,better,last,accepted,version,expected,actual,get,last,accepted,version,join,get,last,accepted,version,throw,new,coordination,state,rejected,exception,incoming,last,accepted,version,join,get,last,accepted,version,of,join,higher,than,current,last,accepted,version,get,last,accepted,version,if,get,last,accepted,version,0,logger,debug,handle,join,ignored,join,because,initial,configuration,not,set,throw,new,coordination,state,rejected,exception,initial,configuration,not,set,boolean,added,join,votes,add,vote,join,get,source,node,boolean,prev,election,won,election,won,election,won,is,election,quorum,join,votes,assert,prev,election,won,election,won,logger,debug,handle,join,added,join,from,for,election,election,won,last,accepted,term,last,accepted,version,join,join,get,source,node,election,won,last,accepted,term,get,last,accepted,version,if,election,won,prev,election,won,false,logger,debug,handle,join,election,won,in,term,with,get,current,term,join,votes,last,published,version,get,last,accepted,version,return,added
CoordinationState -> public boolean handleJoin(Join join);1544254415;May be called on receipt of a Join.__@param join The Join received._@return true iff this instance does not already have a join vote from the given source node for this term_@throws CoordinationStateRejectedException if the arguments were incompatible with the current state of this object.;public boolean handleJoin(Join join) {_        assert join.getTargetNode().equals(localNode) : "handling join " + join + " for the wrong node " + localNode___        if (join.getTerm() != getCurrentTerm()) {_            logger.debug("handleJoin: ignored join due to term mismatch (expected: [{}], actual: [{}])",_                getCurrentTerm(), join.getTerm())__            throw new CoordinationStateRejectedException(_                "incoming term " + join.getTerm() + " does not match current term " + getCurrentTerm())__        }__        if (startedJoinSinceLastReboot == false) {_            logger.debug("handleJoin: ignored join as term was not incremented yet after reboot")__            throw new CoordinationStateRejectedException("ignored join as term has not been incremented yet after reboot")__        }__        final long lastAcceptedTerm = getLastAcceptedTerm()__        if (join.getLastAcceptedTerm() > lastAcceptedTerm) {_            logger.debug("handleJoin: ignored join as joiner has a better last accepted term (expected: <=[{}], actual: [{}])",_                lastAcceptedTerm, join.getLastAcceptedTerm())__            throw new CoordinationStateRejectedException("incoming last accepted term " + join.getLastAcceptedTerm() +_                " of join higher than current last accepted term " + lastAcceptedTerm)__        }__        if (join.getLastAcceptedTerm() == lastAcceptedTerm && join.getLastAcceptedVersion() > getLastAcceptedVersion()) {_            logger.debug("handleJoin: ignored join as joiner has a better last accepted version (expected: <=[{}], actual: [{}])",_                getLastAcceptedVersion(), join.getLastAcceptedVersion())__            throw new CoordinationStateRejectedException("incoming last accepted version " + join.getLastAcceptedVersion() +_                " of join higher than current last accepted version " + getLastAcceptedVersion())__        }__        if (getLastAcceptedVersion() == 0) {_            _            _            _            _            logger.debug("handleJoin: ignored join because initial configuration not set")__            throw new CoordinationStateRejectedException("initial configuration not set")__        }__        boolean added = joinVotes.addVote(join.getSourceNode())__        boolean prevElectionWon = electionWon__        electionWon = isElectionQuorum(joinVotes)__        assert !prevElectionWon || electionWon_ _        logger.debug("handleJoin: added join {} from [{}] for election, electionWon={} lastAcceptedTerm={} lastAcceptedVersion={}", join,_            join.getSourceNode(), electionWon, lastAcceptedTerm, getLastAcceptedVersion())___        if (electionWon && prevElectionWon == false) {_            logger.debug("handleJoin: election won in term [{}] with {}", getCurrentTerm(), joinVotes)__            lastPublishedVersion = getLastAcceptedVersion()__        }_        return added__    };may,be,called,on,receipt,of,a,join,param,join,the,join,received,return,true,iff,this,instance,does,not,already,have,a,join,vote,from,the,given,source,node,for,this,term,throws,coordination,state,rejected,exception,if,the,arguments,were,incompatible,with,the,current,state,of,this,object;public,boolean,handle,join,join,join,assert,join,get,target,node,equals,local,node,handling,join,join,for,the,wrong,node,local,node,if,join,get,term,get,current,term,logger,debug,handle,join,ignored,join,due,to,term,mismatch,expected,actual,get,current,term,join,get,term,throw,new,coordination,state,rejected,exception,incoming,term,join,get,term,does,not,match,current,term,get,current,term,if,started,join,since,last,reboot,false,logger,debug,handle,join,ignored,join,as,term,was,not,incremented,yet,after,reboot,throw,new,coordination,state,rejected,exception,ignored,join,as,term,has,not,been,incremented,yet,after,reboot,final,long,last,accepted,term,get,last,accepted,term,if,join,get,last,accepted,term,last,accepted,term,logger,debug,handle,join,ignored,join,as,joiner,has,a,better,last,accepted,term,expected,actual,last,accepted,term,join,get,last,accepted,term,throw,new,coordination,state,rejected,exception,incoming,last,accepted,term,join,get,last,accepted,term,of,join,higher,than,current,last,accepted,term,last,accepted,term,if,join,get,last,accepted,term,last,accepted,term,join,get,last,accepted,version,get,last,accepted,version,logger,debug,handle,join,ignored,join,as,joiner,has,a,better,last,accepted,version,expected,actual,get,last,accepted,version,join,get,last,accepted,version,throw,new,coordination,state,rejected,exception,incoming,last,accepted,version,join,get,last,accepted,version,of,join,higher,than,current,last,accepted,version,get,last,accepted,version,if,get,last,accepted,version,0,logger,debug,handle,join,ignored,join,because,initial,configuration,not,set,throw,new,coordination,state,rejected,exception,initial,configuration,not,set,boolean,added,join,votes,add,vote,join,get,source,node,boolean,prev,election,won,election,won,election,won,is,election,quorum,join,votes,assert,prev,election,won,election,won,logger,debug,handle,join,added,join,from,for,election,election,won,last,accepted,term,last,accepted,version,join,join,get,source,node,election,won,last,accepted,term,get,last,accepted,version,if,election,won,prev,election,won,false,logger,debug,handle,join,election,won,in,term,with,get,current,term,join,votes,last,published,version,get,last,accepted,version,return,added
CoordinationState -> public boolean handleJoin(Join join);1546592956;May be called on receipt of a Join.__@param join The Join received._@return true iff this instance does not already have a join vote from the given source node for this term_@throws CoordinationStateRejectedException if the arguments were incompatible with the current state of this object.;public boolean handleJoin(Join join) {_        assert join.getTargetNode().equals(localNode) : "handling join " + join + " for the wrong node " + localNode___        if (join.getTerm() != getCurrentTerm()) {_            logger.debug("handleJoin: ignored join due to term mismatch (expected: [{}], actual: [{}])",_                getCurrentTerm(), join.getTerm())__            throw new CoordinationStateRejectedException(_                "incoming term " + join.getTerm() + " does not match current term " + getCurrentTerm())__        }__        if (startedJoinSinceLastReboot == false) {_            logger.debug("handleJoin: ignored join as term was not incremented yet after reboot")__            throw new CoordinationStateRejectedException("ignored join as term has not been incremented yet after reboot")__        }__        final long lastAcceptedTerm = getLastAcceptedTerm()__        if (join.getLastAcceptedTerm() > lastAcceptedTerm) {_            logger.debug("handleJoin: ignored join as joiner has a better last accepted term (expected: <=[{}], actual: [{}])",_                lastAcceptedTerm, join.getLastAcceptedTerm())__            throw new CoordinationStateRejectedException("incoming last accepted term " + join.getLastAcceptedTerm() +_                " of join higher than current last accepted term " + lastAcceptedTerm)__        }__        if (join.getLastAcceptedTerm() == lastAcceptedTerm && join.getLastAcceptedVersion() > getLastAcceptedVersionOrMetaDataVersion()) {_            logger.debug(_                "handleJoin: ignored join as joiner has a better last accepted version (expected: <=[{}], actual: [{}]) in term {}",_                getLastAcceptedVersionOrMetaDataVersion(), join.getLastAcceptedVersion(), lastAcceptedTerm)__            throw new CoordinationStateRejectedException("incoming last accepted version " + join.getLastAcceptedVersion() +_                " of join higher than current last accepted version " + getLastAcceptedVersionOrMetaDataVersion()_                + " in term " + lastAcceptedTerm)__        }__        if (getLastAcceptedConfiguration().isEmpty()) {_            _            _            _            _            logger.debug("handleJoin: rejecting join since this node has not received its initial configuration yet")__            throw new CoordinationStateRejectedException("rejecting join since this node has not received its initial configuration yet")__        }__        boolean added = joinVotes.addVote(join.getSourceNode())__        boolean prevElectionWon = electionWon__        electionWon = isElectionQuorum(joinVotes)__        assert !prevElectionWon || electionWon_ _        logger.debug("handleJoin: added join {} from [{}] for election, electionWon={} lastAcceptedTerm={} lastAcceptedVersion={}", join,_            join.getSourceNode(), electionWon, lastAcceptedTerm, getLastAcceptedVersion())___        if (electionWon && prevElectionWon == false) {_            logger.debug("handleJoin: election won in term [{}] with {}", getCurrentTerm(), joinVotes)__            lastPublishedVersion = getLastAcceptedVersion()__        }_        return added__    };may,be,called,on,receipt,of,a,join,param,join,the,join,received,return,true,iff,this,instance,does,not,already,have,a,join,vote,from,the,given,source,node,for,this,term,throws,coordination,state,rejected,exception,if,the,arguments,were,incompatible,with,the,current,state,of,this,object;public,boolean,handle,join,join,join,assert,join,get,target,node,equals,local,node,handling,join,join,for,the,wrong,node,local,node,if,join,get,term,get,current,term,logger,debug,handle,join,ignored,join,due,to,term,mismatch,expected,actual,get,current,term,join,get,term,throw,new,coordination,state,rejected,exception,incoming,term,join,get,term,does,not,match,current,term,get,current,term,if,started,join,since,last,reboot,false,logger,debug,handle,join,ignored,join,as,term,was,not,incremented,yet,after,reboot,throw,new,coordination,state,rejected,exception,ignored,join,as,term,has,not,been,incremented,yet,after,reboot,final,long,last,accepted,term,get,last,accepted,term,if,join,get,last,accepted,term,last,accepted,term,logger,debug,handle,join,ignored,join,as,joiner,has,a,better,last,accepted,term,expected,actual,last,accepted,term,join,get,last,accepted,term,throw,new,coordination,state,rejected,exception,incoming,last,accepted,term,join,get,last,accepted,term,of,join,higher,than,current,last,accepted,term,last,accepted,term,if,join,get,last,accepted,term,last,accepted,term,join,get,last,accepted,version,get,last,accepted,version,or,meta,data,version,logger,debug,handle,join,ignored,join,as,joiner,has,a,better,last,accepted,version,expected,actual,in,term,get,last,accepted,version,or,meta,data,version,join,get,last,accepted,version,last,accepted,term,throw,new,coordination,state,rejected,exception,incoming,last,accepted,version,join,get,last,accepted,version,of,join,higher,than,current,last,accepted,version,get,last,accepted,version,or,meta,data,version,in,term,last,accepted,term,if,get,last,accepted,configuration,is,empty,logger,debug,handle,join,rejecting,join,since,this,node,has,not,received,its,initial,configuration,yet,throw,new,coordination,state,rejected,exception,rejecting,join,since,this,node,has,not,received,its,initial,configuration,yet,boolean,added,join,votes,add,vote,join,get,source,node,boolean,prev,election,won,election,won,election,won,is,election,quorum,join,votes,assert,prev,election,won,election,won,logger,debug,handle,join,added,join,from,for,election,election,won,last,accepted,term,last,accepted,version,join,join,get,source,node,election,won,last,accepted,term,get,last,accepted,version,if,election,won,prev,election,won,false,logger,debug,handle,join,election,won,in,term,with,get,current,term,join,votes,last,published,version,get,last,accepted,version,return,added
CoordinationState -> public boolean handleJoin(Join join);1547219208;May be called on receipt of a Join.__@param join The Join received._@return true iff this instance does not already have a join vote from the given source node for this term_@throws CoordinationStateRejectedException if the arguments were incompatible with the current state of this object.;public boolean handleJoin(Join join) {_        assert join.targetMatches(localNode) : "handling join " + join + " for the wrong node " + localNode___        if (join.getTerm() != getCurrentTerm()) {_            logger.debug("handleJoin: ignored join due to term mismatch (expected: [{}], actual: [{}])",_                getCurrentTerm(), join.getTerm())__            throw new CoordinationStateRejectedException(_                "incoming term " + join.getTerm() + " does not match current term " + getCurrentTerm())__        }__        if (startedJoinSinceLastReboot == false) {_            logger.debug("handleJoin: ignored join as term was not incremented yet after reboot")__            throw new CoordinationStateRejectedException("ignored join as term has not been incremented yet after reboot")__        }__        final long lastAcceptedTerm = getLastAcceptedTerm()__        if (join.getLastAcceptedTerm() > lastAcceptedTerm) {_            logger.debug("handleJoin: ignored join as joiner has a better last accepted term (expected: <=[{}], actual: [{}])",_                lastAcceptedTerm, join.getLastAcceptedTerm())__            throw new CoordinationStateRejectedException("incoming last accepted term " + join.getLastAcceptedTerm() +_                " of join higher than current last accepted term " + lastAcceptedTerm)__        }__        if (join.getLastAcceptedTerm() == lastAcceptedTerm && join.getLastAcceptedVersion() > getLastAcceptedVersionOrMetaDataVersion()) {_            logger.debug(_                "handleJoin: ignored join as joiner has a better last accepted version (expected: <=[{}], actual: [{}]) in term {}",_                getLastAcceptedVersionOrMetaDataVersion(), join.getLastAcceptedVersion(), lastAcceptedTerm)__            throw new CoordinationStateRejectedException("incoming last accepted version " + join.getLastAcceptedVersion() +_                " of join higher than current last accepted version " + getLastAcceptedVersionOrMetaDataVersion()_                + " in term " + lastAcceptedTerm)__        }__        if (getLastAcceptedConfiguration().isEmpty()) {_            _            _            _            _            logger.debug("handleJoin: rejecting join since this node has not received its initial configuration yet")__            throw new CoordinationStateRejectedException("rejecting join since this node has not received its initial configuration yet")__        }__        boolean added = joinVotes.addVote(join.getSourceNode())__        boolean prevElectionWon = electionWon__        electionWon = isElectionQuorum(joinVotes)__        assert !prevElectionWon || electionWon_ _        logger.debug("handleJoin: added join {} from [{}] for election, electionWon={} lastAcceptedTerm={} lastAcceptedVersion={}", join,_            join.getSourceNode(), electionWon, lastAcceptedTerm, getLastAcceptedVersion())___        if (electionWon && prevElectionWon == false) {_            logger.debug("handleJoin: election won in term [{}] with {}", getCurrentTerm(), joinVotes)__            lastPublishedVersion = getLastAcceptedVersion()__        }_        return added__    };may,be,called,on,receipt,of,a,join,param,join,the,join,received,return,true,iff,this,instance,does,not,already,have,a,join,vote,from,the,given,source,node,for,this,term,throws,coordination,state,rejected,exception,if,the,arguments,were,incompatible,with,the,current,state,of,this,object;public,boolean,handle,join,join,join,assert,join,target,matches,local,node,handling,join,join,for,the,wrong,node,local,node,if,join,get,term,get,current,term,logger,debug,handle,join,ignored,join,due,to,term,mismatch,expected,actual,get,current,term,join,get,term,throw,new,coordination,state,rejected,exception,incoming,term,join,get,term,does,not,match,current,term,get,current,term,if,started,join,since,last,reboot,false,logger,debug,handle,join,ignored,join,as,term,was,not,incremented,yet,after,reboot,throw,new,coordination,state,rejected,exception,ignored,join,as,term,has,not,been,incremented,yet,after,reboot,final,long,last,accepted,term,get,last,accepted,term,if,join,get,last,accepted,term,last,accepted,term,logger,debug,handle,join,ignored,join,as,joiner,has,a,better,last,accepted,term,expected,actual,last,accepted,term,join,get,last,accepted,term,throw,new,coordination,state,rejected,exception,incoming,last,accepted,term,join,get,last,accepted,term,of,join,higher,than,current,last,accepted,term,last,accepted,term,if,join,get,last,accepted,term,last,accepted,term,join,get,last,accepted,version,get,last,accepted,version,or,meta,data,version,logger,debug,handle,join,ignored,join,as,joiner,has,a,better,last,accepted,version,expected,actual,in,term,get,last,accepted,version,or,meta,data,version,join,get,last,accepted,version,last,accepted,term,throw,new,coordination,state,rejected,exception,incoming,last,accepted,version,join,get,last,accepted,version,of,join,higher,than,current,last,accepted,version,get,last,accepted,version,or,meta,data,version,in,term,last,accepted,term,if,get,last,accepted,configuration,is,empty,logger,debug,handle,join,rejecting,join,since,this,node,has,not,received,its,initial,configuration,yet,throw,new,coordination,state,rejected,exception,rejecting,join,since,this,node,has,not,received,its,initial,configuration,yet,boolean,added,join,votes,add,vote,join,get,source,node,boolean,prev,election,won,election,won,election,won,is,election,quorum,join,votes,assert,prev,election,won,election,won,logger,debug,handle,join,added,join,from,for,election,election,won,last,accepted,term,last,accepted,version,join,join,get,source,node,election,won,last,accepted,term,get,last,accepted,version,if,election,won,prev,election,won,false,logger,debug,handle,join,election,won,in,term,with,get,current,term,join,votes,last,published,version,get,last,accepted,version,return,added
CoordinationState -> public boolean handleJoin(Join join);1548772865;May be called on receipt of a Join.__@param join The Join received._@return true iff this instance does not already have a join vote from the given source node for this term_@throws CoordinationStateRejectedException if the arguments were incompatible with the current state of this object.;public boolean handleJoin(Join join) {_        assert join.targetMatches(localNode) : "handling join " + join + " for the wrong node " + localNode___        if (join.getTerm() != getCurrentTerm()) {_            logger.debug("handleJoin: ignored join due to term mismatch (expected: [{}], actual: [{}])",_                getCurrentTerm(), join.getTerm())__            throw new CoordinationStateRejectedException(_                "incoming term " + join.getTerm() + " does not match current term " + getCurrentTerm())__        }__        if (startedJoinSinceLastReboot == false) {_            logger.debug("handleJoin: ignored join as term was not incremented yet after reboot")__            throw new CoordinationStateRejectedException("ignored join as term has not been incremented yet after reboot")__        }__        final long lastAcceptedTerm = getLastAcceptedTerm()__        if (join.getLastAcceptedTerm() > lastAcceptedTerm) {_            logger.debug("handleJoin: ignored join as joiner has a better last accepted term (expected: <=[{}], actual: [{}])",_                lastAcceptedTerm, join.getLastAcceptedTerm())__            throw new CoordinationStateRejectedException("incoming last accepted term " + join.getLastAcceptedTerm() +_                " of join higher than current last accepted term " + lastAcceptedTerm)__        }__        if (join.getLastAcceptedTerm() == lastAcceptedTerm && join.getLastAcceptedVersion() > getLastAcceptedVersionOrMetaDataVersion()) {_            logger.debug(_                "handleJoin: ignored join as joiner has a better last accepted version (expected: <=[{}], actual: [{}]) in term {}",_                getLastAcceptedVersionOrMetaDataVersion(), join.getLastAcceptedVersion(), lastAcceptedTerm)__            throw new CoordinationStateRejectedException("incoming last accepted version " + join.getLastAcceptedVersion() +_                " of join higher than current last accepted version " + getLastAcceptedVersionOrMetaDataVersion()_                + " in term " + lastAcceptedTerm)__        }__        if (getLastAcceptedConfiguration().isEmpty()) {_            _            _            _            _            logger.debug("handleJoin: rejecting join since this node has not received its initial configuration yet")__            throw new CoordinationStateRejectedException("rejecting join since this node has not received its initial configuration yet")__        }__        boolean added = joinVotes.addVote(join.getSourceNode())__        boolean prevElectionWon = electionWon__        electionWon = isElectionQuorum(joinVotes)__        assert !prevElectionWon || electionWon_ _        logger.debug("handleJoin: added join {} from [{}] for election, electionWon={} lastAcceptedTerm={} lastAcceptedVersion={}", join,_            join.getSourceNode(), electionWon, lastAcceptedTerm, getLastAcceptedVersion())___        if (electionWon && prevElectionWon == false) {_            logger.debug("handleJoin: election won in term [{}] with {}", getCurrentTerm(), joinVotes)__            lastPublishedVersion = getLastAcceptedVersion()__        }_        return added__    };may,be,called,on,receipt,of,a,join,param,join,the,join,received,return,true,iff,this,instance,does,not,already,have,a,join,vote,from,the,given,source,node,for,this,term,throws,coordination,state,rejected,exception,if,the,arguments,were,incompatible,with,the,current,state,of,this,object;public,boolean,handle,join,join,join,assert,join,target,matches,local,node,handling,join,join,for,the,wrong,node,local,node,if,join,get,term,get,current,term,logger,debug,handle,join,ignored,join,due,to,term,mismatch,expected,actual,get,current,term,join,get,term,throw,new,coordination,state,rejected,exception,incoming,term,join,get,term,does,not,match,current,term,get,current,term,if,started,join,since,last,reboot,false,logger,debug,handle,join,ignored,join,as,term,was,not,incremented,yet,after,reboot,throw,new,coordination,state,rejected,exception,ignored,join,as,term,has,not,been,incremented,yet,after,reboot,final,long,last,accepted,term,get,last,accepted,term,if,join,get,last,accepted,term,last,accepted,term,logger,debug,handle,join,ignored,join,as,joiner,has,a,better,last,accepted,term,expected,actual,last,accepted,term,join,get,last,accepted,term,throw,new,coordination,state,rejected,exception,incoming,last,accepted,term,join,get,last,accepted,term,of,join,higher,than,current,last,accepted,term,last,accepted,term,if,join,get,last,accepted,term,last,accepted,term,join,get,last,accepted,version,get,last,accepted,version,or,meta,data,version,logger,debug,handle,join,ignored,join,as,joiner,has,a,better,last,accepted,version,expected,actual,in,term,get,last,accepted,version,or,meta,data,version,join,get,last,accepted,version,last,accepted,term,throw,new,coordination,state,rejected,exception,incoming,last,accepted,version,join,get,last,accepted,version,of,join,higher,than,current,last,accepted,version,get,last,accepted,version,or,meta,data,version,in,term,last,accepted,term,if,get,last,accepted,configuration,is,empty,logger,debug,handle,join,rejecting,join,since,this,node,has,not,received,its,initial,configuration,yet,throw,new,coordination,state,rejected,exception,rejecting,join,since,this,node,has,not,received,its,initial,configuration,yet,boolean,added,join,votes,add,vote,join,get,source,node,boolean,prev,election,won,election,won,election,won,is,election,quorum,join,votes,assert,prev,election,won,election,won,logger,debug,handle,join,added,join,from,for,election,election,won,last,accepted,term,last,accepted,version,join,join,get,source,node,election,won,last,accepted,term,get,last,accepted,version,if,election,won,prev,election,won,false,logger,debug,handle,join,election,won,in,term,with,get,current,term,join,votes,last,published,version,get,last,accepted,version,return,added
CoordinationState -> PersistedState -> ClusterState getLastAcceptedState()_;1544081506;Returns the last accepted cluster state;ClusterState getLastAcceptedState()_;returns,the,last,accepted,cluster,state;cluster,state,get,last,accepted,state
CoordinationState -> PersistedState -> ClusterState getLastAcceptedState()_;1544254415;Returns the last accepted cluster state;ClusterState getLastAcceptedState()_;returns,the,last,accepted,cluster,state;cluster,state,get,last,accepted,state
CoordinationState -> PersistedState -> ClusterState getLastAcceptedState()_;1546592956;Returns the last accepted cluster state;ClusterState getLastAcceptedState()_;returns,the,last,accepted,cluster,state;cluster,state,get,last,accepted,state
CoordinationState -> PersistedState -> ClusterState getLastAcceptedState()_;1547219208;Returns the last accepted cluster state;ClusterState getLastAcceptedState()_;returns,the,last,accepted,cluster,state;cluster,state,get,last,accepted,state
CoordinationState -> PersistedState -> ClusterState getLastAcceptedState()_;1548772865;Returns the last accepted cluster state;ClusterState getLastAcceptedState()_;returns,the,last,accepted,cluster,state;cluster,state,get,last,accepted,state
CoordinationState -> PersistedState -> long getCurrentTerm()_;1544081506;Returns the current term;long getCurrentTerm()_;returns,the,current,term;long,get,current,term
CoordinationState -> PersistedState -> long getCurrentTerm()_;1544254415;Returns the current term;long getCurrentTerm()_;returns,the,current,term;long,get,current,term
CoordinationState -> PersistedState -> long getCurrentTerm()_;1546592956;Returns the current term;long getCurrentTerm()_;returns,the,current,term;long,get,current,term
CoordinationState -> PersistedState -> long getCurrentTerm()_;1547219208;Returns the current term;long getCurrentTerm()_;returns,the,current,term;long,get,current,term
CoordinationState -> PersistedState -> long getCurrentTerm()_;1548772865;Returns the current term;long getCurrentTerm()_;returns,the,current,term;long,get,current,term
CoordinationState -> public PublishResponse handlePublishRequest(PublishRequest publishRequest);1544081506;May be called on receipt of a PublishRequest.__@param publishRequest The publish request received._@return A PublishResponse which can be sent back to the sender of the PublishRequest._@throws CoordinationStateRejectedException if the arguments were incompatible with the current state of this object.;public PublishResponse handlePublishRequest(PublishRequest publishRequest) {_        final ClusterState clusterState = publishRequest.getAcceptedState()__        if (clusterState.term() != getCurrentTerm()) {_            logger.debug("handlePublishRequest: ignored publish request due to term mismatch (expected: [{}], actual: [{}])",_                getCurrentTerm(), clusterState.term())__            throw new CoordinationStateRejectedException("incoming term " + clusterState.term() + " does not match current term " +_                getCurrentTerm())__        }_        if (clusterState.term() == getLastAcceptedTerm() && clusterState.version() <= getLastAcceptedVersion()) {_            logger.debug("handlePublishRequest: ignored publish request due to version mismatch (expected: >[{}], actual: [{}])",_                getLastAcceptedVersion(), clusterState.version())__            throw new CoordinationStateRejectedException("incoming version " + clusterState.version() +_                " lower or equal to current version " + getLastAcceptedVersion())__        }__        logger.trace("handlePublishRequest: accepting publish request for version [{}] and term [{}]",_            clusterState.version(), clusterState.term())__        persistedState.setLastAcceptedState(clusterState)__        assert getLastAcceptedState() == clusterState___        return new PublishResponse(clusterState.term(), clusterState.version())__    };may,be,called,on,receipt,of,a,publish,request,param,publish,request,the,publish,request,received,return,a,publish,response,which,can,be,sent,back,to,the,sender,of,the,publish,request,throws,coordination,state,rejected,exception,if,the,arguments,were,incompatible,with,the,current,state,of,this,object;public,publish,response,handle,publish,request,publish,request,publish,request,final,cluster,state,cluster,state,publish,request,get,accepted,state,if,cluster,state,term,get,current,term,logger,debug,handle,publish,request,ignored,publish,request,due,to,term,mismatch,expected,actual,get,current,term,cluster,state,term,throw,new,coordination,state,rejected,exception,incoming,term,cluster,state,term,does,not,match,current,term,get,current,term,if,cluster,state,term,get,last,accepted,term,cluster,state,version,get,last,accepted,version,logger,debug,handle,publish,request,ignored,publish,request,due,to,version,mismatch,expected,actual,get,last,accepted,version,cluster,state,version,throw,new,coordination,state,rejected,exception,incoming,version,cluster,state,version,lower,or,equal,to,current,version,get,last,accepted,version,logger,trace,handle,publish,request,accepting,publish,request,for,version,and,term,cluster,state,version,cluster,state,term,persisted,state,set,last,accepted,state,cluster,state,assert,get,last,accepted,state,cluster,state,return,new,publish,response,cluster,state,term,cluster,state,version
CoordinationState -> public PublishResponse handlePublishRequest(PublishRequest publishRequest);1544254415;May be called on receipt of a PublishRequest.__@param publishRequest The publish request received._@return A PublishResponse which can be sent back to the sender of the PublishRequest._@throws CoordinationStateRejectedException if the arguments were incompatible with the current state of this object.;public PublishResponse handlePublishRequest(PublishRequest publishRequest) {_        final ClusterState clusterState = publishRequest.getAcceptedState()__        if (clusterState.term() != getCurrentTerm()) {_            logger.debug("handlePublishRequest: ignored publish request due to term mismatch (expected: [{}], actual: [{}])",_                getCurrentTerm(), clusterState.term())__            throw new CoordinationStateRejectedException("incoming term " + clusterState.term() + " does not match current term " +_                getCurrentTerm())__        }_        if (clusterState.term() == getLastAcceptedTerm() && clusterState.version() <= getLastAcceptedVersion()) {_            if (clusterState.term() == ZEN1_BWC_TERM_                && clusterState.nodes().getMasterNode().equals(getLastAcceptedState().nodes().getMasterNode()) == false) {_                logger.debug("handling publish request in compatibility mode despite version mismatch (expected: >[{}], actual: [{}])",_                    getLastAcceptedVersion(), clusterState.version())__            } else {_                logger.debug("handlePublishRequest: ignored publish request due to version mismatch (expected: >[{}], actual: [{}])",_                    getLastAcceptedVersion(), clusterState.version())__                throw new CoordinationStateRejectedException("incoming version " + clusterState.version() +_                    " lower or equal to current version " + getLastAcceptedVersion())__            }_        }__        logger.trace("handlePublishRequest: accepting publish request for version [{}] and term [{}]",_            clusterState.version(), clusterState.term())__        persistedState.setLastAcceptedState(clusterState)__        assert getLastAcceptedState() == clusterState___        return new PublishResponse(clusterState.term(), clusterState.version())__    };may,be,called,on,receipt,of,a,publish,request,param,publish,request,the,publish,request,received,return,a,publish,response,which,can,be,sent,back,to,the,sender,of,the,publish,request,throws,coordination,state,rejected,exception,if,the,arguments,were,incompatible,with,the,current,state,of,this,object;public,publish,response,handle,publish,request,publish,request,publish,request,final,cluster,state,cluster,state,publish,request,get,accepted,state,if,cluster,state,term,get,current,term,logger,debug,handle,publish,request,ignored,publish,request,due,to,term,mismatch,expected,actual,get,current,term,cluster,state,term,throw,new,coordination,state,rejected,exception,incoming,term,cluster,state,term,does,not,match,current,term,get,current,term,if,cluster,state,term,get,last,accepted,term,cluster,state,version,get,last,accepted,version,if,cluster,state,term,cluster,state,nodes,get,master,node,equals,get,last,accepted,state,nodes,get,master,node,false,logger,debug,handling,publish,request,in,compatibility,mode,despite,version,mismatch,expected,actual,get,last,accepted,version,cluster,state,version,else,logger,debug,handle,publish,request,ignored,publish,request,due,to,version,mismatch,expected,actual,get,last,accepted,version,cluster,state,version,throw,new,coordination,state,rejected,exception,incoming,version,cluster,state,version,lower,or,equal,to,current,version,get,last,accepted,version,logger,trace,handle,publish,request,accepting,publish,request,for,version,and,term,cluster,state,version,cluster,state,term,persisted,state,set,last,accepted,state,cluster,state,assert,get,last,accepted,state,cluster,state,return,new,publish,response,cluster,state,term,cluster,state,version
CoordinationState -> public PublishResponse handlePublishRequest(PublishRequest publishRequest);1546592956;May be called on receipt of a PublishRequest.__@param publishRequest The publish request received._@return A PublishResponse which can be sent back to the sender of the PublishRequest._@throws CoordinationStateRejectedException if the arguments were incompatible with the current state of this object.;public PublishResponse handlePublishRequest(PublishRequest publishRequest) {_        final ClusterState clusterState = publishRequest.getAcceptedState()__        if (clusterState.term() != getCurrentTerm()) {_            logger.debug("handlePublishRequest: ignored publish request due to term mismatch (expected: [{}], actual: [{}])",_                getCurrentTerm(), clusterState.term())__            throw new CoordinationStateRejectedException("incoming term " + clusterState.term() + " does not match current term " +_                getCurrentTerm())__        }_        if (clusterState.term() == getLastAcceptedTerm() && clusterState.version() <= getLastAcceptedVersion()) {_            if (clusterState.term() == ZEN1_BWC_TERM_                && clusterState.nodes().getMasterNode().equals(getLastAcceptedState().nodes().getMasterNode()) == false) {_                logger.debug("handling publish request in compatibility mode despite version mismatch (expected: >[{}], actual: [{}])",_                    getLastAcceptedVersion(), clusterState.version())__            } else {_                logger.debug("handlePublishRequest: ignored publish request due to version mismatch (expected: >[{}], actual: [{}])",_                    getLastAcceptedVersion(), clusterState.version())__                throw new CoordinationStateRejectedException("incoming version " + clusterState.version() +_                    " lower or equal to current version " + getLastAcceptedVersion())__            }_        }__        logger.trace("handlePublishRequest: accepting publish request for version [{}] and term [{}]",_            clusterState.version(), clusterState.term())__        persistedState.setLastAcceptedState(clusterState)__        assert getLastAcceptedState() == clusterState___        return new PublishResponse(clusterState.term(), clusterState.version())__    };may,be,called,on,receipt,of,a,publish,request,param,publish,request,the,publish,request,received,return,a,publish,response,which,can,be,sent,back,to,the,sender,of,the,publish,request,throws,coordination,state,rejected,exception,if,the,arguments,were,incompatible,with,the,current,state,of,this,object;public,publish,response,handle,publish,request,publish,request,publish,request,final,cluster,state,cluster,state,publish,request,get,accepted,state,if,cluster,state,term,get,current,term,logger,debug,handle,publish,request,ignored,publish,request,due,to,term,mismatch,expected,actual,get,current,term,cluster,state,term,throw,new,coordination,state,rejected,exception,incoming,term,cluster,state,term,does,not,match,current,term,get,current,term,if,cluster,state,term,get,last,accepted,term,cluster,state,version,get,last,accepted,version,if,cluster,state,term,cluster,state,nodes,get,master,node,equals,get,last,accepted,state,nodes,get,master,node,false,logger,debug,handling,publish,request,in,compatibility,mode,despite,version,mismatch,expected,actual,get,last,accepted,version,cluster,state,version,else,logger,debug,handle,publish,request,ignored,publish,request,due,to,version,mismatch,expected,actual,get,last,accepted,version,cluster,state,version,throw,new,coordination,state,rejected,exception,incoming,version,cluster,state,version,lower,or,equal,to,current,version,get,last,accepted,version,logger,trace,handle,publish,request,accepting,publish,request,for,version,and,term,cluster,state,version,cluster,state,term,persisted,state,set,last,accepted,state,cluster,state,assert,get,last,accepted,state,cluster,state,return,new,publish,response,cluster,state,term,cluster,state,version
CoordinationState -> public PublishResponse handlePublishRequest(PublishRequest publishRequest);1547219208;May be called on receipt of a PublishRequest.__@param publishRequest The publish request received._@return A PublishResponse which can be sent back to the sender of the PublishRequest._@throws CoordinationStateRejectedException if the arguments were incompatible with the current state of this object.;public PublishResponse handlePublishRequest(PublishRequest publishRequest) {_        final ClusterState clusterState = publishRequest.getAcceptedState()__        if (clusterState.term() != getCurrentTerm()) {_            logger.debug("handlePublishRequest: ignored publish request due to term mismatch (expected: [{}], actual: [{}])",_                getCurrentTerm(), clusterState.term())__            throw new CoordinationStateRejectedException("incoming term " + clusterState.term() + " does not match current term " +_                getCurrentTerm())__        }_        if (clusterState.term() == getLastAcceptedTerm() && clusterState.version() <= getLastAcceptedVersion()) {_            if (clusterState.term() == ZEN1_BWC_TERM_                && clusterState.nodes().getMasterNode().equals(getLastAcceptedState().nodes().getMasterNode()) == false) {_                logger.debug("handling publish request in compatibility mode despite version mismatch (expected: >[{}], actual: [{}])",_                    getLastAcceptedVersion(), clusterState.version())__            } else {_                logger.debug("handlePublishRequest: ignored publish request due to version mismatch (expected: >[{}], actual: [{}])",_                    getLastAcceptedVersion(), clusterState.version())__                throw new CoordinationStateRejectedException("incoming version " + clusterState.version() +_                    " lower or equal to current version " + getLastAcceptedVersion())__            }_        }__        logger.trace("handlePublishRequest: accepting publish request for version [{}] and term [{}]",_            clusterState.version(), clusterState.term())__        persistedState.setLastAcceptedState(clusterState)__        assert getLastAcceptedState() == clusterState___        return new PublishResponse(clusterState.term(), clusterState.version())__    };may,be,called,on,receipt,of,a,publish,request,param,publish,request,the,publish,request,received,return,a,publish,response,which,can,be,sent,back,to,the,sender,of,the,publish,request,throws,coordination,state,rejected,exception,if,the,arguments,were,incompatible,with,the,current,state,of,this,object;public,publish,response,handle,publish,request,publish,request,publish,request,final,cluster,state,cluster,state,publish,request,get,accepted,state,if,cluster,state,term,get,current,term,logger,debug,handle,publish,request,ignored,publish,request,due,to,term,mismatch,expected,actual,get,current,term,cluster,state,term,throw,new,coordination,state,rejected,exception,incoming,term,cluster,state,term,does,not,match,current,term,get,current,term,if,cluster,state,term,get,last,accepted,term,cluster,state,version,get,last,accepted,version,if,cluster,state,term,cluster,state,nodes,get,master,node,equals,get,last,accepted,state,nodes,get,master,node,false,logger,debug,handling,publish,request,in,compatibility,mode,despite,version,mismatch,expected,actual,get,last,accepted,version,cluster,state,version,else,logger,debug,handle,publish,request,ignored,publish,request,due,to,version,mismatch,expected,actual,get,last,accepted,version,cluster,state,version,throw,new,coordination,state,rejected,exception,incoming,version,cluster,state,version,lower,or,equal,to,current,version,get,last,accepted,version,logger,trace,handle,publish,request,accepting,publish,request,for,version,and,term,cluster,state,version,cluster,state,term,persisted,state,set,last,accepted,state,cluster,state,assert,get,last,accepted,state,cluster,state,return,new,publish,response,cluster,state,term,cluster,state,version
CoordinationState -> public PublishResponse handlePublishRequest(PublishRequest publishRequest);1548772865;May be called on receipt of a PublishRequest.__@param publishRequest The publish request received._@return A PublishResponse which can be sent back to the sender of the PublishRequest._@throws CoordinationStateRejectedException if the arguments were incompatible with the current state of this object.;public PublishResponse handlePublishRequest(PublishRequest publishRequest) {_        final ClusterState clusterState = publishRequest.getAcceptedState()__        if (clusterState.term() != getCurrentTerm()) {_            logger.debug("handlePublishRequest: ignored publish request due to term mismatch (expected: [{}], actual: [{}])",_                getCurrentTerm(), clusterState.term())__            throw new CoordinationStateRejectedException("incoming term " + clusterState.term() + " does not match current term " +_                getCurrentTerm())__        }_        if (clusterState.term() == getLastAcceptedTerm() && clusterState.version() <= getLastAcceptedVersion()) {_            if (clusterState.term() == ZEN1_BWC_TERM_                && clusterState.nodes().getMasterNode().equals(getLastAcceptedState().nodes().getMasterNode()) == false) {_                logger.debug("handling publish request in compatibility mode despite version mismatch (expected: >[{}], actual: [{}])",_                    getLastAcceptedVersion(), clusterState.version())__            } else {_                logger.debug("handlePublishRequest: ignored publish request due to version mismatch (expected: >[{}], actual: [{}])",_                    getLastAcceptedVersion(), clusterState.version())__                throw new CoordinationStateRejectedException("incoming version " + clusterState.version() +_                    " lower or equal to current version " + getLastAcceptedVersion())__            }_        }__        logger.trace("handlePublishRequest: accepting publish request for version [{}] and term [{}]",_            clusterState.version(), clusterState.term())__        persistedState.setLastAcceptedState(clusterState)__        assert getLastAcceptedState() == clusterState___        return new PublishResponse(clusterState.term(), clusterState.version())__    };may,be,called,on,receipt,of,a,publish,request,param,publish,request,the,publish,request,received,return,a,publish,response,which,can,be,sent,back,to,the,sender,of,the,publish,request,throws,coordination,state,rejected,exception,if,the,arguments,were,incompatible,with,the,current,state,of,this,object;public,publish,response,handle,publish,request,publish,request,publish,request,final,cluster,state,cluster,state,publish,request,get,accepted,state,if,cluster,state,term,get,current,term,logger,debug,handle,publish,request,ignored,publish,request,due,to,term,mismatch,expected,actual,get,current,term,cluster,state,term,throw,new,coordination,state,rejected,exception,incoming,term,cluster,state,term,does,not,match,current,term,get,current,term,if,cluster,state,term,get,last,accepted,term,cluster,state,version,get,last,accepted,version,if,cluster,state,term,cluster,state,nodes,get,master,node,equals,get,last,accepted,state,nodes,get,master,node,false,logger,debug,handling,publish,request,in,compatibility,mode,despite,version,mismatch,expected,actual,get,last,accepted,version,cluster,state,version,else,logger,debug,handle,publish,request,ignored,publish,request,due,to,version,mismatch,expected,actual,get,last,accepted,version,cluster,state,version,throw,new,coordination,state,rejected,exception,incoming,version,cluster,state,version,lower,or,equal,to,current,version,get,last,accepted,version,logger,trace,handle,publish,request,accepting,publish,request,for,version,and,term,cluster,state,version,cluster,state,term,persisted,state,set,last,accepted,state,cluster,state,assert,get,last,accepted,state,cluster,state,return,new,publish,response,cluster,state,term,cluster,state,version
CoordinationState -> PersistedState -> void setLastAcceptedState(ClusterState clusterState)_;1544081506;Sets a new last accepted cluster state._After a successful call to this method, {@link #getLastAcceptedState()} should return the last cluster state that was set._The value returned by {@link #getCurrentTerm()} should not be influenced by calls to this method.;void setLastAcceptedState(ClusterState clusterState)_;sets,a,new,last,accepted,cluster,state,after,a,successful,call,to,this,method,link,get,last,accepted,state,should,return,the,last,cluster,state,that,was,set,the,value,returned,by,link,get,current,term,should,not,be,influenced,by,calls,to,this,method;void,set,last,accepted,state,cluster,state,cluster,state
CoordinationState -> PersistedState -> void setLastAcceptedState(ClusterState clusterState)_;1544254415;Sets a new last accepted cluster state._After a successful call to this method, {@link #getLastAcceptedState()} should return the last cluster state that was set._The value returned by {@link #getCurrentTerm()} should not be influenced by calls to this method.;void setLastAcceptedState(ClusterState clusterState)_;sets,a,new,last,accepted,cluster,state,after,a,successful,call,to,this,method,link,get,last,accepted,state,should,return,the,last,cluster,state,that,was,set,the,value,returned,by,link,get,current,term,should,not,be,influenced,by,calls,to,this,method;void,set,last,accepted,state,cluster,state,cluster,state
CoordinationState -> PersistedState -> void setLastAcceptedState(ClusterState clusterState)_;1546592956;Sets a new last accepted cluster state._After a successful call to this method, {@link #getLastAcceptedState()} should return the last cluster state that was set._The value returned by {@link #getCurrentTerm()} should not be influenced by calls to this method.;void setLastAcceptedState(ClusterState clusterState)_;sets,a,new,last,accepted,cluster,state,after,a,successful,call,to,this,method,link,get,last,accepted,state,should,return,the,last,cluster,state,that,was,set,the,value,returned,by,link,get,current,term,should,not,be,influenced,by,calls,to,this,method;void,set,last,accepted,state,cluster,state,cluster,state
CoordinationState -> PersistedState -> void setLastAcceptedState(ClusterState clusterState)_;1547219208;Sets a new last accepted cluster state._After a successful call to this method, {@link #getLastAcceptedState()} should return the last cluster state that was set._The value returned by {@link #getCurrentTerm()} should not be influenced by calls to this method.;void setLastAcceptedState(ClusterState clusterState)_;sets,a,new,last,accepted,cluster,state,after,a,successful,call,to,this,method,link,get,last,accepted,state,should,return,the,last,cluster,state,that,was,set,the,value,returned,by,link,get,current,term,should,not,be,influenced,by,calls,to,this,method;void,set,last,accepted,state,cluster,state,cluster,state
CoordinationState -> PersistedState -> void setLastAcceptedState(ClusterState clusterState)_;1548772865;Sets a new last accepted cluster state._After a successful call to this method, {@link #getLastAcceptedState()} should return the last cluster state that was set._The value returned by {@link #getCurrentTerm()} should not be influenced by calls to this method.;void setLastAcceptedState(ClusterState clusterState)_;sets,a,new,last,accepted,cluster,state,after,a,successful,call,to,this,method,link,get,last,accepted,state,should,return,the,last,cluster,state,that,was,set,the,value,returned,by,link,get,current,term,should,not,be,influenced,by,calls,to,this,method;void,set,last,accepted,state,cluster,state,cluster,state
CoordinationState -> PersistedState -> default void markLastAcceptedConfigAsCommitted();1544081506;Marks the last accepted cluster state as committed._After a successful call to this method, {@link #getLastAcceptedState()} should return the last cluster state that was set,_with the last committed configuration now corresponding to the last accepted configuration.;default void markLastAcceptedConfigAsCommitted() {_            final ClusterState lastAcceptedState = getLastAcceptedState()__            if (lastAcceptedState.getLastAcceptedConfiguration().equals(lastAcceptedState.getLastCommittedConfiguration()) == false) {_                final CoordinationMetaData coordinationMetaData = CoordinationMetaData.builder(lastAcceptedState.coordinationMetaData())_                        .lastCommittedConfiguration(lastAcceptedState.getLastAcceptedConfiguration())_                        .build()__                final MetaData metaData = MetaData.builder(lastAcceptedState.metaData()).coordinationMetaData(coordinationMetaData).build()__                setLastAcceptedState(ClusterState.builder(lastAcceptedState).metaData(metaData).build())__            }_        };marks,the,last,accepted,cluster,state,as,committed,after,a,successful,call,to,this,method,link,get,last,accepted,state,should,return,the,last,cluster,state,that,was,set,with,the,last,committed,configuration,now,corresponding,to,the,last,accepted,configuration;default,void,mark,last,accepted,config,as,committed,final,cluster,state,last,accepted,state,get,last,accepted,state,if,last,accepted,state,get,last,accepted,configuration,equals,last,accepted,state,get,last,committed,configuration,false,final,coordination,meta,data,coordination,meta,data,coordination,meta,data,builder,last,accepted,state,coordination,meta,data,last,committed,configuration,last,accepted,state,get,last,accepted,configuration,build,final,meta,data,meta,data,meta,data,builder,last,accepted,state,meta,data,coordination,meta,data,coordination,meta,data,build,set,last,accepted,state,cluster,state,builder,last,accepted,state,meta,data,meta,data,build
CoordinationState -> PersistedState -> default void markLastAcceptedConfigAsCommitted();1544254415;Marks the last accepted cluster state as committed._After a successful call to this method, {@link #getLastAcceptedState()} should return the last cluster state that was set,_with the last committed configuration now corresponding to the last accepted configuration.;default void markLastAcceptedConfigAsCommitted() {_            final ClusterState lastAcceptedState = getLastAcceptedState()__            if (lastAcceptedState.getLastAcceptedConfiguration().equals(lastAcceptedState.getLastCommittedConfiguration()) == false) {_                final CoordinationMetaData coordinationMetaData = CoordinationMetaData.builder(lastAcceptedState.coordinationMetaData())_                        .lastCommittedConfiguration(lastAcceptedState.getLastAcceptedConfiguration())_                        .build()__                final MetaData metaData = MetaData.builder(lastAcceptedState.metaData()).coordinationMetaData(coordinationMetaData).build()__                setLastAcceptedState(ClusterState.builder(lastAcceptedState).metaData(metaData).build())__            }_        };marks,the,last,accepted,cluster,state,as,committed,after,a,successful,call,to,this,method,link,get,last,accepted,state,should,return,the,last,cluster,state,that,was,set,with,the,last,committed,configuration,now,corresponding,to,the,last,accepted,configuration;default,void,mark,last,accepted,config,as,committed,final,cluster,state,last,accepted,state,get,last,accepted,state,if,last,accepted,state,get,last,accepted,configuration,equals,last,accepted,state,get,last,committed,configuration,false,final,coordination,meta,data,coordination,meta,data,coordination,meta,data,builder,last,accepted,state,coordination,meta,data,last,committed,configuration,last,accepted,state,get,last,accepted,configuration,build,final,meta,data,meta,data,meta,data,builder,last,accepted,state,meta,data,coordination,meta,data,coordination,meta,data,build,set,last,accepted,state,cluster,state,builder,last,accepted,state,meta,data,meta,data,build
CoordinationState -> PersistedState -> default void markLastAcceptedConfigAsCommitted();1546592956;Marks the last accepted cluster state as committed._After a successful call to this method, {@link #getLastAcceptedState()} should return the last cluster state that was set,_with the last committed configuration now corresponding to the last accepted configuration.;default void markLastAcceptedConfigAsCommitted() {_            final ClusterState lastAcceptedState = getLastAcceptedState()__            if (lastAcceptedState.getLastAcceptedConfiguration().equals(lastAcceptedState.getLastCommittedConfiguration()) == false) {_                final CoordinationMetaData coordinationMetaData = CoordinationMetaData.builder(lastAcceptedState.coordinationMetaData())_                        .lastCommittedConfiguration(lastAcceptedState.getLastAcceptedConfiguration())_                        .build()__                final MetaData metaData = MetaData.builder(lastAcceptedState.metaData()).coordinationMetaData(coordinationMetaData).build()__                setLastAcceptedState(ClusterState.builder(lastAcceptedState).metaData(metaData).build())__            }_        };marks,the,last,accepted,cluster,state,as,committed,after,a,successful,call,to,this,method,link,get,last,accepted,state,should,return,the,last,cluster,state,that,was,set,with,the,last,committed,configuration,now,corresponding,to,the,last,accepted,configuration;default,void,mark,last,accepted,config,as,committed,final,cluster,state,last,accepted,state,get,last,accepted,state,if,last,accepted,state,get,last,accepted,configuration,equals,last,accepted,state,get,last,committed,configuration,false,final,coordination,meta,data,coordination,meta,data,coordination,meta,data,builder,last,accepted,state,coordination,meta,data,last,committed,configuration,last,accepted,state,get,last,accepted,configuration,build,final,meta,data,meta,data,meta,data,builder,last,accepted,state,meta,data,coordination,meta,data,coordination,meta,data,build,set,last,accepted,state,cluster,state,builder,last,accepted,state,meta,data,meta,data,build
CoordinationState -> PersistedState -> default void markLastAcceptedConfigAsCommitted();1547219208;Marks the last accepted cluster state as committed._After a successful call to this method, {@link #getLastAcceptedState()} should return the last cluster state that was set,_with the last committed configuration now corresponding to the last accepted configuration.;default void markLastAcceptedConfigAsCommitted() {_            final ClusterState lastAcceptedState = getLastAcceptedState()__            if (lastAcceptedState.getLastAcceptedConfiguration().equals(lastAcceptedState.getLastCommittedConfiguration()) == false) {_                final CoordinationMetaData coordinationMetaData = CoordinationMetaData.builder(lastAcceptedState.coordinationMetaData())_                        .lastCommittedConfiguration(lastAcceptedState.getLastAcceptedConfiguration())_                        .build()__                final MetaData metaData = MetaData.builder(lastAcceptedState.metaData()).coordinationMetaData(coordinationMetaData).build()__                setLastAcceptedState(ClusterState.builder(lastAcceptedState).metaData(metaData).build())__            }_        };marks,the,last,accepted,cluster,state,as,committed,after,a,successful,call,to,this,method,link,get,last,accepted,state,should,return,the,last,cluster,state,that,was,set,with,the,last,committed,configuration,now,corresponding,to,the,last,accepted,configuration;default,void,mark,last,accepted,config,as,committed,final,cluster,state,last,accepted,state,get,last,accepted,state,if,last,accepted,state,get,last,accepted,configuration,equals,last,accepted,state,get,last,committed,configuration,false,final,coordination,meta,data,coordination,meta,data,coordination,meta,data,builder,last,accepted,state,coordination,meta,data,last,committed,configuration,last,accepted,state,get,last,accepted,configuration,build,final,meta,data,meta,data,meta,data,builder,last,accepted,state,meta,data,coordination,meta,data,coordination,meta,data,build,set,last,accepted,state,cluster,state,builder,last,accepted,state,meta,data,meta,data,build
CoordinationState -> public void setInitialState(ClusterState initialState);1544081506;Used to bootstrap a cluster by injecting the initial state and configuration.__@param initialState The initial state to use. Must have term 0, version 1, and non-empty configurations._@throws CoordinationStateRejectedException if the arguments were incompatible with the current state of this object.;public void setInitialState(ClusterState initialState) {_        final long lastAcceptedVersion = getLastAcceptedVersion()__        if (lastAcceptedVersion != 0) {_            logger.debug("setInitialState: rejecting since last-accepted version {} > 0", lastAcceptedVersion)__            throw new CoordinationStateRejectedException("initial state already set: last-accepted version now " + lastAcceptedVersion)__        }__        assert getLastAcceptedTerm() == 0 : getLastAcceptedTerm()__        assert getLastAcceptedConfiguration().isEmpty() : getLastAcceptedConfiguration()__        assert getLastCommittedConfiguration().isEmpty() : getLastCommittedConfiguration()__        assert lastPublishedVersion == 0 : lastAcceptedVersion__        assert lastPublishedConfiguration.isEmpty() : lastPublishedConfiguration__        assert electionWon == false__        assert joinVotes.isEmpty() : joinVotes__        assert publishVotes.isEmpty() : publishVotes___        assert initialState.term() == 0 : initialState__        assert initialState.version() == 1 : initialState__        assert initialState.getLastAcceptedConfiguration().isEmpty() == false__        assert initialState.getLastCommittedConfiguration().isEmpty() == false___        persistedState.setLastAcceptedState(initialState)__    };used,to,bootstrap,a,cluster,by,injecting,the,initial,state,and,configuration,param,initial,state,the,initial,state,to,use,must,have,term,0,version,1,and,non,empty,configurations,throws,coordination,state,rejected,exception,if,the,arguments,were,incompatible,with,the,current,state,of,this,object;public,void,set,initial,state,cluster,state,initial,state,final,long,last,accepted,version,get,last,accepted,version,if,last,accepted,version,0,logger,debug,set,initial,state,rejecting,since,last,accepted,version,0,last,accepted,version,throw,new,coordination,state,rejected,exception,initial,state,already,set,last,accepted,version,now,last,accepted,version,assert,get,last,accepted,term,0,get,last,accepted,term,assert,get,last,accepted,configuration,is,empty,get,last,accepted,configuration,assert,get,last,committed,configuration,is,empty,get,last,committed,configuration,assert,last,published,version,0,last,accepted,version,assert,last,published,configuration,is,empty,last,published,configuration,assert,election,won,false,assert,join,votes,is,empty,join,votes,assert,publish,votes,is,empty,publish,votes,assert,initial,state,term,0,initial,state,assert,initial,state,version,1,initial,state,assert,initial,state,get,last,accepted,configuration,is,empty,false,assert,initial,state,get,last,committed,configuration,is,empty,false,persisted,state,set,last,accepted,state,initial,state
CoordinationState -> public void setInitialState(ClusterState initialState);1544254415;Used to bootstrap a cluster by injecting the initial state and configuration.__@param initialState The initial state to use. Must have term 0, version 1, and non-empty configurations._@throws CoordinationStateRejectedException if the arguments were incompatible with the current state of this object.;public void setInitialState(ClusterState initialState) {_        final long lastAcceptedVersion = getLastAcceptedVersion()__        if (lastAcceptedVersion != 0) {_            logger.debug("setInitialState: rejecting since last-accepted version {} > 0", lastAcceptedVersion)__            throw new CoordinationStateRejectedException("initial state already set: last-accepted version now " + lastAcceptedVersion)__        }__        assert getLastAcceptedTerm() == 0 : getLastAcceptedTerm()__        assert getLastAcceptedConfiguration().isEmpty() : getLastAcceptedConfiguration()__        assert getLastCommittedConfiguration().isEmpty() : getLastCommittedConfiguration()__        assert lastPublishedVersion == 0 : lastAcceptedVersion__        assert lastPublishedConfiguration.isEmpty() : lastPublishedConfiguration__        assert electionWon == false__        assert joinVotes.isEmpty() : joinVotes__        assert publishVotes.isEmpty() : publishVotes___        assert initialState.term() == 0 : initialState__        assert initialState.version() == 1 : initialState__        assert initialState.getLastAcceptedConfiguration().isEmpty() == false__        assert initialState.getLastCommittedConfiguration().isEmpty() == false___        persistedState.setLastAcceptedState(initialState)__    };used,to,bootstrap,a,cluster,by,injecting,the,initial,state,and,configuration,param,initial,state,the,initial,state,to,use,must,have,term,0,version,1,and,non,empty,configurations,throws,coordination,state,rejected,exception,if,the,arguments,were,incompatible,with,the,current,state,of,this,object;public,void,set,initial,state,cluster,state,initial,state,final,long,last,accepted,version,get,last,accepted,version,if,last,accepted,version,0,logger,debug,set,initial,state,rejecting,since,last,accepted,version,0,last,accepted,version,throw,new,coordination,state,rejected,exception,initial,state,already,set,last,accepted,version,now,last,accepted,version,assert,get,last,accepted,term,0,get,last,accepted,term,assert,get,last,accepted,configuration,is,empty,get,last,accepted,configuration,assert,get,last,committed,configuration,is,empty,get,last,committed,configuration,assert,last,published,version,0,last,accepted,version,assert,last,published,configuration,is,empty,last,published,configuration,assert,election,won,false,assert,join,votes,is,empty,join,votes,assert,publish,votes,is,empty,publish,votes,assert,initial,state,term,0,initial,state,assert,initial,state,version,1,initial,state,assert,initial,state,get,last,accepted,configuration,is,empty,false,assert,initial,state,get,last,committed,configuration,is,empty,false,persisted,state,set,last,accepted,state,initial,state
CoordinationState -> public void setInitialState(ClusterState initialState);1546592956;Used to bootstrap a cluster by injecting the initial state and configuration.__@param initialState The initial state to use. Must have term 0, version equal to the last-accepted version, and non-empty_configurations._@throws CoordinationStateRejectedException if the arguments were incompatible with the current state of this object.;public void setInitialState(ClusterState initialState) {__        final VotingConfiguration lastAcceptedConfiguration = getLastAcceptedConfiguration()__        if (lastAcceptedConfiguration.isEmpty() == false) {_            logger.debug("setInitialState: rejecting since last-accepted configuration is nonempty: {}", lastAcceptedConfiguration)__            throw new CoordinationStateRejectedException(_                "initial state already set: last-accepted configuration now " + lastAcceptedConfiguration)__        }__        assert getLastAcceptedTerm() == 0 : getLastAcceptedTerm()__        assert getLastCommittedConfiguration().isEmpty() : getLastCommittedConfiguration()__        assert lastPublishedVersion == 0 : lastPublishedVersion__        assert lastPublishedConfiguration.isEmpty() : lastPublishedConfiguration__        assert electionWon == false__        assert joinVotes.isEmpty() : joinVotes__        assert publishVotes.isEmpty() : publishVotes___        assert initialState.term() == 0 : initialState + " should have term 0"__        assert initialState.version() == getLastAcceptedVersion() : initialState + " should have version " + getLastAcceptedVersion()__        assert initialState.getLastAcceptedConfiguration().isEmpty() == false__        assert initialState.getLastCommittedConfiguration().isEmpty() == false___        persistedState.setLastAcceptedState(initialState)__    };used,to,bootstrap,a,cluster,by,injecting,the,initial,state,and,configuration,param,initial,state,the,initial,state,to,use,must,have,term,0,version,equal,to,the,last,accepted,version,and,non,empty,configurations,throws,coordination,state,rejected,exception,if,the,arguments,were,incompatible,with,the,current,state,of,this,object;public,void,set,initial,state,cluster,state,initial,state,final,voting,configuration,last,accepted,configuration,get,last,accepted,configuration,if,last,accepted,configuration,is,empty,false,logger,debug,set,initial,state,rejecting,since,last,accepted,configuration,is,nonempty,last,accepted,configuration,throw,new,coordination,state,rejected,exception,initial,state,already,set,last,accepted,configuration,now,last,accepted,configuration,assert,get,last,accepted,term,0,get,last,accepted,term,assert,get,last,committed,configuration,is,empty,get,last,committed,configuration,assert,last,published,version,0,last,published,version,assert,last,published,configuration,is,empty,last,published,configuration,assert,election,won,false,assert,join,votes,is,empty,join,votes,assert,publish,votes,is,empty,publish,votes,assert,initial,state,term,0,initial,state,should,have,term,0,assert,initial,state,version,get,last,accepted,version,initial,state,should,have,version,get,last,accepted,version,assert,initial,state,get,last,accepted,configuration,is,empty,false,assert,initial,state,get,last,committed,configuration,is,empty,false,persisted,state,set,last,accepted,state,initial,state
CoordinationState -> public void setInitialState(ClusterState initialState);1547219208;Used to bootstrap a cluster by injecting the initial state and configuration.__@param initialState The initial state to use. Must have term 0, version equal to the last-accepted version, and non-empty_configurations._@throws CoordinationStateRejectedException if the arguments were incompatible with the current state of this object.;public void setInitialState(ClusterState initialState) {__        final VotingConfiguration lastAcceptedConfiguration = getLastAcceptedConfiguration()__        if (lastAcceptedConfiguration.isEmpty() == false) {_            logger.debug("setInitialState: rejecting since last-accepted configuration is nonempty: {}", lastAcceptedConfiguration)__            throw new CoordinationStateRejectedException(_                "initial state already set: last-accepted configuration now " + lastAcceptedConfiguration)__        }__        assert getLastAcceptedTerm() == 0 : getLastAcceptedTerm()__        assert getLastCommittedConfiguration().isEmpty() : getLastCommittedConfiguration()__        assert lastPublishedVersion == 0 : lastPublishedVersion__        assert lastPublishedConfiguration.isEmpty() : lastPublishedConfiguration__        assert electionWon == false__        assert joinVotes.isEmpty() : joinVotes__        assert publishVotes.isEmpty() : publishVotes___        assert initialState.term() == 0 : initialState + " should have term 0"__        assert initialState.version() == getLastAcceptedVersion() : initialState + " should have version " + getLastAcceptedVersion()__        assert initialState.getLastAcceptedConfiguration().isEmpty() == false__        assert initialState.getLastCommittedConfiguration().isEmpty() == false___        persistedState.setLastAcceptedState(initialState)__    };used,to,bootstrap,a,cluster,by,injecting,the,initial,state,and,configuration,param,initial,state,the,initial,state,to,use,must,have,term,0,version,equal,to,the,last,accepted,version,and,non,empty,configurations,throws,coordination,state,rejected,exception,if,the,arguments,were,incompatible,with,the,current,state,of,this,object;public,void,set,initial,state,cluster,state,initial,state,final,voting,configuration,last,accepted,configuration,get,last,accepted,configuration,if,last,accepted,configuration,is,empty,false,logger,debug,set,initial,state,rejecting,since,last,accepted,configuration,is,nonempty,last,accepted,configuration,throw,new,coordination,state,rejected,exception,initial,state,already,set,last,accepted,configuration,now,last,accepted,configuration,assert,get,last,accepted,term,0,get,last,accepted,term,assert,get,last,committed,configuration,is,empty,get,last,committed,configuration,assert,last,published,version,0,last,published,version,assert,last,published,configuration,is,empty,last,published,configuration,assert,election,won,false,assert,join,votes,is,empty,join,votes,assert,publish,votes,is,empty,publish,votes,assert,initial,state,term,0,initial,state,should,have,term,0,assert,initial,state,version,get,last,accepted,version,initial,state,should,have,version,get,last,accepted,version,assert,initial,state,get,last,accepted,configuration,is,empty,false,assert,initial,state,get,last,committed,configuration,is,empty,false,persisted,state,set,last,accepted,state,initial,state
CoordinationState -> public void setInitialState(ClusterState initialState);1548772865;Used to bootstrap a cluster by injecting the initial state and configuration.__@param initialState The initial state to use. Must have term 0, version equal to the last-accepted version, and non-empty_configurations._@throws CoordinationStateRejectedException if the arguments were incompatible with the current state of this object.;public void setInitialState(ClusterState initialState) {__        final VotingConfiguration lastAcceptedConfiguration = getLastAcceptedConfiguration()__        if (lastAcceptedConfiguration.isEmpty() == false) {_            logger.debug("setInitialState: rejecting since last-accepted configuration is nonempty: {}", lastAcceptedConfiguration)__            throw new CoordinationStateRejectedException(_                "initial state already set: last-accepted configuration now " + lastAcceptedConfiguration)__        }__        assert getLastAcceptedTerm() == 0 : getLastAcceptedTerm()__        assert getLastCommittedConfiguration().isEmpty() : getLastCommittedConfiguration()__        assert lastPublishedVersion == 0 : lastPublishedVersion__        assert lastPublishedConfiguration.isEmpty() : lastPublishedConfiguration__        assert electionWon == false__        assert joinVotes.isEmpty() : joinVotes__        assert publishVotes.isEmpty() : publishVotes___        assert initialState.term() == 0 : initialState + " should have term 0"__        assert initialState.version() == getLastAcceptedVersion() : initialState + " should have version " + getLastAcceptedVersion()__        assert initialState.getLastAcceptedConfiguration().isEmpty() == false__        assert initialState.getLastCommittedConfiguration().isEmpty() == false___        persistedState.setLastAcceptedState(initialState)__    };used,to,bootstrap,a,cluster,by,injecting,the,initial,state,and,configuration,param,initial,state,the,initial,state,to,use,must,have,term,0,version,equal,to,the,last,accepted,version,and,non,empty,configurations,throws,coordination,state,rejected,exception,if,the,arguments,were,incompatible,with,the,current,state,of,this,object;public,void,set,initial,state,cluster,state,initial,state,final,voting,configuration,last,accepted,configuration,get,last,accepted,configuration,if,last,accepted,configuration,is,empty,false,logger,debug,set,initial,state,rejecting,since,last,accepted,configuration,is,nonempty,last,accepted,configuration,throw,new,coordination,state,rejected,exception,initial,state,already,set,last,accepted,configuration,now,last,accepted,configuration,assert,get,last,accepted,term,0,get,last,accepted,term,assert,get,last,committed,configuration,is,empty,get,last,committed,configuration,assert,last,published,version,0,last,published,version,assert,last,published,configuration,is,empty,last,published,configuration,assert,election,won,false,assert,join,votes,is,empty,join,votes,assert,publish,votes,is,empty,publish,votes,assert,initial,state,term,0,initial,state,should,have,term,0,assert,initial,state,version,get,last,accepted,version,initial,state,should,have,version,get,last,accepted,version,assert,initial,state,get,last,accepted,configuration,is,empty,false,assert,initial,state,get,last,committed,configuration,is,empty,false,persisted,state,set,last,accepted,state,initial,state
CoordinationState -> public Join handleStartJoin(StartJoinRequest startJoinRequest);1544081506;May be safely called at any time to move this instance to a new term.__@param startJoinRequest The startJoinRequest, specifying the node requesting the join._@return A Join that should be sent to the target node of the join._@throws CoordinationStateRejectedException if the arguments were incompatible with the current state of this object.;public Join handleStartJoin(StartJoinRequest startJoinRequest) {_        if (startJoinRequest.getTerm() <= getCurrentTerm()) {_            logger.debug("handleStartJoin: ignoring [{}] as term provided is not greater than current term [{}]",_                startJoinRequest, getCurrentTerm())__            throw new CoordinationStateRejectedException("incoming term " + startJoinRequest.getTerm() +_                " not greater than current term " + getCurrentTerm())__        }__        logger.debug("handleStartJoin: leaving term [{}] due to {}", getCurrentTerm(), startJoinRequest)___        if (joinVotes.isEmpty() == false) {_            final String reason__            if (electionWon == false) {_                reason = "failed election"__            } else if (startJoinRequest.getSourceNode().equals(localNode)) {_                reason = "bumping term"__            } else {_                reason = "standing down as leader"__            }_            logger.debug("handleStartJoin: discarding {}: {}", joinVotes, reason)__        }__        persistedState.setCurrentTerm(startJoinRequest.getTerm())__        assert getCurrentTerm() == startJoinRequest.getTerm()__        lastPublishedVersion = 0__        lastPublishedConfiguration = getLastAcceptedConfiguration()__        startedJoinSinceLastReboot = true__        electionWon = false__        joinVotes = new VoteCollection()__        publishVotes = new VoteCollection()___        return new Join(localNode, startJoinRequest.getSourceNode(), getCurrentTerm(), getLastAcceptedTerm(), getLastAcceptedVersion())__    };may,be,safely,called,at,any,time,to,move,this,instance,to,a,new,term,param,start,join,request,the,start,join,request,specifying,the,node,requesting,the,join,return,a,join,that,should,be,sent,to,the,target,node,of,the,join,throws,coordination,state,rejected,exception,if,the,arguments,were,incompatible,with,the,current,state,of,this,object;public,join,handle,start,join,start,join,request,start,join,request,if,start,join,request,get,term,get,current,term,logger,debug,handle,start,join,ignoring,as,term,provided,is,not,greater,than,current,term,start,join,request,get,current,term,throw,new,coordination,state,rejected,exception,incoming,term,start,join,request,get,term,not,greater,than,current,term,get,current,term,logger,debug,handle,start,join,leaving,term,due,to,get,current,term,start,join,request,if,join,votes,is,empty,false,final,string,reason,if,election,won,false,reason,failed,election,else,if,start,join,request,get,source,node,equals,local,node,reason,bumping,term,else,reason,standing,down,as,leader,logger,debug,handle,start,join,discarding,join,votes,reason,persisted,state,set,current,term,start,join,request,get,term,assert,get,current,term,start,join,request,get,term,last,published,version,0,last,published,configuration,get,last,accepted,configuration,started,join,since,last,reboot,true,election,won,false,join,votes,new,vote,collection,publish,votes,new,vote,collection,return,new,join,local,node,start,join,request,get,source,node,get,current,term,get,last,accepted,term,get,last,accepted,version
CoordinationState -> public Join handleStartJoin(StartJoinRequest startJoinRequest);1544254415;May be safely called at any time to move this instance to a new term.__@param startJoinRequest The startJoinRequest, specifying the node requesting the join._@return A Join that should be sent to the target node of the join._@throws CoordinationStateRejectedException if the arguments were incompatible with the current state of this object.;public Join handleStartJoin(StartJoinRequest startJoinRequest) {_        if (startJoinRequest.getTerm() <= getCurrentTerm()) {_            logger.debug("handleStartJoin: ignoring [{}] as term provided is not greater than current term [{}]",_                startJoinRequest, getCurrentTerm())__            throw new CoordinationStateRejectedException("incoming term " + startJoinRequest.getTerm() +_                " not greater than current term " + getCurrentTerm())__        }__        logger.debug("handleStartJoin: leaving term [{}] due to {}", getCurrentTerm(), startJoinRequest)___        if (joinVotes.isEmpty() == false) {_            final String reason__            if (electionWon == false) {_                reason = "failed election"__            } else if (startJoinRequest.getSourceNode().equals(localNode)) {_                reason = "bumping term"__            } else {_                reason = "standing down as leader"__            }_            logger.debug("handleStartJoin: discarding {}: {}", joinVotes, reason)__        }__        persistedState.setCurrentTerm(startJoinRequest.getTerm())__        assert getCurrentTerm() == startJoinRequest.getTerm()__        lastPublishedVersion = 0__        lastPublishedConfiguration = getLastAcceptedConfiguration()__        startedJoinSinceLastReboot = true__        electionWon = false__        joinVotes = new VoteCollection()__        publishVotes = new VoteCollection()___        return new Join(localNode, startJoinRequest.getSourceNode(), getCurrentTerm(), getLastAcceptedTerm(), getLastAcceptedVersion())__    };may,be,safely,called,at,any,time,to,move,this,instance,to,a,new,term,param,start,join,request,the,start,join,request,specifying,the,node,requesting,the,join,return,a,join,that,should,be,sent,to,the,target,node,of,the,join,throws,coordination,state,rejected,exception,if,the,arguments,were,incompatible,with,the,current,state,of,this,object;public,join,handle,start,join,start,join,request,start,join,request,if,start,join,request,get,term,get,current,term,logger,debug,handle,start,join,ignoring,as,term,provided,is,not,greater,than,current,term,start,join,request,get,current,term,throw,new,coordination,state,rejected,exception,incoming,term,start,join,request,get,term,not,greater,than,current,term,get,current,term,logger,debug,handle,start,join,leaving,term,due,to,get,current,term,start,join,request,if,join,votes,is,empty,false,final,string,reason,if,election,won,false,reason,failed,election,else,if,start,join,request,get,source,node,equals,local,node,reason,bumping,term,else,reason,standing,down,as,leader,logger,debug,handle,start,join,discarding,join,votes,reason,persisted,state,set,current,term,start,join,request,get,term,assert,get,current,term,start,join,request,get,term,last,published,version,0,last,published,configuration,get,last,accepted,configuration,started,join,since,last,reboot,true,election,won,false,join,votes,new,vote,collection,publish,votes,new,vote,collection,return,new,join,local,node,start,join,request,get,source,node,get,current,term,get,last,accepted,term,get,last,accepted,version
CoordinationState -> public Join handleStartJoin(StartJoinRequest startJoinRequest);1546592956;May be safely called at any time to move this instance to a new term.__@param startJoinRequest The startJoinRequest, specifying the node requesting the join._@return A Join that should be sent to the target node of the join._@throws CoordinationStateRejectedException if the arguments were incompatible with the current state of this object.;public Join handleStartJoin(StartJoinRequest startJoinRequest) {_        if (startJoinRequest.getTerm() <= getCurrentTerm()) {_            logger.debug("handleStartJoin: ignoring [{}] as term provided is not greater than current term [{}]",_                startJoinRequest, getCurrentTerm())__            throw new CoordinationStateRejectedException("incoming term " + startJoinRequest.getTerm() +_                " not greater than current term " + getCurrentTerm())__        }__        logger.debug("handleStartJoin: leaving term [{}] due to {}", getCurrentTerm(), startJoinRequest)___        if (joinVotes.isEmpty() == false) {_            final String reason__            if (electionWon == false) {_                reason = "failed election"__            } else if (startJoinRequest.getSourceNode().equals(localNode)) {_                reason = "bumping term"__            } else {_                reason = "standing down as leader"__            }_            logger.debug("handleStartJoin: discarding {}: {}", joinVotes, reason)__        }__        persistedState.setCurrentTerm(startJoinRequest.getTerm())__        assert getCurrentTerm() == startJoinRequest.getTerm()__        lastPublishedVersion = 0__        lastPublishedConfiguration = getLastAcceptedConfiguration()__        startedJoinSinceLastReboot = true__        electionWon = false__        joinVotes = new VoteCollection()__        publishVotes = new VoteCollection()___        return new Join(localNode, startJoinRequest.getSourceNode(), getCurrentTerm(), getLastAcceptedTerm(),_            getLastAcceptedVersionOrMetaDataVersion())__    };may,be,safely,called,at,any,time,to,move,this,instance,to,a,new,term,param,start,join,request,the,start,join,request,specifying,the,node,requesting,the,join,return,a,join,that,should,be,sent,to,the,target,node,of,the,join,throws,coordination,state,rejected,exception,if,the,arguments,were,incompatible,with,the,current,state,of,this,object;public,join,handle,start,join,start,join,request,start,join,request,if,start,join,request,get,term,get,current,term,logger,debug,handle,start,join,ignoring,as,term,provided,is,not,greater,than,current,term,start,join,request,get,current,term,throw,new,coordination,state,rejected,exception,incoming,term,start,join,request,get,term,not,greater,than,current,term,get,current,term,logger,debug,handle,start,join,leaving,term,due,to,get,current,term,start,join,request,if,join,votes,is,empty,false,final,string,reason,if,election,won,false,reason,failed,election,else,if,start,join,request,get,source,node,equals,local,node,reason,bumping,term,else,reason,standing,down,as,leader,logger,debug,handle,start,join,discarding,join,votes,reason,persisted,state,set,current,term,start,join,request,get,term,assert,get,current,term,start,join,request,get,term,last,published,version,0,last,published,configuration,get,last,accepted,configuration,started,join,since,last,reboot,true,election,won,false,join,votes,new,vote,collection,publish,votes,new,vote,collection,return,new,join,local,node,start,join,request,get,source,node,get,current,term,get,last,accepted,term,get,last,accepted,version,or,meta,data,version
CoordinationState -> public Join handleStartJoin(StartJoinRequest startJoinRequest);1547219208;May be safely called at any time to move this instance to a new term.__@param startJoinRequest The startJoinRequest, specifying the node requesting the join._@return A Join that should be sent to the target node of the join._@throws CoordinationStateRejectedException if the arguments were incompatible with the current state of this object.;public Join handleStartJoin(StartJoinRequest startJoinRequest) {_        if (startJoinRequest.getTerm() <= getCurrentTerm()) {_            logger.debug("handleStartJoin: ignoring [{}] as term provided is not greater than current term [{}]",_                startJoinRequest, getCurrentTerm())__            throw new CoordinationStateRejectedException("incoming term " + startJoinRequest.getTerm() +_                " not greater than current term " + getCurrentTerm())__        }__        logger.debug("handleStartJoin: leaving term [{}] due to {}", getCurrentTerm(), startJoinRequest)___        if (joinVotes.isEmpty() == false) {_            final String reason__            if (electionWon == false) {_                reason = "failed election"__            } else if (startJoinRequest.getSourceNode().equals(localNode)) {_                reason = "bumping term"__            } else {_                reason = "standing down as leader"__            }_            logger.debug("handleStartJoin: discarding {}: {}", joinVotes, reason)__        }__        persistedState.setCurrentTerm(startJoinRequest.getTerm())__        assert getCurrentTerm() == startJoinRequest.getTerm()__        lastPublishedVersion = 0__        lastPublishedConfiguration = getLastAcceptedConfiguration()__        startedJoinSinceLastReboot = true__        electionWon = false__        joinVotes = new VoteCollection()__        publishVotes = new VoteCollection()___        return new Join(localNode, startJoinRequest.getSourceNode(), getCurrentTerm(), getLastAcceptedTerm(),_            getLastAcceptedVersionOrMetaDataVersion())__    };may,be,safely,called,at,any,time,to,move,this,instance,to,a,new,term,param,start,join,request,the,start,join,request,specifying,the,node,requesting,the,join,return,a,join,that,should,be,sent,to,the,target,node,of,the,join,throws,coordination,state,rejected,exception,if,the,arguments,were,incompatible,with,the,current,state,of,this,object;public,join,handle,start,join,start,join,request,start,join,request,if,start,join,request,get,term,get,current,term,logger,debug,handle,start,join,ignoring,as,term,provided,is,not,greater,than,current,term,start,join,request,get,current,term,throw,new,coordination,state,rejected,exception,incoming,term,start,join,request,get,term,not,greater,than,current,term,get,current,term,logger,debug,handle,start,join,leaving,term,due,to,get,current,term,start,join,request,if,join,votes,is,empty,false,final,string,reason,if,election,won,false,reason,failed,election,else,if,start,join,request,get,source,node,equals,local,node,reason,bumping,term,else,reason,standing,down,as,leader,logger,debug,handle,start,join,discarding,join,votes,reason,persisted,state,set,current,term,start,join,request,get,term,assert,get,current,term,start,join,request,get,term,last,published,version,0,last,published,configuration,get,last,accepted,configuration,started,join,since,last,reboot,true,election,won,false,join,votes,new,vote,collection,publish,votes,new,vote,collection,return,new,join,local,node,start,join,request,get,source,node,get,current,term,get,last,accepted,term,get,last,accepted,version,or,meta,data,version
CoordinationState -> public Join handleStartJoin(StartJoinRequest startJoinRequest);1548772865;May be safely called at any time to move this instance to a new term.__@param startJoinRequest The startJoinRequest, specifying the node requesting the join._@return A Join that should be sent to the target node of the join._@throws CoordinationStateRejectedException if the arguments were incompatible with the current state of this object.;public Join handleStartJoin(StartJoinRequest startJoinRequest) {_        if (startJoinRequest.getTerm() <= getCurrentTerm()) {_            logger.debug("handleStartJoin: ignoring [{}] as term provided is not greater than current term [{}]",_                startJoinRequest, getCurrentTerm())__            throw new CoordinationStateRejectedException("incoming term " + startJoinRequest.getTerm() +_                " not greater than current term " + getCurrentTerm())__        }__        logger.debug("handleStartJoin: leaving term [{}] due to {}", getCurrentTerm(), startJoinRequest)___        if (joinVotes.isEmpty() == false) {_            final String reason__            if (electionWon == false) {_                reason = "failed election"__            } else if (startJoinRequest.getSourceNode().equals(localNode)) {_                reason = "bumping term"__            } else {_                reason = "standing down as leader"__            }_            logger.debug("handleStartJoin: discarding {}: {}", joinVotes, reason)__        }__        persistedState.setCurrentTerm(startJoinRequest.getTerm())__        assert getCurrentTerm() == startJoinRequest.getTerm()__        lastPublishedVersion = 0__        lastPublishedConfiguration = getLastAcceptedConfiguration()__        startedJoinSinceLastReboot = true__        electionWon = false__        joinVotes = new VoteCollection()__        publishVotes = new VoteCollection()___        return new Join(localNode, startJoinRequest.getSourceNode(), getCurrentTerm(), getLastAcceptedTerm(),_            getLastAcceptedVersionOrMetaDataVersion())__    };may,be,safely,called,at,any,time,to,move,this,instance,to,a,new,term,param,start,join,request,the,start,join,request,specifying,the,node,requesting,the,join,return,a,join,that,should,be,sent,to,the,target,node,of,the,join,throws,coordination,state,rejected,exception,if,the,arguments,were,incompatible,with,the,current,state,of,this,object;public,join,handle,start,join,start,join,request,start,join,request,if,start,join,request,get,term,get,current,term,logger,debug,handle,start,join,ignoring,as,term,provided,is,not,greater,than,current,term,start,join,request,get,current,term,throw,new,coordination,state,rejected,exception,incoming,term,start,join,request,get,term,not,greater,than,current,term,get,current,term,logger,debug,handle,start,join,leaving,term,due,to,get,current,term,start,join,request,if,join,votes,is,empty,false,final,string,reason,if,election,won,false,reason,failed,election,else,if,start,join,request,get,source,node,equals,local,node,reason,bumping,term,else,reason,standing,down,as,leader,logger,debug,handle,start,join,discarding,join,votes,reason,persisted,state,set,current,term,start,join,request,get,term,assert,get,current,term,start,join,request,get,term,last,published,version,0,last,published,configuration,get,last,accepted,configuration,started,join,since,last,reboot,true,election,won,false,join,votes,new,vote,collection,publish,votes,new,vote,collection,return,new,join,local,node,start,join,request,get,source,node,get,current,term,get,last,accepted,term,get,last,accepted,version,or,meta,data,version
CoordinationState -> PersistedState -> void setCurrentTerm(long currentTerm)_;1544081506;Sets a new current term._After a successful call to this method, {@link #getCurrentTerm()} should return the last term that was set._The value returned by {@link #getLastAcceptedState()} should not be influenced by calls to this method.;void setCurrentTerm(long currentTerm)_;sets,a,new,current,term,after,a,successful,call,to,this,method,link,get,current,term,should,return,the,last,term,that,was,set,the,value,returned,by,link,get,last,accepted,state,should,not,be,influenced,by,calls,to,this,method;void,set,current,term,long,current,term
CoordinationState -> PersistedState -> void setCurrentTerm(long currentTerm)_;1544254415;Sets a new current term._After a successful call to this method, {@link #getCurrentTerm()} should return the last term that was set._The value returned by {@link #getLastAcceptedState()} should not be influenced by calls to this method.;void setCurrentTerm(long currentTerm)_;sets,a,new,current,term,after,a,successful,call,to,this,method,link,get,current,term,should,return,the,last,term,that,was,set,the,value,returned,by,link,get,last,accepted,state,should,not,be,influenced,by,calls,to,this,method;void,set,current,term,long,current,term
CoordinationState -> PersistedState -> void setCurrentTerm(long currentTerm)_;1546592956;Sets a new current term._After a successful call to this method, {@link #getCurrentTerm()} should return the last term that was set._The value returned by {@link #getLastAcceptedState()} should not be influenced by calls to this method.;void setCurrentTerm(long currentTerm)_;sets,a,new,current,term,after,a,successful,call,to,this,method,link,get,current,term,should,return,the,last,term,that,was,set,the,value,returned,by,link,get,last,accepted,state,should,not,be,influenced,by,calls,to,this,method;void,set,current,term,long,current,term
CoordinationState -> PersistedState -> void setCurrentTerm(long currentTerm)_;1547219208;Sets a new current term._After a successful call to this method, {@link #getCurrentTerm()} should return the last term that was set._The value returned by {@link #getLastAcceptedState()} should not be influenced by calls to this method.;void setCurrentTerm(long currentTerm)_;sets,a,new,current,term,after,a,successful,call,to,this,method,link,get,current,term,should,return,the,last,term,that,was,set,the,value,returned,by,link,get,last,accepted,state,should,not,be,influenced,by,calls,to,this,method;void,set,current,term,long,current,term
CoordinationState -> PersistedState -> void setCurrentTerm(long currentTerm)_;1548772865;Sets a new current term._After a successful call to this method, {@link #getCurrentTerm()} should return the last term that was set._The value returned by {@link #getLastAcceptedState()} should not be influenced by calls to this method.;void setCurrentTerm(long currentTerm)_;sets,a,new,current,term,after,a,successful,call,to,this,method,link,get,current,term,should,return,the,last,term,that,was,set,the,value,returned,by,link,get,last,accepted,state,should,not,be,influenced,by,calls,to,this,method;void,set,current,term,long,current,term
