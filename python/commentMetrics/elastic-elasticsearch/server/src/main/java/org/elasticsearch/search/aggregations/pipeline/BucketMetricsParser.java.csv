commented;modifiers;parameterAmount;loc;comment;code
false;public,final;2;56;;@Override public final BucketMetricsPipelineAggregationBuilder<?> parse(String pipelineAggregatorName, XContentParser parser) throws IOException {     XContentParser.Token token.     String currentFieldName = null.     String[] bucketsPaths = null.     String format = null.     GapPolicy gapPolicy = null.     Map<String, Object> params = new HashMap<>(5).     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token == XContentParser.Token.VALUE_STRING) {             if (FORMAT.match(currentFieldName, parser.getDeprecationHandler())) {                 format = parser.text().             } else if (BUCKETS_PATH.match(currentFieldName, parser.getDeprecationHandler())) {                 bucketsPaths = new String[] { parser.text() }.             } else if (GAP_POLICY.match(currentFieldName, parser.getDeprecationHandler())) {                 gapPolicy = GapPolicy.parse(parser.text(), parser.getTokenLocation()).             } else {                 parseToken(pipelineAggregatorName, parser, currentFieldName, token, params).             }         } else if (token == XContentParser.Token.START_ARRAY) {             if (BUCKETS_PATH.match(currentFieldName, parser.getDeprecationHandler())) {                 List<String> paths = new ArrayList<>().                 while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {                     String path = parser.text().                     paths.add(path).                 }                 bucketsPaths = paths.toArray(new String[paths.size()]).             } else {                 parseToken(pipelineAggregatorName, parser, currentFieldName, token, params).             }         } else {             parseToken(pipelineAggregatorName, parser, currentFieldName, token, params).         }     }     if (bucketsPaths == null) {         throw new ParsingException(parser.getTokenLocation(), "Missing required field [" + BUCKETS_PATH.getPreferredName() + "] for aggregation [" + pipelineAggregatorName + "]").     }     BucketMetricsPipelineAggregationBuilder<?> factory = buildFactory(pipelineAggregatorName, bucketsPaths[0], params).     if (format != null) {         factory.format(format).     }     if (gapPolicy != null) {         factory.gapPolicy(gapPolicy).     }     assert (factory != null).     return factory. }
false;protected,abstract;3;2;;protected abstract BucketMetricsPipelineAggregationBuilder<?> buildFactory(String pipelineAggregatorName, String bucketsPaths, Map<String, Object> params).
false;protected;4;4;;protected boolean token(XContentParser parser, String field, XContentParser.Token token, Map<String, Object> params) throws IOException {     return false. }
false;private;5;7;;private void parseToken(String aggregationName, XContentParser parser, String currentFieldName, XContentParser.Token currentToken, Map<String, Object> params) throws IOException {     if (token(parser, currentFieldName, currentToken, params) == false) {         throw new ParsingException(parser.getTokenLocation(), "Unexpected token " + currentToken + " [" + currentFieldName + "] in [" + aggregationName + "]").     } }
