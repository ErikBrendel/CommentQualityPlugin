commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String getName() {     return "document_mget_action". }
false;public;2;35;;@Override public RestChannelConsumer prepareRequest(final RestRequest request, final NodeClient client) throws IOException {     if (request.param("type") != null) {         deprecationLogger.deprecatedAndMaybeLog("mget_with_types", TYPES_DEPRECATION_MESSAGE).     }     MultiGetRequest multiGetRequest = new MultiGetRequest().     multiGetRequest.refresh(request.paramAsBoolean("refresh", multiGetRequest.refresh())).     multiGetRequest.preference(request.param("preference")).     multiGetRequest.realtime(request.paramAsBoolean("realtime", multiGetRequest.realtime())).     if (request.param("fields") != null) {         throw new IllegalArgumentException("The parameter [fields] is no longer supported, " + "please use [stored_fields] to retrieve stored fields or _source filtering if the field is not stored").     }     String[] sFields = null.     String sField = request.param("stored_fields").     if (sField != null) {         sFields = Strings.splitStringByCommaToArray(sField).     }     FetchSourceContext defaultFetchSource = FetchSourceContext.parseFromRestRequest(request).     try (XContentParser parser = request.contentOrSourceParamParser()) {         multiGetRequest.add(request.param("index"), request.param("type"), sFields, defaultFetchSource, request.param("routing"), parser, allowExplicitIndex).     }     for (MultiGetRequest.Item item : multiGetRequest.getItems()) {         if (item.type() != null) {             deprecationLogger.deprecated(TYPES_DEPRECATION_MESSAGE).             break.         }     }     return channel -> client.multiGet(multiGetRequest, new RestToXContentListener<>(channel)). }
