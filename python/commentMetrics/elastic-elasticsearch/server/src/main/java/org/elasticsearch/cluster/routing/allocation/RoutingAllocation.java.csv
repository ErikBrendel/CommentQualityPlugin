commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * returns the nano time captured at the beginning of the allocation. used to make sure all time based decisions are aligned  */ ;/**  * returns the nano time captured at the beginning of the allocation. used to make sure all time based decisions are aligned  */ public long getCurrentNanoTime() {     return currentNanoTime. }
true;public;0;3;/**  * Get {@link AllocationDeciders} used for allocation  * @return {@link AllocationDeciders} used for allocation  */ ;/**  * Get {@link AllocationDeciders} used for allocation  * @return {@link AllocationDeciders} used for allocation  */ public AllocationDeciders deciders() {     return this.deciders. }
true;public;0;3;/**  * Get routing table of current nodes  * @return current routing table  */ ;/**  * Get routing table of current nodes  * @return current routing table  */ public RoutingTable routingTable() {     return routingTable. }
true;public;0;3;/**  * Get current routing nodes  * @return routing nodes  */ ;/**  * Get current routing nodes  * @return routing nodes  */ public RoutingNodes routingNodes() {     return routingNodes. }
true;public;0;3;/**  * Get metadata of routing nodes  * @return Metadata of routing nodes  */ ;/**  * Get metadata of routing nodes  * @return Metadata of routing nodes  */ public MetaData metaData() {     return metaData. }
true;public;0;3;/**  * Get discovery nodes in current routing  * @return discovery nodes  */ ;/**  * Get discovery nodes in current routing  * @return discovery nodes  */ public DiscoveryNodes nodes() {     return nodes. }
false;public;0;3;;public ClusterInfo clusterInfo() {     return clusterInfo. }
false;public;1;3;;public <T extends ClusterState.Custom> T custom(String key) {     return (T) customs.get(key). }
false;public;0;3;;public ImmutableOpenMap<String, ClusterState.Custom> getCustoms() {     return customs. }
false;public;1;3;;public void ignoreDisable(boolean ignoreDisable) {     this.ignoreDisable = ignoreDisable. }
false;public;0;3;;public boolean ignoreDisable() {     return this.ignoreDisable. }
false;public;1;3;;public void setDebugMode(DebugMode debug) {     this.debugDecision = debug. }
false;public;1;3;;public void debugDecision(boolean debug) {     this.debugDecision = debug ? DebugMode.ON : DebugMode.OFF. }
false;public;0;3;;public boolean debugDecision() {     return this.debugDecision != DebugMode.OFF. }
false;public;0;3;;public DebugMode getDebugMode() {     return this.debugDecision. }
false;public;2;6;;public void addIgnoreShardForNode(ShardId shardId, String nodeId) {     if (ignoredShardToNodes == null) {         ignoredShardToNodes = new HashMap<>().     }     ignoredShardToNodes.computeIfAbsent(shardId, k -> new HashSet<>()).add(nodeId). }
true;public;2;7;/**  * Returns whether the given node id should be ignored from consideration when {@link AllocationDeciders}  * is deciding whether to allocate the specified shard id to that node.  The node will be ignored if  * the specified shard failed on that node, triggering the current round of allocation.  Since the shard  * just failed on that node, we don't want to try to reassign it there, if the node is still a part  * of the cluster.  *  * @param shardId the shard id to be allocated  * @param nodeId the node id to check against  * @return true if the node id should be ignored in allocation decisions, false otherwise  */ ;/**  * Returns whether the given node id should be ignored from consideration when {@link AllocationDeciders}  * is deciding whether to allocate the specified shard id to that node.  The node will be ignored if  * the specified shard failed on that node, triggering the current round of allocation.  Since the shard  * just failed on that node, we don't want to try to reassign it there, if the node is still a part  * of the cluster.  *  * @param shardId the shard id to be allocated  * @param nodeId the node id to check against  * @return true if the node id should be ignored in allocation decisions, false otherwise  */ public boolean shouldIgnoreShardForNode(ShardId shardId, String nodeId) {     if (ignoredShardToNodes == null) {         return false.     }     Set<String> nodes = ignoredShardToNodes.get(shardId).     return nodes != null && nodes.contains(nodeId). }
false;public;1;10;;public Set<String> getIgnoreNodes(ShardId shardId) {     if (ignoredShardToNodes == null) {         return emptySet().     }     Set<String> ignore = ignoredShardToNodes.get(shardId).     if (ignore == null) {         return emptySet().     }     return unmodifiableSet(new HashSet<>(ignore)). }
true;public;1;3;/**  * Remove the allocation id of the provided shard from the set of in-sync shard copies  */ ;/**  * Remove the allocation id of the provided shard from the set of in-sync shard copies  */ public void removeAllocationId(ShardRouting shardRouting) {     indexMetaDataUpdater.removeAllocationId(shardRouting). }
true;public;0;3;/**  * Returns observer to use for changes made to the routing nodes  */ ;/**  * Returns observer to use for changes made to the routing nodes  */ public RoutingChangesObserver changes() {     return routingChangesObserver. }
true;public;1;3;/**  * Returns updated {@link MetaData} based on the changes that were made to the routing nodes  */ ;/**  * Returns updated {@link MetaData} based on the changes that were made to the routing nodes  */ public MetaData updateMetaDataWithRoutingChanges(RoutingTable newRoutingTable) {     return indexMetaDataUpdater.applyChanges(metaData, newRoutingTable). }
true;public;1;3;/**  * Returns updated {@link RestoreInProgress} based on the changes that were made to the routing nodes  */ ;/**  * Returns updated {@link RestoreInProgress} based on the changes that were made to the routing nodes  */ public RestoreInProgress updateRestoreInfoWithRoutingChanges(RestoreInProgress restoreInProgress) {     return restoreInProgressUpdater.applyChanges(restoreInProgress). }
true;public;0;3;/**  * Returns true iff changes were made to the routing nodes  */ ;/**  * Returns true iff changes were made to the routing nodes  */ public boolean routingNodesChanged() {     return nodesChangedObserver.isChanged(). }
true;public;4;7;/**  * Create a routing decision, including the reason if the debug flag is  * turned on  * @param decision decision whether to allow/deny allocation  * @param deciderLabel a human readable label for the AllocationDecider  * @param reason a format string explanation of the decision  * @param params format string parameters  */ ;/**  * Create a routing decision, including the reason if the debug flag is  * turned on  * @param decision decision whether to allow/deny allocation  * @param deciderLabel a human readable label for the AllocationDecider  * @param reason a format string explanation of the decision  * @param params format string parameters  */ public Decision decision(Decision decision, String deciderLabel, String reason, Object... params) {     if (debugDecision()) {         return Decision.single(decision.type(), deciderLabel, reason, params).     } else {         return decision.     } }
true;public;0;3;/**  * Returns <code>true</code> iff the current allocation run has not processed all of the in-flight or available  * shard or store fetches. Otherwise <code>true</code>  */ ;/**  * Returns <code>true</code> iff the current allocation run has not processed all of the in-flight or available  * shard or store fetches. Otherwise <code>true</code>  */ public boolean hasPendingAsyncFetch() {     return hasPendingAsyncFetch. }
true;public;0;3;/**  * Sets a flag that signals that current allocation run has not processed all of the in-flight or available shard or store fetches.  * This state is anti-viral and can be reset in on allocation run.  */ ;/**  * Sets a flag that signals that current allocation run has not processed all of the in-flight or available shard or store fetches.  * This state is anti-viral and can be reset in on allocation run.  */ public void setHasPendingAsyncFetch() {     this.hasPendingAsyncFetch = true. }
