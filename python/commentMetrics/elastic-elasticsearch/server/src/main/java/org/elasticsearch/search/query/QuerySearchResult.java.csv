commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public QuerySearchResult queryResult() {     return this. }
false;public;1;3;;public void searchTimedOut(boolean searchTimedOut) {     this.searchTimedOut = searchTimedOut. }
false;public;0;3;;public boolean searchTimedOut() {     return searchTimedOut. }
false;public;1;3;;public void terminatedEarly(boolean terminatedEarly) {     this.terminatedEarly = terminatedEarly. }
false;public;0;3;;public Boolean terminatedEarly() {     return this.terminatedEarly. }
false;public;0;6;;public TopDocsAndMaxScore topDocs() {     if (topDocsAndMaxScore == null) {         throw new IllegalStateException("topDocs already consumed").     }     return topDocsAndMaxScore. }
true;public;0;3;/**  * Returns <code>true</code> iff the top docs have already been consumed.  */ ;/**  * Returns <code>true</code> iff the top docs have already been consumed.  */ public boolean hasConsumedTopDocs() {     return topDocsAndMaxScore == null. }
true;public;0;8;/**  * Returns and nulls out the top docs for this search results. This allows to free up memory once the top docs are consumed.  * @throws IllegalStateException if the top docs have already been consumed.  */ ;/**  * Returns and nulls out the top docs for this search results. This allows to free up memory once the top docs are consumed.  * @throws IllegalStateException if the top docs have already been consumed.  */ public TopDocsAndMaxScore consumeTopDocs() {     TopDocsAndMaxScore topDocsAndMaxScore = this.topDocsAndMaxScore.     if (topDocsAndMaxScore == null) {         throw new IllegalStateException("topDocs already consumed").     }     this.topDocsAndMaxScore = null.     return topDocsAndMaxScore. }
false;public;2;11;;public void topDocs(TopDocsAndMaxScore topDocs, DocValueFormat[] sortValueFormats) {     setTopDocs(topDocs).     if (topDocs.topDocs.scoreDocs.length > 0 && topDocs.topDocs.scoreDocs[0] instanceof FieldDoc) {         int numFields = ((FieldDoc) topDocs.topDocs.scoreDocs[0]).fields.length.         if (numFields != sortValueFormats.length) {             throw new IllegalArgumentException("The number of sort fields does not match: " + numFields + " != " + sortValueFormats.length).         }     }     this.sortValueFormats = sortValueFormats. }
false;private;1;6;;private void setTopDocs(TopDocsAndMaxScore topDocsAndMaxScore) {     this.topDocsAndMaxScore = topDocsAndMaxScore.     this.totalHits = topDocsAndMaxScore.topDocs.totalHits.     this.maxScore = topDocsAndMaxScore.maxScore.     this.hasScoreDocs = topDocsAndMaxScore.topDocs.scoreDocs.length > 0. }
false;public;0;3;;public DocValueFormat[] sortValueFormats() {     return sortValueFormats. }
true;public;0;3;/**  * Returns <code>true</code> if this query result has unconsumed aggregations  */ ;/**  * Returns <code>true</code> if this query result has unconsumed aggregations  */ public boolean hasAggs() {     return hasAggs. }
true;public;0;8;/**  * Returns and nulls out the aggregation for this search results. This allows to free up memory once the aggregation is consumed.  * @throws IllegalStateException if the aggregations have already been consumed.  */ ;/**  * Returns and nulls out the aggregation for this search results. This allows to free up memory once the aggregation is consumed.  * @throws IllegalStateException if the aggregations have already been consumed.  */ public Aggregations consumeAggs() {     if (aggregations == null) {         throw new IllegalStateException("aggs already consumed").     }     Aggregations aggs = aggregations.     aggregations = null.     return aggs. }
false;public;1;4;;public void aggregations(InternalAggregations aggregations) {     this.aggregations = aggregations.     hasAggs = aggregations != null. }
true;public;0;8;/**  * Returns and nulls out the profiled results for this search, or potentially null if result was empty.  * This allows to free up memory once the profiled result is consumed.  * @throws IllegalStateException if the profiled result has already been consumed.  */ ;/**  * Returns and nulls out the profiled results for this search, or potentially null if result was empty.  * This allows to free up memory once the profiled result is consumed.  * @throws IllegalStateException if the profiled result has already been consumed.  */ public ProfileShardResult consumeProfileResult() {     if (profileShardResults == null) {         throw new IllegalStateException("profile results already consumed").     }     ProfileShardResult result = profileShardResults.     profileShardResults = null.     return result. }
false;public;0;3;;public boolean hasProfileResults() {     return hasProfileResults. }
true;public;1;4;/**  * Sets the finalized profiling results for this query  * @param shardResults The finalized profile  */ ;/**  * Sets the finalized profiling results for this query  * @param shardResults The finalized profile  */ public void profileResults(ProfileShardResult shardResults) {     this.profileShardResults = shardResults.     hasProfileResults = shardResults != null. }
false;public;0;3;;public List<SiblingPipelineAggregator> pipelineAggregators() {     return pipelineAggregators. }
false;public;1;3;;public void pipelineAggregators(List<SiblingPipelineAggregator> pipelineAggregators) {     this.pipelineAggregators = pipelineAggregators. }
false;public;0;3;;public Suggest suggest() {     return suggest. }
false;public;1;3;;public void suggest(Suggest suggest) {     this.suggest = suggest. }
false;public;0;3;;public int from() {     return from. }
false;public;1;4;;public QuerySearchResult from(int from) {     this.from = from.     return this. }
true;public;0;3;/**  * Returns the maximum size of this results top docs.  */ ;/**  * Returns the maximum size of this results top docs.  */ public int size() {     return size. }
false;public;1;4;;public QuerySearchResult size(int size) {     this.size = size.     return this. }
false;public;0;3;;public long serviceTimeEWMA() {     return this.serviceTimeEWMA. }
false;public;1;4;;public QuerySearchResult serviceTimeEWMA(long serviceTimeEWMA) {     this.serviceTimeEWMA = serviceTimeEWMA.     return this. }
false;public;0;3;;public int nodeQueueSize() {     return this.nodeQueueSize. }
false;public;1;4;;public QuerySearchResult nodeQueueSize(int nodeQueueSize) {     this.nodeQueueSize = nodeQueueSize.     return this. }
true;public;0;3;/**  * Returns <code>true</code> if this result has any suggest score docs  */ ;/**  * Returns <code>true</code> if this result has any suggest score docs  */ public boolean hasSuggestHits() {     return (suggest != null && suggest.hasScoreDocs()). }
false;public;0;3;;public boolean hasSearchContext() {     return hasScoreDocs || hasSuggestHits(). }
false;public,static;1;5;;public static QuerySearchResult readQuerySearchResult(StreamInput in) throws IOException {     QuerySearchResult result = new QuerySearchResult().     result.readFrom(in).     return result. }
false;public;1;6;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     long id = in.readLong().     readFromWithId(id, in). }
false;public;2;34;;public void readFromWithId(long id, StreamInput in) throws IOException {     this.requestId = id.     from = in.readVInt().     size = in.readVInt().     int numSortFieldsPlus1 = in.readVInt().     if (numSortFieldsPlus1 == 0) {         sortValueFormats = null.     } else {         sortValueFormats = new DocValueFormat[numSortFieldsPlus1 - 1].         for (int i = 0. i < sortValueFormats.length. ++i) {             sortValueFormats[i] = in.readNamedWriteable(DocValueFormat.class).         }     }     setTopDocs(readTopDocs(in)).     if (hasAggs = in.readBoolean()) {         aggregations = InternalAggregations.readAggregations(in).     }     pipelineAggregators = in.readNamedWriteableList(PipelineAggregator.class).stream().map(a -> (SiblingPipelineAggregator) a).collect(Collectors.toList()).     if (in.readBoolean()) {         suggest = new Suggest(in).     }     searchTimedOut = in.readBoolean().     terminatedEarly = in.readOptionalBoolean().     profileShardResults = in.readOptionalWriteable(ProfileShardResult::new).     hasProfileResults = profileShardResults != null.     if (in.getVersion().onOrAfter(Version.V_6_0_0_beta1)) {         serviceTimeEWMA = in.readZLong().         nodeQueueSize = in.readInt().     } else {         serviceTimeEWMA = -1.         nodeQueueSize = -1.     } }
false;public;1;6;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeLong(requestId).     writeToNoId(out). }
false;public;1;33;;public void writeToNoId(StreamOutput out) throws IOException {     out.writeVInt(from).     out.writeVInt(size).     if (sortValueFormats == null) {         out.writeVInt(0).     } else {         out.writeVInt(1 + sortValueFormats.length).         for (int i = 0. i < sortValueFormats.length. ++i) {             out.writeNamedWriteable(sortValueFormats[i]).         }     }     writeTopDocs(out, topDocsAndMaxScore).     if (aggregations == null) {         out.writeBoolean(false).     } else {         out.writeBoolean(true).         aggregations.writeTo(out).     }     out.writeNamedWriteableList(pipelineAggregators == null ? emptyList() : pipelineAggregators).     if (suggest == null) {         out.writeBoolean(false).     } else {         out.writeBoolean(true).         suggest.writeTo(out).     }     out.writeBoolean(searchTimedOut).     out.writeOptionalBoolean(terminatedEarly).     out.writeOptionalWriteable(profileShardResults).     if (out.getVersion().onOrAfter(Version.V_6_0_0_beta1)) {         out.writeZLong(serviceTimeEWMA).         out.writeInt(nodeQueueSize).     } }
false;public;0;3;;public TotalHits getTotalHits() {     return totalHits. }
false;public;0;3;;public float getMaxScore() {     return maxScore. }
