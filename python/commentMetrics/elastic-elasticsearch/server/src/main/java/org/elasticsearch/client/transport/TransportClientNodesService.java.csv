commented;modifiers;parameterAmount;loc;comment;code
false;public;0;7;;public List<TransportAddress> transportAddresses() {     List<TransportAddress> lstBuilder = new ArrayList<>().     for (DiscoveryNode listedNode : listedNodes) {         lstBuilder.add(listedNode.getAddress()).     }     return Collections.unmodifiableList(lstBuilder). }
false;public;0;3;;public List<DiscoveryNode> connectedNodes() {     return this.nodes. }
false;public;0;3;;public List<DiscoveryNode> filteredNodes() {     return this.filteredNodes. }
false;public;0;3;;public List<DiscoveryNode> listedNodes() {     return this.listedNodes. }
false;public;1;34;;public TransportClientNodesService addTransportAddresses(TransportAddress... transportAddresses) {     synchronized (mutex) {         if (closed) {             throw new IllegalStateException("transport client is closed, can't add an address").         }         List<TransportAddress> filtered = new ArrayList<>(transportAddresses.length).         for (TransportAddress transportAddress : transportAddresses) {             boolean found = false.             for (DiscoveryNode otherNode : listedNodes) {                 if (otherNode.getAddress().equals(transportAddress)) {                     found = true.                     logger.debug("address [{}] already exists with [{}], ignoring...", transportAddress, otherNode).                     break.                 }             }             if (!found) {                 filtered.add(transportAddress).             }         }         if (filtered.isEmpty()) {             return this.         }         List<DiscoveryNode> builder = new ArrayList<>(listedNodes).         for (TransportAddress transportAddress : filtered) {             DiscoveryNode node = new DiscoveryNode("#transport#-" + tempNodeIdGenerator.incrementAndGet(), transportAddress, Collections.emptyMap(), Collections.emptySet(), minCompatibilityVersion).             logger.debug("adding address [{}]", node).             builder.add(node).         }         listedNodes = Collections.unmodifiableList(builder).         nodesSampler.sample().     }     return this. }
false;public;1;28;;public TransportClientNodesService removeTransportAddress(TransportAddress transportAddress) {     synchronized (mutex) {         if (closed) {             throw new IllegalStateException("transport client is closed, can't remove an address").         }         List<DiscoveryNode> listNodesBuilder = new ArrayList<>().         for (DiscoveryNode otherNode : listedNodes) {             if (!otherNode.getAddress().equals(transportAddress)) {                 listNodesBuilder.add(otherNode).             } else {                 logger.debug("removing address [{}] from listed nodes", otherNode).             }         }         listedNodes = Collections.unmodifiableList(listNodesBuilder).         List<DiscoveryNode> nodesBuilder = new ArrayList<>().         for (DiscoveryNode otherNode : nodes) {             if (!otherNode.getAddress().equals(transportAddress)) {                 nodesBuilder.add(otherNode).             } else {                 logger.debug("disconnecting from node with address [{}]", otherNode).                 transportService.disconnectFromNode(otherNode).             }         }         nodes = Collections.unmodifiableList(nodesBuilder).         nodesSampler.sample().     }     return this. }
false;public;2;28;;public <Response> void execute(NodeListenerCallback<Response> callback, ActionListener<Response> listener) {     // we first read nodes before checking the closed state. this     // is because otherwise we could be subject to a race where we     // read the state as not being closed, and then the client is     // closed and the nodes list is cleared, and then a     // NoNodeAvailableException is thrown     // it is important that the order of first setting the state of     // closed and then clearing the list of nodes is maintained in     // the close method     final List<DiscoveryNode> nodes = this.nodes.     if (closed) {         throw new IllegalStateException("transport client is closed").     }     ensureNodesAreAvailable(nodes).     int index = getNodeNumber().     RetryListener<Response> retryListener = new RetryListener<>(callback, listener, nodes, index, hostFailureListener).     DiscoveryNode node = retryListener.getNode(0).     try {         callback.doWithNode(node, retryListener).     } catch (Exception e) {         try {             // this exception can't come from the TransportService as it doesn't throw exception at all             listener.onFailure(e).         } finally {             retryListener.maybeNodeFailed(node, e).         }     } }
false;public;1;4;;@Override public void onResponse(Response response) {     listener.onResponse(response). }
false;public;1;21;;@Override public void onFailure(Exception e) {     Throwable throwable = ExceptionsHelper.unwrapCause(e).     if (throwable instanceof ConnectTransportException) {         maybeNodeFailed(getNode(this.i), (ConnectTransportException) throwable).         int i = ++this.i.         if (i >= nodes.size()) {             listener.onFailure(new NoNodeAvailableException("None of the configured nodes were available: " + nodes, e)).         } else {             try {                 callback.doWithNode(getNode(i), this).             } catch (final Exception inner) {                 inner.addSuppressed(e).                 // this exception can't come from the TransportService as it doesn't throw exceptions at all                 listener.onFailure(inner).             }         }     } else {         listener.onFailure(e).     } }
false;final;1;3;;final DiscoveryNode getNode(int i) {     return nodes.get((index + i) % nodes.size()). }
false;final;2;5;;final void maybeNodeFailed(DiscoveryNode node, Exception ex) {     if (ex instanceof NodeDisconnectedException || ex instanceof NodeNotConnectedException) {         hostFailureListener.onNodeDisconnected(node, ex).     } }
false;public;0;19;;@Override public void close() {     synchronized (mutex) {         if (closed) {             return.         }         closed = true.         if (nodesSamplerCancellable != null) {             nodesSamplerCancellable.cancel().         }         for (DiscoveryNode node : nodes) {             transportService.disconnectFromNode(node).         }         for (DiscoveryNode listedNode : listedNodes) {             transportService.disconnectFromNode(listedNode).         }         nodes = Collections.emptyList().     } }
false;private;0;8;;private int getNodeNumber() {     int index = randomNodeGenerator.incrementAndGet().     if (index < 0) {         index = 0.         randomNodeGenerator.set(0).     }     return index. }
false;private;1;6;;private void ensureNodesAreAvailable(List<DiscoveryNode> nodes) {     if (nodes.isEmpty()) {         String message = String.format(Locale.ROOT, "None of the configured nodes are available: %s", this.listedNodes).         throw new NoNodeAvailableException(message).     } }
false;public;0;8;;public void sample() {     synchronized (mutex) {         if (closed) {             return.         }         doSample().     } }
false;protected,abstract;0;1;;protected abstract void doSample().
true;;1;16;/**  * Establishes the node connections. If validateInHandshake is set to true, the connection will fail if  * node returned in the handshake response is different than the discovery node.  */ ;/**  * Establishes the node connections. If validateInHandshake is set to true, the connection will fail if  * node returned in the handshake response is different than the discovery node.  */ List<DiscoveryNode> establishNodeConnections(Set<DiscoveryNode> nodes) {     for (Iterator<DiscoveryNode> it = nodes.iterator(). it.hasNext(). ) {         DiscoveryNode node = it.next().         if (!transportService.nodeConnected(node)) {             try {                 logger.trace("connecting to node [{}]", node).                 transportService.connectToNode(node).             } catch (Exception e) {                 it.remove().                 logger.debug(() -> new ParameterizedMessage("failed to connect to discovered node [{}]", node), e).             }         }     }     return Collections.unmodifiableList(new ArrayList<>(nodes)). }
false;public;0;11;;@Override public void run() {     try {         nodesSampler.sample().         if (!closed) {             nodesSamplerCancellable = threadPool.schedule(this, nodesSamplerInterval, ThreadPool.Names.GENERIC).         }     } catch (Exception e) {         logger.warn("failed to sample", e).     } }
false;public;1;6;;@Override public LivenessResponse read(StreamInput in) throws IOException {     LivenessResponse response = new LivenessResponse().     response.readFrom(in).     return response. }
false;protected;0;41;;@Override protected void doSample() {     HashSet<DiscoveryNode> newNodes = new HashSet<>().     ArrayList<DiscoveryNode> newFilteredNodes = new ArrayList<>().     for (DiscoveryNode listedNode : listedNodes) {         try (Transport.Connection connection = transportService.openConnection(listedNode, LISTED_NODES_PROFILE)) {             final PlainTransportFuture<LivenessResponse> handler = new PlainTransportFuture<>(new FutureTransportResponseHandler<LivenessResponse>() {                  @Override                 public LivenessResponse read(StreamInput in) throws IOException {                     LivenessResponse response = new LivenessResponse().                     response.readFrom(in).                     return response.                 }             }).             transportService.sendRequest(connection, TransportLivenessAction.NAME, new LivenessRequest(), TransportRequestOptions.builder().withType(TransportRequestOptions.Type.STATE).withTimeout(pingTimeout).build(), handler).             final LivenessResponse livenessResponse = handler.txGet().             if (!ignoreClusterName && !clusterName.equals(livenessResponse.getClusterName())) {                 logger.warn("node {} not part of the cluster {}, ignoring...", listedNode, clusterName).                 newFilteredNodes.add(listedNode).             } else {                 // use discovered information but do keep the original transport address,                 // so people can control which address is exactly used.                 DiscoveryNode nodeWithInfo = livenessResponse.getDiscoveryNode().                 newNodes.add(new DiscoveryNode(nodeWithInfo.getName(), nodeWithInfo.getId(), nodeWithInfo.getEphemeralId(), nodeWithInfo.getHostName(), nodeWithInfo.getHostAddress(), listedNode.getAddress(), nodeWithInfo.getAttributes(), nodeWithInfo.getRoles(), nodeWithInfo.getVersion())).             }         } catch (ConnectTransportException e) {             logger.debug(() -> new ParameterizedMessage("failed to connect to node [{}], ignoring...", listedNode), e).             hostFailureListener.onNodeDisconnected(listedNode, e).         } catch (Exception e) {             logger.info(() -> new ParameterizedMessage("failed to get node info for {}, disconnecting...", listedNode), e).         }     }     nodes = establishNodeConnections(newNodes).     filteredNodes = Collections.unmodifiableList(newFilteredNodes). }
false;;0;7;;void onDone() {     try {         IOUtils.closeWhileHandlingException(connectionToClose).     } finally {         latch.countDown().     } }
false;public;1;11;;@Override public void onFailure(Exception e) {     onDone().     if (e instanceof ConnectTransportException) {         logger.debug(() -> new ParameterizedMessage("failed to connect to node [{}], ignoring...", nodeToPing), e).         hostFailureListener.onNodeDisconnected(nodeToPing, e).     } else {         logger.info(() -> new ParameterizedMessage("failed to get local cluster state info for {}, disconnecting...", nodeToPing), e).     } }
false;public;1;6;;@Override public ClusterStateResponse read(StreamInput in) throws IOException {     final ClusterStateResponse clusterStateResponse = new ClusterStateResponse().     clusterStateResponse.readFrom(in).     return clusterStateResponse. }
false;public;0;4;;@Override public String executor() {     return ThreadPool.Names.SAME. }
false;public;1;5;;@Override public void handleResponse(ClusterStateResponse response) {     clusterStateResponses.put(nodeToPing, response).     onDone(). }
false;public;1;10;;@Override public void handleException(TransportException e) {     logger.info(() -> new ParameterizedMessage("failed to get local cluster state for {}, disconnecting...", nodeToPing), e).     try {         hostFailureListener.onNodeDisconnected(nodeToPing, e).     } finally {         onDone().     } }
false;protected;0;51;;@Override protected void doRun() throws Exception {     Transport.Connection pingConnection = null.     if (nodes.contains(nodeToPing)) {         try {             pingConnection = transportService.getConnection(nodeToPing).         } catch (NodeNotConnectedException e) {         // will use a temp connection         }     }     if (pingConnection == null) {         logger.trace("connecting to cluster node [{}]", nodeToPing).         connectionToClose = transportService.openConnection(nodeToPing, LISTED_NODES_PROFILE).         pingConnection = connectionToClose.     }     transportService.sendRequest(pingConnection, ClusterStateAction.NAME, Requests.clusterStateRequest().clear().nodes(true).local(true), TransportRequestOptions.builder().withType(TransportRequestOptions.Type.STATE).withTimeout(pingTimeout).build(), new TransportResponseHandler<ClusterStateResponse>() {          @Override         public ClusterStateResponse read(StreamInput in) throws IOException {             final ClusterStateResponse clusterStateResponse = new ClusterStateResponse().             clusterStateResponse.readFrom(in).             return clusterStateResponse.         }          @Override         public String executor() {             return ThreadPool.Names.SAME.         }          @Override         public void handleResponse(ClusterStateResponse response) {             clusterStateResponses.put(nodeToPing, response).             onDone().         }          @Override         public void handleException(TransportException e) {             logger.info(() -> new ParameterizedMessage("failed to get local cluster state for {}, disconnecting...", nodeToPing), e).             try {                 hostFailureListener.onNodeDisconnected(nodeToPing, e).             } finally {                 onDone().             }         }     }). }
false;protected;0;120;;@Override protected void doSample() {     // the nodes we are going to ping include the core listed nodes that were added     // and the last round of discovered nodes     Set<DiscoveryNode> nodesToPing = new HashSet<>().     for (DiscoveryNode node : listedNodes) {         nodesToPing.add(node).     }     for (DiscoveryNode node : nodes) {         nodesToPing.add(node).     }     final CountDownLatch latch = new CountDownLatch(nodesToPing.size()).     final ConcurrentMap<DiscoveryNode, ClusterStateResponse> clusterStateResponses = ConcurrentCollections.newConcurrentMap().     try {         for (final DiscoveryNode nodeToPing : nodesToPing) {             threadPool.executor(ThreadPool.Names.MANAGEMENT).execute(new AbstractRunnable() {                  /**                  * we try to reuse existing connections but if needed we will open a temporary connection                  * that will be closed at the end of the execution.                  */                 Transport.Connection connectionToClose = null.                  void onDone() {                     try {                         IOUtils.closeWhileHandlingException(connectionToClose).                     } finally {                         latch.countDown().                     }                 }                  @Override                 public void onFailure(Exception e) {                     onDone().                     if (e instanceof ConnectTransportException) {                         logger.debug(() -> new ParameterizedMessage("failed to connect to node [{}], ignoring...", nodeToPing), e).                         hostFailureListener.onNodeDisconnected(nodeToPing, e).                     } else {                         logger.info(() -> new ParameterizedMessage("failed to get local cluster state info for {}, disconnecting...", nodeToPing), e).                     }                 }                  @Override                 protected void doRun() throws Exception {                     Transport.Connection pingConnection = null.                     if (nodes.contains(nodeToPing)) {                         try {                             pingConnection = transportService.getConnection(nodeToPing).                         } catch (NodeNotConnectedException e) {                         // will use a temp connection                         }                     }                     if (pingConnection == null) {                         logger.trace("connecting to cluster node [{}]", nodeToPing).                         connectionToClose = transportService.openConnection(nodeToPing, LISTED_NODES_PROFILE).                         pingConnection = connectionToClose.                     }                     transportService.sendRequest(pingConnection, ClusterStateAction.NAME, Requests.clusterStateRequest().clear().nodes(true).local(true), TransportRequestOptions.builder().withType(TransportRequestOptions.Type.STATE).withTimeout(pingTimeout).build(), new TransportResponseHandler<ClusterStateResponse>() {                          @Override                         public ClusterStateResponse read(StreamInput in) throws IOException {                             final ClusterStateResponse clusterStateResponse = new ClusterStateResponse().                             clusterStateResponse.readFrom(in).                             return clusterStateResponse.                         }                          @Override                         public String executor() {                             return ThreadPool.Names.SAME.                         }                          @Override                         public void handleResponse(ClusterStateResponse response) {                             clusterStateResponses.put(nodeToPing, response).                             onDone().                         }                          @Override                         public void handleException(TransportException e) {                             logger.info(() -> new ParameterizedMessage("failed to get local cluster state for {}, disconnecting...", nodeToPing), e).                             try {                                 hostFailureListener.onNodeDisconnected(nodeToPing, e).                             } finally {                                 onDone().                             }                         }                     }).                 }             }).         }         latch.await().     } catch (InterruptedException e) {         Thread.currentThread().interrupt().         return.     }     HashSet<DiscoveryNode> newNodes = new HashSet<>().     HashSet<DiscoveryNode> newFilteredNodes = new HashSet<>().     for (Map.Entry<DiscoveryNode, ClusterStateResponse> entry : clusterStateResponses.entrySet()) {         if (!ignoreClusterName && !clusterName.equals(entry.getValue().getClusterName())) {             logger.warn("node {} not part of the cluster {}, ignoring...", entry.getValue().getState().nodes().getLocalNode(), clusterName).             newFilteredNodes.add(entry.getKey()).             continue.         }         for (ObjectCursor<DiscoveryNode> cursor : entry.getValue().getState().nodes().getDataNodes().values()) {             newNodes.add(cursor.value).         }     }     nodes = establishNodeConnections(newNodes).     filteredNodes = Collections.unmodifiableList(new ArrayList<>(newFilteredNodes)). }
false;;2;1;;void doWithNode(DiscoveryNode node, ActionListener<Response> listener).
true;;0;3;// pkg private for testing ;// pkg private for testing void doSample() {     nodesSampler.doSample(). }
