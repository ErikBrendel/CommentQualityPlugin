commented;modifiers;parameterAmount;loc;comment;code
true;;0;3;/**  * Returns <code>true</code> iff the results should be merged.  *  * Note that when using the high-level REST client, results are always merged (this flag is always considered 'true').  */ ;/**  * Returns <code>true</code> iff the results should be merged.  *  * Note that when using the high-level REST client, results are always merged (this flag is always considered 'true').  */ boolean isMergeResults() {     return mergeResults. }
true;;1;3;/**  * If set to <code>true</code> the response will contain only a merged view of the per index field capabilities.  * Otherwise only unmerged per index field capabilities are returned.  *  * Note that when using the high-level REST client, results are always merged (this flag is always considered 'true').  */ ;/**  * If set to <code>true</code> the response will contain only a merged view of the per index field capabilities.  * Otherwise only unmerged per index field capabilities are returned.  *  * Note that when using the high-level REST client, results are always merged (this flag is always considered 'true').  */ void setMergeResults(boolean mergeResults) {     this.mergeResults = mergeResults. }
false;public;1;8;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     fields = in.readStringArray().     indices = in.readStringArray().     indicesOptions = IndicesOptions.readIndicesOptions(in).     mergeResults = in.readBoolean(). }
false;public;1;8;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeStringArray(fields).     out.writeStringArray(indices).     indicesOptions.writeIndicesOptions(out).     out.writeBoolean(mergeResults). }
true;public;1;8;/**  * The list of field names to retrieve  */ ;/**  * The list of field names to retrieve  */ public FieldCapabilitiesRequest fields(String... fields) {     if (fields == null || fields.length == 0) {         throw new IllegalArgumentException("specified fields can't be null or empty").     }     Set<String> fieldSet = new HashSet<>(Arrays.asList(fields)).     this.fields = fieldSet.toArray(new String[0]).     return this. }
false;public;0;3;;public String[] fields() {     return fields. }
true;public;1;4;/**  * The list of indices to lookup  */ ;/**  * The list of indices to lookup  */ public FieldCapabilitiesRequest indices(String... indices) {     this.indices = Objects.requireNonNull(indices, "indices must not be null").     return this. }
false;public;1;4;;public FieldCapabilitiesRequest indicesOptions(IndicesOptions indicesOptions) {     this.indicesOptions = Objects.requireNonNull(indicesOptions, "indices options must not be null").     return this. }
false;public;0;4;;@Override public String[] indices() {     return indices. }
false;public;0;4;;@Override public IndicesOptions indicesOptions() {     return indicesOptions. }
false;public;0;9;;@Override public ActionRequestValidationException validate() {     ActionRequestValidationException validationException = null.     if (fields == null || fields.length == 0) {         validationException = ValidateActions.addValidationError("no fields specified", validationException).     }     return validationException. }
false;public;1;11;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     FieldCapabilitiesRequest that = (FieldCapabilitiesRequest) o.     return Arrays.equals(indices, that.indices) && Objects.equals(indicesOptions, that.indicesOptions) && Arrays.equals(fields, that.fields) && Objects.equals(mergeResults, that.mergeResults). }
false;public;0;7;;@Override public int hashCode() {     return Objects.hash(Arrays.hashCode(indices), indicesOptions, Arrays.hashCode(fields), mergeResults). }
