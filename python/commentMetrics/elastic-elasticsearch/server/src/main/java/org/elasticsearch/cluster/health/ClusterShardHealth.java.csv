commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public int getShardId() {     return shardId. }
false;public;0;3;;public ClusterHealthStatus getStatus() {     return status. }
false;public;0;3;;public int getRelocatingShards() {     return relocatingShards. }
false;public;0;3;;public int getActiveShards() {     return activeShards. }
false;public;0;3;;public boolean isPrimaryActive() {     return primaryActive. }
false;public;0;3;;public int getInitializingShards() {     return initializingShards. }
false;public;0;3;;public int getUnassignedShards() {     return unassignedShards. }
false;public;1;10;;@Override public void writeTo(final StreamOutput out) throws IOException {     out.writeVInt(shardId).     out.writeByte(status.value()).     out.writeVInt(activeShards).     out.writeVInt(relocatingShards).     out.writeVInt(initializingShards).     out.writeVInt(unassignedShards).     out.writeBoolean(primaryActive). }
true;public,static;1;16;/**  * Checks if an inactive primary shard should cause the cluster health to go RED.  *  * An inactive primary shard in an index should cause the cluster health to be RED to make it visible that some of the existing data is  * unavailable. In case of index creation, snapshot restore or index shrinking, which are unexceptional events in the cluster lifecycle,  * cluster health should not turn RED for the time where primaries are still in the initializing state but go to YELLOW instead.  * However, in case of exceptional events, for example when the primary shard cannot be assigned to a node or initialization fails at  * some point, cluster health should still turn RED.  *  * NB: this method should *not* be called on active shards nor on non-primary shards.  */ ;/**  * Checks if an inactive primary shard should cause the cluster health to go RED.  *  * An inactive primary shard in an index should cause the cluster health to be RED to make it visible that some of the existing data is  * unavailable. In case of index creation, snapshot restore or index shrinking, which are unexceptional events in the cluster lifecycle,  * cluster health should not turn RED for the time where primaries are still in the initializing state but go to YELLOW instead.  * However, in case of exceptional events, for example when the primary shard cannot be assigned to a node or initialization fails at  * some point, cluster health should still turn RED.  *  * NB: this method should *not* be called on active shards nor on non-primary shards.  */ public static ClusterHealthStatus getInactivePrimaryHealth(final ShardRouting shardRouting) {     assert shardRouting.primary() : "cannot invoke on a replica shard: " + shardRouting.     assert shardRouting.active() == false : "cannot invoke on an active shard: " + shardRouting.     assert shardRouting.unassignedInfo() != null : "cannot invoke on a shard with no UnassignedInfo: " + shardRouting.     assert shardRouting.recoverySource() != null : "cannot invoke on a shard that has no recovery source" + shardRouting.     final UnassignedInfo unassignedInfo = shardRouting.unassignedInfo().     RecoverySource.Type recoveryType = shardRouting.recoverySource().getType().     if (unassignedInfo.getLastAllocationStatus() != AllocationStatus.DECIDERS_NO && unassignedInfo.getNumFailedAllocations() == 0 && (recoveryType == RecoverySource.Type.EMPTY_STORE || recoveryType == RecoverySource.Type.LOCAL_SHARDS || recoveryType == RecoverySource.Type.SNAPSHOT)) {         return ClusterHealthStatus.YELLOW.     } else {         return ClusterHealthStatus.RED.     } }
false;public;2;12;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject(Integer.toString(getShardId())).     builder.field(STATUS, getStatus().name().toLowerCase(Locale.ROOT)).     builder.field(PRIMARY_ACTIVE, isPrimaryActive()).     builder.field(ACTIVE_SHARDS, getActiveShards()).     builder.field(RELOCATING_SHARDS, getRelocatingShards()).     builder.field(INITIALIZING_SHARDS, getInitializingShards()).     builder.field(UNASSIGNED_SHARDS, getUnassignedShards()).     builder.endObject().     return builder. }
false;static;2;3;;static ClusterShardHealth innerFromXContent(XContentParser parser, Integer shardId) {     return PARSER.apply(parser, shardId). }
false;public,static;1;9;;public static ClusterShardHealth fromXContent(XContentParser parser) throws IOException {     ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation).     XContentParser.Token token = parser.nextToken().     ensureExpectedToken(XContentParser.Token.FIELD_NAME, token, parser::getTokenLocation).     String shardIdStr = parser.currentName().     ClusterShardHealth parsed = innerFromXContent(parser, Integer.valueOf(shardIdStr)).     ensureExpectedToken(XContentParser.Token.END_OBJECT, parser.nextToken(), parser::getTokenLocation).     return parsed. }
false;public;0;4;;@Override public String toString() {     return Strings.toString(this). }
false;public;1;13;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (!(o instanceof ClusterShardHealth))         return false.     ClusterShardHealth that = (ClusterShardHealth) o.     return shardId == that.shardId && activeShards == that.activeShards && relocatingShards == that.relocatingShards && initializingShards == that.initializingShards && unassignedShards == that.unassignedShards && primaryActive == that.primaryActive && status == that.status. }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(shardId, status, activeShards, relocatingShards, initializingShards, unassignedShards, primaryActive). }
