commented;modifiers;parameterAmount;loc;comment;code
false;public;0;7;;public void assertNoOpenTranslogRefs() {     if (openTranslogRef.isEmpty() == false) {         AssertionError e = new AssertionError("not all translog generations have been released").         openTranslogRef.values().forEach(e::addSuppressed).         throw e.     } }
false;public,synchronized;1;7;;public synchronized void setMinTranslogGenerationForRecovery(long newGen) {     if (newGen < minTranslogGenerationForRecovery || newGen > translogGenerationOfLastCommit) {         throw new IllegalArgumentException("Invalid minTranslogGenerationForRecovery can't go backwards. new [" + newGen + "]," + "current [" + minTranslogGenerationForRecovery + "], lastGen [" + translogGenerationOfLastCommit + "]").     }     minTranslogGenerationForRecovery = newGen. }
true;public,synchronized;1;7;/**  * Sets the translog generation of the last index commit.  */ ;/**  * Sets the translog generation of the last index commit.  */ public synchronized void setTranslogGenerationOfLastCommit(long lastGen) {     if (lastGen < translogGenerationOfLastCommit || lastGen < minTranslogGenerationForRecovery) {         throw new IllegalArgumentException("Invalid translogGenerationOfLastCommit. new [" + lastGen + "]," + "current [" + translogGenerationOfLastCommit + "], minRequiredGen [" + minTranslogGenerationForRecovery + "]").     }     translogGenerationOfLastCommit = lastGen. }
false;public,synchronized;1;3;;public synchronized void setRetentionSizeInBytes(long bytes) {     retentionSizeInBytes = bytes. }
false;public,synchronized;1;3;;public synchronized void setRetentionAgeInMillis(long ageInMillis) {     retentionAgeInMillis = ageInMillis. }
true;synchronized;1;11;/**  * acquires the basis generation for a new snapshot. Any translog generation above, and including, the returned generation  * will not be deleted until the returned {@link Releasable} is closed.  */ ;/**  * acquires the basis generation for a new snapshot. Any translog generation above, and including, the returned generation  * will not be deleted until the returned {@link Releasable} is closed.  */ synchronized Releasable acquireTranslogGen(final long translogGen) {     translogRefCounts.computeIfAbsent(translogGen, l -> Counter.newCounter(false)).addAndGet(1).     final AtomicBoolean closed = new AtomicBoolean().     assert assertAddTranslogRef(closed).     return () -> {         if (closed.compareAndSet(false, true)) {             releaseTranslogGen(translogGen).             assert assertRemoveTranslogRef(closed).         }     }. }
false;private;1;7;;private boolean assertAddTranslogRef(Object reference) {     final RuntimeException existing = openTranslogRef.put(reference, new RuntimeException()).     if (existing != null) {         throw new AssertionError("double adding of closing reference", existing).     }     return true. }
false;private;1;3;;private boolean assertRemoveTranslogRef(Object reference) {     return openTranslogRef.remove(reference) != null. }
true;synchronized;0;3;/**  * returns the number of generations that were acquired for snapshots  */ ;/**  * returns the number of generations that were acquired for snapshots  */ synchronized int pendingTranslogRefCount() {     return translogRefCounts.size(). }
true;private,synchronized;1;9;/**  * releases a generation that was acquired by {@link #acquireTranslogGen(long)}  */ ;/**  * releases a generation that was acquired by {@link #acquireTranslogGen(long)}  */ private synchronized void releaseTranslogGen(long translogGen) {     Counter current = translogRefCounts.get(translogGen).     if (current == null || current.get() <= 0) {         throw new IllegalArgumentException("translog gen [" + translogGen + "] wasn't acquired").     }     if (current.addAndGet(-1) == 0) {         translogRefCounts.remove(translogGen).     } }
true;synchronized;2;13;/**  * returns the minimum translog generation that is still required by the system. Any generation below  * the returned value may be safely deleted  *  * @param readers current translog readers  * @param writer  current translog writer  */ ;/**  * returns the minimum translog generation that is still required by the system. Any generation below  * the returned value may be safely deleted  *  * @param readers current translog readers  * @param writer  current translog writer  */ synchronized long minTranslogGenRequired(List<TranslogReader> readers, TranslogWriter writer) throws IOException {     long minByLocks = getMinTranslogGenRequiredByLocks().     long minByAge = getMinTranslogGenByAge(readers, writer, retentionAgeInMillis, currentTime()).     long minBySize = getMinTranslogGenBySize(readers, writer, retentionSizeInBytes).     final long minByAgeAndSize.     if (minBySize == Long.MIN_VALUE && minByAge == Long.MIN_VALUE) {         // both size and age are disabled.         minByAgeAndSize = Long.MAX_VALUE.     } else {         minByAgeAndSize = Math.max(minByAge, minBySize).     }     return Math.min(minByAgeAndSize, Math.min(minByLocks, minTranslogGenerationForRecovery)). }
false;static;3;14;;static long getMinTranslogGenBySize(List<TranslogReader> readers, TranslogWriter writer, long retentionSizeInBytes) {     if (retentionSizeInBytes >= 0) {         long totalSize = writer.sizeInBytes().         long minGen = writer.getGeneration().         for (int i = readers.size() - 1. i >= 0 && totalSize < retentionSizeInBytes. i--) {             final TranslogReader reader = readers.get(i).             totalSize += reader.sizeInBytes().             minGen = reader.getGeneration().         }         return minGen.     } else {         return Long.MIN_VALUE.     } }
false;static;4;13;;static long getMinTranslogGenByAge(List<TranslogReader> readers, TranslogWriter writer, long maxRetentionAgeInMillis, long now) throws IOException {     if (maxRetentionAgeInMillis >= 0) {         for (TranslogReader reader : readers) {             if (now - reader.getLastModifiedTime() <= maxRetentionAgeInMillis) {                 return reader.getGeneration().             }         }         return writer.getGeneration().     } else {         return Long.MIN_VALUE.     } }
false;protected;0;3;;protected long currentTime() {     return System.currentTimeMillis(). }
false;private;0;3;;private long getMinTranslogGenRequiredByLocks() {     return translogRefCounts.keySet().stream().reduce(Math::min).orElse(Long.MAX_VALUE). }
true;public,synchronized;0;3;/**  * returns the translog generation that will be used as a basis of a future store/peer recovery  */ ;/**  * returns the translog generation that will be used as a basis of a future store/peer recovery  */ public synchronized long getMinTranslogGenerationForRecovery() {     return minTranslogGenerationForRecovery. }
true;public,synchronized;0;3;/**  * Returns a translog generation that will be used to calculate the number of uncommitted operations since the last index commit.  */ ;/**  * Returns a translog generation that will be used to calculate the number of uncommitted operations since the last index commit.  */ public synchronized long getTranslogGenerationOfLastCommit() {     return translogGenerationOfLastCommit. }
false;synchronized;1;4;;synchronized long getTranslogRefCount(long gen) {     final Counter counter = translogRefCounts.get(gen).     return counter == null ? 0 : counter.get(). }
