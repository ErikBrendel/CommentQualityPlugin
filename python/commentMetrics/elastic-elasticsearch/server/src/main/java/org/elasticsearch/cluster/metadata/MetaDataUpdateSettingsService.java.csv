commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;4;;@Override protected ClusterStateUpdateResponse newResponse(boolean acknowledged) {     return new ClusterStateUpdateResponse(acknowledged). }
false;public;1;129;;@Override public ClusterState execute(ClusterState currentState) {     RoutingTable.Builder routingTableBuilder = RoutingTable.builder(currentState.routingTable()).     MetaData.Builder metaDataBuilder = MetaData.builder(currentState.metaData()).     // allow to change any settings to a close index, and only allow dynamic settings to be changed     // on an open index     Set<Index> openIndices = new HashSet<>().     Set<Index> closeIndices = new HashSet<>().     final String[] actualIndices = new String[request.indices().length].     for (int i = 0. i < request.indices().length. i++) {         Index index = request.indices()[i].         actualIndices[i] = index.getName().         final IndexMetaData metaData = currentState.metaData().getIndexSafe(index).         if (metaData.getState() == IndexMetaData.State.OPEN) {             openIndices.add(index).         } else {             closeIndices.add(index).         }     }     if (!skippedSettings.isEmpty() && !openIndices.isEmpty()) {         throw new IllegalArgumentException(String.format(Locale.ROOT, "Can't update non dynamic settings [%s] for open indices %s", skippedSettings, openIndices)).     }     int updatedNumberOfReplicas = openSettings.getAsInt(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, -1).     if (updatedNumberOfReplicas != -1 && preserveExisting == false) {         // Verify that this won't take us over the cluster shard limit.         int totalNewShards = Arrays.stream(request.indices()).mapToInt(i -> getTotalNewShards(i, currentState, updatedNumberOfReplicas)).sum().         Optional<String> error = IndicesService.checkShardLimit(totalNewShards, currentState).         if (error.isPresent()) {             ValidationException ex = new ValidationException().             ex.addValidationError(error.get()).             throw ex.         }         // we do *not* update the in sync allocation ids as they will be removed upon the first index         // operation which make these copies stale         // TODO: update the list once the data is deleted by the node?         routingTableBuilder.updateNumberOfReplicas(updatedNumberOfReplicas, actualIndices).         metaDataBuilder.updateNumberOfReplicas(updatedNumberOfReplicas, actualIndices).         logger.info("updating number_of_replicas to [{}] for indices {}", updatedNumberOfReplicas, actualIndices).     }     ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(currentState.blocks()).     maybeUpdateClusterBlock(actualIndices, blocks, IndexMetaData.INDEX_READ_ONLY_BLOCK, IndexMetaData.INDEX_READ_ONLY_SETTING, openSettings).     maybeUpdateClusterBlock(actualIndices, blocks, IndexMetaData.INDEX_READ_ONLY_ALLOW_DELETE_BLOCK, IndexMetaData.INDEX_BLOCKS_READ_ONLY_ALLOW_DELETE_SETTING, openSettings).     maybeUpdateClusterBlock(actualIndices, blocks, IndexMetaData.INDEX_METADATA_BLOCK, IndexMetaData.INDEX_BLOCKS_METADATA_SETTING, openSettings).     maybeUpdateClusterBlock(actualIndices, blocks, IndexMetaData.INDEX_WRITE_BLOCK, IndexMetaData.INDEX_BLOCKS_WRITE_SETTING, openSettings).     maybeUpdateClusterBlock(actualIndices, blocks, IndexMetaData.INDEX_READ_BLOCK, IndexMetaData.INDEX_BLOCKS_READ_SETTING, openSettings).     if (!openIndices.isEmpty()) {         for (Index index : openIndices) {             IndexMetaData indexMetaData = metaDataBuilder.getSafe(index).             Settings.Builder updates = Settings.builder().             Settings.Builder indexSettings = Settings.builder().put(indexMetaData.getSettings()).             if (indexScopedSettings.updateDynamicSettings(openSettings, indexSettings, updates, index.getName())) {                 if (preserveExisting) {                     indexSettings.put(indexMetaData.getSettings()).                 }                 Settings finalSettings = indexSettings.build().                 indexScopedSettings.validate(finalSettings.filter(k -> indexScopedSettings.isPrivateSetting(k) == false), true).                 metaDataBuilder.put(IndexMetaData.builder(indexMetaData).settings(finalSettings)).             }         }     }     if (!closeIndices.isEmpty()) {         for (Index index : closeIndices) {             IndexMetaData indexMetaData = metaDataBuilder.getSafe(index).             Settings.Builder updates = Settings.builder().             Settings.Builder indexSettings = Settings.builder().put(indexMetaData.getSettings()).             if (indexScopedSettings.updateSettings(closedSettings, indexSettings, updates, index.getName())) {                 if (preserveExisting) {                     indexSettings.put(indexMetaData.getSettings()).                 }                 Settings finalSettings = indexSettings.build().                 indexScopedSettings.validate(finalSettings.filter(k -> indexScopedSettings.isPrivateSetting(k) == false), true).                 metaDataBuilder.put(IndexMetaData.builder(indexMetaData).settings(finalSettings)).             }         }     }     // increment settings versions     for (final String index : actualIndices) {         if (same(currentState.metaData().index(index).getSettings(), metaDataBuilder.get(index).getSettings()) == false) {             final IndexMetaData.Builder builder = IndexMetaData.builder(metaDataBuilder.get(index)).             builder.settingsVersion(1 + builder.settingsVersion()).             metaDataBuilder.put(builder).         }     }     ClusterState updatedState = ClusterState.builder(currentState).metaData(metaDataBuilder).routingTable(routingTableBuilder.build()).blocks(blocks).build().     // now, reroute in case things change that require it (like number of replicas)     updatedState = allocationService.reroute(updatedState, "settings update").     try {         for (Index index : openIndices) {             final IndexMetaData currentMetaData = currentState.getMetaData().getIndexSafe(index).             final IndexMetaData updatedMetaData = updatedState.metaData().getIndexSafe(index).             indicesService.verifyIndexMetadata(currentMetaData, updatedMetaData).         }         for (Index index : closeIndices) {             final IndexMetaData currentMetaData = currentState.getMetaData().getIndexSafe(index).             final IndexMetaData updatedMetaData = updatedState.metaData().getIndexSafe(index).             // Verifies that the current index settings can be updated with the updated dynamic settings.             indicesService.verifyIndexMetadata(currentMetaData, updatedMetaData).             // Now check that we can create the index with the updated settings (dynamic and non-dynamic).             // This step is mandatory since we allow to update non-dynamic settings on closed indices.             indicesService.verifyIndexMetadata(updatedMetaData, updatedMetaData).         }     } catch (IOException ex) {         throw ExceptionsHelper.convertToElastic(ex).     }     return updatedState. }
false;public;2;169;;public void updateSettings(final UpdateSettingsClusterStateUpdateRequest request, final ActionListener<ClusterStateUpdateResponse> listener) {     final Settings normalizedSettings = Settings.builder().put(request.settings()).normalizePrefix(IndexMetaData.INDEX_SETTING_PREFIX).build().     Settings.Builder settingsForClosedIndices = Settings.builder().     Settings.Builder settingsForOpenIndices = Settings.builder().     final Set<String> skippedSettings = new HashSet<>().     indexScopedSettings.validate(// don't validate wildcards     normalizedSettings.filter(s -> Regex.isSimpleMatchPattern(s) == false), // don't validate dependencies here we check it below never allow to change the number of shards     false, // validate internal or private index settings     true).     for (String key : normalizedSettings.keySet()) {         Setting setting = indexScopedSettings.get(key).         boolean isWildcard = setting == null && Regex.isSimpleMatchPattern(key).         assert // we already validated the normalized settings         setting != null || (isWildcard && normalizedSettings.hasValue(key) == false) : "unknown setting: " + key + " isWildcard: " + isWildcard + " hasValue: " + normalizedSettings.hasValue(key).         settingsForClosedIndices.copy(key, normalizedSettings).         if (isWildcard || setting.isDynamic()) {             settingsForOpenIndices.copy(key, normalizedSettings).         } else {             skippedSettings.add(key).         }     }     final Settings closedSettings = settingsForClosedIndices.build().     final Settings openSettings = settingsForOpenIndices.build().     final boolean preserveExisting = request.isPreserveExisting().     clusterService.submitStateUpdateTask("update-settings", new AckedClusterStateUpdateTask<ClusterStateUpdateResponse>(Priority.URGENT, request, wrapPreservingContext(listener, threadPool.getThreadContext())) {          @Override         protected ClusterStateUpdateResponse newResponse(boolean acknowledged) {             return new ClusterStateUpdateResponse(acknowledged).         }          @Override         public ClusterState execute(ClusterState currentState) {             RoutingTable.Builder routingTableBuilder = RoutingTable.builder(currentState.routingTable()).             MetaData.Builder metaDataBuilder = MetaData.builder(currentState.metaData()).             // allow to change any settings to a close index, and only allow dynamic settings to be changed             // on an open index             Set<Index> openIndices = new HashSet<>().             Set<Index> closeIndices = new HashSet<>().             final String[] actualIndices = new String[request.indices().length].             for (int i = 0. i < request.indices().length. i++) {                 Index index = request.indices()[i].                 actualIndices[i] = index.getName().                 final IndexMetaData metaData = currentState.metaData().getIndexSafe(index).                 if (metaData.getState() == IndexMetaData.State.OPEN) {                     openIndices.add(index).                 } else {                     closeIndices.add(index).                 }             }             if (!skippedSettings.isEmpty() && !openIndices.isEmpty()) {                 throw new IllegalArgumentException(String.format(Locale.ROOT, "Can't update non dynamic settings [%s] for open indices %s", skippedSettings, openIndices)).             }             int updatedNumberOfReplicas = openSettings.getAsInt(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, -1).             if (updatedNumberOfReplicas != -1 && preserveExisting == false) {                 // Verify that this won't take us over the cluster shard limit.                 int totalNewShards = Arrays.stream(request.indices()).mapToInt(i -> getTotalNewShards(i, currentState, updatedNumberOfReplicas)).sum().                 Optional<String> error = IndicesService.checkShardLimit(totalNewShards, currentState).                 if (error.isPresent()) {                     ValidationException ex = new ValidationException().                     ex.addValidationError(error.get()).                     throw ex.                 }                 // we do *not* update the in sync allocation ids as they will be removed upon the first index                 // operation which make these copies stale                 // TODO: update the list once the data is deleted by the node?                 routingTableBuilder.updateNumberOfReplicas(updatedNumberOfReplicas, actualIndices).                 metaDataBuilder.updateNumberOfReplicas(updatedNumberOfReplicas, actualIndices).                 logger.info("updating number_of_replicas to [{}] for indices {}", updatedNumberOfReplicas, actualIndices).             }             ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(currentState.blocks()).             maybeUpdateClusterBlock(actualIndices, blocks, IndexMetaData.INDEX_READ_ONLY_BLOCK, IndexMetaData.INDEX_READ_ONLY_SETTING, openSettings).             maybeUpdateClusterBlock(actualIndices, blocks, IndexMetaData.INDEX_READ_ONLY_ALLOW_DELETE_BLOCK, IndexMetaData.INDEX_BLOCKS_READ_ONLY_ALLOW_DELETE_SETTING, openSettings).             maybeUpdateClusterBlock(actualIndices, blocks, IndexMetaData.INDEX_METADATA_BLOCK, IndexMetaData.INDEX_BLOCKS_METADATA_SETTING, openSettings).             maybeUpdateClusterBlock(actualIndices, blocks, IndexMetaData.INDEX_WRITE_BLOCK, IndexMetaData.INDEX_BLOCKS_WRITE_SETTING, openSettings).             maybeUpdateClusterBlock(actualIndices, blocks, IndexMetaData.INDEX_READ_BLOCK, IndexMetaData.INDEX_BLOCKS_READ_SETTING, openSettings).             if (!openIndices.isEmpty()) {                 for (Index index : openIndices) {                     IndexMetaData indexMetaData = metaDataBuilder.getSafe(index).                     Settings.Builder updates = Settings.builder().                     Settings.Builder indexSettings = Settings.builder().put(indexMetaData.getSettings()).                     if (indexScopedSettings.updateDynamicSettings(openSettings, indexSettings, updates, index.getName())) {                         if (preserveExisting) {                             indexSettings.put(indexMetaData.getSettings()).                         }                         Settings finalSettings = indexSettings.build().                         indexScopedSettings.validate(finalSettings.filter(k -> indexScopedSettings.isPrivateSetting(k) == false), true).                         metaDataBuilder.put(IndexMetaData.builder(indexMetaData).settings(finalSettings)).                     }                 }             }             if (!closeIndices.isEmpty()) {                 for (Index index : closeIndices) {                     IndexMetaData indexMetaData = metaDataBuilder.getSafe(index).                     Settings.Builder updates = Settings.builder().                     Settings.Builder indexSettings = Settings.builder().put(indexMetaData.getSettings()).                     if (indexScopedSettings.updateSettings(closedSettings, indexSettings, updates, index.getName())) {                         if (preserveExisting) {                             indexSettings.put(indexMetaData.getSettings()).                         }                         Settings finalSettings = indexSettings.build().                         indexScopedSettings.validate(finalSettings.filter(k -> indexScopedSettings.isPrivateSetting(k) == false), true).                         metaDataBuilder.put(IndexMetaData.builder(indexMetaData).settings(finalSettings)).                     }                 }             }             // increment settings versions             for (final String index : actualIndices) {                 if (same(currentState.metaData().index(index).getSettings(), metaDataBuilder.get(index).getSettings()) == false) {                     final IndexMetaData.Builder builder = IndexMetaData.builder(metaDataBuilder.get(index)).                     builder.settingsVersion(1 + builder.settingsVersion()).                     metaDataBuilder.put(builder).                 }             }             ClusterState updatedState = ClusterState.builder(currentState).metaData(metaDataBuilder).routingTable(routingTableBuilder.build()).blocks(blocks).build().             // now, reroute in case things change that require it (like number of replicas)             updatedState = allocationService.reroute(updatedState, "settings update").             try {                 for (Index index : openIndices) {                     final IndexMetaData currentMetaData = currentState.getMetaData().getIndexSafe(index).                     final IndexMetaData updatedMetaData = updatedState.metaData().getIndexSafe(index).                     indicesService.verifyIndexMetadata(currentMetaData, updatedMetaData).                 }                 for (Index index : closeIndices) {                     final IndexMetaData currentMetaData = currentState.getMetaData().getIndexSafe(index).                     final IndexMetaData updatedMetaData = updatedState.metaData().getIndexSafe(index).                     // Verifies that the current index settings can be updated with the updated dynamic settings.                     indicesService.verifyIndexMetadata(currentMetaData, updatedMetaData).                     // Now check that we can create the index with the updated settings (dynamic and non-dynamic).                     // This step is mandatory since we allow to update non-dynamic settings on closed indices.                     indicesService.verifyIndexMetadata(updatedMetaData, updatedMetaData).                 }             } catch (IOException ex) {                 throw ExceptionsHelper.convertToElastic(ex).             }             return updatedState.         }     }). }
false;private;3;7;;private int getTotalNewShards(Index index, ClusterState currentState, int updatedNumberOfReplicas) {     IndexMetaData indexMetaData = currentState.metaData().index(index).     int shardsInIndex = indexMetaData.getNumberOfShards().     int oldNumberOfReplicas = indexMetaData.getNumberOfReplicas().     int replicaIncrease = updatedNumberOfReplicas - oldNumberOfReplicas.     return replicaIncrease * shardsInIndex. }
true;private,static;5;13;/**  * Updates the cluster block only iff the setting exists in the given settings  */ ;/**  * Updates the cluster block only iff the setting exists in the given settings  */ private static void maybeUpdateClusterBlock(String[] actualIndices, ClusterBlocks.Builder blocks, ClusterBlock block, Setting<Boolean> setting, Settings openSettings) {     if (setting.exists(openSettings)) {         final boolean updateBlock = setting.get(openSettings).         for (String index : actualIndices) {             if (updateBlock) {                 blocks.addIndexBlock(index, block).             } else {                 blocks.removeIndexBlock(index, block).             }         }     } }
false;protected;1;4;;@Override protected ClusterStateUpdateResponse newResponse(boolean acknowledged) {     return new ClusterStateUpdateResponse(acknowledged). }
false;public;1;23;;@Override public ClusterState execute(ClusterState currentState) {     MetaData.Builder metaDataBuilder = MetaData.builder(currentState.metaData()).     for (Map.Entry<String, Tuple<Version, String>> entry : request.versions().entrySet()) {         String index = entry.getKey().         IndexMetaData indexMetaData = metaDataBuilder.get(index).         if (indexMetaData != null) {             if (Version.CURRENT.equals(indexMetaData.getCreationVersion()) == false) {                 // no reason to pollute the settings, we didn't really upgrade anything                 metaDataBuilder.put(IndexMetaData.builder(indexMetaData).settings(Settings.builder().put(indexMetaData.getSettings()).put(IndexMetaData.SETTING_VERSION_UPGRADED, entry.getValue().v1())).settingsVersion(1 + indexMetaData.getSettingsVersion())).             }         }     }     return ClusterState.builder(currentState).metaData(metaDataBuilder).build(). }
false;public;2;36;;public void upgradeIndexSettings(final UpgradeSettingsClusterStateUpdateRequest request, final ActionListener<ClusterStateUpdateResponse> listener) {     clusterService.submitStateUpdateTask("update-index-compatibility-versions", new AckedClusterStateUpdateTask<ClusterStateUpdateResponse>(Priority.URGENT, request, wrapPreservingContext(listener, threadPool.getThreadContext())) {          @Override         protected ClusterStateUpdateResponse newResponse(boolean acknowledged) {             return new ClusterStateUpdateResponse(acknowledged).         }          @Override         public ClusterState execute(ClusterState currentState) {             MetaData.Builder metaDataBuilder = MetaData.builder(currentState.metaData()).             for (Map.Entry<String, Tuple<Version, String>> entry : request.versions().entrySet()) {                 String index = entry.getKey().                 IndexMetaData indexMetaData = metaDataBuilder.get(index).                 if (indexMetaData != null) {                     if (Version.CURRENT.equals(indexMetaData.getCreationVersion()) == false) {                         // no reason to pollute the settings, we didn't really upgrade anything                         metaDataBuilder.put(IndexMetaData.builder(indexMetaData).settings(Settings.builder().put(indexMetaData.getSettings()).put(IndexMetaData.SETTING_VERSION_UPGRADED, entry.getValue().v1())).settingsVersion(1 + indexMetaData.getSettingsVersion())).                     }                 }             }             return ClusterState.builder(currentState).metaData(metaDataBuilder).build().         }     }). }
