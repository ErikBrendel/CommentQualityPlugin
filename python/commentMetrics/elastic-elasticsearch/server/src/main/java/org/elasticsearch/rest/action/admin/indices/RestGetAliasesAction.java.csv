commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String getName() {     return "get_aliases_action". }
false;static;4;87;;static RestResponse buildRestResponse(boolean aliasesExplicitlyRequested, String[] requestedAliases, ImmutableOpenMap<String, List<AliasMetaData>> responseAliasMap, XContentBuilder builder) throws Exception {     final Set<String> indicesToDisplay = new HashSet<>().     final Set<String> returnedAliasNames = new HashSet<>().     for (final ObjectObjectCursor<String, List<AliasMetaData>> cursor : responseAliasMap) {         for (final AliasMetaData aliasMetaData : cursor.value) {             if (aliasesExplicitlyRequested) {                 // only display indices that have aliases                 indicesToDisplay.add(cursor.key).             }             returnedAliasNames.add(aliasMetaData.alias()).         }     }     // compute explicitly requested aliases that have are not returned in the result     final SortedSet<String> missingAliases = new TreeSet<>().     // first wildcard index, leading "-" as an alias name after this index means     // that it is an exclusion     int firstWildcardIndex = requestedAliases.length.     for (int i = 0. i < requestedAliases.length. i++) {         if (Regex.isSimpleMatchPattern(requestedAliases[i])) {             firstWildcardIndex = i.             break.         }     }     for (int i = 0. i < requestedAliases.length. i++) {         if (MetaData.ALL.equals(requestedAliases[i]) || Regex.isSimpleMatchPattern(requestedAliases[i]) || (i > firstWildcardIndex && requestedAliases[i].charAt(0) == '-')) {             // only explicitly requested aliases will be called out as missing (404)             continue.         }         // check if aliases[i] is subsequently excluded         int j = Math.max(i + 1, firstWildcardIndex).         for (. j < requestedAliases.length. j++) {             if (requestedAliases[j].charAt(0) == '-') {                 // this is an exclude pattern                 if (Regex.simpleMatch(requestedAliases[j].substring(1), requestedAliases[i]) || MetaData.ALL.equals(requestedAliases[j].substring(1))) {                     // aliases[i] is excluded by aliases[j]                     break.                 }             }         }         if (j == requestedAliases.length) {             // explicitly requested aliases[i] is not excluded by any subsequent "-" wildcard in expression             if (false == returnedAliasNames.contains(requestedAliases[i])) {                 // aliases[i] is not in the result set                 missingAliases.add(requestedAliases[i]).             }         }     }     final RestStatus status.     builder.startObject().     {         if (missingAliases.isEmpty()) {             status = RestStatus.OK.         } else {             status = RestStatus.NOT_FOUND.             final String message.             if (missingAliases.size() == 1) {                 message = String.format(Locale.ROOT, "alias [%s] missing", Strings.collectionToCommaDelimitedString(missingAliases)).             } else {                 message = String.format(Locale.ROOT, "aliases [%s] missing", Strings.collectionToCommaDelimitedString(missingAliases)).             }             builder.field("error", message).             builder.field("status", status.getStatus()).         }         for (final ObjectObjectCursor<String, List<AliasMetaData>> entry : responseAliasMap) {             if (aliasesExplicitlyRequested == false || (aliasesExplicitlyRequested && indicesToDisplay.contains(entry.key))) {                 builder.startObject(entry.key).                 {                     builder.startObject("aliases").                     {                         for (final AliasMetaData alias : entry.value) {                             AliasMetaData.Builder.toXContent(alias, builder, ToXContent.EMPTY_PARAMS).                         }                     }                     builder.endObject().                 }                 builder.endObject().             }         }     }     builder.endObject().     return new BytesRestResponse(status, builder). }
false;public;2;4;;@Override public RestResponse buildResponse(GetAliasesResponse response, XContentBuilder builder) throws Exception {     return buildRestResponse(namesProvided, aliases, response.getAliases(), builder). }
false;public;2;23;;@Override public RestChannelConsumer prepareRequest(final RestRequest request, final NodeClient client) throws IOException {     // The TransportGetAliasesAction was improved do the same post processing as is happening here.     // We can't remove this logic yet to support mixed clusters. We should be able to remove this logic here     // in when 8.0 becomes the new version in the master branch.     final boolean namesProvided = request.hasParam("name").     final String[] aliases = request.paramAsStringArrayOrEmptyIfAll("name").     final GetAliasesRequest getAliasesRequest = new GetAliasesRequest(aliases).     final String[] indices = Strings.splitStringByCommaToArray(request.param("index")).     getAliasesRequest.indices(indices).     getAliasesRequest.indicesOptions(IndicesOptions.fromRequest(request, getAliasesRequest.indicesOptions())).     getAliasesRequest.local(request.paramAsBoolean("local", getAliasesRequest.local())).     // not always be available there (they may get replaced so retrieving request.aliases is not quite the same).     return channel -> client.admin().indices().getAliases(getAliasesRequest, new RestBuilderListener<GetAliasesResponse>(channel) {          @Override         public RestResponse buildResponse(GetAliasesResponse response, XContentBuilder builder) throws Exception {             return buildRestResponse(namesProvided, aliases, response.getAliases(), builder).         }     }). }
