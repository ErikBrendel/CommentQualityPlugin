commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public void readFrom(StreamInput in) throws IOException {     throw new UnsupportedOperationException("usage of Streamable is to be replaced by Writeable"). }
false;public;1;17;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeVInt(groups.length).     for (ClusterSearchShardsGroup response : groups) {         response.writeTo(out).     }     out.writeVInt(nodes.length).     for (DiscoveryNode node : nodes) {         node.writeTo(out).     }     out.writeVInt(indicesAndFilters.size()).     for (Map.Entry<String, AliasFilter> entry : indicesAndFilters.entrySet()) {         out.writeString(entry.getKey()).         entry.getValue().writeTo(out).     } }
false;public;0;3;;public ClusterSearchShardsGroup[] getGroups() {     return groups. }
false;public;0;3;;public DiscoveryNode[] getNodes() {     return nodes. }
false;public;0;3;;public Map<String, AliasFilter> getIndicesAndFilters() {     return indicesAndFilters. }
false;public;2;35;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.startObject("nodes").     for (DiscoveryNode node : nodes) {         node.toXContent(builder, params).     }     builder.endObject().     if (indicesAndFilters != null) {         builder.startObject("indices").         for (Map.Entry<String, AliasFilter> entry : indicesAndFilters.entrySet()) {             String index = entry.getKey().             builder.startObject(index).             AliasFilter aliasFilter = entry.getValue().             String[] aliases = aliasFilter.getAliases().             if (aliases.length > 0) {                 // we want consistent ordering here and these values might be generated from a set / map                 Arrays.sort(aliases).                 builder.array("aliases", aliases).                 if (aliasFilter.getQueryBuilder() != null) {                     // might be null if we include non-filtering aliases                     builder.field("filter").                     aliasFilter.getQueryBuilder().toXContent(builder, params).                 }             }             builder.endObject().         }         builder.endObject().     }     builder.startArray("shards").     for (ClusterSearchShardsGroup group : groups) {         group.toXContent(builder, params).     }     builder.endArray().     builder.endObject().     return builder. }
