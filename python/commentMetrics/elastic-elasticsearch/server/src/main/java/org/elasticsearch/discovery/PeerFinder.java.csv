commented;modifiers;parameterAmount;loc;comment;code
false;public;1;13;;public void activate(final DiscoveryNodes lastAcceptedNodes) {     logger.trace("activating with {}", lastAcceptedNodes).     synchronized (mutex) {         assert assertInactiveWithNoKnownPeers().         active = true.         this.lastAcceptedNodes = lastAcceptedNodes.         leader = Optional.empty().         // return value discarded: there are no known peers, so none can be disconnected         handleWakeUp().     }     // trigger a check for a quorum already     onFoundPeersUpdated(). }
false;public;1;13;;public void deactivate(DiscoveryNode leader) {     final boolean peersRemoved.     synchronized (mutex) {         logger.trace("deactivating and setting leader to {}", leader).         active = false.         peersRemoved = handleWakeUp().         this.leader = Optional.of(leader).         assert assertInactiveWithNoKnownPeers().     }     if (peersRemoved) {         onFoundPeersUpdated().     } }
true;protected,final;0;3;// exposed to subclasses for testing ;// exposed to subclasses for testing protected final boolean holdsLock() {     return Thread.holdsLock(mutex). }
false;private;0;6;;private boolean assertInactiveWithNoKnownPeers() {     assert holdsLock() : "PeerFinder mutex not held".     assert active == false.     assert peersByAddress.isEmpty() : peersByAddress.keySet().     return true. }
false;;1;18;;PeersResponse handlePeersRequest(PeersRequest peersRequest) {     synchronized (mutex) {         assert peersRequest.getSourceNode().equals(getLocalNode()) == false.         final List<DiscoveryNode> knownPeers.         if (active) {             assert leader.isPresent() == false : leader.             if (peersRequest.getSourceNode().isMasterNode()) {                 startProbe(peersRequest.getSourceNode().getAddress()).             }             peersRequest.getKnownPeers().stream().map(DiscoveryNode::getAddress).forEach(this::startProbe).             knownPeers = getFoundPeersUnderLock().         } else {             assert leader.isPresent() || lastAcceptedNodes == null.             knownPeers = emptyList().         }         return new PeersResponse(leader, knownPeers, currentTerm).     } }
true;public;0;5;// exposed for checking invariant in o.e.c.c.Coordinator (public since this is a different package) ;// exposed for checking invariant in o.e.c.c.Coordinator (public since this is a different package) public Optional<DiscoveryNode> getLeader() {     synchronized (mutex) {         return leader.     } }
true;public;0;3;// exposed for checking invariant in o.e.c.c.Coordinator (public since this is a different package) ;// exposed for checking invariant in o.e.c.c.Coordinator (public since this is a different package) public long getCurrentTerm() {     return currentTerm. }
false;public;1;3;;public void setCurrentTerm(long currentTerm) {     this.currentTerm = currentTerm. }
false;private;0;5;;private DiscoveryNode getLocalNode() {     final DiscoveryNode localNode = transportService.getLocalNode().     assert localNode != null.     return localNode. }
true;protected,abstract;2;1;/**  * Invoked on receipt of a PeersResponse from a node that believes it's an active leader, which this node should therefore try and join.  * Note that invocations of this method are not synchronised. By the time it is called we may have been deactivated.  */ ;/**  * Invoked on receipt of a PeersResponse from a node that believes it's an active leader, which this node should therefore try and join.  * Note that invocations of this method are not synchronised. By the time it is called we may have been deactivated.  */ protected abstract void onActiveMasterFound(DiscoveryNode masterNode, long term).
true;protected,abstract;0;1;/**  * Invoked when the set of found peers changes. Note that invocations of this method are not fully synchronised, so we only guarantee  * that the change to the set of found peers happens before this method is invoked. If there are multiple concurrent changes then there  * will be multiple concurrent invocations of this method, with no guarantee as to their order. For this reason we do not pass the  * updated set of peers as an argument to this method, leaving it to the implementation to call getFoundPeers() with appropriate  * synchronisation to avoid lost updates. Also, by the time this method is invoked we may have been deactivated.  */ ;/**  * Invoked when the set of found peers changes. Note that invocations of this method are not fully synchronised, so we only guarantee  * that the change to the set of found peers happens before this method is invoked. If there are multiple concurrent changes then there  * will be multiple concurrent invocations of this method, with no guarantee as to their order. For this reason we do not pass the  * updated set of peers as an argument to this method, leaving it to the implementation to call getFoundPeers() with appropriate  * synchronisation to avoid lost updates. Also, by the time this method is invoked we may have been deactivated.  */ protected abstract void onFoundPeersUpdated().
false;public;0;3;;public List<TransportAddress> getLastResolvedAddresses() {     return lastResolvedAddresses. }
true;;2;1;/**  * Identify the node at the given address and, if it is a master node and not the local node then establish a full connection to it.  */ ;/**  * Identify the node at the given address and, if it is a master node and not the local node then establish a full connection to it.  */ void connectToRemoteMasterNode(TransportAddress transportAddress, ActionListener<DiscoveryNode> listener).
true;;1;1;/**  * Attempt to resolve the configured unicast hosts list to a list of transport addresses.  *  * @param consumer Consumer for the resolved list. May not be called if an error occurs or if another resolution attempt is in  *                 progress.  */ ;/**  * Attempt to resolve the configured unicast hosts list to a list of transport addresses.  *  * @param consumer Consumer for the resolved list. May not be called if an error occurs or if another resolution attempt is in  *                 progress.  */ void resolveConfiguredHosts(Consumer<List<TransportAddress>> consumer).
false;public;0;5;;public Iterable<DiscoveryNode> getFoundPeers() {     synchronized (mutex) {         return getFoundPeersUnderLock().     } }
false;private;0;5;;private List<DiscoveryNode> getFoundPeersUnderLock() {     assert holdsLock() : "PeerFinder mutex not held".     return peersByAddress.values().stream().map(Peer::getDiscoveryNode).filter(Objects::nonNull).distinct().collect(Collectors.toList()). }
false;private;1;5;;private Peer createConnectingPeer(TransportAddress transportAddress) {     Peer peer = new Peer(transportAddress).     peer.establishConnection().     return peer. }
false;public;0;4;;@Override public boolean isForceExecution() {     return true. }
false;public;1;5;;@Override public void onFailure(Exception e) {     assert false : e.     logger.debug("unexpected exception in wakeup", e). }
false;protected;0;9;;@Override protected void doRun() {     synchronized (mutex) {         if (handleWakeUp() == false) {             return.         }     }     onFoundPeersUpdated(). }
false;public;0;4;;@Override public String toString() {     return "PeerFinder handling wakeup". }
true;private;0;53;/**  * @return whether any peers were removed due to disconnection  */ ;/**  * @return whether any peers were removed due to disconnection  */ private boolean handleWakeUp() {     assert holdsLock() : "PeerFinder mutex not held".     final boolean peersRemoved = peersByAddress.values().removeIf(Peer::handleWakeUp).     if (active == false) {         logger.trace("not active").         return peersRemoved.     }     logger.trace("probing master nodes from cluster state: {}", lastAcceptedNodes).     for (ObjectCursor<DiscoveryNode> discoveryNodeObjectCursor : lastAcceptedNodes.getMasterNodes().values()) {         startProbe(discoveryNodeObjectCursor.value.getAddress()).     }     configuredHostsResolver.resolveConfiguredHosts(providedAddresses -> {         synchronized (mutex) {             lastResolvedAddresses = providedAddresses.             logger.trace("probing resolved transport addresses {}", providedAddresses).             providedAddresses.forEach(this::startProbe).         }     }).     transportService.getThreadPool().scheduleUnlessShuttingDown(findPeersInterval, Names.GENERIC, new AbstractRunnable() {          @Override         public boolean isForceExecution() {             return true.         }          @Override         public void onFailure(Exception e) {             assert false : e.             logger.debug("unexpected exception in wakeup", e).         }          @Override         protected void doRun() {             synchronized (mutex) {                 if (handleWakeUp() == false) {                     return.                 }             }             onFoundPeersUpdated().         }          @Override         public String toString() {             return "PeerFinder handling wakeup".         }     }).     return peersRemoved. }
false;private;1;14;;private void startProbe(TransportAddress transportAddress) {     assert holdsLock() : "PeerFinder mutex not held".     if (active == false) {         logger.trace("startProbe({}) not running", transportAddress).         return.     }     if (transportAddress.equals(getLocalNode().getAddress())) {         logger.trace("startProbe({}) not probing local node", transportAddress).         return.     }     peersByAddress.computeIfAbsent(transportAddress, this::createConnectingPeer). }
false;;0;4;;@Nullable DiscoveryNode getDiscoveryNode() {     return discoveryNode.get(). }
false;;0;23;;boolean handleWakeUp() {     assert holdsLock() : "PeerFinder mutex not held".     if (active == false) {         return true.     }     final DiscoveryNode discoveryNode = getDiscoveryNode().     if (discoveryNode != null) {         if (transportService.nodeConnected(discoveryNode)) {             if (peersRequestInFlight == false) {                 requestPeers().             }         } else {             logger.trace("{} no longer connected", this).             return true.         }     }     return false. }
false;public;1;17;;@Override public void onResponse(DiscoveryNode remoteNode) {     assert remoteNode.isMasterNode() : remoteNode + " is not master-eligible".     assert remoteNode.equals(getLocalNode()) == false : remoteNode + " is the local node".     synchronized (mutex) {         if (active == false) {             return.         }         assert discoveryNode.get() == null : "discoveryNode unexpectedly already set to " + discoveryNode.get().         discoveryNode.set(remoteNode).         requestPeers().     }     assert holdsLock() == false : "PeerFinder mutex is held in error".     onFoundPeersUpdated(). }
false;public;1;7;;@Override public void onFailure(Exception e) {     logger.debug(() -> new ParameterizedMessage("{} connection failed", Peer.this), e).     synchronized (mutex) {         peersByAddress.remove(transportAddress).     } }
false;;0;34;;void establishConnection() {     assert holdsLock() : "PeerFinder mutex not held".     assert getDiscoveryNode() == null : "unexpectedly connected to " + getDiscoveryNode().     assert active.     logger.trace("{} attempting connection", this).     transportAddressConnector.connectToRemoteMasterNode(transportAddress, new ActionListener<DiscoveryNode>() {          @Override         public void onResponse(DiscoveryNode remoteNode) {             assert remoteNode.isMasterNode() : remoteNode + " is not master-eligible".             assert remoteNode.equals(getLocalNode()) == false : remoteNode + " is the local node".             synchronized (mutex) {                 if (active == false) {                     return.                 }                 assert discoveryNode.get() == null : "discoveryNode unexpectedly already set to " + discoveryNode.get().                 discoveryNode.set(remoteNode).                 requestPeers().             }             assert holdsLock() == false : "PeerFinder mutex is held in error".             onFoundPeersUpdated().         }          @Override         public void onFailure(Exception e) {             logger.debug(() -> new ParameterizedMessage("{} connection failed", Peer.this), e).             synchronized (mutex) {                 peersByAddress.remove(transportAddress).             }         }     }). }
false;public;1;4;;@Override public PeersResponse read(StreamInput in) throws IOException {     return new PeersResponse(in). }
false;public;1;20;;@Override public void handleResponse(PeersResponse response) {     logger.trace("{} received {}", Peer.this, response).     synchronized (mutex) {         if (active == false) {             return.         }         peersRequestInFlight = false.         response.getMasterNode().map(DiscoveryNode::getAddress).ifPresent(PeerFinder.this::startProbe).         response.getKnownPeers().stream().map(DiscoveryNode::getAddress).forEach(PeerFinder.this::startProbe).     }     if (response.getMasterNode().equals(Optional.of(discoveryNode))) {         // Must not hold lock here to avoid deadlock         assert holdsLock() == false : "PeerFinder mutex is held in error".         onActiveMasterFound(discoveryNode, response.getTerm()).     } }
false;public;1;5;;@Override public void handleException(TransportException exp) {     peersRequestInFlight = false.     logger.debug(new ParameterizedMessage("{} peers request failed", Peer.this), exp). }
false;public;0;4;;@Override public String executor() {     return Names.GENERIC. }
false;private;0;62;;private void requestPeers() {     assert holdsLock() : "PeerFinder mutex not held".     assert peersRequestInFlight == false : "PeersRequest already in flight".     assert active.     final DiscoveryNode discoveryNode = getDiscoveryNode().     assert discoveryNode != null : "cannot request peers without first connecting".     if (discoveryNode.equals(getLocalNode())) {         logger.trace("{} not requesting peers from local node", this).         return.     }     logger.trace("{} requesting peers", this).     peersRequestInFlight = true.     final List<DiscoveryNode> knownNodes = getFoundPeersUnderLock().     final TransportResponseHandler<PeersResponse> peersResponseHandler = new TransportResponseHandler<PeersResponse>() {          @Override         public PeersResponse read(StreamInput in) throws IOException {             return new PeersResponse(in).         }          @Override         public void handleResponse(PeersResponse response) {             logger.trace("{} received {}", Peer.this, response).             synchronized (mutex) {                 if (active == false) {                     return.                 }                 peersRequestInFlight = false.                 response.getMasterNode().map(DiscoveryNode::getAddress).ifPresent(PeerFinder.this::startProbe).                 response.getKnownPeers().stream().map(DiscoveryNode::getAddress).forEach(PeerFinder.this::startProbe).             }             if (response.getMasterNode().equals(Optional.of(discoveryNode))) {                 // Must not hold lock here to avoid deadlock                 assert holdsLock() == false : "PeerFinder mutex is held in error".                 onActiveMasterFound(discoveryNode, response.getTerm()).             }         }          @Override         public void handleException(TransportException exp) {             peersRequestInFlight = false.             logger.debug(new ParameterizedMessage("{} peers request failed", Peer.this), exp).         }          @Override         public String executor() {             return Names.GENERIC.         }     }.     transportService.sendRequest(discoveryNode, REQUEST_PEERS_ACTION_NAME, new PeersRequest(getLocalNode(), knownNodes), TransportRequestOptions.builder().withTimeout(requestPeersTimeout).build(), peersResponseHandler). }
false;public;0;8;;@Override public String toString() {     return "Peer{" + "transportAddress=" + transportAddress + ", discoveryNode=" + discoveryNode.get() + ", peersRequestInFlight=" + peersRequestInFlight + '}'. }
