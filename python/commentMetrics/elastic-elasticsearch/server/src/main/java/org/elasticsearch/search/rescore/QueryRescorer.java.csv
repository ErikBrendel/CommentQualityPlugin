commented;modifiers;parameterAmount;loc;comment;code
false;protected;3;10;;@Override protected float combine(float firstPassScore, boolean secondPassMatches, float secondPassScore) {     if (secondPassMatches) {         return rescore.scoreMode.combine(firstPassScore * rescore.queryWeight(), secondPassScore * rescore.rescoreQueryWeight()).     }     // secondary score?     return firstPassScore * rescore.queryWeight(). }
false;public;3;38;;@Override public TopDocs rescore(TopDocs topDocs, IndexSearcher searcher, RescoreContext rescoreContext) throws IOException {     assert rescoreContext != null.     if (topDocs == null || topDocs.scoreDocs.length == 0) {         return topDocs.     }     final QueryRescoreContext rescore = (QueryRescoreContext) rescoreContext.     org.apache.lucene.search.Rescorer rescorer = new org.apache.lucene.search.QueryRescorer(rescore.query()) {          @Override         protected float combine(float firstPassScore, boolean secondPassMatches, float secondPassScore) {             if (secondPassMatches) {                 return rescore.scoreMode.combine(firstPassScore * rescore.queryWeight(), secondPassScore * rescore.rescoreQueryWeight()).             }             // secondary score?             return firstPassScore * rescore.queryWeight().         }     }.     // First take top slice of incoming docs, to be rescored:     TopDocs topNFirstPass = topN(topDocs, rescoreContext.getWindowSize()).     // Save doc IDs for which rescoring was applied to be used in score explanation     Set<Integer> topNDocIDs = Collections.unmodifiableSet(Arrays.stream(topNFirstPass.scoreDocs).map(scoreDoc -> scoreDoc.doc).collect(toSet())).     rescoreContext.setRescoredDocs(topNDocIDs).     // Rescore them:     TopDocs rescored = rescorer.rescore(searcher, topNFirstPass, rescoreContext.getWindowSize()).     // Splice back to non-topN hits and resort all of them:     return combine(topDocs, rescored, (QueryRescoreContext) rescoreContext). }
false;public;4;36;;@Override public Explanation explain(int topLevelDocId, IndexSearcher searcher, RescoreContext rescoreContext, Explanation sourceExplanation) throws IOException {     if (sourceExplanation == null) {         // this should not happen but just in case         return Explanation.noMatch("nothing matched").     }     QueryRescoreContext rescore = (QueryRescoreContext) rescoreContext.     float primaryWeight = rescore.queryWeight().     Explanation prim.     if (sourceExplanation.isMatch()) {         prim = Explanation.match(sourceExplanation.getValue().floatValue() * primaryWeight, "product of:", sourceExplanation, Explanation.match(primaryWeight, "primaryWeight")).     } else {         prim = Explanation.noMatch("First pass did not match", sourceExplanation).     }     if (rescoreContext.isRescored(topLevelDocId)) {         Explanation rescoreExplain = searcher.explain(rescore.query(), topLevelDocId).         // Maybe we should add QueryRescorer.explainCombine to Lucene?         if (rescoreExplain != null && rescoreExplain.isMatch()) {             float secondaryWeight = rescore.rescoreQueryWeight().             Explanation sec = Explanation.match(rescoreExplain.getValue().floatValue() * secondaryWeight, "product of:", rescoreExplain, Explanation.match(secondaryWeight, "secondaryWeight")).             QueryRescoreMode scoreMode = rescore.scoreMode().             return Explanation.match(scoreMode.combine(prim.getValue().floatValue(), sec.getValue().floatValue()), scoreMode + " of:", prim, sec).         }     }     return prim. }
false;public;2;5;;@Override public int compare(ScoreDoc o1, ScoreDoc o2) {     int cmp = Float.compare(o2.score, o1.score).     return cmp == 0 ? Integer.compare(o1.doc, o2.doc) : cmp. }
true;private;2;10;/**  * Returns a new {@link TopDocs} with the topN from the incoming one, or the same TopDocs if the number of hits is already &lt.=  *  topN.  */ ;/**  * Returns a new {@link TopDocs} with the topN from the incoming one, or the same TopDocs if the number of hits is already &lt.=  *  topN.  */ private TopDocs topN(TopDocs in, int topN) {     if (in.scoreDocs.length < topN) {         return in.     }     ScoreDoc[] subset = new ScoreDoc[topN].     System.arraycopy(in.scoreDocs, 0, subset, 0, topN).     return new TopDocs(in.totalHits, subset). }
true;private;3;18;/**  * Modifies incoming TopDocs (in) by replacing the top hits with resorted's hits, and then resorting all hits.  */ ;/**  * Modifies incoming TopDocs (in) by replacing the top hits with resorted's hits, and then resorting all hits.  */ private TopDocs combine(TopDocs in, TopDocs resorted, QueryRescoreContext ctx) {     System.arraycopy(resorted.scoreDocs, 0, in.scoreDocs, 0, resorted.scoreDocs.length).     if (in.scoreDocs.length > resorted.scoreDocs.length) {         // not match the 2nd pass query:         for (int i = resorted.scoreDocs.length. i < in.scoreDocs.length. i++) {             // TODO: shouldn't this be up to the ScoreMode?  I.e., we should just invoke ScoreMode.combine, passing 0.0f for the             // secondary score?             in.scoreDocs[i].score *= ctx.queryWeight().         }         // TODO: this is wrong, i.e. we are comparing apples and oranges at this point.  It would be better if we always rescored all         // incoming first pass hits, instead of allowing recoring of just the top subset:         Arrays.sort(in.scoreDocs, SCORE_DOC_COMPARATOR).     }     return in. }
false;public;1;3;;public void setQuery(Query query) {     this.query = query. }
false;public;0;4;;@Override public List<Query> getQueries() {     return Collections.singletonList(query). }
false;public;0;3;;public Query query() {     return query. }
false;public;0;3;;public float queryWeight() {     return queryWeight. }
false;public;0;3;;public float rescoreQueryWeight() {     return rescoreQueryWeight. }
false;public;0;3;;public QueryRescoreMode scoreMode() {     return scoreMode. }
false;public;1;3;;public void setRescoreQueryWeight(float rescoreQueryWeight) {     this.rescoreQueryWeight = rescoreQueryWeight. }
false;public;1;3;;public void setQueryWeight(float queryWeight) {     this.queryWeight = queryWeight. }
false;public;1;3;;public void setScoreMode(QueryRescoreMode scoreMode) {     this.scoreMode = scoreMode. }
false;public;1;3;;public void setScoreMode(String scoreMode) {     setScoreMode(QueryRescoreMode.fromString(scoreMode)). }
