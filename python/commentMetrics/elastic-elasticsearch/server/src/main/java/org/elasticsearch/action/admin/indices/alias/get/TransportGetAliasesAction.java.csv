commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;5;;@Override protected String executor() {     // very lightweight operation all in memory no need to fork to a thread pool     return ThreadPool.Names.SAME. }
false;protected;2;5;;@Override protected ClusterBlockException checkBlock(GetAliasesRequest request, ClusterState state) {     return state.blocks().indicesBlockedException(ClusterBlockLevel.METADATA_READ, indexNameExpressionResolver.concreteIndexNames(state, request)). }
false;protected;0;4;;@Override protected GetAliasesResponse newResponse() {     return new GetAliasesResponse(). }
false;protected;3;6;;@Override protected void masterOperation(GetAliasesRequest request, ClusterState state, ActionListener<GetAliasesResponse> listener) {     String[] concreteIndices = indexNameExpressionResolver.concreteIndexNames(state, request).     ImmutableOpenMap<String, List<AliasMetaData>> aliases = state.metaData().findAliases(request, concreteIndices).     listener.onResponse(new GetAliasesResponse(postProcess(request, concreteIndices, aliases))). }
true;static;3;12;/**  * Fills alias result with empty entries for requested indices when no specific aliases were requested.  */ ;/**  * Fills alias result with empty entries for requested indices when no specific aliases were requested.  */ static ImmutableOpenMap<String, List<AliasMetaData>> postProcess(GetAliasesRequest request, String[] concreteIndices, ImmutableOpenMap<String, List<AliasMetaData>> aliases) {     boolean noAliasesSpecified = request.getOriginalAliases() == null || request.getOriginalAliases().length == 0.     ImmutableOpenMap.Builder<String, List<AliasMetaData>> mapBuilder = ImmutableOpenMap.builder(aliases).     for (String index : concreteIndices) {         if (aliases.get(index) == null && noAliasesSpecified) {             List<AliasMetaData> previous = mapBuilder.put(index, Collections.emptyList()).             assert previous == null.         }     }     return mapBuilder.build(). }
