commented;modifiers;parameterAmount;loc;comment;code
false;public;1;6;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeBoolean(normalize).     out.writeOptionalVInt(unknownDocRating).     out.writeVInt(k). }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
false;;0;3;;boolean getNormalize() {     return this.normalize. }
false;;0;3;;int getK() {     return this.k. }
true;public;0;3;/**  * get the rating used for unrated documents  */ ;/**  * get the rating used for unrated documents  */ public Integer getUnknownDocRating() {     return this.unknownDocRating. }
false;public;0;4;;@Override public OptionalInt forcedSearchSize() {     return OptionalInt.of(k). }
false;public;3;38;;@Override public EvalQueryQuality evaluate(String taskId, SearchHit[] hits, List<RatedDocument> ratedDocs) {     List<RatedSearchHit> ratedHits = joinHitsWithRatings(hits, ratedDocs).     List<Integer> ratingsInSearchHits = new ArrayList<>(ratedHits.size()).     int unratedResults = 0.     for (RatedSearchHit hit : ratedHits) {         if (hit.getRating().isPresent()) {             ratingsInSearchHits.add(hit.getRating().getAsInt()).         } else {             // unknownDocRating might be null, in which case unrated docs will be ignored in the dcg calculation.             // we still need to add them as a placeholder so the rank of the subsequent ratings is correct             ratingsInSearchHits.add(unknownDocRating).         }         if (hit.getRating().isPresent() == false) {             unratedResults++.         }     }     final double dcg = computeDCG(ratingsInSearchHits).     double result = dcg.     double idcg = 0.     if (normalize) {         List<Integer> allRatings = ratedDocs.stream().mapToInt(RatedDocument::getRating).boxed().collect(Collectors.toList()).         Collections.sort(allRatings, Comparator.nullsLast(Collections.reverseOrder())).         idcg = computeDCG(allRatings.subList(0, Math.min(ratingsInSearchHits.size(), allRatings.size()))).         if (idcg != 0) {             result = dcg / idcg.         } else {             result = 0.         }     }     EvalQueryQuality evalQueryQuality = new EvalQueryQuality(taskId, result).     evalQueryQuality.addHitsAndRatings(ratedHits).     evalQueryQuality.setMetricDetails(new Detail(dcg, idcg, unratedResults)).     return evalQueryQuality. }
false;private,static;1;11;;private static double computeDCG(List<Integer> ratings) {     int rank = 1.     double dcg = 0.     for (Integer rating : ratings) {         if (rating != null) {             dcg += (Math.pow(2, rating) - 1) / ((Math.log(rank + 1) / LOG2)).         }         rank++.     }     return dcg. }
false;public,static;1;3;;public static DiscountedCumulativeGain fromXContent(XContentParser parser) {     return PARSER.apply(parser, null). }
false;public;2;13;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.startObject(NAME).     builder.field(NORMALIZE_FIELD.getPreferredName(), this.normalize).     if (unknownDocRating != null) {         builder.field(UNKNOWN_DOC_RATING_FIELD.getPreferredName(), this.unknownDocRating).     }     builder.field(K_FIELD.getPreferredName(), this.k).     builder.endObject().     builder.endObject().     return builder. }
false;public,final;1;13;;@Override public final boolean equals(Object obj) {     if (this == obj) {         return true.     }     if (obj == null || getClass() != obj.getClass()) {         return false.     }     DiscountedCumulativeGain other = (DiscountedCumulativeGain) obj.     return Objects.equals(normalize, other.normalize) && Objects.equals(unknownDocRating, other.unknownDocRating) && Objects.equals(k, other.k). }
false;public,final;0;4;;@Override public final int hashCode() {     return Objects.hash(normalize, unknownDocRating, k). }
false;public;0;5;;@Override public String getMetricName() {     return NAME. }
false;public;2;10;;@Override public XContentBuilder innerToXContent(XContentBuilder builder, Params params) throws IOException {     builder.field(DCG_FIELD.getPreferredName(), this.dcg).     if (this.idcg != 0) {         builder.field(IDCG_FIELD.getPreferredName(), this.idcg).         builder.field(NDCG_FIELD.getPreferredName(), this.dcg / this.idcg).     }     builder.field(UNRATED_FIELD.getPreferredName(), this.unratedDocs).     return builder. }
false;public,static;1;3;;public static Detail fromXContent(XContentParser parser) {     return PARSER.apply(parser, null). }
false;public;1;6;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeDouble(this.dcg).     out.writeDouble(this.idcg).     out.writeVInt(this.unratedDocs). }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
true;public;0;3;/**  * @return the discounted cumulative gain  */ ;/**  * @return the discounted cumulative gain  */ public double getDCG() {     return this.dcg. }
true;public;0;3;/**  * @return the ideal discounted cumulative gain, can be 0 if nothing was computed, e.g. because no normalization was required  */ ;/**  * @return the ideal discounted cumulative gain, can be 0 if nothing was computed, e.g. because no normalization was required  */ public double getIDCG() {     return this.idcg. }
true;public;0;3;/**  * @return the normalized discounted cumulative gain, can be 0 if nothing was computed, e.g. because no normalization was required  */ ;/**  * @return the normalized discounted cumulative gain, can be 0 if nothing was computed, e.g. because no normalization was required  */ public double getNDCG() {     return (this.idcg != 0) ? this.dcg / this.idcg : 0. }
true;public;0;3;/**  * @return the number of unrated documents in the search results  */ ;/**  * @return the number of unrated documents in the search results  */ public Object getUnratedDocs() {     return this.unratedDocs. }
false;public;1;13;;@Override public boolean equals(Object obj) {     if (this == obj) {         return true.     }     if (obj == null || getClass() != obj.getClass()) {         return false.     }     DiscountedCumulativeGain.Detail other = (DiscountedCumulativeGain.Detail) obj.     return Double.compare(this.dcg, other.dcg) == 0 && Double.compare(this.idcg, other.idcg) == 0 && this.unratedDocs == other.unratedDocs. }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(this.dcg, this.idcg, this.unratedDocs). }
