commented;modifiers;parameterAmount;loc;comment;code
true;;3;1;/**  * Evaluates a single ranking evaluation case.  *  * @param taskId  *            an identifier of the query for which the search ranking is  *            evaluated  * @param hits  *            the search result hits  * @param ratedDocs  *            the documents that contain the document rating for this query case  * @return an {@link EvalQueryQuality} instance that contains the metric score  *         with respect to the provided search hits and ratings  */ ;/**  * Evaluates a single ranking evaluation case.  *  * @param taskId  *            an identifier of the query for which the search ranking is  *            evaluated  * @param hits  *            the search result hits  * @param ratedDocs  *            the documents that contain the document rating for this query case  * @return an {@link EvalQueryQuality} instance that contains the metric score  *         with respect to the provided search hits and ratings  */ EvalQueryQuality evaluate(String taskId, SearchHit[] hits, List<RatedDocument> ratedDocs).
true;static;2;15;/**  * Joins hits with rated documents using the joint _index/_id document key.  */ ;/**  * Joins hits with rated documents using the joint _index/_id document key.  */ static List<RatedSearchHit> joinHitsWithRatings(SearchHit[] hits, List<RatedDocument> ratedDocs) {     Map<DocumentKey, RatedDocument> ratedDocumentMap = ratedDocs.stream().collect(Collectors.toMap(RatedDocument::getKey, item -> item)).     List<RatedSearchHit> ratedSearchHits = new ArrayList<>(hits.length).     for (SearchHit hit : hits) {         DocumentKey key = new DocumentKey(hit.getIndex(), hit.getId()).         RatedDocument ratedDoc = ratedDocumentMap.get(key).         if (ratedDoc != null) {             ratedSearchHits.add(new RatedSearchHit(hit, OptionalInt.of(ratedDoc.getRating()))).         } else {             ratedSearchHits.add(new RatedSearchHit(hit, OptionalInt.empty())).         }     }     return ratedSearchHits. }
true;static;1;4;/**  * Filter {@link RatedSearchHit}s that do not have a rating.  */ ;/**  * Filter {@link RatedSearchHit}s that do not have a rating.  */ static List<DocumentKey> filterUnratedDocuments(List<RatedSearchHit> ratedHits) {     return ratedHits.stream().filter(hit -> hit.getRating().isPresent() == false).map(hit -> new DocumentKey(hit.getSearchHit().getIndex(), hit.getSearchHit().getId())).collect(Collectors.toList()). }
true;default;1;3;/**  * Combine several {@link EvalQueryQuality} results into the overall evaluation score.  * This defaults to averaging over the partial results, but can be overwritten to obtain a different behavior.  */ ;/**  * Combine several {@link EvalQueryQuality} results into the overall evaluation score.  * This defaults to averaging over the partial results, but can be overwritten to obtain a different behavior.  */ default double combine(Collection<EvalQueryQuality> partialResults) {     return partialResults.stream().mapToDouble(EvalQueryQuality::metricScore).sum() / partialResults.size(). }
true;default;0;3;/**  * Metrics can define a size of the search hits windows they want to retrieve by overwriting  * this method. The default implementation returns an empty optional.  * @return the number of search hits this metrics requests  */ ;/**  * Metrics can define a size of the search hits windows they want to retrieve by overwriting  * this method. The default implementation returns an empty optional.  * @return the number of search hits this metrics requests  */ default OptionalInt forcedSearchSize() {     return OptionalInt.empty(). }
