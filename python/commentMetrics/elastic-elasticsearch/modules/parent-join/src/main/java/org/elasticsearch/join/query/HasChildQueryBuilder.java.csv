commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;10;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     out.writeString(type).     out.writeInt(minChildren).     out.writeInt(maxChildren).     out.writeVInt(scoreMode.ordinal()).     out.writeNamedWriteable(query).     out.writeOptionalWriteable(innerHitBuilder).     out.writeBoolean(ignoreUnmapped). }
true;public;2;14;/**  * Defines the minimum number of children that are required to match for the parent to be considered a match and  * the maximum number of children that are required to match for the parent to be considered a match.  */ ;/**  * Defines the minimum number of children that are required to match for the parent to be considered a match and  * the maximum number of children that are required to match for the parent to be considered a match.  */ public HasChildQueryBuilder minMaxChildren(int minChildren, int maxChildren) {     if (minChildren < 0) {         throw new IllegalArgumentException("[" + NAME + "] requires non-negative 'min_children' field").     }     if (maxChildren < 0) {         throw new IllegalArgumentException("[" + NAME + "] requires non-negative 'max_children' field").     }     if (maxChildren < minChildren) {         throw new IllegalArgumentException("[" + NAME + "] 'max_children' is less than 'min_children'").     }     this.minChildren = minChildren.     this.maxChildren = maxChildren.     return this. }
true;public;0;3;/**  * Returns inner hit definition in the scope of this query and reusing the defined type and query.  */ ;/**  * Returns inner hit definition in the scope of this query and reusing the defined type and query.  */ public InnerHitBuilder innerHit() {     return innerHitBuilder. }
false;public;1;5;;public HasChildQueryBuilder innerHit(InnerHitBuilder innerHit) {     this.innerHitBuilder = innerHit.     innerHitBuilder.setIgnoreUnmapped(ignoreUnmapped).     return this. }
true;public;0;3;/**  * Returns the children query to execute.  */ ;/**  * Returns the children query to execute.  */ public QueryBuilder query() {     return query. }
true;public;0;3;/**  * Returns the child type  */ ;/**  * Returns the child type  */ public String childType() {     return type. }
true;public;0;3;/**  * Returns how the scores from the matching child documents are mapped into the parent document.  */ ;/**  * Returns how the scores from the matching child documents are mapped into the parent document.  */ public ScoreMode scoreMode() {     return scoreMode. }
true;public;0;3;/**  * Returns the minimum number of children that are required to match for the parent to be considered a match.  * The default is {@value #DEFAULT_MIN_CHILDREN}  */ ;/**  * Returns the minimum number of children that are required to match for the parent to be considered a match.  * The default is {@value #DEFAULT_MIN_CHILDREN}  */ public int minChildren() {     return minChildren. }
true;public;0;1;/**  * Returns the maximum number of children that are required to match for the parent to be considered a match.  * The default is {@value #DEFAULT_MAX_CHILDREN}  */ ;/**  * Returns the maximum number of children that are required to match for the parent to be considered a match.  * The default is {@value #DEFAULT_MAX_CHILDREN}  */ public int maxChildren() {     return maxChildren. }
true;public;1;7;/**  * Sets whether the query builder should ignore unmapped types (and run a  * {@link MatchNoDocsQuery} in place of this query) or throw an exception if  * the type is unmapped.  */ ;/**  * Sets whether the query builder should ignore unmapped types (and run a  * {@link MatchNoDocsQuery} in place of this query) or throw an exception if  * the type is unmapped.  */ public HasChildQueryBuilder ignoreUnmapped(boolean ignoreUnmapped) {     this.ignoreUnmapped = ignoreUnmapped.     if (innerHitBuilder != null) {         innerHitBuilder.setIgnoreUnmapped(ignoreUnmapped).     }     return this. }
true;public;0;3;/**  * Gets whether the query builder will ignore unmapped types (and run a  * {@link MatchNoDocsQuery} in place of this query) or throw an exception if  * the type is unmapped.  */ ;/**  * Gets whether the query builder will ignore unmapped types (and run a  * {@link MatchNoDocsQuery} in place of this query) or throw an exception if  * the type is unmapped.  */ public boolean ignoreUnmapped() {     return ignoreUnmapped. }
false;protected;2;16;;@Override protected void doXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject(NAME).     builder.field(QUERY_FIELD.getPreferredName()).     query.toXContent(builder, params).     builder.field(TYPE_FIELD.getPreferredName(), type).     builder.field(SCORE_MODE_FIELD.getPreferredName(), NestedQueryBuilder.scoreModeAsString(scoreMode)).     builder.field(MIN_CHILDREN_FIELD.getPreferredName(), minChildren).     builder.field(MAX_CHILDREN_FIELD.getPreferredName(), maxChildren).     builder.field(IGNORE_UNMAPPED_FIELD.getPreferredName(), ignoreUnmapped).     printBoostAndQueryName(builder).     if (innerHitBuilder != null) {         builder.field(INNER_HITS_FIELD.getPreferredName(), innerHitBuilder, params).     }     builder.endObject(). }
false;public,static;1;53;;public static HasChildQueryBuilder fromXContent(XContentParser parser) throws IOException {     float boost = AbstractQueryBuilder.DEFAULT_BOOST.     String childType = null.     ScoreMode scoreMode = ScoreMode.None.     int minChildren = HasChildQueryBuilder.DEFAULT_MIN_CHILDREN.     int maxChildren = HasChildQueryBuilder.DEFAULT_MAX_CHILDREN.     boolean ignoreUnmapped = DEFAULT_IGNORE_UNMAPPED.     String queryName = null.     InnerHitBuilder innerHitBuilder = null.     String currentFieldName = null.     XContentParser.Token token.     QueryBuilder iqb = null.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token == XContentParser.Token.START_OBJECT) {             if (QUERY_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 iqb = parseInnerQueryBuilder(parser).             } else if (INNER_HITS_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 innerHitBuilder = InnerHitBuilder.fromXContent(parser).             } else {                 throw new ParsingException(parser.getTokenLocation(), "[has_child] query does not support [" + currentFieldName + "]").             }         } else if (token.isValue()) {             if (TYPE_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 childType = parser.text().             } else if (SCORE_MODE_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 scoreMode = NestedQueryBuilder.parseScoreMode(parser.text()).             } else if (AbstractQueryBuilder.BOOST_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 boost = parser.floatValue().             } else if (MIN_CHILDREN_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 minChildren = parser.intValue(true).             } else if (MAX_CHILDREN_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 maxChildren = parser.intValue(true).             } else if (IGNORE_UNMAPPED_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 ignoreUnmapped = parser.booleanValue().             } else if (AbstractQueryBuilder.NAME_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 queryName = parser.text().             } else {                 throw new ParsingException(parser.getTokenLocation(), "[has_child] query does not support [" + currentFieldName + "]").             }         }     }     HasChildQueryBuilder hasChildQueryBuilder = new HasChildQueryBuilder(childType, iqb, scoreMode).     hasChildQueryBuilder.minMaxChildren(minChildren, maxChildren).     hasChildQueryBuilder.queryName(queryName).     hasChildQueryBuilder.boost(boost).     hasChildQueryBuilder.ignoreUnmapped(ignoreUnmapped).     if (innerHitBuilder != null) {         hasChildQueryBuilder.innerHit(innerHitBuilder).     }     return hasChildQueryBuilder. }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
false;protected;1;29;;@Override protected Query doToQuery(QueryShardContext context) throws IOException {     ParentJoinFieldMapper joinFieldMapper = ParentJoinFieldMapper.getMapper(context.getMapperService()).     if (joinFieldMapper == null) {         if (ignoreUnmapped) {             return new MatchNoDocsQuery().         } else {             throw new QueryShardException(context, "[" + NAME + "] no join field has been configured").         }     }     ParentIdFieldMapper parentIdFieldMapper = joinFieldMapper.getParentIdFieldMapper(type, false).     if (parentIdFieldMapper != null) {         Query parentFilter = parentIdFieldMapper.getParentFilter().         Query childFilter = parentIdFieldMapper.getChildFilter(type).         Query innerQuery = Queries.filtered(query.toQuery(context), childFilter).         MappedFieldType fieldType = parentIdFieldMapper.fieldType().         final SortedSetDVOrdinalsIndexFieldData fieldData = context.getForField(fieldType).         return new LateParsingQuery(parentFilter, innerQuery, minChildren(), maxChildren(), fieldType.name(), scoreMode, fieldData, context.getSearchSimilarity()).     } else {         if (ignoreUnmapped) {             return new MatchNoDocsQuery().         } else {             throw new QueryShardException(context, "[" + NAME + "] join field [" + joinFieldMapper.name() + "] doesn't hold [" + type + "] as a child").         }     } }
false;public;1;26;;@Override public Query rewrite(IndexReader reader) throws IOException {     Query rewritten = super.rewrite(reader).     if (rewritten != this) {         return rewritten.     }     if (reader instanceof DirectoryReader) {         IndexSearcher indexSearcher = new IndexSearcher(reader).         indexSearcher.setQueryCache(null).         indexSearcher.setSimilarity(similarity).         IndexOrdinalsFieldData indexParentChildFieldData = fieldDataJoin.loadGlobal((DirectoryReader) reader).         OrdinalMap ordinalMap = indexParentChildFieldData.getOrdinalMap().         return JoinUtil.createJoinQuery(joinField, innerQuery, toQuery, indexSearcher, scoreMode, ordinalMap, minChildren, maxChildren).     } else {         if (reader.leaves().isEmpty() && reader.numDocs() == 0) {             // and rewrite to match nothing             return new MatchNoDocsQuery().         }         throw new IllegalStateException("can't load global ordinals for reader of type: " + reader.getClass() + " must be a DirectoryReader").     } }
false;public;1;13;;@Override public boolean equals(Object o) {     if (sameClassAs(o) == false)         return false.     LateParsingQuery that = (LateParsingQuery) o.     if (minChildren != that.minChildren)         return false.     if (maxChildren != that.maxChildren)         return false.     if (!toQuery.equals(that.toQuery))         return false.     if (!innerQuery.equals(that.innerQuery))         return false.     if (!joinField.equals(that.joinField))         return false.     return scoreMode == that.scoreMode. }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(getClass(), toQuery, innerQuery, minChildren, maxChildren, joinField, scoreMode). }
false;public;1;4;;@Override public String toString(String s) {     return "LateParsingQuery {joinField=" + joinField + "}". }
false;public;0;3;;public int getMinChildren() {     return minChildren. }
false;public;0;3;;public int getMaxChildren() {     return maxChildren. }
false;public;0;3;;public ScoreMode getScoreMode() {     return scoreMode. }
false;public;0;3;;public Query getInnerQuery() {     return innerQuery. }
false;public;0;3;;public Similarity getSimilarity() {     return similarity. }
false;protected;1;10;;@Override protected boolean doEquals(HasChildQueryBuilder that) {     return Objects.equals(query, that.query) && Objects.equals(type, that.type) && Objects.equals(scoreMode, that.scoreMode) && Objects.equals(minChildren, that.minChildren) && Objects.equals(maxChildren, that.maxChildren) && Objects.equals(innerHitBuilder, that.innerHitBuilder) && Objects.equals(ignoreUnmapped, that.ignoreUnmapped). }
false;protected;0;4;;@Override protected int doHashCode() {     return Objects.hash(query, type, scoreMode, minChildren, maxChildren, innerHitBuilder, ignoreUnmapped). }
false;protected;1;11;;@Override protected QueryBuilder doRewrite(QueryRewriteContext queryShardContext) throws IOException {     QueryBuilder rewrittenQuery = query.rewrite(queryShardContext).     if (rewrittenQuery != query) {         HasChildQueryBuilder hasChildQueryBuilder = new HasChildQueryBuilder(type, rewrittenQuery, minChildren, maxChildren, scoreMode, innerHitBuilder).         hasChildQueryBuilder.ignoreUnmapped(ignoreUnmapped).         return hasChildQueryBuilder.     }     return this. }
false;protected;1;15;;@Override protected void extractInnerHitBuilders(Map<String, InnerHitContextBuilder> innerHits) {     if (innerHitBuilder != null) {         String name = innerHitBuilder.getName() != null ? innerHitBuilder.getName() : type.         if (innerHits.containsKey(name)) {             throw new IllegalArgumentException("[inner_hits] already contains an entry for key [" + name + "]").         }         Map<String, InnerHitContextBuilder> children = new HashMap<>().         InnerHitContextBuilder.extractInnerHits(query, children).         InnerHitContextBuilder innerHitContextBuilder = new ParentChildInnerHitContextBuilder(type, true, query, innerHitBuilder, children).         innerHits.put(name, innerHitContextBuilder).     } }
