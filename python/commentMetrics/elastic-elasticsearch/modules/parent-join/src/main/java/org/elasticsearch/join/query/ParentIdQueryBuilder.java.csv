commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;6;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     out.writeString(type).     out.writeString(id).     out.writeBoolean(ignoreUnmapped). }
false;public;0;3;;public String getType() {     return type. }
false;public;0;3;;public String getId() {     return id. }
true;public;1;4;/**  * Sets whether the query builder should ignore unmapped types (and run a  * {@link MatchNoDocsQuery} in place of this query) or throw an exception if  * the type is unmapped.  */ ;/**  * Sets whether the query builder should ignore unmapped types (and run a  * {@link MatchNoDocsQuery} in place of this query) or throw an exception if  * the type is unmapped.  */ public ParentIdQueryBuilder ignoreUnmapped(boolean ignoreUnmapped) {     this.ignoreUnmapped = ignoreUnmapped.     return this. }
true;public;0;3;/**  * Gets whether the query builder will ignore unmapped types (and run a  * {@link MatchNoDocsQuery} in place of this query) or throw an exception if  * the type is unmapped.  */ ;/**  * Gets whether the query builder will ignore unmapped types (and run a  * {@link MatchNoDocsQuery} in place of this query) or throw an exception if  * the type is unmapped.  */ public boolean ignoreUnmapped() {     return ignoreUnmapped. }
false;protected;2;9;;@Override protected void doXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject(NAME).     builder.field(TYPE_FIELD.getPreferredName(), type).     builder.field(ID_FIELD.getPreferredName(), id).     builder.field(IGNORE_UNMAPPED_FIELD.getPreferredName(), ignoreUnmapped).     printBoostAndQueryName(builder).     builder.endObject(). }
false;public,static;1;35;;public static ParentIdQueryBuilder fromXContent(XContentParser parser) throws IOException {     float boost = AbstractQueryBuilder.DEFAULT_BOOST.     String type = null.     String id = null.     String queryName = null.     String currentFieldName = null.     boolean ignoreUnmapped = DEFAULT_IGNORE_UNMAPPED.     XContentParser.Token token.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token.isValue()) {             if (TYPE_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 type = parser.text().             } else if (ID_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 id = parser.text().             } else if (IGNORE_UNMAPPED_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 ignoreUnmapped = parser.booleanValue().             } else if (AbstractQueryBuilder.BOOST_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 boost = parser.floatValue().             } else if (AbstractQueryBuilder.NAME_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 queryName = parser.text().             } else {                 throw new ParsingException(parser.getTokenLocation(), "[parent_id] query does not support [" + currentFieldName + "]").             }         } else {             throw new ParsingException(parser.getTokenLocation(), "[parent_id] query does not support [" + currentFieldName + "]").         }     }     ParentIdQueryBuilder queryBuilder = new ParentIdQueryBuilder(type, id).     queryBuilder.queryName(queryName).     queryBuilder.boost(boost).     queryBuilder.ignoreUnmapped(ignoreUnmapped).     return queryBuilder. }
false;protected;1;25;;@Override protected Query doToQuery(QueryShardContext context) throws IOException {     ParentJoinFieldMapper joinFieldMapper = ParentJoinFieldMapper.getMapper(context.getMapperService()).     if (joinFieldMapper == null) {         if (ignoreUnmapped) {             return new MatchNoDocsQuery().         } else {             final String indexName = context.getIndexSettings().getIndex().getName().             throw new QueryShardException(context, "[" + NAME + "] no join field found for index [" + indexName + "]").         }     }     final ParentIdFieldMapper childMapper = joinFieldMapper.getParentIdFieldMapper(type, false).     if (childMapper == null) {         if (ignoreUnmapped) {             return new MatchNoDocsQuery().         } else {             throw new QueryShardException(context, "[" + NAME + "] no relation found for child [" + type + "]").         }     }     return new BooleanQuery.Builder().add(childMapper.fieldType().termQuery(id, context), BooleanClause.Occur.MUST).add(joinFieldMapper.fieldType().termQuery(type, context), BooleanClause.Occur.FILTER).build(). }
false;protected;1;6;;@Override protected boolean doEquals(ParentIdQueryBuilder that) {     return Objects.equals(type, that.type) && Objects.equals(id, that.id) && Objects.equals(ignoreUnmapped, that.ignoreUnmapped). }
false;protected;0;4;;@Override protected int doHashCode() {     return Objects.hash(type, id, ignoreUnmapped). }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
