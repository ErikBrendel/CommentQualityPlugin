commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;5;/**  * Returns the {@link ParentJoinFieldMapper} associated with the <code>service</code> or null  * if there is no parent-join field in this mapping.  */ ;/**  * Returns the {@link ParentJoinFieldMapper} associated with the <code>service</code> or null  * if there is no parent-join field in this mapping.  */ public static ParentJoinFieldMapper getMapper(MapperService service) {     MetaJoinFieldMapper.MetaJoinFieldType fieldType = (MetaJoinFieldMapper.MetaJoinFieldType) service.fullName(MetaJoinFieldMapper.NAME).     return fieldType == null ? null : fieldType.getMapper(). }
false;private,static;2;3;;private static String getParentIdFieldName(String joinFieldName, String parentName) {     return joinFieldName + "#" + parentName. }
false;private,static;2;6;;private static void checkIndexCompatibility(IndexSettings settings, String name) {     if (settings.getIndexMetaData().isRoutingPartitionedIndex()) {         throw new IllegalStateException("cannot create join field [" + name + "] " + "for the partitioned index " + "[" + settings.getIndex().getName() + "]").     } }
false;private,static;2;6;;private static void checkObjectOrNested(ContentPath path, String name) {     if (path.pathAsText(name).contains(".")) {         throw new IllegalArgumentException("join field [" + path.pathAsText(name) + "] " + "cannot be added inside an object or in a multi-field").     } }
false;private,static;2;14;;private static void checkParentFields(String name, List<ParentIdFieldMapper> mappers) {     Set<String> children = new HashSet<>().     List<String> conflicts = new ArrayList<>().     for (ParentIdFieldMapper mapper : mappers) {         for (String child : mapper.getChildren()) {             if (children.add(child) == false) {                 conflicts.add("[" + child + "] cannot have multiple parents").             }         }     }     if (conflicts.isEmpty() == false) {         throw new IllegalArgumentException("invalid definition for join field [" + name + "]:\n" + conflicts.toString()).     } }
false;public;0;4;;@Override public JoinFieldType fieldType() {     return (JoinFieldType) super.fieldType(). }
false;public;2;5;;public Builder addParent(String parent, Set<String> children) {     String parentIdFieldName = getParentIdFieldName(name, parent).     parentIdFieldBuilders.add(new ParentIdFieldMapper.Builder(parentIdFieldName, parent, children)).     return builder. }
false;public;1;4;;public Builder eagerGlobalOrdinals(boolean eagerGlobalOrdinals) {     this.eagerGlobalOrdinals = eagerGlobalOrdinals.     return builder. }
false;public;1;18;;@Override public ParentJoinFieldMapper build(BuilderContext context) {     checkObjectOrNested(context.path(), name).     fieldType.setName(name).     final List<ParentIdFieldMapper> parentIdFields = new ArrayList<>().     parentIdFieldBuilders.stream().map((parentBuilder) -> {         if (eagerGlobalOrdinals) {             parentBuilder.eagerGlobalOrdinals(true).         }         return parentBuilder.build(context).     }).forEach(parentIdFields::add).     checkParentFields(name(), parentIdFields).     MetaJoinFieldMapper unique = new MetaJoinFieldMapper.Builder().build(context).     return new ParentJoinFieldMapper(name, fieldType, context.indexSettings(), unique, Collections.unmodifiableList(parentIdFields), eagerGlobalOrdinals). }
false;public;3;34;;@Override public Mapper.Builder<?, ?> parse(String name, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {     final IndexSettings indexSettings = parserContext.mapperService().getIndexSettings().     checkIndexCompatibility(indexSettings, name).     Builder builder = new Builder(name).     for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(). iterator.hasNext(). ) {         Map.Entry<String, Object> entry = iterator.next().         if ("type".equals(entry.getKey())) {             continue.         }         if ("eager_global_ordinals".equals(entry.getKey())) {             builder.eagerGlobalOrdinals(XContentMapValues.nodeBooleanValue(entry.getValue(), "eager_global_ordinals")).             iterator.remove().             continue.         }         if ("relations".equals(entry.getKey())) {             Map<String, Object> relations = XContentMapValues.nodeMapValue(entry.getValue(), "relations").             for (Iterator<Map.Entry<String, Object>> relIt = relations.entrySet().iterator(). relIt.hasNext(). ) {                 Map.Entry<String, Object> relation = relIt.next().                 final String parent = relation.getKey().                 Set<String> children.                 if (XContentMapValues.isArray(relation.getValue())) {                     children = new HashSet<>(Arrays.asList(XContentMapValues.nodeStringArrayValue(relation.getValue()))).                 } else {                     children = Collections.singleton(relation.getValue().toString()).                 }                 builder.addParent(parent, children).             }             iterator.remove().         }     }     return builder. }
false;public;0;3;;public JoinFieldType clone() {     return new JoinFieldType(this). }
false;public;0;4;;@Override public String typeName() {     return CONTENT_TYPE. }
false;public;1;5;;@Override public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {     failIfNoDocValues().     return new DocValuesIndexFieldData.Builder(). }
false;public;1;8;;@Override public Object valueForDisplay(Object value) {     if (value == null) {         return null.     }     BytesRef binaryValue = (BytesRef) value.     return binaryValue.utf8ToString(). }
false;public;1;4;;@Override public Query existsQuery(QueryShardContext context) {     return new DocValuesFieldExistsQuery(name()). }
false;protected;0;4;;@Override protected String contentType() {     return CONTENT_TYPE. }
false;protected;0;4;;@Override protected ParentJoinFieldMapper clone() {     return (ParentJoinFieldMapper) super.clone(). }
false;public;0;4;;@Override public JoinFieldType fieldType() {     return (JoinFieldType) super.fieldType(). }
false;public;0;6;;@Override public Iterator<Mapper> iterator() {     List<Mapper> mappers = new ArrayList<>(parentIdFields).     mappers.add(uniqueFieldMapper).     return mappers.iterator(). }
true;public;1;3;/**  * Returns true if <code>name</code> is a parent name in the field.  */ ;/**  * Returns true if <code>name</code> is a parent name in the field.  */ public boolean hasParent(String name) {     return parentIdFields.stream().anyMatch((mapper) -> name.equals(mapper.getParentName())). }
true;public;1;3;/**  * Returns true if <code>name</code> is a child name in the field.  */ ;/**  * Returns true if <code>name</code> is a child name in the field.  */ public boolean hasChild(String name) {     return parentIdFields.stream().anyMatch((mapper) -> mapper.getChildren().contains(name)). }
true;public;2;10;/**  * Returns the parent Id field mapper associated with a parent <code>name</code>  * if <code>isParent</code> is true and a child <code>name</code> otherwise.  */ ;/**  * Returns the parent Id field mapper associated with a parent <code>name</code>  * if <code>isParent</code> is true and a child <code>name</code> otherwise.  */ public ParentIdFieldMapper getParentIdFieldMapper(String name, boolean isParent) {     for (ParentIdFieldMapper mapper : parentIdFields) {         if (isParent && name.equals(mapper.getParentName())) {             return mapper.         } else if (isParent == false && mapper.getChildren().contains(name)) {             return mapper.         }     }     return null. }
false;protected;1;44;;@Override protected void doMerge(Mapper mergeWith) {     super.doMerge(mergeWith).     ParentJoinFieldMapper joinMergeWith = (ParentJoinFieldMapper) mergeWith.     List<String> conflicts = new ArrayList<>().     for (ParentIdFieldMapper mapper : parentIdFields) {         if (joinMergeWith.getParentIdFieldMapper(mapper.getParentName(), true) == null) {             conflicts.add("cannot remove parent [" + mapper.getParentName() + "] in join field [" + name() + "]").         }     }     final List<ParentIdFieldMapper> newParentIdFields = new ArrayList<>().     for (ParentIdFieldMapper mergeWithMapper : joinMergeWith.parentIdFields) {         ParentIdFieldMapper self = getParentIdFieldMapper(mergeWithMapper.getParentName(), true).         if (self == null) {             if (getParentIdFieldMapper(mergeWithMapper.getParentName(), false) != null) {                 // it is forbidden to add a parent to an existing child                 conflicts.add("cannot create parent [" + mergeWithMapper.getParentName() + "] from an existing child").             }             for (String child : mergeWithMapper.getChildren()) {                 if (getParentIdFieldMapper(child, true) != null) {                     // it is forbidden to add a parent to an existing child                     conflicts.add("cannot create child [" + child + "] from an existing parent").                 }             }             newParentIdFields.add(mergeWithMapper).         } else {             for (String child : self.getChildren()) {                 if (mergeWithMapper.getChildren().contains(child) == false) {                     conflicts.add("cannot remove child [" + child + "] in join field [" + name() + "]").                 }             }             ParentIdFieldMapper merged = (ParentIdFieldMapper) self.merge(mergeWithMapper).             newParentIdFields.add(merged).         }     }     if (conflicts.isEmpty() == false) {         throw new IllegalStateException("invalid update for join field [" + name() + "]:\n" + conflicts.toString()).     }     this.eagerGlobalOrdinals = joinMergeWith.eagerGlobalOrdinals.     this.parentIdFields = Collections.unmodifiableList(newParentIdFields).     this.uniqueFieldMapper = (MetaJoinFieldMapper) uniqueFieldMapper.merge(joinMergeWith.uniqueFieldMapper).     uniqueFieldMapper.setFieldMapper(this). }
false;public;1;12;;@Override public FieldMapper updateFieldType(Map<String, MappedFieldType> fullNameToFieldType) {     ParentJoinFieldMapper fieldMapper = (ParentJoinFieldMapper) super.updateFieldType(fullNameToFieldType).     final List<ParentIdFieldMapper> newMappers = new ArrayList<>().     for (ParentIdFieldMapper mapper : fieldMapper.parentIdFields) {         newMappers.add((ParentIdFieldMapper) mapper.updateFieldType(fullNameToFieldType)).     }     fieldMapper.parentIdFields = Collections.unmodifiableList(newMappers).     this.uniqueFieldMapper = (MetaJoinFieldMapper) uniqueFieldMapper.updateFieldType(fullNameToFieldType).     uniqueFieldMapper.setFieldMapper(this).     return fieldMapper. }
false;protected;2;4;;@Override protected void parseCreateField(ParseContext context, List<IndexableField> fields) throws IOException {     throw new UnsupportedOperationException("parsing is implemented in parse(), this method should NEVER be called"). }
false;public;1;64;;@Override public void parse(ParseContext context) throws IOException {     context.path().add(simpleName()).     XContentParser.Token token = context.parser().currentToken().     String name = null.     String parent = null.     if (token == XContentParser.Token.START_OBJECT) {         String currentFieldName = null.         while ((token = context.parser().nextToken()) != XContentParser.Token.END_OBJECT) {             if (token == XContentParser.Token.FIELD_NAME) {                 currentFieldName = context.parser().currentName().             } else if (token == XContentParser.Token.VALUE_STRING) {                 if ("name".equals(currentFieldName)) {                     name = context.parser().text().                 } else if ("parent".equals(currentFieldName)) {                     parent = context.parser().text().                 } else {                     throw new IllegalArgumentException("unknown field name [" + currentFieldName + "] in join field [" + name() + "]").                 }             } else if (token == XContentParser.Token.VALUE_NUMBER) {                 if ("parent".equals(currentFieldName)) {                     parent = context.parser().numberValue().toString().                 } else {                     throw new IllegalArgumentException("unknown field name [" + currentFieldName + "] in join field [" + name() + "]").                 }             }         }     } else if (token == XContentParser.Token.VALUE_STRING) {         name = context.parser().text().         parent = null.     } else {         throw new IllegalStateException("[" + name + "] expected START_OBJECT or VALUE_STRING but was: " + token).     }     ParentIdFieldMapper parentIdField = getParentIdFieldMapper(name, true).     ParentIdFieldMapper childParentIdField = getParentIdFieldMapper(name, false).     if (parentIdField == null && childParentIdField == null) {         throw new IllegalArgumentException("unknown join name [" + name + "] for field [" + name() + "]").     }     if (childParentIdField != null) {         // Index the document as a child         if (parent == null) {             throw new IllegalArgumentException("[parent] is missing for join field [" + name() + "]").         }         if (context.sourceToParse().routing() == null) {             throw new IllegalArgumentException("[routing] is missing for join field [" + name() + "]").         }         assert childParentIdField.getChildren().contains(name).         ParseContext externalContext = context.createExternalValueContext(parent).         childParentIdField.parse(externalContext).     }     if (parentIdField != null) {         // Index the document as a parent         assert parentIdField.getParentName().equals(name).         ParseContext externalContext = context.createExternalValueContext(context.sourceToParse().id()).         parentIdField.parse(externalContext).     }     BytesRef binaryValue = new BytesRef(name).     Field field = new Field(fieldType().name(), binaryValue, fieldType()).     context.doc().add(field).     context.doc().add(new SortedDocValuesField(fieldType().name(), binaryValue)).     context.path().remove(). }
false;protected;3;14;;@Override protected void doXContentBody(XContentBuilder builder, boolean includeDefaults, Params params) throws IOException {     builder.field("type", contentType()).     builder.field("eager_global_ordinals", eagerGlobalOrdinals).     builder.startObject("relations").     for (ParentIdFieldMapper field : parentIdFields) {         if (field.getChildren().size() == 1) {             builder.field(field.getParentName(), field.getChildren().iterator().next()).         } else {             builder.field(field.getParentName(), field.getChildren()).         }     }     builder.endObject(). }
