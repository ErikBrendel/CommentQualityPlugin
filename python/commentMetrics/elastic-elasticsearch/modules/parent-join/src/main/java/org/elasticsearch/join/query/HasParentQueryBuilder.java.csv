commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;8;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     out.writeString(type).     out.writeBoolean(score).     out.writeNamedWriteable(query).     out.writeOptionalWriteable(innerHitBuilder).     out.writeBoolean(ignoreUnmapped). }
true;public;0;3;/**  * Returns the query to execute.  */ ;/**  * Returns the query to execute.  */ public QueryBuilder query() {     return query. }
true;public;0;3;/**  * Returns <code>true</code> if the parent score is mapped into the child documents  */ ;/**  * Returns <code>true</code> if the parent score is mapped into the child documents  */ public boolean score() {     return score. }
true;public;0;3;/**  * Returns the parents type name  */ ;/**  * Returns the parents type name  */ public String type() {     return type. }
true;public;0;3;/**  *  Returns inner hit definition in the scope of this query and reusing the defined type and query.  */ ;/**  *  Returns inner hit definition in the scope of this query and reusing the defined type and query.  */ public InnerHitBuilder innerHit() {     return innerHitBuilder. }
false;public;1;5;;public HasParentQueryBuilder innerHit(InnerHitBuilder innerHit) {     this.innerHitBuilder = innerHit.     innerHitBuilder.setIgnoreUnmapped(ignoreUnmapped).     return this. }
true;public;1;7;/**  * Sets whether the query builder should ignore unmapped types (and run a  * {@link MatchNoDocsQuery} in place of this query) or throw an exception if  * the type is unmapped.  */ ;/**  * Sets whether the query builder should ignore unmapped types (and run a  * {@link MatchNoDocsQuery} in place of this query) or throw an exception if  * the type is unmapped.  */ public HasParentQueryBuilder ignoreUnmapped(boolean ignoreUnmapped) {     this.ignoreUnmapped = ignoreUnmapped.     if (innerHitBuilder != null) {         innerHitBuilder.setIgnoreUnmapped(ignoreUnmapped).     }     return this. }
true;public;0;3;/**  * Gets whether the query builder will ignore unmapped types (and run a  * {@link MatchNoDocsQuery} in place of this query) or throw an exception if  * the type is unmapped.  */ ;/**  * Gets whether the query builder will ignore unmapped types (and run a  * {@link MatchNoDocsQuery} in place of this query) or throw an exception if  * the type is unmapped.  */ public boolean ignoreUnmapped() {     return ignoreUnmapped. }
false;protected;1;30;;@Override protected Query doToQuery(QueryShardContext context) throws IOException {     ParentJoinFieldMapper joinFieldMapper = ParentJoinFieldMapper.getMapper(context.getMapperService()).     if (joinFieldMapper == null) {         if (ignoreUnmapped) {             return new MatchNoDocsQuery().         } else {             throw new QueryShardException(context, "[" + NAME + "] no join field has been configured").         }     }     ParentIdFieldMapper parentIdFieldMapper = joinFieldMapper.getParentIdFieldMapper(type, true).     if (parentIdFieldMapper != null) {         Query parentFilter = parentIdFieldMapper.getParentFilter().         Query innerQuery = Queries.filtered(query.toQuery(context), parentFilter).         Query childFilter = parentIdFieldMapper.getChildrenFilter().         MappedFieldType fieldType = parentIdFieldMapper.fieldType().         final SortedSetDVOrdinalsIndexFieldData fieldData = context.getForField(fieldType).         return new HasChildQueryBuilder.LateParsingQuery(childFilter, innerQuery, HasChildQueryBuilder.DEFAULT_MIN_CHILDREN, HasChildQueryBuilder.DEFAULT_MAX_CHILDREN, fieldType.name(), score ? ScoreMode.Max : ScoreMode.None, fieldData, context.getSearchSimilarity()).     } else {         if (ignoreUnmapped) {             return new MatchNoDocsQuery().         } else {             throw new QueryShardException(context, "[" + NAME + "] join field [" + joinFieldMapper.name() + "] doesn't hold [" + type + "] as a parent").         }     } }
false;protected;2;14;;@Override protected void doXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject(NAME).     builder.field(QUERY_FIELD.getPreferredName()).     query.toXContent(builder, params).     builder.field(PARENT_TYPE_FIELD.getPreferredName(), type).     builder.field(SCORE_FIELD.getPreferredName(), score).     builder.field(IGNORE_UNMAPPED_FIELD.getPreferredName(), ignoreUnmapped).     printBoostAndQueryName(builder).     if (innerHitBuilder != null) {         builder.field(INNER_HITS_FIELD.getPreferredName(), innerHitBuilder, params).     }     builder.endObject(). }
false;public,static;1;49;;public static HasParentQueryBuilder fromXContent(XContentParser parser) throws IOException {     float boost = AbstractQueryBuilder.DEFAULT_BOOST.     String parentType = null.     boolean score = false.     String queryName = null.     InnerHitBuilder innerHits = null.     boolean ignoreUnmapped = DEFAULT_IGNORE_UNMAPPED.     String currentFieldName = null.     XContentParser.Token token.     QueryBuilder iqb = null.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token == XContentParser.Token.START_OBJECT) {             if (QUERY_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 iqb = parseInnerQueryBuilder(parser).             } else if (INNER_HITS_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 innerHits = InnerHitBuilder.fromXContent(parser).             } else {                 throw new ParsingException(parser.getTokenLocation(), "[has_parent] query does not support [" + currentFieldName + "]").             }         } else if (token.isValue()) {             if (PARENT_TYPE_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 parentType = parser.text().             } else if (SCORE_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 score = parser.booleanValue().             } else if (IGNORE_UNMAPPED_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 ignoreUnmapped = parser.booleanValue().             } else if (AbstractQueryBuilder.BOOST_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 boost = parser.floatValue().             } else if (AbstractQueryBuilder.NAME_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 queryName = parser.text().             } else {                 throw new ParsingException(parser.getTokenLocation(), "[has_parent] query does not support [" + currentFieldName + "]").             }         }     }     HasParentQueryBuilder queryBuilder = new HasParentQueryBuilder(parentType, iqb, score).ignoreUnmapped(ignoreUnmapped).queryName(queryName).boost(boost).     if (innerHits != null) {         queryBuilder.innerHit(innerHits).     }     return queryBuilder. }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
false;protected;1;8;;@Override protected boolean doEquals(HasParentQueryBuilder that) {     return Objects.equals(query, that.query) && Objects.equals(type, that.type) && Objects.equals(score, that.score) && Objects.equals(innerHitBuilder, that.innerHitBuilder) && Objects.equals(ignoreUnmapped, that.ignoreUnmapped). }
false;protected;0;4;;@Override protected int doHashCode() {     return Objects.hash(query, type, score, innerHitBuilder, ignoreUnmapped). }
false;protected;1;10;;@Override protected QueryBuilder doRewrite(QueryRewriteContext queryShardContext) throws IOException {     QueryBuilder rewrittenQuery = query.rewrite(queryShardContext).     if (rewrittenQuery != query) {         HasParentQueryBuilder hasParentQueryBuilder = new HasParentQueryBuilder(type, rewrittenQuery, score, innerHitBuilder).         hasParentQueryBuilder.ignoreUnmapped(ignoreUnmapped).         return hasParentQueryBuilder.     }     return this. }
false;protected;1;15;;@Override protected void extractInnerHitBuilders(Map<String, InnerHitContextBuilder> innerHits) {     if (innerHitBuilder != null) {         String name = innerHitBuilder.getName() != null ? innerHitBuilder.getName() : type.         if (innerHits.containsKey(name)) {             throw new IllegalArgumentException("[inner_hits] already contains an entry for key [" + name + "]").         }         Map<String, InnerHitContextBuilder> children = new HashMap<>().         InnerHitContextBuilder.extractInnerHits(query, children).         InnerHitContextBuilder innerHitContextBuilder = new ParentChildInnerHitContextBuilder(type, false, query, innerHitBuilder, children).         innerHits.put(name, innerHitContextBuilder).     } }
