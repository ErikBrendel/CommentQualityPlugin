commented;modifiers;parameterAmount;loc;comment;code
false;public;0;19;;public void testNoDocs() throws IOException {     Directory directory = newDirectory().     RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory).     // intentionally not writing any docs     indexWriter.close().     IndexReader indexReader = DirectoryReader.open(directory).     testCase(new MatchAllDocsQuery(), newSearcher(indexReader, false, true), childrenToParent -> {         assertEquals(0, childrenToParent.getDocCount()).         Aggregation parentAggregation = childrenToParent.getAggregations().get("in_parent").         assertEquals(0, childrenToParent.getDocCount()).         assertNotNull("Aggregations: " + childrenToParent.getAggregations().asMap(), parentAggregation).         assertEquals(Double.POSITIVE_INFINITY, ((InternalMin) parentAggregation).getValue(), Double.MIN_VALUE).         assertFalse(JoinAggregationInspectionHelper.hasValue(childrenToParent)).     }).     indexReader.close().     directory.close(). }
false;public;0;42;;public void testParentChild() throws IOException {     Directory directory = newDirectory().     RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory).     final Map<String, Tuple<Integer, Integer>> expectedParentChildRelations = setupIndex(indexWriter).     indexWriter.close().     IndexReader indexReader = ElasticsearchDirectoryReader.wrap(DirectoryReader.open(directory), new ShardId(new Index("foo", "_na_"), 1)).     // TODO set "maybeWrap" to true for IndexSearcher once #23338 is resolved     IndexSearcher indexSearcher = newSearcher(indexReader, false, true).     // verify with all documents     testCase(new MatchAllDocsQuery(), indexSearcher, parent -> {         int expectedTotalParents = 0.         int expectedMinValue = Integer.MAX_VALUE.         for (Tuple<Integer, Integer> expectedValues : expectedParentChildRelations.values()) {             expectedTotalParents++.             expectedMinValue = Math.min(expectedMinValue, expectedValues.v2()).         }         assertEquals("Having " + parent.getDocCount() + " docs and aggregation results: " + parent.getAggregations().asMap(), expectedTotalParents, parent.getDocCount()).         assertEquals(expectedMinValue, ((InternalMin) parent.getAggregations().get("in_parent")).getValue(), Double.MIN_VALUE).         assertTrue(JoinAggregationInspectionHelper.hasValue(parent)).     }).     // verify for each children     for (String parent : expectedParentChildRelations.keySet()) {         testCase(new TermInSetQuery(IdFieldMapper.NAME, Uid.encodeId("child0_" + parent)), indexSearcher, aggregation -> {             assertEquals("Expected one result for min-aggregation for parent: " + parent + ", but had aggregation-results: " + aggregation, 1, aggregation.getDocCount()).             assertEquals(expectedParentChildRelations.get(parent).v2(), ((InternalMin) aggregation.getAggregations().get("in_parent")).getValue(), Double.MIN_VALUE).         }).     }     indexReader.close().     directory.close(). }
false;public;0;52;;public void testParentChildTerms() throws IOException {     Directory directory = newDirectory().     RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory).     final Map<String, Tuple<Integer, Integer>> expectedParentChildRelations = setupIndex(indexWriter).     indexWriter.close().     SortedMap<Integer, Long> entries = new TreeMap<>().     for (Tuple<Integer, Integer> value : expectedParentChildRelations.values()) {         Long l = entries.computeIfAbsent(value.v2(), integer -> 0L).         entries.put(value.v2(), l + 1).     }     List<Map.Entry<Integer, Long>> sortedValues = new ArrayList<>(entries.entrySet()).     sortedValues.sort((o1, o2) -> {         // sort larger values first         int ret = o2.getValue().compareTo(o1.getValue()).         if (ret != 0) {             return ret.         }         // on equal value, sort by key         return o1.getKey().compareTo(o2.getKey()).     }).     IndexReader indexReader = ElasticsearchDirectoryReader.wrap(DirectoryReader.open(directory), new ShardId(new Index("foo", "_na_"), 1)).     // TODO set "maybeWrap" to true for IndexSearcher once #23338 is resolved     IndexSearcher indexSearcher = newSearcher(indexReader, false, true).     // verify a terms-aggregation inside the parent-aggregation     testCaseTerms(new MatchAllDocsQuery(), indexSearcher, parent -> {         assertNotNull(parent).         assertTrue(JoinAggregationInspectionHelper.hasValue(parent)).         LongTerms valueTerms = parent.getAggregations().get("value_terms").         assertNotNull(valueTerms).         List<LongTerms.Bucket> valueTermsBuckets = valueTerms.getBuckets().         assertNotNull(valueTermsBuckets).         assertEquals("Had: " + parent, sortedValues.size(), valueTermsBuckets.size()).         int i = 0.         for (Map.Entry<Integer, Long> entry : sortedValues) {             LongTerms.Bucket bucket = valueTermsBuckets.get(i).             assertEquals(entry.getKey().longValue(), bucket.getKeyAsNumber()).             assertEquals(entry.getValue(), (Long) bucket.getDocCount()).             i++.         }     }).     indexReader.close().     directory.close(). }
false;public;0;32;;public void testTermsParentChildTerms() throws IOException {     Directory directory = newDirectory().     RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory).     final Map<String, Tuple<Integer, Integer>> expectedParentChildRelations = setupIndex(indexWriter).     indexWriter.close().     SortedMap<Integer, Long> sortedValues = new TreeMap<>().     for (Tuple<Integer, Integer> value : expectedParentChildRelations.values()) {         Long l = sortedValues.computeIfAbsent(value.v2(), integer -> 0L).         sortedValues.put(value.v2(), l + 1).     }     IndexReader indexReader = ElasticsearchDirectoryReader.wrap(DirectoryReader.open(directory), new ShardId(new Index("foo", "_na_"), 1)).     // TODO set "maybeWrap" to true for IndexSearcher once #23338 is resolved     IndexSearcher indexSearcher = newSearcher(indexReader, false, true).     // verify a terms-aggregation inside the parent-aggregation which itself is inside a     // terms-aggregation on the child-documents     testCaseTermsParentTerms(new MatchAllDocsQuery(), indexSearcher, longTerms -> {         assertNotNull(longTerms).         for (LongTerms.Bucket bucket : longTerms.getBuckets()) {             assertNotNull(bucket).             assertNotNull(bucket.getKeyAsString()).         }     }).     indexReader.close().     directory.close(). }
false;private,static;1;22;;private static Map<String, Tuple<Integer, Integer>> setupIndex(RandomIndexWriter iw) throws IOException {     Map<String, Tuple<Integer, Integer>> expectedValues = new HashMap<>().     int numParents = randomIntBetween(1, 10).     for (int i = 0. i < numParents. i++) {         String parent = "parent" + i.         int randomValue = randomIntBetween(0, 100).         List<Field> parentDocument = createParentDocument(parent, randomValue).         /*long parentDocId =*/         iw.addDocument(parentDocument).         // System.out.println("Parent: " + parent + ": " + randomValue + ", id: " + parentDocId).         int numChildren = randomIntBetween(1, 10).         int minValue = Integer.MAX_VALUE.         for (int c = 0. c < numChildren. c++) {             minValue = Math.min(minValue, randomValue).             int randomSubValue = randomIntBetween(0, 100).             List<Field> childDocument = createChildDocument("child" + c + "_" + parent, parent, randomSubValue).             /*long childDocId =*/             iw.addDocument(childDocument).         // System.out.println("Child: " + "child" + c + "_" + parent + ": " + randomSubValue + ", id: " + childDocId).         }         expectedValues.put(parent, new Tuple<>(numChildren, minValue)).     }     return expectedValues. }
false;private,static;2;8;;private static List<Field> createParentDocument(String id, int value) {     return Arrays.asList(new StringField(IdFieldMapper.NAME, Uid.encodeId(id), Field.Store.NO), new StringField("join_field", PARENT_TYPE, Field.Store.NO), createJoinField(PARENT_TYPE, id), new SortedNumericDocValuesField("number", value)). }
false;private,static;3;8;;private static List<Field> createChildDocument(String childId, String parentId, int value) {     return Arrays.asList(new StringField(IdFieldMapper.NAME, Uid.encodeId(childId), Field.Store.NO), new StringField("join_field", CHILD_TYPE, Field.Store.NO), createJoinField(PARENT_TYPE, parentId), new SortedNumericDocValuesField("subNumber", value)). }
false;private,static;2;3;;private static SortedDocValuesField createJoinField(String parentType, String id) {     return new SortedDocValuesField("join_field#" + parentType, new BytesRef(id)). }
false;protected;0;9;;@Override protected MapperService mapperServiceMock() {     ParentJoinFieldMapper joinFieldMapper = createJoinFieldMapper().     MapperService mapperService = mock(MapperService.class).     MetaJoinFieldMapper.MetaJoinFieldType metaJoinFieldType = mock(MetaJoinFieldMapper.MetaJoinFieldType.class).     when(metaJoinFieldType.getMapper()).thenReturn(joinFieldMapper).     when(mapperService.fullName("_parent_join")).thenReturn(metaJoinFieldType).     return mapperService. }
false;private,static;0;6;;private static ParentJoinFieldMapper createJoinFieldMapper() {     Settings settings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT).build().     return new ParentJoinFieldMapper.Builder("join_field").addParent(PARENT_TYPE, Collections.singleton(CHILD_TYPE)).build(new Mapper.BuilderContext(settings, new ContentPath(0))). }
false;private;3;11;;private void testCase(Query query, IndexSearcher indexSearcher, Consumer<InternalParent> verify) throws IOException {     ParentAggregationBuilder aggregationBuilder = new ParentAggregationBuilder("_name", CHILD_TYPE).     aggregationBuilder.subAggregation(new MinAggregationBuilder("in_parent").field("number")).     MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(NumberFieldMapper.NumberType.LONG).     fieldType.setName("number").     InternalParent result = search(indexSearcher, query, aggregationBuilder, fieldType).     verify.accept(result). }
false;private;3;11;;private void testCaseTerms(Query query, IndexSearcher indexSearcher, Consumer<InternalParent> verify) throws IOException {     ParentAggregationBuilder aggregationBuilder = new ParentAggregationBuilder("_name", CHILD_TYPE).     aggregationBuilder.subAggregation(new TermsAggregationBuilder("value_terms", ValueType.LONG).field("number")).     MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(NumberFieldMapper.NumberType.LONG).     fieldType.setName("number").     InternalParent result = search(indexSearcher, query, aggregationBuilder, fieldType).     verify.accept(result). }
true;private;3;14;// run a terms aggregation on the number in child-documents, then a parent aggregation and then terms on the parent-number ;// run a terms aggregation on the number in child-documents, then a parent aggregation and then terms on the parent-number private void testCaseTermsParentTerms(Query query, IndexSearcher indexSearcher, Consumer<LongTerms> verify) throws IOException {     AggregationBuilder aggregationBuilder = new TermsAggregationBuilder("subvalue_terms", ValueType.LONG).field("subNumber").subAggregation(new ParentAggregationBuilder("to_parent", CHILD_TYPE).subAggregation(new TermsAggregationBuilder("value_terms", ValueType.LONG).field("number"))).     MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(NumberFieldMapper.NumberType.LONG).     fieldType.setName("number").     MappedFieldType subFieldType = new NumberFieldMapper.NumberFieldType(NumberFieldMapper.NumberType.LONG).     subFieldType.setName("subNumber").     LongTerms result = search(indexSearcher, query, aggregationBuilder, fieldType, subFieldType).     verify.accept(result). }
