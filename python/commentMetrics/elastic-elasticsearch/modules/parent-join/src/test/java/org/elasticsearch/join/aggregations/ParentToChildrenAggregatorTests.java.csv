commented;modifiers;parameterAmount;loc;comment;code
false;public;0;16;;public void testNoDocs() throws IOException {     Directory directory = newDirectory().     RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory).     // intentionally not writing any docs     indexWriter.close().     IndexReader indexReader = DirectoryReader.open(directory).     testCase(new MatchAllDocsQuery(), newSearcher(indexReader, false, true), parentToChild -> {         assertEquals(0, parentToChild.getDocCount()).         assertEquals(Double.POSITIVE_INFINITY, ((InternalMin) parentToChild.getAggregations().get("in_child")).getValue(), Double.MIN_VALUE).     }).     indexReader.close().     directory.close(). }
false;public;0;34;;public void testParentChild() throws IOException {     Directory directory = newDirectory().     RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory).     final Map<String, Tuple<Integer, Integer>> expectedParentChildRelations = setupIndex(indexWriter).     indexWriter.close().     IndexReader indexReader = ElasticsearchDirectoryReader.wrap(DirectoryReader.open(directory), new ShardId(new Index("foo", "_na_"), 1)).     // TODO set "maybeWrap" to true for IndexSearcher once #23338 is resolved     IndexSearcher indexSearcher = newSearcher(indexReader, false, true).     testCase(new MatchAllDocsQuery(), indexSearcher, child -> {         int expectedTotalChildren = 0.         int expectedMinValue = Integer.MAX_VALUE.         for (Tuple<Integer, Integer> expectedValues : expectedParentChildRelations.values()) {             expectedTotalChildren += expectedValues.v1().             expectedMinValue = Math.min(expectedMinValue, expectedValues.v2()).         }         assertEquals(expectedTotalChildren, child.getDocCount()).         assertTrue(JoinAggregationInspectionHelper.hasValue(child)).         assertEquals(expectedMinValue, ((InternalMin) child.getAggregations().get("in_child")).getValue(), Double.MIN_VALUE).     }).     for (String parent : expectedParentChildRelations.keySet()) {         testCase(new TermInSetQuery(IdFieldMapper.NAME, Uid.encodeId(parent)), indexSearcher, child -> {             assertEquals((long) expectedParentChildRelations.get(parent).v1(), child.getDocCount()).             assertEquals(expectedParentChildRelations.get(parent).v2(), ((InternalMin) child.getAggregations().get("in_child")).getValue(), Double.MIN_VALUE).         }).     }     indexReader.close().     directory.close(). }
false;private,static;1;17;;private static Map<String, Tuple<Integer, Integer>> setupIndex(RandomIndexWriter iw) throws IOException {     Map<String, Tuple<Integer, Integer>> expectedValues = new HashMap<>().     int numParents = randomIntBetween(1, 10).     for (int i = 0. i < numParents. i++) {         String parent = "parent" + i.         iw.addDocument(createParentDocument(parent)).         int numChildren = randomIntBetween(1, 10).         int minValue = Integer.MAX_VALUE.         for (int c = 0. c < numChildren. c++) {             int randomValue = randomIntBetween(0, 100).             minValue = Math.min(minValue, randomValue).             iw.addDocument(createChildDocument("child" + c + "_" + parent, parent, randomValue)).         }         expectedValues.put(parent, new Tuple<>(numChildren, minValue)).     }     return expectedValues. }
false;private,static;1;7;;private static List<Field> createParentDocument(String id) {     return Arrays.asList(new StringField(IdFieldMapper.NAME, Uid.encodeId(id), Field.Store.NO), new StringField("join_field", PARENT_TYPE, Field.Store.NO), createJoinField(PARENT_TYPE, id)). }
false;private,static;3;8;;private static List<Field> createChildDocument(String childId, String parentId, int value) {     return Arrays.asList(new StringField(IdFieldMapper.NAME, Uid.encodeId(childId), Field.Store.NO), new StringField("join_field", CHILD_TYPE, Field.Store.NO), createJoinField(PARENT_TYPE, parentId), new SortedNumericDocValuesField("number", value)). }
false;private,static;2;3;;private static SortedDocValuesField createJoinField(String parentType, String id) {     return new SortedDocValuesField("join_field#" + parentType, new BytesRef(id)). }
false;protected;0;9;;@Override protected MapperService mapperServiceMock() {     ParentJoinFieldMapper joinFieldMapper = createJoinFieldMapper().     MapperService mapperService = mock(MapperService.class).     MetaJoinFieldMapper.MetaJoinFieldType metaJoinFieldType = mock(MetaJoinFieldMapper.MetaJoinFieldType.class).     when(metaJoinFieldType.getMapper()).thenReturn(joinFieldMapper).     when(mapperService.fullName("_parent_join")).thenReturn(metaJoinFieldType).     return mapperService. }
false;private,static;0;6;;private static ParentJoinFieldMapper createJoinFieldMapper() {     Settings settings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT).build().     return new ParentJoinFieldMapper.Builder("join_field").addParent(PARENT_TYPE, Collections.singleton(CHILD_TYPE)).build(new Mapper.BuilderContext(settings, new ContentPath(0))). }
false;private;3;11;;private void testCase(Query query, IndexSearcher indexSearcher, Consumer<InternalChildren> verify) throws IOException {     ChildrenAggregationBuilder aggregationBuilder = new ChildrenAggregationBuilder("_name", CHILD_TYPE).     aggregationBuilder.subAggregation(new MinAggregationBuilder("in_child").field("number")).     MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(NumberFieldMapper.NumberType.LONG).     fieldType.setName("number").     InternalChildren result = search(indexSearcher, query, aggregationBuilder, fieldType).     verify.accept(result). }
