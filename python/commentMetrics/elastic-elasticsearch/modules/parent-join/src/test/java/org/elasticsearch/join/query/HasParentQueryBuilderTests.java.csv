commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected Collection<Class<? extends Plugin>> getPlugins() {     return Collections.singletonList(ParentJoinPlugin.class). }
false;protected;0;7;;@Override protected Settings createTestIndexSettings() {     return Settings.builder().put(super.createTestIndexSettings()).put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT).build(). }
false;protected;1;35;;@Override protected void initializeAdditionalMappings(MapperService mapperService) throws IOException {     XContentBuilder mapping = jsonBuilder().startObject().startObject("_doc").startObject("properties").startObject("join_field").field("type", "join").startObject("relations").field(PARENT_DOC, CHILD_DOC).endObject().endObject().startObject(STRING_FIELD_NAME).field("type", "text").endObject().startObject(STRING_FIELD_NAME_2).field("type", "keyword").endObject().startObject(INT_FIELD_NAME).field("type", "integer").endObject().startObject(DOUBLE_FIELD_NAME).field("type", "double").endObject().startObject(BOOLEAN_FIELD_NAME).field("type", "boolean").endObject().startObject(DATE_FIELD_NAME).field("type", "date").endObject().startObject(OBJECT_FIELD_NAME).field("type", "object").endObject().endObject().endObject().endObject().     mapperService.merge(TYPE, new CompressedXContent(Strings.toString(mapping)), MapperService.MergeReason.MAPPING_UPDATE). }
true;protected;0;17;/**  * @return a {@link HasChildQueryBuilder} with random values all over the place  */ ;/**  * @return a {@link HasChildQueryBuilder} with random values all over the place  */ @Override protected HasParentQueryBuilder doCreateTestQueryBuilder() {     QueryBuilder innerQueryBuilder = new MatchAllQueryBuilder().     if (randomBoolean()) {         requiresRewrite = true.         innerQueryBuilder = new WrapperQueryBuilder(innerQueryBuilder.toString()).     }     HasParentQueryBuilder hqb = new HasParentQueryBuilder(PARENT_DOC, innerQueryBuilder, randomBoolean()).     hqb.ignoreUnmapped(randomBoolean()).     if (randomBoolean()) {         hqb.innerHit(new InnerHitBuilder().setName(randomAlphaOfLengthBetween(1, 10)).setSize(randomIntBetween(0, 100)).addSort(new FieldSortBuilder(STRING_FIELD_NAME_2).order(SortOrder.ASC))).     }     return hqb. }
false;protected;3;27;;@Override protected void doAssertLuceneQuery(HasParentQueryBuilder queryBuilder, Query query, SearchContext searchContext) throws IOException {     assertThat(query, instanceOf(HasChildQueryBuilder.LateParsingQuery.class)).     HasChildQueryBuilder.LateParsingQuery lpq = (HasChildQueryBuilder.LateParsingQuery) query.     assertEquals(queryBuilder.score() ? ScoreMode.Max : ScoreMode.None, lpq.getScoreMode()).     if (queryBuilder.innerHit() != null) {         // have to rewrite again because the provided queryBuilder hasn't been rewritten (directly returned from         // doCreateTestQueryBuilder)         queryBuilder = (HasParentQueryBuilder) queryBuilder.rewrite(searchContext.getQueryShardContext()).         assertNotNull(searchContext).         Map<String, InnerHitContextBuilder> innerHitBuilders = new HashMap<>().         InnerHitContextBuilder.extractInnerHits(queryBuilder, innerHitBuilders).         for (InnerHitContextBuilder builder : innerHitBuilders.values()) {             builder.build(searchContext, searchContext.innerHits()).         }         assertNotNull(searchContext.innerHits()).         assertEquals(1, searchContext.innerHits().getInnerHits().size()).         assertTrue(searchContext.innerHits().getInnerHits().containsKey(queryBuilder.innerHit().getName())).         InnerHitsContext.InnerHitSubContext innerHits = searchContext.innerHits().getInnerHits().get(queryBuilder.innerHit().getName()).         assertEquals(innerHits.size(), queryBuilder.innerHit().getSize()).         assertEquals(innerHits.sort().sort.getSort().length, 1).         assertEquals(innerHits.sort().sort.getSort()[0].getField(), STRING_FIELD_NAME_2).     } }
true;public;0;6;/**  * Test (de)serialization on all previous released versions  */ ;/**  * Test (de)serialization on all previous released versions  */ public void testSerializationBWC() throws IOException {     for (Version version : VersionUtils.allReleasedVersions()) {         HasParentQueryBuilder testQuery = createTestQueryBuilder().         assertSerialization(testQuery, version).     } }
false;public;0;15;;public void testIllegalValues() throws IOException {     QueryBuilder query = new MatchAllQueryBuilder().     IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> hasParentQuery(null, query, false)).     assertThat(e.getMessage(), equalTo("[has_parent] requires 'parent_type' field")).     e = expectThrows(IllegalArgumentException.class, () -> hasParentQuery("foo", null, false)).     assertThat(e.getMessage(), equalTo("[has_parent] requires 'query' field")).     QueryShardContext context = createShardContext().     HasParentQueryBuilder qb = hasParentQuery("just_a_type", new MatchAllQueryBuilder(), false).     QueryShardException qse = expectThrows(QueryShardException.class, () -> qb.doToQuery(context)).     assertThat(qse.getMessage(), equalTo("[has_parent] join field [join_field] doesn't hold [just_a_type] as a parent")). }
false;public;0;11;;public void testToQueryInnerQueryType() throws IOException {     String[] searchTypes = new String[] { TYPE }.     QueryShardContext shardContext = createShardContext().     shardContext.setTypes(searchTypes).     HasParentQueryBuilder hasParentQueryBuilder = new HasParentQueryBuilder(PARENT_DOC, new IdsQueryBuilder().addIds("id"), false).     Query query = hasParentQueryBuilder.toQuery(shardContext).     // verify that the context types are still the same as the ones we previously set     assertThat(shardContext.getTypes(), equalTo(searchTypes)).     HasChildQueryBuilderTests.assertLateParsingQuery(query, PARENT_DOC, "id"). }
false;public;0;10;;@Override public void testMustRewrite() throws IOException {     try {         super.testMustRewrite().     } catch (UnsupportedOperationException e) {         if (requiresRewrite == false) {             throw e.         }     } }
false;public;0;23;;public void testFromJson() throws IOException {     String json = "{\n" + "  \"has_parent\" : {\n" + "    \"query\" : {\n" + "      \"term\" : {\n" + "        \"tag\" : {\n" + "          \"value\" : \"something\",\n" + "          \"boost\" : 1.0\n" + "        }\n" + "      }\n" + "    },\n" + "    \"parent_type\" : \"blog\",\n" + "    \"score\" : true,\n" + "    \"ignore_unmapped\" : false,\n" + "    \"boost\" : 1.0\n" + "  }\n" + "}".     HasParentQueryBuilder parsed = (HasParentQueryBuilder) parseQuery(json).     checkGeneratedJson(json, parsed).     assertEquals(json, "blog", parsed.type()).     assertEquals(json, "something", ((TermQueryBuilder) parsed.query()).value()). }
false;public;0;19;;public void testIgnoreUnmapped() throws IOException {     final HasParentQueryBuilder queryBuilder = new HasParentQueryBuilder("unmapped", new MatchAllQueryBuilder(), false).     queryBuilder.innerHit(new InnerHitBuilder()).     assertFalse(queryBuilder.innerHit().isIgnoreUnmapped()).     queryBuilder.ignoreUnmapped(true).     assertTrue(queryBuilder.innerHit().isIgnoreUnmapped()).     Query query = queryBuilder.toQuery(createShardContext()).     assertThat(query, notNullValue()).     assertThat(query, instanceOf(MatchNoDocsQuery.class)).     final HasParentQueryBuilder failingQueryBuilder = new HasParentQueryBuilder("unmapped", new MatchAllQueryBuilder(), false).     failingQueryBuilder.innerHit(new InnerHitBuilder()).     assertFalse(failingQueryBuilder.innerHit().isIgnoreUnmapped()).     failingQueryBuilder.ignoreUnmapped(false).     assertFalse(failingQueryBuilder.innerHit().isIgnoreUnmapped()).     QueryShardException e = expectThrows(QueryShardException.class, () -> failingQueryBuilder.toQuery(createShardContext())).     assertThat(e.getMessage(), containsString("[has_parent] join field [join_field] doesn't hold [unmapped] as a parent")). }
false;public;0;10;;public void testIgnoreUnmappedWithRewrite() throws IOException {     // WrapperQueryBuilder makes sure we always rewrite     final HasParentQueryBuilder queryBuilder = new HasParentQueryBuilder("unmapped", new WrapperQueryBuilder(new MatchAllQueryBuilder().toString()), false).     queryBuilder.ignoreUnmapped(true).     QueryShardContext queryShardContext = createShardContext().     Query query = queryBuilder.rewrite(queryShardContext).toQuery(queryShardContext).     assertThat(query, notNullValue()).     assertThat(query, instanceOf(MatchNoDocsQuery.class)). }
false;public;0;7;;public void testExtractInnerHitBuildersWithDuplicate() {     final HasParentQueryBuilder queryBuilder = new HasParentQueryBuilder(CHILD_DOC, new WrapperQueryBuilder(new MatchAllQueryBuilder().toString()), false).     queryBuilder.innerHit(new InnerHitBuilder("some_name")).     IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> InnerHitContextBuilder.extractInnerHits(queryBuilder, Collections.singletonMap("some_name", null))). }
