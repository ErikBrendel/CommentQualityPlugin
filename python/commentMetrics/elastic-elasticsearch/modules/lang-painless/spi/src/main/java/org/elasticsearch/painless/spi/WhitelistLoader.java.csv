# id;timestamp;commentText;codeText;commentWords;codeWords
WhitelistLoader -> public static Whitelist loadFromResourceFiles(Class<?> resource, String... filepaths);1524684173;Loads and creates a {@link Whitelist} from one to many text files.  The file paths are passed in as an array of_{@link String}s with a single {@link Class} to be be used to load the resources where each {@link String}_is the path of a single text file.  The {@link Class}'s {@link ClassLoader} will be used to lookup the Java_reflection objects for each individual {@link Class}, {@link Constructor}, {@link Method}, and {@link Field}_specified as part of the white-list in the text file.__A single pass is made through each file to collect all the information about each struct, constructor, method,_and field.  Most validation will be done at a later point after all white-lists have been gathered and their_merging takes place.__A painless type name is one of the following:_<ul>_<li> def - The Painless dynamic type which is automatically included without a need to be_white-listed. </li>_<li> fully-qualified Java type name - Any white-listed Java class will have the equivalent name as_a Painless type name with the exception that any dollar symbols used as part of inner classes will_be replaced with dot symbols. </li>_<li> short Java type name - The text after the final dot symbol of any specified Java class.  A_short type Java name may be excluded by using the 'only_fqn' token during Painless struct parsing_as described later. </li>_</ul>__The following can be parsed from each white-list text file:_<ul>_<li> Blank lines will be ignored by the parser. </li>_<li> Comments may be created starting with a pound '#' symbol and end with a newline.  These will_be ignored by the parser. </li>_<li> Primitive types may be specified starting with 'class' and followed by the Java type name,_an opening bracket, a newline, a closing bracket, and a final newline. </li>_<li> Complex types may be specified starting with 'class' and followed the fully-qualified Java_class name, optionally followed by an 'only_fqn' token, an opening bracket, a newline,_constructor/method/field specifications, a closing bracket, and a final newline. Within a complex_type the following may be parsed:_<ul>_<li> A constructor may be specified starting with an opening parenthesis, followed by a_comma-delimited list of Painless type names corresponding to the type/class names for_the equivalent Java parameter types (these must be white-listed as well), a closing_parenthesis, and a newline. </li>_<li> A method may be specified starting with a Painless type name for the return type,_followed by the Java name of the method (which will also be the Painless name for the_method), an opening parenthesis, a comma-delimited list of Painless type names_corresponding to the type/class names for the equivalent Java parameter types_(these must be white-listed as well), a closing parenthesis, and a newline. </li>_<li> An augmented method may be specified starting with a Painless type name for the return_type, followed by the fully qualified Java name of the class the augmented method is_part of (this class does not need to be white-listed), the Java name of the method_(which will also be the Painless name for the method), an opening parenthesis, a_comma-delimited list of Painless type names corresponding to the type/class names_for the equivalent Java parameter types (these must be white-listed as well), a closing_parenthesis, and a newline. </li>_<li>A field may be specified starting with a Painless type name for the equivalent Java type_of the field, followed by the Java name of the field (which all be the Painless name_for the field), and a newline. </li>_</ul>_</ul>__Note there must be a one-to-one correspondence of Painless type names to Java type/class names._If the same Painless type is defined across multiple files and the Java class is the same, all_specified constructors, methods, and fields will be merged into a single Painless type.  The_Painless dynamic type, 'def', used as part of constructor, method, and field definitions will_be appropriately parsed and handled.  Painless complex types must be specified with the_fully-qualified Java class name.  Method argument types, method return types, and field types_must be specified with Painless type names (def, fully-qualified, or short) as described earlier.__The following example is used to create a single white-list text file:__{@code_# primitive types__class int -> int {___# complex types__class my.package.Example only_fqn {_# constructors__(int)_(def, def)_(Example, def)__# method_Example add(int, def)_int add(Example, Example)_void example()__# augmented_Example some.other.Class sub(Example, int, def)__# fields_int value0_int value1_def value2;public static Whitelist loadFromResourceFiles(Class<?> resource, String... filepaths) {_        List<Whitelist.Struct> whitelistStructs = new ArrayList<>()___        _        _        for (String filepath : filepaths) {_            String line__            int number = -1___            try (LineNumberReader reader = new LineNumberReader(_                new InputStreamReader(resource.getResourceAsStream(filepath), StandardCharsets.UTF_8))) {__                String whitelistStructOrigin = null__                String javaClassName = null__                boolean onlyFQNJavaClassName = false__                List<Whitelist.Constructor> whitelistConstructors = null__                List<Whitelist.Method> whitelistMethods = null__                List<Whitelist.Field> whitelistFields = null___                while ((line = reader.readLine()) != null) {_                    number = reader.getLineNumber()__                    line = line.trim()___                    _                    if (line.length() == 0 || line.charAt(0) == '#') {_                        continue__                    }__                    _                    _                    if (line.startsWith("class ")) {_                        _                        if (line.endsWith("{") == false) {_                            throw new IllegalArgumentException(_                                "invalid struct definition: failed to parse class opening bracket [" + line + "]")__                        }__                        _                        String[] tokens = line.substring(5, line.length() - 1).trim().split("\\s+")___                        _                        if (tokens.length == 2 && "only_fqn".equals(tokens[1])) {_                            onlyFQNJavaClassName = true__                        } else if (tokens.length != 1) {_                            throw new IllegalArgumentException("invalid struct definition: failed to parse class name [" + line + "]")__                        }__                        whitelistStructOrigin = "[" + filepath + "]:[" + number + "]"__                        javaClassName = tokens[0]___                        _                        whitelistConstructors = new ArrayList<>()__                        whitelistMethods = new ArrayList<>()__                        whitelistFields = new ArrayList<>()___                    _                    _                    _                    } else if (line.equals("}")) {_                        if (javaClassName == null) {_                            throw new IllegalArgumentException("invalid struct definition: extraneous closing bracket")__                        }__                        whitelistStructs.add(new Whitelist.Struct(whitelistStructOrigin, javaClassName, onlyFQNJavaClassName,_                            whitelistConstructors, whitelistMethods, whitelistFields))___                        _                        whitelistStructOrigin = null__                        javaClassName = null__                        onlyFQNJavaClassName = false__                        whitelistConstructors = null__                        whitelistMethods = null__                        whitelistFields = null___                    _                    } else {_                        _                        String origin = "[" + filepath + "]:[" + number + "]"___                        _                        if (javaClassName == null) {_                            throw new IllegalArgumentException("invalid object definition: expected a class name [" + line + "]")__                        }__                        _                        _                        if (line.startsWith("(")) {_                            _                            if (line.endsWith(")") == false) {_                                throw new IllegalArgumentException(_                                    "invalid constructor definition: expected a closing parenthesis [" + line + "]")__                            }__                            _                            String[] tokens = line.substring(1, line.length() - 1).replaceAll("\\s+", "").split(",")___                            _                            if ("".equals(tokens[0])) {_                                tokens = new String[0]__                            }__                            whitelistConstructors.add(new Whitelist.Constructor(origin, Arrays.asList(tokens)))___                        _                        _                        } else if (line.contains("(")) {_                            _                            if (line.endsWith(")") == false) {_                                throw new IllegalArgumentException(_                                    "invalid method definition: expected a closing parenthesis [" + line + "]")__                            }__                            _                            int parameterIndex = line.indexOf('(')__                            String[] tokens = line.trim().substring(0, parameterIndex).split("\\s+")___                            String javaMethodName__                            String javaAugmentedClassName___                            _                            if (tokens.length == 2) {_                                javaMethodName = tokens[1]__                                javaAugmentedClassName = null__                            } else if (tokens.length == 3) {_                                javaMethodName = tokens[2]__                                javaAugmentedClassName = tokens[1]__                            } else {_                                throw new IllegalArgumentException("invalid method definition: unexpected format [" + line + "]")__                            }__                            String painlessReturnTypeName = tokens[0]___                            _                            tokens = line.substring(parameterIndex + 1, line.length() - 1).replaceAll("\\s+", "").split(",")___                            _                            if ("".equals(tokens[0])) {_                                tokens = new String[0]__                            }__                            whitelistMethods.add(new Whitelist.Method(origin, javaAugmentedClassName, javaMethodName,_                                painlessReturnTypeName, Arrays.asList(tokens)))___                        _                        _                        } else {_                            _                            String[] tokens = line.split("\\s+")___                            _                            if (tokens.length != 2) {_                                throw new IllegalArgumentException("invalid field definition: unexpected format [" + line + "]")__                            }__                            whitelistFields.add(new Whitelist.Field(origin, tokens[1], tokens[0]))__                        }_                    }_                }__                _                if (javaClassName != null) {_                    throw new IllegalArgumentException("invalid struct definition: expected closing bracket")__                }_            } catch (Exception exception) {_                throw new RuntimeException("error in [" + filepath + "] at line [" + number + "]", exception)__            }_        }_        ClassLoader loader = AccessController.doPrivileged((PrivilegedAction<ClassLoader>)resource::getClassLoader)___        return new Whitelist(loader, whitelistStructs)__    };loads,and,creates,a,link,whitelist,from,one,to,many,text,files,the,file,paths,are,passed,in,as,an,array,of,link,string,s,with,a,single,link,class,to,be,be,used,to,load,the,resources,where,each,link,string,is,the,path,of,a,single,text,file,the,link,class,s,link,class,loader,will,be,used,to,lookup,the,java,reflection,objects,for,each,individual,link,class,link,constructor,link,method,and,link,field,specified,as,part,of,the,white,list,in,the,text,file,a,single,pass,is,made,through,each,file,to,collect,all,the,information,about,each,struct,constructor,method,and,field,most,validation,will,be,done,at,a,later,point,after,all,white,lists,have,been,gathered,and,their,merging,takes,place,a,painless,type,name,is,one,of,the,following,ul,li,def,the,painless,dynamic,type,which,is,automatically,included,without,a,need,to,be,white,listed,li,li,fully,qualified,java,type,name,any,white,listed,java,class,will,have,the,equivalent,name,as,a,painless,type,name,with,the,exception,that,any,dollar,symbols,used,as,part,of,inner,classes,will,be,replaced,with,dot,symbols,li,li,short,java,type,name,the,text,after,the,final,dot,symbol,of,any,specified,java,class,a,short,type,java,name,may,be,excluded,by,using,the,token,during,painless,struct,parsing,as,described,later,li,ul,the,following,can,be,parsed,from,each,white,list,text,file,ul,li,blank,lines,will,be,ignored,by,the,parser,li,li,comments,may,be,created,starting,with,a,pound,symbol,and,end,with,a,newline,these,will,be,ignored,by,the,parser,li,li,primitive,types,may,be,specified,starting,with,class,and,followed,by,the,java,type,name,an,opening,bracket,a,newline,a,closing,bracket,and,a,final,newline,li,li,complex,types,may,be,specified,starting,with,class,and,followed,the,fully,qualified,java,class,name,optionally,followed,by,an,token,an,opening,bracket,a,newline,constructor,method,field,specifications,a,closing,bracket,and,a,final,newline,within,a,complex,type,the,following,may,be,parsed,ul,li,a,constructor,may,be,specified,starting,with,an,opening,parenthesis,followed,by,a,comma,delimited,list,of,painless,type,names,corresponding,to,the,type,class,names,for,the,equivalent,java,parameter,types,these,must,be,white,listed,as,well,a,closing,parenthesis,and,a,newline,li,li,a,method,may,be,specified,starting,with,a,painless,type,name,for,the,return,type,followed,by,the,java,name,of,the,method,which,will,also,be,the,painless,name,for,the,method,an,opening,parenthesis,a,comma,delimited,list,of,painless,type,names,corresponding,to,the,type,class,names,for,the,equivalent,java,parameter,types,these,must,be,white,listed,as,well,a,closing,parenthesis,and,a,newline,li,li,an,augmented,method,may,be,specified,starting,with,a,painless,type,name,for,the,return,type,followed,by,the,fully,qualified,java,name,of,the,class,the,augmented,method,is,part,of,this,class,does,not,need,to,be,white,listed,the,java,name,of,the,method,which,will,also,be,the,painless,name,for,the,method,an,opening,parenthesis,a,comma,delimited,list,of,painless,type,names,corresponding,to,the,type,class,names,for,the,equivalent,java,parameter,types,these,must,be,white,listed,as,well,a,closing,parenthesis,and,a,newline,li,li,a,field,may,be,specified,starting,with,a,painless,type,name,for,the,equivalent,java,type,of,the,field,followed,by,the,java,name,of,the,field,which,all,be,the,painless,name,for,the,field,and,a,newline,li,ul,ul,note,there,must,be,a,one,to,one,correspondence,of,painless,type,names,to,java,type,class,names,if,the,same,painless,type,is,defined,across,multiple,files,and,the,java,class,is,the,same,all,specified,constructors,methods,and,fields,will,be,merged,into,a,single,painless,type,the,painless,dynamic,type,def,used,as,part,of,constructor,method,and,field,definitions,will,be,appropriately,parsed,and,handled,painless,complex,types,must,be,specified,with,the,fully,qualified,java,class,name,method,argument,types,method,return,types,and,field,types,must,be,specified,with,painless,type,names,def,fully,qualified,or,short,as,described,earlier,the,following,example,is,used,to,create,a,single,white,list,text,file,code,primitive,types,class,int,int,complex,types,class,my,package,example,constructors,int,def,def,example,def,method,example,add,int,def,int,add,example,example,void,example,augmented,example,some,other,class,sub,example,int,def,fields,int,value0,int,value1,def,value2;public,static,whitelist,load,from,resource,files,class,resource,string,filepaths,list,whitelist,struct,whitelist,structs,new,array,list,for,string,filepath,filepaths,string,line,int,number,1,try,line,number,reader,reader,new,line,number,reader,new,input,stream,reader,resource,get,resource,as,stream,filepath,standard,charsets,string,whitelist,struct,origin,null,string,java,class,name,null,boolean,only,fqnjava,class,name,false,list,whitelist,constructor,whitelist,constructors,null,list,whitelist,method,whitelist,methods,null,list,whitelist,field,whitelist,fields,null,while,line,reader,read,line,null,number,reader,get,line,number,line,line,trim,if,line,length,0,line,char,at,0,continue,if,line,starts,with,class,if,line,ends,with,false,throw,new,illegal,argument,exception,invalid,struct,definition,failed,to,parse,class,opening,bracket,line,string,tokens,line,substring,5,line,length,1,trim,split,s,if,tokens,length,2,equals,tokens,1,only,fqnjava,class,name,true,else,if,tokens,length,1,throw,new,illegal,argument,exception,invalid,struct,definition,failed,to,parse,class,name,line,whitelist,struct,origin,filepath,number,java,class,name,tokens,0,whitelist,constructors,new,array,list,whitelist,methods,new,array,list,whitelist,fields,new,array,list,else,if,line,equals,if,java,class,name,null,throw,new,illegal,argument,exception,invalid,struct,definition,extraneous,closing,bracket,whitelist,structs,add,new,whitelist,struct,whitelist,struct,origin,java,class,name,only,fqnjava,class,name,whitelist,constructors,whitelist,methods,whitelist,fields,whitelist,struct,origin,null,java,class,name,null,only,fqnjava,class,name,false,whitelist,constructors,null,whitelist,methods,null,whitelist,fields,null,else,string,origin,filepath,number,if,java,class,name,null,throw,new,illegal,argument,exception,invalid,object,definition,expected,a,class,name,line,if,line,starts,with,if,line,ends,with,false,throw,new,illegal,argument,exception,invalid,constructor,definition,expected,a,closing,parenthesis,line,string,tokens,line,substring,1,line,length,1,replace,all,s,split,if,equals,tokens,0,tokens,new,string,0,whitelist,constructors,add,new,whitelist,constructor,origin,arrays,as,list,tokens,else,if,line,contains,if,line,ends,with,false,throw,new,illegal,argument,exception,invalid,method,definition,expected,a,closing,parenthesis,line,int,parameter,index,line,index,of,string,tokens,line,trim,substring,0,parameter,index,split,s,string,java,method,name,string,java,augmented,class,name,if,tokens,length,2,java,method,name,tokens,1,java,augmented,class,name,null,else,if,tokens,length,3,java,method,name,tokens,2,java,augmented,class,name,tokens,1,else,throw,new,illegal,argument,exception,invalid,method,definition,unexpected,format,line,string,painless,return,type,name,tokens,0,tokens,line,substring,parameter,index,1,line,length,1,replace,all,s,split,if,equals,tokens,0,tokens,new,string,0,whitelist,methods,add,new,whitelist,method,origin,java,augmented,class,name,java,method,name,painless,return,type,name,arrays,as,list,tokens,else,string,tokens,line,split,s,if,tokens,length,2,throw,new,illegal,argument,exception,invalid,field,definition,unexpected,format,line,whitelist,fields,add,new,whitelist,field,origin,tokens,1,tokens,0,if,java,class,name,null,throw,new,illegal,argument,exception,invalid,struct,definition,expected,closing,bracket,catch,exception,exception,throw,new,runtime,exception,error,in,filepath,at,line,number,exception,class,loader,loader,access,controller,do,privileged,privileged,action,class,loader,resource,get,class,loader,return,new,whitelist,loader,whitelist,structs
WhitelistLoader -> public static Whitelist loadFromResourceFiles(Class<?> resource, String... filepaths);1531179852;Loads and creates a {@link Whitelist} from one to many text files.  The file paths are passed in as an array of_{@link String}s with a single {@link Class} to be be used to load the resources where each {@link String}_is the path of a single text file.  The {@link Class}'s {@link ClassLoader} will be used to lookup the Java_reflection objects for each individual {@link Class}, {@link Constructor}, {@link Method}, and {@link Field}_specified as part of the whitelist in the text file.__A single pass is made through each file to collect all the information about each class, constructor, method,_and field.  Most validation will be done at a later point after all whitelists have been gathered and their_merging takes place.__A painless type name is one of the following:_<ul>_<li> def - The Painless dynamic type which is automatically included without a need to be_whitelisted. </li>_<li> fully-qualified Java type name - Any whitelisted Java class will have the equivalent name as_a Painless type name with the exception that any dollar symbols used as part of inner classes will_be replaced with dot symbols. </li>_<li> short Java type name - The text after the final dot symbol of any specified Java class.  A_short type Java name may be excluded by using the 'only_fqn' token during Painless class parsing_as described later. </li>_</ul>__The following can be parsed from each whitelist text file:_<ul>_<li> Blank lines will be ignored by the parser. </li>_<li> Comments may be created starting with a pound '#' symbol and end with a newline.  These will_be ignored by the parser. </li>_<li> Primitive types may be specified starting with 'class' and followed by the Java type name,_an opening bracket, a newline, a closing bracket, and a final newline. </li>_<li> Complex types may be specified starting with 'class' and followed the fully-qualified Java_class name, optionally followed by an 'only_fqn' token, an opening bracket, a newline,_constructor/method/field specifications, a closing bracket, and a final newline. Within a complex_type the following may be parsed:_<ul>_<li> A constructor may be specified starting with an opening parenthesis, followed by a_comma-delimited list of Painless type names corresponding to the type/class names for_the equivalent Java parameter types (these must be whitelisted as well), a closing_parenthesis, and a newline. </li>_<li> A method may be specified starting with a Painless type name for the return type,_followed by the Java name of the method (which will also be the Painless name for the_method), an opening parenthesis, a comma-delimited list of Painless type names_corresponding to the type/class names for the equivalent Java parameter types_(these must be whitelisted as well), a closing parenthesis, and a newline. </li>_<li> An augmented method may be specified starting with a Painless type name for the return_type, followed by the fully qualified Java name of the class the augmented method is_part of (this class does not need to be whitelisted), the Java name of the method_(which will also be the Painless name for the method), an opening parenthesis, a_comma-delimited list of Painless type names corresponding to the type/class names_for the equivalent Java parameter types (these must be whitelisted as well), a closing_parenthesis, and a newline. </li>_<li>A field may be specified starting with a Painless type name for the equivalent Java type_of the field, followed by the Java name of the field (which all be the Painless name_for the field), and a newline. </li>_</ul>_</ul>__Note there must be a one-to-one correspondence of Painless type names to Java type/class names._If the same Painless type is defined across multiple files and the Java class is the same, all_specified constructors, methods, and fields will be merged into a single Painless type.  The_Painless dynamic type, 'def', used as part of constructor, method, and field definitions will_be appropriately parsed and handled.  Painless complex types must be specified with the_fully-qualified Java class name.  Method argument types, method return types, and field types_must be specified with Painless type names (def, fully-qualified, or short) as described earlier.__The following example is used to create a single whitelist text file:__{@code_# primitive types__class int -> int {___# complex types__class my.package.Example only_fqn {_# constructors__(int)_(def, def)_(Example, def)__# method_Example add(int, def)_int add(Example, Example)_void example()__# augmented_Example some.other.Class sub(Example, int, def)__# fields_int value0_int value1_def value2;public static Whitelist loadFromResourceFiles(Class<?> resource, String... filepaths) {_        List<WhitelistClass> whitelistStructs = new ArrayList<>()___        _        _        for (String filepath : filepaths) {_            String line__            int number = -1___            try (LineNumberReader reader = new LineNumberReader(_                new InputStreamReader(resource.getResourceAsStream(filepath), StandardCharsets.UTF_8))) {__                String whitelistStructOrigin = null__                String javaClassName = null__                boolean onlyFQNJavaClassName = false__                List<WhitelistConstructor> whitelistConstructors = null__                List<WhitelistMethod> whitelistMethods = null__                List<WhitelistField> whitelistFields = null___                while ((line = reader.readLine()) != null) {_                    number = reader.getLineNumber()__                    line = line.trim()___                    _                    if (line.length() == 0 || line.charAt(0) == '#') {_                        continue__                    }__                    _                    _                    if (line.startsWith("class ")) {_                        _                        if (line.endsWith("{") == false) {_                            throw new IllegalArgumentException(_                                "invalid class definition: failed to parse class opening bracket [" + line + "]")__                        }__                        _                        String[] tokens = line.substring(5, line.length() - 1).trim().split("\\s+")___                        _                        if (tokens.length == 2 && "only_fqn".equals(tokens[1])) {_                            onlyFQNJavaClassName = true__                        } else if (tokens.length != 1) {_                            throw new IllegalArgumentException("invalid class definition: failed to parse class name [" + line + "]")__                        }__                        whitelistStructOrigin = "[" + filepath + "]:[" + number + "]"__                        javaClassName = tokens[0]___                        _                        whitelistConstructors = new ArrayList<>()__                        whitelistMethods = new ArrayList<>()__                        whitelistFields = new ArrayList<>()___                    _                    _                    _                    } else if (line.equals("}")) {_                        if (javaClassName == null) {_                            throw new IllegalArgumentException("invalid class definition: extraneous closing bracket")__                        }__                        whitelistStructs.add(new WhitelistClass(whitelistStructOrigin, javaClassName, onlyFQNJavaClassName,_                            whitelistConstructors, whitelistMethods, whitelistFields))___                        _                        whitelistStructOrigin = null__                        javaClassName = null__                        onlyFQNJavaClassName = false__                        whitelistConstructors = null__                        whitelistMethods = null__                        whitelistFields = null___                    _                    } else {_                        _                        String origin = "[" + filepath + "]:[" + number + "]"___                        _                        if (javaClassName == null) {_                            throw new IllegalArgumentException("invalid object definition: expected a class name [" + line + "]")__                        }__                        _                        _                        if (line.startsWith("(")) {_                            _                            if (line.endsWith(")") == false) {_                                throw new IllegalArgumentException(_                                    "invalid constructor definition: expected a closing parenthesis [" + line + "]")__                            }__                            _                            String[] tokens = line.substring(1, line.length() - 1).replaceAll("\\s+", "").split(",")___                            _                            if ("".equals(tokens[0])) {_                                tokens = new String[0]__                            }__                            whitelistConstructors.add(new WhitelistConstructor(origin, Arrays.asList(tokens)))___                        _                        _                        } else if (line.contains("(")) {_                            _                            if (line.endsWith(")") == false) {_                                throw new IllegalArgumentException(_                                    "invalid method definition: expected a closing parenthesis [" + line + "]")__                            }__                            _                            int parameterIndex = line.indexOf('(')__                            String[] tokens = line.trim().substring(0, parameterIndex).split("\\s+")___                            String javaMethodName__                            String javaAugmentedClassName___                            _                            if (tokens.length == 2) {_                                javaMethodName = tokens[1]__                                javaAugmentedClassName = null__                            } else if (tokens.length == 3) {_                                javaMethodName = tokens[2]__                                javaAugmentedClassName = tokens[1]__                            } else {_                                throw new IllegalArgumentException("invalid method definition: unexpected format [" + line + "]")__                            }__                            String painlessReturnTypeName = tokens[0]___                            _                            tokens = line.substring(parameterIndex + 1, line.length() - 1).replaceAll("\\s+", "").split(",")___                            _                            if ("".equals(tokens[0])) {_                                tokens = new String[0]__                            }__                            whitelistMethods.add(new WhitelistMethod(origin, javaAugmentedClassName, javaMethodName,_                                painlessReturnTypeName, Arrays.asList(tokens)))___                        _                        _                        } else {_                            _                            String[] tokens = line.split("\\s+")___                            _                            if (tokens.length != 2) {_                                throw new IllegalArgumentException("invalid field definition: unexpected format [" + line + "]")__                            }__                            whitelistFields.add(new WhitelistField(origin, tokens[1], tokens[0]))__                        }_                    }_                }__                _                if (javaClassName != null) {_                    throw new IllegalArgumentException("invalid class definition: expected closing bracket")__                }_            } catch (Exception exception) {_                throw new RuntimeException("error in [" + filepath + "] at line [" + number + "]", exception)__            }_        }_        ClassLoader loader = AccessController.doPrivileged((PrivilegedAction<ClassLoader>)resource::getClassLoader)___        return new Whitelist(loader, whitelistStructs)__    };loads,and,creates,a,link,whitelist,from,one,to,many,text,files,the,file,paths,are,passed,in,as,an,array,of,link,string,s,with,a,single,link,class,to,be,be,used,to,load,the,resources,where,each,link,string,is,the,path,of,a,single,text,file,the,link,class,s,link,class,loader,will,be,used,to,lookup,the,java,reflection,objects,for,each,individual,link,class,link,constructor,link,method,and,link,field,specified,as,part,of,the,whitelist,in,the,text,file,a,single,pass,is,made,through,each,file,to,collect,all,the,information,about,each,class,constructor,method,and,field,most,validation,will,be,done,at,a,later,point,after,all,whitelists,have,been,gathered,and,their,merging,takes,place,a,painless,type,name,is,one,of,the,following,ul,li,def,the,painless,dynamic,type,which,is,automatically,included,without,a,need,to,be,whitelisted,li,li,fully,qualified,java,type,name,any,whitelisted,java,class,will,have,the,equivalent,name,as,a,painless,type,name,with,the,exception,that,any,dollar,symbols,used,as,part,of,inner,classes,will,be,replaced,with,dot,symbols,li,li,short,java,type,name,the,text,after,the,final,dot,symbol,of,any,specified,java,class,a,short,type,java,name,may,be,excluded,by,using,the,token,during,painless,class,parsing,as,described,later,li,ul,the,following,can,be,parsed,from,each,whitelist,text,file,ul,li,blank,lines,will,be,ignored,by,the,parser,li,li,comments,may,be,created,starting,with,a,pound,symbol,and,end,with,a,newline,these,will,be,ignored,by,the,parser,li,li,primitive,types,may,be,specified,starting,with,class,and,followed,by,the,java,type,name,an,opening,bracket,a,newline,a,closing,bracket,and,a,final,newline,li,li,complex,types,may,be,specified,starting,with,class,and,followed,the,fully,qualified,java,class,name,optionally,followed,by,an,token,an,opening,bracket,a,newline,constructor,method,field,specifications,a,closing,bracket,and,a,final,newline,within,a,complex,type,the,following,may,be,parsed,ul,li,a,constructor,may,be,specified,starting,with,an,opening,parenthesis,followed,by,a,comma,delimited,list,of,painless,type,names,corresponding,to,the,type,class,names,for,the,equivalent,java,parameter,types,these,must,be,whitelisted,as,well,a,closing,parenthesis,and,a,newline,li,li,a,method,may,be,specified,starting,with,a,painless,type,name,for,the,return,type,followed,by,the,java,name,of,the,method,which,will,also,be,the,painless,name,for,the,method,an,opening,parenthesis,a,comma,delimited,list,of,painless,type,names,corresponding,to,the,type,class,names,for,the,equivalent,java,parameter,types,these,must,be,whitelisted,as,well,a,closing,parenthesis,and,a,newline,li,li,an,augmented,method,may,be,specified,starting,with,a,painless,type,name,for,the,return,type,followed,by,the,fully,qualified,java,name,of,the,class,the,augmented,method,is,part,of,this,class,does,not,need,to,be,whitelisted,the,java,name,of,the,method,which,will,also,be,the,painless,name,for,the,method,an,opening,parenthesis,a,comma,delimited,list,of,painless,type,names,corresponding,to,the,type,class,names,for,the,equivalent,java,parameter,types,these,must,be,whitelisted,as,well,a,closing,parenthesis,and,a,newline,li,li,a,field,may,be,specified,starting,with,a,painless,type,name,for,the,equivalent,java,type,of,the,field,followed,by,the,java,name,of,the,field,which,all,be,the,painless,name,for,the,field,and,a,newline,li,ul,ul,note,there,must,be,a,one,to,one,correspondence,of,painless,type,names,to,java,type,class,names,if,the,same,painless,type,is,defined,across,multiple,files,and,the,java,class,is,the,same,all,specified,constructors,methods,and,fields,will,be,merged,into,a,single,painless,type,the,painless,dynamic,type,def,used,as,part,of,constructor,method,and,field,definitions,will,be,appropriately,parsed,and,handled,painless,complex,types,must,be,specified,with,the,fully,qualified,java,class,name,method,argument,types,method,return,types,and,field,types,must,be,specified,with,painless,type,names,def,fully,qualified,or,short,as,described,earlier,the,following,example,is,used,to,create,a,single,whitelist,text,file,code,primitive,types,class,int,int,complex,types,class,my,package,example,constructors,int,def,def,example,def,method,example,add,int,def,int,add,example,example,void,example,augmented,example,some,other,class,sub,example,int,def,fields,int,value0,int,value1,def,value2;public,static,whitelist,load,from,resource,files,class,resource,string,filepaths,list,whitelist,class,whitelist,structs,new,array,list,for,string,filepath,filepaths,string,line,int,number,1,try,line,number,reader,reader,new,line,number,reader,new,input,stream,reader,resource,get,resource,as,stream,filepath,standard,charsets,string,whitelist,struct,origin,null,string,java,class,name,null,boolean,only,fqnjava,class,name,false,list,whitelist,constructor,whitelist,constructors,null,list,whitelist,method,whitelist,methods,null,list,whitelist,field,whitelist,fields,null,while,line,reader,read,line,null,number,reader,get,line,number,line,line,trim,if,line,length,0,line,char,at,0,continue,if,line,starts,with,class,if,line,ends,with,false,throw,new,illegal,argument,exception,invalid,class,definition,failed,to,parse,class,opening,bracket,line,string,tokens,line,substring,5,line,length,1,trim,split,s,if,tokens,length,2,equals,tokens,1,only,fqnjava,class,name,true,else,if,tokens,length,1,throw,new,illegal,argument,exception,invalid,class,definition,failed,to,parse,class,name,line,whitelist,struct,origin,filepath,number,java,class,name,tokens,0,whitelist,constructors,new,array,list,whitelist,methods,new,array,list,whitelist,fields,new,array,list,else,if,line,equals,if,java,class,name,null,throw,new,illegal,argument,exception,invalid,class,definition,extraneous,closing,bracket,whitelist,structs,add,new,whitelist,class,whitelist,struct,origin,java,class,name,only,fqnjava,class,name,whitelist,constructors,whitelist,methods,whitelist,fields,whitelist,struct,origin,null,java,class,name,null,only,fqnjava,class,name,false,whitelist,constructors,null,whitelist,methods,null,whitelist,fields,null,else,string,origin,filepath,number,if,java,class,name,null,throw,new,illegal,argument,exception,invalid,object,definition,expected,a,class,name,line,if,line,starts,with,if,line,ends,with,false,throw,new,illegal,argument,exception,invalid,constructor,definition,expected,a,closing,parenthesis,line,string,tokens,line,substring,1,line,length,1,replace,all,s,split,if,equals,tokens,0,tokens,new,string,0,whitelist,constructors,add,new,whitelist,constructor,origin,arrays,as,list,tokens,else,if,line,contains,if,line,ends,with,false,throw,new,illegal,argument,exception,invalid,method,definition,expected,a,closing,parenthesis,line,int,parameter,index,line,index,of,string,tokens,line,trim,substring,0,parameter,index,split,s,string,java,method,name,string,java,augmented,class,name,if,tokens,length,2,java,method,name,tokens,1,java,augmented,class,name,null,else,if,tokens,length,3,java,method,name,tokens,2,java,augmented,class,name,tokens,1,else,throw,new,illegal,argument,exception,invalid,method,definition,unexpected,format,line,string,painless,return,type,name,tokens,0,tokens,line,substring,parameter,index,1,line,length,1,replace,all,s,split,if,equals,tokens,0,tokens,new,string,0,whitelist,methods,add,new,whitelist,method,origin,java,augmented,class,name,java,method,name,painless,return,type,name,arrays,as,list,tokens,else,string,tokens,line,split,s,if,tokens,length,2,throw,new,illegal,argument,exception,invalid,field,definition,unexpected,format,line,whitelist,fields,add,new,whitelist,field,origin,tokens,1,tokens,0,if,java,class,name,null,throw,new,illegal,argument,exception,invalid,class,definition,expected,closing,bracket,catch,exception,exception,throw,new,runtime,exception,error,in,filepath,at,line,number,exception,class,loader,loader,access,controller,do,privileged,privileged,action,class,loader,resource,get,class,loader,return,new,whitelist,loader,whitelist,structs
WhitelistLoader -> public static Whitelist loadFromResourceFiles(Class<?> resource, String... filepaths);1534176840;Loads and creates a {@link Whitelist} from one to many text files. The file paths are passed in as an array of_{@link String}s with a single {@link Class} to be be used to load the resources where each {@link String}_is the path of a single text file. The {@link Class}'s {@link ClassLoader} will be used to lookup the Java_reflection objects for each individual {@link Class}, {@link Constructor}, {@link Method}, and {@link Field}_specified as part of the whitelist in the text file.__A single pass is made through each file to collect all the information about each class, constructor, method,_and field. Most validation will be done at a later point after all whitelists have been gathered and their_merging takes place.__A painless type name is one of the following:_<ul>_<li> def - The Painless dynamic type which is automatically included without a need to be_whitelisted. </li>_<li> fully-qualified Java type name - Any whitelisted Java class will have the equivalent name as_a Painless type name with the exception that any dollar symbols used as part of inner classes will_be replaced with dot symbols. </li>_<li> short Java type name - The text after the final dot symbol of any specified Java class. A_short type Java name may be excluded by using the 'only_fqn' token during Painless class parsing_as described later. </li>_</ul>__The following can be parsed from each whitelist text file:_<ul>_<li> Blank lines will be ignored by the parser. </li>_<li> Comments may be created starting with a pound '#' symbol and end with a newline. These will_be ignored by the parser. </li>_<li> Primitive types may be specified starting with 'class' and followed by the Java type name,_an opening bracket, a newline, a closing bracket, and a final newline. </li>_<li> Complex types may be specified starting with 'class' and followed the fully-qualified Java_class name, optionally followed by an 'only_fqn' token, an opening bracket, a newline,_constructor/method/field specifications, a closing bracket, and a final newline. Within a complex_type the following may be parsed:_<ul>_<li> A constructor may be specified starting with an opening parenthesis, followed by a_comma-delimited list of Painless type names corresponding to the type/class names for_the equivalent Java parameter types (these must be whitelisted as well), a closing_parenthesis, and a newline. </li>_<li> A method may be specified starting with a Painless type name for the return type,_followed by the Java name of the method (which will also be the Painless name for the_method), an opening parenthesis, a comma-delimited list of Painless type names_corresponding to the type/class names for the equivalent Java parameter types_(these must be whitelisted as well), a closing parenthesis, and a newline. </li>_<li> An augmented method may be specified starting with a Painless type name for the return_type, followed by the fully qualified Java name of the class the augmented method is_part of (this class does not need to be whitelisted), the Java name of the method_(which will also be the Painless name for the method), an opening parenthesis, a_comma-delimited list of Painless type names corresponding to the type/class names_for the equivalent Java parameter types (these must be whitelisted as well), a closing_parenthesis, and a newline. </li>_<li>A field may be specified starting with a Painless type name for the equivalent Java type_of the field, followed by the Java name of the field (which all be the Painless name_for the field), and a newline. </li>_</ul>_</ul>__Note there must be a one-to-one correspondence of Painless type names to Java type/class names._If the same Painless type is defined across multiple files and the Java class is the same, all_specified constructors, methods, and fields will be merged into a single Painless type. The_Painless dynamic type, 'def', used as part of constructor, method, and field definitions will_be appropriately parsed and handled. Painless complex types must be specified with the_fully-qualified Java class name. Method argument types, method return types, and field types_must be specified with Painless type names (def, fully-qualified, or short) as described earlier.__The following example is used to create a single whitelist text file:__{@code_# primitive types__class int -> int {___# complex types__class my.package.Example only_fqn {_# constructors__(int)_(def, def)_(Example, def)__# method_Example add(int, def)_int add(Example, Example)_void example()__# augmented_Example some.other.Class sub(Example, int, def)__# fields_int value0_int value1_def value2;public static Whitelist loadFromResourceFiles(Class<?> resource, String... filepaths) {_        List<WhitelistClass> whitelistClasses = new ArrayList<>()___        _        _        for (String filepath : filepaths) {_            String line__            int number = -1___            try (LineNumberReader reader = new LineNumberReader(_                new InputStreamReader(resource.getResourceAsStream(filepath), StandardCharsets.UTF_8))) {__                String whitelistClassOrigin = null__                String javaClassName = null__                boolean onlyFQNJavaClassName = false__                List<WhitelistConstructor> whitelistConstructors = null__                List<WhitelistMethod> whitelistMethods = null__                List<WhitelistField> whitelistFields = null___                while ((line = reader.readLine()) != null) {_                    number = reader.getLineNumber()__                    line = line.trim()___                    _                    if (line.length() == 0 || line.charAt(0) == '#') {_                        continue__                    }__                    _                    _                    if (line.startsWith("class ")) {_                        _                        if (line.endsWith("{") == false) {_                            throw new IllegalArgumentException(_                                "invalid class definition: failed to parse class opening bracket [" + line + "]")__                        }__                        _                        String[] tokens = line.substring(5, line.length() - 1).trim().split("\\s+")___                        _                        if (tokens.length == 2 && "only_fqn".equals(tokens[1])) {_                            onlyFQNJavaClassName = true__                        } else if (tokens.length != 1) {_                            throw new IllegalArgumentException("invalid class definition: failed to parse class name [" + line + "]")__                        }__                        whitelistClassOrigin = "[" + filepath + "]:[" + number + "]"__                        javaClassName = tokens[0]___                        _                        whitelistConstructors = new ArrayList<>()__                        whitelistMethods = new ArrayList<>()__                        whitelistFields = new ArrayList<>()___                    _                    _                    _                    } else if (line.equals("}")) {_                        if (javaClassName == null) {_                            throw new IllegalArgumentException("invalid class definition: extraneous closing bracket")__                        }__                        whitelistClasses.add(new WhitelistClass(whitelistClassOrigin, javaClassName, onlyFQNJavaClassName,_                            whitelistConstructors, whitelistMethods, whitelistFields))___                        _                        whitelistClassOrigin = null__                        javaClassName = null__                        onlyFQNJavaClassName = false__                        whitelistConstructors = null__                        whitelistMethods = null__                        whitelistFields = null___                    _                    } else {_                        _                        String origin = "[" + filepath + "]:[" + number + "]"___                        _                        if (javaClassName == null) {_                            throw new IllegalArgumentException("invalid object definition: expected a class name [" + line + "]")__                        }__                        _                        _                        if (line.startsWith("(")) {_                            _                            if (line.endsWith(")") == false) {_                                throw new IllegalArgumentException(_                                    "invalid constructor definition: expected a closing parenthesis [" + line + "]")__                            }__                            _                            String[] tokens = line.substring(1, line.length() - 1).replaceAll("\\s+", "").split(",")___                            _                            if ("".equals(tokens[0])) {_                                tokens = new String[0]__                            }__                            whitelistConstructors.add(new WhitelistConstructor(origin, Arrays.asList(tokens)))___                        _                        _                        } else if (line.contains("(")) {_                            _                            if (line.endsWith(")") == false) {_                                throw new IllegalArgumentException(_                                    "invalid method definition: expected a closing parenthesis [" + line + "]")__                            }__                            _                            int parameterIndex = line.indexOf('(')__                            String[] tokens = line.trim().substring(0, parameterIndex).split("\\s+")___                            String javaMethodName__                            String javaAugmentedClassName___                            _                            if (tokens.length == 2) {_                                javaMethodName = tokens[1]__                                javaAugmentedClassName = null__                            } else if (tokens.length == 3) {_                                javaMethodName = tokens[2]__                                javaAugmentedClassName = tokens[1]__                            } else {_                                throw new IllegalArgumentException("invalid method definition: unexpected format [" + line + "]")__                            }__                            String painlessReturnTypeName = tokens[0]___                            _                            tokens = line.substring(parameterIndex + 1, line.length() - 1).replaceAll("\\s+", "").split(",")___                            _                            if ("".equals(tokens[0])) {_                                tokens = new String[0]__                            }__                            whitelistMethods.add(new WhitelistMethod(origin, javaAugmentedClassName, javaMethodName,_                                painlessReturnTypeName, Arrays.asList(tokens)))___                        _                        _                        } else {_                            _                            String[] tokens = line.split("\\s+")___                            _                            if (tokens.length != 2) {_                                throw new IllegalArgumentException("invalid field definition: unexpected format [" + line + "]")__                            }__                            whitelistFields.add(new WhitelistField(origin, tokens[1], tokens[0]))__                        }_                    }_                }__                _                if (javaClassName != null) {_                    throw new IllegalArgumentException("invalid class definition: expected closing bracket")__                }_            } catch (Exception exception) {_                throw new RuntimeException("error in [" + filepath + "] at line [" + number + "]", exception)__            }_        }_        ClassLoader loader = AccessController.doPrivileged((PrivilegedAction<ClassLoader>)resource::getClassLoader)___        return new Whitelist(loader, whitelistClasses)__    };loads,and,creates,a,link,whitelist,from,one,to,many,text,files,the,file,paths,are,passed,in,as,an,array,of,link,string,s,with,a,single,link,class,to,be,be,used,to,load,the,resources,where,each,link,string,is,the,path,of,a,single,text,file,the,link,class,s,link,class,loader,will,be,used,to,lookup,the,java,reflection,objects,for,each,individual,link,class,link,constructor,link,method,and,link,field,specified,as,part,of,the,whitelist,in,the,text,file,a,single,pass,is,made,through,each,file,to,collect,all,the,information,about,each,class,constructor,method,and,field,most,validation,will,be,done,at,a,later,point,after,all,whitelists,have,been,gathered,and,their,merging,takes,place,a,painless,type,name,is,one,of,the,following,ul,li,def,the,painless,dynamic,type,which,is,automatically,included,without,a,need,to,be,whitelisted,li,li,fully,qualified,java,type,name,any,whitelisted,java,class,will,have,the,equivalent,name,as,a,painless,type,name,with,the,exception,that,any,dollar,symbols,used,as,part,of,inner,classes,will,be,replaced,with,dot,symbols,li,li,short,java,type,name,the,text,after,the,final,dot,symbol,of,any,specified,java,class,a,short,type,java,name,may,be,excluded,by,using,the,token,during,painless,class,parsing,as,described,later,li,ul,the,following,can,be,parsed,from,each,whitelist,text,file,ul,li,blank,lines,will,be,ignored,by,the,parser,li,li,comments,may,be,created,starting,with,a,pound,symbol,and,end,with,a,newline,these,will,be,ignored,by,the,parser,li,li,primitive,types,may,be,specified,starting,with,class,and,followed,by,the,java,type,name,an,opening,bracket,a,newline,a,closing,bracket,and,a,final,newline,li,li,complex,types,may,be,specified,starting,with,class,and,followed,the,fully,qualified,java,class,name,optionally,followed,by,an,token,an,opening,bracket,a,newline,constructor,method,field,specifications,a,closing,bracket,and,a,final,newline,within,a,complex,type,the,following,may,be,parsed,ul,li,a,constructor,may,be,specified,starting,with,an,opening,parenthesis,followed,by,a,comma,delimited,list,of,painless,type,names,corresponding,to,the,type,class,names,for,the,equivalent,java,parameter,types,these,must,be,whitelisted,as,well,a,closing,parenthesis,and,a,newline,li,li,a,method,may,be,specified,starting,with,a,painless,type,name,for,the,return,type,followed,by,the,java,name,of,the,method,which,will,also,be,the,painless,name,for,the,method,an,opening,parenthesis,a,comma,delimited,list,of,painless,type,names,corresponding,to,the,type,class,names,for,the,equivalent,java,parameter,types,these,must,be,whitelisted,as,well,a,closing,parenthesis,and,a,newline,li,li,an,augmented,method,may,be,specified,starting,with,a,painless,type,name,for,the,return,type,followed,by,the,fully,qualified,java,name,of,the,class,the,augmented,method,is,part,of,this,class,does,not,need,to,be,whitelisted,the,java,name,of,the,method,which,will,also,be,the,painless,name,for,the,method,an,opening,parenthesis,a,comma,delimited,list,of,painless,type,names,corresponding,to,the,type,class,names,for,the,equivalent,java,parameter,types,these,must,be,whitelisted,as,well,a,closing,parenthesis,and,a,newline,li,li,a,field,may,be,specified,starting,with,a,painless,type,name,for,the,equivalent,java,type,of,the,field,followed,by,the,java,name,of,the,field,which,all,be,the,painless,name,for,the,field,and,a,newline,li,ul,ul,note,there,must,be,a,one,to,one,correspondence,of,painless,type,names,to,java,type,class,names,if,the,same,painless,type,is,defined,across,multiple,files,and,the,java,class,is,the,same,all,specified,constructors,methods,and,fields,will,be,merged,into,a,single,painless,type,the,painless,dynamic,type,def,used,as,part,of,constructor,method,and,field,definitions,will,be,appropriately,parsed,and,handled,painless,complex,types,must,be,specified,with,the,fully,qualified,java,class,name,method,argument,types,method,return,types,and,field,types,must,be,specified,with,painless,type,names,def,fully,qualified,or,short,as,described,earlier,the,following,example,is,used,to,create,a,single,whitelist,text,file,code,primitive,types,class,int,int,complex,types,class,my,package,example,constructors,int,def,def,example,def,method,example,add,int,def,int,add,example,example,void,example,augmented,example,some,other,class,sub,example,int,def,fields,int,value0,int,value1,def,value2;public,static,whitelist,load,from,resource,files,class,resource,string,filepaths,list,whitelist,class,whitelist,classes,new,array,list,for,string,filepath,filepaths,string,line,int,number,1,try,line,number,reader,reader,new,line,number,reader,new,input,stream,reader,resource,get,resource,as,stream,filepath,standard,charsets,string,whitelist,class,origin,null,string,java,class,name,null,boolean,only,fqnjava,class,name,false,list,whitelist,constructor,whitelist,constructors,null,list,whitelist,method,whitelist,methods,null,list,whitelist,field,whitelist,fields,null,while,line,reader,read,line,null,number,reader,get,line,number,line,line,trim,if,line,length,0,line,char,at,0,continue,if,line,starts,with,class,if,line,ends,with,false,throw,new,illegal,argument,exception,invalid,class,definition,failed,to,parse,class,opening,bracket,line,string,tokens,line,substring,5,line,length,1,trim,split,s,if,tokens,length,2,equals,tokens,1,only,fqnjava,class,name,true,else,if,tokens,length,1,throw,new,illegal,argument,exception,invalid,class,definition,failed,to,parse,class,name,line,whitelist,class,origin,filepath,number,java,class,name,tokens,0,whitelist,constructors,new,array,list,whitelist,methods,new,array,list,whitelist,fields,new,array,list,else,if,line,equals,if,java,class,name,null,throw,new,illegal,argument,exception,invalid,class,definition,extraneous,closing,bracket,whitelist,classes,add,new,whitelist,class,whitelist,class,origin,java,class,name,only,fqnjava,class,name,whitelist,constructors,whitelist,methods,whitelist,fields,whitelist,class,origin,null,java,class,name,null,only,fqnjava,class,name,false,whitelist,constructors,null,whitelist,methods,null,whitelist,fields,null,else,string,origin,filepath,number,if,java,class,name,null,throw,new,illegal,argument,exception,invalid,object,definition,expected,a,class,name,line,if,line,starts,with,if,line,ends,with,false,throw,new,illegal,argument,exception,invalid,constructor,definition,expected,a,closing,parenthesis,line,string,tokens,line,substring,1,line,length,1,replace,all,s,split,if,equals,tokens,0,tokens,new,string,0,whitelist,constructors,add,new,whitelist,constructor,origin,arrays,as,list,tokens,else,if,line,contains,if,line,ends,with,false,throw,new,illegal,argument,exception,invalid,method,definition,expected,a,closing,parenthesis,line,int,parameter,index,line,index,of,string,tokens,line,trim,substring,0,parameter,index,split,s,string,java,method,name,string,java,augmented,class,name,if,tokens,length,2,java,method,name,tokens,1,java,augmented,class,name,null,else,if,tokens,length,3,java,method,name,tokens,2,java,augmented,class,name,tokens,1,else,throw,new,illegal,argument,exception,invalid,method,definition,unexpected,format,line,string,painless,return,type,name,tokens,0,tokens,line,substring,parameter,index,1,line,length,1,replace,all,s,split,if,equals,tokens,0,tokens,new,string,0,whitelist,methods,add,new,whitelist,method,origin,java,augmented,class,name,java,method,name,painless,return,type,name,arrays,as,list,tokens,else,string,tokens,line,split,s,if,tokens,length,2,throw,new,illegal,argument,exception,invalid,field,definition,unexpected,format,line,whitelist,fields,add,new,whitelist,field,origin,tokens,1,tokens,0,if,java,class,name,null,throw,new,illegal,argument,exception,invalid,class,definition,expected,closing,bracket,catch,exception,exception,throw,new,runtime,exception,error,in,filepath,at,line,number,exception,class,loader,loader,access,controller,do,privileged,privileged,action,class,loader,resource,get,class,loader,return,new,whitelist,loader,whitelist,classes
WhitelistLoader -> public static Whitelist loadFromResourceFiles(Class<?> resource, String... filepaths);1534338685;Loads and creates a {@link Whitelist} from one to many text files. The file paths are passed in as an array of_{@link String}s with a single {@link Class} to be be used to load the resources where each {@link String}_is the path of a single text file. The {@link Class}'s {@link ClassLoader} will be used to lookup the Java_reflection objects for each individual {@link Class}, {@link Constructor}, {@link Method}, and {@link Field}_specified as part of the whitelist in the text file.__A single pass is made through each file to collect all the information about each class, constructor, method,_and field. Most validation will be done at a later point after all whitelists have been gathered and their_merging takes place.__A painless type name is one of the following:_<ul>_<li> def - The Painless dynamic type which is automatically included without a need to be_whitelisted. </li>_<li> fully-qualified Java type name - Any whitelisted Java class will have the equivalent name as_a Painless type name with the exception that any dollar symbols used as part of inner classes will_be replaced with dot symbols. </li>_<li> short Java type name - The text after the final dot symbol of any specified Java class. A_short type Java name may be excluded by using the 'no_import' token during Painless class parsing_as described later. </li>_</ul>__The following can be parsed from each whitelist text file:_<ul>_<li> Blank lines will be ignored by the parser. </li>_<li> Comments may be created starting with a pound '#' symbol and end with a newline. These will_be ignored by the parser. </li>_<li> Primitive types may be specified starting with 'class' and followed by the Java type name,_an opening bracket, a newline, a closing bracket, and a final newline. </li>_<li> Complex types may be specified starting with 'class' and followed the fully-qualified Java_class name, optionally followed by an 'no_import' token, an opening bracket, a newline,_constructor/method/field specifications, a closing bracket, and a final newline. Within a complex_type the following may be parsed:_<ul>_<li> A constructor may be specified starting with an opening parenthesis, followed by a_comma-delimited list of Painless type names corresponding to the type/class names for_the equivalent Java parameter types (these must be whitelisted as well), a closing_parenthesis, and a newline. </li>_<li> A method may be specified starting with a Painless type name for the return type,_followed by the Java name of the method (which will also be the Painless name for the_method), an opening parenthesis, a comma-delimited list of Painless type names_corresponding to the type/class names for the equivalent Java parameter types_(these must be whitelisted as well), a closing parenthesis, and a newline. </li>_<li> An augmented method may be specified starting with a Painless type name for the return_type, followed by the fully qualified Java name of the class the augmented method is_part of (this class does not need to be whitelisted), the Java name of the method_(which will also be the Painless name for the method), an opening parenthesis, a_comma-delimited list of Painless type names corresponding to the type/class names_for the equivalent Java parameter types (these must be whitelisted as well), a closing_parenthesis, and a newline. </li>_<li>A field may be specified starting with a Painless type name for the equivalent Java type_of the field, followed by the Java name of the field (which all be the Painless name_for the field), and a newline. </li>_</ul>_</ul>__Note there must be a one-to-one correspondence of Painless type names to Java type/class names._If the same Painless type is defined across multiple files and the Java class is the same, all_specified constructors, methods, and fields will be merged into a single Painless type. The_Painless dynamic type, 'def', used as part of constructor, method, and field definitions will_be appropriately parsed and handled. Painless complex types must be specified with the_fully-qualified Java class name. Method argument types, method return types, and field types_must be specified with Painless type names (def, fully-qualified, or short) as described earlier.__The following example is used to create a single whitelist text file:__{@code_# primitive types__class int -> int {___# complex types__class my.package.Example no_import {_# constructors__(int)_(def, def)_(Example, def)__# method_Example add(int, def)_int add(Example, Example)_void example()__# augmented_Example some.other.Class sub(Example, int, def)__# fields_int value0_int value1_def value2;public static Whitelist loadFromResourceFiles(Class<?> resource, String... filepaths) {_        List<WhitelistClass> whitelistClasses = new ArrayList<>()___        _        _        for (String filepath : filepaths) {_            String line__            int number = -1___            try (LineNumberReader reader = new LineNumberReader(_                new InputStreamReader(resource.getResourceAsStream(filepath), StandardCharsets.UTF_8))) {__                String whitelistClassOrigin = null__                String javaClassName = null__                boolean noImport = false__                List<WhitelistConstructor> whitelistConstructors = null__                List<WhitelistMethod> whitelistMethods = null__                List<WhitelistField> whitelistFields = null___                while ((line = reader.readLine()) != null) {_                    number = reader.getLineNumber()__                    line = line.trim()___                    _                    if (line.length() == 0 || line.charAt(0) == '#') {_                        continue__                    }__                    _                    _                    if (line.startsWith("class ")) {_                        _                        if (line.endsWith("{") == false) {_                            throw new IllegalArgumentException(_                                "invalid class definition: failed to parse class opening bracket [" + line + "]")__                        }__                        _                        String[] tokens = line.substring(5, line.length() - 1).trim().split("\\s+")___                        _                        if (tokens.length == 2 && "no_import".equals(tokens[1])) {_                            noImport = true__                        } else if (tokens.length != 1) {_                            throw new IllegalArgumentException("invalid class definition: failed to parse class name [" + line + "]")__                        }__                        whitelistClassOrigin = "[" + filepath + "]:[" + number + "]"__                        javaClassName = tokens[0]___                        _                        whitelistConstructors = new ArrayList<>()__                        whitelistMethods = new ArrayList<>()__                        whitelistFields = new ArrayList<>()___                    _                    _                    _                    } else if (line.equals("}")) {_                        if (javaClassName == null) {_                            throw new IllegalArgumentException("invalid class definition: extraneous closing bracket")__                        }__                        whitelistClasses.add(new WhitelistClass(whitelistClassOrigin, javaClassName, noImport,_                            whitelistConstructors, whitelistMethods, whitelistFields))___                        _                        whitelistClassOrigin = null__                        javaClassName = null__                        noImport = false__                        whitelistConstructors = null__                        whitelistMethods = null__                        whitelistFields = null___                    _                    } else {_                        _                        String origin = "[" + filepath + "]:[" + number + "]"___                        _                        if (javaClassName == null) {_                            throw new IllegalArgumentException("invalid object definition: expected a class name [" + line + "]")__                        }__                        _                        _                        if (line.startsWith("(")) {_                            _                            if (line.endsWith(")") == false) {_                                throw new IllegalArgumentException(_                                    "invalid constructor definition: expected a closing parenthesis [" + line + "]")__                            }__                            _                            String[] tokens = line.substring(1, line.length() - 1).replaceAll("\\s+", "").split(",")___                            _                            if ("".equals(tokens[0])) {_                                tokens = new String[0]__                            }__                            whitelistConstructors.add(new WhitelistConstructor(origin, Arrays.asList(tokens)))___                        _                        _                        } else if (line.contains("(")) {_                            _                            if (line.endsWith(")") == false) {_                                throw new IllegalArgumentException(_                                    "invalid method definition: expected a closing parenthesis [" + line + "]")__                            }__                            _                            int parameterIndex = line.indexOf('(')__                            String[] tokens = line.trim().substring(0, parameterIndex).split("\\s+")___                            String javaMethodName__                            String javaAugmentedClassName___                            _                            if (tokens.length == 2) {_                                javaMethodName = tokens[1]__                                javaAugmentedClassName = null__                            } else if (tokens.length == 3) {_                                javaMethodName = tokens[2]__                                javaAugmentedClassName = tokens[1]__                            } else {_                                throw new IllegalArgumentException("invalid method definition: unexpected format [" + line + "]")__                            }__                            String painlessReturnTypeName = tokens[0]___                            _                            tokens = line.substring(parameterIndex + 1, line.length() - 1).replaceAll("\\s+", "").split(",")___                            _                            if ("".equals(tokens[0])) {_                                tokens = new String[0]__                            }__                            whitelistMethods.add(new WhitelistMethod(origin, javaAugmentedClassName, javaMethodName,_                                painlessReturnTypeName, Arrays.asList(tokens)))___                        _                        _                        } else {_                            _                            String[] tokens = line.split("\\s+")___                            _                            if (tokens.length != 2) {_                                throw new IllegalArgumentException("invalid field definition: unexpected format [" + line + "]")__                            }__                            whitelistFields.add(new WhitelistField(origin, tokens[1], tokens[0]))__                        }_                    }_                }__                _                if (javaClassName != null) {_                    throw new IllegalArgumentException("invalid class definition: expected closing bracket")__                }_            } catch (Exception exception) {_                throw new RuntimeException("error in [" + filepath + "] at line [" + number + "]", exception)__            }_        }_        ClassLoader loader = AccessController.doPrivileged((PrivilegedAction<ClassLoader>)resource::getClassLoader)___        return new Whitelist(loader, whitelistClasses)__    };loads,and,creates,a,link,whitelist,from,one,to,many,text,files,the,file,paths,are,passed,in,as,an,array,of,link,string,s,with,a,single,link,class,to,be,be,used,to,load,the,resources,where,each,link,string,is,the,path,of,a,single,text,file,the,link,class,s,link,class,loader,will,be,used,to,lookup,the,java,reflection,objects,for,each,individual,link,class,link,constructor,link,method,and,link,field,specified,as,part,of,the,whitelist,in,the,text,file,a,single,pass,is,made,through,each,file,to,collect,all,the,information,about,each,class,constructor,method,and,field,most,validation,will,be,done,at,a,later,point,after,all,whitelists,have,been,gathered,and,their,merging,takes,place,a,painless,type,name,is,one,of,the,following,ul,li,def,the,painless,dynamic,type,which,is,automatically,included,without,a,need,to,be,whitelisted,li,li,fully,qualified,java,type,name,any,whitelisted,java,class,will,have,the,equivalent,name,as,a,painless,type,name,with,the,exception,that,any,dollar,symbols,used,as,part,of,inner,classes,will,be,replaced,with,dot,symbols,li,li,short,java,type,name,the,text,after,the,final,dot,symbol,of,any,specified,java,class,a,short,type,java,name,may,be,excluded,by,using,the,token,during,painless,class,parsing,as,described,later,li,ul,the,following,can,be,parsed,from,each,whitelist,text,file,ul,li,blank,lines,will,be,ignored,by,the,parser,li,li,comments,may,be,created,starting,with,a,pound,symbol,and,end,with,a,newline,these,will,be,ignored,by,the,parser,li,li,primitive,types,may,be,specified,starting,with,class,and,followed,by,the,java,type,name,an,opening,bracket,a,newline,a,closing,bracket,and,a,final,newline,li,li,complex,types,may,be,specified,starting,with,class,and,followed,the,fully,qualified,java,class,name,optionally,followed,by,an,token,an,opening,bracket,a,newline,constructor,method,field,specifications,a,closing,bracket,and,a,final,newline,within,a,complex,type,the,following,may,be,parsed,ul,li,a,constructor,may,be,specified,starting,with,an,opening,parenthesis,followed,by,a,comma,delimited,list,of,painless,type,names,corresponding,to,the,type,class,names,for,the,equivalent,java,parameter,types,these,must,be,whitelisted,as,well,a,closing,parenthesis,and,a,newline,li,li,a,method,may,be,specified,starting,with,a,painless,type,name,for,the,return,type,followed,by,the,java,name,of,the,method,which,will,also,be,the,painless,name,for,the,method,an,opening,parenthesis,a,comma,delimited,list,of,painless,type,names,corresponding,to,the,type,class,names,for,the,equivalent,java,parameter,types,these,must,be,whitelisted,as,well,a,closing,parenthesis,and,a,newline,li,li,an,augmented,method,may,be,specified,starting,with,a,painless,type,name,for,the,return,type,followed,by,the,fully,qualified,java,name,of,the,class,the,augmented,method,is,part,of,this,class,does,not,need,to,be,whitelisted,the,java,name,of,the,method,which,will,also,be,the,painless,name,for,the,method,an,opening,parenthesis,a,comma,delimited,list,of,painless,type,names,corresponding,to,the,type,class,names,for,the,equivalent,java,parameter,types,these,must,be,whitelisted,as,well,a,closing,parenthesis,and,a,newline,li,li,a,field,may,be,specified,starting,with,a,painless,type,name,for,the,equivalent,java,type,of,the,field,followed,by,the,java,name,of,the,field,which,all,be,the,painless,name,for,the,field,and,a,newline,li,ul,ul,note,there,must,be,a,one,to,one,correspondence,of,painless,type,names,to,java,type,class,names,if,the,same,painless,type,is,defined,across,multiple,files,and,the,java,class,is,the,same,all,specified,constructors,methods,and,fields,will,be,merged,into,a,single,painless,type,the,painless,dynamic,type,def,used,as,part,of,constructor,method,and,field,definitions,will,be,appropriately,parsed,and,handled,painless,complex,types,must,be,specified,with,the,fully,qualified,java,class,name,method,argument,types,method,return,types,and,field,types,must,be,specified,with,painless,type,names,def,fully,qualified,or,short,as,described,earlier,the,following,example,is,used,to,create,a,single,whitelist,text,file,code,primitive,types,class,int,int,complex,types,class,my,package,example,constructors,int,def,def,example,def,method,example,add,int,def,int,add,example,example,void,example,augmented,example,some,other,class,sub,example,int,def,fields,int,value0,int,value1,def,value2;public,static,whitelist,load,from,resource,files,class,resource,string,filepaths,list,whitelist,class,whitelist,classes,new,array,list,for,string,filepath,filepaths,string,line,int,number,1,try,line,number,reader,reader,new,line,number,reader,new,input,stream,reader,resource,get,resource,as,stream,filepath,standard,charsets,string,whitelist,class,origin,null,string,java,class,name,null,boolean,no,import,false,list,whitelist,constructor,whitelist,constructors,null,list,whitelist,method,whitelist,methods,null,list,whitelist,field,whitelist,fields,null,while,line,reader,read,line,null,number,reader,get,line,number,line,line,trim,if,line,length,0,line,char,at,0,continue,if,line,starts,with,class,if,line,ends,with,false,throw,new,illegal,argument,exception,invalid,class,definition,failed,to,parse,class,opening,bracket,line,string,tokens,line,substring,5,line,length,1,trim,split,s,if,tokens,length,2,equals,tokens,1,no,import,true,else,if,tokens,length,1,throw,new,illegal,argument,exception,invalid,class,definition,failed,to,parse,class,name,line,whitelist,class,origin,filepath,number,java,class,name,tokens,0,whitelist,constructors,new,array,list,whitelist,methods,new,array,list,whitelist,fields,new,array,list,else,if,line,equals,if,java,class,name,null,throw,new,illegal,argument,exception,invalid,class,definition,extraneous,closing,bracket,whitelist,classes,add,new,whitelist,class,whitelist,class,origin,java,class,name,no,import,whitelist,constructors,whitelist,methods,whitelist,fields,whitelist,class,origin,null,java,class,name,null,no,import,false,whitelist,constructors,null,whitelist,methods,null,whitelist,fields,null,else,string,origin,filepath,number,if,java,class,name,null,throw,new,illegal,argument,exception,invalid,object,definition,expected,a,class,name,line,if,line,starts,with,if,line,ends,with,false,throw,new,illegal,argument,exception,invalid,constructor,definition,expected,a,closing,parenthesis,line,string,tokens,line,substring,1,line,length,1,replace,all,s,split,if,equals,tokens,0,tokens,new,string,0,whitelist,constructors,add,new,whitelist,constructor,origin,arrays,as,list,tokens,else,if,line,contains,if,line,ends,with,false,throw,new,illegal,argument,exception,invalid,method,definition,expected,a,closing,parenthesis,line,int,parameter,index,line,index,of,string,tokens,line,trim,substring,0,parameter,index,split,s,string,java,method,name,string,java,augmented,class,name,if,tokens,length,2,java,method,name,tokens,1,java,augmented,class,name,null,else,if,tokens,length,3,java,method,name,tokens,2,java,augmented,class,name,tokens,1,else,throw,new,illegal,argument,exception,invalid,method,definition,unexpected,format,line,string,painless,return,type,name,tokens,0,tokens,line,substring,parameter,index,1,line,length,1,replace,all,s,split,if,equals,tokens,0,tokens,new,string,0,whitelist,methods,add,new,whitelist,method,origin,java,augmented,class,name,java,method,name,painless,return,type,name,arrays,as,list,tokens,else,string,tokens,line,split,s,if,tokens,length,2,throw,new,illegal,argument,exception,invalid,field,definition,unexpected,format,line,whitelist,fields,add,new,whitelist,field,origin,tokens,1,tokens,0,if,java,class,name,null,throw,new,illegal,argument,exception,invalid,class,definition,expected,closing,bracket,catch,exception,exception,throw,new,runtime,exception,error,in,filepath,at,line,number,exception,class,loader,loader,access,controller,do,privileged,privileged,action,class,loader,resource,get,class,loader,return,new,whitelist,loader,whitelist,classes
WhitelistLoader -> public static Whitelist loadFromResourceFiles(Class<?> resource, String... filepaths);1535666657;Loads and creates a {@link Whitelist} from one to many text files. The file paths are passed in as an array of_{@link String}s with a single {@link Class} to be be used to load the resources where each {@link String}_is the path of a single text file. The {@link Class}'s {@link ClassLoader} will be used to lookup the Java_reflection objects for each individual {@link Class}, {@link Constructor}, {@link Method}, and {@link Field}_specified as part of the whitelist in the text file.__A single pass is made through each file to collect all the information about each class, constructor, method,_and field. Most validation will be done at a later point after all whitelists have been gathered and their_merging takes place.__A painless type name is one of the following:_<ul>_<li> def - The Painless dynamic type which is automatically included without a need to be_whitelisted. </li>_<li> fully-qualified Java type name - Any whitelisted Java class will have the equivalent name as_a Painless type name with the exception that any dollar symbols used as part of inner classes will_be replaced with dot symbols. </li>_<li> short Java type name - The text after the final dot symbol of any specified Java class. A_short type Java name may be excluded by using the 'no_import' token during Painless class parsing_as described later. </li>_</ul>__The following can be parsed from each whitelist text file:_<ul>_<li> Blank lines will be ignored by the parser. </li>_<li> Comments may be created starting with a pound '#' symbol and end with a newline. These will_be ignored by the parser. </li>_<li> Primitive types may be specified starting with 'class' and followed by the Java type name,_an opening bracket, a newline, a closing bracket, and a final newline. </li>_<li> Complex types may be specified starting with 'class' and followed the fully-qualified Java_class name, optionally followed by an 'no_import' token, an opening bracket, a newline,_constructor/method/field specifications, a closing bracket, and a final newline. Within a complex_type the following may be parsed:_<ul>_<li> A constructor may be specified starting with an opening parenthesis, followed by a_comma-delimited list of Painless type names corresponding to the type/class names for_the equivalent Java parameter types (these must be whitelisted as well), a closing_parenthesis, and a newline. </li>_<li> A method may be specified starting with a Painless type name for the return type,_followed by the Java name of the method (which will also be the Painless name for the_method), an opening parenthesis, a comma-delimited list of Painless type names_corresponding to the type/class names for the equivalent Java parameter types_(these must be whitelisted as well), a closing parenthesis, and a newline. </li>_<li> An augmented method may be specified starting with a Painless type name for the return_type, followed by the fully qualified Java name of the class the augmented method is_part of (this class does not need to be whitelisted), the Java name of the method_(which will also be the Painless name for the method), an opening parenthesis, a_comma-delimited list of Painless type names corresponding to the type/class names_for the equivalent Java parameter types (these must be whitelisted as well), a closing_parenthesis, and a newline. </li>_<li>A field may be specified starting with a Painless type name for the equivalent Java type_of the field, followed by the Java name of the field (which all be the Painless name_for the field), and a newline. </li>_</ul>_</ul>__Note there must be a one-to-one correspondence of Painless type names to Java type/class names._If the same Painless type is defined across multiple files and the Java class is the same, all_specified constructors, methods, and fields will be merged into a single Painless type. The_Painless dynamic type, 'def', used as part of constructor, method, and field definitions will_be appropriately parsed and handled. Painless complex types must be specified with the_fully-qualified Java class name. Method argument types, method return types, and field types_must be specified with Painless type names (def, fully-qualified, or short) as described earlier.__The following example is used to create a single whitelist text file:__{@code_# primitive types__class int -> int {___# complex types__class my.package.Example no_import {_# constructors__(int)_(def, def)_(Example, def)__# method_Example add(int, def)_int add(Example, Example)_void example()__# augmented_Example some.other.Class sub(Example, int, def)__# fields_int value0_int value1_def value2;public static Whitelist loadFromResourceFiles(Class<?> resource, String... filepaths) {_        List<WhitelistClass> whitelistClasses = new ArrayList<>()__        List<WhitelistBinding> whitelistBindings = new ArrayList<>()___        _        _        for (String filepath : filepaths) {_            String line__            int number = -1___            try (LineNumberReader reader = new LineNumberReader(_                    new InputStreamReader(resource.getResourceAsStream(filepath), StandardCharsets.UTF_8))) {__                String parseType = null__                String whitelistClassOrigin = null__                String javaClassName = null__                boolean noImport = false__                List<WhitelistConstructor> whitelistConstructors = null__                List<WhitelistMethod> whitelistMethods = null__                List<WhitelistField> whitelistFields = null___                while ((line = reader.readLine()) != null) {_                    number = reader.getLineNumber()__                    line = line.trim()___                    _                    if (line.length() == 0 || line.charAt(0) == '#') {_                        continue__                    }__                    _                    _                    if (line.startsWith("class ")) {_                        _                        if (line.endsWith("{") == false) {_                            throw new IllegalArgumentException(_                                    "invalid class definition: failed to parse class opening bracket [" + line + "]")__                        }__                        if (parseType != null) {_                            throw new IllegalArgumentException("invalid definition: cannot embed class definition [" + line + "]")__                        }__                        _                        String[] tokens = line.substring(5, line.length() - 1).trim().split("\\s+")___                        _                        if (tokens.length == 2 && "no_import".equals(tokens[1])) {_                            noImport = true__                        } else if (tokens.length != 1) {_                            throw new IllegalArgumentException("invalid class definition: failed to parse class name [" + line + "]")__                        }__                        parseType = "class"__                        whitelistClassOrigin = "[" + filepath + "]:[" + number + "]"__                        javaClassName = tokens[0]___                        _                        whitelistConstructors = new ArrayList<>()__                        whitelistMethods = new ArrayList<>()__                        whitelistFields = new ArrayList<>()__                    } else if (line.startsWith("static ")) {_                        _                        if (line.endsWith("{") == false) {_                            throw new IllegalArgumentException(_                                    "invalid static definition: failed to parse static opening bracket [" + line + "]")__                        }__                        if (parseType != null) {_                            throw new IllegalArgumentException("invalid definition: cannot embed static definition [" + line + "]")__                        }__                        parseType = "static"___                    _                    _                    } else if (line.equals("}")) {_                        if (parseType == null) {_                            throw new IllegalArgumentException("invalid definition: extraneous closing bracket")__                        }__                        _                        _                        if ("class".equals(parseType)) {_                            whitelistClasses.add(new WhitelistClass(whitelistClassOrigin, javaClassName, noImport,_                                    whitelistConstructors, whitelistMethods, whitelistFields))___                            whitelistClassOrigin = null__                            javaClassName = null__                            noImport = false__                            whitelistConstructors = null__                            whitelistMethods = null__                            whitelistFields = null__                        }__                        _                        parseType = null___                    _                    _                    } else if ("static".equals(parseType)) {_                        _                        String origin = "[" + filepath + "]:[" + number + "]"___                        _                        int parameterStartIndex = line.indexOf('(')___                        if (parameterStartIndex == -1) {_                            throw new IllegalArgumentException(_                                    "illegal static definition: start of method parameters not found [" + line + "]")__                        }__                        String[] tokens = line.substring(0, parameterStartIndex).trim().split("\\s+")___                        String methodName___                        _                        if (tokens.length == 2) {_                            methodName = tokens[1]__                        } else {_                            throw new IllegalArgumentException("invalid method definition: unexpected format [" + line + "]")__                        }__                        String returnCanonicalTypeName = tokens[0]___                        _                        int parameterEndIndex = line.indexOf(')')___                        if (parameterEndIndex == -1) {_                            throw new IllegalArgumentException(_                                    "illegal static definition: end of method parameters not found [" + line + "]")__                        }__                        String[] canonicalTypeNameParameters =_                                line.substring(parameterStartIndex + 1, parameterEndIndex).replaceAll("\\s+", "").split(",")___                        _                        if ("".equals(canonicalTypeNameParameters[0])) {_                            canonicalTypeNameParameters = new String[0]__                        }__                        _                        tokens = line.substring(parameterEndIndex + 1).trim().split("\\s+")___                        String staticType__                        String targetJavaClassName___                        _                        if (tokens.length == 2) {_                            staticType = tokens[0]__                            targetJavaClassName = tokens[1]__                        } else {_                            throw new IllegalArgumentException("invalid static definition: unexpected format [" + line + "]")__                        }__                        _                        if ("bound_to".equals(staticType) == false) {_                            throw new IllegalArgumentException(_                                    "invalid static definition: unexpected static type [" + staticType + "] [" + line + "]")__                        }__                        whitelistBindings.add(new WhitelistBinding(origin, targetJavaClassName,_                                methodName, returnCanonicalTypeName, Arrays.asList(canonicalTypeNameParameters)))___                    _                    } else if ("class".equals(parseType)) {_                        _                        String origin = "[" + filepath + "]:[" + number + "]"___                        _                        if (parseType == null) {_                            throw new IllegalArgumentException("invalid definition: expected one of ['class', 'static'] [" + line + "]")__                        }__                        _                        _                        if (line.startsWith("(")) {_                            _                            if (line.endsWith(")") == false) {_                                throw new IllegalArgumentException(_                                        "invalid constructor definition: expected a closing parenthesis [" + line + "]")__                            }__                            _                            String[] tokens = line.substring(1, line.length() - 1).replaceAll("\\s+", "").split(",")___                            _                            if ("".equals(tokens[0])) {_                                tokens = new String[0]__                            }__                            whitelistConstructors.add(new WhitelistConstructor(origin, Arrays.asList(tokens)))___                            _                            _                        } else if (line.contains("(")) {_                            _                            if (line.endsWith(")") == false) {_                                throw new IllegalArgumentException(_                                        "invalid method definition: expected a closing parenthesis [" + line + "]")__                            }__                            _                            int parameterIndex = line.indexOf('(')__                            String[] tokens = line.substring(0, parameterIndex).trim().split("\\s+")___                            String methodName__                            String javaAugmentedClassName___                            _                            if (tokens.length == 2) {_                                methodName = tokens[1]__                                javaAugmentedClassName = null__                            } else if (tokens.length == 3) {_                                methodName = tokens[2]__                                javaAugmentedClassName = tokens[1]__                            } else {_                                throw new IllegalArgumentException("invalid method definition: unexpected format [" + line + "]")__                            }__                            String returnCanonicalTypeName = tokens[0]___                            _                            tokens = line.substring(parameterIndex + 1, line.length() - 1).replaceAll("\\s+", "").split(",")___                            _                            if ("".equals(tokens[0])) {_                                tokens = new String[0]__                            }__                            whitelistMethods.add(new WhitelistMethod(origin, javaAugmentedClassName, methodName,_                                    returnCanonicalTypeName, Arrays.asList(tokens)))___                            _                            _                        } else {_                            _                            String[] tokens = line.split("\\s+")___                            _                            if (tokens.length != 2) {_                                throw new IllegalArgumentException("invalid field definition: unexpected format [" + line + "]")__                            }__                            whitelistFields.add(new WhitelistField(origin, tokens[1], tokens[0]))__                        }_                    } else {_                        throw new IllegalArgumentException("invalid definition: unable to parse line [" + line + "]")__                    }_                }__                _                if (javaClassName != null) {_                    throw new IllegalArgumentException("invalid definition: expected closing bracket")__                }_            } catch (Exception exception) {_                throw new RuntimeException("error in [" + filepath + "] at line [" + number + "]", exception)__            }_        }__        ClassLoader loader = AccessController.doPrivileged((PrivilegedAction<ClassLoader>)resource::getClassLoader)___        return new Whitelist(loader, whitelistClasses, whitelistBindings)__    };loads,and,creates,a,link,whitelist,from,one,to,many,text,files,the,file,paths,are,passed,in,as,an,array,of,link,string,s,with,a,single,link,class,to,be,be,used,to,load,the,resources,where,each,link,string,is,the,path,of,a,single,text,file,the,link,class,s,link,class,loader,will,be,used,to,lookup,the,java,reflection,objects,for,each,individual,link,class,link,constructor,link,method,and,link,field,specified,as,part,of,the,whitelist,in,the,text,file,a,single,pass,is,made,through,each,file,to,collect,all,the,information,about,each,class,constructor,method,and,field,most,validation,will,be,done,at,a,later,point,after,all,whitelists,have,been,gathered,and,their,merging,takes,place,a,painless,type,name,is,one,of,the,following,ul,li,def,the,painless,dynamic,type,which,is,automatically,included,without,a,need,to,be,whitelisted,li,li,fully,qualified,java,type,name,any,whitelisted,java,class,will,have,the,equivalent,name,as,a,painless,type,name,with,the,exception,that,any,dollar,symbols,used,as,part,of,inner,classes,will,be,replaced,with,dot,symbols,li,li,short,java,type,name,the,text,after,the,final,dot,symbol,of,any,specified,java,class,a,short,type,java,name,may,be,excluded,by,using,the,token,during,painless,class,parsing,as,described,later,li,ul,the,following,can,be,parsed,from,each,whitelist,text,file,ul,li,blank,lines,will,be,ignored,by,the,parser,li,li,comments,may,be,created,starting,with,a,pound,symbol,and,end,with,a,newline,these,will,be,ignored,by,the,parser,li,li,primitive,types,may,be,specified,starting,with,class,and,followed,by,the,java,type,name,an,opening,bracket,a,newline,a,closing,bracket,and,a,final,newline,li,li,complex,types,may,be,specified,starting,with,class,and,followed,the,fully,qualified,java,class,name,optionally,followed,by,an,token,an,opening,bracket,a,newline,constructor,method,field,specifications,a,closing,bracket,and,a,final,newline,within,a,complex,type,the,following,may,be,parsed,ul,li,a,constructor,may,be,specified,starting,with,an,opening,parenthesis,followed,by,a,comma,delimited,list,of,painless,type,names,corresponding,to,the,type,class,names,for,the,equivalent,java,parameter,types,these,must,be,whitelisted,as,well,a,closing,parenthesis,and,a,newline,li,li,a,method,may,be,specified,starting,with,a,painless,type,name,for,the,return,type,followed,by,the,java,name,of,the,method,which,will,also,be,the,painless,name,for,the,method,an,opening,parenthesis,a,comma,delimited,list,of,painless,type,names,corresponding,to,the,type,class,names,for,the,equivalent,java,parameter,types,these,must,be,whitelisted,as,well,a,closing,parenthesis,and,a,newline,li,li,an,augmented,method,may,be,specified,starting,with,a,painless,type,name,for,the,return,type,followed,by,the,fully,qualified,java,name,of,the,class,the,augmented,method,is,part,of,this,class,does,not,need,to,be,whitelisted,the,java,name,of,the,method,which,will,also,be,the,painless,name,for,the,method,an,opening,parenthesis,a,comma,delimited,list,of,painless,type,names,corresponding,to,the,type,class,names,for,the,equivalent,java,parameter,types,these,must,be,whitelisted,as,well,a,closing,parenthesis,and,a,newline,li,li,a,field,may,be,specified,starting,with,a,painless,type,name,for,the,equivalent,java,type,of,the,field,followed,by,the,java,name,of,the,field,which,all,be,the,painless,name,for,the,field,and,a,newline,li,ul,ul,note,there,must,be,a,one,to,one,correspondence,of,painless,type,names,to,java,type,class,names,if,the,same,painless,type,is,defined,across,multiple,files,and,the,java,class,is,the,same,all,specified,constructors,methods,and,fields,will,be,merged,into,a,single,painless,type,the,painless,dynamic,type,def,used,as,part,of,constructor,method,and,field,definitions,will,be,appropriately,parsed,and,handled,painless,complex,types,must,be,specified,with,the,fully,qualified,java,class,name,method,argument,types,method,return,types,and,field,types,must,be,specified,with,painless,type,names,def,fully,qualified,or,short,as,described,earlier,the,following,example,is,used,to,create,a,single,whitelist,text,file,code,primitive,types,class,int,int,complex,types,class,my,package,example,constructors,int,def,def,example,def,method,example,add,int,def,int,add,example,example,void,example,augmented,example,some,other,class,sub,example,int,def,fields,int,value0,int,value1,def,value2;public,static,whitelist,load,from,resource,files,class,resource,string,filepaths,list,whitelist,class,whitelist,classes,new,array,list,list,whitelist,binding,whitelist,bindings,new,array,list,for,string,filepath,filepaths,string,line,int,number,1,try,line,number,reader,reader,new,line,number,reader,new,input,stream,reader,resource,get,resource,as,stream,filepath,standard,charsets,string,parse,type,null,string,whitelist,class,origin,null,string,java,class,name,null,boolean,no,import,false,list,whitelist,constructor,whitelist,constructors,null,list,whitelist,method,whitelist,methods,null,list,whitelist,field,whitelist,fields,null,while,line,reader,read,line,null,number,reader,get,line,number,line,line,trim,if,line,length,0,line,char,at,0,continue,if,line,starts,with,class,if,line,ends,with,false,throw,new,illegal,argument,exception,invalid,class,definition,failed,to,parse,class,opening,bracket,line,if,parse,type,null,throw,new,illegal,argument,exception,invalid,definition,cannot,embed,class,definition,line,string,tokens,line,substring,5,line,length,1,trim,split,s,if,tokens,length,2,equals,tokens,1,no,import,true,else,if,tokens,length,1,throw,new,illegal,argument,exception,invalid,class,definition,failed,to,parse,class,name,line,parse,type,class,whitelist,class,origin,filepath,number,java,class,name,tokens,0,whitelist,constructors,new,array,list,whitelist,methods,new,array,list,whitelist,fields,new,array,list,else,if,line,starts,with,static,if,line,ends,with,false,throw,new,illegal,argument,exception,invalid,static,definition,failed,to,parse,static,opening,bracket,line,if,parse,type,null,throw,new,illegal,argument,exception,invalid,definition,cannot,embed,static,definition,line,parse,type,static,else,if,line,equals,if,parse,type,null,throw,new,illegal,argument,exception,invalid,definition,extraneous,closing,bracket,if,class,equals,parse,type,whitelist,classes,add,new,whitelist,class,whitelist,class,origin,java,class,name,no,import,whitelist,constructors,whitelist,methods,whitelist,fields,whitelist,class,origin,null,java,class,name,null,no,import,false,whitelist,constructors,null,whitelist,methods,null,whitelist,fields,null,parse,type,null,else,if,static,equals,parse,type,string,origin,filepath,number,int,parameter,start,index,line,index,of,if,parameter,start,index,1,throw,new,illegal,argument,exception,illegal,static,definition,start,of,method,parameters,not,found,line,string,tokens,line,substring,0,parameter,start,index,trim,split,s,string,method,name,if,tokens,length,2,method,name,tokens,1,else,throw,new,illegal,argument,exception,invalid,method,definition,unexpected,format,line,string,return,canonical,type,name,tokens,0,int,parameter,end,index,line,index,of,if,parameter,end,index,1,throw,new,illegal,argument,exception,illegal,static,definition,end,of,method,parameters,not,found,line,string,canonical,type,name,parameters,line,substring,parameter,start,index,1,parameter,end,index,replace,all,s,split,if,equals,canonical,type,name,parameters,0,canonical,type,name,parameters,new,string,0,tokens,line,substring,parameter,end,index,1,trim,split,s,string,static,type,string,target,java,class,name,if,tokens,length,2,static,type,tokens,0,target,java,class,name,tokens,1,else,throw,new,illegal,argument,exception,invalid,static,definition,unexpected,format,line,if,equals,static,type,false,throw,new,illegal,argument,exception,invalid,static,definition,unexpected,static,type,static,type,line,whitelist,bindings,add,new,whitelist,binding,origin,target,java,class,name,method,name,return,canonical,type,name,arrays,as,list,canonical,type,name,parameters,else,if,class,equals,parse,type,string,origin,filepath,number,if,parse,type,null,throw,new,illegal,argument,exception,invalid,definition,expected,one,of,class,static,line,if,line,starts,with,if,line,ends,with,false,throw,new,illegal,argument,exception,invalid,constructor,definition,expected,a,closing,parenthesis,line,string,tokens,line,substring,1,line,length,1,replace,all,s,split,if,equals,tokens,0,tokens,new,string,0,whitelist,constructors,add,new,whitelist,constructor,origin,arrays,as,list,tokens,else,if,line,contains,if,line,ends,with,false,throw,new,illegal,argument,exception,invalid,method,definition,expected,a,closing,parenthesis,line,int,parameter,index,line,index,of,string,tokens,line,substring,0,parameter,index,trim,split,s,string,method,name,string,java,augmented,class,name,if,tokens,length,2,method,name,tokens,1,java,augmented,class,name,null,else,if,tokens,length,3,method,name,tokens,2,java,augmented,class,name,tokens,1,else,throw,new,illegal,argument,exception,invalid,method,definition,unexpected,format,line,string,return,canonical,type,name,tokens,0,tokens,line,substring,parameter,index,1,line,length,1,replace,all,s,split,if,equals,tokens,0,tokens,new,string,0,whitelist,methods,add,new,whitelist,method,origin,java,augmented,class,name,method,name,return,canonical,type,name,arrays,as,list,tokens,else,string,tokens,line,split,s,if,tokens,length,2,throw,new,illegal,argument,exception,invalid,field,definition,unexpected,format,line,whitelist,fields,add,new,whitelist,field,origin,tokens,1,tokens,0,else,throw,new,illegal,argument,exception,invalid,definition,unable,to,parse,line,line,if,java,class,name,null,throw,new,illegal,argument,exception,invalid,definition,expected,closing,bracket,catch,exception,exception,throw,new,runtime,exception,error,in,filepath,at,line,number,exception,class,loader,loader,access,controller,do,privileged,privileged,action,class,loader,resource,get,class,loader,return,new,whitelist,loader,whitelist,classes,whitelist,bindings
WhitelistLoader -> public static Whitelist loadFromResourceFiles(Class<?> resource, String... filepaths);1536611444;Loads and creates a {@link Whitelist} from one to many text files. The file paths are passed in as an array of_{@link String}s with a single {@link Class} to be be used to load the resources where each {@link String}_is the path of a single text file. The {@link Class}'s {@link ClassLoader} will be used to lookup the Java_reflection objects for each individual {@link Class}, {@link Constructor}, {@link Method}, and {@link Field}_specified as part of the whitelist in the text file.__A single pass is made through each file to collect all the information about each class, constructor, method,_and field. Most validation will be done at a later point after all whitelists have been gathered and their_merging takes place.__A painless type name is one of the following:_<ul>_<li> def - The Painless dynamic type which is automatically included without a need to be_whitelisted. </li>_<li> fully-qualified Java type name - Any whitelisted Java class will have the equivalent name as_a Painless type name with the exception that any dollar symbols used as part of inner classes will_be replaced with dot symbols. </li>_<li> short Java type name - The text after the final dot symbol of any specified Java class. A_short type Java name may be excluded by using the 'no_import' token during Painless class parsing_as described later. </li>_</ul>__The following can be parsed from each whitelist text file:_<ul>_<li> Blank lines will be ignored by the parser. </li>_<li> Comments may be created starting with a pound '#' symbol and end with a newline. These will_be ignored by the parser. </li>_<li> Primitive types may be specified starting with 'class' and followed by the Java type name,_an opening bracket, a newline, a closing bracket, and a final newline. </li>_<li> Complex types may be specified starting with 'class' and followed the fully-qualified Java_class name, optionally followed by an 'no_import' token, an opening bracket, a newline,_constructor/method/field specifications, a closing bracket, and a final newline. Within a complex_type the following may be parsed:_<ul>_<li> A constructor may be specified starting with an opening parenthesis, followed by a_comma-delimited list of Painless type names corresponding to the type/class names for_the equivalent Java parameter types (these must be whitelisted as well), a closing_parenthesis, and a newline. </li>_<li> A method may be specified starting with a Painless type name for the return type,_followed by the Java name of the method (which will also be the Painless name for the_method), an opening parenthesis, a comma-delimited list of Painless type names_corresponding to the type/class names for the equivalent Java parameter types_(these must be whitelisted as well), a closing parenthesis, and a newline. </li>_<li> An augmented method may be specified starting with a Painless type name for the return_type, followed by the fully qualified Java name of the class the augmented method is_part of (this class does not need to be whitelisted), the Java name of the method_(which will also be the Painless name for the method), an opening parenthesis, a_comma-delimited list of Painless type names corresponding to the type/class names_for the equivalent Java parameter types (these must be whitelisted as well), a closing_parenthesis, and a newline. </li>_<li>A field may be specified starting with a Painless type name for the equivalent Java type_of the field, followed by the Java name of the field (which all be the Painless name_for the field), and a newline. </li>_</ul>_</ul>__Note there must be a one-to-one correspondence of Painless type names to Java type/class names._If the same Painless type is defined across multiple files and the Java class is the same, all_specified constructors, methods, and fields will be merged into a single Painless type. The_Painless dynamic type, 'def', used as part of constructor, method, and field definitions will_be appropriately parsed and handled. Painless complex types must be specified with the_fully-qualified Java class name. Method argument types, method return types, and field types_must be specified with Painless type names (def, fully-qualified, or short) as described earlier.__The following example is used to create a single whitelist text file:__{@code_# primitive types__class int -> int {___# complex types__class my.package.Example no_import {_# constructors__(int)_(def, def)_(Example, def)__# method_Example add(int, def)_int add(Example, Example)_void example()__# augmented_Example some.other.Class sub(Example, int, def)__# fields_int value0_int value1_def value2;public static Whitelist loadFromResourceFiles(Class<?> resource, String... filepaths) {_        List<WhitelistClass> whitelistClasses = new ArrayList<>()__        List<WhitelistMethod> whitelistStatics = new ArrayList<>()__        List<WhitelistBinding> whitelistBindings = new ArrayList<>()___        _        _        for (String filepath : filepaths) {_            String line__            int number = -1___            try (LineNumberReader reader = new LineNumberReader(_                    new InputStreamReader(resource.getResourceAsStream(filepath), StandardCharsets.UTF_8))) {__                String parseType = null__                String whitelistClassOrigin = null__                String javaClassName = null__                boolean noImport = false__                List<WhitelistConstructor> whitelistConstructors = null__                List<WhitelistMethod> whitelistMethods = null__                List<WhitelistField> whitelistFields = null___                while ((line = reader.readLine()) != null) {_                    number = reader.getLineNumber()__                    line = line.trim()___                    _                    if (line.length() == 0 || line.charAt(0) == '#') {_                        continue__                    }__                    _                    _                    if (line.startsWith("class ")) {_                        _                        if (line.endsWith("{") == false) {_                            throw new IllegalArgumentException(_                                    "invalid class definition: failed to parse class opening bracket [" + line + "]")__                        }__                        if (parseType != null) {_                            throw new IllegalArgumentException("invalid definition: cannot embed class definition [" + line + "]")__                        }__                        _                        String[] tokens = line.substring(5, line.length() - 1).trim().split("\\s+")___                        _                        if (tokens.length == 2 && "no_import".equals(tokens[1])) {_                            noImport = true__                        } else if (tokens.length != 1) {_                            throw new IllegalArgumentException("invalid class definition: failed to parse class name [" + line + "]")__                        }__                        parseType = "class"__                        whitelistClassOrigin = "[" + filepath + "]:[" + number + "]"__                        javaClassName = tokens[0]___                        _                        whitelistConstructors = new ArrayList<>()__                        whitelistMethods = new ArrayList<>()__                        whitelistFields = new ArrayList<>()__                    } else if (line.startsWith("static_import ")) {_                        _                        if (line.endsWith("{") == false) {_                            throw new IllegalArgumentException(_                                    "invalid static import definition: failed to parse static import opening bracket [" + line + "]")__                        }__                        if (parseType != null) {_                            throw new IllegalArgumentException("invalid definition: cannot embed static import definition [" + line + "]")__                        }__                        parseType = "static_import"___                    _                    _                    } else if (line.equals("}")) {_                        if (parseType == null) {_                            throw new IllegalArgumentException("invalid definition: extraneous closing bracket")__                        }__                        _                        _                        if ("class".equals(parseType)) {_                            whitelistClasses.add(new WhitelistClass(whitelistClassOrigin, javaClassName, noImport,_                                    whitelistConstructors, whitelistMethods, whitelistFields))___                            whitelistClassOrigin = null__                            javaClassName = null__                            noImport = false__                            whitelistConstructors = null__                            whitelistMethods = null__                            whitelistFields = null__                        }__                        _                        parseType = null___                    _                    _                    } else if ("static_import".equals(parseType)) {_                        _                        String origin = "[" + filepath + "]:[" + number + "]"___                        _                        int parameterStartIndex = line.indexOf('(')___                        if (parameterStartIndex == -1) {_                            throw new IllegalArgumentException(_                                    "illegal static import definition: start of method parameters not found [" + line + "]")__                        }__                        String[] tokens = line.substring(0, parameterStartIndex).trim().split("\\s+")___                        String methodName___                        _                        if (tokens.length == 2) {_                            methodName = tokens[1]__                        } else {_                            throw new IllegalArgumentException("invalid method definition: unexpected format [" + line + "]")__                        }__                        String returnCanonicalTypeName = tokens[0]___                        _                        int parameterEndIndex = line.indexOf(')')___                        if (parameterEndIndex == -1) {_                            throw new IllegalArgumentException(_                                    "illegal static import definition: end of method parameters not found [" + line + "]")__                        }__                        String[] canonicalTypeNameParameters =_                                line.substring(parameterStartIndex + 1, parameterEndIndex).replaceAll("\\s+", "").split(",")___                        _                        if ("".equals(canonicalTypeNameParameters[0])) {_                            canonicalTypeNameParameters = new String[0]__                        }__                        _                        tokens = line.substring(parameterEndIndex + 1).trim().split("\\s+")___                        String staticImportType__                        String targetJavaClassName___                        _                        if (tokens.length == 2) {_                            staticImportType = tokens[0]__                            targetJavaClassName = tokens[1]__                        } else {_                            throw new IllegalArgumentException("invalid static import definition: unexpected format [" + line + "]")__                        }__                        _                        if ("from_class".equals(staticImportType)) {_                            whitelistStatics.add(new WhitelistMethod(origin, targetJavaClassName,_                                    methodName, returnCanonicalTypeName, Arrays.asList(canonicalTypeNameParameters)))__                        } else if ("bound_to".equals(staticImportType)) {_                            whitelistBindings.add(new WhitelistBinding(origin, targetJavaClassName,_                                    methodName, returnCanonicalTypeName, Arrays.asList(canonicalTypeNameParameters)))__                        } else {_                            throw new IllegalArgumentException("invalid static import definition: " +_                                    "unexpected static import type [" + staticImportType + "] [" + line + "]")__                        }__                    _                    } else if ("class".equals(parseType)) {_                        _                        String origin = "[" + filepath + "]:[" + number + "]"___                        _                        _                        if (line.startsWith("(")) {_                            _                            if (line.endsWith(")") == false) {_                                throw new IllegalArgumentException(_                                        "invalid constructor definition: expected a closing parenthesis [" + line + "]")__                            }__                            _                            String[] tokens = line.substring(1, line.length() - 1).replaceAll("\\s+", "").split(",")___                            _                            if ("".equals(tokens[0])) {_                                tokens = new String[0]__                            }__                            whitelistConstructors.add(new WhitelistConstructor(origin, Arrays.asList(tokens)))___                            _                            _                        } else if (line.contains("(")) {_                            _                            if (line.endsWith(")") == false) {_                                throw new IllegalArgumentException(_                                        "invalid method definition: expected a closing parenthesis [" + line + "]")__                            }__                            _                            int parameterIndex = line.indexOf('(')__                            String[] tokens = line.substring(0, parameterIndex).trim().split("\\s+")___                            String methodName__                            String javaAugmentedClassName___                            _                            if (tokens.length == 2) {_                                methodName = tokens[1]__                                javaAugmentedClassName = null__                            } else if (tokens.length == 3) {_                                methodName = tokens[2]__                                javaAugmentedClassName = tokens[1]__                            } else {_                                throw new IllegalArgumentException("invalid method definition: unexpected format [" + line + "]")__                            }__                            String returnCanonicalTypeName = tokens[0]___                            _                            tokens = line.substring(parameterIndex + 1, line.length() - 1).replaceAll("\\s+", "").split(",")___                            _                            if ("".equals(tokens[0])) {_                                tokens = new String[0]__                            }__                            whitelistMethods.add(new WhitelistMethod(origin, javaAugmentedClassName, methodName,_                                    returnCanonicalTypeName, Arrays.asList(tokens)))___                            _                            _                        } else {_                            _                            String[] tokens = line.split("\\s+")___                            _                            if (tokens.length != 2) {_                                throw new IllegalArgumentException("invalid field definition: unexpected format [" + line + "]")__                            }__                            whitelistFields.add(new WhitelistField(origin, tokens[1], tokens[0]))__                        }_                    } else {_                        throw new IllegalArgumentException("invalid definition: unable to parse line [" + line + "]")__                    }_                }__                _                if (javaClassName != null) {_                    throw new IllegalArgumentException("invalid definition: expected closing bracket")__                }_            } catch (Exception exception) {_                throw new RuntimeException("error in [" + filepath + "] at line [" + number + "]", exception)__            }_        }__        ClassLoader loader = AccessController.doPrivileged((PrivilegedAction<ClassLoader>)resource::getClassLoader)___        return new Whitelist(loader, whitelistClasses, whitelistStatics, whitelistBindings)__    };loads,and,creates,a,link,whitelist,from,one,to,many,text,files,the,file,paths,are,passed,in,as,an,array,of,link,string,s,with,a,single,link,class,to,be,be,used,to,load,the,resources,where,each,link,string,is,the,path,of,a,single,text,file,the,link,class,s,link,class,loader,will,be,used,to,lookup,the,java,reflection,objects,for,each,individual,link,class,link,constructor,link,method,and,link,field,specified,as,part,of,the,whitelist,in,the,text,file,a,single,pass,is,made,through,each,file,to,collect,all,the,information,about,each,class,constructor,method,and,field,most,validation,will,be,done,at,a,later,point,after,all,whitelists,have,been,gathered,and,their,merging,takes,place,a,painless,type,name,is,one,of,the,following,ul,li,def,the,painless,dynamic,type,which,is,automatically,included,without,a,need,to,be,whitelisted,li,li,fully,qualified,java,type,name,any,whitelisted,java,class,will,have,the,equivalent,name,as,a,painless,type,name,with,the,exception,that,any,dollar,symbols,used,as,part,of,inner,classes,will,be,replaced,with,dot,symbols,li,li,short,java,type,name,the,text,after,the,final,dot,symbol,of,any,specified,java,class,a,short,type,java,name,may,be,excluded,by,using,the,token,during,painless,class,parsing,as,described,later,li,ul,the,following,can,be,parsed,from,each,whitelist,text,file,ul,li,blank,lines,will,be,ignored,by,the,parser,li,li,comments,may,be,created,starting,with,a,pound,symbol,and,end,with,a,newline,these,will,be,ignored,by,the,parser,li,li,primitive,types,may,be,specified,starting,with,class,and,followed,by,the,java,type,name,an,opening,bracket,a,newline,a,closing,bracket,and,a,final,newline,li,li,complex,types,may,be,specified,starting,with,class,and,followed,the,fully,qualified,java,class,name,optionally,followed,by,an,token,an,opening,bracket,a,newline,constructor,method,field,specifications,a,closing,bracket,and,a,final,newline,within,a,complex,type,the,following,may,be,parsed,ul,li,a,constructor,may,be,specified,starting,with,an,opening,parenthesis,followed,by,a,comma,delimited,list,of,painless,type,names,corresponding,to,the,type,class,names,for,the,equivalent,java,parameter,types,these,must,be,whitelisted,as,well,a,closing,parenthesis,and,a,newline,li,li,a,method,may,be,specified,starting,with,a,painless,type,name,for,the,return,type,followed,by,the,java,name,of,the,method,which,will,also,be,the,painless,name,for,the,method,an,opening,parenthesis,a,comma,delimited,list,of,painless,type,names,corresponding,to,the,type,class,names,for,the,equivalent,java,parameter,types,these,must,be,whitelisted,as,well,a,closing,parenthesis,and,a,newline,li,li,an,augmented,method,may,be,specified,starting,with,a,painless,type,name,for,the,return,type,followed,by,the,fully,qualified,java,name,of,the,class,the,augmented,method,is,part,of,this,class,does,not,need,to,be,whitelisted,the,java,name,of,the,method,which,will,also,be,the,painless,name,for,the,method,an,opening,parenthesis,a,comma,delimited,list,of,painless,type,names,corresponding,to,the,type,class,names,for,the,equivalent,java,parameter,types,these,must,be,whitelisted,as,well,a,closing,parenthesis,and,a,newline,li,li,a,field,may,be,specified,starting,with,a,painless,type,name,for,the,equivalent,java,type,of,the,field,followed,by,the,java,name,of,the,field,which,all,be,the,painless,name,for,the,field,and,a,newline,li,ul,ul,note,there,must,be,a,one,to,one,correspondence,of,painless,type,names,to,java,type,class,names,if,the,same,painless,type,is,defined,across,multiple,files,and,the,java,class,is,the,same,all,specified,constructors,methods,and,fields,will,be,merged,into,a,single,painless,type,the,painless,dynamic,type,def,used,as,part,of,constructor,method,and,field,definitions,will,be,appropriately,parsed,and,handled,painless,complex,types,must,be,specified,with,the,fully,qualified,java,class,name,method,argument,types,method,return,types,and,field,types,must,be,specified,with,painless,type,names,def,fully,qualified,or,short,as,described,earlier,the,following,example,is,used,to,create,a,single,whitelist,text,file,code,primitive,types,class,int,int,complex,types,class,my,package,example,constructors,int,def,def,example,def,method,example,add,int,def,int,add,example,example,void,example,augmented,example,some,other,class,sub,example,int,def,fields,int,value0,int,value1,def,value2;public,static,whitelist,load,from,resource,files,class,resource,string,filepaths,list,whitelist,class,whitelist,classes,new,array,list,list,whitelist,method,whitelist,statics,new,array,list,list,whitelist,binding,whitelist,bindings,new,array,list,for,string,filepath,filepaths,string,line,int,number,1,try,line,number,reader,reader,new,line,number,reader,new,input,stream,reader,resource,get,resource,as,stream,filepath,standard,charsets,string,parse,type,null,string,whitelist,class,origin,null,string,java,class,name,null,boolean,no,import,false,list,whitelist,constructor,whitelist,constructors,null,list,whitelist,method,whitelist,methods,null,list,whitelist,field,whitelist,fields,null,while,line,reader,read,line,null,number,reader,get,line,number,line,line,trim,if,line,length,0,line,char,at,0,continue,if,line,starts,with,class,if,line,ends,with,false,throw,new,illegal,argument,exception,invalid,class,definition,failed,to,parse,class,opening,bracket,line,if,parse,type,null,throw,new,illegal,argument,exception,invalid,definition,cannot,embed,class,definition,line,string,tokens,line,substring,5,line,length,1,trim,split,s,if,tokens,length,2,equals,tokens,1,no,import,true,else,if,tokens,length,1,throw,new,illegal,argument,exception,invalid,class,definition,failed,to,parse,class,name,line,parse,type,class,whitelist,class,origin,filepath,number,java,class,name,tokens,0,whitelist,constructors,new,array,list,whitelist,methods,new,array,list,whitelist,fields,new,array,list,else,if,line,starts,with,if,line,ends,with,false,throw,new,illegal,argument,exception,invalid,static,import,definition,failed,to,parse,static,import,opening,bracket,line,if,parse,type,null,throw,new,illegal,argument,exception,invalid,definition,cannot,embed,static,import,definition,line,parse,type,else,if,line,equals,if,parse,type,null,throw,new,illegal,argument,exception,invalid,definition,extraneous,closing,bracket,if,class,equals,parse,type,whitelist,classes,add,new,whitelist,class,whitelist,class,origin,java,class,name,no,import,whitelist,constructors,whitelist,methods,whitelist,fields,whitelist,class,origin,null,java,class,name,null,no,import,false,whitelist,constructors,null,whitelist,methods,null,whitelist,fields,null,parse,type,null,else,if,equals,parse,type,string,origin,filepath,number,int,parameter,start,index,line,index,of,if,parameter,start,index,1,throw,new,illegal,argument,exception,illegal,static,import,definition,start,of,method,parameters,not,found,line,string,tokens,line,substring,0,parameter,start,index,trim,split,s,string,method,name,if,tokens,length,2,method,name,tokens,1,else,throw,new,illegal,argument,exception,invalid,method,definition,unexpected,format,line,string,return,canonical,type,name,tokens,0,int,parameter,end,index,line,index,of,if,parameter,end,index,1,throw,new,illegal,argument,exception,illegal,static,import,definition,end,of,method,parameters,not,found,line,string,canonical,type,name,parameters,line,substring,parameter,start,index,1,parameter,end,index,replace,all,s,split,if,equals,canonical,type,name,parameters,0,canonical,type,name,parameters,new,string,0,tokens,line,substring,parameter,end,index,1,trim,split,s,string,static,import,type,string,target,java,class,name,if,tokens,length,2,static,import,type,tokens,0,target,java,class,name,tokens,1,else,throw,new,illegal,argument,exception,invalid,static,import,definition,unexpected,format,line,if,equals,static,import,type,whitelist,statics,add,new,whitelist,method,origin,target,java,class,name,method,name,return,canonical,type,name,arrays,as,list,canonical,type,name,parameters,else,if,equals,static,import,type,whitelist,bindings,add,new,whitelist,binding,origin,target,java,class,name,method,name,return,canonical,type,name,arrays,as,list,canonical,type,name,parameters,else,throw,new,illegal,argument,exception,invalid,static,import,definition,unexpected,static,import,type,static,import,type,line,else,if,class,equals,parse,type,string,origin,filepath,number,if,line,starts,with,if,line,ends,with,false,throw,new,illegal,argument,exception,invalid,constructor,definition,expected,a,closing,parenthesis,line,string,tokens,line,substring,1,line,length,1,replace,all,s,split,if,equals,tokens,0,tokens,new,string,0,whitelist,constructors,add,new,whitelist,constructor,origin,arrays,as,list,tokens,else,if,line,contains,if,line,ends,with,false,throw,new,illegal,argument,exception,invalid,method,definition,expected,a,closing,parenthesis,line,int,parameter,index,line,index,of,string,tokens,line,substring,0,parameter,index,trim,split,s,string,method,name,string,java,augmented,class,name,if,tokens,length,2,method,name,tokens,1,java,augmented,class,name,null,else,if,tokens,length,3,method,name,tokens,2,java,augmented,class,name,tokens,1,else,throw,new,illegal,argument,exception,invalid,method,definition,unexpected,format,line,string,return,canonical,type,name,tokens,0,tokens,line,substring,parameter,index,1,line,length,1,replace,all,s,split,if,equals,tokens,0,tokens,new,string,0,whitelist,methods,add,new,whitelist,method,origin,java,augmented,class,name,method,name,return,canonical,type,name,arrays,as,list,tokens,else,string,tokens,line,split,s,if,tokens,length,2,throw,new,illegal,argument,exception,invalid,field,definition,unexpected,format,line,whitelist,fields,add,new,whitelist,field,origin,tokens,1,tokens,0,else,throw,new,illegal,argument,exception,invalid,definition,unable,to,parse,line,line,if,java,class,name,null,throw,new,illegal,argument,exception,invalid,definition,expected,closing,bracket,catch,exception,exception,throw,new,runtime,exception,error,in,filepath,at,line,number,exception,class,loader,loader,access,controller,do,privileged,privileged,action,class,loader,resource,get,class,loader,return,new,whitelist,loader,whitelist,classes,whitelist,statics,whitelist,bindings
WhitelistLoader -> public static Whitelist loadFromResourceFiles(Class<?> resource, String... filepaths);1537806831;Loads and creates a {@link Whitelist} from one to many text files. The file paths are passed in as an array of_{@link String}s with a single {@link Class} to be be used to load the resources where each {@link String}_is the path of a single text file. The {@link Class}'s {@link ClassLoader} will be used to lookup the Java_reflection objects for each individual {@link Class}, {@link Constructor}, {@link Method}, and {@link Field}_specified as part of the whitelist in the text file.__A single pass is made through each file to collect all the information about each class, constructor, method,_and field. Most validation will be done at a later point after all whitelists have been gathered and their_merging takes place.__A painless type name is one of the following:_<ul>_<li> def - The Painless dynamic type which is automatically included without a need to be_whitelisted. </li>_<li> fully-qualified Java type name - Any whitelisted Java class will have the equivalent name as_a Painless type name with the exception that any dollar symbols used as part of inner classes will_be replaced with dot symbols. </li>_<li> short Java type name - The text after the final dot symbol of any specified Java class. A_short type Java name may be excluded by using the 'no_import' token during Painless class parsing_as described later. </li>_</ul>__The following can be parsed from each whitelist text file:_<ul>_<li> Blank lines will be ignored by the parser. </li>_<li> Comments may be created starting with a pound '#' symbol and end with a newline. These will_be ignored by the parser. </li>_<li> Primitive types may be specified starting with 'class' and followed by the Java type name,_an opening bracket, a newline, a closing bracket, and a final newline. </li>_<li> Complex types may be specified starting with 'class' and followed the fully-qualified Java_class name, optionally followed by an 'no_import' token, an opening bracket, a newline,_constructor/method/field specifications, a closing bracket, and a final newline. Within a complex_type the following may be parsed:_<ul>_<li> A constructor may be specified starting with an opening parenthesis, followed by a_comma-delimited list of Painless type names corresponding to the type/class names for_the equivalent Java parameter types (these must be whitelisted as well), a closing_parenthesis, and a newline. </li>_<li> A method may be specified starting with a Painless type name for the return type,_followed by the Java name of the method (which will also be the Painless name for the_method), an opening parenthesis, a comma-delimited list of Painless type names_corresponding to the type/class names for the equivalent Java parameter types_(these must be whitelisted as well), a closing parenthesis, and a newline. </li>_<li> An augmented method may be specified starting with a Painless type name for the return_type, followed by the fully qualified Java name of the class the augmented method is_part of (this class does not need to be whitelisted), the Java name of the method_(which will also be the Painless name for the method), an opening parenthesis, a_comma-delimited list of Painless type names corresponding to the type/class names_for the equivalent Java parameter types (these must be whitelisted as well), a closing_parenthesis, and a newline. </li>_<li>A field may be specified starting with a Painless type name for the equivalent Java type_of the field, followed by the Java name of the field (which all be the Painless name_for the field), and a newline. </li>_</ul>_</ul>__Note there must be a one-to-one correspondence of Painless type names to Java type/class names._If the same Painless type is defined across multiple files and the Java class is the same, all_specified constructors, methods, and fields will be merged into a single Painless type. The_Painless dynamic type, 'def', used as part of constructor, method, and field definitions will_be appropriately parsed and handled. Painless complex types must be specified with the_fully-qualified Java class name. Method argument types, method return types, and field types_must be specified with Painless type names (def, fully-qualified, or short) as described earlier.__The following example is used to create a single whitelist text file:__{@code_# primitive types__class int -> int {___# complex types__class my.package.Example no_import {_# constructors__(int)_(def, def)_(Example, def)__# method_Example add(int, def)_int add(Example, Example)_void example()__# augmented_Example some.other.Class sub(Example, int, def)__# fields_int value0_int value1_def value2;public static Whitelist loadFromResourceFiles(Class<?> resource, String... filepaths) {_        List<WhitelistClass> whitelistClasses = new ArrayList<>()__        List<WhitelistMethod> whitelistStatics = new ArrayList<>()__        List<WhitelistClassBinding> whitelistClassBindings = new ArrayList<>()___        _        _        for (String filepath : filepaths) {_            String line__            int number = -1___            try (LineNumberReader reader = new LineNumberReader(_                    new InputStreamReader(resource.getResourceAsStream(filepath), StandardCharsets.UTF_8))) {__                String parseType = null__                String whitelistClassOrigin = null__                String javaClassName = null__                boolean noImport = false__                List<WhitelistConstructor> whitelistConstructors = null__                List<WhitelistMethod> whitelistMethods = null__                List<WhitelistField> whitelistFields = null___                while ((line = reader.readLine()) != null) {_                    number = reader.getLineNumber()__                    line = line.trim()___                    _                    if (line.length() == 0 || line.charAt(0) == '#') {_                        continue__                    }__                    _                    _                    if (line.startsWith("class ")) {_                        _                        if (line.endsWith("{") == false) {_                            throw new IllegalArgumentException(_                                    "invalid class definition: failed to parse class opening bracket [" + line + "]")__                        }__                        if (parseType != null) {_                            throw new IllegalArgumentException("invalid definition: cannot embed class definition [" + line + "]")__                        }__                        _                        String[] tokens = line.substring(5, line.length() - 1).trim().split("\\s+")___                        _                        if (tokens.length == 2 && "no_import".equals(tokens[1])) {_                            noImport = true__                        } else if (tokens.length != 1) {_                            throw new IllegalArgumentException("invalid class definition: failed to parse class name [" + line + "]")__                        }__                        parseType = "class"__                        whitelistClassOrigin = "[" + filepath + "]:[" + number + "]"__                        javaClassName = tokens[0]___                        _                        whitelistConstructors = new ArrayList<>()__                        whitelistMethods = new ArrayList<>()__                        whitelistFields = new ArrayList<>()__                    } else if (line.startsWith("static_import ")) {_                        _                        if (line.endsWith("{") == false) {_                            throw new IllegalArgumentException(_                                    "invalid static import definition: failed to parse static import opening bracket [" + line + "]")__                        }__                        if (parseType != null) {_                            throw new IllegalArgumentException("invalid definition: cannot embed static import definition [" + line + "]")__                        }__                        parseType = "static_import"___                    _                    _                    } else if (line.equals("}")) {_                        if (parseType == null) {_                            throw new IllegalArgumentException("invalid definition: extraneous closing bracket")__                        }__                        _                        _                        if ("class".equals(parseType)) {_                            whitelistClasses.add(new WhitelistClass(whitelistClassOrigin, javaClassName, noImport,_                                    whitelistConstructors, whitelistMethods, whitelistFields))___                            whitelistClassOrigin = null__                            javaClassName = null__                            noImport = false__                            whitelistConstructors = null__                            whitelistMethods = null__                            whitelistFields = null__                        }__                        _                        parseType = null___                    _                    _                    } else if ("static_import".equals(parseType)) {_                        _                        String origin = "[" + filepath + "]:[" + number + "]"___                        _                        int parameterStartIndex = line.indexOf('(')___                        if (parameterStartIndex == -1) {_                            throw new IllegalArgumentException(_                                    "illegal static import definition: start of method parameters not found [" + line + "]")__                        }__                        String[] tokens = line.substring(0, parameterStartIndex).trim().split("\\s+")___                        String methodName___                        _                        if (tokens.length == 2) {_                            methodName = tokens[1]__                        } else {_                            throw new IllegalArgumentException("invalid method definition: unexpected format [" + line + "]")__                        }__                        String returnCanonicalTypeName = tokens[0]___                        _                        int parameterEndIndex = line.indexOf(')')___                        if (parameterEndIndex == -1) {_                            throw new IllegalArgumentException(_                                    "illegal static import definition: end of method parameters not found [" + line + "]")__                        }__                        String[] canonicalTypeNameParameters =_                                line.substring(parameterStartIndex + 1, parameterEndIndex).replaceAll("\\s+", "").split(",")___                        _                        if ("".equals(canonicalTypeNameParameters[0])) {_                            canonicalTypeNameParameters = new String[0]__                        }__                        _                        tokens = line.substring(parameterEndIndex + 1).trim().split("\\s+")___                        String staticImportType__                        String targetJavaClassName___                        _                        if (tokens.length == 2) {_                            staticImportType = tokens[0]__                            targetJavaClassName = tokens[1]__                        } else {_                            throw new IllegalArgumentException("invalid static import definition: unexpected format [" + line + "]")__                        }__                        _                        if ("from_class".equals(staticImportType)) {_                            whitelistStatics.add(new WhitelistMethod(origin, targetJavaClassName,_                                    methodName, returnCanonicalTypeName, Arrays.asList(canonicalTypeNameParameters)))__                        } else if ("bound_to".equals(staticImportType)) {_                            whitelistClassBindings.add(new WhitelistClassBinding(origin, targetJavaClassName,_                                    methodName, returnCanonicalTypeName, Arrays.asList(canonicalTypeNameParameters)))__                        } else {_                            throw new IllegalArgumentException("invalid static import definition: " +_                                    "unexpected static import type [" + staticImportType + "] [" + line + "]")__                        }__                    _                    } else if ("class".equals(parseType)) {_                        _                        String origin = "[" + filepath + "]:[" + number + "]"___                        _                        _                        if (line.startsWith("(")) {_                            _                            if (line.endsWith(")") == false) {_                                throw new IllegalArgumentException(_                                        "invalid constructor definition: expected a closing parenthesis [" + line + "]")__                            }__                            _                            String[] tokens = line.substring(1, line.length() - 1).replaceAll("\\s+", "").split(",")___                            _                            if ("".equals(tokens[0])) {_                                tokens = new String[0]__                            }__                            whitelistConstructors.add(new WhitelistConstructor(origin, Arrays.asList(tokens)))___                            _                            _                        } else if (line.contains("(")) {_                            _                            if (line.endsWith(")") == false) {_                                throw new IllegalArgumentException(_                                        "invalid method definition: expected a closing parenthesis [" + line + "]")__                            }__                            _                            int parameterIndex = line.indexOf('(')__                            String[] tokens = line.substring(0, parameterIndex).trim().split("\\s+")___                            String methodName__                            String javaAugmentedClassName___                            _                            if (tokens.length == 2) {_                                methodName = tokens[1]__                                javaAugmentedClassName = null__                            } else if (tokens.length == 3) {_                                methodName = tokens[2]__                                javaAugmentedClassName = tokens[1]__                            } else {_                                throw new IllegalArgumentException("invalid method definition: unexpected format [" + line + "]")__                            }__                            String returnCanonicalTypeName = tokens[0]___                            _                            tokens = line.substring(parameterIndex + 1, line.length() - 1).replaceAll("\\s+", "").split(",")___                            _                            if ("".equals(tokens[0])) {_                                tokens = new String[0]__                            }__                            whitelistMethods.add(new WhitelistMethod(origin, javaAugmentedClassName, methodName,_                                    returnCanonicalTypeName, Arrays.asList(tokens)))___                            _                            _                        } else {_                            _                            String[] tokens = line.split("\\s+")___                            _                            if (tokens.length != 2) {_                                throw new IllegalArgumentException("invalid field definition: unexpected format [" + line + "]")__                            }__                            whitelistFields.add(new WhitelistField(origin, tokens[1], tokens[0]))__                        }_                    } else {_                        throw new IllegalArgumentException("invalid definition: unable to parse line [" + line + "]")__                    }_                }__                _                if (javaClassName != null) {_                    throw new IllegalArgumentException("invalid definition: expected closing bracket")__                }_            } catch (Exception exception) {_                throw new RuntimeException("error in [" + filepath + "] at line [" + number + "]", exception)__            }_        }__        ClassLoader loader = AccessController.doPrivileged((PrivilegedAction<ClassLoader>)resource::getClassLoader)___        return new Whitelist(loader, whitelistClasses, whitelistStatics, whitelistClassBindings)__    };loads,and,creates,a,link,whitelist,from,one,to,many,text,files,the,file,paths,are,passed,in,as,an,array,of,link,string,s,with,a,single,link,class,to,be,be,used,to,load,the,resources,where,each,link,string,is,the,path,of,a,single,text,file,the,link,class,s,link,class,loader,will,be,used,to,lookup,the,java,reflection,objects,for,each,individual,link,class,link,constructor,link,method,and,link,field,specified,as,part,of,the,whitelist,in,the,text,file,a,single,pass,is,made,through,each,file,to,collect,all,the,information,about,each,class,constructor,method,and,field,most,validation,will,be,done,at,a,later,point,after,all,whitelists,have,been,gathered,and,their,merging,takes,place,a,painless,type,name,is,one,of,the,following,ul,li,def,the,painless,dynamic,type,which,is,automatically,included,without,a,need,to,be,whitelisted,li,li,fully,qualified,java,type,name,any,whitelisted,java,class,will,have,the,equivalent,name,as,a,painless,type,name,with,the,exception,that,any,dollar,symbols,used,as,part,of,inner,classes,will,be,replaced,with,dot,symbols,li,li,short,java,type,name,the,text,after,the,final,dot,symbol,of,any,specified,java,class,a,short,type,java,name,may,be,excluded,by,using,the,token,during,painless,class,parsing,as,described,later,li,ul,the,following,can,be,parsed,from,each,whitelist,text,file,ul,li,blank,lines,will,be,ignored,by,the,parser,li,li,comments,may,be,created,starting,with,a,pound,symbol,and,end,with,a,newline,these,will,be,ignored,by,the,parser,li,li,primitive,types,may,be,specified,starting,with,class,and,followed,by,the,java,type,name,an,opening,bracket,a,newline,a,closing,bracket,and,a,final,newline,li,li,complex,types,may,be,specified,starting,with,class,and,followed,the,fully,qualified,java,class,name,optionally,followed,by,an,token,an,opening,bracket,a,newline,constructor,method,field,specifications,a,closing,bracket,and,a,final,newline,within,a,complex,type,the,following,may,be,parsed,ul,li,a,constructor,may,be,specified,starting,with,an,opening,parenthesis,followed,by,a,comma,delimited,list,of,painless,type,names,corresponding,to,the,type,class,names,for,the,equivalent,java,parameter,types,these,must,be,whitelisted,as,well,a,closing,parenthesis,and,a,newline,li,li,a,method,may,be,specified,starting,with,a,painless,type,name,for,the,return,type,followed,by,the,java,name,of,the,method,which,will,also,be,the,painless,name,for,the,method,an,opening,parenthesis,a,comma,delimited,list,of,painless,type,names,corresponding,to,the,type,class,names,for,the,equivalent,java,parameter,types,these,must,be,whitelisted,as,well,a,closing,parenthesis,and,a,newline,li,li,an,augmented,method,may,be,specified,starting,with,a,painless,type,name,for,the,return,type,followed,by,the,fully,qualified,java,name,of,the,class,the,augmented,method,is,part,of,this,class,does,not,need,to,be,whitelisted,the,java,name,of,the,method,which,will,also,be,the,painless,name,for,the,method,an,opening,parenthesis,a,comma,delimited,list,of,painless,type,names,corresponding,to,the,type,class,names,for,the,equivalent,java,parameter,types,these,must,be,whitelisted,as,well,a,closing,parenthesis,and,a,newline,li,li,a,field,may,be,specified,starting,with,a,painless,type,name,for,the,equivalent,java,type,of,the,field,followed,by,the,java,name,of,the,field,which,all,be,the,painless,name,for,the,field,and,a,newline,li,ul,ul,note,there,must,be,a,one,to,one,correspondence,of,painless,type,names,to,java,type,class,names,if,the,same,painless,type,is,defined,across,multiple,files,and,the,java,class,is,the,same,all,specified,constructors,methods,and,fields,will,be,merged,into,a,single,painless,type,the,painless,dynamic,type,def,used,as,part,of,constructor,method,and,field,definitions,will,be,appropriately,parsed,and,handled,painless,complex,types,must,be,specified,with,the,fully,qualified,java,class,name,method,argument,types,method,return,types,and,field,types,must,be,specified,with,painless,type,names,def,fully,qualified,or,short,as,described,earlier,the,following,example,is,used,to,create,a,single,whitelist,text,file,code,primitive,types,class,int,int,complex,types,class,my,package,example,constructors,int,def,def,example,def,method,example,add,int,def,int,add,example,example,void,example,augmented,example,some,other,class,sub,example,int,def,fields,int,value0,int,value1,def,value2;public,static,whitelist,load,from,resource,files,class,resource,string,filepaths,list,whitelist,class,whitelist,classes,new,array,list,list,whitelist,method,whitelist,statics,new,array,list,list,whitelist,class,binding,whitelist,class,bindings,new,array,list,for,string,filepath,filepaths,string,line,int,number,1,try,line,number,reader,reader,new,line,number,reader,new,input,stream,reader,resource,get,resource,as,stream,filepath,standard,charsets,string,parse,type,null,string,whitelist,class,origin,null,string,java,class,name,null,boolean,no,import,false,list,whitelist,constructor,whitelist,constructors,null,list,whitelist,method,whitelist,methods,null,list,whitelist,field,whitelist,fields,null,while,line,reader,read,line,null,number,reader,get,line,number,line,line,trim,if,line,length,0,line,char,at,0,continue,if,line,starts,with,class,if,line,ends,with,false,throw,new,illegal,argument,exception,invalid,class,definition,failed,to,parse,class,opening,bracket,line,if,parse,type,null,throw,new,illegal,argument,exception,invalid,definition,cannot,embed,class,definition,line,string,tokens,line,substring,5,line,length,1,trim,split,s,if,tokens,length,2,equals,tokens,1,no,import,true,else,if,tokens,length,1,throw,new,illegal,argument,exception,invalid,class,definition,failed,to,parse,class,name,line,parse,type,class,whitelist,class,origin,filepath,number,java,class,name,tokens,0,whitelist,constructors,new,array,list,whitelist,methods,new,array,list,whitelist,fields,new,array,list,else,if,line,starts,with,if,line,ends,with,false,throw,new,illegal,argument,exception,invalid,static,import,definition,failed,to,parse,static,import,opening,bracket,line,if,parse,type,null,throw,new,illegal,argument,exception,invalid,definition,cannot,embed,static,import,definition,line,parse,type,else,if,line,equals,if,parse,type,null,throw,new,illegal,argument,exception,invalid,definition,extraneous,closing,bracket,if,class,equals,parse,type,whitelist,classes,add,new,whitelist,class,whitelist,class,origin,java,class,name,no,import,whitelist,constructors,whitelist,methods,whitelist,fields,whitelist,class,origin,null,java,class,name,null,no,import,false,whitelist,constructors,null,whitelist,methods,null,whitelist,fields,null,parse,type,null,else,if,equals,parse,type,string,origin,filepath,number,int,parameter,start,index,line,index,of,if,parameter,start,index,1,throw,new,illegal,argument,exception,illegal,static,import,definition,start,of,method,parameters,not,found,line,string,tokens,line,substring,0,parameter,start,index,trim,split,s,string,method,name,if,tokens,length,2,method,name,tokens,1,else,throw,new,illegal,argument,exception,invalid,method,definition,unexpected,format,line,string,return,canonical,type,name,tokens,0,int,parameter,end,index,line,index,of,if,parameter,end,index,1,throw,new,illegal,argument,exception,illegal,static,import,definition,end,of,method,parameters,not,found,line,string,canonical,type,name,parameters,line,substring,parameter,start,index,1,parameter,end,index,replace,all,s,split,if,equals,canonical,type,name,parameters,0,canonical,type,name,parameters,new,string,0,tokens,line,substring,parameter,end,index,1,trim,split,s,string,static,import,type,string,target,java,class,name,if,tokens,length,2,static,import,type,tokens,0,target,java,class,name,tokens,1,else,throw,new,illegal,argument,exception,invalid,static,import,definition,unexpected,format,line,if,equals,static,import,type,whitelist,statics,add,new,whitelist,method,origin,target,java,class,name,method,name,return,canonical,type,name,arrays,as,list,canonical,type,name,parameters,else,if,equals,static,import,type,whitelist,class,bindings,add,new,whitelist,class,binding,origin,target,java,class,name,method,name,return,canonical,type,name,arrays,as,list,canonical,type,name,parameters,else,throw,new,illegal,argument,exception,invalid,static,import,definition,unexpected,static,import,type,static,import,type,line,else,if,class,equals,parse,type,string,origin,filepath,number,if,line,starts,with,if,line,ends,with,false,throw,new,illegal,argument,exception,invalid,constructor,definition,expected,a,closing,parenthesis,line,string,tokens,line,substring,1,line,length,1,replace,all,s,split,if,equals,tokens,0,tokens,new,string,0,whitelist,constructors,add,new,whitelist,constructor,origin,arrays,as,list,tokens,else,if,line,contains,if,line,ends,with,false,throw,new,illegal,argument,exception,invalid,method,definition,expected,a,closing,parenthesis,line,int,parameter,index,line,index,of,string,tokens,line,substring,0,parameter,index,trim,split,s,string,method,name,string,java,augmented,class,name,if,tokens,length,2,method,name,tokens,1,java,augmented,class,name,null,else,if,tokens,length,3,method,name,tokens,2,java,augmented,class,name,tokens,1,else,throw,new,illegal,argument,exception,invalid,method,definition,unexpected,format,line,string,return,canonical,type,name,tokens,0,tokens,line,substring,parameter,index,1,line,length,1,replace,all,s,split,if,equals,tokens,0,tokens,new,string,0,whitelist,methods,add,new,whitelist,method,origin,java,augmented,class,name,method,name,return,canonical,type,name,arrays,as,list,tokens,else,string,tokens,line,split,s,if,tokens,length,2,throw,new,illegal,argument,exception,invalid,field,definition,unexpected,format,line,whitelist,fields,add,new,whitelist,field,origin,tokens,1,tokens,0,else,throw,new,illegal,argument,exception,invalid,definition,unable,to,parse,line,line,if,java,class,name,null,throw,new,illegal,argument,exception,invalid,definition,expected,closing,bracket,catch,exception,exception,throw,new,runtime,exception,error,in,filepath,at,line,number,exception,class,loader,loader,access,controller,do,privileged,privileged,action,class,loader,resource,get,class,loader,return,new,whitelist,loader,whitelist,classes,whitelist,statics,whitelist,class,bindings
WhitelistLoader -> public static Whitelist loadFromResourceFiles(Class<?> resource, String... filepaths);1540486836;Loads and creates a {@link Whitelist} from one to many text files. The file paths are passed in as an array of_{@link String}s with a single {@link Class} to be be used to load the resources where each {@link String}_is the path of a single text file. The {@link Class}'s {@link ClassLoader} will be used to lookup the Java_reflection objects for each individual {@link Class}, {@link Constructor}, {@link Method}, and {@link Field}_specified as part of the whitelist in the text file.__A single pass is made through each file to collect all the information about each class, constructor, method,_and field. Most validation will be done at a later point after all whitelists have been gathered and their_merging takes place.__A painless type name is one of the following:_<ul>_<li> def - The Painless dynamic type which is automatically included without a need to be_whitelisted. </li>_<li> fully-qualified Java type name - Any whitelisted Java class will have the equivalent name as_a Painless type name with the exception that any dollar symbols used as part of inner classes will_be replaced with dot symbols. </li>_<li> short Java type name - The text after the final dot symbol of any specified Java class. A_short type Java name may be excluded by using the 'no_import' token during Painless class parsing_as described later. </li>_</ul>__The following can be parsed from each whitelist text file:_<ul>_<li> Blank lines will be ignored by the parser. </li>_<li> Comments may be created starting with a pound '#' symbol and end with a newline. These will_be ignored by the parser. </li>_<li> Primitive types may be specified starting with 'class' and followed by the Java type name,_an opening bracket, a newline, a closing bracket, and a final newline. </li>_<li> Complex types may be specified starting with 'class' and followed the fully-qualified Java_class name, optionally followed by an 'no_import' token, an opening bracket, a newline,_constructor/method/field specifications, a closing bracket, and a final newline. Within a complex_type the following may be parsed:_<ul>_<li> A constructor may be specified starting with an opening parenthesis, followed by a_comma-delimited list of Painless type names corresponding to the type/class names for_the equivalent Java parameter types (these must be whitelisted as well), a closing_parenthesis, and a newline. </li>_<li> A method may be specified starting with a Painless type name for the return type,_followed by the Java name of the method (which will also be the Painless name for the_method), an opening parenthesis, a comma-delimited list of Painless type names_corresponding to the type/class names for the equivalent Java parameter types_(these must be whitelisted as well), a closing parenthesis, and a newline. </li>_<li> An augmented method may be specified starting with a Painless type name for the return_type, followed by the fully qualified Java name of the class the augmented method is_part of (this class does not need to be whitelisted), the Java name of the method_(which will also be the Painless name for the method), an opening parenthesis, a_comma-delimited list of Painless type names corresponding to the type/class names_for the equivalent Java parameter types (these must be whitelisted as well), a closing_parenthesis, and a newline. </li>_<li>A field may be specified starting with a Painless type name for the equivalent Java type_of the field, followed by the Java name of the field (which all be the Painless name_for the field), and a newline. </li>_</ul>_</ul>__Note there must be a one-to-one correspondence of Painless type names to Java type/class names._If the same Painless type is defined across multiple files and the Java class is the same, all_specified constructors, methods, and fields will be merged into a single Painless type. The_Painless dynamic type, 'def', used as part of constructor, method, and field definitions will_be appropriately parsed and handled. Painless complex types must be specified with the_fully-qualified Java class name. Method argument types, method return types, and field types_must be specified with Painless type names (def, fully-qualified, or short) as described earlier.__The following example is used to create a single whitelist text file:__{@code_# primitive types__class int -> int {___# complex types__class my.package.Example no_import {_# constructors__(int)_(def, def)_(Example, def)__# method_Example add(int, def)_int add(Example, Example)_void example()__# augmented_Example some.other.Class sub(Example, int, def)__# fields_int value0_int value1_def value2;public static Whitelist loadFromResourceFiles(Class<?> resource, String... filepaths) {_        List<WhitelistClass> whitelistClasses = new ArrayList<>()__        List<WhitelistMethod> whitelistStatics = new ArrayList<>()__        List<WhitelistClassBinding> whitelistClassBindings = new ArrayList<>()___        _        _        for (String filepath : filepaths) {_            String line__            int number = -1___            try (LineNumberReader reader = new LineNumberReader(_                    new InputStreamReader(resource.getResourceAsStream(filepath), StandardCharsets.UTF_8))) {__                String parseType = null__                String whitelistClassOrigin = null__                String javaClassName = null__                boolean noImport = false__                List<WhitelistConstructor> whitelistConstructors = null__                List<WhitelistMethod> whitelistMethods = null__                List<WhitelistField> whitelistFields = null___                while ((line = reader.readLine()) != null) {_                    number = reader.getLineNumber()__                    line = line.trim()___                    _                    if (line.length() == 0 || line.charAt(0) == '#') {_                        continue__                    }__                    _                    _                    if (line.startsWith("class ")) {_                        _                        if (line.endsWith("{") == false) {_                            throw new IllegalArgumentException(_                                    "invalid class definition: failed to parse class opening bracket [" + line + "]")__                        }__                        if (parseType != null) {_                            throw new IllegalArgumentException("invalid definition: cannot embed class definition [" + line + "]")__                        }__                        _                        String[] tokens = line.substring(5, line.length() - 1).trim().split("\\s+")___                        _                        if (tokens.length == 2 && "no_import".equals(tokens[1])) {_                            noImport = true__                        } else if (tokens.length != 1) {_                            throw new IllegalArgumentException("invalid class definition: failed to parse class name [" + line + "]")__                        }__                        parseType = "class"__                        whitelistClassOrigin = "[" + filepath + "]:[" + number + "]"__                        javaClassName = tokens[0]___                        _                        whitelistConstructors = new ArrayList<>()__                        whitelistMethods = new ArrayList<>()__                        whitelistFields = new ArrayList<>()__                    } else if (line.startsWith("static_import ")) {_                        _                        if (line.endsWith("{") == false) {_                            throw new IllegalArgumentException(_                                    "invalid static import definition: failed to parse static import opening bracket [" + line + "]")__                        }__                        if (parseType != null) {_                            throw new IllegalArgumentException("invalid definition: cannot embed static import definition [" + line + "]")__                        }__                        parseType = "static_import"___                    _                    _                    } else if (line.equals("}")) {_                        if (parseType == null) {_                            throw new IllegalArgumentException("invalid definition: extraneous closing bracket")__                        }__                        _                        _                        if ("class".equals(parseType)) {_                            whitelistClasses.add(new WhitelistClass(whitelistClassOrigin, javaClassName, noImport,_                                    whitelistConstructors, whitelistMethods, whitelistFields))___                            whitelistClassOrigin = null__                            javaClassName = null__                            noImport = false__                            whitelistConstructors = null__                            whitelistMethods = null__                            whitelistFields = null__                        }__                        _                        parseType = null___                    _                    _                    } else if ("static_import".equals(parseType)) {_                        _                        String origin = "[" + filepath + "]:[" + number + "]"___                        _                        int parameterStartIndex = line.indexOf('(')___                        if (parameterStartIndex == -1) {_                            throw new IllegalArgumentException(_                                    "illegal static import definition: start of method parameters not found [" + line + "]")__                        }__                        String[] tokens = line.substring(0, parameterStartIndex).trim().split("\\s+")___                        String methodName___                        _                        if (tokens.length == 2) {_                            methodName = tokens[1]__                        } else {_                            throw new IllegalArgumentException("invalid method definition: unexpected format [" + line + "]")__                        }__                        String returnCanonicalTypeName = tokens[0]___                        _                        int parameterEndIndex = line.indexOf(')')___                        if (parameterEndIndex == -1) {_                            throw new IllegalArgumentException(_                                    "illegal static import definition: end of method parameters not found [" + line + "]")__                        }__                        String[] canonicalTypeNameParameters =_                                line.substring(parameterStartIndex + 1, parameterEndIndex).replaceAll("\\s+", "").split(",")___                        _                        if ("".equals(canonicalTypeNameParameters[0])) {_                            canonicalTypeNameParameters = new String[0]__                        }__                        _                        tokens = line.substring(parameterEndIndex + 1).trim().split("\\s+")___                        String staticImportType__                        String targetJavaClassName___                        _                        if (tokens.length == 2) {_                            staticImportType = tokens[0]__                            targetJavaClassName = tokens[1]__                        } else {_                            throw new IllegalArgumentException("invalid static import definition: unexpected format [" + line + "]")__                        }__                        _                        if ("from_class".equals(staticImportType)) {_                            whitelistStatics.add(new WhitelistMethod(origin, targetJavaClassName,_                                    methodName, returnCanonicalTypeName, Arrays.asList(canonicalTypeNameParameters)))__                        } else if ("bound_to".equals(staticImportType)) {_                            whitelistClassBindings.add(new WhitelistClassBinding(origin, targetJavaClassName,_                                    methodName, returnCanonicalTypeName, Arrays.asList(canonicalTypeNameParameters)))__                        } else {_                            throw new IllegalArgumentException("invalid static import definition: " +_                                    "unexpected static import type [" + staticImportType + "] [" + line + "]")__                        }__                    _                    } else if ("class".equals(parseType)) {_                        _                        String origin = "[" + filepath + "]:[" + number + "]"___                        _                        _                        if (line.startsWith("(")) {_                            _                            if (line.endsWith(")") == false) {_                                throw new IllegalArgumentException(_                                        "invalid constructor definition: expected a closing parenthesis [" + line + "]")__                            }__                            _                            String[] tokens = line.substring(1, line.length() - 1).replaceAll("\\s+", "").split(",")___                            _                            if ("".equals(tokens[0])) {_                                tokens = new String[0]__                            }__                            whitelistConstructors.add(new WhitelistConstructor(origin, Arrays.asList(tokens)))___                            _                            _                        } else if (line.contains("(")) {_                            _                            if (line.endsWith(")") == false) {_                                throw new IllegalArgumentException(_                                        "invalid method definition: expected a closing parenthesis [" + line + "]")__                            }__                            _                            int parameterIndex = line.indexOf('(')__                            String[] tokens = line.substring(0, parameterIndex).trim().split("\\s+")___                            String methodName__                            String javaAugmentedClassName___                            _                            if (tokens.length == 2) {_                                methodName = tokens[1]__                                javaAugmentedClassName = null__                            } else if (tokens.length == 3) {_                                methodName = tokens[2]__                                javaAugmentedClassName = tokens[1]__                            } else {_                                throw new IllegalArgumentException("invalid method definition: unexpected format [" + line + "]")__                            }__                            String returnCanonicalTypeName = tokens[0]___                            _                            tokens = line.substring(parameterIndex + 1, line.length() - 1).replaceAll("\\s+", "").split(",")___                            _                            if ("".equals(tokens[0])) {_                                tokens = new String[0]__                            }__                            whitelistMethods.add(new WhitelistMethod(origin, javaAugmentedClassName, methodName,_                                    returnCanonicalTypeName, Arrays.asList(tokens)))___                            _                            _                        } else {_                            _                            String[] tokens = line.split("\\s+")___                            _                            if (tokens.length != 2) {_                                throw new IllegalArgumentException("invalid field definition: unexpected format [" + line + "]")__                            }__                            whitelistFields.add(new WhitelistField(origin, tokens[1], tokens[0]))__                        }_                    } else {_                        throw new IllegalArgumentException("invalid definition: unable to parse line [" + line + "]")__                    }_                }__                _                if (javaClassName != null) {_                    throw new IllegalArgumentException("invalid definition: expected closing bracket")__                }_            } catch (Exception exception) {_                throw new RuntimeException("error in [" + filepath + "] at line [" + number + "]", exception)__            }_        }__        ClassLoader loader = AccessController.doPrivileged((PrivilegedAction<ClassLoader>)resource::getClassLoader)___        return new Whitelist(loader, whitelistClasses, whitelistStatics, whitelistClassBindings, Collections.emptyList())__    };loads,and,creates,a,link,whitelist,from,one,to,many,text,files,the,file,paths,are,passed,in,as,an,array,of,link,string,s,with,a,single,link,class,to,be,be,used,to,load,the,resources,where,each,link,string,is,the,path,of,a,single,text,file,the,link,class,s,link,class,loader,will,be,used,to,lookup,the,java,reflection,objects,for,each,individual,link,class,link,constructor,link,method,and,link,field,specified,as,part,of,the,whitelist,in,the,text,file,a,single,pass,is,made,through,each,file,to,collect,all,the,information,about,each,class,constructor,method,and,field,most,validation,will,be,done,at,a,later,point,after,all,whitelists,have,been,gathered,and,their,merging,takes,place,a,painless,type,name,is,one,of,the,following,ul,li,def,the,painless,dynamic,type,which,is,automatically,included,without,a,need,to,be,whitelisted,li,li,fully,qualified,java,type,name,any,whitelisted,java,class,will,have,the,equivalent,name,as,a,painless,type,name,with,the,exception,that,any,dollar,symbols,used,as,part,of,inner,classes,will,be,replaced,with,dot,symbols,li,li,short,java,type,name,the,text,after,the,final,dot,symbol,of,any,specified,java,class,a,short,type,java,name,may,be,excluded,by,using,the,token,during,painless,class,parsing,as,described,later,li,ul,the,following,can,be,parsed,from,each,whitelist,text,file,ul,li,blank,lines,will,be,ignored,by,the,parser,li,li,comments,may,be,created,starting,with,a,pound,symbol,and,end,with,a,newline,these,will,be,ignored,by,the,parser,li,li,primitive,types,may,be,specified,starting,with,class,and,followed,by,the,java,type,name,an,opening,bracket,a,newline,a,closing,bracket,and,a,final,newline,li,li,complex,types,may,be,specified,starting,with,class,and,followed,the,fully,qualified,java,class,name,optionally,followed,by,an,token,an,opening,bracket,a,newline,constructor,method,field,specifications,a,closing,bracket,and,a,final,newline,within,a,complex,type,the,following,may,be,parsed,ul,li,a,constructor,may,be,specified,starting,with,an,opening,parenthesis,followed,by,a,comma,delimited,list,of,painless,type,names,corresponding,to,the,type,class,names,for,the,equivalent,java,parameter,types,these,must,be,whitelisted,as,well,a,closing,parenthesis,and,a,newline,li,li,a,method,may,be,specified,starting,with,a,painless,type,name,for,the,return,type,followed,by,the,java,name,of,the,method,which,will,also,be,the,painless,name,for,the,method,an,opening,parenthesis,a,comma,delimited,list,of,painless,type,names,corresponding,to,the,type,class,names,for,the,equivalent,java,parameter,types,these,must,be,whitelisted,as,well,a,closing,parenthesis,and,a,newline,li,li,an,augmented,method,may,be,specified,starting,with,a,painless,type,name,for,the,return,type,followed,by,the,fully,qualified,java,name,of,the,class,the,augmented,method,is,part,of,this,class,does,not,need,to,be,whitelisted,the,java,name,of,the,method,which,will,also,be,the,painless,name,for,the,method,an,opening,parenthesis,a,comma,delimited,list,of,painless,type,names,corresponding,to,the,type,class,names,for,the,equivalent,java,parameter,types,these,must,be,whitelisted,as,well,a,closing,parenthesis,and,a,newline,li,li,a,field,may,be,specified,starting,with,a,painless,type,name,for,the,equivalent,java,type,of,the,field,followed,by,the,java,name,of,the,field,which,all,be,the,painless,name,for,the,field,and,a,newline,li,ul,ul,note,there,must,be,a,one,to,one,correspondence,of,painless,type,names,to,java,type,class,names,if,the,same,painless,type,is,defined,across,multiple,files,and,the,java,class,is,the,same,all,specified,constructors,methods,and,fields,will,be,merged,into,a,single,painless,type,the,painless,dynamic,type,def,used,as,part,of,constructor,method,and,field,definitions,will,be,appropriately,parsed,and,handled,painless,complex,types,must,be,specified,with,the,fully,qualified,java,class,name,method,argument,types,method,return,types,and,field,types,must,be,specified,with,painless,type,names,def,fully,qualified,or,short,as,described,earlier,the,following,example,is,used,to,create,a,single,whitelist,text,file,code,primitive,types,class,int,int,complex,types,class,my,package,example,constructors,int,def,def,example,def,method,example,add,int,def,int,add,example,example,void,example,augmented,example,some,other,class,sub,example,int,def,fields,int,value0,int,value1,def,value2;public,static,whitelist,load,from,resource,files,class,resource,string,filepaths,list,whitelist,class,whitelist,classes,new,array,list,list,whitelist,method,whitelist,statics,new,array,list,list,whitelist,class,binding,whitelist,class,bindings,new,array,list,for,string,filepath,filepaths,string,line,int,number,1,try,line,number,reader,reader,new,line,number,reader,new,input,stream,reader,resource,get,resource,as,stream,filepath,standard,charsets,string,parse,type,null,string,whitelist,class,origin,null,string,java,class,name,null,boolean,no,import,false,list,whitelist,constructor,whitelist,constructors,null,list,whitelist,method,whitelist,methods,null,list,whitelist,field,whitelist,fields,null,while,line,reader,read,line,null,number,reader,get,line,number,line,line,trim,if,line,length,0,line,char,at,0,continue,if,line,starts,with,class,if,line,ends,with,false,throw,new,illegal,argument,exception,invalid,class,definition,failed,to,parse,class,opening,bracket,line,if,parse,type,null,throw,new,illegal,argument,exception,invalid,definition,cannot,embed,class,definition,line,string,tokens,line,substring,5,line,length,1,trim,split,s,if,tokens,length,2,equals,tokens,1,no,import,true,else,if,tokens,length,1,throw,new,illegal,argument,exception,invalid,class,definition,failed,to,parse,class,name,line,parse,type,class,whitelist,class,origin,filepath,number,java,class,name,tokens,0,whitelist,constructors,new,array,list,whitelist,methods,new,array,list,whitelist,fields,new,array,list,else,if,line,starts,with,if,line,ends,with,false,throw,new,illegal,argument,exception,invalid,static,import,definition,failed,to,parse,static,import,opening,bracket,line,if,parse,type,null,throw,new,illegal,argument,exception,invalid,definition,cannot,embed,static,import,definition,line,parse,type,else,if,line,equals,if,parse,type,null,throw,new,illegal,argument,exception,invalid,definition,extraneous,closing,bracket,if,class,equals,parse,type,whitelist,classes,add,new,whitelist,class,whitelist,class,origin,java,class,name,no,import,whitelist,constructors,whitelist,methods,whitelist,fields,whitelist,class,origin,null,java,class,name,null,no,import,false,whitelist,constructors,null,whitelist,methods,null,whitelist,fields,null,parse,type,null,else,if,equals,parse,type,string,origin,filepath,number,int,parameter,start,index,line,index,of,if,parameter,start,index,1,throw,new,illegal,argument,exception,illegal,static,import,definition,start,of,method,parameters,not,found,line,string,tokens,line,substring,0,parameter,start,index,trim,split,s,string,method,name,if,tokens,length,2,method,name,tokens,1,else,throw,new,illegal,argument,exception,invalid,method,definition,unexpected,format,line,string,return,canonical,type,name,tokens,0,int,parameter,end,index,line,index,of,if,parameter,end,index,1,throw,new,illegal,argument,exception,illegal,static,import,definition,end,of,method,parameters,not,found,line,string,canonical,type,name,parameters,line,substring,parameter,start,index,1,parameter,end,index,replace,all,s,split,if,equals,canonical,type,name,parameters,0,canonical,type,name,parameters,new,string,0,tokens,line,substring,parameter,end,index,1,trim,split,s,string,static,import,type,string,target,java,class,name,if,tokens,length,2,static,import,type,tokens,0,target,java,class,name,tokens,1,else,throw,new,illegal,argument,exception,invalid,static,import,definition,unexpected,format,line,if,equals,static,import,type,whitelist,statics,add,new,whitelist,method,origin,target,java,class,name,method,name,return,canonical,type,name,arrays,as,list,canonical,type,name,parameters,else,if,equals,static,import,type,whitelist,class,bindings,add,new,whitelist,class,binding,origin,target,java,class,name,method,name,return,canonical,type,name,arrays,as,list,canonical,type,name,parameters,else,throw,new,illegal,argument,exception,invalid,static,import,definition,unexpected,static,import,type,static,import,type,line,else,if,class,equals,parse,type,string,origin,filepath,number,if,line,starts,with,if,line,ends,with,false,throw,new,illegal,argument,exception,invalid,constructor,definition,expected,a,closing,parenthesis,line,string,tokens,line,substring,1,line,length,1,replace,all,s,split,if,equals,tokens,0,tokens,new,string,0,whitelist,constructors,add,new,whitelist,constructor,origin,arrays,as,list,tokens,else,if,line,contains,if,line,ends,with,false,throw,new,illegal,argument,exception,invalid,method,definition,expected,a,closing,parenthesis,line,int,parameter,index,line,index,of,string,tokens,line,substring,0,parameter,index,trim,split,s,string,method,name,string,java,augmented,class,name,if,tokens,length,2,method,name,tokens,1,java,augmented,class,name,null,else,if,tokens,length,3,method,name,tokens,2,java,augmented,class,name,tokens,1,else,throw,new,illegal,argument,exception,invalid,method,definition,unexpected,format,line,string,return,canonical,type,name,tokens,0,tokens,line,substring,parameter,index,1,line,length,1,replace,all,s,split,if,equals,tokens,0,tokens,new,string,0,whitelist,methods,add,new,whitelist,method,origin,java,augmented,class,name,method,name,return,canonical,type,name,arrays,as,list,tokens,else,string,tokens,line,split,s,if,tokens,length,2,throw,new,illegal,argument,exception,invalid,field,definition,unexpected,format,line,whitelist,fields,add,new,whitelist,field,origin,tokens,1,tokens,0,else,throw,new,illegal,argument,exception,invalid,definition,unable,to,parse,line,line,if,java,class,name,null,throw,new,illegal,argument,exception,invalid,definition,expected,closing,bracket,catch,exception,exception,throw,new,runtime,exception,error,in,filepath,at,line,number,exception,class,loader,loader,access,controller,do,privileged,privileged,action,class,loader,resource,get,class,loader,return,new,whitelist,loader,whitelist,classes,whitelist,statics,whitelist,class,bindings,collections,empty,list
