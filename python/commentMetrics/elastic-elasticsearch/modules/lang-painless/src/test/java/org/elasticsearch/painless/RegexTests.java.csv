commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;7;;@Override protected Settings scriptEngineSettings() {     // Enable regexes just for this test. They are disabled by default.     return Settings.builder().put(CompilerSettings.REGEX_ENABLED.getKey(), true).build(). }
false;public;0;4;;public void testPatternAfterReturn() {     assertEquals(true, exec("return 'foo' ==~ /foo/")).     assertEquals(false, exec("return 'bar' ==~ /foo/")). }
false;public;0;3;;public void testBackslashEscapesForwardSlash() {     assertEquals(true, exec("'//' ==~ /\\/\\//")). }
false;public;0;4;;public void testBackslashEscapeBackslash() {     // Both of these are single backslashes but java escaping + Painless escaping....     assertEquals(true, exec("'\\\\' ==~ /\\\\/")). }
false;public;0;3;;public void testRegexIsNonGreedy() {     assertEquals(true, exec("def s = /\\\\/.split('.\\\\.'). return s[1] ==~ /\\./")). }
false;public;0;3;;public void testPatternAfterAssignment() {     assertEquals(true, exec("def a = /foo/. return 'foo' ==~ a")). }
false;public;0;4;;public void testPatternInIfStement() {     assertEquals(true, exec("if (/foo/.matcher('foo').matches()) { return true } else { return false }")).     assertEquals(true, exec("if ('foo' ==~ /foo/) { return true } else { return false }")). }
false;public;0;6;;public void testPatternAfterInfixBoolean() {     assertEquals(true, exec("return false || /foo/.matcher('foo').matches()")).     assertEquals(true, exec("return true && /foo/.matcher('foo').matches()")).     assertEquals(true, exec("return false || 'foo' ==~ /foo/")).     assertEquals(true, exec("return true && 'foo' ==~ /foo/")). }
false;public;0;4;;public void testPatternAfterUnaryNotBoolean() {     assertEquals(false, exec("return !/foo/.matcher('foo').matches()")).     assertEquals(true, exec("return !/foo/.matcher('bar').matches()")). }
false;public;0;6;;public void testInTernaryCondition() {     assertEquals(true, exec("return /foo/.matcher('foo').matches() ? true : false")).     assertEquals(1, exec("def i = 0. i += /foo/.matcher('foo').matches() ? 1 : 1. return i")).     assertEquals(true, exec("return 'foo' ==~ /foo/ ? true : false")).     assertEquals(1, exec("def i = 0. i += 'foo' ==~ /foo/ ? 1 : 1. return i")). }
false;public;0;4;;public void testInTernaryTrueArm() {     assertEquals(true, exec("def i = true. return i ? /foo/.matcher('foo').matches() : false")).     assertEquals(true, exec("def i = true. return i ? 'foo' ==~ /foo/ : false")). }
false;public;0;3;;public void testInTernaryFalseArm() {     assertEquals(true, exec("def i = false. return i ? false : 'foo' ==~ /foo/")). }
false;public;0;4;;public void testRegexInFunction() {     assertEquals(true, exec("boolean m(String s) {/foo/.matcher(s).matches()} m('foo')")).     assertEquals(true, exec("boolean m(String s) {s ==~ /foo/} m('foo')")). }
false;public;0;6;;public void testReturnRegexFromFunction() {     assertEquals(true, exec("Pattern m(boolean a) {a ? /foo/ : /bar/} m(true).matcher('foo').matches()")).     assertEquals(true, exec("Pattern m(boolean a) {a ? /foo/ : /bar/} 'foo' ==~ m(true)")).     assertEquals(false, exec("Pattern m(boolean a) {a ? /foo/ : /bar/} m(false).matcher('foo').matches()")).     assertEquals(false, exec("Pattern m(boolean a) {a ? /foo/ : /bar/} 'foo' ==~ m(false)")). }
false;public;0;4;;public void testCallMatcherDirectly() {     assertEquals(true, exec("return /foo/.matcher('foo').matches()")).     assertEquals(false, exec("return /foo/.matcher('bar').matches()")). }
false;public;0;5;;public void testFindInIf() {     assertEquals(true, exec("if ('fooasdfbasdf' =~ /foo/) {return true} else {return false}")).     assertEquals(true, exec("if ('1fooasdfbasdf' =~ /foo/) {return true} else {return false}")).     assertEquals(false, exec("if ('1f11ooasdfbasdf' =~ /foo/) {return true} else {return false}")). }
false;public;0;5;;public void testFindCastToBoolean() {     assertEquals(true, exec("return (boolean)('fooasdfbasdf' =~ /foo/)")).     assertEquals(true, exec("return (boolean)('111fooasdfbasdf' =~ /foo/)")).     assertEquals(false, exec("return (boolean)('fo11oasdfbasdf' =~ /foo/)")). }
false;public;0;3;;public void testFindOrStringConcat() {     assertEquals(true, exec("return 'f' + 'o' + 'o' =~ /foo/")). }
false;public;0;3;;public void testFindOfDef() {     assertEquals(true, exec("def s = 'foo'. return s =~ /foo/")). }
false;public;0;4;;public void testFindOnInput() {     assertEquals(true, exec("return params.s =~ /foo/", singletonMap("s", "fooasdfdf"), true)).     assertEquals(false, exec("return params.s =~ /foo/", singletonMap("s", "11f2ooasdfdf"), true)). }
false;public;0;3;;public void testGroup() {     assertEquals("foo", exec("Matcher m = /foo/.matcher('foo'). m.find(). return m.group()")). }
false;public;0;3;;public void testNumberedGroup() {     assertEquals("o", exec("Matcher m = /(f)(o)o/.matcher('foo'). m.find(). return m.group(2)")). }
false;public;0;3;;public void testNamedGroup() {     assertEquals("o", exec("Matcher m = /(?<first>f)(?<second>o)o/.matcher('foo'). m.find(). return m.namedGroup('second')")). }
true;public;0;3;// Make sure some methods on Pattern are whitelisted ;// Make sure some methods on Pattern are whitelisted public void testSplit() {     assertArrayEquals(new String[] { "cat", "dog" }, (String[]) exec("/,/.split('cat,dog')")). }
false;public;0;3;;public void testSplitAsStream() {     assertEquals(new HashSet<String>(Arrays.asList("cat", "dog")), exec("/,/.splitAsStream('cat,dog').collect(Collectors.toSet())")). }
true;public;0;3;// Make sure the flags are set ;// Make sure the flags are set public void testMultilineFlag() {     assertEquals(Pattern.MULTILINE, exec("/./m.flags()")). }
false;public;0;3;;public void testSinglelineFlag() {     assertEquals(Pattern.DOTALL, exec("/./s.flags()")). }
false;public;0;3;;public void testInsensitiveFlag() {     assertEquals(Pattern.CASE_INSENSITIVE, exec("/./i.flags()")). }
false;public;0;3;;public void testExtendedFlag() {     assertEquals(Pattern.COMMENTS, exec("/./x.flags()")). }
false;public;0;3;;public void testUnicodeCaseFlag() {     assertEquals(Pattern.UNICODE_CASE, exec("/./u.flags()")). }
false;public;0;3;;public void testUnicodeCharacterClassFlag() {     assertEquals(Pattern.UNICODE_CASE | Pattern.UNICODE_CHARACTER_CLASS, exec("/./U.flags()")). }
false;public;0;3;;public void testLiteralFlag() {     assertEquals(Pattern.LITERAL, exec("/./l.flags()")). }
false;public;0;3;;public void testCanonicalEquivalenceFlag() {     assertEquals(Pattern.CANON_EQ, exec("/./c.flags()")). }
false;public;0;3;;public void testManyFlags() {     assertEquals(Pattern.CANON_EQ | Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE | Pattern.COMMENTS, exec("/./ciux.flags()")). }
false;public;0;3;;public void testReplaceAllMatchesString() {     assertEquals("thE qUIck brOwn fOx", exec("'the quick brown fox'.replaceAll(/[aeiou]/, m -> m.group().toUpperCase(Locale.ROOT))")). }
false;public;0;5;;public void testReplaceAllMatchesCharSequence() {     CharSequence charSequence = CharBuffer.wrap("the quick brown fox").     assertEquals("thE qUIck brOwn fOx", exec("params.a.replaceAll(/[aeiou]/, m -> m.group().toUpperCase(Locale.ROOT))", singletonMap("a", charSequence), true)). }
false;public;0;3;;public void testReplaceAllNoMatchString() {     assertEquals("i am cat", exec("'i am cat'.replaceAll(/dolphin/, m -> m.group().toUpperCase(Locale.ROOT))")). }
false;public;0;5;;public void testReplaceAllNoMatchCharSequence() {     CharSequence charSequence = CharBuffer.wrap("i am cat").     assertEquals("i am cat", exec("params.a.replaceAll(/dolphin/, m -> m.group().toUpperCase(Locale.ROOT))", singletonMap("a", charSequence), true)). }
false;public;0;6;;public void testReplaceAllQuoteReplacement() {     assertEquals("th/E q/U/Ick br/Own f/Ox", exec("'the quick brown fox'.replaceAll(/[aeiou]/, m -> '/' + m.group().toUpperCase(Locale.ROOT))")).     assertEquals("th$E q$U$Ick br$Own f$Ox", exec("'the quick brown fox'.replaceAll(/[aeiou]/, m -> '$' + m.group().toUpperCase(Locale.ROOT))")). }
false;public;0;4;;public void testReplaceFirstMatchesString() {     assertEquals("thE quick brown fox", exec("'the quick brown fox'.replaceFirst(/[aeiou]/, m -> m.group().toUpperCase(Locale.ROOT))")). }
false;public;0;5;;public void testReplaceFirstMatchesCharSequence() {     CharSequence charSequence = CharBuffer.wrap("the quick brown fox").     assertEquals("thE quick brown fox", exec("params.a.replaceFirst(/[aeiou]/, m -> m.group().toUpperCase(Locale.ROOT))", singletonMap("a", charSequence), true)). }
false;public;0;3;;public void testReplaceFirstNoMatchString() {     assertEquals("i am cat", exec("'i am cat'.replaceFirst(/dolphin/, m -> m.group().toUpperCase(Locale.ROOT))")). }
false;public;0;5;;public void testReplaceFirstNoMatchCharSequence() {     CharSequence charSequence = CharBuffer.wrap("i am cat").     assertEquals("i am cat", exec("params.a.replaceFirst(/dolphin/, m -> m.group().toUpperCase(Locale.ROOT))", singletonMap("a", charSequence), true)). }
false;public;0;6;;public void testReplaceFirstQuoteReplacement() {     assertEquals("th/E quick brown fox", exec("'the quick brown fox'.replaceFirst(/[aeiou]/, m -> '/' + m.group().toUpperCase(Locale.ROOT))")).     assertEquals("th$E quick brown fox", exec("'the quick brown fox'.replaceFirst(/[aeiou]/, m -> '$' + m.group().toUpperCase(Locale.ROOT))")). }
false;public;0;6;;public void testCantUsePatternCompile() {     IllegalArgumentException e = expectScriptThrows(IllegalArgumentException.class, () -> {         exec("Pattern.compile('aa')").     }).     assertTrue(e.getMessage().contains("[java.util.regex.Pattern, compile/1]")). }
false;public;0;11;;public void testBadRegexPattern() {     ScriptException e = expectThrows(ScriptException.class, () -> {         // Invalid unicode         exec("/\\ujjjj/").     }).     assertEquals("Error compiling regex: Illegal Unicode escape sequence", e.getCause().getMessage()).     // And make sure the location of the error points to the offset inside the pattern     assertScriptStack(e, "/\\ujjjj/", "   ^---- HERE"). }
false;public;0;6;;public void testRegexAgainstNumber() {     ClassCastException e = expectScriptThrows(ClassCastException.class, () -> {         exec("12 ==~ /cat/").     }).     assertEquals("Cannot cast from [int] to [java.lang.String].", e.getMessage()). }
false;public;0;6;;public void testBogusRegexFlag() {     IllegalArgumentException e = expectScriptThrows(IllegalArgumentException.class, () -> {         // Not picky so we get a non-assertion error         exec("/asdf/b", false).     }).     assertEquals("unexpected token ['b'] was expecting one of [{<EOF>, '.'}].", e.getMessage()). }
