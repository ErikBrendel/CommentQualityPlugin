commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;25;;protected Map<ScriptContext<?>, List<Whitelist>> scriptContexts() {     Map<ScriptContext<?>, List<Whitelist>> contexts = new HashMap<>().     contexts.put(Gets.CONTEXT, Whitelist.BASE_WHITELISTS).     contexts.put(NoArgs.CONTEXT, Whitelist.BASE_WHITELISTS).     contexts.put(OneArg.CONTEXT, Whitelist.BASE_WHITELISTS).     contexts.put(ArrayArg.CONTEXT, Whitelist.BASE_WHITELISTS).     contexts.put(PrimitiveArrayArg.CONTEXT, Whitelist.BASE_WHITELISTS).     contexts.put(DefArrayArg.CONTEXT, Whitelist.BASE_WHITELISTS).     contexts.put(ManyArgs.CONTEXT, Whitelist.BASE_WHITELISTS).     contexts.put(VarArgs.CONTEXT, Whitelist.BASE_WHITELISTS).     contexts.put(DefaultMethods.CONTEXT, Whitelist.BASE_WHITELISTS).     contexts.put(ReturnsVoid.CONTEXT, Whitelist.BASE_WHITELISTS).     contexts.put(ReturnsPrimitiveBoolean.CONTEXT, Whitelist.BASE_WHITELISTS).     contexts.put(ReturnsPrimitiveInt.CONTEXT, Whitelist.BASE_WHITELISTS).     contexts.put(ReturnsPrimitiveFloat.CONTEXT, Whitelist.BASE_WHITELISTS).     contexts.put(ReturnsPrimitiveDouble.CONTEXT, Whitelist.BASE_WHITELISTS).     contexts.put(NoArgsConstant.CONTEXT, Whitelist.BASE_WHITELISTS).     contexts.put(WrongArgsConstant.CONTEXT, Whitelist.BASE_WHITELISTS).     contexts.put(WrongLengthOfArgConstant.CONTEXT, Whitelist.BASE_WHITELISTS).     contexts.put(UnknownArgType.CONTEXT, Whitelist.BASE_WHITELISTS).     contexts.put(UnknownReturnType.CONTEXT, Whitelist.BASE_WHITELISTS).     contexts.put(UnknownArgTypeInArray.CONTEXT, Whitelist.BASE_WHITELISTS).     contexts.put(TwoExecuteMethods.CONTEXT, Whitelist.BASE_WHITELISTS).     return contexts. }
false;;3;1;;Gets newInstance(String testString, int testInt, Map<String, Object> params).
false;public,abstract;0;1;;public abstract Object execute().
false;public;0;3;;public String getTestString() {     return testString. }
false;public;0;3;;public int getTestInt() {     return Math.abs(testInt). }
false;public;0;3;;public Map<String, Object> getTestMap() {     return testMap == null ? new HashMap<>() : testMap. }
false;public;0;15;;public void testGets() throws Exception {     Map<String, Object> map = new HashMap<>().     map.put("s", 1).     assertEquals(1, scriptEngine.compile("testGets0", "testInt", Gets.CONTEXT, emptyMap()).newInstance("s", -1, null).execute()).     assertEquals(Collections.emptyMap(), scriptEngine.compile("testGets1", "testMap", Gets.CONTEXT, emptyMap()).newInstance("s", -1, null).execute()).     assertEquals(Collections.singletonMap("1", "1"), scriptEngine.compile("testGets2", "testMap", Gets.CONTEXT, emptyMap()).newInstance("s", -1, Collections.singletonMap("1", "1")).execute()).     assertEquals("s", scriptEngine.compile("testGets3", "testString", Gets.CONTEXT, emptyMap()).newInstance("s", -1, null).execute()).     assertEquals(map, scriptEngine.compile("testGets4", "testMap.put(testString, testInt). testMap", Gets.CONTEXT, emptyMap()).newInstance("s", -1, null).execute()). }
false;;0;1;;NoArgs newInstance().
false;public,abstract;0;1;;public abstract Object execute().
false;public;0;15;;public void testNoArgs() throws Exception {     assertEquals(1, scriptEngine.compile("testNoArgs0", "1", NoArgs.CONTEXT, emptyMap()).newInstance().execute()).     assertEquals("foo", scriptEngine.compile("testNoArgs1", "'foo'", NoArgs.CONTEXT, emptyMap()).newInstance().execute()).     Exception e = expectScriptThrows(IllegalArgumentException.class, () -> scriptEngine.compile("testNoArgs2", "doc", NoArgs.CONTEXT, emptyMap())).     assertEquals("Variable [doc] is not defined.", e.getMessage()).     e = expectScriptThrows(IllegalArgumentException.class, () -> scriptEngine.compile("testNoArgs3", "_score", NoArgs.CONTEXT, emptyMap())).     assertEquals("Variable [_score] is not defined.", e.getMessage()).     String debug = Debugger.toString(NoArgs.class, "int i = 0", new CompilerSettings()).     assertThat(debug, containsString("ACONST_NULL")).     assertThat(debug, containsString("ARETURN")). }
false;;0;1;;OneArg newInstance().
false;public,abstract;1;1;;public abstract Object execute(Object arg).
false;public;0;6;;public void testOneArg() throws Exception {     Object rando = randomInt().     assertEquals(rando, scriptEngine.compile("testOneArg0", "arg", OneArg.CONTEXT, emptyMap()).newInstance().execute(rando)).     rando = randomAlphaOfLength(5).     assertEquals(rando, scriptEngine.compile("testOneArg1", "arg", OneArg.CONTEXT, emptyMap()).newInstance().execute(rando)). }
false;;0;1;;ArrayArg newInstance().
false;public,abstract;1;1;;public abstract Object execute(String[] arg).
false;public;0;6;;public void testArrayArg() throws Exception {     String rando = randomAlphaOfLength(5).     assertEquals(rando, scriptEngine.compile("testArrayArg0", "arg[0]", ArrayArg.CONTEXT, emptyMap()).newInstance().execute(new String[] { rando, "foo" })). }
false;;0;1;;PrimitiveArrayArg newInstance().
false;public,abstract;1;1;;public abstract Object execute(int[] arg).
false;public;0;6;;public void testPrimitiveArrayArg() throws Exception {     int rando = randomInt().     assertEquals(rando, scriptEngine.compile("PrimitiveArrayArg0", "arg[0]", PrimitiveArrayArg.CONTEXT, emptyMap()).newInstance().execute(new int[] { rando, 10 })). }
false;;0;1;;DefArrayArg newInstance().
false;public,abstract;1;1;;public abstract Object execute(Object[] arg).
false;public;0;13;;public void testDefArrayArg() throws Exception {     Object rando = randomInt().     assertEquals(rando, scriptEngine.compile("testDefArray0", "arg[0]", DefArrayArg.CONTEXT, emptyMap()).newInstance().execute(new Object[] { rando, 10 })).     rando = randomAlphaOfLength(5).     assertEquals(rando, scriptEngine.compile("testDefArray1", "arg[0]", DefArrayArg.CONTEXT, emptyMap()).newInstance().execute(new Object[] { rando, 10 })).     assertEquals(5, scriptEngine.compile("testDefArray2", "arg[0].length()", DefArrayArg.CONTEXT, emptyMap()).newInstance().execute(new Object[] { rando, 10 })). }
false;;0;1;;ManyArgs newInstance().
false;public,abstract;4;1;;public abstract Object execute(int a, int b, int c, int d).
false;public,abstract;0;1;;public abstract boolean needsA().
false;public,abstract;0;1;;public abstract boolean needsB().
false;public,abstract;0;1;;public abstract boolean needsC().
false;public,abstract;0;1;;public abstract boolean needsD().
false;public;0;24;;public void testManyArgs() throws Exception {     int rando = randomInt().     assertEquals(rando, scriptEngine.compile("testManyArgs0", "a", ManyArgs.CONTEXT, emptyMap()).newInstance().execute(rando, 0, 0, 0)).     assertEquals(10, scriptEngine.compile("testManyArgs1", "a + b + c + d", ManyArgs.CONTEXT, emptyMap()).newInstance().execute(1, 2, 3, 4)).     // While we're here we can verify that painless correctly finds used variables     ManyArgs script = scriptEngine.compile("testManyArgs2", "a", ManyArgs.CONTEXT, emptyMap()).newInstance().     assertTrue(script.needsA()).     assertFalse(script.needsB()).     assertFalse(script.needsC()).     assertFalse(script.needsD()).     script = scriptEngine.compile("testManyArgs3", "a + b + c", ManyArgs.CONTEXT, emptyMap()).newInstance().     assertTrue(script.needsA()).     assertTrue(script.needsB()).     assertTrue(script.needsC()).     assertFalse(script.needsD()).     script = scriptEngine.compile("testManyArgs4", "a + b + c + d", ManyArgs.CONTEXT, emptyMap()).newInstance().     assertTrue(script.needsA()).     assertTrue(script.needsB()).     assertTrue(script.needsC()).     assertTrue(script.needsD()). }
false;;0;1;;VarArgs newInstance().
false;public,abstract;1;1;;public abstract Object execute(String... arg).
false;public;0;5;;public void testVarArgs() throws Exception {     assertEquals("foo bar baz", scriptEngine.compile("testVarArgs0", "String.join(' ', Arrays.asList(arg))", VarArgs.CONTEXT, emptyMap()).newInstance().execute("foo", "bar", "baz")). }
false;;0;1;;DefaultMethods newInstance().
false;public,abstract;4;1;;public abstract Object execute(int a, int b, int c, int d).
false;public;0;3;;public Object executeWithOne() {     return execute(1, 1, 1, 1). }
false;public;3;3;;public Object executeWithASingleOne(int a, int b, int c) {     return execute(a, b, c, 1). }
false;public;0;17;;public void testDefaultMethods() throws Exception {     int rando = randomInt().     assertEquals(rando, scriptEngine.compile("testDefaultMethods0", "a", DefaultMethods.CONTEXT, emptyMap()).newInstance().execute(rando, 0, 0, 0)).     assertEquals(rando, scriptEngine.compile("testDefaultMethods1", "a", DefaultMethods.CONTEXT, emptyMap()).newInstance().executeWithASingleOne(rando, 0, 0)).     assertEquals(10, scriptEngine.compile("testDefaultMethods2", "a + b + c + d", DefaultMethods.CONTEXT, emptyMap()).newInstance().execute(1, 2, 3, 4)).     assertEquals(4, scriptEngine.compile("testDefaultMethods3", "a + b + c + d", DefaultMethods.CONTEXT, emptyMap()).newInstance().executeWithOne()).     assertEquals(7, scriptEngine.compile("testDefaultMethods4", "a + b + c + d", DefaultMethods.CONTEXT, emptyMap()).newInstance().executeWithASingleOne(1, 2, 3)). }
false;;0;1;;ReturnsVoid newInstance().
false;public,abstract;1;1;;public abstract void execute(Map<String, Object> map).
false;public;0;13;;public void testReturnsVoid() throws Exception {     Map<String, Object> map = new HashMap<>().     scriptEngine.compile("testReturnsVoid0", "map.a = 'foo'", ReturnsVoid.CONTEXT, emptyMap()).newInstance().execute(map).     assertEquals(Collections.singletonMap("a", "foo"), map).     scriptEngine.compile("testReturnsVoid1", "map.remove('a')", ReturnsVoid.CONTEXT, emptyMap()).newInstance().execute(map).     assertEquals(emptyMap(), map).     String debug = Debugger.toString(ReturnsVoid.class, "int i = 0", new CompilerSettings()).     // The important thing is that this contains the opcode for returning void     assertThat(debug, containsString(" RETURN")).     // We shouldn't contain any weird "default to null" logic     assertThat(debug, not(containsString("ACONST_NULL"))). }
false;;0;1;;ReturnsPrimitiveBoolean newInstance().
false;public,abstract;0;1;;public abstract boolean execute().
false;public;0;55;;public void testReturnsPrimitiveBoolean() throws Exception {     assertTrue(scriptEngine.compile("testReturnsPrimitiveBoolean0", "true", ReturnsPrimitiveBoolean.CONTEXT, emptyMap()).newInstance().execute()).     assertFalse(scriptEngine.compile("testReturnsPrimitiveBoolean1", "false", ReturnsPrimitiveBoolean.CONTEXT, emptyMap()).newInstance().execute()).     assertTrue(scriptEngine.compile("testReturnsPrimitiveBoolean2", "Boolean.TRUE", ReturnsPrimitiveBoolean.CONTEXT, emptyMap()).newInstance().execute()).     assertFalse(scriptEngine.compile("testReturnsPrimitiveBoolean3", "Boolean.FALSE", ReturnsPrimitiveBoolean.CONTEXT, emptyMap()).newInstance().execute()).     assertTrue(scriptEngine.compile("testReturnsPrimitiveBoolean4", "def i = true. i", ReturnsPrimitiveBoolean.CONTEXT, emptyMap()).newInstance().execute()).     assertTrue(scriptEngine.compile("testReturnsPrimitiveBoolean5", "def i = Boolean.TRUE. i", ReturnsPrimitiveBoolean.CONTEXT, emptyMap()).newInstance().execute()).     assertTrue(scriptEngine.compile("testReturnsPrimitiveBoolean6", "true || false", ReturnsPrimitiveBoolean.CONTEXT, emptyMap()).newInstance().execute()).     String debug = Debugger.toString(ReturnsPrimitiveBoolean.class, "false", new CompilerSettings()).     assertThat(debug, containsString("ICONST_0")).     // The important thing here is that we have the bytecode for returning an integer instead of an object. booleans are integers.     assertThat(debug, containsString("IRETURN")).     Exception e = expectScriptThrows(ClassCastException.class, () -> scriptEngine.compile("testReturnsPrimitiveBoolean7", "1L", ReturnsPrimitiveBoolean.CONTEXT, emptyMap()).newInstance().execute()).     assertEquals("Cannot cast from [long] to [boolean].", e.getMessage()).     e = expectScriptThrows(ClassCastException.class, () -> scriptEngine.compile("testReturnsPrimitiveBoolean8", "1.1f", ReturnsPrimitiveBoolean.CONTEXT, emptyMap()).newInstance().execute()).     assertEquals("Cannot cast from [float] to [boolean].", e.getMessage()).     e = expectScriptThrows(ClassCastException.class, () -> scriptEngine.compile("testReturnsPrimitiveBoolean9", "1.1d", ReturnsPrimitiveBoolean.CONTEXT, emptyMap()).newInstance().execute()).     assertEquals("Cannot cast from [double] to [boolean].", e.getMessage()).     expectScriptThrows(ClassCastException.class, () -> scriptEngine.compile("testReturnsPrimitiveBoolean10", "def i = 1L. i", ReturnsPrimitiveBoolean.CONTEXT, emptyMap()).newInstance().execute()).     expectScriptThrows(ClassCastException.class, () -> scriptEngine.compile("testReturnsPrimitiveBoolean11", "def i = 1.1f. i", ReturnsPrimitiveBoolean.CONTEXT, emptyMap()).newInstance().execute()).     expectScriptThrows(ClassCastException.class, () -> scriptEngine.compile("testReturnsPrimitiveBoolean12", "def i = 1.1d. i", ReturnsPrimitiveBoolean.CONTEXT, emptyMap()).newInstance().execute()).     assertFalse(scriptEngine.compile("testReturnsPrimitiveBoolean13", "int i = 0", ReturnsPrimitiveBoolean.CONTEXT, emptyMap()).newInstance().execute()). }
false;;0;1;;ReturnsPrimitiveInt newInstance().
false;public,abstract;0;1;;public abstract int execute().
false;public;0;53;;public void testReturnsPrimitiveInt() throws Exception {     assertEquals(1, scriptEngine.compile("testReturnsPrimitiveInt0", "1", ReturnsPrimitiveInt.CONTEXT, emptyMap()).newInstance().execute()).     assertEquals(1, scriptEngine.compile("testReturnsPrimitiveInt1", "(int) 1L", ReturnsPrimitiveInt.CONTEXT, emptyMap()).newInstance().execute()).     assertEquals(1, scriptEngine.compile("testReturnsPrimitiveInt2", "(int) 1.1d", ReturnsPrimitiveInt.CONTEXT, emptyMap()).newInstance().execute()).     assertEquals(1, scriptEngine.compile("testReturnsPrimitiveInt3", "(int) 1.1f", ReturnsPrimitiveInt.CONTEXT, emptyMap()).newInstance().execute()).     assertEquals(1, scriptEngine.compile("testReturnsPrimitiveInt4", "Integer.valueOf(1)", ReturnsPrimitiveInt.CONTEXT, emptyMap()).newInstance().execute()).     assertEquals(1, scriptEngine.compile("testReturnsPrimitiveInt5", "def i = 1. i", ReturnsPrimitiveInt.CONTEXT, emptyMap()).newInstance().execute()).     assertEquals(1, scriptEngine.compile("testReturnsPrimitiveInt6", "def i = Integer.valueOf(1). i", ReturnsPrimitiveInt.CONTEXT, emptyMap()).newInstance().execute()).     assertEquals(2, scriptEngine.compile("testReturnsPrimitiveInt7", "1 + 1", ReturnsPrimitiveInt.CONTEXT, emptyMap()).newInstance().execute()).     String debug = Debugger.toString(ReturnsPrimitiveInt.class, "1", new CompilerSettings()).     assertThat(debug, containsString("ICONST_1")).     // The important thing here is that we have the bytecode for returning an integer instead of an object     assertThat(debug, containsString("IRETURN")).     Exception e = expectScriptThrows(ClassCastException.class, () -> scriptEngine.compile("testReturnsPrimitiveInt8", "1L", ReturnsPrimitiveInt.CONTEXT, emptyMap()).newInstance().execute()).     assertEquals("Cannot cast from [long] to [int].", e.getMessage()).     e = expectScriptThrows(ClassCastException.class, () -> scriptEngine.compile("testReturnsPrimitiveInt9", "1.1f", ReturnsPrimitiveInt.CONTEXT, emptyMap()).newInstance().execute()).     assertEquals("Cannot cast from [float] to [int].", e.getMessage()).     e = expectScriptThrows(ClassCastException.class, () -> scriptEngine.compile("testReturnsPrimitiveInt10", "1.1d", ReturnsPrimitiveInt.CONTEXT, emptyMap()).newInstance().execute()).     assertEquals("Cannot cast from [double] to [int].", e.getMessage()).     expectScriptThrows(ClassCastException.class, () -> scriptEngine.compile("testReturnsPrimitiveInt11", "def i = 1L. i", ReturnsPrimitiveInt.CONTEXT, emptyMap()).newInstance().execute()).     expectScriptThrows(ClassCastException.class, () -> scriptEngine.compile("testReturnsPrimitiveInt12", "def i = 1.1f. i", ReturnsPrimitiveInt.CONTEXT, emptyMap()).newInstance().execute()).     expectScriptThrows(ClassCastException.class, () -> scriptEngine.compile("testReturnsPrimitiveInt13", "def i = 1.1d. i", ReturnsPrimitiveInt.CONTEXT, emptyMap()).newInstance().execute()).     assertEquals(0, scriptEngine.compile("testReturnsPrimitiveInt14", "int i = 0", ReturnsPrimitiveInt.CONTEXT, emptyMap()).newInstance().execute()). }
false;;0;1;;ReturnsPrimitiveFloat newInstance().
false;public,abstract;0;1;;public abstract float execute().
false;public;0;38;;public void testReturnsPrimitiveFloat() throws Exception {     assertEquals(1.1f, scriptEngine.compile("testReturnsPrimitiveFloat0", "1.1f", ReturnsPrimitiveFloat.CONTEXT, emptyMap()).newInstance().execute(), 0).     assertEquals(1.1f, scriptEngine.compile("testReturnsPrimitiveFloat1", "(float) 1.1d", ReturnsPrimitiveFloat.CONTEXT, emptyMap()).newInstance().execute(), 0).     assertEquals(1.1f, scriptEngine.compile("testReturnsPrimitiveFloat2", "def d = 1.1f. d", ReturnsPrimitiveFloat.CONTEXT, emptyMap()).newInstance().execute(), 0).     assertEquals(1.1f, scriptEngine.compile("testReturnsPrimitiveFloat3", "def d = Float.valueOf(1.1f). d", ReturnsPrimitiveFloat.CONTEXT, emptyMap()).newInstance().execute(), 0).     assertEquals(1.1f + 6.7f, scriptEngine.compile("testReturnsPrimitiveFloat4", "1.1f + 6.7f", ReturnsPrimitiveFloat.CONTEXT, emptyMap()).newInstance().execute(), 0).     Exception e = expectScriptThrows(ClassCastException.class, () -> scriptEngine.compile("testReturnsPrimitiveFloat5", "1.1d", ReturnsPrimitiveFloat.CONTEXT, emptyMap()).newInstance().execute()).     assertEquals("Cannot cast from [double] to [float].", e.getMessage()).     e = expectScriptThrows(ClassCastException.class, () -> scriptEngine.compile("testReturnsPrimitiveFloat6", "def d = 1.1d. d", ReturnsPrimitiveFloat.CONTEXT, emptyMap()).newInstance().execute()).     e = expectScriptThrows(ClassCastException.class, () -> scriptEngine.compile("testReturnsPrimitiveFloat7", "def d = Double.valueOf(1.1). d", ReturnsPrimitiveFloat.CONTEXT, emptyMap()).newInstance().execute()).     String debug = Debugger.toString(ReturnsPrimitiveFloat.class, "1f", new CompilerSettings()).     assertThat(debug, containsString("FCONST_1")).     // The important thing here is that we have the bytecode for returning a float instead of an object     assertThat(debug, containsString("FRETURN")).     assertEquals(0.0f, scriptEngine.compile("testReturnsPrimitiveFloat8", "int i = 0", ReturnsPrimitiveFloat.CONTEXT, emptyMap()).newInstance().execute(), 0). }
false;;0;1;;ReturnsPrimitiveDouble newInstance().
false;public,abstract;0;1;;public abstract double execute().
false;public;0;52;;public void testReturnsPrimitiveDouble() throws Exception {     assertEquals(1.0, scriptEngine.compile("testReturnsPrimitiveDouble0", "1", ReturnsPrimitiveDouble.CONTEXT, emptyMap()).newInstance().execute(), 0).     assertEquals(1.0, scriptEngine.compile("testReturnsPrimitiveDouble1", "1L", ReturnsPrimitiveDouble.CONTEXT, emptyMap()).newInstance().execute(), 0).     assertEquals(1.1, scriptEngine.compile("testReturnsPrimitiveDouble2", "1.1d", ReturnsPrimitiveDouble.CONTEXT, emptyMap()).newInstance().execute(), 0).     assertEquals((double) 1.1f, scriptEngine.compile("testReturnsPrimitiveDouble3", "1.1f", ReturnsPrimitiveDouble.CONTEXT, emptyMap()).newInstance().execute(), 0).     assertEquals(1.1, scriptEngine.compile("testReturnsPrimitiveDouble4", "Double.valueOf(1.1)", ReturnsPrimitiveDouble.CONTEXT, emptyMap()).newInstance().execute(), 0).     assertEquals((double) 1.1f, scriptEngine.compile("testReturnsPrimitiveDouble5", "Float.valueOf(1.1f)", ReturnsPrimitiveDouble.CONTEXT, emptyMap()).newInstance().execute(), 0).     assertEquals(1.0, scriptEngine.compile("testReturnsPrimitiveDouble6", "def d = 1. d", ReturnsPrimitiveDouble.CONTEXT, emptyMap()).newInstance().execute(), 0).     assertEquals(1.0, scriptEngine.compile("testReturnsPrimitiveDouble7", "def d = 1L. d", ReturnsPrimitiveDouble.CONTEXT, emptyMap()).newInstance().execute(), 0).     assertEquals(1.1, scriptEngine.compile("testReturnsPrimitiveDouble8", "def d = 1.1d. d", ReturnsPrimitiveDouble.CONTEXT, emptyMap()).newInstance().execute(), 0).     assertEquals((double) 1.1f, scriptEngine.compile("testReturnsPrimitiveDouble9", "def d = 1.1f. d", ReturnsPrimitiveDouble.CONTEXT, emptyMap()).newInstance().execute(), 0).     assertEquals(1.1, scriptEngine.compile("testReturnsPrimitiveDouble10", "def d = Double.valueOf(1.1). d", ReturnsPrimitiveDouble.CONTEXT, emptyMap()).newInstance().execute(), 0).     assertEquals((double) 1.1f, scriptEngine.compile("testReturnsPrimitiveDouble11", "def d = Float.valueOf(1.1f). d", ReturnsPrimitiveDouble.CONTEXT, emptyMap()).newInstance().execute(), 0).     assertEquals(1.1 + 6.7, scriptEngine.compile("testReturnsPrimitiveDouble12", "1.1 + 6.7", ReturnsPrimitiveDouble.CONTEXT, emptyMap()).newInstance().execute(), 0).     String debug = Debugger.toString(ReturnsPrimitiveDouble.class, "1", new CompilerSettings()).     assertThat(debug, containsString("DCONST_1")).     // The important thing here is that we have the bytecode for returning a double instead of an object     assertThat(debug, containsString("DRETURN")).     assertEquals(0.0, scriptEngine.compile("testReturnsPrimitiveDouble13", "int i = 0", ReturnsPrimitiveDouble.CONTEXT, emptyMap()).newInstance().execute(), 0). }
false;;0;1;;NoArgsConstant newInstance().
false;public,abstract;1;1;;public abstract Object execute(String foo).
false;public;0;7;;public void testNoArgsConstant() {     Exception e = expectScriptThrows(IllegalArgumentException.class, false, () -> scriptEngine.compile("testNoArgsConstant0", "1", NoArgsConstant.CONTEXT, emptyMap()).newInstance().execute("constant")).     assertThat(e.getMessage(), startsWith("Painless needs a constant [String[] PARAMETERS] on all interfaces it implements with the " + "names of the method arguments but [" + NoArgsConstant.class.getName() + "] doesn't have one.")). }
false;;0;1;;WrongArgsConstant newInstance().
false;public,abstract;1;1;;public abstract Object execute(String foo).
false;public;0;7;;public void testWrongArgsConstant() {     Exception e = expectScriptThrows(IllegalArgumentException.class, false, () -> scriptEngine.compile("testWrongArgsConstant0", "1", WrongArgsConstant.CONTEXT, emptyMap())).     assertThat(e.getMessage(), startsWith("Painless needs a constant [String[] PARAMETERS] on all interfaces it implements with the " + "names of the method arguments but [" + WrongArgsConstant.class.getName() + "] doesn't have one.")). }
false;;0;1;;WrongLengthOfArgConstant newInstance().
false;public,abstract;1;1;;public abstract Object execute(String foo).
false;public;0;6;;public void testWrongLengthOfArgConstant() {     Exception e = expectScriptThrows(IllegalArgumentException.class, false, () -> scriptEngine.compile("testWrongLengthOfArgConstant", "1", WrongLengthOfArgConstant.CONTEXT, emptyMap())).     assertThat(e.getMessage(), startsWith("[" + WrongLengthOfArgConstant.class.getName() + "#ARGUMENTS] has length [2] but [" + WrongLengthOfArgConstant.class.getName() + "#execute] takes [1] argument.")). }
false;;0;1;;UnknownArgType newInstance().
false;public,abstract;1;1;;public abstract Object execute(UnknownArgType foo).
false;public;0;6;;public void testUnknownArgType() {     Exception e = expectScriptThrows(IllegalArgumentException.class, false, () -> scriptEngine.compile("testUnknownArgType0", "1", UnknownArgType.CONTEXT, emptyMap())).     assertEquals("[foo] is of unknown type [" + UnknownArgType.class.getName() + ". Painless interfaces can only accept arguments " + "that are of whitelisted types.", e.getMessage()). }
false;;0;1;;UnknownReturnType newInstance().
false;public,abstract;1;1;;public abstract UnknownReturnType execute(String foo).
false;public;0;6;;public void testUnknownReturnType() {     Exception e = expectScriptThrows(IllegalArgumentException.class, false, () -> scriptEngine.compile("testUnknownReturnType0", "1", UnknownReturnType.CONTEXT, emptyMap())).     assertEquals("Painless can only implement execute methods returning a whitelisted type but [" + UnknownReturnType.class.getName() + "#execute] returns [" + UnknownReturnType.class.getName() + "] which isn't whitelisted.", e.getMessage()). }
false;;0;1;;UnknownArgTypeInArray newInstance().
false;public,abstract;1;1;;public abstract Object execute(UnknownArgTypeInArray[] foo).
false;public;0;6;;public void testUnknownArgTypeInArray() {     Exception e = expectScriptThrows(IllegalArgumentException.class, false, () -> scriptEngine.compile("testUnknownAryTypeInArray0", "1", UnknownArgTypeInArray.CONTEXT, emptyMap())).     assertEquals("[foo] is of unknown type [" + UnknownArgTypeInArray.class.getName() + ". Painless interfaces can only accept " + "arguments that are of whitelisted types.", e.getMessage()). }
false;;0;1;;TwoExecuteMethods newInstance().
false;public,abstract;0;1;;public abstract Object execute().
false;public,abstract;1;1;;public abstract Object execute(boolean foo).
false;public;0;6;;public void testTwoExecuteMethods() {     Exception e = expectScriptThrows(IllegalArgumentException.class, false, () -> scriptEngine.compile("testTwoExecuteMethods0", "null", TwoExecuteMethods.CONTEXT, emptyMap())).     assertEquals("Painless can only implement interfaces that have a single method named [execute] but [" + TwoExecuteMethods.class.getName() + "] has more than one.", e.getMessage()). }
