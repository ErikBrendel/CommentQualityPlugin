commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Before public void setup() {     scriptEngine = new PainlessScriptEngine(scriptEngineSettings(), scriptContexts()). }
true;protected;0;3;/**  * Settings used to build the script engine. Override to customize settings like {@link RegexTests} does to enable regexes.  */ ;/**  * Settings used to build the script engine. Override to customize settings like {@link RegexTests} does to enable regexes.  */ protected Settings scriptEngineSettings() {     return Settings.EMPTY. }
true;protected;0;5;/**  * Script contexts used to build the script engine. Override to customize which script contexts are available.  */ ;/**  * Script contexts used to build the script engine. Override to customize which script contexts are available.  */ protected Map<ScriptContext<?>, List<Whitelist>> scriptContexts() {     Map<ScriptContext<?>, List<Whitelist>> contexts = new HashMap<>().     contexts.put(PainlessTestScript.CONTEXT, Whitelist.BASE_WHITELISTS).     return contexts. }
true;public;1;3;/**  * Compiles and returns the result of {@code script}  */ ;/**  * Compiles and returns the result of {@code script}  */ public Object exec(String script) {     return exec(script, null, true). }
true;public;2;3;/**  * Compiles and returns the result of {@code script} with access to {@code picky}  */ ;/**  * Compiles and returns the result of {@code script} with access to {@code picky}  */ public Object exec(String script, boolean picky) {     return exec(script, null, picky). }
true;public;3;5;/**  * Compiles and returns the result of {@code script} with access to {@code vars}  */ ;/**  * Compiles and returns the result of {@code script} with access to {@code vars}  */ public Object exec(String script, Map<String, Object> vars, boolean picky) {     Map<String, String> compilerSettings = new HashMap<>().     compilerSettings.put(CompilerSettings.INITIAL_CALL_SITE_DEPTH, random().nextBoolean() ? "0" : "10").     return exec(script, vars, compilerSettings, picky). }
true;public;4;15;/**  * Compiles and returns the result of {@code script} with access to {@code vars} and compile-time parameters  */ ;/**  * Compiles and returns the result of {@code script} with access to {@code vars} and compile-time parameters  */ public Object exec(String script, Map<String, Object> vars, Map<String, String> compileParams, boolean picky) {     // test for ambiguity errors before running the actual script if picky is true     if (picky) {         ScriptClassInfo scriptClassInfo = new ScriptClassInfo(PAINLESS_LOOKUP, PainlessTestScript.class).         CompilerSettings pickySettings = new CompilerSettings().         pickySettings.setPicky(true).         pickySettings.setRegexesEnabled(CompilerSettings.REGEX_ENABLED.get(scriptEngineSettings())).         Walker.buildPainlessTree(scriptClassInfo, new MainMethodReserved(), getTestName(), script, pickySettings, PAINLESS_LOOKUP, null).     }     // test actual script execution     PainlessTestScript.Factory factory = scriptEngine.compile(null, script, PainlessTestScript.CONTEXT, compileParams).     PainlessTestScript testScript = factory.newInstance(vars == null ? Collections.emptyMap() : vars).     return testScript.execute(). }
true;public;2;4;/**  * Uses the {@link Debugger} to get the bytecode output for a script and compare  * it against an expected bytecode passed in as a String.  */ ;/**  * Uses the {@link Debugger} to get the bytecode output for a script and compare  * it against an expected bytecode passed in as a String.  */ public void assertBytecodeExists(String script, String bytecode) {     final String asm = Debugger.toString(script).     assertTrue("bytecode not found, got: \n" + asm, asm.contains(bytecode)). }
true;public;2;4;/**  * Uses the {@link Debugger} to get the bytecode output for a script and compare  * it against an expected bytecode pattern as a regular expression (please try to avoid!)  */ ;/**  * Uses the {@link Debugger} to get the bytecode output for a script and compare  * it against an expected bytecode pattern as a regular expression (please try to avoid!)  */ public void assertBytecodeHasPattern(String script, String pattern) {     final String asm = Debugger.toString(script).     assertTrue("bytecode not found, got: \n" + asm, asm.matches(pattern)). }
true;public,static;2;3;/**  * Checks a specific exception class is thrown (boxed inside ScriptException) and returns it.  */ ;/**  * Checks a specific exception class is thrown (boxed inside ScriptException) and returns it.  */ public static <T extends Throwable> T expectScriptThrows(Class<T> expectedType, ThrowingRunnable runnable) {     return expectScriptThrows(expectedType, true, runnable). }
true;public,static;3;36;/**  * Checks a specific exception class is thrown (boxed inside ScriptException) and returns it.  */ ;/**  * Checks a specific exception class is thrown (boxed inside ScriptException) and returns it.  */ public static <T extends Throwable> T expectScriptThrows(Class<T> expectedType, boolean shouldHaveScriptStack, ThrowingRunnable runnable) {     try {         runnable.run().     } catch (Throwable e) {         if (e instanceof ScriptException) {             boolean hasEmptyScriptStack = ((ScriptException) e).getScriptStack().isEmpty().             if (shouldHaveScriptStack && hasEmptyScriptStack) {                 /* If this fails you *might* be missing -XX:-OmitStackTraceInFastThrow in the test jvm                      * In Eclipse you can add this by default by going to Preference->Java->Installed JREs,                      * clicking on the default JRE, clicking edit, and adding the flag to the                      * "Default VM Arguments". */                 AssertionFailedError assertion = new AssertionFailedError("ScriptException should have a scriptStack").                 assertion.initCause(e).                 throw assertion.             } else if (false == shouldHaveScriptStack && false == hasEmptyScriptStack) {                 AssertionFailedError assertion = new AssertionFailedError("ScriptException shouldn't have a scriptStack").                 assertion.initCause(e).                 throw assertion.             }             e = e.getCause().             if (expectedType.isInstance(e)) {                 return expectedType.cast(e).             }         } else {             AssertionFailedError assertion = new AssertionFailedError("Expected boxed ScriptException").             assertion.initCause(e).             throw assertion.         }         AssertionFailedError assertion = new AssertionFailedError("Unexpected exception type, expected " + expectedType.getSimpleName()).         assertion.initCause(e).         throw assertion.     }     throw new AssertionFailedError("Expected exception " + expectedType.getSimpleName()). }
true;public,static;2;12;/**  * Asserts that the script_stack looks right.  */ ;/**  * Asserts that the script_stack looks right.  */ public static void assertScriptStack(ScriptException e, String... stack) {     // This particular incantation of assertions makes the error messages more useful     try {         assertThat(e.getScriptStack(), hasSize(stack.length)).         for (int i = 0. i < stack.length. i++) {             assertEquals(stack[i], e.getScriptStack().get(i)).         }     } catch (AssertionError assertion) {         assertion.initCause(e).         throw assertion.     } }
