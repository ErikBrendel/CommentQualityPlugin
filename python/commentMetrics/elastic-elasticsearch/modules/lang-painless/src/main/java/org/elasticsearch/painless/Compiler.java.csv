commented;modifiers;parameterAmount;loc;comment;code
true;public;1;10;/**  * Will check to see if the {@link Class} has already been loaded when  * the {@link PainlessLookup} was initially created.  Allows for {@link Whitelist}ed  * classes to be loaded from other modules/plugins without a direct relationship  * to the module's/plugin's {@link ClassLoader}.  */ ;/**  * Will check to see if the {@link Class} has already been loaded when  * the {@link PainlessLookup} was initially created.  Allows for {@link Whitelist}ed  * classes to be loaded from other modules/plugins without a direct relationship  * to the module's/plugin's {@link ClassLoader}.  */ @Override public Class<?> findClass(String name) throws ClassNotFoundException {     Class<?> found = additionalClasses.get(name).     if (found != null) {         return found.     }     found = painlessLookup.javaClassNameToClass(name).     return found != null ? found : super.findClass(name). }
true;;2;3;/**  * Generates a Class object from the generated byte code.  * @param name The name of the class.  * @param bytes The generated byte code.  * @return A Class object defining a factory.  */ ;/**  * Generates a Class object from the generated byte code.  * @param name The name of the class.  * @param bytes The generated byte code.  * @return A Class object defining a factory.  */ Class<?> defineFactory(String name, byte[] bytes) {     return defineClass(name, bytes, 0, bytes.length, CODESOURCE). }
true;;2;3;/**  * Generates a Class object from the generated byte code.  * @param name The name of the class.  * @param bytes The generated byte code.  * @return A Class object extending {@link PainlessScript}.  */ ;/**  * Generates a Class object from the generated byte code.  * @param name The name of the class.  * @param bytes The generated byte code.  * @return A Class object extending {@link PainlessScript}.  */ Class<? extends PainlessScript> defineScript(String name, byte[] bytes) {     return defineClass(name, bytes, 0, bytes.length, CODESOURCE).asSubclass(PainlessScript.class). }
true;;2;3;/**  * Generates a Class object for a lambda method.  * @param name The name of the class.  * @param bytes The generated byte code.  * @return A Class object.  */ ;/**  * Generates a Class object for a lambda method.  * @param name The name of the class.  * @param bytes The generated byte code.  * @return A Class object.  */ Class<?> defineLambda(String name, byte[] bytes) {     return defineClass(name, bytes, 0, bytes.length, CODESOURCE). }
true;;0;3;/**  * A counter used to generate a unique name for each lambda  * function/reference class in this classloader.  */ ;/**  * A counter used to generate a unique name for each lambda  * function/reference class in this classloader.  */ int newLambdaIdentifier() {     return lambdaCounter.getAndIncrement(). }
true;public;1;3;/**  * Return a new {@link Loader} for a script using the  * {@link Compiler}'s specified {@link PainlessLookup}.  */ ;/**  * Return a new {@link Loader} for a script using the  * {@link Compiler}'s specified {@link PainlessLookup}.  */ public Loader createLoader(ClassLoader parent) {     return new Loader(parent). }
false;private,static;3;22;;private static void addFactoryMethod(Map<String, Class<?>> additionalClasses, Class<?> factoryClass, String methodName) {     if (factoryClass == null) {         return.     }     Method factoryMethod = null.     for (Method method : factoryClass.getMethods()) {         if (methodName.equals(method.getName())) {             factoryMethod = method.             break.         }     }     if (factoryMethod == null) {         return.     }     additionalClasses.put(factoryClass.getName(), factoryClass).     for (int i = 0. i < factoryMethod.getParameterTypes().length. ++i) {         Class<?> parameterClazz = factoryMethod.getParameterTypes()[i].         additionalClasses.put(parameterClazz.getName(), parameterClazz).     } }
true;;5;23;/**  * Runs the two-pass compiler to generate a Painless script.  * @param loader The ClassLoader used to define the script.  * @param name The name of the script.  * @param source The source code for the script.  * @param settings The CompilerSettings to be used during the compilation.  * @return An executable script that implements both a specified interface and is a subclass of {@link PainlessScript}  */ ;/**  * Runs the two-pass compiler to generate a Painless script.  * @param loader The ClassLoader used to define the script.  * @param name The name of the script.  * @param source The source code for the script.  * @param settings The CompilerSettings to be used during the compilation.  * @return An executable script that implements both a specified interface and is a subclass of {@link PainlessScript}  */ Constructor<?> compile(Loader loader, MainMethodReserved reserved, String name, String source, CompilerSettings settings) {     ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass).     SSource root = Walker.buildPainlessTree(scriptClassInfo, reserved, name, source, settings, painlessLookup, null).     root.analyze(painlessLookup).     Map<String, Object> statics = root.write().     try {         Class<? extends PainlessScript> clazz = loader.defineScript(CLASS_NAME, root.getBytes()).         clazz.getField("$NAME").set(null, name).         clazz.getField("$SOURCE").set(null, source).         clazz.getField("$STATEMENTS").set(null, root.getStatements()).         clazz.getField("$DEFINITION").set(null, painlessLookup).         for (Map.Entry<String, Object> statik : statics.entrySet()) {             clazz.getField(statik.getKey()).set(null, statik.getValue()).         }         return clazz.getConstructors()[0].     } catch (Exception exception) {         // Catch everything to let the user know this is something caused internally.         throw new IllegalStateException("An internal error occurred attempting to define the script [" + name + "].", exception).     } }
true;;4;9;/**  * Runs the two-pass compiler to generate a Painless script.  (Used by the debugger.)  * @param source The source code for the script.  * @param settings The CompilerSettings to be used during the compilation.  * @return The bytes for compilation.  */ ;/**  * Runs the two-pass compiler to generate a Painless script.  (Used by the debugger.)  * @param source The source code for the script.  * @param settings The CompilerSettings to be used during the compilation.  * @return The bytes for compilation.  */ byte[] compile(String name, String source, CompilerSettings settings, Printer debugStream) {     ScriptClassInfo scriptClassInfo = new ScriptClassInfo(painlessLookup, scriptClass).     SSource root = Walker.buildPainlessTree(scriptClassInfo, new MainMethodReserved(), name, source, settings, painlessLookup, debugStream).     root.analyze(painlessLookup).     root.write().     return root.getBytes(). }
