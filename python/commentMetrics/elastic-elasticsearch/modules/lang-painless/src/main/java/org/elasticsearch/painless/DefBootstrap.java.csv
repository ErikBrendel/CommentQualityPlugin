commented;modifiers;parameterAmount;loc;comment;code
true;static;2;3;/**  * guard method for inline caching: checks the receiver's class is the same  * as the cached class  */ ;/**  * guard method for inline caching: checks the receiver's class is the same  * as the cached class  */ static boolean checkClass(Class<?> clazz, Object receiver) {     return receiver.getClass() == clazz. }
true;private;3;21;/**  * Does a slow lookup against the whitelist.  */ ;/**  * Does a slow lookup against the whitelist.  */ private MethodHandle lookup(int flavor, String name, Class<?> receiver) throws Throwable {     switch(flavor) {         case METHOD_CALL:             return Def.lookupMethod(painlessLookup, localMethods, methodHandlesLookup, type(), receiver, name, args).         case LOAD:             return Def.lookupGetter(painlessLookup, receiver, name).         case STORE:             return Def.lookupSetter(painlessLookup, receiver, name).         case ARRAY_LOAD:             return Def.lookupArrayLoad(receiver).         case ARRAY_STORE:             return Def.lookupArrayStore(receiver).         case ITERATOR:             return Def.lookupIterator(receiver).         case REFERENCE:             return Def.lookupReference(painlessLookup, localMethods, methodHandlesLookup, (String) args[0], receiver, name).         case INDEX_NORMALIZE:             return Def.lookupIndexNormalize(receiver).         default:             throw new AssertionError().     } }
false;protected;1;10;;@Override protected MethodHandle computeValue(Class<?> receiverType) {     // it's too stupid that we cannot throw checked exceptions... (use rethrow puzzler):     try {         return lookup(flavor, name, receiverType).asType(type).     } catch (Throwable t) {         Def.rethrow(t).         throw new AssertionError().     } }
true;private;0;17;/**  * Creates the {@link MethodHandle} for the megamorphic call site  * using {@link ClassValue} and {@link MethodHandles#exactInvoker(MethodType)}:  */ ;/**  * Creates the {@link MethodHandle} for the megamorphic call site  * using {@link ClassValue} and {@link MethodHandles#exactInvoker(MethodType)}:  */ private MethodHandle createMegamorphicHandle() {     final MethodType type = type().     final ClassValue<MethodHandle> megamorphicCache = new ClassValue<MethodHandle>() {          @Override         protected MethodHandle computeValue(Class<?> receiverType) {             // it's too stupid that we cannot throw checked exceptions... (use rethrow puzzler):             try {                 return lookup(flavor, name, receiverType).asType(type).             } catch (Throwable t) {                 Def.rethrow(t).                 throw new AssertionError().             }         }     }.     return MethodHandles.foldArguments(MethodHandles.exactInvoker(type), MEGAMORPHIC_LOOKUP.bindTo(megamorphicCache)). }
true;;1;21;/**  * Called when a new type is encountered (or, when we have encountered more than {@code MAX_DEPTH}  * types at this call site and given up on caching using this fallback and we switch to a  * megamorphic cache using {@link ClassValue}).  */ ;/**  * Called when a new type is encountered (or, when we have encountered more than {@code MAX_DEPTH}  * types at this call site and given up on caching using this fallback and we switch to a  * megamorphic cache using {@link ClassValue}).  */ @SuppressForbidden(reason = "slow path") Object fallback(final Object[] callArgs) throws Throwable {     if (depth >= MAX_DEPTH) {         // we revert the whole cache and build a new megamorphic one         final MethodHandle target = this.createMegamorphicHandle().         setTarget(target).         return target.invokeWithArguments(callArgs).     } else {         final Class<?> receiver = callArgs[0].getClass().         final MethodHandle target = lookup(flavor, name, receiver).asType(type()).         MethodHandle test = CHECK_CLASS.bindTo(receiver).         MethodHandle guard = MethodHandles.guardWithTest(test, target, getTarget()).         depth++.         setTarget(guard).         return target.invokeWithArguments(callArgs).     } }
true;private;1;27;/**  * Does a slow lookup for the operator  */ ;/**  * Does a slow lookup for the operator  */ private MethodHandle lookup(Object[] args) throws Throwable {     switch(flavor) {         case UNARY_OPERATOR:         case SHIFT_OPERATOR:             // shifts are treated as unary, as java allows long arguments without a cast (but bits are ignored)             MethodHandle unary = DefMath.lookupUnary(args[0].getClass(), name).             if ((flags & OPERATOR_EXPLICIT_CAST) != 0) {                 unary = DefMath.cast(type().returnType(), unary).             } else if ((flags & OPERATOR_COMPOUND_ASSIGNMENT) != 0) {                 unary = DefMath.cast(args[0].getClass(), unary).             }             return unary.         case BINARY_OPERATOR:             if (args[0] == null || args[1] == null) {                 // can handle nulls, casts if supported                 return lookupGeneric().             } else {                 MethodHandle binary = DefMath.lookupBinary(args[0].getClass(), args[1].getClass(), name).                 if ((flags & OPERATOR_EXPLICIT_CAST) != 0) {                     binary = DefMath.cast(type().returnType(), binary).                 } else if ((flags & OPERATOR_COMPOUND_ASSIGNMENT) != 0) {                     binary = DefMath.cast(args[0].getClass(), binary).                 }                 return binary.             }         default:             throw new AssertionError().     } }
false;private;0;11;;private MethodHandle lookupGeneric() {     MethodHandle target = DefMath.lookupGeneric(name).     if ((flags & OPERATOR_EXPLICIT_CAST) != 0) {         // static cast to the return type         target = DefMath.dynamicCast(target, type().returnType()).     } else if ((flags & OPERATOR_COMPOUND_ASSIGNMENT) != 0) {         // dynamic cast to the receiver's type         target = DefMath.dynamicCast(target).     }     return target. }
true;;1;65;/**  * Called when a new type is encountered or if cached type does not match.  * In that case we revert to a generic, but slower operator handling.  */ ;/**  * Called when a new type is encountered or if cached type does not match.  * In that case we revert to a generic, but slower operator handling.  */ @SuppressForbidden(reason = "slow path") Object fallback(Object[] args) throws Throwable {     if (initialized) {         // caching defeated         MethodHandle generic = lookupGeneric().         setTarget(generic.asType(type())).         return generic.invokeWithArguments(args).     }     final MethodType type = type().     MethodHandle target = lookup(args).     // for math operators: WrongMethodType can be confusing. convert into a ClassCastException if they screw up.     try {         target = target.asType(type).     } catch (WrongMethodTypeException e) {         Exception exc = new ClassCastException("Cannot cast from: " + target.type().returnType() + " to " + type.returnType()).         exc.initCause(e).         throw exc.     }     final MethodHandle test.     if (flavor == BINARY_OPERATOR || flavor == SHIFT_OPERATOR) {         // some binary operators support nulls, we handle them separate         Class<?> clazz0 = args[0] == null ? null : args[0].getClass().         Class<?> clazz1 = args[1] == null ? null : args[1].getClass().         if (type.parameterType(1) != Object.class) {             // case 1: only the receiver is unknown, just check that             MethodHandle unaryTest = CHECK_LHS.bindTo(clazz0).             test = unaryTest.asType(unaryTest.type().changeParameterType(0, type.parameterType(0))).         } else if (type.parameterType(0) != Object.class) {             // case 2: only the argument is unknown, just check that             MethodHandle unaryTest = CHECK_RHS.bindTo(clazz0).bindTo(clazz1).             test = unaryTest.asType(unaryTest.type().changeParameterType(0, type.parameterType(0)).changeParameterType(1, type.parameterType(1))).         } else {             // case 3: check both receiver and argument             MethodHandle binaryTest = CHECK_BOTH.bindTo(clazz0).bindTo(clazz1).             test = binaryTest.asType(binaryTest.type().changeParameterType(0, type.parameterType(0)).changeParameterType(1, type.parameterType(1))).         }     } else {         // unary operator         MethodHandle receiverTest = CHECK_LHS.bindTo(args[0].getClass()).         test = receiverTest.asType(receiverTest.type().changeParameterType(0, type.parameterType(0))).     }     MethodHandle guard = MethodHandles.guardWithTest(test, target, getTarget()).     // we wrap + with an NPE catcher, and use our generic method in that case.     if (flavor == BINARY_OPERATOR && (flags & OPERATOR_ALLOWS_NULL) != 0) {         MethodHandle handler = MethodHandles.dropArguments(lookupGeneric().asType(type()), 0, NullPointerException.class).         guard = MethodHandles.catchException(guard, NullPointerException.class, handler).     }     initialized = true.     setTarget(guard).     return target.invokeWithArguments(args). }
true;static;2;3;/**  * guard method for inline caching: checks the receiver's class is the same  * as the cached class  */ ;/**  * guard method for inline caching: checks the receiver's class is the same  * as the cached class  */ static boolean checkLHS(Class<?> clazz, Object leftObject) {     return leftObject.getClass() == clazz. }
true;static;4;3;/**  * guard method for inline caching: checks the first argument is the same  * as the cached first argument.  */ ;/**  * guard method for inline caching: checks the first argument is the same  * as the cached first argument.  */ static boolean checkRHS(Class<?> left, Class<?> right, Object leftObject, Object rightObject) {     return rightObject.getClass() == right. }
true;static;4;3;/**  * guard method for inline caching: checks the receiver's class and the first argument  * are the same as the cached receiver and first argument.  */ ;/**  * guard method for inline caching: checks the receiver's class and the first argument  * are the same as the cached receiver and first argument.  */ static boolean checkBoth(Class<?> left, Class<?> right, Object leftObject, Object rightObject) {     return leftObject.getClass() == left && rightObject.getClass() == right. }
true;public,static;8;65;/**  * invokeDynamic bootstrap method  * <p>  * In addition to ordinary parameters, we also take some parameters defined at the call site:  * <ul>  *   <li>{@code initialDepth}: initial call site depth. this is used to exercise megamorphic fallback.  *   <li>{@code flavor}: type of dynamic call it is (and which part of whitelist to look at).  *   <li>{@code args}: flavor-specific args.  * </ul>  * And we take the {@link PainlessLookup} used to compile the script for whitelist checking.  * <p>  * see https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.invokedynamic  */ ;/**  * invokeDynamic bootstrap method  * <p>  * In addition to ordinary parameters, we also take some parameters defined at the call site:  * <ul>  *   <li>{@code initialDepth}: initial call site depth. this is used to exercise megamorphic fallback.  *   <li>{@code flavor}: type of dynamic call it is (and which part of whitelist to look at).  *   <li>{@code args}: flavor-specific args.  * </ul>  * And we take the {@link PainlessLookup} used to compile the script for whitelist checking.  * <p>  * see https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.invokedynamic  */ @SuppressWarnings("unchecked") public static CallSite bootstrap(PainlessLookup painlessLookup, Map<String, LocalMethod> localMethods, MethodHandles.Lookup methodHandlesLookup, String name, MethodType type, int initialDepth, int flavor, Object... args) {     // validate arguments     switch(flavor) {         // "function-call" like things get a polymorphic cache         case METHOD_CALL:             if (args.length == 0) {                 throw new BootstrapMethodError("Invalid number of parameters for method call").             }             if (args[0] instanceof String == false) {                 throw new BootstrapMethodError("Illegal parameter for method call: " + args[0]).             }             String recipe = (String) args[0].             int numLambdas = recipe.length().             if (numLambdas > type.parameterCount()) {                 throw new BootstrapMethodError("Illegal recipe for method call: too many bits").             }             if (args.length != numLambdas + 1) {                 throw new BootstrapMethodError("Illegal number of parameters: expected " + numLambdas + " references").             }             return new PIC(painlessLookup, localMethods, methodHandlesLookup, name, type, initialDepth, flavor, args).         case LOAD:         case STORE:         case ARRAY_LOAD:         case ARRAY_STORE:         case ITERATOR:         case INDEX_NORMALIZE:             if (args.length > 0) {                 throw new BootstrapMethodError("Illegal static bootstrap parameters for flavor: " + flavor).             }             return new PIC(painlessLookup, localMethods, methodHandlesLookup, name, type, initialDepth, flavor, args).         case REFERENCE:             if (args.length != 1) {                 throw new BootstrapMethodError("Invalid number of parameters for reference call").             }             if (args[0] instanceof String == false) {                 throw new BootstrapMethodError("Illegal parameter for reference call: " + args[0]).             }             return new PIC(painlessLookup, localMethods, methodHandlesLookup, name, type, initialDepth, flavor, args).         // operators get monomorphic cache, with a generic impl for a fallback         case UNARY_OPERATOR:         case SHIFT_OPERATOR:         case BINARY_OPERATOR:             if (args.length != 1) {                 throw new BootstrapMethodError("Invalid number of parameters for operator call").             }             if (args[0] instanceof Integer == false) {                 throw new BootstrapMethodError("Illegal parameter for reference call: " + args[0]).             }             int flags = (int) args[0].             if ((flags & OPERATOR_ALLOWS_NULL) != 0 && flavor != BINARY_OPERATOR) {                 // we just don't need it anywhere else.                 throw new BootstrapMethodError("This parameter is only supported for BINARY_OPERATORs").             }             if ((flags & OPERATOR_COMPOUND_ASSIGNMENT) != 0 && flavor != BINARY_OPERATOR && flavor != SHIFT_OPERATOR) {                 // we just don't need it anywhere else.                 throw new BootstrapMethodError("This parameter is only supported for BINARY/SHIFT_OPERATORs").             }             return new MIC(name, type, initialDepth, flavor, flags).         default:             throw new BootstrapMethodError("Illegal static bootstrap parameter for flavor: " + flavor).     } }
