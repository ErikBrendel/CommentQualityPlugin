commented;modifiers;parameterAmount;loc;comment;code
true;public,static;9;45;/**  * Generates a lambda class for a lambda function/method reference  * within a Painless script.  Variables with the prefix interface are considered  * to represent values for code generated for the lambda class. Variables with  * the prefix delegate are considered to represent values for code generated  * within the Painless script.  The interface method delegates (calls) to the  * delegate method.  * @param lookup Standard {@link MethodHandles#lookup}  * @param interfaceMethodName Name of functional interface method that is called  * @param factoryMethodType The type of method to be linked to this CallSite. note that  *                          captured types are based on the parameters for this method  * @param interfaceMethodType The type of method representing the functional interface method  * @param delegateClassName The name of the class to delegate method call to  * @param delegateInvokeType The type of method call to be made  *                           (static, virtual, interface, or constructor)  * @param delegateMethodName The name of the method to be called in the Painless script class  * @param delegateMethodType The type of method call in the Painless script class without  *                           the captured types  * @param isDelegateInterface If the method to be called is owned by an interface where  *                            if the value is '1' if the delegate is an interface and '0'  *                            otherwise. note this is an int because the bootstrap method  *                            cannot convert constants to boolean  * @return A {@link CallSite} linked to a factory method for creating a lambda class  * that implements the expected functional interface  * @throws LambdaConversionException Thrown when an illegal type conversion occurs at link time  */ ;/**  * Generates a lambda class for a lambda function/method reference  * within a Painless script.  Variables with the prefix interface are considered  * to represent values for code generated for the lambda class. Variables with  * the prefix delegate are considered to represent values for code generated  * within the Painless script.  The interface method delegates (calls) to the  * delegate method.  * @param lookup Standard {@link MethodHandles#lookup}  * @param interfaceMethodName Name of functional interface method that is called  * @param factoryMethodType The type of method to be linked to this CallSite. note that  *                          captured types are based on the parameters for this method  * @param interfaceMethodType The type of method representing the functional interface method  * @param delegateClassName The name of the class to delegate method call to  * @param delegateInvokeType The type of method call to be made  *                           (static, virtual, interface, or constructor)  * @param delegateMethodName The name of the method to be called in the Painless script class  * @param delegateMethodType The type of method call in the Painless script class without  *                           the captured types  * @param isDelegateInterface If the method to be called is owned by an interface where  *                            if the value is '1' if the delegate is an interface and '0'  *                            otherwise. note this is an int because the bootstrap method  *                            cannot convert constants to boolean  * @return A {@link CallSite} linked to a factory method for creating a lambda class  * that implements the expected functional interface  * @throws LambdaConversionException Thrown when an illegal type conversion occurs at link time  */ public static CallSite lambdaBootstrap(Lookup lookup, String interfaceMethodName, MethodType factoryMethodType, MethodType interfaceMethodType, String delegateClassName, int delegateInvokeType, String delegateMethodName, MethodType delegateMethodType, int isDelegateInterface) throws LambdaConversionException {     Compiler.Loader loader = (Compiler.Loader) lookup.lookupClass().getClassLoader().     String lambdaClassName = Type.getInternalName(lookup.lookupClass()) + "$$Lambda" + loader.newLambdaIdentifier().     Type lambdaClassType = Type.getObjectType(lambdaClassName).     Type delegateClassType = Type.getObjectType(delegateClassName.replace('.', '/')).     validateTypes(interfaceMethodType, delegateMethodType).     ClassWriter cw = beginLambdaClass(lambdaClassName, factoryMethodType.returnType()).     Capture[] captures = generateCaptureFields(cw, factoryMethodType).     generateLambdaConstructor(cw, lambdaClassType, factoryMethodType, captures).     // Handles the special case where a method reference refers to a ctor (we need a static wrapper method):     if (delegateInvokeType == H_NEWINVOKESPECIAL) {         assert CTOR_METHOD_NAME.equals(delegateMethodName).         generateStaticCtorDelegator(cw, ACC_PRIVATE, DELEGATED_CTOR_WRAPPER_NAME, delegateClassType, delegateMethodType).         // replace the delegate with our static wrapper:         delegateMethodName = DELEGATED_CTOR_WRAPPER_NAME.         delegateClassType = lambdaClassType.         delegateInvokeType = H_INVOKESTATIC.     }     generateInterfaceMethod(cw, factoryMethodType, lambdaClassType, interfaceMethodName, interfaceMethodType, delegateClassType, delegateInvokeType, delegateMethodName, delegateMethodType, isDelegateInterface == 1, captures).     endLambdaClass(cw).     Class<?> lambdaClass = createLambdaClass(loader, cw, lambdaClassType).     if (captures.length > 0) {         return createCaptureCallSite(lookup, factoryMethodType, lambdaClass).     } else {         return createNoCaptureCallSite(factoryMethodType, lambdaClass).     } }
true;private,static;2;9;/**  * Validates some conversions at link time.  Currently, only ensures that the lambda method  * with a return value cannot delegate to a delegate method with no return type.  */ ;/**  * Validates some conversions at link time.  Currently, only ensures that the lambda method  * with a return value cannot delegate to a delegate method with no return type.  */ private static void validateTypes(MethodType interfaceMethodType, MethodType delegateMethodType) throws LambdaConversionException {     if (interfaceMethodType.returnType() != void.class && delegateMethodType.returnType() == void.class) {         throw new LambdaConversionException("lambda expects return type [" + interfaceMethodType.returnType() + "], but found return type [void]").     } }
true;private,static;2;10;/**  * Creates the {@link ClassWriter} to be used for the lambda class generation.  */ ;/**  * Creates the {@link ClassWriter} to be used for the lambda class generation.  */ private static ClassWriter beginLambdaClass(String lambdaClassName, Class<?> lambdaInterface) {     String baseClass = Type.getInternalName(Object.class).     int modifiers = ACC_PUBLIC | ACC_SUPER | ACC_FINAL | ACC_SYNTHETIC.     ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS).     cw.visit(CLASS_VERSION, modifiers, lambdaClassName, null, baseClass, new String[] { Type.getInternalName(lambdaInterface) }).     return cw. }
true;private,static;2;16;/**  * Generates member fields for captured variables  * based on the parameters for the factory method.  * @return An array of captured variable metadata  * for generating method arguments later on  */ ;/**  * Generates member fields for captured variables  * based on the parameters for the factory method.  * @return An array of captured variable metadata  * for generating method arguments later on  */ private static Capture[] generateCaptureFields(ClassWriter cw, MethodType factoryMethodType) {     int captureTotal = factoryMethodType.parameterCount().     Capture[] captures = new Capture[captureTotal].     for (int captureCount = 0. captureCount < captureTotal. ++captureCount) {         captures[captureCount] = new Capture(captureCount, factoryMethodType.parameterType(captureCount)).         int modifiers = ACC_PRIVATE | ACC_FINAL.         FieldVisitor fv = cw.visitField(modifiers, captures[captureCount].name, captures[captureCount].desc, null, null).         fv.visitEnd().     }     return captures. }
true;private,static;4;40;/**  * Generates a constructor that will take in captured  * arguments if any and store them in their respective  * member fields.  */ ;/**  * Generates a constructor that will take in captured  * arguments if any and store them in their respective  * member fields.  */ private static void generateLambdaConstructor(ClassWriter cw, Type lambdaClassType, MethodType factoryMethodType, Capture[] captures) {     String conDesc = factoryMethodType.changeReturnType(void.class).toMethodDescriptorString().     Method conMeth = new Method(CTOR_METHOD_NAME, conDesc).     Type baseConType = Type.getType(Object.class).     Method baseConMeth = new Method(CTOR_METHOD_NAME, MethodType.methodType(void.class).toMethodDescriptorString()).     int modifiers = (captures.length > 0) ? ACC_PRIVATE : ACC_PUBLIC.     GeneratorAdapter constructor = new GeneratorAdapter(modifiers, conMeth, cw.visitMethod(modifiers, CTOR_METHOD_NAME, conDesc, null, null)).     constructor.visitCode().     constructor.loadThis().     constructor.invokeConstructor(baseConType, baseConMeth).     for (int captureCount = 0. captureCount < captures.length. ++captureCount) {         constructor.loadThis().         constructor.loadArg(captureCount).         constructor.putField(lambdaClassType, captures[captureCount].name, captures[captureCount].type).     }     constructor.returnValue().     constructor.endMethod().     // an instance, so it can omit object creation on heap!     if (captures.length > 0) {         generateStaticCtorDelegator(cw, ACC_PUBLIC, LAMBDA_FACTORY_METHOD_NAME, lambdaClassType, factoryMethodType).     } }
true;private,static;5;17;/**  * Generates a factory method to delegate to constructors.  */ ;/**  * Generates a factory method to delegate to constructors.  */ private static void generateStaticCtorDelegator(ClassWriter cw, int access, String delegatorMethodName, Type delegateClassType, MethodType delegateMethodType) {     Method wrapperMethod = new Method(delegatorMethodName, delegateMethodType.toMethodDescriptorString()).     Method constructorMethod = new Method(CTOR_METHOD_NAME, delegateMethodType.changeReturnType(void.class).toMethodDescriptorString()).     int modifiers = access | ACC_STATIC.     GeneratorAdapter factory = new GeneratorAdapter(modifiers, wrapperMethod, cw.visitMethod(modifiers, delegatorMethodName, delegateMethodType.toMethodDescriptorString(), null, null)).     factory.visitCode().     factory.newInstance(delegateClassType).     factory.dup().     factory.loadArgs().     factory.invokeConstructor(delegateClassType, constructorMethod).     factory.returnValue().     factory.endMethod(). }
true;private,static;11;84;/**  * Generates the interface method that will delegate (call) to the delegate method  * with {@code INVOKEDYNAMIC} using the {@link #delegateBootstrap} type converter.  */ ;/**  * Generates the interface method that will delegate (call) to the delegate method  * with {@code INVOKEDYNAMIC} using the {@link #delegateBootstrap} type converter.  */ private static void generateInterfaceMethod(ClassWriter cw, MethodType factoryMethodType, Type lambdaClassType, String interfaceMethodName, MethodType interfaceMethodType, Type delegateClassType, int delegateInvokeType, String delegateMethodName, MethodType delegateMethodType, boolean isDelegateInterface, Capture[] captures) throws LambdaConversionException {     String lamDesc = interfaceMethodType.toMethodDescriptorString().     Method lamMeth = new Method(lambdaClassType.getInternalName(), lamDesc).     int modifiers = ACC_PUBLIC.     GeneratorAdapter iface = new GeneratorAdapter(modifiers, lamMeth, cw.visitMethod(modifiers, interfaceMethodName, lamDesc, null, null)).     iface.visitCode().     // Loads any captured variables onto the stack.     for (int captureCount = 0. captureCount < captures.length. ++captureCount) {         iface.loadThis().         iface.getField(lambdaClassType, captures[captureCount].name, captures[captureCount].type).     }     // Loads any passed in arguments onto the stack.     iface.loadArgs().     // Example: something.each(x -> x + 1)     if (delegateInvokeType == H_INVOKESTATIC) {         interfaceMethodType = interfaceMethodType.insertParameterTypes(0, factoryMethodType.parameterArray()).         delegateMethodType = delegateMethodType.insertParameterTypes(0, factoryMethodType.parameterArray()).     } else if (delegateInvokeType == H_INVOKEVIRTUAL || delegateInvokeType == H_INVOKEINTERFACE) {         // Example: Object::toString         if (captures.length == 0) {             Class<?> clazz = delegateMethodType.parameterType(0).             delegateClassType = Type.getType(clazz).             delegateMethodType = delegateMethodType.dropParameterTypes(0, 1).         // Handles the case for a virtual or interface reference method with 'this'         // captured. interfaceMethodType inserts the 'this' type into its         // method signature. This later allows the delegate         // method to be invoked dynamically and have the interface method types         // appropriately converted to the delegate method types.         // Example: something::toString         } else if (captures.length == 1) {             Class<?> clazz = factoryMethodType.parameterType(0).             delegateClassType = Type.getType(clazz).             interfaceMethodType = interfaceMethodType.insertParameterTypes(0, clazz).         } else {             throw new LambdaConversionException("unexpected number of captures [ " + captures.length + "]").         }     } else {         throw new IllegalStateException("unexpected invocation type [" + delegateInvokeType + "]").     }     Handle delegateHandle = new Handle(delegateInvokeType, delegateClassType.getInternalName(), delegateMethodName, delegateMethodType.toMethodDescriptorString(), isDelegateInterface).     iface.invokeDynamic(delegateMethodName, Type.getMethodType(interfaceMethodType.toMethodDescriptorString()).getDescriptor(), DELEGATE_BOOTSTRAP_HANDLE, delegateHandle).     iface.returnValue().     iface.endMethod(). }
true;private,static;1;3;/**  * Closes the {@link ClassWriter}.  */ ;/**  * Closes the {@link ClassWriter}.  */ private static void endLambdaClass(ClassWriter cw) {     cw.visitEnd(). }
true;private,static;3;11;/**  * Defines the {@link Class} for the lambda class using the same {@link Compiler.Loader}  * that originally defined the class for the Painless script.  */ ;/**  * Defines the {@link Class} for the lambda class using the same {@link Compiler.Loader}  * that originally defined the class for the Painless script.  */ private static Class<?> createLambdaClass(Compiler.Loader loader, ClassWriter cw, Type lambdaClassType) {     byte[] classBytes = cw.toByteArray().     // new ClassReader(classBytes).accept(new TraceClassVisitor(new PrintWriter(System.out)), ClassReader.SKIP_DEBUG).     return AccessController.doPrivileged((PrivilegedAction<Class<?>>) () -> loader.defineLambda(lambdaClassType.getClassName(), classBytes)). }
true;private,static;2;11;/**  * Creates an {@link ConstantCallSite} that will return the same instance  * of the generated lambda class every time this linked factory method is called.  */ ;/**  * Creates an {@link ConstantCallSite} that will return the same instance  * of the generated lambda class every time this linked factory method is called.  */ private static CallSite createNoCaptureCallSite(MethodType factoryMethodType, Class<?> lambdaClass) {     try {         return new ConstantCallSite(MethodHandles.constant(factoryMethodType.returnType(), lambdaClass.getConstructor().newInstance())).     } catch (ReflectiveOperationException exception) {         throw new IllegalStateException("unable to instantiate lambda class", exception).     } }
true;private,static;3;12;/**  * Creates an {@link ConstantCallSite}  */ ;/**  * Creates an {@link ConstantCallSite}  */ private static CallSite createCaptureCallSite(Lookup lookup, MethodType factoryMethodType, Class<?> lambdaClass) {     try {         return new ConstantCallSite(lookup.findStatic(lambdaClass, LAMBDA_FACTORY_METHOD_NAME, factoryMethodType)).     } catch (ReflectiveOperationException exception) {         throw new IllegalStateException("unable to create lambda class", exception).     } }
true;public,static;4;6;/**  * Links the delegate method to the returned {@link CallSite}.  The linked  * delegate method will use converted types from the interface method.  Using  * invokedynamic to make the delegate method call allows  * {@link MethodHandle#asType} to be used to do the type conversion instead  * of either a lot more code or requiring many {@link Class}es to be looked  * up at link-time.  */ ;/**  * Links the delegate method to the returned {@link CallSite}.  The linked  * delegate method will use converted types from the interface method.  Using  * invokedynamic to make the delegate method call allows  * {@link MethodHandle#asType} to be used to do the type conversion instead  * of either a lot more code or requiring many {@link Class}es to be looked  * up at link-time.  */ public static CallSite delegateBootstrap(Lookup lookup, String delegateMethodName, MethodType interfaceMethodType, MethodHandle delegateMethodHandle) {     return new ConstantCallSite(delegateMethodHandle.asType(interfaceMethodType)). }
