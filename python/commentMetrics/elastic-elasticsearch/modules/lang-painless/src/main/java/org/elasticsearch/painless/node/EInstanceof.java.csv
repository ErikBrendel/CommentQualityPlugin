commented;modifiers;parameterAmount;loc;comment;code
false;;1;4;;@Override void extractVariables(Set<String> variables) {     expression.extractVariables(variables). }
false;;1;27;;@Override void analyze(Locals locals) {     // ensure the specified type is part of the definition     Class<?> clazz = locals.getPainlessLookup().canonicalTypeNameToType(this.type).     if (clazz == null) {         throw createError(new IllegalArgumentException("Not a type [" + this.type + "].")).     }     // map to wrapped type for primitive types     resolvedType = clazz.isPrimitive() ? PainlessLookupUtility.typeToBoxedType(clazz) : PainlessLookupUtility.typeToJavaType(clazz).     // analyze and cast the expression     expression.analyze(locals).     expression.expected = expression.actual.     expression = expression.cast(locals).     // record if the expression returns a primitive     primitiveExpression = expression.actual.isPrimitive().     // map to wrapped type for primitive types     expressionType = expression.actual.isPrimitive() ? PainlessLookupUtility.typeToBoxedType(expression.actual) : PainlessLookupUtility.typeToJavaType(clazz).     actual = boolean.class. }
false;;2;16;;@Override void write(MethodWriter writer, Globals globals) {     // primitive types     if (primitiveExpression) {         // run the expression anyway (who knows what it does)         expression.write(writer, globals).         // discard its result         writer.writePop(MethodWriter.getType(expression.actual).getSize()).         // push our result: its a primitive so it cannot be null.         writer.push(resolvedType.isAssignableFrom(expressionType)).     } else {         // ordinary instanceof         expression.write(writer, globals).         writer.instanceOf(org.objectweb.asm.Type.getType(resolvedType)).     } }
false;public;0;4;;@Override public String toString() {     return singleLineToString(expression, type). }
